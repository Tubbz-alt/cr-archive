<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/linux/osContainer_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_linux.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osContainer_linux.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/osContainer_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,623 ***</span>
   */
  
  #include &lt;string.h&gt;
  #include &lt;math.h&gt;
  #include &lt;errno.h&gt;
<span class="line-modified">! #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-removed">- #include &quot;memory/allocation.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;osContainer_linux.hpp&quot;
  
<span class="line-removed">- /*</span>
<span class="line-removed">-  * PER_CPU_SHARES has been set to 1024 because CPU shares&#39; quota</span>
<span class="line-removed">-  * is commonly used in cloud frameworks like Kubernetes[1],</span>
<span class="line-removed">-  * AWS[2] and Mesos[3] in a similar way. They spawn containers with</span>
<span class="line-removed">-  * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do</span>
<span class="line-removed">-  * the inverse for determining the number of possible available</span>
<span class="line-removed">-  * CPUs to the JVM inside a container. See JDK-8216366.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * [1] https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-cpu</span>
<span class="line-removed">-  *     In particular:</span>
<span class="line-removed">-  *        When using Docker:</span>
<span class="line-removed">-  *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially</span>
<span class="line-removed">-  *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the</span>
<span class="line-removed">-  *          --cpu-shares flag in the docker run command.</span>
<span class="line-removed">-  * [2] https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html</span>
<span class="line-removed">-  * [3] https://github.com/apache/mesos/blob/3478e344fb77d931f6122980c6e94cd3913c441d/src/docker/docker.cpp#L648</span>
<span class="line-removed">-  *     https://github.com/apache/mesos/blob/3478e344fb77d931f6122980c6e94cd3913c441d/src/slave/containerizer/mesos/isolators/cgroups/constants.hpp#L30</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- #define PER_CPU_SHARES 1024</span>
  
  bool  OSContainer::_is_initialized   = false;
  bool  OSContainer::_is_containerized = false;
<span class="line-modified">! julong _unlimited_memory;</span>
<span class="line-removed">- </span>
<span class="line-removed">- class CgroupSubsystem: CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed">-  friend class OSContainer;</span>
<span class="line-removed">- </span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-     /* mountinfo contents */</span>
<span class="line-removed">-     char *_root;</span>
<span class="line-removed">-     char *_mount_point;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Constructed subsystem directory */</span>
<span class="line-removed">-     char *_path;</span>
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-     CgroupSubsystem(char *root, char *mountpoint) {</span>
<span class="line-removed">-       _root = os::strdup(root);</span>
<span class="line-removed">-       _mount_point = os::strdup(mountpoint);</span>
<span class="line-removed">-       _path = NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Set directory to subsystem specific files based</span>
<span class="line-removed">-      * on the contents of the mountinfo and cgroup files.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void set_subsystem_path(char *cgroup_path) {</span>
<span class="line-removed">-       char buf[MAXPATHLEN+1];</span>
<span class="line-removed">-       if (_root != NULL &amp;&amp; cgroup_path != NULL) {</span>
<span class="line-removed">-         if (strcmp(_root, &quot;/&quot;) == 0) {</span>
<span class="line-removed">-           int buflen;</span>
<span class="line-removed">-           strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed">-           buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-           if (strcmp(cgroup_path,&quot;/&quot;) != 0) {</span>
<span class="line-removed">-             buflen = strlen(buf);</span>
<span class="line-removed">-             if ((buflen + strlen(cgroup_path)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed">-               return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             strncat(buf, cgroup_path, MAXPATHLEN-buflen);</span>
<span class="line-removed">-             buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           _path = os::strdup(buf);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           if (strcmp(_root, cgroup_path) == 0) {</span>
<span class="line-removed">-             strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed">-             buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-             _path = os::strdup(buf);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             char *p = strstr(_root, cgroup_path);</span>
<span class="line-removed">-             if (p != NULL &amp;&amp; p == _root) {</span>
<span class="line-removed">-               if (strlen(cgroup_path) &gt; strlen(_root)) {</span>
<span class="line-removed">-                 int buflen;</span>
<span class="line-removed">-                 strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed">-                 buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-                 buflen = strlen(buf);</span>
<span class="line-removed">-                 if ((buflen + strlen(cgroup_path)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed">-                   return;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);</span>
<span class="line-removed">-                 buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-                 _path = os::strdup(buf);</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     char *subsystem_path() { return _path; }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- CgroupSubsystem* memory = NULL;</span>
<span class="line-removed">- CgroupSubsystem* cpuset = NULL;</span>
<span class="line-removed">- CgroupSubsystem* cpu = NULL;</span>
<span class="line-removed">- CgroupSubsystem* cpuacct = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef char * cptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">- PRAGMA_DIAG_PUSH</span>
<span class="line-removed">- PRAGMA_FORMAT_NONLITERAL_IGNORED</span>
<span class="line-removed">- template &lt;typename T&gt; int subsystem_file_contents(CgroupSubsystem* c,</span>
<span class="line-removed">-                                               const char *filename,</span>
<span class="line-removed">-                                               const char *scan_fmt,</span>
<span class="line-removed">-                                               T returnval) {</span>
<span class="line-removed">-   FILE *fp = NULL;</span>
<span class="line-removed">-   char *p;</span>
<span class="line-removed">-   char file[MAXPATHLEN+1];</span>
<span class="line-removed">-   char buf[MAXPATHLEN+1];</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (c == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;subsystem_file_contents: CgroupSubsytem* is NULL&quot;);</span>
<span class="line-removed">-     return OSCONTAINER_ERROR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (c-&gt;subsystem_path() == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;subsystem_file_contents: subsystem path is NULL&quot;);</span>
<span class="line-removed">-     return OSCONTAINER_ERROR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   strncpy(file, c-&gt;subsystem_path(), MAXPATHLEN);</span>
<span class="line-removed">-   file[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">-   int filelen = strlen(file);</span>
<span class="line-removed">-   if ((filelen + strlen(filename)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;File path too long %s, %s&quot;, file, filename);</span>
<span class="line-removed">-     return OSCONTAINER_ERROR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   strncat(file, filename, MAXPATHLEN-filelen);</span>
<span class="line-removed">-   log_trace(os, container)(&quot;Path to %s is %s&quot;, filename, file);</span>
<span class="line-removed">-   fp = fopen(file, &quot;r&quot;);</span>
<span class="line-removed">-   if (fp != NULL) {</span>
<span class="line-removed">-     p = fgets(buf, MAXPATHLEN, fp);</span>
<span class="line-removed">-     if (p != NULL) {</span>
<span class="line-removed">-       int matched = sscanf(p, scan_fmt, returnval);</span>
<span class="line-removed">-       if (matched == 1) {</span>
<span class="line-removed">-         fclose(fp);</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         log_debug(os, container)(&quot;Type %s not found in file %s&quot;, scan_fmt, file);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       log_debug(os, container)(&quot;Empty file %s&quot;, file);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Open of file %s failed, %s&quot;, file, os::strerror(errno));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (fp != NULL)</span>
<span class="line-removed">-     fclose(fp);</span>
<span class="line-removed">-   return OSCONTAINER_ERROR;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- PRAGMA_DIAG_POP</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define GET_CONTAINER_INFO(return_type, subsystem, filename,              \</span>
<span class="line-removed">-                            logstring, scan_fmt, variable)                 \</span>
<span class="line-removed">-   return_type variable;                                                   \</span>
<span class="line-removed">- {                                                                         \</span>
<span class="line-removed">-   int err;                                                                \</span>
<span class="line-removed">-   err = subsystem_file_contents(subsystem,                                \</span>
<span class="line-removed">-                                 filename,                                 \</span>
<span class="line-removed">-                                 scan_fmt,                                 \</span>
<span class="line-removed">-                                 &amp;variable);                               \</span>
<span class="line-removed">-   if (err != 0)                                                           \</span>
<span class="line-removed">-     return (return_type) OSCONTAINER_ERROR;                               \</span>
<span class="line-removed">-                                                                           \</span>
<span class="line-removed">-   log_trace(os, container)(logstring, variable);                          \</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \</span>
<span class="line-removed">-                                logstring, scan_fmt, variable, bufsize)    \</span>
<span class="line-removed">-   char variable[bufsize];                                                 \</span>
<span class="line-removed">- {                                                                         \</span>
<span class="line-removed">-   int err;                                                                \</span>
<span class="line-removed">-   err = subsystem_file_contents(subsystem,                                \</span>
<span class="line-removed">-                                 filename,                                 \</span>
<span class="line-removed">-                                 scan_fmt,                                 \</span>
<span class="line-removed">-                                 variable);                                \</span>
<span class="line-removed">-   if (err != 0)                                                           \</span>
<span class="line-removed">-     return (return_type) NULL;                                            \</span>
<span class="line-removed">-                                                                           \</span>
<span class="line-removed">-   log_trace(os, container)(logstring, variable);                          \</span>
<span class="line-removed">- }</span>
  
  /* init
   *
   * Initialize the container support and determine if
   * we are running under cgroup control.
   */
  void OSContainer::init() {
<span class="line-removed">-   int mountid;</span>
<span class="line-removed">-   int parentid;</span>
<span class="line-removed">-   int major;</span>
<span class="line-removed">-   int minor;</span>
<span class="line-removed">-   FILE *mntinfo = NULL;</span>
<span class="line-removed">-   FILE *cgroup = NULL;</span>
<span class="line-removed">-   char buf[MAXPATHLEN+1];</span>
<span class="line-removed">-   char tmproot[MAXPATHLEN+1];</span>
<span class="line-removed">-   char tmpmount[MAXPATHLEN+1];</span>
<span class="line-removed">-   char tmpbase[MAXPATHLEN+1];</span>
<span class="line-removed">-   char *p;</span>
    jlong mem_limit;
  
    assert(!_is_initialized, &quot;Initializing OSContainer more than once&quot;);
  
    _is_initialized = true;
    _is_containerized = false;
  
<span class="line-removed">-   _unlimited_memory = (LONG_MAX / os::vm_page_size()) * os::vm_page_size();</span>
<span class="line-removed">- </span>
    log_trace(os, container)(&quot;OSContainer::init: Initializing Container Support&quot;);
    if (!UseContainerSupport) {
      log_trace(os, container)(&quot;Container Support not enabled&quot;);
      return;
    }
  
<span class="line-modified">!   /*</span>
<span class="line-modified">!    * Find the cgroup mount point for memory and cpuset</span>
<span class="line-modified">!    * by reading /proc/self/mountinfo</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * Example for docker:</span>
<span class="line-removed">-    * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * Example for host:</span>
<span class="line-removed">-    * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   mntinfo = fopen(&quot;/proc/self/mountinfo&quot;, &quot;r&quot;);</span>
<span class="line-removed">-   if (mntinfo == NULL) {</span>
<span class="line-removed">-       log_debug(os, container)(&quot;Can&#39;t open /proc/self/mountinfo, %s&quot;,</span>
<span class="line-removed">-                                os::strerror(errno));</span>
<span class="line-removed">-       return;</span>
    }
<span class="line-removed">- </span>
<span class="line-removed">-   while ( (p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {</span>
<span class="line-removed">-     // Look for the filesystem type and see if it&#39;s cgroup</span>
<span class="line-removed">-     char fstype[MAXPATHLEN+1];</span>
<span class="line-removed">-     fstype[0] = &#39;\0&#39;;</span>
<span class="line-removed">-     char *s =  strstr(p, &quot; - &quot;);</span>
<span class="line-removed">-     if (s != NULL &amp;&amp;</span>
<span class="line-removed">-         sscanf(s, &quot; - %s&quot;, fstype) == 1 &amp;&amp;</span>
<span class="line-removed">-         strcmp(fstype, &quot;cgroup&quot;) == 0) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (strstr(p, &quot;memory&quot;) != NULL) {</span>
<span class="line-removed">-         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">-                              &amp;mountid,</span>
<span class="line-removed">-                              &amp;parentid,</span>
<span class="line-removed">-                              &amp;major,</span>
<span class="line-removed">-                              &amp;minor,</span>
<span class="line-removed">-                              tmproot,</span>
<span class="line-removed">-                              tmpmount);</span>
<span class="line-removed">-         if (matched == 6) {</span>
<span class="line-removed">-           memory = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-           log_debug(os, container)(&quot;Incompatible str containing cgroup and memory: %s&quot;, p);</span>
<span class="line-removed">-       } else if (strstr(p, &quot;cpuset&quot;) != NULL) {</span>
<span class="line-removed">-         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">-                              &amp;mountid,</span>
<span class="line-removed">-                              &amp;parentid,</span>
<span class="line-removed">-                              &amp;major,</span>
<span class="line-removed">-                              &amp;minor,</span>
<span class="line-removed">-                              tmproot,</span>
<span class="line-removed">-                              tmpmount);</span>
<span class="line-removed">-         if (matched == 6) {</span>
<span class="line-removed">-           cpuset = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpuset: %s&quot;, p);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else if (strstr(p, &quot;cpu,cpuacct&quot;) != NULL || strstr(p, &quot;cpuacct,cpu&quot;) != NULL) {</span>
<span class="line-removed">-         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">-                              &amp;mountid,</span>
<span class="line-removed">-                              &amp;parentid,</span>
<span class="line-removed">-                              &amp;major,</span>
<span class="line-removed">-                              &amp;minor,</span>
<span class="line-removed">-                              tmproot,</span>
<span class="line-removed">-                              tmpmount);</span>
<span class="line-removed">-         if (matched == 6) {</span>
<span class="line-removed">-           cpu = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-           cpuacct = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpu,cpuacct: %s&quot;, p);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else if (strstr(p, &quot;cpuacct&quot;) != NULL) {</span>
<span class="line-removed">-         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">-                              &amp;mountid,</span>
<span class="line-removed">-                              &amp;parentid,</span>
<span class="line-removed">-                              &amp;major,</span>
<span class="line-removed">-                              &amp;minor,</span>
<span class="line-removed">-                              tmproot,</span>
<span class="line-removed">-                              tmpmount);</span>
<span class="line-removed">-         if (matched == 6) {</span>
<span class="line-removed">-           cpuacct = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpuacct: %s&quot;, p);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else if (strstr(p, &quot;cpu&quot;) != NULL) {</span>
<span class="line-removed">-         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">-                              &amp;mountid,</span>
<span class="line-removed">-                              &amp;parentid,</span>
<span class="line-removed">-                              &amp;major,</span>
<span class="line-removed">-                              &amp;minor,</span>
<span class="line-removed">-                              tmproot,</span>
<span class="line-removed">-                              tmpmount);</span>
<span class="line-removed">-         if (matched == 6) {</span>
<span class="line-removed">-           cpu = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpu: %s&quot;, p);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   fclose(mntinfo);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (memory == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Required cgroup memory subsystem not found&quot;);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (cpuset == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Required cgroup cpuset subsystem not found&quot;);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (cpu == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Required cgroup cpu subsystem not found&quot;);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (cpuacct == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Required cgroup cpuacct subsystem not found&quot;);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /*</span>
<span class="line-removed">-    * Read /proc/self/cgroup and map host mount point to</span>
<span class="line-removed">-    * local one via /proc/self/mountinfo content above</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * Docker example:</span>
<span class="line-removed">-    * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * Host example:</span>
<span class="line-removed">-    * 5:memory:/user.slice</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * Construct a path to the process specific memory and cpuset</span>
<span class="line-removed">-    * cgroup directory.</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * For a container running under Docker from memory example above</span>
<span class="line-removed">-    * the paths would be:</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * /sys/fs/cgroup/memory</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * For a Host from memory example above the path would be:</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * /sys/fs/cgroup/memory/user.slice</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   cgroup = fopen(&quot;/proc/self/cgroup&quot;, &quot;r&quot;);</span>
<span class="line-removed">-   if (cgroup == NULL) {</span>
<span class="line-removed">-     log_debug(os, container)(&quot;Can&#39;t open /proc/self/cgroup, %s&quot;,</span>
<span class="line-removed">-                              os::strerror(errno));</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   while ( (p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {</span>
<span class="line-removed">-     int cgno;</span>
<span class="line-removed">-     int matched;</span>
<span class="line-removed">-     char *controller;</span>
<span class="line-removed">-     char *base;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Skip cgroup number */</span>
<span class="line-removed">-     strsep(&amp;p, &quot;:&quot;);</span>
<span class="line-removed">-     /* Get controller and base */</span>
<span class="line-removed">-     controller = strsep(&amp;p, &quot;:&quot;);</span>
<span class="line-removed">-     base = strsep(&amp;p, &quot;\n&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (controller != NULL) {</span>
<span class="line-removed">-       if (strstr(controller, &quot;memory&quot;) != NULL) {</span>
<span class="line-removed">-         memory-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-       } else if (strstr(controller, &quot;cpuset&quot;) != NULL) {</span>
<span class="line-removed">-         cpuset-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-       } else if (strstr(controller, &quot;cpu,cpuacct&quot;) != NULL || strstr(controller, &quot;cpuacct,cpu&quot;) != NULL) {</span>
<span class="line-removed">-         cpu-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-         cpuacct-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-       } else if (strstr(controller, &quot;cpuacct&quot;) != NULL) {</span>
<span class="line-removed">-         cpuacct-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-       } else if (strstr(controller, &quot;cpu&quot;) != NULL) {</span>
<span class="line-removed">-         cpu-&gt;set_subsystem_path(base);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   fclose(cgroup);</span>
<span class="line-removed">- </span>
    // We need to update the amount of physical memory now that
<span class="line-modified">!   // command line arguments have been processed.</span>
<span class="line-modified">!   if ((mem_limit = memory_limit_in_bytes()) &gt; 0) {</span>
      os::Linux::set_physical_memory(mem_limit);
    }
  
    _is_containerized = true;
  
  }
  
  const char * OSContainer::container_type() {
<span class="line-modified">!   if (is_containerized()) {</span>
<span class="line-modified">!     return &quot;cgroupv1&quot;;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- /* memory_limit_in_bytes</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return the limit of available memory for this process.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    memory limit in bytes or</span>
<span class="line-removed">-  *    -1 for unlimited</span>
<span class="line-removed">-  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">-  */</span>
  jlong OSContainer::memory_limit_in_bytes() {
<span class="line-modified">!   GET_CONTAINER_INFO(julong, memory, &quot;/memory.limit_in_bytes&quot;,</span>
<span class="line-modified">!                      &quot;Memory Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memlimit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (memlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">-     log_trace(os, container)(&quot;Memory Limit is: Unlimited&quot;);</span>
<span class="line-removed">-     return (jlong)-1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     return (jlong)memlimit;</span>
<span class="line-removed">-   }</span>
  }
  
  jlong OSContainer::memory_and_swap_limit_in_bytes() {
<span class="line-modified">!   GET_CONTAINER_INFO(julong, memory, &quot;/memory.memsw.limit_in_bytes&quot;,</span>
<span class="line-modified">!                      &quot;Memory and Swap Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memswlimit);</span>
<span class="line-removed">-   if (memswlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">-     log_trace(os, container)(&quot;Memory and Swap Limit is: Unlimited&quot;);</span>
<span class="line-removed">-     return (jlong)-1;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return (jlong)memswlimit;</span>
<span class="line-removed">-   }</span>
  }
  
  jlong OSContainer::memory_soft_limit_in_bytes() {
<span class="line-modified">!   GET_CONTAINER_INFO(julong, memory, &quot;/memory.soft_limit_in_bytes&quot;,</span>
<span class="line-modified">!                      &quot;Memory Soft Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);</span>
<span class="line-removed">-   if (memsoftlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">-     log_trace(os, container)(&quot;Memory Soft Limit is: Unlimited&quot;);</span>
<span class="line-removed">-     return (jlong)-1;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return (jlong)memsoftlimit;</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- /* memory_usage_in_bytes</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return the amount of used memory for this process.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    memory usage in bytes or</span>
<span class="line-removed">-  *    -1 for unlimited</span>
<span class="line-removed">-  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">-  */</span>
  jlong OSContainer::memory_usage_in_bytes() {
<span class="line-modified">!   GET_CONTAINER_INFO(jlong, memory, &quot;/memory.usage_in_bytes&quot;,</span>
<span class="line-modified">!                      &quot;Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memusage);</span>
<span class="line-removed">-   return memusage;</span>
  }
  
<span class="line-removed">- /* memory_max_usage_in_bytes</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return the maximum amount of used memory for this process.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    max memory usage in bytes or</span>
<span class="line-removed">-  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">-  */</span>
  jlong OSContainer::memory_max_usage_in_bytes() {
<span class="line-modified">!   GET_CONTAINER_INFO(jlong, memory, &quot;/memory.max_usage_in_bytes&quot;,</span>
<span class="line-modified">!                      &quot;Maximum Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memmaxusage);</span>
<span class="line-removed">-   return memmaxusage;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* active_processor_count</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Calculate an appropriate number of active processors for the</span>
<span class="line-removed">-  * VM to use based on these three inputs.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * cpu affinity</span>
<span class="line-removed">-  * cgroup cpu quota &amp; cpu period</span>
<span class="line-removed">-  * cgroup cpu shares</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Algorithm:</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Determine the number of available CPUs from sched_getaffinity</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * If user specified a quota (quota != -1), calculate the number of</span>
<span class="line-removed">-  * required CPUs by dividing quota by period.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * If shares are in effect (shares != -1), calculate the number</span>
<span class="line-removed">-  * of CPUs required for the shares by dividing the share value</span>
<span class="line-removed">-  * by PER_CPU_SHARES.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * All results of division are rounded up to the next whole number.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * If neither shares or quotas have been specified, return the</span>
<span class="line-removed">-  * number of active processors in the system.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * If both shares and quotas have been specified, the results are</span>
<span class="line-removed">-  * based on the flag PreferContainerQuotaForCPUCount.  If true,</span>
<span class="line-removed">-  * return the quota value.  If false return the smallest value</span>
<span class="line-removed">-  * between shares or quotas.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * If shares and/or quotas have been specified, the resulting number</span>
<span class="line-removed">-  * returned will never exceed the number of active processors.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    number of CPUs</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- int OSContainer::active_processor_count() {</span>
<span class="line-removed">-   int quota_count = 0, share_count = 0;</span>
<span class="line-removed">-   int cpu_count, limit_count;</span>
<span class="line-removed">-   int result;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   cpu_count = limit_count = os::Linux::active_processor_count();</span>
<span class="line-removed">-   int quota  = cpu_quota();</span>
<span class="line-removed">-   int period = cpu_period();</span>
<span class="line-removed">-   int share  = cpu_shares();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (quota &gt; -1 &amp;&amp; period &gt; 0) {</span>
<span class="line-removed">-     quota_count = ceilf((float)quota / (float)period);</span>
<span class="line-removed">-     log_trace(os, container)(&quot;CPU Quota count based on quota/period: %d&quot;, quota_count);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (share &gt; -1) {</span>
<span class="line-removed">-     share_count = ceilf((float)share / (float)PER_CPU_SHARES);</span>
<span class="line-removed">-     log_trace(os, container)(&quot;CPU Share count based on shares: %d&quot;, share_count);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // If both shares and quotas are setup results depend</span>
<span class="line-removed">-   // on flag PreferContainerQuotaForCPUCount.</span>
<span class="line-removed">-   // If true, limit CPU count to quota</span>
<span class="line-removed">-   // If false, use minimum of shares and quotas</span>
<span class="line-removed">-   if (quota_count !=0 &amp;&amp; share_count != 0) {</span>
<span class="line-removed">-     if (PreferContainerQuotaForCPUCount) {</span>
<span class="line-removed">-       limit_count = quota_count;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       limit_count = MIN2(quota_count, share_count);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else if (quota_count != 0) {</span>
<span class="line-removed">-     limit_count = quota_count;</span>
<span class="line-removed">-   } else if (share_count != 0) {</span>
<span class="line-removed">-     limit_count = share_count;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   result = MIN2(cpu_count, limit_count);</span>
<span class="line-removed">-   log_trace(os, container)(&quot;OSContainer::active_processor_count: %d&quot;, result);</span>
<span class="line-removed">-   return result;</span>
  }
  
  char * OSContainer::cpu_cpuset_cpus() {
<span class="line-modified">!   GET_CONTAINER_INFO_CPTR(cptr, cpuset, &quot;/cpuset.cpus&quot;,</span>
<span class="line-modified">!                      &quot;cpuset.cpus is: %s&quot;, &quot;%1023s&quot;, cpus, 1024);</span>
<span class="line-removed">-   return os::strdup(cpus);</span>
  }
  
  char * OSContainer::cpu_cpuset_memory_nodes() {
<span class="line-modified">!   GET_CONTAINER_INFO_CPTR(cptr, cpuset, &quot;/cpuset.mems&quot;,</span>
<span class="line-modified">!                      &quot;cpuset.mems is: %s&quot;, &quot;%1023s&quot;, mems, 1024);</span>
<span class="line-modified">!   return os::strdup(mems);</span>
  }
  
<span class="line-removed">- /* cpu_quota</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return the number of milliseconds per period</span>
<span class="line-removed">-  * process is guaranteed to run.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    quota time in milliseconds</span>
<span class="line-removed">-  *    -1 for no quota</span>
<span class="line-removed">-  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">-  */</span>
  int OSContainer::cpu_quota() {
<span class="line-modified">!   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.cfs_quota_us&quot;,</span>
<span class="line-modified">!                      &quot;CPU Quota is: %d&quot;, &quot;%d&quot;, quota);</span>
<span class="line-removed">-   return quota;</span>
  }
  
  int OSContainer::cpu_period() {
<span class="line-modified">!   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.cfs_period_us&quot;,</span>
<span class="line-modified">!                      &quot;CPU Period is: %d&quot;, &quot;%d&quot;, period);</span>
<span class="line-removed">-   return period;</span>
  }
  
<span class="line-removed">- /* cpu_shares</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return the amount of cpu shares available to the process</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * return:</span>
<span class="line-removed">-  *    Share number (typically a number relative to 1024)</span>
<span class="line-removed">-  *                 (2048 typically expresses 2 CPUs worth of processing)</span>
<span class="line-removed">-  *    -1 for no share setup</span>
<span class="line-removed">-  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">-  */</span>
  int OSContainer::cpu_shares() {
<span class="line-modified">!   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.shares&quot;,</span>
<span class="line-modified">!                      &quot;CPU Shares is: %d&quot;, &quot;%d&quot;, shares);</span>
<span class="line-removed">-   // Convert 1024 to no shares setup</span>
<span class="line-removed">-   if (shares == 1024) return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return shares;</span>
  }
<span class="line-removed">- </span>
<span class="line-new-header">--- 23,109 ---</span>
   */
  
  #include &lt;string.h&gt;
  #include &lt;math.h&gt;
  #include &lt;errno.h&gt;
<span class="line-modified">! #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;osContainer_linux.hpp&quot;
<span class="line-added">+ #include &quot;cgroupSubsystem_linux.hpp&quot;</span>
  
  
  bool  OSContainer::_is_initialized   = false;
  bool  OSContainer::_is_containerized = false;
<span class="line-modified">! CgroupSubsystem* cgroup_subsystem;</span>
  
  /* init
   *
   * Initialize the container support and determine if
   * we are running under cgroup control.
   */
  void OSContainer::init() {
    jlong mem_limit;
  
    assert(!_is_initialized, &quot;Initializing OSContainer more than once&quot;);
  
    _is_initialized = true;
    _is_containerized = false;
  
    log_trace(os, container)(&quot;OSContainer::init: Initializing Container Support&quot;);
    if (!UseContainerSupport) {
      log_trace(os, container)(&quot;Container Support not enabled&quot;);
      return;
    }
  
<span class="line-modified">!   cgroup_subsystem = CgroupSubsystemFactory::create();</span>
<span class="line-modified">!   if (cgroup_subsystem == NULL) {</span>
<span class="line-modified">!     return; // Required subsystem files not found or other error</span>
    }
    // We need to update the amount of physical memory now that
<span class="line-modified">!   // cgroup subsystem files have been processed.</span>
<span class="line-modified">!   if ((mem_limit = cgroup_subsystem-&gt;memory_limit_in_bytes()) &gt; 0) {</span>
      os::Linux::set_physical_memory(mem_limit);
<span class="line-added">+     log_info(os, container)(&quot;Memory Limit is: &quot; JLONG_FORMAT, mem_limit);</span>
    }
  
    _is_containerized = true;
  
  }
  
  const char * OSContainer::container_type() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;container_type();</span>
  }
  
  jlong OSContainer::memory_limit_in_bytes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;memory_limit_in_bytes();</span>
  }
  
  jlong OSContainer::memory_and_swap_limit_in_bytes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;memory_and_swap_limit_in_bytes();</span>
  }
  
  jlong OSContainer::memory_soft_limit_in_bytes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;memory_soft_limit_in_bytes();</span>
  }
  
  jlong OSContainer::memory_usage_in_bytes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;memory_usage_in_bytes();</span>
  }
  
  jlong OSContainer::memory_max_usage_in_bytes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;memory_max_usage_in_bytes();</span>
  }
  
  char * OSContainer::cpu_cpuset_cpus() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;cpu_cpuset_cpus();</span>
  }
  
  char * OSContainer::cpu_cpuset_memory_nodes() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;cpu_cpuset_memory_nodes();</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int OSContainer::active_processor_count() {</span>
<span class="line-added">+   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-added">+   return cgroup_subsystem-&gt;active_processor_count();</span>
  }
  
  int OSContainer::cpu_quota() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;cpu_quota();</span>
  }
  
  int OSContainer::cpu_period() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;cpu_period();</span>
  }
  
  int OSContainer::cpu_shares() {
<span class="line-modified">!   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">!   return cgroup_subsystem-&gt;cpu_shares();</span>
  }
</pre>
<center><a href="globals_linux.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osContainer_linux.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
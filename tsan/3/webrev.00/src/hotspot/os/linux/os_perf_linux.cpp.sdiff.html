<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_perf_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_perf_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_linux.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;

  31 
  32 #include CPU_HEADER(vm_version_ext)
  33 
  34 #include &lt;stdio.h&gt;
  35 #include &lt;stdarg.h&gt;
  36 #include &lt;unistd.h&gt;
  37 #include &lt;errno.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;sys/resource.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #include &lt;dirent.h&gt;
  43 #include &lt;stdlib.h&gt;
  44 #include &lt;dlfcn.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;limits.h&gt;
  47 #include &lt;ifaddrs.h&gt;
  48 #include &lt;fcntl.h&gt;
  49 
  50 /**
</pre>
<hr />
<pre>
 189  *   params is the parameter number where the actual args to
 190  *       the format starts. If the args are in a va_list, this
 191  *       should be 0.
 192  */
 193 #ifndef PRINTF_ARGS
 194 #  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)
 195 #endif
 196 
 197 #ifndef SCANF_ARGS
 198 #  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)
 199 #endif
 200 
 201 #ifndef _PRINTFMT_
 202 #  define _PRINTFMT_
 203 #endif
 204 
 205 #ifndef _SCANFMT_
 206 #  define _SCANFMT_
 207 #endif
 208 
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210 struct CPUPerfTicks {</span>
<span class="line-removed"> 211   uint64_t  used;</span>
<span class="line-removed"> 212   uint64_t  usedKernel;</span>
<span class="line-removed"> 213   uint64_t  total;</span>
<span class="line-removed"> 214 };</span>
<span class="line-removed"> 215 </span>
 216 typedef enum {
 217   CPU_LOAD_VM_ONLY,
 218   CPU_LOAD_GLOBAL,
 219 } CpuLoadTarget;
 220 
 221 enum {
 222   UNDETECTED,
 223   UNDETECTABLE,
 224   LINUX26_NPTL,
 225   BAREMETAL
 226 };
 227 
 228 struct CPUPerfCounters {
 229   int   nProcs;
<span class="line-modified"> 230   CPUPerfTicks jvmTicks;</span>
<span class="line-modified"> 231   CPUPerfTicks* cpus;</span>
 232 };
 233 
 234 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
 235 
 236 /** reads /proc/&lt;pid&gt;/stat data, with some checks and some skips.
 237  *  Ensure that &#39;fmt&#39; does _NOT_ contain the first two &quot;%d %s&quot;
 238  */
 239 static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {
 240   FILE*f;
 241   int n;
 242   char buf[2048];
 243 
 244   if ((f = fopen(procfile, &quot;r&quot;)) == NULL) {
 245     return -1;
 246   }
 247 
 248   if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {
 249     char *tmp;
 250 
 251     buf[n-1] = &#39;\0&#39;;
</pre>
<hr />
<pre>
 270   va_list args;
 271 
 272   va_start(args, fmt);
 273   n = vread_statdata(procfile, fmt, args);
 274   va_end(args);
 275   return n;
 276 }
 277 
 278 static FILE* open_statfile(void) {
 279   FILE *f;
 280 
 281   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {
 282     static int haveWarned = 0;
 283     if (!haveWarned) {
 284       haveWarned = 1;
 285     }
 286   }
 287   return f;
 288 }
 289 
<span class="line-removed"> 290 static void</span>
<span class="line-removed"> 291 next_line(FILE *f) {</span>
<span class="line-removed"> 292   int c;</span>
<span class="line-removed"> 293   do {</span>
<span class="line-removed"> 294     c = fgetc(f);</span>
<span class="line-removed"> 295   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-removed"> 296 }</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298 /**</span>
<span class="line-removed"> 299  * Return the total number of ticks since the system was booted.</span>
<span class="line-removed"> 300  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="line-removed"> 301  * the number of ticks spent on actual processes (user, system or</span>
<span class="line-removed"> 302  * nice processes) since system boot. Note that this is the total number</span>
<span class="line-removed"> 303  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="line-removed"> 304  * n times the number of ticks that has passed in clock time.</span>
<span class="line-removed"> 305  *</span>
<span class="line-removed"> 306  * Returns a negative value if the reading of the ticks failed.</span>
<span class="line-removed"> 307  */</span>
<span class="line-removed"> 308 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {</span>
<span class="line-removed"> 309   FILE*         fh;</span>
<span class="line-removed"> 310   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-removed"> 311   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-removed"> 312   int           logical_cpu = -1;</span>
<span class="line-removed"> 313   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="line-removed"> 314   int           n;</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316   if ((fh = open_statfile()) == NULL) {</span>
<span class="line-removed"> 317     return OS_ERR;</span>
<span class="line-removed"> 318   }</span>
<span class="line-removed"> 319   if (-1 == which_logical_cpu) {</span>
<span class="line-removed"> 320     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 321             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 322             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-removed"> 323             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 324   } else {</span>
<span class="line-removed"> 325     // Move to next line</span>
<span class="line-removed"> 326     next_line(fh);</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-removed"> 329     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-removed"> 330       next_line(fh);</span>
<span class="line-removed"> 331     }</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 334                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 335                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-removed"> 336                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 337   }</span>
<span class="line-removed"> 338 </span>
<span class="line-removed"> 339   fclose(fh);</span>
<span class="line-removed"> 340   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-removed"> 341 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 342     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="line-removed"> 343 #endif</span>
<span class="line-removed"> 344     return OS_ERR;</span>
<span class="line-removed"> 345   }</span>
<span class="line-removed"> 346 </span>
<span class="line-removed"> 347 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 348   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="line-removed"> 349           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 350           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="line-removed"> 351           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="line-removed"> 352           iowTicks, irqTicks, sirqTicks);</span>
<span class="line-removed"> 353 #endif</span>
<span class="line-removed"> 354 </span>
<span class="line-removed"> 355   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-removed"> 356   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 357   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-removed"> 358                        iowTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 359 </span>
<span class="line-removed"> 360   return OS_OK;</span>
<span class="line-removed"> 361 }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363 </span>
 364 static int get_systemtype(void) {
 365   static int procEntriesType = UNDETECTED;
 366   DIR *taskDir;
 367 
 368   if (procEntriesType != UNDETECTED) {
 369     return procEntriesType;
 370   }
 371 
 372   // Check whether we have a task subdirectory
 373   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {
 374     procEntriesType = UNDETECTABLE;
 375   } else {
 376     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system
 377     closedir(taskDir);
 378     procEntriesType = LINUX26_NPTL;
 379   }
 380 
 381   return procEntriesType;
 382 }
 383 
 384 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 385 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 386   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 387     userTicks, systemTicks);
 388 }
 389 
 390 /**
 391  * Return the number of ticks spent in any of the processes belonging
 392  * to the JVM on any CPU.
 393  */
<span class="line-modified"> 394 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {</span>
 395   uint64_t userTicks;
 396   uint64_t systemTicks;
 397 
 398   if (get_systemtype() != LINUX26_NPTL) {
 399     return OS_ERR;
 400   }
 401 
 402   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {
 403     return OS_ERR;
 404   }
 405 
 406   // get the total
<span class="line-modified"> 407   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
 408     return OS_ERR;
 409   }
 410 
 411   pticks-&gt;used       = userTicks;
 412   pticks-&gt;usedKernel = systemTicks;
 413 
 414   return OS_OK;
 415 }
 416 
 417 /**
 418  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 419  * available time for user or system processes, 0.0 means the CPU uses all time
 420  * being idle.
 421  *
 422  * Returns a negative value if there is a problem in determining the CPU load.
 423  */
 424 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 425   uint64_t udiff, kdiff, tdiff;
<span class="line-modified"> 426   CPUPerfTicks* pticks;</span>
<span class="line-modified"> 427   CPUPerfTicks  tmp;</span>
 428   double user_load;
 429 
 430   *pkernelLoad = 0.0;
 431 
 432   if (target == CPU_LOAD_VM_ONLY) {
 433     pticks = &amp;counters-&gt;jvmTicks;
 434   } else if (-1 == which_logical_cpu) {
 435     pticks = &amp;counters-&gt;cpus[counters-&gt;nProcs];
 436   } else {
 437     pticks = &amp;counters-&gt;cpus[which_logical_cpu];
 438   }
 439 
 440   tmp = *pticks;
 441 
 442   if (target == CPU_LOAD_VM_ONLY) {
 443     if (get_jvm_ticks(pticks) != OS_OK) {
 444       return -1.0;
 445     }
<span class="line-modified"> 446   } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {</span>
 447     return -1.0;
 448   }
 449 
 450   // seems like we sometimes end up with less kernel ticks when
 451   // reading /proc/self/stat a second time, timing issue between cpus?
 452   if (pticks-&gt;usedKernel &lt; tmp.usedKernel) {
 453     kdiff = 0;
 454   } else {
 455     kdiff = pticks-&gt;usedKernel - tmp.usedKernel;
 456   }
 457   tdiff = pticks-&gt;total - tmp.total;
 458   udiff = pticks-&gt;used - tmp.used;
 459 
 460   if (tdiff == 0) {
 461     return 0.0;
 462   } else if (tdiff &lt; (udiff + kdiff)) {
 463     tdiff = udiff + kdiff;
 464   }
 465   *pkernelLoad = (kdiff / (double)tdiff);
 466   // BUG9044876, normalize return values to sane values
</pre>
<hr />
<pre>
 494       }
 495     } else {
 496         fclose(f);
 497         va_end(args);
 498         return OS_ERR;
 499     }
 500   }
 501 }
 502 
 503 static int get_noof_context_switches(uint64_t* switches) {
 504   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 505 }
 506 
 507 /** returns boot time in _seconds_ since epoch */
 508 static int get_boot_time(uint64_t* time) {
 509   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 510 }
 511 
 512 static int perf_context_switch_rate(double* rate) {
 513   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified"> 514   static uint64_t      lastTime;</span>

 515   static uint64_t      lastSwitches;
 516   static double        lastRate;
 517 
<span class="line-modified"> 518   uint64_t lt = 0;</span>
 519   int res = 0;
 520 
<span class="line-modified"> 521   if (lastTime == 0) {</span>

 522     uint64_t tmp;
 523     if (get_boot_time(&amp;tmp) &lt; 0) {
 524       return OS_ERR;
 525     }
<span class="line-modified"> 526     lt = tmp * 1000;</span>
 527   }
 528 
 529   res = OS_OK;
 530 
 531   pthread_mutex_lock(&amp;contextSwitchLock);
 532   {
 533 
 534     uint64_t sw;
 535     s8 t, d;
 536 
<span class="line-modified"> 537     if (lastTime == 0) {</span>
<span class="line-modified"> 538       lastTime = lt;</span>










 539     }
 540 
<span class="line-removed"> 541     t = os::javaTimeMillis();</span>
<span class="line-removed"> 542     d = t - lastTime;</span>
<span class="line-removed"> 543 </span>
 544     if (d == 0) {
 545       *rate = lastRate;
<span class="line-modified"> 546     } else if (!get_noof_context_switches(&amp;sw)) {</span>
 547       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 548       lastRate     = *rate;
 549       lastSwitches = sw;
<span class="line-modified"> 550       lastTime     = t;</span>


 551     } else {
 552       *rate = 0;
 553       res   = OS_ERR;
 554     }
 555     if (*rate &lt;= 0) {
 556       *rate = 0;
 557       lastRate = 0;
 558     }




 559   }
 560   pthread_mutex_unlock(&amp;contextSwitchLock);
 561 
 562   return res;
 563 }
 564 
 565 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 566   friend class CPUPerformanceInterface;
 567  private:
 568   CPUPerfCounters _counters;
 569 
 570   int cpu_load(int which_logical_cpu, double* cpu_load);
 571   int context_switch_rate(double* rate);
 572   int cpu_load_total_process(double* cpu_load);
 573   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 574 
 575  public:
 576   CPUPerformance();
 577   bool initialize();
 578   ~CPUPerformance();
 579 };
 580 
 581 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 582   _counters.nProcs = os::active_processor_count();
 583   _counters.cpus = NULL;
 584 }
 585 
 586 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified"> 587   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="line-modified"> 588   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified"> 589   if (NULL == _counters.cpus) {</span>
<span class="line-removed"> 590     return false;</span>
<span class="line-removed"> 591   }</span>
<span class="line-removed"> 592   memset(_counters.cpus, 0, tick_array_size);</span>
 593 
 594   // For the CPU load total
<span class="line-modified"> 595   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);</span>
 596 
 597   // For each CPU
 598   for (int i = 0; i &lt; _counters.nProcs; i++) {
<span class="line-modified"> 599     get_total_ticks(i, &amp;_counters.cpus[i]);</span>
 600   }
 601   // For JVM load
 602   get_jvm_ticks(&amp;_counters.jvmTicks);
 603 
 604   // initialize context switch system
 605   // the double is only for init
 606   double init_ctx_switch_rate;
 607   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 608 
 609   return true;
 610 }
 611 
 612 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
 613   if (_counters.cpus != NULL) {
 614     FREE_C_HEAP_ARRAY(char, _counters.cpus);
 615   }
 616 }
 617 
 618 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
 619   double u, s;
</pre>
<hr />
<pre>
 659     t = MIN2&lt;double&gt;(u + s, 1.0);
 660   }
 661 
 662   *pjvmUserLoad = u;
 663   *pjvmKernelLoad = s;
 664   *psystemTotalLoad = t;
 665 
 666   return OS_OK;
 667 }
 668 
 669 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 670   return perf_context_switch_rate(rate);
 671 }
 672 
 673 CPUPerformanceInterface::CPUPerformanceInterface() {
 674   _impl = NULL;
 675 }
 676 
 677 bool CPUPerformanceInterface::initialize() {
 678   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified"> 679   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 680 }
 681 
 682 CPUPerformanceInterface::~CPUPerformanceInterface() {
 683   if (_impl != NULL) {
 684     delete _impl;
 685   }
 686 }
 687 
 688 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 689   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 690 }
 691 
 692 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 693   return _impl-&gt;cpu_load_total_process(cpu_load);
 694 }
 695 
 696 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 697   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 698 }
 699 
</pre>
<hr />
<pre>
 812 }
 813 
 814 // get command line from /proc/&lt;pid&gt;/cmdline
 815 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 816   FILE* fp;
 817   char  buffer[PATH_MAX];
 818   char* cmdline = NULL;
 819 
 820   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 821   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 822   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 823     size_t size = 0;
 824     char   dummy;
 825 
 826     // find out how long the file is (stat always returns 0)
 827     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 828       size++;
 829     }
 830     if (size &gt; 0) {
 831       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified"> 832       if (cmdline != NULL) {</span>
<span class="line-modified"> 833         cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 834         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 835           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 836             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 837             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 838             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 839               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-removed"> 840                 cmdline[i] = &#39; &#39;;</span>
<span class="line-removed"> 841               }</span>
 842             }
<span class="line-removed"> 843             cmdline[size] = &#39;\0&#39;;</span>
 844           }

 845         }
 846       }
 847     }
 848     fclose(fp);
 849   }
 850   return cmdline;
 851 }
 852 
 853 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 854 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 855   char buffer[PATH_MAX];
 856 
 857   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 858   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 859   return realpath(buffer, _exePath);
 860 }
 861 
 862 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 863   if (str != NULL) {
 864     return os::strdup_check_oom(str, mtInternal);
</pre>
<hr />
<pre>
 918   _dir = os::opendir(&quot;/proc&quot;);
 919   _entry = NULL;
 920   _valid = true;
 921   next_process();
 922 
 923   return true;
 924 }
 925 
 926 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 927   if (_dir != NULL) {
 928     os::closedir(_dir);
 929   }
 930 }
 931 
 932 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 933   _iterator = NULL;
 934 }
 935 
 936 bool SystemProcessInterface::SystemProcesses::initialize() {
 937   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified"> 938   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
 939 }
 940 
 941 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 942   if (_iterator != NULL) {
 943     delete _iterator;
 944   }
 945 }
 946 
 947 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 948   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 949   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 950   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 951 
 952   // initialize pointers
 953   *no_of_sys_processes = 0;
 954   *system_processes = NULL;
 955 
 956   while (_iterator-&gt;is_valid()) {
 957     SystemProcess* tmp = new SystemProcess();
 958     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
 965     // new head
 966     *system_processes = tmp;
 967     // increment
 968     (*no_of_sys_processes)++;
 969     // step forward
 970     _iterator-&gt;next_process();
 971   }
 972   return OS_OK;
 973 }
 974 
 975 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 976   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 977 }
 978 
 979 SystemProcessInterface::SystemProcessInterface() {
 980   _impl = NULL;
 981 }
 982 
 983 bool SystemProcessInterface::initialize() {
 984   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified"> 985   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 986 }
 987 
 988 SystemProcessInterface::~SystemProcessInterface() {
 989   if (_impl != NULL) {
 990     delete _impl;
 991   }
 992 }
 993 
 994 CPUInformationInterface::CPUInformationInterface() {
 995   _cpu_info = NULL;
 996 }
 997 
 998 bool CPUInformationInterface::initialize() {
 999   _cpu_info = new CPUInformation();
<span class="line-removed">1000   if (NULL == _cpu_info) {</span>
<span class="line-removed">1001     return false;</span>
<span class="line-removed">1002   }</span>
1003   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1004   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1005   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1006   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1007   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<span class="line-removed">1008 </span>
1009   return true;
1010 }
1011 
1012 CPUInformationInterface::~CPUInformationInterface() {
1013   if (_cpu_info != NULL) {
1014     if (_cpu_info-&gt;cpu_name() != NULL) {
1015       const char* cpu_name = _cpu_info-&gt;cpu_name();
1016       FREE_C_HEAP_ARRAY(char, cpu_name);
1017       _cpu_info-&gt;set_cpu_name(NULL);
1018     }
1019     if (_cpu_info-&gt;cpu_description() != NULL) {
1020        const char* cpu_desc = _cpu_info-&gt;cpu_description();
1021        FREE_C_HEAP_ARRAY(char, cpu_desc);
1022       _cpu_info-&gt;set_cpu_description(NULL);
1023     }
1024     delete _cpu_info;
1025   }
1026 }
1027 
1028 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1029   if (_cpu_info == NULL) {
1030     return OS_ERR;
1031   }
1032 
1033   cpu_info = *_cpu_info; // shallow copy assignment
1034   return OS_OK;
1035 }
1036 
1037 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1038   friend class NetworkPerformanceInterface;
1039  private:
1040   NetworkPerformance();
<span class="line-modified">1041   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">1042   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
1043   bool initialize();
1044   ~NetworkPerformance();
1045   int64_t read_counter(const char* iface, const char* counter) const;
1046   int network_utilization(NetworkInterface** network_interfaces) const;
1047 };
1048 
1049 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
1050 
1051 }
1052 
1053 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1054   return true;
1055 }
1056 
1057 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1058 }
1059 
1060 int64_t NetworkPerformanceInterface::NetworkPerformance::read_counter(const char* iface, const char* counter) const {
1061   char buf[128];
1062 
</pre>
<hr />
<pre>
1102   }
1103 
1104   freeifaddrs(addresses);
1105   *network_interfaces = ret;
1106 
1107   return OS_OK;
1108 }
1109 
1110 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1111   _impl = NULL;
1112 }
1113 
1114 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1115   if (_impl != NULL) {
1116     delete _impl;
1117   }
1118 }
1119 
1120 bool NetworkPerformanceInterface::initialize() {
1121   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">1122   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1123 }
1124 
1125 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1126   return _impl-&gt;network_utilization(network_interfaces);
1127 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_linux.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;
<span class="line-added">  31 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  32 
  33 #include CPU_HEADER(vm_version_ext)
  34 
  35 #include &lt;stdio.h&gt;
  36 #include &lt;stdarg.h&gt;
  37 #include &lt;unistd.h&gt;
  38 #include &lt;errno.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;sys/resource.h&gt;
  41 #include &lt;sys/types.h&gt;
  42 #include &lt;sys/stat.h&gt;
  43 #include &lt;dirent.h&gt;
  44 #include &lt;stdlib.h&gt;
  45 #include &lt;dlfcn.h&gt;
  46 #include &lt;pthread.h&gt;
  47 #include &lt;limits.h&gt;
  48 #include &lt;ifaddrs.h&gt;
  49 #include &lt;fcntl.h&gt;
  50 
  51 /**
</pre>
<hr />
<pre>
 190  *   params is the parameter number where the actual args to
 191  *       the format starts. If the args are in a va_list, this
 192  *       should be 0.
 193  */
 194 #ifndef PRINTF_ARGS
 195 #  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)
 196 #endif
 197 
 198 #ifndef SCANF_ARGS
 199 #  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)
 200 #endif
 201 
 202 #ifndef _PRINTFMT_
 203 #  define _PRINTFMT_
 204 #endif
 205 
 206 #ifndef _SCANFMT_
 207 #  define _SCANFMT_
 208 #endif
 209 







 210 typedef enum {
 211   CPU_LOAD_VM_ONLY,
 212   CPU_LOAD_GLOBAL,
 213 } CpuLoadTarget;
 214 
 215 enum {
 216   UNDETECTED,
 217   UNDETECTABLE,
 218   LINUX26_NPTL,
 219   BAREMETAL
 220 };
 221 
 222 struct CPUPerfCounters {
 223   int   nProcs;
<span class="line-modified"> 224   os::Linux::CPUPerfTicks jvmTicks;</span>
<span class="line-modified"> 225   os::Linux::CPUPerfTicks* cpus;</span>
 226 };
 227 
 228 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
 229 
 230 /** reads /proc/&lt;pid&gt;/stat data, with some checks and some skips.
 231  *  Ensure that &#39;fmt&#39; does _NOT_ contain the first two &quot;%d %s&quot;
 232  */
 233 static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {
 234   FILE*f;
 235   int n;
 236   char buf[2048];
 237 
 238   if ((f = fopen(procfile, &quot;r&quot;)) == NULL) {
 239     return -1;
 240   }
 241 
 242   if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {
 243     char *tmp;
 244 
 245     buf[n-1] = &#39;\0&#39;;
</pre>
<hr />
<pre>
 264   va_list args;
 265 
 266   va_start(args, fmt);
 267   n = vread_statdata(procfile, fmt, args);
 268   va_end(args);
 269   return n;
 270 }
 271 
 272 static FILE* open_statfile(void) {
 273   FILE *f;
 274 
 275   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {
 276     static int haveWarned = 0;
 277     if (!haveWarned) {
 278       haveWarned = 1;
 279     }
 280   }
 281   return f;
 282 }
 283 










































































 284 static int get_systemtype(void) {
 285   static int procEntriesType = UNDETECTED;
 286   DIR *taskDir;
 287 
 288   if (procEntriesType != UNDETECTED) {
 289     return procEntriesType;
 290   }
 291 
 292   // Check whether we have a task subdirectory
 293   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {
 294     procEntriesType = UNDETECTABLE;
 295   } else {
 296     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system
 297     closedir(taskDir);
 298     procEntriesType = LINUX26_NPTL;
 299   }
 300 
 301   return procEntriesType;
 302 }
 303 
 304 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 305 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 306   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 307     userTicks, systemTicks);
 308 }
 309 
 310 /**
 311  * Return the number of ticks spent in any of the processes belonging
 312  * to the JVM on any CPU.
 313  */
<span class="line-modified"> 314 static OSReturn get_jvm_ticks(os::Linux::CPUPerfTicks* pticks) {</span>
 315   uint64_t userTicks;
 316   uint64_t systemTicks;
 317 
 318   if (get_systemtype() != LINUX26_NPTL) {
 319     return OS_ERR;
 320   }
 321 
 322   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {
 323     return OS_ERR;
 324   }
 325 
 326   // get the total
<span class="line-modified"> 327   if (! os::Linux::get_tick_information(pticks, -1)) {</span>
 328     return OS_ERR;
 329   }
 330 
 331   pticks-&gt;used       = userTicks;
 332   pticks-&gt;usedKernel = systemTicks;
 333 
 334   return OS_OK;
 335 }
 336 
 337 /**
 338  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 339  * available time for user or system processes, 0.0 means the CPU uses all time
 340  * being idle.
 341  *
 342  * Returns a negative value if there is a problem in determining the CPU load.
 343  */
 344 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 345   uint64_t udiff, kdiff, tdiff;
<span class="line-modified"> 346   os::Linux::CPUPerfTicks* pticks;</span>
<span class="line-modified"> 347   os::Linux::CPUPerfTicks  tmp;</span>
 348   double user_load;
 349 
 350   *pkernelLoad = 0.0;
 351 
 352   if (target == CPU_LOAD_VM_ONLY) {
 353     pticks = &amp;counters-&gt;jvmTicks;
 354   } else if (-1 == which_logical_cpu) {
 355     pticks = &amp;counters-&gt;cpus[counters-&gt;nProcs];
 356   } else {
 357     pticks = &amp;counters-&gt;cpus[which_logical_cpu];
 358   }
 359 
 360   tmp = *pticks;
 361 
 362   if (target == CPU_LOAD_VM_ONLY) {
 363     if (get_jvm_ticks(pticks) != OS_OK) {
 364       return -1.0;
 365     }
<span class="line-modified"> 366   } else if (! os::Linux::get_tick_information(pticks, which_logical_cpu)) {</span>
 367     return -1.0;
 368   }
 369 
 370   // seems like we sometimes end up with less kernel ticks when
 371   // reading /proc/self/stat a second time, timing issue between cpus?
 372   if (pticks-&gt;usedKernel &lt; tmp.usedKernel) {
 373     kdiff = 0;
 374   } else {
 375     kdiff = pticks-&gt;usedKernel - tmp.usedKernel;
 376   }
 377   tdiff = pticks-&gt;total - tmp.total;
 378   udiff = pticks-&gt;used - tmp.used;
 379 
 380   if (tdiff == 0) {
 381     return 0.0;
 382   } else if (tdiff &lt; (udiff + kdiff)) {
 383     tdiff = udiff + kdiff;
 384   }
 385   *pkernelLoad = (kdiff / (double)tdiff);
 386   // BUG9044876, normalize return values to sane values
</pre>
<hr />
<pre>
 414       }
 415     } else {
 416         fclose(f);
 417         va_end(args);
 418         return OS_ERR;
 419     }
 420   }
 421 }
 422 
 423 static int get_noof_context_switches(uint64_t* switches) {
 424   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 425 }
 426 
 427 /** returns boot time in _seconds_ since epoch */
 428 static int get_boot_time(uint64_t* time) {
 429   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 430 }
 431 
 432 static int perf_context_switch_rate(double* rate) {
 433   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified"> 434   static uint64_t      bootTime;</span>
<span class="line-added"> 435   static uint64_t      lastTimeNanos;</span>
 436   static uint64_t      lastSwitches;
 437   static double        lastRate;
 438 
<span class="line-modified"> 439   uint64_t bt = 0;</span>
 440   int res = 0;
 441 
<span class="line-modified"> 442   // First time through bootTime will be zero.</span>
<span class="line-added"> 443   if (bootTime == 0) {</span>
 444     uint64_t tmp;
 445     if (get_boot_time(&amp;tmp) &lt; 0) {
 446       return OS_ERR;
 447     }
<span class="line-modified"> 448     bt = tmp * 1000;</span>
 449   }
 450 
 451   res = OS_OK;
 452 
 453   pthread_mutex_lock(&amp;contextSwitchLock);
 454   {
 455 
 456     uint64_t sw;
 457     s8 t, d;
 458 
<span class="line-modified"> 459     if (bootTime == 0) {</span>
<span class="line-modified"> 460       // First interval is measured from boot time which is</span>
<span class="line-added"> 461       // seconds since the epoch. Thereafter we measure the</span>
<span class="line-added"> 462       // elapsed time using javaTimeNanos as it is monotonic-</span>
<span class="line-added"> 463       // non-decreasing.</span>
<span class="line-added"> 464       lastTimeNanos = os::javaTimeNanos();</span>
<span class="line-added"> 465       t = os::javaTimeMillis();</span>
<span class="line-added"> 466       d = t - bt;</span>
<span class="line-added"> 467       // keep bootTime zero for now to use as a first-time-through flag</span>
<span class="line-added"> 468     } else {</span>
<span class="line-added"> 469       t = os::javaTimeNanos();</span>
<span class="line-added"> 470       d = nanos_to_millis(t - lastTimeNanos);</span>
 471     }
 472 



 473     if (d == 0) {
 474       *rate = lastRate;
<span class="line-modified"> 475     } else if (get_noof_context_switches(&amp;sw) == 0) {</span>
 476       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 477       lastRate     = *rate;
 478       lastSwitches = sw;
<span class="line-modified"> 479       if (bootTime != 0) {</span>
<span class="line-added"> 480         lastTimeNanos = t;</span>
<span class="line-added"> 481       }</span>
 482     } else {
 483       *rate = 0;
 484       res   = OS_ERR;
 485     }
 486     if (*rate &lt;= 0) {
 487       *rate = 0;
 488       lastRate = 0;
 489     }
<span class="line-added"> 490 </span>
<span class="line-added"> 491     if (bootTime == 0) {</span>
<span class="line-added"> 492       bootTime = bt;</span>
<span class="line-added"> 493     }</span>
 494   }
 495   pthread_mutex_unlock(&amp;contextSwitchLock);
 496 
 497   return res;
 498 }
 499 
 500 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 501   friend class CPUPerformanceInterface;
 502  private:
 503   CPUPerfCounters _counters;
 504 
 505   int cpu_load(int which_logical_cpu, double* cpu_load);
 506   int context_switch_rate(double* rate);
 507   int cpu_load_total_process(double* cpu_load);
 508   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 509 
 510  public:
 511   CPUPerformance();
 512   bool initialize();
 513   ~CPUPerformance();
 514 };
 515 
 516 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 517   _counters.nProcs = os::active_processor_count();
 518   _counters.cpus = NULL;
 519 }
 520 
 521 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified"> 522   size_t array_entry_count = _counters.nProcs + 1;</span>
<span class="line-modified"> 523   _counters.cpus = NEW_C_HEAP_ARRAY(os::Linux::CPUPerfTicks, array_entry_count, mtInternal);</span>
<span class="line-modified"> 524   memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));</span>



 525 
 526   // For the CPU load total
<span class="line-modified"> 527   os::Linux::get_tick_information(&amp;_counters.cpus[_counters.nProcs], -1);</span>
 528 
 529   // For each CPU
 530   for (int i = 0; i &lt; _counters.nProcs; i++) {
<span class="line-modified"> 531     os::Linux::get_tick_information(&amp;_counters.cpus[i], i);</span>
 532   }
 533   // For JVM load
 534   get_jvm_ticks(&amp;_counters.jvmTicks);
 535 
 536   // initialize context switch system
 537   // the double is only for init
 538   double init_ctx_switch_rate;
 539   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 540 
 541   return true;
 542 }
 543 
 544 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
 545   if (_counters.cpus != NULL) {
 546     FREE_C_HEAP_ARRAY(char, _counters.cpus);
 547   }
 548 }
 549 
 550 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
 551   double u, s;
</pre>
<hr />
<pre>
 591     t = MIN2&lt;double&gt;(u + s, 1.0);
 592   }
 593 
 594   *pjvmUserLoad = u;
 595   *pjvmKernelLoad = s;
 596   *psystemTotalLoad = t;
 597 
 598   return OS_OK;
 599 }
 600 
 601 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 602   return perf_context_switch_rate(rate);
 603 }
 604 
 605 CPUPerformanceInterface::CPUPerformanceInterface() {
 606   _impl = NULL;
 607 }
 608 
 609 bool CPUPerformanceInterface::initialize() {
 610   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified"> 611   return _impl-&gt;initialize();</span>
 612 }
 613 
 614 CPUPerformanceInterface::~CPUPerformanceInterface() {
 615   if (_impl != NULL) {
 616     delete _impl;
 617   }
 618 }
 619 
 620 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 621   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 622 }
 623 
 624 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 625   return _impl-&gt;cpu_load_total_process(cpu_load);
 626 }
 627 
 628 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 629   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 630 }
 631 
</pre>
<hr />
<pre>
 744 }
 745 
 746 // get command line from /proc/&lt;pid&gt;/cmdline
 747 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 748   FILE* fp;
 749   char  buffer[PATH_MAX];
 750   char* cmdline = NULL;
 751 
 752   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 753   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 754   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 755     size_t size = 0;
 756     char   dummy;
 757 
 758     // find out how long the file is (stat always returns 0)
 759     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 760       size++;
 761     }
 762     if (size &gt; 0) {
 763       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified"> 764       cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 765       if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 766         if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 767           // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 768           // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 769           for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 770             if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-modified"> 771               cmdline[i] = &#39; &#39;;</span>


 772             }

 773           }
<span class="line-added"> 774           cmdline[size] = &#39;\0&#39;;</span>
 775         }
 776       }
 777     }
 778     fclose(fp);
 779   }
 780   return cmdline;
 781 }
 782 
 783 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 784 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 785   char buffer[PATH_MAX];
 786 
 787   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 788   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 789   return realpath(buffer, _exePath);
 790 }
 791 
 792 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 793   if (str != NULL) {
 794     return os::strdup_check_oom(str, mtInternal);
</pre>
<hr />
<pre>
 848   _dir = os::opendir(&quot;/proc&quot;);
 849   _entry = NULL;
 850   _valid = true;
 851   next_process();
 852 
 853   return true;
 854 }
 855 
 856 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 857   if (_dir != NULL) {
 858     os::closedir(_dir);
 859   }
 860 }
 861 
 862 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 863   _iterator = NULL;
 864 }
 865 
 866 bool SystemProcessInterface::SystemProcesses::initialize() {
 867   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified"> 868   return _iterator-&gt;initialize();</span>
 869 }
 870 
 871 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 872   if (_iterator != NULL) {
 873     delete _iterator;
 874   }
 875 }
 876 
 877 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 878   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 879   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 880   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 881 
 882   // initialize pointers
 883   *no_of_sys_processes = 0;
 884   *system_processes = NULL;
 885 
 886   while (_iterator-&gt;is_valid()) {
 887     SystemProcess* tmp = new SystemProcess();
 888     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
 895     // new head
 896     *system_processes = tmp;
 897     // increment
 898     (*no_of_sys_processes)++;
 899     // step forward
 900     _iterator-&gt;next_process();
 901   }
 902   return OS_OK;
 903 }
 904 
 905 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 906   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 907 }
 908 
 909 SystemProcessInterface::SystemProcessInterface() {
 910   _impl = NULL;
 911 }
 912 
 913 bool SystemProcessInterface::initialize() {
 914   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified"> 915   return _impl-&gt;initialize();</span>
 916 }
 917 
 918 SystemProcessInterface::~SystemProcessInterface() {
 919   if (_impl != NULL) {
 920     delete _impl;
 921   }
 922 }
 923 
 924 CPUInformationInterface::CPUInformationInterface() {
 925   _cpu_info = NULL;
 926 }
 927 
 928 bool CPUInformationInterface::initialize() {
 929   _cpu_info = new CPUInformation();



 930   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
 931   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
 932   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
 933   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
 934   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());

 935   return true;
 936 }
 937 
 938 CPUInformationInterface::~CPUInformationInterface() {
 939   if (_cpu_info != NULL) {
 940     if (_cpu_info-&gt;cpu_name() != NULL) {
 941       const char* cpu_name = _cpu_info-&gt;cpu_name();
 942       FREE_C_HEAP_ARRAY(char, cpu_name);
 943       _cpu_info-&gt;set_cpu_name(NULL);
 944     }
 945     if (_cpu_info-&gt;cpu_description() != NULL) {
 946        const char* cpu_desc = _cpu_info-&gt;cpu_description();
 947        FREE_C_HEAP_ARRAY(char, cpu_desc);
 948       _cpu_info-&gt;set_cpu_description(NULL);
 949     }
 950     delete _cpu_info;
 951   }
 952 }
 953 
 954 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
 955   if (_cpu_info == NULL) {
 956     return OS_ERR;
 957   }
 958 
 959   cpu_info = *_cpu_info; // shallow copy assignment
 960   return OS_OK;
 961 }
 962 
 963 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
 964   friend class NetworkPerformanceInterface;
 965  private:
 966   NetworkPerformance();
<span class="line-modified"> 967   NONCOPYABLE(NetworkPerformance);</span>

 968   bool initialize();
 969   ~NetworkPerformance();
 970   int64_t read_counter(const char* iface, const char* counter) const;
 971   int network_utilization(NetworkInterface** network_interfaces) const;
 972 };
 973 
 974 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
 975 
 976 }
 977 
 978 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
 979   return true;
 980 }
 981 
 982 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
 983 }
 984 
 985 int64_t NetworkPerformanceInterface::NetworkPerformance::read_counter(const char* iface, const char* counter) const {
 986   char buf[128];
 987 
</pre>
<hr />
<pre>
1027   }
1028 
1029   freeifaddrs(addresses);
1030   *network_interfaces = ret;
1031 
1032   return OS_OK;
1033 }
1034 
1035 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1036   _impl = NULL;
1037 }
1038 
1039 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1040   if (_impl != NULL) {
1041     delete _impl;
1042   }
1043 }
1044 
1045 bool NetworkPerformanceInterface::initialize() {
1046   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">1047   return _impl-&gt;initialize();</span>
1048 }
1049 
1050 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1051   return _impl-&gt;network_utilization(network_interfaces);
1052 }
</pre>
</td>
</tr>
</table>
<center><a href="os_linux.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
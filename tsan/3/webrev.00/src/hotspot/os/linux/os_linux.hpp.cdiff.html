<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/linux/os_linux.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  
  // Information about the protection of the page at address &#39;0&#39; on this os.
  static bool zero_page_read_protected() { return true; }
  
  class Linux {
<span class="line-added">+   friend class CgroupSubsystem;</span>
    friend class os;
    friend class OSContainer;
    friend class TestReserveMemorySpecial;
  
    static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,24 ***</span>
    static bool _supports_fast_thread_cpu_time;
  
    static GrowableArray&lt;int&gt;* _cpu_to_node;
    static GrowableArray&lt;int&gt;* _nindex_to_node;
  
<span class="line-removed">-   // 0x00000000 = uninitialized,</span>
<span class="line-removed">-   // 0x01000000 = kernel version unknown,</span>
<span class="line-removed">-   // otherwise a 32-bit number:</span>
<span class="line-removed">-   // Ox00AABBCC</span>
<span class="line-removed">-   // AA, Major Version</span>
<span class="line-removed">-   // BB, Minor Version</span>
<span class="line-removed">-   // CC, Fix   Version</span>
<span class="line-removed">-   static uint32_t _os_version;</span>
<span class="line-removed">- </span>
   protected:
  
    static julong _physical_memory;
    static pthread_t _main_thread;
<span class="line-removed">-   static Mutex* _createThread_lock;</span>
    static int _page_size;
  
    static julong available_memory();
    static julong physical_memory() { return _physical_memory; }
    static void set_physical_memory(julong phys_mem) { _physical_memory = phys_mem; }
<span class="line-new-header">--- 54,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,17 ***</span>
    static bool release_memory_special_shm(char* base, size_t bytes);
    static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);
  
    static void print_full_memory_info(outputStream* st);
    static void print_container_info(outputStream* st);
<span class="line-modified">!   static void print_virtualization_info(outputStream* st);</span>
    static void print_distro_info(outputStream* st);
    static void print_libversion_info(outputStream* st);
    static void print_proc_sys_info(outputStream* st);
    static void print_ld_preload_file(outputStream* st);
  
   public:
    static bool _stack_is_executable;
    static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);
    static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);
  
    static void init_thread_fpu_state();
<span class="line-new-header">--- 97,28 ---</span>
    static bool release_memory_special_shm(char* base, size_t bytes);
    static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);
  
    static void print_full_memory_info(outputStream* st);
    static void print_container_info(outputStream* st);
<span class="line-modified">!   static void print_steal_info(outputStream* st);</span>
    static void print_distro_info(outputStream* st);
    static void print_libversion_info(outputStream* st);
    static void print_proc_sys_info(outputStream* st);
    static void print_ld_preload_file(outputStream* st);
<span class="line-added">+   static void print_uptime_info(outputStream* st);</span>
  
   public:
<span class="line-added">+   struct CPUPerfTicks {</span>
<span class="line-added">+     uint64_t used;</span>
<span class="line-added">+     uint64_t usedKernel;</span>
<span class="line-added">+     uint64_t total;</span>
<span class="line-added">+     uint64_t steal;</span>
<span class="line-added">+     bool     has_steal_ticks;</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   // which_logical_cpu=-1 returns accumulated ticks for all cpus.</span>
<span class="line-added">+   static bool get_tick_information(CPUPerfTicks* pticks, int which_logical_cpu);</span>
    static bool _stack_is_executable;
    static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);
    static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);
  
    static void init_thread_fpu_state();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,12 ***</span>
    static void set_fpu_control_word(int fpu_control);
    static pthread_t main_thread(void)                                { return _main_thread; }
    // returns kernel thread id (similar to LWP id on Solaris), which can be
    // used to access /proc
    static pid_t gettid();
<span class="line-removed">-   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }</span>
<span class="line-removed">-   static Mutex* createThread_lock(void)                             { return _createThread_lock; }</span>
    static void hotspot_sigmask(Thread* thread);
  
    static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
    static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
  
<span class="line-new-header">--- 126,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,11 ***</span>
  
    static void capture_initial_stack(size_t max_size);
  
    // Stack overflow handling
    static bool manually_expand_stack(JavaThread * t, address addr);
<span class="line-removed">-   static int max_register_window_saves_before_flushing();</span>
  
    // fast POSIX clocks support
    static void fast_thread_clock_init(void);
  
    static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
<span class="line-new-header">--- 184,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,14 ***</span>
      return _supports_fast_thread_cpu_time;
    }
  
    static jlong fast_thread_cpu_time(clockid_t clockid);
  
<span class="line-removed">-   static void initialize_os_info();</span>
<span class="line-removed">-   static bool os_version_is_known();</span>
<span class="line-removed">-   static uint32_t os_version();</span>
<span class="line-removed">- </span>
    // Stack repair handling
  
    // none present
  
   private:
<span class="line-new-header">--- 198,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,11 ***</span>
    typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);
    typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);
    typedef void (*numa_interleave_memory_v2_func_t)(void *start, size_t size, struct bitmask* mask);
    typedef struct bitmask* (*numa_get_membind_func_t)(void);
    typedef struct bitmask* (*numa_get_interleave_mask_func_t)(void);
<span class="line-modified">! </span>
    typedef void (*numa_set_bind_policy_func_t)(int policy);
    typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);
    typedef int (*numa_distance_func_t)(int node1, int node2);
  
    static sched_getcpu_func_t _sched_getcpu;
<span class="line-new-header">--- 216,12 ---</span>
    typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);
    typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);
    typedef void (*numa_interleave_memory_v2_func_t)(void *start, size_t size, struct bitmask* mask);
    typedef struct bitmask* (*numa_get_membind_func_t)(void);
    typedef struct bitmask* (*numa_get_interleave_mask_func_t)(void);
<span class="line-modified">!   typedef long (*numa_move_pages_func_t)(int pid, unsigned long count, void **pages, const int *nodes, int *status, int flags);</span>
<span class="line-added">+   typedef void (*numa_set_preferred_func_t)(int node);</span>
    typedef void (*numa_set_bind_policy_func_t)(int policy);
    typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);
    typedef int (*numa_distance_func_t)(int node1, int node2);
  
    static sched_getcpu_func_t _sched_getcpu;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,10 ***</span>
<span class="line-new-header">--- 235,12 ---</span>
    static numa_set_bind_policy_func_t _numa_set_bind_policy;
    static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;
    static numa_distance_func_t _numa_distance;
    static numa_get_membind_func_t _numa_get_membind;
    static numa_get_interleave_mask_func_t _numa_get_interleave_mask;
<span class="line-added">+   static numa_move_pages_func_t _numa_move_pages;</span>
<span class="line-added">+   static numa_set_preferred_func_t _numa_set_preferred;</span>
    static unsigned long* _numa_all_nodes;
    static struct bitmask* _numa_all_nodes_ptr;
    static struct bitmask* _numa_nodes_ptr;
    static struct bitmask* _numa_interleave_bitmask;
    static struct bitmask* _numa_membind_bitmask;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,10 ***</span>
<span class="line-new-header">--- 256,12 ---</span>
    static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }
    static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }
    static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }
    static void set_numa_get_membind(numa_get_membind_func_t func) { _numa_get_membind = func; }
    static void set_numa_get_interleave_mask(numa_get_interleave_mask_func_t func) { _numa_get_interleave_mask = func; }
<span class="line-added">+   static void set_numa_move_pages(numa_move_pages_func_t func) { _numa_move_pages = func; }</span>
<span class="line-added">+   static void set_numa_set_preferred(numa_set_preferred_func_t func) { _numa_set_preferred = func; }</span>
    static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }
    static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = (ptr == NULL ? NULL : *ptr); }
    static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = (ptr == NULL ? NULL : *ptr); }
    static void set_numa_interleave_bitmask(struct bitmask* ptr)     { _numa_interleave_bitmask = ptr ;   }
    static void set_numa_membind_bitmask(struct bitmask* ptr)        { _numa_membind_bitmask = ptr ;      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,18 ***</span>
<span class="line-new-header">--- 315,26 ---</span>
        }
      } else if (_numa_interleave_memory != NULL) {
        _numa_interleave_memory(start, size, _numa_all_nodes);
      }
    }
<span class="line-added">+   static void numa_set_preferred(int node) {</span>
<span class="line-added">+     if (_numa_set_preferred != NULL) {</span>
<span class="line-added">+       _numa_set_preferred(node);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
    static void numa_set_bind_policy(int policy) {
      if (_numa_set_bind_policy != NULL) {
        _numa_set_bind_policy(policy);
      }
    }
    static int numa_distance(int node1, int node2) {
      return _numa_distance != NULL ? _numa_distance(node1, node2) : -1;
    }
<span class="line-added">+   static long numa_move_pages(int pid, unsigned long count, void **pages, const int *nodes, int *status, int flags) {</span>
<span class="line-added">+     return _numa_move_pages != NULL ? _numa_move_pages(pid, count, pages, nodes, status, flags) : -1;</span>
<span class="line-added">+   }</span>
    static int get_node_by_cpu(int cpu_id);
    static int get_existing_num_nodes();
    // Check if numa node is configured (non-zero memory node).
    static bool is_node_in_configured_nodes(unsigned int n) {
      if (_numa_bitmask_isbitset != NULL &amp;&amp; _numa_all_nodes_ptr != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,8 ***</span>
<span class="line-new-header">--- 397,12 ---</span>
        return true;
      } else {
        return false;
      }
    }
<span class="line-added">+ </span>
<span class="line-added">+   static const GrowableArray&lt;int&gt;* numa_nindex_to_node() {</span>
<span class="line-added">+     return _nindex_to_node;</span>
<span class="line-added">+   }</span>
  };
  
  #endif // OS_LINUX_OS_LINUX_HPP
</pre>
<center><a href="os_linux.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
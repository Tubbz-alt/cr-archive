<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/linux/os_perf_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_linux.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;
<a name="2" id="anc2"></a>
  31 
  32 #include CPU_HEADER(vm_version_ext)
  33 
  34 #include &lt;stdio.h&gt;
  35 #include &lt;stdarg.h&gt;
  36 #include &lt;unistd.h&gt;
  37 #include &lt;errno.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;sys/resource.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #include &lt;dirent.h&gt;
  43 #include &lt;stdlib.h&gt;
  44 #include &lt;dlfcn.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;limits.h&gt;
  47 #include &lt;ifaddrs.h&gt;
  48 #include &lt;fcntl.h&gt;
  49 
  50 /**
  51    /proc/[number]/stat
  52               Status information about the process.  This is used by ps(1).  It is defined in /usr/src/linux/fs/proc/array.c.
  53 
  54               The fields, in order, with their proper scanf(3) format specifiers, are:
  55 
  56               1. pid %d The process id.
  57 
  58               2. comm %s
  59                      The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.
  60 
  61               3. state %c
  62                      One  character  from  the  string &quot;RSDZTW&quot; where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk
  63                      sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.
  64 
  65               4. ppid %d
  66                      The PID of the parent.
  67 
  68               5. pgrp %d
  69                      The process group ID of the process.
  70 
  71               6. session %d
  72                      The session ID of the process.
  73 
  74               7. tty_nr %d
  75                      The tty the process uses.
  76 
  77               8. tpgid %d
  78                      The process group ID of the process which currently owns the tty that the process is connected to.
  79 
  80               9. flags %lu
  81                      The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.
  82 
  83               10. minflt %lu
  84                      The number of minor faults the process has made which have not required loading a memory page from disk.
  85 
  86               11. cminflt %lu
  87                      The number of minor faults that the process&#39;s waited-for children have made.
  88 
  89               12. majflt %lu
  90                      The number of major faults the process has made which have required loading a memory page from disk.
  91 
  92               13. cmajflt %lu
  93                      The number of major faults that the process&#39;s waited-for children have made.
  94 
  95               14. utime %lu
  96                      The number of jiffies that this process has been scheduled in user mode.
  97 
  98               15. stime %lu
  99                      The number of jiffies that this process has been scheduled in kernel mode.
 100 
 101               16. cutime %ld
 102                      The number of jiffies that this process&#39;s waited-for children have been scheduled in user mode. (See also times(2).)
 103 
 104               17. cstime %ld
 105                      The number of jiffies that this process&#39; waited-for children have been scheduled in kernel mode.
 106 
 107               18. priority %ld
 108                      The standard nice value, plus fifteen.  The value is never negative in the kernel.
 109 
 110               19. nice %ld
 111                      The nice value ranges from 19 (nicest) to -19 (not nice to others).
 112 
 113               20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.
 114 
 115               21. itrealvalue %ld
 116                      The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.
 117 
 118               22. starttime %lu
 119                      The time in jiffies the process started after system boot.
 120 
 121               23. vsize %lu
 122                      Virtual memory size in bytes.
 123 
 124               24. rss %ld
 125                      Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count
 126                      towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.
 127 
 128               25. rlim %lu
 129                      Current limit in bytes on the rss of the process (usually 4294967295 on i386).
 130 
 131               26. startcode %lu
 132                      The address above which program text can run.
 133 
 134               27. endcode %lu
 135                      The address below which program text can run.
 136 
 137               28. startstack %lu
 138                      The address of the start of the stack.
 139 
 140               29. kstkesp %lu
 141                      The current value of esp (stack pointer), as found in the kernel stack page for the process.
 142 
 143               30. kstkeip %lu
 144                      The current EIP (instruction pointer).
 145 
 146               31. signal %lu
 147                      The bitmap of pending signals (usually 0).
 148 
 149               32. blocked %lu
 150                      The bitmap of blocked signals (usually 0, 2 for shells).
 151 
 152               33. sigignore %lu
 153                      The bitmap of ignored signals.
 154 
 155               34. sigcatch %lu
 156                      The bitmap of catched signals.
 157 
 158               35. wchan %lu
 159                      This  is the &quot;channel&quot; in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need
 160                      a textual name.  (If you have an up-to-date /etc/psdatabase, then try ps -l to see the WCHAN field in action.)
 161 
 162               36. nswap %lu
 163                      Number of pages swapped - not maintained.
 164 
 165               37. cnswap %lu
 166                      Cumulative nswap for child processes.
 167 
 168               38. exit_signal %d
 169                      Signal to be sent to parent when we die.
 170 
 171               39. processor %d
 172                      CPU number last executed on.
 173 
 174 
 175 
 176  ///// SSCANF FORMAT STRING. Copy and use.
 177 
 178 field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39
 179 format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d
 180 
 181 
 182 */
 183 
 184 /**
 185  * For platforms that have them, when declaring
 186  * a printf-style function,
 187  *   formatSpec is the parameter number (starting at 1)
 188  *       that is the format argument (&quot;%d pid %s&quot;)
 189  *   params is the parameter number where the actual args to
 190  *       the format starts. If the args are in a va_list, this
 191  *       should be 0.
 192  */
 193 #ifndef PRINTF_ARGS
 194 #  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)
 195 #endif
 196 
 197 #ifndef SCANF_ARGS
 198 #  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)
 199 #endif
 200 
 201 #ifndef _PRINTFMT_
 202 #  define _PRINTFMT_
 203 #endif
 204 
 205 #ifndef _SCANFMT_
 206 #  define _SCANFMT_
 207 #endif
 208 
<a name="3" id="anc3"></a><span class="line-removed"> 209 </span>
<span class="line-removed"> 210 struct CPUPerfTicks {</span>
<span class="line-removed"> 211   uint64_t  used;</span>
<span class="line-removed"> 212   uint64_t  usedKernel;</span>
<span class="line-removed"> 213   uint64_t  total;</span>
<span class="line-removed"> 214 };</span>
<span class="line-removed"> 215 </span>
 216 typedef enum {
 217   CPU_LOAD_VM_ONLY,
 218   CPU_LOAD_GLOBAL,
 219 } CpuLoadTarget;
 220 
 221 enum {
 222   UNDETECTED,
 223   UNDETECTABLE,
 224   LINUX26_NPTL,
 225   BAREMETAL
 226 };
 227 
 228 struct CPUPerfCounters {
 229   int   nProcs;
<a name="4" id="anc4"></a><span class="line-modified"> 230   CPUPerfTicks jvmTicks;</span>
<span class="line-modified"> 231   CPUPerfTicks* cpus;</span>
 232 };
 233 
 234 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
 235 
 236 /** reads /proc/&lt;pid&gt;/stat data, with some checks and some skips.
 237  *  Ensure that &#39;fmt&#39; does _NOT_ contain the first two &quot;%d %s&quot;
 238  */
 239 static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {
 240   FILE*f;
 241   int n;
 242   char buf[2048];
 243 
 244   if ((f = fopen(procfile, &quot;r&quot;)) == NULL) {
 245     return -1;
 246   }
 247 
 248   if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {
 249     char *tmp;
 250 
 251     buf[n-1] = &#39;\0&#39;;
 252     /** skip through pid and exec name. */
 253     if ((tmp = strrchr(buf, &#39;)&#39;)) != NULL) {
 254       // skip the &#39;)&#39; and the following space
 255       // but check that buffer is long enough
 256       tmp += 2;
 257       if (tmp &lt; buf + n) {
 258         n = vsscanf(tmp, fmt, args);
 259       }
 260     }
 261   }
 262 
 263   fclose(f);
 264 
 265   return n;
 266 }
 267 
 268 static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {
 269   int   n;
 270   va_list args;
 271 
 272   va_start(args, fmt);
 273   n = vread_statdata(procfile, fmt, args);
 274   va_end(args);
 275   return n;
 276 }
 277 
 278 static FILE* open_statfile(void) {
 279   FILE *f;
 280 
 281   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {
 282     static int haveWarned = 0;
 283     if (!haveWarned) {
 284       haveWarned = 1;
 285     }
 286   }
 287   return f;
 288 }
 289 
<a name="5" id="anc5"></a><span class="line-removed"> 290 static void</span>
<span class="line-removed"> 291 next_line(FILE *f) {</span>
<span class="line-removed"> 292   int c;</span>
<span class="line-removed"> 293   do {</span>
<span class="line-removed"> 294     c = fgetc(f);</span>
<span class="line-removed"> 295   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-removed"> 296 }</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298 /**</span>
<span class="line-removed"> 299  * Return the total number of ticks since the system was booted.</span>
<span class="line-removed"> 300  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="line-removed"> 301  * the number of ticks spent on actual processes (user, system or</span>
<span class="line-removed"> 302  * nice processes) since system boot. Note that this is the total number</span>
<span class="line-removed"> 303  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="line-removed"> 304  * n times the number of ticks that has passed in clock time.</span>
<span class="line-removed"> 305  *</span>
<span class="line-removed"> 306  * Returns a negative value if the reading of the ticks failed.</span>
<span class="line-removed"> 307  */</span>
<span class="line-removed"> 308 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {</span>
<span class="line-removed"> 309   FILE*         fh;</span>
<span class="line-removed"> 310   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-removed"> 311   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-removed"> 312   int           logical_cpu = -1;</span>
<span class="line-removed"> 313   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="line-removed"> 314   int           n;</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316   if ((fh = open_statfile()) == NULL) {</span>
<span class="line-removed"> 317     return OS_ERR;</span>
<span class="line-removed"> 318   }</span>
<span class="line-removed"> 319   if (-1 == which_logical_cpu) {</span>
<span class="line-removed"> 320     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 321             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 322             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-removed"> 323             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 324   } else {</span>
<span class="line-removed"> 325     // Move to next line</span>
<span class="line-removed"> 326     next_line(fh);</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-removed"> 329     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-removed"> 330       next_line(fh);</span>
<span class="line-removed"> 331     }</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 334                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 335                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-removed"> 336                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 337   }</span>
<span class="line-removed"> 338 </span>
<span class="line-removed"> 339   fclose(fh);</span>
<span class="line-removed"> 340   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-removed"> 341 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 342     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="line-removed"> 343 #endif</span>
<span class="line-removed"> 344     return OS_ERR;</span>
<span class="line-removed"> 345   }</span>
<span class="line-removed"> 346 </span>
<span class="line-removed"> 347 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 348   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="line-removed"> 349           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 350           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="line-removed"> 351           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="line-removed"> 352           iowTicks, irqTicks, sirqTicks);</span>
<span class="line-removed"> 353 #endif</span>
<span class="line-removed"> 354 </span>
<span class="line-removed"> 355   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-removed"> 356   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 357   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-removed"> 358                        iowTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 359 </span>
<span class="line-removed"> 360   return OS_OK;</span>
<span class="line-removed"> 361 }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363 </span>
 364 static int get_systemtype(void) {
 365   static int procEntriesType = UNDETECTED;
 366   DIR *taskDir;
 367 
 368   if (procEntriesType != UNDETECTED) {
 369     return procEntriesType;
 370   }
 371 
 372   // Check whether we have a task subdirectory
 373   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {
 374     procEntriesType = UNDETECTABLE;
 375   } else {
 376     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system
 377     closedir(taskDir);
 378     procEntriesType = LINUX26_NPTL;
 379   }
 380 
 381   return procEntriesType;
 382 }
 383 
 384 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 385 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 386   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 387     userTicks, systemTicks);
 388 }
 389 
 390 /**
 391  * Return the number of ticks spent in any of the processes belonging
 392  * to the JVM on any CPU.
 393  */
<a name="6" id="anc6"></a><span class="line-modified"> 394 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {</span>
 395   uint64_t userTicks;
 396   uint64_t systemTicks;
 397 
 398   if (get_systemtype() != LINUX26_NPTL) {
 399     return OS_ERR;
 400   }
 401 
 402   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {
 403     return OS_ERR;
 404   }
 405 
 406   // get the total
<a name="7" id="anc7"></a><span class="line-modified"> 407   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
 408     return OS_ERR;
 409   }
 410 
 411   pticks-&gt;used       = userTicks;
 412   pticks-&gt;usedKernel = systemTicks;
 413 
 414   return OS_OK;
 415 }
 416 
 417 /**
 418  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 419  * available time for user or system processes, 0.0 means the CPU uses all time
 420  * being idle.
 421  *
 422  * Returns a negative value if there is a problem in determining the CPU load.
 423  */
 424 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 425   uint64_t udiff, kdiff, tdiff;
<a name="8" id="anc8"></a><span class="line-modified"> 426   CPUPerfTicks* pticks;</span>
<span class="line-modified"> 427   CPUPerfTicks  tmp;</span>
 428   double user_load;
 429 
 430   *pkernelLoad = 0.0;
 431 
 432   if (target == CPU_LOAD_VM_ONLY) {
 433     pticks = &amp;counters-&gt;jvmTicks;
 434   } else if (-1 == which_logical_cpu) {
 435     pticks = &amp;counters-&gt;cpus[counters-&gt;nProcs];
 436   } else {
 437     pticks = &amp;counters-&gt;cpus[which_logical_cpu];
 438   }
 439 
 440   tmp = *pticks;
 441 
 442   if (target == CPU_LOAD_VM_ONLY) {
 443     if (get_jvm_ticks(pticks) != OS_OK) {
 444       return -1.0;
 445     }
<a name="9" id="anc9"></a><span class="line-modified"> 446   } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {</span>
 447     return -1.0;
 448   }
 449 
 450   // seems like we sometimes end up with less kernel ticks when
 451   // reading /proc/self/stat a second time, timing issue between cpus?
 452   if (pticks-&gt;usedKernel &lt; tmp.usedKernel) {
 453     kdiff = 0;
 454   } else {
 455     kdiff = pticks-&gt;usedKernel - tmp.usedKernel;
 456   }
 457   tdiff = pticks-&gt;total - tmp.total;
 458   udiff = pticks-&gt;used - tmp.used;
 459 
 460   if (tdiff == 0) {
 461     return 0.0;
 462   } else if (tdiff &lt; (udiff + kdiff)) {
 463     tdiff = udiff + kdiff;
 464   }
 465   *pkernelLoad = (kdiff / (double)tdiff);
 466   // BUG9044876, normalize return values to sane values
 467   *pkernelLoad = MAX2&lt;double&gt;(*pkernelLoad, 0.0);
 468   *pkernelLoad = MIN2&lt;double&gt;(*pkernelLoad, 1.0);
 469 
 470   user_load = (udiff / (double)tdiff);
 471   user_load = MAX2&lt;double&gt;(user_load, 0.0);
 472   user_load = MIN2&lt;double&gt;(user_load, 1.0);
 473 
 474   return user_load;
 475 }
 476 
 477 static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
 478   FILE *f;
 479   va_list args;
 480 
 481   va_start(args, fmt);
 482 
 483   if ((f = open_statfile()) == NULL) {
 484     va_end(args);
 485     return OS_ERR;
 486   }
 487   for (;;) {
 488     char line[80];
 489     if (fgets(line, sizeof(line), f) != NULL) {
 490       if (vsscanf(line, fmt, args) == 1) {
 491         fclose(f);
 492         va_end(args);
 493         return OS_OK;
 494       }
 495     } else {
 496         fclose(f);
 497         va_end(args);
 498         return OS_ERR;
 499     }
 500   }
 501 }
 502 
 503 static int get_noof_context_switches(uint64_t* switches) {
 504   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 505 }
 506 
 507 /** returns boot time in _seconds_ since epoch */
 508 static int get_boot_time(uint64_t* time) {
 509   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 510 }
 511 
 512 static int perf_context_switch_rate(double* rate) {
 513   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<a name="10" id="anc10"></a><span class="line-modified"> 514   static uint64_t      lastTime;</span>

 515   static uint64_t      lastSwitches;
 516   static double        lastRate;
 517 
<a name="11" id="anc11"></a><span class="line-modified"> 518   uint64_t lt = 0;</span>
 519   int res = 0;
 520 
<a name="12" id="anc12"></a><span class="line-modified"> 521   if (lastTime == 0) {</span>

 522     uint64_t tmp;
 523     if (get_boot_time(&amp;tmp) &lt; 0) {
 524       return OS_ERR;
 525     }
<a name="13" id="anc13"></a><span class="line-modified"> 526     lt = tmp * 1000;</span>
 527   }
 528 
 529   res = OS_OK;
 530 
 531   pthread_mutex_lock(&amp;contextSwitchLock);
 532   {
 533 
 534     uint64_t sw;
 535     s8 t, d;
 536 
<a name="14" id="anc14"></a><span class="line-modified"> 537     if (lastTime == 0) {</span>
<span class="line-modified"> 538       lastTime = lt;</span>










 539     }
 540 
<a name="15" id="anc15"></a><span class="line-removed"> 541     t = os::javaTimeMillis();</span>
<span class="line-removed"> 542     d = t - lastTime;</span>
<span class="line-removed"> 543 </span>
 544     if (d == 0) {
 545       *rate = lastRate;
<a name="16" id="anc16"></a><span class="line-modified"> 546     } else if (!get_noof_context_switches(&amp;sw)) {</span>
 547       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 548       lastRate     = *rate;
 549       lastSwitches = sw;
<a name="17" id="anc17"></a><span class="line-modified"> 550       lastTime     = t;</span>


 551     } else {
 552       *rate = 0;
 553       res   = OS_ERR;
 554     }
 555     if (*rate &lt;= 0) {
 556       *rate = 0;
 557       lastRate = 0;
 558     }
<a name="18" id="anc18"></a>



 559   }
 560   pthread_mutex_unlock(&amp;contextSwitchLock);
 561 
 562   return res;
 563 }
 564 
 565 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 566   friend class CPUPerformanceInterface;
 567  private:
 568   CPUPerfCounters _counters;
 569 
 570   int cpu_load(int which_logical_cpu, double* cpu_load);
 571   int context_switch_rate(double* rate);
 572   int cpu_load_total_process(double* cpu_load);
 573   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 574 
 575  public:
 576   CPUPerformance();
 577   bool initialize();
 578   ~CPUPerformance();
 579 };
 580 
 581 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 582   _counters.nProcs = os::active_processor_count();
 583   _counters.cpus = NULL;
 584 }
 585 
 586 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<a name="19" id="anc19"></a><span class="line-modified"> 587   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="line-modified"> 588   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified"> 589   if (NULL == _counters.cpus) {</span>
<span class="line-removed"> 590     return false;</span>
<span class="line-removed"> 591   }</span>
<span class="line-removed"> 592   memset(_counters.cpus, 0, tick_array_size);</span>
 593 
 594   // For the CPU load total
<a name="20" id="anc20"></a><span class="line-modified"> 595   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);</span>
 596 
 597   // For each CPU
 598   for (int i = 0; i &lt; _counters.nProcs; i++) {
<a name="21" id="anc21"></a><span class="line-modified"> 599     get_total_ticks(i, &amp;_counters.cpus[i]);</span>
 600   }
 601   // For JVM load
 602   get_jvm_ticks(&amp;_counters.jvmTicks);
 603 
 604   // initialize context switch system
 605   // the double is only for init
 606   double init_ctx_switch_rate;
 607   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 608 
 609   return true;
 610 }
 611 
 612 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
 613   if (_counters.cpus != NULL) {
 614     FREE_C_HEAP_ARRAY(char, _counters.cpus);
 615   }
 616 }
 617 
 618 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
 619   double u, s;
 620   u = get_cpu_load(which_logical_cpu, &amp;_counters, &amp;s, CPU_LOAD_GLOBAL);
 621   if (u &lt; 0) {
 622     *cpu_load = 0.0;
 623     return OS_ERR;
 624   }
 625   // Cap total systemload to 1.0
 626   *cpu_load = MIN2&lt;double&gt;((u + s), 1.0);
 627   return OS_OK;
 628 }
 629 
 630 int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
 631   double u, s;
 632   u = get_cpu_load(-1, &amp;_counters, &amp;s, CPU_LOAD_VM_ONLY);
 633   if (u &lt; 0) {
 634     *cpu_load = 0.0;
 635     return OS_ERR;
 636   }
 637   *cpu_load = u + s;
 638   return OS_OK;
 639 }
 640 
 641 int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) {
 642   double u, s, t;
 643 
 644   assert(pjvmUserLoad != NULL, &quot;pjvmUserLoad not inited&quot;);
 645   assert(pjvmKernelLoad != NULL, &quot;pjvmKernelLoad not inited&quot;);
 646   assert(psystemTotalLoad != NULL, &quot;psystemTotalLoad not inited&quot;);
 647 
 648   u = get_cpu_load(-1, &amp;_counters, &amp;s, CPU_LOAD_VM_ONLY);
 649   if (u &lt; 0) {
 650     *pjvmUserLoad = 0.0;
 651     *pjvmKernelLoad = 0.0;
 652     *psystemTotalLoad = 0.0;
 653     return OS_ERR;
 654   }
 655 
 656   cpu_load(-1, &amp;t);
 657   // clamp at user+system and 1.0
 658   if (u + s &gt; t) {
 659     t = MIN2&lt;double&gt;(u + s, 1.0);
 660   }
 661 
 662   *pjvmUserLoad = u;
 663   *pjvmKernelLoad = s;
 664   *psystemTotalLoad = t;
 665 
 666   return OS_OK;
 667 }
 668 
 669 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 670   return perf_context_switch_rate(rate);
 671 }
 672 
 673 CPUPerformanceInterface::CPUPerformanceInterface() {
 674   _impl = NULL;
 675 }
 676 
 677 bool CPUPerformanceInterface::initialize() {
 678   _impl = new CPUPerformanceInterface::CPUPerformance();
<a name="22" id="anc22"></a><span class="line-modified"> 679   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 680 }
 681 
 682 CPUPerformanceInterface::~CPUPerformanceInterface() {
 683   if (_impl != NULL) {
 684     delete _impl;
 685   }
 686 }
 687 
 688 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 689   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 690 }
 691 
 692 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 693   return _impl-&gt;cpu_load_total_process(cpu_load);
 694 }
 695 
 696 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 697   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 698 }
 699 
 700 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
 701   return _impl-&gt;context_switch_rate(rate);
 702 }
 703 
 704 class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {
 705   friend class SystemProcessInterface;
 706  private:
 707   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {
 708     friend class SystemProcessInterface::SystemProcesses;
 709    private:
 710     DIR*           _dir;
 711     struct dirent* _entry;
 712     bool           _valid;
 713     char           _exeName[PATH_MAX];
 714     char           _exePath[PATH_MAX];
 715 
 716     ProcessIterator();
 717     ~ProcessIterator();
 718     bool initialize();
 719 
 720     bool is_valid() const { return _valid; }
 721     bool is_valid_entry(struct dirent* entry) const;
 722     bool is_dir(const char* name) const;
 723     int  fsize(const char* name, uint64_t&amp; size) const;
 724 
 725     char* allocate_string(const char* str) const;
 726     void  get_exe_name();
 727     char* get_exe_path();
 728     char* get_cmdline();
 729 
 730     int current(SystemProcess* process_info);
 731     int next_process();
 732   };
 733 
 734   ProcessIterator* _iterator;
 735   SystemProcesses();
 736   bool initialize();
 737   ~SystemProcesses();
 738 
 739   //information about system processes
 740   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;
 741 };
 742 
 743 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {
 744   struct stat mystat;
 745   int ret_val = 0;
 746 
 747   ret_val = stat(name, &amp;mystat);
 748   if (ret_val &lt; 0) {
 749     return false;
 750   }
 751   ret_val = S_ISDIR(mystat.st_mode);
 752   return ret_val &gt; 0;
 753 }
 754 
 755 int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t&amp; size) const {
 756   assert(name != NULL, &quot;name pointer is NULL!&quot;);
 757   size = 0;
 758   struct stat fbuf;
 759 
 760   if (stat(name, &amp;fbuf) &lt; 0) {
 761     return OS_ERR;
 762   }
 763   size = fbuf.st_size;
 764   return OS_OK;
 765 }
 766 
 767 // if it has a numeric name, is a directory and has a &#39;stat&#39; file in it
 768 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {
 769   char buffer[PATH_MAX];
 770   uint64_t size = 0;
 771 
 772   if (atoi(entry-&gt;d_name) != 0) {
 773     jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s&quot;, entry-&gt;d_name);
 774     buffer[PATH_MAX - 1] = &#39;\0&#39;;
 775 
 776     if (is_dir(buffer)) {
 777       jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/stat&quot;, entry-&gt;d_name);
 778       buffer[PATH_MAX - 1] = &#39;\0&#39;;
 779       if (fsize(buffer, size) != OS_ERR) {
 780         return true;
 781       }
 782     }
 783   }
 784   return false;
 785 }
 786 
 787 // get exe-name from /proc/&lt;pid&gt;/stat
 788 void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {
 789   FILE* fp;
 790   char  buffer[PATH_MAX];
 791 
 792   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/stat&quot;, _entry-&gt;d_name);
 793   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 794   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 795     if (fgets(buffer, PATH_MAX, fp) != NULL) {
 796       char* start, *end;
 797       // exe-name is between the first pair of ( and )
 798       start = strchr(buffer, &#39;(&#39;);
 799       if (start != NULL &amp;&amp; start[1] != &#39;\0&#39;) {
 800         start++;
 801         end = strrchr(start, &#39;)&#39;);
 802         if (end != NULL) {
 803           size_t len;
 804           len = MIN2&lt;size_t&gt;(end - start, sizeof(_exeName) - 1);
 805           memcpy(_exeName, start, len);
 806           _exeName[len] = &#39;\0&#39;;
 807         }
 808       }
 809     }
 810     fclose(fp);
 811   }
 812 }
 813 
 814 // get command line from /proc/&lt;pid&gt;/cmdline
 815 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 816   FILE* fp;
 817   char  buffer[PATH_MAX];
 818   char* cmdline = NULL;
 819 
 820   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 821   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 822   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 823     size_t size = 0;
 824     char   dummy;
 825 
 826     // find out how long the file is (stat always returns 0)
 827     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 828       size++;
 829     }
 830     if (size &gt; 0) {
 831       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<a name="23" id="anc23"></a><span class="line-modified"> 832       if (cmdline != NULL) {</span>
<span class="line-modified"> 833         cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 834         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 835           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 836             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 837             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 838             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 839               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-removed"> 840                 cmdline[i] = &#39; &#39;;</span>
<span class="line-removed"> 841               }</span>
 842             }
<a name="24" id="anc24"></a><span class="line-removed"> 843             cmdline[size] = &#39;\0&#39;;</span>
 844           }
<a name="25" id="anc25"></a>
 845         }
 846       }
 847     }
 848     fclose(fp);
 849   }
 850   return cmdline;
 851 }
 852 
 853 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 854 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 855   char buffer[PATH_MAX];
 856 
 857   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 858   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 859   return realpath(buffer, _exePath);
 860 }
 861 
 862 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 863   if (str != NULL) {
 864     return os::strdup_check_oom(str, mtInternal);
 865   }
 866   return NULL;
 867 }
 868 
 869 int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {
 870   if (!is_valid()) {
 871     return OS_ERR;
 872   }
 873 
 874   process_info-&gt;set_pid(atoi(_entry-&gt;d_name));
 875 
 876   get_exe_name();
 877   process_info-&gt;set_name(allocate_string(_exeName));
 878 
 879   if (get_exe_path() != NULL) {
 880      process_info-&gt;set_path(allocate_string(_exePath));
 881   }
 882 
 883   char* cmdline = NULL;
 884   cmdline = get_cmdline();
 885   if (cmdline != NULL) {
 886     process_info-&gt;set_command_line(allocate_string(cmdline));
 887     FREE_C_HEAP_ARRAY(char, cmdline);
 888   }
 889 
 890   return OS_OK;
 891 }
 892 
 893 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
 894   if (!is_valid()) {
 895     return OS_ERR;
 896   }
 897 
 898   do {
 899     _entry = os::readdir(_dir);
 900     if (_entry == NULL) {
 901       // Error or reached end.  Could use errno to distinguish those cases.
 902       _valid = false;
 903       return OS_ERR;
 904     }
 905   } while(!is_valid_entry(_entry));
 906 
 907   _valid = true;
 908   return OS_OK;
 909 }
 910 
 911 SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
 912   _dir = NULL;
 913   _entry = NULL;
 914   _valid = false;
 915 }
 916 
 917 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
 918   _dir = os::opendir(&quot;/proc&quot;);
 919   _entry = NULL;
 920   _valid = true;
 921   next_process();
 922 
 923   return true;
 924 }
 925 
 926 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 927   if (_dir != NULL) {
 928     os::closedir(_dir);
 929   }
 930 }
 931 
 932 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 933   _iterator = NULL;
 934 }
 935 
 936 bool SystemProcessInterface::SystemProcesses::initialize() {
 937   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<a name="26" id="anc26"></a><span class="line-modified"> 938   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
 939 }
 940 
 941 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 942   if (_iterator != NULL) {
 943     delete _iterator;
 944   }
 945 }
 946 
 947 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 948   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 949   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 950   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 951 
 952   // initialize pointers
 953   *no_of_sys_processes = 0;
 954   *system_processes = NULL;
 955 
 956   while (_iterator-&gt;is_valid()) {
 957     SystemProcess* tmp = new SystemProcess();
 958     _iterator-&gt;current(tmp);
 959 
 960     //if already existing head
 961     if (*system_processes != NULL) {
 962       //move &quot;first to second&quot;
 963       tmp-&gt;set_next(*system_processes);
 964     }
 965     // new head
 966     *system_processes = tmp;
 967     // increment
 968     (*no_of_sys_processes)++;
 969     // step forward
 970     _iterator-&gt;next_process();
 971   }
 972   return OS_OK;
 973 }
 974 
 975 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 976   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 977 }
 978 
 979 SystemProcessInterface::SystemProcessInterface() {
 980   _impl = NULL;
 981 }
 982 
 983 bool SystemProcessInterface::initialize() {
 984   _impl = new SystemProcessInterface::SystemProcesses();
<a name="27" id="anc27"></a><span class="line-modified"> 985   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 986 }
 987 
 988 SystemProcessInterface::~SystemProcessInterface() {
 989   if (_impl != NULL) {
 990     delete _impl;
 991   }
 992 }
 993 
 994 CPUInformationInterface::CPUInformationInterface() {
 995   _cpu_info = NULL;
 996 }
 997 
 998 bool CPUInformationInterface::initialize() {
 999   _cpu_info = new CPUInformation();
<a name="28" id="anc28"></a><span class="line-removed">1000   if (NULL == _cpu_info) {</span>
<span class="line-removed">1001     return false;</span>
<span class="line-removed">1002   }</span>
1003   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1004   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1005   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1006   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1007   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<a name="29" id="anc29"></a><span class="line-removed">1008 </span>
1009   return true;
1010 }
1011 
1012 CPUInformationInterface::~CPUInformationInterface() {
1013   if (_cpu_info != NULL) {
1014     if (_cpu_info-&gt;cpu_name() != NULL) {
1015       const char* cpu_name = _cpu_info-&gt;cpu_name();
1016       FREE_C_HEAP_ARRAY(char, cpu_name);
1017       _cpu_info-&gt;set_cpu_name(NULL);
1018     }
1019     if (_cpu_info-&gt;cpu_description() != NULL) {
1020        const char* cpu_desc = _cpu_info-&gt;cpu_description();
1021        FREE_C_HEAP_ARRAY(char, cpu_desc);
1022       _cpu_info-&gt;set_cpu_description(NULL);
1023     }
1024     delete _cpu_info;
1025   }
1026 }
1027 
1028 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1029   if (_cpu_info == NULL) {
1030     return OS_ERR;
1031   }
1032 
1033   cpu_info = *_cpu_info; // shallow copy assignment
1034   return OS_OK;
1035 }
1036 
1037 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1038   friend class NetworkPerformanceInterface;
1039  private:
1040   NetworkPerformance();
<a name="30" id="anc30"></a><span class="line-modified">1041   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">1042   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
1043   bool initialize();
1044   ~NetworkPerformance();
1045   int64_t read_counter(const char* iface, const char* counter) const;
1046   int network_utilization(NetworkInterface** network_interfaces) const;
1047 };
1048 
1049 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
1050 
1051 }
1052 
1053 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1054   return true;
1055 }
1056 
1057 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1058 }
1059 
1060 int64_t NetworkPerformanceInterface::NetworkPerformance::read_counter(const char* iface, const char* counter) const {
1061   char buf[128];
1062 
1063   snprintf(buf, sizeof(buf), &quot;/sys/class/net/%s/statistics/%s&quot;, iface, counter);
1064 
1065   int fd = os::open(buf, O_RDONLY, 0);
1066   if (fd == -1) {
1067     return -1;
1068   }
1069 
1070   ssize_t num_bytes = read(fd, buf, sizeof(buf));
1071   close(fd);
1072   if ((num_bytes == -1) || (num_bytes &gt;= static_cast&lt;ssize_t&gt;(sizeof(buf))) || (num_bytes &lt; 1)) {
1073     return -1;
1074   }
1075 
1076   buf[num_bytes] = &#39;\0&#39;;
1077   int64_t value = strtoll(buf, NULL, 10);
1078 
1079   return value;
1080 }
1081 
1082 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
1083 {
1084   ifaddrs* addresses;
1085   ifaddrs* cur_address;
1086 
1087   if (getifaddrs(&amp;addresses) != 0) {
1088     return OS_ERR;
1089   }
1090 
1091   NetworkInterface* ret = NULL;
1092   for (cur_address = addresses; cur_address != NULL; cur_address = cur_address-&gt;ifa_next) {
1093     if ((cur_address-&gt;ifa_addr == NULL) || (cur_address-&gt;ifa_addr-&gt;sa_family != AF_PACKET)) {
1094       continue;
1095     }
1096 
1097     int64_t bytes_in = read_counter(cur_address-&gt;ifa_name, &quot;rx_bytes&quot;);
1098     int64_t bytes_out = read_counter(cur_address-&gt;ifa_name, &quot;tx_bytes&quot;);
1099 
1100     NetworkInterface* cur = new NetworkInterface(cur_address-&gt;ifa_name, bytes_in, bytes_out, ret);
1101     ret = cur;
1102   }
1103 
1104   freeifaddrs(addresses);
1105   *network_interfaces = ret;
1106 
1107   return OS_OK;
1108 }
1109 
1110 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1111   _impl = NULL;
1112 }
1113 
1114 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1115   if (_impl != NULL) {
1116     delete _impl;
1117   }
1118 }
1119 
1120 bool NetworkPerformanceInterface::initialize() {
1121   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<a name="31" id="anc31"></a><span class="line-modified">1122   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1123 }
1124 
1125 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1126   return _impl-&gt;network_utilization(network_interfaces);
1127 }
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/perfMemory_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/perfMemory_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 612 
 613         // don&#39;t follow symbolic links for the file
 614         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 615         if (result == OS_ERR) {
 616            FREE_C_HEAP_ARRAY(char, filename);
 617            continue;
 618         }
 619 
 620         // skip over files that are not regular files.
 621         if (!S_ISREG(statbuf.st_mode)) {
 622           FREE_C_HEAP_ARRAY(char, filename);
 623           continue;
 624         }
 625 
 626         // compare and save filename with latest creation time
 627         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 628 
 629           if (statbuf.st_ctime &gt; oldest_ctime) {
 630             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 631 
<span class="line-modified"> 632             if (oldest_user != NULL) FREE_C_HEAP_ARRAY(char, oldest_user);</span>
 633             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 634 
 635             strcpy(oldest_user, user);
 636             oldest_ctime = statbuf.st_ctime;
 637           }
 638         }
 639 
 640         FREE_C_HEAP_ARRAY(char, filename);
 641       }
 642     }
 643     os::closedir(subdirp);
 644     FREE_C_HEAP_ARRAY(char, usrdir_name);
 645   }
 646   os::closedir(tmpdirp);
 647 
 648   return(oldest_user);
 649 }
 650 
 651 // Determine if the vmid is the parent pid
 652 // for a child in a PID namespace.
 653 // return the namespace pid if so, otherwise -1
 654 static int get_namespace_pid(int vmid) {
 655   char fname[24];
 656   int retpid = -1;
 657 
 658   snprintf(fname, sizeof(fname), &quot;/proc/%d/status&quot;, vmid);
 659   FILE *fp = fopen(fname, &quot;r&quot;);
 660 
 661   if (fp) {
 662     int pid, nspid;
 663     int ret;
<span class="line-modified"> 664     while (!feof(fp)) {</span>
 665       ret = fscanf(fp, &quot;NSpid: %d %d&quot;, &amp;pid, &amp;nspid);
 666       if (ret == 1) {
 667         break;
 668       }
 669       if (ret == 2) {
 670         retpid = nspid;
 671         break;
 672       }
 673       for (;;) {
 674         int ch = fgetc(fp);
 675         if (ch == EOF || ch == (int)&#39;\n&#39;) break;
 676       }
 677     }
 678     fclose(fp);
 679   }
 680   return retpid;
 681 }
 682 
 683 // return the name of the user that owns the JVM indicated by the given vmid.
 684 //
</pre>
<hr />
<pre>
1090 
1091 // return the size of the file for the given file descriptor
1092 // or 0 if it is not a valid size for a shared memory file
1093 //
1094 static size_t sharedmem_filesize(int fd, TRAPS) {
1095 
1096   struct stat statbuf;
1097   int result;
1098 
1099   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1100   if (result == OS_ERR) {
1101     if (PrintMiscellaneous &amp;&amp; Verbose) {
1102       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1103     }
1104     THROW_MSG_0(vmSymbols::java_io_IOException(),
1105                 &quot;Could not determine PerfMemory size&quot;);
1106   }
1107 
1108   if ((statbuf.st_size == 0) ||
1109      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
<span class="line-modified">1110     THROW_MSG_0(vmSymbols::java_lang_Exception(),</span>
1111                 &quot;Invalid PerfMemory size&quot;);
1112   }
1113 
1114   return (size_t)statbuf.st_size;
1115 }
1116 
1117 // attach to a named shared memory region.
1118 //
1119 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1120 
1121   char* mapAddress;
1122   int result;
1123   int fd;
1124   size_t size = 0;
1125   const char* luser = NULL;
1126 
1127   int mmap_prot;
1128   int file_flags;
1129 
1130   ResourceMark rm;
</pre>
</td>
<td>
<hr />
<pre>
 612 
 613         // don&#39;t follow symbolic links for the file
 614         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 615         if (result == OS_ERR) {
 616            FREE_C_HEAP_ARRAY(char, filename);
 617            continue;
 618         }
 619 
 620         // skip over files that are not regular files.
 621         if (!S_ISREG(statbuf.st_mode)) {
 622           FREE_C_HEAP_ARRAY(char, filename);
 623           continue;
 624         }
 625 
 626         // compare and save filename with latest creation time
 627         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 628 
 629           if (statbuf.st_ctime &gt; oldest_ctime) {
 630             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 631 
<span class="line-modified"> 632             FREE_C_HEAP_ARRAY(char, oldest_user);</span>
 633             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 634 
 635             strcpy(oldest_user, user);
 636             oldest_ctime = statbuf.st_ctime;
 637           }
 638         }
 639 
 640         FREE_C_HEAP_ARRAY(char, filename);
 641       }
 642     }
 643     os::closedir(subdirp);
 644     FREE_C_HEAP_ARRAY(char, usrdir_name);
 645   }
 646   os::closedir(tmpdirp);
 647 
 648   return(oldest_user);
 649 }
 650 
 651 // Determine if the vmid is the parent pid
 652 // for a child in a PID namespace.
 653 // return the namespace pid if so, otherwise -1
 654 static int get_namespace_pid(int vmid) {
 655   char fname[24];
 656   int retpid = -1;
 657 
 658   snprintf(fname, sizeof(fname), &quot;/proc/%d/status&quot;, vmid);
 659   FILE *fp = fopen(fname, &quot;r&quot;);
 660 
 661   if (fp) {
 662     int pid, nspid;
 663     int ret;
<span class="line-modified"> 664     while (!feof(fp) &amp;&amp; !ferror(fp)) {</span>
 665       ret = fscanf(fp, &quot;NSpid: %d %d&quot;, &amp;pid, &amp;nspid);
 666       if (ret == 1) {
 667         break;
 668       }
 669       if (ret == 2) {
 670         retpid = nspid;
 671         break;
 672       }
 673       for (;;) {
 674         int ch = fgetc(fp);
 675         if (ch == EOF || ch == (int)&#39;\n&#39;) break;
 676       }
 677     }
 678     fclose(fp);
 679   }
 680   return retpid;
 681 }
 682 
 683 // return the name of the user that owns the JVM indicated by the given vmid.
 684 //
</pre>
<hr />
<pre>
1090 
1091 // return the size of the file for the given file descriptor
1092 // or 0 if it is not a valid size for a shared memory file
1093 //
1094 static size_t sharedmem_filesize(int fd, TRAPS) {
1095 
1096   struct stat statbuf;
1097   int result;
1098 
1099   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1100   if (result == OS_ERR) {
1101     if (PrintMiscellaneous &amp;&amp; Verbose) {
1102       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1103     }
1104     THROW_MSG_0(vmSymbols::java_io_IOException(),
1105                 &quot;Could not determine PerfMemory size&quot;);
1106   }
1107 
1108   if ((statbuf.st_size == 0) ||
1109      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
<span class="line-modified">1110     THROW_MSG_0(vmSymbols::java_io_IOException(),</span>
1111                 &quot;Invalid PerfMemory size&quot;);
1112   }
1113 
1114   return (size_t)statbuf.st_size;
1115 }
1116 
1117 // attach to a named shared memory region.
1118 //
1119 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1120 
1121   char* mapAddress;
1122   int result;
1123   int fd;
1124   size_t size = 0;
1125   const char* luser = NULL;
1126 
1127   int mmap_prot;
1128   int file_flags;
1129 
1130   ResourceMark rm;
</pre>
</td>
</tr>
</table>
<center><a href="os_perf_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
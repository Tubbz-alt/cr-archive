<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/linux/cgroupV1Subsystem_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &lt;string.h&gt;
 26 #include &lt;math.h&gt;
 27 #include &lt;errno.h&gt;
 28 #include &quot;cgroupV1Subsystem_linux.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;runtime/globals.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 /*
 36  * Set directory to subsystem specific files based
 37  * on the contents of the mountinfo and cgroup files.
 38  */
 39 void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {
 40   char buf[MAXPATHLEN+1];
 41   if (_root != NULL &amp;&amp; cgroup_path != NULL) {
 42     if (strcmp(_root, &quot;/&quot;) == 0) {
 43       int buflen;
 44       strncpy(buf, _mount_point, MAXPATHLEN);
 45       buf[MAXPATHLEN-1] = &#39;\0&#39;;
 46       if (strcmp(cgroup_path,&quot;/&quot;) != 0) {
 47         buflen = strlen(buf);
 48         if ((buflen + strlen(cgroup_path)) &gt; (MAXPATHLEN-1)) {
 49           return;
 50         }
 51         strncat(buf, cgroup_path, MAXPATHLEN-buflen);
 52         buf[MAXPATHLEN-1] = &#39;\0&#39;;
 53       }
 54       _path = os::strdup(buf);
 55     } else {
 56       if (strcmp(_root, cgroup_path) == 0) {
 57         strncpy(buf, _mount_point, MAXPATHLEN);
 58         buf[MAXPATHLEN-1] = &#39;\0&#39;;
 59         _path = os::strdup(buf);
 60       } else {
 61         char *p = strstr(cgroup_path, _root);
 62         if (p != NULL &amp;&amp; p == _root) {
 63           if (strlen(cgroup_path) &gt; strlen(_root)) {
 64             int buflen;
 65             strncpy(buf, _mount_point, MAXPATHLEN);
 66             buf[MAXPATHLEN-1] = &#39;\0&#39;;
 67             buflen = strlen(buf);
 68             if ((buflen + strlen(cgroup_path) - strlen(_root)) &gt; (MAXPATHLEN-1)) {
 69               return;
 70             }
 71             strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);
 72             buf[MAXPATHLEN-1] = &#39;\0&#39;;
 73             _path = os::strdup(buf);
 74           }
 75         }
 76       }
 77     }
 78   }
 79 }
 80 
 81 /* uses_mem_hierarchy
 82  *
 83  * Return whether or not hierarchical cgroup accounting is being
 84  * done.
 85  *
 86  * return:
 87  *    A number &gt; 0 if true, or
 88  *    OSCONTAINER_ERROR for not supported
 89  */
 90 jlong CgroupV1MemoryController::uses_mem_hierarchy() {
 91   GET_CONTAINER_INFO(jlong, this, &quot;/memory.use_hierarchy&quot;,
 92                     &quot;Use Hierarchy is: &quot; JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);
 93   return use_hierarchy;
 94 }
 95 
 96 void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {
 97   CgroupV1Controller::set_subsystem_path(cgroup_path);
 98   jlong hierarchy = uses_mem_hierarchy();
 99   if (hierarchy &gt; 0) {
100     set_hierarchical(true);
101   }
102 }
103 
104 jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {
105   GET_CONTAINER_INFO(julong, _memory-&gt;controller(), &quot;/memory.limit_in_bytes&quot;,
106                      &quot;Memory Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memlimit);
107 
108   if (memlimit &gt;= _unlimited_memory) {
109     log_trace(os, container)(&quot;Non-Hierarchical Memory Limit is: Unlimited&quot;);
110     CgroupV1MemoryController* mem_controller = reinterpret_cast&lt;CgroupV1MemoryController*&gt;(_memory-&gt;controller());
111     if (mem_controller-&gt;is_hierarchical()) {
112       const char* matchline = &quot;hierarchical_memory_limit&quot;;
113       const char* format = &quot;%s &quot; JULONG_FORMAT;
114       GET_CONTAINER_INFO_LINE(julong, _memory-&gt;controller(), &quot;/memory.stat&quot;, matchline,
115                              &quot;Hierarchical Memory Limit is: &quot; JULONG_FORMAT, format, hier_memlimit)
116       if (hier_memlimit &gt;= _unlimited_memory) {
117         log_trace(os, container)(&quot;Hierarchical Memory Limit is: Unlimited&quot;);
118       } else {
119         return (jlong)hier_memlimit;
120       }
121     }
122     return (jlong)-1;
123   }
124   else {
125     return (jlong)memlimit;
126   }
127 }
128 
129 jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {
130   GET_CONTAINER_INFO(julong, _memory-&gt;controller(), &quot;/memory.memsw.limit_in_bytes&quot;,
131                      &quot;Memory and Swap Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memswlimit);
132   if (memswlimit &gt;= _unlimited_memory) {
133     log_trace(os, container)(&quot;Non-Hierarchical Memory and Swap Limit is: Unlimited&quot;);
134     CgroupV1MemoryController* mem_controller = reinterpret_cast&lt;CgroupV1MemoryController*&gt;(_memory-&gt;controller());
135     if (mem_controller-&gt;is_hierarchical()) {
136       const char* matchline = &quot;hierarchical_memsw_limit&quot;;
137       const char* format = &quot;%s &quot; JULONG_FORMAT;
138       GET_CONTAINER_INFO_LINE(julong, _memory-&gt;controller(), &quot;/memory.stat&quot;, matchline,
139                              &quot;Hierarchical Memory and Swap Limit is : &quot; JULONG_FORMAT, format, hier_memlimit)
140       if (hier_memlimit &gt;= _unlimited_memory) {
141         log_trace(os, container)(&quot;Hierarchical Memory and Swap Limit is: Unlimited&quot;);
142       } else {
143         return (jlong)hier_memlimit;
144       }
145     }
146     return (jlong)-1;
147   } else {
148     return (jlong)memswlimit;
149   }
150 }
151 
152 jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {
153   GET_CONTAINER_INFO(julong, _memory-&gt;controller(), &quot;/memory.soft_limit_in_bytes&quot;,
154                      &quot;Memory Soft Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);
155   if (memsoftlimit &gt;= _unlimited_memory) {
156     log_trace(os, container)(&quot;Memory Soft Limit is: Unlimited&quot;);
157     return (jlong)-1;
158   } else {
159     return (jlong)memsoftlimit;
160   }
161 }
162 
163 /* memory_usage_in_bytes
164  *
165  * Return the amount of used memory for this process.
166  *
167  * return:
168  *    memory usage in bytes or
169  *    -1 for unlimited
170  *    OSCONTAINER_ERROR for not supported
171  */
172 jlong CgroupV1Subsystem::memory_usage_in_bytes() {
173   GET_CONTAINER_INFO(jlong, _memory-&gt;controller(), &quot;/memory.usage_in_bytes&quot;,
174                      &quot;Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memusage);
175   return memusage;
176 }
177 
178 /* memory_max_usage_in_bytes
179  *
180  * Return the maximum amount of used memory for this process.
181  *
182  * return:
183  *    max memory usage in bytes or
184  *    OSCONTAINER_ERROR for not supported
185  */
186 jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {
187   GET_CONTAINER_INFO(jlong, _memory-&gt;controller(), &quot;/memory.max_usage_in_bytes&quot;,
188                      &quot;Maximum Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memmaxusage);
189   return memmaxusage;
190 }
191 
192 char * CgroupV1Subsystem::cpu_cpuset_cpus() {
193   GET_CONTAINER_INFO_CPTR(cptr, _cpuset, &quot;/cpuset.cpus&quot;,
194                      &quot;cpuset.cpus is: %s&quot;, &quot;%1023s&quot;, cpus, 1024);
195   return os::strdup(cpus);
196 }
197 
198 char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {
199   GET_CONTAINER_INFO_CPTR(cptr, _cpuset, &quot;/cpuset.mems&quot;,
200                      &quot;cpuset.mems is: %s&quot;, &quot;%1023s&quot;, mems, 1024);
201   return os::strdup(mems);
202 }
203 
204 /* cpu_quota
205  *
206  * Return the number of milliseconds per period
207  * process is guaranteed to run.
208  *
209  * return:
210  *    quota time in milliseconds
211  *    -1 for no quota
212  *    OSCONTAINER_ERROR for not supported
213  */
214 int CgroupV1Subsystem::cpu_quota() {
215   GET_CONTAINER_INFO(int, _cpu-&gt;controller(), &quot;/cpu.cfs_quota_us&quot;,
216                      &quot;CPU Quota is: %d&quot;, &quot;%d&quot;, quota);
217   return quota;
218 }
219 
220 int CgroupV1Subsystem::cpu_period() {
221   GET_CONTAINER_INFO(int, _cpu-&gt;controller(), &quot;/cpu.cfs_period_us&quot;,
222                      &quot;CPU Period is: %d&quot;, &quot;%d&quot;, period);
223   return period;
224 }
225 
226 /* cpu_shares
227  *
228  * Return the amount of cpu shares available to the process
229  *
230  * return:
231  *    Share number (typically a number relative to 1024)
232  *                 (2048 typically expresses 2 CPUs worth of processing)
233  *    -1 for no share setup
234  *    OSCONTAINER_ERROR for not supported
235  */
236 int CgroupV1Subsystem::cpu_shares() {
237   GET_CONTAINER_INFO(int, _cpu-&gt;controller(), &quot;/cpu.shares&quot;,
238                      &quot;CPU Shares is: %d&quot;, &quot;%d&quot;, shares);
239   // Convert 1024 to no shares setup
240   if (shares == 1024) return -1;
241 
242   return shares;
243 }
    </pre>
  </body>
</html>
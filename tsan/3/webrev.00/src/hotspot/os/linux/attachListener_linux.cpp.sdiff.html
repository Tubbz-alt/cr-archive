<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/attachListener_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd/semaphore_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/z/zLargePages_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/attachListener_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 52 // As the socket is a UNIX domain socket it means that only clients on the
 53 // local machine can connect. In addition there are two other aspects to
 54 // the security:
 55 // 1. The well known file that the socket is bound to has permission 400
 56 // 2. When a client connect, the SO_PEERCRED socket option is used to
 57 //    obtain the credentials of client. We check that the effective uid
 58 //    of the client matches this process.
 59 
 60 // forward reference
 61 class LinuxAttachOperation;
 62 
 63 class LinuxAttachListener: AllStatic {
 64  private:
 65   // the path to which we bind the UNIX domain socket
 66   static char _path[UNIX_PATH_MAX];
 67   static bool _has_path;
 68 
 69   // the file descriptor for the listening socket
 70   static int _listener;
 71 
<span class="line-modified"> 72   static void set_path(char* path) {</span>
<span class="line-removed"> 73     if (path == NULL) {</span>
<span class="line-removed"> 74       _has_path = false;</span>
<span class="line-removed"> 75     } else {</span>
<span class="line-removed"> 76       strncpy(_path, path, UNIX_PATH_MAX);</span>
<span class="line-removed"> 77       _path[UNIX_PATH_MAX-1] = &#39;\0&#39;;</span>
<span class="line-removed"> 78       _has_path = true;</span>
<span class="line-removed"> 79     }</span>
<span class="line-removed"> 80   }</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82   static void set_listener(int s)               { _listener = s; }</span>
 83 
 84   // reads a request from the given connected socket
 85   static LinuxAttachOperation* read_request(int s);
 86 
 87  public:
 88   enum {
 89     ATTACH_PROTOCOL_VER = 1                     // protocol version
 90   };
 91   enum {
 92     ATTACH_ERROR_BADVERSION     = 101           // error codes
 93   };
 94 













 95   // initialize the listener, returns 0 if okay
 96   static int init();
 97 
 98   static char* path()                   { return _path; }
 99   static bool has_path()                { return _has_path; }
100   static int listener()                 { return _listener; }
101 
102   // write the given buffer to a socket
103   static int write_fully(int s, char* buf, int len);
104 
105   static LinuxAttachOperation* dequeue();
106 };
107 
108 class LinuxAttachOperation: public AttachOperation {
109  private:
110   // the connection to the client
111   int _socket;
112 
113  public:
114   void complete(jint res, bufferedStream* st);
115 
116   void set_socket(int s)                                { _socket = s; }
117   int socket() const                                    { return _socket; }
118 
119   LinuxAttachOperation(char* name) : AttachOperation(name) {
120     set_socket(-1);
121   }
122 };
123 
124 // statics
125 char LinuxAttachListener::_path[UNIX_PATH_MAX];
126 bool LinuxAttachListener::_has_path;
127 int LinuxAttachListener::_listener = -1;

128 
129 // Supporting class to help split a buffer into individual components
130 class ArgumentIterator : public StackObj {
131  private:
132   char* _pos;
133   char* _end;
134  public:
135   ArgumentIterator(char* arg_buffer, size_t arg_size) {
136     _pos = arg_buffer;
137     _end = _pos + arg_size - 1;
138   }
139   char* next() {
140     if (*_pos == &#39;\0&#39;) {
141       // advance the iterator if possible (null arguments)
142       if (_pos &lt; _end) {
143         _pos += 1;
144       }
145       return NULL;
146     }
147     char* res = _pos;
148     char* next_pos = strchr(_pos, &#39;\0&#39;);
149     if (next_pos &lt; _end)  {
150       next_pos++;
151     }
152     _pos = next_pos;
153     return res;
154   }
155 };
156 
157 
158 // atexit hook to stop listener and unlink the file that it is
159 // bound too.
160 extern &quot;C&quot; {
161   static void listener_cleanup() {
<span class="line-modified">162     static int cleanup_done;</span>
<span class="line-modified">163     if (!cleanup_done) {</span>
<span class="line-modified">164       cleanup_done = 1;</span>
<span class="line-modified">165       int s = LinuxAttachListener::listener();</span>
<span class="line-modified">166       if (s != -1) {</span>
<span class="line-modified">167         ::close(s);</span>
<span class="line-modified">168       }</span>
<span class="line-modified">169       if (LinuxAttachListener::has_path()) {</span>
<span class="line-modified">170         ::unlink(LinuxAttachListener::path());</span>
<span class="line-removed">171       }</span>
172     }
173   }
174 }
175 
176 // Initialization - create a listener socket and bind it to a file
177 
178 int LinuxAttachListener::init() {
179   char path[UNIX_PATH_MAX];          // socket file
180   char initial_path[UNIX_PATH_MAX];  // socket file during setup
181   int listener;                      // listener socket (file descriptor)
182 
183   // register function to cleanup
<span class="line-modified">184   ::atexit(listener_cleanup);</span>



185 
186   int n = snprintf(path, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
187                    os::get_temp_directory(), os::current_process_id());
188   if (n &lt; (int)UNIX_PATH_MAX) {
189     n = snprintf(initial_path, UNIX_PATH_MAX, &quot;%s.tmp&quot;, path);
190   }
191   if (n &gt;= (int)UNIX_PATH_MAX) {
192     return -1;
193   }
194 
195   // create the listener socket
196   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
197   if (listener == -1) {
198     return -1;
199   }
200 
201   // bind socket
202   struct sockaddr_un addr;
203   memset((void *)&amp;addr, 0, sizeof(addr));
204   addr.sun_family = AF_UNIX;
</pre>
<hr />
<pre>
468     }
469   }
470 }
471 
472 int AttachListener::pd_init() {
473   JavaThread* thread = JavaThread::current();
474   ThreadBlockInVM tbivm(thread);
475 
476   thread-&gt;set_suspend_equivalent();
477   // cleared by handle_special_suspend_equivalent_condition() or
478   // java_suspend_self() via check_and_wait_while_suspended()
479 
480   int ret_code = LinuxAttachListener::init();
481 
482   // were we externally suspended while we were waiting?
483   thread-&gt;check_and_wait_while_suspended();
484 
485   return ret_code;
486 }
487 




















488 // Attach Listener is started lazily except in the case when
489 // +ReduseSignalUsage is used
490 bool AttachListener::init_at_startup() {
491   if (ReduceSignalUsage) {
492     return true;
493   } else {
494     return false;
495   }
496 }
497 
498 // If the file .attach_pid&lt;pid&gt; exists in the working directory
499 // or /tmp then this is the trigger to start the attach mechanism
500 bool AttachListener::is_init_trigger() {
501   if (init_at_startup() || is_initialized()) {
502     return false;               // initialized at startup or already initialized
503   }
504   char fn[PATH_MAX + 1];
505   int ret;
506   struct stat64 st;
507   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 52 // As the socket is a UNIX domain socket it means that only clients on the
 53 // local machine can connect. In addition there are two other aspects to
 54 // the security:
 55 // 1. The well known file that the socket is bound to has permission 400
 56 // 2. When a client connect, the SO_PEERCRED socket option is used to
 57 //    obtain the credentials of client. We check that the effective uid
 58 //    of the client matches this process.
 59 
 60 // forward reference
 61 class LinuxAttachOperation;
 62 
 63 class LinuxAttachListener: AllStatic {
 64  private:
 65   // the path to which we bind the UNIX domain socket
 66   static char _path[UNIX_PATH_MAX];
 67   static bool _has_path;
 68 
 69   // the file descriptor for the listening socket
 70   static int _listener;
 71 
<span class="line-modified"> 72   static bool _atexit_registered;</span>










 73 
 74   // reads a request from the given connected socket
 75   static LinuxAttachOperation* read_request(int s);
 76 
 77  public:
 78   enum {
 79     ATTACH_PROTOCOL_VER = 1                     // protocol version
 80   };
 81   enum {
 82     ATTACH_ERROR_BADVERSION     = 101           // error codes
 83   };
 84 
<span class="line-added"> 85   static void set_path(char* path) {</span>
<span class="line-added"> 86     if (path == NULL) {</span>
<span class="line-added"> 87       _path[0] = &#39;\0&#39;;</span>
<span class="line-added"> 88       _has_path = false;</span>
<span class="line-added"> 89     } else {</span>
<span class="line-added"> 90       strncpy(_path, path, UNIX_PATH_MAX);</span>
<span class="line-added"> 91       _path[UNIX_PATH_MAX-1] = &#39;\0&#39;;</span>
<span class="line-added"> 92       _has_path = true;</span>
<span class="line-added"> 93     }</span>
<span class="line-added"> 94   }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96   static void set_listener(int s)               { _listener = s; }</span>
<span class="line-added"> 97 </span>
 98   // initialize the listener, returns 0 if okay
 99   static int init();
100 
101   static char* path()                   { return _path; }
102   static bool has_path()                { return _has_path; }
103   static int listener()                 { return _listener; }
104 
105   // write the given buffer to a socket
106   static int write_fully(int s, char* buf, int len);
107 
108   static LinuxAttachOperation* dequeue();
109 };
110 
111 class LinuxAttachOperation: public AttachOperation {
112  private:
113   // the connection to the client
114   int _socket;
115 
116  public:
117   void complete(jint res, bufferedStream* st);
118 
119   void set_socket(int s)                                { _socket = s; }
120   int socket() const                                    { return _socket; }
121 
122   LinuxAttachOperation(char* name) : AttachOperation(name) {
123     set_socket(-1);
124   }
125 };
126 
127 // statics
128 char LinuxAttachListener::_path[UNIX_PATH_MAX];
129 bool LinuxAttachListener::_has_path;
130 int LinuxAttachListener::_listener = -1;
<span class="line-added">131 bool LinuxAttachListener::_atexit_registered = false;</span>
132 
133 // Supporting class to help split a buffer into individual components
134 class ArgumentIterator : public StackObj {
135  private:
136   char* _pos;
137   char* _end;
138  public:
139   ArgumentIterator(char* arg_buffer, size_t arg_size) {
140     _pos = arg_buffer;
141     _end = _pos + arg_size - 1;
142   }
143   char* next() {
144     if (*_pos == &#39;\0&#39;) {
145       // advance the iterator if possible (null arguments)
146       if (_pos &lt; _end) {
147         _pos += 1;
148       }
149       return NULL;
150     }
151     char* res = _pos;
152     char* next_pos = strchr(_pos, &#39;\0&#39;);
153     if (next_pos &lt; _end)  {
154       next_pos++;
155     }
156     _pos = next_pos;
157     return res;
158   }
159 };
160 
161 
162 // atexit hook to stop listener and unlink the file that it is
163 // bound too.
164 extern &quot;C&quot; {
165   static void listener_cleanup() {
<span class="line-modified">166     int s = LinuxAttachListener::listener();</span>
<span class="line-modified">167     if (s != -1) {</span>
<span class="line-modified">168       LinuxAttachListener::set_listener(-1);</span>
<span class="line-modified">169       ::shutdown(s, SHUT_RDWR);</span>
<span class="line-modified">170       ::close(s);</span>
<span class="line-modified">171     }</span>
<span class="line-modified">172     if (LinuxAttachListener::has_path()) {</span>
<span class="line-modified">173       ::unlink(LinuxAttachListener::path());</span>
<span class="line-modified">174       LinuxAttachListener::set_path(NULL);</span>

175     }
176   }
177 }
178 
179 // Initialization - create a listener socket and bind it to a file
180 
181 int LinuxAttachListener::init() {
182   char path[UNIX_PATH_MAX];          // socket file
183   char initial_path[UNIX_PATH_MAX];  // socket file during setup
184   int listener;                      // listener socket (file descriptor)
185 
186   // register function to cleanup
<span class="line-modified">187   if (!_atexit_registered) {</span>
<span class="line-added">188     _atexit_registered = true;</span>
<span class="line-added">189     ::atexit(listener_cleanup);</span>
<span class="line-added">190   }</span>
191 
192   int n = snprintf(path, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
193                    os::get_temp_directory(), os::current_process_id());
194   if (n &lt; (int)UNIX_PATH_MAX) {
195     n = snprintf(initial_path, UNIX_PATH_MAX, &quot;%s.tmp&quot;, path);
196   }
197   if (n &gt;= (int)UNIX_PATH_MAX) {
198     return -1;
199   }
200 
201   // create the listener socket
202   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
203   if (listener == -1) {
204     return -1;
205   }
206 
207   // bind socket
208   struct sockaddr_un addr;
209   memset((void *)&amp;addr, 0, sizeof(addr));
210   addr.sun_family = AF_UNIX;
</pre>
<hr />
<pre>
474     }
475   }
476 }
477 
478 int AttachListener::pd_init() {
479   JavaThread* thread = JavaThread::current();
480   ThreadBlockInVM tbivm(thread);
481 
482   thread-&gt;set_suspend_equivalent();
483   // cleared by handle_special_suspend_equivalent_condition() or
484   // java_suspend_self() via check_and_wait_while_suspended()
485 
486   int ret_code = LinuxAttachListener::init();
487 
488   // were we externally suspended while we were waiting?
489   thread-&gt;check_and_wait_while_suspended();
490 
491   return ret_code;
492 }
493 
<span class="line-added">494 bool AttachListener::check_socket_file() {</span>
<span class="line-added">495   int ret;</span>
<span class="line-added">496   struct stat64 st;</span>
<span class="line-added">497   ret = stat64(LinuxAttachListener::path(), &amp;st);</span>
<span class="line-added">498   if (ret == -1) { // need to restart attach listener.</span>
<span class="line-added">499     log_debug(attach)(&quot;Socket file %s does not exist - Restart Attach Listener&quot;,</span>
<span class="line-added">500                       LinuxAttachListener::path());</span>
<span class="line-added">501 </span>
<span class="line-added">502     listener_cleanup();</span>
<span class="line-added">503 </span>
<span class="line-added">504     // wait to terminate current attach listener instance...</span>
<span class="line-added">505     while (AttachListener::transit_state(AL_INITIALIZING,</span>
<span class="line-added">506                                          AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {</span>
<span class="line-added">507       os::naked_yield();</span>
<span class="line-added">508     }</span>
<span class="line-added">509     return is_init_trigger();</span>
<span class="line-added">510   }</span>
<span class="line-added">511   return false;</span>
<span class="line-added">512 }</span>
<span class="line-added">513 </span>
514 // Attach Listener is started lazily except in the case when
515 // +ReduseSignalUsage is used
516 bool AttachListener::init_at_startup() {
517   if (ReduceSignalUsage) {
518     return true;
519   } else {
520     return false;
521   }
522 }
523 
524 // If the file .attach_pid&lt;pid&gt; exists in the working directory
525 // or /tmp then this is the trigger to start the attach mechanism
526 bool AttachListener::is_init_trigger() {
527   if (init_at_startup() || is_initialized()) {
528     return false;               // initialized at startup or already initialized
529   }
530   char fn[PATH_MAX + 1];
531   int ret;
532   struct stat64 st;
533   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
</pre>
</td>
</tr>
</table>
<center><a href="../bsd/semaphore_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/z/zLargePages_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
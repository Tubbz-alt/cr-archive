<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/osContainer_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osContainer_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/osContainer_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &lt;string.h&gt;
 26 #include &lt;math.h&gt;
 27 #include &lt;errno.h&gt;
<span class="line-modified"> 28 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;memory/allocation.hpp&quot;</span>
 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;osContainer_linux.hpp&quot;

 33 
<span class="line-removed"> 34 /*</span>
<span class="line-removed"> 35  * PER_CPU_SHARES has been set to 1024 because CPU shares&#39; quota</span>
<span class="line-removed"> 36  * is commonly used in cloud frameworks like Kubernetes[1],</span>
<span class="line-removed"> 37  * AWS[2] and Mesos[3] in a similar way. They spawn containers with</span>
<span class="line-removed"> 38  * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do</span>
<span class="line-removed"> 39  * the inverse for determining the number of possible available</span>
<span class="line-removed"> 40  * CPUs to the JVM inside a container. See JDK-8216366.</span>
<span class="line-removed"> 41  *</span>
<span class="line-removed"> 42  * [1] https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-cpu</span>
<span class="line-removed"> 43  *     In particular:</span>
<span class="line-removed"> 44  *        When using Docker:</span>
<span class="line-removed"> 45  *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially</span>
<span class="line-removed"> 46  *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the</span>
<span class="line-removed"> 47  *          --cpu-shares flag in the docker run command.</span>
<span class="line-removed"> 48  * [2] https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html</span>
<span class="line-removed"> 49  * [3] https://github.com/apache/mesos/blob/3478e344fb77d931f6122980c6e94cd3913c441d/src/docker/docker.cpp#L648</span>
<span class="line-removed"> 50  *     https://github.com/apache/mesos/blob/3478e344fb77d931f6122980c6e94cd3913c441d/src/slave/containerizer/mesos/isolators/cgroups/constants.hpp#L30</span>
<span class="line-removed"> 51  */</span>
<span class="line-removed"> 52 #define PER_CPU_SHARES 1024</span>
 53 
 54 bool  OSContainer::_is_initialized   = false;
 55 bool  OSContainer::_is_containerized = false;
<span class="line-modified"> 56 julong _unlimited_memory;</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58 class CgroupSubsystem: CHeapObj&lt;mtInternal&gt; {</span>
<span class="line-removed"> 59  friend class OSContainer;</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61  private:</span>
<span class="line-removed"> 62     /* mountinfo contents */</span>
<span class="line-removed"> 63     char *_root;</span>
<span class="line-removed"> 64     char *_mount_point;</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66     /* Constructed subsystem directory */</span>
<span class="line-removed"> 67     char *_path;</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69  public:</span>
<span class="line-removed"> 70     CgroupSubsystem(char *root, char *mountpoint) {</span>
<span class="line-removed"> 71       _root = os::strdup(root);</span>
<span class="line-removed"> 72       _mount_point = os::strdup(mountpoint);</span>
<span class="line-removed"> 73       _path = NULL;</span>
<span class="line-removed"> 74     }</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76     /*</span>
<span class="line-removed"> 77      * Set directory to subsystem specific files based</span>
<span class="line-removed"> 78      * on the contents of the mountinfo and cgroup files.</span>
<span class="line-removed"> 79      */</span>
<span class="line-removed"> 80     void set_subsystem_path(char *cgroup_path) {</span>
<span class="line-removed"> 81       char buf[MAXPATHLEN+1];</span>
<span class="line-removed"> 82       if (_root != NULL &amp;&amp; cgroup_path != NULL) {</span>
<span class="line-removed"> 83         if (strcmp(_root, &quot;/&quot;) == 0) {</span>
<span class="line-removed"> 84           int buflen;</span>
<span class="line-removed"> 85           strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed"> 86           buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed"> 87           if (strcmp(cgroup_path,&quot;/&quot;) != 0) {</span>
<span class="line-removed"> 88             buflen = strlen(buf);</span>
<span class="line-removed"> 89             if ((buflen + strlen(cgroup_path)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed"> 90               return;</span>
<span class="line-removed"> 91             }</span>
<span class="line-removed"> 92             strncat(buf, cgroup_path, MAXPATHLEN-buflen);</span>
<span class="line-removed"> 93             buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed"> 94           }</span>
<span class="line-removed"> 95           _path = os::strdup(buf);</span>
<span class="line-removed"> 96         } else {</span>
<span class="line-removed"> 97           if (strcmp(_root, cgroup_path) == 0) {</span>
<span class="line-removed"> 98             strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed"> 99             buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">100             _path = os::strdup(buf);</span>
<span class="line-removed">101           } else {</span>
<span class="line-removed">102             char *p = strstr(_root, cgroup_path);</span>
<span class="line-removed">103             if (p != NULL &amp;&amp; p == _root) {</span>
<span class="line-removed">104               if (strlen(cgroup_path) &gt; strlen(_root)) {</span>
<span class="line-removed">105                 int buflen;</span>
<span class="line-removed">106                 strncpy(buf, _mount_point, MAXPATHLEN);</span>
<span class="line-removed">107                 buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">108                 buflen = strlen(buf);</span>
<span class="line-removed">109                 if ((buflen + strlen(cgroup_path)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed">110                   return;</span>
<span class="line-removed">111                 }</span>
<span class="line-removed">112                 strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);</span>
<span class="line-removed">113                 buf[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">114                 _path = os::strdup(buf);</span>
<span class="line-removed">115               }</span>
<span class="line-removed">116             }</span>
<span class="line-removed">117           }</span>
<span class="line-removed">118         }</span>
<span class="line-removed">119       }</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121 </span>
<span class="line-removed">122     char *subsystem_path() { return _path; }</span>
<span class="line-removed">123 };</span>
<span class="line-removed">124 </span>
<span class="line-removed">125 CgroupSubsystem* memory = NULL;</span>
<span class="line-removed">126 CgroupSubsystem* cpuset = NULL;</span>
<span class="line-removed">127 CgroupSubsystem* cpu = NULL;</span>
<span class="line-removed">128 CgroupSubsystem* cpuacct = NULL;</span>
<span class="line-removed">129 </span>
<span class="line-removed">130 typedef char * cptr;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132 PRAGMA_DIAG_PUSH</span>
<span class="line-removed">133 PRAGMA_FORMAT_NONLITERAL_IGNORED</span>
<span class="line-removed">134 template &lt;typename T&gt; int subsystem_file_contents(CgroupSubsystem* c,</span>
<span class="line-removed">135                                               const char *filename,</span>
<span class="line-removed">136                                               const char *scan_fmt,</span>
<span class="line-removed">137                                               T returnval) {</span>
<span class="line-removed">138   FILE *fp = NULL;</span>
<span class="line-removed">139   char *p;</span>
<span class="line-removed">140   char file[MAXPATHLEN+1];</span>
<span class="line-removed">141   char buf[MAXPATHLEN+1];</span>
<span class="line-removed">142 </span>
<span class="line-removed">143   if (c == NULL) {</span>
<span class="line-removed">144     log_debug(os, container)(&quot;subsystem_file_contents: CgroupSubsytem* is NULL&quot;);</span>
<span class="line-removed">145     return OSCONTAINER_ERROR;</span>
<span class="line-removed">146   }</span>
<span class="line-removed">147   if (c-&gt;subsystem_path() == NULL) {</span>
<span class="line-removed">148     log_debug(os, container)(&quot;subsystem_file_contents: subsystem path is NULL&quot;);</span>
<span class="line-removed">149     return OSCONTAINER_ERROR;</span>
<span class="line-removed">150   }</span>
<span class="line-removed">151 </span>
<span class="line-removed">152   strncpy(file, c-&gt;subsystem_path(), MAXPATHLEN);</span>
<span class="line-removed">153   file[MAXPATHLEN-1] = &#39;\0&#39;;</span>
<span class="line-removed">154   int filelen = strlen(file);</span>
<span class="line-removed">155   if ((filelen + strlen(filename)) &gt; (MAXPATHLEN-1)) {</span>
<span class="line-removed">156     log_debug(os, container)(&quot;File path too long %s, %s&quot;, file, filename);</span>
<span class="line-removed">157     return OSCONTAINER_ERROR;</span>
<span class="line-removed">158   }</span>
<span class="line-removed">159   strncat(file, filename, MAXPATHLEN-filelen);</span>
<span class="line-removed">160   log_trace(os, container)(&quot;Path to %s is %s&quot;, filename, file);</span>
<span class="line-removed">161   fp = fopen(file, &quot;r&quot;);</span>
<span class="line-removed">162   if (fp != NULL) {</span>
<span class="line-removed">163     p = fgets(buf, MAXPATHLEN, fp);</span>
<span class="line-removed">164     if (p != NULL) {</span>
<span class="line-removed">165       int matched = sscanf(p, scan_fmt, returnval);</span>
<span class="line-removed">166       if (matched == 1) {</span>
<span class="line-removed">167         fclose(fp);</span>
<span class="line-removed">168         return 0;</span>
<span class="line-removed">169       } else {</span>
<span class="line-removed">170         log_debug(os, container)(&quot;Type %s not found in file %s&quot;, scan_fmt, file);</span>
<span class="line-removed">171       }</span>
<span class="line-removed">172     } else {</span>
<span class="line-removed">173       log_debug(os, container)(&quot;Empty file %s&quot;, file);</span>
<span class="line-removed">174     }</span>
<span class="line-removed">175   } else {</span>
<span class="line-removed">176     log_debug(os, container)(&quot;Open of file %s failed, %s&quot;, file, os::strerror(errno));</span>
<span class="line-removed">177   }</span>
<span class="line-removed">178   if (fp != NULL)</span>
<span class="line-removed">179     fclose(fp);</span>
<span class="line-removed">180   return OSCONTAINER_ERROR;</span>
<span class="line-removed">181 }</span>
<span class="line-removed">182 PRAGMA_DIAG_POP</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 #define GET_CONTAINER_INFO(return_type, subsystem, filename,              \</span>
<span class="line-removed">185                            logstring, scan_fmt, variable)                 \</span>
<span class="line-removed">186   return_type variable;                                                   \</span>
<span class="line-removed">187 {                                                                         \</span>
<span class="line-removed">188   int err;                                                                \</span>
<span class="line-removed">189   err = subsystem_file_contents(subsystem,                                \</span>
<span class="line-removed">190                                 filename,                                 \</span>
<span class="line-removed">191                                 scan_fmt,                                 \</span>
<span class="line-removed">192                                 &amp;variable);                               \</span>
<span class="line-removed">193   if (err != 0)                                                           \</span>
<span class="line-removed">194     return (return_type) OSCONTAINER_ERROR;                               \</span>
<span class="line-removed">195                                                                           \</span>
<span class="line-removed">196   log_trace(os, container)(logstring, variable);                          \</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
<span class="line-removed">199 #define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \</span>
<span class="line-removed">200                                logstring, scan_fmt, variable, bufsize)    \</span>
<span class="line-removed">201   char variable[bufsize];                                                 \</span>
<span class="line-removed">202 {                                                                         \</span>
<span class="line-removed">203   int err;                                                                \</span>
<span class="line-removed">204   err = subsystem_file_contents(subsystem,                                \</span>
<span class="line-removed">205                                 filename,                                 \</span>
<span class="line-removed">206                                 scan_fmt,                                 \</span>
<span class="line-removed">207                                 variable);                                \</span>
<span class="line-removed">208   if (err != 0)                                                           \</span>
<span class="line-removed">209     return (return_type) NULL;                                            \</span>
<span class="line-removed">210                                                                           \</span>
<span class="line-removed">211   log_trace(os, container)(logstring, variable);                          \</span>
<span class="line-removed">212 }</span>
213 
214 /* init
215  *
216  * Initialize the container support and determine if
217  * we are running under cgroup control.
218  */
219 void OSContainer::init() {
<span class="line-removed">220   int mountid;</span>
<span class="line-removed">221   int parentid;</span>
<span class="line-removed">222   int major;</span>
<span class="line-removed">223   int minor;</span>
<span class="line-removed">224   FILE *mntinfo = NULL;</span>
<span class="line-removed">225   FILE *cgroup = NULL;</span>
<span class="line-removed">226   char buf[MAXPATHLEN+1];</span>
<span class="line-removed">227   char tmproot[MAXPATHLEN+1];</span>
<span class="line-removed">228   char tmpmount[MAXPATHLEN+1];</span>
<span class="line-removed">229   char tmpbase[MAXPATHLEN+1];</span>
<span class="line-removed">230   char *p;</span>
231   jlong mem_limit;
232 
233   assert(!_is_initialized, &quot;Initializing OSContainer more than once&quot;);
234 
235   _is_initialized = true;
236   _is_containerized = false;
237 
<span class="line-removed">238   _unlimited_memory = (LONG_MAX / os::vm_page_size()) * os::vm_page_size();</span>
<span class="line-removed">239 </span>
240   log_trace(os, container)(&quot;OSContainer::init: Initializing Container Support&quot;);
241   if (!UseContainerSupport) {
242     log_trace(os, container)(&quot;Container Support not enabled&quot;);
243     return;
244   }
245 
<span class="line-modified">246   /*</span>
<span class="line-modified">247    * Find the cgroup mount point for memory and cpuset</span>
<span class="line-modified">248    * by reading /proc/self/mountinfo</span>
<span class="line-removed">249    *</span>
<span class="line-removed">250    * Example for docker:</span>
<span class="line-removed">251    * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span>
<span class="line-removed">252    *</span>
<span class="line-removed">253    * Example for host:</span>
<span class="line-removed">254    * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span>
<span class="line-removed">255    */</span>
<span class="line-removed">256   mntinfo = fopen(&quot;/proc/self/mountinfo&quot;, &quot;r&quot;);</span>
<span class="line-removed">257   if (mntinfo == NULL) {</span>
<span class="line-removed">258       log_debug(os, container)(&quot;Can&#39;t open /proc/self/mountinfo, %s&quot;,</span>
<span class="line-removed">259                                os::strerror(errno));</span>
<span class="line-removed">260       return;</span>
261   }
<span class="line-removed">262 </span>
<span class="line-removed">263   while ( (p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {</span>
<span class="line-removed">264     // Look for the filesystem type and see if it&#39;s cgroup</span>
<span class="line-removed">265     char fstype[MAXPATHLEN+1];</span>
<span class="line-removed">266     fstype[0] = &#39;\0&#39;;</span>
<span class="line-removed">267     char *s =  strstr(p, &quot; - &quot;);</span>
<span class="line-removed">268     if (s != NULL &amp;&amp;</span>
<span class="line-removed">269         sscanf(s, &quot; - %s&quot;, fstype) == 1 &amp;&amp;</span>
<span class="line-removed">270         strcmp(fstype, &quot;cgroup&quot;) == 0) {</span>
<span class="line-removed">271 </span>
<span class="line-removed">272       if (strstr(p, &quot;memory&quot;) != NULL) {</span>
<span class="line-removed">273         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">274                              &amp;mountid,</span>
<span class="line-removed">275                              &amp;parentid,</span>
<span class="line-removed">276                              &amp;major,</span>
<span class="line-removed">277                              &amp;minor,</span>
<span class="line-removed">278                              tmproot,</span>
<span class="line-removed">279                              tmpmount);</span>
<span class="line-removed">280         if (matched == 6) {</span>
<span class="line-removed">281           memory = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">282         }</span>
<span class="line-removed">283         else</span>
<span class="line-removed">284           log_debug(os, container)(&quot;Incompatible str containing cgroup and memory: %s&quot;, p);</span>
<span class="line-removed">285       } else if (strstr(p, &quot;cpuset&quot;) != NULL) {</span>
<span class="line-removed">286         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">287                              &amp;mountid,</span>
<span class="line-removed">288                              &amp;parentid,</span>
<span class="line-removed">289                              &amp;major,</span>
<span class="line-removed">290                              &amp;minor,</span>
<span class="line-removed">291                              tmproot,</span>
<span class="line-removed">292                              tmpmount);</span>
<span class="line-removed">293         if (matched == 6) {</span>
<span class="line-removed">294           cpuset = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">295         }</span>
<span class="line-removed">296         else {</span>
<span class="line-removed">297           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpuset: %s&quot;, p);</span>
<span class="line-removed">298         }</span>
<span class="line-removed">299       } else if (strstr(p, &quot;cpu,cpuacct&quot;) != NULL || strstr(p, &quot;cpuacct,cpu&quot;) != NULL) {</span>
<span class="line-removed">300         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">301                              &amp;mountid,</span>
<span class="line-removed">302                              &amp;parentid,</span>
<span class="line-removed">303                              &amp;major,</span>
<span class="line-removed">304                              &amp;minor,</span>
<span class="line-removed">305                              tmproot,</span>
<span class="line-removed">306                              tmpmount);</span>
<span class="line-removed">307         if (matched == 6) {</span>
<span class="line-removed">308           cpu = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">309           cpuacct = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">310         }</span>
<span class="line-removed">311         else {</span>
<span class="line-removed">312           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpu,cpuacct: %s&quot;, p);</span>
<span class="line-removed">313         }</span>
<span class="line-removed">314       } else if (strstr(p, &quot;cpuacct&quot;) != NULL) {</span>
<span class="line-removed">315         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">316                              &amp;mountid,</span>
<span class="line-removed">317                              &amp;parentid,</span>
<span class="line-removed">318                              &amp;major,</span>
<span class="line-removed">319                              &amp;minor,</span>
<span class="line-removed">320                              tmproot,</span>
<span class="line-removed">321                              tmpmount);</span>
<span class="line-removed">322         if (matched == 6) {</span>
<span class="line-removed">323           cpuacct = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">324         }</span>
<span class="line-removed">325         else {</span>
<span class="line-removed">326           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpuacct: %s&quot;, p);</span>
<span class="line-removed">327         }</span>
<span class="line-removed">328       } else if (strstr(p, &quot;cpu&quot;) != NULL) {</span>
<span class="line-removed">329         int matched = sscanf(p, &quot;%d %d %d:%d %s %s&quot;,</span>
<span class="line-removed">330                              &amp;mountid,</span>
<span class="line-removed">331                              &amp;parentid,</span>
<span class="line-removed">332                              &amp;major,</span>
<span class="line-removed">333                              &amp;minor,</span>
<span class="line-removed">334                              tmproot,</span>
<span class="line-removed">335                              tmpmount);</span>
<span class="line-removed">336         if (matched == 6) {</span>
<span class="line-removed">337           cpu = new CgroupSubsystem(tmproot, tmpmount);</span>
<span class="line-removed">338         }</span>
<span class="line-removed">339         else {</span>
<span class="line-removed">340           log_debug(os, container)(&quot;Incompatible str containing cgroup and cpu: %s&quot;, p);</span>
<span class="line-removed">341         }</span>
<span class="line-removed">342       }</span>
<span class="line-removed">343     }</span>
<span class="line-removed">344   }</span>
<span class="line-removed">345 </span>
<span class="line-removed">346   fclose(mntinfo);</span>
<span class="line-removed">347 </span>
<span class="line-removed">348   if (memory == NULL) {</span>
<span class="line-removed">349     log_debug(os, container)(&quot;Required cgroup memory subsystem not found&quot;);</span>
<span class="line-removed">350     return;</span>
<span class="line-removed">351   }</span>
<span class="line-removed">352   if (cpuset == NULL) {</span>
<span class="line-removed">353     log_debug(os, container)(&quot;Required cgroup cpuset subsystem not found&quot;);</span>
<span class="line-removed">354     return;</span>
<span class="line-removed">355   }</span>
<span class="line-removed">356   if (cpu == NULL) {</span>
<span class="line-removed">357     log_debug(os, container)(&quot;Required cgroup cpu subsystem not found&quot;);</span>
<span class="line-removed">358     return;</span>
<span class="line-removed">359   }</span>
<span class="line-removed">360   if (cpuacct == NULL) {</span>
<span class="line-removed">361     log_debug(os, container)(&quot;Required cgroup cpuacct subsystem not found&quot;);</span>
<span class="line-removed">362     return;</span>
<span class="line-removed">363   }</span>
<span class="line-removed">364 </span>
<span class="line-removed">365   /*</span>
<span class="line-removed">366    * Read /proc/self/cgroup and map host mount point to</span>
<span class="line-removed">367    * local one via /proc/self/mountinfo content above</span>
<span class="line-removed">368    *</span>
<span class="line-removed">369    * Docker example:</span>
<span class="line-removed">370    * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span>
<span class="line-removed">371    *</span>
<span class="line-removed">372    * Host example:</span>
<span class="line-removed">373    * 5:memory:/user.slice</span>
<span class="line-removed">374    *</span>
<span class="line-removed">375    * Construct a path to the process specific memory and cpuset</span>
<span class="line-removed">376    * cgroup directory.</span>
<span class="line-removed">377    *</span>
<span class="line-removed">378    * For a container running under Docker from memory example above</span>
<span class="line-removed">379    * the paths would be:</span>
<span class="line-removed">380    *</span>
<span class="line-removed">381    * /sys/fs/cgroup/memory</span>
<span class="line-removed">382    *</span>
<span class="line-removed">383    * For a Host from memory example above the path would be:</span>
<span class="line-removed">384    *</span>
<span class="line-removed">385    * /sys/fs/cgroup/memory/user.slice</span>
<span class="line-removed">386    *</span>
<span class="line-removed">387    */</span>
<span class="line-removed">388   cgroup = fopen(&quot;/proc/self/cgroup&quot;, &quot;r&quot;);</span>
<span class="line-removed">389   if (cgroup == NULL) {</span>
<span class="line-removed">390     log_debug(os, container)(&quot;Can&#39;t open /proc/self/cgroup, %s&quot;,</span>
<span class="line-removed">391                              os::strerror(errno));</span>
<span class="line-removed">392     return;</span>
<span class="line-removed">393   }</span>
<span class="line-removed">394 </span>
<span class="line-removed">395   while ( (p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {</span>
<span class="line-removed">396     int cgno;</span>
<span class="line-removed">397     int matched;</span>
<span class="line-removed">398     char *controller;</span>
<span class="line-removed">399     char *base;</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     /* Skip cgroup number */</span>
<span class="line-removed">402     strsep(&amp;p, &quot;:&quot;);</span>
<span class="line-removed">403     /* Get controller and base */</span>
<span class="line-removed">404     controller = strsep(&amp;p, &quot;:&quot;);</span>
<span class="line-removed">405     base = strsep(&amp;p, &quot;\n&quot;);</span>
<span class="line-removed">406 </span>
<span class="line-removed">407     if (controller != NULL) {</span>
<span class="line-removed">408       if (strstr(controller, &quot;memory&quot;) != NULL) {</span>
<span class="line-removed">409         memory-&gt;set_subsystem_path(base);</span>
<span class="line-removed">410       } else if (strstr(controller, &quot;cpuset&quot;) != NULL) {</span>
<span class="line-removed">411         cpuset-&gt;set_subsystem_path(base);</span>
<span class="line-removed">412       } else if (strstr(controller, &quot;cpu,cpuacct&quot;) != NULL || strstr(controller, &quot;cpuacct,cpu&quot;) != NULL) {</span>
<span class="line-removed">413         cpu-&gt;set_subsystem_path(base);</span>
<span class="line-removed">414         cpuacct-&gt;set_subsystem_path(base);</span>
<span class="line-removed">415       } else if (strstr(controller, &quot;cpuacct&quot;) != NULL) {</span>
<span class="line-removed">416         cpuacct-&gt;set_subsystem_path(base);</span>
<span class="line-removed">417       } else if (strstr(controller, &quot;cpu&quot;) != NULL) {</span>
<span class="line-removed">418         cpu-&gt;set_subsystem_path(base);</span>
<span class="line-removed">419       }</span>
<span class="line-removed">420     }</span>
<span class="line-removed">421   }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423   fclose(cgroup);</span>
<span class="line-removed">424 </span>
425   // We need to update the amount of physical memory now that
<span class="line-modified">426   // command line arguments have been processed.</span>
<span class="line-modified">427   if ((mem_limit = memory_limit_in_bytes()) &gt; 0) {</span>
428     os::Linux::set_physical_memory(mem_limit);

429   }
430 
431   _is_containerized = true;
432 
433 }
434 
435 const char * OSContainer::container_type() {
<span class="line-modified">436   if (is_containerized()) {</span>
<span class="line-modified">437     return &quot;cgroupv1&quot;;</span>
<span class="line-removed">438   } else {</span>
<span class="line-removed">439     return NULL;</span>
<span class="line-removed">440   }</span>
441 }
442 
<span class="line-removed">443 </span>
<span class="line-removed">444 /* memory_limit_in_bytes</span>
<span class="line-removed">445  *</span>
<span class="line-removed">446  * Return the limit of available memory for this process.</span>
<span class="line-removed">447  *</span>
<span class="line-removed">448  * return:</span>
<span class="line-removed">449  *    memory limit in bytes or</span>
<span class="line-removed">450  *    -1 for unlimited</span>
<span class="line-removed">451  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">452  */</span>
453 jlong OSContainer::memory_limit_in_bytes() {
<span class="line-modified">454   GET_CONTAINER_INFO(julong, memory, &quot;/memory.limit_in_bytes&quot;,</span>
<span class="line-modified">455                      &quot;Memory Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memlimit);</span>
<span class="line-removed">456 </span>
<span class="line-removed">457   if (memlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">458     log_trace(os, container)(&quot;Memory Limit is: Unlimited&quot;);</span>
<span class="line-removed">459     return (jlong)-1;</span>
<span class="line-removed">460   }</span>
<span class="line-removed">461   else {</span>
<span class="line-removed">462     return (jlong)memlimit;</span>
<span class="line-removed">463   }</span>
464 }
465 
466 jlong OSContainer::memory_and_swap_limit_in_bytes() {
<span class="line-modified">467   GET_CONTAINER_INFO(julong, memory, &quot;/memory.memsw.limit_in_bytes&quot;,</span>
<span class="line-modified">468                      &quot;Memory and Swap Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memswlimit);</span>
<span class="line-removed">469   if (memswlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">470     log_trace(os, container)(&quot;Memory and Swap Limit is: Unlimited&quot;);</span>
<span class="line-removed">471     return (jlong)-1;</span>
<span class="line-removed">472   } else {</span>
<span class="line-removed">473     return (jlong)memswlimit;</span>
<span class="line-removed">474   }</span>
475 }
476 
477 jlong OSContainer::memory_soft_limit_in_bytes() {
<span class="line-modified">478   GET_CONTAINER_INFO(julong, memory, &quot;/memory.soft_limit_in_bytes&quot;,</span>
<span class="line-modified">479                      &quot;Memory Soft Limit is: &quot; JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);</span>
<span class="line-removed">480   if (memsoftlimit &gt;= _unlimited_memory) {</span>
<span class="line-removed">481     log_trace(os, container)(&quot;Memory Soft Limit is: Unlimited&quot;);</span>
<span class="line-removed">482     return (jlong)-1;</span>
<span class="line-removed">483   } else {</span>
<span class="line-removed">484     return (jlong)memsoftlimit;</span>
<span class="line-removed">485   }</span>
486 }
487 
<span class="line-removed">488 /* memory_usage_in_bytes</span>
<span class="line-removed">489  *</span>
<span class="line-removed">490  * Return the amount of used memory for this process.</span>
<span class="line-removed">491  *</span>
<span class="line-removed">492  * return:</span>
<span class="line-removed">493  *    memory usage in bytes or</span>
<span class="line-removed">494  *    -1 for unlimited</span>
<span class="line-removed">495  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">496  */</span>
497 jlong OSContainer::memory_usage_in_bytes() {
<span class="line-modified">498   GET_CONTAINER_INFO(jlong, memory, &quot;/memory.usage_in_bytes&quot;,</span>
<span class="line-modified">499                      &quot;Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memusage);</span>
<span class="line-removed">500   return memusage;</span>
501 }
502 
<span class="line-removed">503 /* memory_max_usage_in_bytes</span>
<span class="line-removed">504  *</span>
<span class="line-removed">505  * Return the maximum amount of used memory for this process.</span>
<span class="line-removed">506  *</span>
<span class="line-removed">507  * return:</span>
<span class="line-removed">508  *    max memory usage in bytes or</span>
<span class="line-removed">509  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">510  */</span>
511 jlong OSContainer::memory_max_usage_in_bytes() {
<span class="line-modified">512   GET_CONTAINER_INFO(jlong, memory, &quot;/memory.max_usage_in_bytes&quot;,</span>
<span class="line-modified">513                      &quot;Maximum Memory Usage is: &quot; JLONG_FORMAT, JLONG_FORMAT, memmaxusage);</span>
<span class="line-removed">514   return memmaxusage;</span>
<span class="line-removed">515 }</span>
<span class="line-removed">516 </span>
<span class="line-removed">517 /* active_processor_count</span>
<span class="line-removed">518  *</span>
<span class="line-removed">519  * Calculate an appropriate number of active processors for the</span>
<span class="line-removed">520  * VM to use based on these three inputs.</span>
<span class="line-removed">521  *</span>
<span class="line-removed">522  * cpu affinity</span>
<span class="line-removed">523  * cgroup cpu quota &amp; cpu period</span>
<span class="line-removed">524  * cgroup cpu shares</span>
<span class="line-removed">525  *</span>
<span class="line-removed">526  * Algorithm:</span>
<span class="line-removed">527  *</span>
<span class="line-removed">528  * Determine the number of available CPUs from sched_getaffinity</span>
<span class="line-removed">529  *</span>
<span class="line-removed">530  * If user specified a quota (quota != -1), calculate the number of</span>
<span class="line-removed">531  * required CPUs by dividing quota by period.</span>
<span class="line-removed">532  *</span>
<span class="line-removed">533  * If shares are in effect (shares != -1), calculate the number</span>
<span class="line-removed">534  * of CPUs required for the shares by dividing the share value</span>
<span class="line-removed">535  * by PER_CPU_SHARES.</span>
<span class="line-removed">536  *</span>
<span class="line-removed">537  * All results of division are rounded up to the next whole number.</span>
<span class="line-removed">538  *</span>
<span class="line-removed">539  * If neither shares or quotas have been specified, return the</span>
<span class="line-removed">540  * number of active processors in the system.</span>
<span class="line-removed">541  *</span>
<span class="line-removed">542  * If both shares and quotas have been specified, the results are</span>
<span class="line-removed">543  * based on the flag PreferContainerQuotaForCPUCount.  If true,</span>
<span class="line-removed">544  * return the quota value.  If false return the smallest value</span>
<span class="line-removed">545  * between shares or quotas.</span>
<span class="line-removed">546  *</span>
<span class="line-removed">547  * If shares and/or quotas have been specified, the resulting number</span>
<span class="line-removed">548  * returned will never exceed the number of active processors.</span>
<span class="line-removed">549  *</span>
<span class="line-removed">550  * return:</span>
<span class="line-removed">551  *    number of CPUs</span>
<span class="line-removed">552  */</span>
<span class="line-removed">553 int OSContainer::active_processor_count() {</span>
<span class="line-removed">554   int quota_count = 0, share_count = 0;</span>
<span class="line-removed">555   int cpu_count, limit_count;</span>
<span class="line-removed">556   int result;</span>
<span class="line-removed">557 </span>
<span class="line-removed">558   cpu_count = limit_count = os::Linux::active_processor_count();</span>
<span class="line-removed">559   int quota  = cpu_quota();</span>
<span class="line-removed">560   int period = cpu_period();</span>
<span class="line-removed">561   int share  = cpu_shares();</span>
<span class="line-removed">562 </span>
<span class="line-removed">563   if (quota &gt; -1 &amp;&amp; period &gt; 0) {</span>
<span class="line-removed">564     quota_count = ceilf((float)quota / (float)period);</span>
<span class="line-removed">565     log_trace(os, container)(&quot;CPU Quota count based on quota/period: %d&quot;, quota_count);</span>
<span class="line-removed">566   }</span>
<span class="line-removed">567   if (share &gt; -1) {</span>
<span class="line-removed">568     share_count = ceilf((float)share / (float)PER_CPU_SHARES);</span>
<span class="line-removed">569     log_trace(os, container)(&quot;CPU Share count based on shares: %d&quot;, share_count);</span>
<span class="line-removed">570   }</span>
<span class="line-removed">571 </span>
<span class="line-removed">572   // If both shares and quotas are setup results depend</span>
<span class="line-removed">573   // on flag PreferContainerQuotaForCPUCount.</span>
<span class="line-removed">574   // If true, limit CPU count to quota</span>
<span class="line-removed">575   // If false, use minimum of shares and quotas</span>
<span class="line-removed">576   if (quota_count !=0 &amp;&amp; share_count != 0) {</span>
<span class="line-removed">577     if (PreferContainerQuotaForCPUCount) {</span>
<span class="line-removed">578       limit_count = quota_count;</span>
<span class="line-removed">579     } else {</span>
<span class="line-removed">580       limit_count = MIN2(quota_count, share_count);</span>
<span class="line-removed">581     }</span>
<span class="line-removed">582   } else if (quota_count != 0) {</span>
<span class="line-removed">583     limit_count = quota_count;</span>
<span class="line-removed">584   } else if (share_count != 0) {</span>
<span class="line-removed">585     limit_count = share_count;</span>
<span class="line-removed">586   }</span>
<span class="line-removed">587 </span>
<span class="line-removed">588   result = MIN2(cpu_count, limit_count);</span>
<span class="line-removed">589   log_trace(os, container)(&quot;OSContainer::active_processor_count: %d&quot;, result);</span>
<span class="line-removed">590   return result;</span>
591 }
592 
593 char * OSContainer::cpu_cpuset_cpus() {
<span class="line-modified">594   GET_CONTAINER_INFO_CPTR(cptr, cpuset, &quot;/cpuset.cpus&quot;,</span>
<span class="line-modified">595                      &quot;cpuset.cpus is: %s&quot;, &quot;%1023s&quot;, cpus, 1024);</span>
<span class="line-removed">596   return os::strdup(cpus);</span>
597 }
598 
599 char * OSContainer::cpu_cpuset_memory_nodes() {
<span class="line-modified">600   GET_CONTAINER_INFO_CPTR(cptr, cpuset, &quot;/cpuset.mems&quot;,</span>
<span class="line-modified">601                      &quot;cpuset.mems is: %s&quot;, &quot;%1023s&quot;, mems, 1024);</span>
<span class="line-modified">602   return os::strdup(mems);</span>




603 }
604 
<span class="line-removed">605 /* cpu_quota</span>
<span class="line-removed">606  *</span>
<span class="line-removed">607  * Return the number of milliseconds per period</span>
<span class="line-removed">608  * process is guaranteed to run.</span>
<span class="line-removed">609  *</span>
<span class="line-removed">610  * return:</span>
<span class="line-removed">611  *    quota time in milliseconds</span>
<span class="line-removed">612  *    -1 for no quota</span>
<span class="line-removed">613  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">614  */</span>
615 int OSContainer::cpu_quota() {
<span class="line-modified">616   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.cfs_quota_us&quot;,</span>
<span class="line-modified">617                      &quot;CPU Quota is: %d&quot;, &quot;%d&quot;, quota);</span>
<span class="line-removed">618   return quota;</span>
619 }
620 
621 int OSContainer::cpu_period() {
<span class="line-modified">622   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.cfs_period_us&quot;,</span>
<span class="line-modified">623                      &quot;CPU Period is: %d&quot;, &quot;%d&quot;, period);</span>
<span class="line-removed">624   return period;</span>
625 }
626 
<span class="line-removed">627 /* cpu_shares</span>
<span class="line-removed">628  *</span>
<span class="line-removed">629  * Return the amount of cpu shares available to the process</span>
<span class="line-removed">630  *</span>
<span class="line-removed">631  * return:</span>
<span class="line-removed">632  *    Share number (typically a number relative to 1024)</span>
<span class="line-removed">633  *                 (2048 typically expresses 2 CPUs worth of processing)</span>
<span class="line-removed">634  *    -1 for no share setup</span>
<span class="line-removed">635  *    OSCONTAINER_ERROR for not supported</span>
<span class="line-removed">636  */</span>
637 int OSContainer::cpu_shares() {
<span class="line-modified">638   GET_CONTAINER_INFO(int, cpu, &quot;/cpu.shares&quot;,</span>
<span class="line-modified">639                      &quot;CPU Shares is: %d&quot;, &quot;%d&quot;, shares);</span>
<span class="line-removed">640   // Convert 1024 to no shares setup</span>
<span class="line-removed">641   if (shares == 1024) return -1;</span>
<span class="line-removed">642 </span>
<span class="line-removed">643   return shares;</span>
644 }
<span class="line-removed">645 </span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &lt;string.h&gt;
 26 #include &lt;math.h&gt;
 27 #include &lt;errno.h&gt;
<span class="line-modified"> 28 #include &quot;runtime/globals.hpp&quot;</span>

 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;osContainer_linux.hpp&quot;
<span class="line-added"> 32 #include &quot;cgroupSubsystem_linux.hpp&quot;</span>
 33 



















 34 
 35 bool  OSContainer::_is_initialized   = false;
 36 bool  OSContainer::_is_containerized = false;
<span class="line-modified"> 37 CgroupSubsystem* cgroup_subsystem;</span>




























































































































































 38 
 39 /* init
 40  *
 41  * Initialize the container support and determine if
 42  * we are running under cgroup control.
 43  */
 44 void OSContainer::init() {











 45   jlong mem_limit;
 46 
 47   assert(!_is_initialized, &quot;Initializing OSContainer more than once&quot;);
 48 
 49   _is_initialized = true;
 50   _is_containerized = false;
 51 


 52   log_trace(os, container)(&quot;OSContainer::init: Initializing Container Support&quot;);
 53   if (!UseContainerSupport) {
 54     log_trace(os, container)(&quot;Container Support not enabled&quot;);
 55     return;
 56   }
 57 
<span class="line-modified"> 58   cgroup_subsystem = CgroupSubsystemFactory::create();</span>
<span class="line-modified"> 59   if (cgroup_subsystem == NULL) {</span>
<span class="line-modified"> 60     return; // Required subsystem files not found or other error</span>












 61   }



































































































































































 62   // We need to update the amount of physical memory now that
<span class="line-modified"> 63   // cgroup subsystem files have been processed.</span>
<span class="line-modified"> 64   if ((mem_limit = cgroup_subsystem-&gt;memory_limit_in_bytes()) &gt; 0) {</span>
 65     os::Linux::set_physical_memory(mem_limit);
<span class="line-added"> 66     log_info(os, container)(&quot;Memory Limit is: &quot; JLONG_FORMAT, mem_limit);</span>
 67   }
 68 
 69   _is_containerized = true;
 70 
 71 }
 72 
 73 const char * OSContainer::container_type() {
<span class="line-modified"> 74   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified"> 75   return cgroup_subsystem-&gt;container_type();</span>



 76 }
 77 










 78 jlong OSContainer::memory_limit_in_bytes() {
<span class="line-modified"> 79   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified"> 80   return cgroup_subsystem-&gt;memory_limit_in_bytes();</span>








 81 }
 82 
 83 jlong OSContainer::memory_and_swap_limit_in_bytes() {
<span class="line-modified"> 84   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified"> 85   return cgroup_subsystem-&gt;memory_and_swap_limit_in_bytes();</span>






 86 }
 87 
 88 jlong OSContainer::memory_soft_limit_in_bytes() {
<span class="line-modified"> 89   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified"> 90   return cgroup_subsystem-&gt;memory_soft_limit_in_bytes();</span>






 91 }
 92 









 93 jlong OSContainer::memory_usage_in_bytes() {
<span class="line-modified"> 94   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified"> 95   return cgroup_subsystem-&gt;memory_usage_in_bytes();</span>

 96 }
 97 








 98 jlong OSContainer::memory_max_usage_in_bytes() {
<span class="line-modified"> 99   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">100   return cgroup_subsystem-&gt;memory_max_usage_in_bytes();</span>













































































101 }
102 
103 char * OSContainer::cpu_cpuset_cpus() {
<span class="line-modified">104   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">105   return cgroup_subsystem-&gt;cpu_cpuset_cpus();</span>

106 }
107 
108 char * OSContainer::cpu_cpuset_memory_nodes() {
<span class="line-modified">109   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">110   return cgroup_subsystem-&gt;cpu_cpuset_memory_nodes();</span>
<span class="line-modified">111 }</span>
<span class="line-added">112 </span>
<span class="line-added">113 int OSContainer::active_processor_count() {</span>
<span class="line-added">114   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-added">115   return cgroup_subsystem-&gt;active_processor_count();</span>
116 }
117 










118 int OSContainer::cpu_quota() {
<span class="line-modified">119   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">120   return cgroup_subsystem-&gt;cpu_quota();</span>

121 }
122 
123 int OSContainer::cpu_period() {
<span class="line-modified">124   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">125   return cgroup_subsystem-&gt;cpu_period();</span>

126 }
127 










128 int OSContainer::cpu_shares() {
<span class="line-modified">129   assert(cgroup_subsystem != NULL, &quot;cgroup subsystem not available&quot;);</span>
<span class="line-modified">130   return cgroup_subsystem-&gt;cpu_shares();</span>




131 }

</pre>
</td>
</tr>
</table>
<center><a href="globals_linux.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osContainer_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
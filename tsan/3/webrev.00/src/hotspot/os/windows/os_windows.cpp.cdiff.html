<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/windows/os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_windows.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,11 ---</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="line-added">+ #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;os_share_windows.hpp&quot;
  #include &quot;os_windows.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,11 ***</span>
    // sysclasspath, java_home, dll_dir
    {
      char *home_path;
      char *dll_path;
      char *pslash;
<span class="line-modified">!     char *bin = &quot;\\bin&quot;;</span>
      char home_dir[MAX_PATH + 1];
      char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
  
      if (alt_home_dir != NULL)  {
        strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
<span class="line-new-header">--- 199,11 ---</span>
    // sysclasspath, java_home, dll_dir
    {
      char *home_path;
      char *dll_path;
      char *pslash;
<span class="line-modified">!     const char *bin = &quot;\\bin&quot;;</span>
      char home_dir[MAX_PATH + 1];
      char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
  
      if (alt_home_dir != NULL)  {
        strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,22 ***</span>
          }
        }
      }
  
      home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
<span class="line-removed">-     if (home_path == NULL) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
      strcpy(home_path, home_dir);
      Arguments::set_java_home(home_path);
      FREE_C_HEAP_ARRAY(char, home_path);
  
      dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
                                  mtInternal);
<span class="line-removed">-     if (dll_path == NULL) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
      strcpy(dll_path, home_dir);
      strcat(dll_path, bin);
      Arguments::set_dll_dir(dll_path);
      FREE_C_HEAP_ARRAY(char, dll_path);
  
<span class="line-new-header">--- 222,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 494,11 ***</span>
                                    int thread_id) {
    // Allocate the OSThread object
    OSThread* osthread = new OSThread(NULL, NULL);
    if (osthread == NULL) return NULL;
  
<span class="line-modified">!   // Initialize support for Java interrupts</span>
    HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
    if (interrupt_event == NULL) {
      delete osthread;
      return NULL;
    }
<span class="line-new-header">--- 489,14 ---</span>
                                    int thread_id) {
    // Allocate the OSThread object
    OSThread* osthread = new OSThread(NULL, NULL);
    if (osthread == NULL) return NULL;
  
<span class="line-modified">!   // Initialize the JDK library&#39;s interrupt event.</span>
<span class="line-added">+   // This should really be done when OSThread is constructed,</span>
<span class="line-added">+   // but there is no way for a constructor to report failure to</span>
<span class="line-added">+   // allocate the event.</span>
    HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
    if (interrupt_event == NULL) {
      delete osthread;
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,18 ***</span>
    OSThread* osthread = new OSThread(NULL, NULL);
    if (osthread == NULL) {
      return false;
    }
  
<span class="line-modified">!   // Initialize support for Java interrupts</span>
    HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
    if (interrupt_event == NULL) {
      delete osthread;
      return false;
    }
    osthread-&gt;set_interrupt_event(interrupt_event);
<span class="line-modified">!   osthread-&gt;set_interrupted(false);</span>
  
    thread-&gt;set_osthread(osthread);
  
    if (stack_size == 0) {
      switch (thr_type) {
<span class="line-new-header">--- 594,23 ---</span>
    OSThread* osthread = new OSThread(NULL, NULL);
    if (osthread == NULL) {
      return false;
    }
  
<span class="line-modified">!   // Initialize the JDK library&#39;s interrupt event.</span>
<span class="line-added">+   // This should really be done when OSThread is constructed,</span>
<span class="line-added">+   // but there is no way for a constructor to report failure to</span>
<span class="line-added">+   // allocate the event.</span>
    HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
    if (interrupt_event == NULL) {
      delete osthread;
      return false;
    }
    osthread-&gt;set_interrupt_event(interrupt_event);
<span class="line-modified">!   // We don&#39;t call set_interrupted(false) as it will trip the assert in there</span>
<span class="line-added">+   // as we are not operating on the current thread. We don&#39;t need to call it</span>
<span class="line-added">+   // because the initial state is already correct.</span>
  
    thread-&gt;set_osthread(osthread);
  
    if (stack_size == 0) {
      switch (thr_type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,15 ***</span>
      log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
        thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
    } else {
      log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
        os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
    }
  
    if (thread_handle == NULL) {
      // Need to clean up stuff we&#39;ve allocated so far
<span class="line-removed">-     CloseHandle(osthread-&gt;interrupt_event());</span>
      thread-&gt;set_osthread(NULL);
      delete osthread;
      return false;
    }
  
<span class="line-new-header">--- 670,18 ---</span>
      log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
        thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
    } else {
      log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
        os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
<span class="line-added">+     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added">+     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added">+     LogStream st(Log(os, thread)::info());</span>
<span class="line-added">+     os::print_memory_info(&amp;st);</span>
    }
  
    if (thread_handle == NULL) {
      // Need to clean up stuff we&#39;ve allocated so far
      thread-&gt;set_osthread(NULL);
      delete osthread;
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,11 ***</span>
    // but we can only really operate on the current thread.
    assert(Thread::current()-&gt;osthread() == osthread,
           &quot;os::free_thread but not current thread&quot;);
  
    CloseHandle(osthread-&gt;thread_handle());
<span class="line-removed">-   CloseHandle(osthread-&gt;interrupt_event());</span>
    delete osthread;
  }
  
  static jlong first_filetime;
  static jlong initial_performance_count;
<span class="line-new-header">--- 707,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,10 ***</span>
<span class="line-new-header">--- 793,14 ---</span>
    } else {
      return proc_count;
    }
  }
  
<span class="line-added">+ uint os::processor_id() {</span>
<span class="line-added">+   return (uint)GetCurrentProcessorNumber();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void os::set_native_thread_name(const char *name) {
  
    // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
    //
    // Note that unfortunately this only works if the process
</pre>
<hr />
<pre>
<span class="line-old-header">*** 819,15 ***</span>
    __try {
      RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
    } __except(EXCEPTION_EXECUTE_HANDLER) {}
  }
  
<span class="line-removed">- bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">-   // Not yet implemented.</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool os::bind_to_processor(uint processor_id) {
    // Not yet implemented.
    return false;
  }
  
<span class="line-new-header">--- 828,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 904,12 ***</span>
    result.dwLowDateTime  = low(a);
    return result;
  }
  
  bool os::supports_vtime() { return true; }
<span class="line-removed">- bool os::enable_vtime() { return false; }</span>
<span class="line-removed">- bool os::vtime_enabled() { return false; }</span>
  
  double os::elapsedVTime() {
    FILETIME created;
    FILETIME exited;
    FILETIME kernel;
<span class="line-new-header">--- 908,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,18 ***</span>
  
  // Loads .dll/.so and
  // in case of error it checks if .dll/.so was built for the
  // same architecture as Hotspot is running on
  void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
    void * result = LoadLibrary(name);
    if (result != NULL) {
      // Recalculate pdb search path if a DLL was loaded successfully.
      SymbolEngine::recalc_search_path();
      return result;
    }
<span class="line-removed">- </span>
    DWORD errcode = GetLastError();
    if (errcode == ERROR_MOD_NOT_FOUND) {
      strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
      ebuf[ebuflen - 1] = &#39;\0&#39;;
      return NULL;
    }
<span class="line-new-header">--- 1360,28 ---</span>
  
  // Loads .dll/.so and
  // in case of error it checks if .dll/.so was built for the
  // same architecture as Hotspot is running on
  void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
<span class="line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, name);</span>
<span class="line-added">+ </span>
    void * result = LoadLibrary(name);
    if (result != NULL) {
<span class="line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);</span>
      // Recalculate pdb search path if a DLL was loaded successfully.
      SymbolEngine::recalc_search_path();
<span class="line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, name);</span>
      return result;
    }
    DWORD errcode = GetLastError();
<span class="line-added">+   // Read system error message into ebuf</span>
<span class="line-added">+   // It may or may not be overwritten below (in the for loop and just above)</span>
<span class="line-added">+   lasterror(ebuf, (size_t) ebuflen);</span>
<span class="line-added">+   ebuf[ebuflen - 1] = &#39;\0&#39;;</span>
<span class="line-added">+   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);</span>
<span class="line-added">+   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);</span>
<span class="line-added">+ </span>
    if (errcode == ERROR_MOD_NOT_FOUND) {
      strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
      ebuf[ebuflen - 1] = &#39;\0&#39;;
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1377,15 ***</span>
    // Parsing dll below
    // If we can read dll-info and find that dll was built
    // for an architecture other than Hotspot is running in
    // - then print to buffer &quot;DLL was built for a different architecture&quot;
    // else call os::lasterror to obtain system error message
<span class="line-removed">- </span>
<span class="line-removed">-   // Read system error message into ebuf</span>
<span class="line-removed">-   // It may or may not be overwritten below (in the for loop and just above)</span>
<span class="line-removed">-   lasterror(ebuf, (size_t) ebuflen);</span>
<span class="line-removed">-   ebuf[ebuflen - 1] = &#39;\0&#39;;</span>
    int fd = ::open(name, O_RDONLY | O_BINARY, 0);
    if (fd &lt; 0) {
      return NULL;
    }
  
<span class="line-new-header">--- 1389,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1582,10 ***</span>
<span class="line-new-header">--- 1589,15 ---</span>
  
  void os::print_os_info_brief(outputStream* st) {
    os::print_os_info(st);
  }
  
<span class="line-added">+ void os::win32::print_uptime_info(outputStream* st) {</span>
<span class="line-added">+   unsigned long long ticks = GetTickCount64();</span>
<span class="line-added">+   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void os::print_os_info(outputStream* st) {
  #ifdef ASSERT
    char buffer[1024];
    st-&gt;print(&quot;HostName: &quot;);
    if (get_host_name(buffer, sizeof(buffer))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1594,10 ***</span>
<span class="line-new-header">--- 1606,16 ---</span>
      st-&gt;print(&quot;N/A &quot;);
    }
  #endif
    st-&gt;print(&quot;OS:&quot;);
    os::win32::print_windows_version(st);
<span class="line-added">+ </span>
<span class="line-added">+   os::win32::print_uptime_info(st);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   VM_Version::print_platform_virtualization_info(st);</span>
<span class="line-added">+ #endif</span>
  }
  
  void os::win32::print_windows_version(outputStream* st) {
    OSVERSIONINFOEX osvi;
    VS_FIXEDFILEINFO *file_info;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2083,11 ***</span>
  
  static int check_pending_signals() {
    while (true) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
  
<span class="line-new-header">--- 2101,11 ---</span>
  
  static int check_pending_signals() {
    while (true) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2174,11 ***</span>
  
  #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
  
  #define def_excpt(val) { #val, (val) }
  
<span class="line-modified">! static const struct { char* name; uint number; } exceptlabels[] = {</span>
      def_excpt(EXCEPTION_ACCESS_VIOLATION),
      def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
      def_excpt(EXCEPTION_BREAKPOINT),
      def_excpt(EXCEPTION_SINGLE_STEP),
      def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
<span class="line-new-header">--- 2192,11 ---</span>
  
  #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
  
  #define def_excpt(val) { #val, (val) }
  
<span class="line-modified">! static const struct { const char* name; uint number; } exceptlabels[] = {</span>
      def_excpt(EXCEPTION_ACCESS_VIOLATION),
      def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
      def_excpt(EXCEPTION_BREAKPOINT),
      def_excpt(EXCEPTION_SINGLE_STEP),
      def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2522,11 ***</span>
  #ifdef _WIN64
            // If it&#39;s a legal stack address map the entire region in
            //
            PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
            address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
<span class="line-modified">!           if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
              addr = (address)((uintptr_t)addr &amp;
                               (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
              os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
                                !ExecMem);
              return EXCEPTION_CONTINUE_EXECUTION;
<span class="line-new-header">--- 2540,11 ---</span>
  #ifdef _WIN64
            // If it&#39;s a legal stack address map the entire region in
            //
            PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
            address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
<span class="line-modified">!           if (thread-&gt;is_in_usable_stack(addr)) {</span>
              addr = (address)((uintptr_t)addr &amp;
                               (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
              os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
                                !ExecMem);
              return EXCEPTION_CONTINUE_EXECUTION;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2569,14 ***</span>
        JavaThread* thread = (JavaThread*)t;
        if (in_java) {
          CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
          nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
        }
<span class="line-modified">!       if ((thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>
            thread-&gt;doing_unsafe_access()) ||
            (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
<span class="line-modified">!         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, (address)Assembler::locate_next_instruction(pc)));</span>
        }
      }
  
      if (in_java) {
        switch (exception_code) {
<span class="line-new-header">--- 2587,22 ---</span>
        JavaThread* thread = (JavaThread*)t;
        if (in_java) {
          CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
          nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
        }
<span class="line-modified">! </span>
<span class="line-added">+       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-added">+       if (((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">+            thread-&gt;thread_state() == _thread_in_native ||</span>
<span class="line-added">+            is_unsafe_arraycopy) &amp;&amp;</span>
            thread-&gt;doing_unsafe_access()) ||
            (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
<span class="line-modified">!         address next_pc =  Assembler::locate_next_instruction(pc);</span>
<span class="line-added">+         if (is_unsafe_arraycopy) {</span>
<span class="line-added">+           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));</span>
        }
      }
  
      if (in_java) {
        switch (exception_code) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2697,13 ***</span>
   private:
    int *_numa_used_node_list;  // allocated below
    int _numa_used_node_count;
  
    void free_node_list() {
<span class="line-modified">!     if (_numa_used_node_list != NULL) {</span>
<span class="line-removed">-       FREE_C_HEAP_ARRAY(int, _numa_used_node_list);</span>
<span class="line-removed">-     }</span>
    }
  
   public:
    NUMANodeListHolder() {
      _numa_used_node_count = 0;
<span class="line-new-header">--- 2723,11 ---</span>
   private:
    int *_numa_used_node_list;  // allocated below
    int _numa_used_node_count;
  
    void free_node_list() {
<span class="line-modified">!     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);</span>
    }
  
   public:
    NUMANodeListHolder() {
      _numa_used_node_count = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3428,10 ***</span>
<span class="line-new-header">--- 3452,14 ---</span>
      }
      return size;
    }
  }
  
<span class="line-added">+ int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool os::get_page_info(char *start, page_info* info) {
    return false;
  }
  
  char *os::scan_pages(char *start, char* end, page_info* page_expected,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3456,136 ***</span>
    // 1:  Thread is running now
    // &gt;1: Thread is still suspended.
    assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
  }
  
<span class="line-removed">- class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {</span>
<span class="line-removed">-   // The default timer resolution seems to be 10 milliseconds.</span>
<span class="line-removed">-   // (Where is this written down?)</span>
<span class="line-removed">-   // If someone wants to sleep for only a fraction of the default,</span>
<span class="line-removed">-   // then we set the timer resolution down to 1 millisecond for</span>
<span class="line-removed">-   // the duration of their interval.</span>
<span class="line-removed">-   // We carefully set the resolution back, since otherwise we</span>
<span class="line-removed">-   // seem to incur an overhead (3%?) that we don&#39;t need.</span>
<span class="line-removed">-   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.</span>
<span class="line-removed">-   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().</span>
<span class="line-removed">-   // Alternatively, we could compute the relative error (503/500 = .6%) and only use</span>
<span class="line-removed">-   // timeBeginPeriod() if the relative error exceeded some threshold.</span>
<span class="line-removed">-   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and</span>
<span class="line-removed">-   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize</span>
<span class="line-removed">-   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high</span>
<span class="line-removed">-   // resolution timers running.</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   jlong resolution;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   HighResolutionInterval(jlong ms) {</span>
<span class="line-removed">-     resolution = ms % 10L;</span>
<span class="line-removed">-     if (resolution != 0) {</span>
<span class="line-removed">-       MMRESULT result = timeBeginPeriod(1L);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   ~HighResolutionInterval() {</span>
<span class="line-removed">-     if (resolution != 0) {</span>
<span class="line-removed">-       MMRESULT result = timeEndPeriod(1L);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     resolution = 0L;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- int os::sleep(Thread* thread, jlong ms, bool interruptable) {</span>
<span class="line-removed">-   jlong limit = (jlong) MAXDWORD;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   while (ms &gt; limit) {</span>
<span class="line-removed">-     int res;</span>
<span class="line-removed">-     if ((res = sleep(thread, limit, interruptable)) != OS_TIMEOUT) {</span>
<span class="line-removed">-       return res;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ms -= limit;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(thread == Thread::current(), &quot;thread consistency check&quot;);</span>
<span class="line-removed">-   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">-   OSThreadWaitState osts(osthread, false /* not Object.wait() */);</span>
<span class="line-removed">-   int result;</span>
<span class="line-removed">-   if (interruptable) {</span>
<span class="line-removed">-     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>
<span class="line-removed">-     JavaThread *jt = (JavaThread *) thread;</span>
<span class="line-removed">-     ThreadBlockInVM tbivm(jt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">-     // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">-     // java_suspend_self() via check_and_wait_while_suspended()</span>
<span class="line-removed">- </span>
<span class="line-removed">-     HANDLE events[1];</span>
<span class="line-removed">-     events[0] = osthread-&gt;interrupt_event();</span>
<span class="line-removed">-     HighResolutionInterval *phri=NULL;</span>
<span class="line-removed">-     if (!ForceTimeHighResolution) {</span>
<span class="line-removed">-       phri = new HighResolutionInterval(ms);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (WaitForMultipleObjects(1, events, FALSE, (DWORD)ms) == WAIT_TIMEOUT) {</span>
<span class="line-removed">-       result = OS_TIMEOUT;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       ResetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">-       osthread-&gt;set_interrupted(false);</span>
<span class="line-removed">-       result = OS_INTRPT;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     delete phri; //if it is NULL, harmless</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // were we externally suspended while we were waiting?</span>
<span class="line-removed">-     jt-&gt;check_and_wait_while_suspended();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(!thread-&gt;is_Java_thread(), &quot;must not be java thread&quot;);</span>
<span class="line-removed">-     Sleep((long) ms);</span>
<span class="line-removed">-     result = OS_TIMEOUT;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return result;</span>
<span class="line-removed">- }</span>
  
  // Short sleep, direct OS call.
  //
  // ms = 0, means allow others (if any) to run.
  //
  void os::naked_short_sleep(jlong ms) {
    assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
    Sleep(ms);
  }
  
  void os::naked_short_nanosleep(jlong ns) {
    assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-removed">-   LARGE_INTEGER hundreds_nanos = { 0 };</span>
<span class="line-removed">-   HANDLE wait_timer = ::CreateWaitableTimer(NULL /* attributes*/,</span>
<span class="line-removed">-                                             true /* manual reset */,</span>
<span class="line-removed">-                                             NULL /* name */ );</span>
<span class="line-removed">-   if (wait_timer == NULL) {</span>
<span class="line-removed">-     log_warning(os)(&quot;Failed to CreateWaitableTimer: %u&quot;, GetLastError());</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // We need a minimum of one hundred nanos.</span>
<span class="line-modified">!   ns = ns &gt; 100 ? ns : 100;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Round ns to the nearst hundred of nanos.</span>
<span class="line-modified">!   // Negative values indicate relative time.</span>
<span class="line-removed">-   hundreds_nanos.QuadPart = -((ns + 50) / 100);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (::SetWaitableTimer(wait_timer /* handle */,</span>
<span class="line-removed">-                          &amp;hundreds_nanos /* due time */,</span>
<span class="line-removed">-                          0 /* period */,</span>
<span class="line-removed">-                          NULL /* comp func */,</span>
<span class="line-removed">-                          NULL /* comp func args */,</span>
<span class="line-removed">-                          FALSE /* resume */)) {</span>
<span class="line-removed">-     DWORD res = ::WaitForSingleObject(wait_timer /* handle */, INFINITE /* timeout */);</span>
<span class="line-removed">-     if (res != WAIT_OBJECT_0) {</span>
<span class="line-removed">-       if (res == WAIT_FAILED) {</span>
<span class="line-removed">-         log_warning(os)(&quot;Failed to WaitForSingleObject: %u&quot;, GetLastError());</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         log_warning(os)(&quot;Unexpected return from WaitForSingleObject: %s&quot;,</span>
<span class="line-removed">-                         res == WAIT_ABANDONED ? &quot;WAIT_ABANDONED&quot; : &quot;WAIT_TIMEOUT&quot;);</span>
<span class="line-removed">-       }</span>
      }
<span class="line-modified">!   }</span>
<span class="line-removed">-   ::CloseHandle(wait_timer /* handle */);</span>
  }
  
  // Sleep forever; naked call to OS-specific sleep; use with CAUTION
  void os::infinite_sleep() {
    while (true) {    // sleep forever ...
<span class="line-new-header">--- 3484,33 ---</span>
    // 1:  Thread is running now
    // &gt;1: Thread is still suspended.
    assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
  }
  
  
  // Short sleep, direct OS call.
  //
  // ms = 0, means allow others (if any) to run.
  //
  void os::naked_short_sleep(jlong ms) {
    assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
    Sleep(ms);
  }
  
<span class="line-added">+ // Windows does not provide sleep functionality with nanosecond resolution, so we</span>
<span class="line-added">+ // try to approximate this with spinning combined with yielding if another thread</span>
<span class="line-added">+ // is ready to run on the current processor.</span>
  void os::naked_short_nanosleep(jlong ns) {
    assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
  
<span class="line-modified">!   int64_t start = os::javaTimeNanos();</span>
<span class="line-modified">!   do {</span>
<span class="line-modified">!     if (SwitchToThread() == 0) {</span>
<span class="line-modified">!       // Nothing else is ready to run on this cpu, spin a little</span>
<span class="line-modified">!       SpinPause();</span>
      }
<span class="line-modified">!   } while (os::javaTimeNanos() - start &lt; ns);</span>
  }
  
  // Sleep forever; naked call to OS-specific sleep; use with CAUTION
  void os::infinite_sleep() {
    while (true) {    // sleep forever ...
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3667,51 ***</span>
    }
    *priority_ptr = os_prio;
    return OS_OK;
  }
  
<span class="line-removed">- void os::interrupt(Thread* thread) {</span>
<span class="line-removed">-   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">-   osthread-&gt;set_interrupted(true);</span>
<span class="line-removed">-   // More than one thread can get here with the same value of osthread,</span>
<span class="line-removed">-   // resulting in multiple notifications.  We do, however, want the store</span>
<span class="line-removed">-   // to interrupted() to be visible to other threads before we post</span>
<span class="line-removed">-   // the interrupt event.</span>
<span class="line-removed">-   OrderAccess::release();</span>
<span class="line-removed">-   SetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">-   // For JSR166:  unpark after setting status</span>
<span class="line-removed">-   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">-     ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ParkEvent * ev = thread-&gt;_ParkEvent;</span>
<span class="line-removed">-   if (ev != NULL) ev-&gt;unpark();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- bool os::is_interrupted(Thread* thread, bool clear_interrupted) {</span>
<span class="line-removed">-   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">-   // There is no synchronization between the setting of the interrupt</span>
<span class="line-removed">-   // and it being cleared here. It is critical - see 6535709 - that</span>
<span class="line-removed">-   // we only clear the interrupt state, and reset the interrupt event,</span>
<span class="line-removed">-   // if we are going to report that we were indeed interrupted - else</span>
<span class="line-removed">-   // an interrupt can be &quot;lost&quot;, leading to spurious wakeups or lost wakeups</span>
<span class="line-removed">-   // depending on the timing. By checking thread interrupt event to see</span>
<span class="line-removed">-   // if the thread gets real interrupt thus prevent spurious wakeup.</span>
<span class="line-removed">-   bool interrupted = osthread-&gt;interrupted() &amp;&amp; (WaitForSingleObject(osthread-&gt;interrupt_event(), 0) == WAIT_OBJECT_0);</span>
<span class="line-removed">-   if (interrupted &amp;&amp; clear_interrupted) {</span>
<span class="line-removed">-     osthread-&gt;set_interrupted(false);</span>
<span class="line-removed">-     ResetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">-   } // Otherwise leave the interrupted state alone</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return interrupted;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // GetCurrentThreadId() returns DWORD
  intx os::current_thread_id()  { return GetCurrentThreadId(); }
  
  static int _initial_pid = 0;
  
<span class="line-new-header">--- 3592,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3868,19 ***</span>
      bool registered = false;
  
      // The first thread that reached this point, initializes the critical section.
      if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
        warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
<span class="line-modified">!     } else if (OrderAccess::load_acquire(&amp;process_exiting) == 0) {</span>
        if (what != EPT_THREAD) {
          // Atomically set process_exiting before the critical section
          // to increase the visibility between racing threads.
<span class="line-modified">!         Atomic::cmpxchg(GetCurrentThreadId(), &amp;process_exiting, (DWORD)0);</span>
        }
        EnterCriticalSection(&amp;crit_sect);
  
<span class="line-modified">!       if (what == EPT_THREAD &amp;&amp; OrderAccess::load_acquire(&amp;process_exiting) == 0) {</span>
          // Remove from the array those handles of the threads that have completed exiting.
          for (i = 0, j = 0; i &lt; handle_count; ++i) {
            res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
            if (res == WAIT_TIMEOUT) {
              handles[j++] = handles[i];
<span class="line-new-header">--- 3752,19 ---</span>
      bool registered = false;
  
      // The first thread that reached this point, initializes the critical section.
      if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
        warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
<span class="line-modified">!     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {</span>
        if (what != EPT_THREAD) {
          // Atomically set process_exiting before the critical section
          // to increase the visibility between racing threads.
<span class="line-modified">!         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());</span>
        }
        EnterCriticalSection(&amp;crit_sect);
  
<span class="line-modified">!       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {</span>
          // Remove from the array those handles of the threads that have completed exiting.
          for (i = 0, j = 0; i &lt; handle_count; ++i) {
            res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
            if (res == WAIT_TIMEOUT) {
              handles[j++] = handles[i];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3989,11 ***</span>
  
        LeaveCriticalSection(&amp;crit_sect);
      }
  
      if (!registered &amp;&amp;
<span class="line-modified">!         OrderAccess::load_acquire(&amp;process_exiting) != 0 &amp;&amp;</span>
          process_exiting != GetCurrentThreadId()) {
        // Some other thread is about to call exit(), so we don&#39;t let
        // the current unregistered thread proceed to exit() or _endthreadex()
        while (true) {
          SuspendThread(GetCurrentThread());
<span class="line-new-header">--- 3873,11 ---</span>
  
        LeaveCriticalSection(&amp;crit_sect);
      }
  
      if (!registered &amp;&amp;
<span class="line-modified">!         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;</span>
          process_exiting != GetCurrentThreadId()) {
        // Some other thread is about to call exit(), so we don&#39;t let
        // the current unregistered thread proceed to exit() or _endthreadex()
        while (true) {
          SuspendThread(GetCurrentThread());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4026,16 ***</span>
    _setmode(_fileno(stdin), _O_BINARY);
    _setmode(_fileno(stdout), _O_BINARY);
    _setmode(_fileno(stderr), _O_BINARY);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- bool os::is_debugger_attached() {</span>
<span class="line-removed">-   return IsDebuggerPresent() ? true : false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void os::wait_for_keypress_at_exit(void) {
    if (PauseAtExit) {
      fprintf(stderr, &quot;Press any key to continue...\n&quot;);
      fgetc(stdin);
    }
<span class="line-new-header">--- 3910,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4083,11 ***</span>
    win32::initialize_system_info();
    win32::setmode_streams();
    init_page_sizes((size_t) win32::vm_page_size());
  
    // This may be overridden later when argument processing is done.
<span class="line-modified">!   FLAG_SET_ERGO(bool, UseLargePagesIndividualAllocation, false);</span>
  
    // Initialize main_process and main_thread
    main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
    if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
                         &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
<span class="line-new-header">--- 3961,11 ---</span>
    win32::initialize_system_info();
    win32::setmode_streams();
    init_page_sizes((size_t) win32::vm_page_size());
  
    // This may be overridden later when argument processing is done.
<span class="line-modified">!   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);</span>
  
    // Initialize main_process and main_thread
    main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
    if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
                         &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4120,11 ***</span>
  #if INCLUDE_AOT
    // If AOT is enabled we need to install a vectored exception handler
    // in order to forward implicit exceptions from code in AOT
    // generated DLLs.  This is necessary since these DLLs are not
    // registered for structured exceptions like codecache methods are.
<span class="line-modified">!   if (UseAOT) {</span>
      topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
    }
  #endif
  
    // for debugging float code generation bugs
<span class="line-new-header">--- 3998,11 ---</span>
  #if INCLUDE_AOT
    // If AOT is enabled we need to install a vectored exception handler
    // in order to forward implicit exceptions from code in AOT
    // generated DLLs.  This is necessary since these DLLs are not
    // registered for structured exceptions like codecache methods are.
<span class="line-modified">!   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {</span>
      topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
    }
  #endif
  
    // for debugging float code generation bugs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4281,98 ***</span>
    } else {
      sbuf-&gt;st_mode |= S_IFREG;
    }
  }
  
<span class="line-modified">! // The following function is adapted from java.base/windows/native/libjava/canonicalize_md.c</span>
<span class="line-modified">! // Creates an UNC path from a single byte path. Return buffer is</span>
<span class="line-modified">! // allocated in C heap and needs to be freed by the caller.</span>
<span class="line-modified">! // Returns NULL on error.</span>
<span class="line-modified">! static wchar_t* create_unc_path(const char* path, errno_t &amp;err) {</span>
<span class="line-modified">!   wchar_t* wpath = NULL;</span>
<span class="line-modified">!   size_t converted_chars = 0;</span>
<span class="line-modified">!   size_t path_len = strlen(path) + 1; // includes the terminating NULL</span>
<span class="line-modified">!   if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {</span>
<span class="line-modified">!     if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;){</span>
<span class="line-modified">!       // if it already has a \\?\ don&#39;t do the prefix</span>
<span class="line-modified">!       wpath = (wchar_t*)os::malloc(path_len * sizeof(wchar_t), mtInternal);</span>
<span class="line-modified">!       if (wpath != NULL) {</span>
<span class="line-modified">!         err = ::mbstowcs_s(&amp;converted_chars, wpath, path_len, path, path_len);</span>
        } else {
<span class="line-modified">!         err = ENOMEM;</span>
        }
      } else {
<span class="line-modified">!       // only UNC pathname includes double slashes here</span>
<span class="line-modified">!       wpath = (wchar_t*)os::malloc((path_len + 7) * sizeof(wchar_t), mtInternal);</span>
<span class="line-removed">-       if (wpath != NULL) {</span>
<span class="line-removed">-         ::wcscpy(wpath, L&quot;\\\\?\\UNC\0&quot;);</span>
<span class="line-removed">-         err = ::mbstowcs_s(&amp;converted_chars, &amp;wpath[7], path_len, path, path_len);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         err = ENOMEM;</span>
<span class="line-removed">-       }</span>
      }
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     wpath = (wchar_t*)os::malloc((path_len + 4) * sizeof(wchar_t), mtInternal);</span>
<span class="line-modified">!     if (wpath != NULL) {</span>
<span class="line-modified">!       ::wcscpy(wpath, L&quot;\\\\?\\\0&quot;);</span>
<span class="line-modified">!       err = ::mbstowcs_s(&amp;converted_chars, &amp;wpath[4], path_len, path, path_len);</span>
<span class="line-modified">!     } else {</span>
        err = ENOMEM;
      }
    }
<span class="line-removed">-   return wpath;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static void destroy_unc_path(wchar_t* wpath) {</span>
<span class="line-modified">!   os::free(wpath);</span>
  }
  
  int os::stat(const char *path, struct stat *sbuf) {
<span class="line-modified">!   char* pathbuf = (char*)os::strdup(path, mtInternal);</span>
<span class="line-modified">!   if (pathbuf == NULL) {</span>
<span class="line-modified">!     errno = ENOMEM;</span>
      return -1;
    }
<span class="line-modified">!   os::native_path(pathbuf);</span>
<span class="line-modified">!   int ret;</span>
<span class="line-modified">!   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="line-modified">!   // Not using stat() to avoid the problem described in JDK-6539723</span>
<span class="line-modified">!   if (strlen(path) &lt; MAX_PATH) {</span>
<span class="line-modified">!     BOOL bret = ::GetFileAttributesExA(pathbuf, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-modified">!     if (!bret) {</span>
<span class="line-modified">!       errno = ::GetLastError();</span>
<span class="line-modified">!       ret = -1;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     else {</span>
<span class="line-modified">!       file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-modified">!       ret = 0;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     errno_t err = ERROR_SUCCESS;</span>
<span class="line-modified">!     wchar_t* wpath = create_unc_path(pathbuf, err);</span>
<span class="line-modified">!     if (err != ERROR_SUCCESS) {</span>
<span class="line-modified">!       if (wpath != NULL) {</span>
<span class="line-modified">!         destroy_unc_path(wpath);</span>
        }
<span class="line-removed">-       os::free(pathbuf);</span>
<span class="line-removed">-       errno = err;</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     BOOL bret = ::GetFileAttributesExW(wpath, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-removed">-     if (!bret) {</span>
<span class="line-removed">-       errno = ::GetLastError();</span>
<span class="line-removed">-       ret = -1;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-removed">-       ret = 0;</span>
      }
<span class="line-removed">-     destroy_unc_path(wpath);</span>
    }
<span class="line-removed">-   os::free(pathbuf);</span>
<span class="line-removed">-   return ret;</span>
<span class="line-removed">- }</span>
  
  
  #define FT2INT64(ft) \
    ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
  
  
<span class="line-new-header">--- 4159,186 ---</span>
    } else {
      sbuf-&gt;st_mode |= S_IFREG;
    }
  }
  
<span class="line-modified">! // Returns the given path as an absolute wide path in unc format. The returned path is NULL</span>
<span class="line-modified">! // on error (with err being set accordingly) and should be freed via os::free() otherwise.</span>
<span class="line-modified">! // additional_space is the number of additionally allocated wchars after the terminating L&#39;\0&#39;.</span>
<span class="line-modified">! // This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for</span>
<span class="line-modified">! // short paths.</span>
<span class="line-modified">! static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {</span>
<span class="line-modified">!   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {</span>
<span class="line-modified">!     err = ENOENT;</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   size_t path_len = strlen(path);</span>
<span class="line-modified">!   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.</span>
<span class="line-modified">!   char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);</span>
<span class="line-added">+   wchar_t* result = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (buf == NULL) {</span>
<span class="line-added">+     err = ENOMEM;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     memcpy(buf, path, path_len + 1);</span>
<span class="line-added">+     os::native_path(buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+     wchar_t* prefix;</span>
<span class="line-added">+     int prefix_off = 0;</span>
<span class="line-added">+     bool is_abs = true;</span>
<span class="line-added">+     bool needs_fullpath = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {</span>
<span class="line-added">+       prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-added">+     } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {</span>
<span class="line-added">+       if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {</span>
<span class="line-added">+         prefix = L&quot;&quot;;</span>
<span class="line-added">+         needs_fullpath = false;</span>
        } else {
<span class="line-modified">!         prefix = L&quot;\\\\?\\UNC&quot;;</span>
<span class="line-added">+         prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path</span>
        }
      } else {
<span class="line-modified">!       is_abs = false;</span>
<span class="line-modified">!       prefix = L&quot;\\\\?\\&quot;;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     size_t buf_len = strlen(buf);</span>
<span class="line-modified">!     size_t prefix_len = wcslen(prefix);</span>
<span class="line-modified">!     size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;</span>
<span class="line-modified">!     size_t result_size = prefix_len + full_path_size - prefix_off;</span>
<span class="line-modified">!     result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (result == NULL) {</span>
        err = ENOMEM;
<span class="line-added">+     } else {</span>
<span class="line-added">+       size_t converted_chars;</span>
<span class="line-added">+       wchar_t* path_start = result + prefix_len - prefix_off;</span>
<span class="line-added">+       err = ::mbstowcs_s(&amp;converted_chars, path_start, buf_len + 1, buf, buf_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if ((err == ERROR_SUCCESS) &amp;&amp; needs_fullpath) {</span>
<span class="line-added">+         wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (tmp == NULL) {</span>
<span class="line-added">+           err = ENOMEM;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           if (!_wfullpath(tmp, path_start, full_path_size)) {</span>
<span class="line-added">+             err = ENOENT;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           os::free(tmp);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       memcpy(result, prefix, sizeof(wchar_t) * prefix_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)</span>
<span class="line-added">+       size_t result_len = wcslen(result);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (result[result_len - 1] == L&#39;\\&#39;) {</span>
<span class="line-added">+         if (!(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {</span>
<span class="line-added">+           result[result_len - 1] = L&#39;\0&#39;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
    }
  
<span class="line-modified">!   os::free(buf);</span>
<span class="line-modified">! </span>
<span class="line-added">+   if (err != ERROR_SUCCESS) {</span>
<span class="line-added">+     os::free(result);</span>
<span class="line-added">+     result = NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return result;</span>
  }
  
  int os::stat(const char *path, struct stat *sbuf) {
<span class="line-modified">!   errno_t err;</span>
<span class="line-modified">!   wchar_t* wide_path = wide_abs_unc_path(path, err);</span>
<span class="line-modified">! </span>
<span class="line-added">+   if (wide_path == NULL) {</span>
<span class="line-added">+     errno = err;</span>
      return -1;
    }
<span class="line-modified">! </span>
<span class="line-modified">!   WIN32_FILE_ATTRIBUTE_DATA file_data;;</span>
<span class="line-modified">!   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-modified">!   os::free(wide_path);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!bret) {</span>
<span class="line-modified">!     errno = ::GetLastError();</span>
<span class="line-modified">!     return -1;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-modified">!   return 0;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static HANDLE create_read_only_file_handle(const char* file) {</span>
<span class="line-modified">!   errno_t err;</span>
<span class="line-modified">!   wchar_t* wide_path = wide_abs_unc_path(file, err);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (wide_path == NULL) {</span>
<span class="line-modified">!     errno = err;</span>
<span class="line-added">+     return INVALID_HANDLE_VALUE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,</span>
<span class="line-added">+                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</span>
<span class="line-added">+   os::free(wide_path);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return handle;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool os::same_files(const char* file1, const char* file2) {</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (file1 == NULL &amp;&amp; file2 == NULL) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (file1 == NULL || file2 == NULL) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (strcmp(file1, file2) == 0) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   HANDLE handle1 = create_read_only_file_handle(file1);</span>
<span class="line-added">+   HANDLE handle2 = create_read_only_file_handle(file2);</span>
<span class="line-added">+   bool result = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // if we could open both paths...</span>
<span class="line-added">+   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">+     BY_HANDLE_FILE_INFORMATION fileInfo1;</span>
<span class="line-added">+     BY_HANDLE_FILE_INFORMATION fileInfo2;</span>
<span class="line-added">+     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;</span>
<span class="line-added">+       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {</span>
<span class="line-added">+       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)</span>
<span class="line-added">+       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;</span>
<span class="line-added">+         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;</span>
<span class="line-added">+         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {</span>
<span class="line-added">+         result = true;</span>
        }
      }
    }
  
<span class="line-added">+   //free the handles</span>
<span class="line-added">+   if (handle1 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">+     ::CloseHandle(handle1);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (handle2 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">+     ::CloseHandle(handle2);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
  
  #define FT2INT64(ft) \
    ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4474,93 ***</span>
  // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
  bool os::dont_yield() {
    return DontYieldALot;
  }
  
<span class="line-removed">- // This method is a slightly reworked copy of JDK&#39;s sysOpen</span>
<span class="line-removed">- // from src/windows/hpi/src/sys_api_md.c</span>
<span class="line-removed">- </span>
  int os::open(const char *path, int oflag, int mode) {
<span class="line-modified">!   char* pathbuf = (char*)os::strdup(path, mtInternal);</span>
<span class="line-modified">!   if (pathbuf == NULL) {</span>
<span class="line-modified">!     errno = ENOMEM;</span>
      return -1;
    }
<span class="line-modified">!   os::native_path(pathbuf);</span>
<span class="line-modified">!   int ret;</span>
<span class="line-modified">!   if (strlen(path) &lt; MAX_PATH) {</span>
<span class="line-modified">!     ret = ::open(pathbuf, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-modified">!   } else {</span>
<span class="line-removed">-     errno_t err = ERROR_SUCCESS;</span>
<span class="line-removed">-     wchar_t* wpath = create_unc_path(pathbuf, err);</span>
<span class="line-removed">-     if (err != ERROR_SUCCESS) {</span>
<span class="line-removed">-       if (wpath != NULL) {</span>
<span class="line-removed">-         destroy_unc_path(wpath);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       os::free(pathbuf);</span>
<span class="line-removed">-       errno = err;</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ret = ::_wopen(wpath, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-removed">-     if (ret == -1) {</span>
<span class="line-removed">-       errno = ::GetLastError();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     destroy_unc_path(wpath);</span>
    }
<span class="line-modified">!   os::free(pathbuf);</span>
<span class="line-modified">!   return ret;</span>
  }
  
  FILE* os::open(int fd, const char* mode) {
    return ::_fdopen(fd, mode);
  }
  
  // Is a (classpath) directory empty?
  bool os::dir_is_empty(const char* path) {
<span class="line-modified">!   char* search_path = (char*)os::malloc(strlen(path) + 3, mtInternal);</span>
<span class="line-modified">!   if (search_path == NULL) {</span>
<span class="line-modified">!     errno = ENOMEM;</span>
<span class="line-modified">!     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   strcpy(search_path, path);</span>
<span class="line-removed">-   os::native_path(search_path);</span>
<span class="line-removed">-   // Append &quot;*&quot;, or possibly &quot;\\*&quot;, to path</span>
<span class="line-removed">-   if (search_path[1] == &#39;:&#39; &amp;&amp;</span>
<span class="line-removed">-        (search_path[2] == &#39;\0&#39; ||</span>
<span class="line-removed">-          (search_path[2] == &#39;\\&#39; &amp;&amp; search_path[3] == &#39;\0&#39;))) {</span>
<span class="line-removed">-     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;</span>
<span class="line-removed">-     strcat(search_path, &quot;*&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     strcat(search_path, &quot;\\*&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   errno_t err = ERROR_SUCCESS;</span>
<span class="line-removed">-   wchar_t* wpath = create_unc_path(search_path, err);</span>
<span class="line-removed">-   if (err != ERROR_SUCCESS) {</span>
<span class="line-removed">-     if (wpath != NULL) {</span>
<span class="line-removed">-       destroy_unc_path(wpath);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     os::free(search_path);</span>
      errno = err;
      return false;
    }
    WIN32_FIND_DATAW fd;
<span class="line-modified">!   HANDLE f = ::FindFirstFileW(wpath, &amp;fd);</span>
<span class="line-modified">!   destroy_unc_path(wpath);</span>
    bool is_empty = true;
    if (f != INVALID_HANDLE_VALUE) {
      while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
        // An empty directory contains only the current directory file
        // and the previous directory file.
        if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
            (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
          is_empty = false;
        }
      }
      FindClose(f);
    }
<span class="line-modified">!   os::free(search_path);</span>
    return is_empty;
  }
  
  // create binary file, rewriting existing file if required
  int os::create_binary_file(const char* path, bool rewrite_existing) {
<span class="line-new-header">--- 4440,68 ---</span>
  // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
  bool os::dont_yield() {
    return DontYieldALot;
  }
  
  int os::open(const char *path, int oflag, int mode) {
<span class="line-modified">!   errno_t err;</span>
<span class="line-modified">!   wchar_t* wide_path = wide_abs_unc_path(path, err);</span>
<span class="line-modified">! </span>
<span class="line-added">+   if (wide_path == NULL) {</span>
<span class="line-added">+     errno = err;</span>
      return -1;
    }
<span class="line-modified">!   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-modified">!   os::free(wide_path);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (fd == -1) {</span>
<span class="line-modified">!     errno = ::GetLastError();</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   return fd;</span>
  }
  
  FILE* os::open(int fd, const char* mode) {
    return ::_fdopen(fd, mode);
  }
  
  // Is a (classpath) directory empty?
  bool os::dir_is_empty(const char* path) {
<span class="line-modified">!   errno_t err;</span>
<span class="line-modified">!   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (wide_path == NULL) {</span>
      errno = err;
      return false;
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Make sure we end with &quot;\\*&quot;</span>
<span class="line-added">+   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {</span>
<span class="line-added">+     wcscat(wide_path, L&quot;*&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     wcscat(wide_path, L&quot;\\*&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    WIN32_FIND_DATAW fd;
<span class="line-modified">!   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);</span>
<span class="line-modified">!   os::free(wide_path);</span>
    bool is_empty = true;
<span class="line-added">+ </span>
    if (f != INVALID_HANDLE_VALUE) {
      while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
        // An empty directory contains only the current directory file
        // and the previous directory file.
        if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
            (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
          is_empty = false;
        }
      }
      FindClose(f);
<span class="line-added">+   } else {</span>
<span class="line-added">+     errno = ::GetLastError();</span>
    }
<span class="line-modified">! </span>
    return is_empty;
  }
  
  // create binary file, rewriting existing file if required
  int os::create_binary_file(const char* path, bool rewrite_existing) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4921,10 ***</span>
<span class="line-new-header">--- 4862,13 ---</span>
        log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
        CloseHandle(hFile);
        return NULL;
      }
  
<span class="line-added">+     // Record virtual memory allocation</span>
<span class="line-added">+     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);</span>
<span class="line-added">+ </span>
      DWORD bytes_read;
      OVERLAPPED overlapped;
      overlapped.Offset = (DWORD)file_offset;
      overlapped.OffsetHigh = 0;
      overlapped.hEvent = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4989,21 ***</span>
  // Remap a block of memory.
  char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
                            char *addr, size_t bytes, bool read_only,
                            bool allow_exec) {
    // This OS does not allow existing memory maps to be remapped so we
<span class="line-modified">!   // have to unmap the memory before we remap it.</span>
<span class="line-removed">-   if (!os::unmap_memory(addr, bytes)) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // There is a very small theoretical window between the unmap_memory()</span>
<span class="line-removed">-   // call above and the map_memory() call below where a thread in native</span>
<span class="line-removed">-   // code may be able to access an address that is no longer mapped.</span>
  
<span class="line-modified">!   return os::map_memory(fd, file_name, file_offset, addr, bytes,</span>
<span class="line-modified">!                         read_only, allow_exec);</span>
  }
  
  
  // Unmap a block of memory.
  // Returns true=success, otherwise false.
<span class="line-new-header">--- 4933,17 ---</span>
  // Remap a block of memory.
  char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
                            char *addr, size_t bytes, bool read_only,
                            bool allow_exec) {
    // This OS does not allow existing memory maps to be remapped so we
<span class="line-modified">!   // would have to unmap the memory before we remap it.</span>
  
<span class="line-modified">!   // Because there is a small window between unmapping memory and mapping</span>
<span class="line-modified">!   // it in again with different protections, CDS archives are mapped RW</span>
<span class="line-added">+   // on windows, so this function isn&#39;t called.</span>
<span class="line-added">+   ShouldNotReachHere();</span>
<span class="line-added">+   return NULL;</span>
  }
  
  
  // Unmap a block of memory.
  // Returns true=success, otherwise false.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5035,11 ***</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
<span class="line-new-header">--- 4975,11 ---</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5087,10 ***</span>
<span class="line-new-header">--- 5027,44 ---</span>
    _protected_thread = NULL;
    Thread::muxRelease(&amp;_crash_mux);
    return success;
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {</span>
<span class="line-added">+   // The default timer resolution seems to be 10 milliseconds.</span>
<span class="line-added">+   // (Where is this written down?)</span>
<span class="line-added">+   // If someone wants to sleep for only a fraction of the default,</span>
<span class="line-added">+   // then we set the timer resolution down to 1 millisecond for</span>
<span class="line-added">+   // the duration of their interval.</span>
<span class="line-added">+   // We carefully set the resolution back, since otherwise we</span>
<span class="line-added">+   // seem to incur an overhead (3%?) that we don&#39;t need.</span>
<span class="line-added">+   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.</span>
<span class="line-added">+   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().</span>
<span class="line-added">+   // Alternatively, we could compute the relative error (503/500 = .6%) and only use</span>
<span class="line-added">+   // timeBeginPeriod() if the relative error exceeded some threshold.</span>
<span class="line-added">+   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and</span>
<span class="line-added">+   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize</span>
<span class="line-added">+   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high</span>
<span class="line-added">+   // resolution timers running.</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   jlong resolution;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   HighResolutionInterval(jlong ms) {</span>
<span class="line-added">+     resolution = ms % 10L;</span>
<span class="line-added">+     if (resolution != 0) {</span>
<span class="line-added">+       MMRESULT result = timeBeginPeriod(1L);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ~HighResolutionInterval() {</span>
<span class="line-added">+     if (resolution != 0) {</span>
<span class="line-added">+       MMRESULT result = timeEndPeriod(1L);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     resolution = 0L;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
  //
  // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
  //
  // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5122,11 ***</span>
  //
  // TODO-FIXME:
  // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
  // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
  //     to recover from (or at least detect) the dreaded Windows 841176 bug.
<span class="line-modified">! // 3.  Collapse the interrupt_event, the JSR166 parker event, and the objectmonitor ParkEvent</span>
  //     into a single win32 CreateEvent() handle.
  //
  // Assumption:
  //    Only one parker can exist on an event, which is why we allocate
  //    them per-thread. Multiple unparkers can coexist.
<span class="line-new-header">--- 5096,11 ---</span>
  //
  // TODO-FIXME:
  // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
  // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
  //     to recover from (or at least detect) the dreaded Windows 841176 bug.
<span class="line-modified">! // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent</span>
  //     into a single win32 CreateEvent() handle.
  //
  // Assumption:
  //    Only one parker can exist on an event, which is why we allocate
  //    them per-thread. Multiple unparkers can coexist.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5167,11 ***</span>
    // Consider: use atomic decrement instead of CAS-loop
  
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
    }
    guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
    if (v != 0) return OS_OK;
  
    // Do this the hard way by blocking ...
<span class="line-new-header">--- 5141,11 ---</span>
    // Consider: use atomic decrement instead of CAS-loop
  
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
    }
    guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
    if (v != 0) return OS_OK;
  
    // Do this the hard way by blocking ...
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5195,15 ***</span>
<span class="line-new-header">--- 5169,20 ---</span>
    while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
      DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
      if (Millis &gt; MAXTIMEOUT) {
        prd = MAXTIMEOUT;
      }
<span class="line-added">+     HighResolutionInterval *phri = NULL;</span>
<span class="line-added">+     if (!ForceTimeHighResolution) {</span>
<span class="line-added">+       phri = new HighResolutionInterval(prd);</span>
<span class="line-added">+     }</span>
      rv = ::WaitForSingleObject(_ParkHandle, prd);
      assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
      if (rv == WAIT_TIMEOUT) {
        Millis -= prd;
      }
<span class="line-added">+     delete phri; // if it is NULL, harmless</span>
    }
    v = _Event;
    _Event = 0;
    // see comment at end of os::PlatformEvent::park() below:
    OrderAccess::fence();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5224,11 ***</span>
    // may call park().
    // Consider: use atomic decrement instead of CAS-loop
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
    }
    guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
    if (v != 0) return;
  
    // Do this the hard way by blocking ...
<span class="line-new-header">--- 5203,11 ---</span>
    // may call park().
    // Consider: use atomic decrement instead of CAS-loop
    int v;
    for (;;) {
      v = _Event;
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
    }
    guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
    if (v != 0) return;
  
    // Do this the hard way by blocking ...
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5262,11 ***</span>
    // that it will take two back-to-back park() calls for the owning
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without condition variables.
  
<span class="line-modified">!   if (Atomic::xchg(1, &amp;_Event) &gt;= 0) return;</span>
  
    ::SetEvent(_ParkHandle);
  }
  
  
<span class="line-new-header">--- 5241,11 ---</span>
    // that it will take two back-to-back park() calls for the owning
    // thread to block. This has the benefit of forcing a spurious return
    // from the first park() call after an unpark() call which will help
    // shake out uses of park() and unpark() without condition variables.
  
<span class="line-modified">!   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;</span>
  
    ::SetEvent(_ParkHandle);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5298,11 ***</span>
    }
  
    JavaThread* thread = JavaThread::current();
  
    // Don&#39;t wait if interrupted or already triggered
<span class="line-modified">!   if (Thread::is_interrupted(thread, false) ||</span>
        WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
      ResetEvent(_ParkEvent);
      return;
    } else {
      ThreadBlockInVM tbivm(thread);
<span class="line-new-header">--- 5277,11 ---</span>
    }
  
    JavaThread* thread = JavaThread::current();
  
    // Don&#39;t wait if interrupted or already triggered
<span class="line-modified">!   if (thread-&gt;is_interrupted(false) ||</span>
        WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
      ResetEvent(_ParkEvent);
      return;
    } else {
      ThreadBlockInVM tbivm(thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5350,11 ***</span>
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD exit_code;
  
    char * cmd_string;
<span class="line-modified">!   char * cmd_prefix = &quot;cmd /C &quot;;</span>
    size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
    cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
    if (cmd_string == NULL) {
      return -1;
    }
<span class="line-new-header">--- 5329,11 ---</span>
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD exit_code;
  
    char * cmd_string;
<span class="line-modified">!   const char * cmd_prefix = &quot;cmd /C &quot;;</span>
    size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
    cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
    if (cmd_string == NULL) {
      return -1;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5689,12 ***</span>
       (LIST TBD)
  
  */
  int os::get_signal_number(const char* name) {
    static const struct {
<span class="line-modified">!     char* name;</span>
<span class="line-modified">!     int   number;</span>
    } siglabels [] =
      // derived from version 6.0 VC98/include/signal.h
    {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
    &quot;FPE&quot;,        SIGFPE,         // floating point exception
    &quot;SEGV&quot;,       SIGSEGV,        // segment violation
<span class="line-new-header">--- 5668,12 ---</span>
       (LIST TBD)
  
  */
  int os::get_signal_number(const char* name) {
    static const struct {
<span class="line-modified">!     const char* name;</span>
<span class="line-modified">!     int         number;</span>
    } siglabels [] =
      // derived from version 6.0 VC98/include/signal.h
    {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
    &quot;FPE&quot;,        SIGFPE,         // floating point exception
    &quot;SEGV&quot;,       SIGSEGV,        // segment violation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5718,7 ***</span>
  
  // We need to call the os_exception_wrapper once so that it sets
  // up the offset from FS of the thread pointer.
  void os::win32::initialize_thread_ptr_offset() {
    os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
<span class="line-modified">!                            NULL, NULL, NULL, NULL);</span>
  }
<span class="line-new-header">--- 5697,11 ---</span>
  
  // We need to call the os_exception_wrapper once so that it sets
  // up the offset from FS of the thread pointer.
  void os::win32::initialize_thread_ptr_offset() {
    os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
<span class="line-modified">!                            NULL, methodHandle(), NULL, NULL);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool os::supports_map_sync() {</span>
<span class="line-added">+   return false;</span>
  }
</pre>
<center><a href="os_perf_windows.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
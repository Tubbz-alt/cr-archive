<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/attachListener_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris/perfMemory_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/attachListener_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
255     guarantee(res == WAIT_OBJECT_0, &quot;wait failed&quot;);
256 
257     Win32AttachOperation* op = head();
258     if (op != NULL) {
259       set_head(op-&gt;next());
260       if (head() == NULL) {     // list is empty
261         set_tail(NULL);
262       }
263     }
264     ::ReleaseMutex(mutex());
265 
266     if (op != NULL) {
267       return op;
268     }
269   }
270 }
271 
272 
273 // open the pipe to the client
274 HANDLE Win32AttachOperation::open_pipe() {
<span class="line-modified">275   HANDLE hPipe;</span>
<span class="line-removed">276 </span>
<span class="line-removed">277   hPipe = ::CreateFile( pipe(),  // pipe name</span>
278                         GENERIC_WRITE,   // write only
279                         0,              // no sharing
280                         NULL,           // default security attributes
281                         OPEN_EXISTING,  // opens existing pipe
282                         0,              // default attributes
283                         NULL);          // no template file
<span class="line-removed">284 </span>
<span class="line-removed">285   if (hPipe != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">286     // shouldn&#39;t happen as there is a pipe created per operation</span>
<span class="line-removed">287     if (::GetLastError() == ERROR_PIPE_BUSY) {</span>
<span class="line-removed">288       ::CloseHandle(hPipe);</span>
<span class="line-removed">289       return INVALID_HANDLE_VALUE;</span>
<span class="line-removed">290     }</span>
<span class="line-removed">291   }</span>
292   return hPipe;
293 }
294 
295 // write to the pipe
296 BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {
297   do {
298     DWORD nwrote;
299 
300     BOOL fSuccess = WriteFile(  hPipe,                  // pipe handle
301                                 (LPCVOID)buf,           // message
302                                 (DWORD)len,             // message length
303                                 &amp;nwrote,                // bytes written
304                                 NULL);                  // not overlapped
305     if (!fSuccess) {
306       return fSuccess;
307     }
308     buf += nwrote;
309     len -= nwrote;
<span class="line-modified">310   }</span>
<span class="line-removed">311   while (len &gt; 0);</span>
312   return TRUE;
313 }
314 
315 // Complete the operation:
316 //   - open the pipe to the client
317 //   - write the operation result (a jint)
318 //   - write the operation output (the result stream)
319 //
320 void Win32AttachOperation::complete(jint result, bufferedStream* result_stream) {
321   JavaThread* thread = JavaThread::current();
322   ThreadBlockInVM tbivm(thread);
323 
324   thread-&gt;set_suspend_equivalent();
325   // cleared by handle_special_suspend_equivalent_condition() or
326   // java_suspend_self() via check_and_wait_while_suspended()
327 
328   HANDLE hPipe = open_pipe();

329   if (hPipe != INVALID_HANDLE_VALUE) {
330     BOOL fSuccess;
331 
332     char msg[32];
333     _snprintf(msg, sizeof(msg), &quot;%d\n&quot;, result);
334     msg[sizeof(msg) - 1] = &#39;\0&#39;;
335 
336     fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));
337     if (fSuccess) {
338       fSuccess = write_pipe(hPipe, (char*)result_stream-&gt;base(), (int)(result_stream-&gt;size()));
339     }

340 
341     // Need to flush buffers
342     FlushFileBuffers(hPipe);
343     CloseHandle(hPipe);
344 
345     if (fSuccess) {
346       log_debug(attach)(&quot;wrote result of attach operation %s to pipe %s&quot;, name(), pipe());
347     } else {
<span class="line-modified">348       log_error(attach)(&quot;failure writing result of operation %s to pipe %s&quot;, name(), pipe());</span>
349     }
350   } else {
<span class="line-modified">351     log_error(attach)(&quot;could not open pipe %s to send result of operation %s&quot;, pipe(), name());</span>
352   }
353 
354   DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);
355   if (res == WAIT_OBJECT_0) {
356 
357     // put the operation back on the available list
358     set_next(Win32AttachListener::available());
359     Win32AttachListener::set_available(this);
360 
361     ::ReleaseMutex(Win32AttachListener::mutex());
362   }
363 
364   // were we externally suspended while we were waiting?
365   thread-&gt;check_and_wait_while_suspended();
366 }
367 
368 
369 // AttachOperation functions
370 
371 AttachOperation* AttachListener::dequeue() {
</pre>
<hr />
<pre>
375   thread-&gt;set_suspend_equivalent();
376   // cleared by handle_special_suspend_equivalent_condition() or
377   // java_suspend_self() via check_and_wait_while_suspended()
378 
379   AttachOperation* op = Win32AttachListener::dequeue();
380 
381   // were we externally suspended while we were waiting?
382   thread-&gt;check_and_wait_while_suspended();
383 
384   return op;
385 }
386 
387 void AttachListener::vm_start() {
388   // nothing to do
389 }
390 
391 int AttachListener::pd_init() {
392   return Win32AttachListener::init();
393 }
394 






395 bool AttachListener::init_at_startup() {
396   return true;
397 }
398 
399 // no trigger mechanism on Windows to start Attach Listener lazily
400 bool AttachListener::is_init_trigger() {
401   return false;
402 }
403 
404 void AttachListener::abort() {
405   // nothing to do
406 }
407 
408 void AttachListener::pd_data_dump() {
409   os::signal_notify(SIGBREAK);
410 }
411 
412 AttachOperationFunctionInfo* AttachListener::pd_find_operation(const char* n) {
413   return NULL;
414 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
255     guarantee(res == WAIT_OBJECT_0, &quot;wait failed&quot;);
256 
257     Win32AttachOperation* op = head();
258     if (op != NULL) {
259       set_head(op-&gt;next());
260       if (head() == NULL) {     // list is empty
261         set_tail(NULL);
262       }
263     }
264     ::ReleaseMutex(mutex());
265 
266     if (op != NULL) {
267       return op;
268     }
269   }
270 }
271 
272 
273 // open the pipe to the client
274 HANDLE Win32AttachOperation::open_pipe() {
<span class="line-modified">275   HANDLE hPipe = ::CreateFile( pipe(),  // pipe name</span>


276                         GENERIC_WRITE,   // write only
277                         0,              // no sharing
278                         NULL,           // default security attributes
279                         OPEN_EXISTING,  // opens existing pipe
280                         0,              // default attributes
281                         NULL);          // no template file








282   return hPipe;
283 }
284 
285 // write to the pipe
286 BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {
287   do {
288     DWORD nwrote;
289 
290     BOOL fSuccess = WriteFile(  hPipe,                  // pipe handle
291                                 (LPCVOID)buf,           // message
292                                 (DWORD)len,             // message length
293                                 &amp;nwrote,                // bytes written
294                                 NULL);                  // not overlapped
295     if (!fSuccess) {
296       return fSuccess;
297     }
298     buf += nwrote;
299     len -= nwrote;
<span class="line-modified">300   } while (len &gt; 0);</span>

301   return TRUE;
302 }
303 
304 // Complete the operation:
305 //   - open the pipe to the client
306 //   - write the operation result (a jint)
307 //   - write the operation output (the result stream)
308 //
309 void Win32AttachOperation::complete(jint result, bufferedStream* result_stream) {
310   JavaThread* thread = JavaThread::current();
311   ThreadBlockInVM tbivm(thread);
312 
313   thread-&gt;set_suspend_equivalent();
314   // cleared by handle_special_suspend_equivalent_condition() or
315   // java_suspend_self() via check_and_wait_while_suspended()
316 
317   HANDLE hPipe = open_pipe();
<span class="line-added">318   int lastError = (int)::GetLastError();</span>
319   if (hPipe != INVALID_HANDLE_VALUE) {
320     BOOL fSuccess;
321 
322     char msg[32];
323     _snprintf(msg, sizeof(msg), &quot;%d\n&quot;, result);
324     msg[sizeof(msg) - 1] = &#39;\0&#39;;
325 
326     fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));
327     if (fSuccess) {
328       fSuccess = write_pipe(hPipe, (char*)result_stream-&gt;base(), (int)(result_stream-&gt;size()));
329     }
<span class="line-added">330     lastError = (int)::GetLastError();</span>
331 
332     // Need to flush buffers
333     FlushFileBuffers(hPipe);
334     CloseHandle(hPipe);
335 
336     if (fSuccess) {
337       log_debug(attach)(&quot;wrote result of attach operation %s to pipe %s&quot;, name(), pipe());
338     } else {
<span class="line-modified">339       log_error(attach)(&quot;failure (%d) writing result of operation %s to pipe %s&quot;, lastError, name(), pipe());</span>
340     }
341   } else {
<span class="line-modified">342     log_error(attach)(&quot;could not open (%d) pipe %s to send result of operation %s&quot;, lastError, pipe(), name());</span>
343   }
344 
345   DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);
346   if (res == WAIT_OBJECT_0) {
347 
348     // put the operation back on the available list
349     set_next(Win32AttachListener::available());
350     Win32AttachListener::set_available(this);
351 
352     ::ReleaseMutex(Win32AttachListener::mutex());
353   }
354 
355   // were we externally suspended while we were waiting?
356   thread-&gt;check_and_wait_while_suspended();
357 }
358 
359 
360 // AttachOperation functions
361 
362 AttachOperation* AttachListener::dequeue() {
</pre>
<hr />
<pre>
366   thread-&gt;set_suspend_equivalent();
367   // cleared by handle_special_suspend_equivalent_condition() or
368   // java_suspend_self() via check_and_wait_while_suspended()
369 
370   AttachOperation* op = Win32AttachListener::dequeue();
371 
372   // were we externally suspended while we were waiting?
373   thread-&gt;check_and_wait_while_suspended();
374 
375   return op;
376 }
377 
378 void AttachListener::vm_start() {
379   // nothing to do
380 }
381 
382 int AttachListener::pd_init() {
383   return Win32AttachListener::init();
384 }
385 
<span class="line-added">386 // This function is used for Un*x OSes only.</span>
<span class="line-added">387 // We need not to implement it for Windows.</span>
<span class="line-added">388 bool AttachListener::check_socket_file() {</span>
<span class="line-added">389   return false;</span>
<span class="line-added">390 }</span>
<span class="line-added">391 </span>
392 bool AttachListener::init_at_startup() {
393   return true;
394 }
395 
396 // no trigger mechanism on Windows to start Attach Listener lazily
397 bool AttachListener::is_init_trigger() {
398   return false;
399 }
400 
401 void AttachListener::abort() {
402   // nothing to do
403 }
404 
405 void AttachListener::pd_data_dump() {
406   os::signal_notify(SIGBREAK);
407 }
408 
409 AttachOperationFunctionInfo* AttachListener::pd_find_operation(const char* n) {
410   return NULL;
411 }
</pre>
</td>
</tr>
</table>
<center><a href="../solaris/perfMemory_solaris.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
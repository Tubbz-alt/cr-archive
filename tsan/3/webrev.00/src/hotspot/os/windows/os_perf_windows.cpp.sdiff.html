<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/os_perf_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osThread_windows.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_perf_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;iphlp_interface.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;pdh_interface.hpp&quot;
  31 #include &quot;runtime/os_perf.hpp&quot;
  32 #include &quot;runtime/os.hpp&quot;

  33 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  34 #include &quot;vm_version_ext_x86.hpp&quot;</span>
  35 #include &lt;math.h&gt;
  36 #include &lt;psapi.h&gt;
  37 #include &lt;TlHelp32.h&gt;
  38 
  39 /*
  40  * Windows provides a vast plethora of performance objects and counters,
  41  * consumption of which is assisted using the Performance Data Helper (PDH) interface.
  42  * We import a selected few api entry points from PDH, see pdh_interface.hpp.
  43  *
  44  * The code located in this file is to a large extent an abstraction over much of the
  45  * plumbing needed to start consuming an object and/or counter of choice.
  46  *
  47  */
  48 
  49  /*
  50  * How to use:
  51  * 1. Create query
  52  * 2. Add counters to the query
  53  * 3. Collect the performance data using the query
  54  * 4. Display the performance data using the counters associated with the query
</pre>
<hr />
<pre>
  79 static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  80 static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  81 static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  82 static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
  83 static const char* const PROCESS_OBJECT_INSTANCE_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;
  84 static const size_t PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN = 5;
  85 
  86 static const char* process_image_name = NULL; // for example, &quot;java&quot; but could have another image name
  87 static char* pdh_IDProcess_counter_fmt = NULL;   // &quot;\Process(java#%d)\ID Process&quot; */
  88 
  89 // Need to limit how often we update a query to minimize the heisenberg effect.
  90 // (PDH behaves erratically if the counters are queried too often, especially counters that
  91 // store and use values from two consecutive updates, like cpu load.)
  92 static const int min_update_interval_millis = 500;
  93 
  94 /*
  95 * Structs for PDH queries.
  96 */
  97 typedef struct {
  98   HQUERY query;
<span class="line-modified">  99   s8     lastUpdate; // Last time query was updated (current millis).</span>
 100 } UpdateQueryS, *UpdateQueryP;
 101 
 102 
 103 typedef struct {
 104   UpdateQueryS query;
 105   HCOUNTER     counter;
 106   bool         initialized;
 107 } CounterQueryS, *CounterQueryP;
 108 
 109 typedef struct {
 110   UpdateQueryS query;
 111   HCOUNTER*    counters;
 112   int          noOfCounters;
 113   bool         initialized;
 114 } MultiCounterQueryS, *MultiCounterQueryP;
 115 
 116 typedef struct {
 117   MultiCounterQueryP queries;
 118   int                size;
 119   bool               initialized;
 120 } MultiCounterQuerySetS, *MultiCounterQuerySetP;
 121 
 122 typedef struct {
 123   MultiCounterQuerySetS set;
 124   int                   process_index;
 125 } ProcessQueryS, *ProcessQueryP;
 126 
 127 static void pdh_cleanup(HQUERY* const query, HCOUNTER* const counter) {
 128   if (counter != NULL &amp;&amp; *counter != NULL) {
 129     PdhDll::PdhRemoveCounter(*counter);
 130     *counter = NULL;
 131   }
 132   if (query != NULL &amp;&amp; *query != NULL) {
 133     PdhDll::PdhCloseQuery(*query);
 134     *query = NULL;
 135   }
 136 }
 137 
 138 static CounterQueryP create_counter_query() {
<span class="line-modified"> 139   CounterQueryP const query = NEW_C_HEAP_ARRAY(CounterQueryS, 1, mtInternal);</span>
 140   memset(query, 0, sizeof(CounterQueryS));
 141   return query;
 142 }
 143 
 144 static void destroy_counter_query(CounterQueryP query) {
 145   assert(query != NULL, &quot;invariant&quot;);
 146   pdh_cleanup(&amp;query-&gt;query.query, &amp;query-&gt;counter);
<span class="line-modified"> 147   FREE_C_HEAP_ARRAY(CounterQueryS, query);</span>
 148 }
 149 
 150 static MultiCounterQueryP create_multi_counter_query() {
 151   MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
 152   memset(query, 0, sizeof(MultiCounterQueryS));
 153   return query;
 154 }
 155 
 156 static void destroy_counter_query(MultiCounterQueryP counter_query) {
 157   if (counter_query != NULL) {
 158     for (int i = 0; i &lt; counter_query-&gt;noOfCounters; ++i) {
 159       pdh_cleanup(NULL, &amp;counter_query-&gt;counters[i]);
 160     }
 161     FREE_C_HEAP_ARRAY(char, counter_query-&gt;counters);
 162     pdh_cleanup(&amp;counter_query-&gt;query.query, NULL);
 163     FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query);
 164   }
 165 }
 166 
 167 static void destroy_multi_counter_query(MultiCounterQuerySetP counter_query_set) {
 168   for (int i = 0; i &lt; counter_query_set-&gt;size; i++) {
 169     for (int j = 0; j &lt; counter_query_set-&gt;queries[i].noOfCounters; ++j) {
 170       pdh_cleanup(NULL, &amp;counter_query_set-&gt;queries[i].counters[j]);
 171     }
 172     FREE_C_HEAP_ARRAY(char, counter_query_set-&gt;queries[i].counters);
 173     pdh_cleanup(&amp;counter_query_set-&gt;queries[i].query.query, NULL);
 174   }
 175   FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query_set-&gt;queries);
 176 }
 177 
 178 static void destroy_counter_query(MultiCounterQuerySetP counter_query_set) {
 179   destroy_multi_counter_query(counter_query_set);
 180   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, counter_query_set);
 181 }
 182 
 183 static void destroy_counter_query(ProcessQueryP process_query) {
 184   destroy_multi_counter_query(&amp;process_query-&gt;set);
<span class="line-modified"> 185   FREE_C_HEAP_ARRAY(ProcessQueryS, process_query);</span>
 186 }
 187 
 188 static int open_query(HQUERY* query) {
 189   return PdhDll::PdhOpenQuery(NULL, 0, query);
 190 }
 191 
 192 template &lt;typename QueryP&gt;
 193 static int open_query(QueryP query) {
 194   return open_query(&amp;query-&gt;query);
 195 }
 196 
<span class="line-modified"> 197 static int allocate_counters(MultiCounterQueryP query, size_t nofCounters) {</span>
 198   assert(query != NULL, &quot;invariant&quot;);
 199   assert(!query-&gt;initialized, &quot;invariant&quot;);
 200   assert(0 == query-&gt;noOfCounters, &quot;invariant&quot;);
 201   assert(query-&gt;counters == NULL, &quot;invariant&quot;);
<span class="line-modified"> 202   query-&gt;counters = (HCOUNTER*)NEW_C_HEAP_ARRAY(char, nofCounters * sizeof(HCOUNTER), mtInternal);</span>
<span class="line-removed"> 203   if (query-&gt;counters == NULL) {</span>
<span class="line-removed"> 204     return OS_ERR;</span>
<span class="line-removed"> 205   }</span>
 206   memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
 207   query-&gt;noOfCounters = (int)nofCounters;
<span class="line-removed"> 208   return OS_OK;</span>
 209 }
 210 
<span class="line-modified"> 211 static int allocate_counters(MultiCounterQuerySetP query_set, size_t nofCounters) {</span>
 212   assert(query_set != NULL, &quot;invariant&quot;);
 213   assert(!query_set-&gt;initialized, &quot;invariant&quot;);
 214   for (int i = 0; i &lt; query_set-&gt;size; ++i) {
<span class="line-modified"> 215     if (allocate_counters(&amp;query_set-&gt;queries[i], nofCounters) != OS_OK) {</span>
<span class="line-removed"> 216       return OS_ERR;</span>
<span class="line-removed"> 217     }</span>
 218   }
<span class="line-removed"> 219   return OS_OK;</span>
 220 }
 221 
<span class="line-modified"> 222 static int allocate_counters(ProcessQueryP process_query, size_t nofCounters) {</span>
 223   assert(process_query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 224   return allocate_counters(&amp;process_query-&gt;set, nofCounters);</span>
 225 }
 226 
 227 static void deallocate_counters(MultiCounterQueryP query) {
<span class="line-modified"> 228   if (query-&gt;counters != NULL) {</span>
<span class="line-modified"> 229     FREE_C_HEAP_ARRAY(char, query-&gt;counters);</span>
<span class="line-modified"> 230     query-&gt;counters = NULL;</span>
<span class="line-removed"> 231     query-&gt;noOfCounters = 0;</span>
<span class="line-removed"> 232   }</span>
 233 }
 234 
 235 static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {
 236   assert(query != NULL, &quot;invariant&quot;);
 237   assert(counter != NULL, &quot;invariant&quot;);
 238   assert(path != NULL, &quot;invariant&quot;);
 239   if (query-&gt;query == NULL) {
 240     if (open_query(query) != ERROR_SUCCESS) {
 241       return OS_ERR;
 242     }
 243   }
 244   assert(query-&gt;query != NULL, &quot;invariant&quot;);
 245   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;query, path, 0, counter);
 246   if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
 247     return OS_ERR;
 248   }
 249   /*
 250   * According to the MSDN documentation, rate counters must be read twice:
 251   *
 252   * &quot;Obtaining the value of rate counters such as Page faults/sec requires that
</pre>
<hr />
<pre>
 278   }
 279   counter_query-&gt;initialized = true;
 280   return OS_OK;
 281 }
 282 
 283 static OSReturn add_process_counter(MultiCounterQueryP query, int slot_index, const char* path, bool first_sample_on_init) {
 284   assert(query != NULL, &quot;invariant&quot;);
 285   assert(slot_index &lt; query-&gt;noOfCounters, &quot;invariant&quot;);
 286   assert(query-&gt;counters[slot_index] == NULL, &quot;invariant&quot;);
 287   const OSReturn ret = add_counter(query, &amp;query-&gt;counters[slot_index], path, first_sample_on_init);
 288   if (OS_OK == ret) {
 289     if (slot_index + 1 == query-&gt;noOfCounters) {
 290       query-&gt;initialized = true;
 291     }
 292   }
 293   return ret;
 294 }
 295 
 296 static int collect_query_data(UpdateQueryP update_query) {
 297   assert(update_query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 298   const s8 now = os::javaTimeMillis();</span>
<span class="line-modified"> 299   if (now - update_query-&gt;lastUpdate &gt; min_update_interval_millis) {</span>
 300     if (PdhDll::PdhCollectQueryData(update_query-&gt;query) != ERROR_SUCCESS) {
 301       return OS_ERR;
 302     }
 303     update_query-&gt;lastUpdate = now;
 304   }
 305   return OS_OK;
 306 }
 307 
 308 template &lt;typename Query&gt;
 309 static int collect_query_data(Query* counter_query) {
 310   assert(counter_query != NULL, &quot;invariant&quot;);
 311   return collect_query_data(&amp;counter_query-&gt;query);
 312 }
 313 
 314 static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
 315   assert(value != NULL, &quot;invariant&quot;);
 316   if (PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS) {
 317     return OS_ERR;
 318   }
 319   return OS_OK;
</pre>
<hr />
<pre>
 371       return OS_ERR;
 372     } else {
 373       PDH_FMT_COUNTERVALUE counter_value;
 374       formatted_counter_value(handle_counter, PDH_FMT_LONG, &amp;counter_value);
 375       pdh_cleanup(NULL, &amp;handle_counter);
 376       if ((LONG)os::current_process_id() == counter_value.longValue) {
 377         pdh_cleanup(&amp;tmpQuery, NULL);
 378         return index;
 379       }
 380     }
 381   }
 382   pdh_cleanup(&amp;tmpQuery, NULL);
 383   return OS_ERR;
 384 }
 385 
 386 static ProcessQueryP create_process_query() {
 387   const int current_process_idx = current_query_index_for_process();
 388   if (OS_ERR == current_process_idx) {
 389     return NULL;
 390   }
<span class="line-modified"> 391   ProcessQueryP const process_query = NEW_C_HEAP_ARRAY(ProcessQueryS, 1, mtInternal);</span>
 392   memset(process_query, 0, sizeof(ProcessQueryS));
 393   process_query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, current_process_idx + 1, mtInternal);
 394   memset(process_query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * (current_process_idx + 1));
 395   process_query-&gt;process_index = current_process_idx;
 396   process_query-&gt;set.size = current_process_idx + 1;
 397   assert(process_query-&gt;set.size &gt; process_query-&gt;process_index, &quot;invariant&quot;);
 398   return process_query;
 399 }
 400 
 401 static MultiCounterQueryP current_process_counter_query(ProcessQueryP process_query) {
 402   assert(process_query != NULL, &quot;invariant&quot;);
 403   assert(process_query-&gt;process_index &lt; process_query-&gt;set.size, &quot;invariant&quot;);
 404   return &amp;process_query-&gt;set.queries[process_query-&gt;process_index];
 405 }
 406 
 407 static void clear_multi_counter(MultiCounterQueryP query) {
 408   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {
 409     pdh_cleanup(NULL, &amp;query-&gt;counters[i]);
 410   }
 411   pdh_cleanup(&amp;query-&gt;query.query, NULL);
</pre>
<hr />
<pre>
 585   PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
 586   assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
 587   *p_string = NEW_RESOURCE_ARRAY_RETURN_NULL(char, size);
 588   if (*p_string== NULL) {
 589     return OS_ERR;
 590   }
 591   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
 592     return OS_ERR;
 593   }
 594   if (0 == size || *p_string == NULL) {
 595     return OS_ERR;
 596   }
 597   // windows vista does not null-terminate the string (although the docs says it will)
 598   (*p_string)[size - 1] = &#39;\0&#39;;
 599   return OS_OK;
 600 }
 601 
 602 static const char* copy_string_to_c_heap(const char* string) {
 603   assert(string != NULL, &quot;invariant&quot;);
 604   const size_t len = strlen(string);
<span class="line-modified"> 605   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
 606   if (NULL == cheap_allocated_string) {
 607     return NULL;
 608   }
 609   strncpy(cheap_allocated_string, string, len + 1);
 610   return cheap_allocated_string;
 611 }
 612 
 613 /*
 614 * Maps an index to a resource area allocated string for the localized PDH artifact.
 615 *
 616 * Caller will need a ResourceMark.
 617 *
 618 * @param index    the counter index as specified in the registry
 619 * @return         localized pdh artifact string if successful, NULL on failure.
 620 */
 621 static const char* pdh_localized_artifact(DWORD pdh_artifact_index) {
 622   char* pdh_localized_artifact_string = NULL;
 623   // get localized name from pdh artifact index
 624   if (lookup_name_by_index(pdh_artifact_index, &amp;pdh_localized_artifact_string) != OS_OK) {
 625     return NULL;
</pre>
<hr />
<pre>
 642   char* module_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, MAX_PATH);
 643   if (NULL == module_name) {
 644     return NULL;
 645   }
 646   // Find our module name and use it to extract the image name used by PDH
 647   DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
 648   if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
 649     return NULL;
 650   }
 651   if (os::get_last_error() == ERROR_INSUFFICIENT_BUFFER) {
 652     return NULL;
 653   }
 654   char* process_image_name = strrchr(module_name, &#39;\\&#39;); //drop path
 655   process_image_name++;                                  //skip slash
 656   char* dot_pos = strrchr(process_image_name, &#39;.&#39;);      //drop .exe
 657   dot_pos[0] = &#39;\0&#39;;
 658   return process_image_name;
 659 }
 660 
 661 static void deallocate_pdh_constants() {
<span class="line-modified"> 662   if (process_image_name != NULL) {</span>
<span class="line-modified"> 663     FREE_C_HEAP_ARRAY(char, process_image_name);</span>
<span class="line-modified"> 664     process_image_name = NULL;</span>
<span class="line-modified"> 665   }</span>
<span class="line-removed"> 666   if (pdh_IDProcess_counter_fmt != NULL) {</span>
<span class="line-removed"> 667     FREE_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt);</span>
<span class="line-removed"> 668     pdh_IDProcess_counter_fmt = NULL;</span>
<span class="line-removed"> 669   }</span>
 670 }
 671 
 672 static int allocate_pdh_constants() {
 673   assert(process_image_name == NULL, &quot;invariant&quot;);
 674   const char* pdh_image_name = pdh_process_image_name();
 675   if (pdh_image_name == NULL) {
 676     return OS_ERR;
 677   }
 678   process_image_name = copy_string_to_c_heap(pdh_image_name);
 679 
 680   const char* pdh_localized_process_object = pdh_localized_artifact(PDH_PROCESS_IDX);
 681   if (pdh_localized_process_object == NULL) {
 682     return OS_ERR;
 683   }
 684 
 685   const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
 686   if (pdh_localized_IDProcess_counter == NULL) {
 687     return OS_ERR;
 688   }
 689 
</pre>
<hr />
<pre>
 838     if (add_counter(cpu_query, &amp;cpu_query-&gt;counters[index], counter_path, false) != OS_OK) {
 839       // performance counter is disabled in registry and not accessible via PerfLib
 840       log_error_message_on_no_PDH_artifact(counter_path);
 841       // return OS_OK to have the system continue to run without the missing counter
 842       return OS_OK;
 843     }
 844   }
 845   cpu_query-&gt;initialized = true;
 846   // Query once to initialize the counters which require at least two samples
 847   // (like the % CPU usage) to calculate correctly.
 848   collect_query_data(cpu_query);
 849   return OS_OK;
 850 }
 851 
 852 static int initialize_cpu_query(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {
 853   assert(cpu_query != NULL, &quot;invariant&quot;);
 854   assert(!cpu_query-&gt;initialized, &quot;invariant&quot;);
 855   const int logical_cpu_count = number_of_logical_cpus();
 856   assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
 857   // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified"> 858   if (allocate_counters(cpu_query, logical_cpu_count + 1) != OS_OK) {</span>
<span class="line-removed"> 859     return OS_ERR;</span>
<span class="line-removed"> 860   }</span>
 861   assert(cpu_query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);
 862   return initialize_cpu_query_counters(cpu_query, pdh_counter_idx);
 863 }
 864 
 865 static int initialize_process_counter(ProcessQueryP process_query, int slot_index, DWORD pdh_counter_index) {
 866   char* localized_process_object;
 867   if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
 868     return OS_ERR;
 869   }
 870   assert(localized_process_object != NULL, &quot;invariant&quot;);
 871   char* localized_counter_name;
 872   if (lookup_name_by_index(pdh_counter_index, &amp;localized_counter_name) != OS_OK) {
 873     return OS_ERR;
 874   }
 875   assert(localized_counter_name != NULL, &quot;invariant&quot;);
 876   for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
 877     char instanceIndexBuffer[32];
 878     const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
 879                                                                  localized_counter_name,
 880                                                                  process_image_name,
</pre>
<hr />
<pre>
1006   ProcessIterator* _iterator;
1007   SystemProcesses();
1008   ~SystemProcesses();
1009   bool initialize();
1010 
1011   // information about system processes
1012   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;
1013 };
1014 
1015 CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
1016 
1017 bool CPUPerformanceInterface::CPUPerformance::initialize() {
1018   if (!pdh_acquire()) {
1019     return true;
1020   }
1021   _context_switches = create_counter_query(PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);
1022   _process_cpu_load = create_process_query();
1023   if (_process_cpu_load == NULL) {
1024     return true;
1025   }
<span class="line-modified">1026   if (allocate_counters(_process_cpu_load, 2) != OS_OK) {</span>
<span class="line-removed">1027     return true;</span>
<span class="line-removed">1028   }</span>
1029   if (initialize_process_counter(_process_cpu_load, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {
1030     return true;
1031   }
1032   if (initialize_process_counter(_process_cpu_load, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {
1033     return true;
1034   }
1035   _process_cpu_load-&gt;set.initialized = true;
1036   _machine_cpu_load = create_multi_counter_query();
1037   if (_machine_cpu_load == NULL) {
1038     return true;
1039   }
1040   initialize_cpu_query(_machine_cpu_load, PDH_PROCESSOR_TIME_IDX);
1041   return true;
1042 }
1043 
1044 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
1045   if (_context_switches != NULL) {
1046     destroy_counter_query(_context_switches);
1047     _context_switches = NULL;
1048   }
1049   if (_process_cpu_load != NULL) {
1050     destroy_counter_query(_process_cpu_load);
1051     _process_cpu_load = NULL;
1052   }
1053   if (_machine_cpu_load != NULL) {
1054     destroy_counter_query(_machine_cpu_load);
1055     _machine_cpu_load = NULL;
1056   }
1057   pdh_release();
1058 }
1059 
1060 CPUPerformanceInterface::CPUPerformanceInterface() {
1061   _impl = NULL;
1062 }
1063 
1064 bool CPUPerformanceInterface::initialize() {
1065   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">1066   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1067 }
1068 
1069 CPUPerformanceInterface::~CPUPerformanceInterface() {
1070   if (_impl != NULL) {
1071     delete _impl;
1072   }
1073 }
1074 
1075 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
1076   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
1077 }
1078 
1079 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
1080   return _impl-&gt;context_switch_rate(rate);
1081 }
1082 
1083 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
1084   return _impl-&gt;cpu_load_total_process(cpu_load);
1085 }
1086 
</pre>
<hr />
<pre>
1252 }
1253 
1254 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
1255   if (str != NULL) {
1256     return os::strdup_check_oom(str, mtInternal);
1257   }
1258   return NULL;
1259 }
1260 
1261 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
1262   _valid = Process32Next(_hProcessSnap, &amp;_pe32);
1263   return OS_OK;
1264 }
1265 
1266 SystemProcessInterface::SystemProcesses::SystemProcesses() {
1267   _iterator = NULL;
1268 }
1269 
1270 bool SystemProcessInterface::SystemProcesses::initialize() {
1271   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">1272   return _iterator != NULL &amp;&amp; _iterator-&gt;initialize();</span>
1273 }
1274 
1275 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
1276   if (_iterator != NULL) {
1277     delete _iterator;
1278     _iterator = NULL;
1279   }
1280 }
1281 
1282 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
1283                                                               int* no_of_sys_processes) const {
1284   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
1285   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
1286   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
1287 
1288   // initialize pointers
1289   *no_of_sys_processes = 0;
1290   *system_processes = NULL;
1291 
1292   // take process snapshot
</pre>
<hr />
<pre>
1307     *system_processes = tmp;
1308     // increment
1309     (*no_of_sys_processes)++;
1310     // step forward
1311     _iterator-&gt;next_process();
1312   }
1313   return OS_OK;
1314 }
1315 
1316 int SystemProcessInterface::system_processes(SystemProcess** system_procs,
1317                                              int* no_of_sys_processes) const {
1318   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
1319 }
1320 
1321 SystemProcessInterface::SystemProcessInterface() {
1322   _impl = NULL;
1323 }
1324 
1325 bool SystemProcessInterface::initialize() {
1326   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">1327   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1328 }
1329 
1330 SystemProcessInterface::~SystemProcessInterface() {
1331   if (_impl != NULL) {
1332     delete _impl;
1333   }
1334 }
1335 
1336 CPUInformationInterface::CPUInformationInterface() {
1337   _cpu_info = NULL;
1338 }
1339 
1340 bool CPUInformationInterface::initialize() {
1341   _cpu_info = new CPUInformation();
<span class="line-removed">1342   if (NULL == _cpu_info) {</span>
<span class="line-removed">1343     return false;</span>
<span class="line-removed">1344   }</span>
1345   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1346   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1347   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1348   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1349   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
1350   return true;
1351 }
1352 
1353 CPUInformationInterface::~CPUInformationInterface() {
1354   if (_cpu_info != NULL) {
<span class="line-modified">1355     const char* cpu_name = _cpu_info-&gt;cpu_name();</span>
<span class="line-modified">1356     if (cpu_name != NULL) {</span>
<span class="line-modified">1357       FREE_C_HEAP_ARRAY(char, cpu_name);</span>
<span class="line-modified">1358       _cpu_info-&gt;set_cpu_name(NULL);</span>
<span class="line-removed">1359     }</span>
<span class="line-removed">1360     const char* cpu_desc = _cpu_info-&gt;cpu_description();</span>
<span class="line-removed">1361     if (cpu_desc != NULL) {</span>
<span class="line-removed">1362       FREE_C_HEAP_ARRAY(char, cpu_desc);</span>
<span class="line-removed">1363       _cpu_info-&gt;set_cpu_description(NULL);</span>
<span class="line-removed">1364     }</span>
1365     delete _cpu_info;
1366     _cpu_info = NULL;
1367   }
1368 }
1369 
1370 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1371   if (NULL == _cpu_info) {
1372     return OS_ERR;
1373   }
1374   cpu_info = *_cpu_info; // shallow copy assignment
1375   return OS_OK;
1376 }
1377 
1378 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1379   friend class NetworkPerformanceInterface;
1380  private:
1381   bool _iphlp_attached;
1382 
1383   NetworkPerformance();
<span class="line-modified">1384   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">1385   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
1386   bool initialize();
1387   ~NetworkPerformance();
1388   int network_utilization(NetworkInterface** network_interfaces) const;
1389 };
1390 
1391 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance()
1392 : _iphlp_attached(false) {
1393 }
1394 
1395 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1396   _iphlp_attached = IphlpDll::IphlpAttach();
1397   return _iphlp_attached;
1398 }
1399 
1400 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1401   if (_iphlp_attached) {
1402     IphlpDll::IphlpDetach();
1403   }
1404 }
1405 
</pre>
<hr />
<pre>
1426   }
1427 
1428   IphlpDll::FreeMibTable(table);
1429   *network_interfaces = ret;
1430 
1431   return OS_OK;
1432 }
1433 
1434 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1435   _impl = NULL;
1436 }
1437 
1438 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1439   if (_impl != NULL) {
1440     delete _impl;
1441   }
1442 }
1443 
1444 bool NetworkPerformanceInterface::initialize() {
1445   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">1446   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1447 }
1448 
1449 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1450   return _impl-&gt;network_utilization(network_interfaces);
1451 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;iphlp_interface.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;pdh_interface.hpp&quot;
  31 #include &quot;runtime/os_perf.hpp&quot;
  32 #include &quot;runtime/os.hpp&quot;
<span class="line-added">  33 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  34 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  35 #include CPU_HEADER(vm_version_ext)</span>
  36 #include &lt;math.h&gt;
  37 #include &lt;psapi.h&gt;
  38 #include &lt;TlHelp32.h&gt;
  39 
  40 /*
  41  * Windows provides a vast plethora of performance objects and counters,
  42  * consumption of which is assisted using the Performance Data Helper (PDH) interface.
  43  * We import a selected few api entry points from PDH, see pdh_interface.hpp.
  44  *
  45  * The code located in this file is to a large extent an abstraction over much of the
  46  * plumbing needed to start consuming an object and/or counter of choice.
  47  *
  48  */
  49 
  50  /*
  51  * How to use:
  52  * 1. Create query
  53  * 2. Add counters to the query
  54  * 3. Collect the performance data using the query
  55  * 4. Display the performance data using the counters associated with the query
</pre>
<hr />
<pre>
  80 static const char* const OBJECT_COUNTER_FMT = &quot;\\%s\\%s&quot;;
  81 static const size_t OBJECT_COUNTER_FMT_LEN = 2;
  82 static const char* const OBJECT_WITH_INSTANCES_COUNTER_FMT = &quot;\\%s(%s)\\%s&quot;;
  83 static const size_t OBJECT_WITH_INSTANCES_COUNTER_FMT_LEN = 4;
  84 static const char* const PROCESS_OBJECT_INSTANCE_COUNTER_FMT = &quot;\\%s(%s#%s)\\%s&quot;;
  85 static const size_t PROCESS_OBJECT_INSTANCE_COUNTER_FMT_LEN = 5;
  86 
  87 static const char* process_image_name = NULL; // for example, &quot;java&quot; but could have another image name
  88 static char* pdh_IDProcess_counter_fmt = NULL;   // &quot;\Process(java#%d)\ID Process&quot; */
  89 
  90 // Need to limit how often we update a query to minimize the heisenberg effect.
  91 // (PDH behaves erratically if the counters are queried too often, especially counters that
  92 // store and use values from two consecutive updates, like cpu load.)
  93 static const int min_update_interval_millis = 500;
  94 
  95 /*
  96 * Structs for PDH queries.
  97 */
  98 typedef struct {
  99   HQUERY query;
<span class="line-modified"> 100   s8     lastUpdate; // Last time query was updated.</span>
 101 } UpdateQueryS, *UpdateQueryP;
 102 
 103 
 104 typedef struct {
 105   UpdateQueryS query;
 106   HCOUNTER     counter;
 107   bool         initialized;
 108 } CounterQueryS, *CounterQueryP;
 109 
 110 typedef struct {
 111   UpdateQueryS query;
 112   HCOUNTER*    counters;
 113   int          noOfCounters;
 114   bool         initialized;
 115 } MultiCounterQueryS, *MultiCounterQueryP;
 116 
 117 typedef struct {
 118   MultiCounterQueryP queries;
 119   int                size;
 120   bool               initialized;
 121 } MultiCounterQuerySetS, *MultiCounterQuerySetP;
 122 
 123 typedef struct {
 124   MultiCounterQuerySetS set;
 125   int                   process_index;
 126 } ProcessQueryS, *ProcessQueryP;
 127 
 128 static void pdh_cleanup(HQUERY* const query, HCOUNTER* const counter) {
 129   if (counter != NULL &amp;&amp; *counter != NULL) {
 130     PdhDll::PdhRemoveCounter(*counter);
 131     *counter = NULL;
 132   }
 133   if (query != NULL &amp;&amp; *query != NULL) {
 134     PdhDll::PdhCloseQuery(*query);
 135     *query = NULL;
 136   }
 137 }
 138 
 139 static CounterQueryP create_counter_query() {
<span class="line-modified"> 140   CounterQueryP const query = NEW_C_HEAP_OBJ(CounterQueryS, mtInternal);</span>
 141   memset(query, 0, sizeof(CounterQueryS));
 142   return query;
 143 }
 144 
 145 static void destroy_counter_query(CounterQueryP query) {
 146   assert(query != NULL, &quot;invariant&quot;);
 147   pdh_cleanup(&amp;query-&gt;query.query, &amp;query-&gt;counter);
<span class="line-modified"> 148   FREE_C_HEAP_OBJ(query);</span>
 149 }
 150 
 151 static MultiCounterQueryP create_multi_counter_query() {
 152   MultiCounterQueryP const query = NEW_C_HEAP_ARRAY(MultiCounterQueryS, 1, mtInternal);
 153   memset(query, 0, sizeof(MultiCounterQueryS));
 154   return query;
 155 }
 156 
 157 static void destroy_counter_query(MultiCounterQueryP counter_query) {
 158   if (counter_query != NULL) {
 159     for (int i = 0; i &lt; counter_query-&gt;noOfCounters; ++i) {
 160       pdh_cleanup(NULL, &amp;counter_query-&gt;counters[i]);
 161     }
 162     FREE_C_HEAP_ARRAY(char, counter_query-&gt;counters);
 163     pdh_cleanup(&amp;counter_query-&gt;query.query, NULL);
 164     FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query);
 165   }
 166 }
 167 
 168 static void destroy_multi_counter_query(MultiCounterQuerySetP counter_query_set) {
 169   for (int i = 0; i &lt; counter_query_set-&gt;size; i++) {
 170     for (int j = 0; j &lt; counter_query_set-&gt;queries[i].noOfCounters; ++j) {
 171       pdh_cleanup(NULL, &amp;counter_query_set-&gt;queries[i].counters[j]);
 172     }
 173     FREE_C_HEAP_ARRAY(char, counter_query_set-&gt;queries[i].counters);
 174     pdh_cleanup(&amp;counter_query_set-&gt;queries[i].query.query, NULL);
 175   }
 176   FREE_C_HEAP_ARRAY(MultiCounterQueryS, counter_query_set-&gt;queries);
 177 }
 178 
 179 static void destroy_counter_query(MultiCounterQuerySetP counter_query_set) {
 180   destroy_multi_counter_query(counter_query_set);
 181   FREE_C_HEAP_ARRAY(MultiCounterQuerySetS, counter_query_set);
 182 }
 183 
 184 static void destroy_counter_query(ProcessQueryP process_query) {
 185   destroy_multi_counter_query(&amp;process_query-&gt;set);
<span class="line-modified"> 186   FREE_C_HEAP_OBJ(process_query);</span>
 187 }
 188 
 189 static int open_query(HQUERY* query) {
 190   return PdhDll::PdhOpenQuery(NULL, 0, query);
 191 }
 192 
 193 template &lt;typename QueryP&gt;
 194 static int open_query(QueryP query) {
 195   return open_query(&amp;query-&gt;query);
 196 }
 197 
<span class="line-modified"> 198 static void allocate_counters(MultiCounterQueryP query, size_t nofCounters) {</span>
 199   assert(query != NULL, &quot;invariant&quot;);
 200   assert(!query-&gt;initialized, &quot;invariant&quot;);
 201   assert(0 == query-&gt;noOfCounters, &quot;invariant&quot;);
 202   assert(query-&gt;counters == NULL, &quot;invariant&quot;);
<span class="line-modified"> 203   query-&gt;counters = NEW_C_HEAP_ARRAY(HCOUNTER, nofCounters, mtInternal);</span>



 204   memset(query-&gt;counters, 0, nofCounters * sizeof(HCOUNTER));
 205   query-&gt;noOfCounters = (int)nofCounters;

 206 }
 207 
<span class="line-modified"> 208 static void allocate_counters(MultiCounterQuerySetP query_set, size_t nofCounters) {</span>
 209   assert(query_set != NULL, &quot;invariant&quot;);
 210   assert(!query_set-&gt;initialized, &quot;invariant&quot;);
 211   for (int i = 0; i &lt; query_set-&gt;size; ++i) {
<span class="line-modified"> 212     allocate_counters(&amp;query_set-&gt;queries[i], nofCounters);</span>


 213   }

 214 }
 215 
<span class="line-modified"> 216 static void allocate_counters(ProcessQueryP process_query, size_t nofCounters) {</span>
 217   assert(process_query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 218   allocate_counters(&amp;process_query-&gt;set, nofCounters);</span>
 219 }
 220 
 221 static void deallocate_counters(MultiCounterQueryP query) {
<span class="line-modified"> 222   FREE_C_HEAP_ARRAY(char, query-&gt;counters);</span>
<span class="line-modified"> 223   query-&gt;counters = NULL;</span>
<span class="line-modified"> 224   query-&gt;noOfCounters = 0;</span>


 225 }
 226 
 227 static OSReturn add_counter(UpdateQueryP query, HCOUNTER* counter, const char* path, bool first_sample_on_init) {
 228   assert(query != NULL, &quot;invariant&quot;);
 229   assert(counter != NULL, &quot;invariant&quot;);
 230   assert(path != NULL, &quot;invariant&quot;);
 231   if (query-&gt;query == NULL) {
 232     if (open_query(query) != ERROR_SUCCESS) {
 233       return OS_ERR;
 234     }
 235   }
 236   assert(query-&gt;query != NULL, &quot;invariant&quot;);
 237   PDH_STATUS status = PdhDll::PdhAddCounter(query-&gt;query, path, 0, counter);
 238   if (PDH_CSTATUS_NO_OBJECT == status || PDH_CSTATUS_NO_COUNTER == status) {
 239     return OS_ERR;
 240   }
 241   /*
 242   * According to the MSDN documentation, rate counters must be read twice:
 243   *
 244   * &quot;Obtaining the value of rate counters such as Page faults/sec requires that
</pre>
<hr />
<pre>
 270   }
 271   counter_query-&gt;initialized = true;
 272   return OS_OK;
 273 }
 274 
 275 static OSReturn add_process_counter(MultiCounterQueryP query, int slot_index, const char* path, bool first_sample_on_init) {
 276   assert(query != NULL, &quot;invariant&quot;);
 277   assert(slot_index &lt; query-&gt;noOfCounters, &quot;invariant&quot;);
 278   assert(query-&gt;counters[slot_index] == NULL, &quot;invariant&quot;);
 279   const OSReturn ret = add_counter(query, &amp;query-&gt;counters[slot_index], path, first_sample_on_init);
 280   if (OS_OK == ret) {
 281     if (slot_index + 1 == query-&gt;noOfCounters) {
 282       query-&gt;initialized = true;
 283     }
 284   }
 285   return ret;
 286 }
 287 
 288 static int collect_query_data(UpdateQueryP update_query) {
 289   assert(update_query != NULL, &quot;invariant&quot;);
<span class="line-modified"> 290   const s8 now = os::javaTimeNanos();</span>
<span class="line-modified"> 291   if (nanos_to_millis(now - update_query-&gt;lastUpdate) &gt; min_update_interval_millis) {</span>
 292     if (PdhDll::PdhCollectQueryData(update_query-&gt;query) != ERROR_SUCCESS) {
 293       return OS_ERR;
 294     }
 295     update_query-&gt;lastUpdate = now;
 296   }
 297   return OS_OK;
 298 }
 299 
 300 template &lt;typename Query&gt;
 301 static int collect_query_data(Query* counter_query) {
 302   assert(counter_query != NULL, &quot;invariant&quot;);
 303   return collect_query_data(&amp;counter_query-&gt;query);
 304 }
 305 
 306 static int formatted_counter_value(HCOUNTER counter, DWORD format, PDH_FMT_COUNTERVALUE* const value) {
 307   assert(value != NULL, &quot;invariant&quot;);
 308   if (PdhDll::PdhGetFormattedCounterValue(counter, format, NULL, value) != ERROR_SUCCESS) {
 309     return OS_ERR;
 310   }
 311   return OS_OK;
</pre>
<hr />
<pre>
 363       return OS_ERR;
 364     } else {
 365       PDH_FMT_COUNTERVALUE counter_value;
 366       formatted_counter_value(handle_counter, PDH_FMT_LONG, &amp;counter_value);
 367       pdh_cleanup(NULL, &amp;handle_counter);
 368       if ((LONG)os::current_process_id() == counter_value.longValue) {
 369         pdh_cleanup(&amp;tmpQuery, NULL);
 370         return index;
 371       }
 372     }
 373   }
 374   pdh_cleanup(&amp;tmpQuery, NULL);
 375   return OS_ERR;
 376 }
 377 
 378 static ProcessQueryP create_process_query() {
 379   const int current_process_idx = current_query_index_for_process();
 380   if (OS_ERR == current_process_idx) {
 381     return NULL;
 382   }
<span class="line-modified"> 383   ProcessQueryP const process_query = NEW_C_HEAP_OBJ(ProcessQueryS, mtInternal);</span>
 384   memset(process_query, 0, sizeof(ProcessQueryS));
 385   process_query-&gt;set.queries = NEW_C_HEAP_ARRAY(MultiCounterQueryS, current_process_idx + 1, mtInternal);
 386   memset(process_query-&gt;set.queries, 0, sizeof(MultiCounterQueryS) * (current_process_idx + 1));
 387   process_query-&gt;process_index = current_process_idx;
 388   process_query-&gt;set.size = current_process_idx + 1;
 389   assert(process_query-&gt;set.size &gt; process_query-&gt;process_index, &quot;invariant&quot;);
 390   return process_query;
 391 }
 392 
 393 static MultiCounterQueryP current_process_counter_query(ProcessQueryP process_query) {
 394   assert(process_query != NULL, &quot;invariant&quot;);
 395   assert(process_query-&gt;process_index &lt; process_query-&gt;set.size, &quot;invariant&quot;);
 396   return &amp;process_query-&gt;set.queries[process_query-&gt;process_index];
 397 }
 398 
 399 static void clear_multi_counter(MultiCounterQueryP query) {
 400   for (int i = 0; i &lt; query-&gt;noOfCounters; ++i) {
 401     pdh_cleanup(NULL, &amp;query-&gt;counters[i]);
 402   }
 403   pdh_cleanup(&amp;query-&gt;query.query, NULL);
</pre>
<hr />
<pre>
 577   PDH_STATUS status = PdhDll::PdhLookupPerfNameByIndex(NULL, index, NULL, &amp;size);
 578   assert(status == PDH_MORE_DATA, &quot;invariant&quot;);
 579   *p_string = NEW_RESOURCE_ARRAY_RETURN_NULL(char, size);
 580   if (*p_string== NULL) {
 581     return OS_ERR;
 582   }
 583   if (PdhDll::PdhLookupPerfNameByIndex(NULL, index, *p_string, &amp;size) != ERROR_SUCCESS) {
 584     return OS_ERR;
 585   }
 586   if (0 == size || *p_string == NULL) {
 587     return OS_ERR;
 588   }
 589   // windows vista does not null-terminate the string (although the docs says it will)
 590   (*p_string)[size - 1] = &#39;\0&#39;;
 591   return OS_OK;
 592 }
 593 
 594 static const char* copy_string_to_c_heap(const char* string) {
 595   assert(string != NULL, &quot;invariant&quot;);
 596   const size_t len = strlen(string);
<span class="line-modified"> 597   char* const cheap_allocated_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len + 1, mtInternal);</span>
 598   if (NULL == cheap_allocated_string) {
 599     return NULL;
 600   }
 601   strncpy(cheap_allocated_string, string, len + 1);
 602   return cheap_allocated_string;
 603 }
 604 
 605 /*
 606 * Maps an index to a resource area allocated string for the localized PDH artifact.
 607 *
 608 * Caller will need a ResourceMark.
 609 *
 610 * @param index    the counter index as specified in the registry
 611 * @return         localized pdh artifact string if successful, NULL on failure.
 612 */
 613 static const char* pdh_localized_artifact(DWORD pdh_artifact_index) {
 614   char* pdh_localized_artifact_string = NULL;
 615   // get localized name from pdh artifact index
 616   if (lookup_name_by_index(pdh_artifact_index, &amp;pdh_localized_artifact_string) != OS_OK) {
 617     return NULL;
</pre>
<hr />
<pre>
 634   char* module_name = NEW_RESOURCE_ARRAY_RETURN_NULL(char, MAX_PATH);
 635   if (NULL == module_name) {
 636     return NULL;
 637   }
 638   // Find our module name and use it to extract the image name used by PDH
 639   DWORD getmfn_return = GetModuleFileName(NULL, module_name, MAX_PATH);
 640   if (getmfn_return &gt;= MAX_PATH || 0 == getmfn_return) {
 641     return NULL;
 642   }
 643   if (os::get_last_error() == ERROR_INSUFFICIENT_BUFFER) {
 644     return NULL;
 645   }
 646   char* process_image_name = strrchr(module_name, &#39;\\&#39;); //drop path
 647   process_image_name++;                                  //skip slash
 648   char* dot_pos = strrchr(process_image_name, &#39;.&#39;);      //drop .exe
 649   dot_pos[0] = &#39;\0&#39;;
 650   return process_image_name;
 651 }
 652 
 653 static void deallocate_pdh_constants() {
<span class="line-modified"> 654   FREE_C_HEAP_ARRAY(char, process_image_name);</span>
<span class="line-modified"> 655   process_image_name = NULL;</span>
<span class="line-modified"> 656   FREE_C_HEAP_ARRAY(char, pdh_IDProcess_counter_fmt);</span>
<span class="line-modified"> 657   pdh_IDProcess_counter_fmt = NULL;</span>




 658 }
 659 
 660 static int allocate_pdh_constants() {
 661   assert(process_image_name == NULL, &quot;invariant&quot;);
 662   const char* pdh_image_name = pdh_process_image_name();
 663   if (pdh_image_name == NULL) {
 664     return OS_ERR;
 665   }
 666   process_image_name = copy_string_to_c_heap(pdh_image_name);
 667 
 668   const char* pdh_localized_process_object = pdh_localized_artifact(PDH_PROCESS_IDX);
 669   if (pdh_localized_process_object == NULL) {
 670     return OS_ERR;
 671   }
 672 
 673   const char* pdh_localized_IDProcess_counter = pdh_localized_artifact(PDH_ID_PROCESS_IDX);
 674   if (pdh_localized_IDProcess_counter == NULL) {
 675     return OS_ERR;
 676   }
 677 
</pre>
<hr />
<pre>
 826     if (add_counter(cpu_query, &amp;cpu_query-&gt;counters[index], counter_path, false) != OS_OK) {
 827       // performance counter is disabled in registry and not accessible via PerfLib
 828       log_error_message_on_no_PDH_artifact(counter_path);
 829       // return OS_OK to have the system continue to run without the missing counter
 830       return OS_OK;
 831     }
 832   }
 833   cpu_query-&gt;initialized = true;
 834   // Query once to initialize the counters which require at least two samples
 835   // (like the % CPU usage) to calculate correctly.
 836   collect_query_data(cpu_query);
 837   return OS_OK;
 838 }
 839 
 840 static int initialize_cpu_query(MultiCounterQueryP cpu_query, DWORD pdh_counter_idx) {
 841   assert(cpu_query != NULL, &quot;invariant&quot;);
 842   assert(!cpu_query-&gt;initialized, &quot;invariant&quot;);
 843   const int logical_cpu_count = number_of_logical_cpus();
 844   assert(logical_cpu_count &gt;= os::processor_count(), &quot;invariant&quot;);
 845   // we also add another counter for instance &quot;_Total&quot;
<span class="line-modified"> 846   allocate_counters(cpu_query, logical_cpu_count + 1);</span>


 847   assert(cpu_query-&gt;noOfCounters == logical_cpu_count + 1, &quot;invariant&quot;);
 848   return initialize_cpu_query_counters(cpu_query, pdh_counter_idx);
 849 }
 850 
 851 static int initialize_process_counter(ProcessQueryP process_query, int slot_index, DWORD pdh_counter_index) {
 852   char* localized_process_object;
 853   if (lookup_name_by_index(PDH_PROCESS_IDX, &amp;localized_process_object) != OS_OK) {
 854     return OS_ERR;
 855   }
 856   assert(localized_process_object != NULL, &quot;invariant&quot;);
 857   char* localized_counter_name;
 858   if (lookup_name_by_index(pdh_counter_index, &amp;localized_counter_name) != OS_OK) {
 859     return OS_ERR;
 860   }
 861   assert(localized_counter_name != NULL, &quot;invariant&quot;);
 862   for (int i = 0; i &lt; process_query-&gt;set.size; ++i) {
 863     char instanceIndexBuffer[32];
 864     const char* counter_path = make_fully_qualified_counter_path(localized_process_object,
 865                                                                  localized_counter_name,
 866                                                                  process_image_name,
</pre>
<hr />
<pre>
 992   ProcessIterator* _iterator;
 993   SystemProcesses();
 994   ~SystemProcesses();
 995   bool initialize();
 996 
 997   // information about system processes
 998   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;
 999 };
1000 
1001 CPUPerformanceInterface::CPUPerformance::CPUPerformance() : _context_switches(NULL), _process_cpu_load(NULL), _machine_cpu_load(NULL) {}
1002 
1003 bool CPUPerformanceInterface::CPUPerformance::initialize() {
1004   if (!pdh_acquire()) {
1005     return true;
1006   }
1007   _context_switches = create_counter_query(PDH_SYSTEM_IDX, PDH_CONTEXT_SWITCH_RATE_IDX);
1008   _process_cpu_load = create_process_query();
1009   if (_process_cpu_load == NULL) {
1010     return true;
1011   }
<span class="line-modified">1012   allocate_counters(_process_cpu_load, 2);</span>


1013   if (initialize_process_counter(_process_cpu_load, 0, PDH_PROCESSOR_TIME_IDX) != OS_OK) {
1014     return true;
1015   }
1016   if (initialize_process_counter(_process_cpu_load, 1, PDH_PRIV_PROCESSOR_TIME_IDX) != OS_OK) {
1017     return true;
1018   }
1019   _process_cpu_load-&gt;set.initialized = true;
1020   _machine_cpu_load = create_multi_counter_query();
1021   if (_machine_cpu_load == NULL) {
1022     return true;
1023   }
1024   initialize_cpu_query(_machine_cpu_load, PDH_PROCESSOR_TIME_IDX);
1025   return true;
1026 }
1027 
1028 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
1029   if (_context_switches != NULL) {
1030     destroy_counter_query(_context_switches);
1031     _context_switches = NULL;
1032   }
1033   if (_process_cpu_load != NULL) {
1034     destroy_counter_query(_process_cpu_load);
1035     _process_cpu_load = NULL;
1036   }
1037   if (_machine_cpu_load != NULL) {
1038     destroy_counter_query(_machine_cpu_load);
1039     _machine_cpu_load = NULL;
1040   }
1041   pdh_release();
1042 }
1043 
1044 CPUPerformanceInterface::CPUPerformanceInterface() {
1045   _impl = NULL;
1046 }
1047 
1048 bool CPUPerformanceInterface::initialize() {
1049   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">1050   return _impl-&gt;initialize();</span>
1051 }
1052 
1053 CPUPerformanceInterface::~CPUPerformanceInterface() {
1054   if (_impl != NULL) {
1055     delete _impl;
1056   }
1057 }
1058 
1059 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
1060   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
1061 }
1062 
1063 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
1064   return _impl-&gt;context_switch_rate(rate);
1065 }
1066 
1067 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
1068   return _impl-&gt;cpu_load_total_process(cpu_load);
1069 }
1070 
</pre>
<hr />
<pre>
1236 }
1237 
1238 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
1239   if (str != NULL) {
1240     return os::strdup_check_oom(str, mtInternal);
1241   }
1242   return NULL;
1243 }
1244 
1245 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
1246   _valid = Process32Next(_hProcessSnap, &amp;_pe32);
1247   return OS_OK;
1248 }
1249 
1250 SystemProcessInterface::SystemProcesses::SystemProcesses() {
1251   _iterator = NULL;
1252 }
1253 
1254 bool SystemProcessInterface::SystemProcesses::initialize() {
1255   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">1256   return _iterator-&gt;initialize();</span>
1257 }
1258 
1259 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
1260   if (_iterator != NULL) {
1261     delete _iterator;
1262     _iterator = NULL;
1263   }
1264 }
1265 
1266 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes,
1267                                                               int* no_of_sys_processes) const {
1268   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
1269   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
1270   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
1271 
1272   // initialize pointers
1273   *no_of_sys_processes = 0;
1274   *system_processes = NULL;
1275 
1276   // take process snapshot
</pre>
<hr />
<pre>
1291     *system_processes = tmp;
1292     // increment
1293     (*no_of_sys_processes)++;
1294     // step forward
1295     _iterator-&gt;next_process();
1296   }
1297   return OS_OK;
1298 }
1299 
1300 int SystemProcessInterface::system_processes(SystemProcess** system_procs,
1301                                              int* no_of_sys_processes) const {
1302   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
1303 }
1304 
1305 SystemProcessInterface::SystemProcessInterface() {
1306   _impl = NULL;
1307 }
1308 
1309 bool SystemProcessInterface::initialize() {
1310   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">1311   return _impl-&gt;initialize();</span>
1312 }
1313 
1314 SystemProcessInterface::~SystemProcessInterface() {
1315   if (_impl != NULL) {
1316     delete _impl;
1317   }
1318 }
1319 
1320 CPUInformationInterface::CPUInformationInterface() {
1321   _cpu_info = NULL;
1322 }
1323 
1324 bool CPUInformationInterface::initialize() {
1325   _cpu_info = new CPUInformation();



1326   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
1327   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
1328   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1329   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1330   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
1331   return true;
1332 }
1333 
1334 CPUInformationInterface::~CPUInformationInterface() {
1335   if (_cpu_info != NULL) {
<span class="line-modified">1336     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_name());</span>
<span class="line-modified">1337     _cpu_info-&gt;set_cpu_name(NULL);</span>
<span class="line-modified">1338     FREE_C_HEAP_ARRAY(char, _cpu_info-&gt;cpu_description());</span>
<span class="line-modified">1339     _cpu_info-&gt;set_cpu_description(NULL);</span>






1340     delete _cpu_info;
1341     _cpu_info = NULL;
1342   }
1343 }
1344 
1345 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1346   if (NULL == _cpu_info) {
1347     return OS_ERR;
1348   }
1349   cpu_info = *_cpu_info; // shallow copy assignment
1350   return OS_OK;
1351 }
1352 
1353 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1354   friend class NetworkPerformanceInterface;
1355  private:
1356   bool _iphlp_attached;
1357 
1358   NetworkPerformance();
<span class="line-modified">1359   NONCOPYABLE(NetworkPerformance);</span>

1360   bool initialize();
1361   ~NetworkPerformance();
1362   int network_utilization(NetworkInterface** network_interfaces) const;
1363 };
1364 
1365 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance()
1366 : _iphlp_attached(false) {
1367 }
1368 
1369 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1370   _iphlp_attached = IphlpDll::IphlpAttach();
1371   return _iphlp_attached;
1372 }
1373 
1374 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1375   if (_iphlp_attached) {
1376     IphlpDll::IphlpDetach();
1377   }
1378 }
1379 
</pre>
<hr />
<pre>
1400   }
1401 
1402   IphlpDll::FreeMibTable(table);
1403   *network_interfaces = ret;
1404 
1405   return OS_OK;
1406 }
1407 
1408 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1409   _impl = NULL;
1410 }
1411 
1412 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1413   if (_impl != NULL) {
1414     delete _impl;
1415   }
1416 }
1417 
1418 bool NetworkPerformanceInterface::initialize() {
1419   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">1420   return _impl-&gt;initialize();</span>
1421 }
1422 
1423 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1424   return _impl-&gt;network_utilization(network_interfaces);
1425 }
</pre>
</td>
</tr>
</table>
<center><a href="osThread_windows.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
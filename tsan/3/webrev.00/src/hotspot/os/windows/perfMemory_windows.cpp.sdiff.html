<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/perfMemory_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_windows.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="semaphore_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/perfMemory_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 377         }
 378 
 379         // If we found a matching file with a newer creation time, then
 380         // save the user name. The newer creation time indicates that
 381         // we found a newer incarnation of the process associated with
 382         // vmid. Due to the way that Windows recycles pids and the fact
 383         // that we can&#39;t delete the file from the file system namespace
 384         // until last close, it is possible for there to be more than
 385         // one hsperfdata file with a name matching vmid (diff users).
 386         //
 387         // We no longer ignore hsperfdata files where (st_size == 0).
 388         // In this function, all we&#39;re trying to do is determine the
 389         // name of the user that owns the process associated with vmid
 390         // so the size doesn&#39;t matter. Very rarely, we have observed
 391         // hsperfdata files where (st_size == 0) and the st_size field
 392         // later becomes the expected value.
 393         //
 394         if (statbuf.st_ctime &gt; latest_ctime) {
 395           char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 396 
<span class="line-modified"> 397           if (latest_user != NULL) FREE_C_HEAP_ARRAY(char, latest_user);</span>
 398           latest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 399 
 400           strcpy(latest_user, user);
 401           latest_ctime = statbuf.st_ctime;
 402         }
 403 
 404         FREE_C_HEAP_ARRAY(char, filename);
 405       }
 406     }
 407     os::closedir(subdirp);
 408     FREE_C_HEAP_ARRAY(char, usrdir_name);
 409   }
 410   os::closedir(tmpdirp);
 411 
 412   return(latest_user);
 413 }
 414 
 415 // return the name of the user that owns the process identified by vmid.
 416 //
 417 // note: this method should only be used via the Perf native methods.
</pre>
<hr />
<pre>
 747     if (success &amp;&amp; exists &amp;&amp; pACL != NULL &amp;&amp; !isdefault) {
 748       FREE_C_HEAP_ARRAY(char, pACL);
 749     }
 750 
 751     // free the security descriptor
 752     FREE_C_HEAP_ARRAY(char, pSD);
 753   }
 754 }
 755 
 756 // method to free up a security attributes structure and any
 757 // contained security descriptors and ACL
 758 //
 759 static void free_security_attr(LPSECURITY_ATTRIBUTES lpSA) {
 760 
 761   if (lpSA != NULL) {
 762     // free the contained security descriptor and the ACL
 763     free_security_desc(lpSA-&gt;lpSecurityDescriptor);
 764     lpSA-&gt;lpSecurityDescriptor = NULL;
 765 
 766     // free the security attributes structure
<span class="line-modified"> 767     FREE_C_HEAP_ARRAY(char, lpSA);</span>
 768   }
 769 }
 770 
 771 // get the user SID for the process indicated by the process handle
 772 //
 773 static PSID get_user_sid(HANDLE hProcess) {
 774 
 775   HANDLE hAccessToken;
 776   PTOKEN_USER token_buf = NULL;
 777   DWORD rsize = 0;
 778 
 779   if (hProcess == NULL) {
 780     return NULL;
 781   }
 782 
 783   // get the process token
 784   if (!OpenProcessToken(hProcess, TOKEN_READ, &amp;hAccessToken)) {
 785     if (PrintMiscellaneous &amp;&amp; Verbose) {
 786       warning(&quot;OpenProcessToken failure: lasterror = %d \n&quot;, GetLastError());
 787     }
</pre>
<hr />
<pre>
1056 
1057   // initialize the security descriptor
1058   if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
1059     if (PrintMiscellaneous &amp;&amp; Verbose) {
1060       warning(&quot;InitializeSecurityDescriptor failure: &quot;
1061               &quot;lasterror = %d \n&quot;, GetLastError());
1062     }
1063     free_security_desc(pSD);
1064     return NULL;
1065   }
1066 
1067   // add the access control entries
1068   if (!add_allow_aces(pSD, aces, count)) {
1069     free_security_desc(pSD);
1070     return NULL;
1071   }
1072 
1073   // allocate and initialize the security attributes structure and
1074   // return it to the caller.
1075   //
<span class="line-modified">1076   LPSECURITY_ATTRIBUTES lpSA = (LPSECURITY_ATTRIBUTES)</span>
<span class="line-modified">1077     NEW_C_HEAP_ARRAY(char, sizeof(SECURITY_ATTRIBUTES), mtInternal);</span>
1078   lpSA-&gt;nLength = sizeof(SECURITY_ATTRIBUTES);
1079   lpSA-&gt;lpSecurityDescriptor = pSD;
1080   lpSA-&gt;bInheritHandle = FALSE;
1081 
1082   return(lpSA);
1083 }
1084 
1085 // method to create a security attributes structure with a restrictive
1086 // access control list that creates a set access rights for the user/owner
1087 // of the securable object and a separate set access rights for everyone else.
1088 // also provides for full access rights for the administrator group.
1089 //
1090 // the caller must free the resources associated with the security
1091 // attributes structure created by this method by calling the
1092 // free_security_attr() method.
1093 //
1094 
1095 static LPSECURITY_ATTRIBUTES make_user_everybody_admin_security_attr(
1096                                 DWORD umask, DWORD emask, DWORD amask) {
1097 
</pre>
<hr />
<pre>
1544   //
1545   // on win95/98/me, _stat returns a file size of 0 bytes, but on
1546   // winnt/2k the appropriate file size is returned. support for
1547   // the sharable aspects of performance counters was abandonded
1548   // on the non-nt win32 platforms due to this and other api
1549   // inconsistencies
1550   //
1551   if (::stat(filename, &amp;statbuf) == OS_ERR) {
1552     if (PrintMiscellaneous &amp;&amp; Verbose) {
1553       warning(&quot;stat %s failed: %s\n&quot;, filename, os::strerror(errno));
1554     }
1555     THROW_MSG_0(vmSymbols::java_io_IOException(),
1556                 &quot;Could not determine PerfMemory size&quot;);
1557   }
1558 
1559   if ((statbuf.st_size == 0) || (statbuf.st_size % os::vm_page_size() != 0)) {
1560     if (PrintMiscellaneous &amp;&amp; Verbose) {
1561       warning(&quot;unexpected file size: size = &quot; SIZE_FORMAT &quot;\n&quot;,
1562               statbuf.st_size);
1563     }
<span class="line-modified">1564     THROW_MSG_0(vmSymbols::java_lang_Exception(),</span>
1565                 &quot;Invalid PerfMemory size&quot;);
1566   }
1567 
1568   return statbuf.st_size;
1569 }
1570 
1571 // this method opens a file mapping object and maps the object
1572 // into the address space of the process
1573 //
1574 static void open_file_mapping(const char* user, int vmid,
1575                               PerfMemory::PerfMemoryMode mode,
1576                               char** addrp, size_t* sizep, TRAPS) {
1577 
1578   ResourceMark rm;
1579 
1580   void *mapAddress = 0;
1581   size_t size = 0;
1582   HANDLE fmh;
1583   DWORD ofm_access;
1584   DWORD mv_access;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 377         }
 378 
 379         // If we found a matching file with a newer creation time, then
 380         // save the user name. The newer creation time indicates that
 381         // we found a newer incarnation of the process associated with
 382         // vmid. Due to the way that Windows recycles pids and the fact
 383         // that we can&#39;t delete the file from the file system namespace
 384         // until last close, it is possible for there to be more than
 385         // one hsperfdata file with a name matching vmid (diff users).
 386         //
 387         // We no longer ignore hsperfdata files where (st_size == 0).
 388         // In this function, all we&#39;re trying to do is determine the
 389         // name of the user that owns the process associated with vmid
 390         // so the size doesn&#39;t matter. Very rarely, we have observed
 391         // hsperfdata files where (st_size == 0) and the st_size field
 392         // later becomes the expected value.
 393         //
 394         if (statbuf.st_ctime &gt; latest_ctime) {
 395           char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 396 
<span class="line-modified"> 397           FREE_C_HEAP_ARRAY(char, latest_user);</span>
 398           latest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 399 
 400           strcpy(latest_user, user);
 401           latest_ctime = statbuf.st_ctime;
 402         }
 403 
 404         FREE_C_HEAP_ARRAY(char, filename);
 405       }
 406     }
 407     os::closedir(subdirp);
 408     FREE_C_HEAP_ARRAY(char, usrdir_name);
 409   }
 410   os::closedir(tmpdirp);
 411 
 412   return(latest_user);
 413 }
 414 
 415 // return the name of the user that owns the process identified by vmid.
 416 //
 417 // note: this method should only be used via the Perf native methods.
</pre>
<hr />
<pre>
 747     if (success &amp;&amp; exists &amp;&amp; pACL != NULL &amp;&amp; !isdefault) {
 748       FREE_C_HEAP_ARRAY(char, pACL);
 749     }
 750 
 751     // free the security descriptor
 752     FREE_C_HEAP_ARRAY(char, pSD);
 753   }
 754 }
 755 
 756 // method to free up a security attributes structure and any
 757 // contained security descriptors and ACL
 758 //
 759 static void free_security_attr(LPSECURITY_ATTRIBUTES lpSA) {
 760 
 761   if (lpSA != NULL) {
 762     // free the contained security descriptor and the ACL
 763     free_security_desc(lpSA-&gt;lpSecurityDescriptor);
 764     lpSA-&gt;lpSecurityDescriptor = NULL;
 765 
 766     // free the security attributes structure
<span class="line-modified"> 767     FREE_C_HEAP_OBJ(lpSA);</span>
 768   }
 769 }
 770 
 771 // get the user SID for the process indicated by the process handle
 772 //
 773 static PSID get_user_sid(HANDLE hProcess) {
 774 
 775   HANDLE hAccessToken;
 776   PTOKEN_USER token_buf = NULL;
 777   DWORD rsize = 0;
 778 
 779   if (hProcess == NULL) {
 780     return NULL;
 781   }
 782 
 783   // get the process token
 784   if (!OpenProcessToken(hProcess, TOKEN_READ, &amp;hAccessToken)) {
 785     if (PrintMiscellaneous &amp;&amp; Verbose) {
 786       warning(&quot;OpenProcessToken failure: lasterror = %d \n&quot;, GetLastError());
 787     }
</pre>
<hr />
<pre>
1056 
1057   // initialize the security descriptor
1058   if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
1059     if (PrintMiscellaneous &amp;&amp; Verbose) {
1060       warning(&quot;InitializeSecurityDescriptor failure: &quot;
1061               &quot;lasterror = %d \n&quot;, GetLastError());
1062     }
1063     free_security_desc(pSD);
1064     return NULL;
1065   }
1066 
1067   // add the access control entries
1068   if (!add_allow_aces(pSD, aces, count)) {
1069     free_security_desc(pSD);
1070     return NULL;
1071   }
1072 
1073   // allocate and initialize the security attributes structure and
1074   // return it to the caller.
1075   //
<span class="line-modified">1076   LPSECURITY_ATTRIBUTES lpSA =</span>
<span class="line-modified">1077       NEW_C_HEAP_OBJ(SECURITY_ATTRIBUTES, mtInternal);</span>
1078   lpSA-&gt;nLength = sizeof(SECURITY_ATTRIBUTES);
1079   lpSA-&gt;lpSecurityDescriptor = pSD;
1080   lpSA-&gt;bInheritHandle = FALSE;
1081 
1082   return(lpSA);
1083 }
1084 
1085 // method to create a security attributes structure with a restrictive
1086 // access control list that creates a set access rights for the user/owner
1087 // of the securable object and a separate set access rights for everyone else.
1088 // also provides for full access rights for the administrator group.
1089 //
1090 // the caller must free the resources associated with the security
1091 // attributes structure created by this method by calling the
1092 // free_security_attr() method.
1093 //
1094 
1095 static LPSECURITY_ATTRIBUTES make_user_everybody_admin_security_attr(
1096                                 DWORD umask, DWORD emask, DWORD amask) {
1097 
</pre>
<hr />
<pre>
1544   //
1545   // on win95/98/me, _stat returns a file size of 0 bytes, but on
1546   // winnt/2k the appropriate file size is returned. support for
1547   // the sharable aspects of performance counters was abandonded
1548   // on the non-nt win32 platforms due to this and other api
1549   // inconsistencies
1550   //
1551   if (::stat(filename, &amp;statbuf) == OS_ERR) {
1552     if (PrintMiscellaneous &amp;&amp; Verbose) {
1553       warning(&quot;stat %s failed: %s\n&quot;, filename, os::strerror(errno));
1554     }
1555     THROW_MSG_0(vmSymbols::java_io_IOException(),
1556                 &quot;Could not determine PerfMemory size&quot;);
1557   }
1558 
1559   if ((statbuf.st_size == 0) || (statbuf.st_size % os::vm_page_size() != 0)) {
1560     if (PrintMiscellaneous &amp;&amp; Verbose) {
1561       warning(&quot;unexpected file size: size = &quot; SIZE_FORMAT &quot;\n&quot;,
1562               statbuf.st_size);
1563     }
<span class="line-modified">1564     THROW_MSG_0(vmSymbols::java_io_IOException(),</span>
1565                 &quot;Invalid PerfMemory size&quot;);
1566   }
1567 
1568   return statbuf.st_size;
1569 }
1570 
1571 // this method opens a file mapping object and maps the object
1572 // into the address space of the process
1573 //
1574 static void open_file_mapping(const char* user, int vmid,
1575                               PerfMemory::PerfMemoryMode mode,
1576                               char** addrp, size_t* sizep, TRAPS) {
1577 
1578   ResourceMark rm;
1579 
1580   void *mapAddress = 0;
1581   size_t size = 0;
1582   HANDLE fmh;
1583   DWORD ofm_access;
1584   DWORD mv_access;
</pre>
</td>
</tr>
</table>
<center><a href="os_windows.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="semaphore_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
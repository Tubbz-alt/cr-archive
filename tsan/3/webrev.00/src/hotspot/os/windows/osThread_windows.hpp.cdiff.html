<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/windows/osThread_windows.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osThread_windows.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_perf_windows.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/osThread_windows.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,20 ***</span>
    typedef unsigned long thread_id_t;
  
   private:
    // Win32-specific thread information
    HANDLE _thread_handle;        // Win32 thread handle
<span class="line-modified">!   HANDLE _interrupt_event;      // Event signalled on thread interrupt</span>
    ThreadState _last_state;
  
   public:
    // The following will only apply in the Win32 implementation, and should only
    // be visible in the concrete class, not this which should be an abstract base class
    HANDLE thread_handle() const                     { return _thread_handle; }
    void set_thread_handle(HANDLE handle)            { _thread_handle = handle; }
    HANDLE interrupt_event() const                   { return _interrupt_event; }
    void set_interrupt_event(HANDLE interrupt_event) { _interrupt_event = interrupt_event; }
  
  #ifndef PRODUCT
    // Used for debugging, return a unique integer for each thread.
    int thread_identifier() const                    { return _thread_id; }
  #endif
<span class="line-new-header">--- 30,23 ---</span>
    typedef unsigned long thread_id_t;
  
   private:
    // Win32-specific thread information
    HANDLE _thread_handle;        // Win32 thread handle
<span class="line-modified">!   HANDLE _interrupt_event;      // Event signalled on thread interrupt for use by</span>
<span class="line-added">+                                 // Process.waitFor().</span>
    ThreadState _last_state;
  
   public:
    // The following will only apply in the Win32 implementation, and should only
    // be visible in the concrete class, not this which should be an abstract base class
    HANDLE thread_handle() const                     { return _thread_handle; }
    void set_thread_handle(HANDLE handle)            { _thread_handle = handle; }
    HANDLE interrupt_event() const                   { return _interrupt_event; }
    void set_interrupt_event(HANDLE interrupt_event) { _interrupt_event = interrupt_event; }
<span class="line-added">+   // This is specialized on Windows to interact with the _interrupt_event.</span>
<span class="line-added">+   void set_interrupted(bool z);</span>
  
  #ifndef PRODUCT
    // Used for debugging, return a unique integer for each thread.
    int thread_identifier() const                    { return _thread_id; }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,11 ***</span>
    //
    bool valid_reposition_failure() {
      return false;
    }
  #endif // ASSERT
<span class="line-removed">-   bool is_try_mutex_enter()                        { return false; }</span>
  
    // This is a temporary fix for the thread states during
    // suspend/resume until we throw away OSThread completely.
    // NEEDS_CLEANUP
    void set_last_state(ThreadState state)           { _last_state = state; }
<span class="line-new-header">--- 55,10 ---</span>
</pre>
<center><a href="osThread_windows.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_perf_windows.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
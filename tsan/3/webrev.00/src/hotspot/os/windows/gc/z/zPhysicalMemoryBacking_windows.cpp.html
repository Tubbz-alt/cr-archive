<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/windows/gc/z/zPhysicalMemoryBacking_windows.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zGlobals.hpp&quot;
 26 #include &quot;gc/z/zGranuleMap.inline.hpp&quot;
 27 #include &quot;gc/z/zMapper_windows.hpp&quot;
 28 #include &quot;gc/z/zPhysicalMemoryBacking_windows.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/globals.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 
 33 // The backing commits and uncommits physical memory, that can be
 34 // multi-mapped into the virtual address space. To support fine-graned
 35 // committing and uncommitting, each ZGranuleSize&#39;d chunk is mapped to
 36 // a separate paging file mapping.
 37 
 38 ZPhysicalMemoryBacking::ZPhysicalMemoryBacking() :
 39     _handles(MaxHeapSize),
 40     _size(0) {}
 41 
 42 bool ZPhysicalMemoryBacking::is_initialized() const {
 43   return true;
 44 }
 45 
 46 void ZPhysicalMemoryBacking::warn_commit_limits(size_t max) const {
 47   // Does nothing
 48 }
 49 
 50 size_t ZPhysicalMemoryBacking::size() const {
 51   return _size;
 52 }
 53 
 54 HANDLE ZPhysicalMemoryBacking::get_handle(uintptr_t offset) const {
 55   HANDLE const handle = _handles.get(offset);
 56   assert(handle != 0, &quot;Should be set&quot;);
 57   return handle;
 58 }
 59 
 60 void ZPhysicalMemoryBacking::put_handle(uintptr_t offset, HANDLE handle) {
 61   assert(handle != INVALID_HANDLE_VALUE, &quot;Invalid handle&quot;);
 62   assert(_handles.get(offset) == 0, &quot;Should be cleared&quot;);
 63   _handles.put(offset, handle);
 64 }
 65 
 66 void ZPhysicalMemoryBacking::clear_handle(uintptr_t offset) {
 67   assert(_handles.get(offset) != 0, &quot;Should be set&quot;);
 68   _handles.put(offset, 0);
 69 }
 70 
 71 size_t ZPhysicalMemoryBacking::commit_from_paging_file(size_t offset, size_t size) {
 72   for (size_t i = 0; i &lt; size; i += ZGranuleSize) {
 73     HANDLE const handle = ZMapper::create_and_commit_paging_file_mapping(ZGranuleSize);
 74     if (handle == 0) {
 75       return i;
 76     }
 77 
 78     put_handle(offset + i, handle);
 79   }
 80 
 81   return size;
 82 }
 83 
 84 size_t ZPhysicalMemoryBacking::uncommit_from_paging_file(size_t offset, size_t size) {
 85   for (size_t i = 0; i &lt; size; i += ZGranuleSize) {
 86     HANDLE const handle = get_handle(offset + i);
 87     clear_handle(offset + i);
 88     ZMapper::close_paging_file_mapping(handle);
 89   }
 90 
 91   return size;
 92 }
 93 
 94 size_t ZPhysicalMemoryBacking::commit(size_t offset, size_t length) {
 95   log_trace(gc, heap)(&quot;Committing memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
 96                       offset / M, (offset + length) / M, length / M);
 97 
 98   const size_t committed = commit_from_paging_file(offset, length);
 99 
100   const size_t end = offset + committed;
101   if (end &gt; _size) {
102     // Update size
103     _size = end;
104   }
105 
106   return committed;
107 }
108 
109 size_t ZPhysicalMemoryBacking::uncommit(size_t offset, size_t length) {
110   log_trace(gc, heap)(&quot;Uncommitting memory: &quot; SIZE_FORMAT &quot;M-&quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;M)&quot;,
111                       offset / M, (offset + length) / M, length / M);
112 
113   return uncommit_from_paging_file(offset, length);
114 }
115 
116 void ZPhysicalMemoryBacking::map(uintptr_t addr, size_t size, size_t offset) const {
117   assert(is_aligned(offset, ZGranuleSize), &quot;Misaligned&quot;);
118   assert(is_aligned(addr, ZGranuleSize), &quot;Misaligned&quot;);
119   assert(is_aligned(size, ZGranuleSize), &quot;Misaligned&quot;);
120 
121   for (size_t i = 0; i &lt; size; i += ZGranuleSize) {
122     HANDLE const handle = get_handle(offset + i);
123     ZMapper::map_view_replace_placeholder(handle, 0 /* offset */, addr + i, ZGranuleSize);
124   }
125 }
126 
127 void ZPhysicalMemoryBacking::unmap(uintptr_t addr, size_t size) const {
128   assert(is_aligned(addr, ZGranuleSize), &quot;Misaligned&quot;);
129   assert(is_aligned(size, ZGranuleSize), &quot;Misaligned&quot;);
130 
131   for (size_t i = 0; i &lt; size; i += ZGranuleSize) {
132     ZMapper::unmap_view_preserve_placeholder(addr + i, ZGranuleSize);
133   }
134 }
    </pre>
  </body>
</html>
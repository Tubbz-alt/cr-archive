<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/windows/gc/z/zVirtualMemory_windows.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zAddress.inline.hpp&quot;
 26 #include &quot;gc/z/zGlobals.hpp&quot;
 27 #include &quot;gc/z/zMapper_windows.hpp&quot;
 28 #include &quot;gc/z/zVirtualMemory.hpp&quot;
 29 #include &quot;utilities/align.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 
 32 static void split_placeholder(uintptr_t start, size_t size) {
 33   ZMapper::split_placeholder(ZAddress::marked0(start), size);
 34   ZMapper::split_placeholder(ZAddress::marked1(start), size);
 35   ZMapper::split_placeholder(ZAddress::remapped(start), size);
 36 }
 37 
 38 static void coalesce_placeholders(uintptr_t start, size_t size) {
 39   ZMapper::coalesce_placeholders(ZAddress::marked0(start), size);
 40   ZMapper::coalesce_placeholders(ZAddress::marked1(start), size);
 41   ZMapper::coalesce_placeholders(ZAddress::remapped(start), size);
 42 }
 43 
 44 static void split_into_placeholder_granules(uintptr_t start, size_t size) {
 45   for (uintptr_t addr = start; addr &lt; start + size; addr += ZGranuleSize) {
 46     split_placeholder(addr, ZGranuleSize);
 47   }
 48 }
 49 
 50 static void coalesce_into_one_placeholder(uintptr_t start, size_t size) {
 51   assert(is_aligned(size, ZGranuleSize), &quot;Must be granule aligned&quot;);
 52 
 53   if (size &gt; ZGranuleSize) {
 54     coalesce_placeholders(start, size);
 55   }
 56 }
 57 
 58 static void create_callback(const ZMemory* area) {
 59   assert(is_aligned(area-&gt;size(), ZGranuleSize), &quot;Must be granule aligned&quot;);
 60   coalesce_into_one_placeholder(area-&gt;start(), area-&gt;size());
 61 }
 62 
 63 static void destroy_callback(const ZMemory* area) {
 64   assert(is_aligned(area-&gt;size(), ZGranuleSize), &quot;Must be granule aligned&quot;);
 65   // Don&#39;t try split the last granule - VirtualFree will fail
 66   split_into_placeholder_granules(area-&gt;start(), area-&gt;size() - ZGranuleSize);
 67 }
 68 
 69 static void shrink_from_front_callback(const ZMemory* area, size_t size) {
 70   assert(is_aligned(size, ZGranuleSize), &quot;Must be granule aligned&quot;);
 71   split_into_placeholder_granules(area-&gt;start(), size);
 72 }
 73 
 74 static void shrink_from_back_callback(const ZMemory* area, size_t size) {
 75   assert(is_aligned(size, ZGranuleSize), &quot;Must be granule aligned&quot;);
 76   // Don&#39;t try split the last granule - VirtualFree will fail
 77   split_into_placeholder_granules(area-&gt;end() - size, size - ZGranuleSize);
 78 }
 79 
 80 static void grow_from_front_callback(const ZMemory* area, size_t size) {
 81   assert(is_aligned(area-&gt;size(), ZGranuleSize), &quot;Must be granule aligned&quot;);
 82   coalesce_into_one_placeholder(area-&gt;start() - size, area-&gt;size() + size);
 83 }
 84 
 85 static void grow_from_back_callback(const ZMemory* area, size_t size) {
 86   assert(is_aligned(area-&gt;size(), ZGranuleSize), &quot;Must be granule aligned&quot;);
 87   coalesce_into_one_placeholder(area-&gt;start(), area-&gt;size() + size);
 88 }
 89 
 90 void ZVirtualMemoryManager::initialize_os() {
 91   // Each reserved virtual memory address area registered in _manager is
 92   // exactly covered by a single placeholder. Callbacks are installed so
 93   // that whenever a memory area changes, the corresponding placeholder
 94   // is adjusted.
 95   //
 96   // The create and grow callbacks are called when virtual memory is
 97   // returned to the memory manager. The new memory area is then covered
 98   // by a new single placeholder.
 99   //
100   // The destroy and shrink callbacks are called when virtual memory is
101   // allocated from the memory manager. The memory area is then is split
102   // into granule-sized placeholders.
103   //
104   // See comment in zMapper_windows.cpp explaining why placeholders are
105   // split into ZGranuleSize sized placeholders.
106 
107   ZMemoryManager::Callbacks callbacks;
108 
109   callbacks._create = &amp;create_callback;
110   callbacks._destroy = &amp;destroy_callback;
111   callbacks._shrink_from_front = &amp;shrink_from_front_callback;
112   callbacks._shrink_from_back = &amp;shrink_from_back_callback;
113   callbacks._grow_from_front = &amp;grow_from_front_callback;
114   callbacks._grow_from_back = &amp;grow_from_back_callback;
115 
116   _manager.register_callbacks(callbacks);
117 }
118 
119 bool ZVirtualMemoryManager::reserve_contiguous_platform(uintptr_t start, size_t size) {
120   assert(is_aligned(size, ZGranuleSize), &quot;Must be granule aligned&quot;);
121 
122   // Reserve address views
123   const uintptr_t marked0 = ZAddress::marked0(start);
124   const uintptr_t marked1 = ZAddress::marked1(start);
125   const uintptr_t remapped = ZAddress::remapped(start);
126 
127   // Reserve address space
128   if (ZMapper::reserve(marked0, size) != marked0) {
129     return false;
130   }
131 
132   if (ZMapper::reserve(marked1, size) != marked1) {
133     ZMapper::unreserve(marked0, size);
134     return false;
135   }
136 
137   if (ZMapper::reserve(remapped, size) != remapped) {
138     ZMapper::unreserve(marked0, size);
139     ZMapper::unreserve(marked1, size);
140     return false;
141   }
142 
143   // Register address views with native memory tracker
144   nmt_reserve(marked0, size);
145   nmt_reserve(marked1, size);
146   nmt_reserve(remapped, size);
147 
148   return true;
149 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/windows/os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_windows.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/os_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;

  39 #include &quot;memory/allocation.inline.hpp&quot;
  40 #include &quot;memory/filemap.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;os_share_windows.hpp&quot;
  43 #include &quot;os_windows.inline.hpp&quot;
  44 #include &quot;prims/jniFastGetField.hpp&quot;
  45 #include &quot;prims/jvm_misc.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;
  48 #include &quot;runtime/extendedPC.hpp&quot;
  49 #include &quot;runtime/globals.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/java.hpp&quot;
  52 #include &quot;runtime/javaCalls.hpp&quot;
  53 #include &quot;runtime/mutexLocker.hpp&quot;
  54 #include &quot;runtime/objectMonitor.hpp&quot;
  55 #include &quot;runtime/orderAccess.hpp&quot;
  56 #include &quot;runtime/osThread.hpp&quot;
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
 183 
 184 
 185 // This method is  a periodic task to check for misbehaving JNI applications
 186 // under CheckJNI, we can add any periodic checks here.
 187 // For Windows at the moment does nothing
 188 void os::run_periodic_checks() {
 189   return;
 190 }
 191 
 192 // previous UnhandledExceptionFilter, if there is one
 193 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 194 
 195 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 196 
 197 void os::init_system_properties_values() {
 198   // sysclasspath, java_home, dll_dir
 199   {
 200     char *home_path;
 201     char *dll_path;
 202     char *pslash;
<span class="line-modified"> 203     char *bin = &quot;\\bin&quot;;</span>
 204     char home_dir[MAX_PATH + 1];
 205     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 206 
 207     if (alt_home_dir != NULL)  {
 208       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 209       home_dir[MAX_PATH] = &#39;\0&#39;;
 210     } else {
 211       os::jvm_path(home_dir, sizeof(home_dir));
 212       // Found the full path to jvm.dll.
 213       // Now cut the path to &lt;java_home&gt;/jre if we can.
 214       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 215       pslash = strrchr(home_dir, &#39;\\&#39;);
 216       if (pslash != NULL) {
 217         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 218         pslash = strrchr(home_dir, &#39;\\&#39;);
 219         if (pslash != NULL) {
 220           *pslash = &#39;\0&#39;;                 // get rid of \bin
 221         }
 222       }
 223     }
 224 
 225     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
<span class="line-removed"> 226     if (home_path == NULL) {</span>
<span class="line-removed"> 227       return;</span>
<span class="line-removed"> 228     }</span>
 229     strcpy(home_path, home_dir);
 230     Arguments::set_java_home(home_path);
 231     FREE_C_HEAP_ARRAY(char, home_path);
 232 
 233     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 234                                 mtInternal);
<span class="line-removed"> 235     if (dll_path == NULL) {</span>
<span class="line-removed"> 236       return;</span>
<span class="line-removed"> 237     }</span>
 238     strcpy(dll_path, home_dir);
 239     strcat(dll_path, bin);
 240     Arguments::set_dll_dir(dll_path);
 241     FREE_C_HEAP_ARRAY(char, dll_path);
 242 
 243     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 244       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 245     }
 246   }
 247 
 248 // library_path
 249 #define EXT_DIR &quot;\\lib\\ext&quot;
 250 #define BIN_DIR &quot;\\bin&quot;
 251 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 252   {
 253     // Win32 library search order (See the documentation for LoadLibrary):
 254     //
 255     // 1. The directory from which application is loaded.
 256     // 2. The system wide Java Extensions directory (Java only)
 257     // 3. System directory (GetSystemDirectory)
</pre>
<hr />
<pre>
 479   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 480 
 481   // One less thread is executing
 482   // When the VMThread gets here, the main thread may have already exited
 483   // which frees the CodeHeap containing the Atomic::add code
 484   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 485     Atomic::dec(&amp;os::win32::_os_thread_count);
 486   }
 487 
 488   // Thread must not return from exit_process_or_thread(), but if it does,
 489   // let it proceed to exit normally
 490   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 491 }
 492 
 493 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 494                                   int thread_id) {
 495   // Allocate the OSThread object
 496   OSThread* osthread = new OSThread(NULL, NULL);
 497   if (osthread == NULL) return NULL;
 498 
<span class="line-modified"> 499   // Initialize support for Java interrupts</span>



 500   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 501   if (interrupt_event == NULL) {
 502     delete osthread;
 503     return NULL;
 504   }
 505   osthread-&gt;set_interrupt_event(interrupt_event);
 506 
 507   // Store info on the Win32 thread into the OSThread
 508   osthread-&gt;set_thread_handle(thread_handle);
 509   osthread-&gt;set_thread_id(thread_id);
 510 
 511   if (UseNUMA) {
 512     int lgrp_id = os::numa_get_group_id();
 513     if (lgrp_id != -1) {
 514       thread-&gt;set_lgrp_id(lgrp_id);
 515     }
 516   }
 517 
 518   // Initial thread state is INITIALIZED, not SUSPENDED
 519   osthread-&gt;set_state(INITIALIZED);
</pre>
<hr />
<pre>
 581   #define ALL(X) \
 582     X(CREATE_SUSPENDED) \
 583     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 584   ALL(PRINT_FLAG)
 585   #undef ALL
 586   #undef PRINT_FLAG
 587   return buf;
 588 }
 589 
 590 // Allocate and initialize a new OSThread
 591 bool os::create_thread(Thread* thread, ThreadType thr_type,
 592                        size_t stack_size) {
 593   unsigned thread_id;
 594 
 595   // Allocate the OSThread object
 596   OSThread* osthread = new OSThread(NULL, NULL);
 597   if (osthread == NULL) {
 598     return false;
 599   }
 600 
<span class="line-modified"> 601   // Initialize support for Java interrupts</span>



 602   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 603   if (interrupt_event == NULL) {
 604     delete osthread;
 605     return false;
 606   }
 607   osthread-&gt;set_interrupt_event(interrupt_event);
<span class="line-modified"> 608   osthread-&gt;set_interrupted(false);</span>


 609 
 610   thread-&gt;set_osthread(osthread);
 611 
 612   if (stack_size == 0) {
 613     switch (thr_type) {
 614     case os::java_thread:
 615       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 616       if (JavaThread::stack_size_at_create() &gt; 0) {
 617         stack_size = JavaThread::stack_size_at_create();
 618       }
 619       break;
 620     case os::compiler_thread:
 621       if (CompilerThreadStackSize &gt; 0) {
 622         stack_size = (size_t)(CompilerThreadStackSize * K);
 623         break;
 624       } // else fall through:
 625         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 626     case os::vm_thread:
 627     case os::pgc_thread:
 628     case os::cgc_thread:
</pre>
<hr />
<pre>
 652   // are not supposed to call CreateThread() directly according to MSDN
 653   // document because JVM uses C runtime library. The good news is that the
 654   // flag appears to work with _beginthredex() as well.
 655 
 656   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 657   HANDLE thread_handle =
 658     (HANDLE)_beginthreadex(NULL,
 659                            (unsigned)stack_size,
 660                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 661                            thread,
 662                            initflag,
 663                            &amp;thread_id);
 664 
 665   char buf[64];
 666   if (thread_handle != NULL) {
 667     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 668       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 669   } else {
 670     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 671       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));




 672   }
 673 
 674   if (thread_handle == NULL) {
 675     // Need to clean up stuff we&#39;ve allocated so far
<span class="line-removed"> 676     CloseHandle(osthread-&gt;interrupt_event());</span>
 677     thread-&gt;set_osthread(NULL);
 678     delete osthread;
 679     return false;
 680   }
 681 
 682   Atomic::inc(&amp;os::win32::_os_thread_count);
 683 
 684   // Store info on the Win32 thread into the OSThread
 685   osthread-&gt;set_thread_handle(thread_handle);
 686   osthread-&gt;set_thread_id(thread_id);
 687 
 688   // Initial thread state is INITIALIZED, not SUSPENDED
 689   osthread-&gt;set_state(INITIALIZED);
 690 
 691   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 692   return true;
 693 }
 694 
 695 
 696 // Free Win32 resources related to the OSThread
 697 void os::free_thread(OSThread* osthread) {
 698   assert(osthread != NULL, &quot;osthread not set&quot;);
 699 
 700   // We are told to free resources of the argument thread,
 701   // but we can only really operate on the current thread.
 702   assert(Thread::current()-&gt;osthread() == osthread,
 703          &quot;os::free_thread but not current thread&quot;);
 704 
 705   CloseHandle(osthread-&gt;thread_handle());
<span class="line-removed"> 706   CloseHandle(osthread-&gt;interrupt_event());</span>
 707   delete osthread;
 708 }
 709 
 710 static jlong first_filetime;
 711 static jlong initial_performance_count;
 712 static jlong performance_frequency;
 713 
 714 
 715 jlong as_long(LARGE_INTEGER x) {
 716   jlong result = 0; // initialization to avoid warning
 717   set_high(&amp;result, x.HighPart);
 718   set_low(&amp;result, x.LowPart);
 719   return result;
 720 }
 721 
 722 
 723 jlong os::elapsed_counter() {
 724   LARGE_INTEGER count;
 725   QueryPerformanceCounter(&amp;count);
 726   return as_long(count) - initial_performance_count;
</pre>
<hr />
<pre>
 773     return ActiveProcessorCount;
 774   }
 775 
 776   DWORD_PTR lpProcessAffinityMask = 0;
 777   DWORD_PTR lpSystemAffinityMask = 0;
 778   int proc_count = processor_count();
 779   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 780       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 781     // Nof active processors is number of bits in process affinity mask
 782     int bitcount = 0;
 783     while (lpProcessAffinityMask != 0) {
 784       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 785       bitcount++;
 786     }
 787     return bitcount;
 788   } else {
 789     return proc_count;
 790   }
 791 }
 792 




 793 void os::set_native_thread_name(const char *name) {
 794 
 795   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 796   //
 797   // Note that unfortunately this only works if the process
 798   // is already attached to a debugger; debugger must observe
 799   // the exception below to show the correct name.
 800 
 801   // If there is no debugger attached skip raising the exception
 802   if (!IsDebuggerPresent()) {
 803     return;
 804   }
 805 
 806   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 807   struct {
 808     DWORD dwType;     // must be 0x1000
 809     LPCSTR szName;    // pointer to name (in user addr space)
 810     DWORD dwThreadID; // thread ID (-1=caller thread)
 811     DWORD dwFlags;    // reserved for future use, must be zero
 812   } info;
 813 
 814   info.dwType = 0x1000;
 815   info.szName = name;
 816   info.dwThreadID = -1;
 817   info.dwFlags = 0;
 818 
 819   __try {
 820     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 821   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 822 }
 823 
<span class="line-removed"> 824 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed"> 825   // Not yet implemented.</span>
<span class="line-removed"> 826   return false;</span>
<span class="line-removed"> 827 }</span>
<span class="line-removed"> 828 </span>
 829 bool os::bind_to_processor(uint processor_id) {
 830   // Not yet implemented.
 831   return false;
 832 }
 833 
 834 void os::win32::initialize_performance_counter() {
 835   LARGE_INTEGER count;
 836   QueryPerformanceFrequency(&amp;count);
 837   performance_frequency = as_long(count);
 838   QueryPerformanceCounter(&amp;count);
 839   initial_performance_count = as_long(count);
 840 }
 841 
 842 
 843 double os::elapsedTime() {
 844   return (double) elapsed_counter() / (double) elapsed_frequency();
 845 }
 846 
 847 
 848 // Windows format:
</pre>
<hr />
<pre>
 889 jlong windows_to_java_time(FILETIME wt) {
 890   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 891   return (a - offset()) / 10000;
 892 }
 893 
 894 // Returns time ticks in (10th of micro seconds)
 895 jlong windows_to_time_ticks(FILETIME wt) {
 896   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 897   return (a - offset());
 898 }
 899 
 900 FILETIME java_to_windows_time(jlong l) {
 901   jlong a = (l * 10000) + offset();
 902   FILETIME result;
 903   result.dwHighDateTime = high(a);
 904   result.dwLowDateTime  = low(a);
 905   return result;
 906 }
 907 
 908 bool os::supports_vtime() { return true; }
<span class="line-removed"> 909 bool os::enable_vtime() { return false; }</span>
<span class="line-removed"> 910 bool os::vtime_enabled() { return false; }</span>
 911 
 912 double os::elapsedVTime() {
 913   FILETIME created;
 914   FILETIME exited;
 915   FILETIME kernel;
 916   FILETIME user;
 917   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 918     // the resolution of windows_to_java_time() should be sufficient (ms)
 919     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 920   } else {
 921     return elapsedTime();
 922   }
 923 }
 924 
 925 jlong os::javaTimeMillis() {
 926   FILETIME wt;
 927   GetSystemTimeAsFileTime(&amp;wt);
 928   return windows_to_java_time(wt);
 929 }
 930 
</pre>
<hr />
<pre>
1343   }
1344 
1345   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1346 }
1347 
1348 // print module info; param is outputStream*
1349 static int _print_module(const char* fname, address base_address,
1350                          address top_address, void* param) {
1351   if (!param) return -1;
1352 
1353   outputStream* st = (outputStream*)param;
1354 
1355   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1356   return 0;
1357 }
1358 
1359 // Loads .dll/.so and
1360 // in case of error it checks if .dll/.so was built for the
1361 // same architecture as Hotspot is running on
1362 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {


1363   void * result = LoadLibrary(name);
1364   if (result != NULL) {

1365     // Recalculate pdb search path if a DLL was loaded successfully.
1366     SymbolEngine::recalc_search_path();

1367     return result;
1368   }
<span class="line-removed">1369 </span>
1370   DWORD errcode = GetLastError();







1371   if (errcode == ERROR_MOD_NOT_FOUND) {
1372     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1373     ebuf[ebuflen - 1] = &#39;\0&#39;;
1374     return NULL;
1375   }
1376 
1377   // Parsing dll below
1378   // If we can read dll-info and find that dll was built
1379   // for an architecture other than Hotspot is running in
1380   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1381   // else call os::lasterror to obtain system error message
<span class="line-removed">1382 </span>
<span class="line-removed">1383   // Read system error message into ebuf</span>
<span class="line-removed">1384   // It may or may not be overwritten below (in the for loop and just above)</span>
<span class="line-removed">1385   lasterror(ebuf, (size_t) ebuflen);</span>
<span class="line-removed">1386   ebuf[ebuflen - 1] = &#39;\0&#39;;</span>
1387   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1388   if (fd &lt; 0) {
1389     return NULL;
1390   }
1391 
1392   uint32_t signature_offset;
1393   uint16_t lib_arch = 0;
1394   bool failed_to_get_lib_arch =
1395     ( // Go to position 3c in the dll
1396      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1397      ||
1398      // Read location of signature
1399      (sizeof(signature_offset) !=
1400      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1401      ||
1402      // Go to COFF File Header in dll
1403      // that is located after &quot;signature&quot; (4 bytes long)
1404      (os::seek_to_file_offset(fd,
1405      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1406      ||
</pre>
<hr />
<pre>
1567 #endif // _MSC_VER dispatch
1568 }
1569 
1570 static inline time_t get_mtime(const char* filename) {
1571   struct stat st;
1572   int ret = os::stat(filename, &amp;st);
1573   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1574   return st.st_mtime;
1575 }
1576 
1577 int os::compare_file_modified_times(const char* file1, const char* file2) {
1578   time_t t1 = get_mtime(file1);
1579   time_t t2 = get_mtime(file2);
1580   return t1 - t2;
1581 }
1582 
1583 void os::print_os_info_brief(outputStream* st) {
1584   os::print_os_info(st);
1585 }
1586 





1587 void os::print_os_info(outputStream* st) {
1588 #ifdef ASSERT
1589   char buffer[1024];
1590   st-&gt;print(&quot;HostName: &quot;);
1591   if (get_host_name(buffer, sizeof(buffer))) {
1592     st-&gt;print(&quot;%s &quot;, buffer);
1593   } else {
1594     st-&gt;print(&quot;N/A &quot;);
1595   }
1596 #endif
1597   st-&gt;print(&quot;OS:&quot;);
1598   os::win32::print_windows_version(st);






1599 }
1600 
1601 void os::win32::print_windows_version(outputStream* st) {
1602   OSVERSIONINFOEX osvi;
1603   VS_FIXEDFILEINFO *file_info;
1604   TCHAR kernel32_path[MAX_PATH];
1605   UINT len, ret;
1606 
1607   // Use the GetVersionEx information to see if we&#39;re on a server or
1608   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1609   // trust the OS version information returned by this API.
1610   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1611   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1612   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1613     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1614     return;
1615   }
1616   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1617 
1618   // Get the full path to \Windows\System32\kernel32.dll and use that for
</pre>
<hr />
<pre>
2068 
2069   // Add a CTRL-C handler
2070   SetConsoleCtrlHandler(consoleHandler, TRUE);
2071 }
2072 
2073 void os::signal_notify(int sig) {
2074   if (sig_sem != NULL) {
2075     Atomic::inc(&amp;pending_signals[sig]);
2076     sig_sem-&gt;signal();
2077   } else {
2078     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2079     // initialization isn&#39;t called.
2080     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2081   }
2082 }
2083 
2084 static int check_pending_signals() {
2085   while (true) {
2086     for (int i = 0; i &lt; NSIG + 1; i++) {
2087       jint n = pending_signals[i];
<span class="line-modified">2088       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
2089         return i;
2090       }
2091     }
2092     JavaThread *thread = JavaThread::current();
2093 
2094     ThreadBlockInVM tbivm(thread);
2095 
2096     bool threadIsSuspended;
2097     do {
2098       thread-&gt;set_suspend_equivalent();
2099       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2100       sig_sem-&gt;wait();
2101 
2102       // were we externally suspended while we were waiting?
2103       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2104       if (threadIsSuspended) {
2105         // The semaphore has been incremented, but while we were waiting
2106         // another thread suspended us. We don&#39;t want to continue running
2107         // while suspended because that would surprise the thread that
2108         // suspended us.
</pre>
<hr />
<pre>
2159 
2160 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2161 // Once a system header becomes available, the &quot;real&quot; define should be
2162 // included or copied here.
2163 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2164 
2165 // Windows Vista/2008 heap corruption check
2166 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2167 
2168 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2169 // C++ compiler contain this error code. Because this is a compiler-generated
2170 // error, the code is not listed in the Win32 API header files.
2171 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2172 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2173 // ASCII values of &quot;msc&quot;.
2174 
2175 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2176 
2177 #define def_excpt(val) { #val, (val) }
2178 
<span class="line-modified">2179 static const struct { char* name; uint number; } exceptlabels[] = {</span>
2180     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2181     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2182     def_excpt(EXCEPTION_BREAKPOINT),
2183     def_excpt(EXCEPTION_SINGLE_STEP),
2184     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2185     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2186     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2187     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2188     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2189     def_excpt(EXCEPTION_FLT_OVERFLOW),
2190     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2191     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2192     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2193     def_excpt(EXCEPTION_INT_OVERFLOW),
2194     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2195     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2196     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2197     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2198     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2199     def_excpt(EXCEPTION_STACK_OVERFLOW),
</pre>
<hr />
<pre>
2507                  &quot;should be caught by red zone code above.&quot;);
2508           return Handle_Exception(exceptionInfo,
2509                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2510         }
2511         // Check for safepoint polling and implicit null
2512         // We only expect null pointers in the stubs (vtable)
2513         // the rest are checked explicitly now.
2514         CodeBlob* cb = CodeCache::find_blob(pc);
2515         if (cb != NULL) {
2516           if (os::is_poll_address(addr)) {
2517             address stub = SharedRuntime::get_poll_stub(pc);
2518             return Handle_Exception(exceptionInfo, stub);
2519           }
2520         }
2521         {
2522 #ifdef _WIN64
2523           // If it&#39;s a legal stack address map the entire region in
2524           //
2525           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2526           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
<span class="line-modified">2527           if (addr &gt; thread-&gt;stack_reserved_zone_base() &amp;&amp; addr &lt; thread-&gt;stack_base()) {</span>
2528             addr = (address)((uintptr_t)addr &amp;
2529                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
2530             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
2531                               !ExecMem);
2532             return EXCEPTION_CONTINUE_EXECUTION;
2533           } else
2534 #endif
2535           {
2536             // Null pointer exception.
2537             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
2538               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
2539               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
2540             }
2541             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2542                          exceptionInfo-&gt;ContextRecord);
2543             return EXCEPTION_CONTINUE_SEARCH;
2544           }
2545         }
2546       }
2547 
</pre>
<hr />
<pre>
2554         if (addr != (address)-1) {
2555           return Handle_Exception(exceptionInfo, addr);
2556         }
2557       }
2558 #endif
2559 
2560       // Stack overflow or null pointer exception in native code.
2561       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2562                    exceptionInfo-&gt;ContextRecord);
2563       return EXCEPTION_CONTINUE_SEARCH;
2564     } // /EXCEPTION_ACCESS_VIOLATION
2565     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2566 
2567     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {
2568       CompiledMethod* nm = NULL;
2569       JavaThread* thread = (JavaThread*)t;
2570       if (in_java) {
2571         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
2572         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
2573       }
<span class="line-modified">2574       if ((thread-&gt;thread_state() == _thread_in_vm &amp;&amp;</span>




2575           thread-&gt;doing_unsafe_access()) ||
2576           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
<span class="line-modified">2577         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, (address)Assembler::locate_next_instruction(pc)));</span>




2578       }
2579     }
2580 
2581     if (in_java) {
2582       switch (exception_code) {
2583       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2584         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2585 
2586       case EXCEPTION_INT_OVERFLOW:
2587         return Handle_IDiv_Exception(exceptionInfo);
2588 
2589       } // switch
2590     }
2591     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2592          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2593          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2594       LONG result=Handle_FLT_Exception(exceptionInfo);
2595       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2596     }
2597   }
</pre>
<hr />
<pre>
2682 // scenario, I found through experiment it only uses large page if the entire
2683 // memory region is reserved and committed in a single VirtualAlloc() call.
2684 // This makes Windows large page support more or less like Solaris ISM, in
2685 // that the entire heap must be committed upfront. This probably will change
2686 // in the future, if so the code below needs to be revisited.
2687 
2688 #ifndef MEM_LARGE_PAGES
2689   #define MEM_LARGE_PAGES 0x20000000
2690 #endif
2691 
2692 static HANDLE    _hProcess;
2693 static HANDLE    _hToken;
2694 
2695 // Container for NUMA node list info
2696 class NUMANodeListHolder {
2697  private:
2698   int *_numa_used_node_list;  // allocated below
2699   int _numa_used_node_count;
2700 
2701   void free_node_list() {
<span class="line-modified">2702     if (_numa_used_node_list != NULL) {</span>
<span class="line-removed">2703       FREE_C_HEAP_ARRAY(int, _numa_used_node_list);</span>
<span class="line-removed">2704     }</span>
2705   }
2706 
2707  public:
2708   NUMANodeListHolder() {
2709     _numa_used_node_count = 0;
2710     _numa_used_node_list = NULL;
2711     // do rest of initialization in build routine (after function pointers are set up)
2712   }
2713 
2714   ~NUMANodeListHolder() {
2715     free_node_list();
2716   }
2717 
2718   bool build() {
2719     DWORD_PTR proc_aff_mask;
2720     DWORD_PTR sys_aff_mask;
2721     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2722     ULONG highest_node_number;
2723     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2724     free_node_list();
</pre>
<hr />
<pre>
3413 void os::numa_make_global(char *addr, size_t bytes)    { }
3414 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3415 bool os::numa_topology_changed()                       { return false; }
3416 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3417 int os::numa_get_group_id()                            { return 0; }
3418 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3419   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3420     // Provide an answer for UMA systems
3421     ids[0] = 0;
3422     return 1;
3423   } else {
3424     // check for size bigger than actual groups_num
3425     size = MIN2(size, numa_get_groups_num());
3426     for (int i = 0; i &lt; (int)size; i++) {
3427       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3428     }
3429     return size;
3430   }
3431 }
3432 




3433 bool os::get_page_info(char *start, page_info* info) {
3434   return false;
3435 }
3436 
3437 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3438                      page_info* page_found) {
3439   return end;
3440 }
3441 
3442 char* os::non_memory_address_word() {
3443   // Must never look like an address returned by reserve_memory,
3444   // even in its subfields (as defined by the CPU immediate fields,
3445   // if the CPU splits constants across multiple instructions).
3446   return (char*)-1;
3447 }
3448 
3449 #define MAX_ERROR_COUNT 100
3450 #define SYS_THREAD_ERROR 0xffffffffUL
3451 
3452 void os::pd_start_thread(Thread* thread) {
3453   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3454   // Returns previous suspend state:
3455   // 0:  Thread was not suspended
3456   // 1:  Thread is running now
3457   // &gt;1: Thread is still suspended.
3458   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3459 }
3460 
<span class="line-removed">3461 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {</span>
<span class="line-removed">3462   // The default timer resolution seems to be 10 milliseconds.</span>
<span class="line-removed">3463   // (Where is this written down?)</span>
<span class="line-removed">3464   // If someone wants to sleep for only a fraction of the default,</span>
<span class="line-removed">3465   // then we set the timer resolution down to 1 millisecond for</span>
<span class="line-removed">3466   // the duration of their interval.</span>
<span class="line-removed">3467   // We carefully set the resolution back, since otherwise we</span>
<span class="line-removed">3468   // seem to incur an overhead (3%?) that we don&#39;t need.</span>
<span class="line-removed">3469   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.</span>
<span class="line-removed">3470   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().</span>
<span class="line-removed">3471   // Alternatively, we could compute the relative error (503/500 = .6%) and only use</span>
<span class="line-removed">3472   // timeBeginPeriod() if the relative error exceeded some threshold.</span>
<span class="line-removed">3473   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and</span>
<span class="line-removed">3474   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize</span>
<span class="line-removed">3475   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high</span>
<span class="line-removed">3476   // resolution timers running.</span>
<span class="line-removed">3477  private:</span>
<span class="line-removed">3478   jlong resolution;</span>
<span class="line-removed">3479  public:</span>
<span class="line-removed">3480   HighResolutionInterval(jlong ms) {</span>
<span class="line-removed">3481     resolution = ms % 10L;</span>
<span class="line-removed">3482     if (resolution != 0) {</span>
<span class="line-removed">3483       MMRESULT result = timeBeginPeriod(1L);</span>
<span class="line-removed">3484     }</span>
<span class="line-removed">3485   }</span>
<span class="line-removed">3486   ~HighResolutionInterval() {</span>
<span class="line-removed">3487     if (resolution != 0) {</span>
<span class="line-removed">3488       MMRESULT result = timeEndPeriod(1L);</span>
<span class="line-removed">3489     }</span>
<span class="line-removed">3490     resolution = 0L;</span>
<span class="line-removed">3491   }</span>
<span class="line-removed">3492 };</span>
<span class="line-removed">3493 </span>
<span class="line-removed">3494 int os::sleep(Thread* thread, jlong ms, bool interruptable) {</span>
<span class="line-removed">3495   jlong limit = (jlong) MAXDWORD;</span>
<span class="line-removed">3496 </span>
<span class="line-removed">3497   while (ms &gt; limit) {</span>
<span class="line-removed">3498     int res;</span>
<span class="line-removed">3499     if ((res = sleep(thread, limit, interruptable)) != OS_TIMEOUT) {</span>
<span class="line-removed">3500       return res;</span>
<span class="line-removed">3501     }</span>
<span class="line-removed">3502     ms -= limit;</span>
<span class="line-removed">3503   }</span>
<span class="line-removed">3504 </span>
<span class="line-removed">3505   assert(thread == Thread::current(), &quot;thread consistency check&quot;);</span>
<span class="line-removed">3506   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">3507   OSThreadWaitState osts(osthread, false /* not Object.wait() */);</span>
<span class="line-removed">3508   int result;</span>
<span class="line-removed">3509   if (interruptable) {</span>
<span class="line-removed">3510     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>
<span class="line-removed">3511     JavaThread *jt = (JavaThread *) thread;</span>
<span class="line-removed">3512     ThreadBlockInVM tbivm(jt);</span>
<span class="line-removed">3513 </span>
<span class="line-removed">3514     jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">3515     // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">3516     // java_suspend_self() via check_and_wait_while_suspended()</span>
<span class="line-removed">3517 </span>
<span class="line-removed">3518     HANDLE events[1];</span>
<span class="line-removed">3519     events[0] = osthread-&gt;interrupt_event();</span>
<span class="line-removed">3520     HighResolutionInterval *phri=NULL;</span>
<span class="line-removed">3521     if (!ForceTimeHighResolution) {</span>
<span class="line-removed">3522       phri = new HighResolutionInterval(ms);</span>
<span class="line-removed">3523     }</span>
<span class="line-removed">3524     if (WaitForMultipleObjects(1, events, FALSE, (DWORD)ms) == WAIT_TIMEOUT) {</span>
<span class="line-removed">3525       result = OS_TIMEOUT;</span>
<span class="line-removed">3526     } else {</span>
<span class="line-removed">3527       ResetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">3528       osthread-&gt;set_interrupted(false);</span>
<span class="line-removed">3529       result = OS_INTRPT;</span>
<span class="line-removed">3530     }</span>
<span class="line-removed">3531     delete phri; //if it is NULL, harmless</span>
<span class="line-removed">3532 </span>
<span class="line-removed">3533     // were we externally suspended while we were waiting?</span>
<span class="line-removed">3534     jt-&gt;check_and_wait_while_suspended();</span>
<span class="line-removed">3535   } else {</span>
<span class="line-removed">3536     assert(!thread-&gt;is_Java_thread(), &quot;must not be java thread&quot;);</span>
<span class="line-removed">3537     Sleep((long) ms);</span>
<span class="line-removed">3538     result = OS_TIMEOUT;</span>
<span class="line-removed">3539   }</span>
<span class="line-removed">3540   return result;</span>
<span class="line-removed">3541 }</span>
3542 
3543 // Short sleep, direct OS call.
3544 //
3545 // ms = 0, means allow others (if any) to run.
3546 //
3547 void os::naked_short_sleep(jlong ms) {
3548   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3549   Sleep(ms);
3550 }
3551 



3552 void os::naked_short_nanosleep(jlong ns) {
3553   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
<span class="line-removed">3554   LARGE_INTEGER hundreds_nanos = { 0 };</span>
<span class="line-removed">3555   HANDLE wait_timer = ::CreateWaitableTimer(NULL /* attributes*/,</span>
<span class="line-removed">3556                                             true /* manual reset */,</span>
<span class="line-removed">3557                                             NULL /* name */ );</span>
<span class="line-removed">3558   if (wait_timer == NULL) {</span>
<span class="line-removed">3559     log_warning(os)(&quot;Failed to CreateWaitableTimer: %u&quot;, GetLastError());</span>
<span class="line-removed">3560     return;</span>
<span class="line-removed">3561   }</span>
3562 
<span class="line-modified">3563   // We need a minimum of one hundred nanos.</span>
<span class="line-modified">3564   ns = ns &gt; 100 ? ns : 100;</span>
<span class="line-modified">3565 </span>
<span class="line-modified">3566   // Round ns to the nearst hundred of nanos.</span>
<span class="line-modified">3567   // Negative values indicate relative time.</span>
<span class="line-removed">3568   hundreds_nanos.QuadPart = -((ns + 50) / 100);</span>
<span class="line-removed">3569 </span>
<span class="line-removed">3570   if (::SetWaitableTimer(wait_timer /* handle */,</span>
<span class="line-removed">3571                          &amp;hundreds_nanos /* due time */,</span>
<span class="line-removed">3572                          0 /* period */,</span>
<span class="line-removed">3573                          NULL /* comp func */,</span>
<span class="line-removed">3574                          NULL /* comp func args */,</span>
<span class="line-removed">3575                          FALSE /* resume */)) {</span>
<span class="line-removed">3576     DWORD res = ::WaitForSingleObject(wait_timer /* handle */, INFINITE /* timeout */);</span>
<span class="line-removed">3577     if (res != WAIT_OBJECT_0) {</span>
<span class="line-removed">3578       if (res == WAIT_FAILED) {</span>
<span class="line-removed">3579         log_warning(os)(&quot;Failed to WaitForSingleObject: %u&quot;, GetLastError());</span>
<span class="line-removed">3580       } else {</span>
<span class="line-removed">3581         log_warning(os)(&quot;Unexpected return from WaitForSingleObject: %s&quot;,</span>
<span class="line-removed">3582                         res == WAIT_ABANDONED ? &quot;WAIT_ABANDONED&quot; : &quot;WAIT_TIMEOUT&quot;);</span>
<span class="line-removed">3583       }</span>
3584     }
<span class="line-modified">3585   }</span>
<span class="line-removed">3586   ::CloseHandle(wait_timer /* handle */);</span>
3587 }
3588 
3589 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3590 void os::infinite_sleep() {
3591   while (true) {    // sleep forever ...
3592     Sleep(100000);  // ... 100 seconds at a time
3593   }
3594 }
3595 
3596 typedef BOOL (WINAPI * STTSignature)(void);
3597 
3598 void os::naked_yield() {
3599   // Consider passing back the return value from SwitchToThread().
3600   SwitchToThread();
3601 }
3602 
3603 // Win32 only gives you access to seven real priorities at a time,
3604 // so we compress Java&#39;s ten down to seven.  It would be better
3605 // if we dynamically adjusted relative priorities.
3606 
</pre>
<hr />
<pre>
3652   if (!UseThreadPriorities) return OS_OK;
3653   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3654   return ret ? OS_OK : OS_ERR;
3655 }
3656 
3657 OSReturn os::get_native_priority(const Thread* const thread,
3658                                  int* priority_ptr) {
3659   if (!UseThreadPriorities) {
3660     *priority_ptr = java_to_os_priority[NormPriority];
3661     return OS_OK;
3662   }
3663   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3664   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3665     assert(false, &quot;GetThreadPriority failed&quot;);
3666     return OS_ERR;
3667   }
3668   *priority_ptr = os_prio;
3669   return OS_OK;
3670 }
3671 
<span class="line-removed">3672 void os::interrupt(Thread* thread) {</span>
<span class="line-removed">3673   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">3674 </span>
<span class="line-removed">3675   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">3676   osthread-&gt;set_interrupted(true);</span>
<span class="line-removed">3677   // More than one thread can get here with the same value of osthread,</span>
<span class="line-removed">3678   // resulting in multiple notifications.  We do, however, want the store</span>
<span class="line-removed">3679   // to interrupted() to be visible to other threads before we post</span>
<span class="line-removed">3680   // the interrupt event.</span>
<span class="line-removed">3681   OrderAccess::release();</span>
<span class="line-removed">3682   SetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">3683   // For JSR166:  unpark after setting status</span>
<span class="line-removed">3684   if (thread-&gt;is_Java_thread()) {</span>
<span class="line-removed">3685     ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span>
<span class="line-removed">3686   }</span>
<span class="line-removed">3687 </span>
<span class="line-removed">3688   ParkEvent * ev = thread-&gt;_ParkEvent;</span>
<span class="line-removed">3689   if (ev != NULL) ev-&gt;unpark();</span>
<span class="line-removed">3690 }</span>
<span class="line-removed">3691 </span>
<span class="line-removed">3692 </span>
<span class="line-removed">3693 bool os::is_interrupted(Thread* thread, bool clear_interrupted) {</span>
<span class="line-removed">3694   debug_only(Thread::check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">3695 </span>
<span class="line-removed">3696   OSThread* osthread = thread-&gt;osthread();</span>
<span class="line-removed">3697   // There is no synchronization between the setting of the interrupt</span>
<span class="line-removed">3698   // and it being cleared here. It is critical - see 6535709 - that</span>
<span class="line-removed">3699   // we only clear the interrupt state, and reset the interrupt event,</span>
<span class="line-removed">3700   // if we are going to report that we were indeed interrupted - else</span>
<span class="line-removed">3701   // an interrupt can be &quot;lost&quot;, leading to spurious wakeups or lost wakeups</span>
<span class="line-removed">3702   // depending on the timing. By checking thread interrupt event to see</span>
<span class="line-removed">3703   // if the thread gets real interrupt thus prevent spurious wakeup.</span>
<span class="line-removed">3704   bool interrupted = osthread-&gt;interrupted() &amp;&amp; (WaitForSingleObject(osthread-&gt;interrupt_event(), 0) == WAIT_OBJECT_0);</span>
<span class="line-removed">3705   if (interrupted &amp;&amp; clear_interrupted) {</span>
<span class="line-removed">3706     osthread-&gt;set_interrupted(false);</span>
<span class="line-removed">3707     ResetEvent(osthread-&gt;interrupt_event());</span>
<span class="line-removed">3708   } // Otherwise leave the interrupted state alone</span>
<span class="line-removed">3709 </span>
<span class="line-removed">3710   return interrupted;</span>
<span class="line-removed">3711 }</span>
<span class="line-removed">3712 </span>
3713 // GetCurrentThreadId() returns DWORD
3714 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3715 
3716 static int _initial_pid = 0;
3717 
3718 int os::current_process_id() {
3719   return (_initial_pid ? _initial_pid : _getpid());
3720 }
3721 
3722 int    os::win32::_vm_page_size              = 0;
3723 int    os::win32::_vm_allocation_granularity = 0;
3724 int    os::win32::_processor_type            = 0;
3725 // Processor level is not available on non-NT systems, use vm_version instead
3726 int    os::win32::_processor_level           = 0;
3727 julong os::win32::_physical_memory           = 0;
3728 size_t os::win32::_default_stack_size        = 0;
3729 
3730 intx          os::win32::_os_thread_limit    = 0;
3731 volatile intx os::win32::_os_thread_count    = 0;
3732 
</pre>
<hr />
<pre>
3853     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3854     static int handle_count = 0;
3855 
3856     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3857     static CRITICAL_SECTION crit_sect;
3858     static volatile DWORD process_exiting = 0;
3859     int i, j;
3860     DWORD res;
3861     HANDLE hproc, hthr;
3862 
3863     // We only attempt to register threads until a process exiting
3864     // thread manages to set the process_exiting flag. Any threads
3865     // that come through here after the process_exiting flag is set
3866     // are unregistered and will be caught in the SuspendThread()
3867     // infinite loop below.
3868     bool registered = false;
3869 
3870     // The first thread that reached this point, initializes the critical section.
3871     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3872       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
<span class="line-modified">3873     } else if (OrderAccess::load_acquire(&amp;process_exiting) == 0) {</span>
3874       if (what != EPT_THREAD) {
3875         // Atomically set process_exiting before the critical section
3876         // to increase the visibility between racing threads.
<span class="line-modified">3877         Atomic::cmpxchg(GetCurrentThreadId(), &amp;process_exiting, (DWORD)0);</span>
3878       }
3879       EnterCriticalSection(&amp;crit_sect);
3880 
<span class="line-modified">3881       if (what == EPT_THREAD &amp;&amp; OrderAccess::load_acquire(&amp;process_exiting) == 0) {</span>
3882         // Remove from the array those handles of the threads that have completed exiting.
3883         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3884           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3885           if (res == WAIT_TIMEOUT) {
3886             handles[j++] = handles[i];
3887           } else {
3888             if (res == WAIT_FAILED) {
3889               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3890                       GetLastError(), __FILE__, __LINE__);
3891             }
3892             // Don&#39;t keep the handle, if we failed waiting for it.
3893             CloseHandle(handles[i]);
3894           }
3895         }
3896 
3897         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3898         // wait until at least one thread completes exiting.
3899         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3900           // Raise the priority of the oldest exiting thread to increase its chances
3901           // to complete sooner.
</pre>
<hr />
<pre>
3974                     GetLastError(), __FILE__, __LINE__);
3975             // Reset portion_count so we close the remaining
3976             // handles due to this error.
3977             portion_count = handle_count - i;
3978           }
3979           for (j = 0; j &lt; portion_count; ++j) {
3980             CloseHandle(handles[i + j]);
3981           }
3982           if ((i += portion_count) &gt;= handle_count) {
3983             break;
3984           }
3985           start_time = os::javaTimeNanos();
3986         }
3987         handle_count = 0;
3988       }
3989 
3990       LeaveCriticalSection(&amp;crit_sect);
3991     }
3992 
3993     if (!registered &amp;&amp;
<span class="line-modified">3994         OrderAccess::load_acquire(&amp;process_exiting) != 0 &amp;&amp;</span>
3995         process_exiting != GetCurrentThreadId()) {
3996       // Some other thread is about to call exit(), so we don&#39;t let
3997       // the current unregistered thread proceed to exit() or _endthreadex()
3998       while (true) {
3999         SuspendThread(GetCurrentThread());
4000         // Avoid busy-wait loop, if SuspendThread() failed.
4001         Sleep(EXIT_TIMEOUT);
4002       }
4003     }
4004   }
4005 
4006   // We are here if either
4007   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
4008   // - initialization of the critical section failed (unlikely);
4009   // - the current thread has registered itself and left the critical section;
4010   // - the process-exiting thread has raised the flag and left the critical section.
4011   if (what == EPT_THREAD) {
4012     _endthreadex((unsigned)exit_code);
4013   } else if (what == EPT_PROCESS) {
4014     ::exit(exit_code);
4015   } else {
4016     _exit(exit_code);
4017   }
4018 
4019   // Should not reach here
4020   return exit_code;
4021 }
4022 
4023 #undef EXIT_TIMEOUT
4024 
4025 void os::win32::setmode_streams() {
4026   _setmode(_fileno(stdin), _O_BINARY);
4027   _setmode(_fileno(stdout), _O_BINARY);
4028   _setmode(_fileno(stderr), _O_BINARY);
4029 }
4030 
<span class="line-removed">4031 </span>
<span class="line-removed">4032 bool os::is_debugger_attached() {</span>
<span class="line-removed">4033   return IsDebuggerPresent() ? true : false;</span>
<span class="line-removed">4034 }</span>
<span class="line-removed">4035 </span>
<span class="line-removed">4036 </span>
4037 void os::wait_for_keypress_at_exit(void) {
4038   if (PauseAtExit) {
4039     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
4040     fgetc(stdin);
4041   }
4042 }
4043 
4044 
4045 bool os::message_box(const char* title, const char* message) {
4046   int result = MessageBox(NULL, message, title,
4047                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
4048   return result == IDYES;
4049 }
4050 
4051 #ifndef PRODUCT
4052 #ifndef _WIN64
4053 // Helpers to check whether NX protection is enabled
4054 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
4055   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
4056       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
</pre>
<hr />
<pre>
4068   __try {
4069     __asm call code_ptr
4070   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
4071     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
4072   }
4073 }
4074 #endif // _WIN64
4075 #endif // PRODUCT
4076 
4077 // This is called _before_ the global arguments have been parsed
4078 void os::init(void) {
4079   _initial_pid = _getpid();
4080 
4081   init_random(1234567);
4082 
4083   win32::initialize_system_info();
4084   win32::setmode_streams();
4085   init_page_sizes((size_t) win32::vm_page_size());
4086 
4087   // This may be overridden later when argument processing is done.
<span class="line-modified">4088   FLAG_SET_ERGO(bool, UseLargePagesIndividualAllocation, false);</span>
4089 
4090   // Initialize main_process and main_thread
4091   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
4092   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
4093                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
4094     fatal(&quot;DuplicateHandle failed\n&quot;);
4095   }
4096   main_thread_id = (int) GetCurrentThreadId();
4097 
4098   // initialize fast thread access - only used for 32-bit
4099   win32::initialize_thread_ptr_offset();
4100 }
4101 
4102 // To install functions for atexit processing
4103 extern &quot;C&quot; {
4104   static void perfMemory_exit_helper() {
4105     perfMemory_exit();
4106   }
4107 }
4108 
4109 static jint initSock();
4110 
4111 // this is called _after_ the global arguments have been parsed
4112 jint os::init_2(void) {
4113 
4114   // This could be set any time but all platforms
4115   // have to set it the same so we have to mirror Solaris.
4116   DEBUG_ONLY(os::set_mutex_init_done();)
4117 
4118   // Setup Windows Exceptions
4119 
4120 #if INCLUDE_AOT
4121   // If AOT is enabled we need to install a vectored exception handler
4122   // in order to forward implicit exceptions from code in AOT
4123   // generated DLLs.  This is necessary since these DLLs are not
4124   // registered for structured exceptions like codecache methods are.
<span class="line-modified">4125   if (UseAOT) {</span>
4126     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
4127   }
4128 #endif
4129 
4130   // for debugging float code generation bugs
4131   if (ForceFloatExceptions) {
4132 #ifndef  _WIN64
4133     static long fp_control_word = 0;
4134     __asm { fstcw fp_control_word }
4135     // see Intel PPro Manual, Vol. 2, p 7-16
4136     const long precision = 0x20;
4137     const long underflow = 0x10;
4138     const long overflow  = 0x08;
4139     const long zero_div  = 0x04;
4140     const long denorm    = 0x02;
4141     const long invalid   = 0x01;
4142     fp_control_word |= invalid;
4143     __asm { fldcw fp_control_word }
4144 #endif
4145   }
</pre>
<hr />
<pre>
4266   return value;
4267 }
4268 
4269 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4270 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4271   ::memset((void*)sbuf, 0, sizeof(struct stat));
4272   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4273   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4274                                   file_data.ftLastWriteTime.dwLowDateTime);
4275   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4276                                   file_data.ftCreationTime.dwLowDateTime);
4277   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4278                                   file_data.ftLastAccessTime.dwLowDateTime);
4279   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4280     sbuf-&gt;st_mode |= S_IFDIR;
4281   } else {
4282     sbuf-&gt;st_mode |= S_IFREG;
4283   }
4284 }
4285 
<span class="line-modified">4286 // The following function is adapted from java.base/windows/native/libjava/canonicalize_md.c</span>
<span class="line-modified">4287 // Creates an UNC path from a single byte path. Return buffer is</span>
<span class="line-modified">4288 // allocated in C heap and needs to be freed by the caller.</span>
<span class="line-modified">4289 // Returns NULL on error.</span>
<span class="line-modified">4290 static wchar_t* create_unc_path(const char* path, errno_t &amp;err) {</span>
<span class="line-modified">4291   wchar_t* wpath = NULL;</span>
<span class="line-modified">4292   size_t converted_chars = 0;</span>
<span class="line-modified">4293   size_t path_len = strlen(path) + 1; // includes the terminating NULL</span>
<span class="line-modified">4294   if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {</span>
<span class="line-modified">4295     if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;){</span>
<span class="line-modified">4296       // if it already has a \\?\ don&#39;t do the prefix</span>
<span class="line-modified">4297       wpath = (wchar_t*)os::malloc(path_len * sizeof(wchar_t), mtInternal);</span>
<span class="line-modified">4298       if (wpath != NULL) {</span>
<span class="line-modified">4299         err = ::mbstowcs_s(&amp;converted_chars, wpath, path_len, path, path_len);</span>



















4300       } else {
<span class="line-modified">4301         err = ENOMEM;</span>

4302       }
4303     } else {
<span class="line-modified">4304       // only UNC pathname includes double slashes here</span>
<span class="line-modified">4305       wpath = (wchar_t*)os::malloc((path_len + 7) * sizeof(wchar_t), mtInternal);</span>
<span class="line-removed">4306       if (wpath != NULL) {</span>
<span class="line-removed">4307         ::wcscpy(wpath, L&quot;\\\\?\\UNC\0&quot;);</span>
<span class="line-removed">4308         err = ::mbstowcs_s(&amp;converted_chars, &amp;wpath[7], path_len, path, path_len);</span>
<span class="line-removed">4309       } else {</span>
<span class="line-removed">4310         err = ENOMEM;</span>
<span class="line-removed">4311       }</span>
4312     }
<span class="line-modified">4313   } else {</span>
<span class="line-modified">4314     wpath = (wchar_t*)os::malloc((path_len + 4) * sizeof(wchar_t), mtInternal);</span>
<span class="line-modified">4315     if (wpath != NULL) {</span>
<span class="line-modified">4316       ::wcscpy(wpath, L&quot;\\\\?\\\0&quot;);</span>
<span class="line-modified">4317       err = ::mbstowcs_s(&amp;converted_chars, &amp;wpath[4], path_len, path, path_len);</span>
<span class="line-modified">4318     } else {</span>


4319       err = ENOMEM;































4320     }
4321   }
<span class="line-removed">4322   return wpath;</span>
<span class="line-removed">4323 }</span>
4324 
<span class="line-modified">4325 static void destroy_unc_path(wchar_t* wpath) {</span>
<span class="line-modified">4326   os::free(wpath);</span>






4327 }
4328 
4329 int os::stat(const char *path, struct stat *sbuf) {
<span class="line-modified">4330   char* pathbuf = (char*)os::strdup(path, mtInternal);</span>
<span class="line-modified">4331   if (pathbuf == NULL) {</span>
<span class="line-modified">4332     errno = ENOMEM;</span>


4333     return -1;
4334   }
<span class="line-modified">4335   os::native_path(pathbuf);</span>
<span class="line-modified">4336   int ret;</span>
<span class="line-modified">4337   WIN32_FILE_ATTRIBUTE_DATA file_data;</span>
<span class="line-modified">4338   // Not using stat() to avoid the problem described in JDK-6539723</span>
<span class="line-modified">4339   if (strlen(path) &lt; MAX_PATH) {</span>
<span class="line-modified">4340     BOOL bret = ::GetFileAttributesExA(pathbuf, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-modified">4341     if (!bret) {</span>
<span class="line-modified">4342       errno = ::GetLastError();</span>
<span class="line-modified">4343       ret = -1;</span>
<span class="line-modified">4344     }</span>
<span class="line-modified">4345     else {</span>
<span class="line-modified">4346       file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-modified">4347       ret = 0;</span>
<span class="line-modified">4348     }</span>
<span class="line-modified">4349   } else {</span>
<span class="line-modified">4350     errno_t err = ERROR_SUCCESS;</span>
<span class="line-modified">4351     wchar_t* wpath = create_unc_path(pathbuf, err);</span>
<span class="line-modified">4352     if (err != ERROR_SUCCESS) {</span>
<span class="line-modified">4353       if (wpath != NULL) {</span>
<span class="line-modified">4354         destroy_unc_path(wpath);</span>







































4355       }
<span class="line-removed">4356       os::free(pathbuf);</span>
<span class="line-removed">4357       errno = err;</span>
<span class="line-removed">4358       return -1;</span>
<span class="line-removed">4359     }</span>
<span class="line-removed">4360     BOOL bret = ::GetFileAttributesExW(wpath, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-removed">4361     if (!bret) {</span>
<span class="line-removed">4362       errno = ::GetLastError();</span>
<span class="line-removed">4363       ret = -1;</span>
<span class="line-removed">4364     } else {</span>
<span class="line-removed">4365       file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-removed">4366       ret = 0;</span>
4367     }
<span class="line-removed">4368     destroy_unc_path(wpath);</span>
4369   }
<span class="line-removed">4370   os::free(pathbuf);</span>
<span class="line-removed">4371   return ret;</span>
<span class="line-removed">4372 }</span>
4373 











4374 
4375 #define FT2INT64(ft) \
4376   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4377 
4378 
4379 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4380 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4381 // of a thread.
4382 //
4383 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4384 // the fast estimate available on the platform.
4385 
4386 // current_thread_cpu_time() is not optimized for Windows yet
4387 jlong os::current_thread_cpu_time() {
4388   // return user + sys since the cost is the same
4389   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4390 }
4391 
4392 jlong os::thread_cpu_time(Thread* thread) {
4393   // consistent with what current_thread_cpu_time() returns.
</pre>
<hr />
<pre>
4459 //    returns 100%), so we&#39;d have to deal with that as well.
4460 //
4461 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4462 //    the answer in a global variable.  The call to loadavg would
4463 //    just return the value of the global, avoiding the slow query.
4464 //
4465 // c) Sample a better answer using exponential decay to smooth the
4466 //    value.  This is basically the algorithm used by UNIX kernels.
4467 //
4468 // Note that sampling thread starvation could affect both (b) and (c).
4469 int os::loadavg(double loadavg[], int nelem) {
4470   return -1;
4471 }
4472 
4473 
4474 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4475 bool os::dont_yield() {
4476   return DontYieldALot;
4477 }
4478 
<span class="line-removed">4479 // This method is a slightly reworked copy of JDK&#39;s sysOpen</span>
<span class="line-removed">4480 // from src/windows/hpi/src/sys_api_md.c</span>
<span class="line-removed">4481 </span>
4482 int os::open(const char *path, int oflag, int mode) {
<span class="line-modified">4483   char* pathbuf = (char*)os::strdup(path, mtInternal);</span>
<span class="line-modified">4484   if (pathbuf == NULL) {</span>
<span class="line-modified">4485     errno = ENOMEM;</span>


4486     return -1;
4487   }
<span class="line-modified">4488   os::native_path(pathbuf);</span>
<span class="line-modified">4489   int ret;</span>
<span class="line-modified">4490   if (strlen(path) &lt; MAX_PATH) {</span>
<span class="line-modified">4491     ret = ::open(pathbuf, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-modified">4492   } else {</span>
<span class="line-removed">4493     errno_t err = ERROR_SUCCESS;</span>
<span class="line-removed">4494     wchar_t* wpath = create_unc_path(pathbuf, err);</span>
<span class="line-removed">4495     if (err != ERROR_SUCCESS) {</span>
<span class="line-removed">4496       if (wpath != NULL) {</span>
<span class="line-removed">4497         destroy_unc_path(wpath);</span>
<span class="line-removed">4498       }</span>
<span class="line-removed">4499       os::free(pathbuf);</span>
<span class="line-removed">4500       errno = err;</span>
<span class="line-removed">4501       return -1;</span>
<span class="line-removed">4502     }</span>
<span class="line-removed">4503     ret = ::_wopen(wpath, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-removed">4504     if (ret == -1) {</span>
<span class="line-removed">4505       errno = ::GetLastError();</span>
<span class="line-removed">4506     }</span>
<span class="line-removed">4507     destroy_unc_path(wpath);</span>
4508   }
<span class="line-modified">4509   os::free(pathbuf);</span>
<span class="line-modified">4510   return ret;</span>
4511 }
4512 
4513 FILE* os::open(int fd, const char* mode) {
4514   return ::_fdopen(fd, mode);
4515 }
4516 
4517 // Is a (classpath) directory empty?
4518 bool os::dir_is_empty(const char* path) {
<span class="line-modified">4519   char* search_path = (char*)os::malloc(strlen(path) + 3, mtInternal);</span>
<span class="line-modified">4520   if (search_path == NULL) {</span>
<span class="line-modified">4521     errno = ENOMEM;</span>
<span class="line-modified">4522     return false;</span>
<span class="line-removed">4523   }</span>
<span class="line-removed">4524   strcpy(search_path, path);</span>
<span class="line-removed">4525   os::native_path(search_path);</span>
<span class="line-removed">4526   // Append &quot;*&quot;, or possibly &quot;\\*&quot;, to path</span>
<span class="line-removed">4527   if (search_path[1] == &#39;:&#39; &amp;&amp;</span>
<span class="line-removed">4528        (search_path[2] == &#39;\0&#39; ||</span>
<span class="line-removed">4529          (search_path[2] == &#39;\\&#39; &amp;&amp; search_path[3] == &#39;\0&#39;))) {</span>
<span class="line-removed">4530     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;</span>
<span class="line-removed">4531     strcat(search_path, &quot;*&quot;);</span>
<span class="line-removed">4532   }</span>
<span class="line-removed">4533   else {</span>
<span class="line-removed">4534     strcat(search_path, &quot;\\*&quot;);</span>
<span class="line-removed">4535   }</span>
<span class="line-removed">4536   errno_t err = ERROR_SUCCESS;</span>
<span class="line-removed">4537   wchar_t* wpath = create_unc_path(search_path, err);</span>
<span class="line-removed">4538   if (err != ERROR_SUCCESS) {</span>
<span class="line-removed">4539     if (wpath != NULL) {</span>
<span class="line-removed">4540       destroy_unc_path(wpath);</span>
<span class="line-removed">4541     }</span>
<span class="line-removed">4542     os::free(search_path);</span>
4543     errno = err;
4544     return false;
4545   }








4546   WIN32_FIND_DATAW fd;
<span class="line-modified">4547   HANDLE f = ::FindFirstFileW(wpath, &amp;fd);</span>
<span class="line-modified">4548   destroy_unc_path(wpath);</span>
4549   bool is_empty = true;

4550   if (f != INVALID_HANDLE_VALUE) {
4551     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4552       // An empty directory contains only the current directory file
4553       // and the previous directory file.
4554       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4555           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4556         is_empty = false;
4557       }
4558     }
4559     FindClose(f);


4560   }
<span class="line-modified">4561   os::free(search_path);</span>
4562   return is_empty;
4563 }
4564 
4565 // create binary file, rewriting existing file if required
4566 int os::create_binary_file(const char* path, bool rewrite_existing) {
4567   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4568   if (!rewrite_existing) {
4569     oflags |= _O_EXCL;
4570   }
4571   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4572 }
4573 
4574 // return current position of file pointer
4575 jlong os::current_file_offset(int fd) {
4576   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4577 }
4578 
4579 // move file pointer to the specified offset
4580 jlong os::seek_to_file_offset(int fd, jlong offset) {
4581   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
</pre>
<hr />
<pre>
4906 
4907   if (allow_exec) {
4908     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4909     // unless it comes from a PE image (which the shared archive is not.)
4910     // Even VirtualProtect refuses to give execute access to mapped memory
4911     // that was not previously executable.
4912     //
4913     // Instead, stick the executable region in anonymous memory.  Yuck.
4914     // Penalty is that ~4 pages will not be shareable - in the future
4915     // we might consider DLLizing the shared archive with a proper PE
4916     // header so that mapping executable + sharing is possible.
4917 
4918     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4919                                 PAGE_READWRITE);
4920     if (base == NULL) {
4921       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4922       CloseHandle(hFile);
4923       return NULL;
4924     }
4925 



4926     DWORD bytes_read;
4927     OVERLAPPED overlapped;
4928     overlapped.Offset = (DWORD)file_offset;
4929     overlapped.OffsetHigh = 0;
4930     overlapped.hEvent = NULL;
4931     // ReadFile guarantees that if the return value is true, the requested
4932     // number of bytes were read before returning.
4933     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4934     if (!res) {
4935       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4936       release_memory(base, bytes);
4937       CloseHandle(hFile);
4938       return NULL;
4939     }
4940   } else {
4941     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4942                                     NULL /* file_name */);
4943     if (hMap == NULL) {
4944       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4945       CloseHandle(hFile);
</pre>
<hr />
<pre>
4974       // VirtualProtect fails, we should still be able to execute
4975       CloseHandle(hFile);
4976       return base;
4977     }
4978   }
4979 
4980   if (CloseHandle(hFile) == 0) {
4981     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4982     return base;
4983   }
4984 
4985   return base;
4986 }
4987 
4988 
4989 // Remap a block of memory.
4990 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4991                           char *addr, size_t bytes, bool read_only,
4992                           bool allow_exec) {
4993   // This OS does not allow existing memory maps to be remapped so we
<span class="line-modified">4994   // have to unmap the memory before we remap it.</span>
<span class="line-removed">4995   if (!os::unmap_memory(addr, bytes)) {</span>
<span class="line-removed">4996     return NULL;</span>
<span class="line-removed">4997   }</span>
<span class="line-removed">4998 </span>
<span class="line-removed">4999   // There is a very small theoretical window between the unmap_memory()</span>
<span class="line-removed">5000   // call above and the map_memory() call below where a thread in native</span>
<span class="line-removed">5001   // code may be able to access an address that is no longer mapped.</span>
5002 
<span class="line-modified">5003   return os::map_memory(fd, file_name, file_offset, addr, bytes,</span>
<span class="line-modified">5004                         read_only, allow_exec);</span>



5005 }
5006 
5007 
5008 // Unmap a block of memory.
5009 // Returns true=success, otherwise false.
5010 
5011 bool os::pd_unmap_memory(char* addr, size_t bytes) {
5012   MEMORY_BASIC_INFORMATION mem_info;
5013   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
5014     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
5015     return false;
5016   }
5017 
5018   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
5019   // Instead, executable region was allocated using VirtualAlloc(). See
5020   // pd_map_memory() above.
5021   //
5022   // The following flags should match the &#39;exec_access&#39; flages used for
5023   // VirtualProtect() in pd_map_memory().
5024   if (mem_info.Protect == PAGE_EXECUTE_READ ||
5025       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
5026     return pd_release_memory(addr, bytes);
5027   }
5028 
5029   BOOL result = UnmapViewOfFile(addr);
5030   if (result == 0) {
5031     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
5032     return false;
5033   }
5034   return true;
5035 }
5036 
5037 void os::pause() {
5038   char filename[MAX_PATH];
5039   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">5040     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
5041   } else {
5042     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
5043   }
5044 
5045   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
5046   if (fd != -1) {
5047     struct stat buf;
5048     ::close(fd);
5049     while (::stat(filename, &amp;buf) == 0) {
5050       Sleep(100);
5051     }
5052   } else {
5053     jio_fprintf(stderr,
5054                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
5055   }
5056 }
5057 
5058 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
5059 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
5060 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
</pre>
<hr />
<pre>
5072 
5073   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5074 
5075   _protected_thread = Thread::current_or_null();
5076   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5077 
5078   bool success = true;
5079   __try {
5080     _crash_protection = this;
5081     cb.call();
5082   } __except(EXCEPTION_EXECUTE_HANDLER) {
5083     // only for protection, nothing to do
5084     success = false;
5085   }
5086   _crash_protection = NULL;
5087   _protected_thread = NULL;
5088   Thread::muxRelease(&amp;_crash_mux);
5089   return success;
5090 }
5091 


































5092 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5093 //
5094 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5095 //
5096 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5097 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5098 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5099 //     In addition, an unpark() operation might fetch the handle field, but the
5100 //     event could recycle between the fetch and the SetEvent() operation.
5101 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5102 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5103 //     on an stale but recycled handle would be harmless, but in practice this might
5104 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5105 //
5106 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5107 //     with the Event.  The event handle is never closed.  This could be construed
5108 //     as handle leakage, but only up to the maximum # of threads that have been extant
5109 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5110 //     permit a process to have hundreds of thousands of open handles.
5111 //
5112 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5113 //     and release unused handles.
5114 //
5115 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5116 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5117 //
5118 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5119 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5120 //
5121 // We use (2).
5122 //
5123 // TODO-FIXME:
5124 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5125 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5126 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
<span class="line-modified">5127 // 3.  Collapse the interrupt_event, the JSR166 parker event, and the objectmonitor ParkEvent</span>
5128 //     into a single win32 CreateEvent() handle.
5129 //
5130 // Assumption:
5131 //    Only one parker can exist on an event, which is why we allocate
5132 //    them per-thread. Multiple unparkers can coexist.
5133 //
5134 // _Event transitions in park()
5135 //   -1 =&gt; -1 : illegal
5136 //    1 =&gt;  0 : pass - return immediately
5137 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5138 //
5139 // _Event transitions in unpark()
5140 //    0 =&gt; 1 : just return
5141 //    1 =&gt; 1 : just return
5142 //   -1 =&gt; either 0 or 1; must signal target thread
5143 //         That is, we can safely transition _Event from -1 to either
5144 //         0 or 1.
5145 //
5146 // _Event serves as a restricted-range semaphore.
5147 //   -1 : thread is blocked, i.e. there is a waiter
</pre>
<hr />
<pre>
5152 // Another possible encoding of _Event would be with
5153 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5154 //
5155 
5156 int os::PlatformEvent::park(jlong Millis) {
5157   // Transitions for _Event:
5158   //   -1 =&gt; -1 : illegal
5159   //    1 =&gt;  0 : pass - return immediately
5160   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5161 
5162   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5163   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5164 
5165   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5166   // the initial park() operation.
5167   // Consider: use atomic decrement instead of CAS-loop
5168 
5169   int v;
5170   for (;;) {
5171     v = _Event;
<span class="line-modified">5172     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
5173   }
5174   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5175   if (v != 0) return OS_OK;
5176 
5177   // Do this the hard way by blocking ...
5178   // TODO: consider a brief spin here, gated on the success of recent
5179   // spin attempts by this thread.
5180   //
5181   // We decompose long timeouts into series of shorter timed waits.
5182   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5183   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5184   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5185   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5186   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5187   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5188   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5189   // for the already waited time.  This policy does not admit any new outcomes.
5190   // In the future, however, we might want to track the accumulated wait time and
5191   // adjust Millis accordingly if we encounter a spurious wakeup.
5192 
5193   const int MAXTIMEOUT = 0x10000000;
5194   DWORD rv = WAIT_TIMEOUT;
5195   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5196     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5197     if (Millis &gt; MAXTIMEOUT) {
5198       prd = MAXTIMEOUT;
5199     }




5200     rv = ::WaitForSingleObject(_ParkHandle, prd);
5201     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5202     if (rv == WAIT_TIMEOUT) {
5203       Millis -= prd;
5204     }

5205   }
5206   v = _Event;
5207   _Event = 0;
5208   // see comment at end of os::PlatformEvent::park() below:
5209   OrderAccess::fence();
5210   // If we encounter a nearly simultanous timeout expiry and unpark()
5211   // we return OS_OK indicating we awoke via unpark().
5212   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5213   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5214 }
5215 
5216 void os::PlatformEvent::park() {
5217   // Transitions for _Event:
5218   //   -1 =&gt; -1 : illegal
5219   //    1 =&gt;  0 : pass - return immediately
5220   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5221 
5222   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5223   // Invariant: Only the thread associated with the Event/PlatformEvent
5224   // may call park().
5225   // Consider: use atomic decrement instead of CAS-loop
5226   int v;
5227   for (;;) {
5228     v = _Event;
<span class="line-modified">5229     if (Atomic::cmpxchg(v-1, &amp;_Event, v) == v) break;</span>
5230   }
5231   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5232   if (v != 0) return;
5233 
5234   // Do this the hard way by blocking ...
5235   // TODO: consider a brief spin here, gated on the success of recent
5236   // spin attempts by this thread.
5237   while (_Event &lt; 0) {
5238     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5239     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5240   }
5241 
5242   // Usually we&#39;ll find _Event == 0 at this point, but as
5243   // an optional optimization we clear it, just in case can
5244   // multiple unpark() operations drove _Event up to 1.
5245   _Event = 0;
5246   OrderAccess::fence();
5247   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5248 }
5249 
5250 void os::PlatformEvent::unpark() {
5251   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5252 
5253   // Transitions for _Event:
5254   //    0 =&gt; 1 : just return
5255   //    1 =&gt; 1 : just return
5256   //   -1 =&gt; either 0 or 1; must signal target thread
5257   //         That is, we can safely transition _Event from -1 to either
5258   //         0 or 1.
5259   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5260   //
5261   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5262   // that it will take two back-to-back park() calls for the owning
5263   // thread to block. This has the benefit of forcing a spurious return
5264   // from the first park() call after an unpark() call which will help
5265   // shake out uses of park() and unpark() without condition variables.
5266 
<span class="line-modified">5267   if (Atomic::xchg(1, &amp;_Event) &gt;= 0) return;</span>
5268 
5269   ::SetEvent(_ParkHandle);
5270 }
5271 
5272 
5273 // JSR166
5274 // -------------------------------------------------------
5275 
5276 // The Windows implementation of Park is very straightforward: Basic
5277 // operations on Win32 Events turn out to have the right semantics to
5278 // use them directly. We opportunistically resuse the event inherited
5279 // from Monitor.
5280 
5281 void Parker::park(bool isAbsolute, jlong time) {
5282   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5283   // First, demultiplex/decode time arguments
5284   if (time &lt; 0) { // don&#39;t wait
5285     return;
5286   } else if (time == 0 &amp;&amp; !isAbsolute) {
5287     time = INFINITE;
5288   } else if (isAbsolute) {
5289     time -= os::javaTimeMillis(); // convert to relative time
5290     if (time &lt;= 0) {  // already elapsed
5291       return;
5292     }
5293   } else { // relative
5294     time /= 1000000;  // Must coarsen from nanos to millis
5295     if (time == 0) {  // Wait for the minimal time unit if zero
5296       time = 1;
5297     }
5298   }
5299 
5300   JavaThread* thread = JavaThread::current();
5301 
5302   // Don&#39;t wait if interrupted or already triggered
<span class="line-modified">5303   if (Thread::is_interrupted(thread, false) ||</span>
5304       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5305     ResetEvent(_ParkEvent);
5306     return;
5307   } else {
5308     ThreadBlockInVM tbivm(thread);
5309     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5310     thread-&gt;set_suspend_equivalent();
5311 
5312     WaitForSingleObject(_ParkEvent, time);
5313     ResetEvent(_ParkEvent);
5314 
5315     // If externally suspended while waiting, re-suspend
5316     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5317       thread-&gt;java_suspend_self();
5318     }
5319   }
5320 }
5321 
5322 void Parker::unpark() {
5323   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
5335   if (status != 0) {
5336     ret = OS_OK;
5337   }
5338   #ifndef PRODUCT
5339   else {
5340     DWORD err = GetLastError();
5341     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5342   }
5343   #endif
5344   return ret;
5345 }
5346 
5347 // Run the specified command in a separate process. Return its exit value,
5348 // or -1 on failure (e.g. can&#39;t create a new process).
5349 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5350   STARTUPINFO si;
5351   PROCESS_INFORMATION pi;
5352   DWORD exit_code;
5353 
5354   char * cmd_string;
<span class="line-modified">5355   char * cmd_prefix = &quot;cmd /C &quot;;</span>
5356   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5357   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5358   if (cmd_string == NULL) {
5359     return -1;
5360   }
5361   cmd_string[0] = &#39;\0&#39;;
5362   strcat(cmd_string, cmd_prefix);
5363   strcat(cmd_string, cmd);
5364 
5365   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5366   char * substring = cmd_string;
5367   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5368     substring[0] = &#39;&amp;&#39;;
5369     substring++;
5370   }
5371   memset(&amp;si, 0, sizeof(si));
5372   si.cb = sizeof(si);
5373   memset(&amp;pi, 0, sizeof(pi));
5374   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5375                             cmd_string,    // command line
</pre>
<hr />
<pre>
5674   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5675   UseNUMAInterleaving = old_use_numa_interleaving;
5676 }
5677 #endif // PRODUCT
5678 
5679 /*
5680   All the defined signal names for Windows.
5681 
5682   NOTE that not all of these names are accepted by FindSignal!
5683 
5684   For various reasons some of these may be rejected at runtime.
5685 
5686   Here are the names currently accepted by a user of sun.misc.Signal with
5687   1.4.1 (ignoring potential interaction with use of chaining, etc):
5688 
5689      (LIST TBD)
5690 
5691 */
5692 int os::get_signal_number(const char* name) {
5693   static const struct {
<span class="line-modified">5694     char* name;</span>
<span class="line-modified">5695     int   number;</span>
5696   } siglabels [] =
5697     // derived from version 6.0 VC98/include/signal.h
5698   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5699   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5700   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5701   &quot;INT&quot;,        SIGINT,         // interrupt
5702   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5703   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5704   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5705   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5706     if (strcmp(name, siglabels[i].name) == 0) {
5707       return siglabels[i].number;
5708     }
5709   }
5710   return -1;
5711 }
5712 
5713 // Fast current thread access
5714 
5715 int os::win32::_thread_ptr_offset = 0;
5716 
5717 static void call_wrapper_dummy() {}
5718 
5719 // We need to call the os_exception_wrapper once so that it sets
5720 // up the offset from FS of the thread pointer.
5721 void os::win32::initialize_thread_ptr_offset() {
5722   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
<span class="line-modified">5723                            NULL, NULL, NULL, NULL);</span>




5724 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
<span class="line-added">  39 #include &quot;logging/logStream.hpp&quot;</span>
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/filemap.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;os_share_windows.hpp&quot;
  44 #include &quot;os_windows.inline.hpp&quot;
  45 #include &quot;prims/jniFastGetField.hpp&quot;
  46 #include &quot;prims/jvm_misc.hpp&quot;
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/atomic.hpp&quot;
  49 #include &quot;runtime/extendedPC.hpp&quot;
  50 #include &quot;runtime/globals.hpp&quot;
  51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
  56 #include &quot;runtime/orderAccess.hpp&quot;
  57 #include &quot;runtime/osThread.hpp&quot;
  58 #include &quot;runtime/perfMemory.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
</pre>
<hr />
<pre>
 184 
 185 
 186 // This method is  a periodic task to check for misbehaving JNI applications
 187 // under CheckJNI, we can add any periodic checks here.
 188 // For Windows at the moment does nothing
 189 void os::run_periodic_checks() {
 190   return;
 191 }
 192 
 193 // previous UnhandledExceptionFilter, if there is one
 194 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 195 
 196 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 197 
 198 void os::init_system_properties_values() {
 199   // sysclasspath, java_home, dll_dir
 200   {
 201     char *home_path;
 202     char *dll_path;
 203     char *pslash;
<span class="line-modified"> 204     const char *bin = &quot;\\bin&quot;;</span>
 205     char home_dir[MAX_PATH + 1];
 206     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 207 
 208     if (alt_home_dir != NULL)  {
 209       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 210       home_dir[MAX_PATH] = &#39;\0&#39;;
 211     } else {
 212       os::jvm_path(home_dir, sizeof(home_dir));
 213       // Found the full path to jvm.dll.
 214       // Now cut the path to &lt;java_home&gt;/jre if we can.
 215       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 216       pslash = strrchr(home_dir, &#39;\\&#39;);
 217       if (pslash != NULL) {
 218         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 219         pslash = strrchr(home_dir, &#39;\\&#39;);
 220         if (pslash != NULL) {
 221           *pslash = &#39;\0&#39;;                 // get rid of \bin
 222         }
 223       }
 224     }
 225 
 226     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);



 227     strcpy(home_path, home_dir);
 228     Arguments::set_java_home(home_path);
 229     FREE_C_HEAP_ARRAY(char, home_path);
 230 
 231     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 232                                 mtInternal);



 233     strcpy(dll_path, home_dir);
 234     strcat(dll_path, bin);
 235     Arguments::set_dll_dir(dll_path);
 236     FREE_C_HEAP_ARRAY(char, dll_path);
 237 
 238     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 239       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 240     }
 241   }
 242 
 243 // library_path
 244 #define EXT_DIR &quot;\\lib\\ext&quot;
 245 #define BIN_DIR &quot;\\bin&quot;
 246 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 247   {
 248     // Win32 library search order (See the documentation for LoadLibrary):
 249     //
 250     // 1. The directory from which application is loaded.
 251     // 2. The system wide Java Extensions directory (Java only)
 252     // 3. System directory (GetSystemDirectory)
</pre>
<hr />
<pre>
 474   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 475 
 476   // One less thread is executing
 477   // When the VMThread gets here, the main thread may have already exited
 478   // which frees the CodeHeap containing the Atomic::add code
 479   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 480     Atomic::dec(&amp;os::win32::_os_thread_count);
 481   }
 482 
 483   // Thread must not return from exit_process_or_thread(), but if it does,
 484   // let it proceed to exit normally
 485   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 486 }
 487 
 488 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 489                                   int thread_id) {
 490   // Allocate the OSThread object
 491   OSThread* osthread = new OSThread(NULL, NULL);
 492   if (osthread == NULL) return NULL;
 493 
<span class="line-modified"> 494   // Initialize the JDK library&#39;s interrupt event.</span>
<span class="line-added"> 495   // This should really be done when OSThread is constructed,</span>
<span class="line-added"> 496   // but there is no way for a constructor to report failure to</span>
<span class="line-added"> 497   // allocate the event.</span>
 498   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 499   if (interrupt_event == NULL) {
 500     delete osthread;
 501     return NULL;
 502   }
 503   osthread-&gt;set_interrupt_event(interrupt_event);
 504 
 505   // Store info on the Win32 thread into the OSThread
 506   osthread-&gt;set_thread_handle(thread_handle);
 507   osthread-&gt;set_thread_id(thread_id);
 508 
 509   if (UseNUMA) {
 510     int lgrp_id = os::numa_get_group_id();
 511     if (lgrp_id != -1) {
 512       thread-&gt;set_lgrp_id(lgrp_id);
 513     }
 514   }
 515 
 516   // Initial thread state is INITIALIZED, not SUSPENDED
 517   osthread-&gt;set_state(INITIALIZED);
</pre>
<hr />
<pre>
 579   #define ALL(X) \
 580     X(CREATE_SUSPENDED) \
 581     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 582   ALL(PRINT_FLAG)
 583   #undef ALL
 584   #undef PRINT_FLAG
 585   return buf;
 586 }
 587 
 588 // Allocate and initialize a new OSThread
 589 bool os::create_thread(Thread* thread, ThreadType thr_type,
 590                        size_t stack_size) {
 591   unsigned thread_id;
 592 
 593   // Allocate the OSThread object
 594   OSThread* osthread = new OSThread(NULL, NULL);
 595   if (osthread == NULL) {
 596     return false;
 597   }
 598 
<span class="line-modified"> 599   // Initialize the JDK library&#39;s interrupt event.</span>
<span class="line-added"> 600   // This should really be done when OSThread is constructed,</span>
<span class="line-added"> 601   // but there is no way for a constructor to report failure to</span>
<span class="line-added"> 602   // allocate the event.</span>
 603   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 604   if (interrupt_event == NULL) {
 605     delete osthread;
 606     return false;
 607   }
 608   osthread-&gt;set_interrupt_event(interrupt_event);
<span class="line-modified"> 609   // We don&#39;t call set_interrupted(false) as it will trip the assert in there</span>
<span class="line-added"> 610   // as we are not operating on the current thread. We don&#39;t need to call it</span>
<span class="line-added"> 611   // because the initial state is already correct.</span>
 612 
 613   thread-&gt;set_osthread(osthread);
 614 
 615   if (stack_size == 0) {
 616     switch (thr_type) {
 617     case os::java_thread:
 618       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 619       if (JavaThread::stack_size_at_create() &gt; 0) {
 620         stack_size = JavaThread::stack_size_at_create();
 621       }
 622       break;
 623     case os::compiler_thread:
 624       if (CompilerThreadStackSize &gt; 0) {
 625         stack_size = (size_t)(CompilerThreadStackSize * K);
 626         break;
 627       } // else fall through:
 628         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 629     case os::vm_thread:
 630     case os::pgc_thread:
 631     case os::cgc_thread:
</pre>
<hr />
<pre>
 655   // are not supposed to call CreateThread() directly according to MSDN
 656   // document because JVM uses C runtime library. The good news is that the
 657   // flag appears to work with _beginthredex() as well.
 658 
 659   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 660   HANDLE thread_handle =
 661     (HANDLE)_beginthreadex(NULL,
 662                            (unsigned)stack_size,
 663                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 664                            thread,
 665                            initflag,
 666                            &amp;thread_id);
 667 
 668   char buf[64];
 669   if (thread_handle != NULL) {
 670     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 671       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 672   } else {
 673     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 674       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
<span class="line-added"> 675     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 676     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 677     LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 678     os::print_memory_info(&amp;st);</span>
 679   }
 680 
 681   if (thread_handle == NULL) {
 682     // Need to clean up stuff we&#39;ve allocated so far

 683     thread-&gt;set_osthread(NULL);
 684     delete osthread;
 685     return false;
 686   }
 687 
 688   Atomic::inc(&amp;os::win32::_os_thread_count);
 689 
 690   // Store info on the Win32 thread into the OSThread
 691   osthread-&gt;set_thread_handle(thread_handle);
 692   osthread-&gt;set_thread_id(thread_id);
 693 
 694   // Initial thread state is INITIALIZED, not SUSPENDED
 695   osthread-&gt;set_state(INITIALIZED);
 696 
 697   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 698   return true;
 699 }
 700 
 701 
 702 // Free Win32 resources related to the OSThread
 703 void os::free_thread(OSThread* osthread) {
 704   assert(osthread != NULL, &quot;osthread not set&quot;);
 705 
 706   // We are told to free resources of the argument thread,
 707   // but we can only really operate on the current thread.
 708   assert(Thread::current()-&gt;osthread() == osthread,
 709          &quot;os::free_thread but not current thread&quot;);
 710 
 711   CloseHandle(osthread-&gt;thread_handle());

 712   delete osthread;
 713 }
 714 
 715 static jlong first_filetime;
 716 static jlong initial_performance_count;
 717 static jlong performance_frequency;
 718 
 719 
 720 jlong as_long(LARGE_INTEGER x) {
 721   jlong result = 0; // initialization to avoid warning
 722   set_high(&amp;result, x.HighPart);
 723   set_low(&amp;result, x.LowPart);
 724   return result;
 725 }
 726 
 727 
 728 jlong os::elapsed_counter() {
 729   LARGE_INTEGER count;
 730   QueryPerformanceCounter(&amp;count);
 731   return as_long(count) - initial_performance_count;
</pre>
<hr />
<pre>
 778     return ActiveProcessorCount;
 779   }
 780 
 781   DWORD_PTR lpProcessAffinityMask = 0;
 782   DWORD_PTR lpSystemAffinityMask = 0;
 783   int proc_count = processor_count();
 784   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 785       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 786     // Nof active processors is number of bits in process affinity mask
 787     int bitcount = 0;
 788     while (lpProcessAffinityMask != 0) {
 789       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 790       bitcount++;
 791     }
 792     return bitcount;
 793   } else {
 794     return proc_count;
 795   }
 796 }
 797 
<span class="line-added"> 798 uint os::processor_id() {</span>
<span class="line-added"> 799   return (uint)GetCurrentProcessorNumber();</span>
<span class="line-added"> 800 }</span>
<span class="line-added"> 801 </span>
 802 void os::set_native_thread_name(const char *name) {
 803 
 804   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 805   //
 806   // Note that unfortunately this only works if the process
 807   // is already attached to a debugger; debugger must observe
 808   // the exception below to show the correct name.
 809 
 810   // If there is no debugger attached skip raising the exception
 811   if (!IsDebuggerPresent()) {
 812     return;
 813   }
 814 
 815   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 816   struct {
 817     DWORD dwType;     // must be 0x1000
 818     LPCSTR szName;    // pointer to name (in user addr space)
 819     DWORD dwThreadID; // thread ID (-1=caller thread)
 820     DWORD dwFlags;    // reserved for future use, must be zero
 821   } info;
 822 
 823   info.dwType = 0x1000;
 824   info.szName = name;
 825   info.dwThreadID = -1;
 826   info.dwFlags = 0;
 827 
 828   __try {
 829     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 830   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 831 }
 832 





 833 bool os::bind_to_processor(uint processor_id) {
 834   // Not yet implemented.
 835   return false;
 836 }
 837 
 838 void os::win32::initialize_performance_counter() {
 839   LARGE_INTEGER count;
 840   QueryPerformanceFrequency(&amp;count);
 841   performance_frequency = as_long(count);
 842   QueryPerformanceCounter(&amp;count);
 843   initial_performance_count = as_long(count);
 844 }
 845 
 846 
 847 double os::elapsedTime() {
 848   return (double) elapsed_counter() / (double) elapsed_frequency();
 849 }
 850 
 851 
 852 // Windows format:
</pre>
<hr />
<pre>
 893 jlong windows_to_java_time(FILETIME wt) {
 894   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 895   return (a - offset()) / 10000;
 896 }
 897 
 898 // Returns time ticks in (10th of micro seconds)
 899 jlong windows_to_time_ticks(FILETIME wt) {
 900   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 901   return (a - offset());
 902 }
 903 
 904 FILETIME java_to_windows_time(jlong l) {
 905   jlong a = (l * 10000) + offset();
 906   FILETIME result;
 907   result.dwHighDateTime = high(a);
 908   result.dwLowDateTime  = low(a);
 909   return result;
 910 }
 911 
 912 bool os::supports_vtime() { return true; }


 913 
 914 double os::elapsedVTime() {
 915   FILETIME created;
 916   FILETIME exited;
 917   FILETIME kernel;
 918   FILETIME user;
 919   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 920     // the resolution of windows_to_java_time() should be sufficient (ms)
 921     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 922   } else {
 923     return elapsedTime();
 924   }
 925 }
 926 
 927 jlong os::javaTimeMillis() {
 928   FILETIME wt;
 929   GetSystemTimeAsFileTime(&amp;wt);
 930   return windows_to_java_time(wt);
 931 }
 932 
</pre>
<hr />
<pre>
1345   }
1346 
1347   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1348 }
1349 
1350 // print module info; param is outputStream*
1351 static int _print_module(const char* fname, address base_address,
1352                          address top_address, void* param) {
1353   if (!param) return -1;
1354 
1355   outputStream* st = (outputStream*)param;
1356 
1357   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1358   return 0;
1359 }
1360 
1361 // Loads .dll/.so and
1362 // in case of error it checks if .dll/.so was built for the
1363 // same architecture as Hotspot is running on
1364 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
<span class="line-added">1365   log_info(os)(&quot;attempting shared library load of %s&quot;, name);</span>
<span class="line-added">1366 </span>
1367   void * result = LoadLibrary(name);
1368   if (result != NULL) {
<span class="line-added">1369     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);</span>
1370     // Recalculate pdb search path if a DLL was loaded successfully.
1371     SymbolEngine::recalc_search_path();
<span class="line-added">1372     log_info(os)(&quot;shared library load of %s was successful&quot;, name);</span>
1373     return result;
1374   }

1375   DWORD errcode = GetLastError();
<span class="line-added">1376   // Read system error message into ebuf</span>
<span class="line-added">1377   // It may or may not be overwritten below (in the for loop and just above)</span>
<span class="line-added">1378   lasterror(ebuf, (size_t) ebuflen);</span>
<span class="line-added">1379   ebuf[ebuflen - 1] = &#39;\0&#39;;</span>
<span class="line-added">1380   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);</span>
<span class="line-added">1381   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);</span>
<span class="line-added">1382 </span>
1383   if (errcode == ERROR_MOD_NOT_FOUND) {
1384     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1385     ebuf[ebuflen - 1] = &#39;\0&#39;;
1386     return NULL;
1387   }
1388 
1389   // Parsing dll below
1390   // If we can read dll-info and find that dll was built
1391   // for an architecture other than Hotspot is running in
1392   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1393   // else call os::lasterror to obtain system error message





1394   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1395   if (fd &lt; 0) {
1396     return NULL;
1397   }
1398 
1399   uint32_t signature_offset;
1400   uint16_t lib_arch = 0;
1401   bool failed_to_get_lib_arch =
1402     ( // Go to position 3c in the dll
1403      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1404      ||
1405      // Read location of signature
1406      (sizeof(signature_offset) !=
1407      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1408      ||
1409      // Go to COFF File Header in dll
1410      // that is located after &quot;signature&quot; (4 bytes long)
1411      (os::seek_to_file_offset(fd,
1412      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1413      ||
</pre>
<hr />
<pre>
1574 #endif // _MSC_VER dispatch
1575 }
1576 
1577 static inline time_t get_mtime(const char* filename) {
1578   struct stat st;
1579   int ret = os::stat(filename, &amp;st);
1580   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1581   return st.st_mtime;
1582 }
1583 
1584 int os::compare_file_modified_times(const char* file1, const char* file2) {
1585   time_t t1 = get_mtime(file1);
1586   time_t t2 = get_mtime(file2);
1587   return t1 - t2;
1588 }
1589 
1590 void os::print_os_info_brief(outputStream* st) {
1591   os::print_os_info(st);
1592 }
1593 
<span class="line-added">1594 void os::win32::print_uptime_info(outputStream* st) {</span>
<span class="line-added">1595   unsigned long long ticks = GetTickCount64();</span>
<span class="line-added">1596   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);</span>
<span class="line-added">1597 }</span>
<span class="line-added">1598 </span>
1599 void os::print_os_info(outputStream* st) {
1600 #ifdef ASSERT
1601   char buffer[1024];
1602   st-&gt;print(&quot;HostName: &quot;);
1603   if (get_host_name(buffer, sizeof(buffer))) {
1604     st-&gt;print(&quot;%s &quot;, buffer);
1605   } else {
1606     st-&gt;print(&quot;N/A &quot;);
1607   }
1608 #endif
1609   st-&gt;print(&quot;OS:&quot;);
1610   os::win32::print_windows_version(st);
<span class="line-added">1611 </span>
<span class="line-added">1612   os::win32::print_uptime_info(st);</span>
<span class="line-added">1613 </span>
<span class="line-added">1614 #ifdef _LP64</span>
<span class="line-added">1615   VM_Version::print_platform_virtualization_info(st);</span>
<span class="line-added">1616 #endif</span>
1617 }
1618 
1619 void os::win32::print_windows_version(outputStream* st) {
1620   OSVERSIONINFOEX osvi;
1621   VS_FIXEDFILEINFO *file_info;
1622   TCHAR kernel32_path[MAX_PATH];
1623   UINT len, ret;
1624 
1625   // Use the GetVersionEx information to see if we&#39;re on a server or
1626   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1627   // trust the OS version information returned by this API.
1628   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1629   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1630   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1631     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1632     return;
1633   }
1634   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1635 
1636   // Get the full path to \Windows\System32\kernel32.dll and use that for
</pre>
<hr />
<pre>
2086 
2087   // Add a CTRL-C handler
2088   SetConsoleCtrlHandler(consoleHandler, TRUE);
2089 }
2090 
2091 void os::signal_notify(int sig) {
2092   if (sig_sem != NULL) {
2093     Atomic::inc(&amp;pending_signals[sig]);
2094     sig_sem-&gt;signal();
2095   } else {
2096     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2097     // initialization isn&#39;t called.
2098     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2099   }
2100 }
2101 
2102 static int check_pending_signals() {
2103   while (true) {
2104     for (int i = 0; i &lt; NSIG + 1; i++) {
2105       jint n = pending_signals[i];
<span class="line-modified">2106       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
2107         return i;
2108       }
2109     }
2110     JavaThread *thread = JavaThread::current();
2111 
2112     ThreadBlockInVM tbivm(thread);
2113 
2114     bool threadIsSuspended;
2115     do {
2116       thread-&gt;set_suspend_equivalent();
2117       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2118       sig_sem-&gt;wait();
2119 
2120       // were we externally suspended while we were waiting?
2121       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2122       if (threadIsSuspended) {
2123         // The semaphore has been incremented, but while we were waiting
2124         // another thread suspended us. We don&#39;t want to continue running
2125         // while suspended because that would surprise the thread that
2126         // suspended us.
</pre>
<hr />
<pre>
2177 
2178 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2179 // Once a system header becomes available, the &quot;real&quot; define should be
2180 // included or copied here.
2181 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2182 
2183 // Windows Vista/2008 heap corruption check
2184 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2185 
2186 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2187 // C++ compiler contain this error code. Because this is a compiler-generated
2188 // error, the code is not listed in the Win32 API header files.
2189 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2190 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2191 // ASCII values of &quot;msc&quot;.
2192 
2193 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2194 
2195 #define def_excpt(val) { #val, (val) }
2196 
<span class="line-modified">2197 static const struct { const char* name; uint number; } exceptlabels[] = {</span>
2198     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2199     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2200     def_excpt(EXCEPTION_BREAKPOINT),
2201     def_excpt(EXCEPTION_SINGLE_STEP),
2202     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2203     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2204     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2205     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2206     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2207     def_excpt(EXCEPTION_FLT_OVERFLOW),
2208     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2209     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2210     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2211     def_excpt(EXCEPTION_INT_OVERFLOW),
2212     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2213     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2214     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2215     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2216     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2217     def_excpt(EXCEPTION_STACK_OVERFLOW),
</pre>
<hr />
<pre>
2525                  &quot;should be caught by red zone code above.&quot;);
2526           return Handle_Exception(exceptionInfo,
2527                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2528         }
2529         // Check for safepoint polling and implicit null
2530         // We only expect null pointers in the stubs (vtable)
2531         // the rest are checked explicitly now.
2532         CodeBlob* cb = CodeCache::find_blob(pc);
2533         if (cb != NULL) {
2534           if (os::is_poll_address(addr)) {
2535             address stub = SharedRuntime::get_poll_stub(pc);
2536             return Handle_Exception(exceptionInfo, stub);
2537           }
2538         }
2539         {
2540 #ifdef _WIN64
2541           // If it&#39;s a legal stack address map the entire region in
2542           //
2543           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2544           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
<span class="line-modified">2545           if (thread-&gt;is_in_usable_stack(addr)) {</span>
2546             addr = (address)((uintptr_t)addr &amp;
2547                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
2548             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
2549                               !ExecMem);
2550             return EXCEPTION_CONTINUE_EXECUTION;
2551           } else
2552 #endif
2553           {
2554             // Null pointer exception.
2555             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
2556               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
2557               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
2558             }
2559             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2560                          exceptionInfo-&gt;ContextRecord);
2561             return EXCEPTION_CONTINUE_SEARCH;
2562           }
2563         }
2564       }
2565 
</pre>
<hr />
<pre>
2572         if (addr != (address)-1) {
2573           return Handle_Exception(exceptionInfo, addr);
2574         }
2575       }
2576 #endif
2577 
2578       // Stack overflow or null pointer exception in native code.
2579       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2580                    exceptionInfo-&gt;ContextRecord);
2581       return EXCEPTION_CONTINUE_SEARCH;
2582     } // /EXCEPTION_ACCESS_VIOLATION
2583     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2584 
2585     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {
2586       CompiledMethod* nm = NULL;
2587       JavaThread* thread = (JavaThread*)t;
2588       if (in_java) {
2589         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
2590         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
2591       }
<span class="line-modified">2592 </span>
<span class="line-added">2593       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);</span>
<span class="line-added">2594       if (((thread-&gt;thread_state() == _thread_in_vm ||</span>
<span class="line-added">2595            thread-&gt;thread_state() == _thread_in_native ||</span>
<span class="line-added">2596            is_unsafe_arraycopy) &amp;&amp;</span>
2597           thread-&gt;doing_unsafe_access()) ||
2598           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
<span class="line-modified">2599         address next_pc =  Assembler::locate_next_instruction(pc);</span>
<span class="line-added">2600         if (is_unsafe_arraycopy) {</span>
<span class="line-added">2601           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);</span>
<span class="line-added">2602         }</span>
<span class="line-added">2603         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));</span>
2604       }
2605     }
2606 
2607     if (in_java) {
2608       switch (exception_code) {
2609       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2610         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2611 
2612       case EXCEPTION_INT_OVERFLOW:
2613         return Handle_IDiv_Exception(exceptionInfo);
2614 
2615       } // switch
2616     }
2617     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2618          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2619          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2620       LONG result=Handle_FLT_Exception(exceptionInfo);
2621       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2622     }
2623   }
</pre>
<hr />
<pre>
2708 // scenario, I found through experiment it only uses large page if the entire
2709 // memory region is reserved and committed in a single VirtualAlloc() call.
2710 // This makes Windows large page support more or less like Solaris ISM, in
2711 // that the entire heap must be committed upfront. This probably will change
2712 // in the future, if so the code below needs to be revisited.
2713 
2714 #ifndef MEM_LARGE_PAGES
2715   #define MEM_LARGE_PAGES 0x20000000
2716 #endif
2717 
2718 static HANDLE    _hProcess;
2719 static HANDLE    _hToken;
2720 
2721 // Container for NUMA node list info
2722 class NUMANodeListHolder {
2723  private:
2724   int *_numa_used_node_list;  // allocated below
2725   int _numa_used_node_count;
2726 
2727   void free_node_list() {
<span class="line-modified">2728     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);</span>


2729   }
2730 
2731  public:
2732   NUMANodeListHolder() {
2733     _numa_used_node_count = 0;
2734     _numa_used_node_list = NULL;
2735     // do rest of initialization in build routine (after function pointers are set up)
2736   }
2737 
2738   ~NUMANodeListHolder() {
2739     free_node_list();
2740   }
2741 
2742   bool build() {
2743     DWORD_PTR proc_aff_mask;
2744     DWORD_PTR sys_aff_mask;
2745     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2746     ULONG highest_node_number;
2747     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2748     free_node_list();
</pre>
<hr />
<pre>
3437 void os::numa_make_global(char *addr, size_t bytes)    { }
3438 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3439 bool os::numa_topology_changed()                       { return false; }
3440 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3441 int os::numa_get_group_id()                            { return 0; }
3442 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3443   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3444     // Provide an answer for UMA systems
3445     ids[0] = 0;
3446     return 1;
3447   } else {
3448     // check for size bigger than actual groups_num
3449     size = MIN2(size, numa_get_groups_num());
3450     for (int i = 0; i &lt; (int)size; i++) {
3451       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3452     }
3453     return size;
3454   }
3455 }
3456 
<span class="line-added">3457 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">3458   return 0;</span>
<span class="line-added">3459 }</span>
<span class="line-added">3460 </span>
3461 bool os::get_page_info(char *start, page_info* info) {
3462   return false;
3463 }
3464 
3465 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3466                      page_info* page_found) {
3467   return end;
3468 }
3469 
3470 char* os::non_memory_address_word() {
3471   // Must never look like an address returned by reserve_memory,
3472   // even in its subfields (as defined by the CPU immediate fields,
3473   // if the CPU splits constants across multiple instructions).
3474   return (char*)-1;
3475 }
3476 
3477 #define MAX_ERROR_COUNT 100
3478 #define SYS_THREAD_ERROR 0xffffffffUL
3479 
3480 void os::pd_start_thread(Thread* thread) {
3481   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3482   // Returns previous suspend state:
3483   // 0:  Thread was not suspended
3484   // 1:  Thread is running now
3485   // &gt;1: Thread is still suspended.
3486   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3487 }
3488 

















































































3489 
3490 // Short sleep, direct OS call.
3491 //
3492 // ms = 0, means allow others (if any) to run.
3493 //
3494 void os::naked_short_sleep(jlong ms) {
3495   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3496   Sleep(ms);
3497 }
3498 
<span class="line-added">3499 // Windows does not provide sleep functionality with nanosecond resolution, so we</span>
<span class="line-added">3500 // try to approximate this with spinning combined with yielding if another thread</span>
<span class="line-added">3501 // is ready to run on the current processor.</span>
3502 void os::naked_short_nanosleep(jlong ns) {
3503   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);








3504 
<span class="line-modified">3505   int64_t start = os::javaTimeNanos();</span>
<span class="line-modified">3506   do {</span>
<span class="line-modified">3507     if (SwitchToThread() == 0) {</span>
<span class="line-modified">3508       // Nothing else is ready to run on this cpu, spin a little</span>
<span class="line-modified">3509       SpinPause();</span>
















3510     }
<span class="line-modified">3511   } while (os::javaTimeNanos() - start &lt; ns);</span>

3512 }
3513 
3514 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3515 void os::infinite_sleep() {
3516   while (true) {    // sleep forever ...
3517     Sleep(100000);  // ... 100 seconds at a time
3518   }
3519 }
3520 
3521 typedef BOOL (WINAPI * STTSignature)(void);
3522 
3523 void os::naked_yield() {
3524   // Consider passing back the return value from SwitchToThread().
3525   SwitchToThread();
3526 }
3527 
3528 // Win32 only gives you access to seven real priorities at a time,
3529 // so we compress Java&#39;s ten down to seven.  It would be better
3530 // if we dynamically adjusted relative priorities.
3531 
</pre>
<hr />
<pre>
3577   if (!UseThreadPriorities) return OS_OK;
3578   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3579   return ret ? OS_OK : OS_ERR;
3580 }
3581 
3582 OSReturn os::get_native_priority(const Thread* const thread,
3583                                  int* priority_ptr) {
3584   if (!UseThreadPriorities) {
3585     *priority_ptr = java_to_os_priority[NormPriority];
3586     return OS_OK;
3587   }
3588   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3589   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3590     assert(false, &quot;GetThreadPriority failed&quot;);
3591     return OS_ERR;
3592   }
3593   *priority_ptr = os_prio;
3594   return OS_OK;
3595 }
3596 









































3597 // GetCurrentThreadId() returns DWORD
3598 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3599 
3600 static int _initial_pid = 0;
3601 
3602 int os::current_process_id() {
3603   return (_initial_pid ? _initial_pid : _getpid());
3604 }
3605 
3606 int    os::win32::_vm_page_size              = 0;
3607 int    os::win32::_vm_allocation_granularity = 0;
3608 int    os::win32::_processor_type            = 0;
3609 // Processor level is not available on non-NT systems, use vm_version instead
3610 int    os::win32::_processor_level           = 0;
3611 julong os::win32::_physical_memory           = 0;
3612 size_t os::win32::_default_stack_size        = 0;
3613 
3614 intx          os::win32::_os_thread_limit    = 0;
3615 volatile intx os::win32::_os_thread_count    = 0;
3616 
</pre>
<hr />
<pre>
3737     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3738     static int handle_count = 0;
3739 
3740     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3741     static CRITICAL_SECTION crit_sect;
3742     static volatile DWORD process_exiting = 0;
3743     int i, j;
3744     DWORD res;
3745     HANDLE hproc, hthr;
3746 
3747     // We only attempt to register threads until a process exiting
3748     // thread manages to set the process_exiting flag. Any threads
3749     // that come through here after the process_exiting flag is set
3750     // are unregistered and will be caught in the SuspendThread()
3751     // infinite loop below.
3752     bool registered = false;
3753 
3754     // The first thread that reached this point, initializes the critical section.
3755     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3756       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
<span class="line-modified">3757     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {</span>
3758       if (what != EPT_THREAD) {
3759         // Atomically set process_exiting before the critical section
3760         // to increase the visibility between racing threads.
<span class="line-modified">3761         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());</span>
3762       }
3763       EnterCriticalSection(&amp;crit_sect);
3764 
<span class="line-modified">3765       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {</span>
3766         // Remove from the array those handles of the threads that have completed exiting.
3767         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3768           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3769           if (res == WAIT_TIMEOUT) {
3770             handles[j++] = handles[i];
3771           } else {
3772             if (res == WAIT_FAILED) {
3773               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3774                       GetLastError(), __FILE__, __LINE__);
3775             }
3776             // Don&#39;t keep the handle, if we failed waiting for it.
3777             CloseHandle(handles[i]);
3778           }
3779         }
3780 
3781         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3782         // wait until at least one thread completes exiting.
3783         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3784           // Raise the priority of the oldest exiting thread to increase its chances
3785           // to complete sooner.
</pre>
<hr />
<pre>
3858                     GetLastError(), __FILE__, __LINE__);
3859             // Reset portion_count so we close the remaining
3860             // handles due to this error.
3861             portion_count = handle_count - i;
3862           }
3863           for (j = 0; j &lt; portion_count; ++j) {
3864             CloseHandle(handles[i + j]);
3865           }
3866           if ((i += portion_count) &gt;= handle_count) {
3867             break;
3868           }
3869           start_time = os::javaTimeNanos();
3870         }
3871         handle_count = 0;
3872       }
3873 
3874       LeaveCriticalSection(&amp;crit_sect);
3875     }
3876 
3877     if (!registered &amp;&amp;
<span class="line-modified">3878         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;</span>
3879         process_exiting != GetCurrentThreadId()) {
3880       // Some other thread is about to call exit(), so we don&#39;t let
3881       // the current unregistered thread proceed to exit() or _endthreadex()
3882       while (true) {
3883         SuspendThread(GetCurrentThread());
3884         // Avoid busy-wait loop, if SuspendThread() failed.
3885         Sleep(EXIT_TIMEOUT);
3886       }
3887     }
3888   }
3889 
3890   // We are here if either
3891   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
3892   // - initialization of the critical section failed (unlikely);
3893   // - the current thread has registered itself and left the critical section;
3894   // - the process-exiting thread has raised the flag and left the critical section.
3895   if (what == EPT_THREAD) {
3896     _endthreadex((unsigned)exit_code);
3897   } else if (what == EPT_PROCESS) {
3898     ::exit(exit_code);
3899   } else {
3900     _exit(exit_code);
3901   }
3902 
3903   // Should not reach here
3904   return exit_code;
3905 }
3906 
3907 #undef EXIT_TIMEOUT
3908 
3909 void os::win32::setmode_streams() {
3910   _setmode(_fileno(stdin), _O_BINARY);
3911   _setmode(_fileno(stdout), _O_BINARY);
3912   _setmode(_fileno(stderr), _O_BINARY);
3913 }
3914 






3915 void os::wait_for_keypress_at_exit(void) {
3916   if (PauseAtExit) {
3917     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
3918     fgetc(stdin);
3919   }
3920 }
3921 
3922 
3923 bool os::message_box(const char* title, const char* message) {
3924   int result = MessageBox(NULL, message, title,
3925                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
3926   return result == IDYES;
3927 }
3928 
3929 #ifndef PRODUCT
3930 #ifndef _WIN64
3931 // Helpers to check whether NX protection is enabled
3932 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
3933   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
3934       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
</pre>
<hr />
<pre>
3946   __try {
3947     __asm call code_ptr
3948   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
3949     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
3950   }
3951 }
3952 #endif // _WIN64
3953 #endif // PRODUCT
3954 
3955 // This is called _before_ the global arguments have been parsed
3956 void os::init(void) {
3957   _initial_pid = _getpid();
3958 
3959   init_random(1234567);
3960 
3961   win32::initialize_system_info();
3962   win32::setmode_streams();
3963   init_page_sizes((size_t) win32::vm_page_size());
3964 
3965   // This may be overridden later when argument processing is done.
<span class="line-modified">3966   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);</span>
3967 
3968   // Initialize main_process and main_thread
3969   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
3970   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
3971                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
3972     fatal(&quot;DuplicateHandle failed\n&quot;);
3973   }
3974   main_thread_id = (int) GetCurrentThreadId();
3975 
3976   // initialize fast thread access - only used for 32-bit
3977   win32::initialize_thread_ptr_offset();
3978 }
3979 
3980 // To install functions for atexit processing
3981 extern &quot;C&quot; {
3982   static void perfMemory_exit_helper() {
3983     perfMemory_exit();
3984   }
3985 }
3986 
3987 static jint initSock();
3988 
3989 // this is called _after_ the global arguments have been parsed
3990 jint os::init_2(void) {
3991 
3992   // This could be set any time but all platforms
3993   // have to set it the same so we have to mirror Solaris.
3994   DEBUG_ONLY(os::set_mutex_init_done();)
3995 
3996   // Setup Windows Exceptions
3997 
3998 #if INCLUDE_AOT
3999   // If AOT is enabled we need to install a vectored exception handler
4000   // in order to forward implicit exceptions from code in AOT
4001   // generated DLLs.  This is necessary since these DLLs are not
4002   // registered for structured exceptions like codecache methods are.
<span class="line-modified">4003   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {</span>
4004     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
4005   }
4006 #endif
4007 
4008   // for debugging float code generation bugs
4009   if (ForceFloatExceptions) {
4010 #ifndef  _WIN64
4011     static long fp_control_word = 0;
4012     __asm { fstcw fp_control_word }
4013     // see Intel PPro Manual, Vol. 2, p 7-16
4014     const long precision = 0x20;
4015     const long underflow = 0x10;
4016     const long overflow  = 0x08;
4017     const long zero_div  = 0x04;
4018     const long denorm    = 0x02;
4019     const long invalid   = 0x01;
4020     fp_control_word |= invalid;
4021     __asm { fldcw fp_control_word }
4022 #endif
4023   }
</pre>
<hr />
<pre>
4144   return value;
4145 }
4146 
4147 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4148 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4149   ::memset((void*)sbuf, 0, sizeof(struct stat));
4150   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4151   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4152                                   file_data.ftLastWriteTime.dwLowDateTime);
4153   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4154                                   file_data.ftCreationTime.dwLowDateTime);
4155   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4156                                   file_data.ftLastAccessTime.dwLowDateTime);
4157   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4158     sbuf-&gt;st_mode |= S_IFDIR;
4159   } else {
4160     sbuf-&gt;st_mode |= S_IFREG;
4161   }
4162 }
4163 
<span class="line-modified">4164 // Returns the given path as an absolute wide path in unc format. The returned path is NULL</span>
<span class="line-modified">4165 // on error (with err being set accordingly) and should be freed via os::free() otherwise.</span>
<span class="line-modified">4166 // additional_space is the number of additionally allocated wchars after the terminating L&#39;\0&#39;.</span>
<span class="line-modified">4167 // This is based on pathToNTPath() in io_util_md.cpp, but omits the optimizations for</span>
<span class="line-modified">4168 // short paths.</span>
<span class="line-modified">4169 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {</span>
<span class="line-modified">4170   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {</span>
<span class="line-modified">4171     err = ENOENT;</span>
<span class="line-modified">4172     return NULL;</span>
<span class="line-modified">4173   }</span>
<span class="line-modified">4174 </span>
<span class="line-modified">4175   size_t path_len = strlen(path);</span>
<span class="line-modified">4176   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.</span>
<span class="line-modified">4177   char* buf = (char*) os::malloc(1 + MAX2((size_t) 3, path_len), mtInternal);</span>
<span class="line-added">4178   wchar_t* result = NULL;</span>
<span class="line-added">4179 </span>
<span class="line-added">4180   if (buf == NULL) {</span>
<span class="line-added">4181     err = ENOMEM;</span>
<span class="line-added">4182   } else {</span>
<span class="line-added">4183     memcpy(buf, path, path_len + 1);</span>
<span class="line-added">4184     os::native_path(buf);</span>
<span class="line-added">4185 </span>
<span class="line-added">4186     wchar_t* prefix;</span>
<span class="line-added">4187     int prefix_off = 0;</span>
<span class="line-added">4188     bool is_abs = true;</span>
<span class="line-added">4189     bool needs_fullpath = true;</span>
<span class="line-added">4190 </span>
<span class="line-added">4191     if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {</span>
<span class="line-added">4192       prefix = L&quot;\\\\?\\&quot;;</span>
<span class="line-added">4193     } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {</span>
<span class="line-added">4194       if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {</span>
<span class="line-added">4195         prefix = L&quot;&quot;;</span>
<span class="line-added">4196         needs_fullpath = false;</span>
4197       } else {
<span class="line-modified">4198         prefix = L&quot;\\\\?\\UNC&quot;;</span>
<span class="line-added">4199         prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path</span>
4200       }
4201     } else {
<span class="line-modified">4202       is_abs = false;</span>
<span class="line-modified">4203       prefix = L&quot;\\\\?\\&quot;;</span>






4204     }
<span class="line-modified">4205 </span>
<span class="line-modified">4206     size_t buf_len = strlen(buf);</span>
<span class="line-modified">4207     size_t prefix_len = wcslen(prefix);</span>
<span class="line-modified">4208     size_t full_path_size = is_abs ? 1 + buf_len : JVM_MAXPATHLEN;</span>
<span class="line-modified">4209     size_t result_size = prefix_len + full_path_size - prefix_off;</span>
<span class="line-modified">4210     result = (wchar_t*) os::malloc(sizeof(wchar_t) * (additional_space + result_size), mtInternal);</span>
<span class="line-added">4211 </span>
<span class="line-added">4212     if (result == NULL) {</span>
4213       err = ENOMEM;
<span class="line-added">4214     } else {</span>
<span class="line-added">4215       size_t converted_chars;</span>
<span class="line-added">4216       wchar_t* path_start = result + prefix_len - prefix_off;</span>
<span class="line-added">4217       err = ::mbstowcs_s(&amp;converted_chars, path_start, buf_len + 1, buf, buf_len);</span>
<span class="line-added">4218 </span>
<span class="line-added">4219       if ((err == ERROR_SUCCESS) &amp;&amp; needs_fullpath) {</span>
<span class="line-added">4220         wchar_t* tmp = (wchar_t*) os::malloc(sizeof(wchar_t) * full_path_size, mtInternal);</span>
<span class="line-added">4221 </span>
<span class="line-added">4222         if (tmp == NULL) {</span>
<span class="line-added">4223           err = ENOMEM;</span>
<span class="line-added">4224         } else {</span>
<span class="line-added">4225           if (!_wfullpath(tmp, path_start, full_path_size)) {</span>
<span class="line-added">4226             err = ENOENT;</span>
<span class="line-added">4227           } else {</span>
<span class="line-added">4228             ::memcpy(path_start, tmp, (1 + wcslen(tmp)) * sizeof(wchar_t));</span>
<span class="line-added">4229           }</span>
<span class="line-added">4230 </span>
<span class="line-added">4231           os::free(tmp);</span>
<span class="line-added">4232         }</span>
<span class="line-added">4233       }</span>
<span class="line-added">4234 </span>
<span class="line-added">4235       memcpy(result, prefix, sizeof(wchar_t) * prefix_len);</span>
<span class="line-added">4236 </span>
<span class="line-added">4237       // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)</span>
<span class="line-added">4238       size_t result_len = wcslen(result);</span>
<span class="line-added">4239 </span>
<span class="line-added">4240       if (result[result_len - 1] == L&#39;\\&#39;) {</span>
<span class="line-added">4241         if (!(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {</span>
<span class="line-added">4242           result[result_len - 1] = L&#39;\0&#39;;</span>
<span class="line-added">4243         }</span>
<span class="line-added">4244       }</span>
4245     }
4246   }


4247 
<span class="line-modified">4248   os::free(buf);</span>
<span class="line-modified">4249 </span>
<span class="line-added">4250   if (err != ERROR_SUCCESS) {</span>
<span class="line-added">4251     os::free(result);</span>
<span class="line-added">4252     result = NULL;</span>
<span class="line-added">4253   }</span>
<span class="line-added">4254 </span>
<span class="line-added">4255   return result;</span>
4256 }
4257 
4258 int os::stat(const char *path, struct stat *sbuf) {
<span class="line-modified">4259   errno_t err;</span>
<span class="line-modified">4260   wchar_t* wide_path = wide_abs_unc_path(path, err);</span>
<span class="line-modified">4261 </span>
<span class="line-added">4262   if (wide_path == NULL) {</span>
<span class="line-added">4263     errno = err;</span>
4264     return -1;
4265   }
<span class="line-modified">4266 </span>
<span class="line-modified">4267   WIN32_FILE_ATTRIBUTE_DATA file_data;;</span>
<span class="line-modified">4268   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);</span>
<span class="line-modified">4269   os::free(wide_path);</span>
<span class="line-modified">4270 </span>
<span class="line-modified">4271   if (!bret) {</span>
<span class="line-modified">4272     errno = ::GetLastError();</span>
<span class="line-modified">4273     return -1;</span>
<span class="line-modified">4274   }</span>
<span class="line-modified">4275 </span>
<span class="line-modified">4276   file_attribute_data_to_stat(sbuf, file_data);</span>
<span class="line-modified">4277   return 0;</span>
<span class="line-modified">4278 }</span>
<span class="line-modified">4279 </span>
<span class="line-modified">4280 static HANDLE create_read_only_file_handle(const char* file) {</span>
<span class="line-modified">4281   errno_t err;</span>
<span class="line-modified">4282   wchar_t* wide_path = wide_abs_unc_path(file, err);</span>
<span class="line-modified">4283 </span>
<span class="line-modified">4284   if (wide_path == NULL) {</span>
<span class="line-modified">4285     errno = err;</span>
<span class="line-added">4286     return INVALID_HANDLE_VALUE;</span>
<span class="line-added">4287   }</span>
<span class="line-added">4288 </span>
<span class="line-added">4289   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,</span>
<span class="line-added">4290                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</span>
<span class="line-added">4291   os::free(wide_path);</span>
<span class="line-added">4292 </span>
<span class="line-added">4293   return handle;</span>
<span class="line-added">4294 }</span>
<span class="line-added">4295 </span>
<span class="line-added">4296 bool os::same_files(const char* file1, const char* file2) {</span>
<span class="line-added">4297 </span>
<span class="line-added">4298   if (file1 == NULL &amp;&amp; file2 == NULL) {</span>
<span class="line-added">4299     return true;</span>
<span class="line-added">4300   }</span>
<span class="line-added">4301 </span>
<span class="line-added">4302   if (file1 == NULL || file2 == NULL) {</span>
<span class="line-added">4303     return false;</span>
<span class="line-added">4304   }</span>
<span class="line-added">4305 </span>
<span class="line-added">4306   if (strcmp(file1, file2) == 0) {</span>
<span class="line-added">4307     return true;</span>
<span class="line-added">4308   }</span>
<span class="line-added">4309 </span>
<span class="line-added">4310   HANDLE handle1 = create_read_only_file_handle(file1);</span>
<span class="line-added">4311   HANDLE handle2 = create_read_only_file_handle(file2);</span>
<span class="line-added">4312   bool result = false;</span>
<span class="line-added">4313 </span>
<span class="line-added">4314   // if we could open both paths...</span>
<span class="line-added">4315   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">4316     BY_HANDLE_FILE_INFORMATION fileInfo1;</span>
<span class="line-added">4317     BY_HANDLE_FILE_INFORMATION fileInfo2;</span>
<span class="line-added">4318     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;</span>
<span class="line-added">4319       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {</span>
<span class="line-added">4320       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)</span>
<span class="line-added">4321       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;</span>
<span class="line-added">4322         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;</span>
<span class="line-added">4323         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {</span>
<span class="line-added">4324         result = true;</span>
4325       }











4326     }

4327   }



4328 
<span class="line-added">4329   //free the handles</span>
<span class="line-added">4330   if (handle1 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">4331     ::CloseHandle(handle1);</span>
<span class="line-added">4332   }</span>
<span class="line-added">4333 </span>
<span class="line-added">4334   if (handle2 != INVALID_HANDLE_VALUE) {</span>
<span class="line-added">4335     ::CloseHandle(handle2);</span>
<span class="line-added">4336   }</span>
<span class="line-added">4337 </span>
<span class="line-added">4338   return result;</span>
<span class="line-added">4339 }</span>
4340 
4341 #define FT2INT64(ft) \
4342   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4343 
4344 
4345 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4346 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4347 // of a thread.
4348 //
4349 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4350 // the fast estimate available on the platform.
4351 
4352 // current_thread_cpu_time() is not optimized for Windows yet
4353 jlong os::current_thread_cpu_time() {
4354   // return user + sys since the cost is the same
4355   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4356 }
4357 
4358 jlong os::thread_cpu_time(Thread* thread) {
4359   // consistent with what current_thread_cpu_time() returns.
</pre>
<hr />
<pre>
4425 //    returns 100%), so we&#39;d have to deal with that as well.
4426 //
4427 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4428 //    the answer in a global variable.  The call to loadavg would
4429 //    just return the value of the global, avoiding the slow query.
4430 //
4431 // c) Sample a better answer using exponential decay to smooth the
4432 //    value.  This is basically the algorithm used by UNIX kernels.
4433 //
4434 // Note that sampling thread starvation could affect both (b) and (c).
4435 int os::loadavg(double loadavg[], int nelem) {
4436   return -1;
4437 }
4438 
4439 
4440 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4441 bool os::dont_yield() {
4442   return DontYieldALot;
4443 }
4444 



4445 int os::open(const char *path, int oflag, int mode) {
<span class="line-modified">4446   errno_t err;</span>
<span class="line-modified">4447   wchar_t* wide_path = wide_abs_unc_path(path, err);</span>
<span class="line-modified">4448 </span>
<span class="line-added">4449   if (wide_path == NULL) {</span>
<span class="line-added">4450     errno = err;</span>
4451     return -1;
4452   }
<span class="line-modified">4453   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);</span>
<span class="line-modified">4454   os::free(wide_path);</span>
<span class="line-modified">4455 </span>
<span class="line-modified">4456   if (fd == -1) {</span>
<span class="line-modified">4457     errno = ::GetLastError();</span>















4458   }
<span class="line-modified">4459 </span>
<span class="line-modified">4460   return fd;</span>
4461 }
4462 
4463 FILE* os::open(int fd, const char* mode) {
4464   return ::_fdopen(fd, mode);
4465 }
4466 
4467 // Is a (classpath) directory empty?
4468 bool os::dir_is_empty(const char* path) {
<span class="line-modified">4469   errno_t err;</span>
<span class="line-modified">4470   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);</span>
<span class="line-modified">4471 </span>
<span class="line-modified">4472   if (wide_path == NULL) {</span>




















4473     errno = err;
4474     return false;
4475   }
<span class="line-added">4476 </span>
<span class="line-added">4477   // Make sure we end with &quot;\\*&quot;</span>
<span class="line-added">4478   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {</span>
<span class="line-added">4479     wcscat(wide_path, L&quot;*&quot;);</span>
<span class="line-added">4480   } else {</span>
<span class="line-added">4481     wcscat(wide_path, L&quot;\\*&quot;);</span>
<span class="line-added">4482   }</span>
<span class="line-added">4483 </span>
4484   WIN32_FIND_DATAW fd;
<span class="line-modified">4485   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);</span>
<span class="line-modified">4486   os::free(wide_path);</span>
4487   bool is_empty = true;
<span class="line-added">4488 </span>
4489   if (f != INVALID_HANDLE_VALUE) {
4490     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4491       // An empty directory contains only the current directory file
4492       // and the previous directory file.
4493       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4494           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4495         is_empty = false;
4496       }
4497     }
4498     FindClose(f);
<span class="line-added">4499   } else {</span>
<span class="line-added">4500     errno = ::GetLastError();</span>
4501   }
<span class="line-modified">4502 </span>
4503   return is_empty;
4504 }
4505 
4506 // create binary file, rewriting existing file if required
4507 int os::create_binary_file(const char* path, bool rewrite_existing) {
4508   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4509   if (!rewrite_existing) {
4510     oflags |= _O_EXCL;
4511   }
4512   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4513 }
4514 
4515 // return current position of file pointer
4516 jlong os::current_file_offset(int fd) {
4517   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4518 }
4519 
4520 // move file pointer to the specified offset
4521 jlong os::seek_to_file_offset(int fd, jlong offset) {
4522   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
</pre>
<hr />
<pre>
4847 
4848   if (allow_exec) {
4849     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4850     // unless it comes from a PE image (which the shared archive is not.)
4851     // Even VirtualProtect refuses to give execute access to mapped memory
4852     // that was not previously executable.
4853     //
4854     // Instead, stick the executable region in anonymous memory.  Yuck.
4855     // Penalty is that ~4 pages will not be shareable - in the future
4856     // we might consider DLLizing the shared archive with a proper PE
4857     // header so that mapping executable + sharing is possible.
4858 
4859     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4860                                 PAGE_READWRITE);
4861     if (base == NULL) {
4862       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4863       CloseHandle(hFile);
4864       return NULL;
4865     }
4866 
<span class="line-added">4867     // Record virtual memory allocation</span>
<span class="line-added">4868     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);</span>
<span class="line-added">4869 </span>
4870     DWORD bytes_read;
4871     OVERLAPPED overlapped;
4872     overlapped.Offset = (DWORD)file_offset;
4873     overlapped.OffsetHigh = 0;
4874     overlapped.hEvent = NULL;
4875     // ReadFile guarantees that if the return value is true, the requested
4876     // number of bytes were read before returning.
4877     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4878     if (!res) {
4879       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4880       release_memory(base, bytes);
4881       CloseHandle(hFile);
4882       return NULL;
4883     }
4884   } else {
4885     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4886                                     NULL /* file_name */);
4887     if (hMap == NULL) {
4888       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4889       CloseHandle(hFile);
</pre>
<hr />
<pre>
4918       // VirtualProtect fails, we should still be able to execute
4919       CloseHandle(hFile);
4920       return base;
4921     }
4922   }
4923 
4924   if (CloseHandle(hFile) == 0) {
4925     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4926     return base;
4927   }
4928 
4929   return base;
4930 }
4931 
4932 
4933 // Remap a block of memory.
4934 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4935                           char *addr, size_t bytes, bool read_only,
4936                           bool allow_exec) {
4937   // This OS does not allow existing memory maps to be remapped so we
<span class="line-modified">4938   // would have to unmap the memory before we remap it.</span>







4939 
<span class="line-modified">4940   // Because there is a small window between unmapping memory and mapping</span>
<span class="line-modified">4941   // it in again with different protections, CDS archives are mapped RW</span>
<span class="line-added">4942   // on windows, so this function isn&#39;t called.</span>
<span class="line-added">4943   ShouldNotReachHere();</span>
<span class="line-added">4944   return NULL;</span>
4945 }
4946 
4947 
4948 // Unmap a block of memory.
4949 // Returns true=success, otherwise false.
4950 
4951 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4952   MEMORY_BASIC_INFORMATION mem_info;
4953   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4954     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4955     return false;
4956   }
4957 
4958   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4959   // Instead, executable region was allocated using VirtualAlloc(). See
4960   // pd_map_memory() above.
4961   //
4962   // The following flags should match the &#39;exec_access&#39; flages used for
4963   // VirtualProtect() in pd_map_memory().
4964   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4965       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4966     return pd_release_memory(addr, bytes);
4967   }
4968 
4969   BOOL result = UnmapViewOfFile(addr);
4970   if (result == 0) {
4971     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4972     return false;
4973   }
4974   return true;
4975 }
4976 
4977 void os::pause() {
4978   char filename[MAX_PATH];
4979   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">4980     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
4981   } else {
4982     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4983   }
4984 
4985   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4986   if (fd != -1) {
4987     struct stat buf;
4988     ::close(fd);
4989     while (::stat(filename, &amp;buf) == 0) {
4990       Sleep(100);
4991     }
4992   } else {
4993     jio_fprintf(stderr,
4994                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
4995   }
4996 }
4997 
4998 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
4999 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
5000 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
</pre>
<hr />
<pre>
5012 
5013   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5014 
5015   _protected_thread = Thread::current_or_null();
5016   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5017 
5018   bool success = true;
5019   __try {
5020     _crash_protection = this;
5021     cb.call();
5022   } __except(EXCEPTION_EXECUTE_HANDLER) {
5023     // only for protection, nothing to do
5024     success = false;
5025   }
5026   _crash_protection = NULL;
5027   _protected_thread = NULL;
5028   Thread::muxRelease(&amp;_crash_mux);
5029   return success;
5030 }
5031 
<span class="line-added">5032 </span>
<span class="line-added">5033 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {</span>
<span class="line-added">5034   // The default timer resolution seems to be 10 milliseconds.</span>
<span class="line-added">5035   // (Where is this written down?)</span>
<span class="line-added">5036   // If someone wants to sleep for only a fraction of the default,</span>
<span class="line-added">5037   // then we set the timer resolution down to 1 millisecond for</span>
<span class="line-added">5038   // the duration of their interval.</span>
<span class="line-added">5039   // We carefully set the resolution back, since otherwise we</span>
<span class="line-added">5040   // seem to incur an overhead (3%?) that we don&#39;t need.</span>
<span class="line-added">5041   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.</span>
<span class="line-added">5042   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().</span>
<span class="line-added">5043   // Alternatively, we could compute the relative error (503/500 = .6%) and only use</span>
<span class="line-added">5044   // timeBeginPeriod() if the relative error exceeded some threshold.</span>
<span class="line-added">5045   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and</span>
<span class="line-added">5046   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize</span>
<span class="line-added">5047   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high</span>
<span class="line-added">5048   // resolution timers running.</span>
<span class="line-added">5049  private:</span>
<span class="line-added">5050   jlong resolution;</span>
<span class="line-added">5051  public:</span>
<span class="line-added">5052   HighResolutionInterval(jlong ms) {</span>
<span class="line-added">5053     resolution = ms % 10L;</span>
<span class="line-added">5054     if (resolution != 0) {</span>
<span class="line-added">5055       MMRESULT result = timeBeginPeriod(1L);</span>
<span class="line-added">5056     }</span>
<span class="line-added">5057   }</span>
<span class="line-added">5058   ~HighResolutionInterval() {</span>
<span class="line-added">5059     if (resolution != 0) {</span>
<span class="line-added">5060       MMRESULT result = timeEndPeriod(1L);</span>
<span class="line-added">5061     }</span>
<span class="line-added">5062     resolution = 0L;</span>
<span class="line-added">5063   }</span>
<span class="line-added">5064 };</span>
<span class="line-added">5065 </span>
5066 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5067 //
5068 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5069 //
5070 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5071 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5072 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5073 //     In addition, an unpark() operation might fetch the handle field, but the
5074 //     event could recycle between the fetch and the SetEvent() operation.
5075 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5076 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5077 //     on an stale but recycled handle would be harmless, but in practice this might
5078 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5079 //
5080 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5081 //     with the Event.  The event handle is never closed.  This could be construed
5082 //     as handle leakage, but only up to the maximum # of threads that have been extant
5083 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5084 //     permit a process to have hundreds of thousands of open handles.
5085 //
5086 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5087 //     and release unused handles.
5088 //
5089 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5090 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5091 //
5092 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5093 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5094 //
5095 // We use (2).
5096 //
5097 // TODO-FIXME:
5098 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5099 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5100 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
<span class="line-modified">5101 // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent</span>
5102 //     into a single win32 CreateEvent() handle.
5103 //
5104 // Assumption:
5105 //    Only one parker can exist on an event, which is why we allocate
5106 //    them per-thread. Multiple unparkers can coexist.
5107 //
5108 // _Event transitions in park()
5109 //   -1 =&gt; -1 : illegal
5110 //    1 =&gt;  0 : pass - return immediately
5111 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5112 //
5113 // _Event transitions in unpark()
5114 //    0 =&gt; 1 : just return
5115 //    1 =&gt; 1 : just return
5116 //   -1 =&gt; either 0 or 1; must signal target thread
5117 //         That is, we can safely transition _Event from -1 to either
5118 //         0 or 1.
5119 //
5120 // _Event serves as a restricted-range semaphore.
5121 //   -1 : thread is blocked, i.e. there is a waiter
</pre>
<hr />
<pre>
5126 // Another possible encoding of _Event would be with
5127 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5128 //
5129 
5130 int os::PlatformEvent::park(jlong Millis) {
5131   // Transitions for _Event:
5132   //   -1 =&gt; -1 : illegal
5133   //    1 =&gt;  0 : pass - return immediately
5134   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5135 
5136   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5137   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5138 
5139   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5140   // the initial park() operation.
5141   // Consider: use atomic decrement instead of CAS-loop
5142 
5143   int v;
5144   for (;;) {
5145     v = _Event;
<span class="line-modified">5146     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
5147   }
5148   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5149   if (v != 0) return OS_OK;
5150 
5151   // Do this the hard way by blocking ...
5152   // TODO: consider a brief spin here, gated on the success of recent
5153   // spin attempts by this thread.
5154   //
5155   // We decompose long timeouts into series of shorter timed waits.
5156   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5157   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5158   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5159   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5160   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5161   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5162   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5163   // for the already waited time.  This policy does not admit any new outcomes.
5164   // In the future, however, we might want to track the accumulated wait time and
5165   // adjust Millis accordingly if we encounter a spurious wakeup.
5166 
5167   const int MAXTIMEOUT = 0x10000000;
5168   DWORD rv = WAIT_TIMEOUT;
5169   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5170     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5171     if (Millis &gt; MAXTIMEOUT) {
5172       prd = MAXTIMEOUT;
5173     }
<span class="line-added">5174     HighResolutionInterval *phri = NULL;</span>
<span class="line-added">5175     if (!ForceTimeHighResolution) {</span>
<span class="line-added">5176       phri = new HighResolutionInterval(prd);</span>
<span class="line-added">5177     }</span>
5178     rv = ::WaitForSingleObject(_ParkHandle, prd);
5179     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5180     if (rv == WAIT_TIMEOUT) {
5181       Millis -= prd;
5182     }
<span class="line-added">5183     delete phri; // if it is NULL, harmless</span>
5184   }
5185   v = _Event;
5186   _Event = 0;
5187   // see comment at end of os::PlatformEvent::park() below:
5188   OrderAccess::fence();
5189   // If we encounter a nearly simultanous timeout expiry and unpark()
5190   // we return OS_OK indicating we awoke via unpark().
5191   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5192   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5193 }
5194 
5195 void os::PlatformEvent::park() {
5196   // Transitions for _Event:
5197   //   -1 =&gt; -1 : illegal
5198   //    1 =&gt;  0 : pass - return immediately
5199   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5200 
5201   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5202   // Invariant: Only the thread associated with the Event/PlatformEvent
5203   // may call park().
5204   // Consider: use atomic decrement instead of CAS-loop
5205   int v;
5206   for (;;) {
5207     v = _Event;
<span class="line-modified">5208     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;</span>
5209   }
5210   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5211   if (v != 0) return;
5212 
5213   // Do this the hard way by blocking ...
5214   // TODO: consider a brief spin here, gated on the success of recent
5215   // spin attempts by this thread.
5216   while (_Event &lt; 0) {
5217     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5218     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5219   }
5220 
5221   // Usually we&#39;ll find _Event == 0 at this point, but as
5222   // an optional optimization we clear it, just in case can
5223   // multiple unpark() operations drove _Event up to 1.
5224   _Event = 0;
5225   OrderAccess::fence();
5226   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5227 }
5228 
5229 void os::PlatformEvent::unpark() {
5230   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5231 
5232   // Transitions for _Event:
5233   //    0 =&gt; 1 : just return
5234   //    1 =&gt; 1 : just return
5235   //   -1 =&gt; either 0 or 1; must signal target thread
5236   //         That is, we can safely transition _Event from -1 to either
5237   //         0 or 1.
5238   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5239   //
5240   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5241   // that it will take two back-to-back park() calls for the owning
5242   // thread to block. This has the benefit of forcing a spurious return
5243   // from the first park() call after an unpark() call which will help
5244   // shake out uses of park() and unpark() without condition variables.
5245 
<span class="line-modified">5246   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;</span>
5247 
5248   ::SetEvent(_ParkHandle);
5249 }
5250 
5251 
5252 // JSR166
5253 // -------------------------------------------------------
5254 
5255 // The Windows implementation of Park is very straightforward: Basic
5256 // operations on Win32 Events turn out to have the right semantics to
5257 // use them directly. We opportunistically resuse the event inherited
5258 // from Monitor.
5259 
5260 void Parker::park(bool isAbsolute, jlong time) {
5261   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5262   // First, demultiplex/decode time arguments
5263   if (time &lt; 0) { // don&#39;t wait
5264     return;
5265   } else if (time == 0 &amp;&amp; !isAbsolute) {
5266     time = INFINITE;
5267   } else if (isAbsolute) {
5268     time -= os::javaTimeMillis(); // convert to relative time
5269     if (time &lt;= 0) {  // already elapsed
5270       return;
5271     }
5272   } else { // relative
5273     time /= 1000000;  // Must coarsen from nanos to millis
5274     if (time == 0) {  // Wait for the minimal time unit if zero
5275       time = 1;
5276     }
5277   }
5278 
5279   JavaThread* thread = JavaThread::current();
5280 
5281   // Don&#39;t wait if interrupted or already triggered
<span class="line-modified">5282   if (thread-&gt;is_interrupted(false) ||</span>
5283       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5284     ResetEvent(_ParkEvent);
5285     return;
5286   } else {
5287     ThreadBlockInVM tbivm(thread);
5288     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5289     thread-&gt;set_suspend_equivalent();
5290 
5291     WaitForSingleObject(_ParkEvent, time);
5292     ResetEvent(_ParkEvent);
5293 
5294     // If externally suspended while waiting, re-suspend
5295     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5296       thread-&gt;java_suspend_self();
5297     }
5298   }
5299 }
5300 
5301 void Parker::unpark() {
5302   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
5314   if (status != 0) {
5315     ret = OS_OK;
5316   }
5317   #ifndef PRODUCT
5318   else {
5319     DWORD err = GetLastError();
5320     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5321   }
5322   #endif
5323   return ret;
5324 }
5325 
5326 // Run the specified command in a separate process. Return its exit value,
5327 // or -1 on failure (e.g. can&#39;t create a new process).
5328 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5329   STARTUPINFO si;
5330   PROCESS_INFORMATION pi;
5331   DWORD exit_code;
5332 
5333   char * cmd_string;
<span class="line-modified">5334   const char * cmd_prefix = &quot;cmd /C &quot;;</span>
5335   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5336   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5337   if (cmd_string == NULL) {
5338     return -1;
5339   }
5340   cmd_string[0] = &#39;\0&#39;;
5341   strcat(cmd_string, cmd_prefix);
5342   strcat(cmd_string, cmd);
5343 
5344   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5345   char * substring = cmd_string;
5346   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5347     substring[0] = &#39;&amp;&#39;;
5348     substring++;
5349   }
5350   memset(&amp;si, 0, sizeof(si));
5351   si.cb = sizeof(si);
5352   memset(&amp;pi, 0, sizeof(pi));
5353   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5354                             cmd_string,    // command line
</pre>
<hr />
<pre>
5653   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5654   UseNUMAInterleaving = old_use_numa_interleaving;
5655 }
5656 #endif // PRODUCT
5657 
5658 /*
5659   All the defined signal names for Windows.
5660 
5661   NOTE that not all of these names are accepted by FindSignal!
5662 
5663   For various reasons some of these may be rejected at runtime.
5664 
5665   Here are the names currently accepted by a user of sun.misc.Signal with
5666   1.4.1 (ignoring potential interaction with use of chaining, etc):
5667 
5668      (LIST TBD)
5669 
5670 */
5671 int os::get_signal_number(const char* name) {
5672   static const struct {
<span class="line-modified">5673     const char* name;</span>
<span class="line-modified">5674     int         number;</span>
5675   } siglabels [] =
5676     // derived from version 6.0 VC98/include/signal.h
5677   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5678   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5679   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5680   &quot;INT&quot;,        SIGINT,         // interrupt
5681   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5682   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5683   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5684   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5685     if (strcmp(name, siglabels[i].name) == 0) {
5686       return siglabels[i].number;
5687     }
5688   }
5689   return -1;
5690 }
5691 
5692 // Fast current thread access
5693 
5694 int os::win32::_thread_ptr_offset = 0;
5695 
5696 static void call_wrapper_dummy() {}
5697 
5698 // We need to call the os_exception_wrapper once so that it sets
5699 // up the offset from FS of the thread pointer.
5700 void os::win32::initialize_thread_ptr_offset() {
5701   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
<span class="line-modified">5702                            NULL, methodHandle(), NULL, NULL);</span>
<span class="line-added">5703 }</span>
<span class="line-added">5704 </span>
<span class="line-added">5705 bool os::supports_map_sync() {</span>
<span class="line-added">5706   return false;</span>
5707 }
</pre>
</td>
</tr>
</table>
<center><a href="os_perf_windows.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_windows.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
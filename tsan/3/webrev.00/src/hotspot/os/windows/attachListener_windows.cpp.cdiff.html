<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/windows/attachListener_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris/perfMemory_solaris.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_windows.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/windows/attachListener_windows.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,27 ***</span>
  }
  
  
  // open the pipe to the client
  HANDLE Win32AttachOperation::open_pipe() {
<span class="line-modified">!   HANDLE hPipe;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hPipe = ::CreateFile( pipe(),  // pipe name</span>
                          GENERIC_WRITE,   // write only
                          0,              // no sharing
                          NULL,           // default security attributes
                          OPEN_EXISTING,  // opens existing pipe
                          0,              // default attributes
                          NULL);          // no template file
<span class="line-removed">- </span>
<span class="line-removed">-   if (hPipe != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">-     // shouldn&#39;t happen as there is a pipe created per operation</span>
<span class="line-removed">-     if (::GetLastError() == ERROR_PIPE_BUSY) {</span>
<span class="line-removed">-       ::CloseHandle(hPipe);</span>
<span class="line-removed">-       return INVALID_HANDLE_VALUE;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
    return hPipe;
  }
  
  // write to the pipe
  BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {
<span class="line-new-header">--- 270,17 ---</span>
  }
  
  
  // open the pipe to the client
  HANDLE Win32AttachOperation::open_pipe() {
<span class="line-modified">!   HANDLE hPipe = ::CreateFile( pipe(),  // pipe name</span>
                          GENERIC_WRITE,   // write only
                          0,              // no sharing
                          NULL,           // default security attributes
                          OPEN_EXISTING,  // opens existing pipe
                          0,              // default attributes
                          NULL);          // no template file
    return hPipe;
  }
  
  // write to the pipe
  BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,12 ***</span>
      if (!fSuccess) {
        return fSuccess;
      }
      buf += nwrote;
      len -= nwrote;
<span class="line-modified">!   }</span>
<span class="line-removed">-   while (len &gt; 0);</span>
    return TRUE;
  }
  
  // Complete the operation:
  //   - open the pipe to the client
<span class="line-new-header">--- 295,11 ---</span>
      if (!fSuccess) {
        return fSuccess;
      }
      buf += nwrote;
      len -= nwrote;
<span class="line-modified">!   } while (len &gt; 0);</span>
    return TRUE;
  }
  
  // Complete the operation:
  //   - open the pipe to the client
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,10 ***</span>
<span class="line-new-header">--- 313,11 ---</span>
    thread-&gt;set_suspend_equivalent();
    // cleared by handle_special_suspend_equivalent_condition() or
    // java_suspend_self() via check_and_wait_while_suspended()
  
    HANDLE hPipe = open_pipe();
<span class="line-added">+   int lastError = (int)::GetLastError();</span>
    if (hPipe != INVALID_HANDLE_VALUE) {
      BOOL fSuccess;
  
      char msg[32];
      _snprintf(msg, sizeof(msg), &quot;%d\n&quot;, result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,22 ***</span>
  
      fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));
      if (fSuccess) {
        fSuccess = write_pipe(hPipe, (char*)result_stream-&gt;base(), (int)(result_stream-&gt;size()));
      }
  
      // Need to flush buffers
      FlushFileBuffers(hPipe);
      CloseHandle(hPipe);
  
      if (fSuccess) {
        log_debug(attach)(&quot;wrote result of attach operation %s to pipe %s&quot;, name(), pipe());
      } else {
<span class="line-modified">!       log_error(attach)(&quot;failure writing result of operation %s to pipe %s&quot;, name(), pipe());</span>
      }
    } else {
<span class="line-modified">!     log_error(attach)(&quot;could not open pipe %s to send result of operation %s&quot;, pipe(), name());</span>
    }
  
    DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);
    if (res == WAIT_OBJECT_0) {
  
<span class="line-new-header">--- 325,23 ---</span>
  
      fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));
      if (fSuccess) {
        fSuccess = write_pipe(hPipe, (char*)result_stream-&gt;base(), (int)(result_stream-&gt;size()));
      }
<span class="line-added">+     lastError = (int)::GetLastError();</span>
  
      // Need to flush buffers
      FlushFileBuffers(hPipe);
      CloseHandle(hPipe);
  
      if (fSuccess) {
        log_debug(attach)(&quot;wrote result of attach operation %s to pipe %s&quot;, name(), pipe());
      } else {
<span class="line-modified">!       log_error(attach)(&quot;failure (%d) writing result of operation %s to pipe %s&quot;, lastError, name(), pipe());</span>
      }
    } else {
<span class="line-modified">!     log_error(attach)(&quot;could not open (%d) pipe %s to send result of operation %s&quot;, lastError, pipe(), name());</span>
    }
  
    DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);
    if (res == WAIT_OBJECT_0) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,10 ***</span>
<span class="line-new-header">--- 381,16 ---</span>
  
  int AttachListener::pd_init() {
    return Win32AttachListener::init();
  }
  
<span class="line-added">+ // This function is used for Un*x OSes only.</span>
<span class="line-added">+ // We need not to implement it for Windows.</span>
<span class="line-added">+ bool AttachListener::check_socket_file() {</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool AttachListener::init_at_startup() {
    return true;
  }
  
  // no trigger mechanism on Windows to start Attach Listener lazily
</pre>
<center><a href="../solaris/perfMemory_solaris.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_windows.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
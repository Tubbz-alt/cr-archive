diff a/src/hotspot/os/bsd/osThread_bsd.cpp b/src/hotspot/os/bsd/osThread_bsd.cpp
--- a/src/hotspot/os/bsd/osThread_bsd.cpp
+++ b/src/hotspot/os/bsd/osThread_bsd.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -34,21 +34,38 @@
 #ifdef __APPLE__
   _thread_id        = 0;
 #else
   _thread_id        = NULL;
 #endif
+  _unique_thread_id = 0;
   _pthread_id       = NULL;
-  _siginfo = NULL;
-  _ucontext = NULL;
-  _expanding_stack = 0;
-  _alt_sig_stack = NULL;
+  _siginfo          = NULL;
+  _ucontext         = NULL;
+  _expanding_stack  = 0;
+  _alt_sig_stack    = NULL;
 
   sigemptyset(&_caller_sigmask);
 
   _startThread_lock = new Monitor(Mutex::event, "startThread_lock", true,
                                   Monitor::_safepoint_check_never);
   assert(_startThread_lock !=NULL, "check");
 }
 
+// Additional thread_id used to correlate threads in SA
+void OSThread::set_unique_thread_id() {
+#ifdef __APPLE__
+  thread_identifier_info_data_t m_ident_info;
+  mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
+
+  mach_port_t mach_thread_port = mach_thread_self();
+  guarantee(mach_thread_port != 0, "just checking");
+  thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,
+              (thread_info_t) &m_ident_info, &count);
+  mach_port_deallocate(mach_task_self(), mach_thread_port);
+
+  _unique_thread_id = m_ident_info.thread_id;
+#endif
+}
+
 void OSThread::pd_destroy() {
   delete _startThread_lock;
 }

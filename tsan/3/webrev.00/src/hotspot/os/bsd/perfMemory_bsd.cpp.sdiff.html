<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/perfMemory_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_perf_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="semaphore_bsd.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/perfMemory_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 574 
 575         // don&#39;t follow symbolic links for the file
 576         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 577         if (result == OS_ERR) {
 578            FREE_C_HEAP_ARRAY(char, filename);
 579            continue;
 580         }
 581 
 582         // skip over files that are not regular files.
 583         if (!S_ISREG(statbuf.st_mode)) {
 584           FREE_C_HEAP_ARRAY(char, filename);
 585           continue;
 586         }
 587 
 588         // compare and save filename with latest creation time
 589         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 590 
 591           if (statbuf.st_ctime &gt; oldest_ctime) {
 592             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 593 
<span class="line-modified"> 594             if (oldest_user != NULL) FREE_C_HEAP_ARRAY(char, oldest_user);</span>
 595             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 596 
 597             strcpy(oldest_user, user);
 598             oldest_ctime = statbuf.st_ctime;
 599           }
 600         }
 601 
 602         FREE_C_HEAP_ARRAY(char, filename);
 603       }
 604     }
 605     os::closedir(subdirp);
 606     FREE_C_HEAP_ARRAY(char, usrdir_name);
 607   }
 608   os::closedir(tmpdirp);
 609 
 610   return(oldest_user);
 611 }
 612 
 613 // return the name of the user that owns the JVM indicated by the given vmid.
 614 //
</pre>
<hr />
<pre>
1011 
1012 // return the size of the file for the given file descriptor
1013 // or 0 if it is not a valid size for a shared memory file
1014 //
1015 static size_t sharedmem_filesize(int fd, TRAPS) {
1016 
1017   struct stat statbuf;
1018   int result;
1019 
1020   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1021   if (result == OS_ERR) {
1022     if (PrintMiscellaneous &amp;&amp; Verbose) {
1023       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1024     }
1025     THROW_MSG_0(vmSymbols::java_io_IOException(),
1026                 &quot;Could not determine PerfMemory size&quot;);
1027   }
1028 
1029   if ((statbuf.st_size == 0) ||
1030      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
<span class="line-modified">1031     THROW_MSG_0(vmSymbols::java_lang_Exception(),</span>
1032                 &quot;Invalid PerfMemory size&quot;);
1033   }
1034 
1035   return (size_t)statbuf.st_size;
1036 }
1037 
1038 // attach to a named shared memory region.
1039 //
1040 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1041 
1042   char* mapAddress;
1043   int result;
1044   int fd;
1045   size_t size = 0;
1046   const char* luser = NULL;
1047 
1048   int mmap_prot;
1049   int file_flags;
1050 
1051   ResourceMark rm;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 574 
 575         // don&#39;t follow symbolic links for the file
 576         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 577         if (result == OS_ERR) {
 578            FREE_C_HEAP_ARRAY(char, filename);
 579            continue;
 580         }
 581 
 582         // skip over files that are not regular files.
 583         if (!S_ISREG(statbuf.st_mode)) {
 584           FREE_C_HEAP_ARRAY(char, filename);
 585           continue;
 586         }
 587 
 588         // compare and save filename with latest creation time
 589         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 590 
 591           if (statbuf.st_ctime &gt; oldest_ctime) {
 592             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 593 
<span class="line-modified"> 594             FREE_C_HEAP_ARRAY(char, oldest_user);</span>
 595             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 596 
 597             strcpy(oldest_user, user);
 598             oldest_ctime = statbuf.st_ctime;
 599           }
 600         }
 601 
 602         FREE_C_HEAP_ARRAY(char, filename);
 603       }
 604     }
 605     os::closedir(subdirp);
 606     FREE_C_HEAP_ARRAY(char, usrdir_name);
 607   }
 608   os::closedir(tmpdirp);
 609 
 610   return(oldest_user);
 611 }
 612 
 613 // return the name of the user that owns the JVM indicated by the given vmid.
 614 //
</pre>
<hr />
<pre>
1011 
1012 // return the size of the file for the given file descriptor
1013 // or 0 if it is not a valid size for a shared memory file
1014 //
1015 static size_t sharedmem_filesize(int fd, TRAPS) {
1016 
1017   struct stat statbuf;
1018   int result;
1019 
1020   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1021   if (result == OS_ERR) {
1022     if (PrintMiscellaneous &amp;&amp; Verbose) {
1023       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1024     }
1025     THROW_MSG_0(vmSymbols::java_io_IOException(),
1026                 &quot;Could not determine PerfMemory size&quot;);
1027   }
1028 
1029   if ((statbuf.st_size == 0) ||
1030      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
<span class="line-modified">1031     THROW_MSG_0(vmSymbols::java_io_IOException(),</span>
1032                 &quot;Invalid PerfMemory size&quot;);
1033   }
1034 
1035   return (size_t)statbuf.st_size;
1036 }
1037 
1038 // attach to a named shared memory region.
1039 //
1040 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1041 
1042   char* mapAddress;
1043   int result;
1044   int fd;
1045   size_t size = 0;
1046   const char* luser = NULL;
1047 
1048   int mmap_prot;
1049   int file_flags;
1050 
1051   ResourceMark rm;
</pre>
</td>
</tr>
</table>
<center><a href="os_perf_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="semaphore_bsd.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
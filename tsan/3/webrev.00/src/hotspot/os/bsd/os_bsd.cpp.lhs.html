<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
<a name="2" id="anc2"></a>
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/filemap.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;os_bsd.inline.hpp&quot;
  40 #include &quot;os_posix.inline.hpp&quot;
  41 #include &quot;os_share_bsd.hpp&quot;
  42 #include &quot;prims/jniFastGetField.hpp&quot;
  43 #include &quot;prims/jvm_misc.hpp&quot;
  44 #include &quot;runtime/arguments.hpp&quot;
  45 #include &quot;runtime/atomic.hpp&quot;
  46 #include &quot;runtime/extendedPC.hpp&quot;
  47 #include &quot;runtime/globals.hpp&quot;
  48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/mutexLocker.hpp&quot;
  52 #include &quot;runtime/objectMonitor.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed">  53 #include &quot;runtime/orderAccess.hpp&quot;</span>
  54 #include &quot;runtime/osThread.hpp&quot;
  55 #include &quot;runtime/perfMemory.hpp&quot;
  56 #include &quot;runtime/semaphore.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadCritical.hpp&quot;
  62 #include &quot;runtime/timer.hpp&quot;
  63 #include &quot;services/attachListener.hpp&quot;
  64 #include &quot;services/memTracker.hpp&quot;
  65 #include &quot;services/runtimeService.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/decoder.hpp&quot;
  68 #include &quot;utilities/defaultStream.hpp&quot;
  69 #include &quot;utilities/events.hpp&quot;
  70 #include &quot;utilities/growableArray.hpp&quot;
  71 #include &quot;utilities/vmError.hpp&quot;
  72 
  73 // put OS-includes here
  74 # include &lt;dlfcn.h&gt;
  75 # include &lt;errno.h&gt;
  76 # include &lt;fcntl.h&gt;
  77 # include &lt;inttypes.h&gt;
  78 # include &lt;poll.h&gt;
  79 # include &lt;pthread.h&gt;
  80 # include &lt;pwd.h&gt;
  81 # include &lt;signal.h&gt;
  82 # include &lt;stdint.h&gt;
  83 # include &lt;stdio.h&gt;
  84 # include &lt;string.h&gt;
  85 # include &lt;sys/ioctl.h&gt;
  86 # include &lt;sys/mman.h&gt;
  87 # include &lt;sys/param.h&gt;
  88 # include &lt;sys/resource.h&gt;
  89 # include &lt;sys/socket.h&gt;
  90 # include &lt;sys/stat.h&gt;
  91 # include &lt;sys/syscall.h&gt;
  92 # include &lt;sys/sysctl.h&gt;
  93 # include &lt;sys/time.h&gt;
  94 # include &lt;sys/times.h&gt;
  95 # include &lt;sys/types.h&gt;
  96 # include &lt;sys/wait.h&gt;
  97 # include &lt;time.h&gt;
  98 # include &lt;unistd.h&gt;
  99 
 100 #if defined(__FreeBSD__) || defined(__NetBSD__)
 101   #include &lt;elf.h&gt;
 102 #endif
 103 
 104 #ifdef __APPLE__
 105   #include &lt;mach-o/dyld.h&gt;
 106 #endif
 107 
 108 #ifndef MAP_ANONYMOUS
 109   #define MAP_ANONYMOUS MAP_ANON
 110 #endif
 111 
 112 #define MAX_PATH    (2 * K)
 113 
 114 // for timer info max values which include all bits
 115 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 116 
 117 ////////////////////////////////////////////////////////////////////////////////
 118 // global variables
 119 julong os::Bsd::_physical_memory = 0;
 120 
 121 #ifdef __APPLE__
 122 mach_timebase_info_data_t os::Bsd::_timebase_info = {0, 0};
 123 volatile uint64_t         os::Bsd::_max_abstime   = 0;
 124 #else
 125 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
 126 #endif
 127 pthread_t os::Bsd::_main_thread;
 128 int os::Bsd::_page_size = -1;
 129 
 130 static jlong initial_time_count=0;
 131 
 132 static int clock_tics_per_sec = 100;
 133 
 134 // For diagnostics to print a message once. see run_periodic_checks
 135 static sigset_t check_signal_done;
 136 static bool check_signals = true;
 137 
<a name="4" id="anc4"></a><span class="line-removed"> 138 static pid_t _initial_pid = 0;</span>
<span class="line-removed"> 139 </span>
 140 // Signal number used to suspend/resume a thread
 141 
 142 // do not use any signal number less than SIGSEGV, see 4355769
 143 static int SR_signum = SIGUSR2;
 144 sigset_t SR_sigset;
 145 
 146 
 147 ////////////////////////////////////////////////////////////////////////////////
 148 // utility functions
 149 
 150 static int SR_initialize();
 151 
 152 julong os::available_memory() {
 153   return Bsd::available_memory();
 154 }
 155 
 156 // available here means free
 157 julong os::Bsd::available_memory() {
 158   uint64_t available = physical_memory() &gt;&gt; 2;
 159 #ifdef __APPLE__
 160   mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;
 161   vm_statistics64_data_t vmstat;
 162   kern_return_t kerr = host_statistics64(mach_host_self(), HOST_VM_INFO64,
 163                                          (host_info64_t)&amp;vmstat, &amp;count);
 164   assert(kerr == KERN_SUCCESS,
 165          &quot;host_statistics64 failed - check mach_host_self() and count&quot;);
 166   if (kerr == KERN_SUCCESS) {
 167     available = vmstat.free_count * os::vm_page_size();
 168   }
 169 #endif
 170   return available;
 171 }
 172 
<a name="5" id="anc5"></a>















 173 julong os::physical_memory() {
 174   return Bsd::physical_memory();
 175 }
 176 
 177 // Return true if user is running as root.
 178 
 179 bool os::have_special_privileges() {
 180   static bool init = false;
 181   static bool privileges = false;
 182   if (!init) {
 183     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 184     init = true;
 185   }
 186   return privileges;
 187 }
 188 
 189 
 190 
 191 // Cpu architecture string
 192 #if   defined(ZERO)
 193 static char cpu_arch[] = ZERO_LIBARCH;
 194 #elif defined(IA64)
 195 static char cpu_arch[] = &quot;ia64&quot;;
 196 #elif defined(IA32)
 197 static char cpu_arch[] = &quot;i386&quot;;
 198 #elif defined(AMD64)
 199 static char cpu_arch[] = &quot;amd64&quot;;
 200 #elif defined(ARM)
 201 static char cpu_arch[] = &quot;arm&quot;;
 202 #elif defined(PPC32)
 203 static char cpu_arch[] = &quot;ppc&quot;;
 204 #elif defined(SPARC)
 205   #ifdef _LP64
 206 static char cpu_arch[] = &quot;sparcv9&quot;;
 207   #else
 208 static char cpu_arch[] = &quot;sparc&quot;;
 209   #endif
 210 #else
 211   #error Add appropriate cpu_arch setting
 212 #endif
 213 
 214 // Compiler variant
 215 #ifdef COMPILER2
 216   #define COMPILER_VARIANT &quot;server&quot;
 217 #else
 218   #define COMPILER_VARIANT &quot;client&quot;
 219 #endif
 220 
 221 
 222 void os::Bsd::initialize_system_info() {
 223   int mib[2];
 224   size_t len;
 225   int cpu_val;
 226   julong mem_val;
 227 
 228   // get processors count via hw.ncpus sysctl
 229   mib[0] = CTL_HW;
 230   mib[1] = HW_NCPU;
 231   len = sizeof(cpu_val);
 232   if (sysctl(mib, 2, &amp;cpu_val, &amp;len, NULL, 0) != -1 &amp;&amp; cpu_val &gt;= 1) {
 233     assert(len == sizeof(cpu_val), &quot;unexpected data size&quot;);
 234     set_processor_count(cpu_val);
 235   } else {
 236     set_processor_count(1);   // fallback
 237   }
 238 
 239   // get physical memory via hw.memsize sysctl (hw.memsize is used
 240   // since it returns a 64 bit value)
 241   mib[0] = CTL_HW;
 242 
 243 #if defined (HW_MEMSIZE) // Apple
 244   mib[1] = HW_MEMSIZE;
 245 #elif defined(HW_PHYSMEM) // Most of BSD
 246   mib[1] = HW_PHYSMEM;
 247 #elif defined(HW_REALMEM) // Old FreeBSD
 248   mib[1] = HW_REALMEM;
 249 #else
 250   #error No ways to get physmem
 251 #endif
 252 
 253   len = sizeof(mem_val);
 254   if (sysctl(mib, 2, &amp;mem_val, &amp;len, NULL, 0) != -1) {
 255     assert(len == sizeof(mem_val), &quot;unexpected data size&quot;);
 256     _physical_memory = mem_val;
 257   } else {
 258     _physical_memory = 256 * 1024 * 1024;       // fallback (XXXBSD?)
 259   }
 260 
 261 #ifdef __OpenBSD__
 262   {
 263     // limit _physical_memory memory view on OpenBSD since
 264     // datasize rlimit restricts us anyway.
 265     struct rlimit limits;
 266     getrlimit(RLIMIT_DATA, &amp;limits);
 267     _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
 268   }
 269 #endif
 270 }
 271 
 272 #ifdef __APPLE__
 273 static const char *get_home() {
 274   const char *home_dir = ::getenv(&quot;HOME&quot;);
 275   if ((home_dir == NULL) || (*home_dir == &#39;\0&#39;)) {
 276     struct passwd *passwd_info = getpwuid(geteuid());
 277     if (passwd_info != NULL) {
 278       home_dir = passwd_info-&gt;pw_dir;
 279     }
 280   }
 281 
 282   return home_dir;
 283 }
 284 #endif
 285 
 286 void os::init_system_properties_values() {
 287   // The next steps are taken in the product version:
 288   //
 289   // Obtain the JAVA_HOME value from the location of libjvm.so.
 290   // This library should be located at:
 291   // &lt;JAVA_HOME&gt;/jre/lib/&lt;arch&gt;/{client|server}/libjvm.so.
 292   //
 293   // If &quot;/jre/lib/&quot; appears at the right place in the path, then we
 294   // assume libjvm.so is installed in a JDK and we use this path.
 295   //
 296   // Otherwise exit with message: &quot;Could not create the Java virtual machine.&quot;
 297   //
 298   // The following extra steps are taken in the debugging version:
 299   //
 300   // If &quot;/jre/lib/&quot; does NOT appear at the right place in the path
 301   // instead of exit check for $JAVA_HOME environment variable.
 302   //
 303   // If it is defined and we are able to locate $JAVA_HOME/jre/lib/&lt;arch&gt;,
 304   // then we append a fake suffix &quot;hotspot/libjvm.so&quot; to this path so
 305   // it looks like libjvm.so is installed there
 306   // &lt;JAVA_HOME&gt;/jre/lib/&lt;arch&gt;/hotspot/libjvm.so.
 307   //
 308   // Otherwise exit.
 309   //
 310   // Important note: if the location of libjvm.so changes this
 311   // code needs to be changed accordingly.
 312 
 313   // See ld(1):
 314   //      The linker uses the following search paths to locate required
 315   //      shared libraries:
 316   //        1: ...
 317   //        ...
 318   //        7: The default directories, normally /lib and /usr/lib.
 319 #ifndef DEFAULT_LIBPATH
 320   #ifndef OVERRIDE_LIBPATH
 321     #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 322   #else
 323     #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 324   #endif
 325 #endif
 326 
 327 // Base path of extensions installed on the system.
 328 #define SYS_EXT_DIR     &quot;/usr/java/packages&quot;
 329 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 330 
 331 #ifndef __APPLE__
 332 
 333   // Buffer that fits several sprintfs.
 334   // Note that the space for the colon and the trailing null are provided
 335   // by the nulls included by the sizeof operator.
 336   const size_t bufsize =
 337     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 338          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<a name="6" id="anc6"></a><span class="line-modified"> 339   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 340 
 341   // sysclasspath, java_home, dll_dir
 342   {
 343     char *pslash;
 344     os::jvm_path(buf, bufsize);
 345 
 346     // Found the full path to libjvm.so.
 347     // Now cut the path to &lt;java_home&gt;/jre if we can.
 348     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 349     pslash = strrchr(buf, &#39;/&#39;);
 350     if (pslash != NULL) {
 351       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 352     }
 353     Arguments::set_dll_dir(buf);
 354 
 355     if (pslash != NULL) {
 356       pslash = strrchr(buf, &#39;/&#39;);
 357       if (pslash != NULL) {
 358         *pslash = &#39;\0&#39;;          // Get rid of /&lt;arch&gt;.
 359         pslash = strrchr(buf, &#39;/&#39;);
 360         if (pslash != NULL) {
 361           *pslash = &#39;\0&#39;;        // Get rid of /lib.
 362         }
 363       }
 364     }
 365     Arguments::set_java_home(buf);
 366     if (!set_boot_path(&#39;/&#39;, &#39;:&#39;)) {
 367       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 368     }
 369   }
 370 
 371   // Where to look for native libraries.
 372   //
 373   // Note: Due to a legacy implementation, most of the library path
 374   // is set in the launcher. This was to accomodate linking restrictions
 375   // on legacy Bsd implementations (which are no longer supported).
 376   // Eventually, all the library path setting will be done here.
 377   //
 378   // However, to prevent the proliferation of improperly built native
 379   // libraries, the new path component /usr/java/packages is added here.
 380   // Eventually, all the library path setting will be done here.
 381   {
 382     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 383     // should always exist (until the legacy problem cited above is
 384     // addressed).
 385     const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
 386     const char *v_colon = &quot;:&quot;;
 387     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 388     // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<a name="7" id="anc7"></a><span class="line-modified"> 389     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 390                                                      strlen(v) + 1 +</span>
<span class="line-modified"> 391                                                      sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified"> 392                                                      mtInternal);</span>
 393     sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib/%s:&quot; DEFAULT_LIBPATH, v, v_colon, cpu_arch);
 394     Arguments::set_library_path(ld_library_path);
 395     FREE_C_HEAP_ARRAY(char, ld_library_path);
 396   }
 397 
 398   // Extensions directories.
 399   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());
 400   Arguments::set_ext_dirs(buf);
 401 
 402   FREE_C_HEAP_ARRAY(char, buf);
 403 
 404 #else // __APPLE__
 405 
 406   #define SYS_EXTENSIONS_DIR   &quot;/Library/Java/Extensions&quot;
 407   #define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR &quot;:/Network&quot; SYS_EXTENSIONS_DIR &quot;:/System&quot; SYS_EXTENSIONS_DIR &quot;:/usr/lib/java&quot;
 408 
 409   const char *user_home_dir = get_home();
 410   // The null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir.
 411   size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +
 412     sizeof(SYS_EXTENSIONS_DIRS);
 413 
 414   // Buffer that fits several sprintfs.
 415   // Note that the space for the colon and the trailing null are provided
 416   // by the nulls included by the sizeof operator.
 417   const size_t bufsize =
 418     MAX2((size_t)MAXPATHLEN,  // for dll_dir &amp; friends.
 419          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
<a name="8" id="anc8"></a><span class="line-modified"> 420   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 421 
 422   // sysclasspath, java_home, dll_dir
 423   {
 424     char *pslash;
 425     os::jvm_path(buf, bufsize);
 426 
 427     // Found the full path to libjvm.so.
 428     // Now cut the path to &lt;java_home&gt;/jre if we can.
 429     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 430     pslash = strrchr(buf, &#39;/&#39;);
 431     if (pslash != NULL) {
 432       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 433     }
 434 #ifdef STATIC_BUILD
 435     strcat(buf, &quot;/lib&quot;);
 436 #endif
 437 
 438     Arguments::set_dll_dir(buf);
 439 
 440     if (pslash != NULL) {
 441       pslash = strrchr(buf, &#39;/&#39;);
 442       if (pslash != NULL) {
 443         *pslash = &#39;\0&#39;;          // Get rid of /lib.
 444       }
 445     }
 446     Arguments::set_java_home(buf);
 447     set_boot_path(&#39;/&#39;, &#39;:&#39;);
 448   }
 449 
 450   // Where to look for native libraries.
 451   //
 452   // Note: Due to a legacy implementation, most of the library path
 453   // is set in the launcher. This was to accomodate linking restrictions
 454   // on legacy Bsd implementations (which are no longer supported).
 455   // Eventually, all the library path setting will be done here.
 456   //
 457   // However, to prevent the proliferation of improperly built native
 458   // libraries, the new path component /usr/java/packages is added here.
 459   // Eventually, all the library path setting will be done here.
 460   {
 461     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 462     // should always exist (until the legacy problem cited above is
 463     // addressed).
 464     // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code
 465     // can specify a directory inside an app wrapper
 466     const char *l = ::getenv(&quot;JAVA_LIBRARY_PATH&quot;);
 467     const char *l_colon = &quot;:&quot;;
 468     if (l == NULL) { l = &quot;&quot;; l_colon = &quot;&quot;; }
 469 
 470     const char *v = ::getenv(&quot;DYLD_LIBRARY_PATH&quot;);
 471     const char *v_colon = &quot;:&quot;;
 472     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 473 
 474     // Apple&#39;s Java6 has &quot;.&quot; at the beginning of java.library.path.
 475     // OpenJDK on Windows has &quot;.&quot; at the end of java.library.path.
 476     // OpenJDK on Linux and Solaris don&#39;t have &quot;.&quot; in java.library.path
 477     // at all. To ease the transition from Apple&#39;s Java6 to OpenJDK7,
 478     // &quot;.&quot; is appended to the end of java.library.path. Yes, this
 479     // could cause a change in behavior, but Apple&#39;s Java6 behavior
 480     // can be achieved by putting &quot;.&quot; at the beginning of the
 481     // JAVA_LIBRARY_PATH environment variable.
<a name="9" id="anc9"></a><span class="line-modified"> 482     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 483                                                      strlen(v) + 1 + strlen(l) + 1 +</span>
<span class="line-modified"> 484                                                      system_ext_size + 3,</span>
<span class="line-modified"> 485                                                      mtInternal);</span>
 486     sprintf(ld_library_path, &quot;%s%s%s%s%s&quot; SYS_EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS &quot;:.&quot;,
 487             v, v_colon, l, l_colon, user_home_dir);
 488     Arguments::set_library_path(ld_library_path);
 489     FREE_C_HEAP_ARRAY(char, ld_library_path);
 490   }
 491 
 492   // Extensions directories.
 493   //
 494   // Note that the space for the colon and the trailing null are provided
 495   // by the nulls included by the sizeof operator (so actually one byte more
 496   // than necessary is allocated).
 497   sprintf(buf, &quot;%s&quot; SYS_EXTENSIONS_DIR &quot;:%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS,
 498           user_home_dir, Arguments::get_java_home());
 499   Arguments::set_ext_dirs(buf);
 500 
 501   FREE_C_HEAP_ARRAY(char, buf);
 502 
 503 #undef SYS_EXTENSIONS_DIR
 504 #undef SYS_EXTENSIONS_DIRS
 505 
 506 #endif // __APPLE__
 507 
 508 #undef SYS_EXT_DIR
 509 #undef EXTENSIONS_DIR
 510 }
 511 
 512 ////////////////////////////////////////////////////////////////////////////////
 513 // breakpoint support
 514 
 515 void os::breakpoint() {
 516   BREAKPOINT;
 517 }
 518 
 519 extern &quot;C&quot; void breakpoint() {
 520   // use debugger to set breakpoint here
 521 }
 522 
 523 ////////////////////////////////////////////////////////////////////////////////
 524 // signal support
 525 
 526 debug_only(static bool signal_sets_initialized = false);
 527 static sigset_t unblocked_sigs, vm_sigs;
 528 
 529 void os::Bsd::signal_sets_init() {
 530   // Should also have an assertion stating we are still single-threaded.
 531   assert(!signal_sets_initialized, &quot;Already initialized&quot;);
 532   // Fill in signals that are necessarily unblocked for all threads in
 533   // the VM. Currently, we unblock the following signals:
 534   // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden
 535   //                         by -Xrs (=ReduceSignalUsage));
 536   // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all
 537   // other threads. The &quot;ReduceSignalUsage&quot; boolean tells us not to alter
 538   // the dispositions or masks wrt these signals.
 539   // Programs embedding the VM that want to use the above signals for their
 540   // own purposes must, at this time, use the &quot;-Xrs&quot; option to prevent
 541   // interference with shutdown hooks and BREAK_SIGNAL thread dumping.
 542   // (See bug 4345157, and other related bugs).
 543   // In reality, though, unblocking these signals is really a nop, since
 544   // these signals are not blocked by default.
 545   sigemptyset(&amp;unblocked_sigs);
 546   sigaddset(&amp;unblocked_sigs, SIGILL);
 547   sigaddset(&amp;unblocked_sigs, SIGSEGV);
 548   sigaddset(&amp;unblocked_sigs, SIGBUS);
 549   sigaddset(&amp;unblocked_sigs, SIGFPE);
 550   sigaddset(&amp;unblocked_sigs, SR_signum);
 551 
 552   if (!ReduceSignalUsage) {
 553     if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {
 554       sigaddset(&amp;unblocked_sigs, SHUTDOWN1_SIGNAL);
 555 
 556     }
 557     if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {
 558       sigaddset(&amp;unblocked_sigs, SHUTDOWN2_SIGNAL);
 559     }
 560     if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {
 561       sigaddset(&amp;unblocked_sigs, SHUTDOWN3_SIGNAL);
 562     }
 563   }
 564   // Fill in signals that are blocked by all but the VM thread.
 565   sigemptyset(&amp;vm_sigs);
 566   if (!ReduceSignalUsage) {
 567     sigaddset(&amp;vm_sigs, BREAK_SIGNAL);
 568   }
 569   debug_only(signal_sets_initialized = true);
 570 
 571 }
 572 
 573 // These are signals that are unblocked while a thread is running Java.
 574 // (For some reason, they get blocked by default.)
 575 sigset_t* os::Bsd::unblocked_signals() {
 576   assert(signal_sets_initialized, &quot;Not initialized&quot;);
 577   return &amp;unblocked_sigs;
 578 }
 579 
 580 // These are the signals that are blocked while a (non-VM) thread is
 581 // running Java. Only the VM thread handles these signals.
 582 sigset_t* os::Bsd::vm_signals() {
 583   assert(signal_sets_initialized, &quot;Not initialized&quot;);
 584   return &amp;vm_sigs;
 585 }
 586 
 587 void os::Bsd::hotspot_sigmask(Thread* thread) {
 588 
 589   //Save caller&#39;s signal mask before setting VM signal mask
 590   sigset_t caller_sigmask;
 591   pthread_sigmask(SIG_BLOCK, NULL, &amp;caller_sigmask);
 592 
 593   OSThread* osthread = thread-&gt;osthread();
 594   osthread-&gt;set_caller_sigmask(caller_sigmask);
 595 
 596   pthread_sigmask(SIG_UNBLOCK, os::Bsd::unblocked_signals(), NULL);
 597 
 598   if (!ReduceSignalUsage) {
 599     if (thread-&gt;is_VM_thread()) {
 600       // Only the VM thread handles BREAK_SIGNAL ...
 601       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 602     } else {
 603       // ... all other threads block BREAK_SIGNAL
 604       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 605     }
 606   }
 607 }
 608 
 609 
 610 //////////////////////////////////////////////////////////////////////////////
 611 // create new thread
 612 
 613 #ifdef __APPLE__
 614 // library handle for calling objc_registerThreadWithCollector()
 615 // without static linking to the libobjc library
 616   #define OBJC_LIB &quot;/usr/lib/libobjc.dylib&quot;
 617   #define OBJC_GCREGISTER &quot;objc_registerThreadWithCollector&quot;
 618 typedef void (*objc_registerThreadWithCollector_t)();
 619 extern &quot;C&quot; objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;
 620 objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;
 621 #endif
 622 
<a name="10" id="anc10"></a><span class="line-removed"> 623 #ifdef __APPLE__</span>
<span class="line-removed"> 624 static uint64_t locate_unique_thread_id(mach_port_t mach_thread_port) {</span>
<span class="line-removed"> 625   // Additional thread_id used to correlate threads in SA</span>
<span class="line-removed"> 626   thread_identifier_info_data_t     m_ident_info;</span>
<span class="line-removed"> 627   mach_msg_type_number_t            count = THREAD_IDENTIFIER_INFO_COUNT;</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629   thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,</span>
<span class="line-removed"> 630               (thread_info_t) &amp;m_ident_info, &amp;count);</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632   return m_ident_info.thread_id;</span>
<span class="line-removed"> 633 }</span>
<span class="line-removed"> 634 #endif</span>
<span class="line-removed"> 635 </span>
 636 // Thread start routine for all newly created threads
 637 static void *thread_native_entry(Thread *thread) {
 638 
 639   thread-&gt;record_stack_base_and_size();
 640 
 641   // Try to randomize the cache line index of hot stack frames.
 642   // This helps when threads of the same stack traces evict each other&#39;s
 643   // cache lines. The threads can be either from the same JVM instance, or
 644   // from different JVM instances. The benefit is especially true for
 645   // processors with hyperthreading technology.
 646   static int counter = 0;
 647   int pid = os::current_process_id();
 648   alloca(((pid ^ counter++) &amp; 7) * 128);
 649 
 650   thread-&gt;initialize_thread_current();
 651 
 652   OSThread* osthread = thread-&gt;osthread();
 653   Monitor* sync = osthread-&gt;startThread_lock();
 654 
 655   osthread-&gt;set_thread_id(os::Bsd::gettid());
 656 
 657   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 658     os::current_thread_id(), (uintx) pthread_self());
 659 
 660 #ifdef __APPLE__
<a name="11" id="anc11"></a><span class="line-modified"> 661   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified"> 662   guarantee(unique_thread_id != 0, &quot;unique thread id was not found&quot;);</span>
<span class="line-removed"> 663   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
 664 #endif
<a name="12" id="anc12"></a>
 665   // initialize signal mask for this thread
 666   os::Bsd::hotspot_sigmask(thread);
 667 
 668   // initialize floating point control register
 669   os::Bsd::init_thread_fpu_state();
 670 
 671 #ifdef __APPLE__
 672   // register thread with objc gc
 673   if (objc_registerThreadWithCollectorFunction != NULL) {
 674     objc_registerThreadWithCollectorFunction();
 675   }
 676 #endif
 677 
 678   // handshaking with parent thread
 679   {
<a name="13" id="anc13"></a><span class="line-modified"> 680     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);</span>
 681 
 682     // notify parent thread
 683     osthread-&gt;set_state(INITIALIZED);
 684     sync-&gt;notify_all();
 685 
 686     // wait until os::start_thread()
 687     while (osthread-&gt;get_state() == INITIALIZED) {
<a name="14" id="anc14"></a><span class="line-modified"> 688       sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 689     }
 690   }
 691 
 692   // call one more level start routine
 693   thread-&gt;call_run();
 694 
 695   // Note: at this point the thread object may already have deleted itself.
 696   // Prevent dereferencing it from here on out.
 697   thread = NULL;
 698 
 699   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 700     os::current_thread_id(), (uintx) pthread_self());
 701 
 702   return 0;
 703 }
 704 
 705 bool os::create_thread(Thread* thread, ThreadType thr_type,
 706                        size_t req_stack_size) {
 707   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 708 
 709   // Allocate the OSThread object
 710   OSThread* osthread = new OSThread(NULL, NULL);
 711   if (osthread == NULL) {
 712     return false;
 713   }
 714 
 715   // set the correct thread state
 716   osthread-&gt;set_thread_type(thr_type);
 717 
 718   // Initial state is ALLOCATED but not INITIALIZED
 719   osthread-&gt;set_state(ALLOCATED);
 720 
 721   thread-&gt;set_osthread(osthread);
 722 
 723   // init thread attributes
 724   pthread_attr_t attr;
 725   pthread_attr_init(&amp;attr);
 726   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
 727 
 728   // calculate stack size if it&#39;s not specified by caller
 729   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
 730   int status = pthread_attr_setstacksize(&amp;attr, stack_size);
 731   assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
 732 
 733   ThreadState state;
 734 
 735   {
 736     pthread_t tid;
 737     int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 738 
 739     char buf[64];
 740     if (ret == 0) {
 741       log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 742         (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 743     } else {
 744       log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
 745         os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<a name="15" id="anc15"></a>




 746     }
 747 
 748     pthread_attr_destroy(&amp;attr);
 749 
 750     if (ret != 0) {
 751       // Need to clean up stuff we&#39;ve allocated so far
 752       thread-&gt;set_osthread(NULL);
 753       delete osthread;
 754       return false;
 755     }
 756 
 757     // Store pthread info into the OSThread
 758     osthread-&gt;set_pthread_id(tid);
 759 
 760     // Wait until child thread is either initialized or aborted
 761     {
 762       Monitor* sync_with_child = osthread-&gt;startThread_lock();
<a name="16" id="anc16"></a><span class="line-modified"> 763       MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 764       while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<a name="17" id="anc17"></a><span class="line-modified"> 765         sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 766       }
 767     }
 768 
 769   }
 770 
 771   // Aborted due to thread limit being reached
 772   if (state == ZOMBIE) {
 773     thread-&gt;set_osthread(NULL);
 774     delete osthread;
 775     return false;
 776   }
 777 
 778   // The thread is returned suspended (in state INITIALIZED),
 779   // and is started higher up in the call chain
 780   assert(state == INITIALIZED, &quot;race condition&quot;);
 781   return true;
 782 }
 783 
 784 /////////////////////////////////////////////////////////////////////////////
 785 // attach existing thread
 786 
 787 // bootstrap the main thread
 788 bool os::create_main_thread(JavaThread* thread) {
 789   assert(os::Bsd::_main_thread == pthread_self(), &quot;should be called inside main thread&quot;);
 790   return create_attached_thread(thread);
 791 }
 792 
 793 bool os::create_attached_thread(JavaThread* thread) {
 794 #ifdef ASSERT
 795   thread-&gt;verify_not_published();
 796 #endif
 797 
 798   // Allocate the OSThread object
 799   OSThread* osthread = new OSThread(NULL, NULL);
 800 
 801   if (osthread == NULL) {
 802     return false;
 803   }
 804 
 805   osthread-&gt;set_thread_id(os::Bsd::gettid());
 806 
<a name="18" id="anc18"></a><span class="line-removed"> 807   // Store pthread info into the OSThread</span>
 808 #ifdef __APPLE__
<a name="19" id="anc19"></a><span class="line-modified"> 809   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified"> 810   guarantee(unique_thread_id != 0, &quot;just checking&quot;);</span>
<span class="line-removed"> 811   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
 812 #endif
<a name="20" id="anc20"></a>

 813   osthread-&gt;set_pthread_id(::pthread_self());
 814 
 815   // initialize floating point control register
 816   os::Bsd::init_thread_fpu_state();
 817 
 818   // Initial thread state is RUNNABLE
 819   osthread-&gt;set_state(RUNNABLE);
 820 
 821   thread-&gt;set_osthread(osthread);
 822 
 823   // initialize signal mask for this thread
 824   // and save the caller&#39;s signal mask
 825   os::Bsd::hotspot_sigmask(thread);
 826 
 827   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 828     os::current_thread_id(), (uintx) pthread_self());
 829 
 830   return true;
 831 }
 832 
 833 void os::pd_start_thread(Thread* thread) {
 834   OSThread * osthread = thread-&gt;osthread();
 835   assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
 836   Monitor* sync_with_child = osthread-&gt;startThread_lock();
<a name="21" id="anc21"></a><span class="line-modified"> 837   MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 838   sync_with_child-&gt;notify();
 839 }
 840 
 841 // Free Bsd resources related to the OSThread
 842 void os::free_thread(OSThread* osthread) {
 843   assert(osthread != NULL, &quot;osthread not set&quot;);
 844 
 845   // We are told to free resources of the argument thread,
 846   // but we can only really operate on the current thread.
 847   assert(Thread::current()-&gt;osthread() == osthread,
 848          &quot;os::free_thread but not current thread&quot;);
 849 
 850   // Restore caller&#39;s signal mask
 851   sigset_t sigmask = osthread-&gt;caller_sigmask();
 852   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
 853 
 854   delete osthread;
 855 }
 856 
 857 ////////////////////////////////////////////////////////////////////////////////
 858 // time support
 859 
 860 // Time since start-up in seconds to a fine granularity.
 861 // Used by VMSelfDestructTimer and the MemProfiler.
 862 double os::elapsedTime() {
 863 
 864   return ((double)os::elapsed_counter()) / os::elapsed_frequency();
 865 }
 866 
 867 jlong os::elapsed_counter() {
 868   return javaTimeNanos() - initial_time_count;
 869 }
 870 
 871 jlong os::elapsed_frequency() {
 872   return NANOSECS_PER_SEC; // nanosecond resolution
 873 }
 874 
 875 bool os::supports_vtime() { return true; }
<a name="22" id="anc22"></a><span class="line-removed"> 876 bool os::enable_vtime()   { return false; }</span>
<span class="line-removed"> 877 bool os::vtime_enabled()  { return false; }</span>
 878 
 879 double os::elapsedVTime() {
 880   // better than nothing, but not much
 881   return elapsedTime();
 882 }
 883 
 884 jlong os::javaTimeMillis() {
 885   timeval time;
 886   int status = gettimeofday(&amp;time, NULL);
 887   assert(status != -1, &quot;bsd error&quot;);
 888   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
 889 }
 890 
 891 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 892   timeval time;
 893   int status = gettimeofday(&amp;time, NULL);
 894   assert(status != -1, &quot;bsd error&quot;);
 895   seconds = jlong(time.tv_sec);
 896   nanos = jlong(time.tv_usec) * 1000;
 897 }
 898 
 899 #ifndef __APPLE__
 900   #ifndef CLOCK_MONOTONIC
 901     #define CLOCK_MONOTONIC (1)
 902   #endif
 903 #endif
 904 
 905 #ifdef __APPLE__
 906 void os::Bsd::clock_init() {
 907   mach_timebase_info(&amp;_timebase_info);
 908 }
 909 #else
 910 void os::Bsd::clock_init() {
 911   struct timespec res;
 912   struct timespec tp;
 913   if (::clock_getres(CLOCK_MONOTONIC, &amp;res) == 0 &amp;&amp;
 914       ::clock_gettime(CLOCK_MONOTONIC, &amp;tp)  == 0) {
 915     // yes, monotonic clock is supported
 916     _clock_gettime = ::clock_gettime;
 917   }
 918 }
 919 #endif
 920 
 921 
 922 
 923 #ifdef __APPLE__
 924 
 925 jlong os::javaTimeNanos() {
 926   const uint64_t tm = mach_absolute_time();
 927   const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
 928   const uint64_t prev = Bsd::_max_abstime;
 929   if (now &lt;= prev) {
 930     return prev;   // same or retrograde time;
 931   }
<a name="23" id="anc23"></a><span class="line-modified"> 932   const uint64_t obsv = Atomic::cmpxchg(now, &amp;Bsd::_max_abstime, prev);</span>
 933   assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
 934   // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
 935   // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
 936   // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
 937   // some other thread raced this thread and installed a new value, in which case
 938   // we could either (a) retry the entire operation, (b) retry trying to install now
 939   // or (c) just return obsv.  We use (c).   No loop is required although in some cases
 940   // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
 941   // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
 942   // to (a) or (b) -- and greatly reduces coherence traffic.
 943   // We might also condition (c) on the magnitude of the delta between obsv and now.
 944   // Avoiding excessive CAS operations to hot RW locations is critical.
 945   // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
 946   return (prev == obsv) ? now : obsv;
 947 }
 948 
 949 #else // __APPLE__
 950 
 951 jlong os::javaTimeNanos() {
 952   if (os::supports_monotonic_clock()) {
 953     struct timespec tp;
 954     int status = Bsd::_clock_gettime(CLOCK_MONOTONIC, &amp;tp);
 955     assert(status == 0, &quot;gettime error&quot;);
 956     jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);
 957     return result;
 958   } else {
 959     timeval time;
 960     int status = gettimeofday(&amp;time, NULL);
 961     assert(status != -1, &quot;bsd error&quot;);
 962     jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);
 963     return 1000 * usecs;
 964   }
 965 }
 966 
 967 #endif // __APPLE__
 968 
 969 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 970   if (os::supports_monotonic_clock()) {
 971     info_ptr-&gt;max_value = ALL_64_BITS;
 972 
 973     // CLOCK_MONOTONIC - amount of time since some arbitrary point in the past
 974     info_ptr-&gt;may_skip_backward = false;      // not subject to resetting or drifting
 975     info_ptr-&gt;may_skip_forward = false;       // not subject to resetting or drifting
 976   } else {
 977     // gettimeofday - based on time in seconds since the Epoch thus does not wrap
 978     info_ptr-&gt;max_value = ALL_64_BITS;
 979 
 980     // gettimeofday is a real time clock so it skips
 981     info_ptr-&gt;may_skip_backward = true;
 982     info_ptr-&gt;may_skip_forward = true;
 983   }
 984 
 985   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 986 }
 987 
 988 // Return the real, user, and system times in seconds from an
 989 // arbitrary fixed point in the past.
 990 bool os::getTimesSecs(double* process_real_time,
 991                       double* process_user_time,
 992                       double* process_system_time) {
 993   struct tms ticks;
 994   clock_t real_ticks = times(&amp;ticks);
 995 
 996   if (real_ticks == (clock_t) (-1)) {
 997     return false;
 998   } else {
 999     double ticks_per_second = (double) clock_tics_per_sec;
1000     *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;
1001     *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;
1002     *process_real_time = ((double) real_ticks) / ticks_per_second;
1003 
1004     return true;
1005   }
1006 }
1007 
1008 
1009 char * os::local_time_string(char *buf, size_t buflen) {
1010   struct tm t;
1011   time_t long_time;
1012   time(&amp;long_time);
1013   localtime_r(&amp;long_time, &amp;t);
1014   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
1015                t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,
1016                t.tm_hour, t.tm_min, t.tm_sec);
1017   return buf;
1018 }
1019 
1020 struct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {
1021   return localtime_r(clock, res);
1022 }
1023 
1024 ////////////////////////////////////////////////////////////////////////////////
1025 // runtime exit support
1026 
1027 // Note: os::shutdown() might be called very early during initialization, or
1028 // called from signal handler. Before adding something to os::shutdown(), make
1029 // sure it is async-safe and can handle partially initialized VM.
1030 void os::shutdown() {
1031 
1032   // allow PerfMemory to attempt cleanup of any persistent resources
1033   perfMemory_exit();
1034 
1035   // needs to remove object in file system
1036   AttachListener::abort();
1037 
1038   // flush buffered output, finish log files
1039   ostream_abort();
1040 
1041   // Check for abort hook
1042   abort_hook_t abort_hook = Arguments::abort_hook();
1043   if (abort_hook != NULL) {
1044     abort_hook();
1045   }
1046 
1047 }
1048 
1049 // Note: os::abort() might be called very early during initialization, or
1050 // called from signal handler. Before adding something to os::abort(), make
1051 // sure it is async-safe and can handle partially initialized VM.
1052 void os::abort(bool dump_core, void* siginfo, const void* context) {
1053   os::shutdown();
1054   if (dump_core) {
1055 #ifndef PRODUCT
1056     fdStream out(defaultStream::output_fd());
1057     out.print_raw(&quot;Current thread is &quot;);
1058     char buf[16];
1059     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1060     out.print_raw_cr(buf);
1061     out.print_raw_cr(&quot;Dumping core ...&quot;);
1062 #endif
1063     ::abort(); // dump core
1064   }
1065 
1066   ::exit(1);
1067 }
1068 
1069 // Die immediately, no exit hook, no abort hook, no cleanup.
<a name="24" id="anc24"></a>
1070 void os::die() {
<a name="25" id="anc25"></a><span class="line-modified">1071   // _exit() on BsdThreads only kills current thread</span>
<span class="line-modified">1072   ::abort();</span>






1073 }
1074 
1075 // Information of current thread in variety of formats
1076 pid_t os::Bsd::gettid() {
1077   int retval = -1;
1078 
<a name="26" id="anc26"></a><span class="line-modified">1079 #ifdef __APPLE__ //XNU kernel</span>
<span class="line-modified">1080   // despite the fact mach port is actually not a thread id use it</span>
<span class="line-modified">1081   // instead of syscall(SYS_thread_selfid) as it certainly fits to u4</span>
<span class="line-modified">1082   retval = ::pthread_mach_thread_np(::pthread_self());</span>
<span class="line-modified">1083   guarantee(retval != 0, &quot;just checking&quot;);</span>
<span class="line-removed">1084   return retval;</span>
1085 
1086 #else
1087   #ifdef __FreeBSD__
1088   retval = syscall(SYS_thr_self);
1089   #else
1090     #ifdef __OpenBSD__
1091   retval = syscall(SYS_getthrid);
1092     #else
1093       #ifdef __NetBSD__
1094   retval = (pid_t) syscall(SYS__lwp_self);
1095       #endif
1096     #endif
1097   #endif
1098 #endif
1099 
1100   if (retval == -1) {
1101     return getpid();
1102   }
1103 }
1104 
1105 intx os::current_thread_id() {
1106 #ifdef __APPLE__
<a name="27" id="anc27"></a><span class="line-modified">1107   return (intx)::pthread_mach_thread_np(::pthread_self());</span>
1108 #else
1109   return (intx)::pthread_self();
1110 #endif
1111 }
1112 
1113 int os::current_process_id() {
<a name="28" id="anc28"></a><span class="line-modified">1114 </span>
<span class="line-removed">1115   // Under the old bsd thread library, bsd gives each thread</span>
<span class="line-removed">1116   // its own process id. Because of this each thread will return</span>
<span class="line-removed">1117   // a different pid if this method were to return the result</span>
<span class="line-removed">1118   // of getpid(2). Bsd provides no api that returns the pid</span>
<span class="line-removed">1119   // of the launcher thread for the vm. This implementation</span>
<span class="line-removed">1120   // returns a unique pid, the pid of the launcher thread</span>
<span class="line-removed">1121   // that starts the vm &#39;process&#39;.</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123   // Under the NPTL, getpid() returns the same pid as the</span>
<span class="line-removed">1124   // launcher thread rather than a unique pid per thread.</span>
<span class="line-removed">1125   // Use gettid() if you want the old pre NPTL behaviour.</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127   // if you are looking for the result of a call to getpid() that</span>
<span class="line-removed">1128   // returns a unique pid for the calling thread, then look at the</span>
<span class="line-removed">1129   // OSThread::thread_id() method in osThread_bsd.hpp file</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131   return (int)(_initial_pid ? _initial_pid : getpid());</span>
1132 }
1133 
1134 // DLL functions
1135 
1136 const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
1137 
1138 // This must be hard coded because it&#39;s the system&#39;s temporary
1139 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1140 #ifdef __APPLE__
1141 // macosx has a secure per-user temporary directory
1142 char temp_path_storage[PATH_MAX];
1143 const char* os::get_temp_directory() {
1144   static char *temp_path = NULL;
1145   if (temp_path == NULL) {
1146     int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);
1147     if (pathSize == 0 || pathSize &gt; PATH_MAX) {
1148       strlcpy(temp_path_storage, &quot;/tmp/&quot;, sizeof(temp_path_storage));
1149     }
1150     temp_path = temp_path_storage;
1151   }
1152   return temp_path;
1153 }
1154 #else // __APPLE__
1155 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1156 #endif // __APPLE__
1157 
1158 // check if addr is inside libjvm.so
1159 bool os::address_is_in_vm(address addr) {
1160   static address libjvm_base_addr;
1161   Dl_info dlinfo;
1162 
1163   if (libjvm_base_addr == NULL) {
1164     if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &amp;dlinfo) != 0) {
1165       libjvm_base_addr = (address)dlinfo.dli_fbase;
1166     }
1167     assert(libjvm_base_addr !=NULL, &quot;Cannot obtain base address for libjvm&quot;);
1168   }
1169 
1170   if (dladdr((void *)addr, &amp;dlinfo) != 0) {
1171     if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;
1172   }
1173 
1174   return false;
1175 }
1176 
1177 
1178 #define MACH_MAXSYMLEN 256
1179 
1180 bool os::dll_address_to_function_name(address addr, char *buf,
1181                                       int buflen, int *offset,
1182                                       bool demangle) {
1183   // buf is not optional, but offset is optional
1184   assert(buf != NULL, &quot;sanity check&quot;);
1185 
1186   Dl_info dlinfo;
1187   char localbuf[MACH_MAXSYMLEN];
1188 
1189   if (dladdr((void*)addr, &amp;dlinfo) != 0) {
1190     // see if we have a matching symbol
1191     if (dlinfo.dli_saddr != NULL &amp;&amp; dlinfo.dli_sname != NULL) {
1192       if (!(demangle &amp;&amp; Decoder::demangle(dlinfo.dli_sname, buf, buflen))) {
1193         jio_snprintf(buf, buflen, &quot;%s&quot;, dlinfo.dli_sname);
1194       }
1195       if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;
1196       return true;
1197     }
1198     // no matching symbol so try for just file info
1199     if (dlinfo.dli_fname != NULL &amp;&amp; dlinfo.dli_fbase != NULL) {
1200       if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),
1201                           buf, buflen, offset, dlinfo.dli_fname, demangle)) {
1202         return true;
1203       }
1204     }
1205 
1206     // Handle non-dynamic manually:
1207     if (dlinfo.dli_fbase != NULL &amp;&amp;
1208         Decoder::decode(addr, localbuf, MACH_MAXSYMLEN, offset,
1209                         dlinfo.dli_fbase)) {
1210       if (!(demangle &amp;&amp; Decoder::demangle(localbuf, buf, buflen))) {
1211         jio_snprintf(buf, buflen, &quot;%s&quot;, localbuf);
1212       }
1213       return true;
1214     }
1215   }
1216   buf[0] = &#39;\0&#39;;
1217   if (offset != NULL) *offset = -1;
1218   return false;
1219 }
1220 
1221 // ported from solaris version
1222 bool os::dll_address_to_library_name(address addr, char* buf,
1223                                      int buflen, int* offset) {
1224   // buf is not optional, but offset is optional
1225   assert(buf != NULL, &quot;sanity check&quot;);
1226 
1227   Dl_info dlinfo;
1228 
1229   if (dladdr((void*)addr, &amp;dlinfo) != 0) {
1230     if (dlinfo.dli_fname != NULL) {
1231       jio_snprintf(buf, buflen, &quot;%s&quot;, dlinfo.dli_fname);
1232     }
1233     if (dlinfo.dli_fbase != NULL &amp;&amp; offset != NULL) {
1234       *offset = addr - (address)dlinfo.dli_fbase;
1235     }
1236     return true;
1237   }
1238 
1239   buf[0] = &#39;\0&#39;;
1240   if (offset) *offset = -1;
1241   return false;
1242 }
1243 
1244 // Loads .dll/.so and
1245 // in case of error it checks if .dll/.so was built for the
1246 // same architecture as Hotspot is running on
1247 
1248 #ifdef __APPLE__
1249 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1250 #ifdef STATIC_BUILD
1251   return os::get_default_process_handle();
1252 #else
<a name="29" id="anc29"></a>

1253   void * result= ::dlopen(filename, RTLD_LAZY);
1254   if (result != NULL) {
<a name="30" id="anc30"></a>
1255     // Successful loading
<a name="31" id="anc31"></a>
1256     return result;
1257   }
1258 
<a name="32" id="anc32"></a><span class="line-modified">1259   // Read system error message into ebuf</span>
<span class="line-modified">1260   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">1261   ebuf[ebuflen-1]=&#39;\0&#39;;</span>








1262 
1263   return NULL;
1264 #endif // STATIC_BUILD
1265 }
1266 #else
1267 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1268 #ifdef STATIC_BUILD
1269   return os::get_default_process_handle();
1270 #else
<a name="33" id="anc33"></a>
1271   void * result= ::dlopen(filename, RTLD_LAZY);
1272   if (result != NULL) {
<a name="34" id="anc34"></a>
1273     // Successful loading
<a name="35" id="anc35"></a>
1274     return result;
1275   }
1276 
1277   Elf32_Ehdr elf_head;
1278 
<a name="36" id="anc36"></a><span class="line-modified">1279   // Read system error message into ebuf</span>
<span class="line-modified">1280   // It may or may not be overwritten below</span>
<span class="line-modified">1281   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">1282   ebuf[ebuflen-1]=&#39;\0&#39;;</span>








1283   int diag_msg_max_length=ebuflen-strlen(ebuf);
1284   char* diag_msg_buf=ebuf+strlen(ebuf);
1285 
1286   if (diag_msg_max_length==0) {
1287     // No more space in ebuf for additional diagnostics message
1288     return NULL;
1289   }
1290 
1291 
1292   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1293 
1294   if (file_descriptor &lt; 0) {
1295     // Can&#39;t open library, report dlerror() message
1296     return NULL;
1297   }
1298 
1299   bool failed_to_read_elf_head=
1300     (sizeof(elf_head)!=
1301      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1302 
1303   ::close(file_descriptor);
1304   if (failed_to_read_elf_head) {
1305     // file i/o error - report dlerror() msg
1306     return NULL;
1307   }
1308 
1309   typedef struct {
1310     Elf32_Half  code;         // Actual value as defined in elf.h
1311     Elf32_Half  compat_class; // Compatibility of archs at VM&#39;s sense
1312     char        elf_class;    // 32 or 64 bit
1313     char        endianess;    // MSB or LSB
1314     char*       name;         // String representation
1315   } arch_t;
1316 
1317   #ifndef EM_486
1318     #define EM_486          6               /* Intel 80486 */
1319   #endif
1320 
1321   #ifndef EM_MIPS_RS3_LE
1322     #define EM_MIPS_RS3_LE  10              /* MIPS */
1323   #endif
1324 
1325   #ifndef EM_PPC64
1326     #define EM_PPC64        21              /* PowerPC64 */
1327   #endif
1328 
1329   #ifndef EM_S390
1330     #define EM_S390         22              /* IBM System/390 */
1331   #endif
1332 
1333   #ifndef EM_IA_64
1334     #define EM_IA_64        50              /* HP/Intel IA-64 */
1335   #endif
1336 
1337   #ifndef EM_X86_64
1338     #define EM_X86_64       62              /* AMD x86-64 */
1339   #endif
1340 
1341   static const arch_t arch_array[]={
1342     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1343     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1344     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1345     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1346     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1347     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1348     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1349     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1350     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1351     {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)&quot;ARM&quot;},
1352     {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},
1353     {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
1354     {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
1355     {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
1356     {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
1357     {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;}
1358   };
1359 
1360   #if  (defined IA32)
1361   static  Elf32_Half running_arch_code=EM_386;
1362   #elif   (defined AMD64)
1363   static  Elf32_Half running_arch_code=EM_X86_64;
1364   #elif  (defined IA64)
1365   static  Elf32_Half running_arch_code=EM_IA_64;
1366   #elif  (defined __sparc) &amp;&amp; (defined _LP64)
1367   static  Elf32_Half running_arch_code=EM_SPARCV9;
1368   #elif  (defined __sparc) &amp;&amp; (!defined _LP64)
1369   static  Elf32_Half running_arch_code=EM_SPARC;
1370   #elif  (defined __powerpc64__)
1371   static  Elf32_Half running_arch_code=EM_PPC64;
1372   #elif  (defined __powerpc__)
1373   static  Elf32_Half running_arch_code=EM_PPC;
1374   #elif  (defined ARM)
1375   static  Elf32_Half running_arch_code=EM_ARM;
1376   #elif  (defined S390)
1377   static  Elf32_Half running_arch_code=EM_S390;
1378   #elif  (defined ALPHA)
1379   static  Elf32_Half running_arch_code=EM_ALPHA;
1380   #elif  (defined MIPSEL)
1381   static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
1382   #elif  (defined PARISC)
1383   static  Elf32_Half running_arch_code=EM_PARISC;
1384   #elif  (defined MIPS)
1385   static  Elf32_Half running_arch_code=EM_MIPS;
1386   #elif  (defined M68K)
1387   static  Elf32_Half running_arch_code=EM_68K;
1388   #else
1389     #error Method os::dll_load requires that one of following is defined:\
1390          IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K
1391   #endif
1392 
1393   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture
1394   // Obtain string descriptions for architectures
1395 
1396   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1397   int running_arch_index=-1;
1398 
1399   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1400     if (running_arch_code == arch_array[i].code) {
1401       running_arch_index    = i;
1402     }
1403     if (lib_arch.code == arch_array[i].code) {
1404       lib_arch.compat_class = arch_array[i].compat_class;
1405       lib_arch.name         = arch_array[i].name;
1406     }
1407   }
1408 
1409   assert(running_arch_index != -1,
1410          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
1411   if (running_arch_index == -1) {
1412     // Even though running architecture detection failed
1413     // we may still continue with reporting dlerror() message
1414     return NULL;
1415   }
1416 
1417   if (lib_arch.endianess != arch_array[running_arch_index].endianess) {
1418     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: endianness mismatch)&quot;);
1419     return NULL;
1420   }
1421 
1422 #ifndef S390
1423   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {
1424     ::snprintf(diag_msg_buf, diag_msg_max_length-1,&quot; (Possible cause: architecture word width mismatch)&quot;);
1425     return NULL;
1426   }
1427 #endif // !S390
1428 
1429   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
1430     if (lib_arch.name!=NULL) {
1431       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
1432                  &quot; (Possible cause: can&#39;t load %s-bit .so on a %s-bit platform)&quot;,
1433                  lib_arch.name, arch_array[running_arch_index].name);
1434     } else {
1435       ::snprintf(diag_msg_buf, diag_msg_max_length-1,
1436                  &quot; (Possible cause: can&#39;t load this .so (machine code=0x%x) on a %s-bit platform)&quot;,
1437                  lib_arch.code,
1438                  arch_array[running_arch_index].name);
1439     }
1440   }
1441 
1442   return NULL;
1443 #endif // STATIC_BUILD
1444 }
1445 #endif // !__APPLE__
1446 
1447 void* os::get_default_process_handle() {
1448 #ifdef __APPLE__
1449   // MacOS X needs to use RTLD_FIRST instead of RTLD_LAZY
1450   // to avoid finding unexpected symbols on second (or later)
1451   // loads of a library.
1452   return (void*)::dlopen(NULL, RTLD_FIRST);
1453 #else
1454   return (void*)::dlopen(NULL, RTLD_LAZY);
1455 #endif
1456 }
1457 
1458 // XXX: Do we need a lock around this as per Linux?
1459 void* os::dll_lookup(void* handle, const char* name) {
1460   return dlsym(handle, name);
1461 }
1462 
1463 int _print_dll_info_cb(const char * name, address base_address, address top_address, void * param) {
1464   outputStream * out = (outputStream *) param;
1465   out-&gt;print_cr(INTPTR_FORMAT &quot; \t%s&quot;, (intptr_t)base_address, name);
1466   return 0;
1467 }
1468 
1469 void os::print_dll_info(outputStream *st) {
1470   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1471   if (get_loaded_modules_info(_print_dll_info_cb, (void *)st)) {
1472     st-&gt;print_cr(&quot;Error: Cannot print dynamic libraries.&quot;);
1473   }
1474 }
1475 
1476 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1477 #ifdef RTLD_DI_LINKMAP
1478   Dl_info dli;
1479   void *handle;
1480   Link_map *map;
1481   Link_map *p;
1482 
1483   if (dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &amp;dli) == 0 ||
1484       dli.dli_fname == NULL) {
1485     return 1;
1486   }
1487   handle = dlopen(dli.dli_fname, RTLD_LAZY);
1488   if (handle == NULL) {
1489     return 1;
1490   }
1491   dlinfo(handle, RTLD_DI_LINKMAP, &amp;map);
1492   if (map == NULL) {
1493     dlclose(handle);
1494     return 1;
1495   }
1496 
1497   while (map-&gt;l_prev != NULL)
1498     map = map-&gt;l_prev;
1499 
1500   while (map != NULL) {
1501     // Value for top_address is returned as 0 since we don&#39;t have any information about module size
1502     if (callback(map-&gt;l_name, (address)map-&gt;l_addr, (address)0, param)) {
1503       dlclose(handle);
1504       return 1;
1505     }
1506     map = map-&gt;l_next;
1507   }
1508 
1509   dlclose(handle);
1510 #elif defined(__APPLE__)
1511   for (uint32_t i = 1; i &lt; _dyld_image_count(); i++) {
1512     // Value for top_address is returned as 0 since we don&#39;t have any information about module size
1513     if (callback(_dyld_get_image_name(i), (address)_dyld_get_image_header(i), (address)0, param)) {
1514       return 1;
1515     }
1516   }
1517   return 0;
1518 #else
1519   return 1;
1520 #endif
1521 }
1522 
1523 void os::get_summary_os_info(char* buf, size_t buflen) {
1524   // These buffers are small because we want this to be brief
1525   // and not use a lot of stack while generating the hs_err file.
1526   char os[100];
1527   size_t size = sizeof(os);
1528   int mib_kern[] = { CTL_KERN, KERN_OSTYPE };
1529   if (sysctl(mib_kern, 2, os, &amp;size, NULL, 0) &lt; 0) {
1530 #ifdef __APPLE__
1531       strncpy(os, &quot;Darwin&quot;, sizeof(os));
1532 #elif __OpenBSD__
1533       strncpy(os, &quot;OpenBSD&quot;, sizeof(os));
1534 #else
1535       strncpy(os, &quot;BSD&quot;, sizeof(os));
1536 #endif
1537   }
1538 
1539   char release[100];
1540   size = sizeof(release);
1541   int mib_release[] = { CTL_KERN, KERN_OSRELEASE };
1542   if (sysctl(mib_release, 2, release, &amp;size, NULL, 0) &lt; 0) {
1543       // if error, leave blank
1544       strncpy(release, &quot;&quot;, sizeof(release));
1545   }
1546   snprintf(buf, buflen, &quot;%s %s&quot;, os, release);
1547 }
1548 
1549 void os::print_os_info_brief(outputStream* st) {
1550   os::Posix::print_uname_info(st);
1551 }
1552 
1553 void os::print_os_info(outputStream* st) {
1554   st-&gt;print(&quot;OS:&quot;);
1555 
1556   os::Posix::print_uname_info(st);
1557 
<a name="37" id="anc37"></a>

1558   os::Posix::print_rlimit_info(st);
1559 
1560   os::Posix::print_load_average(st);
1561 }
1562 
1563 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1564   // Nothing to do for now.
1565 }
1566 
1567 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1568   unsigned int mhz;
1569   size_t size = sizeof(mhz);
1570   int mib[] = { CTL_HW, HW_CPU_FREQ };
1571   if (sysctl(mib, 2, &amp;mhz, &amp;size, NULL, 0) &lt; 0) {
1572     mhz = 1;  // looks like an error but can be divided by
1573   } else {
1574     mhz /= 1000000;  // reported in millions
1575   }
1576 
1577   char model[100];
1578   size = sizeof(model);
1579   int mib_model[] = { CTL_HW, HW_MODEL };
1580   if (sysctl(mib_model, 2, model, &amp;size, NULL, 0) &lt; 0) {
1581     strncpy(model, cpu_arch, sizeof(model));
1582   }
1583 
1584   char machine[100];
1585   size = sizeof(machine);
1586   int mib_machine[] = { CTL_HW, HW_MACHINE };
1587   if (sysctl(mib_machine, 2, machine, &amp;size, NULL, 0) &lt; 0) {
1588       strncpy(machine, &quot;&quot;, sizeof(machine));
1589   }
1590 
1591   snprintf(buf, buflen, &quot;%s %s %d MHz&quot;, model, machine, mhz);
1592 }
1593 
1594 void os::print_memory_info(outputStream* st) {
<a name="38" id="anc38"></a>

1595 
1596   st-&gt;print(&quot;Memory:&quot;);
1597   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1598 
1599   st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
1600             os::physical_memory() &gt;&gt; 10);
1601   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
1602             os::available_memory() &gt;&gt; 10);
<a name="39" id="anc39"></a>









1603   st-&gt;cr();
1604 }
1605 
1606 static void print_signal_handler(outputStream* st, int sig,
1607                                  char* buf, size_t buflen);
1608 
1609 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1610   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1611   print_signal_handler(st, SIGSEGV, buf, buflen);
1612   print_signal_handler(st, SIGBUS , buf, buflen);
1613   print_signal_handler(st, SIGFPE , buf, buflen);
1614   print_signal_handler(st, SIGPIPE, buf, buflen);
1615   print_signal_handler(st, SIGXFSZ, buf, buflen);
1616   print_signal_handler(st, SIGILL , buf, buflen);
1617   print_signal_handler(st, SR_signum, buf, buflen);
1618   print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);
1619   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
1620   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
1621   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
1622 }
1623 
1624 static char saved_jvm_path[MAXPATHLEN] = {0};
1625 
1626 // Find the full path to the current module, libjvm
1627 void os::jvm_path(char *buf, jint buflen) {
1628   // Error checking.
1629   if (buflen &lt; MAXPATHLEN) {
1630     assert(false, &quot;must use a large-enough buffer&quot;);
1631     buf[0] = &#39;\0&#39;;
1632     return;
1633   }
1634   // Lazy resolve the path to current module.
1635   if (saved_jvm_path[0] != 0) {
1636     strcpy(buf, saved_jvm_path);
1637     return;
1638   }
1639 
1640   char dli_fname[MAXPATHLEN];
1641   bool ret = dll_address_to_library_name(
1642                                          CAST_FROM_FN_PTR(address, os::jvm_path),
1643                                          dli_fname, sizeof(dli_fname), NULL);
1644   assert(ret, &quot;cannot locate libjvm&quot;);
1645   char *rp = NULL;
1646   if (ret &amp;&amp; dli_fname[0] != &#39;\0&#39;) {
1647     rp = os::Posix::realpath(dli_fname, buf, buflen);
1648   }
1649   if (rp == NULL) {
1650     return;
1651   }
1652 
1653   if (Arguments::sun_java_launcher_is_altjvm()) {
1654     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Typical
1655     // value for buf is &quot;&lt;JAVA_HOME&gt;/jre/lib/&lt;arch&gt;/&lt;vmtype&gt;/libjvm.so&quot;
1656     // or &quot;&lt;JAVA_HOME&gt;/jre/lib/&lt;vmtype&gt;/libjvm.dylib&quot;. If &quot;/jre/lib/&quot;
1657     // appears at the right place in the string, then assume we are
1658     // installed in a JDK and we&#39;re done. Otherwise, check for a
1659     // JAVA_HOME environment variable and construct a path to the JVM
1660     // being overridden.
1661 
1662     const char *p = buf + strlen(buf) - 1;
1663     for (int count = 0; p &gt; buf &amp;&amp; count &lt; 5; ++count) {
1664       for (--p; p &gt; buf &amp;&amp; *p != &#39;/&#39;; --p)
1665         /* empty */ ;
1666     }
1667 
1668     if (strncmp(p, &quot;/jre/lib/&quot;, 9) != 0) {
1669       // Look for JAVA_HOME in the environment.
1670       char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1671       if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0) {
1672         char* jrelib_p;
1673         int len;
1674 
1675         // Check the current module name &quot;libjvm&quot;
1676         p = strrchr(buf, &#39;/&#39;);
1677         assert(strstr(p, &quot;/libjvm&quot;) == p, &quot;invalid library name&quot;);
1678 
1679         rp = os::Posix::realpath(java_home_var, buf, buflen);
1680         if (rp == NULL) {
1681           return;
1682         }
1683 
1684         // determine if this is a legacy image or modules image
1685         // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1686         len = strlen(buf);
1687         assert(len &lt; buflen, &quot;Ran out of buffer space&quot;);
1688         jrelib_p = buf + len;
1689 
1690         // Add the appropriate library subdir
1691         snprintf(jrelib_p, buflen-len, &quot;/jre/lib&quot;);
1692         if (0 != access(buf, F_OK)) {
1693           snprintf(jrelib_p, buflen-len, &quot;/lib&quot;);
1694         }
1695 
1696         // Add the appropriate client or server subdir
1697         len = strlen(buf);
1698         jrelib_p = buf + len;
1699         snprintf(jrelib_p, buflen-len, &quot;/%s&quot;, COMPILER_VARIANT);
1700         if (0 != access(buf, F_OK)) {
1701           snprintf(jrelib_p, buflen-len, &quot;%s&quot;, &quot;&quot;);
1702         }
1703 
1704         // If the path exists within JAVA_HOME, add the JVM library name
1705         // to complete the path to JVM being overridden.  Otherwise fallback
1706         // to the path to the current library.
1707         if (0 == access(buf, F_OK)) {
1708           // Use current module name &quot;libjvm&quot;
1709           len = strlen(buf);
1710           snprintf(buf + len, buflen-len, &quot;/libjvm%s&quot;, JNI_LIB_SUFFIX);
1711         } else {
1712           // Fall back to path of current library
1713           rp = os::Posix::realpath(dli_fname, buf, buflen);
1714           if (rp == NULL) {
1715             return;
1716           }
1717         }
1718       }
1719     }
1720   }
1721 
1722   strncpy(saved_jvm_path, buf, MAXPATHLEN);
1723   saved_jvm_path[MAXPATHLEN - 1] = &#39;\0&#39;;
1724 }
1725 
1726 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1727   // no prefix required, not even &quot;_&quot;
1728 }
1729 
1730 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1731   // no suffix required
1732 }
1733 
1734 ////////////////////////////////////////////////////////////////////////////////
1735 // sun.misc.Signal support
1736 
<a name="40" id="anc40"></a><span class="line-removed">1737 static volatile jint sigint_count = 0;</span>
<span class="line-removed">1738 </span>
1739 static void UserHandler(int sig, void *siginfo, void *context) {
<a name="41" id="anc41"></a><span class="line-removed">1740   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="line-removed">1741   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="line-removed">1742   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="line-removed">1743   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1) {</span>
<span class="line-removed">1744     return;</span>
<span class="line-removed">1745   }</span>
<span class="line-removed">1746 </span>
1747   // Ctrl-C is pressed during error reporting, likely because the error
1748   // handler fails to abort. Let VM die immediately.
1749   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1750     os::die();
1751   }
1752 
1753   os::signal_notify(sig);
1754 }
1755 
1756 void* os::user_handler() {
1757   return CAST_FROM_FN_PTR(void*, UserHandler);
1758 }
1759 
1760 extern &quot;C&quot; {
1761   typedef void (*sa_handler_t)(int);
1762   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1763 }
1764 
1765 void* os::signal(int signal_number, void* handler) {
1766   struct sigaction sigAct, oldSigAct;
1767 
1768   sigfillset(&amp;(sigAct.sa_mask));
1769   sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;
1770   sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);
1771 
1772   if (sigaction(signal_number, &amp;sigAct, &amp;oldSigAct)) {
1773     // -1 means registration failed
1774     return (void *)-1;
1775   }
1776 
1777   return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);
1778 }
1779 
1780 void os::signal_raise(int signal_number) {
1781   ::raise(signal_number);
1782 }
1783 
1784 // The following code is moved from os.cpp for making this
1785 // code platform specific, which it is by its very nature.
1786 
1787 // Will be modified when max signal is changed to be dynamic
1788 int os::sigexitnum_pd() {
1789   return NSIG;
1790 }
1791 
1792 // a counter for each possible signal value
1793 static volatile jint pending_signals[NSIG+1] = { 0 };
1794 static Semaphore* sig_sem = NULL;
1795 
1796 static void jdk_misc_signal_init() {
1797   // Initialize signal structures
1798   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1799 
1800   // Initialize signal semaphore
1801   sig_sem = new Semaphore();
1802 }
1803 
1804 void os::signal_notify(int sig) {
1805   if (sig_sem != NULL) {
1806     Atomic::inc(&amp;pending_signals[sig]);
1807     sig_sem-&gt;signal();
1808   } else {
1809     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
1810     // initialization isn&#39;t called.
1811     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
1812   }
1813 }
1814 
1815 static int check_pending_signals() {
<a name="42" id="anc42"></a><span class="line-removed">1816   Atomic::store(0, &amp;sigint_count);</span>
1817   for (;;) {
1818     for (int i = 0; i &lt; NSIG + 1; i++) {
1819       jint n = pending_signals[i];
<a name="43" id="anc43"></a><span class="line-modified">1820       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
1821         return i;
1822       }
1823     }
1824     JavaThread *thread = JavaThread::current();
1825     ThreadBlockInVM tbivm(thread);
1826 
1827     bool threadIsSuspended;
1828     do {
1829       thread-&gt;set_suspend_equivalent();
1830       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1831       sig_sem-&gt;wait();
1832 
1833       // were we externally suspended while we were waiting?
1834       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1835       if (threadIsSuspended) {
1836         // The semaphore has been incremented, but while we were waiting
1837         // another thread suspended us. We don&#39;t want to continue running
1838         // while suspended because that would surprise the thread that
1839         // suspended us.
1840         sig_sem-&gt;signal();
1841 
1842         thread-&gt;java_suspend_self();
1843       }
1844     } while (threadIsSuspended);
1845   }
1846 }
1847 
1848 int os::signal_wait() {
1849   return check_pending_signals();
1850 }
1851 
1852 ////////////////////////////////////////////////////////////////////////////////
1853 // Virtual Memory
1854 
1855 int os::vm_page_size() {
1856   // Seems redundant as all get out
1857   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1858   return os::Bsd::page_size();
1859 }
1860 
1861 // Solaris allocates memory by pages.
1862 int os::vm_allocation_granularity() {
1863   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1864   return os::Bsd::page_size();
1865 }
1866 
1867 // Rationale behind this function:
1868 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
1869 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
1870 //  samples for JITted code. Here we create private executable mapping over the code cache
1871 //  and then we can use standard (well, almost, as mapping can change) way to provide
1872 //  info for the reporting script by storing timestamp and location of symbol
1873 void bsd_wrap_code(char* base, size_t size) {
1874   static volatile jint cnt = 0;
1875 
1876   if (!UseOprofile) {
1877     return;
1878   }
1879 
1880   char buf[PATH_MAX + 1];
<a name="44" id="anc44"></a><span class="line-modified">1881   int num = Atomic::add(1, &amp;cnt);</span>
1882 
1883   snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,
1884            os::get_temp_directory(), os::current_process_id(), num);
1885   unlink(buf);
1886 
1887   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
1888 
1889   if (fd != -1) {
1890     off_t rv = ::lseek(fd, size-2, SEEK_SET);
1891     if (rv != (off_t)-1) {
1892       if (::write(fd, &quot;&quot;, 1) == 1) {
1893         mmap(base, size,
1894              PROT_READ|PROT_WRITE|PROT_EXEC,
1895              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
1896       }
1897     }
1898     ::close(fd);
1899     unlink(buf);
1900   }
1901 }
1902 
1903 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
1904                                     int err) {
1905   warning(&quot;INFO: os::commit_memory(&quot; INTPTR_FORMAT &quot;, &quot; SIZE_FORMAT
1906           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, (intptr_t)addr, size, exec,
1907            os::errno_name(err), err);
1908 }
1909 
1910 // NOTE: Bsd kernel does not really reserve the pages for us.
1911 //       All it does is to check if there are enough free pages
1912 //       left at the time of mmap(). This could be a potential
1913 //       problem.
1914 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
1915   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
1916 #ifdef __OpenBSD__
1917   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<a name="45" id="anc45"></a>
1918   if (::mprotect(addr, size, prot) == 0) {
1919     return true;
1920   }
1921 #else
1922   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
1923                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
1924   if (res != (uintptr_t) MAP_FAILED) {
1925     return true;
1926   }
1927 #endif
1928 
1929   // Warn about any commit errors we see in non-product builds just
1930   // in case mmap() doesn&#39;t work as described on the man page.
1931   NOT_PRODUCT(warn_fail_commit_memory(addr, size, exec, errno);)
1932 
1933   return false;
1934 }
1935 
1936 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
1937                           bool exec) {
1938   // alignment_hint is ignored on this OS
1939   return pd_commit_memory(addr, size, exec);
1940 }
1941 
1942 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
1943                                   const char* mesg) {
1944   assert(mesg != NULL, &quot;mesg must be specified&quot;);
1945   if (!pd_commit_memory(addr, size, exec)) {
1946     // add extra info in product mode for vm_exit_out_of_memory():
1947     PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)
1948     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
1949   }
1950 }
1951 
1952 void os::pd_commit_memory_or_exit(char* addr, size_t size,
1953                                   size_t alignment_hint, bool exec,
1954                                   const char* mesg) {
1955   // alignment_hint is ignored on this OS
1956   pd_commit_memory_or_exit(addr, size, exec, mesg);
1957 }
1958 
1959 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {
1960 }
1961 
1962 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {
1963   ::madvise(addr, bytes, MADV_DONTNEED);
1964 }
1965 
1966 void os::numa_make_global(char *addr, size_t bytes) {
1967 }
1968 
1969 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {
1970 }
1971 
1972 bool os::numa_topology_changed()   { return false; }
1973 
1974 size_t os::numa_get_groups_num() {
1975   return 1;
1976 }
1977 
1978 int os::numa_get_group_id() {
1979   return 0;
1980 }
1981 
1982 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
1983   if (size &gt; 0) {
1984     ids[0] = 0;
1985     return 1;
1986   }
1987   return 0;
1988 }
1989 
<a name="46" id="anc46"></a>



1990 bool os::get_page_info(char *start, page_info* info) {
1991   return false;
1992 }
1993 
1994 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
1995   return end;
1996 }
1997 
1998 
1999 bool os::pd_uncommit_memory(char* addr, size_t size) {
2000 #ifdef __OpenBSD__
2001   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<a name="47" id="anc47"></a>
2002   return ::mprotect(addr, size, PROT_NONE) == 0;
2003 #else
2004   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
2005                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
2006   return res  != (uintptr_t) MAP_FAILED;
2007 #endif
2008 }
2009 
2010 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
2011   return os::commit_memory(addr, size, !ExecMem);
2012 }
2013 
2014 // If this is a growable mapping, remove the guard pages entirely by
2015 // munmap()ping them.  If not, just call uncommit_memory().
2016 bool os::remove_stack_guard_pages(char* addr, size_t size) {
2017   return os::uncommit_memory(addr, size);
2018 }
2019 
2020 // If &#39;fixed&#39; is true, anon_mmap() will attempt to reserve anonymous memory
2021 // at &#39;requested_addr&#39;. If there are existing memory mappings at the same
2022 // location, however, they will be overwritten. If &#39;fixed&#39; is false,
2023 // &#39;requested_addr&#39; is only treated as a hint, the return value may or
2024 // may not start from the requested address. Unlike Bsd mmap(), this
2025 // function returns NULL to indicate failure.
2026 static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {
2027   char * addr;
2028   int flags;
2029 
2030   flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
2031   if (fixed) {
2032     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, &quot;unaligned address&quot;);
2033     flags |= MAP_FIXED;
2034   }
2035 
2036   // Map reserved/uncommitted pages PROT_NONE so we fail early if we
2037   // touch an uncommitted page. Otherwise, the read/write might
2038   // succeed if we have enough swap space to back the physical page.
2039   addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,
2040                        flags, -1, 0);
2041 
2042   return addr == MAP_FAILED ? NULL : addr;
2043 }
2044 
2045 static int anon_munmap(char * addr, size_t size) {
2046   return ::munmap(addr, size) == 0;
2047 }
2048 
2049 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
2050                             size_t alignment_hint) {
2051   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
2052 }
2053 
2054 bool os::pd_release_memory(char* addr, size_t size) {
2055   return anon_munmap(addr, size);
2056 }
2057 
2058 static bool bsd_mprotect(char* addr, size_t size, int prot) {
2059   // Bsd wants the mprotect address argument to be page aligned.
2060   char* bottom = (char*)align_down((intptr_t)addr, os::Bsd::page_size());
2061 
2062   // According to SUSv3, mprotect() should only be used with mappings
2063   // established by mmap(), and mmap() always maps whole pages. Unaligned
2064   // &#39;addr&#39; likely indicates problem in the VM (e.g. trying to change
2065   // protection of malloc&#39;ed or statically allocated memory). Check the
2066   // caller if you hit this assert.
2067   assert(addr == bottom, &quot;sanity check&quot;);
2068 
2069   size = align_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());
<a name="48" id="anc48"></a>
2070   return ::mprotect(bottom, size, prot) == 0;
2071 }
2072 
2073 // Set protections specified
2074 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
2075                         bool is_committed) {
2076   unsigned int p = 0;
2077   switch (prot) {
2078   case MEM_PROT_NONE: p = PROT_NONE; break;
2079   case MEM_PROT_READ: p = PROT_READ; break;
2080   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2081   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2082   default:
2083     ShouldNotReachHere();
2084   }
2085   // is_committed is unused.
2086   return bsd_mprotect(addr, bytes, p);
2087 }
2088 
2089 bool os::guard_memory(char* addr, size_t size) {
2090   return bsd_mprotect(addr, size, PROT_NONE);
2091 }
2092 
2093 bool os::unguard_memory(char* addr, size_t size) {
2094   return bsd_mprotect(addr, size, PROT_READ|PROT_WRITE);
2095 }
2096 
2097 bool os::Bsd::hugetlbfs_sanity_check(bool warn, size_t page_size) {
2098   return false;
2099 }
2100 
2101 // Large page support
2102 
2103 static size_t _large_page_size = 0;
2104 
2105 void os::large_page_init() {
2106 }
2107 
2108 
2109 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {
2110   fatal(&quot;os::reserve_memory_special should not be called on BSD.&quot;);
2111   return NULL;
2112 }
2113 
2114 bool os::release_memory_special(char* base, size_t bytes) {
2115   fatal(&quot;os::release_memory_special should not be called on BSD.&quot;);
2116   return false;
2117 }
2118 
2119 size_t os::large_page_size() {
2120   return _large_page_size;
2121 }
2122 
2123 bool os::can_commit_large_page_memory() {
2124   // Does not matter, we do not support huge pages.
2125   return false;
2126 }
2127 
2128 bool os::can_execute_large_page_memory() {
2129   // Does not matter, we do not support huge pages.
2130   return false;
2131 }
2132 
2133 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2134   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2135   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
2136   if (result != NULL) {
2137     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2138       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2139     }
2140   }
2141   return result;
2142 }
2143 
2144 // Reserve memory at an arbitrary address, only if that area is
2145 // available (and not reserved for something else).
2146 
2147 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<a name="49" id="anc49"></a><span class="line-removed">2148   const int max_tries = 10;</span>
<span class="line-removed">2149   char* base[max_tries];</span>
<span class="line-removed">2150   size_t size[max_tries];</span>
<span class="line-removed">2151   const size_t gap = 0x000000;</span>
<span class="line-removed">2152 </span>
2153   // Assert only that the size is a multiple of the page size, since
2154   // that&#39;s all that mmap requires, and since that&#39;s all we really know
2155   // about at this low abstraction level.  If we need higher alignment,
2156   // we can either pass an alignment to this method or verify alignment
2157   // in one of the methods further up the call chain.  See bug 5044738.
2158   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
2159 
2160   // Repeatedly allocate blocks until the block is allocated at the
2161   // right spot.
2162 
2163   // Bsd mmap allows caller to pass an address as hint; give it a try first,
2164   // if kernel honors the hint then we can return immediately.
2165   char * addr = anon_mmap(requested_addr, bytes, false);
2166   if (addr == requested_addr) {
2167     return requested_addr;
2168   }
2169 
2170   if (addr != NULL) {
2171     // mmap() is successful but it fails to reserve at the requested address
2172     anon_munmap(addr, bytes);
2173   }
2174 
<a name="50" id="anc50"></a><span class="line-modified">2175   int i;</span>
<span class="line-removed">2176   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">2177     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">2178 </span>
<span class="line-removed">2179     if (base[i] != NULL) {</span>
<span class="line-removed">2180       // Is this the block we wanted?</span>
<span class="line-removed">2181       if (base[i] == requested_addr) {</span>
<span class="line-removed">2182         size[i] = bytes;</span>
<span class="line-removed">2183         break;</span>
<span class="line-removed">2184       }</span>
<span class="line-removed">2185 </span>
<span class="line-removed">2186       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">2187       // parts and try again.</span>
<span class="line-removed">2188 </span>
<span class="line-removed">2189       size_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">2190       if (top_overlap &gt;= 0 &amp;&amp; top_overlap &lt; bytes) {</span>
<span class="line-removed">2191         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">2192         base[i] += top_overlap;</span>
<span class="line-removed">2193         size[i] = bytes - top_overlap;</span>
<span class="line-removed">2194       } else {</span>
<span class="line-removed">2195         size_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">2196         if (bottom_overlap &gt;= 0 &amp;&amp; bottom_overlap &lt; bytes) {</span>
<span class="line-removed">2197           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">2198           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">2199         } else {</span>
<span class="line-removed">2200           size[i] = bytes;</span>
<span class="line-removed">2201         }</span>
<span class="line-removed">2202       }</span>
<span class="line-removed">2203     }</span>
<span class="line-removed">2204   }</span>
<span class="line-removed">2205 </span>
<span class="line-removed">2206   // Give back the unused reserved pieces.</span>
<span class="line-removed">2207 </span>
<span class="line-removed">2208   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">2209     if (base[j] != NULL) {</span>
<span class="line-removed">2210       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">2211     }</span>
<span class="line-removed">2212   }</span>
<span class="line-removed">2213 </span>
<span class="line-removed">2214   if (i &lt; max_tries) {</span>
<span class="line-removed">2215     return requested_addr;</span>
<span class="line-removed">2216   } else {</span>
<span class="line-removed">2217     return NULL;</span>
<span class="line-removed">2218   }</span>
2219 }
2220 
2221 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2222 void os::infinite_sleep() {
2223   while (true) {    // sleep forever ...
2224     ::sleep(100);   // ... 100 seconds at a time
2225   }
2226 }
2227 
2228 // Used to convert frequent JVM_Yield() to nops
2229 bool os::dont_yield() {
2230   return DontYieldALot;
2231 }
2232 
2233 void os::naked_yield() {
2234   sched_yield();
2235 }
2236 
2237 ////////////////////////////////////////////////////////////////////////////////
2238 // thread priority support
2239 
2240 // Note: Normal Bsd applications are run with SCHED_OTHER policy. SCHED_OTHER
2241 // only supports dynamic priority, static priority must be zero. For real-time
2242 // applications, Bsd supports SCHED_RR which allows static priority (1-99).
2243 // However, for large multi-threaded applications, SCHED_RR is not only slower
2244 // than SCHED_OTHER, but also very unstable (my volano tests hang hard 4 out
2245 // of 5 runs - Sep 2005).
2246 //
2247 // The following code actually changes the niceness of kernel-thread/LWP. It
2248 // has an assumption that setpriority() only modifies one kernel-thread/LWP,
2249 // not the entire user process, and user level threads are 1:1 mapped to kernel
2250 // threads. It has always been the case, but could change in the future. For
2251 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
2252 // It is only used when ThreadPriorityPolicy=1 and may require system level permission
2253 // (e.g., root privilege or CAP_SYS_NICE capability).
2254 
2255 #if !defined(__APPLE__)
2256 int os::java_to_os_priority[CriticalPriority + 1] = {
2257   19,              // 0 Entry should never be used
2258 
2259    0,              // 1 MinPriority
2260    3,              // 2
2261    6,              // 3
2262 
2263   10,              // 4
2264   15,              // 5 NormPriority
2265   18,              // 6
2266 
2267   21,              // 7
2268   25,              // 8
2269   28,              // 9 NearMaxPriority
2270 
2271   31,              // 10 MaxPriority
2272 
2273   31               // 11 CriticalPriority
2274 };
2275 #else
2276 // Using Mach high-level priority assignments
2277 int os::java_to_os_priority[CriticalPriority + 1] = {
2278    0,              // 0 Entry should never be used (MINPRI_USER)
2279 
2280   27,              // 1 MinPriority
2281   28,              // 2
2282   29,              // 3
2283 
2284   30,              // 4
2285   31,              // 5 NormPriority (BASEPRI_DEFAULT)
2286   32,              // 6
2287 
2288   33,              // 7
2289   34,              // 8
2290   35,              // 9 NearMaxPriority
2291 
2292   36,              // 10 MaxPriority
2293 
2294   36               // 11 CriticalPriority
2295 };
2296 #endif
2297 
2298 static int prio_init() {
2299   if (ThreadPriorityPolicy == 1) {
2300     if (geteuid() != 0) {
2301       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {
2302         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \
2303                 &quot;e.g., being the root user. If the necessary permission is not &quot; \
2304                 &quot;possessed, changes to priority will be silently ignored.&quot;);
2305       }
2306     }
2307   }
2308   if (UseCriticalJavaThreadPriority) {
2309     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
2310   }
2311   return 0;
2312 }
2313 
2314 OSReturn os::set_native_priority(Thread* thread, int newpri) {
2315   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;
2316 
2317 #ifdef __OpenBSD__
2318   // OpenBSD pthread_setprio starves low priority threads
2319   return OS_OK;
2320 #elif defined(__FreeBSD__)
2321   int ret = pthread_setprio(thread-&gt;osthread()-&gt;pthread_id(), newpri);
2322   return (ret == 0) ? OS_OK : OS_ERR;
2323 #elif defined(__APPLE__) || defined(__NetBSD__)
2324   struct sched_param sp;
2325   int policy;
2326 
2327   if (pthread_getschedparam(thread-&gt;osthread()-&gt;pthread_id(), &amp;policy, &amp;sp) != 0) {
2328     return OS_ERR;
2329   }
2330 
2331   sp.sched_priority = newpri;
2332   if (pthread_setschedparam(thread-&gt;osthread()-&gt;pthread_id(), policy, &amp;sp) != 0) {
2333     return OS_ERR;
2334   }
2335 
2336   return OS_OK;
2337 #else
2338   int ret = setpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id(), newpri);
2339   return (ret == 0) ? OS_OK : OS_ERR;
2340 #endif
2341 }
2342 
2343 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
2344   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) {
2345     *priority_ptr = java_to_os_priority[NormPriority];
2346     return OS_OK;
2347   }
2348 
2349   errno = 0;
2350 #if defined(__OpenBSD__) || defined(__FreeBSD__)
2351   *priority_ptr = pthread_getprio(thread-&gt;osthread()-&gt;pthread_id());
2352 #elif defined(__APPLE__) || defined(__NetBSD__)
2353   int policy;
2354   struct sched_param sp;
2355 
2356   int res = pthread_getschedparam(thread-&gt;osthread()-&gt;pthread_id(), &amp;policy, &amp;sp);
2357   if (res != 0) {
2358     *priority_ptr = -1;
2359     return OS_ERR;
2360   } else {
2361     *priority_ptr = sp.sched_priority;
2362     return OS_OK;
2363   }
2364 #else
2365   *priority_ptr = getpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id());
2366 #endif
2367   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
2368 }
2369 
2370 ////////////////////////////////////////////////////////////////////////////////
2371 // suspend/resume support
2372 
2373 //  The low-level signal-based suspend/resume support is a remnant from the
2374 //  old VM-suspension that used to be for java-suspension, safepoints etc,
2375 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2376 //
2377 //  The remaining code is greatly simplified from the more general suspension
2378 //  code that used to be used.
2379 //
2380 //  The protocol is quite simple:
2381 //  - suspend:
2382 //      - sends a signal to the target thread
2383 //      - polls the suspend state of the osthread using a yield loop
2384 //      - target thread signal handler (SR_handler) sets suspend state
2385 //        and blocks in sigsuspend until continued
2386 //  - resume:
2387 //      - sets target osthread state to continue
2388 //      - sends signal to end the sigsuspend loop in the SR_handler
2389 //
2390 //  Note that the SR_lock plays no role in this suspend/resume protocol,
2391 //  but is checked for NULL in SR_handler as a thread termination indicator.
2392 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
2393 //
2394 //  Note that resume_clear_context() and suspend_save_context() are needed
2395 //  by SR_handler(), so that fetch_frame_from_ucontext() works,
2396 //  which in part is used by:
2397 //    - Forte Analyzer: AsyncGetCallTrace()
2398 //    - StackBanging: get_frame_at_stack_banging_point()
2399 
2400 static void resume_clear_context(OSThread *osthread) {
2401   osthread-&gt;set_ucontext(NULL);
2402   osthread-&gt;set_siginfo(NULL);
2403 }
2404 
2405 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {
2406   osthread-&gt;set_ucontext(context);
2407   osthread-&gt;set_siginfo(siginfo);
2408 }
2409 
2410 // Handler function invoked when a thread&#39;s execution is suspended or
2411 // resumed. We have to be careful that only async-safe functions are
2412 // called here (Note: most pthread functions are not async safe and
2413 // should be avoided.)
2414 //
2415 // Note: sigwait() is a more natural fit than sigsuspend() from an
2416 // interface point of view, but sigwait() prevents the signal hander
2417 // from being run. libpthread would get very confused by not having
2418 // its signal handlers run and prevents sigwait()&#39;s use with the
2419 // mutex granting granting signal.
2420 //
2421 // Currently only ever called on the VMThread or JavaThread
2422 //
2423 #ifdef __APPLE__
2424 static OSXSemaphore sr_semaphore;
2425 #else
2426 static PosixSemaphore sr_semaphore;
2427 #endif
2428 
2429 static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {
2430   // Save and restore errno to avoid confusing native code with EINTR
2431   // after sigsuspend.
2432   int old_errno = errno;
2433 
2434   Thread* thread = Thread::current_or_null_safe();
2435   assert(thread != NULL, &quot;Missing current thread in SR_handler&quot;);
2436 
2437   // On some systems we have seen signal delivery get &quot;stuck&quot; until the signal
2438   // mask is changed as part of thread termination. Check that the current thread
2439   // has not already terminated (via SR_lock()) - else the following assertion
2440   // will fail because the thread is no longer a JavaThread as the ~JavaThread
2441   // destructor has completed.
2442 
2443   if (thread-&gt;SR_lock() == NULL) {
2444     return;
2445   }
2446 
2447   assert(thread-&gt;is_VM_thread() || thread-&gt;is_Java_thread(), &quot;Must be VMThread or JavaThread&quot;);
2448 
2449   OSThread* osthread = thread-&gt;osthread();
2450 
2451   os::SuspendResume::State current = osthread-&gt;sr.state();
2452   if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {
2453     suspend_save_context(osthread, siginfo, context);
2454 
2455     // attempt to switch the state, we assume we had a SUSPEND_REQUEST
2456     os::SuspendResume::State state = osthread-&gt;sr.suspended();
2457     if (state == os::SuspendResume::SR_SUSPENDED) {
2458       sigset_t suspend_set;  // signals for sigsuspend()
2459 
2460       // get current set of blocked signals and unblock resume signal
2461       pthread_sigmask(SIG_BLOCK, NULL, &amp;suspend_set);
2462       sigdelset(&amp;suspend_set, SR_signum);
2463 
2464       sr_semaphore.signal();
2465       // wait here until we are resumed
2466       while (1) {
2467         sigsuspend(&amp;suspend_set);
2468 
2469         os::SuspendResume::State result = osthread-&gt;sr.running();
2470         if (result == os::SuspendResume::SR_RUNNING) {
2471           sr_semaphore.signal();
2472           break;
2473         } else if (result != os::SuspendResume::SR_SUSPENDED) {
2474           ShouldNotReachHere();
2475         }
2476       }
2477 
2478     } else if (state == os::SuspendResume::SR_RUNNING) {
2479       // request was cancelled, continue
2480     } else {
2481       ShouldNotReachHere();
2482     }
2483 
2484     resume_clear_context(osthread);
2485   } else if (current == os::SuspendResume::SR_RUNNING) {
2486     // request was cancelled, continue
2487   } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {
2488     // ignore
2489   } else {
2490     // ignore
2491   }
2492 
2493   errno = old_errno;
2494 }
2495 
2496 
2497 static int SR_initialize() {
2498   struct sigaction act;
2499   char *s;
2500   // Get signal number to use for suspend/resume
2501   if ((s = ::getenv(&quot;_JAVA_SR_SIGNUM&quot;)) != 0) {
2502     int sig = ::strtol(s, 0, 10);
2503     if (sig &gt; MAX2(SIGSEGV, SIGBUS) &amp;&amp;  // See 4355769.
2504         sig &lt; NSIG) {                   // Must be legal signal and fit into sigflags[].
2505       SR_signum = sig;
2506     } else {
2507       warning(&quot;You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.&quot;,
2508               sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);
2509     }
2510   }
2511 
2512   assert(SR_signum &gt; SIGSEGV &amp;&amp; SR_signum &gt; SIGBUS,
2513          &quot;SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769&quot;);
2514 
2515   sigemptyset(&amp;SR_sigset);
2516   sigaddset(&amp;SR_sigset, SR_signum);
2517 
2518   // Set up signal handler for suspend/resume
2519   act.sa_flags = SA_RESTART|SA_SIGINFO;
2520   act.sa_handler = (void (*)(int)) SR_handler;
2521 
2522   // SR_signum is blocked by default.
2523   // 4528190 - We also need to block pthread restart signal (32 on all
2524   // supported Bsd platforms). Note that BsdThreads need to block
2525   // this signal for all threads to work properly. So we don&#39;t have
2526   // to use hard-coded signal number when setting up the mask.
2527   pthread_sigmask(SIG_BLOCK, NULL, &amp;act.sa_mask);
2528 
2529   if (sigaction(SR_signum, &amp;act, 0) == -1) {
2530     return -1;
2531   }
2532 
2533   // Save signal flag
2534   os::Bsd::set_our_sigflags(SR_signum, act.sa_flags);
2535   return 0;
2536 }
2537 
2538 static int sr_notify(OSThread* osthread) {
2539   int status = pthread_kill(osthread-&gt;pthread_id(), SR_signum);
2540   assert_status(status == 0, status, &quot;pthread_kill&quot;);
2541   return status;
2542 }
2543 
2544 // &quot;Randomly&quot; selected value for how long we want to spin
2545 // before bailing out on suspending a thread, also how often
2546 // we send a signal to a thread we want to resume
2547 static const int RANDOMLY_LARGE_INTEGER = 1000000;
2548 static const int RANDOMLY_LARGE_INTEGER2 = 100;
2549 
2550 // returns true on success and false on error - really an error is fatal
2551 // but this seems the normal response to library errors
2552 static bool do_suspend(OSThread* osthread) {
2553   assert(osthread-&gt;sr.is_running(), &quot;thread should be running&quot;);
2554   assert(!sr_semaphore.trywait(), &quot;semaphore has invalid state&quot;);
2555 
2556   // mark as suspended and send signal
2557   if (osthread-&gt;sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {
2558     // failed to switch, state wasn&#39;t running?
2559     ShouldNotReachHere();
2560     return false;
2561   }
2562 
2563   if (sr_notify(osthread) != 0) {
2564     ShouldNotReachHere();
2565   }
2566 
2567   // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED
2568   while (true) {
2569     if (sr_semaphore.timedwait(2)) {
2570       break;
2571     } else {
2572       // timeout
2573       os::SuspendResume::State cancelled = osthread-&gt;sr.cancel_suspend();
2574       if (cancelled == os::SuspendResume::SR_RUNNING) {
2575         return false;
2576       } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {
2577         // make sure that we consume the signal on the semaphore as well
2578         sr_semaphore.wait();
2579         break;
2580       } else {
2581         ShouldNotReachHere();
2582         return false;
2583       }
2584     }
2585   }
2586 
2587   guarantee(osthread-&gt;sr.is_suspended(), &quot;Must be suspended&quot;);
2588   return true;
2589 }
2590 
2591 static void do_resume(OSThread* osthread) {
2592   assert(osthread-&gt;sr.is_suspended(), &quot;thread should be suspended&quot;);
2593   assert(!sr_semaphore.trywait(), &quot;invalid semaphore state&quot;);
2594 
2595   if (osthread-&gt;sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {
2596     // failed to switch to WAKEUP_REQUEST
2597     ShouldNotReachHere();
2598     return;
2599   }
2600 
2601   while (true) {
2602     if (sr_notify(osthread) == 0) {
2603       if (sr_semaphore.timedwait(2)) {
2604         if (osthread-&gt;sr.is_running()) {
2605           return;
2606         }
2607       }
2608     } else {
2609       ShouldNotReachHere();
2610     }
2611   }
2612 
2613   guarantee(osthread-&gt;sr.is_running(), &quot;Must be running!&quot;);
2614 }
2615 
2616 ///////////////////////////////////////////////////////////////////////////////////
2617 // signal handling (except suspend/resume)
2618 
2619 // This routine may be used by user applications as a &quot;hook&quot; to catch signals.
2620 // The user-defined signal handler must pass unrecognized signals to this
2621 // routine, and if it returns true (non-zero), then the signal handler must
2622 // return immediately.  If the flag &quot;abort_if_unrecognized&quot; is true, then this
2623 // routine will never retun false (zero), but instead will execute a VM panic
2624 // routine kill the process.
2625 //
2626 // If this routine returns false, it is OK to call it again.  This allows
2627 // the user-defined signal handler to perform checks either before or after
2628 // the VM performs its own checks.  Naturally, the user code would be making
2629 // a serious error if it tried to handle an exception (such as a null check
2630 // or breakpoint) that the VM was generating for its own correct operation.
2631 //
2632 // This routine may recognize any of the following kinds of signals:
2633 //    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.
2634 // It should be consulted by handlers for any of those signals.
2635 //
2636 // The caller of this routine must pass in the three arguments supplied
2637 // to the function referred to in the &quot;sa_sigaction&quot; (not the &quot;sa_handler&quot;)
2638 // field of the structure passed to sigaction().  This routine assumes that
2639 // the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.
2640 //
2641 // Note that the VM will print warnings if it detects conflicting signal
2642 // handlers, unless invoked with the option &quot;-XX:+AllowUserSignalHandlers&quot;.
2643 //
2644 extern &quot;C&quot; JNIEXPORT int JVM_handle_bsd_signal(int signo, siginfo_t* siginfo,
2645                                                void* ucontext,
2646                                                int abort_if_unrecognized);
2647 
2648 static void signalHandler(int sig, siginfo_t* info, void* uc) {
2649   assert(info != NULL &amp;&amp; uc != NULL, &quot;it must be old kernel&quot;);
2650   int orig_errno = errno;  // Preserve errno value over signal handler.
2651   JVM_handle_bsd_signal(sig, info, uc, true);
2652   errno = orig_errno;
2653 }
2654 
2655 
2656 // This boolean allows users to forward their own non-matching signals
2657 // to JVM_handle_bsd_signal, harmlessly.
2658 bool os::Bsd::signal_handlers_are_installed = false;
2659 
2660 // For signal-chaining
2661 bool os::Bsd::libjsig_is_loaded = false;
2662 typedef struct sigaction *(*get_signal_t)(int);
2663 get_signal_t os::Bsd::get_signal_action = NULL;
2664 
2665 struct sigaction* os::Bsd::get_chained_signal_action(int sig) {
2666   struct sigaction *actp = NULL;
2667 
2668   if (libjsig_is_loaded) {
2669     // Retrieve the old signal handler from libjsig
2670     actp = (*get_signal_action)(sig);
2671   }
2672   if (actp == NULL) {
2673     // Retrieve the preinstalled signal handler from jvm
2674     actp = os::Posix::get_preinstalled_handler(sig);
2675   }
2676 
2677   return actp;
2678 }
2679 
2680 static bool call_chained_handler(struct sigaction *actp, int sig,
2681                                  siginfo_t *siginfo, void *context) {
2682   // Call the old signal handler
2683   if (actp-&gt;sa_handler == SIG_DFL) {
2684     // It&#39;s more reasonable to let jvm treat it as an unexpected exception
2685     // instead of taking the default action.
2686     return false;
2687   } else if (actp-&gt;sa_handler != SIG_IGN) {
2688     if ((actp-&gt;sa_flags &amp; SA_NODEFER) == 0) {
2689       // automaticlly block the signal
2690       sigaddset(&amp;(actp-&gt;sa_mask), sig);
2691     }
2692 
2693     sa_handler_t hand;
2694     sa_sigaction_t sa;
2695     bool siginfo_flag_set = (actp-&gt;sa_flags &amp; SA_SIGINFO) != 0;
2696     // retrieve the chained handler
2697     if (siginfo_flag_set) {
2698       sa = actp-&gt;sa_sigaction;
2699     } else {
2700       hand = actp-&gt;sa_handler;
2701     }
2702 
2703     if ((actp-&gt;sa_flags &amp; SA_RESETHAND) != 0) {
2704       actp-&gt;sa_handler = SIG_DFL;
2705     }
2706 
2707     // try to honor the signal mask
2708     sigset_t oset;
2709     pthread_sigmask(SIG_SETMASK, &amp;(actp-&gt;sa_mask), &amp;oset);
2710 
2711     // call into the chained handler
2712     if (siginfo_flag_set) {
2713       (*sa)(sig, siginfo, context);
2714     } else {
2715       (*hand)(sig);
2716     }
2717 
2718     // restore the signal mask
2719     pthread_sigmask(SIG_SETMASK, &amp;oset, 0);
2720   }
2721   // Tell jvm&#39;s signal handler the signal is taken care of.
2722   return true;
2723 }
2724 
2725 bool os::Bsd::chained_handler(int sig, siginfo_t* siginfo, void* context) {
2726   bool chained = false;
2727   // signal-chaining
2728   if (UseSignalChaining) {
2729     struct sigaction *actp = get_chained_signal_action(sig);
2730     if (actp != NULL) {
2731       chained = call_chained_handler(actp, sig, siginfo, context);
2732     }
2733   }
2734   return chained;
2735 }
2736 
2737 // for diagnostic
2738 int sigflags[NSIG];
2739 
2740 int os::Bsd::get_our_sigflags(int sig) {
2741   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
2742   return sigflags[sig];
2743 }
2744 
2745 void os::Bsd::set_our_sigflags(int sig, int flags) {
2746   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
2747   if (sig &gt; 0 &amp;&amp; sig &lt; NSIG) {
2748     sigflags[sig] = flags;
2749   }
2750 }
2751 
2752 void os::Bsd::set_signal_handler(int sig, bool set_installed) {
2753   // Check for overwrite.
2754   struct sigaction oldAct;
2755   sigaction(sig, (struct sigaction*)NULL, &amp;oldAct);
2756 
2757   void* oldhand = oldAct.sa_sigaction
2758                 ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)
2759                 : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);
2760   if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &amp;&amp;
2761       oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &amp;&amp;
2762       oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {
2763     if (AllowUserSignalHandlers || !set_installed) {
2764       // Do not overwrite; user takes responsibility to forward to us.
2765       return;
2766     } else if (UseSignalChaining) {
2767       // save the old handler in jvm
2768       os::Posix::save_preinstalled_handler(sig, oldAct);
2769       // libjsig also interposes the sigaction() call below and saves the
2770       // old sigaction on it own.
2771     } else {
2772       fatal(&quot;Encountered unexpected pre-existing sigaction handler &quot;
2773             &quot;%#lx for signal %d.&quot;, (long)oldhand, sig);
2774     }
2775   }
2776 
2777   struct sigaction sigAct;
2778   sigfillset(&amp;(sigAct.sa_mask));
2779   sigAct.sa_handler = SIG_DFL;
2780   if (!set_installed) {
2781     sigAct.sa_flags = SA_SIGINFO|SA_RESTART;
2782   } else {
2783     sigAct.sa_sigaction = signalHandler;
2784     sigAct.sa_flags = SA_SIGINFO|SA_RESTART;
2785   }
2786 #ifdef __APPLE__
2787   // Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV
2788   // (which starts as SIGBUS) on main thread with faulting address inside &quot;stack+guard pages&quot;
2789   // if the signal handler declares it will handle it on alternate stack.
2790   // Notice we only declare we will handle it on alt stack, but we are not
2791   // actually going to use real alt stack - this is just a workaround.
2792   // Please see ux_exception.c, method catch_mach_exception_raise for details
2793   // link http://www.opensource.apple.com/source/xnu/xnu-2050.18.24/bsd/uxkern/ux_exception.c
2794   if (sig == SIGSEGV) {
2795     sigAct.sa_flags |= SA_ONSTACK;
2796   }
2797 #endif
2798 
2799   // Save flags, which are set by ours
2800   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
2801   sigflags[sig] = sigAct.sa_flags;
2802 
2803   int ret = sigaction(sig, &amp;sigAct, &amp;oldAct);
2804   assert(ret == 0, &quot;check&quot;);
2805 
2806   void* oldhand2  = oldAct.sa_sigaction
2807                   ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)
2808                   : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
2809   assert(oldhand2 == oldhand, &quot;no concurrent signal handler installation&quot;);
2810 }
2811 
2812 // install signal handlers for signals that HotSpot needs to
2813 // handle in order to support Java-level exception handling.
2814 
2815 void os::Bsd::install_signal_handlers() {
2816   if (!signal_handlers_are_installed) {
2817     signal_handlers_are_installed = true;
2818 
2819     // signal-chaining
2820     typedef void (*signal_setting_t)();
2821     signal_setting_t begin_signal_setting = NULL;
2822     signal_setting_t end_signal_setting = NULL;
2823     begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,
2824                                           dlsym(RTLD_DEFAULT, &quot;JVM_begin_signal_setting&quot;));
2825     if (begin_signal_setting != NULL) {
2826       end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,
2827                                           dlsym(RTLD_DEFAULT, &quot;JVM_end_signal_setting&quot;));
2828       get_signal_action = CAST_TO_FN_PTR(get_signal_t,
2829                                          dlsym(RTLD_DEFAULT, &quot;JVM_get_signal_action&quot;));
2830       libjsig_is_loaded = true;
2831       assert(UseSignalChaining, &quot;should enable signal-chaining&quot;);
2832     }
2833     if (libjsig_is_loaded) {
2834       // Tell libjsig jvm is setting signal handlers
2835       (*begin_signal_setting)();
2836     }
2837 
2838     set_signal_handler(SIGSEGV, true);
2839     set_signal_handler(SIGPIPE, true);
2840     set_signal_handler(SIGBUS, true);
2841     set_signal_handler(SIGILL, true);
2842     set_signal_handler(SIGFPE, true);
2843     set_signal_handler(SIGXFSZ, true);
2844 
2845 #if defined(__APPLE__)
2846     // In Mac OS X 10.4, CrashReporter will write a crash log for all &#39;fatal&#39; signals, including
2847     // signals caught and handled by the JVM. To work around this, we reset the mach task
2848     // signal handler that&#39;s placed on our process by CrashReporter. This disables
2849     // CrashReporter-based reporting.
2850     //
2851     // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
2852     // on caught fatal signals.
2853     //
2854     // Additionally, gdb installs both standard BSD signal handlers, and mach exception
2855     // handlers. By replacing the existing task exception handler, we disable gdb&#39;s mach
2856     // exception handling, while leaving the standard BSD signal handlers functional.
2857     kern_return_t kr;
2858     kr = task_set_exception_ports(mach_task_self(),
2859                                   EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
2860                                   MACH_PORT_NULL,
2861                                   EXCEPTION_STATE_IDENTITY,
2862                                   MACHINE_THREAD_STATE);
2863 
2864     assert(kr == KERN_SUCCESS, &quot;could not set mach task signal handler&quot;);
2865 #endif
2866 
2867     if (libjsig_is_loaded) {
2868       // Tell libjsig jvm finishes setting signal handlers
2869       (*end_signal_setting)();
2870     }
2871 
2872     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
2873     // and if UserSignalHandler is installed all bets are off
2874     if (CheckJNICalls) {
2875       if (libjsig_is_loaded) {
<a name="51" id="anc51"></a><span class="line-modified">2876         if (PrintJNIResolving) {</span>
<span class="line-removed">2877           tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">2878         }</span>
2879         check_signals = false;
2880       }
2881       if (AllowUserSignalHandlers) {
<a name="52" id="anc52"></a><span class="line-modified">2882         if (PrintJNIResolving) {</span>
<span class="line-removed">2883           tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">2884         }</span>
2885         check_signals = false;
2886       }
2887     }
2888   }
2889 }
2890 
2891 
2892 /////
2893 // glibc on Bsd platform uses non-documented flag
2894 // to indicate, that some special sort of signal
2895 // trampoline is used.
2896 // We will never set this flag, and we should
2897 // ignore this flag in our diagnostic
2898 #ifdef SIGNIFICANT_SIGNAL_MASK
2899   #undef SIGNIFICANT_SIGNAL_MASK
2900 #endif
2901 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
2902 
2903 static const char* get_signal_handler_name(address handler,
2904                                            char* buf, int buflen) {
2905   int offset;
2906   bool found = os::dll_address_to_library_name(handler, buf, buflen, &amp;offset);
2907   if (found) {
2908     // skip directory names
2909     const char *p1, *p2;
2910     p1 = buf;
2911     size_t len = strlen(os::file_separator());
2912     while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;
2913     jio_snprintf(buf, buflen, &quot;%s+0x%x&quot;, p1, offset);
2914   } else {
2915     jio_snprintf(buf, buflen, PTR_FORMAT, handler);
2916   }
2917   return buf;
2918 }
2919 
2920 static void print_signal_handler(outputStream* st, int sig,
2921                                  char* buf, size_t buflen) {
2922   struct sigaction sa;
2923 
2924   sigaction(sig, NULL, &amp;sa);
2925 
2926   // See comment for SIGNIFICANT_SIGNAL_MASK define
2927   sa.sa_flags &amp;= SIGNIFICANT_SIGNAL_MASK;
2928 
2929   st-&gt;print(&quot;%s: &quot;, os::exception_name(sig, buf, buflen));
2930 
2931   address handler = (sa.sa_flags &amp; SA_SIGINFO)
2932     ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)
2933     : CAST_FROM_FN_PTR(address, sa.sa_handler);
2934 
2935   if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {
2936     st-&gt;print(&quot;SIG_DFL&quot;);
2937   } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {
2938     st-&gt;print(&quot;SIG_IGN&quot;);
2939   } else {
2940     st-&gt;print(&quot;[%s]&quot;, get_signal_handler_name(handler, buf, buflen));
2941   }
2942 
2943   st-&gt;print(&quot;, sa_mask[0]=&quot;);
2944   os::Posix::print_signal_set_short(st, &amp;sa.sa_mask);
2945 
2946   address rh = VMError::get_resetted_sighandler(sig);
2947   // May be, handler was resetted by VMError?
2948   if (rh != NULL) {
2949     handler = rh;
2950     sa.sa_flags = VMError::get_resetted_sigflags(sig) &amp; SIGNIFICANT_SIGNAL_MASK;
2951   }
2952 
2953   st-&gt;print(&quot;, sa_flags=&quot;);
2954   os::Posix::print_sa_flags(st, sa.sa_flags);
2955 
2956   // Check: is it our handler?
2957   if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||
2958       handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {
2959     // It is our signal handler
2960     // check for flags, reset system-used one!
2961     if ((int)sa.sa_flags != os::Bsd::get_our_sigflags(sig)) {
2962       st-&gt;print(
2963                 &quot;, flags was changed from &quot; PTR32_FORMAT &quot;, consider using jsig library&quot;,
2964                 os::Bsd::get_our_sigflags(sig));
2965     }
2966   }
2967   st-&gt;cr();
2968 }
2969 
2970 
2971 #define DO_SIGNAL_CHECK(sig)                      \
2972   do {                                            \
2973     if (!sigismember(&amp;check_signal_done, sig)) {  \
2974       os::Bsd::check_signal_handler(sig);         \
2975     }                                             \
2976   } while (0)
2977 
2978 // This method is a periodic task to check for misbehaving JNI applications
2979 // under CheckJNI, we can add any periodic checks here
2980 
2981 void os::run_periodic_checks() {
2982 
2983   if (check_signals == false) return;
2984 
2985   // SEGV and BUS if overridden could potentially prevent
2986   // generation of hs*.log in the event of a crash, debugging
2987   // such a case can be very challenging, so we absolutely
2988   // check the following for a good measure:
2989   DO_SIGNAL_CHECK(SIGSEGV);
2990   DO_SIGNAL_CHECK(SIGILL);
2991   DO_SIGNAL_CHECK(SIGFPE);
2992   DO_SIGNAL_CHECK(SIGBUS);
2993   DO_SIGNAL_CHECK(SIGPIPE);
2994   DO_SIGNAL_CHECK(SIGXFSZ);
2995 
2996 
2997   // ReduceSignalUsage allows the user to override these handlers
2998   // see comments at the very top and jvm_md.h
2999   if (!ReduceSignalUsage) {
3000     DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);
3001     DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);
3002     DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);
3003     DO_SIGNAL_CHECK(BREAK_SIGNAL);
3004   }
3005 
3006   DO_SIGNAL_CHECK(SR_signum);
3007 }
3008 
3009 typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);
3010 
3011 static os_sigaction_t os_sigaction = NULL;
3012 
3013 void os::Bsd::check_signal_handler(int sig) {
3014   char buf[O_BUFLEN];
3015   address jvmHandler = NULL;
3016 
3017 
3018   struct sigaction act;
3019   if (os_sigaction == NULL) {
3020     // only trust the default sigaction, in case it has been interposed
3021     os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, &quot;sigaction&quot;);
3022     if (os_sigaction == NULL) return;
3023   }
3024 
3025   os_sigaction(sig, (struct sigaction*)NULL, &amp;act);
3026 
3027 
3028   act.sa_flags &amp;= SIGNIFICANT_SIGNAL_MASK;
3029 
3030   address thisHandler = (act.sa_flags &amp; SA_SIGINFO)
3031     ? CAST_FROM_FN_PTR(address, act.sa_sigaction)
3032     : CAST_FROM_FN_PTR(address, act.sa_handler);
3033 
3034 
3035   switch (sig) {
3036   case SIGSEGV:
3037   case SIGBUS:
3038   case SIGFPE:
3039   case SIGPIPE:
3040   case SIGILL:
3041   case SIGXFSZ:
3042     jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);
3043     break;
3044 
3045   case SHUTDOWN1_SIGNAL:
3046   case SHUTDOWN2_SIGNAL:
3047   case SHUTDOWN3_SIGNAL:
3048   case BREAK_SIGNAL:
3049     jvmHandler = (address)user_handler();
3050     break;
3051 
3052   default:
3053     if (sig == SR_signum) {
3054       jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);
3055     } else {
3056       return;
3057     }
3058     break;
3059   }
3060 
3061   if (thisHandler != jvmHandler) {
3062     tty-&gt;print(&quot;Warning: %s handler &quot;, exception_name(sig, buf, O_BUFLEN));
3063     tty-&gt;print(&quot;expected:%s&quot;, get_signal_handler_name(jvmHandler, buf, O_BUFLEN));
3064     tty-&gt;print_cr(&quot;  found:%s&quot;, get_signal_handler_name(thisHandler, buf, O_BUFLEN));
3065     // No need to check this sig any longer
3066     sigaddset(&amp;check_signal_done, sig);
3067     // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN
3068     if (sig == SHUTDOWN2_SIGNAL &amp;&amp; !isatty(fileno(stdin))) {
3069       tty-&gt;print_cr(&quot;Running in non-interactive shell, %s handler is replaced by shell&quot;,
3070                     exception_name(sig, buf, O_BUFLEN));
3071     }
3072   } else if(os::Bsd::get_our_sigflags(sig) != 0 &amp;&amp; (int)act.sa_flags != os::Bsd::get_our_sigflags(sig)) {
3073     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
3074     tty-&gt;print(&quot;expected:&quot;);
3075     os::Posix::print_sa_flags(tty, os::Bsd::get_our_sigflags(sig));
3076     tty-&gt;cr();
3077     tty-&gt;print(&quot;  found:&quot;);
3078     os::Posix::print_sa_flags(tty, act.sa_flags);
3079     tty-&gt;cr();
3080     // No need to check this sig any longer
3081     sigaddset(&amp;check_signal_done, sig);
3082   }
3083 
3084   // Dump all the signal
3085   if (sigismember(&amp;check_signal_done, sig)) {
3086     print_signal_handlers(tty, buf, O_BUFLEN);
3087   }
3088 }
3089 
3090 extern void report_error(char* file_name, int line_no, char* title,
3091                          char* format, ...);
3092 
3093 // this is called _before_ the most of global arguments have been parsed
3094 void os::init(void) {
3095   char dummy;   // used to get a guess on initial stack address
3096 
<a name="53" id="anc53"></a><span class="line-removed">3097   // With BsdThreads the JavaMain thread pid (primordial thread)</span>
<span class="line-removed">3098   // is different than the pid of the java launcher thread.</span>
<span class="line-removed">3099   // So, on Bsd, the launcher thread pid is passed to the VM</span>
<span class="line-removed">3100   // via the sun.java.launcher.pid property.</span>
<span class="line-removed">3101   // Use this property instead of getpid() if it was correctly passed.</span>
<span class="line-removed">3102   // See bug 6351349.</span>
<span class="line-removed">3103   pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();</span>
<span class="line-removed">3104 </span>
<span class="line-removed">3105   _initial_pid = (java_launcher_pid &gt; 0) ? java_launcher_pid : getpid();</span>
<span class="line-removed">3106 </span>
3107   clock_tics_per_sec = CLK_TCK;
3108 
3109   init_random(1234567);
3110 
3111   Bsd::set_page_size(getpagesize());
3112   if (Bsd::page_size() == -1) {
3113     fatal(&quot;os_bsd.cpp: os::init: sysconf failed (%s)&quot;, os::strerror(errno));
3114   }
3115   init_page_sizes((size_t) Bsd::page_size());
3116 
3117   Bsd::initialize_system_info();
3118 
3119   // _main_thread points to the thread that created/loaded the JVM.
3120   Bsd::_main_thread = pthread_self();
3121 
3122   Bsd::clock_init();
3123   initial_time_count = javaTimeNanos();
3124 
3125   os::Posix::init();
3126 }
3127 
3128 // To install functions for atexit system call
3129 extern &quot;C&quot; {
3130   static void perfMemory_exit_helper() {
3131     perfMemory_exit();
3132   }
3133 }
3134 
3135 // this is called _after_ the global arguments have been parsed
3136 jint os::init_2(void) {
3137 
3138   // This could be set after os::Posix::init() but all platforms
3139   // have to set it the same so we have to mirror Solaris.
3140   DEBUG_ONLY(os::set_mutex_init_done();)
3141 
3142   os::Posix::init_2();
3143 
3144   // initialize suspend/resume support - must do this before signal_sets_init()
3145   if (SR_initialize() != 0) {
3146     perror(&quot;SR_initialize failed&quot;);
3147     return JNI_ERR;
3148   }
3149 
3150   Bsd::signal_sets_init();
3151   Bsd::install_signal_handlers();
3152   // Initialize data for jdk.internal.misc.Signal
3153   if (!ReduceSignalUsage) {
3154     jdk_misc_signal_init();
3155   }
3156 
3157   // Check and sets minimum stack sizes against command line options
3158   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
3159     return JNI_ERR;
3160   }
3161 
3162   if (MaxFDLimit) {
3163     // set the number of file descriptors to max. print out error
3164     // if getrlimit/setrlimit fails but continue regardless.
3165     struct rlimit nbr_files;
3166     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
3167     if (status != 0) {
3168       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
3169     } else {
3170       nbr_files.rlim_cur = nbr_files.rlim_max;
3171 
3172 #ifdef __APPLE__
3173       // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if
3174       // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must
3175       // be used instead
3176       nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);
3177 #endif
3178 
3179       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
3180       if (status != 0) {
3181         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
3182       }
3183     }
3184   }
3185 
3186   // at-exit methods are called in the reverse order of their registration.
3187   // atexit functions are called on return from main or as a result of a
3188   // call to exit(3C). There can be only 32 of these functions registered
3189   // and atexit() does not set errno.
3190 
3191   if (PerfAllowAtExitRegistration) {
3192     // only register atexit functions if PerfAllowAtExitRegistration is set.
3193     // atexit functions can be delayed until process exit time, which
3194     // can be problematic for embedded VM situations. Embedded VMs should
3195     // call DestroyJavaVM() to assure that VM resources are released.
3196 
3197     // note: perfMemory_exit_helper atexit function may be removed in
3198     // the future if the appropriate cleanup code can be added to the
3199     // VM_Exit VMOperation&#39;s doit method.
3200     if (atexit(perfMemory_exit_helper) != 0) {
3201       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
3202     }
3203   }
3204 
3205   // initialize thread priority policy
3206   prio_init();
3207 
3208 #ifdef __APPLE__
3209   // dynamically link to objective c gc registration
3210   void *handleLibObjc = dlopen(OBJC_LIB, RTLD_LAZY);
3211   if (handleLibObjc != NULL) {
3212     objc_registerThreadWithCollectorFunction = (objc_registerThreadWithCollector_t) dlsym(handleLibObjc, OBJC_GCREGISTER);
3213   }
3214 #endif
3215 
3216   return JNI_OK;
3217 }
3218 
3219 // Mark the polling page as unreadable
3220 void os::make_polling_page_unreadable(void) {
3221   if (!guard_memory((char*)_polling_page, Bsd::page_size())) {
3222     fatal(&quot;Could not disable polling page&quot;);
3223   }
3224 }
3225 
3226 // Mark the polling page as readable
3227 void os::make_polling_page_readable(void) {
3228   if (!bsd_mprotect((char *)_polling_page, Bsd::page_size(), PROT_READ)) {
3229     fatal(&quot;Could not enable polling page&quot;);
3230   }
3231 }
3232 
3233 int os::active_processor_count() {
3234   // User has overridden the number of active processors
3235   if (ActiveProcessorCount &gt; 0) {
3236     log_trace(os)(&quot;active_processor_count: &quot;
3237                   &quot;active processor count set by user : %d&quot;,
3238                   ActiveProcessorCount);
3239     return ActiveProcessorCount;
3240   }
3241 
3242   return _processor_count;
3243 }
3244 
<a name="54" id="anc54"></a>







































































3245 void os::set_native_thread_name(const char *name) {
3246 #if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5
3247   // This is only supported in Snow Leopard and beyond
3248   if (name != NULL) {
3249     // Add a &quot;Java: &quot; prefix to the name
3250     char buf[MAXTHREADNAMESIZE];
3251     snprintf(buf, sizeof(buf), &quot;Java: %s&quot;, name);
3252     pthread_setname_np(buf);
3253   }
3254 #endif
3255 }
3256 
<a name="55" id="anc55"></a><span class="line-removed">3257 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">3258   // Not yet implemented.</span>
<span class="line-removed">3259   return false;</span>
<span class="line-removed">3260 }</span>
<span class="line-removed">3261 </span>
3262 bool os::bind_to_processor(uint processor_id) {
3263   // Not yet implemented.
3264   return false;
3265 }
3266 
3267 void os::SuspendedThreadTask::internal_do_task() {
3268   if (do_suspend(_thread-&gt;osthread())) {
3269     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3270     do_task(context);
3271     do_resume(_thread-&gt;osthread());
3272   }
3273 }
3274 
3275 ////////////////////////////////////////////////////////////////////////////////
3276 // debug support
3277 
3278 bool os::find(address addr, outputStream* st) {
3279   Dl_info dlinfo;
3280   memset(&amp;dlinfo, 0, sizeof(dlinfo));
3281   if (dladdr(addr, &amp;dlinfo) != 0) {
3282     st-&gt;print(INTPTR_FORMAT &quot;: &quot;, (intptr_t)addr);
3283     if (dlinfo.dli_sname != NULL &amp;&amp; dlinfo.dli_saddr != NULL) {
3284       st-&gt;print(&quot;%s+%#x&quot;, dlinfo.dli_sname,
3285                 (uint)((uintptr_t)addr - (uintptr_t)dlinfo.dli_saddr));
3286     } else if (dlinfo.dli_fbase != NULL) {
3287       st-&gt;print(&quot;&lt;offset %#x&gt;&quot;, (uint)((uintptr_t)addr - (uintptr_t)dlinfo.dli_fbase));
3288     } else {
3289       st-&gt;print(&quot;&lt;absolute address&gt;&quot;);
3290     }
3291     if (dlinfo.dli_fname != NULL) {
3292       st-&gt;print(&quot; in %s&quot;, dlinfo.dli_fname);
3293     }
3294     if (dlinfo.dli_fbase != NULL) {
3295       st-&gt;print(&quot; at &quot; INTPTR_FORMAT, (intptr_t)dlinfo.dli_fbase);
3296     }
3297     st-&gt;cr();
3298 
3299     if (Verbose) {
3300       // decode some bytes around the PC
3301       address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());
3302       address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());
3303       address       lowest = (address) dlinfo.dli_sname;
3304       if (!lowest)  lowest = (address) dlinfo.dli_fbase;
3305       if (begin &lt; lowest)  begin = lowest;
3306       Dl_info dlinfo2;
3307       if (dladdr(end, &amp;dlinfo2) != 0 &amp;&amp; dlinfo2.dli_saddr != dlinfo.dli_saddr
3308           &amp;&amp; end &gt; dlinfo2.dli_saddr &amp;&amp; dlinfo2.dli_saddr &gt; begin) {
3309         end = (address) dlinfo2.dli_saddr;
3310       }
3311       Disassembler::decode(begin, end, st);
3312     }
3313     return true;
3314   }
3315   return false;
3316 }
3317 
3318 ////////////////////////////////////////////////////////////////////////////////
3319 // misc
3320 
3321 // This does not do anything on Bsd. This is basically a hook for being
3322 // able to use structured exception handling (thread-local exception filters)
3323 // on, e.g., Win32.
3324 void os::os_exception_wrapper(java_call_t f, JavaValue* value,
3325                               const methodHandle&amp; method, JavaCallArguments* args,
3326                               Thread* thread) {
3327   f(value, method, args, thread);
3328 }
3329 
3330 void os::print_statistics() {
3331 }
3332 
3333 bool os::message_box(const char* title, const char* message) {
3334   int i;
3335   fdStream err(defaultStream::error_fd());
3336   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;=&quot;);
3337   err.cr();
3338   err.print_raw_cr(title);
3339   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;-&quot;);
3340   err.cr();
3341   err.print_raw_cr(message);
3342   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;=&quot;);
3343   err.cr();
3344 
3345   char buf[16];
3346   // Prevent process from exiting upon &quot;read error&quot; without consuming all CPU
3347   while (::read(0, buf, sizeof(buf)) &lt;= 0) { ::sleep(100); }
3348 
3349   return buf[0] == &#39;y&#39; || buf[0] == &#39;Y&#39;;
3350 }
3351 
3352 static inline struct timespec get_mtime(const char* filename) {
3353   struct stat st;
3354   int ret = os::stat(filename, &amp;st);
3355   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
3356 #ifdef __APPLE__
3357   return st.st_mtimespec;
3358 #else
3359   return st.st_mtim;
3360 #endif
3361 }
3362 
3363 int os::compare_file_modified_times(const char* file1, const char* file2) {
3364   struct timespec filetime1 = get_mtime(file1);
3365   struct timespec filetime2 = get_mtime(file2);
3366   int diff = filetime1.tv_sec - filetime2.tv_sec;
3367   if (diff == 0) {
3368     return filetime1.tv_nsec - filetime2.tv_nsec;
3369   }
3370   return diff;
3371 }
3372 
3373 // Is a (classpath) directory empty?
3374 bool os::dir_is_empty(const char* path) {
3375   DIR *dir = NULL;
3376   struct dirent *ptr;
3377 
3378   dir = opendir(path);
3379   if (dir == NULL) return true;
3380 
3381   // Scan the directory
3382   bool result = true;
3383   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
3384     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
3385       result = false;
3386     }
3387   }
3388   closedir(dir);
3389   return result;
3390 }
3391 
3392 // This code originates from JDK&#39;s sysOpen and open64_w
3393 // from src/solaris/hpi/src/system_md.c
3394 
3395 int os::open(const char *path, int oflag, int mode) {
3396   if (strlen(path) &gt; MAX_PATH - 1) {
3397     errno = ENAMETOOLONG;
3398     return -1;
3399   }
3400   int fd;
3401 
3402   fd = ::open(path, oflag, mode);
3403   if (fd == -1) return -1;
3404 
3405   // If the open succeeded, the file might still be a directory
3406   {
3407     struct stat buf;
3408     int ret = ::fstat(fd, &amp;buf);
3409     int st_mode = buf.st_mode;
3410 
3411     if (ret != -1) {
3412       if ((st_mode &amp; S_IFMT) == S_IFDIR) {
3413         errno = EISDIR;
3414         ::close(fd);
3415         return -1;
3416       }
3417     } else {
3418       ::close(fd);
3419       return -1;
3420     }
3421   }
3422 
3423   // All file descriptors that are opened in the JVM and not
3424   // specifically destined for a subprocess should have the
3425   // close-on-exec flag set.  If we don&#39;t set it, then careless 3rd
3426   // party native code might fork and exec without closing all
3427   // appropriate file descriptors (e.g. as we do in closeDescriptors in
3428   // UNIXProcess.c), and this in turn might:
3429   //
3430   // - cause end-of-file to fail to be detected on some file
3431   //   descriptors, resulting in mysterious hangs, or
3432   //
3433   // - might cause an fopen in the subprocess to fail on a system
3434   //   suffering from bug 1085341.
3435   //
3436   // (Yes, the default setting of the close-on-exec flag is a Unix
3437   // design flaw)
3438   //
3439   // See:
3440   // 1085341: 32-bit stdio routines should support file descriptors &gt;255
3441   // 4843136: (process) pipe file descriptor from Runtime.exec not being closed
3442   // 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9
3443   //
3444 #ifdef FD_CLOEXEC
3445   {
3446     int flags = ::fcntl(fd, F_GETFD);
3447     if (flags != -1) {
3448       ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
3449     }
3450   }
3451 #endif
3452 
3453   return fd;
3454 }
3455 
3456 
3457 // create binary file, rewriting existing file if required
3458 int os::create_binary_file(const char* path, bool rewrite_existing) {
3459   int oflags = O_WRONLY | O_CREAT;
3460   if (!rewrite_existing) {
3461     oflags |= O_EXCL;
3462   }
3463   return ::open(path, oflags, S_IREAD | S_IWRITE);
3464 }
3465 
3466 // return current position of file pointer
3467 jlong os::current_file_offset(int fd) {
3468   return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
3469 }
3470 
3471 // move file pointer to the specified offset
3472 jlong os::seek_to_file_offset(int fd, jlong offset) {
3473   return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
3474 }
3475 
3476 // This code originates from JDK&#39;s sysAvailable
3477 // from src/solaris/hpi/src/native_threads/src/sys_api_td.c
3478 
3479 int os::available(int fd, jlong *bytes) {
3480   jlong cur, end;
3481   int mode;
3482   struct stat buf;
3483 
3484   if (::fstat(fd, &amp;buf) &gt;= 0) {
3485     mode = buf.st_mode;
3486     if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {
3487       int n;
3488       if (::ioctl(fd, FIONREAD, &amp;n) &gt;= 0) {
3489         *bytes = n;
3490         return 1;
3491       }
3492     }
3493   }
3494   if ((cur = ::lseek(fd, 0L, SEEK_CUR)) == -1) {
3495     return 0;
3496   } else if ((end = ::lseek(fd, 0L, SEEK_END)) == -1) {
3497     return 0;
3498   } else if (::lseek(fd, cur, SEEK_SET) == -1) {
3499     return 0;
3500   }
3501   *bytes = end - cur;
3502   return 1;
3503 }
3504 
3505 // Map a block of memory.
3506 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
3507                         char *addr, size_t bytes, bool read_only,
3508                         bool allow_exec) {
3509   int prot;
3510   int flags;
3511 
3512   if (read_only) {
3513     prot = PROT_READ;
3514     flags = MAP_SHARED;
3515   } else {
3516     prot = PROT_READ | PROT_WRITE;
3517     flags = MAP_PRIVATE;
3518   }
3519 
3520   if (allow_exec) {
3521     prot |= PROT_EXEC;
3522   }
3523 
3524   if (addr != NULL) {
3525     flags |= MAP_FIXED;
3526   }
3527 
3528   char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,
3529                                      fd, file_offset);
3530   if (mapped_address == MAP_FAILED) {
3531     return NULL;
3532   }
3533   return mapped_address;
3534 }
3535 
3536 
3537 // Remap a block of memory.
3538 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
3539                           char *addr, size_t bytes, bool read_only,
3540                           bool allow_exec) {
3541   // same as map_memory() on this OS
3542   return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,
3543                         allow_exec);
3544 }
3545 
3546 
3547 // Unmap a block of memory.
3548 bool os::pd_unmap_memory(char* addr, size_t bytes) {
3549   return munmap(addr, bytes) == 0;
3550 }
3551 
3552 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
3553 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
3554 // of a thread.
3555 //
3556 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
3557 // the fast estimate available on the platform.
3558 
3559 jlong os::current_thread_cpu_time() {
3560 #ifdef __APPLE__
3561   return os::thread_cpu_time(Thread::current(), true /* user + sys */);
3562 #else
3563   Unimplemented();
3564   return 0;
3565 #endif
3566 }
3567 
3568 jlong os::thread_cpu_time(Thread* thread) {
3569 #ifdef __APPLE__
3570   return os::thread_cpu_time(thread, true /* user + sys */);
3571 #else
3572   Unimplemented();
3573   return 0;
3574 #endif
3575 }
3576 
3577 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
3578 #ifdef __APPLE__
3579   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
3580 #else
3581   Unimplemented();
3582   return 0;
3583 #endif
3584 }
3585 
3586 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
3587 #ifdef __APPLE__
3588   struct thread_basic_info tinfo;
3589   mach_msg_type_number_t tcount = THREAD_INFO_MAX;
3590   kern_return_t kr;
3591   thread_t mach_thread;
3592 
3593   mach_thread = thread-&gt;osthread()-&gt;thread_id();
3594   kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&amp;tinfo, &amp;tcount);
3595   if (kr != KERN_SUCCESS) {
3596     return -1;
3597   }
3598 
3599   if (user_sys_cpu_time) {
3600     jlong nanos;
3601     nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;
3602     nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;
3603     return nanos;
3604   } else {
3605     return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
3606   }
3607 #else
3608   Unimplemented();
3609   return 0;
3610 #endif
3611 }
3612 
3613 
3614 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
3615   info_ptr-&gt;max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
3616   info_ptr-&gt;may_skip_backward = false;     // elapsed time not wall time
3617   info_ptr-&gt;may_skip_forward = false;      // elapsed time not wall time
3618   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned
3619 }
3620 
3621 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
3622   info_ptr-&gt;max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
3623   info_ptr-&gt;may_skip_backward = false;     // elapsed time not wall time
3624   info_ptr-&gt;may_skip_forward = false;      // elapsed time not wall time
3625   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned
3626 }
3627 
3628 bool os::is_thread_cpu_time_supported() {
3629 #ifdef __APPLE__
3630   return true;
3631 #else
3632   return false;
3633 #endif
3634 }
3635 
3636 // System loadavg support.  Returns -1 if load average cannot be obtained.
3637 // Bsd doesn&#39;t yet have a (official) notion of processor sets,
3638 // so just return the system wide load average.
3639 int os::loadavg(double loadavg[], int nelem) {
3640   return ::getloadavg(loadavg, nelem);
3641 }
3642 
3643 void os::pause() {
3644   char filename[MAX_PATH];
3645   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<a name="56" id="anc56"></a><span class="line-modified">3646     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
3647   } else {
3648     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
3649   }
3650 
3651   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
3652   if (fd != -1) {
3653     struct stat buf;
3654     ::close(fd);
3655     while (::stat(filename, &amp;buf) == 0) {
3656       (void)::poll(NULL, 0, 100);
3657     }
3658   } else {
3659     jio_fprintf(stderr,
3660                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
3661   }
3662 }
3663 
3664 // Darwin has no &quot;environ&quot; in a dynamic library.
3665 #ifdef __APPLE__
3666   #include &lt;crt_externs.h&gt;
3667   #define environ (*_NSGetEnviron())
3668 #else
3669 extern char** environ;
3670 #endif
3671 
3672 // Run the specified command in a separate process. Return its exit value,
3673 // or -1 on failure (e.g. can&#39;t fork a new process).
3674 // Unlike system(), this function can be called from signal handler. It
3675 // doesn&#39;t block SIGINT et al.
3676 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
3677   const char * argv[4] = {&quot;sh&quot;, &quot;-c&quot;, cmd, NULL};
3678 
3679   // fork() in BsdThreads/NPTL is not async-safe. It needs to run
3680   // pthread_atfork handlers and reset pthread library. All we need is a
3681   // separate process to execve. Make a direct syscall to fork process.
3682   // On IA64 there&#39;s no fork syscall, we have to use fork() and hope for
3683   // the best...
3684   pid_t pid = fork();
3685 
3686   if (pid &lt; 0) {
3687     // fork failed
3688     return -1;
3689 
3690   } else if (pid == 0) {
3691     // child process
3692 
3693     // execve() in BsdThreads will call pthread_kill_other_threads_np()
3694     // first to kill every thread on the thread list. Because this list is
3695     // not reset by fork() (see notes above), execve() will instead kill
3696     // every thread in the parent process. We know this is the only thread
3697     // in the new process, so make a system call directly.
3698     // IA64 should use normal execve() from glibc to match the glibc fork()
3699     // above.
3700     execve(&quot;/bin/sh&quot;, (char* const*)argv, environ);
3701 
3702     // execve failed
3703     _exit(-1);
3704 
3705   } else  {
3706     // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don&#39;t
3707     // care about the actual exit code, for now.
3708 
3709     int status;
3710 
3711     // Wait for the child process to exit.  This returns immediately if
3712     // the child has already exited. */
3713     while (waitpid(pid, &amp;status, 0) &lt; 0) {
3714       switch (errno) {
3715       case ECHILD: return 0;
3716       case EINTR: break;
3717       default: return -1;
3718       }
3719     }
3720 
3721     if (WIFEXITED(status)) {
3722       // The child exited normally; get its exit code.
3723       return WEXITSTATUS(status);
3724     } else if (WIFSIGNALED(status)) {
3725       // The child exited because of a signal
3726       // The best value to return is 0x80 + signal number,
3727       // because that is what all Unix shells do, and because
3728       // it allows callers to distinguish between process exit and
3729       // process death by signal.
3730       return 0x80 + WTERMSIG(status);
3731     } else {
3732       // Unknown exit code; pass it through
3733       return status;
3734     }
3735   }
3736 }
3737 
<a name="57" id="anc57"></a><span class="line-modified">3738 // Get the default path to the core file</span>
3739 // Returns the length of the string
3740 int os::get_core_path(char* buffer, size_t bufferSize) {
<a name="58" id="anc58"></a><span class="line-modified">3741   int n = jio_snprintf(buffer, bufferSize, &quot;/cores/core.%d&quot;, current_process_id());</span>
<span class="line-modified">3742 </span>



















3743   // Truncate if theoretical string was longer than bufferSize
3744   n = MIN2(n, (int)bufferSize);
3745 
3746   return n;
3747 }
3748 
<a name="59" id="anc59"></a>



3749 #ifndef PRODUCT
3750 void TestReserveMemorySpecial_test() {
3751   // No tests available for this platform
3752 }
3753 #endif
3754 
3755 bool os::start_debugging(char *buf, int buflen) {
3756   int len = (int)strlen(buf);
3757   char *p = &amp;buf[len];
3758 
3759   jio_snprintf(p, buflen-len,
3760              &quot;\n\n&quot;
3761              &quot;Do you want to debug the problem?\n\n&quot;
3762              &quot;To debug, run &#39;gdb /proc/%d/exe %d&#39;; then switch to thread &quot; INTX_FORMAT &quot; (&quot; INTPTR_FORMAT &quot;)\n&quot;
3763              &quot;Enter &#39;yes&#39; to launch gdb automatically (PATH must include gdb)\n&quot;
3764              &quot;Otherwise, press RETURN to abort...&quot;,
3765              os::current_process_id(), os::current_process_id(),
3766              os::current_thread_id(), os::current_thread_id());
3767 
3768   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
3769 
3770   if (yes) {
3771     // yes, user asked VM to launch debugger
3772     jio_snprintf(buf, sizeof(buf), &quot;gdb /proc/%d/exe %d&quot;,
3773                      os::current_process_id(), os::current_process_id());
3774 
3775     os::fork_and_exec(buf);
3776     yes = false;
3777   }
3778   return yes;
3779 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
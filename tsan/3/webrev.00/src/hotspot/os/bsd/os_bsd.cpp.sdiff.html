<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osThread_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/os_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;

  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/filemap.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;os_bsd.inline.hpp&quot;
  40 #include &quot;os_posix.inline.hpp&quot;
  41 #include &quot;os_share_bsd.hpp&quot;
  42 #include &quot;prims/jniFastGetField.hpp&quot;
  43 #include &quot;prims/jvm_misc.hpp&quot;
  44 #include &quot;runtime/arguments.hpp&quot;
  45 #include &quot;runtime/atomic.hpp&quot;
  46 #include &quot;runtime/extendedPC.hpp&quot;
  47 #include &quot;runtime/globals.hpp&quot;
  48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/mutexLocker.hpp&quot;
  52 #include &quot;runtime/objectMonitor.hpp&quot;
<span class="line-removed">  53 #include &quot;runtime/orderAccess.hpp&quot;</span>
  54 #include &quot;runtime/osThread.hpp&quot;
  55 #include &quot;runtime/perfMemory.hpp&quot;
  56 #include &quot;runtime/semaphore.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadCritical.hpp&quot;
  62 #include &quot;runtime/timer.hpp&quot;
  63 #include &quot;services/attachListener.hpp&quot;
  64 #include &quot;services/memTracker.hpp&quot;
  65 #include &quot;services/runtimeService.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/decoder.hpp&quot;
  68 #include &quot;utilities/defaultStream.hpp&quot;
  69 #include &quot;utilities/events.hpp&quot;
  70 #include &quot;utilities/growableArray.hpp&quot;
  71 #include &quot;utilities/vmError.hpp&quot;
  72 
  73 // put OS-includes here
</pre>
<hr />
<pre>
 118 // global variables
 119 julong os::Bsd::_physical_memory = 0;
 120 
 121 #ifdef __APPLE__
 122 mach_timebase_info_data_t os::Bsd::_timebase_info = {0, 0};
 123 volatile uint64_t         os::Bsd::_max_abstime   = 0;
 124 #else
 125 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
 126 #endif
 127 pthread_t os::Bsd::_main_thread;
 128 int os::Bsd::_page_size = -1;
 129 
 130 static jlong initial_time_count=0;
 131 
 132 static int clock_tics_per_sec = 100;
 133 
 134 // For diagnostics to print a message once. see run_periodic_checks
 135 static sigset_t check_signal_done;
 136 static bool check_signals = true;
 137 
<span class="line-removed"> 138 static pid_t _initial_pid = 0;</span>
<span class="line-removed"> 139 </span>
 140 // Signal number used to suspend/resume a thread
 141 
 142 // do not use any signal number less than SIGSEGV, see 4355769
 143 static int SR_signum = SIGUSR2;
 144 sigset_t SR_sigset;
 145 
 146 
 147 ////////////////////////////////////////////////////////////////////////////////
 148 // utility functions
 149 
 150 static int SR_initialize();
 151 
 152 julong os::available_memory() {
 153   return Bsd::available_memory();
 154 }
 155 
 156 // available here means free
 157 julong os::Bsd::available_memory() {
 158   uint64_t available = physical_memory() &gt;&gt; 2;
 159 #ifdef __APPLE__
 160   mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;
 161   vm_statistics64_data_t vmstat;
 162   kern_return_t kerr = host_statistics64(mach_host_self(), HOST_VM_INFO64,
 163                                          (host_info64_t)&amp;vmstat, &amp;count);
 164   assert(kerr == KERN_SUCCESS,
 165          &quot;host_statistics64 failed - check mach_host_self() and count&quot;);
 166   if (kerr == KERN_SUCCESS) {
 167     available = vmstat.free_count * os::vm_page_size();
 168   }
 169 #endif
 170   return available;
 171 }
 172 
















 173 julong os::physical_memory() {
 174   return Bsd::physical_memory();
 175 }
 176 
 177 // Return true if user is running as root.
 178 
 179 bool os::have_special_privileges() {
 180   static bool init = false;
 181   static bool privileges = false;
 182   if (!init) {
 183     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 184     init = true;
 185   }
 186   return privileges;
 187 }
 188 
 189 
 190 
 191 // Cpu architecture string
 192 #if   defined(ZERO)
</pre>
<hr />
<pre>
 319 #ifndef DEFAULT_LIBPATH
 320   #ifndef OVERRIDE_LIBPATH
 321     #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 322   #else
 323     #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 324   #endif
 325 #endif
 326 
 327 // Base path of extensions installed on the system.
 328 #define SYS_EXT_DIR     &quot;/usr/java/packages&quot;
 329 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 330 
 331 #ifndef __APPLE__
 332 
 333   // Buffer that fits several sprintfs.
 334   // Note that the space for the colon and the trailing null are provided
 335   // by the nulls included by the sizeof operator.
 336   const size_t bufsize =
 337     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 338          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 339   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 340 
 341   // sysclasspath, java_home, dll_dir
 342   {
 343     char *pslash;
 344     os::jvm_path(buf, bufsize);
 345 
 346     // Found the full path to libjvm.so.
 347     // Now cut the path to &lt;java_home&gt;/jre if we can.
 348     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 349     pslash = strrchr(buf, &#39;/&#39;);
 350     if (pslash != NULL) {
 351       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 352     }
 353     Arguments::set_dll_dir(buf);
 354 
 355     if (pslash != NULL) {
 356       pslash = strrchr(buf, &#39;/&#39;);
 357       if (pslash != NULL) {
 358         *pslash = &#39;\0&#39;;          // Get rid of /&lt;arch&gt;.
 359         pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 369   }
 370 
 371   // Where to look for native libraries.
 372   //
 373   // Note: Due to a legacy implementation, most of the library path
 374   // is set in the launcher. This was to accomodate linking restrictions
 375   // on legacy Bsd implementations (which are no longer supported).
 376   // Eventually, all the library path setting will be done here.
 377   //
 378   // However, to prevent the proliferation of improperly built native
 379   // libraries, the new path component /usr/java/packages is added here.
 380   // Eventually, all the library path setting will be done here.
 381   {
 382     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 383     // should always exist (until the legacy problem cited above is
 384     // addressed).
 385     const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
 386     const char *v_colon = &quot;:&quot;;
 387     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 388     // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 389     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 390                                                      strlen(v) + 1 +</span>
<span class="line-modified"> 391                                                      sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified"> 392                                                      mtInternal);</span>
 393     sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib/%s:&quot; DEFAULT_LIBPATH, v, v_colon, cpu_arch);
 394     Arguments::set_library_path(ld_library_path);
 395     FREE_C_HEAP_ARRAY(char, ld_library_path);
 396   }
 397 
 398   // Extensions directories.
 399   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());
 400   Arguments::set_ext_dirs(buf);
 401 
 402   FREE_C_HEAP_ARRAY(char, buf);
 403 
 404 #else // __APPLE__
 405 
 406   #define SYS_EXTENSIONS_DIR   &quot;/Library/Java/Extensions&quot;
 407   #define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR &quot;:/Network&quot; SYS_EXTENSIONS_DIR &quot;:/System&quot; SYS_EXTENSIONS_DIR &quot;:/usr/lib/java&quot;
 408 
 409   const char *user_home_dir = get_home();
 410   // The null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir.
 411   size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +
 412     sizeof(SYS_EXTENSIONS_DIRS);
 413 
 414   // Buffer that fits several sprintfs.
 415   // Note that the space for the colon and the trailing null are provided
 416   // by the nulls included by the sizeof operator.
 417   const size_t bufsize =
 418     MAX2((size_t)MAXPATHLEN,  // for dll_dir &amp; friends.
 419          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
<span class="line-modified"> 420   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 421 
 422   // sysclasspath, java_home, dll_dir
 423   {
 424     char *pslash;
 425     os::jvm_path(buf, bufsize);
 426 
 427     // Found the full path to libjvm.so.
 428     // Now cut the path to &lt;java_home&gt;/jre if we can.
 429     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 430     pslash = strrchr(buf, &#39;/&#39;);
 431     if (pslash != NULL) {
 432       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 433     }
 434 #ifdef STATIC_BUILD
 435     strcat(buf, &quot;/lib&quot;);
 436 #endif
 437 
 438     Arguments::set_dll_dir(buf);
 439 
 440     if (pslash != NULL) {
</pre>
<hr />
<pre>
 462     // should always exist (until the legacy problem cited above is
 463     // addressed).
 464     // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code
 465     // can specify a directory inside an app wrapper
 466     const char *l = ::getenv(&quot;JAVA_LIBRARY_PATH&quot;);
 467     const char *l_colon = &quot;:&quot;;
 468     if (l == NULL) { l = &quot;&quot;; l_colon = &quot;&quot;; }
 469 
 470     const char *v = ::getenv(&quot;DYLD_LIBRARY_PATH&quot;);
 471     const char *v_colon = &quot;:&quot;;
 472     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 473 
 474     // Apple&#39;s Java6 has &quot;.&quot; at the beginning of java.library.path.
 475     // OpenJDK on Windows has &quot;.&quot; at the end of java.library.path.
 476     // OpenJDK on Linux and Solaris don&#39;t have &quot;.&quot; in java.library.path
 477     // at all. To ease the transition from Apple&#39;s Java6 to OpenJDK7,
 478     // &quot;.&quot; is appended to the end of java.library.path. Yes, this
 479     // could cause a change in behavior, but Apple&#39;s Java6 behavior
 480     // can be achieved by putting &quot;.&quot; at the beginning of the
 481     // JAVA_LIBRARY_PATH environment variable.
<span class="line-modified"> 482     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 483                                                      strlen(v) + 1 + strlen(l) + 1 +</span>
<span class="line-modified"> 484                                                      system_ext_size + 3,</span>
<span class="line-modified"> 485                                                      mtInternal);</span>
 486     sprintf(ld_library_path, &quot;%s%s%s%s%s&quot; SYS_EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS &quot;:.&quot;,
 487             v, v_colon, l, l_colon, user_home_dir);
 488     Arguments::set_library_path(ld_library_path);
 489     FREE_C_HEAP_ARRAY(char, ld_library_path);
 490   }
 491 
 492   // Extensions directories.
 493   //
 494   // Note that the space for the colon and the trailing null are provided
 495   // by the nulls included by the sizeof operator (so actually one byte more
 496   // than necessary is allocated).
 497   sprintf(buf, &quot;%s&quot; SYS_EXTENSIONS_DIR &quot;:%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS,
 498           user_home_dir, Arguments::get_java_home());
 499   Arguments::set_ext_dirs(buf);
 500 
 501   FREE_C_HEAP_ARRAY(char, buf);
 502 
 503 #undef SYS_EXTENSIONS_DIR
 504 #undef SYS_EXTENSIONS_DIRS
 505 
</pre>
<hr />
<pre>
 603       // ... all other threads block BREAK_SIGNAL
 604       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 605     }
 606   }
 607 }
 608 
 609 
 610 //////////////////////////////////////////////////////////////////////////////
 611 // create new thread
 612 
 613 #ifdef __APPLE__
 614 // library handle for calling objc_registerThreadWithCollector()
 615 // without static linking to the libobjc library
 616   #define OBJC_LIB &quot;/usr/lib/libobjc.dylib&quot;
 617   #define OBJC_GCREGISTER &quot;objc_registerThreadWithCollector&quot;
 618 typedef void (*objc_registerThreadWithCollector_t)();
 619 extern &quot;C&quot; objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;
 620 objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;
 621 #endif
 622 
<span class="line-removed"> 623 #ifdef __APPLE__</span>
<span class="line-removed"> 624 static uint64_t locate_unique_thread_id(mach_port_t mach_thread_port) {</span>
<span class="line-removed"> 625   // Additional thread_id used to correlate threads in SA</span>
<span class="line-removed"> 626   thread_identifier_info_data_t     m_ident_info;</span>
<span class="line-removed"> 627   mach_msg_type_number_t            count = THREAD_IDENTIFIER_INFO_COUNT;</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629   thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,</span>
<span class="line-removed"> 630               (thread_info_t) &amp;m_ident_info, &amp;count);</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632   return m_ident_info.thread_id;</span>
<span class="line-removed"> 633 }</span>
<span class="line-removed"> 634 #endif</span>
<span class="line-removed"> 635 </span>
 636 // Thread start routine for all newly created threads
 637 static void *thread_native_entry(Thread *thread) {
 638 
 639   thread-&gt;record_stack_base_and_size();
 640 
 641   // Try to randomize the cache line index of hot stack frames.
 642   // This helps when threads of the same stack traces evict each other&#39;s
 643   // cache lines. The threads can be either from the same JVM instance, or
 644   // from different JVM instances. The benefit is especially true for
 645   // processors with hyperthreading technology.
 646   static int counter = 0;
 647   int pid = os::current_process_id();
 648   alloca(((pid ^ counter++) &amp; 7) * 128);
 649 
 650   thread-&gt;initialize_thread_current();
 651 
 652   OSThread* osthread = thread-&gt;osthread();
 653   Monitor* sync = osthread-&gt;startThread_lock();
 654 
 655   osthread-&gt;set_thread_id(os::Bsd::gettid());
 656 
 657   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 658     os::current_thread_id(), (uintx) pthread_self());
 659 
 660 #ifdef __APPLE__
<span class="line-modified"> 661   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified"> 662   guarantee(unique_thread_id != 0, &quot;unique thread id was not found&quot;);</span>
<span class="line-removed"> 663   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
 664 #endif

 665   // initialize signal mask for this thread
 666   os::Bsd::hotspot_sigmask(thread);
 667 
 668   // initialize floating point control register
 669   os::Bsd::init_thread_fpu_state();
 670 
 671 #ifdef __APPLE__
 672   // register thread with objc gc
 673   if (objc_registerThreadWithCollectorFunction != NULL) {
 674     objc_registerThreadWithCollectorFunction();
 675   }
 676 #endif
 677 
 678   // handshaking with parent thread
 679   {
<span class="line-modified"> 680     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);</span>
 681 
 682     // notify parent thread
 683     osthread-&gt;set_state(INITIALIZED);
 684     sync-&gt;notify_all();
 685 
 686     // wait until os::start_thread()
 687     while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified"> 688       sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 689     }
 690   }
 691 
 692   // call one more level start routine
 693   thread-&gt;call_run();
 694 
 695   // Note: at this point the thread object may already have deleted itself.
 696   // Prevent dereferencing it from here on out.
 697   thread = NULL;
 698 
 699   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 700     os::current_thread_id(), (uintx) pthread_self());
 701 
 702   return 0;
 703 }
 704 
 705 bool os::create_thread(Thread* thread, ThreadType thr_type,
 706                        size_t req_stack_size) {
 707   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 708 
</pre>
<hr />
<pre>
 726   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
 727 
 728   // calculate stack size if it&#39;s not specified by caller
 729   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
 730   int status = pthread_attr_setstacksize(&amp;attr, stack_size);
 731   assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
 732 
 733   ThreadState state;
 734 
 735   {
 736     pthread_t tid;
 737     int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 738 
 739     char buf[64];
 740     if (ret == 0) {
 741       log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 742         (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 743     } else {
 744       log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
 745         os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));





 746     }
 747 
 748     pthread_attr_destroy(&amp;attr);
 749 
 750     if (ret != 0) {
 751       // Need to clean up stuff we&#39;ve allocated so far
 752       thread-&gt;set_osthread(NULL);
 753       delete osthread;
 754       return false;
 755     }
 756 
 757     // Store pthread info into the OSThread
 758     osthread-&gt;set_pthread_id(tid);
 759 
 760     // Wait until child thread is either initialized or aborted
 761     {
 762       Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 763       MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 764       while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified"> 765         sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
 766       }
 767     }
 768 
 769   }
 770 
 771   // Aborted due to thread limit being reached
 772   if (state == ZOMBIE) {
 773     thread-&gt;set_osthread(NULL);
 774     delete osthread;
 775     return false;
 776   }
 777 
 778   // The thread is returned suspended (in state INITIALIZED),
 779   // and is started higher up in the call chain
 780   assert(state == INITIALIZED, &quot;race condition&quot;);
 781   return true;
 782 }
 783 
 784 /////////////////////////////////////////////////////////////////////////////
 785 // attach existing thread
</pre>
<hr />
<pre>
 787 // bootstrap the main thread
 788 bool os::create_main_thread(JavaThread* thread) {
 789   assert(os::Bsd::_main_thread == pthread_self(), &quot;should be called inside main thread&quot;);
 790   return create_attached_thread(thread);
 791 }
 792 
 793 bool os::create_attached_thread(JavaThread* thread) {
 794 #ifdef ASSERT
 795   thread-&gt;verify_not_published();
 796 #endif
 797 
 798   // Allocate the OSThread object
 799   OSThread* osthread = new OSThread(NULL, NULL);
 800 
 801   if (osthread == NULL) {
 802     return false;
 803   }
 804 
 805   osthread-&gt;set_thread_id(os::Bsd::gettid());
 806 
<span class="line-removed"> 807   // Store pthread info into the OSThread</span>
 808 #ifdef __APPLE__
<span class="line-modified"> 809   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified"> 810   guarantee(unique_thread_id != 0, &quot;just checking&quot;);</span>
<span class="line-removed"> 811   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
 812 #endif


 813   osthread-&gt;set_pthread_id(::pthread_self());
 814 
 815   // initialize floating point control register
 816   os::Bsd::init_thread_fpu_state();
 817 
 818   // Initial thread state is RUNNABLE
 819   osthread-&gt;set_state(RUNNABLE);
 820 
 821   thread-&gt;set_osthread(osthread);
 822 
 823   // initialize signal mask for this thread
 824   // and save the caller&#39;s signal mask
 825   os::Bsd::hotspot_sigmask(thread);
 826 
 827   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 828     os::current_thread_id(), (uintx) pthread_self());
 829 
 830   return true;
 831 }
 832 
 833 void os::pd_start_thread(Thread* thread) {
 834   OSThread * osthread = thread-&gt;osthread();
 835   assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
 836   Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 837   MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 838   sync_with_child-&gt;notify();
 839 }
 840 
 841 // Free Bsd resources related to the OSThread
 842 void os::free_thread(OSThread* osthread) {
 843   assert(osthread != NULL, &quot;osthread not set&quot;);
 844 
 845   // We are told to free resources of the argument thread,
 846   // but we can only really operate on the current thread.
 847   assert(Thread::current()-&gt;osthread() == osthread,
 848          &quot;os::free_thread but not current thread&quot;);
 849 
 850   // Restore caller&#39;s signal mask
 851   sigset_t sigmask = osthread-&gt;caller_sigmask();
 852   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
 853 
 854   delete osthread;
 855 }
 856 
 857 ////////////////////////////////////////////////////////////////////////////////
 858 // time support
 859 
 860 // Time since start-up in seconds to a fine granularity.
 861 // Used by VMSelfDestructTimer and the MemProfiler.
 862 double os::elapsedTime() {
 863 
 864   return ((double)os::elapsed_counter()) / os::elapsed_frequency();
 865 }
 866 
 867 jlong os::elapsed_counter() {
 868   return javaTimeNanos() - initial_time_count;
 869 }
 870 
 871 jlong os::elapsed_frequency() {
 872   return NANOSECS_PER_SEC; // nanosecond resolution
 873 }
 874 
 875 bool os::supports_vtime() { return true; }
<span class="line-removed"> 876 bool os::enable_vtime()   { return false; }</span>
<span class="line-removed"> 877 bool os::vtime_enabled()  { return false; }</span>
 878 
 879 double os::elapsedVTime() {
 880   // better than nothing, but not much
 881   return elapsedTime();
 882 }
 883 
 884 jlong os::javaTimeMillis() {
 885   timeval time;
 886   int status = gettimeofday(&amp;time, NULL);
 887   assert(status != -1, &quot;bsd error&quot;);
 888   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
 889 }
 890 
 891 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 892   timeval time;
 893   int status = gettimeofday(&amp;time, NULL);
 894   assert(status != -1, &quot;bsd error&quot;);
 895   seconds = jlong(time.tv_sec);
 896   nanos = jlong(time.tv_usec) * 1000;
 897 }
</pre>
<hr />
<pre>
 912   struct timespec tp;
 913   if (::clock_getres(CLOCK_MONOTONIC, &amp;res) == 0 &amp;&amp;
 914       ::clock_gettime(CLOCK_MONOTONIC, &amp;tp)  == 0) {
 915     // yes, monotonic clock is supported
 916     _clock_gettime = ::clock_gettime;
 917   }
 918 }
 919 #endif
 920 
 921 
 922 
 923 #ifdef __APPLE__
 924 
 925 jlong os::javaTimeNanos() {
 926   const uint64_t tm = mach_absolute_time();
 927   const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
 928   const uint64_t prev = Bsd::_max_abstime;
 929   if (now &lt;= prev) {
 930     return prev;   // same or retrograde time;
 931   }
<span class="line-modified"> 932   const uint64_t obsv = Atomic::cmpxchg(now, &amp;Bsd::_max_abstime, prev);</span>
 933   assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
 934   // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
 935   // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
 936   // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
 937   // some other thread raced this thread and installed a new value, in which case
 938   // we could either (a) retry the entire operation, (b) retry trying to install now
 939   // or (c) just return obsv.  We use (c).   No loop is required although in some cases
 940   // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
 941   // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
 942   // to (a) or (b) -- and greatly reduces coherence traffic.
 943   // We might also condition (c) on the magnitude of the delta between obsv and now.
 944   // Avoiding excessive CAS operations to hot RW locations is critical.
 945   // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
 946   return (prev == obsv) ? now : obsv;
 947 }
 948 
 949 #else // __APPLE__
 950 
 951 jlong os::javaTimeNanos() {
 952   if (os::supports_monotonic_clock()) {
</pre>
<hr />
<pre>
1050 // called from signal handler. Before adding something to os::abort(), make
1051 // sure it is async-safe and can handle partially initialized VM.
1052 void os::abort(bool dump_core, void* siginfo, const void* context) {
1053   os::shutdown();
1054   if (dump_core) {
1055 #ifndef PRODUCT
1056     fdStream out(defaultStream::output_fd());
1057     out.print_raw(&quot;Current thread is &quot;);
1058     char buf[16];
1059     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1060     out.print_raw_cr(buf);
1061     out.print_raw_cr(&quot;Dumping core ...&quot;);
1062 #endif
1063     ::abort(); // dump core
1064   }
1065 
1066   ::exit(1);
1067 }
1068 
1069 // Die immediately, no exit hook, no abort hook, no cleanup.

1070 void os::die() {
<span class="line-modified">1071   // _exit() on BsdThreads only kills current thread</span>
<span class="line-modified">1072   ::abort();</span>






1073 }
1074 
1075 // Information of current thread in variety of formats
1076 pid_t os::Bsd::gettid() {
1077   int retval = -1;
1078 
<span class="line-modified">1079 #ifdef __APPLE__ //XNU kernel</span>
<span class="line-modified">1080   // despite the fact mach port is actually not a thread id use it</span>
<span class="line-modified">1081   // instead of syscall(SYS_thread_selfid) as it certainly fits to u4</span>
<span class="line-modified">1082   retval = ::pthread_mach_thread_np(::pthread_self());</span>
<span class="line-modified">1083   guarantee(retval != 0, &quot;just checking&quot;);</span>
<span class="line-removed">1084   return retval;</span>
1085 
1086 #else
1087   #ifdef __FreeBSD__
1088   retval = syscall(SYS_thr_self);
1089   #else
1090     #ifdef __OpenBSD__
1091   retval = syscall(SYS_getthrid);
1092     #else
1093       #ifdef __NetBSD__
1094   retval = (pid_t) syscall(SYS__lwp_self);
1095       #endif
1096     #endif
1097   #endif
1098 #endif
1099 
1100   if (retval == -1) {
1101     return getpid();
1102   }
1103 }
1104 
1105 intx os::current_thread_id() {
1106 #ifdef __APPLE__
<span class="line-modified">1107   return (intx)::pthread_mach_thread_np(::pthread_self());</span>
1108 #else
1109   return (intx)::pthread_self();
1110 #endif
1111 }
1112 
1113 int os::current_process_id() {
<span class="line-modified">1114 </span>
<span class="line-removed">1115   // Under the old bsd thread library, bsd gives each thread</span>
<span class="line-removed">1116   // its own process id. Because of this each thread will return</span>
<span class="line-removed">1117   // a different pid if this method were to return the result</span>
<span class="line-removed">1118   // of getpid(2). Bsd provides no api that returns the pid</span>
<span class="line-removed">1119   // of the launcher thread for the vm. This implementation</span>
<span class="line-removed">1120   // returns a unique pid, the pid of the launcher thread</span>
<span class="line-removed">1121   // that starts the vm &#39;process&#39;.</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123   // Under the NPTL, getpid() returns the same pid as the</span>
<span class="line-removed">1124   // launcher thread rather than a unique pid per thread.</span>
<span class="line-removed">1125   // Use gettid() if you want the old pre NPTL behaviour.</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127   // if you are looking for the result of a call to getpid() that</span>
<span class="line-removed">1128   // returns a unique pid for the calling thread, then look at the</span>
<span class="line-removed">1129   // OSThread::thread_id() method in osThread_bsd.hpp file</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131   return (int)(_initial_pid ? _initial_pid : getpid());</span>
1132 }
1133 
1134 // DLL functions
1135 
1136 const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
1137 
1138 // This must be hard coded because it&#39;s the system&#39;s temporary
1139 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1140 #ifdef __APPLE__
1141 // macosx has a secure per-user temporary directory
1142 char temp_path_storage[PATH_MAX];
1143 const char* os::get_temp_directory() {
1144   static char *temp_path = NULL;
1145   if (temp_path == NULL) {
1146     int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);
1147     if (pathSize == 0 || pathSize &gt; PATH_MAX) {
1148       strlcpy(temp_path_storage, &quot;/tmp/&quot;, sizeof(temp_path_storage));
1149     }
1150     temp_path = temp_path_storage;
1151   }
</pre>
<hr />
<pre>
1233     if (dlinfo.dli_fbase != NULL &amp;&amp; offset != NULL) {
1234       *offset = addr - (address)dlinfo.dli_fbase;
1235     }
1236     return true;
1237   }
1238 
1239   buf[0] = &#39;\0&#39;;
1240   if (offset) *offset = -1;
1241   return false;
1242 }
1243 
1244 // Loads .dll/.so and
1245 // in case of error it checks if .dll/.so was built for the
1246 // same architecture as Hotspot is running on
1247 
1248 #ifdef __APPLE__
1249 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1250 #ifdef STATIC_BUILD
1251   return os::get_default_process_handle();
1252 #else


1253   void * result= ::dlopen(filename, RTLD_LAZY);
1254   if (result != NULL) {

1255     // Successful loading

1256     return result;
1257   }
1258 
<span class="line-modified">1259   // Read system error message into ebuf</span>
<span class="line-modified">1260   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">1261   ebuf[ebuflen-1]=&#39;\0&#39;;</span>








1262 
1263   return NULL;
1264 #endif // STATIC_BUILD
1265 }
1266 #else
1267 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1268 #ifdef STATIC_BUILD
1269   return os::get_default_process_handle();
1270 #else

1271   void * result= ::dlopen(filename, RTLD_LAZY);
1272   if (result != NULL) {

1273     // Successful loading

1274     return result;
1275   }
1276 
1277   Elf32_Ehdr elf_head;
1278 
<span class="line-modified">1279   // Read system error message into ebuf</span>
<span class="line-modified">1280   // It may or may not be overwritten below</span>
<span class="line-modified">1281   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">1282   ebuf[ebuflen-1]=&#39;\0&#39;;</span>








1283   int diag_msg_max_length=ebuflen-strlen(ebuf);
1284   char* diag_msg_buf=ebuf+strlen(ebuf);
1285 
1286   if (diag_msg_max_length==0) {
1287     // No more space in ebuf for additional diagnostics message
1288     return NULL;
1289   }
1290 
1291 
1292   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1293 
1294   if (file_descriptor &lt; 0) {
1295     // Can&#39;t open library, report dlerror() message
1296     return NULL;
1297   }
1298 
1299   bool failed_to_read_elf_head=
1300     (sizeof(elf_head)!=
1301      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1302 
</pre>
<hr />
<pre>
1538 
1539   char release[100];
1540   size = sizeof(release);
1541   int mib_release[] = { CTL_KERN, KERN_OSRELEASE };
1542   if (sysctl(mib_release, 2, release, &amp;size, NULL, 0) &lt; 0) {
1543       // if error, leave blank
1544       strncpy(release, &quot;&quot;, sizeof(release));
1545   }
1546   snprintf(buf, buflen, &quot;%s %s&quot;, os, release);
1547 }
1548 
1549 void os::print_os_info_brief(outputStream* st) {
1550   os::Posix::print_uname_info(st);
1551 }
1552 
1553 void os::print_os_info(outputStream* st) {
1554   st-&gt;print(&quot;OS:&quot;);
1555 
1556   os::Posix::print_uname_info(st);
1557 


1558   os::Posix::print_rlimit_info(st);
1559 
1560   os::Posix::print_load_average(st);
1561 }
1562 
1563 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1564   // Nothing to do for now.
1565 }
1566 
1567 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1568   unsigned int mhz;
1569   size_t size = sizeof(mhz);
1570   int mib[] = { CTL_HW, HW_CPU_FREQ };
1571   if (sysctl(mib, 2, &amp;mhz, &amp;size, NULL, 0) &lt; 0) {
1572     mhz = 1;  // looks like an error but can be divided by
1573   } else {
1574     mhz /= 1000000;  // reported in millions
1575   }
1576 
1577   char model[100];
1578   size = sizeof(model);
1579   int mib_model[] = { CTL_HW, HW_MODEL };
1580   if (sysctl(mib_model, 2, model, &amp;size, NULL, 0) &lt; 0) {
1581     strncpy(model, cpu_arch, sizeof(model));
1582   }
1583 
1584   char machine[100];
1585   size = sizeof(machine);
1586   int mib_machine[] = { CTL_HW, HW_MACHINE };
1587   if (sysctl(mib_machine, 2, machine, &amp;size, NULL, 0) &lt; 0) {
1588       strncpy(machine, &quot;&quot;, sizeof(machine));
1589   }
1590 
1591   snprintf(buf, buflen, &quot;%s %s %d MHz&quot;, model, machine, mhz);
1592 }
1593 
1594 void os::print_memory_info(outputStream* st) {


1595 
1596   st-&gt;print(&quot;Memory:&quot;);
1597   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1598 
1599   st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
1600             os::physical_memory() &gt;&gt; 10);
1601   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
1602             os::available_memory() &gt;&gt; 10);










1603   st-&gt;cr();
1604 }
1605 
1606 static void print_signal_handler(outputStream* st, int sig,
1607                                  char* buf, size_t buflen);
1608 
1609 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1610   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1611   print_signal_handler(st, SIGSEGV, buf, buflen);
1612   print_signal_handler(st, SIGBUS , buf, buflen);
1613   print_signal_handler(st, SIGFPE , buf, buflen);
1614   print_signal_handler(st, SIGPIPE, buf, buflen);
1615   print_signal_handler(st, SIGXFSZ, buf, buflen);
1616   print_signal_handler(st, SIGILL , buf, buflen);
1617   print_signal_handler(st, SR_signum, buf, buflen);
1618   print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);
1619   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
1620   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
1621   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
1622 }
</pre>
<hr />
<pre>
1717         }
1718       }
1719     }
1720   }
1721 
1722   strncpy(saved_jvm_path, buf, MAXPATHLEN);
1723   saved_jvm_path[MAXPATHLEN - 1] = &#39;\0&#39;;
1724 }
1725 
1726 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1727   // no prefix required, not even &quot;_&quot;
1728 }
1729 
1730 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1731   // no suffix required
1732 }
1733 
1734 ////////////////////////////////////////////////////////////////////////////////
1735 // sun.misc.Signal support
1736 
<span class="line-removed">1737 static volatile jint sigint_count = 0;</span>
<span class="line-removed">1738 </span>
1739 static void UserHandler(int sig, void *siginfo, void *context) {
<span class="line-removed">1740   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="line-removed">1741   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="line-removed">1742   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="line-removed">1743   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1) {</span>
<span class="line-removed">1744     return;</span>
<span class="line-removed">1745   }</span>
<span class="line-removed">1746 </span>
1747   // Ctrl-C is pressed during error reporting, likely because the error
1748   // handler fails to abort. Let VM die immediately.
1749   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1750     os::die();
1751   }
1752 
1753   os::signal_notify(sig);
1754 }
1755 
1756 void* os::user_handler() {
1757   return CAST_FROM_FN_PTR(void*, UserHandler);
1758 }
1759 
1760 extern &quot;C&quot; {
1761   typedef void (*sa_handler_t)(int);
1762   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1763 }
1764 
1765 void* os::signal(int signal_number, void* handler) {
1766   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
1796 static void jdk_misc_signal_init() {
1797   // Initialize signal structures
1798   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1799 
1800   // Initialize signal semaphore
1801   sig_sem = new Semaphore();
1802 }
1803 
1804 void os::signal_notify(int sig) {
1805   if (sig_sem != NULL) {
1806     Atomic::inc(&amp;pending_signals[sig]);
1807     sig_sem-&gt;signal();
1808   } else {
1809     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
1810     // initialization isn&#39;t called.
1811     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
1812   }
1813 }
1814 
1815 static int check_pending_signals() {
<span class="line-removed">1816   Atomic::store(0, &amp;sigint_count);</span>
1817   for (;;) {
1818     for (int i = 0; i &lt; NSIG + 1; i++) {
1819       jint n = pending_signals[i];
<span class="line-modified">1820       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
1821         return i;
1822       }
1823     }
1824     JavaThread *thread = JavaThread::current();
1825     ThreadBlockInVM tbivm(thread);
1826 
1827     bool threadIsSuspended;
1828     do {
1829       thread-&gt;set_suspend_equivalent();
1830       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1831       sig_sem-&gt;wait();
1832 
1833       // were we externally suspended while we were waiting?
1834       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1835       if (threadIsSuspended) {
1836         // The semaphore has been incremented, but while we were waiting
1837         // another thread suspended us. We don&#39;t want to continue running
1838         // while suspended because that would surprise the thread that
1839         // suspended us.
1840         sig_sem-&gt;signal();
</pre>
<hr />
<pre>
1861 // Solaris allocates memory by pages.
1862 int os::vm_allocation_granularity() {
1863   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1864   return os::Bsd::page_size();
1865 }
1866 
1867 // Rationale behind this function:
1868 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
1869 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
1870 //  samples for JITted code. Here we create private executable mapping over the code cache
1871 //  and then we can use standard (well, almost, as mapping can change) way to provide
1872 //  info for the reporting script by storing timestamp and location of symbol
1873 void bsd_wrap_code(char* base, size_t size) {
1874   static volatile jint cnt = 0;
1875 
1876   if (!UseOprofile) {
1877     return;
1878   }
1879 
1880   char buf[PATH_MAX + 1];
<span class="line-modified">1881   int num = Atomic::add(1, &amp;cnt);</span>
1882 
1883   snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,
1884            os::get_temp_directory(), os::current_process_id(), num);
1885   unlink(buf);
1886 
1887   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
1888 
1889   if (fd != -1) {
1890     off_t rv = ::lseek(fd, size-2, SEEK_SET);
1891     if (rv != (off_t)-1) {
1892       if (::write(fd, &quot;&quot;, 1) == 1) {
1893         mmap(base, size,
1894              PROT_READ|PROT_WRITE|PROT_EXEC,
1895              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
1896       }
1897     }
1898     ::close(fd);
1899     unlink(buf);
1900   }
1901 }
1902 
1903 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
1904                                     int err) {
1905   warning(&quot;INFO: os::commit_memory(&quot; INTPTR_FORMAT &quot;, &quot; SIZE_FORMAT
1906           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, (intptr_t)addr, size, exec,
1907            os::errno_name(err), err);
1908 }
1909 
1910 // NOTE: Bsd kernel does not really reserve the pages for us.
1911 //       All it does is to check if there are enough free pages
1912 //       left at the time of mmap(). This could be a potential
1913 //       problem.
1914 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
1915   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
1916 #ifdef __OpenBSD__
1917   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD

1918   if (::mprotect(addr, size, prot) == 0) {
1919     return true;
1920   }
1921 #else
1922   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
1923                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
1924   if (res != (uintptr_t) MAP_FAILED) {
1925     return true;
1926   }
1927 #endif
1928 
1929   // Warn about any commit errors we see in non-product builds just
1930   // in case mmap() doesn&#39;t work as described on the man page.
1931   NOT_PRODUCT(warn_fail_commit_memory(addr, size, exec, errno);)
1932 
1933   return false;
1934 }
1935 
1936 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
1937                           bool exec) {
</pre>
<hr />
<pre>
1970 }
1971 
1972 bool os::numa_topology_changed()   { return false; }
1973 
1974 size_t os::numa_get_groups_num() {
1975   return 1;
1976 }
1977 
1978 int os::numa_get_group_id() {
1979   return 0;
1980 }
1981 
1982 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
1983   if (size &gt; 0) {
1984     ids[0] = 0;
1985     return 1;
1986   }
1987   return 0;
1988 }
1989 




1990 bool os::get_page_info(char *start, page_info* info) {
1991   return false;
1992 }
1993 
1994 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
1995   return end;
1996 }
1997 
1998 
1999 bool os::pd_uncommit_memory(char* addr, size_t size) {
2000 #ifdef __OpenBSD__
2001   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD

2002   return ::mprotect(addr, size, PROT_NONE) == 0;
2003 #else
2004   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
2005                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
2006   return res  != (uintptr_t) MAP_FAILED;
2007 #endif
2008 }
2009 
2010 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
2011   return os::commit_memory(addr, size, !ExecMem);
2012 }
2013 
2014 // If this is a growable mapping, remove the guard pages entirely by
2015 // munmap()ping them.  If not, just call uncommit_memory().
2016 bool os::remove_stack_guard_pages(char* addr, size_t size) {
2017   return os::uncommit_memory(addr, size);
2018 }
2019 
2020 // If &#39;fixed&#39; is true, anon_mmap() will attempt to reserve anonymous memory
2021 // at &#39;requested_addr&#39;. If there are existing memory mappings at the same
</pre>
<hr />
<pre>
2050                             size_t alignment_hint) {
2051   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
2052 }
2053 
2054 bool os::pd_release_memory(char* addr, size_t size) {
2055   return anon_munmap(addr, size);
2056 }
2057 
2058 static bool bsd_mprotect(char* addr, size_t size, int prot) {
2059   // Bsd wants the mprotect address argument to be page aligned.
2060   char* bottom = (char*)align_down((intptr_t)addr, os::Bsd::page_size());
2061 
2062   // According to SUSv3, mprotect() should only be used with mappings
2063   // established by mmap(), and mmap() always maps whole pages. Unaligned
2064   // &#39;addr&#39; likely indicates problem in the VM (e.g. trying to change
2065   // protection of malloc&#39;ed or statically allocated memory). Check the
2066   // caller if you hit this assert.
2067   assert(addr == bottom, &quot;sanity check&quot;);
2068 
2069   size = align_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());

2070   return ::mprotect(bottom, size, prot) == 0;
2071 }
2072 
2073 // Set protections specified
2074 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
2075                         bool is_committed) {
2076   unsigned int p = 0;
2077   switch (prot) {
2078   case MEM_PROT_NONE: p = PROT_NONE; break;
2079   case MEM_PROT_READ: p = PROT_READ; break;
2080   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2081   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2082   default:
2083     ShouldNotReachHere();
2084   }
2085   // is_committed is unused.
2086   return bsd_mprotect(addr, bytes, p);
2087 }
2088 
2089 bool os::guard_memory(char* addr, size_t size) {
</pre>
<hr />
<pre>
2128 bool os::can_execute_large_page_memory() {
2129   // Does not matter, we do not support huge pages.
2130   return false;
2131 }
2132 
2133 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2134   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2135   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
2136   if (result != NULL) {
2137     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2138       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2139     }
2140   }
2141   return result;
2142 }
2143 
2144 // Reserve memory at an arbitrary address, only if that area is
2145 // available (and not reserved for something else).
2146 
2147 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="line-removed">2148   const int max_tries = 10;</span>
<span class="line-removed">2149   char* base[max_tries];</span>
<span class="line-removed">2150   size_t size[max_tries];</span>
<span class="line-removed">2151   const size_t gap = 0x000000;</span>
<span class="line-removed">2152 </span>
2153   // Assert only that the size is a multiple of the page size, since
2154   // that&#39;s all that mmap requires, and since that&#39;s all we really know
2155   // about at this low abstraction level.  If we need higher alignment,
2156   // we can either pass an alignment to this method or verify alignment
2157   // in one of the methods further up the call chain.  See bug 5044738.
2158   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
2159 
2160   // Repeatedly allocate blocks until the block is allocated at the
2161   // right spot.
2162 
2163   // Bsd mmap allows caller to pass an address as hint; give it a try first,
2164   // if kernel honors the hint then we can return immediately.
2165   char * addr = anon_mmap(requested_addr, bytes, false);
2166   if (addr == requested_addr) {
2167     return requested_addr;
2168   }
2169 
2170   if (addr != NULL) {
2171     // mmap() is successful but it fails to reserve at the requested address
2172     anon_munmap(addr, bytes);
2173   }
2174 
<span class="line-modified">2175   int i;</span>
<span class="line-removed">2176   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">2177     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">2178 </span>
<span class="line-removed">2179     if (base[i] != NULL) {</span>
<span class="line-removed">2180       // Is this the block we wanted?</span>
<span class="line-removed">2181       if (base[i] == requested_addr) {</span>
<span class="line-removed">2182         size[i] = bytes;</span>
<span class="line-removed">2183         break;</span>
<span class="line-removed">2184       }</span>
<span class="line-removed">2185 </span>
<span class="line-removed">2186       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">2187       // parts and try again.</span>
<span class="line-removed">2188 </span>
<span class="line-removed">2189       size_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">2190       if (top_overlap &gt;= 0 &amp;&amp; top_overlap &lt; bytes) {</span>
<span class="line-removed">2191         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">2192         base[i] += top_overlap;</span>
<span class="line-removed">2193         size[i] = bytes - top_overlap;</span>
<span class="line-removed">2194       } else {</span>
<span class="line-removed">2195         size_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">2196         if (bottom_overlap &gt;= 0 &amp;&amp; bottom_overlap &lt; bytes) {</span>
<span class="line-removed">2197           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">2198           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">2199         } else {</span>
<span class="line-removed">2200           size[i] = bytes;</span>
<span class="line-removed">2201         }</span>
<span class="line-removed">2202       }</span>
<span class="line-removed">2203     }</span>
<span class="line-removed">2204   }</span>
<span class="line-removed">2205 </span>
<span class="line-removed">2206   // Give back the unused reserved pieces.</span>
<span class="line-removed">2207 </span>
<span class="line-removed">2208   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">2209     if (base[j] != NULL) {</span>
<span class="line-removed">2210       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">2211     }</span>
<span class="line-removed">2212   }</span>
<span class="line-removed">2213 </span>
<span class="line-removed">2214   if (i &lt; max_tries) {</span>
<span class="line-removed">2215     return requested_addr;</span>
<span class="line-removed">2216   } else {</span>
<span class="line-removed">2217     return NULL;</span>
<span class="line-removed">2218   }</span>
2219 }
2220 
2221 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2222 void os::infinite_sleep() {
2223   while (true) {    // sleep forever ...
2224     ::sleep(100);   // ... 100 seconds at a time
2225   }
2226 }
2227 
2228 // Used to convert frequent JVM_Yield() to nops
2229 bool os::dont_yield() {
2230   return DontYieldALot;
2231 }
2232 
2233 void os::naked_yield() {
2234   sched_yield();
2235 }
2236 
2237 ////////////////////////////////////////////////////////////////////////////////
2238 // thread priority support
</pre>
<hr />
<pre>
2856     // exception handling, while leaving the standard BSD signal handlers functional.
2857     kern_return_t kr;
2858     kr = task_set_exception_ports(mach_task_self(),
2859                                   EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
2860                                   MACH_PORT_NULL,
2861                                   EXCEPTION_STATE_IDENTITY,
2862                                   MACHINE_THREAD_STATE);
2863 
2864     assert(kr == KERN_SUCCESS, &quot;could not set mach task signal handler&quot;);
2865 #endif
2866 
2867     if (libjsig_is_loaded) {
2868       // Tell libjsig jvm finishes setting signal handlers
2869       (*end_signal_setting)();
2870     }
2871 
2872     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
2873     // and if UserSignalHandler is installed all bets are off
2874     if (CheckJNICalls) {
2875       if (libjsig_is_loaded) {
<span class="line-modified">2876         if (PrintJNIResolving) {</span>
<span class="line-removed">2877           tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">2878         }</span>
2879         check_signals = false;
2880       }
2881       if (AllowUserSignalHandlers) {
<span class="line-modified">2882         if (PrintJNIResolving) {</span>
<span class="line-removed">2883           tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">2884         }</span>
2885         check_signals = false;
2886       }
2887     }
2888   }
2889 }
2890 
2891 
2892 /////
2893 // glibc on Bsd platform uses non-documented flag
2894 // to indicate, that some special sort of signal
2895 // trampoline is used.
2896 // We will never set this flag, and we should
2897 // ignore this flag in our diagnostic
2898 #ifdef SIGNIFICANT_SIGNAL_MASK
2899   #undef SIGNIFICANT_SIGNAL_MASK
2900 #endif
2901 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
2902 
2903 static const char* get_signal_handler_name(address handler,
2904                                            char* buf, int buflen) {
</pre>
<hr />
<pre>
3077     tty-&gt;print(&quot;  found:&quot;);
3078     os::Posix::print_sa_flags(tty, act.sa_flags);
3079     tty-&gt;cr();
3080     // No need to check this sig any longer
3081     sigaddset(&amp;check_signal_done, sig);
3082   }
3083 
3084   // Dump all the signal
3085   if (sigismember(&amp;check_signal_done, sig)) {
3086     print_signal_handlers(tty, buf, O_BUFLEN);
3087   }
3088 }
3089 
3090 extern void report_error(char* file_name, int line_no, char* title,
3091                          char* format, ...);
3092 
3093 // this is called _before_ the most of global arguments have been parsed
3094 void os::init(void) {
3095   char dummy;   // used to get a guess on initial stack address
3096 
<span class="line-removed">3097   // With BsdThreads the JavaMain thread pid (primordial thread)</span>
<span class="line-removed">3098   // is different than the pid of the java launcher thread.</span>
<span class="line-removed">3099   // So, on Bsd, the launcher thread pid is passed to the VM</span>
<span class="line-removed">3100   // via the sun.java.launcher.pid property.</span>
<span class="line-removed">3101   // Use this property instead of getpid() if it was correctly passed.</span>
<span class="line-removed">3102   // See bug 6351349.</span>
<span class="line-removed">3103   pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();</span>
<span class="line-removed">3104 </span>
<span class="line-removed">3105   _initial_pid = (java_launcher_pid &gt; 0) ? java_launcher_pid : getpid();</span>
<span class="line-removed">3106 </span>
3107   clock_tics_per_sec = CLK_TCK;
3108 
3109   init_random(1234567);
3110 
3111   Bsd::set_page_size(getpagesize());
3112   if (Bsd::page_size() == -1) {
3113     fatal(&quot;os_bsd.cpp: os::init: sysconf failed (%s)&quot;, os::strerror(errno));
3114   }
3115   init_page_sizes((size_t) Bsd::page_size());
3116 
3117   Bsd::initialize_system_info();
3118 
3119   // _main_thread points to the thread that created/loaded the JVM.
3120   Bsd::_main_thread = pthread_self();
3121 
3122   Bsd::clock_init();
3123   initial_time_count = javaTimeNanos();
3124 
3125   os::Posix::init();
3126 }
</pre>
<hr />
<pre>
3225 
3226 // Mark the polling page as readable
3227 void os::make_polling_page_readable(void) {
3228   if (!bsd_mprotect((char *)_polling_page, Bsd::page_size(), PROT_READ)) {
3229     fatal(&quot;Could not enable polling page&quot;);
3230   }
3231 }
3232 
3233 int os::active_processor_count() {
3234   // User has overridden the number of active processors
3235   if (ActiveProcessorCount &gt; 0) {
3236     log_trace(os)(&quot;active_processor_count: &quot;
3237                   &quot;active processor count set by user : %d&quot;,
3238                   ActiveProcessorCount);
3239     return ActiveProcessorCount;
3240   }
3241 
3242   return _processor_count;
3243 }
3244 








































































3245 void os::set_native_thread_name(const char *name) {
3246 #if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5
3247   // This is only supported in Snow Leopard and beyond
3248   if (name != NULL) {
3249     // Add a &quot;Java: &quot; prefix to the name
3250     char buf[MAXTHREADNAMESIZE];
3251     snprintf(buf, sizeof(buf), &quot;Java: %s&quot;, name);
3252     pthread_setname_np(buf);
3253   }
3254 #endif
3255 }
3256 
<span class="line-removed">3257 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">3258   // Not yet implemented.</span>
<span class="line-removed">3259   return false;</span>
<span class="line-removed">3260 }</span>
<span class="line-removed">3261 </span>
3262 bool os::bind_to_processor(uint processor_id) {
3263   // Not yet implemented.
3264   return false;
3265 }
3266 
3267 void os::SuspendedThreadTask::internal_do_task() {
3268   if (do_suspend(_thread-&gt;osthread())) {
3269     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3270     do_task(context);
3271     do_resume(_thread-&gt;osthread());
3272   }
3273 }
3274 
3275 ////////////////////////////////////////////////////////////////////////////////
3276 // debug support
3277 
3278 bool os::find(address addr, outputStream* st) {
3279   Dl_info dlinfo;
3280   memset(&amp;dlinfo, 0, sizeof(dlinfo));
3281   if (dladdr(addr, &amp;dlinfo) != 0) {
</pre>
<hr />
<pre>
3626 }
3627 
3628 bool os::is_thread_cpu_time_supported() {
3629 #ifdef __APPLE__
3630   return true;
3631 #else
3632   return false;
3633 #endif
3634 }
3635 
3636 // System loadavg support.  Returns -1 if load average cannot be obtained.
3637 // Bsd doesn&#39;t yet have a (official) notion of processor sets,
3638 // so just return the system wide load average.
3639 int os::loadavg(double loadavg[], int nelem) {
3640   return ::getloadavg(loadavg, nelem);
3641 }
3642 
3643 void os::pause() {
3644   char filename[MAX_PATH];
3645   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">3646     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
3647   } else {
3648     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
3649   }
3650 
3651   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
3652   if (fd != -1) {
3653     struct stat buf;
3654     ::close(fd);
3655     while (::stat(filename, &amp;buf) == 0) {
3656       (void)::poll(NULL, 0, 100);
3657     }
3658   } else {
3659     jio_fprintf(stderr,
3660                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
3661   }
3662 }
3663 
3664 // Darwin has no &quot;environ&quot; in a dynamic library.
3665 #ifdef __APPLE__
3666   #include &lt;crt_externs.h&gt;
</pre>
<hr />
<pre>
3718       }
3719     }
3720 
3721     if (WIFEXITED(status)) {
3722       // The child exited normally; get its exit code.
3723       return WEXITSTATUS(status);
3724     } else if (WIFSIGNALED(status)) {
3725       // The child exited because of a signal
3726       // The best value to return is 0x80 + signal number,
3727       // because that is what all Unix shells do, and because
3728       // it allows callers to distinguish between process exit and
3729       // process death by signal.
3730       return 0x80 + WTERMSIG(status);
3731     } else {
3732       // Unknown exit code; pass it through
3733       return status;
3734     }
3735   }
3736 }
3737 
<span class="line-modified">3738 // Get the default path to the core file</span>
3739 // Returns the length of the string
3740 int os::get_core_path(char* buffer, size_t bufferSize) {
<span class="line-modified">3741   int n = jio_snprintf(buffer, bufferSize, &quot;/cores/core.%d&quot;, current_process_id());</span>
<span class="line-modified">3742 </span>



















3743   // Truncate if theoretical string was longer than bufferSize
3744   n = MIN2(n, (int)bufferSize);
3745 
3746   return n;
3747 }
3748 




3749 #ifndef PRODUCT
3750 void TestReserveMemorySpecial_test() {
3751   // No tests available for this platform
3752 }
3753 #endif
3754 
3755 bool os::start_debugging(char *buf, int buflen) {
3756   int len = (int)strlen(buf);
3757   char *p = &amp;buf[len];
3758 
3759   jio_snprintf(p, buflen-len,
3760              &quot;\n\n&quot;
3761              &quot;Do you want to debug the problem?\n\n&quot;
3762              &quot;To debug, run &#39;gdb /proc/%d/exe %d&#39;; then switch to thread &quot; INTX_FORMAT &quot; (&quot; INTPTR_FORMAT &quot;)\n&quot;
3763              &quot;Enter &#39;yes&#39; to launch gdb automatically (PATH must include gdb)\n&quot;
3764              &quot;Otherwise, press RETURN to abort...&quot;,
3765              os::current_process_id(), os::current_process_id(),
3766              os::current_thread_id(), os::current_thread_id());
3767 
3768   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_bsd.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_bsd.hpp&quot;
  43 #include &quot;prims/jniFastGetField.hpp&quot;
  44 #include &quot;prims/jvm_misc.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;
  47 #include &quot;runtime/extendedPC.hpp&quot;
  48 #include &quot;runtime/globals.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/java.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/mutexLocker.hpp&quot;
  53 #include &quot;runtime/objectMonitor.hpp&quot;

  54 #include &quot;runtime/osThread.hpp&quot;
  55 #include &quot;runtime/perfMemory.hpp&quot;
  56 #include &quot;runtime/semaphore.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadCritical.hpp&quot;
  62 #include &quot;runtime/timer.hpp&quot;
  63 #include &quot;services/attachListener.hpp&quot;
  64 #include &quot;services/memTracker.hpp&quot;
  65 #include &quot;services/runtimeService.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/decoder.hpp&quot;
  68 #include &quot;utilities/defaultStream.hpp&quot;
  69 #include &quot;utilities/events.hpp&quot;
  70 #include &quot;utilities/growableArray.hpp&quot;
  71 #include &quot;utilities/vmError.hpp&quot;
  72 
  73 // put OS-includes here
</pre>
<hr />
<pre>
 118 // global variables
 119 julong os::Bsd::_physical_memory = 0;
 120 
 121 #ifdef __APPLE__
 122 mach_timebase_info_data_t os::Bsd::_timebase_info = {0, 0};
 123 volatile uint64_t         os::Bsd::_max_abstime   = 0;
 124 #else
 125 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
 126 #endif
 127 pthread_t os::Bsd::_main_thread;
 128 int os::Bsd::_page_size = -1;
 129 
 130 static jlong initial_time_count=0;
 131 
 132 static int clock_tics_per_sec = 100;
 133 
 134 // For diagnostics to print a message once. see run_periodic_checks
 135 static sigset_t check_signal_done;
 136 static bool check_signals = true;
 137 


 138 // Signal number used to suspend/resume a thread
 139 
 140 // do not use any signal number less than SIGSEGV, see 4355769
 141 static int SR_signum = SIGUSR2;
 142 sigset_t SR_sigset;
 143 
 144 
 145 ////////////////////////////////////////////////////////////////////////////////
 146 // utility functions
 147 
 148 static int SR_initialize();
 149 
 150 julong os::available_memory() {
 151   return Bsd::available_memory();
 152 }
 153 
 154 // available here means free
 155 julong os::Bsd::available_memory() {
 156   uint64_t available = physical_memory() &gt;&gt; 2;
 157 #ifdef __APPLE__
 158   mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;
 159   vm_statistics64_data_t vmstat;
 160   kern_return_t kerr = host_statistics64(mach_host_self(), HOST_VM_INFO64,
 161                                          (host_info64_t)&amp;vmstat, &amp;count);
 162   assert(kerr == KERN_SUCCESS,
 163          &quot;host_statistics64 failed - check mach_host_self() and count&quot;);
 164   if (kerr == KERN_SUCCESS) {
 165     available = vmstat.free_count * os::vm_page_size();
 166   }
 167 #endif
 168   return available;
 169 }
 170 
<span class="line-added"> 171 // for more info see :</span>
<span class="line-added"> 172 // https://man.openbsd.org/sysctl.2</span>
<span class="line-added"> 173 void os::Bsd::print_uptime_info(outputStream* st) {</span>
<span class="line-added"> 174   struct timeval boottime;</span>
<span class="line-added"> 175   size_t len = sizeof(boottime);</span>
<span class="line-added"> 176   int mib[2];</span>
<span class="line-added"> 177   mib[0] = CTL_KERN;</span>
<span class="line-added"> 178   mib[1] = KERN_BOOTTIME;</span>
<span class="line-added"> 179 </span>
<span class="line-added"> 180   if (sysctl(mib, 2, &amp;boottime, &amp;len, NULL, 0) &gt;= 0) {</span>
<span class="line-added"> 181     time_t bootsec = boottime.tv_sec;</span>
<span class="line-added"> 182     time_t currsec = time(NULL);</span>
<span class="line-added"> 183     os::print_dhm(st, &quot;OS uptime:&quot;, (long) difftime(currsec, bootsec));</span>
<span class="line-added"> 184   }</span>
<span class="line-added"> 185 }</span>
<span class="line-added"> 186 </span>
 187 julong os::physical_memory() {
 188   return Bsd::physical_memory();
 189 }
 190 
 191 // Return true if user is running as root.
 192 
 193 bool os::have_special_privileges() {
 194   static bool init = false;
 195   static bool privileges = false;
 196   if (!init) {
 197     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 198     init = true;
 199   }
 200   return privileges;
 201 }
 202 
 203 
 204 
 205 // Cpu architecture string
 206 #if   defined(ZERO)
</pre>
<hr />
<pre>
 333 #ifndef DEFAULT_LIBPATH
 334   #ifndef OVERRIDE_LIBPATH
 335     #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 336   #else
 337     #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 338   #endif
 339 #endif
 340 
 341 // Base path of extensions installed on the system.
 342 #define SYS_EXT_DIR     &quot;/usr/java/packages&quot;
 343 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 344 
 345 #ifndef __APPLE__
 346 
 347   // Buffer that fits several sprintfs.
 348   // Note that the space for the colon and the trailing null are provided
 349   // by the nulls included by the sizeof operator.
 350   const size_t bufsize =
 351     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 352          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 353   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 354 
 355   // sysclasspath, java_home, dll_dir
 356   {
 357     char *pslash;
 358     os::jvm_path(buf, bufsize);
 359 
 360     // Found the full path to libjvm.so.
 361     // Now cut the path to &lt;java_home&gt;/jre if we can.
 362     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 363     pslash = strrchr(buf, &#39;/&#39;);
 364     if (pslash != NULL) {
 365       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 366     }
 367     Arguments::set_dll_dir(buf);
 368 
 369     if (pslash != NULL) {
 370       pslash = strrchr(buf, &#39;/&#39;);
 371       if (pslash != NULL) {
 372         *pslash = &#39;\0&#39;;          // Get rid of /&lt;arch&gt;.
 373         pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 383   }
 384 
 385   // Where to look for native libraries.
 386   //
 387   // Note: Due to a legacy implementation, most of the library path
 388   // is set in the launcher. This was to accomodate linking restrictions
 389   // on legacy Bsd implementations (which are no longer supported).
 390   // Eventually, all the library path setting will be done here.
 391   //
 392   // However, to prevent the proliferation of improperly built native
 393   // libraries, the new path component /usr/java/packages is added here.
 394   // Eventually, all the library path setting will be done here.
 395   {
 396     // Get the user setting of LD_LIBRARY_PATH, and prepended it. It
 397     // should always exist (until the legacy problem cited above is
 398     // addressed).
 399     const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
 400     const char *v_colon = &quot;:&quot;;
 401     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 402     // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 403     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 404                                              strlen(v) + 1 +</span>
<span class="line-modified"> 405                                              sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified"> 406                                              mtInternal);</span>
 407     sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib/%s:&quot; DEFAULT_LIBPATH, v, v_colon, cpu_arch);
 408     Arguments::set_library_path(ld_library_path);
 409     FREE_C_HEAP_ARRAY(char, ld_library_path);
 410   }
 411 
 412   // Extensions directories.
 413   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());
 414   Arguments::set_ext_dirs(buf);
 415 
 416   FREE_C_HEAP_ARRAY(char, buf);
 417 
 418 #else // __APPLE__
 419 
 420   #define SYS_EXTENSIONS_DIR   &quot;/Library/Java/Extensions&quot;
 421   #define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR &quot;:/Network&quot; SYS_EXTENSIONS_DIR &quot;:/System&quot; SYS_EXTENSIONS_DIR &quot;:/usr/lib/java&quot;
 422 
 423   const char *user_home_dir = get_home();
 424   // The null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir.
 425   size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +
 426     sizeof(SYS_EXTENSIONS_DIRS);
 427 
 428   // Buffer that fits several sprintfs.
 429   // Note that the space for the colon and the trailing null are provided
 430   // by the nulls included by the sizeof operator.
 431   const size_t bufsize =
 432     MAX2((size_t)MAXPATHLEN,  // for dll_dir &amp; friends.
 433          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
<span class="line-modified"> 434   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 435 
 436   // sysclasspath, java_home, dll_dir
 437   {
 438     char *pslash;
 439     os::jvm_path(buf, bufsize);
 440 
 441     // Found the full path to libjvm.so.
 442     // Now cut the path to &lt;java_home&gt;/jre if we can.
 443     *(strrchr(buf, &#39;/&#39;)) = &#39;\0&#39;; // Get rid of /libjvm.so.
 444     pslash = strrchr(buf, &#39;/&#39;);
 445     if (pslash != NULL) {
 446       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 447     }
 448 #ifdef STATIC_BUILD
 449     strcat(buf, &quot;/lib&quot;);
 450 #endif
 451 
 452     Arguments::set_dll_dir(buf);
 453 
 454     if (pslash != NULL) {
</pre>
<hr />
<pre>
 476     // should always exist (until the legacy problem cited above is
 477     // addressed).
 478     // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code
 479     // can specify a directory inside an app wrapper
 480     const char *l = ::getenv(&quot;JAVA_LIBRARY_PATH&quot;);
 481     const char *l_colon = &quot;:&quot;;
 482     if (l == NULL) { l = &quot;&quot;; l_colon = &quot;&quot;; }
 483 
 484     const char *v = ::getenv(&quot;DYLD_LIBRARY_PATH&quot;);
 485     const char *v_colon = &quot;:&quot;;
 486     if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 487 
 488     // Apple&#39;s Java6 has &quot;.&quot; at the beginning of java.library.path.
 489     // OpenJDK on Windows has &quot;.&quot; at the end of java.library.path.
 490     // OpenJDK on Linux and Solaris don&#39;t have &quot;.&quot; in java.library.path
 491     // at all. To ease the transition from Apple&#39;s Java6 to OpenJDK7,
 492     // &quot;.&quot; is appended to the end of java.library.path. Yes, this
 493     // could cause a change in behavior, but Apple&#39;s Java6 behavior
 494     // can be achieved by putting &quot;.&quot; at the beginning of the
 495     // JAVA_LIBRARY_PATH environment variable.
<span class="line-modified"> 496     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified"> 497                                              strlen(v) + 1 + strlen(l) + 1 +</span>
<span class="line-modified"> 498                                              system_ext_size + 3,</span>
<span class="line-modified"> 499                                              mtInternal);</span>
 500     sprintf(ld_library_path, &quot;%s%s%s%s%s&quot; SYS_EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS &quot;:.&quot;,
 501             v, v_colon, l, l_colon, user_home_dir);
 502     Arguments::set_library_path(ld_library_path);
 503     FREE_C_HEAP_ARRAY(char, ld_library_path);
 504   }
 505 
 506   // Extensions directories.
 507   //
 508   // Note that the space for the colon and the trailing null are provided
 509   // by the nulls included by the sizeof operator (so actually one byte more
 510   // than necessary is allocated).
 511   sprintf(buf, &quot;%s&quot; SYS_EXTENSIONS_DIR &quot;:%s&quot; EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS,
 512           user_home_dir, Arguments::get_java_home());
 513   Arguments::set_ext_dirs(buf);
 514 
 515   FREE_C_HEAP_ARRAY(char, buf);
 516 
 517 #undef SYS_EXTENSIONS_DIR
 518 #undef SYS_EXTENSIONS_DIRS
 519 
</pre>
<hr />
<pre>
 617       // ... all other threads block BREAK_SIGNAL
 618       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 619     }
 620   }
 621 }
 622 
 623 
 624 //////////////////////////////////////////////////////////////////////////////
 625 // create new thread
 626 
 627 #ifdef __APPLE__
 628 // library handle for calling objc_registerThreadWithCollector()
 629 // without static linking to the libobjc library
 630   #define OBJC_LIB &quot;/usr/lib/libobjc.dylib&quot;
 631   #define OBJC_GCREGISTER &quot;objc_registerThreadWithCollector&quot;
 632 typedef void (*objc_registerThreadWithCollector_t)();
 633 extern &quot;C&quot; objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;
 634 objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;
 635 #endif
 636 













 637 // Thread start routine for all newly created threads
 638 static void *thread_native_entry(Thread *thread) {
 639 
 640   thread-&gt;record_stack_base_and_size();
 641 
 642   // Try to randomize the cache line index of hot stack frames.
 643   // This helps when threads of the same stack traces evict each other&#39;s
 644   // cache lines. The threads can be either from the same JVM instance, or
 645   // from different JVM instances. The benefit is especially true for
 646   // processors with hyperthreading technology.
 647   static int counter = 0;
 648   int pid = os::current_process_id();
 649   alloca(((pid ^ counter++) &amp; 7) * 128);
 650 
 651   thread-&gt;initialize_thread_current();
 652 
 653   OSThread* osthread = thread-&gt;osthread();
 654   Monitor* sync = osthread-&gt;startThread_lock();
 655 
 656   osthread-&gt;set_thread_id(os::Bsd::gettid());
 657 
 658   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 659     os::current_thread_id(), (uintx) pthread_self());
 660 
 661 #ifdef __APPLE__
<span class="line-modified"> 662   // Store unique OS X thread id used by SA</span>
<span class="line-modified"> 663   osthread-&gt;set_unique_thread_id();</span>

 664 #endif
<span class="line-added"> 665 </span>
 666   // initialize signal mask for this thread
 667   os::Bsd::hotspot_sigmask(thread);
 668 
 669   // initialize floating point control register
 670   os::Bsd::init_thread_fpu_state();
 671 
 672 #ifdef __APPLE__
 673   // register thread with objc gc
 674   if (objc_registerThreadWithCollectorFunction != NULL) {
 675     objc_registerThreadWithCollectorFunction();
 676   }
 677 #endif
 678 
 679   // handshaking with parent thread
 680   {
<span class="line-modified"> 681     MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);</span>
 682 
 683     // notify parent thread
 684     osthread-&gt;set_state(INITIALIZED);
 685     sync-&gt;notify_all();
 686 
 687     // wait until os::start_thread()
 688     while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified"> 689       sync-&gt;wait_without_safepoint_check();</span>
 690     }
 691   }
 692 
 693   // call one more level start routine
 694   thread-&gt;call_run();
 695 
 696   // Note: at this point the thread object may already have deleted itself.
 697   // Prevent dereferencing it from here on out.
 698   thread = NULL;
 699 
 700   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 701     os::current_thread_id(), (uintx) pthread_self());
 702 
 703   return 0;
 704 }
 705 
 706 bool os::create_thread(Thread* thread, ThreadType thr_type,
 707                        size_t req_stack_size) {
 708   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 709 
</pre>
<hr />
<pre>
 727   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
 728 
 729   // calculate stack size if it&#39;s not specified by caller
 730   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
 731   int status = pthread_attr_setstacksize(&amp;attr, stack_size);
 732   assert_status(status == 0, status, &quot;pthread_attr_setstacksize&quot;);
 733 
 734   ThreadState state;
 735 
 736   {
 737     pthread_t tid;
 738     int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 739 
 740     char buf[64];
 741     if (ret == 0) {
 742       log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 743         (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 744     } else {
 745       log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
 746         os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="line-added"> 747       // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 748       log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 749       LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 750       os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added"> 751       os::print_memory_info(&amp;st);</span>
 752     }
 753 
 754     pthread_attr_destroy(&amp;attr);
 755 
 756     if (ret != 0) {
 757       // Need to clean up stuff we&#39;ve allocated so far
 758       thread-&gt;set_osthread(NULL);
 759       delete osthread;
 760       return false;
 761     }
 762 
 763     // Store pthread info into the OSThread
 764     osthread-&gt;set_pthread_id(tid);
 765 
 766     // Wait until child thread is either initialized or aborted
 767     {
 768       Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 769       MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 770       while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified"> 771         sync_with_child-&gt;wait_without_safepoint_check();</span>
 772       }
 773     }
 774 
 775   }
 776 
 777   // Aborted due to thread limit being reached
 778   if (state == ZOMBIE) {
 779     thread-&gt;set_osthread(NULL);
 780     delete osthread;
 781     return false;
 782   }
 783 
 784   // The thread is returned suspended (in state INITIALIZED),
 785   // and is started higher up in the call chain
 786   assert(state == INITIALIZED, &quot;race condition&quot;);
 787   return true;
 788 }
 789 
 790 /////////////////////////////////////////////////////////////////////////////
 791 // attach existing thread
</pre>
<hr />
<pre>
 793 // bootstrap the main thread
 794 bool os::create_main_thread(JavaThread* thread) {
 795   assert(os::Bsd::_main_thread == pthread_self(), &quot;should be called inside main thread&quot;);
 796   return create_attached_thread(thread);
 797 }
 798 
 799 bool os::create_attached_thread(JavaThread* thread) {
 800 #ifdef ASSERT
 801   thread-&gt;verify_not_published();
 802 #endif
 803 
 804   // Allocate the OSThread object
 805   OSThread* osthread = new OSThread(NULL, NULL);
 806 
 807   if (osthread == NULL) {
 808     return false;
 809   }
 810 
 811   osthread-&gt;set_thread_id(os::Bsd::gettid());
 812 

 813 #ifdef __APPLE__
<span class="line-modified"> 814   // Store unique OS X thread id used by SA</span>
<span class="line-modified"> 815   osthread-&gt;set_unique_thread_id();</span>

 816 #endif
<span class="line-added"> 817 </span>
<span class="line-added"> 818   // Store pthread info into the OSThread</span>
 819   osthread-&gt;set_pthread_id(::pthread_self());
 820 
 821   // initialize floating point control register
 822   os::Bsd::init_thread_fpu_state();
 823 
 824   // Initial thread state is RUNNABLE
 825   osthread-&gt;set_state(RUNNABLE);
 826 
 827   thread-&gt;set_osthread(osthread);
 828 
 829   // initialize signal mask for this thread
 830   // and save the caller&#39;s signal mask
 831   os::Bsd::hotspot_sigmask(thread);
 832 
 833   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
 834     os::current_thread_id(), (uintx) pthread_self());
 835 
 836   return true;
 837 }
 838 
 839 void os::pd_start_thread(Thread* thread) {
 840   OSThread * osthread = thread-&gt;osthread();
 841   assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
 842   Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified"> 843   MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
 844   sync_with_child-&gt;notify();
 845 }
 846 
 847 // Free Bsd resources related to the OSThread
 848 void os::free_thread(OSThread* osthread) {
 849   assert(osthread != NULL, &quot;osthread not set&quot;);
 850 
 851   // We are told to free resources of the argument thread,
 852   // but we can only really operate on the current thread.
 853   assert(Thread::current()-&gt;osthread() == osthread,
 854          &quot;os::free_thread but not current thread&quot;);
 855 
 856   // Restore caller&#39;s signal mask
 857   sigset_t sigmask = osthread-&gt;caller_sigmask();
 858   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
 859 
 860   delete osthread;
 861 }
 862 
 863 ////////////////////////////////////////////////////////////////////////////////
 864 // time support
 865 
 866 // Time since start-up in seconds to a fine granularity.
 867 // Used by VMSelfDestructTimer and the MemProfiler.
 868 double os::elapsedTime() {
 869 
 870   return ((double)os::elapsed_counter()) / os::elapsed_frequency();
 871 }
 872 
 873 jlong os::elapsed_counter() {
 874   return javaTimeNanos() - initial_time_count;
 875 }
 876 
 877 jlong os::elapsed_frequency() {
 878   return NANOSECS_PER_SEC; // nanosecond resolution
 879 }
 880 
 881 bool os::supports_vtime() { return true; }


 882 
 883 double os::elapsedVTime() {
 884   // better than nothing, but not much
 885   return elapsedTime();
 886 }
 887 
 888 jlong os::javaTimeMillis() {
 889   timeval time;
 890   int status = gettimeofday(&amp;time, NULL);
 891   assert(status != -1, &quot;bsd error&quot;);
 892   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
 893 }
 894 
 895 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 896   timeval time;
 897   int status = gettimeofday(&amp;time, NULL);
 898   assert(status != -1, &quot;bsd error&quot;);
 899   seconds = jlong(time.tv_sec);
 900   nanos = jlong(time.tv_usec) * 1000;
 901 }
</pre>
<hr />
<pre>
 916   struct timespec tp;
 917   if (::clock_getres(CLOCK_MONOTONIC, &amp;res) == 0 &amp;&amp;
 918       ::clock_gettime(CLOCK_MONOTONIC, &amp;tp)  == 0) {
 919     // yes, monotonic clock is supported
 920     _clock_gettime = ::clock_gettime;
 921   }
 922 }
 923 #endif
 924 
 925 
 926 
 927 #ifdef __APPLE__
 928 
 929 jlong os::javaTimeNanos() {
 930   const uint64_t tm = mach_absolute_time();
 931   const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
 932   const uint64_t prev = Bsd::_max_abstime;
 933   if (now &lt;= prev) {
 934     return prev;   // same or retrograde time;
 935   }
<span class="line-modified"> 936   const uint64_t obsv = Atomic::cmpxchg(&amp;Bsd::_max_abstime, prev, now);</span>
 937   assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
 938   // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
 939   // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
 940   // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
 941   // some other thread raced this thread and installed a new value, in which case
 942   // we could either (a) retry the entire operation, (b) retry trying to install now
 943   // or (c) just return obsv.  We use (c).   No loop is required although in some cases
 944   // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
 945   // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
 946   // to (a) or (b) -- and greatly reduces coherence traffic.
 947   // We might also condition (c) on the magnitude of the delta between obsv and now.
 948   // Avoiding excessive CAS operations to hot RW locations is critical.
 949   // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
 950   return (prev == obsv) ? now : obsv;
 951 }
 952 
 953 #else // __APPLE__
 954 
 955 jlong os::javaTimeNanos() {
 956   if (os::supports_monotonic_clock()) {
</pre>
<hr />
<pre>
1054 // called from signal handler. Before adding something to os::abort(), make
1055 // sure it is async-safe and can handle partially initialized VM.
1056 void os::abort(bool dump_core, void* siginfo, const void* context) {
1057   os::shutdown();
1058   if (dump_core) {
1059 #ifndef PRODUCT
1060     fdStream out(defaultStream::output_fd());
1061     out.print_raw(&quot;Current thread is &quot;);
1062     char buf[16];
1063     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1064     out.print_raw_cr(buf);
1065     out.print_raw_cr(&quot;Dumping core ...&quot;);
1066 #endif
1067     ::abort(); // dump core
1068   }
1069 
1070   ::exit(1);
1071 }
1072 
1073 // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">1074 // Dump a core file, if possible, for debugging.</span>
1075 void os::die() {
<span class="line-modified">1076   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-modified">1077     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">1078     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">1079     os::signal_raise(SIGKILL);</span>
<span class="line-added">1080   } else {</span>
<span class="line-added">1081     // _exit() on BsdThreads only kills current thread</span>
<span class="line-added">1082     ::abort();</span>
<span class="line-added">1083   }</span>
1084 }
1085 
1086 // Information of current thread in variety of formats
1087 pid_t os::Bsd::gettid() {
1088   int retval = -1;
1089 
<span class="line-modified">1090 #ifdef __APPLE__ // XNU kernel</span>
<span class="line-modified">1091   mach_port_t port = mach_thread_self();</span>
<span class="line-modified">1092   guarantee(MACH_PORT_VALID(port), &quot;just checking&quot;);</span>
<span class="line-modified">1093   mach_port_deallocate(mach_task_self(), port);</span>
<span class="line-modified">1094   return (pid_t)port;</span>

1095 
1096 #else
1097   #ifdef __FreeBSD__
1098   retval = syscall(SYS_thr_self);
1099   #else
1100     #ifdef __OpenBSD__
1101   retval = syscall(SYS_getthrid);
1102     #else
1103       #ifdef __NetBSD__
1104   retval = (pid_t) syscall(SYS__lwp_self);
1105       #endif
1106     #endif
1107   #endif
1108 #endif
1109 
1110   if (retval == -1) {
1111     return getpid();
1112   }
1113 }
1114 
1115 intx os::current_thread_id() {
1116 #ifdef __APPLE__
<span class="line-modified">1117   return (intx)os::Bsd::gettid();</span>
1118 #else
1119   return (intx)::pthread_self();
1120 #endif
1121 }
1122 
1123 int os::current_process_id() {
<span class="line-modified">1124   return (int)(getpid());</span>

















1125 }
1126 
1127 // DLL functions
1128 
1129 const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
1130 
1131 // This must be hard coded because it&#39;s the system&#39;s temporary
1132 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1133 #ifdef __APPLE__
1134 // macosx has a secure per-user temporary directory
1135 char temp_path_storage[PATH_MAX];
1136 const char* os::get_temp_directory() {
1137   static char *temp_path = NULL;
1138   if (temp_path == NULL) {
1139     int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);
1140     if (pathSize == 0 || pathSize &gt; PATH_MAX) {
1141       strlcpy(temp_path_storage, &quot;/tmp/&quot;, sizeof(temp_path_storage));
1142     }
1143     temp_path = temp_path_storage;
1144   }
</pre>
<hr />
<pre>
1226     if (dlinfo.dli_fbase != NULL &amp;&amp; offset != NULL) {
1227       *offset = addr - (address)dlinfo.dli_fbase;
1228     }
1229     return true;
1230   }
1231 
1232   buf[0] = &#39;\0&#39;;
1233   if (offset) *offset = -1;
1234   return false;
1235 }
1236 
1237 // Loads .dll/.so and
1238 // in case of error it checks if .dll/.so was built for the
1239 // same architecture as Hotspot is running on
1240 
1241 #ifdef __APPLE__
1242 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1243 #ifdef STATIC_BUILD
1244   return os::get_default_process_handle();
1245 #else
<span class="line-added">1246   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">1247 </span>
1248   void * result= ::dlopen(filename, RTLD_LAZY);
1249   if (result != NULL) {
<span class="line-added">1250     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
1251     // Successful loading
<span class="line-added">1252     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1253     return result;
1254   }
1255 
<span class="line-modified">1256   const char* error_report = ::dlerror();</span>
<span class="line-modified">1257   if (error_report == NULL) {</span>
<span class="line-modified">1258     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">1259   }</span>
<span class="line-added">1260   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">1261     // Read system error message into ebuf</span>
<span class="line-added">1262     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">1263     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">1264   }</span>
<span class="line-added">1265   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1266   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
1267 
1268   return NULL;
1269 #endif // STATIC_BUILD
1270 }
1271 #else
1272 void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1273 #ifdef STATIC_BUILD
1274   return os::get_default_process_handle();
1275 #else
<span class="line-added">1276   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
1277   void * result= ::dlopen(filename, RTLD_LAZY);
1278   if (result != NULL) {
<span class="line-added">1279     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
1280     // Successful loading
<span class="line-added">1281     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1282     return result;
1283   }
1284 
1285   Elf32_Ehdr elf_head;
1286 
<span class="line-modified">1287   const char* const error_report = ::dlerror();</span>
<span class="line-modified">1288   if (error_report == NULL) {</span>
<span class="line-modified">1289     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-modified">1290   }</span>
<span class="line-added">1291   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">1292     // Read system error message into ebuf</span>
<span class="line-added">1293     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">1294     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">1295   }</span>
<span class="line-added">1296   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1297   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1298 </span>
1299   int diag_msg_max_length=ebuflen-strlen(ebuf);
1300   char* diag_msg_buf=ebuf+strlen(ebuf);
1301 
1302   if (diag_msg_max_length==0) {
1303     // No more space in ebuf for additional diagnostics message
1304     return NULL;
1305   }
1306 
1307 
1308   int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);
1309 
1310   if (file_descriptor &lt; 0) {
1311     // Can&#39;t open library, report dlerror() message
1312     return NULL;
1313   }
1314 
1315   bool failed_to_read_elf_head=
1316     (sizeof(elf_head)!=
1317      (::read(file_descriptor, &amp;elf_head,sizeof(elf_head))));
1318 
</pre>
<hr />
<pre>
1554 
1555   char release[100];
1556   size = sizeof(release);
1557   int mib_release[] = { CTL_KERN, KERN_OSRELEASE };
1558   if (sysctl(mib_release, 2, release, &amp;size, NULL, 0) &lt; 0) {
1559       // if error, leave blank
1560       strncpy(release, &quot;&quot;, sizeof(release));
1561   }
1562   snprintf(buf, buflen, &quot;%s %s&quot;, os, release);
1563 }
1564 
1565 void os::print_os_info_brief(outputStream* st) {
1566   os::Posix::print_uname_info(st);
1567 }
1568 
1569 void os::print_os_info(outputStream* st) {
1570   st-&gt;print(&quot;OS:&quot;);
1571 
1572   os::Posix::print_uname_info(st);
1573 
<span class="line-added">1574   os::Bsd::print_uptime_info(st);</span>
<span class="line-added">1575 </span>
1576   os::Posix::print_rlimit_info(st);
1577 
1578   os::Posix::print_load_average(st);
1579 }
1580 
1581 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1582   // Nothing to do for now.
1583 }
1584 
1585 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1586   unsigned int mhz;
1587   size_t size = sizeof(mhz);
1588   int mib[] = { CTL_HW, HW_CPU_FREQ };
1589   if (sysctl(mib, 2, &amp;mhz, &amp;size, NULL, 0) &lt; 0) {
1590     mhz = 1;  // looks like an error but can be divided by
1591   } else {
1592     mhz /= 1000000;  // reported in millions
1593   }
1594 
1595   char model[100];
1596   size = sizeof(model);
1597   int mib_model[] = { CTL_HW, HW_MODEL };
1598   if (sysctl(mib_model, 2, model, &amp;size, NULL, 0) &lt; 0) {
1599     strncpy(model, cpu_arch, sizeof(model));
1600   }
1601 
1602   char machine[100];
1603   size = sizeof(machine);
1604   int mib_machine[] = { CTL_HW, HW_MACHINE };
1605   if (sysctl(mib_machine, 2, machine, &amp;size, NULL, 0) &lt; 0) {
1606       strncpy(machine, &quot;&quot;, sizeof(machine));
1607   }
1608 
1609   snprintf(buf, buflen, &quot;%s %s %d MHz&quot;, model, machine, mhz);
1610 }
1611 
1612 void os::print_memory_info(outputStream* st) {
<span class="line-added">1613   xsw_usage swap_usage;</span>
<span class="line-added">1614   size_t size = sizeof(swap_usage);</span>
1615 
1616   st-&gt;print(&quot;Memory:&quot;);
1617   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1618 
1619   st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
1620             os::physical_memory() &gt;&gt; 10);
1621   st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
1622             os::available_memory() &gt;&gt; 10);
<span class="line-added">1623 </span>
<span class="line-added">1624   if((sysctlbyname(&quot;vm.swapusage&quot;, &amp;swap_usage, &amp;size, NULL, 0) == 0) || (errno == ENOMEM)) {</span>
<span class="line-added">1625     if (size &gt;= offset_of(xsw_usage, xsu_used)) {</span>
<span class="line-added">1626       st-&gt;print(&quot;, swap &quot; UINT64_FORMAT &quot;k&quot;,</span>
<span class="line-added">1627                 ((julong) swap_usage.xsu_total) &gt;&gt; 10);</span>
<span class="line-added">1628       st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,</span>
<span class="line-added">1629                 ((julong) swap_usage.xsu_avail) &gt;&gt; 10);</span>
<span class="line-added">1630     }</span>
<span class="line-added">1631   }</span>
<span class="line-added">1632 </span>
1633   st-&gt;cr();
1634 }
1635 
1636 static void print_signal_handler(outputStream* st, int sig,
1637                                  char* buf, size_t buflen);
1638 
1639 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1640   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1641   print_signal_handler(st, SIGSEGV, buf, buflen);
1642   print_signal_handler(st, SIGBUS , buf, buflen);
1643   print_signal_handler(st, SIGFPE , buf, buflen);
1644   print_signal_handler(st, SIGPIPE, buf, buflen);
1645   print_signal_handler(st, SIGXFSZ, buf, buflen);
1646   print_signal_handler(st, SIGILL , buf, buflen);
1647   print_signal_handler(st, SR_signum, buf, buflen);
1648   print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);
1649   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
1650   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
1651   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
1652 }
</pre>
<hr />
<pre>
1747         }
1748       }
1749     }
1750   }
1751 
1752   strncpy(saved_jvm_path, buf, MAXPATHLEN);
1753   saved_jvm_path[MAXPATHLEN - 1] = &#39;\0&#39;;
1754 }
1755 
1756 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1757   // no prefix required, not even &quot;_&quot;
1758 }
1759 
1760 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1761   // no suffix required
1762 }
1763 
1764 ////////////////////////////////////////////////////////////////////////////////
1765 // sun.misc.Signal support
1766 


1767 static void UserHandler(int sig, void *siginfo, void *context) {







1768   // Ctrl-C is pressed during error reporting, likely because the error
1769   // handler fails to abort. Let VM die immediately.
1770   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1771     os::die();
1772   }
1773 
1774   os::signal_notify(sig);
1775 }
1776 
1777 void* os::user_handler() {
1778   return CAST_FROM_FN_PTR(void*, UserHandler);
1779 }
1780 
1781 extern &quot;C&quot; {
1782   typedef void (*sa_handler_t)(int);
1783   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1784 }
1785 
1786 void* os::signal(int signal_number, void* handler) {
1787   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
1817 static void jdk_misc_signal_init() {
1818   // Initialize signal structures
1819   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1820 
1821   // Initialize signal semaphore
1822   sig_sem = new Semaphore();
1823 }
1824 
1825 void os::signal_notify(int sig) {
1826   if (sig_sem != NULL) {
1827     Atomic::inc(&amp;pending_signals[sig]);
1828     sig_sem-&gt;signal();
1829   } else {
1830     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
1831     // initialization isn&#39;t called.
1832     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
1833   }
1834 }
1835 
1836 static int check_pending_signals() {

1837   for (;;) {
1838     for (int i = 0; i &lt; NSIG + 1; i++) {
1839       jint n = pending_signals[i];
<span class="line-modified">1840       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
1841         return i;
1842       }
1843     }
1844     JavaThread *thread = JavaThread::current();
1845     ThreadBlockInVM tbivm(thread);
1846 
1847     bool threadIsSuspended;
1848     do {
1849       thread-&gt;set_suspend_equivalent();
1850       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1851       sig_sem-&gt;wait();
1852 
1853       // were we externally suspended while we were waiting?
1854       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1855       if (threadIsSuspended) {
1856         // The semaphore has been incremented, but while we were waiting
1857         // another thread suspended us. We don&#39;t want to continue running
1858         // while suspended because that would surprise the thread that
1859         // suspended us.
1860         sig_sem-&gt;signal();
</pre>
<hr />
<pre>
1881 // Solaris allocates memory by pages.
1882 int os::vm_allocation_granularity() {
1883   assert(os::Bsd::page_size() != -1, &quot;must call os::init&quot;);
1884   return os::Bsd::page_size();
1885 }
1886 
1887 // Rationale behind this function:
1888 //  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable
1889 //  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get
1890 //  samples for JITted code. Here we create private executable mapping over the code cache
1891 //  and then we can use standard (well, almost, as mapping can change) way to provide
1892 //  info for the reporting script by storing timestamp and location of symbol
1893 void bsd_wrap_code(char* base, size_t size) {
1894   static volatile jint cnt = 0;
1895 
1896   if (!UseOprofile) {
1897     return;
1898   }
1899 
1900   char buf[PATH_MAX + 1];
<span class="line-modified">1901   int num = Atomic::add(&amp;cnt, 1);</span>
1902 
1903   snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,
1904            os::get_temp_directory(), os::current_process_id(), num);
1905   unlink(buf);
1906 
1907   int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);
1908 
1909   if (fd != -1) {
1910     off_t rv = ::lseek(fd, size-2, SEEK_SET);
1911     if (rv != (off_t)-1) {
1912       if (::write(fd, &quot;&quot;, 1) == 1) {
1913         mmap(base, size,
1914              PROT_READ|PROT_WRITE|PROT_EXEC,
1915              MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);
1916       }
1917     }
1918     ::close(fd);
1919     unlink(buf);
1920   }
1921 }
1922 
1923 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
1924                                     int err) {
1925   warning(&quot;INFO: os::commit_memory(&quot; INTPTR_FORMAT &quot;, &quot; SIZE_FORMAT
1926           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, (intptr_t)addr, size, exec,
1927            os::errno_name(err), err);
1928 }
1929 
1930 // NOTE: Bsd kernel does not really reserve the pages for us.
1931 //       All it does is to check if there are enough free pages
1932 //       left at the time of mmap(). This could be a potential
1933 //       problem.
1934 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
1935   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
1936 #ifdef __OpenBSD__
1937   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<span class="line-added">1938   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
1939   if (::mprotect(addr, size, prot) == 0) {
1940     return true;
1941   }
1942 #else
1943   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
1944                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
1945   if (res != (uintptr_t) MAP_FAILED) {
1946     return true;
1947   }
1948 #endif
1949 
1950   // Warn about any commit errors we see in non-product builds just
1951   // in case mmap() doesn&#39;t work as described on the man page.
1952   NOT_PRODUCT(warn_fail_commit_memory(addr, size, exec, errno);)
1953 
1954   return false;
1955 }
1956 
1957 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
1958                           bool exec) {
</pre>
<hr />
<pre>
1991 }
1992 
1993 bool os::numa_topology_changed()   { return false; }
1994 
1995 size_t os::numa_get_groups_num() {
1996   return 1;
1997 }
1998 
1999 int os::numa_get_group_id() {
2000   return 0;
2001 }
2002 
2003 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
2004   if (size &gt; 0) {
2005     ids[0] = 0;
2006     return 1;
2007   }
2008   return 0;
2009 }
2010 
<span class="line-added">2011 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">2012   return 0;</span>
<span class="line-added">2013 }</span>
<span class="line-added">2014 </span>
2015 bool os::get_page_info(char *start, page_info* info) {
2016   return false;
2017 }
2018 
2019 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
2020   return end;
2021 }
2022 
2023 
2024 bool os::pd_uncommit_memory(char* addr, size_t size) {
2025 #ifdef __OpenBSD__
2026   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<span class="line-added">2027   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with PROT_NONE&quot;, p2i(addr), p2i(addr+size));</span>
2028   return ::mprotect(addr, size, PROT_NONE) == 0;
2029 #else
2030   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
2031                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
2032   return res  != (uintptr_t) MAP_FAILED;
2033 #endif
2034 }
2035 
2036 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
2037   return os::commit_memory(addr, size, !ExecMem);
2038 }
2039 
2040 // If this is a growable mapping, remove the guard pages entirely by
2041 // munmap()ping them.  If not, just call uncommit_memory().
2042 bool os::remove_stack_guard_pages(char* addr, size_t size) {
2043   return os::uncommit_memory(addr, size);
2044 }
2045 
2046 // If &#39;fixed&#39; is true, anon_mmap() will attempt to reserve anonymous memory
2047 // at &#39;requested_addr&#39;. If there are existing memory mappings at the same
</pre>
<hr />
<pre>
2076                             size_t alignment_hint) {
2077   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
2078 }
2079 
2080 bool os::pd_release_memory(char* addr, size_t size) {
2081   return anon_munmap(addr, size);
2082 }
2083 
2084 static bool bsd_mprotect(char* addr, size_t size, int prot) {
2085   // Bsd wants the mprotect address argument to be page aligned.
2086   char* bottom = (char*)align_down((intptr_t)addr, os::Bsd::page_size());
2087 
2088   // According to SUSv3, mprotect() should only be used with mappings
2089   // established by mmap(), and mmap() always maps whole pages. Unaligned
2090   // &#39;addr&#39; likely indicates problem in the VM (e.g. trying to change
2091   // protection of malloc&#39;ed or statically allocated memory). Check the
2092   // caller if you hit this assert.
2093   assert(addr == bottom, &quot;sanity check&quot;);
2094 
2095   size = align_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());
<span class="line-added">2096   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(bottom), p2i(bottom+size), prot);</span>
2097   return ::mprotect(bottom, size, prot) == 0;
2098 }
2099 
2100 // Set protections specified
2101 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
2102                         bool is_committed) {
2103   unsigned int p = 0;
2104   switch (prot) {
2105   case MEM_PROT_NONE: p = PROT_NONE; break;
2106   case MEM_PROT_READ: p = PROT_READ; break;
2107   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2108   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2109   default:
2110     ShouldNotReachHere();
2111   }
2112   // is_committed is unused.
2113   return bsd_mprotect(addr, bytes, p);
2114 }
2115 
2116 bool os::guard_memory(char* addr, size_t size) {
</pre>
<hr />
<pre>
2155 bool os::can_execute_large_page_memory() {
2156   // Does not matter, we do not support huge pages.
2157   return false;
2158 }
2159 
2160 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2161   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2162   char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);
2163   if (result != NULL) {
2164     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2165       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2166     }
2167   }
2168   return result;
2169 }
2170 
2171 // Reserve memory at an arbitrary address, only if that area is
2172 // available (and not reserved for something else).
2173 
2174 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {





2175   // Assert only that the size is a multiple of the page size, since
2176   // that&#39;s all that mmap requires, and since that&#39;s all we really know
2177   // about at this low abstraction level.  If we need higher alignment,
2178   // we can either pass an alignment to this method or verify alignment
2179   // in one of the methods further up the call chain.  See bug 5044738.
2180   assert(bytes % os::vm_page_size() == 0, &quot;reserving unexpected size block&quot;);
2181 
2182   // Repeatedly allocate blocks until the block is allocated at the
2183   // right spot.
2184 
2185   // Bsd mmap allows caller to pass an address as hint; give it a try first,
2186   // if kernel honors the hint then we can return immediately.
2187   char * addr = anon_mmap(requested_addr, bytes, false);
2188   if (addr == requested_addr) {
2189     return requested_addr;
2190   }
2191 
2192   if (addr != NULL) {
2193     // mmap() is successful but it fails to reserve at the requested address
2194     anon_munmap(addr, bytes);
2195   }
2196 
<span class="line-modified">2197   return NULL;</span>











































2198 }
2199 
2200 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2201 void os::infinite_sleep() {
2202   while (true) {    // sleep forever ...
2203     ::sleep(100);   // ... 100 seconds at a time
2204   }
2205 }
2206 
2207 // Used to convert frequent JVM_Yield() to nops
2208 bool os::dont_yield() {
2209   return DontYieldALot;
2210 }
2211 
2212 void os::naked_yield() {
2213   sched_yield();
2214 }
2215 
2216 ////////////////////////////////////////////////////////////////////////////////
2217 // thread priority support
</pre>
<hr />
<pre>
2835     // exception handling, while leaving the standard BSD signal handlers functional.
2836     kern_return_t kr;
2837     kr = task_set_exception_ports(mach_task_self(),
2838                                   EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
2839                                   MACH_PORT_NULL,
2840                                   EXCEPTION_STATE_IDENTITY,
2841                                   MACHINE_THREAD_STATE);
2842 
2843     assert(kr == KERN_SUCCESS, &quot;could not set mach task signal handler&quot;);
2844 #endif
2845 
2846     if (libjsig_is_loaded) {
2847       // Tell libjsig jvm finishes setting signal handlers
2848       (*end_signal_setting)();
2849     }
2850 
2851     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
2852     // and if UserSignalHandler is installed all bets are off
2853     if (CheckJNICalls) {
2854       if (libjsig_is_loaded) {
<span class="line-modified">2855         log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>


2856         check_signals = false;
2857       }
2858       if (AllowUserSignalHandlers) {
<span class="line-modified">2859         log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>


2860         check_signals = false;
2861       }
2862     }
2863   }
2864 }
2865 
2866 
2867 /////
2868 // glibc on Bsd platform uses non-documented flag
2869 // to indicate, that some special sort of signal
2870 // trampoline is used.
2871 // We will never set this flag, and we should
2872 // ignore this flag in our diagnostic
2873 #ifdef SIGNIFICANT_SIGNAL_MASK
2874   #undef SIGNIFICANT_SIGNAL_MASK
2875 #endif
2876 #define SIGNIFICANT_SIGNAL_MASK (~0x04000000)
2877 
2878 static const char* get_signal_handler_name(address handler,
2879                                            char* buf, int buflen) {
</pre>
<hr />
<pre>
3052     tty-&gt;print(&quot;  found:&quot;);
3053     os::Posix::print_sa_flags(tty, act.sa_flags);
3054     tty-&gt;cr();
3055     // No need to check this sig any longer
3056     sigaddset(&amp;check_signal_done, sig);
3057   }
3058 
3059   // Dump all the signal
3060   if (sigismember(&amp;check_signal_done, sig)) {
3061     print_signal_handlers(tty, buf, O_BUFLEN);
3062   }
3063 }
3064 
3065 extern void report_error(char* file_name, int line_no, char* title,
3066                          char* format, ...);
3067 
3068 // this is called _before_ the most of global arguments have been parsed
3069 void os::init(void) {
3070   char dummy;   // used to get a guess on initial stack address
3071 










3072   clock_tics_per_sec = CLK_TCK;
3073 
3074   init_random(1234567);
3075 
3076   Bsd::set_page_size(getpagesize());
3077   if (Bsd::page_size() == -1) {
3078     fatal(&quot;os_bsd.cpp: os::init: sysconf failed (%s)&quot;, os::strerror(errno));
3079   }
3080   init_page_sizes((size_t) Bsd::page_size());
3081 
3082   Bsd::initialize_system_info();
3083 
3084   // _main_thread points to the thread that created/loaded the JVM.
3085   Bsd::_main_thread = pthread_self();
3086 
3087   Bsd::clock_init();
3088   initial_time_count = javaTimeNanos();
3089 
3090   os::Posix::init();
3091 }
</pre>
<hr />
<pre>
3190 
3191 // Mark the polling page as readable
3192 void os::make_polling_page_readable(void) {
3193   if (!bsd_mprotect((char *)_polling_page, Bsd::page_size(), PROT_READ)) {
3194     fatal(&quot;Could not enable polling page&quot;);
3195   }
3196 }
3197 
3198 int os::active_processor_count() {
3199   // User has overridden the number of active processors
3200   if (ActiveProcessorCount &gt; 0) {
3201     log_trace(os)(&quot;active_processor_count: &quot;
3202                   &quot;active processor count set by user : %d&quot;,
3203                   ActiveProcessorCount);
3204     return ActiveProcessorCount;
3205   }
3206 
3207   return _processor_count;
3208 }
3209 
<span class="line-added">3210 #ifdef __APPLE__</span>
<span class="line-added">3211 static volatile int* volatile apic_to_processor_mapping = NULL;</span>
<span class="line-added">3212 static volatile int next_processor_id = 0;</span>
<span class="line-added">3213 </span>
<span class="line-added">3214 static inline volatile int* get_apic_to_processor_mapping() {</span>
<span class="line-added">3215   volatile int* mapping = Atomic::load_acquire(&amp;apic_to_processor_mapping);</span>
<span class="line-added">3216   if (mapping == NULL) {</span>
<span class="line-added">3217     // Calculate possible number space for APIC ids. This space is not necessarily</span>
<span class="line-added">3218     // in the range [0, number_of_processors).</span>
<span class="line-added">3219     uint total_bits = 0;</span>
<span class="line-added">3220     for (uint i = 0;; ++i) {</span>
<span class="line-added">3221       uint eax = 0xb; // Query topology leaf</span>
<span class="line-added">3222       uint ebx;</span>
<span class="line-added">3223       uint ecx = i;</span>
<span class="line-added">3224       uint edx;</span>
<span class="line-added">3225 </span>
<span class="line-added">3226       __asm__ (&quot;cpuid\n\t&quot; : &quot;+a&quot; (eax), &quot;+b&quot; (ebx), &quot;+c&quot; (ecx), &quot;+d&quot; (edx) : );</span>
<span class="line-added">3227 </span>
<span class="line-added">3228       uint level_type = (ecx &gt;&gt; 8) &amp; 0xFF;</span>
<span class="line-added">3229       if (level_type == 0) {</span>
<span class="line-added">3230         // Invalid level; end of topology</span>
<span class="line-added">3231         break;</span>
<span class="line-added">3232       }</span>
<span class="line-added">3233       uint level_apic_id_shift = eax &amp; ((1u &lt;&lt; 5) - 1);</span>
<span class="line-added">3234       total_bits += level_apic_id_shift;</span>
<span class="line-added">3235     }</span>
<span class="line-added">3236 </span>
<span class="line-added">3237     uint max_apic_ids = 1u &lt;&lt; total_bits;</span>
<span class="line-added">3238     mapping = NEW_C_HEAP_ARRAY(int, max_apic_ids, mtInternal);</span>
<span class="line-added">3239 </span>
<span class="line-added">3240     for (uint i = 0; i &lt; max_apic_ids; ++i) {</span>
<span class="line-added">3241       mapping[i] = -1;</span>
<span class="line-added">3242     }</span>
<span class="line-added">3243 </span>
<span class="line-added">3244     if (!Atomic::replace_if_null(&amp;apic_to_processor_mapping, mapping)) {</span>
<span class="line-added">3245       FREE_C_HEAP_ARRAY(int, mapping);</span>
<span class="line-added">3246       mapping = Atomic::load_acquire(&amp;apic_to_processor_mapping);</span>
<span class="line-added">3247     }</span>
<span class="line-added">3248   }</span>
<span class="line-added">3249 </span>
<span class="line-added">3250   return mapping;</span>
<span class="line-added">3251 }</span>
<span class="line-added">3252 </span>
<span class="line-added">3253 uint os::processor_id() {</span>
<span class="line-added">3254   volatile int* mapping = get_apic_to_processor_mapping();</span>
<span class="line-added">3255 </span>
<span class="line-added">3256   uint eax = 0xb;</span>
<span class="line-added">3257   uint ebx;</span>
<span class="line-added">3258   uint ecx = 0;</span>
<span class="line-added">3259   uint edx;</span>
<span class="line-added">3260 </span>
<span class="line-added">3261   __asm__ (&quot;cpuid\n\t&quot; : &quot;+a&quot; (eax), &quot;+b&quot; (ebx), &quot;+c&quot; (ecx), &quot;+d&quot; (edx) : );</span>
<span class="line-added">3262 </span>
<span class="line-added">3263   // Map from APIC id to a unique logical processor ID in the expected</span>
<span class="line-added">3264   // [0, num_processors) range.</span>
<span class="line-added">3265 </span>
<span class="line-added">3266   uint apic_id = edx;</span>
<span class="line-added">3267   int processor_id = Atomic::load(&amp;mapping[apic_id]);</span>
<span class="line-added">3268 </span>
<span class="line-added">3269   while (processor_id &lt; 0) {</span>
<span class="line-added">3270     if (Atomic::cmpxchg(&amp;mapping[apic_id], -1, -2) == -1) {</span>
<span class="line-added">3271       Atomic::store(&amp;mapping[apic_id], Atomic::add(&amp;next_processor_id, 1) - 1);</span>
<span class="line-added">3272     }</span>
<span class="line-added">3273     processor_id = Atomic::load(&amp;mapping[apic_id]);</span>
<span class="line-added">3274   }</span>
<span class="line-added">3275 </span>
<span class="line-added">3276   assert(processor_id &gt;= 0 &amp;&amp; processor_id &lt; os::processor_count(), &quot;invalid processor id&quot;);</span>
<span class="line-added">3277 </span>
<span class="line-added">3278   return (uint)processor_id;</span>
<span class="line-added">3279 }</span>
<span class="line-added">3280 #endif</span>
<span class="line-added">3281 </span>
3282 void os::set_native_thread_name(const char *name) {
3283 #if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5
3284   // This is only supported in Snow Leopard and beyond
3285   if (name != NULL) {
3286     // Add a &quot;Java: &quot; prefix to the name
3287     char buf[MAXTHREADNAMESIZE];
3288     snprintf(buf, sizeof(buf), &quot;Java: %s&quot;, name);
3289     pthread_setname_np(buf);
3290   }
3291 #endif
3292 }
3293 





3294 bool os::bind_to_processor(uint processor_id) {
3295   // Not yet implemented.
3296   return false;
3297 }
3298 
3299 void os::SuspendedThreadTask::internal_do_task() {
3300   if (do_suspend(_thread-&gt;osthread())) {
3301     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3302     do_task(context);
3303     do_resume(_thread-&gt;osthread());
3304   }
3305 }
3306 
3307 ////////////////////////////////////////////////////////////////////////////////
3308 // debug support
3309 
3310 bool os::find(address addr, outputStream* st) {
3311   Dl_info dlinfo;
3312   memset(&amp;dlinfo, 0, sizeof(dlinfo));
3313   if (dladdr(addr, &amp;dlinfo) != 0) {
</pre>
<hr />
<pre>
3658 }
3659 
3660 bool os::is_thread_cpu_time_supported() {
3661 #ifdef __APPLE__
3662   return true;
3663 #else
3664   return false;
3665 #endif
3666 }
3667 
3668 // System loadavg support.  Returns -1 if load average cannot be obtained.
3669 // Bsd doesn&#39;t yet have a (official) notion of processor sets,
3670 // so just return the system wide load average.
3671 int os::loadavg(double loadavg[], int nelem) {
3672   return ::getloadavg(loadavg, nelem);
3673 }
3674 
3675 void os::pause() {
3676   char filename[MAX_PATH];
3677   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">3678     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
3679   } else {
3680     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
3681   }
3682 
3683   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
3684   if (fd != -1) {
3685     struct stat buf;
3686     ::close(fd);
3687     while (::stat(filename, &amp;buf) == 0) {
3688       (void)::poll(NULL, 0, 100);
3689     }
3690   } else {
3691     jio_fprintf(stderr,
3692                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
3693   }
3694 }
3695 
3696 // Darwin has no &quot;environ&quot; in a dynamic library.
3697 #ifdef __APPLE__
3698   #include &lt;crt_externs.h&gt;
</pre>
<hr />
<pre>
3750       }
3751     }
3752 
3753     if (WIFEXITED(status)) {
3754       // The child exited normally; get its exit code.
3755       return WEXITSTATUS(status);
3756     } else if (WIFSIGNALED(status)) {
3757       // The child exited because of a signal
3758       // The best value to return is 0x80 + signal number,
3759       // because that is what all Unix shells do, and because
3760       // it allows callers to distinguish between process exit and
3761       // process death by signal.
3762       return 0x80 + WTERMSIG(status);
3763     } else {
3764       // Unknown exit code; pass it through
3765       return status;
3766     }
3767   }
3768 }
3769 
<span class="line-modified">3770 // Get the kern.corefile setting, or otherwise the default path to the core file</span>
3771 // Returns the length of the string
3772 int os::get_core_path(char* buffer, size_t bufferSize) {
<span class="line-modified">3773   int n = 0;</span>
<span class="line-modified">3774 #ifdef __APPLE__</span>
<span class="line-added">3775   char coreinfo[MAX_PATH];</span>
<span class="line-added">3776   size_t sz = sizeof(coreinfo);</span>
<span class="line-added">3777   int ret = sysctlbyname(&quot;kern.corefile&quot;, coreinfo, &amp;sz, NULL, 0);</span>
<span class="line-added">3778   if (ret == 0) {</span>
<span class="line-added">3779     char *pid_pos = strstr(coreinfo, &quot;%P&quot;);</span>
<span class="line-added">3780     // skip over the &quot;%P&quot; to preserve any optional custom user pattern</span>
<span class="line-added">3781     const char* tail = (pid_pos != NULL) ? (pid_pos + 2) : &quot;&quot;;</span>
<span class="line-added">3782 </span>
<span class="line-added">3783     if (pid_pos != NULL) {</span>
<span class="line-added">3784       *pid_pos = &#39;\0&#39;;</span>
<span class="line-added">3785       n = jio_snprintf(buffer, bufferSize, &quot;%s%d%s&quot;, coreinfo, os::current_process_id(), tail);</span>
<span class="line-added">3786     } else {</span>
<span class="line-added">3787       n = jio_snprintf(buffer, bufferSize, &quot;%s&quot;, coreinfo);</span>
<span class="line-added">3788     }</span>
<span class="line-added">3789   } else</span>
<span class="line-added">3790 #endif</span>
<span class="line-added">3791   {</span>
<span class="line-added">3792     n = jio_snprintf(buffer, bufferSize, &quot;/cores/core.%d&quot;, os::current_process_id());</span>
<span class="line-added">3793   }</span>
3794   // Truncate if theoretical string was longer than bufferSize
3795   n = MIN2(n, (int)bufferSize);
3796 
3797   return n;
3798 }
3799 
<span class="line-added">3800 bool os::supports_map_sync() {</span>
<span class="line-added">3801   return false;</span>
<span class="line-added">3802 }</span>
<span class="line-added">3803 </span>
3804 #ifndef PRODUCT
3805 void TestReserveMemorySpecial_test() {
3806   // No tests available for this platform
3807 }
3808 #endif
3809 
3810 bool os::start_debugging(char *buf, int buflen) {
3811   int len = (int)strlen(buf);
3812   char *p = &amp;buf[len];
3813 
3814   jio_snprintf(p, buflen-len,
3815              &quot;\n\n&quot;
3816              &quot;Do you want to debug the problem?\n\n&quot;
3817              &quot;To debug, run &#39;gdb /proc/%d/exe %d&#39;; then switch to thread &quot; INTX_FORMAT &quot; (&quot; INTPTR_FORMAT &quot;)\n&quot;
3818              &quot;Enter &#39;yes&#39; to launch gdb automatically (PATH must include gdb)\n&quot;
3819              &quot;Otherwise, press RETURN to abort...&quot;,
3820              os::current_process_id(), os::current_process_id(),
3821              os::current_thread_id(), os::current_thread_id());
3822 
3823   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
</pre>
</td>
</tr>
</table>
<center><a href="osThread_bsd.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
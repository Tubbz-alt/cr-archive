<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osThread_bsd.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/os_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="line-added">+ #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;os_bsd.inline.hpp&quot;
  #include &quot;os_posix.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,11 ***</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/perfMemory.hpp&quot;
  #include &quot;runtime/semaphore.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/statSampler.hpp&quot;
<span class="line-new-header">--- 49,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,12 ***</span>
  
  // For diagnostics to print a message once. see run_periodic_checks
  static sigset_t check_signal_done;
  static bool check_signals = true;
  
<span class="line-removed">- static pid_t _initial_pid = 0;</span>
<span class="line-removed">- </span>
  // Signal number used to suspend/resume a thread
  
  // do not use any signal number less than SIGSEGV, see 4355769
  static int SR_signum = SIGUSR2;
  sigset_t SR_sigset;
<span class="line-new-header">--- 133,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,10 ***</span>
<span class="line-new-header">--- 166,26 ---</span>
    }
  #endif
    return available;
  }
  
<span class="line-added">+ // for more info see :</span>
<span class="line-added">+ // https://man.openbsd.org/sysctl.2</span>
<span class="line-added">+ void os::Bsd::print_uptime_info(outputStream* st) {</span>
<span class="line-added">+   struct timeval boottime;</span>
<span class="line-added">+   size_t len = sizeof(boottime);</span>
<span class="line-added">+   int mib[2];</span>
<span class="line-added">+   mib[0] = CTL_KERN;</span>
<span class="line-added">+   mib[1] = KERN_BOOTTIME;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sysctl(mib, 2, &amp;boottime, &amp;len, NULL, 0) &gt;= 0) {</span>
<span class="line-added">+     time_t bootsec = boottime.tv_sec;</span>
<span class="line-added">+     time_t currsec = time(NULL);</span>
<span class="line-added">+     os::print_dhm(st, &quot;OS uptime:&quot;, (long) difftime(currsec, bootsec));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  julong os::physical_memory() {
    return Bsd::physical_memory();
  }
  
  // Return true if user is running as root.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,11 ***</span>
    // Note that the space for the colon and the trailing null are provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified">!   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
<span class="line-new-header">--- 348,11 ---</span>
    // Note that the space for the colon and the trailing null are provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified">!   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,14 ***</span>
      // addressed).
      const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
      const char *v_colon = &quot;:&quot;;
      if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
      // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified">!     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified">!                                                      strlen(v) + 1 +</span>
<span class="line-modified">!                                                      sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified">!                                                      mtInternal);</span>
      sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib/%s:&quot; DEFAULT_LIBPATH, v, v_colon, cpu_arch);
      Arguments::set_library_path(ld_library_path);
      FREE_C_HEAP_ARRAY(char, ld_library_path);
    }
  
<span class="line-new-header">--- 398,14 ---</span>
      // addressed).
      const char *v = ::getenv(&quot;LD_LIBRARY_PATH&quot;);
      const char *v_colon = &quot;:&quot;;
      if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
      // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified">!     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified">!                                              strlen(v) + 1 +</span>
<span class="line-modified">!                                              sizeof(SYS_EXT_DIR) + sizeof(&quot;/lib/&quot;) + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,</span>
<span class="line-modified">!                                              mtInternal);</span>
      sprintf(ld_library_path, &quot;%s%s&quot; SYS_EXT_DIR &quot;/lib/%s:&quot; DEFAULT_LIBPATH, v, v_colon, cpu_arch);
      Arguments::set_library_path(ld_library_path);
      FREE_C_HEAP_ARRAY(char, ld_library_path);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,11 ***</span>
    // Note that the space for the colon and the trailing null are provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // for dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
<span class="line-modified">!   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
<span class="line-new-header">--- 429,11 ---</span>
    // Note that the space for the colon and the trailing null are provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // for dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
<span class="line-modified">!   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,14 ***</span>
      // at all. To ease the transition from Apple&#39;s Java6 to OpenJDK7,
      // &quot;.&quot; is appended to the end of java.library.path. Yes, this
      // could cause a change in behavior, but Apple&#39;s Java6 behavior
      // can be achieved by putting &quot;.&quot; at the beginning of the
      // JAVA_LIBRARY_PATH environment variable.
<span class="line-modified">!     char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified">!                                                      strlen(v) + 1 + strlen(l) + 1 +</span>
<span class="line-modified">!                                                      system_ext_size + 3,</span>
<span class="line-modified">!                                                      mtInternal);</span>
      sprintf(ld_library_path, &quot;%s%s%s%s%s&quot; SYS_EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS &quot;:.&quot;,
              v, v_colon, l, l_colon, user_home_dir);
      Arguments::set_library_path(ld_library_path);
      FREE_C_HEAP_ARRAY(char, ld_library_path);
    }
<span class="line-new-header">--- 491,14 ---</span>
      // at all. To ease the transition from Apple&#39;s Java6 to OpenJDK7,
      // &quot;.&quot; is appended to the end of java.library.path. Yes, this
      // could cause a change in behavior, but Apple&#39;s Java6 behavior
      // can be achieved by putting &quot;.&quot; at the beginning of the
      // JAVA_LIBRARY_PATH environment variable.
<span class="line-modified">!     char *ld_library_path = NEW_C_HEAP_ARRAY(char,</span>
<span class="line-modified">!                                              strlen(v) + 1 + strlen(l) + 1 +</span>
<span class="line-modified">!                                              system_ext_size + 3,</span>
<span class="line-modified">!                                              mtInternal);</span>
      sprintf(ld_library_path, &quot;%s%s%s%s%s&quot; SYS_EXTENSIONS_DIR &quot;:&quot; SYS_EXTENSIONS_DIRS &quot;:.&quot;,
              v, v_colon, l, l_colon, user_home_dir);
      Arguments::set_library_path(ld_library_path);
      FREE_C_HEAP_ARRAY(char, ld_library_path);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,23 ***</span>
  typedef void (*objc_registerThreadWithCollector_t)();
  extern &quot;C&quot; objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;
  objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;
  #endif
  
<span class="line-removed">- #ifdef __APPLE__</span>
<span class="line-removed">- static uint64_t locate_unique_thread_id(mach_port_t mach_thread_port) {</span>
<span class="line-removed">-   // Additional thread_id used to correlate threads in SA</span>
<span class="line-removed">-   thread_identifier_info_data_t     m_ident_info;</span>
<span class="line-removed">-   mach_msg_type_number_t            count = THREAD_IDENTIFIER_INFO_COUNT;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,</span>
<span class="line-removed">-               (thread_info_t) &amp;m_ident_info, &amp;count);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return m_ident_info.thread_id;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  // Thread start routine for all newly created threads
  static void *thread_native_entry(Thread *thread) {
  
    thread-&gt;record_stack_base_and_size();
  
<span class="line-new-header">--- 632,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,14 ***</span>
  
    log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
      os::current_thread_id(), (uintx) pthread_self());
  
  #ifdef __APPLE__
<span class="line-modified">!   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified">!   guarantee(unique_thread_id != 0, &quot;unique thread id was not found&quot;);</span>
<span class="line-removed">-   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
  #endif
    // initialize signal mask for this thread
    os::Bsd::hotspot_sigmask(thread);
  
    // initialize floating point control register
    os::Bsd::init_thread_fpu_state();
<span class="line-new-header">--- 657,14 ---</span>
  
    log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, pthread id: &quot; UINTX_FORMAT &quot;).&quot;,
      os::current_thread_id(), (uintx) pthread_self());
  
  #ifdef __APPLE__
<span class="line-modified">!   // Store unique OS X thread id used by SA</span>
<span class="line-modified">!   osthread-&gt;set_unique_thread_id();</span>
  #endif
<span class="line-added">+ </span>
    // initialize signal mask for this thread
    os::Bsd::hotspot_sigmask(thread);
  
    // initialize floating point control register
    os::Bsd::init_thread_fpu_state();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,19 ***</span>
    }
  #endif
  
    // handshaking with parent thread
    {
<span class="line-modified">!     MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);</span>
  
      // notify parent thread
      osthread-&gt;set_state(INITIALIZED);
      sync-&gt;notify_all();
  
      // wait until os::start_thread()
      while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified">!       sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
      }
    }
  
    // call one more level start routine
    thread-&gt;call_run();
<span class="line-new-header">--- 676,19 ---</span>
    }
  #endif
  
    // handshaking with parent thread
    {
<span class="line-modified">!     MutexLocker ml(sync, Mutex::_no_safepoint_check_flag);</span>
  
      // notify parent thread
      osthread-&gt;set_state(INITIALIZED);
      sync-&gt;notify_all();
  
      // wait until os::start_thread()
      while (osthread-&gt;get_state() == INITIALIZED) {
<span class="line-modified">!       sync-&gt;wait_without_safepoint_check();</span>
      }
    }
  
    // call one more level start routine
    thread-&gt;call_run();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 741,10 ***</span>
<span class="line-new-header">--- 742,15 ---</span>
        log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
          (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
      } else {
        log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%s) for attributes: %s.&quot;,
          os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="line-added">+       // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added">+       log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added">+       LogStream st(Log(os, thread)::info());</span>
<span class="line-added">+       os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added">+       os::print_memory_info(&amp;st);</span>
      }
  
      pthread_attr_destroy(&amp;attr);
  
      if (ret != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,13 ***</span>
      osthread-&gt;set_pthread_id(tid);
  
      // Wait until child thread is either initialized or aborted
      {
        Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified">!       MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
        while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified">!         sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
        }
      }
  
    }
  
<span class="line-new-header">--- 764,13 ---</span>
      osthread-&gt;set_pthread_id(tid);
  
      // Wait until child thread is either initialized or aborted
      {
        Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified">!       MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
        while ((state = osthread-&gt;get_state()) == ALLOCATED) {
<span class="line-modified">!         sync_with_child-&gt;wait_without_safepoint_check();</span>
        }
      }
  
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,16 ***</span>
      return false;
    }
  
    osthread-&gt;set_thread_id(os::Bsd::gettid());
  
<span class="line-removed">-   // Store pthread info into the OSThread</span>
  #ifdef __APPLE__
<span class="line-modified">!   uint64_t unique_thread_id = locate_unique_thread_id(osthread-&gt;thread_id());</span>
<span class="line-modified">!   guarantee(unique_thread_id != 0, &quot;just checking&quot;);</span>
<span class="line-removed">-   osthread-&gt;set_unique_thread_id(unique_thread_id);</span>
  #endif
    osthread-&gt;set_pthread_id(::pthread_self());
  
    // initialize floating point control register
    os::Bsd::init_thread_fpu_state();
  
<span class="line-new-header">--- 808,16 ---</span>
      return false;
    }
  
    osthread-&gt;set_thread_id(os::Bsd::gettid());
  
  #ifdef __APPLE__
<span class="line-modified">!   // Store unique OS X thread id used by SA</span>
<span class="line-modified">!   osthread-&gt;set_unique_thread_id();</span>
  #endif
<span class="line-added">+ </span>
<span class="line-added">+   // Store pthread info into the OSThread</span>
    osthread-&gt;set_pthread_id(::pthread_self());
  
    // initialize floating point control register
    os::Bsd::init_thread_fpu_state();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,11 ***</span>
  
  void os::pd_start_thread(Thread* thread) {
    OSThread * osthread = thread-&gt;osthread();
    assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
    Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified">!   MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
    sync_with_child-&gt;notify();
  }
  
  // Free Bsd resources related to the OSThread
  void os::free_thread(OSThread* osthread) {
<span class="line-new-header">--- 838,11 ---</span>
  
  void os::pd_start_thread(Thread* thread) {
    OSThread * osthread = thread-&gt;osthread();
    assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);
    Monitor* sync_with_child = osthread-&gt;startThread_lock();
<span class="line-modified">!   MutexLocker ml(sync_with_child, Mutex::_no_safepoint_check_flag);</span>
    sync_with_child-&gt;notify();
  }
  
  // Free Bsd resources related to the OSThread
  void os::free_thread(OSThread* osthread) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 871,12 ***</span>
  jlong os::elapsed_frequency() {
    return NANOSECS_PER_SEC; // nanosecond resolution
  }
  
  bool os::supports_vtime() { return true; }
<span class="line-removed">- bool os::enable_vtime()   { return false; }</span>
<span class="line-removed">- bool os::vtime_enabled()  { return false; }</span>
  
  double os::elapsedVTime() {
    // better than nothing, but not much
    return elapsedTime();
  }
<span class="line-new-header">--- 877,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,11 ***</span>
    const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
    const uint64_t prev = Bsd::_max_abstime;
    if (now &lt;= prev) {
      return prev;   // same or retrograde time;
    }
<span class="line-modified">!   const uint64_t obsv = Atomic::cmpxchg(now, &amp;Bsd::_max_abstime, prev);</span>
    assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
    // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
    // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
    // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
    // some other thread raced this thread and installed a new value, in which case
<span class="line-new-header">--- 931,11 ---</span>
    const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
    const uint64_t prev = Bsd::_max_abstime;
    if (now &lt;= prev) {
      return prev;   // same or retrograde time;
    }
<span class="line-modified">!   const uint64_t obsv = Atomic::cmpxchg(&amp;Bsd::_max_abstime, prev, now);</span>
    assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
    // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
    // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
    // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
    // some other thread raced this thread and installed a new value, in which case
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,25 ***</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
  void os::die() {
<span class="line-modified">!   // _exit() on BsdThreads only kills current thread</span>
<span class="line-modified">!   ::abort();</span>
  }
  
  // Information of current thread in variety of formats
  pid_t os::Bsd::gettid() {
    int retval = -1;
  
<span class="line-modified">! #ifdef __APPLE__ //XNU kernel</span>
<span class="line-modified">!   // despite the fact mach port is actually not a thread id use it</span>
<span class="line-modified">!   // instead of syscall(SYS_thread_selfid) as it certainly fits to u4</span>
<span class="line-modified">!   retval = ::pthread_mach_thread_np(::pthread_self());</span>
<span class="line-modified">!   guarantee(retval != 0, &quot;just checking&quot;);</span>
<span class="line-removed">-   return retval;</span>
  
  #else
    #ifdef __FreeBSD__
    retval = syscall(SYS_thr_self);
    #else
<span class="line-new-header">--- 1069,31 ---</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">+ // Dump a core file, if possible, for debugging.</span>
  void os::die() {
<span class="line-modified">!   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-modified">!     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">+     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">+     os::signal_raise(SIGKILL);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // _exit() on BsdThreads only kills current thread</span>
<span class="line-added">+     ::abort();</span>
<span class="line-added">+   }</span>
  }
  
  // Information of current thread in variety of formats
  pid_t os::Bsd::gettid() {
    int retval = -1;
  
<span class="line-modified">! #ifdef __APPLE__ // XNU kernel</span>
<span class="line-modified">!   mach_port_t port = mach_thread_self();</span>
<span class="line-modified">!   guarantee(MACH_PORT_VALID(port), &quot;just checking&quot;);</span>
<span class="line-modified">!   mach_port_deallocate(mach_task_self(), port);</span>
<span class="line-modified">!   return (pid_t)port;</span>
  
  #else
    #ifdef __FreeBSD__
    retval = syscall(SYS_thr_self);
    #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1102,35 ***</span>
    }
  }
  
  intx os::current_thread_id() {
  #ifdef __APPLE__
<span class="line-modified">!   return (intx)::pthread_mach_thread_np(::pthread_self());</span>
  #else
    return (intx)::pthread_self();
  #endif
  }
  
  int os::current_process_id() {
<span class="line-modified">! </span>
<span class="line-removed">-   // Under the old bsd thread library, bsd gives each thread</span>
<span class="line-removed">-   // its own process id. Because of this each thread will return</span>
<span class="line-removed">-   // a different pid if this method were to return the result</span>
<span class="line-removed">-   // of getpid(2). Bsd provides no api that returns the pid</span>
<span class="line-removed">-   // of the launcher thread for the vm. This implementation</span>
<span class="line-removed">-   // returns a unique pid, the pid of the launcher thread</span>
<span class="line-removed">-   // that starts the vm &#39;process&#39;.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Under the NPTL, getpid() returns the same pid as the</span>
<span class="line-removed">-   // launcher thread rather than a unique pid per thread.</span>
<span class="line-removed">-   // Use gettid() if you want the old pre NPTL behaviour.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // if you are looking for the result of a call to getpid() that</span>
<span class="line-removed">-   // returns a unique pid for the calling thread, then look at the</span>
<span class="line-removed">-   // OSThread::thread_id() method in osThread_bsd.hpp file</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return (int)(_initial_pid ? _initial_pid : getpid());</span>
  }
  
  // DLL functions
  
  const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
<span class="line-new-header">--- 1112,18 ---</span>
    }
  }
  
  intx os::current_thread_id() {
  #ifdef __APPLE__
<span class="line-modified">!   return (intx)os::Bsd::gettid();</span>
  #else
    return (intx)::pthread_self();
  #endif
  }
  
  int os::current_process_id() {
<span class="line-modified">!   return (int)(getpid());</span>
  }
  
  // DLL functions
  
  const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,40 ***</span>
  #ifdef __APPLE__
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
  #ifdef STATIC_BUILD
    return os::get_default_process_handle();
  #else
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
      // Successful loading
      return result;
    }
  
<span class="line-modified">!   // Read system error message into ebuf</span>
<span class="line-modified">!   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">!   ebuf[ebuflen-1]=&#39;\0&#39;;</span>
  
    return NULL;
  #endif // STATIC_BUILD
  }
  #else
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
  #ifdef STATIC_BUILD
    return os::get_default_process_handle();
  #else
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
      // Successful loading
      return result;
    }
  
    Elf32_Ehdr elf_head;
  
<span class="line-modified">!   // Read system error message into ebuf</span>
<span class="line-modified">!   // It may or may not be overwritten below</span>
<span class="line-modified">!   ::strncpy(ebuf, ::dlerror(), ebuflen-1);</span>
<span class="line-modified">!   ebuf[ebuflen-1]=&#39;\0&#39;;</span>
    int diag_msg_max_length=ebuflen-strlen(ebuf);
    char* diag_msg_buf=ebuf+strlen(ebuf);
  
    if (diag_msg_max_length==0) {
      // No more space in ebuf for additional diagnostics message
<span class="line-new-header">--- 1241,63 ---</span>
  #ifdef __APPLE__
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
  #ifdef STATIC_BUILD
    return os::get_default_process_handle();
  #else
<span class="line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">+ </span>
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
<span class="line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
      // Successful loading
<span class="line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
      return result;
    }
  
<span class="line-modified">!   const char* error_report = ::dlerror();</span>
<span class="line-modified">!   if (error_report == NULL) {</span>
<span class="line-modified">!     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">+     // Read system error message into ebuf</span>
<span class="line-added">+     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">+     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">+   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
  
    return NULL;
  #endif // STATIC_BUILD
  }
  #else
  void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
  #ifdef STATIC_BUILD
    return os::get_default_process_handle();
  #else
<span class="line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
<span class="line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
      // Successful loading
<span class="line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
      return result;
    }
  
    Elf32_Ehdr elf_head;
  
<span class="line-modified">!   const char* const error_report = ::dlerror();</span>
<span class="line-modified">!   if (error_report == NULL) {</span>
<span class="line-modified">!     error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
<span class="line-added">+     // Read system error message into ebuf</span>
<span class="line-added">+     ::strncpy(ebuf, error_report, ebuflen-1);</span>
<span class="line-added">+     ebuf[ebuflen-1]=&#39;\0&#39;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">+   log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">+ </span>
    int diag_msg_max_length=ebuflen-strlen(ebuf);
    char* diag_msg_buf=ebuf+strlen(ebuf);
  
    if (diag_msg_max_length==0) {
      // No more space in ebuf for additional diagnostics message
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1553,10 ***</span>
<span class="line-new-header">--- 1569,12 ---</span>
  void os::print_os_info(outputStream* st) {
    st-&gt;print(&quot;OS:&quot;);
  
    os::Posix::print_uname_info(st);
  
<span class="line-added">+   os::Bsd::print_uptime_info(st);</span>
<span class="line-added">+ </span>
    os::Posix::print_rlimit_info(st);
  
    os::Posix::print_load_average(st);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1590,18 ***</span>
<span class="line-new-header">--- 1608,30 ---</span>
  
    snprintf(buf, buflen, &quot;%s %s %d MHz&quot;, model, machine, mhz);
  }
  
  void os::print_memory_info(outputStream* st) {
<span class="line-added">+   xsw_usage swap_usage;</span>
<span class="line-added">+   size_t size = sizeof(swap_usage);</span>
  
    st-&gt;print(&quot;Memory:&quot;);
    st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
  
    st-&gt;print(&quot;, physical &quot; UINT64_FORMAT &quot;k&quot;,
              os::physical_memory() &gt;&gt; 10);
    st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,
              os::available_memory() &gt;&gt; 10);
<span class="line-added">+ </span>
<span class="line-added">+   if((sysctlbyname(&quot;vm.swapusage&quot;, &amp;swap_usage, &amp;size, NULL, 0) == 0) || (errno == ENOMEM)) {</span>
<span class="line-added">+     if (size &gt;= offset_of(xsw_usage, xsu_used)) {</span>
<span class="line-added">+       st-&gt;print(&quot;, swap &quot; UINT64_FORMAT &quot;k&quot;,</span>
<span class="line-added">+                 ((julong) swap_usage.xsu_total) &gt;&gt; 10);</span>
<span class="line-added">+       st-&gt;print(&quot;(&quot; UINT64_FORMAT &quot;k free)&quot;,</span>
<span class="line-added">+                 ((julong) swap_usage.xsu_avail) &gt;&gt; 10);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    st-&gt;cr();
  }
  
  static void print_signal_handler(outputStream* st, int sig,
                                   char* buf, size_t buflen);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1732,20 ***</span>
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  // sun.misc.Signal support
  
<span class="line-removed">- static volatile jint sigint_count = 0;</span>
<span class="line-removed">- </span>
  static void UserHandler(int sig, void *siginfo, void *context) {
<span class="line-removed">-   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="line-removed">-   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="line-removed">-   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="line-removed">-   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Ctrl-C is pressed during error reporting, likely because the error
    // handler fails to abort. Let VM die immediately.
    if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
      os::die();
    }
<span class="line-new-header">--- 1762,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1811,15 ***</span>
      assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
    }
  }
  
  static int check_pending_signals() {
<span class="line-removed">-   Atomic::store(0, &amp;sigint_count);</span>
    for (;;) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
<span class="line-new-header">--- 1832,14 ---</span>
      assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
    }
  }
  
  static int check_pending_signals() {
    for (;;) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="line-modified">!       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1876,11 ***</span>
    if (!UseOprofile) {
      return;
    }
  
    char buf[PATH_MAX + 1];
<span class="line-modified">!   int num = Atomic::add(1, &amp;cnt);</span>
  
    snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,
             os::get_temp_directory(), os::current_process_id(), num);
    unlink(buf);
  
<span class="line-new-header">--- 1896,11 ---</span>
    if (!UseOprofile) {
      return;
    }
  
    char buf[PATH_MAX + 1];
<span class="line-modified">!   int num = Atomic::add(&amp;cnt, 1);</span>
  
    snprintf(buf, PATH_MAX + 1, &quot;%s/hs-vm-%d-%d&quot;,
             os::get_temp_directory(), os::current_process_id(), num);
    unlink(buf);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1913,10 ***</span>
<span class="line-new-header">--- 1933,11 ---</span>
  //       problem.
  bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
  #ifdef __OpenBSD__
    // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<span class="line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
    if (::mprotect(addr, size, prot) == 0) {
      return true;
    }
  #else
    uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1985,10 ***</span>
<span class="line-new-header">--- 2006,14 ---</span>
      return 1;
    }
    return 0;
  }
  
<span class="line-added">+ int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool os::get_page_info(char *start, page_info* info) {
    return false;
  }
  
  char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1997,10 ***</span>
<span class="line-new-header">--- 2022,11 ---</span>
  
  
  bool os::pd_uncommit_memory(char* addr, size_t size) {
  #ifdef __OpenBSD__
    // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
<span class="line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with PROT_NONE&quot;, p2i(addr), p2i(addr+size));</span>
    return ::mprotect(addr, size, PROT_NONE) == 0;
  #else
    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                       MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
    return res  != (uintptr_t) MAP_FAILED;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2065,10 ***</span>
<span class="line-new-header">--- 2091,11 ---</span>
    // protection of malloc&#39;ed or statically allocated memory). Check the
    // caller if you hit this assert.
    assert(addr == bottom, &quot;sanity check&quot;);
  
    size = align_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());
<span class="line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(bottom), p2i(bottom+size), prot);</span>
    return ::mprotect(bottom, size, prot) == 0;
  }
  
  // Set protections specified
  bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2143,15 ***</span>
  
  // Reserve memory at an arbitrary address, only if that area is
  // available (and not reserved for something else).
  
  char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
<span class="line-removed">-   const int max_tries = 10;</span>
<span class="line-removed">-   char* base[max_tries];</span>
<span class="line-removed">-   size_t size[max_tries];</span>
<span class="line-removed">-   const size_t gap = 0x000000;</span>
<span class="line-removed">- </span>
    // Assert only that the size is a multiple of the page size, since
    // that&#39;s all that mmap requires, and since that&#39;s all we really know
    // about at this low abstraction level.  If we need higher alignment,
    // we can either pass an alignment to this method or verify alignment
    // in one of the methods further up the call chain.  See bug 5044738.
<span class="line-new-header">--- 2170,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2170,54 ***</span>
    if (addr != NULL) {
      // mmap() is successful but it fails to reserve at the requested address
      anon_munmap(addr, bytes);
    }
  
<span class="line-modified">!   int i;</span>
<span class="line-removed">-   for (i = 0; i &lt; max_tries; ++i) {</span>
<span class="line-removed">-     base[i] = reserve_memory(bytes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (base[i] != NULL) {</span>
<span class="line-removed">-       // Is this the block we wanted?</span>
<span class="line-removed">-       if (base[i] == requested_addr) {</span>
<span class="line-removed">-         size[i] = bytes;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Does this overlap the block we wanted? Give back the overlapped</span>
<span class="line-removed">-       // parts and try again.</span>
<span class="line-removed">- </span>
<span class="line-removed">-       size_t top_overlap = requested_addr + (bytes + gap) - base[i];</span>
<span class="line-removed">-       if (top_overlap &gt;= 0 &amp;&amp; top_overlap &lt; bytes) {</span>
<span class="line-removed">-         unmap_memory(base[i], top_overlap);</span>
<span class="line-removed">-         base[i] += top_overlap;</span>
<span class="line-removed">-         size[i] = bytes - top_overlap;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         size_t bottom_overlap = base[i] + bytes - requested_addr;</span>
<span class="line-removed">-         if (bottom_overlap &gt;= 0 &amp;&amp; bottom_overlap &lt; bytes) {</span>
<span class="line-removed">-           unmap_memory(requested_addr, bottom_overlap);</span>
<span class="line-removed">-           size[i] = bytes - bottom_overlap;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           size[i] = bytes;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Give back the unused reserved pieces.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (int j = 0; j &lt; i; ++j) {</span>
<span class="line-removed">-     if (base[j] != NULL) {</span>
<span class="line-removed">-       unmap_memory(base[j], size[j]);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (i &lt; max_tries) {</span>
<span class="line-removed">-     return requested_addr;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
  }
  
  // Sleep forever; naked call to OS-specific sleep; use with CAUTION
  void os::infinite_sleep() {
    while (true) {    // sleep forever ...
<span class="line-new-header">--- 2192,11 ---</span>
    if (addr != NULL) {
      // mmap() is successful but it fails to reserve at the requested address
      anon_munmap(addr, bytes);
    }
  
<span class="line-modified">!   return NULL;</span>
  }
  
  // Sleep forever; naked call to OS-specific sleep; use with CAUTION
  void os::infinite_sleep() {
    while (true) {    // sleep forever ...
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2871,19 ***</span>
  
      // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
      // and if UserSignalHandler is installed all bets are off
      if (CheckJNICalls) {
        if (libjsig_is_loaded) {
<span class="line-modified">!         if (PrintJNIResolving) {</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">-         }</span>
          check_signals = false;
        }
        if (AllowUserSignalHandlers) {
<span class="line-modified">!         if (PrintJNIResolving) {</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
<span class="line-removed">-         }</span>
          check_signals = false;
        }
      }
    }
  }
<span class="line-new-header">--- 2850,15 ---</span>
  
      // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
      // and if UserSignalHandler is installed all bets are off
      if (CheckJNICalls) {
        if (libjsig_is_loaded) {
<span class="line-modified">!         log_debug(jni, resolve)(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);</span>
          check_signals = false;
        }
        if (AllowUserSignalHandlers) {
<span class="line-modified">!         log_debug(jni, resolve)(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);</span>
          check_signals = false;
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3092,20 ***</span>
  
  // this is called _before_ the most of global arguments have been parsed
  void os::init(void) {
    char dummy;   // used to get a guess on initial stack address
  
<span class="line-removed">-   // With BsdThreads the JavaMain thread pid (primordial thread)</span>
<span class="line-removed">-   // is different than the pid of the java launcher thread.</span>
<span class="line-removed">-   // So, on Bsd, the launcher thread pid is passed to the VM</span>
<span class="line-removed">-   // via the sun.java.launcher.pid property.</span>
<span class="line-removed">-   // Use this property instead of getpid() if it was correctly passed.</span>
<span class="line-removed">-   // See bug 6351349.</span>
<span class="line-removed">-   pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   _initial_pid = (java_launcher_pid &gt; 0) ? java_launcher_pid : getpid();</span>
<span class="line-removed">- </span>
    clock_tics_per_sec = CLK_TCK;
  
    init_random(1234567);
  
    Bsd::set_page_size(getpagesize());
<span class="line-new-header">--- 3067,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3240,10 ***</span>
<span class="line-new-header">--- 3205,82 ---</span>
    }
  
    return _processor_count;
  }
  
<span class="line-added">+ #ifdef __APPLE__</span>
<span class="line-added">+ static volatile int* volatile apic_to_processor_mapping = NULL;</span>
<span class="line-added">+ static volatile int next_processor_id = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline volatile int* get_apic_to_processor_mapping() {</span>
<span class="line-added">+   volatile int* mapping = Atomic::load_acquire(&amp;apic_to_processor_mapping);</span>
<span class="line-added">+   if (mapping == NULL) {</span>
<span class="line-added">+     // Calculate possible number space for APIC ids. This space is not necessarily</span>
<span class="line-added">+     // in the range [0, number_of_processors).</span>
<span class="line-added">+     uint total_bits = 0;</span>
<span class="line-added">+     for (uint i = 0;; ++i) {</span>
<span class="line-added">+       uint eax = 0xb; // Query topology leaf</span>
<span class="line-added">+       uint ebx;</span>
<span class="line-added">+       uint ecx = i;</span>
<span class="line-added">+       uint edx;</span>
<span class="line-added">+ </span>
<span class="line-added">+       __asm__ (&quot;cpuid\n\t&quot; : &quot;+a&quot; (eax), &quot;+b&quot; (ebx), &quot;+c&quot; (ecx), &quot;+d&quot; (edx) : );</span>
<span class="line-added">+ </span>
<span class="line-added">+       uint level_type = (ecx &gt;&gt; 8) &amp; 0xFF;</span>
<span class="line-added">+       if (level_type == 0) {</span>
<span class="line-added">+         // Invalid level; end of topology</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       uint level_apic_id_shift = eax &amp; ((1u &lt;&lt; 5) - 1);</span>
<span class="line-added">+       total_bits += level_apic_id_shift;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint max_apic_ids = 1u &lt;&lt; total_bits;</span>
<span class="line-added">+     mapping = NEW_C_HEAP_ARRAY(int, max_apic_ids, mtInternal);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (uint i = 0; i &lt; max_apic_ids; ++i) {</span>
<span class="line-added">+       mapping[i] = -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!Atomic::replace_if_null(&amp;apic_to_processor_mapping, mapping)) {</span>
<span class="line-added">+       FREE_C_HEAP_ARRAY(int, mapping);</span>
<span class="line-added">+       mapping = Atomic::load_acquire(&amp;apic_to_processor_mapping);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return mapping;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ uint os::processor_id() {</span>
<span class="line-added">+   volatile int* mapping = get_apic_to_processor_mapping();</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint eax = 0xb;</span>
<span class="line-added">+   uint ebx;</span>
<span class="line-added">+   uint ecx = 0;</span>
<span class="line-added">+   uint edx;</span>
<span class="line-added">+ </span>
<span class="line-added">+   __asm__ (&quot;cpuid\n\t&quot; : &quot;+a&quot; (eax), &quot;+b&quot; (ebx), &quot;+c&quot; (ecx), &quot;+d&quot; (edx) : );</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Map from APIC id to a unique logical processor ID in the expected</span>
<span class="line-added">+   // [0, num_processors) range.</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint apic_id = edx;</span>
<span class="line-added">+   int processor_id = Atomic::load(&amp;mapping[apic_id]);</span>
<span class="line-added">+ </span>
<span class="line-added">+   while (processor_id &lt; 0) {</span>
<span class="line-added">+     if (Atomic::cmpxchg(&amp;mapping[apic_id], -1, -2) == -1) {</span>
<span class="line-added">+       Atomic::store(&amp;mapping[apic_id], Atomic::add(&amp;next_processor_id, 1) - 1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     processor_id = Atomic::load(&amp;mapping[apic_id]);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(processor_id &gt;= 0 &amp;&amp; processor_id &lt; os::processor_count(), &quot;invalid processor id&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return (uint)processor_id;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  void os::set_native_thread_name(const char *name) {
  #if defined(__APPLE__) &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &gt; MAC_OS_X_VERSION_10_5
    // This is only supported in Snow Leopard and beyond
    if (name != NULL) {
      // Add a &quot;Java: &quot; prefix to the name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3252,15 ***</span>
      pthread_setname_np(buf);
    }
  #endif
  }
  
<span class="line-removed">- bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">-   // Not yet implemented.</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool os::bind_to_processor(uint processor_id) {
    // Not yet implemented.
    return false;
  }
  
<span class="line-new-header">--- 3289,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3641,11 ***</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
<span class="line-new-header">--- 3673,11 ---</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">!     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3733,21 ***</span>
        return status;
      }
    }
  }
  
<span class="line-modified">! // Get the default path to the core file</span>
  // Returns the length of the string
  int os::get_core_path(char* buffer, size_t bufferSize) {
<span class="line-modified">!   int n = jio_snprintf(buffer, bufferSize, &quot;/cores/core.%d&quot;, current_process_id());</span>
<span class="line-modified">! </span>
    // Truncate if theoretical string was longer than bufferSize
    n = MIN2(n, (int)bufferSize);
  
    return n;
  }
  
  #ifndef PRODUCT
  void TestReserveMemorySpecial_test() {
    // No tests available for this platform
  }
  #endif
<span class="line-new-header">--- 3765,44 ---</span>
        return status;
      }
    }
  }
  
<span class="line-modified">! // Get the kern.corefile setting, or otherwise the default path to the core file</span>
  // Returns the length of the string
  int os::get_core_path(char* buffer, size_t bufferSize) {
<span class="line-modified">!   int n = 0;</span>
<span class="line-modified">! #ifdef __APPLE__</span>
<span class="line-added">+   char coreinfo[MAX_PATH];</span>
<span class="line-added">+   size_t sz = sizeof(coreinfo);</span>
<span class="line-added">+   int ret = sysctlbyname(&quot;kern.corefile&quot;, coreinfo, &amp;sz, NULL, 0);</span>
<span class="line-added">+   if (ret == 0) {</span>
<span class="line-added">+     char *pid_pos = strstr(coreinfo, &quot;%P&quot;);</span>
<span class="line-added">+     // skip over the &quot;%P&quot; to preserve any optional custom user pattern</span>
<span class="line-added">+     const char* tail = (pid_pos != NULL) ? (pid_pos + 2) : &quot;&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (pid_pos != NULL) {</span>
<span class="line-added">+       *pid_pos = &#39;\0&#39;;</span>
<span class="line-added">+       n = jio_snprintf(buffer, bufferSize, &quot;%s%d%s&quot;, coreinfo, os::current_process_id(), tail);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       n = jio_snprintf(buffer, bufferSize, &quot;%s&quot;, coreinfo);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   {</span>
<span class="line-added">+     n = jio_snprintf(buffer, bufferSize, &quot;/cores/core.%d&quot;, os::current_process_id());</span>
<span class="line-added">+   }</span>
    // Truncate if theoretical string was longer than bufferSize
    n = MIN2(n, (int)bufferSize);
  
    return n;
  }
  
<span class="line-added">+ bool os::supports_map_sync() {</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
  void TestReserveMemorySpecial_test() {
    // No tests available for this platform
  }
  #endif
</pre>
<center><a href="osThread_bsd.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
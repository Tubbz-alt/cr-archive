<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/os_perf_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_aix.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/os_perf_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_aix.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;

  31 
  32 #include CPU_HEADER(vm_version_ext)
  33 
  34 #include &lt;stdio.h&gt;
  35 #include &lt;stdarg.h&gt;
  36 #include &lt;unistd.h&gt;
  37 #include &lt;errno.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;sys/resource.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #include &lt;dirent.h&gt;
  43 #include &lt;stdlib.h&gt;
  44 #include &lt;dlfcn.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;limits.h&gt;
  47 
  48 /**
  49    /proc/[number]/stat
  50               Status information about the process.  This is used by ps(1).  It is defined in /usr/src/linux/fs/proc/array.c.
</pre>
<hr />
<pre>
 256         n = vsscanf(tmp, fmt, args);
 257       }
 258     }
 259   }
 260 
 261   fclose(f);
 262 
 263   return n;
 264 }
 265 
 266 static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {
 267   int   n;
 268   va_list args;
 269 
 270   va_start(args, fmt);
 271   n = vread_statdata(procfile, fmt, args);
 272   va_end(args);
 273   return n;
 274 }
 275 
<span class="line-removed"> 276 static FILE* open_statfile(void) {</span>
<span class="line-removed"> 277   FILE *f;</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed"> 280     static int haveWarned = 0;</span>
<span class="line-removed"> 281     if (!haveWarned) {</span>
<span class="line-removed"> 282       haveWarned = 1;</span>
<span class="line-removed"> 283     }</span>
<span class="line-removed"> 284   }</span>
<span class="line-removed"> 285   return f;</span>
<span class="line-removed"> 286 }</span>
<span class="line-removed"> 287 </span>
<span class="line-removed"> 288 static void</span>
<span class="line-removed"> 289 next_line(FILE *f) {</span>
<span class="line-removed"> 290   int c;</span>
<span class="line-removed"> 291   do {</span>
<span class="line-removed"> 292     c = fgetc(f);</span>
<span class="line-removed"> 293   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-removed"> 294 }</span>
<span class="line-removed"> 295 </span>
 296 /**
<span class="line-modified"> 297  * Return the total number of ticks since the system was booted.</span>
<span class="line-modified"> 298  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="line-removed"> 299  * the number of ticks spent on actual processes (user, system or</span>
<span class="line-removed"> 300  * nice processes) since system boot. Note that this is the total number</span>
<span class="line-removed"> 301  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="line-removed"> 302  * n times the number of ticks that has passed in clock time.</span>
<span class="line-removed"> 303  *</span>
<span class="line-removed"> 304  * Returns a negative value if the reading of the ticks failed.</span>
 305  */
 306 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
<span class="line-modified"> 307   FILE*         fh;</span>
<span class="line-removed"> 308   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-removed"> 309   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-removed"> 310   int           logical_cpu = -1;</span>
<span class="line-removed"> 311   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="line-removed"> 312   int           n;</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314   if ((fh = open_statfile()) == NULL) {</span>
<span class="line-removed"> 315     return OS_ERR;</span>
<span class="line-removed"> 316   }</span>
<span class="line-removed"> 317   if (-1 == which_logical_cpu) {</span>
<span class="line-removed"> 318     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 319             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 320             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-removed"> 321             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 322   } else {</span>
<span class="line-removed"> 323     // Move to next line</span>
<span class="line-removed"> 324     next_line(fh);</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-removed"> 327     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-removed"> 328       next_line(fh);</span>
<span class="line-removed"> 329     }</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 332                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 333                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-removed"> 334                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 335   }</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337   fclose(fh);</span>
<span class="line-removed"> 338   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-removed"> 339 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 340     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="line-removed"> 341 #endif</span>
<span class="line-removed"> 342     return OS_ERR;</span>
<span class="line-removed"> 343   }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 346   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="line-removed"> 347           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 348           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="line-removed"> 349           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="line-removed"> 350           iowTicks, irqTicks, sirqTicks);</span>
<span class="line-removed"> 351 #endif</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-removed"> 354   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 355   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-removed"> 356                        iowTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   return OS_OK;</span>
<span class="line-removed"> 359 }</span>
<span class="line-removed"> 360 </span>
<span class="line-removed"> 361 </span>
<span class="line-removed"> 362 static int get_systemtype(void) {</span>
<span class="line-removed"> 363   static int procEntriesType = UNDETECTED;</span>
<span class="line-removed"> 364   DIR *taskDir;</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366   if (procEntriesType != UNDETECTED) {</span>
<span class="line-removed"> 367     return procEntriesType;</span>
<span class="line-removed"> 368   }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370   // Check whether we have a task subdirectory</span>
<span class="line-removed"> 371   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {</span>
<span class="line-removed"> 372     procEntriesType = UNDETECTABLE;</span>
<span class="line-removed"> 373   } else {</span>
<span class="line-removed"> 374     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system</span>
<span class="line-removed"> 375     closedir(taskDir);</span>
<span class="line-removed"> 376     procEntriesType = LINUX26_NPTL;</span>
<span class="line-removed"> 377   }</span>
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379   return procEntriesType;</span>
 380 }
 381 
 382 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 383 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 384   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 385     userTicks, systemTicks);
 386 }
 387 
 388 /**
 389  * Return the number of ticks spent in any of the processes belonging
 390  * to the JVM on any CPU.
 391  */
 392 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
<span class="line-modified"> 393   uint64_t userTicks;</span>
<span class="line-removed"> 394   uint64_t systemTicks;</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   if (get_systemtype() != LINUX26_NPTL) {</span>
<span class="line-removed"> 397     return OS_ERR;</span>
<span class="line-removed"> 398   }</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {</span>
<span class="line-removed"> 401     return OS_ERR;</span>
<span class="line-removed"> 402   }</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404   // get the total</span>
<span class="line-removed"> 405   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
<span class="line-removed"> 406     return OS_ERR;</span>
<span class="line-removed"> 407   }</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409   pticks-&gt;used       = userTicks;</span>
<span class="line-removed"> 410   pticks-&gt;usedKernel = systemTicks;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412   return OS_OK;</span>
 413 }
 414 
 415 /**
 416  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 417  * available time for user or system processes, 0.0 means the CPU uses all time
 418  * being idle.
 419  *
 420  * Returns a negative value if there is a problem in determining the CPU load.
 421  */
 422 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 423   uint64_t udiff, kdiff, tdiff;
 424   CPUPerfTicks* pticks;
 425   CPUPerfTicks  tmp;
 426   double user_load;
 427 
 428   *pkernelLoad = 0.0;
 429 
 430   if (target == CPU_LOAD_VM_ONLY) {
 431     pticks = &amp;counters-&gt;jvmTicks;
 432   } else if (-1 == which_logical_cpu) {
</pre>
<hr />
<pre>
 456   udiff = pticks-&gt;used - tmp.used;
 457 
 458   if (tdiff == 0) {
 459     return 0.0;
 460   } else if (tdiff &lt; (udiff + kdiff)) {
 461     tdiff = udiff + kdiff;
 462   }
 463   *pkernelLoad = (kdiff / (double)tdiff);
 464   // BUG9044876, normalize return values to sane values
 465   *pkernelLoad = MAX2&lt;double&gt;(*pkernelLoad, 0.0);
 466   *pkernelLoad = MIN2&lt;double&gt;(*pkernelLoad, 1.0);
 467 
 468   user_load = (udiff / (double)tdiff);
 469   user_load = MAX2&lt;double&gt;(user_load, 0.0);
 470   user_load = MIN2&lt;double&gt;(user_load, 1.0);
 471 
 472   return user_load;
 473 }
 474 
 475 static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
<span class="line-modified"> 476   FILE *f;</span>
<span class="line-removed"> 477   va_list args;</span>
<span class="line-removed"> 478 </span>
<span class="line-removed"> 479   va_start(args, fmt);</span>
<span class="line-removed"> 480 </span>
<span class="line-removed"> 481   if ((f = open_statfile()) == NULL) {</span>
<span class="line-removed"> 482     va_end(args);</span>
<span class="line-removed"> 483     return OS_ERR;</span>
<span class="line-removed"> 484   }</span>
<span class="line-removed"> 485   for (;;) {</span>
<span class="line-removed"> 486     char line[80];</span>
<span class="line-removed"> 487     if (fgets(line, sizeof(line), f) != NULL) {</span>
<span class="line-removed"> 488       if (vsscanf(line, fmt, args) == 1) {</span>
<span class="line-removed"> 489         fclose(f);</span>
<span class="line-removed"> 490         va_end(args);</span>
<span class="line-removed"> 491         return OS_OK;</span>
<span class="line-removed"> 492       }</span>
<span class="line-removed"> 493     } else {</span>
<span class="line-removed"> 494         fclose(f);</span>
<span class="line-removed"> 495         va_end(args);</span>
<span class="line-removed"> 496         return OS_ERR;</span>
<span class="line-removed"> 497     }</span>
<span class="line-removed"> 498   }</span>
 499 }
 500 
 501 static int get_noof_context_switches(uint64_t* switches) {
 502   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 503 }
 504 
 505 /** returns boot time in _seconds_ since epoch */
 506 static int get_boot_time(uint64_t* time) {
 507   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 508 }
 509 
 510 static int perf_context_switch_rate(double* rate) {
 511   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified"> 512   static uint64_t      lastTime;</span>

 513   static uint64_t      lastSwitches;
 514   static double        lastRate;
 515 
<span class="line-modified"> 516   uint64_t lt = 0;</span>
 517   int res = 0;
 518 
<span class="line-modified"> 519   if (lastTime == 0) {</span>

 520     uint64_t tmp;
 521     if (get_boot_time(&amp;tmp) &lt; 0) {
 522       return OS_ERR;
 523     }
<span class="line-modified"> 524     lt = tmp * 1000;</span>
 525   }
 526 
 527   res = OS_OK;
 528 
 529   pthread_mutex_lock(&amp;contextSwitchLock);
 530   {
 531 
 532     uint64_t sw;
 533     s8 t, d;
 534 
<span class="line-modified"> 535     if (lastTime == 0) {</span>
<span class="line-modified"> 536       lastTime = lt;</span>










 537     }
 538 
<span class="line-removed"> 539     t = os::javaTimeMillis();</span>
<span class="line-removed"> 540     d = t - lastTime;</span>
<span class="line-removed"> 541 </span>
 542     if (d == 0) {
 543       *rate = lastRate;
<span class="line-modified"> 544     } else if (!get_noof_context_switches(&amp;sw)) {</span>
 545       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 546       lastRate     = *rate;
 547       lastSwitches = sw;
<span class="line-modified"> 548       lastTime     = t;</span>


 549     } else {
 550       *rate = 0;
 551       res   = OS_ERR;
 552     }
 553     if (*rate &lt;= 0) {
 554       *rate = 0;
 555       lastRate = 0;
 556     }




 557   }
 558   pthread_mutex_unlock(&amp;contextSwitchLock);
 559 
 560   return res;
 561 }
 562 
 563 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 564   friend class CPUPerformanceInterface;
 565  private:
 566   CPUPerfCounters _counters;
 567 
 568   int cpu_load(int which_logical_cpu, double* cpu_load);
 569   int context_switch_rate(double* rate);
 570   int cpu_load_total_process(double* cpu_load);
 571   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 572 
 573  public:
 574   CPUPerformance();
 575   bool initialize();
 576   ~CPUPerformance();
 577 };
 578 
 579 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 580   _counters.nProcs = os::active_processor_count();
 581   _counters.cpus = NULL;
 582 }
 583 
 584 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified"> 585   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="line-modified"> 586   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified"> 587   if (NULL == _counters.cpus) {</span>
<span class="line-removed"> 588     return false;</span>
<span class="line-removed"> 589   }</span>
<span class="line-removed"> 590   memset(_counters.cpus, 0, tick_array_size);</span>
 591 
 592   // For the CPU load total
 593   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);
 594 
 595   // For each CPU
 596   for (int i = 0; i &lt; _counters.nProcs; i++) {
 597     get_total_ticks(i, &amp;_counters.cpus[i]);
 598   }
 599   // For JVM load
 600   get_jvm_ticks(&amp;_counters.jvmTicks);
 601 
 602   // initialize context switch system
 603   // the double is only for init
 604   double init_ctx_switch_rate;
 605   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 606 
 607   return true;
 608 }
 609 
 610 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
</pre>
<hr />
<pre>
 657     t = MIN2&lt;double&gt;(u + s, 1.0);
 658   }
 659 
 660   *pjvmUserLoad = u;
 661   *pjvmKernelLoad = s;
 662   *psystemTotalLoad = t;
 663 
 664   return OS_OK;
 665 }
 666 
 667 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 668   return perf_context_switch_rate(rate);
 669 }
 670 
 671 CPUPerformanceInterface::CPUPerformanceInterface() {
 672   _impl = NULL;
 673 }
 674 
 675 bool CPUPerformanceInterface::initialize() {
 676   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified"> 677   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 678 }
 679 
 680 CPUPerformanceInterface::~CPUPerformanceInterface() {
 681   if (_impl != NULL) {
 682     delete _impl;
 683   }
 684 }
 685 
 686 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 687   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 688 }
 689 
 690 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 691   return _impl-&gt;cpu_load_total_process(cpu_load);
 692 }
 693 
 694 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 695   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 696 }
 697 
</pre>
<hr />
<pre>
 810 }
 811 
 812 // get command line from /proc/&lt;pid&gt;/cmdline
 813 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 814   FILE* fp;
 815   char  buffer[PATH_MAX];
 816   char* cmdline = NULL;
 817 
 818   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 819   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 820   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 821     size_t size = 0;
 822     char   dummy;
 823 
 824     // find out how long the file is (stat always returns 0)
 825     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 826       size++;
 827     }
 828     if (size &gt; 0) {
 829       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified"> 830       if (cmdline != NULL) {</span>
<span class="line-modified"> 831         cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 832         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 833           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 834             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 835             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 836             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 837               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-removed"> 838                 cmdline[i] = &#39; &#39;;</span>
<span class="line-removed"> 839               }</span>
 840             }
<span class="line-removed"> 841             cmdline[size] = &#39;\0&#39;;</span>
 842           }

 843         }
 844       }
 845     }
 846     fclose(fp);
 847   }
 848   return cmdline;
 849 }
 850 
 851 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 852 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 853   char buffer[PATH_MAX];
 854 
 855   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 856   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 857   return realpath(buffer, _exePath);
 858 }
 859 
 860 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 861   if (str != NULL) {
 862     return os::strdup_check_oom(str, mtInternal);
</pre>
<hr />
<pre>
 912   _valid = false;
 913 }
 914 
 915 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
 916   // Not yet implemented.
 917   return false;
 918 }
 919 
 920 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 921   if (_dir != NULL) {
 922     os::closedir(_dir);
 923   }
 924 }
 925 
 926 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 927   _iterator = NULL;
 928 }
 929 
 930 bool SystemProcessInterface::SystemProcesses::initialize() {
 931   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified"> 932   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
 933 }
 934 
 935 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 936   if (_iterator != NULL) {
 937     delete _iterator;
 938   }
 939 }
 940 
 941 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 942   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 943   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 944   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 945 
 946   // initialize pointers
 947   *no_of_sys_processes = 0;
 948   *system_processes = NULL;
 949 
 950   while (_iterator-&gt;is_valid()) {
 951     SystemProcess* tmp = new SystemProcess();
 952     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
 959     // new head
 960     *system_processes = tmp;
 961     // increment
 962     (*no_of_sys_processes)++;
 963     // step forward
 964     _iterator-&gt;next_process();
 965   }
 966   return OS_OK;
 967 }
 968 
 969 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 970   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 971 }
 972 
 973 SystemProcessInterface::SystemProcessInterface() {
 974   _impl = NULL;
 975 }
 976 
 977 bool SystemProcessInterface::initialize() {
 978   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified"> 979   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 980 }
 981 
 982 SystemProcessInterface::~SystemProcessInterface() {
 983   if (_impl != NULL) {
 984     delete _impl;
 985   }
 986 }
 987 
 988 CPUInformationInterface::CPUInformationInterface() {
 989   _cpu_info = NULL;
 990 }
 991 
 992 bool CPUInformationInterface::initialize() {
 993   _cpu_info = new CPUInformation();
<span class="line-removed"> 994   if (NULL == _cpu_info) {</span>
<span class="line-removed"> 995     return false;</span>
<span class="line-removed"> 996   }</span>
 997   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
 998   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
 999   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1000   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1001   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<span class="line-removed">1002 </span>
1003   return true;
1004 }
1005 
1006 CPUInformationInterface::~CPUInformationInterface() {
1007   if (_cpu_info != NULL) {
1008     if (_cpu_info-&gt;cpu_name() != NULL) {
1009       const char* cpu_name = _cpu_info-&gt;cpu_name();
1010       FREE_C_HEAP_ARRAY(char, cpu_name);
1011       _cpu_info-&gt;set_cpu_name(NULL);
1012     }
1013     if (_cpu_info-&gt;cpu_description() != NULL) {
1014        const char* cpu_desc = _cpu_info-&gt;cpu_description();
1015        FREE_C_HEAP_ARRAY(char, cpu_desc);
1016       _cpu_info-&gt;set_cpu_description(NULL);
1017     }
1018     delete _cpu_info;
1019   }
1020 }
1021 
1022 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1023   if (_cpu_info == NULL) {
1024     return OS_ERR;
1025   }
1026 
1027   cpu_info = *_cpu_info; // shallow copy assignment
1028   return OS_OK;
1029 }
1030 
1031 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1032   friend class NetworkPerformanceInterface;
1033  private:
1034   NetworkPerformance();
<span class="line-modified">1035   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">1036   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
1037   bool initialize();
1038   ~NetworkPerformance();
1039   int network_utilization(NetworkInterface** network_interfaces) const;
1040 };
1041 
1042 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
1043 
1044 }
1045 
1046 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1047   return true;
1048 }
1049 
1050 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1051 }
1052 
1053 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
1054 {
1055   return FUNCTIONALITY_NOT_IMPLEMENTED;
1056 }
1057 
1058 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1059   _impl = NULL;
1060 }
1061 
1062 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1063   if (_impl != NULL) {
1064     delete _impl;
1065   }
1066 }
1067 
1068 bool NetworkPerformanceInterface::initialize() {
1069   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">1070   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1071 }
1072 
1073 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1074   return _impl-&gt;network_utilization(network_interfaces);
1075 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_aix.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;
<span class="line-added">  31 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  32 
  33 #include CPU_HEADER(vm_version_ext)
  34 
  35 #include &lt;stdio.h&gt;
  36 #include &lt;stdarg.h&gt;
  37 #include &lt;unistd.h&gt;
  38 #include &lt;errno.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;sys/resource.h&gt;
  41 #include &lt;sys/types.h&gt;
  42 #include &lt;sys/stat.h&gt;
  43 #include &lt;dirent.h&gt;
  44 #include &lt;stdlib.h&gt;
  45 #include &lt;dlfcn.h&gt;
  46 #include &lt;pthread.h&gt;
  47 #include &lt;limits.h&gt;
  48 
  49 /**
  50    /proc/[number]/stat
  51               Status information about the process.  This is used by ps(1).  It is defined in /usr/src/linux/fs/proc/array.c.
</pre>
<hr />
<pre>
 257         n = vsscanf(tmp, fmt, args);
 258       }
 259     }
 260   }
 261 
 262   fclose(f);
 263 
 264   return n;
 265 }
 266 
 267 static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {
 268   int   n;
 269   va_list args;
 270 
 271   va_start(args, fmt);
 272   n = vread_statdata(procfile, fmt, args);
 273   va_end(args);
 274   return n;
 275 }
 276 




















 277 /**
<span class="line-modified"> 278  * on Linux we got the ticks related information from /proc/stat</span>
<span class="line-modified"> 279  * this does not work on AIX, libperfstat might be an alternative</span>






 280  */
 281 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
<span class="line-modified"> 282   return OS_ERR;</span>








































































 283 }
 284 
 285 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 286 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 287   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 288     userTicks, systemTicks);
 289 }
 290 
 291 /**
 292  * Return the number of ticks spent in any of the processes belonging
 293  * to the JVM on any CPU.
 294  */
 295 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
<span class="line-modified"> 296   return OS_ERR;</span>



















 297 }
 298 
 299 /**
 300  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 301  * available time for user or system processes, 0.0 means the CPU uses all time
 302  * being idle.
 303  *
 304  * Returns a negative value if there is a problem in determining the CPU load.
 305  */
 306 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 307   uint64_t udiff, kdiff, tdiff;
 308   CPUPerfTicks* pticks;
 309   CPUPerfTicks  tmp;
 310   double user_load;
 311 
 312   *pkernelLoad = 0.0;
 313 
 314   if (target == CPU_LOAD_VM_ONLY) {
 315     pticks = &amp;counters-&gt;jvmTicks;
 316   } else if (-1 == which_logical_cpu) {
</pre>
<hr />
<pre>
 340   udiff = pticks-&gt;used - tmp.used;
 341 
 342   if (tdiff == 0) {
 343     return 0.0;
 344   } else if (tdiff &lt; (udiff + kdiff)) {
 345     tdiff = udiff + kdiff;
 346   }
 347   *pkernelLoad = (kdiff / (double)tdiff);
 348   // BUG9044876, normalize return values to sane values
 349   *pkernelLoad = MAX2&lt;double&gt;(*pkernelLoad, 0.0);
 350   *pkernelLoad = MIN2&lt;double&gt;(*pkernelLoad, 1.0);
 351 
 352   user_load = (udiff / (double)tdiff);
 353   user_load = MAX2&lt;double&gt;(user_load, 0.0);
 354   user_load = MIN2&lt;double&gt;(user_load, 1.0);
 355 
 356   return user_load;
 357 }
 358 
 359 static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
<span class="line-modified"> 360   return OS_ERR;</span>






















 361 }
 362 
 363 static int get_noof_context_switches(uint64_t* switches) {
 364   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 365 }
 366 
 367 /** returns boot time in _seconds_ since epoch */
 368 static int get_boot_time(uint64_t* time) {
 369   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 370 }
 371 
 372 static int perf_context_switch_rate(double* rate) {
 373   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified"> 374   static uint64_t      bootTime;</span>
<span class="line-added"> 375   static uint64_t      lastTimeNanos;</span>
 376   static uint64_t      lastSwitches;
 377   static double        lastRate;
 378 
<span class="line-modified"> 379   uint64_t bt = 0;</span>
 380   int res = 0;
 381 
<span class="line-modified"> 382   // First time through bootTime will be zero.</span>
<span class="line-added"> 383   if (bootTime == 0) {</span>
 384     uint64_t tmp;
 385     if (get_boot_time(&amp;tmp) &lt; 0) {
 386       return OS_ERR;
 387     }
<span class="line-modified"> 388     bt = tmp * 1000;</span>
 389   }
 390 
 391   res = OS_OK;
 392 
 393   pthread_mutex_lock(&amp;contextSwitchLock);
 394   {
 395 
 396     uint64_t sw;
 397     s8 t, d;
 398 
<span class="line-modified"> 399     if (bootTime == 0) {</span>
<span class="line-modified"> 400       // First interval is measured from boot time which is</span>
<span class="line-added"> 401       // seconds since the epoch. Thereafter we measure the</span>
<span class="line-added"> 402       // elapsed time using javaTimeNanos as it is monotonic-</span>
<span class="line-added"> 403       // non-decreasing.</span>
<span class="line-added"> 404       lastTimeNanos = os::javaTimeNanos();</span>
<span class="line-added"> 405       t = os::javaTimeMillis();</span>
<span class="line-added"> 406       d = t - bt;</span>
<span class="line-added"> 407       // keep bootTime zero for now to use as a first-time-through flag</span>
<span class="line-added"> 408     } else {</span>
<span class="line-added"> 409       t = os::javaTimeNanos();</span>
<span class="line-added"> 410       d = nanos_to_millis(t - lastTimeNanos);</span>
 411     }
 412 



 413     if (d == 0) {
 414       *rate = lastRate;
<span class="line-modified"> 415     } else if (get_noof_context_switches(&amp;sw) == 0) {</span>
 416       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 417       lastRate     = *rate;
 418       lastSwitches = sw;
<span class="line-modified"> 419       if (bootTime != 0) {</span>
<span class="line-added"> 420         lastTimeNanos = t;</span>
<span class="line-added"> 421       }</span>
 422     } else {
 423       *rate = 0;
 424       res   = OS_ERR;
 425     }
 426     if (*rate &lt;= 0) {
 427       *rate = 0;
 428       lastRate = 0;
 429     }
<span class="line-added"> 430 </span>
<span class="line-added"> 431     if (bootTime == 0) {</span>
<span class="line-added"> 432       bootTime = bt;</span>
<span class="line-added"> 433     }</span>
 434   }
 435   pthread_mutex_unlock(&amp;contextSwitchLock);
 436 
 437   return res;
 438 }
 439 
 440 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 441   friend class CPUPerformanceInterface;
 442  private:
 443   CPUPerfCounters _counters;
 444 
 445   int cpu_load(int which_logical_cpu, double* cpu_load);
 446   int context_switch_rate(double* rate);
 447   int cpu_load_total_process(double* cpu_load);
 448   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 449 
 450  public:
 451   CPUPerformance();
 452   bool initialize();
 453   ~CPUPerformance();
 454 };
 455 
 456 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 457   _counters.nProcs = os::active_processor_count();
 458   _counters.cpus = NULL;
 459 }
 460 
 461 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified"> 462   size_t array_entry_count = _counters.nProcs + 1;</span>
<span class="line-modified"> 463   _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);</span>
<span class="line-modified"> 464   memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));</span>



 465 
 466   // For the CPU load total
 467   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);
 468 
 469   // For each CPU
 470   for (int i = 0; i &lt; _counters.nProcs; i++) {
 471     get_total_ticks(i, &amp;_counters.cpus[i]);
 472   }
 473   // For JVM load
 474   get_jvm_ticks(&amp;_counters.jvmTicks);
 475 
 476   // initialize context switch system
 477   // the double is only for init
 478   double init_ctx_switch_rate;
 479   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 480 
 481   return true;
 482 }
 483 
 484 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
</pre>
<hr />
<pre>
 531     t = MIN2&lt;double&gt;(u + s, 1.0);
 532   }
 533 
 534   *pjvmUserLoad = u;
 535   *pjvmKernelLoad = s;
 536   *psystemTotalLoad = t;
 537 
 538   return OS_OK;
 539 }
 540 
 541 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 542   return perf_context_switch_rate(rate);
 543 }
 544 
 545 CPUPerformanceInterface::CPUPerformanceInterface() {
 546   _impl = NULL;
 547 }
 548 
 549 bool CPUPerformanceInterface::initialize() {
 550   _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified"> 551   return _impl-&gt;initialize();</span>
 552 }
 553 
 554 CPUPerformanceInterface::~CPUPerformanceInterface() {
 555   if (_impl != NULL) {
 556     delete _impl;
 557   }
 558 }
 559 
 560 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 561   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 562 }
 563 
 564 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 565   return _impl-&gt;cpu_load_total_process(cpu_load);
 566 }
 567 
 568 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 569   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 570 }
 571 
</pre>
<hr />
<pre>
 684 }
 685 
 686 // get command line from /proc/&lt;pid&gt;/cmdline
 687 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 688   FILE* fp;
 689   char  buffer[PATH_MAX];
 690   char* cmdline = NULL;
 691 
 692   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 693   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 694   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 695     size_t size = 0;
 696     char   dummy;
 697 
 698     // find out how long the file is (stat always returns 0)
 699     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 700       size++;
 701     }
 702     if (size &gt; 0) {
 703       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified"> 704       cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 705       if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 706         if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 707           // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 708           // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 709           for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 710             if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-modified"> 711               cmdline[i] = &#39; &#39;;</span>


 712             }

 713           }
<span class="line-added"> 714           cmdline[size] = &#39;\0&#39;;</span>
 715         }
 716       }
 717     }
 718     fclose(fp);
 719   }
 720   return cmdline;
 721 }
 722 
 723 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 724 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 725   char buffer[PATH_MAX];
 726 
 727   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 728   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 729   return realpath(buffer, _exePath);
 730 }
 731 
 732 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 733   if (str != NULL) {
 734     return os::strdup_check_oom(str, mtInternal);
</pre>
<hr />
<pre>
 784   _valid = false;
 785 }
 786 
 787 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
 788   // Not yet implemented.
 789   return false;
 790 }
 791 
 792 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 793   if (_dir != NULL) {
 794     os::closedir(_dir);
 795   }
 796 }
 797 
 798 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 799   _iterator = NULL;
 800 }
 801 
 802 bool SystemProcessInterface::SystemProcesses::initialize() {
 803   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified"> 804   return _iterator-&gt;initialize();</span>
 805 }
 806 
 807 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 808   if (_iterator != NULL) {
 809     delete _iterator;
 810   }
 811 }
 812 
 813 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 814   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 815   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 816   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 817 
 818   // initialize pointers
 819   *no_of_sys_processes = 0;
 820   *system_processes = NULL;
 821 
 822   while (_iterator-&gt;is_valid()) {
 823     SystemProcess* tmp = new SystemProcess();
 824     _iterator-&gt;current(tmp);
</pre>
<hr />
<pre>
 831     // new head
 832     *system_processes = tmp;
 833     // increment
 834     (*no_of_sys_processes)++;
 835     // step forward
 836     _iterator-&gt;next_process();
 837   }
 838   return OS_OK;
 839 }
 840 
 841 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 842   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 843 }
 844 
 845 SystemProcessInterface::SystemProcessInterface() {
 846   _impl = NULL;
 847 }
 848 
 849 bool SystemProcessInterface::initialize() {
 850   _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified"> 851   return _impl-&gt;initialize();</span>
 852 }
 853 
 854 SystemProcessInterface::~SystemProcessInterface() {
 855   if (_impl != NULL) {
 856     delete _impl;
 857   }
 858 }
 859 
 860 CPUInformationInterface::CPUInformationInterface() {
 861   _cpu_info = NULL;
 862 }
 863 
 864 bool CPUInformationInterface::initialize() {
 865   _cpu_info = new CPUInformation();



 866   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
 867   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
 868   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
 869   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
 870   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());

 871   return true;
 872 }
 873 
 874 CPUInformationInterface::~CPUInformationInterface() {
 875   if (_cpu_info != NULL) {
 876     if (_cpu_info-&gt;cpu_name() != NULL) {
 877       const char* cpu_name = _cpu_info-&gt;cpu_name();
 878       FREE_C_HEAP_ARRAY(char, cpu_name);
 879       _cpu_info-&gt;set_cpu_name(NULL);
 880     }
 881     if (_cpu_info-&gt;cpu_description() != NULL) {
 882        const char* cpu_desc = _cpu_info-&gt;cpu_description();
 883        FREE_C_HEAP_ARRAY(char, cpu_desc);
 884       _cpu_info-&gt;set_cpu_description(NULL);
 885     }
 886     delete _cpu_info;
 887   }
 888 }
 889 
 890 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
 891   if (_cpu_info == NULL) {
 892     return OS_ERR;
 893   }
 894 
 895   cpu_info = *_cpu_info; // shallow copy assignment
 896   return OS_OK;
 897 }
 898 
 899 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
 900   friend class NetworkPerformanceInterface;
 901  private:
 902   NetworkPerformance();
<span class="line-modified"> 903   NONCOPYABLE(NetworkPerformance);</span>

 904   bool initialize();
 905   ~NetworkPerformance();
 906   int network_utilization(NetworkInterface** network_interfaces) const;
 907 };
 908 
 909 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
 910 
 911 }
 912 
 913 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
 914   return true;
 915 }
 916 
 917 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
 918 }
 919 
 920 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
 921 {
 922   return FUNCTIONALITY_NOT_IMPLEMENTED;
 923 }
 924 
 925 NetworkPerformanceInterface::NetworkPerformanceInterface() {
 926   _impl = NULL;
 927 }
 928 
 929 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
 930   if (_impl != NULL) {
 931     delete _impl;
 932   }
 933 }
 934 
 935 bool NetworkPerformanceInterface::initialize() {
 936   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified"> 937   return _impl-&gt;initialize();</span>
 938 }
 939 
 940 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
 941   return _impl-&gt;network_utilization(network_interfaces);
 942 }
</pre>
</td>
</tr>
</table>
<center><a href="os_aix.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
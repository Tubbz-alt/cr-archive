<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os/aix/safepointMechanism_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="perfMemory_aix.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../bsd/attachListener_bsd.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/safepointMechanism_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,18 +30,18 @@</span>
  #include &quot;services/memTracker.hpp&quot;
  #include &lt;sys/mman.h&gt;
  
  void SafepointMechanism::pd_initialize() {
    // No special code needed if we can use SIGTRAP
<span class="udiff-line-modified-removed">-   if (ThreadLocalHandshakes &amp;&amp; USE_POLL_BIT_ONLY) {</span>
<span class="udiff-line-modified-added">+   if (USE_POLL_BIT_ONLY) {</span>
      default_initialize();
      return;
    }
  
    // Allocate one protected page
    char* map_address = (char*)MAP_FAILED;
<span class="udiff-line-modified-removed">-   const size_t map_size = ThreadLocalHandshakes ? 2 * os::vm_page_size() : os::vm_page_size();</span>
<span class="udiff-line-modified-added">+   const size_t map_size = 2 * os::vm_page_size();</span>
    const int prot  = PROT_READ;
    const int flags = MAP_PRIVATE | MAP_ANONYMOUS;
  
    // Use optimized addresses for the polling page,
    // e.g. map it to a special 32-bit address.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,15 +97,12 @@</span>
    os::set_polling_page((address)(map_address));
  
    // Register polling page with NMT.
    MemTracker::record_virtual_memory_reserve_and_commit(map_address, map_size, CALLER_PC, mtSafepoint);
  
<span class="udiff-line-modified-removed">-   // Use same page for ThreadLocalHandshakes without SIGTRAP</span>
<span class="udiff-line-modified-removed">-   if (ThreadLocalHandshakes) {</span>
<span class="udiff-line-modified-removed">-     set_uses_thread_local_poll();</span>
<span class="udiff-line-modified-removed">-     os::make_polling_page_unreadable();</span>
<span class="udiff-line-modified-removed">-     intptr_t bad_page_val  = reinterpret_cast&lt;intptr_t&gt;(map_address),</span>
<span class="udiff-line-modified-removed">-              good_page_val = bad_page_val + os::vm_page_size();</span>
<span class="udiff-line-removed">-     _poll_armed_value    = reinterpret_cast&lt;void*&gt;(bad_page_val  + poll_bit());</span>
<span class="udiff-line-removed">-     _poll_disarmed_value = reinterpret_cast&lt;void*&gt;(good_page_val);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Use same page for thread local handshakes without SIGTRAP</span>
<span class="udiff-line-modified-added">+   os::make_polling_page_unreadable();</span>
<span class="udiff-line-modified-added">+   intptr_t bad_page_val  = reinterpret_cast&lt;intptr_t&gt;(map_address),</span>
<span class="udiff-line-modified-added">+            good_page_val = bad_page_val + os::vm_page_size();</span>
<span class="udiff-line-modified-added">+   _poll_armed_value    = reinterpret_cast&lt;void*&gt;(bad_page_val  + poll_bit());</span>
<span class="udiff-line-modified-added">+   _poll_disarmed_value = reinterpret_cast&lt;void*&gt;(good_page_val);</span>
  }
</pre>
<center><a href="perfMemory_aix.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../bsd/attachListener_bsd.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
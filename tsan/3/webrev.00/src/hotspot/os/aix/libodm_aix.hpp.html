<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/aix/libodm_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2015, 2019 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 // Encapsulates the libodm library and provides more convenient interfaces.
 27 
 28 #ifndef OS_AIX_LIBODM_AIX_HPP
 29 #define OS_AIX_LIBODM_AIX_HPP
 30 
 31 #include &lt;odmi.h&gt;
 32 
 33 
 34 // The purpose of this code is to dynamically load the libodm library
 35 // instead of statically linking against it. The library is AIX-specific.
 36 // It only exists on AIX, not on PASE. In order to share binaries
 37 // between AIX and PASE, we can&#39;t directly link against it.
 38 
 39 typedef int          (*fun_odm_initialize )(void);
 40 typedef char*        (*fun_odm_set_path   )(char*);
 41 typedef CLASS_SYMBOL (*fun_odm_mount_class)(char*);
 42 typedef void*        (*fun_odm_get_obj    )(CLASS_SYMBOL, char*, void*, int);
 43 typedef int          (*fun_odm_terminate  )(void);
 44 
 45 class dynamicOdm {
 46   void *_libhandle;
 47  protected:
 48   fun_odm_initialize  _odm_initialize;
 49   fun_odm_set_path    _odm_set_path;
 50   fun_odm_mount_class _odm_mount_class;
 51   fun_odm_get_obj     _odm_get_obj;
 52   fun_odm_terminate   _odm_terminate;
 53  public:
 54   dynamicOdm();
 55   ~dynamicOdm();
 56   bool odm_loaded() {return _libhandle != NULL; }
 57 };
 58 
 59 
 60 // We provide a more convenient interface for odm access and
 61 // especially to determine the exact AIX kernel version.
 62 
 63 class odmWrapper : private dynamicOdm {
 64   CLASS_SYMBOL _odm_class;
 65   char *_data;
 66   bool _initialized;
 67   void clean_data();
 68 
 69  public:
 70   // Make sure everything gets initialized and cleaned up properly.
 71   explicit odmWrapper(const char* odm_class_name, const char* odm_path = NULL) : _odm_class((CLASS_SYMBOL)-1),
 72                                                                      _data(NULL), _initialized(false) {
 73     if (!odm_loaded()) { return; }
 74     _initialized = ((*_odm_initialize)() != -1);
 75     if (_initialized) {
 76       // should we free what odm_set_path returns, man page suggests it
 77       // see https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/o_bostechref/odm_set_path.html
 78       if (odm_path) { (*_odm_set_path)((char*)odm_path); }
 79       _odm_class = (*_odm_mount_class)((char*)odm_class_name);
 80     }
 81   }
 82   ~odmWrapper() {
 83     if (_initialized) { (*_odm_terminate)(); clean_data(); }
 84   }
 85 
 86   CLASS_SYMBOL odm_class() { return _odm_class; }
 87   bool has_class() { return odm_class() != (CLASS_SYMBOL)-1; }
 88   int class_offset(const char *field, bool is_aix_5);
 89   char* data() { return _data; }
 90 
 91   char* retrieve_obj(const char* name = NULL) {
 92     clean_data();
 93     char *cnp = (char*)(void*)(*_odm_get_obj)(odm_class(), (char*) name, NULL, (name == NULL) ? ODM_NEXT : ODM_FIRST);
 94     if (cnp != (char*)-1) { _data = cnp; }
 95     return data();
 96   }
 97 
 98   int read_short(int offs) {
 99     short *addr = (short*)(data() + offs);
100     return *addr;
101   }
102 
103   // Determine the exact AIX kernel version as 4 byte value.
104   // The high order 2 bytes must be initialized already. They can be determined by uname.
105   static void determine_os_kernel_version(uint32_t* p_ver);
106 };
107 
108 #endif // OS_AIX_LIBODM_AIX_HPP
    </pre>
  </body>
</html>
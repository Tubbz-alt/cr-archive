<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/os_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loadlib_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/os_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 // According to the AIX OS doc #pragma alloca must be used
  27 // with C++ compiler before referencing the function alloca()
  28 #pragma alloca
  29 
  30 // no precompiled headers
  31 #include &quot;jvm.h&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/systemDictionary.hpp&quot;
  34 #include &quot;classfile/vmSymbols.hpp&quot;
  35 #include &quot;code/icBuffer.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;

  40 #include &quot;libo4.hpp&quot;
  41 #include &quot;libperfstat_aix.hpp&quot;
  42 #include &quot;libodm_aix.hpp&quot;
  43 #include &quot;loadlib_aix.hpp&quot;
  44 #include &quot;memory/allocation.inline.hpp&quot;
  45 #include &quot;memory/filemap.hpp&quot;
  46 #include &quot;misc_aix.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;
  48 #include &quot;os_aix.inline.hpp&quot;
  49 #include &quot;os_share_aix.hpp&quot;
  50 #include &quot;porting_aix.hpp&quot;
  51 #include &quot;prims/jniFastGetField.hpp&quot;
  52 #include &quot;prims/jvm_misc.hpp&quot;
  53 #include &quot;runtime/arguments.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/extendedPC.hpp&quot;
  56 #include &quot;runtime/globals.hpp&quot;
  57 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  58 #include &quot;runtime/java.hpp&quot;
  59 #include &quot;runtime/javaCalls.hpp&quot;
  60 #include &quot;runtime/mutexLocker.hpp&quot;
  61 #include &quot;runtime/objectMonitor.hpp&quot;
<span class="line-removed">  62 #include &quot;runtime/orderAccess.hpp&quot;</span>
  63 #include &quot;runtime/os.hpp&quot;
  64 #include &quot;runtime/osThread.hpp&quot;
  65 #include &quot;runtime/perfMemory.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/statSampler.hpp&quot;
  68 #include &quot;runtime/stubRoutines.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/threadCritical.hpp&quot;
  71 #include &quot;runtime/timer.hpp&quot;
  72 #include &quot;runtime/vm_version.hpp&quot;
  73 #include &quot;services/attachListener.hpp&quot;
  74 #include &quot;services/runtimeService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/decoder.hpp&quot;
  77 #include &quot;utilities/defaultStream.hpp&quot;
  78 #include &quot;utilities/events.hpp&quot;
  79 #include &quot;utilities/growableArray.hpp&quot;
  80 #include &quot;utilities/vmError.hpp&quot;
  81 
  82 // put OS-includes here (sorted alphabetically)
</pre>
<hr />
<pre>
 114 extern &quot;C&quot;
 115 int mread_real_time(timebasestruct_t *t, size_t size_of_timebasestruct_t);
 116 
 117 #if !defined(_AIXVERSION_610)
 118 extern &quot;C&quot; int getthrds64(pid_t, struct thrdentry64*, int, tid64_t*, int);
 119 extern &quot;C&quot; int getprocs64(procentry64*, int, fdsinfo*, int, pid_t*, int);
 120 extern &quot;C&quot; int getargs(procsinfo*, int, char*, int);
 121 #endif
 122 
 123 #define MAX_PATH (2 * K)
 124 
 125 // for timer info max values which include all bits
 126 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 127 // for multipage initialization error analysis (in &#39;g_multipage_error&#39;)
 128 #define ERROR_MP_OS_TOO_OLD                          100
 129 #define ERROR_MP_EXTSHM_ACTIVE                       101
 130 #define ERROR_MP_VMGETINFO_FAILED                    102
 131 #define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103
 132 
 133 // excerpts from systemcfg.h that might be missing on older os levels
<span class="line-removed"> 134 #ifndef PV_5_Compat</span>
<span class="line-removed"> 135   #define PV_5_Compat 0x0F8000   /* Power PC 5 */</span>
<span class="line-removed"> 136 #endif</span>
<span class="line-removed"> 137 #ifndef PV_6</span>
<span class="line-removed"> 138   #define PV_6 0x100000          /* Power PC 6 */</span>
<span class="line-removed"> 139 #endif</span>
<span class="line-removed"> 140 #ifndef PV_6_1</span>
<span class="line-removed"> 141   #define PV_6_1 0x100001        /* Power PC 6 DD1.x */</span>
<span class="line-removed"> 142 #endif</span>
<span class="line-removed"> 143 #ifndef PV_6_Compat</span>
<span class="line-removed"> 144   #define PV_6_Compat 0x108000   /* Power PC 6 */</span>
<span class="line-removed"> 145 #endif</span>
 146 #ifndef PV_7
 147   #define PV_7 0x200000          /* Power PC 7 */
 148 #endif
 149 #ifndef PV_7_Compat
 150   #define PV_7_Compat 0x208000   /* Power PC 7 */
 151 #endif
 152 #ifndef PV_8
 153   #define PV_8 0x300000          /* Power PC 8 */
 154 #endif
 155 #ifndef PV_8_Compat
 156   #define PV_8_Compat 0x308000   /* Power PC 8 */
 157 #endif







 158 
 159 static address resolve_function_descriptor_to_code_pointer(address p);
 160 
 161 static void vmembk_print_on(outputStream* os);
 162 
 163 ////////////////////////////////////////////////////////////////////////////////
 164 // global variables (for a description see os_aix.hpp)
 165 
 166 julong    os::Aix::_physical_memory = 0;
 167 
 168 pthread_t os::Aix::_main_thread = ((pthread_t)0);
 169 int       os::Aix::_page_size = -1;
 170 
 171 // -1 = uninitialized, 0 if AIX, 1 if OS/400 pase
 172 int       os::Aix::_on_pase = -1;
 173 
 174 // 0 = uninitialized, otherwise 32 bit number:
 175 //  0xVVRRTTSS
 176 //  VV - major version
 177 //  RR - minor version
</pre>
<hr />
<pre>
 469       trcVerbose(&quot; %s &quot;, describe_pagesize(sizes[i]));
 470     }
 471 
 472     // Can we use 64K, 16M pages?
 473     for (int i = 0; i &lt; num_psizes; i ++) {
 474       const size_t pagesize = sizes[i];
 475       if (pagesize != 64*K &amp;&amp; pagesize != 16*M) {
 476         continue;
 477       }
 478       bool can_use = false;
 479       trcVerbose(&quot;Probing support for %s pages...&quot;, describe_pagesize(pagesize));
 480       const int shmid = ::shmget(IPC_PRIVATE, pagesize,
 481         IPC_CREAT | S_IRUSR | S_IWUSR);
 482       guarantee0(shmid != -1); // Should always work.
 483       // Try to set pagesize.
 484       struct shmid_ds shm_buf = { 0 };
 485       shm_buf.shm_pagesize = pagesize;
 486       if (::shmctl(shmid, SHM_PAGESIZE, &amp;shm_buf) != 0) {
 487         const int en = errno;
 488         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
<span class="line-modified"> 489         trcVerbose(&quot;shmctl(SHM_PAGESIZE) failed with errno=%n&quot;,</span>
<span class="line-removed"> 490           errno);</span>
 491       } else {
 492         // Attach and double check pageisze.
 493         void* p = ::shmat(shmid, NULL, 0);
 494         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
 495         guarantee0(p != (void*) -1); // Should always work.
 496         const size_t real_pagesize = os::Aix::query_pagesize(p);
 497         if (real_pagesize != pagesize) {
<span class="line-modified"> 498           trcVerbose(&quot;real page size (0x%llX) differs.&quot;, real_pagesize);</span>
 499         } else {
 500           can_use = true;
 501         }
 502         ::shmdt(p);
 503       }
 504       trcVerbose(&quot;Can use: %s&quot;, (can_use ? &quot;yes&quot; : &quot;no&quot;));
 505       if (pagesize == 64*K) {
 506         g_multipage_support.can_use_64K_pages = can_use;
 507       } else if (pagesize == 16*M) {
 508         g_multipage_support.can_use_16M_pages = can_use;
 509       }
 510     }
 511 
 512   } // end: check which pages can be used for shared memory
 513 
 514 query_multipage_support_end:
 515 
 516   trcVerbose(&quot;base page size (sysconf _SC_PAGESIZE): %s&quot;,
 517       describe_pagesize(g_multipage_support.pagesize));
 518   trcVerbose(&quot;Data page size (C-Heap, bss, etc): %s&quot;,
 519       describe_pagesize(g_multipage_support.datapsize));
 520   trcVerbose(&quot;Text page size: %s&quot;,
 521       describe_pagesize(g_multipage_support.textpsize));
 522   trcVerbose(&quot;Thread stack page size (pthread): %s&quot;,
 523       describe_pagesize(g_multipage_support.pthr_stack_pagesize));
 524   trcVerbose(&quot;Default shared memory page size: %s&quot;,
 525       describe_pagesize(g_multipage_support.shmpsize));
<span class="line-modified"> 526   trcVerbose(&quot;Can use 64K pages dynamically with shared meory: %s&quot;,</span>
 527       (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
 528   trcVerbose(&quot;Can use 16M pages dynamically with shared memory: %s&quot;,
 529       (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
 530   trcVerbose(&quot;Multipage error details: %d&quot;,
 531       g_multipage_support.error);
 532 
 533   // sanity checks
 534   assert0(g_multipage_support.pagesize == 4*K);
 535   assert0(g_multipage_support.datapsize == 4*K || g_multipage_support.datapsize == 64*K);
 536   assert0(g_multipage_support.textpsize == 4*K || g_multipage_support.textpsize == 64*K);
 537   assert0(g_multipage_support.pthr_stack_pagesize == g_multipage_support.datapsize);
 538   assert0(g_multipage_support.shmpsize == 4*K || g_multipage_support.shmpsize == 64*K);
 539 
 540 }
 541 
 542 void os::init_system_properties_values() {
 543 
 544 #ifndef OVERRIDE_LIBPATH
 545   #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 546 #else
 547   #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 548 #endif
 549 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 550 
 551   // Buffer that fits several sprintfs.
 552   // Note that the space for the trailing null is provided
 553   // by the nulls included by the sizeof operator.
 554   const size_t bufsize =
 555     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 556          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 557   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 558 
 559   // sysclasspath, java_home, dll_dir
 560   {
 561     char *pslash;
 562     os::jvm_path(buf, bufsize);
 563 
 564     // Found the full path to libjvm.so.
 565     // Now cut the path to &lt;java_home&gt;/jre if we can.
 566     pslash = strrchr(buf, &#39;/&#39;);
 567     if (pslash != NULL) {
 568       *pslash = &#39;\0&#39;;            // Get rid of /libjvm.so.
 569     }
 570     pslash = strrchr(buf, &#39;/&#39;);
 571     if (pslash != NULL) {
 572       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 573     }
 574     Arguments::set_dll_dir(buf);
 575 
 576     if (pslash != NULL) {
 577       pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 579         *pslash = &#39;\0&#39;;        // Get rid of /lib.
 580       }
 581     }
 582     Arguments::set_java_home(buf);
 583     if (!set_boot_path(&#39;/&#39;, &#39;:&#39;)) {
 584       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 585     }
 586   }
 587 
 588   // Where to look for native libraries.
 589 
 590   // On Aix we get the user setting of LIBPATH.
 591   // Eventually, all the library path setting will be done here.
 592   // Get the user setting of LIBPATH.
 593   const char *v = ::getenv(&quot;LIBPATH&quot;);
 594   const char *v_colon = &quot;:&quot;;
 595   if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 596 
 597   // Concatenate user and invariant part of ld_library_path.
 598   // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 599   char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);</span>
 600   sprintf(ld_library_path, &quot;%s%s&quot; DEFAULT_LIBPATH, v, v_colon);
 601   Arguments::set_library_path(ld_library_path);
 602   FREE_C_HEAP_ARRAY(char, ld_library_path);
 603 
 604   // Extensions directories.
 605   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR, Arguments::get_java_home());
 606   Arguments::set_ext_dirs(buf);
 607 
 608   FREE_C_HEAP_ARRAY(char, buf);
 609 
 610 #undef DEFAULT_LIBPATH
 611 #undef EXTENSIONS_DIR
 612 }
 613 
 614 ////////////////////////////////////////////////////////////////////////////////
 615 // breakpoint support
 616 
 617 void os::breakpoint() {
 618   BREAKPOINT;
 619 }
</pre>
<hr />
<pre>
 906   // Save some cycles and a page by disabling OS guard pages where we have our own
 907   // VM guard pages (in java threads). For other threads, keep system default guard
 908   // pages in place.
 909   if (thr_type == java_thread || thr_type == compiler_thread) {
 910     ret = pthread_attr_setguardsize(&amp;attr, 0);
 911   }
 912 
 913   pthread_t tid = 0;
 914   if (ret == 0) {
 915     ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 916   }
 917 
 918   if (ret == 0) {
 919     char buf[64];
 920     log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 921       (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 922   } else {
 923     char buf[64];
 924     log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%d=%s) for attributes: %s.&quot;,
 925       ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));





 926   }
 927 
 928   pthread_attr_destroy(&amp;attr);
 929 
 930   if (ret != 0) {
 931     // Need to clean up stuff we&#39;ve allocated so far.
 932     thread-&gt;set_osthread(NULL);
 933     delete osthread;
 934     return false;
 935   }
 936 
 937   // OSThread::thread_id is the pthread id.
 938   osthread-&gt;set_thread_id(tid);
 939 
 940   return true;
 941 }
 942 
 943 /////////////////////////////////////////////////////////////////////////////
 944 // attach existing thread
 945 
</pre>
<hr />
<pre>
1005   assert(osthread != NULL, &quot;osthread not set&quot;);
1006 
1007   // We are told to free resources of the argument thread,
1008   // but we can only really operate on the current thread.
1009   assert(Thread::current()-&gt;osthread() == osthread,
1010          &quot;os::free_thread but not current thread&quot;);
1011 
1012   // Restore caller&#39;s signal mask
1013   sigset_t sigmask = osthread-&gt;caller_sigmask();
1014   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
1015 
1016   delete osthread;
1017 }
1018 
1019 ////////////////////////////////////////////////////////////////////////////////
1020 // time support
1021 
1022 // Time since start-up in seconds to a fine granularity.
1023 // Used by VMSelfDestructTimer and the MemProfiler.
1024 double os::elapsedTime() {
<span class="line-modified">1025   return (double)(os::elapsed_counter()) * 0.000001;</span>
1026 }
1027 
1028 jlong os::elapsed_counter() {
<span class="line-modified">1029   timeval time;</span>
<span class="line-removed">1030   int status = gettimeofday(&amp;time, NULL);</span>
<span class="line-removed">1031   return jlong(time.tv_sec) * 1000 * 1000 + jlong(time.tv_usec) - initial_time_count;</span>
1032 }
1033 
1034 jlong os::elapsed_frequency() {
<span class="line-modified">1035   return (1000 * 1000);</span>
1036 }
1037 
1038 bool os::supports_vtime() { return true; }
<span class="line-removed">1039 bool os::enable_vtime()   { return false; }</span>
<span class="line-removed">1040 bool os::vtime_enabled()  { return false; }</span>
1041 
1042 double os::elapsedVTime() {
1043   struct rusage usage;
1044   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1045   if (retval == 0) {
1046     return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec + (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000.0 * 1000);
1047   } else {
1048     // better than nothing, but not much
1049     return elapsedTime();
1050   }
1051 }
1052 
1053 jlong os::javaTimeMillis() {
1054   timeval time;
1055   int status = gettimeofday(&amp;time, NULL);
1056   assert(status != -1, &quot;aix error at gettimeofday()&quot;);
1057   return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);
1058 }
1059 
1060 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
</pre>
<hr />
<pre>
1071 // this unconditionally, so we do it.
1072 //
1073 // See: https://www.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.basetrf2/read_real_time.htm
1074 //
1075 // On PASE: mread_real_time will always return RTC_POWER_PC data, so no
1076 // conversion is necessary. However, mread_real_time will not return
1077 // monotonic results but merely matches read_real_time. So we need a tweak
1078 // to ensure monotonic results.
1079 //
1080 // For PASE no public documentation exists, just word by IBM
1081 jlong os::javaTimeNanos() {
1082   timebasestruct_t time;
1083   int rc = mread_real_time(&amp;time, TIMEBASE_SZ);
1084   if (os::Aix::on_pase()) {
1085     assert(rc == RTC_POWER, &quot;expected time format RTC_POWER from mread_real_time in PASE&quot;);
1086     jlong now = jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
1087     jlong prev = max_real_time;
1088     if (now &lt;= prev) {
1089       return prev;   // same or retrograde time;
1090     }
<span class="line-modified">1091     jlong obsv = Atomic::cmpxchg(now, &amp;max_real_time, prev);</span>
1092     assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
1093     // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
1094     // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
1095     // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
1096     // some other thread raced this thread and installed a new value, in which case
1097     // we could either (a) retry the entire operation, (b) retry trying to install now
1098     // or (c) just return obsv.  We use (c).   No loop is required although in some cases
1099     // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
1100     // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
1101     // to (a) or (b) -- and greatly reduces coherence traffic.
1102     // We might also condition (c) on the magnitude of the delta between obsv and now.
1103     // Avoiding excessive CAS operations to hot RW locations is critical.
1104     // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
1105     return (prev == obsv) ? now : obsv;
1106   } else {
1107     if (rc != RTC_POWER) {
1108       rc = time_base_to_time(&amp;time, TIMEBASE_SZ);
1109       assert(rc != -1, &quot;error calling time_base_to_time()&quot;);
1110     }
1111     return jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
</pre>
<hr />
<pre>
1183 // called from signal handler. Before adding something to os::abort(), make
1184 // sure it is async-safe and can handle partially initialized VM.
1185 void os::abort(bool dump_core, void* siginfo, const void* context) {
1186   os::shutdown();
1187   if (dump_core) {
1188 #ifndef PRODUCT
1189     fdStream out(defaultStream::output_fd());
1190     out.print_raw(&quot;Current thread is &quot;);
1191     char buf[16];
1192     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1193     out.print_raw_cr(buf);
1194     out.print_raw_cr(&quot;Dumping core ...&quot;);
1195 #endif
1196     ::abort(); // dump core
1197   }
1198 
1199   ::exit(1);
1200 }
1201 
1202 // Die immediately, no exit hook, no abort hook, no cleanup.

1203 void os::die() {
<span class="line-modified">1204   ::abort();</span>






1205 }
1206 
1207 intx os::current_thread_id() {
1208   return (intx)pthread_self();
1209 }
1210 
1211 int os::current_process_id() {
1212   return getpid();
1213 }
1214 
1215 // DLL functions
1216 
1217 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1218 
1219 // This must be hard coded because it&#39;s the system&#39;s temporary
1220 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1221 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1222 
1223 // Check if addr is inside libjvm.so.
1224 bool os::address_is_in_vm(address addr) {
</pre>
<hr />
<pre>
1284   if (offset) {
1285     *offset = -1;
1286   }
1287   // Buf is not optional, but offset is optional.
1288   assert(buf != NULL, &quot;sanity check&quot;);
1289   buf[0] = &#39;\0&#39;;
1290 
1291   // Resolve function ptr literals first.
1292   addr = resolve_function_descriptor_to_code_pointer(addr);
1293   if (!addr) {
1294     return false;
1295   }
1296 
1297   return AixSymbols::get_module_name(addr, buf, buflen);
1298 }
1299 
1300 // Loads .dll/.so and in case of error it checks if .dll/.so was built
1301 // for the same architecture as Hotspot is running on.
1302 void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1303 


1304   if (ebuf &amp;&amp; ebuflen &gt; 0) {
1305     ebuf[0] = &#39;\0&#39;;
1306     ebuf[ebuflen - 1] = &#39;\0&#39;;
1307   }
1308 
1309   if (!filename || strlen(filename) == 0) {
1310     ::strncpy(ebuf, &quot;dll_load: empty filename specified&quot;, ebuflen - 1);
1311     return NULL;
1312   }
1313 
1314   // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.
1315   void * result= ::dlopen(filename, RTLD_LAZY);
1316   if (result != NULL) {

1317     // Reload dll cache. Don&#39;t do this in signal handling.
1318     LoadedLibraries::reload();

1319     return result;
1320   } else {
1321     // error analysis when dlopen fails
<span class="line-modified">1322     const char* const error_report = ::dlerror();</span>
<span class="line-modified">1323     if (error_report &amp;&amp; ebuf &amp;&amp; ebuflen &gt; 0) {</span>



1324       snprintf(ebuf, ebuflen - 1, &quot;%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s&quot;,
1325                filename, ::getenv(&quot;LIBPATH&quot;), ::getenv(&quot;LD_LIBRARY_PATH&quot;), error_report);
1326     }


1327   }
1328   return NULL;
1329 }
1330 
1331 void* os::dll_lookup(void* handle, const char* name) {
1332   void* res = dlsym(handle, name);
1333   return res;
1334 }
1335 
1336 void* os::get_default_process_handle() {
1337   return (void*)::dlopen(NULL, RTLD_LAZY);
1338 }
1339 
1340 void os::print_dll_info(outputStream *st) {
1341   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1342   LoadedLibraries::print(st);
1343 }
1344 
1345 void os::get_summary_os_info(char* buf, size_t buflen) {
1346   // There might be something more readable than uname results for AIX.
</pre>
<hr />
<pre>
1350 }
1351 
1352 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1353   // Not yet implemented.
1354   return 0;
1355 }
1356 
1357 void os::print_os_info_brief(outputStream* st) {
1358   uint32_t ver = os::Aix::os_version();
1359   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1360                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1361 
1362   os::Posix::print_uname_info(st);
1363 
1364   // Linux uses print_libversion_info(st); here.
1365 }
1366 
1367 void os::print_os_info(outputStream* st) {
1368   st-&gt;print(&quot;OS:&quot;);
1369 
<span class="line-modified">1370   st-&gt;print(&quot;uname:&quot;);</span>
<span class="line-removed">1371   struct utsname name;</span>
<span class="line-removed">1372   uname(&amp;name);</span>
<span class="line-removed">1373   st-&gt;print(name.sysname); st-&gt;print(&quot; &quot;);</span>
<span class="line-removed">1374   st-&gt;print(name.nodename); st-&gt;print(&quot; &quot;);</span>
<span class="line-removed">1375   st-&gt;print(name.release); st-&gt;print(&quot; &quot;);</span>
<span class="line-removed">1376   st-&gt;print(name.version); st-&gt;print(&quot; &quot;);</span>
<span class="line-removed">1377   st-&gt;print(name.machine);</span>
<span class="line-removed">1378   st-&gt;cr();</span>
1379 
1380   uint32_t ver = os::Aix::os_version();
1381   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1382                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1383 


1384   os::Posix::print_rlimit_info(st);
1385 
<span class="line-modified">1386   // load average</span>
<span class="line-modified">1387   st-&gt;print(&quot;load average:&quot;);</span>
<span class="line-modified">1388   double loadavg[3] = {-1.L, -1.L, -1.L};</span>
<span class="line-modified">1389   os::loadavg(loadavg, 3);</span>
<span class="line-modified">1390   st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>
<span class="line-removed">1391   st-&gt;cr();</span>
1392 
1393   // print wpar info
1394   libperfstat::wparinfo_t wi;
1395   if (libperfstat::get_wparinfo(&amp;wi)) {
1396     st-&gt;print_cr(&quot;wpar info&quot;);
1397     st-&gt;print_cr(&quot;name: %s&quot;, wi.name);
1398     st-&gt;print_cr(&quot;id:   %d&quot;, wi.wpar_id);
1399     st-&gt;print_cr(&quot;type: %s&quot;, (wi.app_wpar ? &quot;application&quot; : &quot;system&quot;));
1400   }
1401 
<span class="line-modified">1402   // print partition info</span>
<span class="line-removed">1403   libperfstat::partitioninfo_t pi;</span>
<span class="line-removed">1404   if (libperfstat::get_partitioninfo(&amp;pi)) {</span>
<span class="line-removed">1405     st-&gt;print_cr(&quot;partition info&quot;);</span>
<span class="line-removed">1406     st-&gt;print_cr(&quot; name: %s&quot;, pi.name);</span>
<span class="line-removed">1407   }</span>
<span class="line-removed">1408 </span>
1409 }
1410 
1411 void os::print_memory_info(outputStream* st) {
1412 
1413   st-&gt;print_cr(&quot;Memory:&quot;);
1414 
1415   st-&gt;print_cr(&quot;  Base page size (sysconf _SC_PAGESIZE):  %s&quot;,
1416     describe_pagesize(g_multipage_support.pagesize));
1417   st-&gt;print_cr(&quot;  Data page size (C-Heap, bss, etc):      %s&quot;,
1418     describe_pagesize(g_multipage_support.datapsize));
1419   st-&gt;print_cr(&quot;  Text page size:                         %s&quot;,
1420     describe_pagesize(g_multipage_support.textpsize));
1421   st-&gt;print_cr(&quot;  Thread stack page size (pthread):       %s&quot;,
1422     describe_pagesize(g_multipage_support.pthr_stack_pagesize));
1423   st-&gt;print_cr(&quot;  Default shared memory page size:        %s&quot;,
1424     describe_pagesize(g_multipage_support.shmpsize));
<span class="line-modified">1425   st-&gt;print_cr(&quot;  Can use 64K pages dynamically with shared meory:  %s&quot;,</span>
1426     (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
1427   st-&gt;print_cr(&quot;  Can use 16M pages dynamically with shared memory: %s&quot;,
1428     (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
1429   st-&gt;print_cr(&quot;  Multipage error: %d&quot;,
1430     g_multipage_support.error);
1431   st-&gt;cr();
1432   st-&gt;print_cr(&quot;  os::vm_page_size:       %s&quot;, describe_pagesize(os::vm_page_size()));
1433 
1434   // print out LDR_CNTRL because it affects the default page sizes
1435   const char* const ldr_cntrl = ::getenv(&quot;LDR_CNTRL&quot;);
1436   st-&gt;print_cr(&quot;  LDR_CNTRL=%s.&quot;, ldr_cntrl ? ldr_cntrl : &quot;&lt;unset&gt;&quot;);
1437 
1438   // Print out EXTSHM because it is an unsupported setting.
1439   const char* const extshm = ::getenv(&quot;EXTSHM&quot;);
1440   st-&gt;print_cr(&quot;  EXTSHM=%s.&quot;, extshm ? extshm : &quot;&lt;unset&gt;&quot;);
1441   if ( (strcmp(extshm, &quot;on&quot;) == 0) || (strcmp(extshm, &quot;ON&quot;) == 0) ) {
1442     st-&gt;print_cr(&quot;  *** Unsupported! Please remove EXTSHM from your environment! ***&quot;);
1443   }
1444 
1445   // Print out AIXTHREAD_GUARDPAGES because it affects the size of pthread stacks.
</pre>
<hr />
<pre>
1471 
1472   // Print program break.
1473   st-&gt;print_cr(&quot;Program break at VM startup: &quot; PTR_FORMAT &quot;.&quot;, p2i(g_brk_at_startup));
1474   address brk_now = (address)::sbrk(0);
1475   if (brk_now != (address)-1) {
1476     st-&gt;print_cr(&quot;Program break now          : &quot; PTR_FORMAT &quot; (distance: &quot; SIZE_FORMAT &quot;k).&quot;,
1477                  p2i(brk_now), (size_t)((brk_now - g_brk_at_startup) / K));
1478   }
1479   st-&gt;print_cr(&quot;MaxExpectedDataSegmentSize    : &quot; SIZE_FORMAT &quot;k.&quot;, MaxExpectedDataSegmentSize / K);
1480   st-&gt;cr();
1481 
1482   // Print segments allocated with os::reserve_memory.
1483   st-&gt;print_cr(&quot;internal virtual memory regions used by vm:&quot;);
1484   vmembk_print_on(st);
1485 }
1486 
1487 // Get a string for the cpuinfo that is a summary of the cpu type
1488 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1489   // read _system_configuration.version
1490   switch (_system_configuration.version) {



1491   case PV_8:
1492     strncpy(buf, &quot;Power PC 8&quot;, buflen);
1493     break;
1494   case PV_7:
1495     strncpy(buf, &quot;Power PC 7&quot;, buflen);
1496     break;
1497   case PV_6_1:
1498     strncpy(buf, &quot;Power PC 6 DD1.x&quot;, buflen);
1499     break;
1500   case PV_6:
1501     strncpy(buf, &quot;Power PC 6&quot;, buflen);
1502     break;
1503   case PV_5:
1504     strncpy(buf, &quot;Power PC 5&quot;, buflen);
1505     break;
1506   case PV_5_2:
1507     strncpy(buf, &quot;Power PC 5_2&quot;, buflen);
1508     break;
1509   case PV_5_3:
1510     strncpy(buf, &quot;Power PC 5_3&quot;, buflen);
1511     break;
1512   case PV_5_Compat:
1513     strncpy(buf, &quot;PV_5_Compat&quot;, buflen);
1514     break;
1515   case PV_6_Compat:
1516     strncpy(buf, &quot;PV_6_Compat&quot;, buflen);
1517     break;
1518   case PV_7_Compat:
1519     strncpy(buf, &quot;PV_7_Compat&quot;, buflen);
1520     break;
1521   case PV_8_Compat:
1522     strncpy(buf, &quot;PV_8_Compat&quot;, buflen);
1523     break;



1524   default:
1525     strncpy(buf, &quot;unknown&quot;, buflen);
1526   }
1527 }
1528 
1529 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1530   // Nothing to do beyond of what os::print_cpu_info() does.
1531 }
1532 
1533 static void print_signal_handler(outputStream* st, int sig,
1534                                  char* buf, size_t buflen);
1535 
1536 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1537   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1538   print_signal_handler(st, SIGSEGV, buf, buflen);
1539   print_signal_handler(st, SIGBUS , buf, buflen);
1540   print_signal_handler(st, SIGFPE , buf, buflen);
1541   print_signal_handler(st, SIGPIPE, buf, buflen);
1542   print_signal_handler(st, SIGXFSZ, buf, buflen);
1543   print_signal_handler(st, SIGILL , buf, buflen);
</pre>
<hr />
<pre>
1630         }
1631       }
1632     }
1633   }
1634 
1635   strncpy(saved_jvm_path, buf, sizeof(saved_jvm_path));
1636   saved_jvm_path[sizeof(saved_jvm_path) - 1] = &#39;\0&#39;;
1637 }
1638 
1639 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1640   // no prefix required, not even &quot;_&quot;
1641 }
1642 
1643 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1644   // no suffix required
1645 }
1646 
1647 ////////////////////////////////////////////////////////////////////////////////
1648 // sun.misc.Signal support
1649 
<span class="line-removed">1650 static volatile jint sigint_count = 0;</span>
<span class="line-removed">1651 </span>
1652 static void
1653 UserHandler(int sig, void *siginfo, void *context) {
<span class="line-removed">1654   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="line-removed">1655   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="line-removed">1656   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="line-removed">1657   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1)</span>
<span class="line-removed">1658     return;</span>
<span class="line-removed">1659 </span>
1660   // Ctrl-C is pressed during error reporting, likely because the error
1661   // handler fails to abort. Let VM die immediately.
1662   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1663     os::die();
1664   }
1665 
1666   os::signal_notify(sig);
1667 }
1668 
1669 void* os::user_handler() {
1670   return CAST_FROM_FN_PTR(void*, UserHandler);
1671 }
1672 
1673 extern &quot;C&quot; {
1674   typedef void (*sa_handler_t)(int);
1675   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1676 }
1677 
1678 void* os::signal(int signal_number, void* handler) {
1679   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
1779       trcVerbose(&quot;msem_lock failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1780       warn_only_once = true;
1781     }
1782   }
1783 }
1784 
1785 static void jdk_misc_signal_init() {
1786   // Initialize signal structures
1787   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1788 
1789   // Initialize signal semaphore
1790   local_sem_init();
1791 }
1792 
1793 void os::signal_notify(int sig) {
1794   Atomic::inc(&amp;pending_signals[sig]);
1795   local_sem_post();
1796 }
1797 
1798 static int check_pending_signals() {
<span class="line-removed">1799   Atomic::store(0, &amp;sigint_count);</span>
1800   for (;;) {
1801     for (int i = 0; i &lt; NSIG + 1; i++) {
1802       jint n = pending_signals[i];
<span class="line-modified">1803       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
1804         return i;
1805       }
1806     }
1807     JavaThread *thread = JavaThread::current();
1808     ThreadBlockInVM tbivm(thread);
1809 
1810     bool threadIsSuspended;
1811     do {
1812       thread-&gt;set_suspend_equivalent();
1813       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1814 
1815       local_sem_wait();
1816 
1817       // were we externally suspended while we were waiting?
1818       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1819       if (threadIsSuspended) {
1820         //
1821         // The semaphore has been incremented, but while we were waiting
1822         // another thread suspended us. We don&#39;t want to continue running
1823         // while suspended because that would surprise the thread that
</pre>
<hr />
<pre>
1856   }
1857 
1858   bool contains_range(char* p, size_t s) const {
1859     return contains_addr(p) &amp;&amp; contains_addr(p + s - 1);
1860   }
1861 
1862   void print_on(outputStream* os) const {
1863     os-&gt;print(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] (&quot; UINTX_FORMAT
1864       &quot; bytes, %d %s pages), %s&quot;,
1865       addr, addr + size - 1, size, size / pagesize, describe_pagesize(pagesize),
1866       (type == VMEM_SHMATED ? &quot;shmat&quot; : &quot;mmap&quot;)
1867     );
1868   }
1869 
1870   // Check that range is a sub range of memory block (or equal to memory block);
1871   // also check that range is fully page aligned to the page size if the block.
1872   void assert_is_valid_subrange(char* p, size_t s) const {
1873     if (!contains_range(p, s)) {
1874       trcVerbose(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not a sub &quot;
1875               &quot;range of [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">1876               p, p + s, addr, addr + size);</span>
1877       guarantee0(false);
1878     }
1879     if (!is_aligned_to(p, pagesize) || !is_aligned_to(p + s, pagesize)) {
1880       trcVerbose(&quot;range [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not&quot;
<span class="line-modified">1881               &quot; aligned to pagesize (%lu)&quot;, p, p + s, (unsigned long) pagesize);</span>
1882       guarantee0(false);
1883     }
1884   }
1885 };
1886 
1887 static struct {
1888   vmembk_t* first;
1889   MiscUtils::CritSect cs;
1890 } vmem;
1891 
1892 static void vmembk_add(char* addr, size_t size, size_t pagesize, int type) {
1893   vmembk_t* p = (vmembk_t*) ::malloc(sizeof(vmembk_t));
1894   assert0(p);
1895   if (p) {
1896     MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1897     p-&gt;addr = addr; p-&gt;size = size;
1898     p-&gt;pagesize = pagesize;
1899     p-&gt;type = type;
1900     p-&gt;next = vmem.first;
1901     vmem.first = p;
</pre>
<hr />
<pre>
1932     vmi-&gt;print_on(os);
1933     os-&gt;cr();
1934   }
1935 }
1936 
1937 // Reserve and attach a section of System V memory.
1938 // If &lt;requested_addr&gt; is not NULL, function will attempt to attach the memory at the given
1939 // address. Failing that, it will attach the memory anywhere.
1940 // If &lt;requested_addr&gt; is NULL, function will attach the memory anywhere.
1941 //
1942 // &lt;alignment_hint&gt; is being ignored by this function. It is very probable however that the
1943 // alignment requirements are met anyway, because shmat() attaches at 256M boundaries.
1944 // Should this be not enogh, we can put more work into it.
1945 static char* reserve_shmated_memory (
1946   size_t bytes,
1947   char* requested_addr,
1948   size_t alignment_hint) {
1949 
1950   trcVerbose(&quot;reserve_shmated_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot;
1951     PTR_FORMAT &quot;, alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="line-modified">1952     bytes, requested_addr, alignment_hint);</span>
1953 
1954   // Either give me wish address or wish alignment but not both.
1955   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint != 0));
1956 
1957   // We must prevent anyone from attaching too close to the
1958   // BRK because that may cause malloc OOM.
1959   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
1960     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="line-modified">1961       &quot;Will attach anywhere.&quot;, requested_addr);</span>
1962     // Act like the OS refused to attach there.
1963     requested_addr = NULL;
1964   }
1965 
1966   // For old AS/400&#39;s (V5R4 and older) we should not even be here - System V shared memory is not
1967   // really supported (max size 4GB), so reserve_mmapped_memory should have been used instead.
1968   if (os::Aix::on_pase_V5R4_or_older()) {
1969     ShouldNotReachHere();
1970   }
1971 
1972   // Align size of shm up to 64K to avoid errors if we later try to change the page size.
1973   const size_t size = align_up(bytes, 64*K);
1974 
1975   // Reserve the shared segment.
1976   int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | S_IRUSR | S_IWUSR);
1977   if (shmid == -1) {
1978     trcVerbose(&quot;shmget(.., &quot; UINTX_FORMAT &quot;, ..) failed (errno: %d).&quot;, size, errno);
1979     return NULL;
1980   }
1981 
</pre>
<hr />
<pre>
1993                size / (64*K), errno);
1994     // I want to know if this ever happens.
1995     assert(false, &quot;failed to set page size for shmat&quot;);
1996   }
1997 
1998   // Now attach the shared segment.
1999   // Note that I attach with SHM_RND - which means that the requested address is rounded down, if
2000   // needed, to the next lowest segment boundary. Otherwise the attach would fail if the address
2001   // were not a segment boundary.
2002   char* const addr = (char*) shmat(shmid, requested_addr, SHM_RND);
2003   const int errno_shmat = errno;
2004 
2005   // (A) Right after shmat and before handing shmat errors delete the shm segment.
2006   if (::shmctl(shmid, IPC_RMID, NULL) == -1) {
2007     trcVerbose(&quot;shmctl(%u, IPC_RMID) failed (%d)\n&quot;, shmid, errno);
2008     assert(false, &quot;failed to remove shared memory segment!&quot;);
2009   }
2010 
2011   // Handle shmat error. If we failed to attach, just return.
2012   if (addr == (char*)-1) {
<span class="line-modified">2013     trcVerbose(&quot;Failed to attach segment at &quot; PTR_FORMAT &quot; (%d).&quot;, requested_addr, errno_shmat);</span>
2014     return NULL;
2015   }
2016 
2017   // Just for info: query the real page size. In case setting the page size did not
2018   // work (see above), the system may have given us something other then 4K (LDR_CNTRL).
2019   const size_t real_pagesize = os::Aix::query_pagesize(addr);
2020   if (real_pagesize != shmbuf.shm_pagesize) {
<span class="line-modified">2021     trcVerbose(&quot;pagesize is, surprisingly, %h.&quot;, real_pagesize);</span>
2022   }
2023 
2024   if (addr) {
2025     trcVerbose(&quot;shm-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes, &quot; UINTX_FORMAT &quot; %s pages)&quot;,
<span class="line-modified">2026       addr, addr + size - 1, size, size/real_pagesize, describe_pagesize(real_pagesize));</span>
2027   } else {
2028     if (requested_addr != NULL) {
<span class="line-modified">2029       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at with address &quot; PTR_FORMAT &quot;.&quot;, size, requested_addr);</span>
2030     } else {
2031       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, size);
2032     }
2033   }
2034 
2035   // book-keeping
2036   vmembk_add(addr, size, real_pagesize, VMEM_SHMATED);
2037   assert0(is_aligned_to(addr, os::vm_page_size()));
2038 
2039   return addr;
2040 }
2041 
2042 static bool release_shmated_memory(char* addr, size_t size) {
2043 
2044   trcVerbose(&quot;release_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2045     addr, addr + size - 1);</span>
2046 
2047   bool rc = false;
2048 
2049   // TODO: is there a way to verify shm size without doing bookkeeping?
2050   if (::shmdt(addr) != 0) {
2051     trcVerbose(&quot;error (%d).&quot;, errno);
2052   } else {
2053     trcVerbose(&quot;ok.&quot;);
2054     rc = true;
2055   }
2056   return rc;
2057 }
2058 
2059 static bool uncommit_shmated_memory(char* addr, size_t size) {
2060   trcVerbose(&quot;uncommit_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2061     addr, addr + size - 1);</span>
2062 
2063   const bool rc = my_disclaim64(addr, size);
2064 
2065   if (!rc) {
<span class="line-modified">2066     trcVerbose(&quot;my_disclaim64(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;) failed.\n&quot;, addr, size);</span>
2067     return false;
2068   }
2069   return true;
2070 }
2071 
2072 ////////////////////////////////  mmap-based routines /////////////////////////////////
2073 
2074 // Reserve memory via mmap.
2075 // If &lt;requested_addr&gt; is given, an attempt is made to attach at the given address.
2076 // Failing that, memory is allocated at any address.
2077 // If &lt;alignment_hint&gt; is given and &lt;requested_addr&gt; is NULL, an attempt is made to
2078 // allocate at an address aligned with the given alignment. Failing that, memory
2079 // is aligned anywhere.
2080 static char* reserve_mmaped_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2081   trcVerbose(&quot;reserve_mmaped_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot; PTR_FORMAT &quot;, &quot;
2082     &quot;alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="line-modified">2083     bytes, requested_addr, alignment_hint);</span>
2084 
2085   // If a wish address is given, but not aligned to 4K page boundary, mmap will fail.
2086   if (requested_addr &amp;&amp; !is_aligned_to(requested_addr, os::vm_page_size()) != 0) {
<span class="line-modified">2087     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; not aligned to page boundary.&quot;, requested_addr);</span>
2088     return NULL;
2089   }
2090 
2091   // We must prevent anyone from attaching too close to the
2092   // BRK because that may cause malloc OOM.
2093   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
2094     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="line-modified">2095       &quot;Will attach anywhere.&quot;, requested_addr);</span>
2096     // Act like the OS refused to attach there.
2097     requested_addr = NULL;
2098   }
2099 
2100   // Specify one or the other but not both.
2101   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint &gt; 0));
2102 
2103   // In 64K mode, we claim the global page size (os::vm_page_size())
2104   // is 64K. This is one of the few points where that illusion may
2105   // break, because mmap() will always return memory aligned to 4K. So
2106   // we must ensure we only ever return memory aligned to 64k.
2107   if (alignment_hint) {
2108     alignment_hint = lcm(alignment_hint, os::vm_page_size());
2109   } else {
2110     alignment_hint = os::vm_page_size();
2111   }
2112 
2113   // Size shall always be a multiple of os::vm_page_size (esp. in 64K mode).
2114   const size_t size = align_up(bytes, os::vm_page_size());
2115 
</pre>
<hr />
<pre>
2122   // later use msync(MS_INVALIDATE) (see os::uncommit_memory).
2123   int flags = MAP_ANONYMOUS | MAP_SHARED;
2124 
2125   // MAP_FIXED is needed to enforce requested_addr - manpage is vague about what
2126   // it means if wishaddress is given but MAP_FIXED is not set.
2127   //
2128   // Important! Behaviour differs depending on whether SPEC1170 mode is active or not.
2129   // SPEC1170 mode active: behaviour like POSIX, MAP_FIXED will clobber existing mappings.
2130   // SPEC1170 mode not active: behaviour, unlike POSIX, is that no existing mappings will
2131   // get clobbered.
2132   if (requested_addr != NULL) {
2133     if (!os::Aix::xpg_sus_mode()) {  // not SPEC1170 Behaviour
2134       flags |= MAP_FIXED;
2135     }
2136   }
2137 
2138   char* addr = (char*)::mmap(requested_addr, extra_size,
2139       PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);
2140 
2141   if (addr == MAP_FAILED) {
<span class="line-modified">2142     trcVerbose(&quot;mmap(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;, ..) failed (%d)&quot;, requested_addr, size, errno);</span>
2143     return NULL;
2144   }
2145 
2146   // Handle alignment.
2147   char* const addr_aligned = align_up(addr, alignment_hint);
2148   const size_t waste_pre = addr_aligned - addr;
2149   char* const addr_aligned_end = addr_aligned + size;
2150   const size_t waste_post = extra_size - waste_pre - size;
2151   if (waste_pre &gt; 0) {
2152     ::munmap(addr, waste_pre);
2153   }
2154   if (waste_post &gt; 0) {
2155     ::munmap(addr_aligned_end, waste_post);
2156   }
2157   addr = addr_aligned;
2158 
2159   if (addr) {
2160     trcVerbose(&quot;mmap-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes)&quot;,
<span class="line-modified">2161       addr, addr + bytes, bytes);</span>
2162   } else {
2163     if (requested_addr != NULL) {
<span class="line-modified">2164       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at wish address &quot; PTR_FORMAT &quot;.&quot;, bytes, requested_addr);</span>
2165     } else {
2166       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, bytes);
2167     }
2168   }
2169 
2170   // bookkeeping
2171   vmembk_add(addr, size, 4*K, VMEM_MAPPED);
2172 
2173   // Test alignment, see above.
2174   assert0(is_aligned_to(addr, os::vm_page_size()));
2175 
2176   return addr;
2177 }
2178 
2179 static bool release_mmaped_memory(char* addr, size_t size) {
2180   assert0(is_aligned_to(addr, os::vm_page_size()));
2181   assert0(is_aligned_to(size, os::vm_page_size()));
2182 
2183   trcVerbose(&quot;release_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2184     addr, addr + size - 1);</span>
2185   bool rc = false;
2186 
2187   if (::munmap(addr, size) != 0) {
2188     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2189     rc = false;
2190   } else {
2191     trcVerbose(&quot;ok.&quot;);
2192     rc = true;
2193   }
2194 
2195   return rc;
2196 }
2197 
2198 static bool uncommit_mmaped_memory(char* addr, size_t size) {
2199 
2200   assert0(is_aligned_to(addr, os::vm_page_size()));
2201   assert0(is_aligned_to(size, os::vm_page_size()));
2202 
2203   trcVerbose(&quot;uncommit_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2204     addr, addr + size - 1);</span>
2205   bool rc = false;
2206 
2207   // Uncommit mmap memory with msync MS_INVALIDATE.
2208   if (::msync(addr, size, MS_INVALIDATE) != 0) {
2209     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2210     rc = false;
2211   } else {
2212     trcVerbose(&quot;ok.&quot;);
2213     rc = true;
2214   }
2215 
2216   return rc;
2217 }
2218 
2219 int os::vm_page_size() {
2220   // Seems redundant as all get out.
2221   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2222   return os::Aix::page_size();
2223 }
2224 
2225 // Aix allocates memory by pages.
2226 int os::vm_allocation_granularity() {
2227   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2228   return os::Aix::page_size();
2229 }
2230 
2231 #ifdef PRODUCT
2232 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
2233                                     int err) {
2234   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
<span class="line-modified">2235           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, size, exec,</span>
2236           os::errno_name(err), err);
2237 }
2238 #endif
2239 
2240 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
2241                                   const char* mesg) {
2242   assert(mesg != NULL, &quot;mesg must be specified&quot;);
2243   if (!pd_commit_memory(addr, size, exec)) {
2244     // Add extra info in product mode for vm_exit_out_of_memory():
2245     PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)
2246     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
2247   }
2248 }
2249 
2250 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
2251 
2252   assert(is_aligned_to(addr, os::vm_page_size()),
2253     &quot;addr &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2254     p2i(addr), os::vm_page_size());
2255   assert(is_aligned_to(size, os::vm_page_size()),
2256     &quot;size &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2257     size, os::vm_page_size());
2258 
2259   vmembk_t* const vmi = vmembk_find(addr);
2260   guarantee0(vmi);
2261   vmi-&gt;assert_is_valid_subrange(addr, size);
2262 
<span class="line-modified">2263   trcVerbose(&quot;commit_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;, addr, addr + size - 1);</span>
2264 
2265   if (UseExplicitCommit) {
2266     // AIX commits memory on touch. So, touch all pages to be committed.
2267     for (char* p = addr; p &lt; (addr + size); p += 4*K) {
2268       *p = &#39;\0&#39;;
2269     }
2270   }
2271 
2272   return true;
2273 }
2274 
2275 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint, bool exec) {
2276   return pd_commit_memory(addr, size, exec);
2277 }
2278 
2279 void os::pd_commit_memory_or_exit(char* addr, size_t size,
2280                                   size_t alignment_hint, bool exec,
2281                                   const char* mesg) {
2282   // Alignment_hint is ignored on this OS.
2283   pd_commit_memory_or_exit(addr, size, exec, mesg);
</pre>
<hr />
<pre>
2330 bool os::numa_topology_changed() {
2331   return false;
2332 }
2333 
2334 size_t os::numa_get_groups_num() {
2335   return 1;
2336 }
2337 
2338 int os::numa_get_group_id() {
2339   return 0;
2340 }
2341 
2342 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
2343   if (size &gt; 0) {
2344     ids[0] = 0;
2345     return 1;
2346   }
2347   return 0;
2348 }
2349 




2350 bool os::get_page_info(char *start, page_info* info) {
2351   return false;
2352 }
2353 
2354 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
2355   return end;
2356 }
2357 
2358 // Reserves and attaches a shared memory segment.
2359 // Will assert if a wish address is given and could not be obtained.
2360 char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2361 
2362   // All other Unices do a mmap(MAP_FIXED) if the addr is given,
2363   // thereby clobbering old mappings at that place. That is probably
2364   // not intended, never used and almost certainly an error were it
2365   // ever be used this way (to try attaching at a specified address
2366   // without clobbering old mappings an alternate API exists,
2367   // os::attempt_reserve_memory_at()).
2368   // Instead of mimicking the dangerous coding of the other platforms, here I
2369   // just ignore the request address (release) or assert(debug).
</pre>
<hr />
<pre>
2422   }
2423 
2424   // update bookkeeping
2425   if (rc &amp;&amp; remove_bookkeeping) {
2426     vmembk_remove(vmi);
2427   }
2428 
2429   return rc;
2430 }
2431 
2432 static bool checked_mprotect(char* addr, size_t size, int prot) {
2433 
2434   // Little problem here: if SPEC1170 behaviour is off, mprotect() on AIX will
2435   // not tell me if protection failed when trying to protect an un-protectable range.
2436   //
2437   // This means if the memory was allocated using shmget/shmat, protection wont work
2438   // but mprotect will still return 0:
2439   //
2440   // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm
2441 

2442   bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;
2443 
2444   if (!rc) {
2445     const char* const s_errno = os::errno_name(errno);
2446     warning(&quot;mprotect(&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;, 0x%X) failed (%s).&quot;, addr, addr + size, prot, s_errno);
2447     return false;
2448   }
2449 
2450   // mprotect success check
2451   //
2452   // Mprotect said it changed the protection but can I believe it?
2453   //
2454   // To be sure I need to check the protection afterwards. Try to
2455   // read from protected memory and check whether that causes a segfault.
2456   //
2457   if (!os::Aix::xpg_sus_mode()) {
2458 
2459     if (CanUseSafeFetch32()) {
2460 
2461       const bool read_protected =
2462         (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2463          SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2464 
2465       if (prot &amp; PROT_READ) {
2466         rc = !read_protected;
2467       } else {
2468         rc = read_protected;
2469       }
2470 
2471       if (!rc) {
2472         if (os::Aix::on_pase()) {
2473           // There is an issue on older PASE systems where mprotect() will return success but the
2474           // memory will not be protected.
2475           // This has nothing to do with the problem of using mproect() on SPEC1170 incompatible
2476           // machines; we only see it rarely, when using mprotect() to protect the guard page of
2477           // a stack. It is an OS error.
2478           //
2479           // A valid strategy is just to try again. This usually works. :-/
2480 
2481           ::usleep(1000);

2482           if (::mprotect(addr, size, prot) == 0) {
2483             const bool read_protected_2 =
2484               (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2485               SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2486             rc = true;
2487           }
2488         }
2489       }
2490     }
2491   }
2492 
2493   assert(rc == true, &quot;mprotect failed.&quot;);
2494 
2495   return rc;
2496 }
2497 
2498 // Set protections specified
2499 bool os::protect_memory(char* addr, size_t size, ProtType prot, bool is_committed) {
2500   unsigned int p = 0;
2501   switch (prot) {
</pre>
<hr />
<pre>
2628 int os::java_to_os_priority[CriticalPriority + 1] = {
2629   54,             // 0 Entry should never be used
2630 
2631   55,             // 1 MinPriority
2632   55,             // 2
2633   56,             // 3
2634 
2635   56,             // 4
2636   57,             // 5 NormPriority
2637   57,             // 6
2638 
2639   58,             // 7
2640   58,             // 8
2641   59,             // 9 NearMaxPriority
2642 
2643   60,             // 10 MaxPriority
2644 
2645   60              // 11 CriticalPriority
2646 };
2647 
















2648 OSReturn os::set_native_priority(Thread* thread, int newpri) {
<span class="line-modified">2649   if (!UseThreadPriorities) return OS_OK;</span>
2650   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2651   int policy = SCHED_OTHER;
2652   struct sched_param param;
2653   param.sched_priority = newpri;
2654   int ret = pthread_setschedparam(thr, policy, &amp;param);
2655 
2656   if (ret != 0) {
2657     trcVerbose(&quot;Could not change priority for thread %d to %d (error %d, %s)&quot;,
2658         (int)thr, newpri, ret, os::errno_name(ret));
2659   }
2660   return (ret == 0) ? OS_OK : OS_ERR;
2661 }
2662 
2663 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
<span class="line-modified">2664   if (!UseThreadPriorities) {</span>
2665     *priority_ptr = java_to_os_priority[NormPriority];
2666     return OS_OK;
2667   }
2668   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2669   int policy = SCHED_OTHER;
2670   struct sched_param param;
2671   int ret = pthread_getschedparam(thr, &amp;policy, &amp;param);
2672   *priority_ptr = param.sched_priority;
2673 
2674   return (ret == 0) ? OS_OK : OS_ERR;
2675 }
2676 
2677 ////////////////////////////////////////////////////////////////////////////////
2678 // suspend/resume support
2679 
2680 //  The low-level signal-based suspend/resume support is a remnant from the
2681 //  old VM-suspension that used to be for java-suspension, safepoints etc,
2682 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2683 //
2684 //  The remaining code is greatly simplified from the more general suspension
</pre>
<hr />
<pre>
2741   // has not already terminated (via SR_lock()) - else the following assertion
2742   // will fail because the thread is no longer a JavaThread as the ~JavaThread
2743   // destructor has completed.
2744 
2745   if (thread-&gt;SR_lock() == NULL) {
2746     return;
2747   }
2748 
2749   assert(thread-&gt;is_VM_thread() || thread-&gt;is_Java_thread(), &quot;Must be VMThread or JavaThread&quot;);
2750 
2751   OSThread* osthread = thread-&gt;osthread();
2752 
2753   os::SuspendResume::State current = osthread-&gt;sr.state();
2754   if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {
2755     suspend_save_context(osthread, siginfo, context);
2756 
2757     // attempt to switch the state, we assume we had a SUSPEND_REQUEST
2758     os::SuspendResume::State state = osthread-&gt;sr.suspended();
2759     if (state == os::SuspendResume::SR_SUSPENDED) {
2760       sigset_t suspend_set;  // signals for sigsuspend()
<span class="line-modified">2761 </span>
2762       // get current set of blocked signals and unblock resume signal
2763       pthread_sigmask(SIG_BLOCK, NULL, &amp;suspend_set);
2764       sigdelset(&amp;suspend_set, SR_signum);
2765 
2766       // wait here until we are resumed
2767       while (1) {
2768         sigsuspend(&amp;suspend_set);
2769 
2770         os::SuspendResume::State result = osthread-&gt;sr.running();
2771         if (result == os::SuspendResume::SR_RUNNING) {
2772           break;
2773         }
2774       }
2775 
2776     } else if (state == os::SuspendResume::SR_RUNNING) {
2777       // request was cancelled, continue
2778     } else {
2779       ShouldNotReachHere();
2780     }
2781 
</pre>
<hr />
<pre>
3027       // automaticlly block the signal
3028       sigaddset(&amp;(actp-&gt;sa_mask), sig);
3029     }
3030 
3031     sa_handler_t hand = NULL;
3032     sa_sigaction_t sa = NULL;
3033     bool siginfo_flag_set = (actp-&gt;sa_flags &amp; SA_SIGINFO) != 0;
3034     // retrieve the chained handler
3035     if (siginfo_flag_set) {
3036       sa = actp-&gt;sa_sigaction;
3037     } else {
3038       hand = actp-&gt;sa_handler;
3039     }
3040 
3041     if ((actp-&gt;sa_flags &amp; SA_RESETHAND) != 0) {
3042       actp-&gt;sa_handler = SIG_DFL;
3043     }
3044 
3045     // try to honor the signal mask
3046     sigset_t oset;

3047     pthread_sigmask(SIG_SETMASK, &amp;(actp-&gt;sa_mask), &amp;oset);
3048 
3049     // call into the chained handler
3050     if (siginfo_flag_set) {
3051       (*sa)(sig, siginfo, context);
3052     } else {
3053       (*hand)(sig);
3054     }
3055 
3056     // restore the signal mask
<span class="line-modified">3057     pthread_sigmask(SIG_SETMASK, &amp;oset, 0);</span>
3058   }
3059   // Tell jvm&#39;s signal handler the signal is taken care of.
3060   return true;
3061 }
3062 
3063 bool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {
3064   bool chained = false;
3065   // signal-chaining
3066   if (UseSignalChaining) {
3067     struct sigaction *actp = get_chained_signal_action(sig);
3068     if (actp != NULL) {
3069       chained = call_chained_handler(actp, sig, siginfo, context);
3070     }
3071   }
3072   return chained;
3073 }
3074 
3075 // for diagnostic
3076 int sigflags[NSIG];
3077 
</pre>
<hr />
<pre>
3427       // with datapsize=64K (like, any other launcher but our own).
3428       //
3429       // In this case it would be smart to allocate the java heap with 64K
3430       // to get the performance benefit, and to fake 64k pages for the
3431       // data segment (when dealing with thread stacks).
3432       //
3433       // However, leave a possibility to downgrade to 4K, using
3434       // -XX:-Use64KPages.
3435       if (Use64KPages) {
3436         trcVerbose(&quot;64K page mode (faked for data segment)&quot;);
3437         Aix::_page_size = 64*K;
3438       } else {
3439         trcVerbose(&quot;4K page mode (Use64KPages=off)&quot;);
3440         Aix::_page_size = 4*K;
3441       }
3442     } else {
3443       // .. and not able to allocate 64k pages dynamically. Here, just
3444       // fall back to 4K paged mode and use mmap for everything.
3445       trcVerbose(&quot;4K page mode&quot;);
3446       Aix::_page_size = 4*K;
<span class="line-modified">3447       FLAG_SET_ERGO(bool, Use64KPages, false);</span>
3448     }
3449   } else {
3450     // datapsize = 64k. Data segment, thread stacks are 64k paged.
3451     // This normally means that we can allocate 64k pages dynamically.
3452     // (There is one special case where this may be false: EXTSHM=on.
3453     // but we decided to not support that mode).
3454     assert0(g_multipage_support.can_use_64K_pages);
3455     Aix::_page_size = 64*K;
3456     trcVerbose(&quot;64K page mode&quot;);
<span class="line-modified">3457     FLAG_SET_ERGO(bool, Use64KPages, true);</span>
3458   }
3459 
3460   // For now UseLargePages is just ignored.
<span class="line-modified">3461   FLAG_SET_ERGO(bool, UseLargePages, false);</span>
3462   _page_sizes[0] = 0;
3463 
3464   // debug trace
3465   trcVerbose(&quot;os::vm_page_size %s&quot;, describe_pagesize(os::vm_page_size()));
3466 
3467   // Next, we need to initialize libo4 and libperfstat libraries.
3468   if (os::Aix::on_pase()) {
3469     os::Aix::initialize_libo4();
3470   } else {
3471     os::Aix::initialize_libperfstat();
3472   }
3473 
3474   // Reset the perfstat information provided by ODM.
3475   if (os::Aix::on_aix()) {
3476     libperfstat::perfstat_reset();
3477   }
3478 
3479   // Now initialze basic system properties. Note that for some of the values we
3480   // need libperfstat etc.
3481   os::Aix::initialize_system_info();
3482 
3483   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
3484 
3485   init_random(1234567);
3486 
3487   // _main_thread points to the thread that created/loaded the JVM.
3488   Aix::_main_thread = pthread_self();
3489 
<span class="line-modified">3490   initial_time_count = os::elapsed_counter();</span>
3491 
3492   os::Posix::init();
3493 }
3494 
3495 // This is called _after_ the global arguments have been parsed.
3496 jint os::init_2(void) {
3497 
3498   // This could be set after os::Posix::init() but all platforms
3499   // have to set it the same so we have to mirror Solaris.
3500   DEBUG_ONLY(os::set_mutex_init_done();)
3501 
3502   os::Posix::init_2();
3503 
3504   if (os::Aix::on_pase()) {
3505     trcVerbose(&quot;Running on PASE.&quot;);
3506   } else {
3507     trcVerbose(&quot;Running on AIX (not PASE).&quot;);
3508   }
3509 
3510   trcVerbose(&quot;processor count: %d&quot;, os::_processor_count);
</pre>
<hr />
<pre>
3553       if (status != 0) {
3554         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
3555       }
3556     }
3557   }
3558 
3559   if (PerfAllowAtExitRegistration) {
3560     // Only register atexit functions if PerfAllowAtExitRegistration is set.
3561     // At exit functions can be delayed until process exit time, which
3562     // can be problematic for embedded VM situations. Embedded VMs should
3563     // call DestroyJavaVM() to assure that VM resources are released.
3564 
3565     // Note: perfMemory_exit_helper atexit function may be removed in
3566     // the future if the appropriate cleanup code can be added to the
3567     // VM_Exit VMOperation&#39;s doit method.
3568     if (atexit(perfMemory_exit_helper) != 0) {
3569       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
3570     }
3571   }
3572 



3573   return JNI_OK;
3574 }
3575 
3576 // Mark the polling page as unreadable
3577 void os::make_polling_page_unreadable(void) {
3578   if (!guard_memory((char*)_polling_page, Aix::page_size())) {
3579     fatal(&quot;Could not disable polling page&quot;);
3580   }
3581 };
3582 
3583 // Mark the polling page as readable
3584 void os::make_polling_page_readable(void) {
3585   // Changed according to os_linux.cpp.
3586   if (!checked_mprotect((char *)_polling_page, Aix::page_size(), PROT_READ)) {
3587     fatal(&quot;Could not enable polling page at &quot; PTR_FORMAT, _polling_page);
3588   }
3589 };
3590 
3591 int os::active_processor_count() {
3592   // User has overridden the number of active processors
3593   if (ActiveProcessorCount &gt; 0) {
3594     log_trace(os)(&quot;active_processor_count: &quot;
3595                   &quot;active processor count set by user : %d&quot;,
3596                   ActiveProcessorCount);
3597     return ActiveProcessorCount;
3598   }
3599 
3600   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
3601   assert(online_cpus &gt; 0 &amp;&amp; online_cpus &lt;= processor_count(), &quot;sanity check&quot;);
3602   return online_cpus;
3603 }
3604 
3605 void os::set_native_thread_name(const char *name) {
3606   // Not yet implemented.
3607   return;
3608 }
3609 
<span class="line-removed">3610 bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="line-removed">3611   // Not yet implemented.</span>
<span class="line-removed">3612   return false;</span>
<span class="line-removed">3613 }</span>
<span class="line-removed">3614 </span>
3615 bool os::bind_to_processor(uint processor_id) {
3616   // Not yet implemented.
3617   return false;
3618 }
3619 
3620 void os::SuspendedThreadTask::internal_do_task() {
3621   if (do_suspend(_thread-&gt;osthread())) {
3622     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3623     do_task(context);
3624     do_resume(_thread-&gt;osthread());
3625   }
3626 }
3627 
3628 ////////////////////////////////////////////////////////////////////////////////
3629 // debug support
3630 
3631 bool os::find(address addr, outputStream* st) {
3632 
3633   st-&gt;print(PTR_FORMAT &quot;: &quot;, addr);
3634 
</pre>
<hr />
<pre>
3687   /* Scan the directory */
3688   bool result = true;
3689   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
3690     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
3691       result = false;
3692     }
3693   }
3694   closedir(dir);
3695   return result;
3696 }
3697 
3698 // This code originates from JDK&#39;s sysOpen and open64_w
3699 // from src/solaris/hpi/src/system_md.c
3700 
3701 int os::open(const char *path, int oflag, int mode) {
3702 
3703   if (strlen(path) &gt; MAX_PATH - 1) {
3704     errno = ENAMETOOLONG;
3705     return -1;
3706   }
<span class="line-modified">3707   int fd;</span>


3708 
<span class="line-modified">3709   fd = ::open64(path, oflag, mode);</span>
<span class="line-modified">3710   if (fd == -1) return -1;</span>






3711 
3712   // If the open succeeded, the file might still be a directory.
3713   {
3714     struct stat64 buf64;
3715     int ret = ::fstat64(fd, &amp;buf64);
3716     int st_mode = buf64.st_mode;
3717 
3718     if (ret != -1) {
3719       if ((st_mode &amp; S_IFMT) == S_IFDIR) {
3720         errno = EISDIR;
3721         ::close(fd);
3722         return -1;
3723       }
3724     } else {
3725       ::close(fd);
3726       return -1;
3727     }
3728   }
3729 
3730   // All file descriptors that are opened in the JVM and not
3731   // specifically destined for a subprocess should have the
3732   // close-on-exec flag set. If we don&#39;t set it, then careless 3rd
3733   // party native code might fork and exec without closing all
3734   // appropriate file descriptors (e.g. as we do in closeDescriptors in
3735   // UNIXProcess.c), and this in turn might:
3736   //
3737   // - cause end-of-file to fail to be detected on some file
3738   //   descriptors, resulting in mysterious hangs, or
3739   //
3740   // - might cause an fopen in the subprocess to fail on a system
3741   //   suffering from bug 1085341.
<span class="line-modified">3742   //</span>
<span class="line-modified">3743   // (Yes, the default setting of the close-on-exec flag is a Unix</span>
<span class="line-modified">3744   // design flaw.)</span>
<span class="line-modified">3745   //</span>
<span class="line-modified">3746   // See:</span>
<span class="line-modified">3747   // 1085341: 32-bit stdio routines should support file descriptors &gt;255</span>
<span class="line-modified">3748   // 4843136: (process) pipe file descriptor from Runtime.exec not being closed</span>
<span class="line-modified">3749   // 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9</span>
<span class="line-modified">3750 #ifdef FD_CLOEXEC</span>
<span class="line-modified">3751   {</span>




3752     int flags = ::fcntl(fd, F_GETFD);
<span class="line-modified">3753     if (flags != -1)</span>
3754       ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);

3755   }
<span class="line-removed">3756 #endif</span>
3757 
3758   return fd;
3759 }
3760 
3761 // create binary file, rewriting existing file if required
3762 int os::create_binary_file(const char* path, bool rewrite_existing) {
3763   int oflags = O_WRONLY | O_CREAT;
3764   if (!rewrite_existing) {
3765     oflags |= O_EXCL;
3766   }
3767   return ::open64(path, oflags, S_IREAD | S_IWRITE);
3768 }
3769 
3770 // return current position of file pointer
3771 jlong os::current_file_offset(int fd) {
3772   return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
3773 }
3774 
3775 // move file pointer to the specified offset
3776 jlong os::seek_to_file_offset(int fd, jlong offset) {
</pre>
<hr />
<pre>
3994     }
3995 
3996   } else {
3997 
3998     // AIX: use libperfstat
3999     libperfstat::cpuinfo_t ci;
4000     if (libperfstat::get_cpuinfo(&amp;ci)) {
4001       for (int i = 0; i &lt; nelem; i++) {
4002         values[i] = ci.loadavg[i];
4003       }
4004     } else {
4005       return -1;
4006     }
4007     return nelem;
4008   }
4009 }
4010 
4011 void os::pause() {
4012   char filename[MAX_PATH];
4013   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">4014     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
4015   } else {
4016     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4017   }
4018 
4019   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4020   if (fd != -1) {
4021     struct stat buf;
4022     ::close(fd);
4023     while (::stat(filename, &amp;buf) == 0) {
4024       (void)::poll(NULL, 0, 100);
4025     }
4026   } else {
4027     trcVerbose(&quot;Could not open pause file &#39;%s&#39;, continuing immediately.&quot;, filename);
4028   }
4029 }
4030 
4031 bool os::is_primordial_thread(void) {
4032   if (pthread_self() == (pthread_t)1) {
4033     return true;
4034   } else {
</pre>
<hr />
<pre>
4041 void os::Aix::initialize_os_info() {
4042 
4043   assert(_on_pase == -1 &amp;&amp; _os_version == 0, &quot;already called.&quot;);
4044 
4045   struct utsname uts;
4046   memset(&amp;uts, 0, sizeof(uts));
4047   strcpy(uts.sysname, &quot;?&quot;);
4048   if (::uname(&amp;uts) == -1) {
4049     trcVerbose(&quot;uname failed (%d)&quot;, errno);
4050     guarantee(0, &quot;Could not determine whether we run on AIX or PASE&quot;);
4051   } else {
4052     trcVerbose(&quot;uname says: sysname \&quot;%s\&quot; version \&quot;%s\&quot; release \&quot;%s\&quot; &quot;
4053                &quot;node \&quot;%s\&quot; machine \&quot;%s\&quot;\n&quot;,
4054                uts.sysname, uts.version, uts.release, uts.nodename, uts.machine);
4055     const int major = atoi(uts.version);
4056     assert(major &gt; 0, &quot;invalid OS version&quot;);
4057     const int minor = atoi(uts.release);
4058     assert(minor &gt; 0, &quot;invalid OS release&quot;);
4059     _os_version = (major &lt;&lt; 24) | (minor &lt;&lt; 16);
4060     char ver_str[20] = {0};
<span class="line-modified">4061     char *name_str = &quot;unknown OS&quot;;</span>
4062     if (strcmp(uts.sysname, &quot;OS400&quot;) == 0) {
4063       // We run on AS/400 PASE. We do not support versions older than V5R4M0.
4064       _on_pase = 1;
4065       if (os_version_short() &lt; 0x0504) {
4066         trcVerbose(&quot;OS/400 releases older than V5R4M0 not supported.&quot;);
4067         assert(false, &quot;OS/400 release too old.&quot;);
4068       }
4069       name_str = &quot;OS/400 (pase)&quot;;
4070       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u&quot;, major, minor);
4071     } else if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
<span class="line-modified">4072       // We run on AIX. We do not support versions older than AIX 5.3.</span>
4073       _on_pase = 0;
4074       // Determine detailed AIX version: Version, Release, Modification, Fix Level.
4075       odmWrapper::determine_os_kernel_version(&amp;_os_version);
<span class="line-modified">4076       if (os_version_short() &lt; 0x0503) {</span>
<span class="line-modified">4077         trcVerbose(&quot;AIX release older than AIX 5.3 not supported.&quot;);</span>
4078         assert(false, &quot;AIX release too old.&quot;);
4079       }
4080       name_str = &quot;AIX&quot;;
4081       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u.%u.%u&quot;,
4082                    major, minor, (_os_version &gt;&gt; 8) &amp; 0xFF, _os_version &amp; 0xFF);
4083     } else {
<span class="line-modified">4084       assert(false, name_str);</span>
4085     }
4086     trcVerbose(&quot;We run on %s %s&quot;, name_str, ver_str);
4087   }
4088 
4089   guarantee(_on_pase != -1 &amp;&amp; _os_version, &quot;Could not determine AIX/OS400 release&quot;);
4090 } // end: os::Aix::initialize_os_info()
4091 
4092 // Scan environment for important settings which might effect the VM.
4093 // Trace out settings. Warn about invalid settings and/or correct them.
4094 //
4095 // Must run after os::Aix::initialue_os_info().
4096 void os::Aix::scan_environment() {
4097 
4098   char* p;
4099   int rc;
4100 
4101   // Warn explicity if EXTSHM=ON is used. That switch changes how
4102   // System V shared memory behaves. One effect is that page size of
4103   // shared memory cannot be change dynamically, effectivly preventing
4104   // large pages from working.
</pre>
<hr />
<pre>
4200   AixMisc::stackbounds_t bounds;
4201   bool rc = AixMisc::query_stack_bounds_for_current_thread(&amp;bounds);
4202   guarantee(rc, &quot;Unable to retrieve stack bounds.&quot;);
4203   // Align the returned stack size such that the stack low address
4204   // is aligned to page size (Note: base is usually not and we do not care).
4205   // We need to do this because caller code will assume stack low address is
4206   // page aligned and will place guard pages without checking.
4207   address low = bounds.base - bounds.size;
4208   address low_aligned = (address)align_up(low, os::vm_page_size());
4209   size_t s = bounds.base - low_aligned;
4210   return s;
4211 }
4212 
4213 extern char** environ;
4214 
4215 // Run the specified command in a separate process. Return its exit value,
4216 // or -1 on failure (e.g. can&#39;t fork a new process).
4217 // Unlike system(), this function can be called from signal handler. It
4218 // doesn&#39;t block SIGINT et al.
4219 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
<span class="line-modified">4220   char * argv[4] = {&quot;sh&quot;, &quot;-c&quot;, cmd, NULL};</span>
4221 
4222   pid_t pid = fork();
4223 
4224   if (pid &lt; 0) {
4225     // fork failed
4226     return -1;
4227 
4228   } else if (pid == 0) {
4229     // child process
4230 
4231     // Try to be consistent with system(), which uses &quot;/usr/bin/sh&quot; on AIX.
4232     execve(&quot;/usr/bin/sh&quot;, argv, environ);
4233 
4234     // execve failed
4235     _exit(-1);
4236 
4237   } else {
4238     // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don&#39;t
4239     // care about the actual exit code, for now.
4240 
</pre>
<hr />
<pre>
4310     jio_snprintf(buf, buflen, &quot;dbx -a %d&quot;, os::current_process_id());
4311 
4312     os::fork_and_exec(buf);
4313     yes = false;
4314   }
4315   return yes;
4316 }
4317 
4318 static inline time_t get_mtime(const char* filename) {
4319   struct stat st;
4320   int ret = os::stat(filename, &amp;st);
4321   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
4322   return st.st_mtime;
4323 }
4324 
4325 int os::compare_file_modified_times(const char* file1, const char* file2) {
4326   time_t t1 = get_mtime(file1);
4327   time_t t2 = get_mtime(file2);
4328   return t1 - t2;
4329 }




</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 // According to the AIX OS doc #pragma alloca must be used
  27 // with C++ compiler before referencing the function alloca()
  28 #pragma alloca
  29 
  30 // no precompiled headers
  31 #include &quot;jvm.h&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/systemDictionary.hpp&quot;
  34 #include &quot;classfile/vmSymbols.hpp&quot;
  35 #include &quot;code/icBuffer.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
<span class="line-added">  40 #include &quot;logging/logStream.hpp&quot;</span>
  41 #include &quot;libo4.hpp&quot;
  42 #include &quot;libperfstat_aix.hpp&quot;
  43 #include &quot;libodm_aix.hpp&quot;
  44 #include &quot;loadlib_aix.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;misc_aix.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;os_aix.inline.hpp&quot;
  50 #include &quot;os_share_aix.hpp&quot;
  51 #include &quot;porting_aix.hpp&quot;
  52 #include &quot;prims/jniFastGetField.hpp&quot;
  53 #include &quot;prims/jvm_misc.hpp&quot;
  54 #include &quot;runtime/arguments.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/extendedPC.hpp&quot;
  57 #include &quot;runtime/globals.hpp&quot;
  58 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  59 #include &quot;runtime/java.hpp&quot;
  60 #include &quot;runtime/javaCalls.hpp&quot;
  61 #include &quot;runtime/mutexLocker.hpp&quot;
  62 #include &quot;runtime/objectMonitor.hpp&quot;

  63 #include &quot;runtime/os.hpp&quot;
  64 #include &quot;runtime/osThread.hpp&quot;
  65 #include &quot;runtime/perfMemory.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/statSampler.hpp&quot;
  68 #include &quot;runtime/stubRoutines.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/threadCritical.hpp&quot;
  71 #include &quot;runtime/timer.hpp&quot;
  72 #include &quot;runtime/vm_version.hpp&quot;
  73 #include &quot;services/attachListener.hpp&quot;
  74 #include &quot;services/runtimeService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/decoder.hpp&quot;
  77 #include &quot;utilities/defaultStream.hpp&quot;
  78 #include &quot;utilities/events.hpp&quot;
  79 #include &quot;utilities/growableArray.hpp&quot;
  80 #include &quot;utilities/vmError.hpp&quot;
  81 
  82 // put OS-includes here (sorted alphabetically)
</pre>
<hr />
<pre>
 114 extern &quot;C&quot;
 115 int mread_real_time(timebasestruct_t *t, size_t size_of_timebasestruct_t);
 116 
 117 #if !defined(_AIXVERSION_610)
 118 extern &quot;C&quot; int getthrds64(pid_t, struct thrdentry64*, int, tid64_t*, int);
 119 extern &quot;C&quot; int getprocs64(procentry64*, int, fdsinfo*, int, pid_t*, int);
 120 extern &quot;C&quot; int getargs(procsinfo*, int, char*, int);
 121 #endif
 122 
 123 #define MAX_PATH (2 * K)
 124 
 125 // for timer info max values which include all bits
 126 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 127 // for multipage initialization error analysis (in &#39;g_multipage_error&#39;)
 128 #define ERROR_MP_OS_TOO_OLD                          100
 129 #define ERROR_MP_EXTSHM_ACTIVE                       101
 130 #define ERROR_MP_VMGETINFO_FAILED                    102
 131 #define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103
 132 
 133 // excerpts from systemcfg.h that might be missing on older os levels












 134 #ifndef PV_7
 135   #define PV_7 0x200000          /* Power PC 7 */
 136 #endif
 137 #ifndef PV_7_Compat
 138   #define PV_7_Compat 0x208000   /* Power PC 7 */
 139 #endif
 140 #ifndef PV_8
 141   #define PV_8 0x300000          /* Power PC 8 */
 142 #endif
 143 #ifndef PV_8_Compat
 144   #define PV_8_Compat 0x308000   /* Power PC 8 */
 145 #endif
<span class="line-added"> 146 #ifndef PV_9</span>
<span class="line-added"> 147   #define PV_9 0x400000          /* Power PC 9 */</span>
<span class="line-added"> 148 #endif</span>
<span class="line-added"> 149 #ifndef PV_9_Compat</span>
<span class="line-added"> 150   #define PV_9_Compat  0x408000  /* Power PC 9 */</span>
<span class="line-added"> 151 #endif</span>
<span class="line-added"> 152 </span>
 153 
 154 static address resolve_function_descriptor_to_code_pointer(address p);
 155 
 156 static void vmembk_print_on(outputStream* os);
 157 
 158 ////////////////////////////////////////////////////////////////////////////////
 159 // global variables (for a description see os_aix.hpp)
 160 
 161 julong    os::Aix::_physical_memory = 0;
 162 
 163 pthread_t os::Aix::_main_thread = ((pthread_t)0);
 164 int       os::Aix::_page_size = -1;
 165 
 166 // -1 = uninitialized, 0 if AIX, 1 if OS/400 pase
 167 int       os::Aix::_on_pase = -1;
 168 
 169 // 0 = uninitialized, otherwise 32 bit number:
 170 //  0xVVRRTTSS
 171 //  VV - major version
 172 //  RR - minor version
</pre>
<hr />
<pre>
 464       trcVerbose(&quot; %s &quot;, describe_pagesize(sizes[i]));
 465     }
 466 
 467     // Can we use 64K, 16M pages?
 468     for (int i = 0; i &lt; num_psizes; i ++) {
 469       const size_t pagesize = sizes[i];
 470       if (pagesize != 64*K &amp;&amp; pagesize != 16*M) {
 471         continue;
 472       }
 473       bool can_use = false;
 474       trcVerbose(&quot;Probing support for %s pages...&quot;, describe_pagesize(pagesize));
 475       const int shmid = ::shmget(IPC_PRIVATE, pagesize,
 476         IPC_CREAT | S_IRUSR | S_IWUSR);
 477       guarantee0(shmid != -1); // Should always work.
 478       // Try to set pagesize.
 479       struct shmid_ds shm_buf = { 0 };
 480       shm_buf.shm_pagesize = pagesize;
 481       if (::shmctl(shmid, SHM_PAGESIZE, &amp;shm_buf) != 0) {
 482         const int en = errno;
 483         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
<span class="line-modified"> 484         trcVerbose(&quot;shmctl(SHM_PAGESIZE) failed with errno=%d&quot;, errno);</span>

 485       } else {
 486         // Attach and double check pageisze.
 487         void* p = ::shmat(shmid, NULL, 0);
 488         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
 489         guarantee0(p != (void*) -1); // Should always work.
 490         const size_t real_pagesize = os::Aix::query_pagesize(p);
 491         if (real_pagesize != pagesize) {
<span class="line-modified"> 492           trcVerbose(&quot;real page size (&quot; SIZE_FORMAT_HEX &quot;) differs.&quot;, real_pagesize);</span>
 493         } else {
 494           can_use = true;
 495         }
 496         ::shmdt(p);
 497       }
 498       trcVerbose(&quot;Can use: %s&quot;, (can_use ? &quot;yes&quot; : &quot;no&quot;));
 499       if (pagesize == 64*K) {
 500         g_multipage_support.can_use_64K_pages = can_use;
 501       } else if (pagesize == 16*M) {
 502         g_multipage_support.can_use_16M_pages = can_use;
 503       }
 504     }
 505 
 506   } // end: check which pages can be used for shared memory
 507 
 508 query_multipage_support_end:
 509 
 510   trcVerbose(&quot;base page size (sysconf _SC_PAGESIZE): %s&quot;,
 511       describe_pagesize(g_multipage_support.pagesize));
 512   trcVerbose(&quot;Data page size (C-Heap, bss, etc): %s&quot;,
 513       describe_pagesize(g_multipage_support.datapsize));
 514   trcVerbose(&quot;Text page size: %s&quot;,
 515       describe_pagesize(g_multipage_support.textpsize));
 516   trcVerbose(&quot;Thread stack page size (pthread): %s&quot;,
 517       describe_pagesize(g_multipage_support.pthr_stack_pagesize));
 518   trcVerbose(&quot;Default shared memory page size: %s&quot;,
 519       describe_pagesize(g_multipage_support.shmpsize));
<span class="line-modified"> 520   trcVerbose(&quot;Can use 64K pages dynamically with shared memory: %s&quot;,</span>
 521       (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
 522   trcVerbose(&quot;Can use 16M pages dynamically with shared memory: %s&quot;,
 523       (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
 524   trcVerbose(&quot;Multipage error details: %d&quot;,
 525       g_multipage_support.error);
 526 
 527   // sanity checks
 528   assert0(g_multipage_support.pagesize == 4*K);
 529   assert0(g_multipage_support.datapsize == 4*K || g_multipage_support.datapsize == 64*K);
 530   assert0(g_multipage_support.textpsize == 4*K || g_multipage_support.textpsize == 64*K);
 531   assert0(g_multipage_support.pthr_stack_pagesize == g_multipage_support.datapsize);
 532   assert0(g_multipage_support.shmpsize == 4*K || g_multipage_support.shmpsize == 64*K);
 533 
 534 }
 535 
 536 void os::init_system_properties_values() {
 537 
 538 #ifndef OVERRIDE_LIBPATH
 539   #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 540 #else
 541   #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 542 #endif
 543 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 544 
 545   // Buffer that fits several sprintfs.
 546   // Note that the space for the trailing null is provided
 547   // by the nulls included by the sizeof operator.
 548   const size_t bufsize =
 549     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 550          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="line-modified"> 551   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 552 
 553   // sysclasspath, java_home, dll_dir
 554   {
 555     char *pslash;
 556     os::jvm_path(buf, bufsize);
 557 
 558     // Found the full path to libjvm.so.
 559     // Now cut the path to &lt;java_home&gt;/jre if we can.
 560     pslash = strrchr(buf, &#39;/&#39;);
 561     if (pslash != NULL) {
 562       *pslash = &#39;\0&#39;;            // Get rid of /libjvm.so.
 563     }
 564     pslash = strrchr(buf, &#39;/&#39;);
 565     if (pslash != NULL) {
 566       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 567     }
 568     Arguments::set_dll_dir(buf);
 569 
 570     if (pslash != NULL) {
 571       pslash = strrchr(buf, &#39;/&#39;);
</pre>
<hr />
<pre>
 573         *pslash = &#39;\0&#39;;        // Get rid of /lib.
 574       }
 575     }
 576     Arguments::set_java_home(buf);
 577     if (!set_boot_path(&#39;/&#39;, &#39;:&#39;)) {
 578       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 579     }
 580   }
 581 
 582   // Where to look for native libraries.
 583 
 584   // On Aix we get the user setting of LIBPATH.
 585   // Eventually, all the library path setting will be done here.
 586   // Get the user setting of LIBPATH.
 587   const char *v = ::getenv(&quot;LIBPATH&quot;);
 588   const char *v_colon = &quot;:&quot;;
 589   if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 590 
 591   // Concatenate user and invariant part of ld_library_path.
 592   // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="line-modified"> 593   char *ld_library_path = NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);</span>
 594   sprintf(ld_library_path, &quot;%s%s&quot; DEFAULT_LIBPATH, v, v_colon);
 595   Arguments::set_library_path(ld_library_path);
 596   FREE_C_HEAP_ARRAY(char, ld_library_path);
 597 
 598   // Extensions directories.
 599   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR, Arguments::get_java_home());
 600   Arguments::set_ext_dirs(buf);
 601 
 602   FREE_C_HEAP_ARRAY(char, buf);
 603 
 604 #undef DEFAULT_LIBPATH
 605 #undef EXTENSIONS_DIR
 606 }
 607 
 608 ////////////////////////////////////////////////////////////////////////////////
 609 // breakpoint support
 610 
 611 void os::breakpoint() {
 612   BREAKPOINT;
 613 }
</pre>
<hr />
<pre>
 900   // Save some cycles and a page by disabling OS guard pages where we have our own
 901   // VM guard pages (in java threads). For other threads, keep system default guard
 902   // pages in place.
 903   if (thr_type == java_thread || thr_type == compiler_thread) {
 904     ret = pthread_attr_setguardsize(&amp;attr, 0);
 905   }
 906 
 907   pthread_t tid = 0;
 908   if (ret == 0) {
 909     ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 910   }
 911 
 912   if (ret == 0) {
 913     char buf[64];
 914     log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 915       (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 916   } else {
 917     char buf[64];
 918     log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%d=%s) for attributes: %s.&quot;,
 919       ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="line-added"> 920     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 921     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 922     LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 923     os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added"> 924     os::print_memory_info(&amp;st);</span>
 925   }
 926 
 927   pthread_attr_destroy(&amp;attr);
 928 
 929   if (ret != 0) {
 930     // Need to clean up stuff we&#39;ve allocated so far.
 931     thread-&gt;set_osthread(NULL);
 932     delete osthread;
 933     return false;
 934   }
 935 
 936   // OSThread::thread_id is the pthread id.
 937   osthread-&gt;set_thread_id(tid);
 938 
 939   return true;
 940 }
 941 
 942 /////////////////////////////////////////////////////////////////////////////
 943 // attach existing thread
 944 
</pre>
<hr />
<pre>
1004   assert(osthread != NULL, &quot;osthread not set&quot;);
1005 
1006   // We are told to free resources of the argument thread,
1007   // but we can only really operate on the current thread.
1008   assert(Thread::current()-&gt;osthread() == osthread,
1009          &quot;os::free_thread but not current thread&quot;);
1010 
1011   // Restore caller&#39;s signal mask
1012   sigset_t sigmask = osthread-&gt;caller_sigmask();
1013   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
1014 
1015   delete osthread;
1016 }
1017 
1018 ////////////////////////////////////////////////////////////////////////////////
1019 // time support
1020 
1021 // Time since start-up in seconds to a fine granularity.
1022 // Used by VMSelfDestructTimer and the MemProfiler.
1023 double os::elapsedTime() {
<span class="line-modified">1024   return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution</span>
1025 }
1026 
1027 jlong os::elapsed_counter() {
<span class="line-modified">1028   return javaTimeNanos() - initial_time_count;</span>


1029 }
1030 
1031 jlong os::elapsed_frequency() {
<span class="line-modified">1032   return NANOSECS_PER_SEC; // nanosecond resolution</span>
1033 }
1034 
1035 bool os::supports_vtime() { return true; }


1036 
1037 double os::elapsedVTime() {
1038   struct rusage usage;
1039   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1040   if (retval == 0) {
1041     return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec + (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000.0 * 1000);
1042   } else {
1043     // better than nothing, but not much
1044     return elapsedTime();
1045   }
1046 }
1047 
1048 jlong os::javaTimeMillis() {
1049   timeval time;
1050   int status = gettimeofday(&amp;time, NULL);
1051   assert(status != -1, &quot;aix error at gettimeofday()&quot;);
1052   return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);
1053 }
1054 
1055 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
</pre>
<hr />
<pre>
1066 // this unconditionally, so we do it.
1067 //
1068 // See: https://www.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.basetrf2/read_real_time.htm
1069 //
1070 // On PASE: mread_real_time will always return RTC_POWER_PC data, so no
1071 // conversion is necessary. However, mread_real_time will not return
1072 // monotonic results but merely matches read_real_time. So we need a tweak
1073 // to ensure monotonic results.
1074 //
1075 // For PASE no public documentation exists, just word by IBM
1076 jlong os::javaTimeNanos() {
1077   timebasestruct_t time;
1078   int rc = mread_real_time(&amp;time, TIMEBASE_SZ);
1079   if (os::Aix::on_pase()) {
1080     assert(rc == RTC_POWER, &quot;expected time format RTC_POWER from mread_real_time in PASE&quot;);
1081     jlong now = jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
1082     jlong prev = max_real_time;
1083     if (now &lt;= prev) {
1084       return prev;   // same or retrograde time;
1085     }
<span class="line-modified">1086     jlong obsv = Atomic::cmpxchg(&amp;max_real_time, prev, now);</span>
1087     assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
1088     // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
1089     // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
1090     // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
1091     // some other thread raced this thread and installed a new value, in which case
1092     // we could either (a) retry the entire operation, (b) retry trying to install now
1093     // or (c) just return obsv.  We use (c).   No loop is required although in some cases
1094     // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
1095     // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
1096     // to (a) or (b) -- and greatly reduces coherence traffic.
1097     // We might also condition (c) on the magnitude of the delta between obsv and now.
1098     // Avoiding excessive CAS operations to hot RW locations is critical.
1099     // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
1100     return (prev == obsv) ? now : obsv;
1101   } else {
1102     if (rc != RTC_POWER) {
1103       rc = time_base_to_time(&amp;time, TIMEBASE_SZ);
1104       assert(rc != -1, &quot;error calling time_base_to_time()&quot;);
1105     }
1106     return jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
</pre>
<hr />
<pre>
1178 // called from signal handler. Before adding something to os::abort(), make
1179 // sure it is async-safe and can handle partially initialized VM.
1180 void os::abort(bool dump_core, void* siginfo, const void* context) {
1181   os::shutdown();
1182   if (dump_core) {
1183 #ifndef PRODUCT
1184     fdStream out(defaultStream::output_fd());
1185     out.print_raw(&quot;Current thread is &quot;);
1186     char buf[16];
1187     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1188     out.print_raw_cr(buf);
1189     out.print_raw_cr(&quot;Dumping core ...&quot;);
1190 #endif
1191     ::abort(); // dump core
1192   }
1193 
1194   ::exit(1);
1195 }
1196 
1197 // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added">1198 // Dump a core file, if possible, for debugging.</span>
1199 void os::die() {
<span class="line-modified">1200   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-added">1201     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">1202     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">1203     os::signal_raise(SIGKILL);</span>
<span class="line-added">1204   } else {</span>
<span class="line-added">1205     ::abort();</span>
<span class="line-added">1206   }</span>
1207 }
1208 
1209 intx os::current_thread_id() {
1210   return (intx)pthread_self();
1211 }
1212 
1213 int os::current_process_id() {
1214   return getpid();
1215 }
1216 
1217 // DLL functions
1218 
1219 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1220 
1221 // This must be hard coded because it&#39;s the system&#39;s temporary
1222 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1223 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1224 
1225 // Check if addr is inside libjvm.so.
1226 bool os::address_is_in_vm(address addr) {
</pre>
<hr />
<pre>
1286   if (offset) {
1287     *offset = -1;
1288   }
1289   // Buf is not optional, but offset is optional.
1290   assert(buf != NULL, &quot;sanity check&quot;);
1291   buf[0] = &#39;\0&#39;;
1292 
1293   // Resolve function ptr literals first.
1294   addr = resolve_function_descriptor_to_code_pointer(addr);
1295   if (!addr) {
1296     return false;
1297   }
1298 
1299   return AixSymbols::get_module_name(addr, buf, buflen);
1300 }
1301 
1302 // Loads .dll/.so and in case of error it checks if .dll/.so was built
1303 // for the same architecture as Hotspot is running on.
1304 void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1305 
<span class="line-added">1306   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">1307 </span>
1308   if (ebuf &amp;&amp; ebuflen &gt; 0) {
1309     ebuf[0] = &#39;\0&#39;;
1310     ebuf[ebuflen - 1] = &#39;\0&#39;;
1311   }
1312 
1313   if (!filename || strlen(filename) == 0) {
1314     ::strncpy(ebuf, &quot;dll_load: empty filename specified&quot;, ebuflen - 1);
1315     return NULL;
1316   }
1317 
1318   // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.
1319   void * result= ::dlopen(filename, RTLD_LAZY);
1320   if (result != NULL) {
<span class="line-added">1321     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
1322     // Reload dll cache. Don&#39;t do this in signal handling.
1323     LoadedLibraries::reload();
<span class="line-added">1324     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1325     return result;
1326   } else {
1327     // error analysis when dlopen fails
<span class="line-modified">1328     const char* error_report = ::dlerror();</span>
<span class="line-modified">1329     if (error_report == NULL) {</span>
<span class="line-added">1330       error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332     if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
1333       snprintf(ebuf, ebuflen - 1, &quot;%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s&quot;,
1334                filename, ::getenv(&quot;LIBPATH&quot;), ::getenv(&quot;LD_LIBRARY_PATH&quot;), error_report);
1335     }
<span class="line-added">1336     Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1337     log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
1338   }
1339   return NULL;
1340 }
1341 
1342 void* os::dll_lookup(void* handle, const char* name) {
1343   void* res = dlsym(handle, name);
1344   return res;
1345 }
1346 
1347 void* os::get_default_process_handle() {
1348   return (void*)::dlopen(NULL, RTLD_LAZY);
1349 }
1350 
1351 void os::print_dll_info(outputStream *st) {
1352   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1353   LoadedLibraries::print(st);
1354 }
1355 
1356 void os::get_summary_os_info(char* buf, size_t buflen) {
1357   // There might be something more readable than uname results for AIX.
</pre>
<hr />
<pre>
1361 }
1362 
1363 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1364   // Not yet implemented.
1365   return 0;
1366 }
1367 
1368 void os::print_os_info_brief(outputStream* st) {
1369   uint32_t ver = os::Aix::os_version();
1370   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1371                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1372 
1373   os::Posix::print_uname_info(st);
1374 
1375   // Linux uses print_libversion_info(st); here.
1376 }
1377 
1378 void os::print_os_info(outputStream* st) {
1379   st-&gt;print(&quot;OS:&quot;);
1380 
<span class="line-modified">1381   os::Posix::print_uname_info(st);</span>








1382 
1383   uint32_t ver = os::Aix::os_version();
1384   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1385                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1386 
<span class="line-added">1387   os::Posix::print_uptime_info(st);</span>
<span class="line-added">1388 </span>
1389   os::Posix::print_rlimit_info(st);
1390 
<span class="line-modified">1391   os::Posix::print_load_average(st);</span>
<span class="line-modified">1392 </span>
<span class="line-modified">1393   // _SC_THREAD_THREADS_MAX is the maximum number of threads within a process.</span>
<span class="line-modified">1394   long tmax = sysconf(_SC_THREAD_THREADS_MAX);</span>
<span class="line-modified">1395   st-&gt;print_cr(&quot;maximum #threads within a process:%ld&quot;, tmax);</span>

1396 
1397   // print wpar info
1398   libperfstat::wparinfo_t wi;
1399   if (libperfstat::get_wparinfo(&amp;wi)) {
1400     st-&gt;print_cr(&quot;wpar info&quot;);
1401     st-&gt;print_cr(&quot;name: %s&quot;, wi.name);
1402     st-&gt;print_cr(&quot;id:   %d&quot;, wi.wpar_id);
1403     st-&gt;print_cr(&quot;type: %s&quot;, (wi.app_wpar ? &quot;application&quot; : &quot;system&quot;));
1404   }
1405 
<span class="line-modified">1406   VM_Version::print_platform_virtualization_info(st);</span>






1407 }
1408 
1409 void os::print_memory_info(outputStream* st) {
1410 
1411   st-&gt;print_cr(&quot;Memory:&quot;);
1412 
1413   st-&gt;print_cr(&quot;  Base page size (sysconf _SC_PAGESIZE):  %s&quot;,
1414     describe_pagesize(g_multipage_support.pagesize));
1415   st-&gt;print_cr(&quot;  Data page size (C-Heap, bss, etc):      %s&quot;,
1416     describe_pagesize(g_multipage_support.datapsize));
1417   st-&gt;print_cr(&quot;  Text page size:                         %s&quot;,
1418     describe_pagesize(g_multipage_support.textpsize));
1419   st-&gt;print_cr(&quot;  Thread stack page size (pthread):       %s&quot;,
1420     describe_pagesize(g_multipage_support.pthr_stack_pagesize));
1421   st-&gt;print_cr(&quot;  Default shared memory page size:        %s&quot;,
1422     describe_pagesize(g_multipage_support.shmpsize));
<span class="line-modified">1423   st-&gt;print_cr(&quot;  Can use 64K pages dynamically with shared memory:  %s&quot;,</span>
1424     (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
1425   st-&gt;print_cr(&quot;  Can use 16M pages dynamically with shared memory: %s&quot;,
1426     (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
1427   st-&gt;print_cr(&quot;  Multipage error: %d&quot;,
1428     g_multipage_support.error);
1429   st-&gt;cr();
1430   st-&gt;print_cr(&quot;  os::vm_page_size:       %s&quot;, describe_pagesize(os::vm_page_size()));
1431 
1432   // print out LDR_CNTRL because it affects the default page sizes
1433   const char* const ldr_cntrl = ::getenv(&quot;LDR_CNTRL&quot;);
1434   st-&gt;print_cr(&quot;  LDR_CNTRL=%s.&quot;, ldr_cntrl ? ldr_cntrl : &quot;&lt;unset&gt;&quot;);
1435 
1436   // Print out EXTSHM because it is an unsupported setting.
1437   const char* const extshm = ::getenv(&quot;EXTSHM&quot;);
1438   st-&gt;print_cr(&quot;  EXTSHM=%s.&quot;, extshm ? extshm : &quot;&lt;unset&gt;&quot;);
1439   if ( (strcmp(extshm, &quot;on&quot;) == 0) || (strcmp(extshm, &quot;ON&quot;) == 0) ) {
1440     st-&gt;print_cr(&quot;  *** Unsupported! Please remove EXTSHM from your environment! ***&quot;);
1441   }
1442 
1443   // Print out AIXTHREAD_GUARDPAGES because it affects the size of pthread stacks.
</pre>
<hr />
<pre>
1469 
1470   // Print program break.
1471   st-&gt;print_cr(&quot;Program break at VM startup: &quot; PTR_FORMAT &quot;.&quot;, p2i(g_brk_at_startup));
1472   address brk_now = (address)::sbrk(0);
1473   if (brk_now != (address)-1) {
1474     st-&gt;print_cr(&quot;Program break now          : &quot; PTR_FORMAT &quot; (distance: &quot; SIZE_FORMAT &quot;k).&quot;,
1475                  p2i(brk_now), (size_t)((brk_now - g_brk_at_startup) / K));
1476   }
1477   st-&gt;print_cr(&quot;MaxExpectedDataSegmentSize    : &quot; SIZE_FORMAT &quot;k.&quot;, MaxExpectedDataSegmentSize / K);
1478   st-&gt;cr();
1479 
1480   // Print segments allocated with os::reserve_memory.
1481   st-&gt;print_cr(&quot;internal virtual memory regions used by vm:&quot;);
1482   vmembk_print_on(st);
1483 }
1484 
1485 // Get a string for the cpuinfo that is a summary of the cpu type
1486 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1487   // read _system_configuration.version
1488   switch (_system_configuration.version) {
<span class="line-added">1489   case PV_9:</span>
<span class="line-added">1490     strncpy(buf, &quot;Power PC 9&quot;, buflen);</span>
<span class="line-added">1491     break;</span>
1492   case PV_8:
1493     strncpy(buf, &quot;Power PC 8&quot;, buflen);
1494     break;
1495   case PV_7:
1496     strncpy(buf, &quot;Power PC 7&quot;, buflen);
1497     break;
1498   case PV_6_1:
1499     strncpy(buf, &quot;Power PC 6 DD1.x&quot;, buflen);
1500     break;
1501   case PV_6:
1502     strncpy(buf, &quot;Power PC 6&quot;, buflen);
1503     break;
1504   case PV_5:
1505     strncpy(buf, &quot;Power PC 5&quot;, buflen);
1506     break;
1507   case PV_5_2:
1508     strncpy(buf, &quot;Power PC 5_2&quot;, buflen);
1509     break;
1510   case PV_5_3:
1511     strncpy(buf, &quot;Power PC 5_3&quot;, buflen);
1512     break;
1513   case PV_5_Compat:
1514     strncpy(buf, &quot;PV_5_Compat&quot;, buflen);
1515     break;
1516   case PV_6_Compat:
1517     strncpy(buf, &quot;PV_6_Compat&quot;, buflen);
1518     break;
1519   case PV_7_Compat:
1520     strncpy(buf, &quot;PV_7_Compat&quot;, buflen);
1521     break;
1522   case PV_8_Compat:
1523     strncpy(buf, &quot;PV_8_Compat&quot;, buflen);
1524     break;
<span class="line-added">1525   case PV_9_Compat:</span>
<span class="line-added">1526     strncpy(buf, &quot;PV_9_Compat&quot;, buflen);</span>
<span class="line-added">1527     break;</span>
1528   default:
1529     strncpy(buf, &quot;unknown&quot;, buflen);
1530   }
1531 }
1532 
1533 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1534   // Nothing to do beyond of what os::print_cpu_info() does.
1535 }
1536 
1537 static void print_signal_handler(outputStream* st, int sig,
1538                                  char* buf, size_t buflen);
1539 
1540 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1541   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1542   print_signal_handler(st, SIGSEGV, buf, buflen);
1543   print_signal_handler(st, SIGBUS , buf, buflen);
1544   print_signal_handler(st, SIGFPE , buf, buflen);
1545   print_signal_handler(st, SIGPIPE, buf, buflen);
1546   print_signal_handler(st, SIGXFSZ, buf, buflen);
1547   print_signal_handler(st, SIGILL , buf, buflen);
</pre>
<hr />
<pre>
1634         }
1635       }
1636     }
1637   }
1638 
1639   strncpy(saved_jvm_path, buf, sizeof(saved_jvm_path));
1640   saved_jvm_path[sizeof(saved_jvm_path) - 1] = &#39;\0&#39;;
1641 }
1642 
1643 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1644   // no prefix required, not even &quot;_&quot;
1645 }
1646 
1647 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1648   // no suffix required
1649 }
1650 
1651 ////////////////////////////////////////////////////////////////////////////////
1652 // sun.misc.Signal support
1653 


1654 static void
1655 UserHandler(int sig, void *siginfo, void *context) {






1656   // Ctrl-C is pressed during error reporting, likely because the error
1657   // handler fails to abort. Let VM die immediately.
1658   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1659     os::die();
1660   }
1661 
1662   os::signal_notify(sig);
1663 }
1664 
1665 void* os::user_handler() {
1666   return CAST_FROM_FN_PTR(void*, UserHandler);
1667 }
1668 
1669 extern &quot;C&quot; {
1670   typedef void (*sa_handler_t)(int);
1671   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1672 }
1673 
1674 void* os::signal(int signal_number, void* handler) {
1675   struct sigaction sigAct, oldSigAct;
</pre>
<hr />
<pre>
1775       trcVerbose(&quot;msem_lock failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1776       warn_only_once = true;
1777     }
1778   }
1779 }
1780 
1781 static void jdk_misc_signal_init() {
1782   // Initialize signal structures
1783   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1784 
1785   // Initialize signal semaphore
1786   local_sem_init();
1787 }
1788 
1789 void os::signal_notify(int sig) {
1790   Atomic::inc(&amp;pending_signals[sig]);
1791   local_sem_post();
1792 }
1793 
1794 static int check_pending_signals() {

1795   for (;;) {
1796     for (int i = 0; i &lt; NSIG + 1; i++) {
1797       jint n = pending_signals[i];
<span class="line-modified">1798       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
1799         return i;
1800       }
1801     }
1802     JavaThread *thread = JavaThread::current();
1803     ThreadBlockInVM tbivm(thread);
1804 
1805     bool threadIsSuspended;
1806     do {
1807       thread-&gt;set_suspend_equivalent();
1808       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1809 
1810       local_sem_wait();
1811 
1812       // were we externally suspended while we were waiting?
1813       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1814       if (threadIsSuspended) {
1815         //
1816         // The semaphore has been incremented, but while we were waiting
1817         // another thread suspended us. We don&#39;t want to continue running
1818         // while suspended because that would surprise the thread that
</pre>
<hr />
<pre>
1851   }
1852 
1853   bool contains_range(char* p, size_t s) const {
1854     return contains_addr(p) &amp;&amp; contains_addr(p + s - 1);
1855   }
1856 
1857   void print_on(outputStream* os) const {
1858     os-&gt;print(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] (&quot; UINTX_FORMAT
1859       &quot; bytes, %d %s pages), %s&quot;,
1860       addr, addr + size - 1, size, size / pagesize, describe_pagesize(pagesize),
1861       (type == VMEM_SHMATED ? &quot;shmat&quot; : &quot;mmap&quot;)
1862     );
1863   }
1864 
1865   // Check that range is a sub range of memory block (or equal to memory block);
1866   // also check that range is fully page aligned to the page size if the block.
1867   void assert_is_valid_subrange(char* p, size_t s) const {
1868     if (!contains_range(p, s)) {
1869       trcVerbose(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not a sub &quot;
1870               &quot;range of [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">1871               p2i(p), p2i(p + s), p2i(addr), p2i(addr + size));</span>
1872       guarantee0(false);
1873     }
1874     if (!is_aligned_to(p, pagesize) || !is_aligned_to(p + s, pagesize)) {
1875       trcVerbose(&quot;range [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not&quot;
<span class="line-modified">1876               &quot; aligned to pagesize (%lu)&quot;, p2i(p), p2i(p + s), (unsigned long) pagesize);</span>
1877       guarantee0(false);
1878     }
1879   }
1880 };
1881 
1882 static struct {
1883   vmembk_t* first;
1884   MiscUtils::CritSect cs;
1885 } vmem;
1886 
1887 static void vmembk_add(char* addr, size_t size, size_t pagesize, int type) {
1888   vmembk_t* p = (vmembk_t*) ::malloc(sizeof(vmembk_t));
1889   assert0(p);
1890   if (p) {
1891     MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1892     p-&gt;addr = addr; p-&gt;size = size;
1893     p-&gt;pagesize = pagesize;
1894     p-&gt;type = type;
1895     p-&gt;next = vmem.first;
1896     vmem.first = p;
</pre>
<hr />
<pre>
1927     vmi-&gt;print_on(os);
1928     os-&gt;cr();
1929   }
1930 }
1931 
1932 // Reserve and attach a section of System V memory.
1933 // If &lt;requested_addr&gt; is not NULL, function will attempt to attach the memory at the given
1934 // address. Failing that, it will attach the memory anywhere.
1935 // If &lt;requested_addr&gt; is NULL, function will attach the memory anywhere.
1936 //
1937 // &lt;alignment_hint&gt; is being ignored by this function. It is very probable however that the
1938 // alignment requirements are met anyway, because shmat() attaches at 256M boundaries.
1939 // Should this be not enogh, we can put more work into it.
1940 static char* reserve_shmated_memory (
1941   size_t bytes,
1942   char* requested_addr,
1943   size_t alignment_hint) {
1944 
1945   trcVerbose(&quot;reserve_shmated_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot;
1946     PTR_FORMAT &quot;, alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="line-modified">1947     bytes, p2i(requested_addr), alignment_hint);</span>
1948 
1949   // Either give me wish address or wish alignment but not both.
1950   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint != 0));
1951 
1952   // We must prevent anyone from attaching too close to the
1953   // BRK because that may cause malloc OOM.
1954   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
1955     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="line-modified">1956       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
1957     // Act like the OS refused to attach there.
1958     requested_addr = NULL;
1959   }
1960 
1961   // For old AS/400&#39;s (V5R4 and older) we should not even be here - System V shared memory is not
1962   // really supported (max size 4GB), so reserve_mmapped_memory should have been used instead.
1963   if (os::Aix::on_pase_V5R4_or_older()) {
1964     ShouldNotReachHere();
1965   }
1966 
1967   // Align size of shm up to 64K to avoid errors if we later try to change the page size.
1968   const size_t size = align_up(bytes, 64*K);
1969 
1970   // Reserve the shared segment.
1971   int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | S_IRUSR | S_IWUSR);
1972   if (shmid == -1) {
1973     trcVerbose(&quot;shmget(.., &quot; UINTX_FORMAT &quot;, ..) failed (errno: %d).&quot;, size, errno);
1974     return NULL;
1975   }
1976 
</pre>
<hr />
<pre>
1988                size / (64*K), errno);
1989     // I want to know if this ever happens.
1990     assert(false, &quot;failed to set page size for shmat&quot;);
1991   }
1992 
1993   // Now attach the shared segment.
1994   // Note that I attach with SHM_RND - which means that the requested address is rounded down, if
1995   // needed, to the next lowest segment boundary. Otherwise the attach would fail if the address
1996   // were not a segment boundary.
1997   char* const addr = (char*) shmat(shmid, requested_addr, SHM_RND);
1998   const int errno_shmat = errno;
1999 
2000   // (A) Right after shmat and before handing shmat errors delete the shm segment.
2001   if (::shmctl(shmid, IPC_RMID, NULL) == -1) {
2002     trcVerbose(&quot;shmctl(%u, IPC_RMID) failed (%d)\n&quot;, shmid, errno);
2003     assert(false, &quot;failed to remove shared memory segment!&quot;);
2004   }
2005 
2006   // Handle shmat error. If we failed to attach, just return.
2007   if (addr == (char*)-1) {
<span class="line-modified">2008     trcVerbose(&quot;Failed to attach segment at &quot; PTR_FORMAT &quot; (%d).&quot;, p2i(requested_addr), errno_shmat);</span>
2009     return NULL;
2010   }
2011 
2012   // Just for info: query the real page size. In case setting the page size did not
2013   // work (see above), the system may have given us something other then 4K (LDR_CNTRL).
2014   const size_t real_pagesize = os::Aix::query_pagesize(addr);
2015   if (real_pagesize != shmbuf.shm_pagesize) {
<span class="line-modified">2016     trcVerbose(&quot;pagesize is, surprisingly, &quot; SIZE_FORMAT, real_pagesize);</span>
2017   }
2018 
2019   if (addr) {
2020     trcVerbose(&quot;shm-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes, &quot; UINTX_FORMAT &quot; %s pages)&quot;,
<span class="line-modified">2021       p2i(addr), p2i(addr + size - 1), size, size/real_pagesize, describe_pagesize(real_pagesize));</span>
2022   } else {
2023     if (requested_addr != NULL) {
<span class="line-modified">2024       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at with address &quot; PTR_FORMAT &quot;.&quot;, size, p2i(requested_addr));</span>
2025     } else {
2026       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, size);
2027     }
2028   }
2029 
2030   // book-keeping
2031   vmembk_add(addr, size, real_pagesize, VMEM_SHMATED);
2032   assert0(is_aligned_to(addr, os::vm_page_size()));
2033 
2034   return addr;
2035 }
2036 
2037 static bool release_shmated_memory(char* addr, size_t size) {
2038 
2039   trcVerbose(&quot;release_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2040     p2i(addr), p2i(addr + size - 1));</span>
2041 
2042   bool rc = false;
2043 
2044   // TODO: is there a way to verify shm size without doing bookkeeping?
2045   if (::shmdt(addr) != 0) {
2046     trcVerbose(&quot;error (%d).&quot;, errno);
2047   } else {
2048     trcVerbose(&quot;ok.&quot;);
2049     rc = true;
2050   }
2051   return rc;
2052 }
2053 
2054 static bool uncommit_shmated_memory(char* addr, size_t size) {
2055   trcVerbose(&quot;uncommit_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2056     p2i(addr), p2i(addr + size - 1));</span>
2057 
2058   const bool rc = my_disclaim64(addr, size);
2059 
2060   if (!rc) {
<span class="line-modified">2061     trcVerbose(&quot;my_disclaim64(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;) failed.\n&quot;, p2i(addr), size);</span>
2062     return false;
2063   }
2064   return true;
2065 }
2066 
2067 ////////////////////////////////  mmap-based routines /////////////////////////////////
2068 
2069 // Reserve memory via mmap.
2070 // If &lt;requested_addr&gt; is given, an attempt is made to attach at the given address.
2071 // Failing that, memory is allocated at any address.
2072 // If &lt;alignment_hint&gt; is given and &lt;requested_addr&gt; is NULL, an attempt is made to
2073 // allocate at an address aligned with the given alignment. Failing that, memory
2074 // is aligned anywhere.
2075 static char* reserve_mmaped_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2076   trcVerbose(&quot;reserve_mmaped_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot; PTR_FORMAT &quot;, &quot;
2077     &quot;alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="line-modified">2078     bytes, p2i(requested_addr), alignment_hint);</span>
2079 
2080   // If a wish address is given, but not aligned to 4K page boundary, mmap will fail.
2081   if (requested_addr &amp;&amp; !is_aligned_to(requested_addr, os::vm_page_size()) != 0) {
<span class="line-modified">2082     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; not aligned to page boundary.&quot;, p2i(requested_addr));</span>
2083     return NULL;
2084   }
2085 
2086   // We must prevent anyone from attaching too close to the
2087   // BRK because that may cause malloc OOM.
2088   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
2089     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="line-modified">2090       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
2091     // Act like the OS refused to attach there.
2092     requested_addr = NULL;
2093   }
2094 
2095   // Specify one or the other but not both.
2096   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint &gt; 0));
2097 
2098   // In 64K mode, we claim the global page size (os::vm_page_size())
2099   // is 64K. This is one of the few points where that illusion may
2100   // break, because mmap() will always return memory aligned to 4K. So
2101   // we must ensure we only ever return memory aligned to 64k.
2102   if (alignment_hint) {
2103     alignment_hint = lcm(alignment_hint, os::vm_page_size());
2104   } else {
2105     alignment_hint = os::vm_page_size();
2106   }
2107 
2108   // Size shall always be a multiple of os::vm_page_size (esp. in 64K mode).
2109   const size_t size = align_up(bytes, os::vm_page_size());
2110 
</pre>
<hr />
<pre>
2117   // later use msync(MS_INVALIDATE) (see os::uncommit_memory).
2118   int flags = MAP_ANONYMOUS | MAP_SHARED;
2119 
2120   // MAP_FIXED is needed to enforce requested_addr - manpage is vague about what
2121   // it means if wishaddress is given but MAP_FIXED is not set.
2122   //
2123   // Important! Behaviour differs depending on whether SPEC1170 mode is active or not.
2124   // SPEC1170 mode active: behaviour like POSIX, MAP_FIXED will clobber existing mappings.
2125   // SPEC1170 mode not active: behaviour, unlike POSIX, is that no existing mappings will
2126   // get clobbered.
2127   if (requested_addr != NULL) {
2128     if (!os::Aix::xpg_sus_mode()) {  // not SPEC1170 Behaviour
2129       flags |= MAP_FIXED;
2130     }
2131   }
2132 
2133   char* addr = (char*)::mmap(requested_addr, extra_size,
2134       PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);
2135 
2136   if (addr == MAP_FAILED) {
<span class="line-modified">2137     trcVerbose(&quot;mmap(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;, ..) failed (%d)&quot;, p2i(requested_addr), size, errno);</span>
2138     return NULL;
2139   }
2140 
2141   // Handle alignment.
2142   char* const addr_aligned = align_up(addr, alignment_hint);
2143   const size_t waste_pre = addr_aligned - addr;
2144   char* const addr_aligned_end = addr_aligned + size;
2145   const size_t waste_post = extra_size - waste_pre - size;
2146   if (waste_pre &gt; 0) {
2147     ::munmap(addr, waste_pre);
2148   }
2149   if (waste_post &gt; 0) {
2150     ::munmap(addr_aligned_end, waste_post);
2151   }
2152   addr = addr_aligned;
2153 
2154   if (addr) {
2155     trcVerbose(&quot;mmap-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes)&quot;,
<span class="line-modified">2156       p2i(addr), p2i(addr + bytes), bytes);</span>
2157   } else {
2158     if (requested_addr != NULL) {
<span class="line-modified">2159       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at wish address &quot; PTR_FORMAT &quot;.&quot;, bytes, p2i(requested_addr));</span>
2160     } else {
2161       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, bytes);
2162     }
2163   }
2164 
2165   // bookkeeping
2166   vmembk_add(addr, size, 4*K, VMEM_MAPPED);
2167 
2168   // Test alignment, see above.
2169   assert0(is_aligned_to(addr, os::vm_page_size()));
2170 
2171   return addr;
2172 }
2173 
2174 static bool release_mmaped_memory(char* addr, size_t size) {
2175   assert0(is_aligned_to(addr, os::vm_page_size()));
2176   assert0(is_aligned_to(size, os::vm_page_size()));
2177 
2178   trcVerbose(&quot;release_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2179     p2i(addr), p2i(addr + size - 1));</span>
2180   bool rc = false;
2181 
2182   if (::munmap(addr, size) != 0) {
2183     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2184     rc = false;
2185   } else {
2186     trcVerbose(&quot;ok.&quot;);
2187     rc = true;
2188   }
2189 
2190   return rc;
2191 }
2192 
2193 static bool uncommit_mmaped_memory(char* addr, size_t size) {
2194 
2195   assert0(is_aligned_to(addr, os::vm_page_size()));
2196   assert0(is_aligned_to(size, os::vm_page_size()));
2197 
2198   trcVerbose(&quot;uncommit_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="line-modified">2199     p2i(addr), p2i(addr + size - 1));</span>
2200   bool rc = false;
2201 
2202   // Uncommit mmap memory with msync MS_INVALIDATE.
2203   if (::msync(addr, size, MS_INVALIDATE) != 0) {
2204     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2205     rc = false;
2206   } else {
2207     trcVerbose(&quot;ok.&quot;);
2208     rc = true;
2209   }
2210 
2211   return rc;
2212 }
2213 
2214 int os::vm_page_size() {
2215   // Seems redundant as all get out.
2216   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2217   return os::Aix::page_size();
2218 }
2219 
2220 // Aix allocates memory by pages.
2221 int os::vm_allocation_granularity() {
2222   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2223   return os::Aix::page_size();
2224 }
2225 
2226 #ifdef PRODUCT
2227 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
2228                                     int err) {
2229   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
<span class="line-modified">2230           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, p2i(addr), size, exec,</span>
2231           os::errno_name(err), err);
2232 }
2233 #endif
2234 
2235 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
2236                                   const char* mesg) {
2237   assert(mesg != NULL, &quot;mesg must be specified&quot;);
2238   if (!pd_commit_memory(addr, size, exec)) {
2239     // Add extra info in product mode for vm_exit_out_of_memory():
2240     PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)
2241     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
2242   }
2243 }
2244 
2245 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
2246 
2247   assert(is_aligned_to(addr, os::vm_page_size()),
2248     &quot;addr &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2249     p2i(addr), os::vm_page_size());
2250   assert(is_aligned_to(size, os::vm_page_size()),
2251     &quot;size &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2252     size, os::vm_page_size());
2253 
2254   vmembk_t* const vmi = vmembk_find(addr);
2255   guarantee0(vmi);
2256   vmi-&gt;assert_is_valid_subrange(addr, size);
2257 
<span class="line-modified">2258   trcVerbose(&quot;commit_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;, p2i(addr), p2i(addr + size - 1));</span>
2259 
2260   if (UseExplicitCommit) {
2261     // AIX commits memory on touch. So, touch all pages to be committed.
2262     for (char* p = addr; p &lt; (addr + size); p += 4*K) {
2263       *p = &#39;\0&#39;;
2264     }
2265   }
2266 
2267   return true;
2268 }
2269 
2270 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint, bool exec) {
2271   return pd_commit_memory(addr, size, exec);
2272 }
2273 
2274 void os::pd_commit_memory_or_exit(char* addr, size_t size,
2275                                   size_t alignment_hint, bool exec,
2276                                   const char* mesg) {
2277   // Alignment_hint is ignored on this OS.
2278   pd_commit_memory_or_exit(addr, size, exec, mesg);
</pre>
<hr />
<pre>
2325 bool os::numa_topology_changed() {
2326   return false;
2327 }
2328 
2329 size_t os::numa_get_groups_num() {
2330   return 1;
2331 }
2332 
2333 int os::numa_get_group_id() {
2334   return 0;
2335 }
2336 
2337 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
2338   if (size &gt; 0) {
2339     ids[0] = 0;
2340     return 1;
2341   }
2342   return 0;
2343 }
2344 
<span class="line-added">2345 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">2346   return 0;</span>
<span class="line-added">2347 }</span>
<span class="line-added">2348 </span>
2349 bool os::get_page_info(char *start, page_info* info) {
2350   return false;
2351 }
2352 
2353 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
2354   return end;
2355 }
2356 
2357 // Reserves and attaches a shared memory segment.
2358 // Will assert if a wish address is given and could not be obtained.
2359 char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2360 
2361   // All other Unices do a mmap(MAP_FIXED) if the addr is given,
2362   // thereby clobbering old mappings at that place. That is probably
2363   // not intended, never used and almost certainly an error were it
2364   // ever be used this way (to try attaching at a specified address
2365   // without clobbering old mappings an alternate API exists,
2366   // os::attempt_reserve_memory_at()).
2367   // Instead of mimicking the dangerous coding of the other platforms, here I
2368   // just ignore the request address (release) or assert(debug).
</pre>
<hr />
<pre>
2421   }
2422 
2423   // update bookkeeping
2424   if (rc &amp;&amp; remove_bookkeeping) {
2425     vmembk_remove(vmi);
2426   }
2427 
2428   return rc;
2429 }
2430 
2431 static bool checked_mprotect(char* addr, size_t size, int prot) {
2432 
2433   // Little problem here: if SPEC1170 behaviour is off, mprotect() on AIX will
2434   // not tell me if protection failed when trying to protect an un-protectable range.
2435   //
2436   // This means if the memory was allocated using shmget/shmat, protection wont work
2437   // but mprotect will still return 0:
2438   //
2439   // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm
2440 
<span class="line-added">2441   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
2442   bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;
2443 
2444   if (!rc) {
2445     const char* const s_errno = os::errno_name(errno);
2446     warning(&quot;mprotect(&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;, 0x%X) failed (%s).&quot;, addr, addr + size, prot, s_errno);
2447     return false;
2448   }
2449 
2450   // mprotect success check
2451   //
2452   // Mprotect said it changed the protection but can I believe it?
2453   //
2454   // To be sure I need to check the protection afterwards. Try to
2455   // read from protected memory and check whether that causes a segfault.
2456   //
2457   if (!os::Aix::xpg_sus_mode()) {
2458 
2459     if (CanUseSafeFetch32()) {
2460 
2461       const bool read_protected =
2462         (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2463          SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2464 
2465       if (prot &amp; PROT_READ) {
2466         rc = !read_protected;
2467       } else {
2468         rc = read_protected;
2469       }
2470 
2471       if (!rc) {
2472         if (os::Aix::on_pase()) {
2473           // There is an issue on older PASE systems where mprotect() will return success but the
2474           // memory will not be protected.
2475           // This has nothing to do with the problem of using mproect() on SPEC1170 incompatible
2476           // machines; we only see it rarely, when using mprotect() to protect the guard page of
2477           // a stack. It is an OS error.
2478           //
2479           // A valid strategy is just to try again. This usually works. :-/
2480 
2481           ::usleep(1000);
<span class="line-added">2482           Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
2483           if (::mprotect(addr, size, prot) == 0) {
2484             const bool read_protected_2 =
2485               (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2486               SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2487             rc = true;
2488           }
2489         }
2490       }
2491     }
2492   }
2493 
2494   assert(rc == true, &quot;mprotect failed.&quot;);
2495 
2496   return rc;
2497 }
2498 
2499 // Set protections specified
2500 bool os::protect_memory(char* addr, size_t size, ProtType prot, bool is_committed) {
2501   unsigned int p = 0;
2502   switch (prot) {
</pre>
<hr />
<pre>
2629 int os::java_to_os_priority[CriticalPriority + 1] = {
2630   54,             // 0 Entry should never be used
2631 
2632   55,             // 1 MinPriority
2633   55,             // 2
2634   56,             // 3
2635 
2636   56,             // 4
2637   57,             // 5 NormPriority
2638   57,             // 6
2639 
2640   58,             // 7
2641   58,             // 8
2642   59,             // 9 NearMaxPriority
2643 
2644   60,             // 10 MaxPriority
2645 
2646   60              // 11 CriticalPriority
2647 };
2648 
<span class="line-added">2649 static int prio_init() {</span>
<span class="line-added">2650   if (ThreadPriorityPolicy == 1) {</span>
<span class="line-added">2651     if (geteuid() != 0) {</span>
<span class="line-added">2652       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {</span>
<span class="line-added">2653         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \</span>
<span class="line-added">2654                 &quot;e.g., being the root user. If the necessary permission is not &quot; \</span>
<span class="line-added">2655                 &quot;possessed, changes to priority will be silently ignored.&quot;);</span>
<span class="line-added">2656       }</span>
<span class="line-added">2657     }</span>
<span class="line-added">2658   }</span>
<span class="line-added">2659   if (UseCriticalJavaThreadPriority) {</span>
<span class="line-added">2660     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];</span>
<span class="line-added">2661   }</span>
<span class="line-added">2662   return 0;</span>
<span class="line-added">2663 }</span>
<span class="line-added">2664 </span>
2665 OSReturn os::set_native_priority(Thread* thread, int newpri) {
<span class="line-modified">2666   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;</span>
2667   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2668   int policy = SCHED_OTHER;
2669   struct sched_param param;
2670   param.sched_priority = newpri;
2671   int ret = pthread_setschedparam(thr, policy, &amp;param);
2672 
2673   if (ret != 0) {
2674     trcVerbose(&quot;Could not change priority for thread %d to %d (error %d, %s)&quot;,
2675         (int)thr, newpri, ret, os::errno_name(ret));
2676   }
2677   return (ret == 0) ? OS_OK : OS_ERR;
2678 }
2679 
2680 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
<span class="line-modified">2681   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) {</span>
2682     *priority_ptr = java_to_os_priority[NormPriority];
2683     return OS_OK;
2684   }
2685   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2686   int policy = SCHED_OTHER;
2687   struct sched_param param;
2688   int ret = pthread_getschedparam(thr, &amp;policy, &amp;param);
2689   *priority_ptr = param.sched_priority;
2690 
2691   return (ret == 0) ? OS_OK : OS_ERR;
2692 }
2693 
2694 ////////////////////////////////////////////////////////////////////////////////
2695 // suspend/resume support
2696 
2697 //  The low-level signal-based suspend/resume support is a remnant from the
2698 //  old VM-suspension that used to be for java-suspension, safepoints etc,
2699 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2700 //
2701 //  The remaining code is greatly simplified from the more general suspension
</pre>
<hr />
<pre>
2758   // has not already terminated (via SR_lock()) - else the following assertion
2759   // will fail because the thread is no longer a JavaThread as the ~JavaThread
2760   // destructor has completed.
2761 
2762   if (thread-&gt;SR_lock() == NULL) {
2763     return;
2764   }
2765 
2766   assert(thread-&gt;is_VM_thread() || thread-&gt;is_Java_thread(), &quot;Must be VMThread or JavaThread&quot;);
2767 
2768   OSThread* osthread = thread-&gt;osthread();
2769 
2770   os::SuspendResume::State current = osthread-&gt;sr.state();
2771   if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {
2772     suspend_save_context(osthread, siginfo, context);
2773 
2774     // attempt to switch the state, we assume we had a SUSPEND_REQUEST
2775     os::SuspendResume::State state = osthread-&gt;sr.suspended();
2776     if (state == os::SuspendResume::SR_SUSPENDED) {
2777       sigset_t suspend_set;  // signals for sigsuspend()
<span class="line-modified">2778       sigemptyset(&amp;suspend_set);</span>
2779       // get current set of blocked signals and unblock resume signal
2780       pthread_sigmask(SIG_BLOCK, NULL, &amp;suspend_set);
2781       sigdelset(&amp;suspend_set, SR_signum);
2782 
2783       // wait here until we are resumed
2784       while (1) {
2785         sigsuspend(&amp;suspend_set);
2786 
2787         os::SuspendResume::State result = osthread-&gt;sr.running();
2788         if (result == os::SuspendResume::SR_RUNNING) {
2789           break;
2790         }
2791       }
2792 
2793     } else if (state == os::SuspendResume::SR_RUNNING) {
2794       // request was cancelled, continue
2795     } else {
2796       ShouldNotReachHere();
2797     }
2798 
</pre>
<hr />
<pre>
3044       // automaticlly block the signal
3045       sigaddset(&amp;(actp-&gt;sa_mask), sig);
3046     }
3047 
3048     sa_handler_t hand = NULL;
3049     sa_sigaction_t sa = NULL;
3050     bool siginfo_flag_set = (actp-&gt;sa_flags &amp; SA_SIGINFO) != 0;
3051     // retrieve the chained handler
3052     if (siginfo_flag_set) {
3053       sa = actp-&gt;sa_sigaction;
3054     } else {
3055       hand = actp-&gt;sa_handler;
3056     }
3057 
3058     if ((actp-&gt;sa_flags &amp; SA_RESETHAND) != 0) {
3059       actp-&gt;sa_handler = SIG_DFL;
3060     }
3061 
3062     // try to honor the signal mask
3063     sigset_t oset;
<span class="line-added">3064     sigemptyset(&amp;oset);</span>
3065     pthread_sigmask(SIG_SETMASK, &amp;(actp-&gt;sa_mask), &amp;oset);
3066 
3067     // call into the chained handler
3068     if (siginfo_flag_set) {
3069       (*sa)(sig, siginfo, context);
3070     } else {
3071       (*hand)(sig);
3072     }
3073 
3074     // restore the signal mask
<span class="line-modified">3075     pthread_sigmask(SIG_SETMASK, &amp;oset, NULL);</span>
3076   }
3077   // Tell jvm&#39;s signal handler the signal is taken care of.
3078   return true;
3079 }
3080 
3081 bool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {
3082   bool chained = false;
3083   // signal-chaining
3084   if (UseSignalChaining) {
3085     struct sigaction *actp = get_chained_signal_action(sig);
3086     if (actp != NULL) {
3087       chained = call_chained_handler(actp, sig, siginfo, context);
3088     }
3089   }
3090   return chained;
3091 }
3092 
3093 // for diagnostic
3094 int sigflags[NSIG];
3095 
</pre>
<hr />
<pre>
3445       // with datapsize=64K (like, any other launcher but our own).
3446       //
3447       // In this case it would be smart to allocate the java heap with 64K
3448       // to get the performance benefit, and to fake 64k pages for the
3449       // data segment (when dealing with thread stacks).
3450       //
3451       // However, leave a possibility to downgrade to 4K, using
3452       // -XX:-Use64KPages.
3453       if (Use64KPages) {
3454         trcVerbose(&quot;64K page mode (faked for data segment)&quot;);
3455         Aix::_page_size = 64*K;
3456       } else {
3457         trcVerbose(&quot;4K page mode (Use64KPages=off)&quot;);
3458         Aix::_page_size = 4*K;
3459       }
3460     } else {
3461       // .. and not able to allocate 64k pages dynamically. Here, just
3462       // fall back to 4K paged mode and use mmap for everything.
3463       trcVerbose(&quot;4K page mode&quot;);
3464       Aix::_page_size = 4*K;
<span class="line-modified">3465       FLAG_SET_ERGO(Use64KPages, false);</span>
3466     }
3467   } else {
3468     // datapsize = 64k. Data segment, thread stacks are 64k paged.
3469     // This normally means that we can allocate 64k pages dynamically.
3470     // (There is one special case where this may be false: EXTSHM=on.
3471     // but we decided to not support that mode).
3472     assert0(g_multipage_support.can_use_64K_pages);
3473     Aix::_page_size = 64*K;
3474     trcVerbose(&quot;64K page mode&quot;);
<span class="line-modified">3475     FLAG_SET_ERGO(Use64KPages, true);</span>
3476   }
3477 
3478   // For now UseLargePages is just ignored.
<span class="line-modified">3479   FLAG_SET_ERGO(UseLargePages, false);</span>
3480   _page_sizes[0] = 0;
3481 
3482   // debug trace
3483   trcVerbose(&quot;os::vm_page_size %s&quot;, describe_pagesize(os::vm_page_size()));
3484 
3485   // Next, we need to initialize libo4 and libperfstat libraries.
3486   if (os::Aix::on_pase()) {
3487     os::Aix::initialize_libo4();
3488   } else {
3489     os::Aix::initialize_libperfstat();
3490   }
3491 
3492   // Reset the perfstat information provided by ODM.
3493   if (os::Aix::on_aix()) {
3494     libperfstat::perfstat_reset();
3495   }
3496 
3497   // Now initialze basic system properties. Note that for some of the values we
3498   // need libperfstat etc.
3499   os::Aix::initialize_system_info();
3500 
3501   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
3502 
3503   init_random(1234567);
3504 
3505   // _main_thread points to the thread that created/loaded the JVM.
3506   Aix::_main_thread = pthread_self();
3507 
<span class="line-modified">3508   initial_time_count = javaTimeNanos();</span>
3509 
3510   os::Posix::init();
3511 }
3512 
3513 // This is called _after_ the global arguments have been parsed.
3514 jint os::init_2(void) {
3515 
3516   // This could be set after os::Posix::init() but all platforms
3517   // have to set it the same so we have to mirror Solaris.
3518   DEBUG_ONLY(os::set_mutex_init_done();)
3519 
3520   os::Posix::init_2();
3521 
3522   if (os::Aix::on_pase()) {
3523     trcVerbose(&quot;Running on PASE.&quot;);
3524   } else {
3525     trcVerbose(&quot;Running on AIX (not PASE).&quot;);
3526   }
3527 
3528   trcVerbose(&quot;processor count: %d&quot;, os::_processor_count);
</pre>
<hr />
<pre>
3571       if (status != 0) {
3572         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
3573       }
3574     }
3575   }
3576 
3577   if (PerfAllowAtExitRegistration) {
3578     // Only register atexit functions if PerfAllowAtExitRegistration is set.
3579     // At exit functions can be delayed until process exit time, which
3580     // can be problematic for embedded VM situations. Embedded VMs should
3581     // call DestroyJavaVM() to assure that VM resources are released.
3582 
3583     // Note: perfMemory_exit_helper atexit function may be removed in
3584     // the future if the appropriate cleanup code can be added to the
3585     // VM_Exit VMOperation&#39;s doit method.
3586     if (atexit(perfMemory_exit_helper) != 0) {
3587       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
3588     }
3589   }
3590 
<span class="line-added">3591   // initialize thread priority policy</span>
<span class="line-added">3592   prio_init();</span>
<span class="line-added">3593 </span>
3594   return JNI_OK;
3595 }
3596 
3597 // Mark the polling page as unreadable
3598 void os::make_polling_page_unreadable(void) {
3599   if (!guard_memory((char*)_polling_page, Aix::page_size())) {
3600     fatal(&quot;Could not disable polling page&quot;);
3601   }
3602 };
3603 
3604 // Mark the polling page as readable
3605 void os::make_polling_page_readable(void) {
3606   // Changed according to os_linux.cpp.
3607   if (!checked_mprotect((char *)_polling_page, Aix::page_size(), PROT_READ)) {
3608     fatal(&quot;Could not enable polling page at &quot; PTR_FORMAT, _polling_page);
3609   }
3610 };
3611 
3612 int os::active_processor_count() {
3613   // User has overridden the number of active processors
3614   if (ActiveProcessorCount &gt; 0) {
3615     log_trace(os)(&quot;active_processor_count: &quot;
3616                   &quot;active processor count set by user : %d&quot;,
3617                   ActiveProcessorCount);
3618     return ActiveProcessorCount;
3619   }
3620 
3621   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
3622   assert(online_cpus &gt; 0 &amp;&amp; online_cpus &lt;= processor_count(), &quot;sanity check&quot;);
3623   return online_cpus;
3624 }
3625 
3626 void os::set_native_thread_name(const char *name) {
3627   // Not yet implemented.
3628   return;
3629 }
3630 





3631 bool os::bind_to_processor(uint processor_id) {
3632   // Not yet implemented.
3633   return false;
3634 }
3635 
3636 void os::SuspendedThreadTask::internal_do_task() {
3637   if (do_suspend(_thread-&gt;osthread())) {
3638     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3639     do_task(context);
3640     do_resume(_thread-&gt;osthread());
3641   }
3642 }
3643 
3644 ////////////////////////////////////////////////////////////////////////////////
3645 // debug support
3646 
3647 bool os::find(address addr, outputStream* st) {
3648 
3649   st-&gt;print(PTR_FORMAT &quot;: &quot;, addr);
3650 
</pre>
<hr />
<pre>
3703   /* Scan the directory */
3704   bool result = true;
3705   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
3706     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
3707       result = false;
3708     }
3709   }
3710   closedir(dir);
3711   return result;
3712 }
3713 
3714 // This code originates from JDK&#39;s sysOpen and open64_w
3715 // from src/solaris/hpi/src/system_md.c
3716 
3717 int os::open(const char *path, int oflag, int mode) {
3718 
3719   if (strlen(path) &gt; MAX_PATH - 1) {
3720     errno = ENAMETOOLONG;
3721     return -1;
3722   }
<span class="line-modified">3723   // AIX 7.X now supports O_CLOEXEC too, like modern Linux; but we have to be careful, see</span>
<span class="line-added">3724   // IV90804: OPENING A FILE IN AFS WITH O_CLOEXEC FAILS WITH AN EINVAL ERROR APPLIES TO AIX 7100-04 17/04/14 PTF PECHANGE</span>
<span class="line-added">3725   int oflag_with_o_cloexec = oflag | O_CLOEXEC;</span>
3726 
<span class="line-modified">3727   int fd = ::open64(path, oflag_with_o_cloexec, mode);</span>
<span class="line-modified">3728   if (fd == -1) {</span>
<span class="line-added">3729     // we might fail in the open call when O_CLOEXEC is set, so try again without (see IV90804)</span>
<span class="line-added">3730     fd = ::open64(path, oflag, mode);</span>
<span class="line-added">3731     if (fd == -1) {</span>
<span class="line-added">3732       return -1;</span>
<span class="line-added">3733     }</span>
<span class="line-added">3734   }</span>
3735 
3736   // If the open succeeded, the file might still be a directory.
3737   {
3738     struct stat64 buf64;
3739     int ret = ::fstat64(fd, &amp;buf64);
3740     int st_mode = buf64.st_mode;
3741 
3742     if (ret != -1) {
3743       if ((st_mode &amp; S_IFMT) == S_IFDIR) {
3744         errno = EISDIR;
3745         ::close(fd);
3746         return -1;
3747       }
3748     } else {
3749       ::close(fd);
3750       return -1;
3751     }
3752   }
3753 
3754   // All file descriptors that are opened in the JVM and not
3755   // specifically destined for a subprocess should have the
3756   // close-on-exec flag set. If we don&#39;t set it, then careless 3rd
3757   // party native code might fork and exec without closing all
3758   // appropriate file descriptors (e.g. as we do in closeDescriptors in
3759   // UNIXProcess.c), and this in turn might:
3760   //
3761   // - cause end-of-file to fail to be detected on some file
3762   //   descriptors, resulting in mysterious hangs, or
3763   //
3764   // - might cause an fopen in the subprocess to fail on a system
3765   //   suffering from bug 1085341.
<span class="line-modified">3766 </span>
<span class="line-modified">3767   // Validate that the use of the O_CLOEXEC flag on open above worked.</span>
<span class="line-modified">3768   static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;</span>
<span class="line-modified">3769   if (O_CLOEXEC_is_known_to_work == 0) {</span>
<span class="line-modified">3770     int flags = ::fcntl(fd, F_GETFD);</span>
<span class="line-modified">3771     if (flags != -1) {</span>
<span class="line-modified">3772       if ((flags &amp; FD_CLOEXEC) != 0) {</span>
<span class="line-modified">3773         O_CLOEXEC_is_known_to_work = 1;</span>
<span class="line-modified">3774       } else { // it does not work</span>
<span class="line-modified">3775         ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);</span>
<span class="line-added">3776         O_CLOEXEC_is_known_to_work = -1;</span>
<span class="line-added">3777       }</span>
<span class="line-added">3778     }</span>
<span class="line-added">3779   } else if (O_CLOEXEC_is_known_to_work == -1) {</span>
3780     int flags = ::fcntl(fd, F_GETFD);
<span class="line-modified">3781     if (flags != -1) {</span>
3782       ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
<span class="line-added">3783     }</span>
3784   }

3785 
3786   return fd;
3787 }
3788 
3789 // create binary file, rewriting existing file if required
3790 int os::create_binary_file(const char* path, bool rewrite_existing) {
3791   int oflags = O_WRONLY | O_CREAT;
3792   if (!rewrite_existing) {
3793     oflags |= O_EXCL;
3794   }
3795   return ::open64(path, oflags, S_IREAD | S_IWRITE);
3796 }
3797 
3798 // return current position of file pointer
3799 jlong os::current_file_offset(int fd) {
3800   return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
3801 }
3802 
3803 // move file pointer to the specified offset
3804 jlong os::seek_to_file_offset(int fd, jlong offset) {
</pre>
<hr />
<pre>
4022     }
4023 
4024   } else {
4025 
4026     // AIX: use libperfstat
4027     libperfstat::cpuinfo_t ci;
4028     if (libperfstat::get_cpuinfo(&amp;ci)) {
4029       for (int i = 0; i &lt; nelem; i++) {
4030         values[i] = ci.loadavg[i];
4031       }
4032     } else {
4033       return -1;
4034     }
4035     return nelem;
4036   }
4037 }
4038 
4039 void os::pause() {
4040   char filename[MAX_PATH];
4041   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="line-modified">4042     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
4043   } else {
4044     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4045   }
4046 
4047   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4048   if (fd != -1) {
4049     struct stat buf;
4050     ::close(fd);
4051     while (::stat(filename, &amp;buf) == 0) {
4052       (void)::poll(NULL, 0, 100);
4053     }
4054   } else {
4055     trcVerbose(&quot;Could not open pause file &#39;%s&#39;, continuing immediately.&quot;, filename);
4056   }
4057 }
4058 
4059 bool os::is_primordial_thread(void) {
4060   if (pthread_self() == (pthread_t)1) {
4061     return true;
4062   } else {
</pre>
<hr />
<pre>
4069 void os::Aix::initialize_os_info() {
4070 
4071   assert(_on_pase == -1 &amp;&amp; _os_version == 0, &quot;already called.&quot;);
4072 
4073   struct utsname uts;
4074   memset(&amp;uts, 0, sizeof(uts));
4075   strcpy(uts.sysname, &quot;?&quot;);
4076   if (::uname(&amp;uts) == -1) {
4077     trcVerbose(&quot;uname failed (%d)&quot;, errno);
4078     guarantee(0, &quot;Could not determine whether we run on AIX or PASE&quot;);
4079   } else {
4080     trcVerbose(&quot;uname says: sysname \&quot;%s\&quot; version \&quot;%s\&quot; release \&quot;%s\&quot; &quot;
4081                &quot;node \&quot;%s\&quot; machine \&quot;%s\&quot;\n&quot;,
4082                uts.sysname, uts.version, uts.release, uts.nodename, uts.machine);
4083     const int major = atoi(uts.version);
4084     assert(major &gt; 0, &quot;invalid OS version&quot;);
4085     const int minor = atoi(uts.release);
4086     assert(minor &gt; 0, &quot;invalid OS release&quot;);
4087     _os_version = (major &lt;&lt; 24) | (minor &lt;&lt; 16);
4088     char ver_str[20] = {0};
<span class="line-modified">4089     const char* name_str = &quot;unknown OS&quot;;</span>
4090     if (strcmp(uts.sysname, &quot;OS400&quot;) == 0) {
4091       // We run on AS/400 PASE. We do not support versions older than V5R4M0.
4092       _on_pase = 1;
4093       if (os_version_short() &lt; 0x0504) {
4094         trcVerbose(&quot;OS/400 releases older than V5R4M0 not supported.&quot;);
4095         assert(false, &quot;OS/400 release too old.&quot;);
4096       }
4097       name_str = &quot;OS/400 (pase)&quot;;
4098       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u&quot;, major, minor);
4099     } else if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
<span class="line-modified">4100       // We run on AIX. We do not support versions older than AIX 7.1.</span>
4101       _on_pase = 0;
4102       // Determine detailed AIX version: Version, Release, Modification, Fix Level.
4103       odmWrapper::determine_os_kernel_version(&amp;_os_version);
<span class="line-modified">4104       if (os_version_short() &lt; 0x0701) {</span>
<span class="line-modified">4105         trcVerbose(&quot;AIX releases older than AIX 7.1 are not supported.&quot;);</span>
4106         assert(false, &quot;AIX release too old.&quot;);
4107       }
4108       name_str = &quot;AIX&quot;;
4109       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u.%u.%u&quot;,
4110                    major, minor, (_os_version &gt;&gt; 8) &amp; 0xFF, _os_version &amp; 0xFF);
4111     } else {
<span class="line-modified">4112       assert(false, &quot;%s&quot;, name_str);</span>
4113     }
4114     trcVerbose(&quot;We run on %s %s&quot;, name_str, ver_str);
4115   }
4116 
4117   guarantee(_on_pase != -1 &amp;&amp; _os_version, &quot;Could not determine AIX/OS400 release&quot;);
4118 } // end: os::Aix::initialize_os_info()
4119 
4120 // Scan environment for important settings which might effect the VM.
4121 // Trace out settings. Warn about invalid settings and/or correct them.
4122 //
4123 // Must run after os::Aix::initialue_os_info().
4124 void os::Aix::scan_environment() {
4125 
4126   char* p;
4127   int rc;
4128 
4129   // Warn explicity if EXTSHM=ON is used. That switch changes how
4130   // System V shared memory behaves. One effect is that page size of
4131   // shared memory cannot be change dynamically, effectivly preventing
4132   // large pages from working.
</pre>
<hr />
<pre>
4228   AixMisc::stackbounds_t bounds;
4229   bool rc = AixMisc::query_stack_bounds_for_current_thread(&amp;bounds);
4230   guarantee(rc, &quot;Unable to retrieve stack bounds.&quot;);
4231   // Align the returned stack size such that the stack low address
4232   // is aligned to page size (Note: base is usually not and we do not care).
4233   // We need to do this because caller code will assume stack low address is
4234   // page aligned and will place guard pages without checking.
4235   address low = bounds.base - bounds.size;
4236   address low_aligned = (address)align_up(low, os::vm_page_size());
4237   size_t s = bounds.base - low_aligned;
4238   return s;
4239 }
4240 
4241 extern char** environ;
4242 
4243 // Run the specified command in a separate process. Return its exit value,
4244 // or -1 on failure (e.g. can&#39;t fork a new process).
4245 // Unlike system(), this function can be called from signal handler. It
4246 // doesn&#39;t block SIGINT et al.
4247 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
<span class="line-modified">4248   char* argv[4] = { (char*)&quot;sh&quot;, (char*)&quot;-c&quot;, cmd, NULL};</span>
4249 
4250   pid_t pid = fork();
4251 
4252   if (pid &lt; 0) {
4253     // fork failed
4254     return -1;
4255 
4256   } else if (pid == 0) {
4257     // child process
4258 
4259     // Try to be consistent with system(), which uses &quot;/usr/bin/sh&quot; on AIX.
4260     execve(&quot;/usr/bin/sh&quot;, argv, environ);
4261 
4262     // execve failed
4263     _exit(-1);
4264 
4265   } else {
4266     // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don&#39;t
4267     // care about the actual exit code, for now.
4268 
</pre>
<hr />
<pre>
4338     jio_snprintf(buf, buflen, &quot;dbx -a %d&quot;, os::current_process_id());
4339 
4340     os::fork_and_exec(buf);
4341     yes = false;
4342   }
4343   return yes;
4344 }
4345 
4346 static inline time_t get_mtime(const char* filename) {
4347   struct stat st;
4348   int ret = os::stat(filename, &amp;st);
4349   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
4350   return st.st_mtime;
4351 }
4352 
4353 int os::compare_file_modified_times(const char* file1, const char* file2) {
4354   time_t t1 = get_mtime(file1);
4355   time_t t2 = get_mtime(file2);
4356   return t1 - t2;
4357 }
<span class="line-added">4358 </span>
<span class="line-added">4359 bool os::supports_map_sync() {</span>
<span class="line-added">4360   return false;</span>
<span class="line-added">4361 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="loadlib_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
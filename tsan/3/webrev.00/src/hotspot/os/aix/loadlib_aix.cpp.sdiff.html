<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/loadlib_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="libodm_aix.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/loadlib_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
190   const struct ld_info* ldi = NULL;
191 
192   // Call loadquery(L_GETINFO..) to get a list of all loaded Dlls from AIX. loadquery
193   // requires a large enough buffer.
194   uint8_t* buffer = NULL;
195   size_t buflen = 1024;
196   for (;;) {
197     buffer = (uint8_t*) ::realloc(buffer, buflen);
198     if (loadquery(L_GETINFO, buffer, buflen) == -1) {
199       if (errno == ENOMEM) {
200         buflen *= 2;
201       } else {
202         trcVerbose(&quot;loadquery failed (%d)&quot;, errno);
203         goto cleanup;
204       }
205     } else {
206       break;
207     }
208   }
209 
<span class="line-modified">210   trcVerbose(&quot;loadquery buffer size is %llu.&quot;, buflen);</span>
211 
212   // Iterate over the loadquery result. For details see sys/ldr.h on AIX.
213   ldi = (struct ld_info*) buffer;
214 
215   for (;;) {
216 
217     entry_t* e = (entry_t*) ::malloc(sizeof(entry_t));
218     if (!e) {
219       trcVerbose(&quot;OOM.&quot;);
220       goto cleanup;
221     }
222 
223     memset(e, 0, sizeof(entry_t));
224 
225     e-&gt;info.text = ldi-&gt;ldinfo_textorg;
226     e-&gt;info.text_len = ldi-&gt;ldinfo_textsize;
227     e-&gt;info.data = ldi-&gt;ldinfo_dataorg;
228     e-&gt;info.data_len = ldi-&gt;ldinfo_datasize;
229 
230     e-&gt;info.path = g_stringlist.add(ldi-&gt;ldinfo_filename);
</pre>
<hr />
<pre>
247     // Do we have a member name as well (see ldr.h)?
248     const char* p_mbr_name =
249       ldi-&gt;ldinfo_filename + strlen(ldi-&gt;ldinfo_filename) + 1;
250     if (*p_mbr_name) {
251       e-&gt;info.member = g_stringlist.add(p_mbr_name);
252       if (!e-&gt;info.member) {
253         trcVerbose(&quot;OOM.&quot;);
254         goto cleanup;
255       }
256     } else {
257       e-&gt;info.member = NULL;
258     }
259 
260     if (strcmp(e-&gt;info.shortname, &quot;libjvm.so&quot;) == 0) {
261       // Note that this, theoretically, is fuzzy. We may accidentally contain
262       // more than one libjvm.so. But that is improbable, so lets go with this
263       // solution.
264       e-&gt;info.is_in_vm = true;
265     }
266 
<span class="line-modified">267     trcVerbose(&quot;entry: %p %llu, %p %llu, %s %s %s, %d&quot;,</span>
268       e-&gt;info.text, e-&gt;info.text_len,
269       e-&gt;info.data, e-&gt;info.data_len,
270       e-&gt;info.path, e-&gt;info.shortname,
271       (e-&gt;info.member ? e-&gt;info.member : &quot;NULL&quot;),
272       e-&gt;info.is_in_vm
273     );
274 
275     // Add to list.
276     add_entry_to_list(e, &amp;new_list);
277 
278     // Next entry...
279     if (ldi-&gt;ldinfo_next) {
280       ldi = (struct ld_info*)(((char*)ldi) + ldi-&gt;ldinfo_next);
281     } else {
282       break;
283     }
284   }
285 
286   // We are done. All is well. Free old list and swap to new one.
287   if (g_first) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
190   const struct ld_info* ldi = NULL;
191 
192   // Call loadquery(L_GETINFO..) to get a list of all loaded Dlls from AIX. loadquery
193   // requires a large enough buffer.
194   uint8_t* buffer = NULL;
195   size_t buflen = 1024;
196   for (;;) {
197     buffer = (uint8_t*) ::realloc(buffer, buflen);
198     if (loadquery(L_GETINFO, buffer, buflen) == -1) {
199       if (errno == ENOMEM) {
200         buflen *= 2;
201       } else {
202         trcVerbose(&quot;loadquery failed (%d)&quot;, errno);
203         goto cleanup;
204       }
205     } else {
206       break;
207     }
208   }
209 
<span class="line-modified">210   trcVerbose(&quot;loadquery buffer size is &quot; SIZE_FORMAT &quot;.&quot;, buflen);</span>
211 
212   // Iterate over the loadquery result. For details see sys/ldr.h on AIX.
213   ldi = (struct ld_info*) buffer;
214 
215   for (;;) {
216 
217     entry_t* e = (entry_t*) ::malloc(sizeof(entry_t));
218     if (!e) {
219       trcVerbose(&quot;OOM.&quot;);
220       goto cleanup;
221     }
222 
223     memset(e, 0, sizeof(entry_t));
224 
225     e-&gt;info.text = ldi-&gt;ldinfo_textorg;
226     e-&gt;info.text_len = ldi-&gt;ldinfo_textsize;
227     e-&gt;info.data = ldi-&gt;ldinfo_dataorg;
228     e-&gt;info.data_len = ldi-&gt;ldinfo_datasize;
229 
230     e-&gt;info.path = g_stringlist.add(ldi-&gt;ldinfo_filename);
</pre>
<hr />
<pre>
247     // Do we have a member name as well (see ldr.h)?
248     const char* p_mbr_name =
249       ldi-&gt;ldinfo_filename + strlen(ldi-&gt;ldinfo_filename) + 1;
250     if (*p_mbr_name) {
251       e-&gt;info.member = g_stringlist.add(p_mbr_name);
252       if (!e-&gt;info.member) {
253         trcVerbose(&quot;OOM.&quot;);
254         goto cleanup;
255       }
256     } else {
257       e-&gt;info.member = NULL;
258     }
259 
260     if (strcmp(e-&gt;info.shortname, &quot;libjvm.so&quot;) == 0) {
261       // Note that this, theoretically, is fuzzy. We may accidentally contain
262       // more than one libjvm.so. But that is improbable, so lets go with this
263       // solution.
264       e-&gt;info.is_in_vm = true;
265     }
266 
<span class="line-modified">267     trcVerbose(&quot;entry: %p &quot; SIZE_FORMAT &quot;, %p &quot; SIZE_FORMAT &quot;, %s %s %s, %d&quot;,</span>
268       e-&gt;info.text, e-&gt;info.text_len,
269       e-&gt;info.data, e-&gt;info.data_len,
270       e-&gt;info.path, e-&gt;info.shortname,
271       (e-&gt;info.member ? e-&gt;info.member : &quot;NULL&quot;),
272       e-&gt;info.is_in_vm
273     );
274 
275     // Add to list.
276     add_entry_to_list(e, &amp;new_list);
277 
278     // Next entry...
279     if (ldi-&gt;ldinfo_next) {
280       ldi = (struct ld_info*)(((char*)ldi) + ldi-&gt;ldinfo_next);
281     } else {
282       break;
283     }
284   }
285 
286   // We are done. All is well. Free old list and swap to new one.
287   if (g_first) {
</pre>
</td>
</tr>
</table>
<center><a href="libodm_aix.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
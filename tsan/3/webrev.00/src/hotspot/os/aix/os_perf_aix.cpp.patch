diff a/src/hotspot/os/aix/os_perf_aix.cpp b/src/hotspot/os/aix/os_perf_aix.cpp
--- a/src/hotspot/os/aix/os_perf_aix.cpp
+++ b/src/hotspot/os/aix/os_perf_aix.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,10 +26,11 @@
 #include "jvm.h"
 #include "memory/allocation.inline.hpp"
 #include "os_aix.inline.hpp"
 #include "runtime/os.hpp"
 #include "runtime/os_perf.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 #include CPU_HEADER(vm_version_ext)
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -271,114 +272,16 @@
   n = vread_statdata(procfile, fmt, args);
   va_end(args);
   return n;
 }
 
-static FILE* open_statfile(void) {
-  FILE *f;
-
-  if ((f = fopen("/proc/stat", "r")) == NULL) {
-    static int haveWarned = 0;
-    if (!haveWarned) {
-      haveWarned = 1;
-    }
-  }
-  return f;
-}
-
-static void
-next_line(FILE *f) {
-  int c;
-  do {
-    c = fgetc(f);
-  } while (c != '\n' && c != EOF);
-}
-
 /**
- * Return the total number of ticks since the system was booted.
- * If the usedTicks parameter is not NULL, it will be filled with
- * the number of ticks spent on actual processes (user, system or
- * nice processes) since system boot. Note that this is the total number
- * of "executed" ticks on _all_ CPU:s, that is on a n-way system it is
- * n times the number of ticks that has passed in clock time.
- *
- * Returns a negative value if the reading of the ticks failed.
+ * on Linux we got the ticks related information from /proc/stat
+ * this does not work on AIX, libperfstat might be an alternative
  */
 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
-  FILE*         fh;
-  uint64_t      userTicks, niceTicks, systemTicks, idleTicks;
-  uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;
-  int           logical_cpu = -1;
-  const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;
-  int           n;
-
-  if ((fh = open_statfile()) == NULL) {
-    return OS_ERR;
-  }
-  if (-1 == which_logical_cpu) {
-    n = fscanf(fh, "cpu " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-            UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT,
-            &userTicks, &niceTicks, &systemTicks, &idleTicks,
-            &iowTicks, &irqTicks, &sirqTicks);
-  } else {
-    // Move to next line
-    next_line(fh);
-
-    // find the line for requested cpu faster to just iterate linefeeds?
-    for (int i = 0; i < which_logical_cpu; i++) {
-      next_line(fh);
-    }
-
-    n = fscanf(fh, "cpu%u " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-               UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT,
-               &logical_cpu, &userTicks, &niceTicks,
-               &systemTicks, &idleTicks, &iowTicks, &irqTicks, &sirqTicks);
-  }
-
-  fclose(fh);
-  if (n < expected_assign_count || logical_cpu != which_logical_cpu) {
-#ifdef DEBUG_LINUX_PROC_STAT
-    vm_fprintf(stderr, "[stat] read failed");
-#endif
-    return OS_ERR;
-  }
-
-#ifdef DEBUG_LINUX_PROC_STAT
-  vm_fprintf(stderr, "[stat] read "
-          UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " "
-          UINT64_FORMAT " " UINT64_FORMAT " " UINT64_FORMAT " \n",
-          userTicks, niceTicks, systemTicks, idleTicks,
-          iowTicks, irqTicks, sirqTicks);
-#endif
-
-  pticks->used       = userTicks + niceTicks;
-  pticks->usedKernel = systemTicks + irqTicks + sirqTicks;
-  pticks->total      = userTicks + niceTicks + systemTicks + idleTicks +
-                       iowTicks + irqTicks + sirqTicks;
-
-  return OS_OK;
-}
-
-
-static int get_systemtype(void) {
-  static int procEntriesType = UNDETECTED;
-  DIR *taskDir;
-
-  if (procEntriesType != UNDETECTED) {
-    return procEntriesType;
-  }
-
-  // Check whether we have a task subdirectory
-  if ((taskDir = opendir("/proc/self/task")) == NULL) {
-    procEntriesType = UNDETECTABLE;
-  } else {
-    // The task subdirectory exists; we're on a Linux >= 2.6 system
-    closedir(taskDir);
-    procEntriesType = LINUX26_NPTL;
-  }
-
-  return procEntriesType;
+  return OS_ERR;
 }
 
 /** read user and system ticks from a named procfile, assumed to be in 'stat' format then. */
 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
   return read_statdata(procfile, "%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u " UINT64_FORMAT " " UINT64_FORMAT,
@@ -388,30 +291,11 @@
 /**
  * Return the number of ticks spent in any of the processes belonging
  * to the JVM on any CPU.
  */
 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
-  uint64_t userTicks;
-  uint64_t systemTicks;
-
-  if (get_systemtype() != LINUX26_NPTL) {
-    return OS_ERR;
-  }
-
-  if (read_ticks("/proc/self/stat", &userTicks, &systemTicks) != 2) {
-    return OS_ERR;
-  }
-
-  // get the total
-  if (get_total_ticks(-1, pticks) != OS_OK) {
-    return OS_ERR;
-  }
-
-  pticks->used       = userTicks;
-  pticks->usedKernel = systemTicks;
-
-  return OS_OK;
+  return OS_ERR;
 }
 
 /**
  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
  * available time for user or system processes, 0.0 means the CPU uses all time
@@ -471,33 +355,11 @@
 
   return user_load;
 }
 
 static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
-  FILE *f;
-  va_list args;
-
-  va_start(args, fmt);
-
-  if ((f = open_statfile()) == NULL) {
-    va_end(args);
-    return OS_ERR;
-  }
-  for (;;) {
-    char line[80];
-    if (fgets(line, sizeof(line), f) != NULL) {
-      if (vsscanf(line, fmt, args) == 1) {
-        fclose(f);
-        va_end(args);
-        return OS_OK;
-      }
-    } else {
-        fclose(f);
-        va_end(args);
-        return OS_ERR;
-    }
-  }
+  return OS_ERR;
 }
 
 static int get_noof_context_switches(uint64_t* switches) {
   return parse_stat("ctxt " UINT64_FORMAT "\n", switches);
 }
@@ -507,55 +369,70 @@
   return parse_stat("btime " UINT64_FORMAT "\n", time);
 }
 
 static int perf_context_switch_rate(double* rate) {
   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
-  static uint64_t      lastTime;
+  static uint64_t      bootTime;
+  static uint64_t      lastTimeNanos;
   static uint64_t      lastSwitches;
   static double        lastRate;
 
-  uint64_t lt = 0;
+  uint64_t bt = 0;
   int res = 0;
 
-  if (lastTime == 0) {
+  // First time through bootTime will be zero.
+  if (bootTime == 0) {
     uint64_t tmp;
     if (get_boot_time(&tmp) < 0) {
       return OS_ERR;
     }
-    lt = tmp * 1000;
+    bt = tmp * 1000;
   }
 
   res = OS_OK;
 
   pthread_mutex_lock(&contextSwitchLock);
   {
 
     uint64_t sw;
     s8 t, d;
 
-    if (lastTime == 0) {
-      lastTime = lt;
+    if (bootTime == 0) {
+      // First interval is measured from boot time which is
+      // seconds since the epoch. Thereafter we measure the
+      // elapsed time using javaTimeNanos as it is monotonic-
+      // non-decreasing.
+      lastTimeNanos = os::javaTimeNanos();
+      t = os::javaTimeMillis();
+      d = t - bt;
+      // keep bootTime zero for now to use as a first-time-through flag
+    } else {
+      t = os::javaTimeNanos();
+      d = nanos_to_millis(t - lastTimeNanos);
     }
 
-    t = os::javaTimeMillis();
-    d = t - lastTime;
-
     if (d == 0) {
       *rate = lastRate;
-    } else if (!get_noof_context_switches(&sw)) {
+    } else if (get_noof_context_switches(&sw) == 0) {
       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
       lastRate     = *rate;
       lastSwitches = sw;
-      lastTime     = t;
+      if (bootTime != 0) {
+        lastTimeNanos = t;
+      }
     } else {
       *rate = 0;
       res   = OS_ERR;
     }
     if (*rate <= 0) {
       *rate = 0;
       lastRate = 0;
     }
+
+    if (bootTime == 0) {
+      bootTime = bt;
+    }
   }
   pthread_mutex_unlock(&contextSwitchLock);
 
   return res;
 }
@@ -580,16 +457,13 @@
   _counters.nProcs = os::active_processor_count();
   _counters.cpus = NULL;
 }
 
 bool CPUPerformanceInterface::CPUPerformance::initialize() {
-  size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);
-  _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);
-  if (NULL == _counters.cpus) {
-    return false;
-  }
-  memset(_counters.cpus, 0, tick_array_size);
+  size_t array_entry_count = _counters.nProcs + 1;
+  _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);
+  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));
 
   // For the CPU load total
   get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);
 
   // For each CPU
@@ -672,11 +546,11 @@
   _impl = NULL;
 }
 
 bool CPUPerformanceInterface::initialize() {
   _impl = new CPUPerformanceInterface::CPUPerformance();
-  return NULL == _impl ? false : _impl->initialize();
+  return _impl->initialize();
 }
 
 CPUPerformanceInterface::~CPUPerformanceInterface() {
   if (_impl != NULL) {
     delete _impl;
@@ -825,23 +699,21 @@
     while (fread(&dummy, 1, 1, fp) == 1) {
       size++;
     }
     if (size > 0) {
       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
-      if (cmdline != NULL) {
-        cmdline[0] = '\0';
-        if (fseek(fp, 0, SEEK_SET) == 0) {
-          if (fread(cmdline, 1, size, fp) == size) {
-            // the file has the arguments separated by '\0',
-            // so we translate '\0' to ' '
-            for (size_t i = 0; i < size; i++) {
-              if (cmdline[i] == '\0') {
-                cmdline[i] = ' ';
-              }
+      cmdline[0] = '\0';
+      if (fseek(fp, 0, SEEK_SET) == 0) {
+        if (fread(cmdline, 1, size, fp) == size) {
+          // the file has the arguments separated by '\0',
+          // so we translate '\0' to ' '
+          for (size_t i = 0; i < size; i++) {
+            if (cmdline[i] == '\0') {
+              cmdline[i] = ' ';
             }
-            cmdline[size] = '\0';
           }
+          cmdline[size] = '\0';
         }
       }
     }
     fclose(fp);
   }
@@ -927,11 +799,11 @@
   _iterator = NULL;
 }
 
 bool SystemProcessInterface::SystemProcesses::initialize() {
   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
-  return NULL == _iterator ? false : _iterator->initialize();
+  return _iterator->initialize();
 }
 
 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
   if (_iterator != NULL) {
     delete _iterator;
@@ -974,11 +846,11 @@
   _impl = NULL;
 }
 
 bool SystemProcessInterface::initialize() {
   _impl = new SystemProcessInterface::SystemProcesses();
-  return NULL == _impl ? false : _impl->initialize();
+  return _impl->initialize();
 }
 
 SystemProcessInterface::~SystemProcessInterface() {
   if (_impl != NULL) {
     delete _impl;
@@ -989,19 +861,15 @@
   _cpu_info = NULL;
 }
 
 bool CPUInformationInterface::initialize() {
   _cpu_info = new CPUInformation();
-  if (NULL == _cpu_info) {
-    return false;
-  }
   _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
   _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());
   _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());
   _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());
   _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());
-
   return true;
 }
 
 CPUInformationInterface::~CPUInformationInterface() {
   if (_cpu_info != NULL) {
@@ -1030,12 +898,11 @@
 
 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj<mtInternal> {
   friend class NetworkPerformanceInterface;
  private:
   NetworkPerformance();
-  NetworkPerformance(const NetworkPerformance& rhs); // no impl
-  NetworkPerformance& operator=(const NetworkPerformance& rhs); // no impl
+  NONCOPYABLE(NetworkPerformance);
   bool initialize();
   ~NetworkPerformance();
   int network_utilization(NetworkInterface** network_interfaces) const;
 };
 
@@ -1065,11 +932,11 @@
   }
 }
 
 bool NetworkPerformanceInterface::initialize() {
   _impl = new NetworkPerformanceInterface::NetworkPerformance();
-  return _impl != NULL && _impl->initialize();
+  return _impl->initialize();
 }
 
 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
   return _impl->network_utilization(network_interfaces);
 }

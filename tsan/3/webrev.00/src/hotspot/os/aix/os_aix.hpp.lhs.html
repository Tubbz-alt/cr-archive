<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/os_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2013, 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef OS_AIX_OS_AIX_HPP
 27 #define OS_AIX_OS_AIX_HPP
 28 
 29 // Information about the protection of the page at address &#39;0&#39; on this os.
 30 static bool zero_page_read_protected() { return false; }
 31 
 32 // Class Aix defines the interface to the Aix operating systems.
 33 
 34 class Aix {
 35   friend class os;
 36 
 37   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 38                                         // __sigaction(), signal() is loaded
 39   static struct sigaction *(*get_signal_action)(int);
 40 
 41   static void check_signal_handler(int sig);
 42 
 43  private:
 44 
 45   static julong _physical_memory;
 46   static pthread_t _main_thread;
<a name="1" id="anc1"></a><span class="line-removed"> 47   static Mutex* _createThread_lock;</span>
 48   static int _page_size;
 49 
 50   // -1 = uninitialized, 0 = AIX, 1 = OS/400 (PASE)
 51   static int _on_pase;
 52 
 53   // 0 = uninitialized, otherwise 16 bit number:
 54   //  lower 8 bit - minor version
 55   //  higher 8 bit - major version
 56   //  For AIX, e.g. 0x0601 for AIX 6.1
 57   //  for OS/400 e.g. 0x0504 for OS/400 V5R4
 58   static uint32_t _os_version;
 59 
 60   // -1 = uninitialized,
 61   //  0 - SPEC1170 not requested (XPG_SUS_ENV is OFF or not set)
 62   //  1 - SPEC1170 requested (XPG_SUS_ENV is ON)
 63   static int _xpg_sus_mode;
 64 
 65   // -1 = uninitialized,
 66   //  0 - EXTSHM=OFF or not set
 67   //  1 - EXTSHM=ON
 68   static int _extshm;
 69 
 70   static julong available_memory();
 71   static julong physical_memory() { return _physical_memory; }
 72   static void initialize_system_info();
 73 
 74   // OS recognitions (PASE/AIX, OS level) call this before calling any
 75   // one of Aix::on_pase(), Aix::os_version().
 76   static void initialize_os_info();
 77 
 78   // Scan environment for important settings which might effect the
 79   // VM. Trace out settings. Warn about invalid settings and/or
 80   // correct them.
 81   //
 82   // Must run after os::Aix::initialue_os_info().
 83   static void scan_environment();
 84 
 85   // Initialize libo4 (on PASE) and libperfstat (on AIX). Call this
 86   // before relying on functions from either lib, e.g. Aix::get_meminfo().
 87   static void initialize_libo4();
 88   static void initialize_libperfstat();
 89 
 90  public:
 91   static void init_thread_fpu_state();
 92   static pthread_t main_thread(void)                                { return _main_thread; }
<a name="2" id="anc2"></a><span class="line-removed"> 93   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }</span>
<span class="line-removed"> 94   static Mutex* createThread_lock(void)                             { return _createThread_lock; }</span>
 95   static void hotspot_sigmask(Thread* thread);
 96 
 97   // Given an address, returns the size of the page backing that address
 98   static size_t query_pagesize(void* p);
 99 
100   static int page_size(void) {
101     assert(_page_size != -1, &quot;not initialized&quot;);
102     return _page_size;
103   }
104 
105   static address   ucontext_get_pc(const ucontext_t* uc);
106   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
107   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
108   // Set PC into context. Needed for continuation after signal.
109   static void ucontext_set_pc(ucontext_t* uc, address pc);
110 
111   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
112 
113   // This boolean allows users to forward their own non-matching signals
114   // to JVM_handle_aix_signal, harmlessly.
115   static bool signal_handlers_are_installed;
116 
117   static int get_our_sigflags(int);
118   static void set_our_sigflags(int, int);
119   static void signal_sets_init();
120   static void install_signal_handlers();
121   static void set_signal_handler(int, bool);
122 
123   static sigset_t* unblocked_signals();
124   static sigset_t* vm_signals();
125 
126   // For signal-chaining
127   static struct sigaction *get_chained_signal_action(int sig);
128   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
129 
130   // libpthread version string
131   static void libpthread_init();
132 
133   // Function returns true if we run on OS/400 (pase), false if we run
134   // on AIX.
135   static bool on_pase() {
136     assert(_on_pase != -1, &quot;not initialized&quot;);
137     return _on_pase ? true : false;
138   }
139 
140   // Function returns true if we run on AIX, false if we run on OS/400
141   // (pase).
142   static bool on_aix() {
143     assert(_on_pase != -1, &quot;not initialized&quot;);
144     return _on_pase ? false : true;
145   }
146 
147   // Get 4 byte AIX kernel version number:
148   // highest 2 bytes: Version, Release
149   // if available: lowest 2 bytes: Tech Level, Service Pack.
150   static uint32_t os_version() {
151     assert(_os_version != 0, &quot;not initialized&quot;);
152     return _os_version;
153   }
154 
155   // 0 = uninitialized, otherwise 16 bit number:
156   // lower 8 bit - minor version
157   // higher 8 bit - major version
158   // For AIX, e.g. 0x0601 for AIX 6.1
159   // for OS/400 e.g. 0x0504 for OS/400 V5R4
160   static int os_version_short() {
161     return os_version() &gt;&gt; 16;
162   }
163 
164   // Convenience method: returns true if running on PASE V5R4 or older.
165   static bool on_pase_V5R4_or_older() {
166     return on_pase() &amp;&amp; os_version_short() &lt;= 0x0504;
167   }
168 
169   // Convenience method: returns true if running on AIX 5.3 or older.
170   static bool on_aix_53_or_older() {
171     return on_aix() &amp;&amp; os_version_short() &lt;= 0x0503;
172   }
173 
174   // Returns true if we run in SPEC1170 compliant mode (XPG_SUS_ENV=ON).
175   static bool xpg_sus_mode() {
176     assert(_xpg_sus_mode != -1, &quot;not initialized&quot;);
177     return _xpg_sus_mode;
178   }
179 
180   // Returns true if EXTSHM=ON.
181   static bool extshm() {
182     assert(_extshm != -1, &quot;not initialized&quot;);
183     return _extshm;
184   }
185 
186   // result struct for get_meminfo()
187   struct meminfo_t {
188 
189     // Amount of virtual memory (in units of 4 KB pages)
190     unsigned long long virt_total;
191 
192     // Amount of real memory, in bytes
193     unsigned long long real_total;
194 
195     // Amount of free real memory, in bytes
196     unsigned long long real_free;
197 
198     // Total amount of paging space, in bytes
199     unsigned long long pgsp_total;
200 
201     // Amount of free paging space, in bytes
202     unsigned long long pgsp_free;
203 
204   };
205 
206   // Functions to retrieve memory information on AIX, PASE.
207   // (on AIX, using libperfstat, on PASE with libo4.so).
208   // Returns true if ok, false if error.
209   static bool get_meminfo(meminfo_t* pmi);
210 
211 };
212 
213 #endif // OS_AIX_OS_AIX_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
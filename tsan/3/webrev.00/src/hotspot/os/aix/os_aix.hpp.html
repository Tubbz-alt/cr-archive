<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/aix/os_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2013, 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef OS_AIX_OS_AIX_HPP
 27 #define OS_AIX_OS_AIX_HPP
 28 
 29 // Information about the protection of the page at address &#39;0&#39; on this os.
 30 static bool zero_page_read_protected() { return false; }
 31 
 32 // Class Aix defines the interface to the Aix operating systems.
 33 
 34 class Aix {
 35   friend class os;
 36 
 37   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 38                                         // __sigaction(), signal() is loaded
 39   static struct sigaction *(*get_signal_action)(int);
 40 
 41   static void check_signal_handler(int sig);
 42 
 43  private:
 44 
 45   static julong _physical_memory;
 46   static pthread_t _main_thread;
 47   static int _page_size;
 48 
 49   // -1 = uninitialized, 0 = AIX, 1 = OS/400 (PASE)
 50   static int _on_pase;
 51 
 52   // 0 = uninitialized, otherwise 16 bit number:
 53   //  lower 8 bit - minor version
 54   //  higher 8 bit - major version
 55   //  For AIX, e.g. 0x0601 for AIX 6.1
 56   //  for OS/400 e.g. 0x0504 for OS/400 V5R4
 57   static uint32_t _os_version;
 58 
 59   // -1 = uninitialized,
 60   //  0 - SPEC1170 not requested (XPG_SUS_ENV is OFF or not set)
 61   //  1 - SPEC1170 requested (XPG_SUS_ENV is ON)
 62   static int _xpg_sus_mode;
 63 
 64   // -1 = uninitialized,
 65   //  0 - EXTSHM=OFF or not set
 66   //  1 - EXTSHM=ON
 67   static int _extshm;
 68 
 69   static julong available_memory();
 70   static julong physical_memory() { return _physical_memory; }
 71   static void initialize_system_info();
 72 
 73   // OS recognitions (PASE/AIX, OS level) call this before calling any
 74   // one of Aix::on_pase(), Aix::os_version().
 75   static void initialize_os_info();
 76 
 77   // Scan environment for important settings which might effect the
 78   // VM. Trace out settings. Warn about invalid settings and/or
 79   // correct them.
 80   //
 81   // Must run after os::Aix::initialue_os_info().
 82   static void scan_environment();
 83 
 84   // Initialize libo4 (on PASE) and libperfstat (on AIX). Call this
 85   // before relying on functions from either lib, e.g. Aix::get_meminfo().
 86   static void initialize_libo4();
 87   static void initialize_libperfstat();
 88 
 89  public:
 90   static void init_thread_fpu_state();
 91   static pthread_t main_thread(void)                                { return _main_thread; }
 92   static void hotspot_sigmask(Thread* thread);
 93 
 94   // Given an address, returns the size of the page backing that address
 95   static size_t query_pagesize(void* p);
 96 
 97   static int page_size(void) {
 98     assert(_page_size != -1, &quot;not initialized&quot;);
 99     return _page_size;
100   }
101 
102   static address   ucontext_get_pc(const ucontext_t* uc);
103   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
104   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
105   // Set PC into context. Needed for continuation after signal.
106   static void ucontext_set_pc(ucontext_t* uc, address pc);
107 
108   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
109 
110   // This boolean allows users to forward their own non-matching signals
111   // to JVM_handle_aix_signal, harmlessly.
112   static bool signal_handlers_are_installed;
113 
114   static int get_our_sigflags(int);
115   static void set_our_sigflags(int, int);
116   static void signal_sets_init();
117   static void install_signal_handlers();
118   static void set_signal_handler(int, bool);
119 
120   static sigset_t* unblocked_signals();
121   static sigset_t* vm_signals();
122 
123   // For signal-chaining
124   static struct sigaction *get_chained_signal_action(int sig);
125   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
126 
127   // libpthread version string
128   static void libpthread_init();
129 
130   // Function returns true if we run on OS/400 (pase), false if we run
131   // on AIX.
132   static bool on_pase() {
133     assert(_on_pase != -1, &quot;not initialized&quot;);
134     return _on_pase ? true : false;
135   }
136 
137   // Function returns true if we run on AIX, false if we run on OS/400
138   // (pase).
139   static bool on_aix() {
140     assert(_on_pase != -1, &quot;not initialized&quot;);
141     return _on_pase ? false : true;
142   }
143 
144   // Get 4 byte AIX kernel version number:
145   // highest 2 bytes: Version, Release
146   // if available: lowest 2 bytes: Tech Level, Service Pack.
147   static uint32_t os_version() {
148     assert(_os_version != 0, &quot;not initialized&quot;);
149     return _os_version;
150   }
151 
152   // 0 = uninitialized, otherwise 16 bit number:
153   // lower 8 bit - minor version
154   // higher 8 bit - major version
155   // For AIX, e.g. 0x0601 for AIX 6.1
156   // for OS/400 e.g. 0x0504 for OS/400 V5R4
157   static int os_version_short() {
158     return os_version() &gt;&gt; 16;
159   }
160 
161   // Convenience method: returns true if running on PASE V5R4 or older.
162   static bool on_pase_V5R4_or_older() {
163     return on_pase() &amp;&amp; os_version_short() &lt;= 0x0504;
164   }
165 
166   // Convenience method: returns true if running on AIX 5.3 or older.
167   static bool on_aix_53_or_older() {
168     return on_aix() &amp;&amp; os_version_short() &lt;= 0x0503;
169   }
170 
171   // Returns true if we run in SPEC1170 compliant mode (XPG_SUS_ENV=ON).
172   static bool xpg_sus_mode() {
173     assert(_xpg_sus_mode != -1, &quot;not initialized&quot;);
174     return _xpg_sus_mode;
175   }
176 
177   // Returns true if EXTSHM=ON.
178   static bool extshm() {
179     assert(_extshm != -1, &quot;not initialized&quot;);
180     return _extshm;
181   }
182 
183   // result struct for get_meminfo()
184   struct meminfo_t {
185 
186     // Amount of virtual memory (in units of 4 KB pages)
187     unsigned long long virt_total;
188 
189     // Amount of real memory, in bytes
190     unsigned long long real_total;
191 
192     // Amount of free real memory, in bytes
193     unsigned long long real_free;
194 
195     // Total amount of paging space, in bytes
196     unsigned long long pgsp_total;
197 
198     // Amount of free paging space, in bytes
199     unsigned long long pgsp_free;
200 
201   };
202 
203   // Functions to retrieve memory information on AIX, PASE.
204   // (on AIX, using libperfstat, on PASE with libo4.so).
205   // Returns true if ok, false if error.
206   static bool get_meminfo(meminfo_t* pmi);
207 
208 };
209 
210 #endif // OS_AIX_OS_AIX_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/loadlib_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 
 27 // Implementation of LoadedLibraries and friends
 28 
 29 // Ultimately this just uses loadquery()
 30 // See:
 31 // http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp
 32 //      ?topic=/com.ibm.aix.basetechref/doc/basetrf1/loadquery.htm
 33 
 34 #include &quot;loadlib_aix.hpp&quot;
 35 #include &quot;misc_aix.hpp&quot;
 36 #include &quot;porting_aix.hpp&quot;
 37 #include &quot;utilities/debug.hpp&quot;
 38 #include &quot;utilities/ostream.hpp&quot;
 39 
 40 // For loadquery()
 41 #include &lt;sys/ldr.h&gt;
 42 
 43 // Use raw malloc instead of os::malloc - this code gets used for error reporting.
 44 
 45 // A class to &quot;intern&quot; eternal strings.
 46 // TODO: similar coding exists in AIX version of dladdr and potentially elsewhere: consolidate!
 47 class StringList {
 48 
 49   char** _list;
 50   int _cap;
 51   int _num;
 52 
 53   // Enlarge list. If oom, leave old list intact and return false.
 54   bool enlarge() {
 55     int cap2 = _cap + 64;
 56     char** l2 = (char**) ::realloc(_list, sizeof(char*) * cap2);
 57     if (!l2) {
 58       return false;
 59     }
 60     _list = l2;
 61     _cap = cap2;
 62     return true;
 63   }
 64 
 65   // Append string to end of list.
 66   // Returns NULL if oom.
 67   char* append(const char* s) {
 68     if (_cap == _num) {
 69       if (!enlarge()) {
 70         return NULL;
 71       }
 72     }
 73     assert0(_cap &gt; _num);
 74     char* s2 = ::strdup(s);
 75     if (!s2) {
 76       return NULL;
 77     }
 78     _list[_num] = s2;
 79     trcVerbose(&quot;StringDir: added %s at pos %d&quot;, s2, _num);
 80     _num ++;
 81     return s2;
 82   }
 83 
 84 public:
 85 
 86   StringList()
 87     : _list(NULL)
 88     , _cap(0)
 89     , _num(0)
 90   {}
 91 
 92   // String is copied into the list; pointer to copy is returned.
 93   // Returns NULL if oom.
 94   char* add (const char* s) {
 95     for (int i = 0; i &lt; _num; i++) {
 96       if (strcmp(_list[i], s) == 0) {
 97         return _list[i];
 98       }
 99     }
100     return append(s);
101   }
102 
103 };
104 
105 static StringList g_stringlist;
106 
107 //////////////////////
108 
109 // Entries are kept in a linked list ordered by text address. Entries are not
110 // eternal - this list is rebuilt on every reload.
111 // Note that we do not hand out those entries, but copies of them.
112 
113 struct entry_t {
114   entry_t* next;
115   loaded_module_t info;
116 };
117 
118 static void print_entry(const entry_t* e, outputStream* os) {
119   const loaded_module_t* const lm = &amp;(e-&gt;info);
120   os-&gt;print(&quot; %c text: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT
121             &quot;, data: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; &quot;
122             &quot;%s&quot;,
123       (lm-&gt;is_in_vm ? &#39;*&#39; : &#39; &#39;),
124       lm-&gt;text, (uintptr_t)lm-&gt;text + lm-&gt;text_len,
125       lm-&gt;data, (uintptr_t)lm-&gt;data + lm-&gt;data_len,
126       lm-&gt;path);
127   if (lm-&gt;member) {
128     os-&gt;print(&quot;(%s)&quot;, lm-&gt;member);
129   }
130 }
131 
132 static entry_t* g_first = NULL;
133 
134 static entry_t* find_entry_for_text_address(const void* p) {
135   for (entry_t* e = g_first; e; e = e-&gt;next) {
136     if ((uintptr_t)p &gt;= (uintptr_t)e-&gt;info.text &amp;&amp;
137         (uintptr_t)p &lt; ((uintptr_t)e-&gt;info.text + e-&gt;info.text_len)) {
138       return e;
139     }
140   }
141   return NULL;
142 }
143 
144 static entry_t* find_entry_for_data_address(const void* p) {
145   for (entry_t* e = g_first; e; e = e-&gt;next) {
146     if ((uintptr_t)p &gt;= (uintptr_t)e-&gt;info.data &amp;&amp;
147         (uintptr_t)p &lt; ((uintptr_t)e-&gt;info.data + e-&gt;info.data_len)) {
148       return e;
149     }
150   }
151   return NULL;
152 }
153 
154 // Adds a new entry to the list (ordered by text address ascending).
155 static void add_entry_to_list(entry_t* e, entry_t** start) {
156   entry_t* last = NULL;
157   entry_t* e2 = *start;
158   while (e2 &amp;&amp; e2-&gt;info.text &lt; e-&gt;info.text) {
159     last = e2;
160     e2 = e2-&gt;next;
161   }
162   if (last) {
163     last-&gt;next = e;
164   } else {
165     *start = e;
166   }
167   e-&gt;next = e2;
168 }
169 
170 static void free_entry_list(entry_t** start) {
171   entry_t* e = *start;
172   while (e) {
173     entry_t* const e2 = e-&gt;next;
174     ::free(e);
175     e = e2;
176   }
177   *start = NULL;
178 }
179 
180 
181 // Rebuild the internal module table. If an error occurs, old table remains
182 // unchanged.
183 static bool reload_table() {
184 
185   bool rc = false;
186 
187   trcVerbose(&quot;reload module table...&quot;);
188 
189   entry_t* new_list = NULL;
190   const struct ld_info* ldi = NULL;
191 
192   // Call loadquery(L_GETINFO..) to get a list of all loaded Dlls from AIX. loadquery
193   // requires a large enough buffer.
194   uint8_t* buffer = NULL;
195   size_t buflen = 1024;
196   for (;;) {
197     buffer = (uint8_t*) ::realloc(buffer, buflen);
198     if (loadquery(L_GETINFO, buffer, buflen) == -1) {
199       if (errno == ENOMEM) {
200         buflen *= 2;
201       } else {
202         trcVerbose(&quot;loadquery failed (%d)&quot;, errno);
203         goto cleanup;
204       }
205     } else {
206       break;
207     }
208   }
209 
<a name="2" id="anc2"></a><span class="line-modified">210   trcVerbose(&quot;loadquery buffer size is %llu.&quot;, buflen);</span>
211 
212   // Iterate over the loadquery result. For details see sys/ldr.h on AIX.
213   ldi = (struct ld_info*) buffer;
214 
215   for (;;) {
216 
217     entry_t* e = (entry_t*) ::malloc(sizeof(entry_t));
218     if (!e) {
219       trcVerbose(&quot;OOM.&quot;);
220       goto cleanup;
221     }
222 
223     memset(e, 0, sizeof(entry_t));
224 
225     e-&gt;info.text = ldi-&gt;ldinfo_textorg;
226     e-&gt;info.text_len = ldi-&gt;ldinfo_textsize;
227     e-&gt;info.data = ldi-&gt;ldinfo_dataorg;
228     e-&gt;info.data_len = ldi-&gt;ldinfo_datasize;
229 
230     e-&gt;info.path = g_stringlist.add(ldi-&gt;ldinfo_filename);
231     if (!e-&gt;info.path) {
232       trcVerbose(&quot;OOM.&quot;);
233       goto cleanup;
234     }
235 
236     // Extract short name
237     {
238       const char* p = strrchr(e-&gt;info.path, &#39;/&#39;);
239       if (p) {
240         p ++;
241         e-&gt;info.shortname = p;
242       } else {
243         e-&gt;info.shortname = e-&gt;info.path;
244       }
245     }
246 
247     // Do we have a member name as well (see ldr.h)?
248     const char* p_mbr_name =
249       ldi-&gt;ldinfo_filename + strlen(ldi-&gt;ldinfo_filename) + 1;
250     if (*p_mbr_name) {
251       e-&gt;info.member = g_stringlist.add(p_mbr_name);
252       if (!e-&gt;info.member) {
253         trcVerbose(&quot;OOM.&quot;);
254         goto cleanup;
255       }
256     } else {
257       e-&gt;info.member = NULL;
258     }
259 
260     if (strcmp(e-&gt;info.shortname, &quot;libjvm.so&quot;) == 0) {
261       // Note that this, theoretically, is fuzzy. We may accidentally contain
262       // more than one libjvm.so. But that is improbable, so lets go with this
263       // solution.
264       e-&gt;info.is_in_vm = true;
265     }
266 
<a name="3" id="anc3"></a><span class="line-modified">267     trcVerbose(&quot;entry: %p %llu, %p %llu, %s %s %s, %d&quot;,</span>
268       e-&gt;info.text, e-&gt;info.text_len,
269       e-&gt;info.data, e-&gt;info.data_len,
270       e-&gt;info.path, e-&gt;info.shortname,
271       (e-&gt;info.member ? e-&gt;info.member : &quot;NULL&quot;),
272       e-&gt;info.is_in_vm
273     );
274 
275     // Add to list.
276     add_entry_to_list(e, &amp;new_list);
277 
278     // Next entry...
279     if (ldi-&gt;ldinfo_next) {
280       ldi = (struct ld_info*)(((char*)ldi) + ldi-&gt;ldinfo_next);
281     } else {
282       break;
283     }
284   }
285 
286   // We are done. All is well. Free old list and swap to new one.
287   if (g_first) {
288     free_entry_list(&amp;g_first);
289   }
290   g_first = new_list;
291   new_list = NULL;
292 
293   rc = true;
294 
295 cleanup:
296 
297   if (new_list) {
298     free_entry_list(&amp;new_list);
299   }
300 
301   ::free(buffer);
302 
303   return rc;
304 
305 } // end LoadedLibraries::reload()
306 
307 
308 ///////////////////////////////////////////////////////////////////////////////
309 // Externals
310 
311 static MiscUtils::CritSect g_cs;
312 
313 // Rebuild the internal module table. If an error occurs, old table remains
314 // unchanged.
315 bool LoadedLibraries::reload() {
316   MiscUtils::AutoCritSect lck(&amp;g_cs);
317   return reload_table();
318 }
319 
320 void LoadedLibraries::print(outputStream* os) {
321   MiscUtils::AutoCritSect lck(&amp;g_cs);
322   if (!g_first) {
323     reload_table();
324   }
325   for (entry_t* e = g_first; e; e = e-&gt;next) {
326     print_entry(e, os);
327     os-&gt;cr();
328   }
329 }
330 
331 bool LoadedLibraries::find_for_text_address(const void* p,
332                                             loaded_module_t* info) {
333   MiscUtils::AutoCritSect lck(&amp;g_cs);
334   if (!g_first) {
335     reload_table();
336   }
337   const entry_t* const e = find_entry_for_text_address(p);
338   if (e) {
339     if (info) {
340       *info = e-&gt;info;
341     }
342     return true;
343   }
344   return false;
345 }
346 
347 
348 bool LoadedLibraries::find_for_data_address (
349   const void* p,
350   loaded_module_t* info // optional. can be NULL:
351 ) {
352   MiscUtils::AutoCritSect lck(&amp;g_cs);
353   if (!g_first) {
354     reload_table();
355   }
356   const entry_t* const e = find_entry_for_data_address(p);
357   if (e) {
358     if (info) {
359       *info = e-&gt;info;
360     }
361     return true;
362   }
363   return false;
364 }
365 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
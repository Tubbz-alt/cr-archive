<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/os_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 // According to the AIX OS doc #pragma alloca must be used
  27 // with C++ compiler before referencing the function alloca()
  28 #pragma alloca
  29 
  30 // no precompiled headers
  31 #include &quot;jvm.h&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/systemDictionary.hpp&quot;
  34 #include &quot;classfile/vmSymbols.hpp&quot;
  35 #include &quot;code/icBuffer.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  40 #include &quot;logging/logStream.hpp&quot;</span>
  41 #include &quot;libo4.hpp&quot;
  42 #include &quot;libperfstat_aix.hpp&quot;
  43 #include &quot;libodm_aix.hpp&quot;
  44 #include &quot;loadlib_aix.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;misc_aix.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;os_aix.inline.hpp&quot;
  50 #include &quot;os_share_aix.hpp&quot;
  51 #include &quot;porting_aix.hpp&quot;
  52 #include &quot;prims/jniFastGetField.hpp&quot;
  53 #include &quot;prims/jvm_misc.hpp&quot;
  54 #include &quot;runtime/arguments.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/extendedPC.hpp&quot;
  57 #include &quot;runtime/globals.hpp&quot;
  58 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  59 #include &quot;runtime/java.hpp&quot;
  60 #include &quot;runtime/javaCalls.hpp&quot;
  61 #include &quot;runtime/mutexLocker.hpp&quot;
  62 #include &quot;runtime/objectMonitor.hpp&quot;
<a name="3" id="anc3"></a>
  63 #include &quot;runtime/os.hpp&quot;
  64 #include &quot;runtime/osThread.hpp&quot;
  65 #include &quot;runtime/perfMemory.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/statSampler.hpp&quot;
  68 #include &quot;runtime/stubRoutines.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/threadCritical.hpp&quot;
  71 #include &quot;runtime/timer.hpp&quot;
  72 #include &quot;runtime/vm_version.hpp&quot;
  73 #include &quot;services/attachListener.hpp&quot;
  74 #include &quot;services/runtimeService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/decoder.hpp&quot;
  77 #include &quot;utilities/defaultStream.hpp&quot;
  78 #include &quot;utilities/events.hpp&quot;
  79 #include &quot;utilities/growableArray.hpp&quot;
  80 #include &quot;utilities/vmError.hpp&quot;
  81 
  82 // put OS-includes here (sorted alphabetically)
  83 #include &lt;errno.h&gt;
  84 #include &lt;fcntl.h&gt;
  85 #include &lt;inttypes.h&gt;
  86 #include &lt;poll.h&gt;
  87 #include &lt;procinfo.h&gt;
  88 #include &lt;pthread.h&gt;
  89 #include &lt;pwd.h&gt;
  90 #include &lt;semaphore.h&gt;
  91 #include &lt;signal.h&gt;
  92 #include &lt;stdint.h&gt;
  93 #include &lt;stdio.h&gt;
  94 #include &lt;string.h&gt;
  95 #include &lt;unistd.h&gt;
  96 #include &lt;sys/ioctl.h&gt;
  97 #include &lt;sys/ipc.h&gt;
  98 #include &lt;sys/mman.h&gt;
  99 #include &lt;sys/resource.h&gt;
 100 #include &lt;sys/select.h&gt;
 101 #include &lt;sys/shm.h&gt;
 102 #include &lt;sys/socket.h&gt;
 103 #include &lt;sys/stat.h&gt;
 104 #include &lt;sys/sysinfo.h&gt;
 105 #include &lt;sys/systemcfg.h&gt;
 106 #include &lt;sys/time.h&gt;
 107 #include &lt;sys/times.h&gt;
 108 #include &lt;sys/types.h&gt;
 109 #include &lt;sys/utsname.h&gt;
 110 #include &lt;sys/vminfo.h&gt;
 111 #include &lt;sys/wait.h&gt;
 112 
 113 // Missing prototypes for various system APIs.
 114 extern &quot;C&quot;
 115 int mread_real_time(timebasestruct_t *t, size_t size_of_timebasestruct_t);
 116 
 117 #if !defined(_AIXVERSION_610)
 118 extern &quot;C&quot; int getthrds64(pid_t, struct thrdentry64*, int, tid64_t*, int);
 119 extern &quot;C&quot; int getprocs64(procentry64*, int, fdsinfo*, int, pid_t*, int);
 120 extern &quot;C&quot; int getargs(procsinfo*, int, char*, int);
 121 #endif
 122 
 123 #define MAX_PATH (2 * K)
 124 
 125 // for timer info max values which include all bits
 126 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 127 // for multipage initialization error analysis (in &#39;g_multipage_error&#39;)
 128 #define ERROR_MP_OS_TOO_OLD                          100
 129 #define ERROR_MP_EXTSHM_ACTIVE                       101
 130 #define ERROR_MP_VMGETINFO_FAILED                    102
 131 #define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103
 132 
 133 // excerpts from systemcfg.h that might be missing on older os levels
<a name="4" id="anc4"></a>











 134 #ifndef PV_7
 135   #define PV_7 0x200000          /* Power PC 7 */
 136 #endif
 137 #ifndef PV_7_Compat
 138   #define PV_7_Compat 0x208000   /* Power PC 7 */
 139 #endif
 140 #ifndef PV_8
 141   #define PV_8 0x300000          /* Power PC 8 */
 142 #endif
 143 #ifndef PV_8_Compat
 144   #define PV_8_Compat 0x308000   /* Power PC 8 */
 145 #endif
<a name="5" id="anc5"></a><span class="line-added"> 146 #ifndef PV_9</span>
<span class="line-added"> 147   #define PV_9 0x400000          /* Power PC 9 */</span>
<span class="line-added"> 148 #endif</span>
<span class="line-added"> 149 #ifndef PV_9_Compat</span>
<span class="line-added"> 150   #define PV_9_Compat  0x408000  /* Power PC 9 */</span>
<span class="line-added"> 151 #endif</span>
<span class="line-added"> 152 </span>
 153 
 154 static address resolve_function_descriptor_to_code_pointer(address p);
 155 
 156 static void vmembk_print_on(outputStream* os);
 157 
 158 ////////////////////////////////////////////////////////////////////////////////
 159 // global variables (for a description see os_aix.hpp)
 160 
 161 julong    os::Aix::_physical_memory = 0;
 162 
 163 pthread_t os::Aix::_main_thread = ((pthread_t)0);
 164 int       os::Aix::_page_size = -1;
 165 
 166 // -1 = uninitialized, 0 if AIX, 1 if OS/400 pase
 167 int       os::Aix::_on_pase = -1;
 168 
 169 // 0 = uninitialized, otherwise 32 bit number:
 170 //  0xVVRRTTSS
 171 //  VV - major version
 172 //  RR - minor version
 173 //  TT - tech level, if known, 0 otherwise
 174 //  SS - service pack, if known, 0 otherwise
 175 uint32_t  os::Aix::_os_version = 0;
 176 
 177 // -1 = uninitialized, 0 - no, 1 - yes
 178 int       os::Aix::_xpg_sus_mode = -1;
 179 
 180 // -1 = uninitialized, 0 - no, 1 - yes
 181 int       os::Aix::_extshm = -1;
 182 
 183 ////////////////////////////////////////////////////////////////////////////////
 184 // local variables
 185 
 186 static volatile jlong max_real_time = 0;
 187 static jlong    initial_time_count = 0;
 188 static int      clock_tics_per_sec = 100;
 189 static sigset_t check_signal_done;         // For diagnostics to print a message once (see run_periodic_checks)
 190 static bool     check_signals      = true;
 191 static int      SR_signum          = SIGUSR2; // Signal used to suspend/resume a thread (must be &gt; SIGSEGV, see 4355769)
 192 static sigset_t SR_sigset;
 193 
 194 // Process break recorded at startup.
 195 static address g_brk_at_startup = NULL;
 196 
 197 // This describes the state of multipage support of the underlying
 198 // OS. Note that this is of no interest to the outsize world and
 199 // therefore should not be defined in AIX class.
 200 //
 201 // AIX supports four different page sizes - 4K, 64K, 16MB, 16GB. The
 202 // latter two (16M &quot;large&quot; resp. 16G &quot;huge&quot; pages) require special
 203 // setup and are normally not available.
 204 //
 205 // AIX supports multiple page sizes per process, for:
 206 //  - Stack (of the primordial thread, so not relevant for us)
 207 //  - Data - data, bss, heap, for us also pthread stacks
 208 //  - Text - text code
 209 //  - shared memory
 210 //
 211 // Default page sizes can be set via linker options (-bdatapsize, -bstacksize, ...)
 212 // and via environment variable LDR_CNTRL (DATAPSIZE, STACKPSIZE, ...).
 213 //
 214 // For shared memory, page size can be set dynamically via
 215 // shmctl(). Different shared memory regions can have different page
 216 // sizes.
 217 //
 218 // More information can be found at AIBM info center:
 219 //   http://publib.boulder.ibm.com/infocenter/aix/v6r1/index.jsp?topic=/com.ibm.aix.prftungd/doc/prftungd/multiple_page_size_app_support.htm
 220 //
 221 static struct {
 222   size_t pagesize;            // sysconf _SC_PAGESIZE (4K)
 223   size_t datapsize;           // default data page size (LDR_CNTRL DATAPSIZE)
 224   size_t shmpsize;            // default shared memory page size (LDR_CNTRL SHMPSIZE)
 225   size_t pthr_stack_pagesize; // stack page size of pthread threads
 226   size_t textpsize;           // default text page size (LDR_CNTRL STACKPSIZE)
 227   bool can_use_64K_pages;     // True if we can alloc 64K pages dynamically with Sys V shm.
 228   bool can_use_16M_pages;     // True if we can alloc 16M pages dynamically with Sys V shm.
 229   int error;                  // Error describing if something went wrong at multipage init.
 230 } g_multipage_support = {
 231   (size_t) -1,
 232   (size_t) -1,
 233   (size_t) -1,
 234   (size_t) -1,
 235   (size_t) -1,
 236   false, false,
 237   0
 238 };
 239 
 240 // We must not accidentally allocate memory close to the BRK - even if
 241 // that would work - because then we prevent the BRK segment from
 242 // growing which may result in a malloc OOM even though there is
 243 // enough memory. The problem only arises if we shmat() or mmap() at
 244 // a specific wish address, e.g. to place the heap in a
 245 // compressed-oops-friendly way.
 246 static bool is_close_to_brk(address a) {
 247   assert0(g_brk_at_startup != NULL);
 248   if (a &gt;= g_brk_at_startup &amp;&amp;
 249       a &lt; (g_brk_at_startup + MaxExpectedDataSegmentSize)) {
 250     return true;
 251   }
 252   return false;
 253 }
 254 
 255 julong os::available_memory() {
 256   return Aix::available_memory();
 257 }
 258 
 259 julong os::Aix::available_memory() {
 260   // Avoid expensive API call here, as returned value will always be null.
 261   if (os::Aix::on_pase()) {
 262     return 0x0LL;
 263   }
 264   os::Aix::meminfo_t mi;
 265   if (os::Aix::get_meminfo(&amp;mi)) {
 266     return mi.real_free;
 267   } else {
 268     return ULONG_MAX;
 269   }
 270 }
 271 
 272 julong os::physical_memory() {
 273   return Aix::physical_memory();
 274 }
 275 
 276 // Return true if user is running as root.
 277 
 278 bool os::have_special_privileges() {
 279   static bool init = false;
 280   static bool privileges = false;
 281   if (!init) {
 282     privileges = (getuid() != geteuid()) || (getgid() != getegid());
 283     init = true;
 284   }
 285   return privileges;
 286 }
 287 
 288 // Helper function, emulates disclaim64 using multiple 32bit disclaims
 289 // because we cannot use disclaim64() on AS/400 and old AIX releases.
 290 static bool my_disclaim64(char* addr, size_t size) {
 291 
 292   if (size == 0) {
 293     return true;
 294   }
 295 
 296   // Maximum size 32bit disclaim() accepts. (Theoretically 4GB, but I just do not trust that.)
 297   const unsigned int maxDisclaimSize = 0x40000000;
 298 
 299   const unsigned int numFullDisclaimsNeeded = (size / maxDisclaimSize);
 300   const unsigned int lastDisclaimSize = (size % maxDisclaimSize);
 301 
 302   char* p = addr;
 303 
 304   for (int i = 0; i &lt; numFullDisclaimsNeeded; i ++) {
 305     if (::disclaim(p, maxDisclaimSize, DISCLAIM_ZEROMEM) != 0) {
 306       trcVerbose(&quot;Cannot disclaim %p - %p (errno %d)\n&quot;, p, p + maxDisclaimSize, errno);
 307       return false;
 308     }
 309     p += maxDisclaimSize;
 310   }
 311 
 312   if (lastDisclaimSize &gt; 0) {
 313     if (::disclaim(p, lastDisclaimSize, DISCLAIM_ZEROMEM) != 0) {
 314       trcVerbose(&quot;Cannot disclaim %p - %p (errno %d)\n&quot;, p, p + lastDisclaimSize, errno);
 315       return false;
 316     }
 317   }
 318 
 319   return true;
 320 }
 321 
 322 // Cpu architecture string
 323 #if defined(PPC32)
 324 static char cpu_arch[] = &quot;ppc&quot;;
 325 #elif defined(PPC64)
 326 static char cpu_arch[] = &quot;ppc64&quot;;
 327 #else
 328 #error Add appropriate cpu_arch setting
 329 #endif
 330 
 331 // Wrap the function &quot;vmgetinfo&quot; which is not available on older OS releases.
 332 static int checked_vmgetinfo(void *out, int command, int arg) {
 333   if (os::Aix::on_pase() &amp;&amp; os::Aix::os_version_short() &lt; 0x0601) {
 334     guarantee(false, &quot;cannot call vmgetinfo on AS/400 older than V6R1&quot;);
 335   }
 336   return ::vmgetinfo(out, command, arg);
 337 }
 338 
 339 // Given an address, returns the size of the page backing that address.
 340 size_t os::Aix::query_pagesize(void* addr) {
 341 
 342   if (os::Aix::on_pase() &amp;&amp; os::Aix::os_version_short() &lt; 0x0601) {
 343     // AS/400 older than V6R1: no vmgetinfo here, default to 4K
 344     return 4*K;
 345   }
 346 
 347   vm_page_info pi;
 348   pi.addr = (uint64_t)addr;
 349   if (checked_vmgetinfo(&amp;pi, VM_PAGE_INFO, sizeof(pi)) == 0) {
 350     return pi.pagesize;
 351   } else {
 352     assert(false, &quot;vmgetinfo failed to retrieve page size&quot;);
 353     return 4*K;
 354   }
 355 }
 356 
 357 void os::Aix::initialize_system_info() {
 358 
 359   // Get the number of online(logical) cpus instead of configured.
 360   os::_processor_count = sysconf(_SC_NPROCESSORS_ONLN);
 361   assert(_processor_count &gt; 0, &quot;_processor_count must be &gt; 0&quot;);
 362 
 363   // Retrieve total physical storage.
 364   os::Aix::meminfo_t mi;
 365   if (!os::Aix::get_meminfo(&amp;mi)) {
 366     assert(false, &quot;os::Aix::get_meminfo failed.&quot;);
 367   }
 368   _physical_memory = (julong) mi.real_total;
 369 }
 370 
 371 // Helper function for tracing page sizes.
 372 static const char* describe_pagesize(size_t pagesize) {
 373   switch (pagesize) {
 374     case 4*K : return &quot;4K&quot;;
 375     case 64*K: return &quot;64K&quot;;
 376     case 16*M: return &quot;16M&quot;;
 377     case 16*G: return &quot;16G&quot;;
 378     default:
 379       assert(false, &quot;surprise&quot;);
 380       return &quot;??&quot;;
 381   }
 382 }
 383 
 384 // Probe OS for multipage support.
 385 // Will fill the global g_multipage_support structure.
 386 // Must be called before calling os::large_page_init().
 387 static void query_multipage_support() {
 388 
 389   guarantee(g_multipage_support.pagesize == -1,
 390             &quot;do not call twice&quot;);
 391 
 392   g_multipage_support.pagesize = ::sysconf(_SC_PAGESIZE);
 393 
 394   // This really would surprise me.
 395   assert(g_multipage_support.pagesize == 4*K, &quot;surprise!&quot;);
 396 
 397   // Query default data page size (default page size for C-Heap, pthread stacks and .bss).
 398   // Default data page size is defined either by linker options (-bdatapsize)
 399   // or by environment variable LDR_CNTRL (suboption DATAPSIZE). If none is given,
 400   // default should be 4K.
 401   {
 402     void* p = ::malloc(16*M);
 403     g_multipage_support.datapsize = os::Aix::query_pagesize(p);
 404     ::free(p);
 405   }
 406 
 407   // Query default shm page size (LDR_CNTRL SHMPSIZE).
 408   // Note that this is pure curiosity. We do not rely on default page size but set
 409   // our own page size after allocated.
 410   {
 411     const int shmid = ::shmget(IPC_PRIVATE, 1, IPC_CREAT | S_IRUSR | S_IWUSR);
 412     guarantee(shmid != -1, &quot;shmget failed&quot;);
 413     void* p = ::shmat(shmid, NULL, 0);
 414     ::shmctl(shmid, IPC_RMID, NULL);
 415     guarantee(p != (void*) -1, &quot;shmat failed&quot;);
 416     g_multipage_support.shmpsize = os::Aix::query_pagesize(p);
 417     ::shmdt(p);
 418   }
 419 
 420   // Before querying the stack page size, make sure we are not running as primordial
 421   // thread (because primordial thread&#39;s stack may have different page size than
 422   // pthread thread stacks). Running a VM on the primordial thread won&#39;t work for a
 423   // number of reasons so we may just as well guarantee it here.
 424   guarantee0(!os::is_primordial_thread());
 425 
 426   // Query pthread stack page size. Should be the same as data page size because
 427   // pthread stacks are allocated from C-Heap.
 428   {
 429     int dummy = 0;
 430     g_multipage_support.pthr_stack_pagesize = os::Aix::query_pagesize(&amp;dummy);
 431   }
 432 
 433   // Query default text page size (LDR_CNTRL TEXTPSIZE).
 434   {
 435     address any_function =
 436       resolve_function_descriptor_to_code_pointer((address)describe_pagesize);
 437     g_multipage_support.textpsize = os::Aix::query_pagesize(any_function);
 438   }
 439 
 440   // Now probe for support of 64K pages and 16M pages.
 441 
 442   // Before OS/400 V6R1, there is no support for pages other than 4K.
 443   if (os::Aix::on_pase_V5R4_or_older()) {
 444     trcVerbose(&quot;OS/400 &lt; V6R1 - no large page support.&quot;);
 445     g_multipage_support.error = ERROR_MP_OS_TOO_OLD;
 446     goto query_multipage_support_end;
 447   }
 448 
 449   // Now check which page sizes the OS claims it supports, and of those, which actually can be used.
 450   {
 451     const int MAX_PAGE_SIZES = 4;
 452     psize_t sizes[MAX_PAGE_SIZES];
 453     const int num_psizes = checked_vmgetinfo(sizes, VMINFO_GETPSIZES, MAX_PAGE_SIZES);
 454     if (num_psizes == -1) {
 455       trcVerbose(&quot;vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d)&quot;, errno);
 456       trcVerbose(&quot;disabling multipage support.&quot;);
 457       g_multipage_support.error = ERROR_MP_VMGETINFO_FAILED;
 458       goto query_multipage_support_end;
 459     }
 460     guarantee(num_psizes &gt; 0, &quot;vmgetinfo(.., VMINFO_GETPSIZES, ...) failed.&quot;);
 461     assert(num_psizes &lt;= MAX_PAGE_SIZES, &quot;Surprise! more than 4 page sizes?&quot;);
 462     trcVerbose(&quot;vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: &quot;, num_psizes);
 463     for (int i = 0; i &lt; num_psizes; i ++) {
 464       trcVerbose(&quot; %s &quot;, describe_pagesize(sizes[i]));
 465     }
 466 
 467     // Can we use 64K, 16M pages?
 468     for (int i = 0; i &lt; num_psizes; i ++) {
 469       const size_t pagesize = sizes[i];
 470       if (pagesize != 64*K &amp;&amp; pagesize != 16*M) {
 471         continue;
 472       }
 473       bool can_use = false;
 474       trcVerbose(&quot;Probing support for %s pages...&quot;, describe_pagesize(pagesize));
 475       const int shmid = ::shmget(IPC_PRIVATE, pagesize,
 476         IPC_CREAT | S_IRUSR | S_IWUSR);
 477       guarantee0(shmid != -1); // Should always work.
 478       // Try to set pagesize.
 479       struct shmid_ds shm_buf = { 0 };
 480       shm_buf.shm_pagesize = pagesize;
 481       if (::shmctl(shmid, SHM_PAGESIZE, &amp;shm_buf) != 0) {
 482         const int en = errno;
 483         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
<a name="6" id="anc6"></a><span class="line-modified"> 484         trcVerbose(&quot;shmctl(SHM_PAGESIZE) failed with errno=%d&quot;, errno);</span>

 485       } else {
 486         // Attach and double check pageisze.
 487         void* p = ::shmat(shmid, NULL, 0);
 488         ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
 489         guarantee0(p != (void*) -1); // Should always work.
 490         const size_t real_pagesize = os::Aix::query_pagesize(p);
 491         if (real_pagesize != pagesize) {
<a name="7" id="anc7"></a><span class="line-modified"> 492           trcVerbose(&quot;real page size (&quot; SIZE_FORMAT_HEX &quot;) differs.&quot;, real_pagesize);</span>
 493         } else {
 494           can_use = true;
 495         }
 496         ::shmdt(p);
 497       }
 498       trcVerbose(&quot;Can use: %s&quot;, (can_use ? &quot;yes&quot; : &quot;no&quot;));
 499       if (pagesize == 64*K) {
 500         g_multipage_support.can_use_64K_pages = can_use;
 501       } else if (pagesize == 16*M) {
 502         g_multipage_support.can_use_16M_pages = can_use;
 503       }
 504     }
 505 
 506   } // end: check which pages can be used for shared memory
 507 
 508 query_multipage_support_end:
 509 
 510   trcVerbose(&quot;base page size (sysconf _SC_PAGESIZE): %s&quot;,
 511       describe_pagesize(g_multipage_support.pagesize));
 512   trcVerbose(&quot;Data page size (C-Heap, bss, etc): %s&quot;,
 513       describe_pagesize(g_multipage_support.datapsize));
 514   trcVerbose(&quot;Text page size: %s&quot;,
 515       describe_pagesize(g_multipage_support.textpsize));
 516   trcVerbose(&quot;Thread stack page size (pthread): %s&quot;,
 517       describe_pagesize(g_multipage_support.pthr_stack_pagesize));
 518   trcVerbose(&quot;Default shared memory page size: %s&quot;,
 519       describe_pagesize(g_multipage_support.shmpsize));
<a name="8" id="anc8"></a><span class="line-modified"> 520   trcVerbose(&quot;Can use 64K pages dynamically with shared memory: %s&quot;,</span>
 521       (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
 522   trcVerbose(&quot;Can use 16M pages dynamically with shared memory: %s&quot;,
 523       (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
 524   trcVerbose(&quot;Multipage error details: %d&quot;,
 525       g_multipage_support.error);
 526 
 527   // sanity checks
 528   assert0(g_multipage_support.pagesize == 4*K);
 529   assert0(g_multipage_support.datapsize == 4*K || g_multipage_support.datapsize == 64*K);
 530   assert0(g_multipage_support.textpsize == 4*K || g_multipage_support.textpsize == 64*K);
 531   assert0(g_multipage_support.pthr_stack_pagesize == g_multipage_support.datapsize);
 532   assert0(g_multipage_support.shmpsize == 4*K || g_multipage_support.shmpsize == 64*K);
 533 
 534 }
 535 
 536 void os::init_system_properties_values() {
 537 
 538 #ifndef OVERRIDE_LIBPATH
 539   #define DEFAULT_LIBPATH &quot;/lib:/usr/lib&quot;
 540 #else
 541   #define DEFAULT_LIBPATH OVERRIDE_LIBPATH
 542 #endif
 543 #define EXTENSIONS_DIR  &quot;/lib/ext&quot;
 544 
 545   // Buffer that fits several sprintfs.
 546   // Note that the space for the trailing null is provided
 547   // by the nulls included by the sizeof operator.
 548   const size_t bufsize =
 549     MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
 550          (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR)); // extensions dir
<a name="9" id="anc9"></a><span class="line-modified"> 551   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
 552 
 553   // sysclasspath, java_home, dll_dir
 554   {
 555     char *pslash;
 556     os::jvm_path(buf, bufsize);
 557 
 558     // Found the full path to libjvm.so.
 559     // Now cut the path to &lt;java_home&gt;/jre if we can.
 560     pslash = strrchr(buf, &#39;/&#39;);
 561     if (pslash != NULL) {
 562       *pslash = &#39;\0&#39;;            // Get rid of /libjvm.so.
 563     }
 564     pslash = strrchr(buf, &#39;/&#39;);
 565     if (pslash != NULL) {
 566       *pslash = &#39;\0&#39;;            // Get rid of /{client|server|hotspot}.
 567     }
 568     Arguments::set_dll_dir(buf);
 569 
 570     if (pslash != NULL) {
 571       pslash = strrchr(buf, &#39;/&#39;);
 572       if (pslash != NULL) {
 573         *pslash = &#39;\0&#39;;        // Get rid of /lib.
 574       }
 575     }
 576     Arguments::set_java_home(buf);
 577     if (!set_boot_path(&#39;/&#39;, &#39;:&#39;)) {
 578       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 579     }
 580   }
 581 
 582   // Where to look for native libraries.
 583 
 584   // On Aix we get the user setting of LIBPATH.
 585   // Eventually, all the library path setting will be done here.
 586   // Get the user setting of LIBPATH.
 587   const char *v = ::getenv(&quot;LIBPATH&quot;);
 588   const char *v_colon = &quot;:&quot;;
 589   if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
 590 
 591   // Concatenate user and invariant part of ld_library_path.
 592   // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<a name="10" id="anc10"></a><span class="line-modified"> 593   char *ld_library_path = NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);</span>
 594   sprintf(ld_library_path, &quot;%s%s&quot; DEFAULT_LIBPATH, v, v_colon);
 595   Arguments::set_library_path(ld_library_path);
 596   FREE_C_HEAP_ARRAY(char, ld_library_path);
 597 
 598   // Extensions directories.
 599   sprintf(buf, &quot;%s&quot; EXTENSIONS_DIR, Arguments::get_java_home());
 600   Arguments::set_ext_dirs(buf);
 601 
 602   FREE_C_HEAP_ARRAY(char, buf);
 603 
 604 #undef DEFAULT_LIBPATH
 605 #undef EXTENSIONS_DIR
 606 }
 607 
 608 ////////////////////////////////////////////////////////////////////////////////
 609 // breakpoint support
 610 
 611 void os::breakpoint() {
 612   BREAKPOINT;
 613 }
 614 
 615 extern &quot;C&quot; void breakpoint() {
 616   // use debugger to set breakpoint here
 617 }
 618 
 619 ////////////////////////////////////////////////////////////////////////////////
 620 // signal support
 621 
 622 debug_only(static bool signal_sets_initialized = false);
 623 static sigset_t unblocked_sigs, vm_sigs;
 624 
 625 void os::Aix::signal_sets_init() {
 626   // Should also have an assertion stating we are still single-threaded.
 627   assert(!signal_sets_initialized, &quot;Already initialized&quot;);
 628   // Fill in signals that are necessarily unblocked for all threads in
 629   // the VM. Currently, we unblock the following signals:
 630   // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden
 631   //                         by -Xrs (=ReduceSignalUsage));
 632   // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all
 633   // other threads. The &quot;ReduceSignalUsage&quot; boolean tells us not to alter
 634   // the dispositions or masks wrt these signals.
 635   // Programs embedding the VM that want to use the above signals for their
 636   // own purposes must, at this time, use the &quot;-Xrs&quot; option to prevent
 637   // interference with shutdown hooks and BREAK_SIGNAL thread dumping.
 638   // (See bug 4345157, and other related bugs).
 639   // In reality, though, unblocking these signals is really a nop, since
 640   // these signals are not blocked by default.
 641   sigemptyset(&amp;unblocked_sigs);
 642   sigaddset(&amp;unblocked_sigs, SIGILL);
 643   sigaddset(&amp;unblocked_sigs, SIGSEGV);
 644   sigaddset(&amp;unblocked_sigs, SIGBUS);
 645   sigaddset(&amp;unblocked_sigs, SIGFPE);
 646   sigaddset(&amp;unblocked_sigs, SIGTRAP);
 647   sigaddset(&amp;unblocked_sigs, SR_signum);
 648 
 649   if (!ReduceSignalUsage) {
 650    if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {
 651      sigaddset(&amp;unblocked_sigs, SHUTDOWN1_SIGNAL);
 652    }
 653    if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {
 654      sigaddset(&amp;unblocked_sigs, SHUTDOWN2_SIGNAL);
 655    }
 656    if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {
 657      sigaddset(&amp;unblocked_sigs, SHUTDOWN3_SIGNAL);
 658    }
 659   }
 660   // Fill in signals that are blocked by all but the VM thread.
 661   sigemptyset(&amp;vm_sigs);
 662   if (!ReduceSignalUsage)
 663     sigaddset(&amp;vm_sigs, BREAK_SIGNAL);
 664   debug_only(signal_sets_initialized = true);
 665 }
 666 
 667 // These are signals that are unblocked while a thread is running Java.
 668 // (For some reason, they get blocked by default.)
 669 sigset_t* os::Aix::unblocked_signals() {
 670   assert(signal_sets_initialized, &quot;Not initialized&quot;);
 671   return &amp;unblocked_sigs;
 672 }
 673 
 674 // These are the signals that are blocked while a (non-VM) thread is
 675 // running Java. Only the VM thread handles these signals.
 676 sigset_t* os::Aix::vm_signals() {
 677   assert(signal_sets_initialized, &quot;Not initialized&quot;);
 678   return &amp;vm_sigs;
 679 }
 680 
 681 void os::Aix::hotspot_sigmask(Thread* thread) {
 682 
 683   //Save caller&#39;s signal mask before setting VM signal mask
 684   sigset_t caller_sigmask;
 685   pthread_sigmask(SIG_BLOCK, NULL, &amp;caller_sigmask);
 686 
 687   OSThread* osthread = thread-&gt;osthread();
 688   osthread-&gt;set_caller_sigmask(caller_sigmask);
 689 
 690   pthread_sigmask(SIG_UNBLOCK, os::Aix::unblocked_signals(), NULL);
 691 
 692   if (!ReduceSignalUsage) {
 693     if (thread-&gt;is_VM_thread()) {
 694       // Only the VM thread handles BREAK_SIGNAL ...
 695       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 696     } else {
 697       // ... all other threads block BREAK_SIGNAL
 698       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 699     }
 700   }
 701 }
 702 
 703 // retrieve memory information.
 704 // Returns false if something went wrong;
 705 // content of pmi undefined in this case.
 706 bool os::Aix::get_meminfo(meminfo_t* pmi) {
 707 
 708   assert(pmi, &quot;get_meminfo: invalid parameter&quot;);
 709 
 710   memset(pmi, 0, sizeof(meminfo_t));
 711 
 712   if (os::Aix::on_pase()) {
 713     // On PASE, use the libo4 porting library.
 714 
 715     unsigned long long virt_total = 0;
 716     unsigned long long real_total = 0;
 717     unsigned long long real_free = 0;
 718     unsigned long long pgsp_total = 0;
 719     unsigned long long pgsp_free = 0;
 720     if (libo4::get_memory_info(&amp;virt_total, &amp;real_total, &amp;real_free, &amp;pgsp_total, &amp;pgsp_free)) {
 721       pmi-&gt;virt_total = virt_total;
 722       pmi-&gt;real_total = real_total;
 723       pmi-&gt;real_free = real_free;
 724       pmi-&gt;pgsp_total = pgsp_total;
 725       pmi-&gt;pgsp_free = pgsp_free;
 726       return true;
 727     }
 728     return false;
 729 
 730   } else {
 731 
 732     // On AIX, I use the (dynamically loaded) perfstat library to retrieve memory statistics
 733     // See:
 734     // http://publib.boulder.ibm.com/infocenter/systems/index.jsp
 735     //        ?topic=/com.ibm.aix.basetechref/doc/basetrf1/perfstat_memtot.htm
 736     // http://publib.boulder.ibm.com/infocenter/systems/index.jsp
 737     //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm
 738 
 739     perfstat_memory_total_t psmt;
 740     memset (&amp;psmt, &#39;\0&#39;, sizeof(psmt));
 741     const int rc = libperfstat::perfstat_memory_total(NULL, &amp;psmt, sizeof(psmt), 1);
 742     if (rc == -1) {
 743       trcVerbose(&quot;perfstat_memory_total() failed (errno=%d)&quot;, errno);
 744       assert(0, &quot;perfstat_memory_total() failed&quot;);
 745       return false;
 746     }
 747 
 748     assert(rc == 1, &quot;perfstat_memory_total() - weird return code&quot;);
 749 
 750     // excerpt from
 751     // http://publib.boulder.ibm.com/infocenter/systems/index.jsp
 752     //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm
 753     // The fields of perfstat_memory_total_t:
 754     // u_longlong_t virt_total         Total virtual memory (in 4 KB pages).
 755     // u_longlong_t real_total         Total real memory (in 4 KB pages).
 756     // u_longlong_t real_free          Free real memory (in 4 KB pages).
 757     // u_longlong_t pgsp_total         Total paging space (in 4 KB pages).
 758     // u_longlong_t pgsp_free          Free paging space (in 4 KB pages).
 759 
 760     pmi-&gt;virt_total = psmt.virt_total * 4096;
 761     pmi-&gt;real_total = psmt.real_total * 4096;
 762     pmi-&gt;real_free = psmt.real_free * 4096;
 763     pmi-&gt;pgsp_total = psmt.pgsp_total * 4096;
 764     pmi-&gt;pgsp_free = psmt.pgsp_free * 4096;
 765 
 766     return true;
 767 
 768   }
 769 } // end os::Aix::get_meminfo
 770 
 771 //////////////////////////////////////////////////////////////////////////////
 772 // create new thread
 773 
 774 // Thread start routine for all newly created threads
 775 static void *thread_native_entry(Thread *thread) {
 776 
 777   thread-&gt;record_stack_base_and_size();
 778 
 779   const pthread_t pthread_id = ::pthread_self();
 780   const tid_t kernel_thread_id = ::thread_self();
 781 
 782   LogTarget(Info, os, thread) lt;
 783   if (lt.is_enabled()) {
 784     address low_address = thread-&gt;stack_end();
 785     address high_address = thread-&gt;stack_base();
 786     lt.print(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;, kernel thread id: &quot; UINTX_FORMAT
 787              &quot;, stack [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot;k using %uk pages)).&quot;,
 788              os::current_thread_id(), (uintx) kernel_thread_id, low_address, high_address,
 789              (high_address - low_address) / K, os::Aix::query_pagesize(low_address) / K);
 790   }
 791 
 792   // Normally, pthread stacks on AIX live in the data segment (are allocated with malloc()
 793   // by the pthread library). In rare cases, this may not be the case, e.g. when third-party
 794   // tools hook pthread_create(). In this case, we may run into problems establishing
 795   // guard pages on those stacks, because the stacks may reside in memory which is not
 796   // protectable (shmated).
 797   if (thread-&gt;stack_base() &gt; ::sbrk(0)) {
 798     log_warning(os, thread)(&quot;Thread stack not in data segment.&quot;);
 799   }
 800 
 801   // Try to randomize the cache line index of hot stack frames.
 802   // This helps when threads of the same stack traces evict each other&#39;s
 803   // cache lines. The threads can be either from the same JVM instance, or
 804   // from different JVM instances. The benefit is especially true for
 805   // processors with hyperthreading technology.
 806 
 807   static int counter = 0;
 808   int pid = os::current_process_id();
 809   alloca(((pid ^ counter++) &amp; 7) * 128);
 810 
 811   thread-&gt;initialize_thread_current();
 812 
 813   OSThread* osthread = thread-&gt;osthread();
 814 
 815   // Thread_id is pthread id.
 816   osthread-&gt;set_thread_id(pthread_id);
 817 
 818   // .. but keep kernel thread id too for diagnostics
 819   osthread-&gt;set_kernel_thread_id(kernel_thread_id);
 820 
 821   // Initialize signal mask for this thread.
 822   os::Aix::hotspot_sigmask(thread);
 823 
 824   // Initialize floating point control register.
 825   os::Aix::init_thread_fpu_state();
 826 
 827   assert(osthread-&gt;get_state() == RUNNABLE, &quot;invalid os thread state&quot;);
 828 
 829   // Call one more level start routine.
 830   thread-&gt;call_run();
 831 
 832   // Note: at this point the thread object may already have deleted itself.
 833   // Prevent dereferencing it from here on out.
 834   thread = NULL;
 835 
 836   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;, kernel thread id: &quot; UINTX_FORMAT &quot;).&quot;,
 837     os::current_thread_id(), (uintx) kernel_thread_id);
 838 
 839   return 0;
 840 }
 841 
 842 bool os::create_thread(Thread* thread, ThreadType thr_type,
 843                        size_t req_stack_size) {
 844 
 845   assert(thread-&gt;osthread() == NULL, &quot;caller responsible&quot;);
 846 
 847   // Allocate the OSThread object.
 848   OSThread* osthread = new OSThread(NULL, NULL);
 849   if (osthread == NULL) {
 850     return false;
 851   }
 852 
 853   // Set the correct thread state.
 854   osthread-&gt;set_thread_type(thr_type);
 855 
 856   // Initial state is ALLOCATED but not INITIALIZED
 857   osthread-&gt;set_state(ALLOCATED);
 858 
 859   thread-&gt;set_osthread(osthread);
 860 
 861   // Init thread attributes.
 862   pthread_attr_t attr;
 863   pthread_attr_init(&amp;attr);
 864   guarantee(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) == 0, &quot;???&quot;);
 865 
 866   // Make sure we run in 1:1 kernel-user-thread mode.
 867   if (os::Aix::on_aix()) {
 868     guarantee(pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM) == 0, &quot;???&quot;);
 869     guarantee(pthread_attr_setinheritsched(&amp;attr, PTHREAD_EXPLICIT_SCHED) == 0, &quot;???&quot;);
 870   }
 871 
 872   // Start in suspended state, and in os::thread_start, wake the thread up.
 873   guarantee(pthread_attr_setsuspendstate_np(&amp;attr, PTHREAD_CREATE_SUSPENDED_NP) == 0, &quot;???&quot;);
 874 
 875   // Calculate stack size if it&#39;s not specified by caller.
 876   size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);
 877 
 878   // JDK-8187028: It was observed that on some configurations (4K backed thread stacks)
 879   // the real thread stack size may be smaller than the requested stack size, by as much as 64K.
 880   // This very much looks like a pthread lib error. As a workaround, increase the stack size
 881   // by 64K for small thread stacks (arbitrarily choosen to be &lt; 4MB)
 882   if (stack_size &lt; 4096 * K) {
 883     stack_size += 64 * K;
 884   }
 885 
 886   // On Aix, pthread_attr_setstacksize fails with huge values and leaves the
 887   // thread size in attr unchanged. If this is the minimal stack size as set
 888   // by pthread_attr_init this leads to crashes after thread creation. E.g. the
 889   // guard pages might not fit on the tiny stack created.
 890   int ret = pthread_attr_setstacksize(&amp;attr, stack_size);
 891   if (ret != 0) {
 892     log_warning(os, thread)(&quot;The %sthread stack size specified is invalid: &quot; SIZE_FORMAT &quot;k&quot;,
 893                             (thr_type == compiler_thread) ? &quot;compiler &quot; : ((thr_type == java_thread) ? &quot;&quot; : &quot;VM &quot;),
 894                             stack_size / K);
 895     thread-&gt;set_osthread(NULL);
 896     delete osthread;
 897     return false;
 898   }
 899 
 900   // Save some cycles and a page by disabling OS guard pages where we have our own
 901   // VM guard pages (in java threads). For other threads, keep system default guard
 902   // pages in place.
 903   if (thr_type == java_thread || thr_type == compiler_thread) {
 904     ret = pthread_attr_setguardsize(&amp;attr, 0);
 905   }
 906 
 907   pthread_t tid = 0;
 908   if (ret == 0) {
 909     ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread);
 910   }
 911 
 912   if (ret == 0) {
 913     char buf[64];
 914     log_info(os, thread)(&quot;Thread started (pthread id: &quot; UINTX_FORMAT &quot;, attributes: %s). &quot;,
 915       (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
 916   } else {
 917     char buf[64];
 918     log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%d=%s) for attributes: %s.&quot;,
 919       ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<a name="11" id="anc11"></a><span class="line-added"> 920     // Log some OS information which might explain why creating the thread failed.</span>
<span class="line-added"> 921     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="line-added"> 922     LogStream st(Log(os, thread)::info());</span>
<span class="line-added"> 923     os::Posix::print_rlimit_info(&amp;st);</span>
<span class="line-added"> 924     os::print_memory_info(&amp;st);</span>
 925   }
 926 
 927   pthread_attr_destroy(&amp;attr);
 928 
 929   if (ret != 0) {
 930     // Need to clean up stuff we&#39;ve allocated so far.
 931     thread-&gt;set_osthread(NULL);
 932     delete osthread;
 933     return false;
 934   }
 935 
 936   // OSThread::thread_id is the pthread id.
 937   osthread-&gt;set_thread_id(tid);
 938 
 939   return true;
 940 }
 941 
 942 /////////////////////////////////////////////////////////////////////////////
 943 // attach existing thread
 944 
 945 // bootstrap the main thread
 946 bool os::create_main_thread(JavaThread* thread) {
 947   assert(os::Aix::_main_thread == pthread_self(), &quot;should be called inside main thread&quot;);
 948   return create_attached_thread(thread);
 949 }
 950 
 951 bool os::create_attached_thread(JavaThread* thread) {
 952 #ifdef ASSERT
 953     thread-&gt;verify_not_published();
 954 #endif
 955 
 956   // Allocate the OSThread object
 957   OSThread* osthread = new OSThread(NULL, NULL);
 958 
 959   if (osthread == NULL) {
 960     return false;
 961   }
 962 
 963   const pthread_t pthread_id = ::pthread_self();
 964   const tid_t kernel_thread_id = ::thread_self();
 965 
 966   // OSThread::thread_id is the pthread id.
 967   osthread-&gt;set_thread_id(pthread_id);
 968 
 969   // .. but keep kernel thread id too for diagnostics
 970   osthread-&gt;set_kernel_thread_id(kernel_thread_id);
 971 
 972   // initialize floating point control register
 973   os::Aix::init_thread_fpu_state();
 974 
 975   // Initial thread state is RUNNABLE
 976   osthread-&gt;set_state(RUNNABLE);
 977 
 978   thread-&gt;set_osthread(osthread);
 979 
 980   if (UseNUMA) {
 981     int lgrp_id = os::numa_get_group_id();
 982     if (lgrp_id != -1) {
 983       thread-&gt;set_lgrp_id(lgrp_id);
 984     }
 985   }
 986 
 987   // initialize signal mask for this thread
 988   // and save the caller&#39;s signal mask
 989   os::Aix::hotspot_sigmask(thread);
 990 
 991   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;, kernel thread id: &quot; UINTX_FORMAT &quot;).&quot;,
 992     os::current_thread_id(), (uintx) kernel_thread_id);
 993 
 994   return true;
 995 }
 996 
 997 void os::pd_start_thread(Thread* thread) {
 998   int status = pthread_continue_np(thread-&gt;osthread()-&gt;pthread_id());
 999   assert(status == 0, &quot;thr_continue failed&quot;);
1000 }
1001 
1002 // Free OS resources related to the OSThread
1003 void os::free_thread(OSThread* osthread) {
1004   assert(osthread != NULL, &quot;osthread not set&quot;);
1005 
1006   // We are told to free resources of the argument thread,
1007   // but we can only really operate on the current thread.
1008   assert(Thread::current()-&gt;osthread() == osthread,
1009          &quot;os::free_thread but not current thread&quot;);
1010 
1011   // Restore caller&#39;s signal mask
1012   sigset_t sigmask = osthread-&gt;caller_sigmask();
1013   pthread_sigmask(SIG_SETMASK, &amp;sigmask, NULL);
1014 
1015   delete osthread;
1016 }
1017 
1018 ////////////////////////////////////////////////////////////////////////////////
1019 // time support
1020 
1021 // Time since start-up in seconds to a fine granularity.
1022 // Used by VMSelfDestructTimer and the MemProfiler.
1023 double os::elapsedTime() {
<a name="12" id="anc12"></a><span class="line-modified">1024   return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution</span>
1025 }
1026 
1027 jlong os::elapsed_counter() {
<a name="13" id="anc13"></a><span class="line-modified">1028   return javaTimeNanos() - initial_time_count;</span>


1029 }
1030 
1031 jlong os::elapsed_frequency() {
<a name="14" id="anc14"></a><span class="line-modified">1032   return NANOSECS_PER_SEC; // nanosecond resolution</span>
1033 }
1034 
1035 bool os::supports_vtime() { return true; }
<a name="15" id="anc15"></a>

1036 
1037 double os::elapsedVTime() {
1038   struct rusage usage;
1039   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1040   if (retval == 0) {
1041     return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec + (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000.0 * 1000);
1042   } else {
1043     // better than nothing, but not much
1044     return elapsedTime();
1045   }
1046 }
1047 
1048 jlong os::javaTimeMillis() {
1049   timeval time;
1050   int status = gettimeofday(&amp;time, NULL);
1051   assert(status != -1, &quot;aix error at gettimeofday()&quot;);
1052   return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);
1053 }
1054 
1055 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
1056   timeval time;
1057   int status = gettimeofday(&amp;time, NULL);
1058   assert(status != -1, &quot;aix error at gettimeofday()&quot;);
1059   seconds = jlong(time.tv_sec);
1060   nanos = jlong(time.tv_usec) * 1000;
1061 }
1062 
1063 // We use mread_real_time here.
1064 // On AIX: If the CPU has a time register, the result will be RTC_POWER and
1065 // it has to be converted to real time. AIX documentations suggests to do
1066 // this unconditionally, so we do it.
1067 //
1068 // See: https://www.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.basetrf2/read_real_time.htm
1069 //
1070 // On PASE: mread_real_time will always return RTC_POWER_PC data, so no
1071 // conversion is necessary. However, mread_real_time will not return
1072 // monotonic results but merely matches read_real_time. So we need a tweak
1073 // to ensure monotonic results.
1074 //
1075 // For PASE no public documentation exists, just word by IBM
1076 jlong os::javaTimeNanos() {
1077   timebasestruct_t time;
1078   int rc = mread_real_time(&amp;time, TIMEBASE_SZ);
1079   if (os::Aix::on_pase()) {
1080     assert(rc == RTC_POWER, &quot;expected time format RTC_POWER from mread_real_time in PASE&quot;);
1081     jlong now = jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
1082     jlong prev = max_real_time;
1083     if (now &lt;= prev) {
1084       return prev;   // same or retrograde time;
1085     }
<a name="16" id="anc16"></a><span class="line-modified">1086     jlong obsv = Atomic::cmpxchg(&amp;max_real_time, prev, now);</span>
1087     assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
1088     // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
1089     // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
1090     // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
1091     // some other thread raced this thread and installed a new value, in which case
1092     // we could either (a) retry the entire operation, (b) retry trying to install now
1093     // or (c) just return obsv.  We use (c).   No loop is required although in some cases
1094     // we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly
1095     // installed obsv value.   That&#39;s entirely benign -- it admits no new orderings compared
1096     // to (a) or (b) -- and greatly reduces coherence traffic.
1097     // We might also condition (c) on the magnitude of the delta between obsv and now.
1098     // Avoiding excessive CAS operations to hot RW locations is critical.
1099     // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
1100     return (prev == obsv) ? now : obsv;
1101   } else {
1102     if (rc != RTC_POWER) {
1103       rc = time_base_to_time(&amp;time, TIMEBASE_SZ);
1104       assert(rc != -1, &quot;error calling time_base_to_time()&quot;);
1105     }
1106     return jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
1107   }
1108 }
1109 
1110 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
1111   info_ptr-&gt;max_value = ALL_64_BITS;
1112   // mread_real_time() is monotonic (see &#39;os::javaTimeNanos()&#39;)
1113   info_ptr-&gt;may_skip_backward = false;
1114   info_ptr-&gt;may_skip_forward = false;
1115   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;    // elapsed not CPU time
1116 }
1117 
1118 // Return the real, user, and system times in seconds from an
1119 // arbitrary fixed point in the past.
1120 bool os::getTimesSecs(double* process_real_time,
1121                       double* process_user_time,
1122                       double* process_system_time) {
1123   struct tms ticks;
1124   clock_t real_ticks = times(&amp;ticks);
1125 
1126   if (real_ticks == (clock_t) (-1)) {
1127     return false;
1128   } else {
1129     double ticks_per_second = (double) clock_tics_per_sec;
1130     *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;
1131     *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;
1132     *process_real_time = ((double) real_ticks) / ticks_per_second;
1133 
1134     return true;
1135   }
1136 }
1137 
1138 char * os::local_time_string(char *buf, size_t buflen) {
1139   struct tm t;
1140   time_t long_time;
1141   time(&amp;long_time);
1142   localtime_r(&amp;long_time, &amp;t);
1143   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
1144                t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,
1145                t.tm_hour, t.tm_min, t.tm_sec);
1146   return buf;
1147 }
1148 
1149 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
1150   return localtime_r(clock, res);
1151 }
1152 
1153 ////////////////////////////////////////////////////////////////////////////////
1154 // runtime exit support
1155 
1156 // Note: os::shutdown() might be called very early during initialization, or
1157 // called from signal handler. Before adding something to os::shutdown(), make
1158 // sure it is async-safe and can handle partially initialized VM.
1159 void os::shutdown() {
1160 
1161   // allow PerfMemory to attempt cleanup of any persistent resources
1162   perfMemory_exit();
1163 
1164   // needs to remove object in file system
1165   AttachListener::abort();
1166 
1167   // flush buffered output, finish log files
1168   ostream_abort();
1169 
1170   // Check for abort hook
1171   abort_hook_t abort_hook = Arguments::abort_hook();
1172   if (abort_hook != NULL) {
1173     abort_hook();
1174   }
1175 }
1176 
1177 // Note: os::abort() might be called very early during initialization, or
1178 // called from signal handler. Before adding something to os::abort(), make
1179 // sure it is async-safe and can handle partially initialized VM.
1180 void os::abort(bool dump_core, void* siginfo, const void* context) {
1181   os::shutdown();
1182   if (dump_core) {
1183 #ifndef PRODUCT
1184     fdStream out(defaultStream::output_fd());
1185     out.print_raw(&quot;Current thread is &quot;);
1186     char buf[16];
1187     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());
1188     out.print_raw_cr(buf);
1189     out.print_raw_cr(&quot;Dumping core ...&quot;);
1190 #endif
1191     ::abort(); // dump core
1192   }
1193 
1194   ::exit(1);
1195 }
1196 
1197 // Die immediately, no exit hook, no abort hook, no cleanup.
<a name="17" id="anc17"></a><span class="line-added">1198 // Dump a core file, if possible, for debugging.</span>
1199 void os::die() {
<a name="18" id="anc18"></a><span class="line-modified">1200   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="line-added">1201     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="line-added">1202     // and don&#39;t take the time to generate a core file.</span>
<span class="line-added">1203     os::signal_raise(SIGKILL);</span>
<span class="line-added">1204   } else {</span>
<span class="line-added">1205     ::abort();</span>
<span class="line-added">1206   }</span>
1207 }
1208 
1209 intx os::current_thread_id() {
1210   return (intx)pthread_self();
1211 }
1212 
1213 int os::current_process_id() {
1214   return getpid();
1215 }
1216 
1217 // DLL functions
1218 
1219 const char* os::dll_file_extension() { return &quot;.so&quot;; }
1220 
1221 // This must be hard coded because it&#39;s the system&#39;s temporary
1222 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1223 const char* os::get_temp_directory() { return &quot;/tmp&quot;; }
1224 
1225 // Check if addr is inside libjvm.so.
1226 bool os::address_is_in_vm(address addr) {
1227 
1228   // Input could be a real pc or a function pointer literal. The latter
1229   // would be a function descriptor residing in the data segment of a module.
1230   loaded_module_t lm;
1231   if (LoadedLibraries::find_for_text_address(addr, &amp;lm) != NULL) {
1232     return lm.is_in_vm;
1233   } else if (LoadedLibraries::find_for_data_address(addr, &amp;lm) != NULL) {
1234     return lm.is_in_vm;
1235   } else {
1236     return false;
1237   }
1238 
1239 }
1240 
1241 // Resolve an AIX function descriptor literal to a code pointer.
1242 // If the input is a valid code pointer to a text segment of a loaded module,
1243 //   it is returned unchanged.
1244 // If the input is a valid AIX function descriptor, it is resolved to the
1245 //   code entry point.
1246 // If the input is neither a valid function descriptor nor a valid code pointer,
1247 //   NULL is returned.
1248 static address resolve_function_descriptor_to_code_pointer(address p) {
1249 
1250   if (LoadedLibraries::find_for_text_address(p, NULL) != NULL) {
1251     // It is a real code pointer.
1252     return p;
1253   } else if (LoadedLibraries::find_for_data_address(p, NULL) != NULL) {
1254     // Pointer to data segment, potential function descriptor.
1255     address code_entry = (address)(((FunctionDescriptor*)p)-&gt;entry());
1256     if (LoadedLibraries::find_for_text_address(code_entry, NULL) != NULL) {
1257       // It is a function descriptor.
1258       return code_entry;
1259     }
1260   }
1261 
1262   return NULL;
1263 }
1264 
1265 bool os::dll_address_to_function_name(address addr, char *buf,
1266                                       int buflen, int *offset,
1267                                       bool demangle) {
1268   if (offset) {
1269     *offset = -1;
1270   }
1271   // Buf is not optional, but offset is optional.
1272   assert(buf != NULL, &quot;sanity check&quot;);
1273   buf[0] = &#39;\0&#39;;
1274 
1275   // Resolve function ptr literals first.
1276   addr = resolve_function_descriptor_to_code_pointer(addr);
1277   if (!addr) {
1278     return false;
1279   }
1280 
1281   return AixSymbols::get_function_name(addr, buf, buflen, offset, NULL, demangle);
1282 }
1283 
1284 bool os::dll_address_to_library_name(address addr, char* buf,
1285                                      int buflen, int* offset) {
1286   if (offset) {
1287     *offset = -1;
1288   }
1289   // Buf is not optional, but offset is optional.
1290   assert(buf != NULL, &quot;sanity check&quot;);
1291   buf[0] = &#39;\0&#39;;
1292 
1293   // Resolve function ptr literals first.
1294   addr = resolve_function_descriptor_to_code_pointer(addr);
1295   if (!addr) {
1296     return false;
1297   }
1298 
1299   return AixSymbols::get_module_name(addr, buf, buflen);
1300 }
1301 
1302 // Loads .dll/.so and in case of error it checks if .dll/.so was built
1303 // for the same architecture as Hotspot is running on.
1304 void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {
1305 
<a name="19" id="anc19"></a><span class="line-added">1306   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="line-added">1307 </span>
1308   if (ebuf &amp;&amp; ebuflen &gt; 0) {
1309     ebuf[0] = &#39;\0&#39;;
1310     ebuf[ebuflen - 1] = &#39;\0&#39;;
1311   }
1312 
1313   if (!filename || strlen(filename) == 0) {
1314     ::strncpy(ebuf, &quot;dll_load: empty filename specified&quot;, ebuflen - 1);
1315     return NULL;
1316   }
1317 
1318   // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.
1319   void * result= ::dlopen(filename, RTLD_LAZY);
1320   if (result != NULL) {
<a name="20" id="anc20"></a><span class="line-added">1321     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
1322     // Reload dll cache. Don&#39;t do this in signal handling.
1323     LoadedLibraries::reload();
<a name="21" id="anc21"></a><span class="line-added">1324     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
1325     return result;
1326   } else {
1327     // error analysis when dlopen fails
<a name="22" id="anc22"></a><span class="line-modified">1328     const char* error_report = ::dlerror();</span>
<span class="line-modified">1329     if (error_report == NULL) {</span>
<span class="line-added">1330       error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332     if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
1333       snprintf(ebuf, ebuflen - 1, &quot;%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s&quot;,
1334                filename, ::getenv(&quot;LIBPATH&quot;), ::getenv(&quot;LD_LIBRARY_PATH&quot;), error_report);
1335     }
<a name="23" id="anc23"></a><span class="line-added">1336     Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="line-added">1337     log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
1338   }
1339   return NULL;
1340 }
1341 
1342 void* os::dll_lookup(void* handle, const char* name) {
1343   void* res = dlsym(handle, name);
1344   return res;
1345 }
1346 
1347 void* os::get_default_process_handle() {
1348   return (void*)::dlopen(NULL, RTLD_LAZY);
1349 }
1350 
1351 void os::print_dll_info(outputStream *st) {
1352   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1353   LoadedLibraries::print(st);
1354 }
1355 
1356 void os::get_summary_os_info(char* buf, size_t buflen) {
1357   // There might be something more readable than uname results for AIX.
1358   struct utsname name;
1359   uname(&amp;name);
1360   snprintf(buf, buflen, &quot;%s %s&quot;, name.release, name.version);
1361 }
1362 
1363 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1364   // Not yet implemented.
1365   return 0;
1366 }
1367 
1368 void os::print_os_info_brief(outputStream* st) {
1369   uint32_t ver = os::Aix::os_version();
1370   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1371                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1372 
1373   os::Posix::print_uname_info(st);
1374 
1375   // Linux uses print_libversion_info(st); here.
1376 }
1377 
1378 void os::print_os_info(outputStream* st) {
1379   st-&gt;print(&quot;OS:&quot;);
1380 
<a name="24" id="anc24"></a><span class="line-modified">1381   os::Posix::print_uname_info(st);</span>








1382 
1383   uint32_t ver = os::Aix::os_version();
1384   st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
1385                (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
1386 
<a name="25" id="anc25"></a><span class="line-added">1387   os::Posix::print_uptime_info(st);</span>
<span class="line-added">1388 </span>
1389   os::Posix::print_rlimit_info(st);
1390 
<a name="26" id="anc26"></a><span class="line-modified">1391   os::Posix::print_load_average(st);</span>
<span class="line-modified">1392 </span>
<span class="line-modified">1393   // _SC_THREAD_THREADS_MAX is the maximum number of threads within a process.</span>
<span class="line-modified">1394   long tmax = sysconf(_SC_THREAD_THREADS_MAX);</span>
<span class="line-modified">1395   st-&gt;print_cr(&quot;maximum #threads within a process:%ld&quot;, tmax);</span>

1396 
1397   // print wpar info
1398   libperfstat::wparinfo_t wi;
1399   if (libperfstat::get_wparinfo(&amp;wi)) {
1400     st-&gt;print_cr(&quot;wpar info&quot;);
1401     st-&gt;print_cr(&quot;name: %s&quot;, wi.name);
1402     st-&gt;print_cr(&quot;id:   %d&quot;, wi.wpar_id);
1403     st-&gt;print_cr(&quot;type: %s&quot;, (wi.app_wpar ? &quot;application&quot; : &quot;system&quot;));
1404   }
1405 
<a name="27" id="anc27"></a><span class="line-modified">1406   VM_Version::print_platform_virtualization_info(st);</span>






1407 }
1408 
1409 void os::print_memory_info(outputStream* st) {
1410 
1411   st-&gt;print_cr(&quot;Memory:&quot;);
1412 
1413   st-&gt;print_cr(&quot;  Base page size (sysconf _SC_PAGESIZE):  %s&quot;,
1414     describe_pagesize(g_multipage_support.pagesize));
1415   st-&gt;print_cr(&quot;  Data page size (C-Heap, bss, etc):      %s&quot;,
1416     describe_pagesize(g_multipage_support.datapsize));
1417   st-&gt;print_cr(&quot;  Text page size:                         %s&quot;,
1418     describe_pagesize(g_multipage_support.textpsize));
1419   st-&gt;print_cr(&quot;  Thread stack page size (pthread):       %s&quot;,
1420     describe_pagesize(g_multipage_support.pthr_stack_pagesize));
1421   st-&gt;print_cr(&quot;  Default shared memory page size:        %s&quot;,
1422     describe_pagesize(g_multipage_support.shmpsize));
<a name="28" id="anc28"></a><span class="line-modified">1423   st-&gt;print_cr(&quot;  Can use 64K pages dynamically with shared memory:  %s&quot;,</span>
1424     (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
1425   st-&gt;print_cr(&quot;  Can use 16M pages dynamically with shared memory: %s&quot;,
1426     (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
1427   st-&gt;print_cr(&quot;  Multipage error: %d&quot;,
1428     g_multipage_support.error);
1429   st-&gt;cr();
1430   st-&gt;print_cr(&quot;  os::vm_page_size:       %s&quot;, describe_pagesize(os::vm_page_size()));
1431 
1432   // print out LDR_CNTRL because it affects the default page sizes
1433   const char* const ldr_cntrl = ::getenv(&quot;LDR_CNTRL&quot;);
1434   st-&gt;print_cr(&quot;  LDR_CNTRL=%s.&quot;, ldr_cntrl ? ldr_cntrl : &quot;&lt;unset&gt;&quot;);
1435 
1436   // Print out EXTSHM because it is an unsupported setting.
1437   const char* const extshm = ::getenv(&quot;EXTSHM&quot;);
1438   st-&gt;print_cr(&quot;  EXTSHM=%s.&quot;, extshm ? extshm : &quot;&lt;unset&gt;&quot;);
1439   if ( (strcmp(extshm, &quot;on&quot;) == 0) || (strcmp(extshm, &quot;ON&quot;) == 0) ) {
1440     st-&gt;print_cr(&quot;  *** Unsupported! Please remove EXTSHM from your environment! ***&quot;);
1441   }
1442 
1443   // Print out AIXTHREAD_GUARDPAGES because it affects the size of pthread stacks.
1444   const char* const aixthread_guardpages = ::getenv(&quot;AIXTHREAD_GUARDPAGES&quot;);
1445   st-&gt;print_cr(&quot;  AIXTHREAD_GUARDPAGES=%s.&quot;,
1446       aixthread_guardpages ? aixthread_guardpages : &quot;&lt;unset&gt;&quot;);
1447   st-&gt;cr();
1448 
1449   os::Aix::meminfo_t mi;
1450   if (os::Aix::get_meminfo(&amp;mi)) {
1451     if (os::Aix::on_aix()) {
1452       st-&gt;print_cr(&quot;physical total : &quot; SIZE_FORMAT, mi.real_total);
1453       st-&gt;print_cr(&quot;physical free  : &quot; SIZE_FORMAT, mi.real_free);
1454       st-&gt;print_cr(&quot;swap total     : &quot; SIZE_FORMAT, mi.pgsp_total);
1455       st-&gt;print_cr(&quot;swap free      : &quot; SIZE_FORMAT, mi.pgsp_free);
1456     } else {
1457       // PASE - Numbers are result of QWCRSSTS; they mean:
1458       // real_total: Sum of all system pools
1459       // real_free: always 0
1460       // pgsp_total: we take the size of the system ASP
1461       // pgsp_free: size of system ASP times percentage of system ASP unused
1462       st-&gt;print_cr(&quot;physical total     : &quot; SIZE_FORMAT, mi.real_total);
1463       st-&gt;print_cr(&quot;system asp total   : &quot; SIZE_FORMAT, mi.pgsp_total);
1464       st-&gt;print_cr(&quot;%% system asp used : %.2f&quot;,
1465         mi.pgsp_total ? (100.0f * (mi.pgsp_total - mi.pgsp_free) / mi.pgsp_total) : -1.0f);
1466     }
1467   }
1468   st-&gt;cr();
1469 
1470   // Print program break.
1471   st-&gt;print_cr(&quot;Program break at VM startup: &quot; PTR_FORMAT &quot;.&quot;, p2i(g_brk_at_startup));
1472   address brk_now = (address)::sbrk(0);
1473   if (brk_now != (address)-1) {
1474     st-&gt;print_cr(&quot;Program break now          : &quot; PTR_FORMAT &quot; (distance: &quot; SIZE_FORMAT &quot;k).&quot;,
1475                  p2i(brk_now), (size_t)((brk_now - g_brk_at_startup) / K));
1476   }
1477   st-&gt;print_cr(&quot;MaxExpectedDataSegmentSize    : &quot; SIZE_FORMAT &quot;k.&quot;, MaxExpectedDataSegmentSize / K);
1478   st-&gt;cr();
1479 
1480   // Print segments allocated with os::reserve_memory.
1481   st-&gt;print_cr(&quot;internal virtual memory regions used by vm:&quot;);
1482   vmembk_print_on(st);
1483 }
1484 
1485 // Get a string for the cpuinfo that is a summary of the cpu type
1486 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1487   // read _system_configuration.version
1488   switch (_system_configuration.version) {
<a name="29" id="anc29"></a><span class="line-added">1489   case PV_9:</span>
<span class="line-added">1490     strncpy(buf, &quot;Power PC 9&quot;, buflen);</span>
<span class="line-added">1491     break;</span>
1492   case PV_8:
1493     strncpy(buf, &quot;Power PC 8&quot;, buflen);
1494     break;
1495   case PV_7:
1496     strncpy(buf, &quot;Power PC 7&quot;, buflen);
1497     break;
1498   case PV_6_1:
1499     strncpy(buf, &quot;Power PC 6 DD1.x&quot;, buflen);
1500     break;
1501   case PV_6:
1502     strncpy(buf, &quot;Power PC 6&quot;, buflen);
1503     break;
1504   case PV_5:
1505     strncpy(buf, &quot;Power PC 5&quot;, buflen);
1506     break;
1507   case PV_5_2:
1508     strncpy(buf, &quot;Power PC 5_2&quot;, buflen);
1509     break;
1510   case PV_5_3:
1511     strncpy(buf, &quot;Power PC 5_3&quot;, buflen);
1512     break;
1513   case PV_5_Compat:
1514     strncpy(buf, &quot;PV_5_Compat&quot;, buflen);
1515     break;
1516   case PV_6_Compat:
1517     strncpy(buf, &quot;PV_6_Compat&quot;, buflen);
1518     break;
1519   case PV_7_Compat:
1520     strncpy(buf, &quot;PV_7_Compat&quot;, buflen);
1521     break;
1522   case PV_8_Compat:
1523     strncpy(buf, &quot;PV_8_Compat&quot;, buflen);
1524     break;
<a name="30" id="anc30"></a><span class="line-added">1525   case PV_9_Compat:</span>
<span class="line-added">1526     strncpy(buf, &quot;PV_9_Compat&quot;, buflen);</span>
<span class="line-added">1527     break;</span>
1528   default:
1529     strncpy(buf, &quot;unknown&quot;, buflen);
1530   }
1531 }
1532 
1533 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1534   // Nothing to do beyond of what os::print_cpu_info() does.
1535 }
1536 
1537 static void print_signal_handler(outputStream* st, int sig,
1538                                  char* buf, size_t buflen);
1539 
1540 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1541   st-&gt;print_cr(&quot;Signal Handlers:&quot;);
1542   print_signal_handler(st, SIGSEGV, buf, buflen);
1543   print_signal_handler(st, SIGBUS , buf, buflen);
1544   print_signal_handler(st, SIGFPE , buf, buflen);
1545   print_signal_handler(st, SIGPIPE, buf, buflen);
1546   print_signal_handler(st, SIGXFSZ, buf, buflen);
1547   print_signal_handler(st, SIGILL , buf, buflen);
1548   print_signal_handler(st, SR_signum, buf, buflen);
1549   print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);
1550   print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);
1551   print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);
1552   print_signal_handler(st, BREAK_SIGNAL, buf, buflen);
1553   print_signal_handler(st, SIGTRAP, buf, buflen);
1554   // We also want to know if someone else adds a SIGDANGER handler because
1555   // that will interfere with OOM killling.
1556   print_signal_handler(st, SIGDANGER, buf, buflen);
1557 }
1558 
1559 static char saved_jvm_path[MAXPATHLEN] = {0};
1560 
1561 // Find the full path to the current module, libjvm.so.
1562 void os::jvm_path(char *buf, jint buflen) {
1563   // Error checking.
1564   if (buflen &lt; MAXPATHLEN) {
1565     assert(false, &quot;must use a large-enough buffer&quot;);
1566     buf[0] = &#39;\0&#39;;
1567     return;
1568   }
1569   // Lazy resolve the path to current module.
1570   if (saved_jvm_path[0] != 0) {
1571     strcpy(buf, saved_jvm_path);
1572     return;
1573   }
1574 
1575   Dl_info dlinfo;
1576   int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &amp;dlinfo);
1577   assert(ret != 0, &quot;cannot locate libjvm&quot;);
1578   char* rp = os::Posix::realpath((char *)dlinfo.dli_fname, buf, buflen);
1579   assert(rp != NULL, &quot;error in realpath(): maybe the &#39;path&#39; argument is too long?&quot;);
1580 
1581   if (Arguments::sun_java_launcher_is_altjvm()) {
1582     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Typical
1583     // value for buf is &quot;&lt;JAVA_HOME&gt;/jre/lib/&lt;vmtype&gt;/libjvm.so&quot;.
1584     // If &quot;/jre/lib/&quot; appears at the right place in the string, then
1585     // assume we are installed in a JDK and we&#39;re done. Otherwise, check
1586     // for a JAVA_HOME environment variable and fix up the path so it
1587     // looks like libjvm.so is installed there (append a fake suffix
1588     // hotspot/libjvm.so).
1589     const char *p = buf + strlen(buf) - 1;
1590     for (int count = 0; p &gt; buf &amp;&amp; count &lt; 4; ++count) {
1591       for (--p; p &gt; buf &amp;&amp; *p != &#39;/&#39;; --p)
1592         /* empty */ ;
1593     }
1594 
1595     if (strncmp(p, &quot;/jre/lib/&quot;, 9) != 0) {
1596       // Look for JAVA_HOME in the environment.
1597       char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1598       if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0) {
1599         char* jrelib_p;
1600         int len;
1601 
1602         // Check the current module name &quot;libjvm.so&quot;.
1603         p = strrchr(buf, &#39;/&#39;);
1604         if (p == NULL) {
1605           return;
1606         }
1607         assert(strstr(p, &quot;/libjvm&quot;) == p, &quot;invalid library name&quot;);
1608 
1609         rp = os::Posix::realpath(java_home_var, buf, buflen);
1610         if (rp == NULL) {
1611           return;
1612         }
1613 
1614         // determine if this is a legacy image or modules image
1615         // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1616         len = strlen(buf);
1617         assert(len &lt; buflen, &quot;Ran out of buffer room&quot;);
1618         jrelib_p = buf + len;
1619         snprintf(jrelib_p, buflen-len, &quot;/jre/lib&quot;);
1620         if (0 != access(buf, F_OK)) {
1621           snprintf(jrelib_p, buflen-len, &quot;/lib&quot;);
1622         }
1623 
1624         if (0 == access(buf, F_OK)) {
1625           // Use current module name &quot;libjvm.so&quot;
1626           len = strlen(buf);
1627           snprintf(buf + len, buflen-len, &quot;/hotspot/libjvm.so&quot;);
1628         } else {
1629           // Go back to path of .so
1630           rp = os::Posix::realpath((char *)dlinfo.dli_fname, buf, buflen);
1631           if (rp == NULL) {
1632             return;
1633           }
1634         }
1635       }
1636     }
1637   }
1638 
1639   strncpy(saved_jvm_path, buf, sizeof(saved_jvm_path));
1640   saved_jvm_path[sizeof(saved_jvm_path) - 1] = &#39;\0&#39;;
1641 }
1642 
1643 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1644   // no prefix required, not even &quot;_&quot;
1645 }
1646 
1647 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1648   // no suffix required
1649 }
1650 
1651 ////////////////////////////////////////////////////////////////////////////////
1652 // sun.misc.Signal support
1653 
<a name="31" id="anc31"></a>

1654 static void
1655 UserHandler(int sig, void *siginfo, void *context) {
<a name="32" id="anc32"></a>





1656   // Ctrl-C is pressed during error reporting, likely because the error
1657   // handler fails to abort. Let VM die immediately.
1658   if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
1659     os::die();
1660   }
1661 
1662   os::signal_notify(sig);
1663 }
1664 
1665 void* os::user_handler() {
1666   return CAST_FROM_FN_PTR(void*, UserHandler);
1667 }
1668 
1669 extern &quot;C&quot; {
1670   typedef void (*sa_handler_t)(int);
1671   typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
1672 }
1673 
1674 void* os::signal(int signal_number, void* handler) {
1675   struct sigaction sigAct, oldSigAct;
1676 
1677   sigfillset(&amp;(sigAct.sa_mask));
1678 
1679   // Do not block out synchronous signals in the signal handler.
1680   // Blocking synchronous signals only makes sense if you can really
1681   // be sure that those signals won&#39;t happen during signal handling,
1682   // when the blocking applies. Normal signal handlers are lean and
1683   // do not cause signals. But our signal handlers tend to be &quot;risky&quot;
1684   // - secondary SIGSEGV, SIGILL, SIGBUS&#39; may and do happen.
1685   // On AIX, PASE there was a case where a SIGSEGV happened, followed
1686   // by a SIGILL, which was blocked due to the signal mask. The process
1687   // just hung forever. Better to crash from a secondary signal than to hang.
1688   sigdelset(&amp;(sigAct.sa_mask), SIGSEGV);
1689   sigdelset(&amp;(sigAct.sa_mask), SIGBUS);
1690   sigdelset(&amp;(sigAct.sa_mask), SIGILL);
1691   sigdelset(&amp;(sigAct.sa_mask), SIGFPE);
1692   sigdelset(&amp;(sigAct.sa_mask), SIGTRAP);
1693 
1694   sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;
1695 
1696   sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);
1697 
1698   if (sigaction(signal_number, &amp;sigAct, &amp;oldSigAct)) {
1699     // -1 means registration failed
1700     return (void *)-1;
1701   }
1702 
1703   return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);
1704 }
1705 
1706 void os::signal_raise(int signal_number) {
1707   ::raise(signal_number);
1708 }
1709 
1710 //
1711 // The following code is moved from os.cpp for making this
1712 // code platform specific, which it is by its very nature.
1713 //
1714 
1715 // Will be modified when max signal is changed to be dynamic
1716 int os::sigexitnum_pd() {
1717   return NSIG;
1718 }
1719 
1720 // a counter for each possible signal value
1721 static volatile jint pending_signals[NSIG+1] = { 0 };
1722 
1723 // Wrapper functions for: sem_init(), sem_post(), sem_wait()
1724 // On AIX, we use sem_init(), sem_post(), sem_wait()
1725 // On Pase, we need to use msem_lock() and msem_unlock(), because Posix Semaphores
1726 // do not seem to work at all on PASE (unimplemented, will cause SIGILL).
1727 // Note that just using msem_.. APIs for both PASE and AIX is not an option either, as
1728 // on AIX, msem_..() calls are suspected of causing problems.
1729 static sem_t sig_sem;
1730 static msemaphore* p_sig_msem = 0;
1731 
1732 static void local_sem_init() {
1733   if (os::Aix::on_aix()) {
1734     int rc = ::sem_init(&amp;sig_sem, 0, 0);
1735     guarantee(rc != -1, &quot;sem_init failed&quot;);
1736   } else {
1737     // Memory semaphores must live in shared mem.
1738     guarantee0(p_sig_msem == NULL);
1739     p_sig_msem = (msemaphore*)os::reserve_memory(sizeof(msemaphore), NULL);
1740     guarantee(p_sig_msem, &quot;Cannot allocate memory for memory semaphore&quot;);
1741     guarantee(::msem_init(p_sig_msem, 0) == p_sig_msem, &quot;msem_init failed&quot;);
1742   }
1743 }
1744 
1745 static void local_sem_post() {
1746   static bool warn_only_once = false;
1747   if (os::Aix::on_aix()) {
1748     int rc = ::sem_post(&amp;sig_sem);
1749     if (rc == -1 &amp;&amp; !warn_only_once) {
1750       trcVerbose(&quot;sem_post failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1751       warn_only_once = true;
1752     }
1753   } else {
1754     guarantee0(p_sig_msem != NULL);
1755     int rc = ::msem_unlock(p_sig_msem, 0);
1756     if (rc == -1 &amp;&amp; !warn_only_once) {
1757       trcVerbose(&quot;msem_unlock failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1758       warn_only_once = true;
1759     }
1760   }
1761 }
1762 
1763 static void local_sem_wait() {
1764   static bool warn_only_once = false;
1765   if (os::Aix::on_aix()) {
1766     int rc = ::sem_wait(&amp;sig_sem);
1767     if (rc == -1 &amp;&amp; !warn_only_once) {
1768       trcVerbose(&quot;sem_wait failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1769       warn_only_once = true;
1770     }
1771   } else {
1772     guarantee0(p_sig_msem != NULL); // must init before use
1773     int rc = ::msem_lock(p_sig_msem, 0);
1774     if (rc == -1 &amp;&amp; !warn_only_once) {
1775       trcVerbose(&quot;msem_lock failed (errno = %d, %s)&quot;, errno, os::errno_name(errno));
1776       warn_only_once = true;
1777     }
1778   }
1779 }
1780 
1781 static void jdk_misc_signal_init() {
1782   // Initialize signal structures
1783   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
1784 
1785   // Initialize signal semaphore
1786   local_sem_init();
1787 }
1788 
1789 void os::signal_notify(int sig) {
1790   Atomic::inc(&amp;pending_signals[sig]);
1791   local_sem_post();
1792 }
1793 
1794 static int check_pending_signals() {
<a name="33" id="anc33"></a>
1795   for (;;) {
1796     for (int i = 0; i &lt; NSIG + 1; i++) {
1797       jint n = pending_signals[i];
<a name="34" id="anc34"></a><span class="line-modified">1798       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
1799         return i;
1800       }
1801     }
1802     JavaThread *thread = JavaThread::current();
1803     ThreadBlockInVM tbivm(thread);
1804 
1805     bool threadIsSuspended;
1806     do {
1807       thread-&gt;set_suspend_equivalent();
1808       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
1809 
1810       local_sem_wait();
1811 
1812       // were we externally suspended while we were waiting?
1813       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
1814       if (threadIsSuspended) {
1815         //
1816         // The semaphore has been incremented, but while we were waiting
1817         // another thread suspended us. We don&#39;t want to continue running
1818         // while suspended because that would surprise the thread that
1819         // suspended us.
1820         //
1821 
1822         local_sem_post();
1823 
1824         thread-&gt;java_suspend_self();
1825       }
1826     } while (threadIsSuspended);
1827   }
1828 }
1829 
1830 int os::signal_wait() {
1831   return check_pending_signals();
1832 }
1833 
1834 ////////////////////////////////////////////////////////////////////////////////
1835 // Virtual Memory
1836 
1837 // We need to keep small simple bookkeeping for os::reserve_memory and friends.
1838 
1839 #define VMEM_MAPPED  1
1840 #define VMEM_SHMATED 2
1841 
1842 struct vmembk_t {
1843   int type;         // 1 - mmap, 2 - shmat
1844   char* addr;
1845   size_t size;      // Real size, may be larger than usersize.
1846   size_t pagesize;  // page size of area
1847   vmembk_t* next;
1848 
1849   bool contains_addr(char* p) const {
1850     return p &gt;= addr &amp;&amp; p &lt; (addr + size);
1851   }
1852 
1853   bool contains_range(char* p, size_t s) const {
1854     return contains_addr(p) &amp;&amp; contains_addr(p + s - 1);
1855   }
1856 
1857   void print_on(outputStream* os) const {
1858     os-&gt;print(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] (&quot; UINTX_FORMAT
1859       &quot; bytes, %d %s pages), %s&quot;,
1860       addr, addr + size - 1, size, size / pagesize, describe_pagesize(pagesize),
1861       (type == VMEM_SHMATED ? &quot;shmat&quot; : &quot;mmap&quot;)
1862     );
1863   }
1864 
1865   // Check that range is a sub range of memory block (or equal to memory block);
1866   // also check that range is fully page aligned to the page size if the block.
1867   void assert_is_valid_subrange(char* p, size_t s) const {
1868     if (!contains_range(p, s)) {
1869       trcVerbose(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not a sub &quot;
1870               &quot;range of [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<a name="35" id="anc35"></a><span class="line-modified">1871               p2i(p), p2i(p + s), p2i(addr), p2i(addr + size));</span>
1872       guarantee0(false);
1873     }
1874     if (!is_aligned_to(p, pagesize) || !is_aligned_to(p + s, pagesize)) {
1875       trcVerbose(&quot;range [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not&quot;
<a name="36" id="anc36"></a><span class="line-modified">1876               &quot; aligned to pagesize (%lu)&quot;, p2i(p), p2i(p + s), (unsigned long) pagesize);</span>
1877       guarantee0(false);
1878     }
1879   }
1880 };
1881 
1882 static struct {
1883   vmembk_t* first;
1884   MiscUtils::CritSect cs;
1885 } vmem;
1886 
1887 static void vmembk_add(char* addr, size_t size, size_t pagesize, int type) {
1888   vmembk_t* p = (vmembk_t*) ::malloc(sizeof(vmembk_t));
1889   assert0(p);
1890   if (p) {
1891     MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1892     p-&gt;addr = addr; p-&gt;size = size;
1893     p-&gt;pagesize = pagesize;
1894     p-&gt;type = type;
1895     p-&gt;next = vmem.first;
1896     vmem.first = p;
1897   }
1898 }
1899 
1900 static vmembk_t* vmembk_find(char* addr) {
1901   MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1902   for (vmembk_t* p = vmem.first; p; p = p-&gt;next) {
1903     if (p-&gt;addr &lt;= addr &amp;&amp; (p-&gt;addr + p-&gt;size) &gt; addr) {
1904       return p;
1905     }
1906   }
1907   return NULL;
1908 }
1909 
1910 static void vmembk_remove(vmembk_t* p0) {
1911   MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1912   assert0(p0);
1913   assert0(vmem.first); // List should not be empty.
1914   for (vmembk_t** pp = &amp;(vmem.first); *pp; pp = &amp;((*pp)-&gt;next)) {
1915     if (*pp == p0) {
1916       *pp = p0-&gt;next;
1917       ::free(p0);
1918       return;
1919     }
1920   }
1921   assert0(false); // Not found?
1922 }
1923 
1924 static void vmembk_print_on(outputStream* os) {
1925   MiscUtils::AutoCritSect lck(&amp;vmem.cs);
1926   for (vmembk_t* vmi = vmem.first; vmi; vmi = vmi-&gt;next) {
1927     vmi-&gt;print_on(os);
1928     os-&gt;cr();
1929   }
1930 }
1931 
1932 // Reserve and attach a section of System V memory.
1933 // If &lt;requested_addr&gt; is not NULL, function will attempt to attach the memory at the given
1934 // address. Failing that, it will attach the memory anywhere.
1935 // If &lt;requested_addr&gt; is NULL, function will attach the memory anywhere.
1936 //
1937 // &lt;alignment_hint&gt; is being ignored by this function. It is very probable however that the
1938 // alignment requirements are met anyway, because shmat() attaches at 256M boundaries.
1939 // Should this be not enogh, we can put more work into it.
1940 static char* reserve_shmated_memory (
1941   size_t bytes,
1942   char* requested_addr,
1943   size_t alignment_hint) {
1944 
1945   trcVerbose(&quot;reserve_shmated_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot;
1946     PTR_FORMAT &quot;, alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<a name="37" id="anc37"></a><span class="line-modified">1947     bytes, p2i(requested_addr), alignment_hint);</span>
1948 
1949   // Either give me wish address or wish alignment but not both.
1950   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint != 0));
1951 
1952   // We must prevent anyone from attaching too close to the
1953   // BRK because that may cause malloc OOM.
1954   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
1955     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<a name="38" id="anc38"></a><span class="line-modified">1956       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
1957     // Act like the OS refused to attach there.
1958     requested_addr = NULL;
1959   }
1960 
1961   // For old AS/400&#39;s (V5R4 and older) we should not even be here - System V shared memory is not
1962   // really supported (max size 4GB), so reserve_mmapped_memory should have been used instead.
1963   if (os::Aix::on_pase_V5R4_or_older()) {
1964     ShouldNotReachHere();
1965   }
1966 
1967   // Align size of shm up to 64K to avoid errors if we later try to change the page size.
1968   const size_t size = align_up(bytes, 64*K);
1969 
1970   // Reserve the shared segment.
1971   int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | S_IRUSR | S_IWUSR);
1972   if (shmid == -1) {
1973     trcVerbose(&quot;shmget(.., &quot; UINTX_FORMAT &quot;, ..) failed (errno: %d).&quot;, size, errno);
1974     return NULL;
1975   }
1976 
1977   // Important note:
1978   // It is very important that we, upon leaving this function, do not leave a shm segment alive.
1979   // We must right after attaching it remove it from the system. System V shm segments are global and
1980   // survive the process.
1981   // So, from here on: Do not assert, do not return, until we have called shmctl(IPC_RMID) (A).
1982 
1983   struct shmid_ds shmbuf;
1984   memset(&amp;shmbuf, 0, sizeof(shmbuf));
1985   shmbuf.shm_pagesize = 64*K;
1986   if (shmctl(shmid, SHM_PAGESIZE, &amp;shmbuf) != 0) {
1987     trcVerbose(&quot;Failed to set page size (need &quot; UINTX_FORMAT &quot; 64K pages) - shmctl failed with %d.&quot;,
1988                size / (64*K), errno);
1989     // I want to know if this ever happens.
1990     assert(false, &quot;failed to set page size for shmat&quot;);
1991   }
1992 
1993   // Now attach the shared segment.
1994   // Note that I attach with SHM_RND - which means that the requested address is rounded down, if
1995   // needed, to the next lowest segment boundary. Otherwise the attach would fail if the address
1996   // were not a segment boundary.
1997   char* const addr = (char*) shmat(shmid, requested_addr, SHM_RND);
1998   const int errno_shmat = errno;
1999 
2000   // (A) Right after shmat and before handing shmat errors delete the shm segment.
2001   if (::shmctl(shmid, IPC_RMID, NULL) == -1) {
2002     trcVerbose(&quot;shmctl(%u, IPC_RMID) failed (%d)\n&quot;, shmid, errno);
2003     assert(false, &quot;failed to remove shared memory segment!&quot;);
2004   }
2005 
2006   // Handle shmat error. If we failed to attach, just return.
2007   if (addr == (char*)-1) {
<a name="39" id="anc39"></a><span class="line-modified">2008     trcVerbose(&quot;Failed to attach segment at &quot; PTR_FORMAT &quot; (%d).&quot;, p2i(requested_addr), errno_shmat);</span>
2009     return NULL;
2010   }
2011 
2012   // Just for info: query the real page size. In case setting the page size did not
2013   // work (see above), the system may have given us something other then 4K (LDR_CNTRL).
2014   const size_t real_pagesize = os::Aix::query_pagesize(addr);
2015   if (real_pagesize != shmbuf.shm_pagesize) {
<a name="40" id="anc40"></a><span class="line-modified">2016     trcVerbose(&quot;pagesize is, surprisingly, &quot; SIZE_FORMAT, real_pagesize);</span>
2017   }
2018 
2019   if (addr) {
2020     trcVerbose(&quot;shm-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes, &quot; UINTX_FORMAT &quot; %s pages)&quot;,
<a name="41" id="anc41"></a><span class="line-modified">2021       p2i(addr), p2i(addr + size - 1), size, size/real_pagesize, describe_pagesize(real_pagesize));</span>
2022   } else {
2023     if (requested_addr != NULL) {
<a name="42" id="anc42"></a><span class="line-modified">2024       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at with address &quot; PTR_FORMAT &quot;.&quot;, size, p2i(requested_addr));</span>
2025     } else {
2026       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, size);
2027     }
2028   }
2029 
2030   // book-keeping
2031   vmembk_add(addr, size, real_pagesize, VMEM_SHMATED);
2032   assert0(is_aligned_to(addr, os::vm_page_size()));
2033 
2034   return addr;
2035 }
2036 
2037 static bool release_shmated_memory(char* addr, size_t size) {
2038 
2039   trcVerbose(&quot;release_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<a name="43" id="anc43"></a><span class="line-modified">2040     p2i(addr), p2i(addr + size - 1));</span>
2041 
2042   bool rc = false;
2043 
2044   // TODO: is there a way to verify shm size without doing bookkeeping?
2045   if (::shmdt(addr) != 0) {
2046     trcVerbose(&quot;error (%d).&quot;, errno);
2047   } else {
2048     trcVerbose(&quot;ok.&quot;);
2049     rc = true;
2050   }
2051   return rc;
2052 }
2053 
2054 static bool uncommit_shmated_memory(char* addr, size_t size) {
2055   trcVerbose(&quot;uncommit_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<a name="44" id="anc44"></a><span class="line-modified">2056     p2i(addr), p2i(addr + size - 1));</span>
2057 
2058   const bool rc = my_disclaim64(addr, size);
2059 
2060   if (!rc) {
<a name="45" id="anc45"></a><span class="line-modified">2061     trcVerbose(&quot;my_disclaim64(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;) failed.\n&quot;, p2i(addr), size);</span>
2062     return false;
2063   }
2064   return true;
2065 }
2066 
2067 ////////////////////////////////  mmap-based routines /////////////////////////////////
2068 
2069 // Reserve memory via mmap.
2070 // If &lt;requested_addr&gt; is given, an attempt is made to attach at the given address.
2071 // Failing that, memory is allocated at any address.
2072 // If &lt;alignment_hint&gt; is given and &lt;requested_addr&gt; is NULL, an attempt is made to
2073 // allocate at an address aligned with the given alignment. Failing that, memory
2074 // is aligned anywhere.
2075 static char* reserve_mmaped_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2076   trcVerbose(&quot;reserve_mmaped_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot; PTR_FORMAT &quot;, &quot;
2077     &quot;alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<a name="46" id="anc46"></a><span class="line-modified">2078     bytes, p2i(requested_addr), alignment_hint);</span>
2079 
2080   // If a wish address is given, but not aligned to 4K page boundary, mmap will fail.
2081   if (requested_addr &amp;&amp; !is_aligned_to(requested_addr, os::vm_page_size()) != 0) {
<a name="47" id="anc47"></a><span class="line-modified">2082     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; not aligned to page boundary.&quot;, p2i(requested_addr));</span>
2083     return NULL;
2084   }
2085 
2086   // We must prevent anyone from attaching too close to the
2087   // BRK because that may cause malloc OOM.
2088   if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
2089     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<a name="48" id="anc48"></a><span class="line-modified">2090       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
2091     // Act like the OS refused to attach there.
2092     requested_addr = NULL;
2093   }
2094 
2095   // Specify one or the other but not both.
2096   assert0(!(requested_addr != NULL &amp;&amp; alignment_hint &gt; 0));
2097 
2098   // In 64K mode, we claim the global page size (os::vm_page_size())
2099   // is 64K. This is one of the few points where that illusion may
2100   // break, because mmap() will always return memory aligned to 4K. So
2101   // we must ensure we only ever return memory aligned to 64k.
2102   if (alignment_hint) {
2103     alignment_hint = lcm(alignment_hint, os::vm_page_size());
2104   } else {
2105     alignment_hint = os::vm_page_size();
2106   }
2107 
2108   // Size shall always be a multiple of os::vm_page_size (esp. in 64K mode).
2109   const size_t size = align_up(bytes, os::vm_page_size());
2110 
2111   // alignment: Allocate memory large enough to include an aligned range of the right size and
2112   // cut off the leading and trailing waste pages.
2113   assert0(alignment_hint != 0 &amp;&amp; is_aligned_to(alignment_hint, os::vm_page_size())); // see above
2114   const size_t extra_size = size + alignment_hint;
2115 
2116   // Note: MAP_SHARED (instead of MAP_PRIVATE) needed to be able to
2117   // later use msync(MS_INVALIDATE) (see os::uncommit_memory).
2118   int flags = MAP_ANONYMOUS | MAP_SHARED;
2119 
2120   // MAP_FIXED is needed to enforce requested_addr - manpage is vague about what
2121   // it means if wishaddress is given but MAP_FIXED is not set.
2122   //
2123   // Important! Behaviour differs depending on whether SPEC1170 mode is active or not.
2124   // SPEC1170 mode active: behaviour like POSIX, MAP_FIXED will clobber existing mappings.
2125   // SPEC1170 mode not active: behaviour, unlike POSIX, is that no existing mappings will
2126   // get clobbered.
2127   if (requested_addr != NULL) {
2128     if (!os::Aix::xpg_sus_mode()) {  // not SPEC1170 Behaviour
2129       flags |= MAP_FIXED;
2130     }
2131   }
2132 
2133   char* addr = (char*)::mmap(requested_addr, extra_size,
2134       PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);
2135 
2136   if (addr == MAP_FAILED) {
<a name="49" id="anc49"></a><span class="line-modified">2137     trcVerbose(&quot;mmap(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;, ..) failed (%d)&quot;, p2i(requested_addr), size, errno);</span>
2138     return NULL;
2139   }
2140 
2141   // Handle alignment.
2142   char* const addr_aligned = align_up(addr, alignment_hint);
2143   const size_t waste_pre = addr_aligned - addr;
2144   char* const addr_aligned_end = addr_aligned + size;
2145   const size_t waste_post = extra_size - waste_pre - size;
2146   if (waste_pre &gt; 0) {
2147     ::munmap(addr, waste_pre);
2148   }
2149   if (waste_post &gt; 0) {
2150     ::munmap(addr_aligned_end, waste_post);
2151   }
2152   addr = addr_aligned;
2153 
2154   if (addr) {
2155     trcVerbose(&quot;mmap-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes)&quot;,
<a name="50" id="anc50"></a><span class="line-modified">2156       p2i(addr), p2i(addr + bytes), bytes);</span>
2157   } else {
2158     if (requested_addr != NULL) {
<a name="51" id="anc51"></a><span class="line-modified">2159       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at wish address &quot; PTR_FORMAT &quot;.&quot;, bytes, p2i(requested_addr));</span>
2160     } else {
2161       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, bytes);
2162     }
2163   }
2164 
2165   // bookkeeping
2166   vmembk_add(addr, size, 4*K, VMEM_MAPPED);
2167 
2168   // Test alignment, see above.
2169   assert0(is_aligned_to(addr, os::vm_page_size()));
2170 
2171   return addr;
2172 }
2173 
2174 static bool release_mmaped_memory(char* addr, size_t size) {
2175   assert0(is_aligned_to(addr, os::vm_page_size()));
2176   assert0(is_aligned_to(size, os::vm_page_size()));
2177 
2178   trcVerbose(&quot;release_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<a name="52" id="anc52"></a><span class="line-modified">2179     p2i(addr), p2i(addr + size - 1));</span>
2180   bool rc = false;
2181 
2182   if (::munmap(addr, size) != 0) {
2183     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2184     rc = false;
2185   } else {
2186     trcVerbose(&quot;ok.&quot;);
2187     rc = true;
2188   }
2189 
2190   return rc;
2191 }
2192 
2193 static bool uncommit_mmaped_memory(char* addr, size_t size) {
2194 
2195   assert0(is_aligned_to(addr, os::vm_page_size()));
2196   assert0(is_aligned_to(size, os::vm_page_size()));
2197 
2198   trcVerbose(&quot;uncommit_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<a name="53" id="anc53"></a><span class="line-modified">2199     p2i(addr), p2i(addr + size - 1));</span>
2200   bool rc = false;
2201 
2202   // Uncommit mmap memory with msync MS_INVALIDATE.
2203   if (::msync(addr, size, MS_INVALIDATE) != 0) {
2204     trcVerbose(&quot;failed (%d)\n&quot;, errno);
2205     rc = false;
2206   } else {
2207     trcVerbose(&quot;ok.&quot;);
2208     rc = true;
2209   }
2210 
2211   return rc;
2212 }
2213 
2214 int os::vm_page_size() {
2215   // Seems redundant as all get out.
2216   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2217   return os::Aix::page_size();
2218 }
2219 
2220 // Aix allocates memory by pages.
2221 int os::vm_allocation_granularity() {
2222   assert(os::Aix::page_size() != -1, &quot;must call os::init&quot;);
2223   return os::Aix::page_size();
2224 }
2225 
2226 #ifdef PRODUCT
2227 static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
2228                                     int err) {
2229   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
<a name="54" id="anc54"></a><span class="line-modified">2230           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, p2i(addr), size, exec,</span>
2231           os::errno_name(err), err);
2232 }
2233 #endif
2234 
2235 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
2236                                   const char* mesg) {
2237   assert(mesg != NULL, &quot;mesg must be specified&quot;);
2238   if (!pd_commit_memory(addr, size, exec)) {
2239     // Add extra info in product mode for vm_exit_out_of_memory():
2240     PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)
2241     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
2242   }
2243 }
2244 
2245 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
2246 
2247   assert(is_aligned_to(addr, os::vm_page_size()),
2248     &quot;addr &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2249     p2i(addr), os::vm_page_size());
2250   assert(is_aligned_to(size, os::vm_page_size()),
2251     &quot;size &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2252     size, os::vm_page_size());
2253 
2254   vmembk_t* const vmi = vmembk_find(addr);
2255   guarantee0(vmi);
2256   vmi-&gt;assert_is_valid_subrange(addr, size);
2257 
<a name="55" id="anc55"></a><span class="line-modified">2258   trcVerbose(&quot;commit_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;, p2i(addr), p2i(addr + size - 1));</span>
2259 
2260   if (UseExplicitCommit) {
2261     // AIX commits memory on touch. So, touch all pages to be committed.
2262     for (char* p = addr; p &lt; (addr + size); p += 4*K) {
2263       *p = &#39;\0&#39;;
2264     }
2265   }
2266 
2267   return true;
2268 }
2269 
2270 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint, bool exec) {
2271   return pd_commit_memory(addr, size, exec);
2272 }
2273 
2274 void os::pd_commit_memory_or_exit(char* addr, size_t size,
2275                                   size_t alignment_hint, bool exec,
2276                                   const char* mesg) {
2277   // Alignment_hint is ignored on this OS.
2278   pd_commit_memory_or_exit(addr, size, exec, mesg);
2279 }
2280 
2281 bool os::pd_uncommit_memory(char* addr, size_t size) {
2282   assert(is_aligned_to(addr, os::vm_page_size()),
2283     &quot;addr &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2284     p2i(addr), os::vm_page_size());
2285   assert(is_aligned_to(size, os::vm_page_size()),
2286     &quot;size &quot; PTR_FORMAT &quot; not aligned to vm_page_size (&quot; PTR_FORMAT &quot;)&quot;,
2287     size, os::vm_page_size());
2288 
2289   // Dynamically do different things for mmap/shmat.
2290   const vmembk_t* const vmi = vmembk_find(addr);
2291   guarantee0(vmi);
2292   vmi-&gt;assert_is_valid_subrange(addr, size);
2293 
2294   if (vmi-&gt;type == VMEM_SHMATED) {
2295     return uncommit_shmated_memory(addr, size);
2296   } else {
2297     return uncommit_mmaped_memory(addr, size);
2298   }
2299 }
2300 
2301 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
2302   // Do not call this; no need to commit stack pages on AIX.
2303   ShouldNotReachHere();
2304   return true;
2305 }
2306 
2307 bool os::remove_stack_guard_pages(char* addr, size_t size) {
2308   // Do not call this; no need to commit stack pages on AIX.
2309   ShouldNotReachHere();
2310   return true;
2311 }
2312 
2313 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {
2314 }
2315 
2316 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {
2317 }
2318 
2319 void os::numa_make_global(char *addr, size_t bytes) {
2320 }
2321 
2322 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {
2323 }
2324 
2325 bool os::numa_topology_changed() {
2326   return false;
2327 }
2328 
2329 size_t os::numa_get_groups_num() {
2330   return 1;
2331 }
2332 
2333 int os::numa_get_group_id() {
2334   return 0;
2335 }
2336 
2337 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
2338   if (size &gt; 0) {
2339     ids[0] = 0;
2340     return 1;
2341   }
2342   return 0;
2343 }
2344 
<a name="56" id="anc56"></a><span class="line-added">2345 int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="line-added">2346   return 0;</span>
<span class="line-added">2347 }</span>
<span class="line-added">2348 </span>
2349 bool os::get_page_info(char *start, page_info* info) {
2350   return false;
2351 }
2352 
2353 char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
2354   return end;
2355 }
2356 
2357 // Reserves and attaches a shared memory segment.
2358 // Will assert if a wish address is given and could not be obtained.
2359 char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
2360 
2361   // All other Unices do a mmap(MAP_FIXED) if the addr is given,
2362   // thereby clobbering old mappings at that place. That is probably
2363   // not intended, never used and almost certainly an error were it
2364   // ever be used this way (to try attaching at a specified address
2365   // without clobbering old mappings an alternate API exists,
2366   // os::attempt_reserve_memory_at()).
2367   // Instead of mimicking the dangerous coding of the other platforms, here I
2368   // just ignore the request address (release) or assert(debug).
2369   assert0(requested_addr == NULL);
2370 
2371   // Always round to os::vm_page_size(), which may be larger than 4K.
2372   bytes = align_up(bytes, os::vm_page_size());
2373   const size_t alignment_hint0 =
2374     alignment_hint ? align_up(alignment_hint, os::vm_page_size()) : 0;
2375 
2376   // In 4K mode always use mmap.
2377   // In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.
2378   if (os::vm_page_size() == 4*K) {
2379     return reserve_mmaped_memory(bytes, requested_addr, alignment_hint);
2380   } else {
2381     if (bytes &gt;= Use64KPagesThreshold) {
2382       return reserve_shmated_memory(bytes, requested_addr, alignment_hint);
2383     } else {
2384       return reserve_mmaped_memory(bytes, requested_addr, alignment_hint);
2385     }
2386   }
2387 }
2388 
2389 bool os::pd_release_memory(char* addr, size_t size) {
2390 
2391   // Dynamically do different things for mmap/shmat.
2392   vmembk_t* const vmi = vmembk_find(addr);
2393   guarantee0(vmi);
2394 
2395   // Always round to os::vm_page_size(), which may be larger than 4K.
2396   size = align_up(size, os::vm_page_size());
2397   addr = align_up(addr, os::vm_page_size());
2398 
2399   bool rc = false;
2400   bool remove_bookkeeping = false;
2401   if (vmi-&gt;type == VMEM_SHMATED) {
2402     // For shmatted memory, we do:
2403     // - If user wants to release the whole range, release the memory (shmdt).
2404     // - If user only wants to release a partial range, uncommit (disclaim) that
2405     //   range. That way, at least, we do not use memory anymore (bust still page
2406     //   table space).
2407     vmi-&gt;assert_is_valid_subrange(addr, size);
2408     if (addr == vmi-&gt;addr &amp;&amp; size == vmi-&gt;size) {
2409       rc = release_shmated_memory(addr, size);
2410       remove_bookkeeping = true;
2411     } else {
2412       rc = uncommit_shmated_memory(addr, size);
2413     }
2414   } else {
2415     // User may unmap partial regions but region has to be fully contained.
2416 #ifdef ASSERT
2417     vmi-&gt;assert_is_valid_subrange(addr, size);
2418 #endif
2419     rc = release_mmaped_memory(addr, size);
2420     remove_bookkeeping = true;
2421   }
2422 
2423   // update bookkeeping
2424   if (rc &amp;&amp; remove_bookkeeping) {
2425     vmembk_remove(vmi);
2426   }
2427 
2428   return rc;
2429 }
2430 
2431 static bool checked_mprotect(char* addr, size_t size, int prot) {
2432 
2433   // Little problem here: if SPEC1170 behaviour is off, mprotect() on AIX will
2434   // not tell me if protection failed when trying to protect an un-protectable range.
2435   //
2436   // This means if the memory was allocated using shmget/shmat, protection wont work
2437   // but mprotect will still return 0:
2438   //
2439   // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm
2440 
<a name="57" id="anc57"></a><span class="line-added">2441   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
2442   bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;
2443 
2444   if (!rc) {
2445     const char* const s_errno = os::errno_name(errno);
2446     warning(&quot;mprotect(&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;, 0x%X) failed (%s).&quot;, addr, addr + size, prot, s_errno);
2447     return false;
2448   }
2449 
2450   // mprotect success check
2451   //
2452   // Mprotect said it changed the protection but can I believe it?
2453   //
2454   // To be sure I need to check the protection afterwards. Try to
2455   // read from protected memory and check whether that causes a segfault.
2456   //
2457   if (!os::Aix::xpg_sus_mode()) {
2458 
2459     if (CanUseSafeFetch32()) {
2460 
2461       const bool read_protected =
2462         (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2463          SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2464 
2465       if (prot &amp; PROT_READ) {
2466         rc = !read_protected;
2467       } else {
2468         rc = read_protected;
2469       }
2470 
2471       if (!rc) {
2472         if (os::Aix::on_pase()) {
2473           // There is an issue on older PASE systems where mprotect() will return success but the
2474           // memory will not be protected.
2475           // This has nothing to do with the problem of using mproect() on SPEC1170 incompatible
2476           // machines; we only see it rarely, when using mprotect() to protect the guard page of
2477           // a stack. It is an OS error.
2478           //
2479           // A valid strategy is just to try again. This usually works. :-/
2480 
2481           ::usleep(1000);
<a name="58" id="anc58"></a><span class="line-added">2482           Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
2483           if (::mprotect(addr, size, prot) == 0) {
2484             const bool read_protected_2 =
2485               (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
2486               SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
2487             rc = true;
2488           }
2489         }
2490       }
2491     }
2492   }
2493 
2494   assert(rc == true, &quot;mprotect failed.&quot;);
2495 
2496   return rc;
2497 }
2498 
2499 // Set protections specified
2500 bool os::protect_memory(char* addr, size_t size, ProtType prot, bool is_committed) {
2501   unsigned int p = 0;
2502   switch (prot) {
2503   case MEM_PROT_NONE: p = PROT_NONE; break;
2504   case MEM_PROT_READ: p = PROT_READ; break;
2505   case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;
2506   case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;
2507   default:
2508     ShouldNotReachHere();
2509   }
2510   // is_committed is unused.
2511   return checked_mprotect(addr, size, p);
2512 }
2513 
2514 bool os::guard_memory(char* addr, size_t size) {
2515   return checked_mprotect(addr, size, PROT_NONE);
2516 }
2517 
2518 bool os::unguard_memory(char* addr, size_t size) {
2519   return checked_mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC);
2520 }
2521 
2522 // Large page support
2523 
2524 static size_t _large_page_size = 0;
2525 
2526 // Enable large page support if OS allows that.
2527 void os::large_page_init() {
2528   return; // Nothing to do. See query_multipage_support and friends.
2529 }
2530 
2531 char* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {
2532   // reserve_memory_special() is used to allocate large paged memory. On AIX, we implement
2533   // 64k paged memory reservation using the normal memory allocation paths (os::reserve_memory()),
2534   // so this is not needed.
2535   assert(false, &quot;should not be called on AIX&quot;);
2536   return NULL;
2537 }
2538 
2539 bool os::release_memory_special(char* base, size_t bytes) {
2540   // Detaching the SHM segment will also delete it, see reserve_memory_special().
2541   Unimplemented();
2542   return false;
2543 }
2544 
2545 size_t os::large_page_size() {
2546   return _large_page_size;
2547 }
2548 
2549 bool os::can_commit_large_page_memory() {
2550   // Does not matter, we do not support huge pages.
2551   return false;
2552 }
2553 
2554 bool os::can_execute_large_page_memory() {
2555   // Does not matter, we do not support huge pages.
2556   return false;
2557 }
2558 
2559 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
2560   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
2561   char* result = NULL;
2562 
2563   // Always round to os::vm_page_size(), which may be larger than 4K.
2564   bytes = align_up(bytes, os::vm_page_size());
2565   result = reserve_mmaped_memory(bytes, requested_addr, 0);
2566 
2567   if (result != NULL) {
2568     if (replace_existing_mapping_with_file_mapping(result, bytes, file_desc) == NULL) {
2569       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
2570     }
2571   }
2572   return result;
2573 }
2574 
2575 // Reserve memory at an arbitrary address, only if that area is
2576 // available (and not reserved for something else).
2577 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
2578   char* addr = NULL;
2579 
2580   // Always round to os::vm_page_size(), which may be larger than 4K.
2581   bytes = align_up(bytes, os::vm_page_size());
2582 
2583   // In 4K mode always use mmap.
2584   // In 64K mode allocate small sizes with mmap, large ones with 64K shmatted.
2585   if (os::vm_page_size() == 4*K) {
2586     return reserve_mmaped_memory(bytes, requested_addr, 0);
2587   } else {
2588     if (bytes &gt;= Use64KPagesThreshold) {
2589       return reserve_shmated_memory(bytes, requested_addr, 0);
2590     } else {
2591       return reserve_mmaped_memory(bytes, requested_addr, 0);
2592     }
2593   }
2594 
2595   return addr;
2596 }
2597 
2598 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
2599 void os::infinite_sleep() {
2600   while (true) {    // sleep forever ...
2601     ::sleep(100);   // ... 100 seconds at a time
2602   }
2603 }
2604 
2605 // Used to convert frequent JVM_Yield() to nops
2606 bool os::dont_yield() {
2607   return DontYieldALot;
2608 }
2609 
2610 void os::naked_yield() {
2611   sched_yield();
2612 }
2613 
2614 ////////////////////////////////////////////////////////////////////////////////
2615 // thread priority support
2616 
2617 // From AIX manpage to pthread_setschedparam
2618 // (see: http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?
2619 //    topic=/com.ibm.aix.basetechref/doc/basetrf1/pthread_setschedparam.htm):
2620 //
2621 // &quot;If schedpolicy is SCHED_OTHER, then sched_priority must be in the
2622 // range from 40 to 80, where 40 is the least favored priority and 80
2623 // is the most favored.&quot;
2624 //
2625 // (Actually, I doubt this even has an impact on AIX, as we do kernel
2626 // scheduling there; however, this still leaves iSeries.)
2627 //
2628 // We use the same values for AIX and PASE.
2629 int os::java_to_os_priority[CriticalPriority + 1] = {
2630   54,             // 0 Entry should never be used
2631 
2632   55,             // 1 MinPriority
2633   55,             // 2
2634   56,             // 3
2635 
2636   56,             // 4
2637   57,             // 5 NormPriority
2638   57,             // 6
2639 
2640   58,             // 7
2641   58,             // 8
2642   59,             // 9 NearMaxPriority
2643 
2644   60,             // 10 MaxPriority
2645 
2646   60              // 11 CriticalPriority
2647 };
2648 
<a name="59" id="anc59"></a><span class="line-added">2649 static int prio_init() {</span>
<span class="line-added">2650   if (ThreadPriorityPolicy == 1) {</span>
<span class="line-added">2651     if (geteuid() != 0) {</span>
<span class="line-added">2652       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {</span>
<span class="line-added">2653         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \</span>
<span class="line-added">2654                 &quot;e.g., being the root user. If the necessary permission is not &quot; \</span>
<span class="line-added">2655                 &quot;possessed, changes to priority will be silently ignored.&quot;);</span>
<span class="line-added">2656       }</span>
<span class="line-added">2657     }</span>
<span class="line-added">2658   }</span>
<span class="line-added">2659   if (UseCriticalJavaThreadPriority) {</span>
<span class="line-added">2660     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];</span>
<span class="line-added">2661   }</span>
<span class="line-added">2662   return 0;</span>
<span class="line-added">2663 }</span>
<span class="line-added">2664 </span>
2665 OSReturn os::set_native_priority(Thread* thread, int newpri) {
<a name="60" id="anc60"></a><span class="line-modified">2666   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;</span>
2667   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2668   int policy = SCHED_OTHER;
2669   struct sched_param param;
2670   param.sched_priority = newpri;
2671   int ret = pthread_setschedparam(thr, policy, &amp;param);
2672 
2673   if (ret != 0) {
2674     trcVerbose(&quot;Could not change priority for thread %d to %d (error %d, %s)&quot;,
2675         (int)thr, newpri, ret, os::errno_name(ret));
2676   }
2677   return (ret == 0) ? OS_OK : OS_ERR;
2678 }
2679 
2680 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
<a name="61" id="anc61"></a><span class="line-modified">2681   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) {</span>
2682     *priority_ptr = java_to_os_priority[NormPriority];
2683     return OS_OK;
2684   }
2685   pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
2686   int policy = SCHED_OTHER;
2687   struct sched_param param;
2688   int ret = pthread_getschedparam(thr, &amp;policy, &amp;param);
2689   *priority_ptr = param.sched_priority;
2690 
2691   return (ret == 0) ? OS_OK : OS_ERR;
2692 }
2693 
2694 ////////////////////////////////////////////////////////////////////////////////
2695 // suspend/resume support
2696 
2697 //  The low-level signal-based suspend/resume support is a remnant from the
2698 //  old VM-suspension that used to be for java-suspension, safepoints etc,
2699 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2700 //
2701 //  The remaining code is greatly simplified from the more general suspension
2702 //  code that used to be used.
2703 //
2704 //  The protocol is quite simple:
2705 //  - suspend:
2706 //      - sends a signal to the target thread
2707 //      - polls the suspend state of the osthread using a yield loop
2708 //      - target thread signal handler (SR_handler) sets suspend state
2709 //        and blocks in sigsuspend until continued
2710 //  - resume:
2711 //      - sets target osthread state to continue
2712 //      - sends signal to end the sigsuspend loop in the SR_handler
2713 //
2714 //  Note that the SR_lock plays no role in this suspend/resume protocol,
2715 //  but is checked for NULL in SR_handler as a thread termination indicator.
2716 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
2717 //
2718 //  Note that resume_clear_context() and suspend_save_context() are needed
2719 //  by SR_handler(), so that fetch_frame_from_ucontext() works,
2720 //  which in part is used by:
2721 //    - Forte Analyzer: AsyncGetCallTrace()
2722 //    - StackBanging: get_frame_at_stack_banging_point()
2723 
2724 static void resume_clear_context(OSThread *osthread) {
2725   osthread-&gt;set_ucontext(NULL);
2726   osthread-&gt;set_siginfo(NULL);
2727 }
2728 
2729 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {
2730   osthread-&gt;set_ucontext(context);
2731   osthread-&gt;set_siginfo(siginfo);
2732 }
2733 
2734 //
2735 // Handler function invoked when a thread&#39;s execution is suspended or
2736 // resumed. We have to be careful that only async-safe functions are
2737 // called here (Note: most pthread functions are not async safe and
2738 // should be avoided.)
2739 //
2740 // Note: sigwait() is a more natural fit than sigsuspend() from an
2741 // interface point of view, but sigwait() prevents the signal hander
2742 // from being run. libpthread would get very confused by not having
2743 // its signal handlers run and prevents sigwait()&#39;s use with the
2744 // mutex granting granting signal.
2745 //
2746 // Currently only ever called on the VMThread and JavaThreads (PC sampling).
2747 //
2748 static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {
2749   // Save and restore errno to avoid confusing native code with EINTR
2750   // after sigsuspend.
2751   int old_errno = errno;
2752 
2753   Thread* thread = Thread::current_or_null_safe();
2754   assert(thread != NULL, &quot;Missing current thread in SR_handler&quot;);
2755 
2756   // On some systems we have seen signal delivery get &quot;stuck&quot; until the signal
2757   // mask is changed as part of thread termination. Check that the current thread
2758   // has not already terminated (via SR_lock()) - else the following assertion
2759   // will fail because the thread is no longer a JavaThread as the ~JavaThread
2760   // destructor has completed.
2761 
2762   if (thread-&gt;SR_lock() == NULL) {
2763     return;
2764   }
2765 
2766   assert(thread-&gt;is_VM_thread() || thread-&gt;is_Java_thread(), &quot;Must be VMThread or JavaThread&quot;);
2767 
2768   OSThread* osthread = thread-&gt;osthread();
2769 
2770   os::SuspendResume::State current = osthread-&gt;sr.state();
2771   if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {
2772     suspend_save_context(osthread, siginfo, context);
2773 
2774     // attempt to switch the state, we assume we had a SUSPEND_REQUEST
2775     os::SuspendResume::State state = osthread-&gt;sr.suspended();
2776     if (state == os::SuspendResume::SR_SUSPENDED) {
2777       sigset_t suspend_set;  // signals for sigsuspend()
<a name="62" id="anc62"></a><span class="line-modified">2778       sigemptyset(&amp;suspend_set);</span>
2779       // get current set of blocked signals and unblock resume signal
2780       pthread_sigmask(SIG_BLOCK, NULL, &amp;suspend_set);
2781       sigdelset(&amp;suspend_set, SR_signum);
2782 
2783       // wait here until we are resumed
2784       while (1) {
2785         sigsuspend(&amp;suspend_set);
2786 
2787         os::SuspendResume::State result = osthread-&gt;sr.running();
2788         if (result == os::SuspendResume::SR_RUNNING) {
2789           break;
2790         }
2791       }
2792 
2793     } else if (state == os::SuspendResume::SR_RUNNING) {
2794       // request was cancelled, continue
2795     } else {
2796       ShouldNotReachHere();
2797     }
2798 
2799     resume_clear_context(osthread);
2800   } else if (current == os::SuspendResume::SR_RUNNING) {
2801     // request was cancelled, continue
2802   } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {
2803     // ignore
2804   } else {
2805     ShouldNotReachHere();
2806   }
2807 
2808   errno = old_errno;
2809 }
2810 
2811 static int SR_initialize() {
2812   struct sigaction act;
2813   char *s;
2814   // Get signal number to use for suspend/resume
2815   if ((s = ::getenv(&quot;_JAVA_SR_SIGNUM&quot;)) != 0) {
2816     int sig = ::strtol(s, 0, 10);
2817     if (sig &gt; MAX2(SIGSEGV, SIGBUS) &amp;&amp;  // See 4355769.
2818         sig &lt; NSIG) {                   // Must be legal signal and fit into sigflags[].
2819       SR_signum = sig;
2820     } else {
2821       warning(&quot;You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.&quot;,
2822               sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);
2823     }
2824   }
2825 
2826   assert(SR_signum &gt; SIGSEGV &amp;&amp; SR_signum &gt; SIGBUS,
2827         &quot;SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769&quot;);
2828 
2829   sigemptyset(&amp;SR_sigset);
2830   sigaddset(&amp;SR_sigset, SR_signum);
2831 
2832   // Set up signal handler for suspend/resume.
2833   act.sa_flags = SA_RESTART|SA_SIGINFO;
2834   act.sa_handler = (void (*)(int)) SR_handler;
2835 
2836   // SR_signum is blocked by default.
2837   pthread_sigmask(SIG_BLOCK, NULL, &amp;act.sa_mask);
2838 
2839   if (sigaction(SR_signum, &amp;act, 0) == -1) {
2840     return -1;
2841   }
2842 
2843   // Save signal flag
2844   os::Aix::set_our_sigflags(SR_signum, act.sa_flags);
2845   return 0;
2846 }
2847 
2848 static int SR_finalize() {
2849   return 0;
2850 }
2851 
2852 static int sr_notify(OSThread* osthread) {
2853   int status = pthread_kill(osthread-&gt;pthread_id(), SR_signum);
2854   assert_status(status == 0, status, &quot;pthread_kill&quot;);
2855   return status;
2856 }
2857 
2858 // &quot;Randomly&quot; selected value for how long we want to spin
2859 // before bailing out on suspending a thread, also how often
2860 // we send a signal to a thread we want to resume
2861 static const int RANDOMLY_LARGE_INTEGER = 1000000;
2862 static const int RANDOMLY_LARGE_INTEGER2 = 100;
2863 
2864 // returns true on success and false on error - really an error is fatal
2865 // but this seems the normal response to library errors
2866 static bool do_suspend(OSThread* osthread) {
2867   assert(osthread-&gt;sr.is_running(), &quot;thread should be running&quot;);
2868   // mark as suspended and send signal
2869 
2870   if (osthread-&gt;sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {
2871     // failed to switch, state wasn&#39;t running?
2872     ShouldNotReachHere();
2873     return false;
2874   }
2875 
2876   if (sr_notify(osthread) != 0) {
2877     // try to cancel, switch to running
2878 
2879     os::SuspendResume::State result = osthread-&gt;sr.cancel_suspend();
2880     if (result == os::SuspendResume::SR_RUNNING) {
2881       // cancelled
2882       return false;
2883     } else if (result == os::SuspendResume::SR_SUSPENDED) {
2884       // somehow managed to suspend
2885       return true;
2886     } else {
2887       ShouldNotReachHere();
2888       return false;
2889     }
2890   }
2891 
2892   // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED
2893 
2894   for (int n = 0; !osthread-&gt;sr.is_suspended(); n++) {
2895     for (int i = 0; i &lt; RANDOMLY_LARGE_INTEGER2 &amp;&amp; !osthread-&gt;sr.is_suspended(); i++) {
2896       os::naked_yield();
2897     }
2898 
2899     // timeout, try to cancel the request
2900     if (n &gt;= RANDOMLY_LARGE_INTEGER) {
2901       os::SuspendResume::State cancelled = osthread-&gt;sr.cancel_suspend();
2902       if (cancelled == os::SuspendResume::SR_RUNNING) {
2903         return false;
2904       } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {
2905         return true;
2906       } else {
2907         ShouldNotReachHere();
2908         return false;
2909       }
2910     }
2911   }
2912 
2913   guarantee(osthread-&gt;sr.is_suspended(), &quot;Must be suspended&quot;);
2914   return true;
2915 }
2916 
2917 static void do_resume(OSThread* osthread) {
2918   //assert(osthread-&gt;sr.is_suspended(), &quot;thread should be suspended&quot;);
2919 
2920   if (osthread-&gt;sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {
2921     // failed to switch to WAKEUP_REQUEST
2922     ShouldNotReachHere();
2923     return;
2924   }
2925 
2926   while (!osthread-&gt;sr.is_running()) {
2927     if (sr_notify(osthread) == 0) {
2928       for (int n = 0; n &lt; RANDOMLY_LARGE_INTEGER &amp;&amp; !osthread-&gt;sr.is_running(); n++) {
2929         for (int i = 0; i &lt; 100 &amp;&amp; !osthread-&gt;sr.is_running(); i++) {
2930           os::naked_yield();
2931         }
2932       }
2933     } else {
2934       ShouldNotReachHere();
2935     }
2936   }
2937 
2938   guarantee(osthread-&gt;sr.is_running(), &quot;Must be running!&quot;);
2939 }
2940 
2941 ///////////////////////////////////////////////////////////////////////////////////
2942 // signal handling (except suspend/resume)
2943 
2944 // This routine may be used by user applications as a &quot;hook&quot; to catch signals.
2945 // The user-defined signal handler must pass unrecognized signals to this
2946 // routine, and if it returns true (non-zero), then the signal handler must
2947 // return immediately. If the flag &quot;abort_if_unrecognized&quot; is true, then this
2948 // routine will never retun false (zero), but instead will execute a VM panic
2949 // routine kill the process.
2950 //
2951 // If this routine returns false, it is OK to call it again. This allows
2952 // the user-defined signal handler to perform checks either before or after
2953 // the VM performs its own checks. Naturally, the user code would be making
2954 // a serious error if it tried to handle an exception (such as a null check
2955 // or breakpoint) that the VM was generating for its own correct operation.
2956 //
2957 // This routine may recognize any of the following kinds of signals:
2958 //   SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.
2959 // It should be consulted by handlers for any of those signals.
2960 //
2961 // The caller of this routine must pass in the three arguments supplied
2962 // to the function referred to in the &quot;sa_sigaction&quot; (not the &quot;sa_handler&quot;)
2963 // field of the structure passed to sigaction(). This routine assumes that
2964 // the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.
2965 //
2966 // Note that the VM will print warnings if it detects conflicting signal
2967 // handlers, unless invoked with the option &quot;-XX:+AllowUserSignalHandlers&quot;.
2968 //
2969 extern &quot;C&quot; JNIEXPORT int
2970 JVM_handle_aix_signal(int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized);
2971 
2972 // Set thread signal mask (for some reason on AIX sigthreadmask() seems
2973 // to be the thing to call; documentation is not terribly clear about whether
2974 // pthread_sigmask also works, and if it does, whether it does the same.
2975 bool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {
2976   const int rc = ::pthread_sigmask(how, set, oset);
2977   // return value semantics differ slightly for error case:
2978   // pthread_sigmask returns error number, sigthreadmask -1 and sets global errno
2979   // (so, pthread_sigmask is more theadsafe for error handling)
2980   // But success is always 0.
2981   return rc == 0 ? true : false;
2982 }
2983 
2984 // Function to unblock all signals which are, according
2985 // to POSIX, typical program error signals. If they happen while being blocked,
2986 // they typically will bring down the process immediately.
2987 bool unblock_program_error_signals() {
2988   sigset_t set;
2989   ::sigemptyset(&amp;set);
2990   ::sigaddset(&amp;set, SIGILL);
2991   ::sigaddset(&amp;set, SIGBUS);
2992   ::sigaddset(&amp;set, SIGFPE);
2993   ::sigaddset(&amp;set, SIGSEGV);
2994   return set_thread_signal_mask(SIG_UNBLOCK, &amp;set, NULL);
2995 }
2996 
2997 // Renamed from &#39;signalHandler&#39; to avoid collision with other shared libs.
2998 static void javaSignalHandler(int sig, siginfo_t* info, void* uc) {
2999   assert(info != NULL &amp;&amp; uc != NULL, &quot;it must be old kernel&quot;);
3000 
3001   // Never leave program error signals blocked;
3002   // on all our platforms they would bring down the process immediately when
3003   // getting raised while being blocked.
3004   unblock_program_error_signals();
3005 
3006   int orig_errno = errno;  // Preserve errno value over signal handler.
3007   JVM_handle_aix_signal(sig, info, uc, true);
3008   errno = orig_errno;
3009 }
3010 
3011 // This boolean allows users to forward their own non-matching signals
3012 // to JVM_handle_aix_signal, harmlessly.
3013 bool os::Aix::signal_handlers_are_installed = false;
3014 
3015 // For signal-chaining
3016 bool os::Aix::libjsig_is_loaded = false;
3017 typedef struct sigaction *(*get_signal_t)(int);
3018 get_signal_t os::Aix::get_signal_action = NULL;
3019 
3020 struct sigaction* os::Aix::get_chained_signal_action(int sig) {
3021   struct sigaction *actp = NULL;
3022 
3023   if (libjsig_is_loaded) {
3024     // Retrieve the old signal handler from libjsig
3025     actp = (*get_signal_action)(sig);
3026   }
3027   if (actp == NULL) {
3028     // Retrieve the preinstalled signal handler from jvm
3029     actp = os::Posix::get_preinstalled_handler(sig);
3030   }
3031 
3032   return actp;
3033 }
3034 
3035 static bool call_chained_handler(struct sigaction *actp, int sig,
3036                                  siginfo_t *siginfo, void *context) {
3037   // Call the old signal handler
3038   if (actp-&gt;sa_handler == SIG_DFL) {
3039     // It&#39;s more reasonable to let jvm treat it as an unexpected exception
3040     // instead of taking the default action.
3041     return false;
3042   } else if (actp-&gt;sa_handler != SIG_IGN) {
3043     if ((actp-&gt;sa_flags &amp; SA_NODEFER) == 0) {
3044       // automaticlly block the signal
3045       sigaddset(&amp;(actp-&gt;sa_mask), sig);
3046     }
3047 
3048     sa_handler_t hand = NULL;
3049     sa_sigaction_t sa = NULL;
3050     bool siginfo_flag_set = (actp-&gt;sa_flags &amp; SA_SIGINFO) != 0;
3051     // retrieve the chained handler
3052     if (siginfo_flag_set) {
3053       sa = actp-&gt;sa_sigaction;
3054     } else {
3055       hand = actp-&gt;sa_handler;
3056     }
3057 
3058     if ((actp-&gt;sa_flags &amp; SA_RESETHAND) != 0) {
3059       actp-&gt;sa_handler = SIG_DFL;
3060     }
3061 
3062     // try to honor the signal mask
3063     sigset_t oset;
<a name="63" id="anc63"></a><span class="line-added">3064     sigemptyset(&amp;oset);</span>
3065     pthread_sigmask(SIG_SETMASK, &amp;(actp-&gt;sa_mask), &amp;oset);
3066 
3067     // call into the chained handler
3068     if (siginfo_flag_set) {
3069       (*sa)(sig, siginfo, context);
3070     } else {
3071       (*hand)(sig);
3072     }
3073 
3074     // restore the signal mask
<a name="64" id="anc64"></a><span class="line-modified">3075     pthread_sigmask(SIG_SETMASK, &amp;oset, NULL);</span>
3076   }
3077   // Tell jvm&#39;s signal handler the signal is taken care of.
3078   return true;
3079 }
3080 
3081 bool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {
3082   bool chained = false;
3083   // signal-chaining
3084   if (UseSignalChaining) {
3085     struct sigaction *actp = get_chained_signal_action(sig);
3086     if (actp != NULL) {
3087       chained = call_chained_handler(actp, sig, siginfo, context);
3088     }
3089   }
3090   return chained;
3091 }
3092 
3093 // for diagnostic
3094 int sigflags[NSIG];
3095 
3096 int os::Aix::get_our_sigflags(int sig) {
3097   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
3098   return sigflags[sig];
3099 }
3100 
3101 void os::Aix::set_our_sigflags(int sig, int flags) {
3102   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
3103   if (sig &gt; 0 &amp;&amp; sig &lt; NSIG) {
3104     sigflags[sig] = flags;
3105   }
3106 }
3107 
3108 void os::Aix::set_signal_handler(int sig, bool set_installed) {
3109   // Check for overwrite.
3110   struct sigaction oldAct;
3111   sigaction(sig, (struct sigaction*)NULL, &amp;oldAct);
3112 
3113   void* oldhand = oldAct.sa_sigaction
3114     ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)
3115     : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
3116   if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &amp;&amp;
3117       oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &amp;&amp;
3118       oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {
3119     if (AllowUserSignalHandlers || !set_installed) {
3120       // Do not overwrite; user takes responsibility to forward to us.
3121       return;
3122     } else if (UseSignalChaining) {
3123       // save the old handler in jvm
3124       os::Posix::save_preinstalled_handler(sig, oldAct);
3125       // libjsig also interposes the sigaction() call below and saves the
3126       // old sigaction on it own.
3127     } else {
3128       fatal(&quot;Encountered unexpected pre-existing sigaction handler &quot;
3129             &quot;%#lx for signal %d.&quot;, (long)oldhand, sig);
3130     }
3131   }
3132 
3133   struct sigaction sigAct;
3134   sigfillset(&amp;(sigAct.sa_mask));
3135   if (!set_installed) {
3136     sigAct.sa_handler = SIG_DFL;
3137     sigAct.sa_flags = SA_RESTART;
3138   } else {
3139     sigAct.sa_sigaction = javaSignalHandler;
3140     sigAct.sa_flags = SA_SIGINFO|SA_RESTART;
3141   }
3142   // Save flags, which are set by ours
3143   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
3144   sigflags[sig] = sigAct.sa_flags;
3145 
3146   int ret = sigaction(sig, &amp;sigAct, &amp;oldAct);
3147   assert(ret == 0, &quot;check&quot;);
3148 
3149   void* oldhand2 = oldAct.sa_sigaction
3150                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)
3151                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
3152   assert(oldhand2 == oldhand, &quot;no concurrent signal handler installation&quot;);
3153 }
3154 
3155 // install signal handlers for signals that HotSpot needs to
3156 // handle in order to support Java-level exception handling.
3157 void os::Aix::install_signal_handlers() {
3158   if (!signal_handlers_are_installed) {
3159     signal_handlers_are_installed = true;
3160 
3161     // signal-chaining
3162     typedef void (*signal_setting_t)();
3163     signal_setting_t begin_signal_setting = NULL;
3164     signal_setting_t end_signal_setting = NULL;
3165     begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,
3166                              dlsym(RTLD_DEFAULT, &quot;JVM_begin_signal_setting&quot;));
3167     if (begin_signal_setting != NULL) {
3168       end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,
3169                              dlsym(RTLD_DEFAULT, &quot;JVM_end_signal_setting&quot;));
3170       get_signal_action = CAST_TO_FN_PTR(get_signal_t,
3171                             dlsym(RTLD_DEFAULT, &quot;JVM_get_signal_action&quot;));
3172       libjsig_is_loaded = true;
3173       assert(UseSignalChaining, &quot;should enable signal-chaining&quot;);
3174     }
3175     if (libjsig_is_loaded) {
3176       // Tell libjsig jvm is setting signal handlers.
3177       (*begin_signal_setting)();
3178     }
3179 
3180     set_signal_handler(SIGSEGV, true);
3181     set_signal_handler(SIGPIPE, true);
3182     set_signal_handler(SIGBUS, true);
3183     set_signal_handler(SIGILL, true);
3184     set_signal_handler(SIGFPE, true);
3185     set_signal_handler(SIGTRAP, true);
3186     set_signal_handler(SIGXFSZ, true);
3187 
3188     if (libjsig_is_loaded) {
3189       // Tell libjsig jvm finishes setting signal handlers.
3190       (*end_signal_setting)();
3191     }
3192 
3193     // We don&#39;t activate signal checker if libjsig is in place, we trust ourselves
3194     // and if UserSignalHandler is installed all bets are off.
3195     // Log that signal checking is off only if -verbose:jni is specified.
3196     if (CheckJNICalls) {
3197       if (libjsig_is_loaded) {
3198         tty-&gt;print_cr(&quot;Info: libjsig is activated, all active signal checking is disabled&quot;);
3199         check_signals = false;
3200       }
3201       if (AllowUserSignalHandlers) {
3202         tty-&gt;print_cr(&quot;Info: AllowUserSignalHandlers is activated, all active signal checking is disabled&quot;);
3203         check_signals = false;
3204       }
3205       // Need to initialize check_signal_done.
3206       ::sigemptyset(&amp;check_signal_done);
3207     }
3208   }
3209 }
3210 
3211 static const char* get_signal_handler_name(address handler,
3212                                            char* buf, int buflen) {
3213   int offset;
3214   bool found = os::dll_address_to_library_name(handler, buf, buflen, &amp;offset);
3215   if (found) {
3216     // skip directory names
3217     const char *p1, *p2;
3218     p1 = buf;
3219     size_t len = strlen(os::file_separator());
3220     while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;
3221     // The way os::dll_address_to_library_name is implemented on Aix
3222     // right now, it always returns -1 for the offset which is not
3223     // terribly informative.
3224     // Will fix that. For now, omit the offset.
3225     jio_snprintf(buf, buflen, &quot;%s&quot;, p1);
3226   } else {
3227     jio_snprintf(buf, buflen, PTR_FORMAT, handler);
3228   }
3229   return buf;
3230 }
3231 
3232 static void print_signal_handler(outputStream* st, int sig,
3233                                  char* buf, size_t buflen) {
3234   struct sigaction sa;
3235   sigaction(sig, NULL, &amp;sa);
3236 
3237   st-&gt;print(&quot;%s: &quot;, os::exception_name(sig, buf, buflen));
3238 
3239   address handler = (sa.sa_flags &amp; SA_SIGINFO)
3240     ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)
3241     : CAST_FROM_FN_PTR(address, sa.sa_handler);
3242 
3243   if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {
3244     st-&gt;print(&quot;SIG_DFL&quot;);
3245   } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {
3246     st-&gt;print(&quot;SIG_IGN&quot;);
3247   } else {
3248     st-&gt;print(&quot;[%s]&quot;, get_signal_handler_name(handler, buf, buflen));
3249   }
3250 
3251   // Print readable mask.
3252   st-&gt;print(&quot;, sa_mask[0]=&quot;);
3253   os::Posix::print_signal_set_short(st, &amp;sa.sa_mask);
3254 
3255   address rh = VMError::get_resetted_sighandler(sig);
3256   // May be, handler was resetted by VMError?
3257   if (rh != NULL) {
3258     handler = rh;
3259     sa.sa_flags = VMError::get_resetted_sigflags(sig);
3260   }
3261 
3262   // Print textual representation of sa_flags.
3263   st-&gt;print(&quot;, sa_flags=&quot;);
3264   os::Posix::print_sa_flags(st, sa.sa_flags);
3265 
3266   // Check: is it our handler?
3267   if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||
3268       handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {
3269     // It is our signal handler.
3270     // Check for flags, reset system-used one!
3271     if ((int)sa.sa_flags != os::Aix::get_our_sigflags(sig)) {
3272       st-&gt;print(&quot;, flags was changed from &quot; PTR32_FORMAT &quot;, consider using jsig library&quot;,
3273                 os::Aix::get_our_sigflags(sig));
3274     }
3275   }
3276   st-&gt;cr();
3277 }
3278 
3279 #define DO_SIGNAL_CHECK(sig) \
3280   if (!sigismember(&amp;check_signal_done, sig)) \
3281     os::Aix::check_signal_handler(sig)
3282 
3283 // This method is a periodic task to check for misbehaving JNI applications
3284 // under CheckJNI, we can add any periodic checks here
3285 
3286 void os::run_periodic_checks() {
3287 
3288   if (check_signals == false) return;
3289 
3290   // SEGV and BUS if overridden could potentially prevent
3291   // generation of hs*.log in the event of a crash, debugging
3292   // such a case can be very challenging, so we absolutely
3293   // check the following for a good measure:
3294   DO_SIGNAL_CHECK(SIGSEGV);
3295   DO_SIGNAL_CHECK(SIGILL);
3296   DO_SIGNAL_CHECK(SIGFPE);
3297   DO_SIGNAL_CHECK(SIGBUS);
3298   DO_SIGNAL_CHECK(SIGPIPE);
3299   DO_SIGNAL_CHECK(SIGXFSZ);
3300   if (UseSIGTRAP) {
3301     DO_SIGNAL_CHECK(SIGTRAP);
3302   }
3303 
3304   // ReduceSignalUsage allows the user to override these handlers
3305   // see comments at the very top and jvm_md.h
3306   if (!ReduceSignalUsage) {
3307     DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);
3308     DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);
3309     DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);
3310     DO_SIGNAL_CHECK(BREAK_SIGNAL);
3311   }
3312 
3313   DO_SIGNAL_CHECK(SR_signum);
3314 }
3315 
3316 typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);
3317 
3318 static os_sigaction_t os_sigaction = NULL;
3319 
3320 void os::Aix::check_signal_handler(int sig) {
3321   char buf[O_BUFLEN];
3322   address jvmHandler = NULL;
3323 
3324   struct sigaction act;
3325   if (os_sigaction == NULL) {
3326     // only trust the default sigaction, in case it has been interposed
3327     os_sigaction = CAST_TO_FN_PTR(os_sigaction_t, dlsym(RTLD_DEFAULT, &quot;sigaction&quot;));
3328     if (os_sigaction == NULL) return;
3329   }
3330 
3331   os_sigaction(sig, (struct sigaction*)NULL, &amp;act);
3332 
3333   address thisHandler = (act.sa_flags &amp; SA_SIGINFO)
3334     ? CAST_FROM_FN_PTR(address, act.sa_sigaction)
3335     : CAST_FROM_FN_PTR(address, act.sa_handler);
3336 
3337   switch(sig) {
3338   case SIGSEGV:
3339   case SIGBUS:
3340   case SIGFPE:
3341   case SIGPIPE:
3342   case SIGILL:
3343   case SIGXFSZ:
3344     jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);
3345     break;
3346 
3347   case SHUTDOWN1_SIGNAL:
3348   case SHUTDOWN2_SIGNAL:
3349   case SHUTDOWN3_SIGNAL:
3350   case BREAK_SIGNAL:
3351     jvmHandler = (address)user_handler();
3352     break;
3353 
3354   default:
3355     if (sig == SR_signum) {
3356       jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);
3357     } else {
3358       return;
3359     }
3360     break;
3361   }
3362 
3363   if (thisHandler != jvmHandler) {
3364     tty-&gt;print(&quot;Warning: %s handler &quot;, exception_name(sig, buf, O_BUFLEN));
3365     tty-&gt;print(&quot;expected:%s&quot;, get_signal_handler_name(jvmHandler, buf, O_BUFLEN));
3366     tty-&gt;print_cr(&quot;  found:%s&quot;, get_signal_handler_name(thisHandler, buf, O_BUFLEN));
3367     // No need to check this sig any longer
3368     sigaddset(&amp;check_signal_done, sig);
3369     // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN
3370     if (sig == SHUTDOWN2_SIGNAL &amp;&amp; !isatty(fileno(stdin))) {
3371       tty-&gt;print_cr(&quot;Running in non-interactive shell, %s handler is replaced by shell&quot;,
3372                     exception_name(sig, buf, O_BUFLEN));
3373     }
3374   } else if (os::Aix::get_our_sigflags(sig) != 0 &amp;&amp; (int)act.sa_flags != os::Aix::get_our_sigflags(sig)) {
3375     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
3376     tty-&gt;print(&quot;expected:&quot;);
3377     os::Posix::print_sa_flags(tty, os::Aix::get_our_sigflags(sig));
3378     tty-&gt;cr();
3379     tty-&gt;print(&quot;  found:&quot;);
3380     os::Posix::print_sa_flags(tty, act.sa_flags);
3381     tty-&gt;cr();
3382     // No need to check this sig any longer
3383     sigaddset(&amp;check_signal_done, sig);
3384   }
3385 
3386   // Dump all the signal
3387   if (sigismember(&amp;check_signal_done, sig)) {
3388     print_signal_handlers(tty, buf, O_BUFLEN);
3389   }
3390 }
3391 
3392 // To install functions for atexit system call
3393 extern &quot;C&quot; {
3394   static void perfMemory_exit_helper() {
3395     perfMemory_exit();
3396   }
3397 }
3398 
3399 // This is called _before_ the most of global arguments have been parsed.
3400 void os::init(void) {
3401   // This is basic, we want to know if that ever changes.
3402   // (Shared memory boundary is supposed to be a 256M aligned.)
3403   assert(SHMLBA == ((uint64_t)0x10000000ULL)/*256M*/, &quot;unexpected&quot;);
3404 
3405   // Record process break at startup.
3406   g_brk_at_startup = (address) ::sbrk(0);
3407   assert(g_brk_at_startup != (address) -1, &quot;sbrk failed&quot;);
3408 
3409   // First off, we need to know whether we run on AIX or PASE, and
3410   // the OS level we run on.
3411   os::Aix::initialize_os_info();
3412 
3413   // Scan environment (SPEC1170 behaviour, etc).
3414   os::Aix::scan_environment();
3415 
3416   // Probe multipage support.
3417   query_multipage_support();
3418 
3419   // Act like we only have one page size by eliminating corner cases which
3420   // we did not support very well anyway.
3421   // We have two input conditions:
3422   // 1) Data segment page size. This is controlled by linker setting (datapsize) on the
3423   //    launcher, and/or by LDR_CNTRL environment variable. The latter overrules the linker
3424   //    setting.
3425   //    Data segment page size is important for us because it defines the thread stack page
3426   //    size, which is needed for guard page handling, stack banging etc.
3427   // 2) The ability to allocate 64k pages dynamically. If this is a given, java heap can
3428   //    and should be allocated with 64k pages.
3429   //
3430   // So, we do the following:
3431   // LDR_CNTRL    can_use_64K_pages_dynamically       what we do                      remarks
3432   // 4K           no                                  4K                              old systems (aix 5.2, as/400 v5r4) or new systems with AME activated
3433   // 4k           yes                                 64k (treat 4k stacks as 64k)    different loader than java and standard settings
3434   // 64k          no              --- AIX 5.2 ? ---
3435   // 64k          yes                                 64k                             new systems and standard java loader (we set datapsize=64k when linking)
3436 
3437   // We explicitly leave no option to change page size, because only upgrading would work,
3438   // not downgrading (if stack page size is 64k you cannot pretend its 4k).
3439 
3440   if (g_multipage_support.datapsize == 4*K) {
3441     // datapsize = 4K. Data segment, thread stacks are 4K paged.
3442     if (g_multipage_support.can_use_64K_pages) {
3443       // .. but we are able to use 64K pages dynamically.
3444       // This would be typical for java launchers which are not linked
3445       // with datapsize=64K (like, any other launcher but our own).
3446       //
3447       // In this case it would be smart to allocate the java heap with 64K
3448       // to get the performance benefit, and to fake 64k pages for the
3449       // data segment (when dealing with thread stacks).
3450       //
3451       // However, leave a possibility to downgrade to 4K, using
3452       // -XX:-Use64KPages.
3453       if (Use64KPages) {
3454         trcVerbose(&quot;64K page mode (faked for data segment)&quot;);
3455         Aix::_page_size = 64*K;
3456       } else {
3457         trcVerbose(&quot;4K page mode (Use64KPages=off)&quot;);
3458         Aix::_page_size = 4*K;
3459       }
3460     } else {
3461       // .. and not able to allocate 64k pages dynamically. Here, just
3462       // fall back to 4K paged mode and use mmap for everything.
3463       trcVerbose(&quot;4K page mode&quot;);
3464       Aix::_page_size = 4*K;
<a name="65" id="anc65"></a><span class="line-modified">3465       FLAG_SET_ERGO(Use64KPages, false);</span>
3466     }
3467   } else {
3468     // datapsize = 64k. Data segment, thread stacks are 64k paged.
3469     // This normally means that we can allocate 64k pages dynamically.
3470     // (There is one special case where this may be false: EXTSHM=on.
3471     // but we decided to not support that mode).
3472     assert0(g_multipage_support.can_use_64K_pages);
3473     Aix::_page_size = 64*K;
3474     trcVerbose(&quot;64K page mode&quot;);
<a name="66" id="anc66"></a><span class="line-modified">3475     FLAG_SET_ERGO(Use64KPages, true);</span>
3476   }
3477 
3478   // For now UseLargePages is just ignored.
<a name="67" id="anc67"></a><span class="line-modified">3479   FLAG_SET_ERGO(UseLargePages, false);</span>
3480   _page_sizes[0] = 0;
3481 
3482   // debug trace
3483   trcVerbose(&quot;os::vm_page_size %s&quot;, describe_pagesize(os::vm_page_size()));
3484 
3485   // Next, we need to initialize libo4 and libperfstat libraries.
3486   if (os::Aix::on_pase()) {
3487     os::Aix::initialize_libo4();
3488   } else {
3489     os::Aix::initialize_libperfstat();
3490   }
3491 
3492   // Reset the perfstat information provided by ODM.
3493   if (os::Aix::on_aix()) {
3494     libperfstat::perfstat_reset();
3495   }
3496 
3497   // Now initialze basic system properties. Note that for some of the values we
3498   // need libperfstat etc.
3499   os::Aix::initialize_system_info();
3500 
3501   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
3502 
3503   init_random(1234567);
3504 
3505   // _main_thread points to the thread that created/loaded the JVM.
3506   Aix::_main_thread = pthread_self();
3507 
<a name="68" id="anc68"></a><span class="line-modified">3508   initial_time_count = javaTimeNanos();</span>
3509 
3510   os::Posix::init();
3511 }
3512 
3513 // This is called _after_ the global arguments have been parsed.
3514 jint os::init_2(void) {
3515 
3516   // This could be set after os::Posix::init() but all platforms
3517   // have to set it the same so we have to mirror Solaris.
3518   DEBUG_ONLY(os::set_mutex_init_done();)
3519 
3520   os::Posix::init_2();
3521 
3522   if (os::Aix::on_pase()) {
3523     trcVerbose(&quot;Running on PASE.&quot;);
3524   } else {
3525     trcVerbose(&quot;Running on AIX (not PASE).&quot;);
3526   }
3527 
3528   trcVerbose(&quot;processor count: %d&quot;, os::_processor_count);
3529   trcVerbose(&quot;physical memory: %lu&quot;, Aix::_physical_memory);
3530 
3531   // Initially build up the loaded dll map.
3532   LoadedLibraries::reload();
3533   if (Verbose) {
3534     trcVerbose(&quot;Loaded Libraries: &quot;);
3535     LoadedLibraries::print(tty);
3536   }
3537 
3538   // initialize suspend/resume support - must do this before signal_sets_init()
3539   if (SR_initialize() != 0) {
3540     perror(&quot;SR_initialize failed&quot;);
3541     return JNI_ERR;
3542   }
3543 
3544   Aix::signal_sets_init();
3545   Aix::install_signal_handlers();
3546   // Initialize data for jdk.internal.misc.Signal
3547   if (!ReduceSignalUsage) {
3548     jdk_misc_signal_init();
3549   }
3550 
3551   // Check and sets minimum stack sizes against command line options
3552   if (Posix::set_minimum_stack_sizes() == JNI_ERR) {
3553     return JNI_ERR;
3554   }
3555 
3556   if (UseNUMA) {
3557     UseNUMA = false;
3558     warning(&quot;NUMA optimizations are not available on this OS.&quot;);
3559   }
3560 
3561   if (MaxFDLimit) {
3562     // Set the number of file descriptors to max. print out error
3563     // if getrlimit/setrlimit fails but continue regardless.
3564     struct rlimit nbr_files;
3565     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
3566     if (status != 0) {
3567       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
3568     } else {
3569       nbr_files.rlim_cur = nbr_files.rlim_max;
3570       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
3571       if (status != 0) {
3572         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
3573       }
3574     }
3575   }
3576 
3577   if (PerfAllowAtExitRegistration) {
3578     // Only register atexit functions if PerfAllowAtExitRegistration is set.
3579     // At exit functions can be delayed until process exit time, which
3580     // can be problematic for embedded VM situations. Embedded VMs should
3581     // call DestroyJavaVM() to assure that VM resources are released.
3582 
3583     // Note: perfMemory_exit_helper atexit function may be removed in
3584     // the future if the appropriate cleanup code can be added to the
3585     // VM_Exit VMOperation&#39;s doit method.
3586     if (atexit(perfMemory_exit_helper) != 0) {
3587       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
3588     }
3589   }
3590 
<a name="69" id="anc69"></a><span class="line-added">3591   // initialize thread priority policy</span>
<span class="line-added">3592   prio_init();</span>
<span class="line-added">3593 </span>
3594   return JNI_OK;
3595 }
3596 
3597 // Mark the polling page as unreadable
3598 void os::make_polling_page_unreadable(void) {
3599   if (!guard_memory((char*)_polling_page, Aix::page_size())) {
3600     fatal(&quot;Could not disable polling page&quot;);
3601   }
3602 };
3603 
3604 // Mark the polling page as readable
3605 void os::make_polling_page_readable(void) {
3606   // Changed according to os_linux.cpp.
3607   if (!checked_mprotect((char *)_polling_page, Aix::page_size(), PROT_READ)) {
3608     fatal(&quot;Could not enable polling page at &quot; PTR_FORMAT, _polling_page);
3609   }
3610 };
3611 
3612 int os::active_processor_count() {
3613   // User has overridden the number of active processors
3614   if (ActiveProcessorCount &gt; 0) {
3615     log_trace(os)(&quot;active_processor_count: &quot;
3616                   &quot;active processor count set by user : %d&quot;,
3617                   ActiveProcessorCount);
3618     return ActiveProcessorCount;
3619   }
3620 
3621   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
3622   assert(online_cpus &gt; 0 &amp;&amp; online_cpus &lt;= processor_count(), &quot;sanity check&quot;);
3623   return online_cpus;
3624 }
3625 
3626 void os::set_native_thread_name(const char *name) {
3627   // Not yet implemented.
3628   return;
3629 }
3630 
<a name="70" id="anc70"></a>




3631 bool os::bind_to_processor(uint processor_id) {
3632   // Not yet implemented.
3633   return false;
3634 }
3635 
3636 void os::SuspendedThreadTask::internal_do_task() {
3637   if (do_suspend(_thread-&gt;osthread())) {
3638     SuspendedThreadTaskContext context(_thread, _thread-&gt;osthread()-&gt;ucontext());
3639     do_task(context);
3640     do_resume(_thread-&gt;osthread());
3641   }
3642 }
3643 
3644 ////////////////////////////////////////////////////////////////////////////////
3645 // debug support
3646 
3647 bool os::find(address addr, outputStream* st) {
3648 
3649   st-&gt;print(PTR_FORMAT &quot;: &quot;, addr);
3650 
3651   loaded_module_t lm;
3652   if (LoadedLibraries::find_for_text_address(addr, &amp;lm) != NULL ||
3653       LoadedLibraries::find_for_data_address(addr, &amp;lm) != NULL) {
3654     st-&gt;print_cr(&quot;%s&quot;, lm.path);
3655     return true;
3656   }
3657 
3658   return false;
3659 }
3660 
3661 ////////////////////////////////////////////////////////////////////////////////
3662 // misc
3663 
3664 // This does not do anything on Aix. This is basically a hook for being
3665 // able to use structured exception handling (thread-local exception filters)
3666 // on, e.g., Win32.
3667 void
3668 os::os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle&amp; method,
3669                          JavaCallArguments* args, Thread* thread) {
3670   f(value, method, args, thread);
3671 }
3672 
3673 void os::print_statistics() {
3674 }
3675 
3676 bool os::message_box(const char* title, const char* message) {
3677   int i;
3678   fdStream err(defaultStream::error_fd());
3679   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;=&quot;);
3680   err.cr();
3681   err.print_raw_cr(title);
3682   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;-&quot;);
3683   err.cr();
3684   err.print_raw_cr(message);
3685   for (i = 0; i &lt; 78; i++) err.print_raw(&quot;=&quot;);
3686   err.cr();
3687 
3688   char buf[16];
3689   // Prevent process from exiting upon &quot;read error&quot; without consuming all CPU
3690   while (::read(0, buf, sizeof(buf)) &lt;= 0) { ::sleep(100); }
3691 
3692   return buf[0] == &#39;y&#39; || buf[0] == &#39;Y&#39;;
3693 }
3694 
3695 // Is a (classpath) directory empty?
3696 bool os::dir_is_empty(const char* path) {
3697   DIR *dir = NULL;
3698   struct dirent *ptr;
3699 
3700   dir = opendir(path);
3701   if (dir == NULL) return true;
3702 
3703   /* Scan the directory */
3704   bool result = true;
3705   while (result &amp;&amp; (ptr = readdir(dir)) != NULL) {
3706     if (strcmp(ptr-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(ptr-&gt;d_name, &quot;..&quot;) != 0) {
3707       result = false;
3708     }
3709   }
3710   closedir(dir);
3711   return result;
3712 }
3713 
3714 // This code originates from JDK&#39;s sysOpen and open64_w
3715 // from src/solaris/hpi/src/system_md.c
3716 
3717 int os::open(const char *path, int oflag, int mode) {
3718 
3719   if (strlen(path) &gt; MAX_PATH - 1) {
3720     errno = ENAMETOOLONG;
3721     return -1;
3722   }
<a name="71" id="anc71"></a><span class="line-modified">3723   // AIX 7.X now supports O_CLOEXEC too, like modern Linux; but we have to be careful, see</span>
<span class="line-added">3724   // IV90804: OPENING A FILE IN AFS WITH O_CLOEXEC FAILS WITH AN EINVAL ERROR APPLIES TO AIX 7100-04 17/04/14 PTF PECHANGE</span>
<span class="line-added">3725   int oflag_with_o_cloexec = oflag | O_CLOEXEC;</span>
3726 
<a name="72" id="anc72"></a><span class="line-modified">3727   int fd = ::open64(path, oflag_with_o_cloexec, mode);</span>
<span class="line-modified">3728   if (fd == -1) {</span>
<span class="line-added">3729     // we might fail in the open call when O_CLOEXEC is set, so try again without (see IV90804)</span>
<span class="line-added">3730     fd = ::open64(path, oflag, mode);</span>
<span class="line-added">3731     if (fd == -1) {</span>
<span class="line-added">3732       return -1;</span>
<span class="line-added">3733     }</span>
<span class="line-added">3734   }</span>
3735 
3736   // If the open succeeded, the file might still be a directory.
3737   {
3738     struct stat64 buf64;
3739     int ret = ::fstat64(fd, &amp;buf64);
3740     int st_mode = buf64.st_mode;
3741 
3742     if (ret != -1) {
3743       if ((st_mode &amp; S_IFMT) == S_IFDIR) {
3744         errno = EISDIR;
3745         ::close(fd);
3746         return -1;
3747       }
3748     } else {
3749       ::close(fd);
3750       return -1;
3751     }
3752   }
3753 
3754   // All file descriptors that are opened in the JVM and not
3755   // specifically destined for a subprocess should have the
3756   // close-on-exec flag set. If we don&#39;t set it, then careless 3rd
3757   // party native code might fork and exec without closing all
3758   // appropriate file descriptors (e.g. as we do in closeDescriptors in
3759   // UNIXProcess.c), and this in turn might:
3760   //
3761   // - cause end-of-file to fail to be detected on some file
3762   //   descriptors, resulting in mysterious hangs, or
3763   //
3764   // - might cause an fopen in the subprocess to fail on a system
3765   //   suffering from bug 1085341.
<a name="73" id="anc73"></a><span class="line-modified">3766 </span>
<span class="line-modified">3767   // Validate that the use of the O_CLOEXEC flag on open above worked.</span>
<span class="line-modified">3768   static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;</span>
<span class="line-modified">3769   if (O_CLOEXEC_is_known_to_work == 0) {</span>
<span class="line-modified">3770     int flags = ::fcntl(fd, F_GETFD);</span>
<span class="line-modified">3771     if (flags != -1) {</span>
<span class="line-modified">3772       if ((flags &amp; FD_CLOEXEC) != 0) {</span>
<span class="line-modified">3773         O_CLOEXEC_is_known_to_work = 1;</span>
<span class="line-modified">3774       } else { // it does not work</span>
<span class="line-modified">3775         ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);</span>
<span class="line-added">3776         O_CLOEXEC_is_known_to_work = -1;</span>
<span class="line-added">3777       }</span>
<span class="line-added">3778     }</span>
<span class="line-added">3779   } else if (O_CLOEXEC_is_known_to_work == -1) {</span>
3780     int flags = ::fcntl(fd, F_GETFD);
<a name="74" id="anc74"></a><span class="line-modified">3781     if (flags != -1) {</span>
3782       ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
<a name="75" id="anc75"></a><span class="line-added">3783     }</span>
3784   }
<a name="76" id="anc76"></a>
3785 
3786   return fd;
3787 }
3788 
3789 // create binary file, rewriting existing file if required
3790 int os::create_binary_file(const char* path, bool rewrite_existing) {
3791   int oflags = O_WRONLY | O_CREAT;
3792   if (!rewrite_existing) {
3793     oflags |= O_EXCL;
3794   }
3795   return ::open64(path, oflags, S_IREAD | S_IWRITE);
3796 }
3797 
3798 // return current position of file pointer
3799 jlong os::current_file_offset(int fd) {
3800   return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
3801 }
3802 
3803 // move file pointer to the specified offset
3804 jlong os::seek_to_file_offset(int fd, jlong offset) {
3805   return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
3806 }
3807 
3808 // This code originates from JDK&#39;s sysAvailable
3809 // from src/solaris/hpi/src/native_threads/src/sys_api_td.c
3810 
3811 int os::available(int fd, jlong *bytes) {
3812   jlong cur, end;
3813   int mode;
3814   struct stat64 buf64;
3815 
3816   if (::fstat64(fd, &amp;buf64) &gt;= 0) {
3817     mode = buf64.st_mode;
3818     if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {
3819       int n;
3820       if (::ioctl(fd, FIONREAD, &amp;n) &gt;= 0) {
3821         *bytes = n;
3822         return 1;
3823       }
3824     }
3825   }
3826   if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {
3827     return 0;
3828   } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {
3829     return 0;
3830   } else if (::lseek64(fd, cur, SEEK_SET) == -1) {
3831     return 0;
3832   }
3833   *bytes = end - cur;
3834   return 1;
3835 }
3836 
3837 // Map a block of memory.
3838 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
3839                         char *addr, size_t bytes, bool read_only,
3840                         bool allow_exec) {
3841   int prot;
3842   int flags = MAP_PRIVATE;
3843 
3844   if (read_only) {
3845     prot = PROT_READ;
3846     flags = MAP_SHARED;
3847   } else {
3848     prot = PROT_READ | PROT_WRITE;
3849     flags = MAP_PRIVATE;
3850   }
3851 
3852   if (allow_exec) {
3853     prot |= PROT_EXEC;
3854   }
3855 
3856   if (addr != NULL) {
3857     flags |= MAP_FIXED;
3858   }
3859 
3860   // Allow anonymous mappings if &#39;fd&#39; is -1.
3861   if (fd == -1) {
3862     flags |= MAP_ANONYMOUS;
3863   }
3864 
3865   char* mapped_address = (char*)::mmap(addr, (size_t)bytes, prot, flags,
3866                                      fd, file_offset);
3867   if (mapped_address == MAP_FAILED) {
3868     return NULL;
3869   }
3870   return mapped_address;
3871 }
3872 
3873 // Remap a block of memory.
3874 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
3875                           char *addr, size_t bytes, bool read_only,
3876                           bool allow_exec) {
3877   // same as map_memory() on this OS
3878   return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,
3879                         allow_exec);
3880 }
3881 
3882 // Unmap a block of memory.
3883 bool os::pd_unmap_memory(char* addr, size_t bytes) {
3884   return munmap(addr, bytes) == 0;
3885 }
3886 
3887 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
3888 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
3889 // of a thread.
3890 //
3891 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
3892 // the fast estimate available on the platform.
3893 
3894 jlong os::current_thread_cpu_time() {
3895   // return user + sys since the cost is the same
3896   const jlong n = os::thread_cpu_time(Thread::current(), true /* user + sys */);
3897   assert(n &gt;= 0, &quot;negative CPU time&quot;);
3898   return n;
3899 }
3900 
3901 jlong os::thread_cpu_time(Thread* thread) {
3902   // consistent with what current_thread_cpu_time() returns
3903   const jlong n = os::thread_cpu_time(thread, true /* user + sys */);
3904   assert(n &gt;= 0, &quot;negative CPU time&quot;);
3905   return n;
3906 }
3907 
3908 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
3909   const jlong n = os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
3910   assert(n &gt;= 0, &quot;negative CPU time&quot;);
3911   return n;
3912 }
3913 
3914 static bool thread_cpu_time_unchecked(Thread* thread, jlong* p_sys_time, jlong* p_user_time) {
3915   bool error = false;
3916 
3917   jlong sys_time = 0;
3918   jlong user_time = 0;
3919 
3920   // Reimplemented using getthrds64().
3921   //
3922   // Works like this:
3923   // For the thread in question, get the kernel thread id. Then get the
3924   // kernel thread statistics using that id.
3925   //
3926   // This only works of course when no pthread scheduling is used,
3927   // i.e. there is a 1:1 relationship to kernel threads.
3928   // On AIX, see AIXTHREAD_SCOPE variable.
3929 
3930   pthread_t pthtid = thread-&gt;osthread()-&gt;pthread_id();
3931 
3932   // retrieve kernel thread id for the pthread:
3933   tid64_t tid = 0;
3934   struct __pthrdsinfo pinfo;
3935   // I just love those otherworldly IBM APIs which force me to hand down
3936   // dummy buffers for stuff I dont care for...
3937   char dummy[1];
3938   int dummy_size = sizeof(dummy);
3939   if (pthread_getthrds_np(&amp;pthtid, PTHRDSINFO_QUERY_TID, &amp;pinfo, sizeof(pinfo),
3940                           dummy, &amp;dummy_size) == 0) {
3941     tid = pinfo.__pi_tid;
3942   } else {
3943     tty-&gt;print_cr(&quot;pthread_getthrds_np failed.&quot;);
3944     error = true;
3945   }
3946 
3947   // retrieve kernel timing info for that kernel thread
3948   if (!error) {
3949     struct thrdentry64 thrdentry;
3950     if (getthrds64(getpid(), &amp;thrdentry, sizeof(thrdentry), &amp;tid, 1) == 1) {
3951       sys_time = thrdentry.ti_ru.ru_stime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_stime.tv_usec * 1000LL;
3952       user_time = thrdentry.ti_ru.ru_utime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_utime.tv_usec * 1000LL;
3953     } else {
3954       tty-&gt;print_cr(&quot;pthread_getthrds_np failed.&quot;);
3955       error = true;
3956     }
3957   }
3958 
3959   if (p_sys_time) {
3960     *p_sys_time = sys_time;
3961   }
3962 
3963   if (p_user_time) {
3964     *p_user_time = user_time;
3965   }
3966 
3967   if (error) {
3968     return false;
3969   }
3970 
3971   return true;
3972 }
3973 
3974 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
3975   jlong sys_time;
3976   jlong user_time;
3977 
3978   if (!thread_cpu_time_unchecked(thread, &amp;sys_time, &amp;user_time)) {
3979     return -1;
3980   }
3981 
3982   return user_sys_cpu_time ? sys_time + user_time : user_time;
3983 }
3984 
3985 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
3986   info_ptr-&gt;max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
3987   info_ptr-&gt;may_skip_backward = false;     // elapsed time not wall time
3988   info_ptr-&gt;may_skip_forward = false;      // elapsed time not wall time
3989   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned
3990 }
3991 
3992 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
3993   info_ptr-&gt;max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
3994   info_ptr-&gt;may_skip_backward = false;     // elapsed time not wall time
3995   info_ptr-&gt;may_skip_forward = false;      // elapsed time not wall time
3996   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned
3997 }
3998 
3999 bool os::is_thread_cpu_time_supported() {
4000   return true;
4001 }
4002 
4003 // System loadavg support. Returns -1 if load average cannot be obtained.
4004 // For now just return the system wide load average (no processor sets).
4005 int os::loadavg(double values[], int nelem) {
4006 
4007   guarantee(nelem &gt;= 0 &amp;&amp; nelem &lt;= 3, &quot;argument error&quot;);
4008   guarantee(values, &quot;argument error&quot;);
4009 
4010   if (os::Aix::on_pase()) {
4011 
4012     // AS/400 PASE: use libo4 porting library
4013     double v[3] = { 0.0, 0.0, 0.0 };
4014 
4015     if (libo4::get_load_avg(v, v + 1, v + 2)) {
4016       for (int i = 0; i &lt; nelem; i ++) {
4017         values[i] = v[i];
4018       }
4019       return nelem;
4020     } else {
4021       return -1;
4022     }
4023 
4024   } else {
4025 
4026     // AIX: use libperfstat
4027     libperfstat::cpuinfo_t ci;
4028     if (libperfstat::get_cpuinfo(&amp;ci)) {
4029       for (int i = 0; i &lt; nelem; i++) {
4030         values[i] = ci.loadavg[i];
4031       }
4032     } else {
4033       return -1;
4034     }
4035     return nelem;
4036   }
4037 }
4038 
4039 void os::pause() {
4040   char filename[MAX_PATH];
4041   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<a name="77" id="anc77"></a><span class="line-modified">4042     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
4043   } else {
4044     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
4045   }
4046 
4047   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
4048   if (fd != -1) {
4049     struct stat buf;
4050     ::close(fd);
4051     while (::stat(filename, &amp;buf) == 0) {
4052       (void)::poll(NULL, 0, 100);
4053     }
4054   } else {
4055     trcVerbose(&quot;Could not open pause file &#39;%s&#39;, continuing immediately.&quot;, filename);
4056   }
4057 }
4058 
4059 bool os::is_primordial_thread(void) {
4060   if (pthread_self() == (pthread_t)1) {
4061     return true;
4062   } else {
4063     return false;
4064   }
4065 }
4066 
4067 // OS recognitions (PASE/AIX, OS level) call this before calling any
4068 // one of Aix::on_pase(), Aix::os_version() static
4069 void os::Aix::initialize_os_info() {
4070 
4071   assert(_on_pase == -1 &amp;&amp; _os_version == 0, &quot;already called.&quot;);
4072 
4073   struct utsname uts;
4074   memset(&amp;uts, 0, sizeof(uts));
4075   strcpy(uts.sysname, &quot;?&quot;);
4076   if (::uname(&amp;uts) == -1) {
4077     trcVerbose(&quot;uname failed (%d)&quot;, errno);
4078     guarantee(0, &quot;Could not determine whether we run on AIX or PASE&quot;);
4079   } else {
4080     trcVerbose(&quot;uname says: sysname \&quot;%s\&quot; version \&quot;%s\&quot; release \&quot;%s\&quot; &quot;
4081                &quot;node \&quot;%s\&quot; machine \&quot;%s\&quot;\n&quot;,
4082                uts.sysname, uts.version, uts.release, uts.nodename, uts.machine);
4083     const int major = atoi(uts.version);
4084     assert(major &gt; 0, &quot;invalid OS version&quot;);
4085     const int minor = atoi(uts.release);
4086     assert(minor &gt; 0, &quot;invalid OS release&quot;);
4087     _os_version = (major &lt;&lt; 24) | (minor &lt;&lt; 16);
4088     char ver_str[20] = {0};
<a name="78" id="anc78"></a><span class="line-modified">4089     const char* name_str = &quot;unknown OS&quot;;</span>
4090     if (strcmp(uts.sysname, &quot;OS400&quot;) == 0) {
4091       // We run on AS/400 PASE. We do not support versions older than V5R4M0.
4092       _on_pase = 1;
4093       if (os_version_short() &lt; 0x0504) {
4094         trcVerbose(&quot;OS/400 releases older than V5R4M0 not supported.&quot;);
4095         assert(false, &quot;OS/400 release too old.&quot;);
4096       }
4097       name_str = &quot;OS/400 (pase)&quot;;
4098       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u&quot;, major, minor);
4099     } else if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
<a name="79" id="anc79"></a><span class="line-modified">4100       // We run on AIX. We do not support versions older than AIX 7.1.</span>
4101       _on_pase = 0;
4102       // Determine detailed AIX version: Version, Release, Modification, Fix Level.
4103       odmWrapper::determine_os_kernel_version(&amp;_os_version);
<a name="80" id="anc80"></a><span class="line-modified">4104       if (os_version_short() &lt; 0x0701) {</span>
<span class="line-modified">4105         trcVerbose(&quot;AIX releases older than AIX 7.1 are not supported.&quot;);</span>
4106         assert(false, &quot;AIX release too old.&quot;);
4107       }
4108       name_str = &quot;AIX&quot;;
4109       jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u.%u.%u&quot;,
4110                    major, minor, (_os_version &gt;&gt; 8) &amp; 0xFF, _os_version &amp; 0xFF);
4111     } else {
<a name="81" id="anc81"></a><span class="line-modified">4112       assert(false, &quot;%s&quot;, name_str);</span>
4113     }
4114     trcVerbose(&quot;We run on %s %s&quot;, name_str, ver_str);
4115   }
4116 
4117   guarantee(_on_pase != -1 &amp;&amp; _os_version, &quot;Could not determine AIX/OS400 release&quot;);
4118 } // end: os::Aix::initialize_os_info()
4119 
4120 // Scan environment for important settings which might effect the VM.
4121 // Trace out settings. Warn about invalid settings and/or correct them.
4122 //
4123 // Must run after os::Aix::initialue_os_info().
4124 void os::Aix::scan_environment() {
4125 
4126   char* p;
4127   int rc;
4128 
4129   // Warn explicity if EXTSHM=ON is used. That switch changes how
4130   // System V shared memory behaves. One effect is that page size of
4131   // shared memory cannot be change dynamically, effectivly preventing
4132   // large pages from working.
4133   // This switch was needed on AIX 32bit, but on AIX 64bit the general
4134   // recommendation is (in OSS notes) to switch it off.
4135   p = ::getenv(&quot;EXTSHM&quot;);
4136   trcVerbose(&quot;EXTSHM=%s.&quot;, p ? p : &quot;&lt;unset&gt;&quot;);
4137   if (p &amp;&amp; strcasecmp(p, &quot;ON&quot;) == 0) {
4138     _extshm = 1;
4139     trcVerbose(&quot;*** Unsupported mode! Please remove EXTSHM from your environment! ***&quot;);
4140     if (!AllowExtshm) {
4141       // We allow under certain conditions the user to continue. However, we want this
4142       // to be a fatal error by default. On certain AIX systems, leaving EXTSHM=ON means
4143       // that the VM is not able to allocate 64k pages for the heap.
4144       // We do not want to run with reduced performance.
4145       vm_exit_during_initialization(&quot;EXTSHM is ON. Please remove EXTSHM from your environment.&quot;);
4146     }
4147   } else {
4148     _extshm = 0;
4149   }
4150 
4151   // SPEC1170 behaviour: will change the behaviour of a number of POSIX APIs.
4152   // Not tested, not supported.
4153   //
4154   // Note that it might be worth the trouble to test and to require it, if only to
4155   // get useful return codes for mprotect.
4156   //
4157   // Note: Setting XPG_SUS_ENV in the process is too late. Must be set earlier (before
4158   // exec() ? before loading the libjvm ? ....)
4159   p = ::getenv(&quot;XPG_SUS_ENV&quot;);
4160   trcVerbose(&quot;XPG_SUS_ENV=%s.&quot;, p ? p : &quot;&lt;unset&gt;&quot;);
4161   if (p &amp;&amp; strcmp(p, &quot;ON&quot;) == 0) {
4162     _xpg_sus_mode = 1;
4163     trcVerbose(&quot;Unsupported setting: XPG_SUS_ENV=ON&quot;);
4164     // This is not supported. Worst of all, it changes behaviour of mmap MAP_FIXED to
4165     // clobber address ranges. If we ever want to support that, we have to do some
4166     // testing first.
4167     guarantee(false, &quot;XPG_SUS_ENV=ON not supported&quot;);
4168   } else {
4169     _xpg_sus_mode = 0;
4170   }
4171 
4172   if (os::Aix::on_pase()) {
4173     p = ::getenv(&quot;QIBM_MULTI_THREADED&quot;);
4174     trcVerbose(&quot;QIBM_MULTI_THREADED=%s.&quot;, p ? p : &quot;&lt;unset&gt;&quot;);
4175   }
4176 
4177   p = ::getenv(&quot;LDR_CNTRL&quot;);
4178   trcVerbose(&quot;LDR_CNTRL=%s.&quot;, p ? p : &quot;&lt;unset&gt;&quot;);
4179   if (os::Aix::on_pase() &amp;&amp; os::Aix::os_version_short() == 0x0701) {
4180     if (p &amp;&amp; ::strstr(p, &quot;TEXTPSIZE&quot;)) {
4181       trcVerbose(&quot;*** WARNING - LDR_CNTRL contains TEXTPSIZE. &quot;
4182         &quot;you may experience hangs or crashes on OS/400 V7R1.&quot;);
4183     }
4184   }
4185 
4186   p = ::getenv(&quot;AIXTHREAD_GUARDPAGES&quot;);
4187   trcVerbose(&quot;AIXTHREAD_GUARDPAGES=%s.&quot;, p ? p : &quot;&lt;unset&gt;&quot;);
4188 
4189 } // end: os::Aix::scan_environment()
4190 
4191 // PASE: initialize the libo4 library (PASE porting library).
4192 void os::Aix::initialize_libo4() {
4193   guarantee(os::Aix::on_pase(), &quot;OS/400 only.&quot;);
4194   if (!libo4::init()) {
4195     trcVerbose(&quot;libo4 initialization failed.&quot;);
4196     assert(false, &quot;libo4 initialization failed&quot;);
4197   } else {
4198     trcVerbose(&quot;libo4 initialized.&quot;);
4199   }
4200 }
4201 
4202 // AIX: initialize the libperfstat library.
4203 void os::Aix::initialize_libperfstat() {
4204   assert(os::Aix::on_aix(), &quot;AIX only&quot;);
4205   if (!libperfstat::init()) {
4206     trcVerbose(&quot;libperfstat initialization failed.&quot;);
4207     assert(false, &quot;libperfstat initialization failed&quot;);
4208   } else {
4209     trcVerbose(&quot;libperfstat initialized.&quot;);
4210   }
4211 }
4212 
4213 /////////////////////////////////////////////////////////////////////////////
4214 // thread stack
4215 
4216 // Get the current stack base from the OS (actually, the pthread library).
4217 // Note: usually not page aligned.
4218 address os::current_stack_base() {
4219   AixMisc::stackbounds_t bounds;
4220   bool rc = AixMisc::query_stack_bounds_for_current_thread(&amp;bounds);
4221   guarantee(rc, &quot;Unable to retrieve stack bounds.&quot;);
4222   return bounds.base;
4223 }
4224 
4225 // Get the current stack size from the OS (actually, the pthread library).
4226 // Returned size is such that (base - size) is always aligned to page size.
4227 size_t os::current_stack_size() {
4228   AixMisc::stackbounds_t bounds;
4229   bool rc = AixMisc::query_stack_bounds_for_current_thread(&amp;bounds);
4230   guarantee(rc, &quot;Unable to retrieve stack bounds.&quot;);
4231   // Align the returned stack size such that the stack low address
4232   // is aligned to page size (Note: base is usually not and we do not care).
4233   // We need to do this because caller code will assume stack low address is
4234   // page aligned and will place guard pages without checking.
4235   address low = bounds.base - bounds.size;
4236   address low_aligned = (address)align_up(low, os::vm_page_size());
4237   size_t s = bounds.base - low_aligned;
4238   return s;
4239 }
4240 
4241 extern char** environ;
4242 
4243 // Run the specified command in a separate process. Return its exit value,
4244 // or -1 on failure (e.g. can&#39;t fork a new process).
4245 // Unlike system(), this function can be called from signal handler. It
4246 // doesn&#39;t block SIGINT et al.
4247 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
<a name="82" id="anc82"></a><span class="line-modified">4248   char* argv[4] = { (char*)&quot;sh&quot;, (char*)&quot;-c&quot;, cmd, NULL};</span>
4249 
4250   pid_t pid = fork();
4251 
4252   if (pid &lt; 0) {
4253     // fork failed
4254     return -1;
4255 
4256   } else if (pid == 0) {
4257     // child process
4258 
4259     // Try to be consistent with system(), which uses &quot;/usr/bin/sh&quot; on AIX.
4260     execve(&quot;/usr/bin/sh&quot;, argv, environ);
4261 
4262     // execve failed
4263     _exit(-1);
4264 
4265   } else {
4266     // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don&#39;t
4267     // care about the actual exit code, for now.
4268 
4269     int status;
4270 
4271     // Wait for the child process to exit. This returns immediately if
4272     // the child has already exited. */
4273     while (waitpid(pid, &amp;status, 0) &lt; 0) {
4274       switch (errno) {
4275         case ECHILD: return 0;
4276         case EINTR: break;
4277         default: return -1;
4278       }
4279     }
4280 
4281     if (WIFEXITED(status)) {
4282       // The child exited normally; get its exit code.
4283       return WEXITSTATUS(status);
4284     } else if (WIFSIGNALED(status)) {
4285       // The child exited because of a signal.
4286       // The best value to return is 0x80 + signal number,
4287       // because that is what all Unix shells do, and because
4288       // it allows callers to distinguish between process exit and
4289       // process death by signal.
4290       return 0x80 + WTERMSIG(status);
4291     } else {
4292       // Unknown exit code; pass it through.
4293       return status;
4294     }
4295   }
4296   return -1;
4297 }
4298 
4299 // Get the default path to the core file
4300 // Returns the length of the string
4301 int os::get_core_path(char* buffer, size_t bufferSize) {
4302   const char* p = get_current_directory(buffer, bufferSize);
4303 
4304   if (p == NULL) {
4305     assert(p != NULL, &quot;failed to get current directory&quot;);
4306     return 0;
4307   }
4308 
4309   jio_snprintf(buffer, bufferSize, &quot;%s/core or core.%d&quot;,
4310                                                p, current_process_id());
4311 
4312   return strlen(buffer);
4313 }
4314 
4315 #ifndef PRODUCT
4316 void TestReserveMemorySpecial_test() {
4317   // No tests available for this platform
4318 }
4319 #endif
4320 
4321 bool os::start_debugging(char *buf, int buflen) {
4322   int len = (int)strlen(buf);
4323   char *p = &amp;buf[len];
4324 
4325   jio_snprintf(p, buflen -len,
4326                  &quot;\n\n&quot;
4327                  &quot;Do you want to debug the problem?\n\n&quot;
4328                  &quot;To debug, run &#39;dbx -a %d&#39;; then switch to thread tid &quot; INTX_FORMAT &quot;, k-tid &quot; INTX_FORMAT &quot;\n&quot;
4329                  &quot;Enter &#39;yes&#39; to launch dbx automatically (PATH must include dbx)\n&quot;
4330                  &quot;Otherwise, press RETURN to abort...&quot;,
4331                  os::current_process_id(),
4332                  os::current_thread_id(), thread_self());
4333 
4334   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
4335 
4336   if (yes) {
4337     // yes, user asked VM to launch debugger
4338     jio_snprintf(buf, buflen, &quot;dbx -a %d&quot;, os::current_process_id());
4339 
4340     os::fork_and_exec(buf);
4341     yes = false;
4342   }
4343   return yes;
4344 }
4345 
4346 static inline time_t get_mtime(const char* filename) {
4347   struct stat st;
4348   int ret = os::stat(filename, &amp;st);
4349   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
4350   return st.st_mtime;
4351 }
4352 
4353 int os::compare_file_modified_times(const char* file1, const char* file2) {
4354   time_t t1 = get_mtime(file1);
4355   time_t t2 = get_mtime(file2);
4356   return t1 - t2;
4357 }
<a name="83" id="anc83"></a><span class="line-added">4358 </span>
<span class="line-added">4359 bool os::supports_map_sync() {</span>
<span class="line-added">4360   return false;</span>
<span class="line-added">4361 }</span>
<a name="84" id="anc84"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="84" type="hidden" />
</body>
</html>
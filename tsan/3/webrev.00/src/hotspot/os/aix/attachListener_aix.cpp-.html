<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/aix/attachListener_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 29 #include &quot;runtime/os.inline.hpp&quot;
 30 #include &quot;services/attachListener.hpp&quot;
 31 #include &quot;services/dtraceAttacher.hpp&quot;
 32 
 33 #include &lt;signal.h&gt;
 34 #include &lt;sys/socket.h&gt;
 35 #include &lt;sys/stat.h&gt;
 36 #include &lt;sys/types.h&gt;
 37 #include &lt;sys/un.h&gt;
 38 #include &lt;unistd.h&gt;
 39 
 40 #ifndef UNIX_PATH_MAX
 41 #define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)-&gt;sun_path)
 42 #endif
 43 
 44 // The attach mechanism on AIX  uses a UNIX domain socket. An attach listener
 45 // thread is created at startup or is created on-demand via a signal from
 46 // the client tool. The attach listener creates a socket and binds it to a file
 47 // in the filesystem. The attach listener then acts as a simple (single-
 48 // threaded) server - it waits for a client to connect, reads the request,
 49 // executes it, and returns the response to the client via the socket
 50 // connection.
 51 //
 52 // As the socket is a UNIX domain socket it means that only clients on the
 53 // local machine can connect. In addition there are two other aspects to
 54 // the security:
 55 // 1. The well known file that the socket is bound to has permission 400
 56 // 2. When a client connect, the SO_PEERID socket option is used to
 57 //    obtain the credentials of client. We check that the effective uid
 58 //    of the client matches this process.
 59 
 60 // forward reference
 61 class AixAttachOperation;
 62 
 63 class AixAttachListener: AllStatic {
 64  private:
 65   // the path to which we bind the UNIX domain socket
 66   static char _path[UNIX_PATH_MAX];
 67   static bool _has_path;
 68   // Shutdown marker to prevent accept blocking during clean-up.
 69   static bool _shutdown;
 70 
 71   // the file descriptor for the listening socket
 72   static int _listener;
 73 
 74   static void set_path(char* path) {
 75     if (path == NULL) {
 76       _has_path = false;
 77     } else {
 78       strncpy(_path, path, UNIX_PATH_MAX);
 79       _path[UNIX_PATH_MAX-1] = &#39;\0&#39;;
 80       _has_path = true;
 81     }
 82   }
 83 
 84   static void set_listener(int s)               { _listener = s; }
 85 
 86   // reads a request from the given connected socket
 87   static AixAttachOperation* read_request(int s);
 88 
 89  public:
 90   enum {
 91     ATTACH_PROTOCOL_VER = 1                     // protocol version
 92   };
 93   enum {
 94     ATTACH_ERROR_BADVERSION     = 101           // error codes
 95   };
 96 
 97   // initialize the listener, returns 0 if okay
 98   static int init();
 99 
100   static char* path()                   { return _path; }
101   static bool has_path()                { return _has_path; }
102   static int listener()                 { return _listener; }
103   // Shutdown marker to prevent accept blocking during clean-up
104   static void set_shutdown(bool shutdown) { _shutdown = shutdown; }
105   static bool is_shutdown()     { return _shutdown; }
106 
107   // write the given buffer to a socket
108   static int write_fully(int s, char* buf, int len);
109 
110   static AixAttachOperation* dequeue();
111 };
112 
113 class AixAttachOperation: public AttachOperation {
114  private:
115   // the connection to the client
116   int _socket;
117 
118  public:
119   void complete(jint res, bufferedStream* st);
120 
121   void set_socket(int s)                                { _socket = s; }
122   int socket() const                                    { return _socket; }
123 
124   AixAttachOperation(char* name) : AttachOperation(name) {
125     set_socket(-1);
126   }
127 };
128 
129 // statics
130 char AixAttachListener::_path[UNIX_PATH_MAX];
131 bool AixAttachListener::_has_path;
132 int AixAttachListener::_listener = -1;
133 // Shutdown marker to prevent accept blocking during clean-up
134 bool AixAttachListener::_shutdown = false;
135 
136 // Supporting class to help split a buffer into individual components
137 class ArgumentIterator : public StackObj {
138  private:
139   char* _pos;
140   char* _end;
141  public:
142   ArgumentIterator(char* arg_buffer, size_t arg_size) {
143     _pos = arg_buffer;
144     _end = _pos + arg_size - 1;
145   }
146   char* next() {
147     if (*_pos == &#39;\0&#39;) {
148       // advance the iterator if possible (null arguments)
149       if (_pos &lt; _end) {
150         _pos += 1;
151       }
152       return NULL;
153     }
154     char* res = _pos;
155     char* next_pos = strchr(_pos, &#39;\0&#39;);
156     if (next_pos &lt; _end)  {
157       next_pos++;
158     }
159     _pos = next_pos;
160     return res;
161   }
162 };
163 
164 // On AIX if sockets block until all data has been transmitted
165 // successfully in some communication domains a socket &quot;close&quot; may
166 // never complete. We have to take care that after the socket shutdown
167 // the listener never enters accept state.
168 
169 // atexit hook to stop listener and unlink the file that it is
170 // bound too.
171 
172 // Some modifications to the listener logic to prevent deadlocks on exit.
173 // 1. We Shutdown the socket here instead. AixAttachOperation::complete() is not the right place
174 //    since more than one agent in a sequence in JPLIS live tests wouldn&#39;t work (Listener thread
175 //    would be dead after the first operation completion).
176 // 2. close(s) may never return if the listener thread is in socket accept(). Unlinking the file
177 //    should be sufficient for cleanup.
178 extern &quot;C&quot; {
179   static void listener_cleanup() {
180     static int cleanup_done;
181     if (!cleanup_done) {
182       cleanup_done = 1;
183       AixAttachListener::set_shutdown(true);
184       int s = AixAttachListener::listener();
185       if (s != -1) {
186         ::shutdown(s, 2);
187       }
188       if (AixAttachListener::has_path()) {
189         ::unlink(AixAttachListener::path());
190       }
191     }
192   }
193 }
194 
195 // Initialization - create a listener socket and bind it to a file
196 
197 int AixAttachListener::init() {
198   char path[UNIX_PATH_MAX];          // socket file
199   char initial_path[UNIX_PATH_MAX];  // socket file during setup
200   int listener;                      // listener socket (file descriptor)
201 
202   // register function to cleanup
203   ::atexit(listener_cleanup);
204 
205   int n = snprintf(path, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
206                    os::get_temp_directory(), os::current_process_id());
207   if (n &lt; (int)UNIX_PATH_MAX) {
208     n = snprintf(initial_path, UNIX_PATH_MAX, &quot;%s.tmp&quot;, path);
209   }
210   if (n &gt;= (int)UNIX_PATH_MAX) {
211     return -1;
212   }
213 
214   // create the listener socket
215   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
216   if (listener == -1) {
217     return -1;
218   }
219 
220   // bind socket
221   struct sockaddr_un addr;
222   memset((void *)&amp;addr, 0, sizeof(addr));
223   addr.sun_family = AF_UNIX;
224   strcpy(addr.sun_path, initial_path);
225   ::unlink(initial_path);
226   // We must call bind with the actual socketaddr length. This is obligatory for AS400.
227   int res = ::bind(listener, (struct sockaddr*)&amp;addr, SUN_LEN(&amp;addr));
228   if (res == -1) {
229     ::close(listener);
230     return -1;
231   }
232 
233   // put in listen mode, set permissions, and rename into place
234   res = ::listen(listener, 5);
235   if (res == 0) {
236     RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);
237     if (res == 0) {
238       // make sure the file is owned by the effective user and effective group
239       // e.g. the group could be inherited from the directory in case the s bit is set
240       RESTARTABLE(::chown(initial_path, geteuid(), getegid()), res);
241       if (res == 0) {
242         res = ::rename(initial_path, path);
243       }
244     }
245   }
246   if (res == -1) {
247     ::close(listener);
248     ::unlink(initial_path);
249     return -1;
250   }
251   set_path(path);
252   set_listener(listener);
253   set_shutdown(false);
254 
255   return 0;
256 }
257 
258 // Given a socket that is connected to a peer we read the request and
259 // create an AttachOperation. As the socket is blocking there is potential
260 // for a denial-of-service if the peer does not response. However this happens
261 // after the peer credentials have been checked and in the worst case it just
262 // means that the attach listener thread is blocked.
263 //
264 AixAttachOperation* AixAttachListener::read_request(int s) {
265   char ver_str[8];
266   sprintf(ver_str, &quot;%d&quot;, ATTACH_PROTOCOL_VER);
267 
268   // The request is a sequence of strings so we first figure out the
269   // expected count and the maximum possible length of the request.
270   // The request is:
271   //   &lt;ver&gt;0&lt;cmd&gt;0&lt;arg&gt;0&lt;arg&gt;0&lt;arg&gt;0
272   // where &lt;ver&gt; is the protocol version (1), &lt;cmd&gt; is the command
273   // name (&quot;load&quot;, &quot;datadump&quot;, ...), and &lt;arg&gt; is an argument
274   int expected_str_count = 2 + AttachOperation::arg_count_max;
275   const int max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +
276     AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);
277 
278   char buf[max_len];
279   int str_count = 0;
280 
281   // Read until all (expected) strings have been read, the buffer is
282   // full, or EOF.
283 
284   int off = 0;
285   int left = max_len;
286 
287   do {
288     int n;
289     // Don&#39;t block on interrupts because this will
290     // hang in the clean-up when shutting down.
291     n = read(s, buf+off, left);
292     assert(n &lt;= left, &quot;buffer was too small, impossible!&quot;);
293     buf[max_len - 1] = &#39;\0&#39;;
294     if (n == -1) {
295       return NULL;      // reset by peer or other error
296     }
297     if (n == 0) {
298       break;
299     }
300     for (int i=0; i&lt;n; i++) {
301       if (buf[off+i] == 0) {
302         // EOS found
303         str_count++;
304 
305         // The first string is &lt;ver&gt; so check it now to
306         // check for protocol mis-match
307         if (str_count == 1) {
308           if ((strlen(buf) != strlen(ver_str)) ||
309               (atoi(buf) != ATTACH_PROTOCOL_VER)) {
310             char msg[32];
311             sprintf(msg, &quot;%d\n&quot;, ATTACH_ERROR_BADVERSION);
312             write_fully(s, msg, strlen(msg));
313             return NULL;
314           }
315         }
316       }
317     }
318     off += n;
319     left -= n;
320   } while (left &gt; 0 &amp;&amp; str_count &lt; expected_str_count);
321 
322   if (str_count != expected_str_count) {
323     return NULL;        // incomplete request
324   }
325 
326   // parse request
327 
328   ArgumentIterator args(buf, (max_len)-left);
329 
330   // version already checked
331   char* v = args.next();
332 
333   char* name = args.next();
334   if (name == NULL || strlen(name) &gt; AttachOperation::name_length_max) {
335     return NULL;
336   }
337 
338   AixAttachOperation* op = new AixAttachOperation(name);
339 
340   for (int i=0; i&lt;AttachOperation::arg_count_max; i++) {
341     char* arg = args.next();
342     if (arg == NULL) {
343       op-&gt;set_arg(i, NULL);
344     } else {
345       if (strlen(arg) &gt; AttachOperation::arg_length_max) {
346         delete op;
347         return NULL;
348       }
349       op-&gt;set_arg(i, arg);
350     }
351   }
352 
353   op-&gt;set_socket(s);
354   return op;
355 }
356 
357 
358 // Dequeue an operation
359 //
360 // In the Aix implementation there is only a single operation and clients
361 // cannot queue commands (except at the socket level).
362 //
363 AixAttachOperation* AixAttachListener::dequeue() {
364   for (;;) {
365     int s;
366 
367     // wait for client to connect
368     struct sockaddr addr;
369     socklen_t len = sizeof(addr);
370     memset(&amp;addr, 0, len);
371     // We must prevent accept blocking on the socket if it has been shut down.
372     // Therefore we allow interrupts and check whether we have been shut down already.
373     if (AixAttachListener::is_shutdown()) {
374       return NULL;
375     }
376     s=::accept(listener(), &amp;addr, &amp;len);
377     if (s == -1) {
378       return NULL;      // log a warning?
379     }
380 
381     // get the credentials of the peer and check the effective uid/guid
382     struct peercred_struct cred_info;
383     socklen_t optlen = sizeof(cred_info);
384     if (::getsockopt(s, SOL_SOCKET, SO_PEERID, (void*)&amp;cred_info, &amp;optlen) == -1) {
385       log_debug(attach)(&quot;Failed to get socket option SO_PEERID&quot;);
386       ::close(s);
387       continue;
388     }
389 
390     if (!os::Posix::matches_effective_uid_and_gid_or_root(cred_info.euid, cred_info.egid)) {
391       log_debug(attach)(&quot;euid/egid check failed (%d/%d vs %d/%d)&quot;,
392               cred_info.euid, cred_info.egid, geteuid(), getegid());
393       ::close(s);
394       continue;
395     }
396 
397     // peer credential look okay so we read the request
398     AixAttachOperation* op = read_request(s);
399     if (op == NULL) {
400       ::close(s);
401       continue;
402     } else {
403       return op;
404     }
405   }
406 }
407 
408 // write the given buffer to the socket
409 int AixAttachListener::write_fully(int s, char* buf, int len) {
410   do {
411     int n = ::write(s, buf, len);
412     if (n == -1) {
413       if (errno != EINTR) return -1;
414     } else {
415       buf += n;
416       len -= n;
417     }
418   }
419   while (len &gt; 0);
420   return 0;
421 }
422 
423 // Complete an operation by sending the operation result and any result
424 // output to the client. At this time the socket is in blocking mode so
425 // potentially we can block if there is a lot of data and the client is
426 // non-responsive. For most operations this is a non-issue because the
427 // default send buffer is sufficient to buffer everything. In the future
428 // if there are operations that involves a very big reply then it the
429 // socket could be made non-blocking and a timeout could be used.
430 
431 void AixAttachOperation::complete(jint result, bufferedStream* st) {
432   JavaThread* thread = JavaThread::current();
433   ThreadBlockInVM tbivm(thread);
434 
435   thread-&gt;set_suspend_equivalent();
436   // cleared by handle_special_suspend_equivalent_condition() or
437   // java_suspend_self() via check_and_wait_while_suspended()
438 
439   // write operation result
440   char msg[32];
441   sprintf(msg, &quot;%d\n&quot;, result);
442   int rc = AixAttachListener::write_fully(this-&gt;socket(), msg, strlen(msg));
443 
444   // write any result data
445   if (rc == 0) {
446     // Shutdown the socket in the cleanup function to enable more than
447     // one agent attach in a sequence (see comments to listener_cleanup()).
448     AixAttachListener::write_fully(this-&gt;socket(), (char*) st-&gt;base(), st-&gt;size());
449   }
450 
451   // done
452   ::close(this-&gt;socket());
453 
454   // were we externally suspended while we were waiting?
455   thread-&gt;check_and_wait_while_suspended();
456 
457   delete this;
458 }
459 
460 
461 // AttachListener functions
462 
463 AttachOperation* AttachListener::dequeue() {
464   JavaThread* thread = JavaThread::current();
465   ThreadBlockInVM tbivm(thread);
466 
467   thread-&gt;set_suspend_equivalent();
468   // cleared by handle_special_suspend_equivalent_condition() or
469   // java_suspend_self() via check_and_wait_while_suspended()
470 
471   AttachOperation* op = AixAttachListener::dequeue();
472 
473   // were we externally suspended while we were waiting?
474   thread-&gt;check_and_wait_while_suspended();
475 
476   return op;
477 }
478 
479 // Performs initialization at vm startup
480 // For AIX we remove any stale .java_pid file which could cause
481 // an attaching process to think we are ready to receive on the
482 // domain socket before we are properly initialized
483 
484 void AttachListener::vm_start() {
485   char fn[UNIX_PATH_MAX];
486   struct stat64 st;
487   int ret;
488 
489   int n = snprintf(fn, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
490            os::get_temp_directory(), os::current_process_id());
491   assert(n &lt; (int)UNIX_PATH_MAX, &quot;java_pid file name buffer overflow&quot;);
492 
493   RESTARTABLE(::stat64(fn, &amp;st), ret);
494   if (ret == 0) {
495     ret = ::unlink(fn);
496     if (ret == -1) {
497       log_debug(attach)(&quot;Failed to remove stale attach pid file at %s&quot;, fn);
498     }
499   }
500 }
501 
502 int AttachListener::pd_init() {
503   JavaThread* thread = JavaThread::current();
504   ThreadBlockInVM tbivm(thread);
505 
506   thread-&gt;set_suspend_equivalent();
507   // cleared by handle_special_suspend_equivalent_condition() or
508   // java_suspend_self() via check_and_wait_while_suspended()
509 
510   int ret_code = AixAttachListener::init();
511 
512   // were we externally suspended while we were waiting?
513   thread-&gt;check_and_wait_while_suspended();
514 
515   return ret_code;
516 }
517 
518 // Attach Listener is started lazily except in the case when
519 // +ReduseSignalUsage is used
520 bool AttachListener::init_at_startup() {
521   if (ReduceSignalUsage) {
522     return true;
523   } else {
524     return false;
525   }
526 }
527 
528 // If the file .attach_pid&lt;pid&gt; exists in the working directory
529 // or /tmp then this is the trigger to start the attach mechanism
530 bool AttachListener::is_init_trigger() {
531   if (init_at_startup() || is_initialized()) {
532     return false;               // initialized at startup or already initialized
533   }
534   char fn[PATH_MAX + 1];
535   int ret;
536   struct stat64 st;
537   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
538   RESTARTABLE(::stat64(fn, &amp;st), ret);
539   if (ret == -1) {
540     log_trace(attach)(&quot;Failed to find attach file: %s, trying alternate&quot;, fn);
541     snprintf(fn, sizeof(fn), &quot;%s/.attach_pid%d&quot;,
542              os::get_temp_directory(), os::current_process_id());
543     RESTARTABLE(::stat64(fn, &amp;st), ret);
544     if (ret == -1) {
545       log_debug(attach)(&quot;Failed to find attach file: %s&quot;, fn);
546     }
547   }
548   if (ret == 0) {
549     // simple check to avoid starting the attach mechanism when
550     // a bogus non-root user creates the file
551     if (os::Posix::matches_effective_uid_or_root(st.st_uid)) {
552       init();
553       log_trace(attach)(&quot;Attach triggered by %s&quot;, fn);
554       return true;
555     } else {
556       log_debug(attach)(&quot;File %s has wrong user id %d (vs %d). Attach is not triggered&quot;, fn, st.st_uid, geteuid());
557     }
558   }
559   return false;
560 }
561 
562 // if VM aborts then remove listener
563 void AttachListener::abort() {
564   listener_cleanup();
565 }
566 
567 void AttachListener::pd_data_dump() {
568   os::signal_notify(SIGQUIT);
569 }
570 
571 AttachOperationFunctionInfo* AttachListener::pd_find_operation(const char* n) {
572   return NULL;
573 }
574 
575 jint AttachListener::pd_set_flag(AttachOperation* op, outputStream* out) {
576   out-&gt;print_cr(&quot;flag &#39;%s&#39; cannot be changed&quot;, op-&gt;arg(0));
577   return JNI_ERR;
578 }
579 
580 void AttachListener::pd_detachall() {
581   // Cleanup server socket to detach clients.
582   listener_cleanup();
583 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/os_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/os_aix.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #define OS_AIX_OS_AIX_HPP
 28 
 29 // Information about the protection of the page at address &#39;0&#39; on this os.
 30 static bool zero_page_read_protected() { return false; }
 31 
 32 // Class Aix defines the interface to the Aix operating systems.
 33 
 34 class Aix {
 35   friend class os;
 36 
 37   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 38                                         // __sigaction(), signal() is loaded
 39   static struct sigaction *(*get_signal_action)(int);
 40 
 41   static void check_signal_handler(int sig);
 42 
 43  private:
 44 
 45   static julong _physical_memory;
 46   static pthread_t _main_thread;
<span class="line-removed"> 47   static Mutex* _createThread_lock;</span>
 48   static int _page_size;
 49 
 50   // -1 = uninitialized, 0 = AIX, 1 = OS/400 (PASE)
 51   static int _on_pase;
 52 
 53   // 0 = uninitialized, otherwise 16 bit number:
 54   //  lower 8 bit - minor version
 55   //  higher 8 bit - major version
 56   //  For AIX, e.g. 0x0601 for AIX 6.1
 57   //  for OS/400 e.g. 0x0504 for OS/400 V5R4
 58   static uint32_t _os_version;
 59 
 60   // -1 = uninitialized,
 61   //  0 - SPEC1170 not requested (XPG_SUS_ENV is OFF or not set)
 62   //  1 - SPEC1170 requested (XPG_SUS_ENV is ON)
 63   static int _xpg_sus_mode;
 64 
 65   // -1 = uninitialized,
 66   //  0 - EXTSHM=OFF or not set
 67   //  1 - EXTSHM=ON
</pre>
<hr />
<pre>
 73 
 74   // OS recognitions (PASE/AIX, OS level) call this before calling any
 75   // one of Aix::on_pase(), Aix::os_version().
 76   static void initialize_os_info();
 77 
 78   // Scan environment for important settings which might effect the
 79   // VM. Trace out settings. Warn about invalid settings and/or
 80   // correct them.
 81   //
 82   // Must run after os::Aix::initialue_os_info().
 83   static void scan_environment();
 84 
 85   // Initialize libo4 (on PASE) and libperfstat (on AIX). Call this
 86   // before relying on functions from either lib, e.g. Aix::get_meminfo().
 87   static void initialize_libo4();
 88   static void initialize_libperfstat();
 89 
 90  public:
 91   static void init_thread_fpu_state();
 92   static pthread_t main_thread(void)                                { return _main_thread; }
<span class="line-removed"> 93   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }</span>
<span class="line-removed"> 94   static Mutex* createThread_lock(void)                             { return _createThread_lock; }</span>
 95   static void hotspot_sigmask(Thread* thread);
 96 
 97   // Given an address, returns the size of the page backing that address
 98   static size_t query_pagesize(void* p);
 99 
100   static int page_size(void) {
101     assert(_page_size != -1, &quot;not initialized&quot;);
102     return _page_size;
103   }
104 
105   static address   ucontext_get_pc(const ucontext_t* uc);
106   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
107   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
108   // Set PC into context. Needed for continuation after signal.
109   static void ucontext_set_pc(ucontext_t* uc, address pc);
110 
111   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
112 
113   // This boolean allows users to forward their own non-matching signals
114   // to JVM_handle_aix_signal, harmlessly.
</pre>
</td>
<td>
<hr />
<pre>
 27 #define OS_AIX_OS_AIX_HPP
 28 
 29 // Information about the protection of the page at address &#39;0&#39; on this os.
 30 static bool zero_page_read_protected() { return false; }
 31 
 32 // Class Aix defines the interface to the Aix operating systems.
 33 
 34 class Aix {
 35   friend class os;
 36 
 37   static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),
 38                                         // __sigaction(), signal() is loaded
 39   static struct sigaction *(*get_signal_action)(int);
 40 
 41   static void check_signal_handler(int sig);
 42 
 43  private:
 44 
 45   static julong _physical_memory;
 46   static pthread_t _main_thread;

 47   static int _page_size;
 48 
 49   // -1 = uninitialized, 0 = AIX, 1 = OS/400 (PASE)
 50   static int _on_pase;
 51 
 52   // 0 = uninitialized, otherwise 16 bit number:
 53   //  lower 8 bit - minor version
 54   //  higher 8 bit - major version
 55   //  For AIX, e.g. 0x0601 for AIX 6.1
 56   //  for OS/400 e.g. 0x0504 for OS/400 V5R4
 57   static uint32_t _os_version;
 58 
 59   // -1 = uninitialized,
 60   //  0 - SPEC1170 not requested (XPG_SUS_ENV is OFF or not set)
 61   //  1 - SPEC1170 requested (XPG_SUS_ENV is ON)
 62   static int _xpg_sus_mode;
 63 
 64   // -1 = uninitialized,
 65   //  0 - EXTSHM=OFF or not set
 66   //  1 - EXTSHM=ON
</pre>
<hr />
<pre>
 72 
 73   // OS recognitions (PASE/AIX, OS level) call this before calling any
 74   // one of Aix::on_pase(), Aix::os_version().
 75   static void initialize_os_info();
 76 
 77   // Scan environment for important settings which might effect the
 78   // VM. Trace out settings. Warn about invalid settings and/or
 79   // correct them.
 80   //
 81   // Must run after os::Aix::initialue_os_info().
 82   static void scan_environment();
 83 
 84   // Initialize libo4 (on PASE) and libperfstat (on AIX). Call this
 85   // before relying on functions from either lib, e.g. Aix::get_meminfo().
 86   static void initialize_libo4();
 87   static void initialize_libperfstat();
 88 
 89  public:
 90   static void init_thread_fpu_state();
 91   static pthread_t main_thread(void)                                { return _main_thread; }


 92   static void hotspot_sigmask(Thread* thread);
 93 
 94   // Given an address, returns the size of the page backing that address
 95   static size_t query_pagesize(void* p);
 96 
 97   static int page_size(void) {
 98     assert(_page_size != -1, &quot;not initialized&quot;);
 99     return _page_size;
100   }
101 
102   static address   ucontext_get_pc(const ucontext_t* uc);
103   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
104   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
105   // Set PC into context. Needed for continuation after signal.
106   static void ucontext_set_pc(ucontext_t* uc, address pc);
107 
108   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
109 
110   // This boolean allows users to forward their own non-matching signals
111   // to JVM_handle_aix_signal, harmlessly.
</pre>
</td>
</tr>
</table>
<center><a href="os_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
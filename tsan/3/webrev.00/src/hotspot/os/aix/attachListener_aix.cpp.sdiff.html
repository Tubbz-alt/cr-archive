<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/attachListener_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/zero/vm_version_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_aix.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/attachListener_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 54 // the security:
 55 // 1. The well known file that the socket is bound to has permission 400
 56 // 2. When a client connect, the SO_PEERID socket option is used to
 57 //    obtain the credentials of client. We check that the effective uid
 58 //    of the client matches this process.
 59 
 60 // forward reference
 61 class AixAttachOperation;
 62 
 63 class AixAttachListener: AllStatic {
 64  private:
 65   // the path to which we bind the UNIX domain socket
 66   static char _path[UNIX_PATH_MAX];
 67   static bool _has_path;
 68   // Shutdown marker to prevent accept blocking during clean-up.
 69   static bool _shutdown;
 70 
 71   // the file descriptor for the listening socket
 72   static int _listener;
 73 
<span class="line-modified"> 74   static void set_path(char* path) {</span>
<span class="line-removed"> 75     if (path == NULL) {</span>
<span class="line-removed"> 76       _has_path = false;</span>
<span class="line-removed"> 77     } else {</span>
<span class="line-removed"> 78       strncpy(_path, path, UNIX_PATH_MAX);</span>
<span class="line-removed"> 79       _path[UNIX_PATH_MAX-1] = &#39;\0&#39;;</span>
<span class="line-removed"> 80       _has_path = true;</span>
<span class="line-removed"> 81     }</span>
<span class="line-removed"> 82   }</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84   static void set_listener(int s)               { _listener = s; }</span>
 85 
 86   // reads a request from the given connected socket
 87   static AixAttachOperation* read_request(int s);
 88 
 89  public:
 90   enum {
 91     ATTACH_PROTOCOL_VER = 1                     // protocol version
 92   };
 93   enum {
 94     ATTACH_ERROR_BADVERSION     = 101           // error codes
 95   };
 96 













 97   // initialize the listener, returns 0 if okay
 98   static int init();
 99 
100   static char* path()                   { return _path; }
101   static bool has_path()                { return _has_path; }
102   static int listener()                 { return _listener; }
103   // Shutdown marker to prevent accept blocking during clean-up
104   static void set_shutdown(bool shutdown) { _shutdown = shutdown; }
105   static bool is_shutdown()     { return _shutdown; }
106 
107   // write the given buffer to a socket
108   static int write_fully(int s, char* buf, int len);
109 
110   static AixAttachOperation* dequeue();
111 };
112 
113 class AixAttachOperation: public AttachOperation {
114  private:
115   // the connection to the client
116   int _socket;
117 
118  public:
119   void complete(jint res, bufferedStream* st);
120 
121   void set_socket(int s)                                { _socket = s; }
122   int socket() const                                    { return _socket; }
123 
124   AixAttachOperation(char* name) : AttachOperation(name) {
125     set_socket(-1);
126   }
127 };
128 
129 // statics
130 char AixAttachListener::_path[UNIX_PATH_MAX];
131 bool AixAttachListener::_has_path;
132 int AixAttachListener::_listener = -1;

133 // Shutdown marker to prevent accept blocking during clean-up
134 bool AixAttachListener::_shutdown = false;
135 
136 // Supporting class to help split a buffer into individual components
137 class ArgumentIterator : public StackObj {
138  private:
139   char* _pos;
140   char* _end;
141  public:
142   ArgumentIterator(char* arg_buffer, size_t arg_size) {
143     _pos = arg_buffer;
144     _end = _pos + arg_size - 1;
145   }
146   char* next() {
147     if (*_pos == &#39;\0&#39;) {
148       // advance the iterator if possible (null arguments)
149       if (_pos &lt; _end) {
150         _pos += 1;
151       }
152       return NULL;
</pre>
<hr />
<pre>
160     return res;
161   }
162 };
163 
164 // On AIX if sockets block until all data has been transmitted
165 // successfully in some communication domains a socket &quot;close&quot; may
166 // never complete. We have to take care that after the socket shutdown
167 // the listener never enters accept state.
168 
169 // atexit hook to stop listener and unlink the file that it is
170 // bound too.
171 
172 // Some modifications to the listener logic to prevent deadlocks on exit.
173 // 1. We Shutdown the socket here instead. AixAttachOperation::complete() is not the right place
174 //    since more than one agent in a sequence in JPLIS live tests wouldn&#39;t work (Listener thread
175 //    would be dead after the first operation completion).
176 // 2. close(s) may never return if the listener thread is in socket accept(). Unlinking the file
177 //    should be sufficient for cleanup.
178 extern &quot;C&quot; {
179   static void listener_cleanup() {
<span class="line-modified">180     static int cleanup_done;</span>
<span class="line-modified">181     if (!cleanup_done) {</span>
<span class="line-modified">182       cleanup_done = 1;</span>
<span class="line-modified">183       AixAttachListener::set_shutdown(true);</span>
<span class="line-modified">184       int s = AixAttachListener::listener();</span>
<span class="line-modified">185       if (s != -1) {</span>
<span class="line-modified">186         ::shutdown(s, 2);</span>
<span class="line-modified">187       }</span>
<span class="line-modified">188       if (AixAttachListener::has_path()) {</span>
<span class="line-removed">189         ::unlink(AixAttachListener::path());</span>
<span class="line-removed">190       }</span>
191     }
192   }
193 }
194 
195 // Initialization - create a listener socket and bind it to a file
196 
197 int AixAttachListener::init() {
198   char path[UNIX_PATH_MAX];          // socket file
199   char initial_path[UNIX_PATH_MAX];  // socket file during setup
200   int listener;                      // listener socket (file descriptor)
201 
202   // register function to cleanup
<span class="line-modified">203   ::atexit(listener_cleanup);</span>



204 
205   int n = snprintf(path, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
206                    os::get_temp_directory(), os::current_process_id());
207   if (n &lt; (int)UNIX_PATH_MAX) {
208     n = snprintf(initial_path, UNIX_PATH_MAX, &quot;%s.tmp&quot;, path);
209   }
210   if (n &gt;= (int)UNIX_PATH_MAX) {
211     return -1;
212   }
213 
214   // create the listener socket
215   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
216   if (listener == -1) {
217     return -1;
218   }
219 
220   // bind socket
221   struct sockaddr_un addr;
222   memset((void *)&amp;addr, 0, sizeof(addr));
223   addr.sun_family = AF_UNIX;
</pre>
<hr />
<pre>
498     }
499   }
500 }
501 
502 int AttachListener::pd_init() {
503   JavaThread* thread = JavaThread::current();
504   ThreadBlockInVM tbivm(thread);
505 
506   thread-&gt;set_suspend_equivalent();
507   // cleared by handle_special_suspend_equivalent_condition() or
508   // java_suspend_self() via check_and_wait_while_suspended()
509 
510   int ret_code = AixAttachListener::init();
511 
512   // were we externally suspended while we were waiting?
513   thread-&gt;check_and_wait_while_suspended();
514 
515   return ret_code;
516 }
517 




















518 // Attach Listener is started lazily except in the case when
519 // +ReduseSignalUsage is used
520 bool AttachListener::init_at_startup() {
521   if (ReduceSignalUsage) {
522     return true;
523   } else {
524     return false;
525   }
526 }
527 
528 // If the file .attach_pid&lt;pid&gt; exists in the working directory
529 // or /tmp then this is the trigger to start the attach mechanism
530 bool AttachListener::is_init_trigger() {
531   if (init_at_startup() || is_initialized()) {
532     return false;               // initialized at startup or already initialized
533   }
534   char fn[PATH_MAX + 1];
535   int ret;
536   struct stat64 st;
537   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 54 // the security:
 55 // 1. The well known file that the socket is bound to has permission 400
 56 // 2. When a client connect, the SO_PEERID socket option is used to
 57 //    obtain the credentials of client. We check that the effective uid
 58 //    of the client matches this process.
 59 
 60 // forward reference
 61 class AixAttachOperation;
 62 
 63 class AixAttachListener: AllStatic {
 64  private:
 65   // the path to which we bind the UNIX domain socket
 66   static char _path[UNIX_PATH_MAX];
 67   static bool _has_path;
 68   // Shutdown marker to prevent accept blocking during clean-up.
 69   static bool _shutdown;
 70 
 71   // the file descriptor for the listening socket
 72   static int _listener;
 73 
<span class="line-modified"> 74   static bool _atexit_registered;</span>










 75 
 76   // reads a request from the given connected socket
 77   static AixAttachOperation* read_request(int s);
 78 
 79  public:
 80   enum {
 81     ATTACH_PROTOCOL_VER = 1                     // protocol version
 82   };
 83   enum {
 84     ATTACH_ERROR_BADVERSION     = 101           // error codes
 85   };
 86 
<span class="line-added"> 87   static void set_path(char* path) {</span>
<span class="line-added"> 88     if (path == NULL) {</span>
<span class="line-added"> 89       _path[0] = &#39;\0&#39;;</span>
<span class="line-added"> 90       _has_path = false;</span>
<span class="line-added"> 91     } else {</span>
<span class="line-added"> 92       strncpy(_path, path, UNIX_PATH_MAX);</span>
<span class="line-added"> 93       _path[UNIX_PATH_MAX-1] = &#39;\0&#39;;</span>
<span class="line-added"> 94       _has_path = true;</span>
<span class="line-added"> 95     }</span>
<span class="line-added"> 96   }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98   static void set_listener(int s)               { _listener = s; }</span>
<span class="line-added"> 99 </span>
100   // initialize the listener, returns 0 if okay
101   static int init();
102 
103   static char* path()                   { return _path; }
104   static bool has_path()                { return _has_path; }
105   static int listener()                 { return _listener; }
106   // Shutdown marker to prevent accept blocking during clean-up
107   static void set_shutdown(bool shutdown) { _shutdown = shutdown; }
108   static bool is_shutdown()     { return _shutdown; }
109 
110   // write the given buffer to a socket
111   static int write_fully(int s, char* buf, int len);
112 
113   static AixAttachOperation* dequeue();
114 };
115 
116 class AixAttachOperation: public AttachOperation {
117  private:
118   // the connection to the client
119   int _socket;
120 
121  public:
122   void complete(jint res, bufferedStream* st);
123 
124   void set_socket(int s)                                { _socket = s; }
125   int socket() const                                    { return _socket; }
126 
127   AixAttachOperation(char* name) : AttachOperation(name) {
128     set_socket(-1);
129   }
130 };
131 
132 // statics
133 char AixAttachListener::_path[UNIX_PATH_MAX];
134 bool AixAttachListener::_has_path;
135 int AixAttachListener::_listener = -1;
<span class="line-added">136 bool AixAttachListener::_atexit_registered = false;</span>
137 // Shutdown marker to prevent accept blocking during clean-up
138 bool AixAttachListener::_shutdown = false;
139 
140 // Supporting class to help split a buffer into individual components
141 class ArgumentIterator : public StackObj {
142  private:
143   char* _pos;
144   char* _end;
145  public:
146   ArgumentIterator(char* arg_buffer, size_t arg_size) {
147     _pos = arg_buffer;
148     _end = _pos + arg_size - 1;
149   }
150   char* next() {
151     if (*_pos == &#39;\0&#39;) {
152       // advance the iterator if possible (null arguments)
153       if (_pos &lt; _end) {
154         _pos += 1;
155       }
156       return NULL;
</pre>
<hr />
<pre>
164     return res;
165   }
166 };
167 
168 // On AIX if sockets block until all data has been transmitted
169 // successfully in some communication domains a socket &quot;close&quot; may
170 // never complete. We have to take care that after the socket shutdown
171 // the listener never enters accept state.
172 
173 // atexit hook to stop listener and unlink the file that it is
174 // bound too.
175 
176 // Some modifications to the listener logic to prevent deadlocks on exit.
177 // 1. We Shutdown the socket here instead. AixAttachOperation::complete() is not the right place
178 //    since more than one agent in a sequence in JPLIS live tests wouldn&#39;t work (Listener thread
179 //    would be dead after the first operation completion).
180 // 2. close(s) may never return if the listener thread is in socket accept(). Unlinking the file
181 //    should be sufficient for cleanup.
182 extern &quot;C&quot; {
183   static void listener_cleanup() {
<span class="line-modified">184     AixAttachListener::set_shutdown(true);</span>
<span class="line-modified">185     int s = AixAttachListener::listener();</span>
<span class="line-modified">186     if (s != -1) {</span>
<span class="line-modified">187       AixAttachListener::set_listener(-1);</span>
<span class="line-modified">188       ::shutdown(s, 2);</span>
<span class="line-modified">189     }</span>
<span class="line-modified">190     if (AixAttachListener::has_path()) {</span>
<span class="line-modified">191       ::unlink(AixAttachListener::path());</span>
<span class="line-modified">192       AixAttachListener::set_path(NULL);</span>


193     }
194   }
195 }
196 
197 // Initialization - create a listener socket and bind it to a file
198 
199 int AixAttachListener::init() {
200   char path[UNIX_PATH_MAX];          // socket file
201   char initial_path[UNIX_PATH_MAX];  // socket file during setup
202   int listener;                      // listener socket (file descriptor)
203 
204   // register function to cleanup
<span class="line-modified">205   if (!_atexit_registered) {</span>
<span class="line-added">206     _atexit_registered = true;</span>
<span class="line-added">207     ::atexit(listener_cleanup);</span>
<span class="line-added">208   }</span>
209 
210   int n = snprintf(path, UNIX_PATH_MAX, &quot;%s/.java_pid%d&quot;,
211                    os::get_temp_directory(), os::current_process_id());
212   if (n &lt; (int)UNIX_PATH_MAX) {
213     n = snprintf(initial_path, UNIX_PATH_MAX, &quot;%s.tmp&quot;, path);
214   }
215   if (n &gt;= (int)UNIX_PATH_MAX) {
216     return -1;
217   }
218 
219   // create the listener socket
220   listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
221   if (listener == -1) {
222     return -1;
223   }
224 
225   // bind socket
226   struct sockaddr_un addr;
227   memset((void *)&amp;addr, 0, sizeof(addr));
228   addr.sun_family = AF_UNIX;
</pre>
<hr />
<pre>
503     }
504   }
505 }
506 
507 int AttachListener::pd_init() {
508   JavaThread* thread = JavaThread::current();
509   ThreadBlockInVM tbivm(thread);
510 
511   thread-&gt;set_suspend_equivalent();
512   // cleared by handle_special_suspend_equivalent_condition() or
513   // java_suspend_self() via check_and_wait_while_suspended()
514 
515   int ret_code = AixAttachListener::init();
516 
517   // were we externally suspended while we were waiting?
518   thread-&gt;check_and_wait_while_suspended();
519 
520   return ret_code;
521 }
522 
<span class="line-added">523 bool AttachListener::check_socket_file() {</span>
<span class="line-added">524   int ret;</span>
<span class="line-added">525   struct stat64 st;</span>
<span class="line-added">526   ret = stat64(AixAttachListener::path(), &amp;st);</span>
<span class="line-added">527   if (ret == -1) { // need to restart attach listener.</span>
<span class="line-added">528     log_debug(attach)(&quot;Socket file %s does not exist - Restart Attach Listener&quot;,</span>
<span class="line-added">529                       AixAttachListener::path());</span>
<span class="line-added">530 </span>
<span class="line-added">531     listener_cleanup();</span>
<span class="line-added">532 </span>
<span class="line-added">533     // wait to terminate current attach listener instance...</span>
<span class="line-added">534     while (AttachListener::transit_state(AL_INITIALIZING,</span>
<span class="line-added">535                                          AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {</span>
<span class="line-added">536       os::naked_yield();</span>
<span class="line-added">537     }</span>
<span class="line-added">538     return is_init_trigger();</span>
<span class="line-added">539   }</span>
<span class="line-added">540   return false;</span>
<span class="line-added">541 }</span>
<span class="line-added">542 </span>
543 // Attach Listener is started lazily except in the case when
544 // +ReduseSignalUsage is used
545 bool AttachListener::init_at_startup() {
546   if (ReduceSignalUsage) {
547     return true;
548   } else {
549     return false;
550   }
551 }
552 
553 // If the file .attach_pid&lt;pid&gt; exists in the working directory
554 // or /tmp then this is the trigger to start the attach mechanism
555 bool AttachListener::is_init_trigger() {
556   if (init_at_startup() || is_initialized()) {
557     return false;               // initialized at startup or already initialized
558   }
559   char fn[PATH_MAX + 1];
560   int ret;
561   struct stat64 st;
562   sprintf(fn, &quot;.attach_pid%d&quot;, os::current_process_id());
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/zero/vm_version_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals_aix.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
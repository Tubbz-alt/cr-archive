<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/aix/libodm_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="libodm_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loadlib_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/libodm_aix.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">  3  * Copyright (c) 2015, 2015 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
 51   fun_odm_get_obj     _odm_get_obj;
 52   fun_odm_terminate   _odm_terminate;
 53  public:
 54   dynamicOdm();
 55   ~dynamicOdm();
 56   bool odm_loaded() {return _libhandle != NULL; }
 57 };
 58 
 59 
 60 // We provide a more convenient interface for odm access and
 61 // especially to determine the exact AIX kernel version.
 62 
 63 class odmWrapper : private dynamicOdm {
 64   CLASS_SYMBOL _odm_class;
 65   char *_data;
 66   bool _initialized;
 67   void clean_data();
 68 
 69  public:
 70   // Make sure everything gets initialized and cleaned up properly.
<span class="line-modified"> 71   explicit odmWrapper(char* odm_class_name, char* odm_path = NULL) : _odm_class((CLASS_SYMBOL)-1),</span>
 72                                                                      _data(NULL), _initialized(false) {
 73     if (!odm_loaded()) { return; }
 74     _initialized = ((*_odm_initialize)() != -1);
 75     if (_initialized) {
<span class="line-modified"> 76       if (odm_path) { (*_odm_set_path)(odm_path); }</span>
<span class="line-modified"> 77       _odm_class = (*_odm_mount_class)(odm_class_name);</span>


 78     }
 79   }
 80   ~odmWrapper() {
 81     if (_initialized) { (*_odm_terminate)(); clean_data(); }
 82   }
 83 
 84   CLASS_SYMBOL odm_class() { return _odm_class; }
 85   bool has_class() { return odm_class() != (CLASS_SYMBOL)-1; }
<span class="line-modified"> 86   int class_offset(char *field, bool is_aix_5);</span>
 87   char* data() { return _data; }
 88 
<span class="line-modified"> 89   char* retrieve_obj(char* name = NULL) {</span>
 90     clean_data();
<span class="line-modified"> 91     char *cnp = (char*)(void*)(*_odm_get_obj)(odm_class(), name, NULL, (name == NULL) ? ODM_NEXT : ODM_FIRST);</span>
 92     if (cnp != (char*)-1) { _data = cnp; }
 93     return data();
 94   }
 95 
 96   int read_short(int offs) {
 97     short *addr = (short*)(data() + offs);
 98     return *addr;
 99   }
100 
101   // Determine the exact AIX kernel version as 4 byte value.
102   // The high order 2 bytes must be initialized already. They can be determined by uname.
103   static void determine_os_kernel_version(uint32_t* p_ver);
104 };
105 
106 #endif // OS_AIX_LIBODM_AIX_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">  3  * Copyright (c) 2015, 2019 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
</pre>
<hr />
<pre>
 51   fun_odm_get_obj     _odm_get_obj;
 52   fun_odm_terminate   _odm_terminate;
 53  public:
 54   dynamicOdm();
 55   ~dynamicOdm();
 56   bool odm_loaded() {return _libhandle != NULL; }
 57 };
 58 
 59 
 60 // We provide a more convenient interface for odm access and
 61 // especially to determine the exact AIX kernel version.
 62 
 63 class odmWrapper : private dynamicOdm {
 64   CLASS_SYMBOL _odm_class;
 65   char *_data;
 66   bool _initialized;
 67   void clean_data();
 68 
 69  public:
 70   // Make sure everything gets initialized and cleaned up properly.
<span class="line-modified"> 71   explicit odmWrapper(const char* odm_class_name, const char* odm_path = NULL) : _odm_class((CLASS_SYMBOL)-1),</span>
 72                                                                      _data(NULL), _initialized(false) {
 73     if (!odm_loaded()) { return; }
 74     _initialized = ((*_odm_initialize)() != -1);
 75     if (_initialized) {
<span class="line-modified"> 76       // should we free what odm_set_path returns, man page suggests it</span>
<span class="line-modified"> 77       // see https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/o_bostechref/odm_set_path.html</span>
<span class="line-added"> 78       if (odm_path) { (*_odm_set_path)((char*)odm_path); }</span>
<span class="line-added"> 79       _odm_class = (*_odm_mount_class)((char*)odm_class_name);</span>
 80     }
 81   }
 82   ~odmWrapper() {
 83     if (_initialized) { (*_odm_terminate)(); clean_data(); }
 84   }
 85 
 86   CLASS_SYMBOL odm_class() { return _odm_class; }
 87   bool has_class() { return odm_class() != (CLASS_SYMBOL)-1; }
<span class="line-modified"> 88   int class_offset(const char *field, bool is_aix_5);</span>
 89   char* data() { return _data; }
 90 
<span class="line-modified"> 91   char* retrieve_obj(const char* name = NULL) {</span>
 92     clean_data();
<span class="line-modified"> 93     char *cnp = (char*)(void*)(*_odm_get_obj)(odm_class(), (char*) name, NULL, (name == NULL) ? ODM_NEXT : ODM_FIRST);</span>
 94     if (cnp != (char*)-1) { _data = cnp; }
 95     return data();
 96   }
 97 
 98   int read_short(int offs) {
 99     short *addr = (short*)(data() + offs);
100     return *addr;
101   }
102 
103   // Determine the exact AIX kernel version as 4 byte value.
104   // The high order 2 bytes must be initialized already. They can be determined by uname.
105   static void determine_os_kernel_version(uint32_t* p_ver);
106 };
107 
108 #endif // OS_AIX_LIBODM_AIX_HPP
</pre>
</td>
</tr>
</table>
<center><a href="libodm_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loadlib_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
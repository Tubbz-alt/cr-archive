<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/os/aix/os_perf_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_aix.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_aix.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/os_perf_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;jvm.h&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;os_aix.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/os_perf.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  #include CPU_HEADER(vm_version_ext)
  
  #include &lt;stdio.h&gt;
  #include &lt;stdarg.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,114 ***</span>
    n = vread_statdata(procfile, fmt, args);
    va_end(args);
    return n;
  }
  
<span class="line-removed">- static FILE* open_statfile(void) {</span>
<span class="line-removed">-   FILE *f;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed">-     static int haveWarned = 0;</span>
<span class="line-removed">-     if (!haveWarned) {</span>
<span class="line-removed">-       haveWarned = 1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return f;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void</span>
<span class="line-removed">- next_line(FILE *f) {</span>
<span class="line-removed">-   int c;</span>
<span class="line-removed">-   do {</span>
<span class="line-removed">-     c = fgetc(f);</span>
<span class="line-removed">-   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  /**
<span class="line-modified">!  * Return the total number of ticks since the system was booted.</span>
<span class="line-modified">!  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="line-removed">-  * the number of ticks spent on actual processes (user, system or</span>
<span class="line-removed">-  * nice processes) since system boot. Note that this is the total number</span>
<span class="line-removed">-  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="line-removed">-  * n times the number of ticks that has passed in clock time.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Returns a negative value if the reading of the ticks failed.</span>
   */
  static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
<span class="line-modified">!   FILE*         fh;</span>
<span class="line-removed">-   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-removed">-   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-removed">-   int           logical_cpu = -1;</span>
<span class="line-removed">-   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="line-removed">-   int           n;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if ((fh = open_statfile()) == NULL) {</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (-1 == which_logical_cpu) {</span>
<span class="line-removed">-     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed">-             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed">-             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-removed">-             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // Move to next line</span>
<span class="line-removed">-     next_line(fh);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-removed">-     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-removed">-       next_line(fh);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed">-                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed">-                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-removed">-                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   fclose(fh);</span>
<span class="line-removed">-   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-removed">- #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed">-     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed">-   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="line-removed">-           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed">-           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="line-removed">-           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="line-removed">-           iowTicks, irqTicks, sirqTicks);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-removed">-   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-removed">-   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-removed">-                        iowTicks + irqTicks + sirqTicks;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return OS_OK;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- static int get_systemtype(void) {</span>
<span class="line-removed">-   static int procEntriesType = UNDETECTED;</span>
<span class="line-removed">-   DIR *taskDir;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (procEntriesType != UNDETECTED) {</span>
<span class="line-removed">-     return procEntriesType;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check whether we have a task subdirectory</span>
<span class="line-removed">-   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {</span>
<span class="line-removed">-     procEntriesType = UNDETECTABLE;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system</span>
<span class="line-removed">-     closedir(taskDir);</span>
<span class="line-removed">-     procEntriesType = LINUX26_NPTL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return procEntriesType;</span>
  }
  
  /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
  static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
    return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
<span class="line-new-header">--- 272,16 ---</span>
    n = vread_statdata(procfile, fmt, args);
    va_end(args);
    return n;
  }
  
  /**
<span class="line-modified">!  * on Linux we got the ticks related information from /proc/stat</span>
<span class="line-modified">!  * this does not work on AIX, libperfstat might be an alternative</span>
   */
  static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
<span class="line-modified">!   return OS_ERR;</span>
  }
  
  /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
  static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
    return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,30 ***</span>
  /**
   * Return the number of ticks spent in any of the processes belonging
   * to the JVM on any CPU.
   */
  static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
<span class="line-modified">!   uint64_t userTicks;</span>
<span class="line-removed">-   uint64_t systemTicks;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (get_systemtype() != LINUX26_NPTL) {</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // get the total</span>
<span class="line-removed">-   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   pticks-&gt;used       = userTicks;</span>
<span class="line-removed">-   pticks-&gt;usedKernel = systemTicks;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return OS_OK;</span>
  }
  
  /**
   * Return the load of the CPU as a double. 1.0 means the CPU process uses all
   * available time for user or system processes, 0.0 means the CPU uses all time
<span class="line-new-header">--- 291,11 ---</span>
  /**
   * Return the number of ticks spent in any of the processes belonging
   * to the JVM on any CPU.
   */
  static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
<span class="line-modified">!   return OS_ERR;</span>
  }
  
  /**
   * Return the load of the CPU as a double. 1.0 means the CPU process uses all
   * available time for user or system processes, 0.0 means the CPU uses all time
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,33 ***</span>
  
    return user_load;
  }
  
  static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
<span class="line-modified">!   FILE *f;</span>
<span class="line-removed">-   va_list args;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   va_start(args, fmt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if ((f = open_statfile()) == NULL) {</span>
<span class="line-removed">-     va_end(args);</span>
<span class="line-removed">-     return OS_ERR;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   for (;;) {</span>
<span class="line-removed">-     char line[80];</span>
<span class="line-removed">-     if (fgets(line, sizeof(line), f) != NULL) {</span>
<span class="line-removed">-       if (vsscanf(line, fmt, args) == 1) {</span>
<span class="line-removed">-         fclose(f);</span>
<span class="line-removed">-         va_end(args);</span>
<span class="line-removed">-         return OS_OK;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         fclose(f);</span>
<span class="line-removed">-         va_end(args);</span>
<span class="line-removed">-         return OS_ERR;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
  static int get_noof_context_switches(uint64_t* switches) {
    return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
  }
<span class="line-new-header">--- 355,11 ---</span>
  
    return user_load;
  }
  
  static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
<span class="line-modified">!   return OS_ERR;</span>
  }
  
  static int get_noof_context_switches(uint64_t* switches) {
    return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,55 ***</span>
    return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
  }
  
  static int perf_context_switch_rate(double* rate) {
    static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified">!   static uint64_t      lastTime;</span>
    static uint64_t      lastSwitches;
    static double        lastRate;
  
<span class="line-modified">!   uint64_t lt = 0;</span>
    int res = 0;
  
<span class="line-modified">!   if (lastTime == 0) {</span>
      uint64_t tmp;
      if (get_boot_time(&amp;tmp) &lt; 0) {
        return OS_ERR;
      }
<span class="line-modified">!     lt = tmp * 1000;</span>
    }
  
    res = OS_OK;
  
    pthread_mutex_lock(&amp;contextSwitchLock);
    {
  
      uint64_t sw;
      s8 t, d;
  
<span class="line-modified">!     if (lastTime == 0) {</span>
<span class="line-modified">!       lastTime = lt;</span>
      }
  
<span class="line-removed">-     t = os::javaTimeMillis();</span>
<span class="line-removed">-     d = t - lastTime;</span>
<span class="line-removed">- </span>
      if (d == 0) {
        *rate = lastRate;
<span class="line-modified">!     } else if (!get_noof_context_switches(&amp;sw)) {</span>
        *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
        lastRate     = *rate;
        lastSwitches = sw;
<span class="line-modified">!       lastTime     = t;</span>
      } else {
        *rate = 0;
        res   = OS_ERR;
      }
      if (*rate &lt;= 0) {
        *rate = 0;
        lastRate = 0;
      }
    }
    pthread_mutex_unlock(&amp;contextSwitchLock);
  
    return res;
  }
<span class="line-new-header">--- 369,70 ---</span>
    return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
  }
  
  static int perf_context_switch_rate(double* rate) {
    static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<span class="line-modified">!   static uint64_t      bootTime;</span>
<span class="line-added">+   static uint64_t      lastTimeNanos;</span>
    static uint64_t      lastSwitches;
    static double        lastRate;
  
<span class="line-modified">!   uint64_t bt = 0;</span>
    int res = 0;
  
<span class="line-modified">!   // First time through bootTime will be zero.</span>
<span class="line-added">+   if (bootTime == 0) {</span>
      uint64_t tmp;
      if (get_boot_time(&amp;tmp) &lt; 0) {
        return OS_ERR;
      }
<span class="line-modified">!     bt = tmp * 1000;</span>
    }
  
    res = OS_OK;
  
    pthread_mutex_lock(&amp;contextSwitchLock);
    {
  
      uint64_t sw;
      s8 t, d;
  
<span class="line-modified">!     if (bootTime == 0) {</span>
<span class="line-modified">!       // First interval is measured from boot time which is</span>
<span class="line-added">+       // seconds since the epoch. Thereafter we measure the</span>
<span class="line-added">+       // elapsed time using javaTimeNanos as it is monotonic-</span>
<span class="line-added">+       // non-decreasing.</span>
<span class="line-added">+       lastTimeNanos = os::javaTimeNanos();</span>
<span class="line-added">+       t = os::javaTimeMillis();</span>
<span class="line-added">+       d = t - bt;</span>
<span class="line-added">+       // keep bootTime zero for now to use as a first-time-through flag</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       t = os::javaTimeNanos();</span>
<span class="line-added">+       d = nanos_to_millis(t - lastTimeNanos);</span>
      }
  
      if (d == 0) {
        *rate = lastRate;
<span class="line-modified">!     } else if (get_noof_context_switches(&amp;sw) == 0) {</span>
        *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
        lastRate     = *rate;
        lastSwitches = sw;
<span class="line-modified">!       if (bootTime != 0) {</span>
<span class="line-added">+         lastTimeNanos = t;</span>
<span class="line-added">+       }</span>
      } else {
        *rate = 0;
        res   = OS_ERR;
      }
      if (*rate &lt;= 0) {
        *rate = 0;
        lastRate = 0;
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (bootTime == 0) {</span>
<span class="line-added">+       bootTime = bt;</span>
<span class="line-added">+     }</span>
    }
    pthread_mutex_unlock(&amp;contextSwitchLock);
  
    return res;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 580,16 ***</span>
    _counters.nProcs = os::active_processor_count();
    _counters.cpus = NULL;
  }
  
  bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">!   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="line-modified">!   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified">!   if (NULL == _counters.cpus) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   memset(_counters.cpus, 0, tick_array_size);</span>
  
    // For the CPU load total
    get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);
  
    // For each CPU
<span class="line-new-header">--- 457,13 ---</span>
    _counters.nProcs = os::active_processor_count();
    _counters.cpus = NULL;
  }
  
  bool CPUPerformanceInterface::CPUPerformance::initialize() {
<span class="line-modified">!   size_t array_entry_count = _counters.nProcs + 1;</span>
<span class="line-modified">!   _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);</span>
<span class="line-modified">!   memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));</span>
  
    // For the CPU load total
    get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);
  
    // For each CPU
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
    _impl = NULL;
  }
  
  bool CPUPerformanceInterface::initialize() {
    _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">!   return NULL == _impl ? false : _impl-&gt;initialize();</span>
  }
  
  CPUPerformanceInterface::~CPUPerformanceInterface() {
    if (_impl != NULL) {
      delete _impl;
<span class="line-new-header">--- 546,11 ---</span>
    _impl = NULL;
  }
  
  bool CPUPerformanceInterface::initialize() {
    _impl = new CPUPerformanceInterface::CPUPerformance();
<span class="line-modified">!   return _impl-&gt;initialize();</span>
  }
  
  CPUPerformanceInterface::~CPUPerformanceInterface() {
    if (_impl != NULL) {
      delete _impl;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 825,23 ***</span>
      while (fread(&amp;dummy, 1, 1, fp) == 1) {
        size++;
      }
      if (size &gt; 0) {
        cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified">!       if (cmdline != NULL) {</span>
<span class="line-modified">!         cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified">!         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified">!           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified">!             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified">!             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified">!             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified">!               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-removed">-                 cmdline[i] = &#39; &#39;;</span>
<span class="line-removed">-               }</span>
              }
<span class="line-removed">-             cmdline[size] = &#39;\0&#39;;</span>
            }
          }
        }
      }
      fclose(fp);
    }
<span class="line-new-header">--- 699,21 ---</span>
      while (fread(&amp;dummy, 1, 1, fp) == 1) {
        size++;
      }
      if (size &gt; 0) {
        cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<span class="line-modified">!       cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified">!       if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified">!         if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified">!           // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified">!           // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified">!           for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified">!             if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-modified">!               cmdline[i] = &#39; &#39;;</span>
              }
            }
<span class="line-added">+           cmdline[size] = &#39;\0&#39;;</span>
          }
        }
      }
      fclose(fp);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,11 ***</span>
    _iterator = NULL;
  }
  
  bool SystemProcessInterface::SystemProcesses::initialize() {
    _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">!   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
  }
  
  SystemProcessInterface::SystemProcesses::~SystemProcesses() {
    if (_iterator != NULL) {
      delete _iterator;
<span class="line-new-header">--- 799,11 ---</span>
    _iterator = NULL;
  }
  
  bool SystemProcessInterface::SystemProcesses::initialize() {
    _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<span class="line-modified">!   return _iterator-&gt;initialize();</span>
  }
  
  SystemProcessInterface::SystemProcesses::~SystemProcesses() {
    if (_iterator != NULL) {
      delete _iterator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 974,11 ***</span>
    _impl = NULL;
  }
  
  bool SystemProcessInterface::initialize() {
    _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">!   return NULL == _impl ? false : _impl-&gt;initialize();</span>
  }
  
  SystemProcessInterface::~SystemProcessInterface() {
    if (_impl != NULL) {
      delete _impl;
<span class="line-new-header">--- 846,11 ---</span>
    _impl = NULL;
  }
  
  bool SystemProcessInterface::initialize() {
    _impl = new SystemProcessInterface::SystemProcesses();
<span class="line-modified">!   return _impl-&gt;initialize();</span>
  }
  
  SystemProcessInterface::~SystemProcessInterface() {
    if (_impl != NULL) {
      delete _impl;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 989,19 ***</span>
    _cpu_info = NULL;
  }
  
  bool CPUInformationInterface::initialize() {
    _cpu_info = new CPUInformation();
<span class="line-removed">-   if (NULL == _cpu_info) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
    _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
    _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
    _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
    _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
    _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<span class="line-removed">- </span>
    return true;
  }
  
  CPUInformationInterface::~CPUInformationInterface() {
    if (_cpu_info != NULL) {
<span class="line-new-header">--- 861,15 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,12 ***</span>
  
  class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
    friend class NetworkPerformanceInterface;
   private:
    NetworkPerformance();
<span class="line-modified">!   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">-   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
    bool initialize();
    ~NetworkPerformance();
    int network_utilization(NetworkInterface** network_interfaces) const;
  };
  
<span class="line-new-header">--- 898,11 ---</span>
  
  class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
    friend class NetworkPerformanceInterface;
   private:
    NetworkPerformance();
<span class="line-modified">!   NONCOPYABLE(NetworkPerformance);</span>
    bool initialize();
    ~NetworkPerformance();
    int network_utilization(NetworkInterface** network_interfaces) const;
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,11 ***</span>
    }
  }
  
  bool NetworkPerformanceInterface::initialize() {
    _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">!   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
  }
  
  int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
    return _impl-&gt;network_utilization(network_interfaces);
  }
<span class="line-new-header">--- 932,11 ---</span>
    }
  }
  
  bool NetworkPerformanceInterface::initialize() {
    _impl = new NetworkPerformanceInterface::NetworkPerformance();
<span class="line-modified">!   return _impl-&gt;initialize();</span>
  }
  
  int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
    return _impl-&gt;network_utilization(network_interfaces);
  }
</pre>
<center><a href="os_aix.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfMemory_aix.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
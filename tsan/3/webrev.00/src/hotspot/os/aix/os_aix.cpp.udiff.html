<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/os/aix/os_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loadlib_aix.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/aix/os_aix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,10 +35,11 @@</span>
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-added">+ #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;libo4.hpp&quot;
  #include &quot;libperfstat_aix.hpp&quot;
  #include &quot;libodm_aix.hpp&quot;
  #include &quot;loadlib_aix.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57,11 +58,10 @@</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/perfMemory.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/statSampler.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,22 +129,10 @@</span>
  #define ERROR_MP_EXTSHM_ACTIVE                       101
  #define ERROR_MP_VMGETINFO_FAILED                    102
  #define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103
  
  // excerpts from systemcfg.h that might be missing on older os levels
<span class="udiff-line-removed">- #ifndef PV_5_Compat</span>
<span class="udiff-line-removed">-   #define PV_5_Compat 0x0F8000   /* Power PC 5 */</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifndef PV_6</span>
<span class="udiff-line-removed">-   #define PV_6 0x100000          /* Power PC 6 */</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifndef PV_6_1</span>
<span class="udiff-line-removed">-   #define PV_6_1 0x100001        /* Power PC 6 DD1.x */</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifndef PV_6_Compat</span>
<span class="udiff-line-removed">-   #define PV_6_Compat 0x108000   /* Power PC 6 */</span>
<span class="udiff-line-removed">- #endif</span>
  #ifndef PV_7
    #define PV_7 0x200000          /* Power PC 7 */
  #endif
  #ifndef PV_7_Compat
    #define PV_7_Compat 0x208000   /* Power PC 7 */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,10 +141,17 @@</span>
    #define PV_8 0x300000          /* Power PC 8 */
  #endif
  #ifndef PV_8_Compat
    #define PV_8_Compat 0x308000   /* Power PC 8 */
  #endif
<span class="udiff-line-added">+ #ifndef PV_9</span>
<span class="udiff-line-added">+   #define PV_9 0x400000          /* Power PC 9 */</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifndef PV_9_Compat</span>
<span class="udiff-line-added">+   #define PV_9_Compat  0x408000  /* Power PC 9 */</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  
  static address resolve_function_descriptor_to_code_pointer(address p);
  
  static void vmembk_print_on(outputStream* os);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,20 +479,19 @@</span>
        struct shmid_ds shm_buf = { 0 };
        shm_buf.shm_pagesize = pagesize;
        if (::shmctl(shmid, SHM_PAGESIZE, &amp;shm_buf) != 0) {
          const int en = errno;
          ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
<span class="udiff-line-modified-removed">-         trcVerbose(&quot;shmctl(SHM_PAGESIZE) failed with errno=%n&quot;,</span>
<span class="udiff-line-removed">-           errno);</span>
<span class="udiff-line-modified-added">+         trcVerbose(&quot;shmctl(SHM_PAGESIZE) failed with errno=%d&quot;, errno);</span>
        } else {
          // Attach and double check pageisze.
          void* p = ::shmat(shmid, NULL, 0);
          ::shmctl(shmid, IPC_RMID, NULL); // As early as possible!
          guarantee0(p != (void*) -1); // Should always work.
          const size_t real_pagesize = os::Aix::query_pagesize(p);
          if (real_pagesize != pagesize) {
<span class="udiff-line-modified-removed">-           trcVerbose(&quot;real page size (0x%llX) differs.&quot;, real_pagesize);</span>
<span class="udiff-line-modified-added">+           trcVerbose(&quot;real page size (&quot; SIZE_FORMAT_HEX &quot;) differs.&quot;, real_pagesize);</span>
          } else {
            can_use = true;
          }
          ::shmdt(p);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -521,11 +515,11 @@</span>
        describe_pagesize(g_multipage_support.textpsize));
    trcVerbose(&quot;Thread stack page size (pthread): %s&quot;,
        describe_pagesize(g_multipage_support.pthr_stack_pagesize));
    trcVerbose(&quot;Default shared memory page size: %s&quot;,
        describe_pagesize(g_multipage_support.shmpsize));
<span class="udiff-line-modified-removed">-   trcVerbose(&quot;Can use 64K pages dynamically with shared meory: %s&quot;,</span>
<span class="udiff-line-modified-added">+   trcVerbose(&quot;Can use 64K pages dynamically with shared memory: %s&quot;,</span>
        (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
    trcVerbose(&quot;Can use 16M pages dynamically with shared memory: %s&quot;,
        (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
    trcVerbose(&quot;Multipage error details: %d&quot;,
        g_multipage_support.error);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,11 +546,11 @@</span>
    // Note that the space for the trailing null is provided
    // by the nulls included by the sizeof operator.
    const size_t bufsize =
      MAX2((size_t)MAXPATHLEN,  // For dll_dir &amp; friends.
           (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR)); // extensions dir
<span class="udiff-line-modified-removed">-   char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
<span class="udiff-line-modified-added">+   char *buf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);</span>
  
    // sysclasspath, java_home, dll_dir
    {
      char *pslash;
      os::jvm_path(buf, bufsize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,11 +588,11 @@</span>
    const char *v_colon = &quot;:&quot;;
    if (v == NULL) { v = &quot;&quot;; v_colon = &quot;&quot;; }
  
    // Concatenate user and invariant part of ld_library_path.
    // That&#39;s +1 for the colon and +1 for the trailing &#39;\0&#39;.
<span class="udiff-line-modified-removed">-   char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);</span>
<span class="udiff-line-modified-added">+   char *ld_library_path = NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);</span>
    sprintf(ld_library_path, &quot;%s%s&quot; DEFAULT_LIBPATH, v, v_colon);
    Arguments::set_library_path(ld_library_path);
    FREE_C_HEAP_ARRAY(char, ld_library_path);
  
    // Extensions directories.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -921,10 +915,15 @@</span>
        (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
    } else {
      char buf[64];
      log_warning(os, thread)(&quot;Failed to start thread - pthread_create failed (%d=%s) for attributes: %s.&quot;,
        ret, os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &amp;attr));
<span class="udiff-line-added">+     // Log some OS information which might explain why creating the thread failed.</span>
<span class="udiff-line-added">+     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());</span>
<span class="udiff-line-added">+     LogStream st(Log(os, thread)::info());</span>
<span class="udiff-line-added">+     os::Posix::print_rlimit_info(&amp;st);</span>
<span class="udiff-line-added">+     os::print_memory_info(&amp;st);</span>
    }
  
    pthread_attr_destroy(&amp;attr);
  
    if (ret != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1020,26 +1019,22 @@</span>
  // time support
  
  // Time since start-up in seconds to a fine granularity.
  // Used by VMSelfDestructTimer and the MemProfiler.
  double os::elapsedTime() {
<span class="udiff-line-modified-removed">-   return (double)(os::elapsed_counter()) * 0.000001;</span>
<span class="udiff-line-modified-added">+   return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution</span>
  }
  
  jlong os::elapsed_counter() {
<span class="udiff-line-modified-removed">-   timeval time;</span>
<span class="udiff-line-removed">-   int status = gettimeofday(&amp;time, NULL);</span>
<span class="udiff-line-removed">-   return jlong(time.tv_sec) * 1000 * 1000 + jlong(time.tv_usec) - initial_time_count;</span>
<span class="udiff-line-modified-added">+   return javaTimeNanos() - initial_time_count;</span>
  }
  
  jlong os::elapsed_frequency() {
<span class="udiff-line-modified-removed">-   return (1000 * 1000);</span>
<span class="udiff-line-modified-added">+   return NANOSECS_PER_SEC; // nanosecond resolution</span>
  }
  
  bool os::supports_vtime() { return true; }
<span class="udiff-line-removed">- bool os::enable_vtime()   { return false; }</span>
<span class="udiff-line-removed">- bool os::vtime_enabled()  { return false; }</span>
  
  double os::elapsedVTime() {
    struct rusage usage;
    int retval = getrusage(RUSAGE_THREAD, &amp;usage);
    if (retval == 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1086,11 +1081,11 @@</span>
      jlong now = jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);
      jlong prev = max_real_time;
      if (now &lt;= prev) {
        return prev;   // same or retrograde time;
      }
<span class="udiff-line-modified-removed">-     jlong obsv = Atomic::cmpxchg(now, &amp;max_real_time, prev);</span>
<span class="udiff-line-modified-added">+     jlong obsv = Atomic::cmpxchg(&amp;max_real_time, prev, now);</span>
      assert(obsv &gt;= prev, &quot;invariant&quot;);   // Monotonicity
      // If the CAS succeeded then we&#39;re done and return &quot;now&quot;.
      // If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then
      // we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then
      // some other thread raced this thread and installed a new value, in which case
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1198,12 +1193,19 @@</span>
  
    ::exit(1);
  }
  
  // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="udiff-line-added">+ // Dump a core file, if possible, for debugging.</span>
  void os::die() {
<span class="udiff-line-modified-removed">-   ::abort();</span>
<span class="udiff-line-modified-added">+   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {</span>
<span class="udiff-line-added">+     // For TimeoutInErrorHandlingTest.java, we just kill the VM</span>
<span class="udiff-line-added">+     // and don&#39;t take the time to generate a core file.</span>
<span class="udiff-line-added">+     os::signal_raise(SIGKILL);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ::abort();</span>
<span class="udiff-line-added">+   }</span>
  }
  
  intx os::current_thread_id() {
    return (intx)pthread_self();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1299,10 +1301,12 @@</span>
  
  // Loads .dll/.so and in case of error it checks if .dll/.so was built
  // for the same architecture as Hotspot is running on.
  void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {
  
<span class="udiff-line-added">+   log_info(os)(&quot;attempting shared library load of %s&quot;, filename);</span>
<span class="udiff-line-added">+ </span>
    if (ebuf &amp;&amp; ebuflen &gt; 0) {
      ebuf[0] = &#39;\0&#39;;
      ebuf[ebuflen - 1] = &#39;\0&#39;;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1312,20 +1316,27 @@</span>
    }
  
    // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.
    void * result= ::dlopen(filename, RTLD_LAZY);
    if (result != NULL) {
<span class="udiff-line-added">+     Events::log(NULL, &quot;Loaded shared library %s&quot;, filename);</span>
      // Reload dll cache. Don&#39;t do this in signal handling.
      LoadedLibraries::reload();
<span class="udiff-line-added">+     log_info(os)(&quot;shared library load of %s was successful&quot;, filename);</span>
      return result;
    } else {
      // error analysis when dlopen fails
<span class="udiff-line-modified-removed">-     const char* const error_report = ::dlerror();</span>
<span class="udiff-line-modified-removed">-     if (error_report &amp;&amp; ebuf &amp;&amp; ebuflen &gt; 0) {</span>
<span class="udiff-line-modified-added">+     const char* error_report = ::dlerror();</span>
<span class="udiff-line-modified-added">+     if (error_report == NULL) {</span>
<span class="udiff-line-added">+       error_report = &quot;dlerror returned no error description&quot;;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (ebuf != NULL &amp;&amp; ebuflen &gt; 0) {</span>
        snprintf(ebuf, ebuflen - 1, &quot;%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s&quot;,
                 filename, ::getenv(&quot;LIBPATH&quot;), ::getenv(&quot;LD_LIBRARY_PATH&quot;), error_report);
      }
<span class="udiff-line-added">+     Events::log(NULL, &quot;Loading shared library %s failed, %s&quot;, filename, error_report);</span>
<span class="udiff-line-added">+     log_info(os)(&quot;shared library load of %s failed, %s&quot;, filename, error_report);</span>
    }
    return NULL;
  }
  
  void* os::dll_lookup(void* handle, const char* name) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1365,49 +1376,36 @@</span>
  }
  
  void os::print_os_info(outputStream* st) {
    st-&gt;print(&quot;OS:&quot;);
  
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;uname:&quot;);</span>
<span class="udiff-line-removed">-   struct utsname name;</span>
<span class="udiff-line-removed">-   uname(&amp;name);</span>
<span class="udiff-line-removed">-   st-&gt;print(name.sysname); st-&gt;print(&quot; &quot;);</span>
<span class="udiff-line-removed">-   st-&gt;print(name.nodename); st-&gt;print(&quot; &quot;);</span>
<span class="udiff-line-removed">-   st-&gt;print(name.release); st-&gt;print(&quot; &quot;);</span>
<span class="udiff-line-removed">-   st-&gt;print(name.version); st-&gt;print(&quot; &quot;);</span>
<span class="udiff-line-removed">-   st-&gt;print(name.machine);</span>
<span class="udiff-line-removed">-   st-&gt;cr();</span>
<span class="udiff-line-modified-added">+   os::Posix::print_uname_info(st);</span>
  
    uint32_t ver = os::Aix::os_version();
    st-&gt;print_cr(&quot;AIX kernel version %u.%u.%u.%u&quot;,
                 (ver &gt;&gt; 24) &amp; 0xFF, (ver &gt;&gt; 16) &amp; 0xFF, (ver &gt;&gt; 8) &amp; 0xFF, ver &amp; 0xFF);
  
<span class="udiff-line-added">+   os::Posix::print_uptime_info(st);</span>
<span class="udiff-line-added">+ </span>
    os::Posix::print_rlimit_info(st);
  
<span class="udiff-line-modified-removed">-   // load average</span>
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;load average:&quot;);</span>
<span class="udiff-line-modified-removed">-   double loadavg[3] = {-1.L, -1.L, -1.L};</span>
<span class="udiff-line-modified-removed">-   os::loadavg(loadavg, 3);</span>
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;%0.02f %0.02f %0.02f&quot;, loadavg[0], loadavg[1], loadavg[2]);</span>
<span class="udiff-line-removed">-   st-&gt;cr();</span>
<span class="udiff-line-modified-added">+   os::Posix::print_load_average(st);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // _SC_THREAD_THREADS_MAX is the maximum number of threads within a process.</span>
<span class="udiff-line-modified-added">+   long tmax = sysconf(_SC_THREAD_THREADS_MAX);</span>
<span class="udiff-line-modified-added">+   st-&gt;print_cr(&quot;maximum #threads within a process:%ld&quot;, tmax);</span>
  
    // print wpar info
    libperfstat::wparinfo_t wi;
    if (libperfstat::get_wparinfo(&amp;wi)) {
      st-&gt;print_cr(&quot;wpar info&quot;);
      st-&gt;print_cr(&quot;name: %s&quot;, wi.name);
      st-&gt;print_cr(&quot;id:   %d&quot;, wi.wpar_id);
      st-&gt;print_cr(&quot;type: %s&quot;, (wi.app_wpar ? &quot;application&quot; : &quot;system&quot;));
    }
  
<span class="udiff-line-modified-removed">-   // print partition info</span>
<span class="udiff-line-removed">-   libperfstat::partitioninfo_t pi;</span>
<span class="udiff-line-removed">-   if (libperfstat::get_partitioninfo(&amp;pi)) {</span>
<span class="udiff-line-removed">-     st-&gt;print_cr(&quot;partition info&quot;);</span>
<span class="udiff-line-removed">-     st-&gt;print_cr(&quot; name: %s&quot;, pi.name);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   VM_Version::print_platform_virtualization_info(st);</span>
  }
  
  void os::print_memory_info(outputStream* st) {
  
    st-&gt;print_cr(&quot;Memory:&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1420,11 +1418,11 @@</span>
      describe_pagesize(g_multipage_support.textpsize));
    st-&gt;print_cr(&quot;  Thread stack page size (pthread):       %s&quot;,
      describe_pagesize(g_multipage_support.pthr_stack_pagesize));
    st-&gt;print_cr(&quot;  Default shared memory page size:        %s&quot;,
      describe_pagesize(g_multipage_support.shmpsize));
<span class="udiff-line-modified-removed">-   st-&gt;print_cr(&quot;  Can use 64K pages dynamically with shared meory:  %s&quot;,</span>
<span class="udiff-line-modified-added">+   st-&gt;print_cr(&quot;  Can use 64K pages dynamically with shared memory:  %s&quot;,</span>
      (g_multipage_support.can_use_64K_pages ? &quot;yes&quot; :&quot;no&quot;));
    st-&gt;print_cr(&quot;  Can use 16M pages dynamically with shared memory: %s&quot;,
      (g_multipage_support.can_use_16M_pages ? &quot;yes&quot; :&quot;no&quot;));
    st-&gt;print_cr(&quot;  Multipage error: %d&quot;,
      g_multipage_support.error);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1486,10 +1484,13 @@</span>
  
  // Get a string for the cpuinfo that is a summary of the cpu type
  void os::get_summary_cpu_info(char* buf, size_t buflen) {
    // read _system_configuration.version
    switch (_system_configuration.version) {
<span class="udiff-line-added">+   case PV_9:</span>
<span class="udiff-line-added">+     strncpy(buf, &quot;Power PC 9&quot;, buflen);</span>
<span class="udiff-line-added">+     break;</span>
    case PV_8:
      strncpy(buf, &quot;Power PC 8&quot;, buflen);
      break;
    case PV_7:
      strncpy(buf, &quot;Power PC 7&quot;, buflen);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1519,10 +1520,13 @@</span>
      strncpy(buf, &quot;PV_7_Compat&quot;, buflen);
      break;
    case PV_8_Compat:
      strncpy(buf, &quot;PV_8_Compat&quot;, buflen);
      break;
<span class="udiff-line-added">+   case PV_9_Compat:</span>
<span class="udiff-line-added">+     strncpy(buf, &quot;PV_9_Compat&quot;, buflen);</span>
<span class="udiff-line-added">+     break;</span>
    default:
      strncpy(buf, &quot;unknown&quot;, buflen);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1645,20 +1649,12 @@</span>
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  // sun.misc.Signal support
  
<span class="udiff-line-removed">- static volatile jint sigint_count = 0;</span>
<span class="udiff-line-removed">- </span>
  static void
  UserHandler(int sig, void *siginfo, void *context) {
<span class="udiff-line-removed">-   // 4511530 - sem_post is serialized and handled by the manager thread. When</span>
<span class="udiff-line-removed">-   // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We</span>
<span class="udiff-line-removed">-   // don&#39;t want to flood the manager thread with sem_post requests.</span>
<span class="udiff-line-removed">-   if (sig == SIGINT &amp;&amp; Atomic::add(1, &amp;sigint_count) &gt; 1)</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">- </span>
    // Ctrl-C is pressed during error reporting, likely because the error
    // handler fails to abort. Let VM die immediately.
    if (sig == SIGINT &amp;&amp; VMError::is_error_reported()) {
      os::die();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1794,15 +1790,14 @@</span>
    Atomic::inc(&amp;pending_signals[sig]);
    local_sem_post();
  }
  
  static int check_pending_signals() {
<span class="udiff-line-removed">-   Atomic::store(0, &amp;sigint_count);</span>
    for (;;) {
      for (int i = 0; i &lt; NSIG + 1; i++) {
        jint n = pending_signals[i];
<span class="udiff-line-modified-removed">-       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(n - 1, &amp;pending_signals[i], n)) {</span>
<span class="udiff-line-modified-added">+       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {</span>
          return i;
        }
      }
      JavaThread *thread = JavaThread::current();
      ThreadBlockInVM tbivm(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1871,16 +1866,16 @@</span>
    // also check that range is fully page aligned to the page size if the block.
    void assert_is_valid_subrange(char* p, size_t s) const {
      if (!contains_range(p, s)) {
        trcVerbose(&quot;[&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not a sub &quot;
                &quot;range of [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="udiff-line-modified-removed">-               p, p + s, addr, addr + size);</span>
<span class="udiff-line-modified-added">+               p2i(p), p2i(p + s), p2i(addr), p2i(addr + size));</span>
        guarantee0(false);
      }
      if (!is_aligned_to(p, pagesize) || !is_aligned_to(p + s, pagesize)) {
        trcVerbose(&quot;range [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;] is not&quot;
<span class="udiff-line-modified-removed">-               &quot; aligned to pagesize (%lu)&quot;, p, p + s, (unsigned long) pagesize);</span>
<span class="udiff-line-modified-added">+               &quot; aligned to pagesize (%lu)&quot;, p2i(p), p2i(p + s), (unsigned long) pagesize);</span>
        guarantee0(false);
      }
    }
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1947,20 +1942,20 @@</span>
    char* requested_addr,
    size_t alignment_hint) {
  
    trcVerbose(&quot;reserve_shmated_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot;
      PTR_FORMAT &quot;, alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="udiff-line-modified-removed">-     bytes, requested_addr, alignment_hint);</span>
<span class="udiff-line-modified-added">+     bytes, p2i(requested_addr), alignment_hint);</span>
  
    // Either give me wish address or wish alignment but not both.
    assert0(!(requested_addr != NULL &amp;&amp; alignment_hint != 0));
  
    // We must prevent anyone from attaching too close to the
    // BRK because that may cause malloc OOM.
    if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
      trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="udiff-line-modified-removed">-       &quot;Will attach anywhere.&quot;, requested_addr);</span>
<span class="udiff-line-modified-added">+       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
      // Act like the OS refused to attach there.
      requested_addr = NULL;
    }
  
    // For old AS/400&#39;s (V5R4 and older) we should not even be here - System V shared memory is not
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2008,27 +2003,27 @@</span>
      assert(false, &quot;failed to remove shared memory segment!&quot;);
    }
  
    // Handle shmat error. If we failed to attach, just return.
    if (addr == (char*)-1) {
<span class="udiff-line-modified-removed">-     trcVerbose(&quot;Failed to attach segment at &quot; PTR_FORMAT &quot; (%d).&quot;, requested_addr, errno_shmat);</span>
<span class="udiff-line-modified-added">+     trcVerbose(&quot;Failed to attach segment at &quot; PTR_FORMAT &quot; (%d).&quot;, p2i(requested_addr), errno_shmat);</span>
      return NULL;
    }
  
    // Just for info: query the real page size. In case setting the page size did not
    // work (see above), the system may have given us something other then 4K (LDR_CNTRL).
    const size_t real_pagesize = os::Aix::query_pagesize(addr);
    if (real_pagesize != shmbuf.shm_pagesize) {
<span class="udiff-line-modified-removed">-     trcVerbose(&quot;pagesize is, surprisingly, %h.&quot;, real_pagesize);</span>
<span class="udiff-line-modified-added">+     trcVerbose(&quot;pagesize is, surprisingly, &quot; SIZE_FORMAT, real_pagesize);</span>
    }
  
    if (addr) {
      trcVerbose(&quot;shm-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes, &quot; UINTX_FORMAT &quot; %s pages)&quot;,
<span class="udiff-line-modified-removed">-       addr, addr + size - 1, size, size/real_pagesize, describe_pagesize(real_pagesize));</span>
<span class="udiff-line-modified-added">+       p2i(addr), p2i(addr + size - 1), size, size/real_pagesize, describe_pagesize(real_pagesize));</span>
    } else {
      if (requested_addr != NULL) {
<span class="udiff-line-modified-removed">-       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at with address &quot; PTR_FORMAT &quot;.&quot;, size, requested_addr);</span>
<span class="udiff-line-modified-added">+       trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at with address &quot; PTR_FORMAT &quot;.&quot;, size, p2i(requested_addr));</span>
      } else {
        trcVerbose(&quot;failed to shm-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, size);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2040,11 +2035,11 @@</span>
  }
  
  static bool release_shmated_memory(char* addr, size_t size) {
  
    trcVerbose(&quot;release_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="udiff-line-modified-removed">-     addr, addr + size - 1);</span>
<span class="udiff-line-modified-added">+     p2i(addr), p2i(addr + size - 1));</span>
  
    bool rc = false;
  
    // TODO: is there a way to verify shm size without doing bookkeeping?
    if (::shmdt(addr) != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2056,16 +2051,16 @@</span>
    return rc;
  }
  
  static bool uncommit_shmated_memory(char* addr, size_t size) {
    trcVerbose(&quot;uncommit_shmated_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="udiff-line-modified-removed">-     addr, addr + size - 1);</span>
<span class="udiff-line-modified-added">+     p2i(addr), p2i(addr + size - 1));</span>
  
    const bool rc = my_disclaim64(addr, size);
  
    if (!rc) {
<span class="udiff-line-modified-removed">-     trcVerbose(&quot;my_disclaim64(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;) failed.\n&quot;, addr, size);</span>
<span class="udiff-line-modified-added">+     trcVerbose(&quot;my_disclaim64(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;) failed.\n&quot;, p2i(addr), size);</span>
      return false;
    }
    return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2078,23 +2073,23 @@</span>
  // allocate at an address aligned with the given alignment. Failing that, memory
  // is aligned anywhere.
  static char* reserve_mmaped_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
    trcVerbose(&quot;reserve_mmaped_memory &quot; UINTX_FORMAT &quot; bytes, wishaddress &quot; PTR_FORMAT &quot;, &quot;
      &quot;alignment_hint &quot; UINTX_FORMAT &quot;...&quot;,
<span class="udiff-line-modified-removed">-     bytes, requested_addr, alignment_hint);</span>
<span class="udiff-line-modified-added">+     bytes, p2i(requested_addr), alignment_hint);</span>
  
    // If a wish address is given, but not aligned to 4K page boundary, mmap will fail.
    if (requested_addr &amp;&amp; !is_aligned_to(requested_addr, os::vm_page_size()) != 0) {
<span class="udiff-line-modified-removed">-     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; not aligned to page boundary.&quot;, requested_addr);</span>
<span class="udiff-line-modified-added">+     trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; not aligned to page boundary.&quot;, p2i(requested_addr));</span>
      return NULL;
    }
  
    // We must prevent anyone from attaching too close to the
    // BRK because that may cause malloc OOM.
    if (requested_addr != NULL &amp;&amp; is_close_to_brk((address)requested_addr)) {
      trcVerbose(&quot;Wish address &quot; PTR_FORMAT &quot; is too close to the BRK segment. &quot;
<span class="udiff-line-modified-removed">-       &quot;Will attach anywhere.&quot;, requested_addr);</span>
<span class="udiff-line-modified-added">+       &quot;Will attach anywhere.&quot;, p2i(requested_addr));</span>
      // Act like the OS refused to attach there.
      requested_addr = NULL;
    }
  
    // Specify one or the other but not both.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2137,11 +2132,11 @@</span>
  
    char* addr = (char*)::mmap(requested_addr, extra_size,
        PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);
  
    if (addr == MAP_FAILED) {
<span class="udiff-line-modified-removed">-     trcVerbose(&quot;mmap(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;, ..) failed (%d)&quot;, requested_addr, size, errno);</span>
<span class="udiff-line-modified-added">+     trcVerbose(&quot;mmap(&quot; PTR_FORMAT &quot;, &quot; UINTX_FORMAT &quot;, ..) failed (%d)&quot;, p2i(requested_addr), size, errno);</span>
      return NULL;
    }
  
    // Handle alignment.
    char* const addr_aligned = align_up(addr, alignment_hint);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2156,14 +2151,14 @@</span>
    }
    addr = addr_aligned;
  
    if (addr) {
      trcVerbose(&quot;mmap-allocated &quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot; (&quot; UINTX_FORMAT &quot; bytes)&quot;,
<span class="udiff-line-modified-removed">-       addr, addr + bytes, bytes);</span>
<span class="udiff-line-modified-added">+       p2i(addr), p2i(addr + bytes), bytes);</span>
    } else {
      if (requested_addr != NULL) {
<span class="udiff-line-modified-removed">-       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at wish address &quot; PTR_FORMAT &quot;.&quot;, bytes, requested_addr);</span>
<span class="udiff-line-modified-added">+       trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at wish address &quot; PTR_FORMAT &quot;.&quot;, bytes, p2i(requested_addr));</span>
      } else {
        trcVerbose(&quot;failed to mmap-allocate &quot; UINTX_FORMAT &quot; bytes at any address.&quot;, bytes);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2179,11 +2174,11 @@</span>
  static bool release_mmaped_memory(char* addr, size_t size) {
    assert0(is_aligned_to(addr, os::vm_page_size()));
    assert0(is_aligned_to(size, os::vm_page_size()));
  
    trcVerbose(&quot;release_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="udiff-line-modified-removed">-     addr, addr + size - 1);</span>
<span class="udiff-line-modified-added">+     p2i(addr), p2i(addr + size - 1));</span>
    bool rc = false;
  
    if (::munmap(addr, size) != 0) {
      trcVerbose(&quot;failed (%d)\n&quot;, errno);
      rc = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2199,11 +2194,11 @@</span>
  
    assert0(is_aligned_to(addr, os::vm_page_size()));
    assert0(is_aligned_to(size, os::vm_page_size()));
  
    trcVerbose(&quot;uncommit_mmaped_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;,
<span class="udiff-line-modified-removed">-     addr, addr + size - 1);</span>
<span class="udiff-line-modified-added">+     p2i(addr), p2i(addr + size - 1));</span>
    bool rc = false;
  
    // Uncommit mmap memory with msync MS_INVALIDATE.
    if (::msync(addr, size, MS_INVALIDATE) != 0) {
      trcVerbose(&quot;failed (%d)\n&quot;, errno);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2230,11 +2225,11 @@</span>
  
  #ifdef PRODUCT
  static void warn_fail_commit_memory(char* addr, size_t size, bool exec,
                                      int err) {
    warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
<span class="udiff-line-modified-removed">-           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, addr, size, exec,</span>
<span class="udiff-line-modified-added">+           &quot;, %d) failed; error=&#39;%s&#39; (errno=%d)&quot;, p2i(addr), size, exec,</span>
            os::errno_name(err), err);
  }
  #endif
  
  void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2258,11 +2253,11 @@</span>
  
    vmembk_t* const vmi = vmembk_find(addr);
    guarantee0(vmi);
    vmi-&gt;assert_is_valid_subrange(addr, size);
  
<span class="udiff-line-modified-removed">-   trcVerbose(&quot;commit_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;, addr, addr + size - 1);</span>
<span class="udiff-line-modified-added">+   trcVerbose(&quot;commit_memory [&quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot;].&quot;, p2i(addr), p2i(addr + size - 1));</span>
  
    if (UseExplicitCommit) {
      // AIX commits memory on touch. So, touch all pages to be committed.
      for (char* p = addr; p &lt; (addr + size); p += 4*K) {
        *p = &#39;\0&#39;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2345,10 +2340,14 @@</span>
      return 1;
    }
    return 0;
  }
  
<span class="udiff-line-added">+ int os::numa_get_group_id_for_address(const void* address) {</span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool os::get_page_info(char *start, page_info* info) {
    return false;
  }
  
  char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2437,10 +2436,11 @@</span>
    // This means if the memory was allocated using shmget/shmat, protection wont work
    // but mprotect will still return 0:
    //
    // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm
  
<span class="udiff-line-added">+   Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
    bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;
  
    if (!rc) {
      const char* const s_errno = os::errno_name(errno);
      warning(&quot;mprotect(&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot;, 0x%X) failed (%s).&quot;, addr, addr + size, prot, s_errno);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2477,10 +2477,11 @@</span>
            // a stack. It is an OS error.
            //
            // A valid strategy is just to try again. This usually works. :-/
  
            ::usleep(1000);
<span class="udiff-line-added">+           Events::log(NULL, &quot;Protecting memory [&quot; INTPTR_FORMAT &quot;,&quot; INTPTR_FORMAT &quot;] with protection modes %x&quot;, p2i(addr), p2i(addr+size), prot);</span>
            if (::mprotect(addr, size, prot) == 0) {
              const bool read_protected_2 =
                (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &amp;&amp;
                SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;
              rc = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2643,12 +2644,28 @@</span>
    60,             // 10 MaxPriority
  
    60              // 11 CriticalPriority
  };
  
<span class="udiff-line-added">+ static int prio_init() {</span>
<span class="udiff-line-added">+   if (ThreadPriorityPolicy == 1) {</span>
<span class="udiff-line-added">+     if (geteuid() != 0) {</span>
<span class="udiff-line-added">+       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {</span>
<span class="udiff-line-added">+         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \</span>
<span class="udiff-line-added">+                 &quot;e.g., being the root user. If the necessary permission is not &quot; \</span>
<span class="udiff-line-added">+                 &quot;possessed, changes to priority will be silently ignored.&quot;);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (UseCriticalJavaThreadPriority) {</span>
<span class="udiff-line-added">+     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  OSReturn os::set_native_priority(Thread* thread, int newpri) {
<span class="udiff-line-modified-removed">-   if (!UseThreadPriorities) return OS_OK;</span>
<span class="udiff-line-modified-added">+   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;</span>
    pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
    int policy = SCHED_OTHER;
    struct sched_param param;
    param.sched_priority = newpri;
    int ret = pthread_setschedparam(thr, policy, &amp;param);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2659,11 +2676,11 @@</span>
    }
    return (ret == 0) ? OS_OK : OS_ERR;
  }
  
  OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
<span class="udiff-line-modified-removed">-   if (!UseThreadPriorities) {</span>
<span class="udiff-line-modified-added">+   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) {</span>
      *priority_ptr = java_to_os_priority[NormPriority];
      return OS_OK;
    }
    pthread_t thr = thread-&gt;osthread()-&gt;pthread_id();
    int policy = SCHED_OTHER;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2756,11 +2773,11 @@</span>
  
      // attempt to switch the state, we assume we had a SUSPEND_REQUEST
      os::SuspendResume::State state = osthread-&gt;sr.suspended();
      if (state == os::SuspendResume::SR_SUSPENDED) {
        sigset_t suspend_set;  // signals for sigsuspend()
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+       sigemptyset(&amp;suspend_set);</span>
        // get current set of blocked signals and unblock resume signal
        pthread_sigmask(SIG_BLOCK, NULL, &amp;suspend_set);
        sigdelset(&amp;suspend_set, SR_signum);
  
        // wait here until we are resumed
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3042,21 +3059,22 @@</span>
        actp-&gt;sa_handler = SIG_DFL;
      }
  
      // try to honor the signal mask
      sigset_t oset;
<span class="udiff-line-added">+     sigemptyset(&amp;oset);</span>
      pthread_sigmask(SIG_SETMASK, &amp;(actp-&gt;sa_mask), &amp;oset);
  
      // call into the chained handler
      if (siginfo_flag_set) {
        (*sa)(sig, siginfo, context);
      } else {
        (*hand)(sig);
      }
  
      // restore the signal mask
<span class="udiff-line-modified-removed">-     pthread_sigmask(SIG_SETMASK, &amp;oset, 0);</span>
<span class="udiff-line-modified-added">+     pthread_sigmask(SIG_SETMASK, &amp;oset, NULL);</span>
    }
    // Tell jvm&#39;s signal handler the signal is taken care of.
    return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3442,25 +3460,25 @@</span>
      } else {
        // .. and not able to allocate 64k pages dynamically. Here, just
        // fall back to 4K paged mode and use mmap for everything.
        trcVerbose(&quot;4K page mode&quot;);
        Aix::_page_size = 4*K;
<span class="udiff-line-modified-removed">-       FLAG_SET_ERGO(bool, Use64KPages, false);</span>
<span class="udiff-line-modified-added">+       FLAG_SET_ERGO(Use64KPages, false);</span>
      }
    } else {
      // datapsize = 64k. Data segment, thread stacks are 64k paged.
      // This normally means that we can allocate 64k pages dynamically.
      // (There is one special case where this may be false: EXTSHM=on.
      // but we decided to not support that mode).
      assert0(g_multipage_support.can_use_64K_pages);
      Aix::_page_size = 64*K;
      trcVerbose(&quot;64K page mode&quot;);
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(bool, Use64KPages, true);</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(Use64KPages, true);</span>
    }
  
    // For now UseLargePages is just ignored.
<span class="udiff-line-modified-removed">-   FLAG_SET_ERGO(bool, UseLargePages, false);</span>
<span class="udiff-line-modified-added">+   FLAG_SET_ERGO(UseLargePages, false);</span>
    _page_sizes[0] = 0;
  
    // debug trace
    trcVerbose(&quot;os::vm_page_size %s&quot;, describe_pagesize(os::vm_page_size()));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3485,11 +3503,11 @@</span>
    init_random(1234567);
  
    // _main_thread points to the thread that created/loaded the JVM.
    Aix::_main_thread = pthread_self();
  
<span class="udiff-line-modified-removed">-   initial_time_count = os::elapsed_counter();</span>
<span class="udiff-line-modified-added">+   initial_time_count = javaTimeNanos();</span>
  
    os::Posix::init();
  }
  
  // This is called _after_ the global arguments have been parsed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3568,10 +3586,13 @@</span>
      if (atexit(perfMemory_exit_helper) != 0) {
        warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
      }
    }
  
<span class="udiff-line-added">+   // initialize thread priority policy</span>
<span class="udiff-line-added">+   prio_init();</span>
<span class="udiff-line-added">+ </span>
    return JNI_OK;
  }
  
  // Mark the polling page as unreadable
  void os::make_polling_page_unreadable(void) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3605,15 +3626,10 @@</span>
  void os::set_native_thread_name(const char *name) {
    // Not yet implemented.
    return;
  }
  
<span class="udiff-line-removed">- bool os::distribute_processes(uint length, uint* distribution) {</span>
<span class="udiff-line-removed">-   // Not yet implemented.</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool os::bind_to_processor(uint processor_id) {
    // Not yet implemented.
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3702,14 +3718,22 @@</span>
  
    if (strlen(path) &gt; MAX_PATH - 1) {
      errno = ENAMETOOLONG;
      return -1;
    }
<span class="udiff-line-modified-removed">-   int fd;</span>
<span class="udiff-line-modified-added">+   // AIX 7.X now supports O_CLOEXEC too, like modern Linux; but we have to be careful, see</span>
<span class="udiff-line-added">+   // IV90804: OPENING A FILE IN AFS WITH O_CLOEXEC FAILS WITH AN EINVAL ERROR APPLIES TO AIX 7100-04 17/04/14 PTF PECHANGE</span>
<span class="udiff-line-added">+   int oflag_with_o_cloexec = oflag | O_CLOEXEC;</span>
  
<span class="udiff-line-modified-removed">-   fd = ::open64(path, oflag, mode);</span>
<span class="udiff-line-modified-removed">-   if (fd == -1) return -1;</span>
<span class="udiff-line-modified-added">+   int fd = ::open64(path, oflag_with_o_cloexec, mode);</span>
<span class="udiff-line-modified-added">+   if (fd == -1) {</span>
<span class="udiff-line-added">+     // we might fail in the open call when O_CLOEXEC is set, so try again without (see IV90804)</span>
<span class="udiff-line-added">+     fd = ::open64(path, oflag, mode);</span>
<span class="udiff-line-added">+     if (fd == -1) {</span>
<span class="udiff-line-added">+       return -1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
    // If the open succeeded, the file might still be a directory.
    {
      struct stat64 buf64;
      int ret = ::fstat64(fd, &amp;buf64);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3737,25 +3761,29 @@</span>
    // - cause end-of-file to fail to be detected on some file
    //   descriptors, resulting in mysterious hangs, or
    //
    // - might cause an fopen in the subprocess to fail on a system
    //   suffering from bug 1085341.
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // (Yes, the default setting of the close-on-exec flag is a Unix</span>
<span class="udiff-line-modified-removed">-   // design flaw.)</span>
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // See:</span>
<span class="udiff-line-modified-removed">-   // 1085341: 32-bit stdio routines should support file descriptors &gt;255</span>
<span class="udiff-line-modified-removed">-   // 4843136: (process) pipe file descriptor from Runtime.exec not being closed</span>
<span class="udiff-line-modified-removed">-   // 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9</span>
<span class="udiff-line-modified-removed">- #ifdef FD_CLOEXEC</span>
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Validate that the use of the O_CLOEXEC flag on open above worked.</span>
<span class="udiff-line-modified-added">+   static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;</span>
<span class="udiff-line-modified-added">+   if (O_CLOEXEC_is_known_to_work == 0) {</span>
<span class="udiff-line-modified-added">+     int flags = ::fcntl(fd, F_GETFD);</span>
<span class="udiff-line-modified-added">+     if (flags != -1) {</span>
<span class="udiff-line-modified-added">+       if ((flags &amp; FD_CLOEXEC) != 0) {</span>
<span class="udiff-line-modified-added">+         O_CLOEXEC_is_known_to_work = 1;</span>
<span class="udiff-line-modified-added">+       } else { // it does not work</span>
<span class="udiff-line-modified-added">+         ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);</span>
<span class="udiff-line-added">+         O_CLOEXEC_is_known_to_work = -1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (O_CLOEXEC_is_known_to_work == -1) {</span>
      int flags = ::fcntl(fd, F_GETFD);
<span class="udiff-line-modified-removed">-     if (flags != -1)</span>
<span class="udiff-line-modified-added">+     if (flags != -1) {</span>
        ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-removed">- #endif</span>
  
    return fd;
  }
  
  // create binary file, rewriting existing file if required
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4009,11 +4037,11 @@</span>
  }
  
  void os::pause() {
    char filename[MAX_PATH];
    if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
<span class="udiff-line-modified-removed">-     jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);</span>
<span class="udiff-line-modified-added">+     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);</span>
    } else {
      jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
    }
  
    int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4056,34 +4084,34 @@</span>
      assert(major &gt; 0, &quot;invalid OS version&quot;);
      const int minor = atoi(uts.release);
      assert(minor &gt; 0, &quot;invalid OS release&quot;);
      _os_version = (major &lt;&lt; 24) | (minor &lt;&lt; 16);
      char ver_str[20] = {0};
<span class="udiff-line-modified-removed">-     char *name_str = &quot;unknown OS&quot;;</span>
<span class="udiff-line-modified-added">+     const char* name_str = &quot;unknown OS&quot;;</span>
      if (strcmp(uts.sysname, &quot;OS400&quot;) == 0) {
        // We run on AS/400 PASE. We do not support versions older than V5R4M0.
        _on_pase = 1;
        if (os_version_short() &lt; 0x0504) {
          trcVerbose(&quot;OS/400 releases older than V5R4M0 not supported.&quot;);
          assert(false, &quot;OS/400 release too old.&quot;);
        }
        name_str = &quot;OS/400 (pase)&quot;;
        jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u&quot;, major, minor);
      } else if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
<span class="udiff-line-modified-removed">-       // We run on AIX. We do not support versions older than AIX 5.3.</span>
<span class="udiff-line-modified-added">+       // We run on AIX. We do not support versions older than AIX 7.1.</span>
        _on_pase = 0;
        // Determine detailed AIX version: Version, Release, Modification, Fix Level.
        odmWrapper::determine_os_kernel_version(&amp;_os_version);
<span class="udiff-line-modified-removed">-       if (os_version_short() &lt; 0x0503) {</span>
<span class="udiff-line-modified-removed">-         trcVerbose(&quot;AIX release older than AIX 5.3 not supported.&quot;);</span>
<span class="udiff-line-modified-added">+       if (os_version_short() &lt; 0x0701) {</span>
<span class="udiff-line-modified-added">+         trcVerbose(&quot;AIX releases older than AIX 7.1 are not supported.&quot;);</span>
          assert(false, &quot;AIX release too old.&quot;);
        }
        name_str = &quot;AIX&quot;;
        jio_snprintf(ver_str, sizeof(ver_str), &quot;%u.%u.%u.%u&quot;,
                     major, minor, (_os_version &gt;&gt; 8) &amp; 0xFF, _os_version &amp; 0xFF);
      } else {
<span class="udiff-line-modified-removed">-       assert(false, name_str);</span>
<span class="udiff-line-modified-added">+       assert(false, &quot;%s&quot;, name_str);</span>
      }
      trcVerbose(&quot;We run on %s %s&quot;, name_str, ver_str);
    }
  
    guarantee(_on_pase != -1 &amp;&amp; _os_version, &quot;Could not determine AIX/OS400 release&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4215,11 +4243,11 @@</span>
  // Run the specified command in a separate process. Return its exit value,
  // or -1 on failure (e.g. can&#39;t fork a new process).
  // Unlike system(), this function can be called from signal handler. It
  // doesn&#39;t block SIGINT et al.
  int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
<span class="udiff-line-modified-removed">-   char * argv[4] = {&quot;sh&quot;, &quot;-c&quot;, cmd, NULL};</span>
<span class="udiff-line-modified-added">+   char* argv[4] = { (char*)&quot;sh&quot;, (char*)&quot;-c&quot;, cmd, NULL};</span>
  
    pid_t pid = fork();
  
    if (pid &lt; 0) {
      // fork failed
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4325,5 +4353,9 @@</span>
  int os::compare_file_modified_times(const char* file1, const char* file2) {
    time_t t1 = get_mtime(file1);
    time_t t2 = get_mtime(file2);
    return t1 - t2;
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool os::supports_map_sync() {</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="loadlib_aix.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_aix.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
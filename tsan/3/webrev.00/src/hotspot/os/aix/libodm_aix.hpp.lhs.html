<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/libodm_aix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">  3  * Copyright (c) 2015, 2015 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 // Encapsulates the libodm library and provides more convenient interfaces.
 27 
 28 #ifndef OS_AIX_LIBODM_AIX_HPP
 29 #define OS_AIX_LIBODM_AIX_HPP
 30 
 31 #include &lt;odmi.h&gt;
 32 
 33 
 34 // The purpose of this code is to dynamically load the libodm library
 35 // instead of statically linking against it. The library is AIX-specific.
 36 // It only exists on AIX, not on PASE. In order to share binaries
 37 // between AIX and PASE, we can&#39;t directly link against it.
 38 
 39 typedef int          (*fun_odm_initialize )(void);
 40 typedef char*        (*fun_odm_set_path   )(char*);
 41 typedef CLASS_SYMBOL (*fun_odm_mount_class)(char*);
 42 typedef void*        (*fun_odm_get_obj    )(CLASS_SYMBOL, char*, void*, int);
 43 typedef int          (*fun_odm_terminate  )(void);
 44 
 45 class dynamicOdm {
 46   void *_libhandle;
 47  protected:
 48   fun_odm_initialize  _odm_initialize;
 49   fun_odm_set_path    _odm_set_path;
 50   fun_odm_mount_class _odm_mount_class;
 51   fun_odm_get_obj     _odm_get_obj;
 52   fun_odm_terminate   _odm_terminate;
 53  public:
 54   dynamicOdm();
 55   ~dynamicOdm();
 56   bool odm_loaded() {return _libhandle != NULL; }
 57 };
 58 
 59 
 60 // We provide a more convenient interface for odm access and
 61 // especially to determine the exact AIX kernel version.
 62 
 63 class odmWrapper : private dynamicOdm {
 64   CLASS_SYMBOL _odm_class;
 65   char *_data;
 66   bool _initialized;
 67   void clean_data();
 68 
 69  public:
 70   // Make sure everything gets initialized and cleaned up properly.
<a name="2" id="anc2"></a><span class="line-modified"> 71   explicit odmWrapper(char* odm_class_name, char* odm_path = NULL) : _odm_class((CLASS_SYMBOL)-1),</span>
 72                                                                      _data(NULL), _initialized(false) {
 73     if (!odm_loaded()) { return; }
 74     _initialized = ((*_odm_initialize)() != -1);
 75     if (_initialized) {
<a name="3" id="anc3"></a><span class="line-modified"> 76       if (odm_path) { (*_odm_set_path)(odm_path); }</span>
<span class="line-modified"> 77       _odm_class = (*_odm_mount_class)(odm_class_name);</span>


 78     }
 79   }
 80   ~odmWrapper() {
 81     if (_initialized) { (*_odm_terminate)(); clean_data(); }
 82   }
 83 
 84   CLASS_SYMBOL odm_class() { return _odm_class; }
 85   bool has_class() { return odm_class() != (CLASS_SYMBOL)-1; }
<a name="4" id="anc4"></a><span class="line-modified"> 86   int class_offset(char *field, bool is_aix_5);</span>
 87   char* data() { return _data; }
 88 
<a name="5" id="anc5"></a><span class="line-modified"> 89   char* retrieve_obj(char* name = NULL) {</span>
 90     clean_data();
<a name="6" id="anc6"></a><span class="line-modified"> 91     char *cnp = (char*)(void*)(*_odm_get_obj)(odm_class(), name, NULL, (name == NULL) ? ODM_NEXT : ODM_FIRST);</span>
 92     if (cnp != (char*)-1) { _data = cnp; }
 93     return data();
 94   }
 95 
 96   int read_short(int offs) {
 97     short *addr = (short*)(data() + offs);
 98     return *addr;
 99   }
100 
101   // Determine the exact AIX kernel version as 4 byte value.
102   // The high order 2 bytes must be initialized already. They can be determined by uname.
103   static void determine_os_kernel_version(uint32_t* p_ver);
104 };
105 
106 #endif // OS_AIX_LIBODM_AIX_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/os_perf_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;os_aix.inline.hpp&quot;
  29 #include &quot;runtime/os.hpp&quot;
  30 #include &quot;runtime/os_perf.hpp&quot;
<a name="2" id="anc2"></a>
  31 
  32 #include CPU_HEADER(vm_version_ext)
  33 
  34 #include &lt;stdio.h&gt;
  35 #include &lt;stdarg.h&gt;
  36 #include &lt;unistd.h&gt;
  37 #include &lt;errno.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;sys/resource.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #include &lt;dirent.h&gt;
  43 #include &lt;stdlib.h&gt;
  44 #include &lt;dlfcn.h&gt;
  45 #include &lt;pthread.h&gt;
  46 #include &lt;limits.h&gt;
  47 
  48 /**
  49    /proc/[number]/stat
  50               Status information about the process.  This is used by ps(1).  It is defined in /usr/src/linux/fs/proc/array.c.
  51 
  52               The fields, in order, with their proper scanf(3) format specifiers, are:
  53 
  54               1. pid %d The process id.
  55 
  56               2. comm %s
  57                      The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.
  58 
  59               3. state %c
  60                      One  character  from  the  string &quot;RSDZTW&quot; where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk
  61                      sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.
  62 
  63               4. ppid %d
  64                      The PID of the parent.
  65 
  66               5. pgrp %d
  67                      The process group ID of the process.
  68 
  69               6. session %d
  70                      The session ID of the process.
  71 
  72               7. tty_nr %d
  73                      The tty the process uses.
  74 
  75               8. tpgid %d
  76                      The process group ID of the process which currently owns the tty that the process is connected to.
  77 
  78               9. flags %lu
  79                      The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.
  80 
  81               10. minflt %lu
  82                      The number of minor faults the process has made which have not required loading a memory page from disk.
  83 
  84               11. cminflt %lu
  85                      The number of minor faults that the process&#39;s waited-for children have made.
  86 
  87               12. majflt %lu
  88                      The number of major faults the process has made which have required loading a memory page from disk.
  89 
  90               13. cmajflt %lu
  91                      The number of major faults that the process&#39;s waited-for children have made.
  92 
  93               14. utime %lu
  94                      The number of jiffies that this process has been scheduled in user mode.
  95 
  96               15. stime %lu
  97                      The number of jiffies that this process has been scheduled in kernel mode.
  98 
  99               16. cutime %ld
 100                      The number of jiffies that this process&#39;s waited-for children have been scheduled in user mode. (See also times(2).)
 101 
 102               17. cstime %ld
 103                      The number of jiffies that this process&#39; waited-for children have been scheduled in kernel mode.
 104 
 105               18. priority %ld
 106                      The standard nice value, plus fifteen.  The value is never negative in the kernel.
 107 
 108               19. nice %ld
 109                      The nice value ranges from 19 (nicest) to -19 (not nice to others).
 110 
 111               20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.
 112 
 113               21. itrealvalue %ld
 114                      The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.
 115 
 116               22. starttime %lu
 117                      The time in jiffies the process started after system boot.
 118 
 119               23. vsize %lu
 120                      Virtual memory size in bytes.
 121 
 122               24. rss %ld
 123                      Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count
 124                      towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.
 125 
 126               25. rlim %lu
 127                      Current limit in bytes on the rss of the process (usually 4294967295 on i386).
 128 
 129               26. startcode %lu
 130                      The address above which program text can run.
 131 
 132               27. endcode %lu
 133                      The address below which program text can run.
 134 
 135               28. startstack %lu
 136                      The address of the start of the stack.
 137 
 138               29. kstkesp %lu
 139                      The current value of esp (stack pointer), as found in the kernel stack page for the process.
 140 
 141               30. kstkeip %lu
 142                      The current EIP (instruction pointer).
 143 
 144               31. signal %lu
 145                      The bitmap of pending signals (usually 0).
 146 
 147               32. blocked %lu
 148                      The bitmap of blocked signals (usually 0, 2 for shells).
 149 
 150               33. sigignore %lu
 151                      The bitmap of ignored signals.
 152 
 153               34. sigcatch %lu
 154                      The bitmap of catched signals.
 155 
 156               35. wchan %lu
 157                      This  is the &quot;channel&quot; in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need
 158                      a textual name.  (If you have an up-to-date /etc/psdatabase, then try ps -l to see the WCHAN field in action.)
 159 
 160               36. nswap %lu
 161                      Number of pages swapped - not maintained.
 162 
 163               37. cnswap %lu
 164                      Cumulative nswap for child processes.
 165 
 166               38. exit_signal %d
 167                      Signal to be sent to parent when we die.
 168 
 169               39. processor %d
 170                      CPU number last executed on.
 171 
 172 
 173 
 174  ///// SSCANF FORMAT STRING. Copy and use.
 175 
 176 field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39
 177 format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d
 178 
 179 
 180 */
 181 
 182 /**
 183  * For platforms that have them, when declaring
 184  * a printf-style function,
 185  *   formatSpec is the parameter number (starting at 1)
 186  *       that is the format argument (&quot;%d pid %s&quot;)
 187  *   params is the parameter number where the actual args to
 188  *       the format starts. If the args are in a va_list, this
 189  *       should be 0.
 190  */
 191 #ifndef PRINTF_ARGS
 192 #  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)
 193 #endif
 194 
 195 #ifndef SCANF_ARGS
 196 #  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)
 197 #endif
 198 
 199 #ifndef _PRINTFMT_
 200 #  define _PRINTFMT_
 201 #endif
 202 
 203 #ifndef _SCANFMT_
 204 #  define _SCANFMT_
 205 #endif
 206 
 207 
 208 struct CPUPerfTicks {
 209   uint64_t  used;
 210   uint64_t  usedKernel;
 211   uint64_t  total;
 212 };
 213 
 214 typedef enum {
 215   CPU_LOAD_VM_ONLY,
 216   CPU_LOAD_GLOBAL,
 217 } CpuLoadTarget;
 218 
 219 enum {
 220   UNDETECTED,
 221   UNDETECTABLE,
 222   LINUX26_NPTL,
 223   BAREMETAL
 224 };
 225 
 226 struct CPUPerfCounters {
 227   int   nProcs;
 228   CPUPerfTicks jvmTicks;
 229   CPUPerfTicks* cpus;
 230 };
 231 
 232 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);
 233 
 234 /** reads /proc/&lt;pid&gt;/stat data, with some checks and some skips.
 235  *  Ensure that &#39;fmt&#39; does _NOT_ contain the first two &quot;%d %s&quot;
 236  */
 237 static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {
 238   FILE*f;
 239   int n;
 240   char buf[2048];
 241 
 242   if ((f = fopen(procfile, &quot;r&quot;)) == NULL) {
 243     return -1;
 244   }
 245 
 246   if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {
 247     char *tmp;
 248 
 249     buf[n-1] = &#39;\0&#39;;
 250     /** skip through pid and exec name. */
 251     if ((tmp = strrchr(buf, &#39;)&#39;)) != NULL) {
 252       // skip the &#39;)&#39; and the following space
 253       // but check that buffer is long enough
 254       tmp += 2;
 255       if (tmp &lt; buf + n) {
 256         n = vsscanf(tmp, fmt, args);
 257       }
 258     }
 259   }
 260 
 261   fclose(f);
 262 
 263   return n;
 264 }
 265 
 266 static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {
 267   int   n;
 268   va_list args;
 269 
 270   va_start(args, fmt);
 271   n = vread_statdata(procfile, fmt, args);
 272   va_end(args);
 273   return n;
 274 }
 275 
<a name="3" id="anc3"></a><span class="line-removed"> 276 static FILE* open_statfile(void) {</span>
<span class="line-removed"> 277   FILE *f;</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279   if ((f = fopen(&quot;/proc/stat&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed"> 280     static int haveWarned = 0;</span>
<span class="line-removed"> 281     if (!haveWarned) {</span>
<span class="line-removed"> 282       haveWarned = 1;</span>
<span class="line-removed"> 283     }</span>
<span class="line-removed"> 284   }</span>
<span class="line-removed"> 285   return f;</span>
<span class="line-removed"> 286 }</span>
<span class="line-removed"> 287 </span>
<span class="line-removed"> 288 static void</span>
<span class="line-removed"> 289 next_line(FILE *f) {</span>
<span class="line-removed"> 290   int c;</span>
<span class="line-removed"> 291   do {</span>
<span class="line-removed"> 292     c = fgetc(f);</span>
<span class="line-removed"> 293   } while (c != &#39;\n&#39; &amp;&amp; c != EOF);</span>
<span class="line-removed"> 294 }</span>
<span class="line-removed"> 295 </span>
 296 /**
<a name="4" id="anc4"></a><span class="line-modified"> 297  * Return the total number of ticks since the system was booted.</span>
<span class="line-modified"> 298  * If the usedTicks parameter is not NULL, it will be filled with</span>
<span class="line-removed"> 299  * the number of ticks spent on actual processes (user, system or</span>
<span class="line-removed"> 300  * nice processes) since system boot. Note that this is the total number</span>
<span class="line-removed"> 301  * of &quot;executed&quot; ticks on _all_ CPU:s, that is on a n-way system it is</span>
<span class="line-removed"> 302  * n times the number of ticks that has passed in clock time.</span>
<span class="line-removed"> 303  *</span>
<span class="line-removed"> 304  * Returns a negative value if the reading of the ticks failed.</span>
 305  */
 306 static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {
<a name="5" id="anc5"></a><span class="line-modified"> 307   FILE*         fh;</span>
<span class="line-removed"> 308   uint64_t      userTicks, niceTicks, systemTicks, idleTicks;</span>
<span class="line-removed"> 309   uint64_t      iowTicks = 0, irqTicks = 0, sirqTicks= 0;</span>
<span class="line-removed"> 310   int           logical_cpu = -1;</span>
<span class="line-removed"> 311   const int     expected_assign_count = (-1 == which_logical_cpu) ? 4 : 5;</span>
<span class="line-removed"> 312   int           n;</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314   if ((fh = open_statfile()) == NULL) {</span>
<span class="line-removed"> 315     return OS_ERR;</span>
<span class="line-removed"> 316   }</span>
<span class="line-removed"> 317   if (-1 == which_logical_cpu) {</span>
<span class="line-removed"> 318     n = fscanf(fh, &quot;cpu &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 319             UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 320             &amp;userTicks, &amp;niceTicks, &amp;systemTicks, &amp;idleTicks,</span>
<span class="line-removed"> 321             &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 322   } else {</span>
<span class="line-removed"> 323     // Move to next line</span>
<span class="line-removed"> 324     next_line(fh);</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     // find the line for requested cpu faster to just iterate linefeeds?</span>
<span class="line-removed"> 327     for (int i = 0; i &lt; which_logical_cpu; i++) {</span>
<span class="line-removed"> 328       next_line(fh);</span>
<span class="line-removed"> 329     }</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331     n = fscanf(fh, &quot;cpu%u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 332                UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,</span>
<span class="line-removed"> 333                &amp;logical_cpu, &amp;userTicks, &amp;niceTicks,</span>
<span class="line-removed"> 334                &amp;systemTicks, &amp;idleTicks, &amp;iowTicks, &amp;irqTicks, &amp;sirqTicks);</span>
<span class="line-removed"> 335   }</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337   fclose(fh);</span>
<span class="line-removed"> 338   if (n &lt; expected_assign_count || logical_cpu != which_logical_cpu) {</span>
<span class="line-removed"> 339 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 340     vm_fprintf(stderr, &quot;[stat] read failed&quot;);</span>
<span class="line-removed"> 341 #endif</span>
<span class="line-removed"> 342     return OS_ERR;</span>
<span class="line-removed"> 343   }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345 #ifdef DEBUG_LINUX_PROC_STAT</span>
<span class="line-removed"> 346   vm_fprintf(stderr, &quot;[stat] read &quot;</span>
<span class="line-removed"> 347           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot;</span>
<span class="line-removed"> 348           UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT &quot; \n&quot;,</span>
<span class="line-removed"> 349           userTicks, niceTicks, systemTicks, idleTicks,</span>
<span class="line-removed"> 350           iowTicks, irqTicks, sirqTicks);</span>
<span class="line-removed"> 351 #endif</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353   pticks-&gt;used       = userTicks + niceTicks;</span>
<span class="line-removed"> 354   pticks-&gt;usedKernel = systemTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 355   pticks-&gt;total      = userTicks + niceTicks + systemTicks + idleTicks +</span>
<span class="line-removed"> 356                        iowTicks + irqTicks + sirqTicks;</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   return OS_OK;</span>
<span class="line-removed"> 359 }</span>
<span class="line-removed"> 360 </span>
<span class="line-removed"> 361 </span>
<span class="line-removed"> 362 static int get_systemtype(void) {</span>
<span class="line-removed"> 363   static int procEntriesType = UNDETECTED;</span>
<span class="line-removed"> 364   DIR *taskDir;</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366   if (procEntriesType != UNDETECTED) {</span>
<span class="line-removed"> 367     return procEntriesType;</span>
<span class="line-removed"> 368   }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370   // Check whether we have a task subdirectory</span>
<span class="line-removed"> 371   if ((taskDir = opendir(&quot;/proc/self/task&quot;)) == NULL) {</span>
<span class="line-removed"> 372     procEntriesType = UNDETECTABLE;</span>
<span class="line-removed"> 373   } else {</span>
<span class="line-removed"> 374     // The task subdirectory exists; we&#39;re on a Linux &gt;= 2.6 system</span>
<span class="line-removed"> 375     closedir(taskDir);</span>
<span class="line-removed"> 376     procEntriesType = LINUX26_NPTL;</span>
<span class="line-removed"> 377   }</span>
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379   return procEntriesType;</span>
 380 }
 381 
 382 /** read user and system ticks from a named procfile, assumed to be in &#39;stat&#39; format then. */
 383 static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {
 384   return read_statdata(procfile, &quot;%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u &quot; UINT64_FORMAT &quot; &quot; UINT64_FORMAT,
 385     userTicks, systemTicks);
 386 }
 387 
 388 /**
 389  * Return the number of ticks spent in any of the processes belonging
 390  * to the JVM on any CPU.
 391  */
 392 static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {
<a name="6" id="anc6"></a><span class="line-modified"> 393   uint64_t userTicks;</span>
<span class="line-removed"> 394   uint64_t systemTicks;</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   if (get_systemtype() != LINUX26_NPTL) {</span>
<span class="line-removed"> 397     return OS_ERR;</span>
<span class="line-removed"> 398   }</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400   if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) != 2) {</span>
<span class="line-removed"> 401     return OS_ERR;</span>
<span class="line-removed"> 402   }</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404   // get the total</span>
<span class="line-removed"> 405   if (get_total_ticks(-1, pticks) != OS_OK) {</span>
<span class="line-removed"> 406     return OS_ERR;</span>
<span class="line-removed"> 407   }</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409   pticks-&gt;used       = userTicks;</span>
<span class="line-removed"> 410   pticks-&gt;usedKernel = systemTicks;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412   return OS_OK;</span>
 413 }
 414 
 415 /**
 416  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
 417  * available time for user or system processes, 0.0 means the CPU uses all time
 418  * being idle.
 419  *
 420  * Returns a negative value if there is a problem in determining the CPU load.
 421  */
 422 static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {
 423   uint64_t udiff, kdiff, tdiff;
 424   CPUPerfTicks* pticks;
 425   CPUPerfTicks  tmp;
 426   double user_load;
 427 
 428   *pkernelLoad = 0.0;
 429 
 430   if (target == CPU_LOAD_VM_ONLY) {
 431     pticks = &amp;counters-&gt;jvmTicks;
 432   } else if (-1 == which_logical_cpu) {
 433     pticks = &amp;counters-&gt;cpus[counters-&gt;nProcs];
 434   } else {
 435     pticks = &amp;counters-&gt;cpus[which_logical_cpu];
 436   }
 437 
 438   tmp = *pticks;
 439 
 440   if (target == CPU_LOAD_VM_ONLY) {
 441     if (get_jvm_ticks(pticks) != OS_OK) {
 442       return -1.0;
 443     }
 444   } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {
 445     return -1.0;
 446   }
 447 
 448   // seems like we sometimes end up with less kernel ticks when
 449   // reading /proc/self/stat a second time, timing issue between cpus?
 450   if (pticks-&gt;usedKernel &lt; tmp.usedKernel) {
 451     kdiff = 0;
 452   } else {
 453     kdiff = pticks-&gt;usedKernel - tmp.usedKernel;
 454   }
 455   tdiff = pticks-&gt;total - tmp.total;
 456   udiff = pticks-&gt;used - tmp.used;
 457 
 458   if (tdiff == 0) {
 459     return 0.0;
 460   } else if (tdiff &lt; (udiff + kdiff)) {
 461     tdiff = udiff + kdiff;
 462   }
 463   *pkernelLoad = (kdiff / (double)tdiff);
 464   // BUG9044876, normalize return values to sane values
 465   *pkernelLoad = MAX2&lt;double&gt;(*pkernelLoad, 0.0);
 466   *pkernelLoad = MIN2&lt;double&gt;(*pkernelLoad, 1.0);
 467 
 468   user_load = (udiff / (double)tdiff);
 469   user_load = MAX2&lt;double&gt;(user_load, 0.0);
 470   user_load = MIN2&lt;double&gt;(user_load, 1.0);
 471 
 472   return user_load;
 473 }
 474 
 475 static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {
<a name="7" id="anc7"></a><span class="line-modified"> 476   FILE *f;</span>
<span class="line-removed"> 477   va_list args;</span>
<span class="line-removed"> 478 </span>
<span class="line-removed"> 479   va_start(args, fmt);</span>
<span class="line-removed"> 480 </span>
<span class="line-removed"> 481   if ((f = open_statfile()) == NULL) {</span>
<span class="line-removed"> 482     va_end(args);</span>
<span class="line-removed"> 483     return OS_ERR;</span>
<span class="line-removed"> 484   }</span>
<span class="line-removed"> 485   for (;;) {</span>
<span class="line-removed"> 486     char line[80];</span>
<span class="line-removed"> 487     if (fgets(line, sizeof(line), f) != NULL) {</span>
<span class="line-removed"> 488       if (vsscanf(line, fmt, args) == 1) {</span>
<span class="line-removed"> 489         fclose(f);</span>
<span class="line-removed"> 490         va_end(args);</span>
<span class="line-removed"> 491         return OS_OK;</span>
<span class="line-removed"> 492       }</span>
<span class="line-removed"> 493     } else {</span>
<span class="line-removed"> 494         fclose(f);</span>
<span class="line-removed"> 495         va_end(args);</span>
<span class="line-removed"> 496         return OS_ERR;</span>
<span class="line-removed"> 497     }</span>
<span class="line-removed"> 498   }</span>
 499 }
 500 
 501 static int get_noof_context_switches(uint64_t* switches) {
 502   return parse_stat(&quot;ctxt &quot; UINT64_FORMAT &quot;\n&quot;, switches);
 503 }
 504 
 505 /** returns boot time in _seconds_ since epoch */
 506 static int get_boot_time(uint64_t* time) {
 507   return parse_stat(&quot;btime &quot; UINT64_FORMAT &quot;\n&quot;, time);
 508 }
 509 
 510 static int perf_context_switch_rate(double* rate) {
 511   static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;
<a name="8" id="anc8"></a><span class="line-modified"> 512   static uint64_t      lastTime;</span>

 513   static uint64_t      lastSwitches;
 514   static double        lastRate;
 515 
<a name="9" id="anc9"></a><span class="line-modified"> 516   uint64_t lt = 0;</span>
 517   int res = 0;
 518 
<a name="10" id="anc10"></a><span class="line-modified"> 519   if (lastTime == 0) {</span>

 520     uint64_t tmp;
 521     if (get_boot_time(&amp;tmp) &lt; 0) {
 522       return OS_ERR;
 523     }
<a name="11" id="anc11"></a><span class="line-modified"> 524     lt = tmp * 1000;</span>
 525   }
 526 
 527   res = OS_OK;
 528 
 529   pthread_mutex_lock(&amp;contextSwitchLock);
 530   {
 531 
 532     uint64_t sw;
 533     s8 t, d;
 534 
<a name="12" id="anc12"></a><span class="line-modified"> 535     if (lastTime == 0) {</span>
<span class="line-modified"> 536       lastTime = lt;</span>










 537     }
 538 
<a name="13" id="anc13"></a><span class="line-removed"> 539     t = os::javaTimeMillis();</span>
<span class="line-removed"> 540     d = t - lastTime;</span>
<span class="line-removed"> 541 </span>
 542     if (d == 0) {
 543       *rate = lastRate;
<a name="14" id="anc14"></a><span class="line-modified"> 544     } else if (!get_noof_context_switches(&amp;sw)) {</span>
 545       *rate      = ( (double)(sw - lastSwitches) / d ) * 1000;
 546       lastRate     = *rate;
 547       lastSwitches = sw;
<a name="15" id="anc15"></a><span class="line-modified"> 548       lastTime     = t;</span>


 549     } else {
 550       *rate = 0;
 551       res   = OS_ERR;
 552     }
 553     if (*rate &lt;= 0) {
 554       *rate = 0;
 555       lastRate = 0;
 556     }
<a name="16" id="anc16"></a>



 557   }
 558   pthread_mutex_unlock(&amp;contextSwitchLock);
 559 
 560   return res;
 561 }
 562 
 563 class CPUPerformanceInterface::CPUPerformance : public CHeapObj&lt;mtInternal&gt; {
 564   friend class CPUPerformanceInterface;
 565  private:
 566   CPUPerfCounters _counters;
 567 
 568   int cpu_load(int which_logical_cpu, double* cpu_load);
 569   int context_switch_rate(double* rate);
 570   int cpu_load_total_process(double* cpu_load);
 571   int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);
 572 
 573  public:
 574   CPUPerformance();
 575   bool initialize();
 576   ~CPUPerformance();
 577 };
 578 
 579 CPUPerformanceInterface::CPUPerformance::CPUPerformance() {
 580   _counters.nProcs = os::active_processor_count();
 581   _counters.cpus = NULL;
 582 }
 583 
 584 bool CPUPerformanceInterface::CPUPerformance::initialize() {
<a name="17" id="anc17"></a><span class="line-modified"> 585   size_t tick_array_size = (_counters.nProcs +1) * sizeof(CPUPerfTicks);</span>
<span class="line-modified"> 586   _counters.cpus = (CPUPerfTicks*)NEW_C_HEAP_ARRAY(char, tick_array_size, mtInternal);</span>
<span class="line-modified"> 587   if (NULL == _counters.cpus) {</span>
<span class="line-removed"> 588     return false;</span>
<span class="line-removed"> 589   }</span>
<span class="line-removed"> 590   memset(_counters.cpus, 0, tick_array_size);</span>
 591 
 592   // For the CPU load total
 593   get_total_ticks(-1, &amp;_counters.cpus[_counters.nProcs]);
 594 
 595   // For each CPU
 596   for (int i = 0; i &lt; _counters.nProcs; i++) {
 597     get_total_ticks(i, &amp;_counters.cpus[i]);
 598   }
 599   // For JVM load
 600   get_jvm_ticks(&amp;_counters.jvmTicks);
 601 
 602   // initialize context switch system
 603   // the double is only for init
 604   double init_ctx_switch_rate;
 605   perf_context_switch_rate(&amp;init_ctx_switch_rate);
 606 
 607   return true;
 608 }
 609 
 610 CPUPerformanceInterface::CPUPerformance::~CPUPerformance() {
 611   if (_counters.cpus != NULL) {
 612     FREE_C_HEAP_ARRAY(char, _counters.cpus);
 613   }
 614 }
 615 
 616 int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {
 617   double u, s;
 618   u = get_cpu_load(which_logical_cpu, &amp;_counters, &amp;s, CPU_LOAD_GLOBAL);
 619   if (u &lt; 0) {
 620     *cpu_load = 0.0;
 621     return OS_ERR;
 622   }
 623   // Cap total systemload to 1.0
 624   *cpu_load = MIN2&lt;double&gt;((u + s), 1.0);
 625   return OS_OK;
 626 }
 627 
 628 int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {
 629   double u, s;
 630   u = get_cpu_load(-1, &amp;_counters, &amp;s, CPU_LOAD_VM_ONLY);
 631   if (u &lt; 0) {
 632     *cpu_load = 0.0;
 633     return OS_ERR;
 634   }
 635   *cpu_load = u + s;
 636   return OS_OK;
 637 }
 638 
 639 int CPUPerformanceInterface::CPUPerformance::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) {
 640   double u, s, t;
 641 
 642   assert(pjvmUserLoad != NULL, &quot;pjvmUserLoad not inited&quot;);
 643   assert(pjvmKernelLoad != NULL, &quot;pjvmKernelLoad not inited&quot;);
 644   assert(psystemTotalLoad != NULL, &quot;psystemTotalLoad not inited&quot;);
 645 
 646   u = get_cpu_load(-1, &amp;_counters, &amp;s, CPU_LOAD_VM_ONLY);
 647   if (u &lt; 0) {
 648     *pjvmUserLoad = 0.0;
 649     *pjvmKernelLoad = 0.0;
 650     *psystemTotalLoad = 0.0;
 651     return OS_ERR;
 652   }
 653 
 654   cpu_load(-1, &amp;t);
 655   // clamp at user+system and 1.0
 656   if (u + s &gt; t) {
 657     t = MIN2&lt;double&gt;(u + s, 1.0);
 658   }
 659 
 660   *pjvmUserLoad = u;
 661   *pjvmKernelLoad = s;
 662   *psystemTotalLoad = t;
 663 
 664   return OS_OK;
 665 }
 666 
 667 int CPUPerformanceInterface::CPUPerformance::context_switch_rate(double* rate) {
 668   return perf_context_switch_rate(rate);
 669 }
 670 
 671 CPUPerformanceInterface::CPUPerformanceInterface() {
 672   _impl = NULL;
 673 }
 674 
 675 bool CPUPerformanceInterface::initialize() {
 676   _impl = new CPUPerformanceInterface::CPUPerformance();
<a name="18" id="anc18"></a><span class="line-modified"> 677   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 678 }
 679 
 680 CPUPerformanceInterface::~CPUPerformanceInterface() {
 681   if (_impl != NULL) {
 682     delete _impl;
 683   }
 684 }
 685 
 686 int CPUPerformanceInterface::cpu_load(int which_logical_cpu, double* cpu_load) const {
 687   return _impl-&gt;cpu_load(which_logical_cpu, cpu_load);
 688 }
 689 
 690 int CPUPerformanceInterface::cpu_load_total_process(double* cpu_load) const {
 691   return _impl-&gt;cpu_load_total_process(cpu_load);
 692 }
 693 
 694 int CPUPerformanceInterface::cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad) const {
 695   return _impl-&gt;cpu_loads_process(pjvmUserLoad, pjvmKernelLoad, psystemTotalLoad);
 696 }
 697 
 698 int CPUPerformanceInterface::context_switch_rate(double* rate) const {
 699   return _impl-&gt;context_switch_rate(rate);
 700 }
 701 
 702 class SystemProcessInterface::SystemProcesses : public CHeapObj&lt;mtInternal&gt; {
 703   friend class SystemProcessInterface;
 704  private:
 705   class ProcessIterator : public CHeapObj&lt;mtInternal&gt; {
 706     friend class SystemProcessInterface::SystemProcesses;
 707    private:
 708     DIR*           _dir;
 709     struct dirent* _entry;
 710     bool           _valid;
 711     char           _exeName[PATH_MAX];
 712     char           _exePath[PATH_MAX];
 713 
 714     ProcessIterator();
 715     ~ProcessIterator();
 716     bool initialize();
 717 
 718     bool is_valid() const { return _valid; }
 719     bool is_valid_entry(struct dirent* entry) const;
 720     bool is_dir(const char* name) const;
 721     int  fsize(const char* name, uint64_t&amp; size) const;
 722 
 723     char* allocate_string(const char* str) const;
 724     void  get_exe_name();
 725     char* get_exe_path();
 726     char* get_cmdline();
 727 
 728     int current(SystemProcess* process_info);
 729     int next_process();
 730   };
 731 
 732   ProcessIterator* _iterator;
 733   SystemProcesses();
 734   bool initialize();
 735   ~SystemProcesses();
 736 
 737   //information about system processes
 738   int system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const;
 739 };
 740 
 741 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {
 742   struct stat mystat;
 743   int ret_val = 0;
 744 
 745   ret_val = stat(name, &amp;mystat);
 746   if (ret_val &lt; 0) {
 747     return false;
 748   }
 749   ret_val = S_ISDIR(mystat.st_mode);
 750   return ret_val &gt; 0;
 751 }
 752 
 753 int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t&amp; size) const {
 754   assert(name != NULL, &quot;name pointer is NULL!&quot;);
 755   size = 0;
 756   struct stat fbuf;
 757 
 758   if (stat(name, &amp;fbuf) &lt; 0) {
 759     return OS_ERR;
 760   }
 761   size = fbuf.st_size;
 762   return OS_OK;
 763 }
 764 
 765 // if it has a numeric name, is a directory and has a &#39;stat&#39; file in it
 766 bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {
 767   char buffer[PATH_MAX];
 768   uint64_t size = 0;
 769 
 770   if (atoi(entry-&gt;d_name) != 0) {
 771     jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s&quot;, entry-&gt;d_name);
 772     buffer[PATH_MAX - 1] = &#39;\0&#39;;
 773 
 774     if (is_dir(buffer)) {
 775       jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/stat&quot;, entry-&gt;d_name);
 776       buffer[PATH_MAX - 1] = &#39;\0&#39;;
 777       if (fsize(buffer, size) != OS_ERR) {
 778         return true;
 779       }
 780     }
 781   }
 782   return false;
 783 }
 784 
 785 // get exe-name from /proc/&lt;pid&gt;/stat
 786 void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {
 787   FILE* fp;
 788   char  buffer[PATH_MAX];
 789 
 790   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/stat&quot;, _entry-&gt;d_name);
 791   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 792   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 793     if (fgets(buffer, PATH_MAX, fp) != NULL) {
 794       char* start, *end;
 795       // exe-name is between the first pair of ( and )
 796       start = strchr(buffer, &#39;(&#39;);
 797       if (start != NULL &amp;&amp; start[1] != &#39;\0&#39;) {
 798         start++;
 799         end = strrchr(start, &#39;)&#39;);
 800         if (end != NULL) {
 801           size_t len;
 802           len = MIN2&lt;size_t&gt;(end - start, sizeof(_exeName) - 1);
 803           memcpy(_exeName, start, len);
 804           _exeName[len] = &#39;\0&#39;;
 805         }
 806       }
 807     }
 808     fclose(fp);
 809   }
 810 }
 811 
 812 // get command line from /proc/&lt;pid&gt;/cmdline
 813 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {
 814   FILE* fp;
 815   char  buffer[PATH_MAX];
 816   char* cmdline = NULL;
 817 
 818   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/cmdline&quot;, _entry-&gt;d_name);
 819   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 820   if ((fp = fopen(buffer, &quot;r&quot;)) != NULL) {
 821     size_t size = 0;
 822     char   dummy;
 823 
 824     // find out how long the file is (stat always returns 0)
 825     while (fread(&amp;dummy, 1, 1, fp) == 1) {
 826       size++;
 827     }
 828     if (size &gt; 0) {
 829       cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);
<a name="19" id="anc19"></a><span class="line-modified"> 830       if (cmdline != NULL) {</span>
<span class="line-modified"> 831         cmdline[0] = &#39;\0&#39;;</span>
<span class="line-modified"> 832         if (fseek(fp, 0, SEEK_SET) == 0) {</span>
<span class="line-modified"> 833           if (fread(cmdline, 1, size, fp) == size) {</span>
<span class="line-modified"> 834             // the file has the arguments separated by &#39;\0&#39;,</span>
<span class="line-modified"> 835             // so we translate &#39;\0&#39; to &#39; &#39;</span>
<span class="line-modified"> 836             for (size_t i = 0; i &lt; size; i++) {</span>
<span class="line-modified"> 837               if (cmdline[i] == &#39;\0&#39;) {</span>
<span class="line-removed"> 838                 cmdline[i] = &#39; &#39;;</span>
<span class="line-removed"> 839               }</span>
 840             }
<a name="20" id="anc20"></a><span class="line-removed"> 841             cmdline[size] = &#39;\0&#39;;</span>
 842           }
<a name="21" id="anc21"></a>
 843         }
 844       }
 845     }
 846     fclose(fp);
 847   }
 848   return cmdline;
 849 }
 850 
 851 // get full path to exe from /proc/&lt;pid&gt;/exe symlink
 852 char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {
 853   char buffer[PATH_MAX];
 854 
 855   jio_snprintf(buffer, PATH_MAX, &quot;/proc/%s/exe&quot;, _entry-&gt;d_name);
 856   buffer[PATH_MAX - 1] = &#39;\0&#39;;
 857   return realpath(buffer, _exePath);
 858 }
 859 
 860 char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {
 861   if (str != NULL) {
 862     return os::strdup_check_oom(str, mtInternal);
 863   }
 864   return NULL;
 865 }
 866 
 867 int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {
 868   if (!is_valid()) {
 869     return OS_ERR;
 870   }
 871 
 872   process_info-&gt;set_pid(atoi(_entry-&gt;d_name));
 873 
 874   get_exe_name();
 875   process_info-&gt;set_name(allocate_string(_exeName));
 876 
 877   if (get_exe_path() != NULL) {
 878      process_info-&gt;set_path(allocate_string(_exePath));
 879   }
 880 
 881   char* cmdline = NULL;
 882   cmdline = get_cmdline();
 883   if (cmdline != NULL) {
 884     process_info-&gt;set_command_line(allocate_string(cmdline));
 885     FREE_C_HEAP_ARRAY(char, cmdline);
 886   }
 887 
 888   return OS_OK;
 889 }
 890 
 891 int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {
 892   if (!is_valid()) {
 893     return OS_ERR;
 894   }
 895 
 896   do {
 897     _entry = os::readdir(_dir);
 898     if (_entry == NULL) {
 899       // Error or reached end.  Could use errno to distinguish those cases.
 900       _valid = false;
 901       return OS_ERR;
 902     }
 903   } while(!is_valid_entry(_entry));
 904 
 905   _valid = true;
 906   return OS_OK;
 907 }
 908 
 909 SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {
 910   _dir = NULL;
 911   _entry = NULL;
 912   _valid = false;
 913 }
 914 
 915 bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {
 916   // Not yet implemented.
 917   return false;
 918 }
 919 
 920 SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {
 921   if (_dir != NULL) {
 922     os::closedir(_dir);
 923   }
 924 }
 925 
 926 SystemProcessInterface::SystemProcesses::SystemProcesses() {
 927   _iterator = NULL;
 928 }
 929 
 930 bool SystemProcessInterface::SystemProcesses::initialize() {
 931   _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();
<a name="22" id="anc22"></a><span class="line-modified"> 932   return NULL == _iterator ? false : _iterator-&gt;initialize();</span>
 933 }
 934 
 935 SystemProcessInterface::SystemProcesses::~SystemProcesses() {
 936   if (_iterator != NULL) {
 937     delete _iterator;
 938   }
 939 }
 940 
 941 int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {
 942   assert(system_processes != NULL, &quot;system_processes pointer is NULL!&quot;);
 943   assert(no_of_sys_processes != NULL, &quot;system_processes counter pointers is NULL!&quot;);
 944   assert(_iterator != NULL, &quot;iterator is NULL!&quot;);
 945 
 946   // initialize pointers
 947   *no_of_sys_processes = 0;
 948   *system_processes = NULL;
 949 
 950   while (_iterator-&gt;is_valid()) {
 951     SystemProcess* tmp = new SystemProcess();
 952     _iterator-&gt;current(tmp);
 953 
 954     //if already existing head
 955     if (*system_processes != NULL) {
 956       //move &quot;first to second&quot;
 957       tmp-&gt;set_next(*system_processes);
 958     }
 959     // new head
 960     *system_processes = tmp;
 961     // increment
 962     (*no_of_sys_processes)++;
 963     // step forward
 964     _iterator-&gt;next_process();
 965   }
 966   return OS_OK;
 967 }
 968 
 969 int SystemProcessInterface::system_processes(SystemProcess** system_procs, int* no_of_sys_processes) const {
 970   return _impl-&gt;system_processes(system_procs, no_of_sys_processes);
 971 }
 972 
 973 SystemProcessInterface::SystemProcessInterface() {
 974   _impl = NULL;
 975 }
 976 
 977 bool SystemProcessInterface::initialize() {
 978   _impl = new SystemProcessInterface::SystemProcesses();
<a name="23" id="anc23"></a><span class="line-modified"> 979   return NULL == _impl ? false : _impl-&gt;initialize();</span>
 980 }
 981 
 982 SystemProcessInterface::~SystemProcessInterface() {
 983   if (_impl != NULL) {
 984     delete _impl;
 985   }
 986 }
 987 
 988 CPUInformationInterface::CPUInformationInterface() {
 989   _cpu_info = NULL;
 990 }
 991 
 992 bool CPUInformationInterface::initialize() {
 993   _cpu_info = new CPUInformation();
<a name="24" id="anc24"></a><span class="line-removed"> 994   if (NULL == _cpu_info) {</span>
<span class="line-removed"> 995     return false;</span>
<span class="line-removed"> 996   }</span>
 997   _cpu_info-&gt;set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());
 998   _cpu_info-&gt;set_number_of_cores(VM_Version_Ext::number_of_cores());
 999   _cpu_info-&gt;set_number_of_sockets(VM_Version_Ext::number_of_sockets());
1000   _cpu_info-&gt;set_cpu_name(VM_Version_Ext::cpu_name());
1001   _cpu_info-&gt;set_cpu_description(VM_Version_Ext::cpu_description());
<a name="25" id="anc25"></a><span class="line-removed">1002 </span>
1003   return true;
1004 }
1005 
1006 CPUInformationInterface::~CPUInformationInterface() {
1007   if (_cpu_info != NULL) {
1008     if (_cpu_info-&gt;cpu_name() != NULL) {
1009       const char* cpu_name = _cpu_info-&gt;cpu_name();
1010       FREE_C_HEAP_ARRAY(char, cpu_name);
1011       _cpu_info-&gt;set_cpu_name(NULL);
1012     }
1013     if (_cpu_info-&gt;cpu_description() != NULL) {
1014        const char* cpu_desc = _cpu_info-&gt;cpu_description();
1015        FREE_C_HEAP_ARRAY(char, cpu_desc);
1016       _cpu_info-&gt;set_cpu_description(NULL);
1017     }
1018     delete _cpu_info;
1019   }
1020 }
1021 
1022 int CPUInformationInterface::cpu_information(CPUInformation&amp; cpu_info) {
1023   if (_cpu_info == NULL) {
1024     return OS_ERR;
1025   }
1026 
1027   cpu_info = *_cpu_info; // shallow copy assignment
1028   return OS_OK;
1029 }
1030 
1031 class NetworkPerformanceInterface::NetworkPerformance : public CHeapObj&lt;mtInternal&gt; {
1032   friend class NetworkPerformanceInterface;
1033  private:
1034   NetworkPerformance();
<a name="26" id="anc26"></a><span class="line-modified">1035   NetworkPerformance(const NetworkPerformance&amp; rhs); // no impl</span>
<span class="line-removed">1036   NetworkPerformance&amp; operator=(const NetworkPerformance&amp; rhs); // no impl</span>
1037   bool initialize();
1038   ~NetworkPerformance();
1039   int network_utilization(NetworkInterface** network_interfaces) const;
1040 };
1041 
1042 NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {
1043 
1044 }
1045 
1046 bool NetworkPerformanceInterface::NetworkPerformance::initialize() {
1047   return true;
1048 }
1049 
1050 NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {
1051 }
1052 
1053 int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const
1054 {
1055   return FUNCTIONALITY_NOT_IMPLEMENTED;
1056 }
1057 
1058 NetworkPerformanceInterface::NetworkPerformanceInterface() {
1059   _impl = NULL;
1060 }
1061 
1062 NetworkPerformanceInterface::~NetworkPerformanceInterface() {
1063   if (_impl != NULL) {
1064     delete _impl;
1065   }
1066 }
1067 
1068 bool NetworkPerformanceInterface::initialize() {
1069   _impl = new NetworkPerformanceInterface::NetworkPerformance();
<a name="27" id="anc27"></a><span class="line-modified">1070   return _impl != NULL &amp;&amp; _impl-&gt;initialize();</span>
1071 }
1072 
1073 int NetworkPerformanceInterface::network_utilization(NetworkInterface** network_interfaces) const {
1074   return _impl-&gt;network_utilization(network_interfaces);
1075 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
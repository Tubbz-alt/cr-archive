<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/compiler/compileTask.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_COMPILER_COMPILETASK_HPP
 26 #define SHARE_COMPILER_COMPILETASK_HPP
 27 
 28 #include &quot;ci/ciMethod.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;compiler/compileLog.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;utilities/xmlstream.hpp&quot;
 33 
 34 // CompileTask
 35 //
 36 // An entry in the compile queue.  It represents a pending or current
 37 // compilation.
 38 
 39 class CompileTask : public CHeapObj&lt;mtCompiler&gt; {
 40   friend class VMStructs;
 41   friend class JVMCIVMStructs;
 42 
 43  public:
 44   // Different reasons for a compilation
 45   // The order is important - Reason_Whitebox and higher can not become
 46   // stale, see CompileTask::can_become_stale()
 47   // Also mapped to reason_names[]
 48   enum CompileReason {
 49       Reason_None,
 50       Reason_InvocationCount,  // Simple/StackWalk-policy
 51       Reason_BackedgeCount,    // Simple/StackWalk-policy
 52       Reason_Tiered,           // Tiered-policy
 53       Reason_CTW,              // Compile the world
 54       Reason_Replay,           // ciReplay
 55       Reason_Whitebox,         // Whitebox API
 56       Reason_MustBeCompiled,   // Java callHelper, LinkResolver
 57       Reason_Bootstrap,        // JVMCI bootstrap
 58       Reason_Count
 59   };
 60 
 61   static const char* reason_name(CompileTask::CompileReason compile_reason) {
 62     static const char* reason_names[] = {
 63       &quot;no_reason&quot;,
 64       &quot;count&quot;,
 65       &quot;backedge_count&quot;,
 66       &quot;tiered&quot;,
 67       &quot;CTW&quot;,
 68       &quot;replay&quot;,
 69       &quot;whitebox&quot;,
 70       &quot;must_be_compiled&quot;,
 71       &quot;bootstrap&quot;
 72     };
 73     return reason_names[compile_reason];
 74   }
 75 
 76  private:
 77   static CompileTask* _task_free_list;
 78 #ifdef ASSERT
 79   static int          _num_allocated_tasks;
 80 #endif
 81 
 82   Monitor*     _lock;
 83   uint         _compile_id;
 84   Method*      _method;
 85   jobject      _method_holder;
 86   int          _osr_bci;
 87   bool         _is_complete;
 88   bool         _is_success;
 89   bool         _is_blocking;
 90 #if INCLUDE_JVMCI
 91   bool         _has_waiter;
 92   // Compiler thread for a blocking JVMCI compilation
 93   CompilerThread* _jvmci_compiler_thread;
 94 #endif
 95   int          _comp_level;
 96   int          _num_inlined_bytecodes;
 97   nmethodLocker* _code_handle;  // holder of eventual result
 98   CompileTask* _next, *_prev;
 99   bool         _is_free;
100   // Fields used for logging why the compilation was initiated:
101   jlong        _time_queued;  // time when task was enqueued
102   jlong        _time_started; // time when compilation started
103   Method*      _hot_method;   // which method actually triggered this task
104   jobject      _hot_method_holder;
105   int          _hot_count;    // information about its invocation counter
106   CompileReason _compile_reason;      // more info about the task
107   const char*  _failure_reason;
108   // Specifies if _failure_reason is on the C heap.
109   bool         _failure_reason_on_C_heap;
110 
111  public:
112   CompileTask() : _failure_reason(NULL), _failure_reason_on_C_heap(false) {
113     _lock = new Monitor(Mutex::nonleaf+2, &quot;CompileTaskLock&quot;);
114   }
115 
116   void initialize(int compile_id, const methodHandle&amp; method, int osr_bci, int comp_level,
117                   const methodHandle&amp; hot_method, int hot_count,
118                   CompileTask::CompileReason compile_reason, bool is_blocking);
119 
120   static CompileTask* allocate();
121   static void         free(CompileTask* task);
122 
123   int          compile_id() const                { return _compile_id; }
124   Method*      method() const                    { return _method; }
125   Method*      hot_method() const                { return _hot_method; }
126   int          osr_bci() const                   { return _osr_bci; }
127   bool         is_complete() const               { return _is_complete; }
128   bool         is_blocking() const               { return _is_blocking; }
129   bool         is_success() const                { return _is_success; }
130   bool         can_become_stale() const          {
131     switch (_compile_reason) {
132       case Reason_BackedgeCount:
133       case Reason_InvocationCount:
134       case Reason_Tiered:
135         return !_is_blocking;
136       default:
137         return false;
138     }
139   }
140 #if INCLUDE_JVMCI
141   bool         has_waiter() const                { return _has_waiter; }
142   void         clear_waiter()                    { _has_waiter = false; }
143   CompilerThread* jvmci_compiler_thread() const  { return _jvmci_compiler_thread; }
144   void         set_jvmci_compiler_thread(CompilerThread* t) {
145     assert(is_blocking(), &quot;must be&quot;);
146     assert((t == NULL) != (_jvmci_compiler_thread == NULL), &quot;must be&quot;);
147     _jvmci_compiler_thread = t;
148   }
149 #endif
150 
151   nmethodLocker* code_handle() const             { return _code_handle; }
152   void         set_code_handle(nmethodLocker* l) { _code_handle = l; }
153   nmethod*     code() const;                     // _code_handle-&gt;code()
154   void         set_code(nmethod* nm);            // _code_handle-&gt;set_code(nm)
155 
156   Monitor*     lock() const                      { return _lock; }
157 
158   void         mark_complete()                   { _is_complete = true; }
159   void         mark_success()                    { _is_success = true; }
160   void         mark_started(jlong time)          { _time_started = time; }
161 
162   int          comp_level()                      { return _comp_level;}
163   void         set_comp_level(int comp_level)    { _comp_level = comp_level;}
164 
165   AbstractCompiler* compiler();
166   CompileTask*      select_for_compilation();
167 
168   int          num_inlined_bytecodes() const     { return _num_inlined_bytecodes; }
169   void         set_num_inlined_bytecodes(int n)  { _num_inlined_bytecodes = n; }
170 
171   CompileTask* next() const                      { return _next; }
172   void         set_next(CompileTask* next)       { _next = next; }
173   CompileTask* prev() const                      { return _prev; }
174   void         set_prev(CompileTask* prev)       { _prev = prev; }
175   bool         is_free() const                   { return _is_free; }
176   void         set_is_free(bool val)             { _is_free = val; }
177   bool         is_unloaded() const;
178 
179   // RedefineClasses support
180   void         metadata_do(MetadataClosure* f);
181   void         mark_on_stack();
182 
183 private:
184   static void  print_impl(outputStream* st, Method* method, int compile_id, int comp_level,
185                                       bool is_osr_method = false, int osr_bci = -1, bool is_blocking = false,
186                                       const char* msg = NULL, bool short_form = false, bool cr = true,
187                                       jlong time_queued = 0, jlong time_started = 0);
188 
189 public:
190   void         print(outputStream* st = tty, const char* msg = NULL, bool short_form = false, bool cr = true);
191   void         print_ul(const char* msg = NULL);
192   static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {
193     print_impl(st, nm-&gt;method(), nm-&gt;compile_id(), nm-&gt;comp_level(),
194                            nm-&gt;is_osr_method(), nm-&gt;is_osr_method() ? nm-&gt;osr_entry_bci() : -1, /*is_blocking*/ false,
195                            msg, short_form, cr);
196   }
197   static void  print_ul(const nmethod* nm, const char* msg = NULL);
198 
199   static void  print_inline_indent(int inline_level, outputStream* st = tty);
200 
201   void         print_tty();
202   void         print_line_on_error(outputStream* st, char* buf, int buflen);
203 
204   void         log_task(xmlStream* log);
205   void         log_task_queued();
206   void         log_task_start(CompileLog* log);
207   void         log_task_done(CompileLog* log);
208 
209   void         set_failure_reason(const char* reason, bool on_C_heap = false) {
210     _failure_reason = reason;
211     _failure_reason_on_C_heap = on_C_heap;
212   }
213 
214   bool         check_break_at_flags();
215 
216   static void print_inlining_inner(outputStream* st, ciMethod* method, int inline_level, int bci, const char* msg = NULL);
217   static void print_inlining_tty(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {
218     print_inlining_inner(tty, method, inline_level, bci, msg);
219   }
220   static void print_inlining_ul(ciMethod* method, int inline_level, int bci, const char* msg = NULL);
221 };
222 
223 #endif // SHARE_COMPILER_COMPILETASK_HPP
    </pre>
  </body>
</html>
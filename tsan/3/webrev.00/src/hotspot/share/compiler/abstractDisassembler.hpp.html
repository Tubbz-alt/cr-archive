<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/compiler/abstractDisassembler.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef SHARE_COMPILER_ABSTRACTDISASSEMBLER_HPP
 27 #define SHARE_COMPILER_ABSTRACTDISASSEMBLER_HPP
 28 
 29 // AbstractDisassembler is the base class for
 30 // platform-specific Disassembler classes.
 31 
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 
 34 class AbstractDisassembler {
 35 
 36  private:
 37   // These are some general settings which control
 38   // abstract disassembly output.
 39   enum {
 40     // that many bytes are dumped in one line.
 41     abstract_instruction_bytes_per_line     = 32,
 42     // instruction bytes are grouped in blocks of that many bytes.
 43     abstract_instruction_bytes_per_block    =  2,
 44     // instructions have this default len.
 45     abstract_instruction_size_in_bytes      =  1,
 46     // instructions have this maximum len.
 47     abstract_instruction_maxsize_in_bytes   =  1
 48   };
 49 
 50   static bool _align_instr;        // vertical alignment of instructions in abstract disassembly
 51   static bool _show_pc;            // print the instruction address
 52   static bool _show_offset;        // print the instruction offset (from start of blob)
 53   static bool _show_bytes;         // print instruction bytes
 54   static bool _show_data_hex;      // print instruction bytes
 55   static bool _show_data_int;      // print instruction bytes
 56   static bool _show_data_float;    // print instruction bytes
 57   static bool _show_structs;       // print compiler data structures (relocations, oop maps, scopes, metadata, ...)
 58   static bool _show_comment;       // print instruction comments
 59   static bool _show_block_comment; // print block comments
 60 
 61  public:
 62   // Platform-independent location and instruction formatting.
 63   // All functions return #characters printed.
 64   static int  print_location(address here, address begin, address end, outputStream* st, bool align, bool print_header);
 65   static int  print_instruction(address here, int len, int max_len,    outputStream* st, bool align, bool print_header);
 66   static int  print_hexdata(address here, int len, outputStream* st, bool print_header = false);
 67   static int  print_delimiter(outputStream* st);
 68   static bool start_newline(int byte_count) { return byte_count &gt;= abstract_instruction_bytes_per_line; }
 69 
 70   static void toggle_align_instr()        { _align_instr        = !_align_instr; }
 71   static void toggle_show_pc()            { _show_pc            = !_show_pc; }
 72   static void toggle_show_offset()        { _show_offset        = !_show_offset; }
 73   static void toggle_show_bytes()         { _show_bytes         = !_show_bytes; }
 74   static void toggle_show_data_hex()      { _show_data_hex      = !_show_data_hex; }
 75   static void toggle_show_data_int()      { _show_data_int      = !_show_data_int; }
 76   static void toggle_show_data_float()    { _show_data_float    = !_show_data_float; }
 77   static void toggle_show_structs()       { _show_structs       = !_show_structs; }
 78   static void toggle_show_comment()       { _show_comment       = !_show_comment; }
 79   static void toggle_show_block_comment() { _show_block_comment = !_show_block_comment; }
 80 
 81   static bool align_instr()        { return _align_instr; }
 82   static bool show_pc()            { return _show_pc; }
 83   static bool show_offset()        { return _show_offset; }
 84   static bool show_bytes()         { return _show_bytes; }
 85   static bool show_data_hex()      { return _show_data_hex; }
 86   static bool show_data_int()      { return _show_data_int; }
 87   static bool show_data_float()    { return _show_data_float; }
 88   static bool show_structs()       { return _show_structs; }
 89   static bool show_comment()       { return _show_comment; }
 90   static bool show_block_comment() { return _show_block_comment; }
 91 
 92   // Decodes the one instruction at address start in a platform-independent
 93   // format. Returns the start of the next instruction (which is
 94   // &#39;start&#39; plus &#39;instruction_size_in_bytes&#39;). The parameter max_instr_size_in_bytes
 95   // is used for output alignment purposes only.
 96   static address decode_instruction_abstract(address start,
 97                                              outputStream* st,
 98                                              const int instruction_size_in_bytes,
 99                                              const int max_instr_size_in_bytes = abstract_instruction_maxsize_in_bytes);
100 
101   // Decodes all instructions in the given range [start..end)
102   // calling decode_instruction_abstract for each instruction.
103   // The format is platform dependent only to the extend that
104   // it respects the actual instruction length where possible.
105   // Does not print any markers or decorators.
106   static void decode_range_abstract(address range_start, address range_end,
107                                     address start, address end,
108                                     outputStream* st,
109                                     const int max_instr_size_in_bytes = abstract_instruction_maxsize_in_bytes);
110 
111   // Decodes all instructions in the given range in a platform-independent
112   // format, calling decode_instruction_abstract for each instruction.
113   static void decode_abstract(address start, address end,
114                               outputStream* st,
115                               const int max_instr_size_in_bytes = abstract_instruction_maxsize_in_bytes);
116 };
117 
118 #endif // SHARE_COMPILER_ABSTRACTDISASSEMBLER_HPP
    </pre>
  </body>
</html>
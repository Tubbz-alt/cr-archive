<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/compiler/compileBroker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractCompiler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileBroker.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,28 ***</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/codeHeapState.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;compiler/directivesParser.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/whitebox.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-new-header">--- 28,29 ---</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/codeHeapState.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;compiler/directivesParser.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/whitebox.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,14 ***</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Compiler.hpp&quot;
  #endif
  #if INCLUDE_JVMCI
<span class="line-modified">! #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/vframe.hpp&quot;</span>
  #endif
  #ifdef COMPILER2
  #include &quot;opto/c2compiler.hpp&quot;
  #endif
  
<span class="line-new-header">--- 67,12 ---</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Compiler.hpp&quot;
  #endif
  #if INCLUDE_JVMCI
<span class="line-modified">! #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
  #endif
  #ifdef COMPILER2
  #include &quot;opto/c2compiler.hpp&quot;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,15 ***</span>
  
  // These counters are used to assign an unique ID to each compilation.
  volatile jint CompileBroker::_compilation_id     = 0;
  volatile jint CompileBroker::_osr_compilation_id = 0;
  
<span class="line-removed">- // Debugging information</span>
<span class="line-removed">- int  CompileBroker::_last_compile_type     = no_compile;</span>
<span class="line-removed">- int  CompileBroker::_last_compile_level    = CompLevel_none;</span>
<span class="line-removed">- char CompileBroker::_last_method_compiled[CompileBroker::name_buffer_length];</span>
<span class="line-removed">- </span>
  // Performance counters
  PerfCounter* CompileBroker::_perf_total_compilation = NULL;
  PerfCounter* CompileBroker::_perf_osr_compilation = NULL;
  PerfCounter* CompileBroker::_perf_standard_compilation = NULL;
  
<span class="line-new-header">--- 132,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,16 ***</span>
  
  
  
  class CompilationLog : public StringEventLog {
   public:
<span class="line-modified">!   CompilationLog() : StringEventLog(&quot;Compilation events&quot;) {</span>
    }
  
    void log_compile(JavaThread* thread, CompileTask* task) {
      StringLogMessage lm;
<span class="line-modified">!     stringStream sstr = lm.stream();</span>
      // msg.time_stamp().update_to(tty-&gt;time_stamp().ticks());
      task-&gt;print(&amp;sstr, NULL, true, false);
      log(thread, &quot;%s&quot;, (const char*)lm);
    }
  
<span class="line-new-header">--- 185,16 ---</span>
  
  
  
  class CompilationLog : public StringEventLog {
   public:
<span class="line-modified">!   CompilationLog() : StringEventLog(&quot;Compilation events&quot;, &quot;jit&quot;) {</span>
    }
  
    void log_compile(JavaThread* thread, CompileTask* task) {
      StringLogMessage lm;
<span class="line-modified">!     stringStream sstr(lm.buffer(), lm.size());</span>
      // msg.time_stamp().update_to(tty-&gt;time_stamp().ticks());
      task-&gt;print(&amp;sstr, NULL, true, false);
      log(thread, &quot;%s&quot;, (const char*)lm);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,11 ***</span>
    task-&gt;set_code_handle(NULL);
    thread-&gt;set_env(NULL);
    if (task-&gt;is_blocking()) {
      bool free_task = false;
      {
<span class="line-modified">!       MutexLocker notifier(task-&gt;lock(), thread);</span>
        task-&gt;mark_complete();
  #if INCLUDE_JVMCI
        if (CompileBroker::compiler(task-&gt;comp_level())-&gt;is_jvmci()) {
          if (!task-&gt;has_waiter()) {
            // The waiting thread timed out and thus did not free the task.
<span class="line-new-header">--- 264,11 ---</span>
    task-&gt;set_code_handle(NULL);
    thread-&gt;set_env(NULL);
    if (task-&gt;is_blocking()) {
      bool free_task = false;
      {
<span class="line-modified">!       MutexLocker notifier(thread, task-&gt;lock());</span>
        task-&gt;mark_complete();
  #if INCLUDE_JVMCI
        if (CompileBroker::compiler(task-&gt;comp_level())-&gt;is_jvmci()) {
          if (!task-&gt;has_waiter()) {
            // The waiting thread timed out and thus did not free the task.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,11 ***</span>
  }
  
  /**
   * Check if a CompilerThread can be removed and update count if requested.
   */
<span class="line-modified">! static bool can_remove(CompilerThread *ct, bool do_it) {</span>
    assert(UseDynamicNumberOfCompilerThreads, &quot;or shouldn&#39;t be here&quot;);
    if (!ReduceNumberOfCompilerThreads) return false;
  
    AbstractCompiler *compiler = ct-&gt;compiler();
    int compiler_count = compiler-&gt;num_compiler_threads();
<span class="line-new-header">--- 297,11 ---</span>
  }
  
  /**
   * Check if a CompilerThread can be removed and update count if requested.
   */
<span class="line-modified">! bool CompileBroker::can_remove(CompilerThread *ct, bool do_it) {</span>
    assert(UseDynamicNumberOfCompilerThreads, &quot;or shouldn&#39;t be here&quot;);
    if (!ReduceNumberOfCompilerThreads) return false;
  
    AbstractCompiler *compiler = ct-&gt;compiler();
    int compiler_count = compiler-&gt;num_compiler_threads();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,17 ***</span>
    if (compiler_count &lt; 2) return false;
  
    // Keep thread alive for at least some time.
    if (ct-&gt;idle_time_millis() &lt; (c1 ? 500 : 100)) return false;
  
    // We only allow the last compiler thread of each type to get removed.
<span class="line-modified">!   jobject last_compiler = c1 ? CompileBroker::compiler1_object(compiler_count - 1)</span>
<span class="line-modified">!                              : CompileBroker::compiler2_object(compiler_count - 1);</span>
<span class="line-modified">!   if (oopDesc::equals(ct-&gt;threadObj(), JNIHandles::resolve_non_null(last_compiler))) {</span>
      if (do_it) {
        assert_locked_or_safepoint(CompileThread_lock); // Update must be consistent.
        compiler-&gt;set_num_compiler_threads(compiler_count - 1);
      }
      return true;
    }
    return false;
  }
<span class="line-new-header">--- 311,36 ---</span>
    if (compiler_count &lt; 2) return false;
  
    // Keep thread alive for at least some time.
    if (ct-&gt;idle_time_millis() &lt; (c1 ? 500 : 100)) return false;
  
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   if (compiler-&gt;is_jvmci()) {</span>
<span class="line-added">+     // Handles for JVMCI thread objects may get released concurrently.</span>
<span class="line-added">+     if (do_it) {</span>
<span class="line-added">+       assert(CompileThread_lock-&gt;owner() == ct, &quot;must be holding lock&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Skip check if it&#39;s the last thread and let caller check again.</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    // We only allow the last compiler thread of each type to get removed.
<span class="line-modified">!   jobject last_compiler = c1 ? compiler1_object(compiler_count - 1)</span>
<span class="line-modified">!                              : compiler2_object(compiler_count - 1);</span>
<span class="line-modified">!   if (ct-&gt;threadObj() == JNIHandles::resolve_non_null(last_compiler)) {</span>
      if (do_it) {
        assert_locked_or_safepoint(CompileThread_lock); // Update must be consistent.
        compiler-&gt;set_num_compiler_threads(compiler_count - 1);
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+       if (compiler-&gt;is_jvmci()) {</span>
<span class="line-added">+         // Old j.l.Thread object can die when no longer referenced elsewhere.</span>
<span class="line-added">+         JNIHandles::destroy_global(compiler2_object(compiler_count - 1));</span>
<span class="line-added">+         _compiler2_objects[compiler_count - 1] = NULL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif</span>
      }
      return true;
    }
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,11 ***</span>
    // save methods from RedefineClasses across safepoint
    // across MethodCompileQueue_lock below.
    methodHandle save_method;
    methodHandle save_hot_method;
  
<span class="line-modified">!   MutexLocker locker(MethodCompileQueue_lock);</span>
    // If _first is NULL we have no more compile jobs. There are two reasons for
    // having no compile jobs: First, we compiled everything we wanted. Second,
    // we ran out of code cache so compilation has been disabled. In the latter
    // case we perform code cache sweeps to free memory such that we can re-enable
    // compilation.
<span class="line-new-header">--- 418,11 ---</span>
    // save methods from RedefineClasses across safepoint
    // across MethodCompileQueue_lock below.
    methodHandle save_method;
    methodHandle save_hot_method;
  
<span class="line-modified">!   MonitorLocker locker(MethodCompileQueue_lock);</span>
    // If _first is NULL we have no more compile jobs. There are two reasons for
    // having no compile jobs: First, we compiled everything we wanted. Second,
    // we ran out of code cache so compilation has been disabled. In the latter
    // case we perform code cache sweeps to free memory such that we can re-enable
    // compilation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,15 ***</span>
      // the stable state, i.e., we do not want to evict methods from the
      // code cache if it is unnecessary.
      // We need a timed wait here, since compiler threads can exit if compilation
      // is disabled forever. We use 5 seconds wait time; the exiting of compiler threads
      // is not critical and we do not want idle compiler threads to wake up too often.
<span class="line-modified">!     MethodCompileQueue_lock-&gt;wait(!Mutex::_no_safepoint_check_flag, 5*1000);</span>
  
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; _first == NULL) {
        // Still nothing to compile. Give caller a chance to stop this thread.
<span class="line-modified">!       if (can_remove(CompilerThread::current(), false)) return NULL;</span>
      }
    }
  
    if (CompileBroker::is_compilation_disabled_forever()) {
      return NULL;
<span class="line-new-header">--- 439,15 ---</span>
      // the stable state, i.e., we do not want to evict methods from the
      // code cache if it is unnecessary.
      // We need a timed wait here, since compiler threads can exit if compilation
      // is disabled forever. We use 5 seconds wait time; the exiting of compiler threads
      // is not critical and we do not want idle compiler threads to wake up too often.
<span class="line-modified">!     locker.wait(5*1000);</span>
  
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; _first == NULL) {
        // Still nothing to compile. Give caller a chance to stop this thread.
<span class="line-modified">!       if (CompileBroker::can_remove(CompilerThread::current(), false)) return NULL;</span>
      }
    }
  
    if (CompileBroker::is_compilation_disabled_forever()) {
      return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,16 ***</span>
    }
  
    if (task != NULL) {
      // Save method pointers across unlock safepoint.  The task is removed from
      // the compilation queue, which is walked during RedefineClasses.
<span class="line-modified">!     save_method = methodHandle(task-&gt;method());</span>
<span class="line-modified">!     save_hot_method = methodHandle(task-&gt;hot_method());</span>
  
      remove(task);
<span class="line-removed">-     purge_stale_tasks(); // may temporarily release MCQ lock</span>
    }
    return task;
  }
  
  // Clean &amp; deallocate stale compile tasks.
  // Temporarily releases MethodCompileQueue lock.
<span class="line-new-header">--- 463,17 ---</span>
    }
  
    if (task != NULL) {
      // Save method pointers across unlock safepoint.  The task is removed from
      // the compilation queue, which is walked during RedefineClasses.
<span class="line-modified">!     Thread* thread = Thread::current();</span>
<span class="line-modified">!     save_method = methodHandle(thread, task-&gt;method());</span>
<span class="line-added">+     save_hot_method = methodHandle(thread, task-&gt;hot_method());</span>
  
      remove(task);
    }
<span class="line-added">+   purge_stale_tasks(); // may temporarily release MCQ lock</span>
    return task;
  }
  
  // Clean &amp; deallocate stale compile tasks.
  // Temporarily releases MethodCompileQueue lock.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,12 ***</span>
    }
    st-&gt;cr();
  }
  
  void CompileQueue::print_tty() {
<span class="line-modified">!   ttyLocker ttyl;</span>
<span class="line-modified">!   print(tty);</span>
  }
  
  CompilerCounters::CompilerCounters() {
    _current_method[0] = &#39;\0&#39;;
    _compile_type = CompileBroker::no_compile;
<span class="line-new-header">--- 575,18 ---</span>
    }
    st-&gt;cr();
  }
  
  void CompileQueue::print_tty() {
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   stringStream ss;</span>
<span class="line-added">+   // Dump the compile queue into a buffer before locking the tty</span>
<span class="line-added">+   print(&amp;ss);</span>
<span class="line-added">+   {</span>
<span class="line-added">+     ttyLocker ttyl;</span>
<span class="line-added">+     tty-&gt;print(&quot;%s&quot;, ss.as_string());</span>
<span class="line-added">+   }</span>
  }
  
  CompilerCounters::CompilerCounters() {
    _current_method[0] = &#39;\0&#39;;
    _compile_type = CompileBroker::no_compile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,13 ***</span>
  
  // ------------------------------------------------------------------
  // CompileBroker::compilation_init
  //
  // Initialize the Compilation object
<span class="line-modified">! void CompileBroker::compilation_init_phase1(TRAPS) {</span>
<span class="line-removed">-   _last_method_compiled[0] = &#39;\0&#39;;</span>
<span class="line-removed">- </span>
    // No need to initialize compilation system if we do not use it.
    if (!UseCompiler) {
      return;
    }
    // Set the interface to the current compiler(s).
<span class="line-new-header">--- 594,11 ---</span>
  
  // ------------------------------------------------------------------
  // CompileBroker::compilation_init
  //
  // Initialize the Compilation object
<span class="line-modified">! void CompileBroker::compilation_init_phase1(Thread* THREAD) {</span>
    // No need to initialize compilation system if we do not use it.
    if (!UseCompiler) {
      return;
    }
    // Set the interface to the current compiler(s).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,10 ***</span>
<span class="line-new-header">--- 645,11 ---</span>
    // Start the compiler thread(s) and the sweeper thread
    init_compiler_sweeper_threads();
    // totalTime performance counter is always created as it is required
    // by the implementation of java.lang.management.CompilationMBean.
    {
<span class="line-added">+     // Ensure OOM leads to vm_exit_during_initialization.</span>
      EXCEPTION_MARK;
      _perf_total_compilation =
                   PerfDataManager::create_counter(JAVA_CI, &quot;totalTime&quot;,
                                                   PerfData::U_Ticks, CHECK);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 741,21 ***</span>
                         string,
                         CHECK_NH);
  }
  
  
<span class="line-modified">! JavaThread* CompileBroker::make_thread(jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, TRAPS) {</span>
<span class="line-modified">!   JavaThread* thread = NULL;</span>
    {
<span class="line-modified">!     MutexLocker mu(Threads_lock, THREAD);</span>
      if (comp != NULL) {
        if (!InjectCompilerCreationFailure || comp-&gt;num_compiler_threads() == 0) {
          CompilerCounters* counters = new CompilerCounters();
<span class="line-modified">!         thread = new CompilerThread(queue, counters);</span>
        }
      } else {
<span class="line-modified">!       thread = new CodeCacheSweeperThread();</span>
      }
      // At this point the new CompilerThread data-races with this startup
      // thread (which I believe is the primoridal thread and NOT the VM
      // thread).  This means Java bytecodes being executed at startup can
      // queue compile jobs which will run at whatever default priority the
<span class="line-new-header">--- 760,21 ---</span>
                         string,
                         CHECK_NH);
  }
  
  
<span class="line-modified">! JavaThread* CompileBroker::make_thread(jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD) {</span>
<span class="line-modified">!   JavaThread* new_thread = NULL;</span>
    {
<span class="line-modified">!     MutexLocker mu(THREAD, Threads_lock);</span>
      if (comp != NULL) {
        if (!InjectCompilerCreationFailure || comp-&gt;num_compiler_threads() == 0) {
          CompilerCounters* counters = new CompilerCounters();
<span class="line-modified">!         new_thread = new CompilerThread(queue, counters);</span>
        }
      } else {
<span class="line-modified">!       new_thread = new CodeCacheSweeperThread();</span>
      }
      // At this point the new CompilerThread data-races with this startup
      // thread (which I believe is the primoridal thread and NOT the VM
      // thread).  This means Java bytecodes being executed at startup can
      // queue compile jobs which will run at whatever default priority the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,13 ***</span>
      // JavaThread due to lack of memory. We would have to throw an exception
      // in that case. However, since this must work and we do not allow
      // exceptions anyway, check and abort if this fails. But first release the
      // lock.
  
<span class="line-modified">!     if (thread != NULL &amp;&amp; thread-&gt;osthread() != NULL) {</span>
  
<span class="line-modified">!       java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), thread);</span>
  
        // Note that this only sets the JavaThread _priority field, which by
        // definition is limited to Java priorities and not OS priorities.
        // The os-priority is set in the CompilerThread startup code itself
  
<span class="line-new-header">--- 785,13 ---</span>
      // JavaThread due to lack of memory. We would have to throw an exception
      // in that case. However, since this must work and we do not allow
      // exceptions anyway, check and abort if this fails. But first release the
      // lock.
  
<span class="line-modified">!     if (new_thread != NULL &amp;&amp; new_thread-&gt;osthread() != NULL) {</span>
  
<span class="line-modified">!       java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), new_thread);</span>
  
        // Note that this only sets the JavaThread _priority field, which by
        // definition is limited to Java priorities and not OS priorities.
        // The os-priority is set in the CompilerThread startup code itself
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,43 ***</span>
            native_prio = os::java_to_os_priority[CriticalPriority];
          } else {
            native_prio = os::java_to_os_priority[NearMaxPriority];
          }
        }
<span class="line-modified">!       os::set_native_priority(thread, native_prio);</span>
  
        java_lang_Thread::set_daemon(JNIHandles::resolve_non_null(thread_handle));
  
<span class="line-modified">!       thread-&gt;set_threadObj(JNIHandles::resolve_non_null(thread_handle));</span>
        if (comp != NULL) {
<span class="line-modified">!         thread-&gt;as_CompilerThread()-&gt;set_compiler(comp);</span>
        }
<span class="line-modified">!       Threads::add(thread);</span>
<span class="line-modified">!       Thread::start(thread);</span>
      }
    }
  
    // First release lock before aborting VM.
<span class="line-modified">!   if (thread == NULL || thread-&gt;osthread() == NULL) {</span>
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; comp != NULL &amp;&amp; comp-&gt;num_compiler_threads() &gt; 0) {
<span class="line-modified">!       if (thread != NULL) {</span>
<span class="line-modified">!         thread-&gt;smr_delete();</span>
        }
        return NULL;
      }
      vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
                                    os::native_thread_creation_failed_msg());
    }
  
    // Let go of Threads_lock before yielding
    os::naked_yield(); // make sure that the compiler thread is started early (especially helpful on SOLARIS)
  
<span class="line-modified">!   return thread;</span>
  }
  
  
  void CompileBroker::init_compiler_sweeper_threads() {
    EXCEPTION_MARK;
  #if !defined(ZERO)
    assert(_c2_count &gt; 0 || _c1_count &gt; 0, &quot;No compilers?&quot;);
  #endif // !ZERO
    // Initialize the compilation queue
<span class="line-new-header">--- 808,44 ---</span>
            native_prio = os::java_to_os_priority[CriticalPriority];
          } else {
            native_prio = os::java_to_os_priority[NearMaxPriority];
          }
        }
<span class="line-modified">!       os::set_native_priority(new_thread, native_prio);</span>
  
        java_lang_Thread::set_daemon(JNIHandles::resolve_non_null(thread_handle));
  
<span class="line-modified">!       new_thread-&gt;set_threadObj(JNIHandles::resolve_non_null(thread_handle));</span>
        if (comp != NULL) {
<span class="line-modified">!         new_thread-&gt;as_CompilerThread()-&gt;set_compiler(comp);</span>
        }
<span class="line-modified">!       Threads::add(new_thread);</span>
<span class="line-modified">!       Thread::start(new_thread);</span>
      }
    }
  
    // First release lock before aborting VM.
<span class="line-modified">!   if (new_thread == NULL || new_thread-&gt;osthread() == NULL) {</span>
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; comp != NULL &amp;&amp; comp-&gt;num_compiler_threads() &gt; 0) {
<span class="line-modified">!       if (new_thread != NULL) {</span>
<span class="line-modified">!         new_thread-&gt;smr_delete();</span>
        }
        return NULL;
      }
      vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
                                    os::native_thread_creation_failed_msg());
    }
  
    // Let go of Threads_lock before yielding
    os::naked_yield(); // make sure that the compiler thread is started early (especially helpful on SOLARIS)
  
<span class="line-modified">!   return new_thread;</span>
  }
  
  
  void CompileBroker::init_compiler_sweeper_threads() {
<span class="line-added">+   // Ensure any exceptions lead to vm_exit_during_initialization.</span>
    EXCEPTION_MARK;
  #if !defined(ZERO)
    assert(_c2_count &gt; 0 || _c1_count &gt; 0, &quot;No compilers?&quot;);
  #endif // !ZERO
    // Initialize the compilation queue
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,19 ***</span>
    }
  
    char name_buffer[256];
  
    for (int i = 0; i &lt; _c2_count; i++) {
      // Create a name for our thread.
      sprintf(name_buffer, &quot;%s CompilerThread%d&quot;, _compilers[1]-&gt;name(), i);
      Handle thread_oop = create_thread_oop(name_buffer, CHECK);
<span class="line-modified">!     jobject thread_handle = JNIHandles::make_global(thread_oop);</span>
      _compiler2_objects[i] = thread_handle;
      _compiler2_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="line-modified">!       JavaThread *ct = make_thread(thread_handle, _c2_compile_queue, _compilers[1], CHECK);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
<span class="line-new-header">--- 862,24 ---</span>
    }
  
    char name_buffer[256];
  
    for (int i = 0; i &lt; _c2_count; i++) {
<span class="line-added">+     jobject thread_handle = NULL;</span>
<span class="line-added">+     // Create all j.l.Thread objects for C1 and C2 threads here, but only one</span>
<span class="line-added">+     // for JVMCI compiler which can create further ones on demand.</span>
<span class="line-added">+     JVMCI_ONLY(if (!UseJVMCICompiler || !UseDynamicNumberOfCompilerThreads || i == 0) {)</span>
      // Create a name for our thread.
      sprintf(name_buffer, &quot;%s CompilerThread%d&quot;, _compilers[1]-&gt;name(), i);
      Handle thread_oop = create_thread_oop(name_buffer, CHECK);
<span class="line-modified">!     thread_handle = JNIHandles::make_global(thread_oop);</span>
<span class="line-added">+     JVMCI_ONLY(})</span>
      _compiler2_objects[i] = thread_handle;
      _compiler2_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="line-modified">!       JavaThread *ct = make_thread(thread_handle, _c2_compile_queue, _compilers[1], THREAD);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,11 ***</span>
      jobject thread_handle = JNIHandles::make_global(thread_oop);
      _compiler1_objects[i] = thread_handle;
      _compiler1_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="line-modified">!       JavaThread *ct = make_thread(thread_handle, _c1_compile_queue, _compilers[0], CHECK);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
<span class="line-new-header">--- 895,11 ---</span>
      jobject thread_handle = JNIHandles::make_global(thread_oop);
      _compiler1_objects[i] = thread_handle;
      _compiler1_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="line-modified">!       JavaThread *ct = make_thread(thread_handle, _c1_compile_queue, _compilers[0], THREAD);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 889,16 ***</span>
  
    if (MethodFlushing) {
      // Initialize the sweeper thread
      Handle thread_oop = create_thread_oop(&quot;Sweeper thread&quot;, CHECK);
      jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());
<span class="line-modified">!     make_thread(thread_handle, NULL, NULL, CHECK);</span>
    }
  }
  
<span class="line-modified">! void CompileBroker::possibly_add_compiler_threads() {</span>
<span class="line-removed">-   EXCEPTION_MARK;</span>
  
    julong available_memory = os::available_memory();
    // If SegmentedCodeCache is off, both values refer to the single heap (with type CodeBlobType::All).
    size_t available_cc_np  = CodeCache::unallocated_capacity(CodeBlobType::MethodNonProfiled),
           available_cc_p   = CodeCache::unallocated_capacity(CodeBlobType::MethodProfiled);
<span class="line-new-header">--- 914,15 ---</span>
  
    if (MethodFlushing) {
      // Initialize the sweeper thread
      Handle thread_oop = create_thread_oop(&quot;Sweeper thread&quot;, CHECK);
      jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());
<span class="line-modified">!     make_thread(thread_handle, NULL, NULL, THREAD);</span>
    }
  }
  
<span class="line-modified">! void CompileBroker::possibly_add_compiler_threads(Thread* THREAD) {</span>
  
    julong available_memory = os::available_memory();
    // If SegmentedCodeCache is off, both values refer to the single heap (with type CodeBlobType::All).
    size_t available_cc_np  = CodeCache::unallocated_capacity(CodeBlobType::MethodNonProfiled),
           available_cc_p   = CodeCache::unallocated_capacity(CodeBlobType::MethodProfiled);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 912,11 ***</span>
          _c2_compile_queue-&gt;size() / 2,
          (int)(available_memory / (200*M)),
          (int)(available_cc_np / (128*K)));
  
      for (int i = old_c2_count; i &lt; new_c2_count; i++) {
<span class="line-modified">!       JavaThread *ct = make_thread(compiler2_object(i), _c2_compile_queue, _compilers[1], CHECK);</span>
        if (ct == NULL) break;
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
<span class="line-new-header">--- 936,44 ---</span>
          _c2_compile_queue-&gt;size() / 2,
          (int)(available_memory / (200*M)),
          (int)(available_cc_np / (128*K)));
  
      for (int i = old_c2_count; i &lt; new_c2_count; i++) {
<span class="line-modified">! #if INCLUDE_JVMCI</span>
<span class="line-added">+       if (UseJVMCICompiler) {</span>
<span class="line-added">+         // Native compiler threads as used in C1/C2 can reuse the j.l.Thread</span>
<span class="line-added">+         // objects as their existence is completely hidden from the rest of</span>
<span class="line-added">+         // the VM (and those compiler threads can&#39;t call Java code to do the</span>
<span class="line-added">+         // creation anyway). For JVMCI we have to create new j.l.Thread objects</span>
<span class="line-added">+         // as they are visible and we can see unexpected thread lifecycle</span>
<span class="line-added">+         // transitions if we bind them to new JavaThreads.</span>
<span class="line-added">+         if (!THREAD-&gt;can_call_java()) break;</span>
<span class="line-added">+         char name_buffer[256];</span>
<span class="line-added">+         sprintf(name_buffer, &quot;%s CompilerThread%d&quot;, _compilers[1]-&gt;name(), i);</span>
<span class="line-added">+         Handle thread_oop;</span>
<span class="line-added">+         {</span>
<span class="line-added">+           // We have to give up the lock temporarily for the Java calls.</span>
<span class="line-added">+           MutexUnlocker mu(CompileThread_lock);</span>
<span class="line-added">+           thread_oop = create_thread_oop(name_buffer, THREAD);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+           if (TraceCompilerThreads) {</span>
<span class="line-added">+             ResourceMark rm;</span>
<span class="line-added">+             tty-&gt;print_cr(&quot;JVMCI compiler thread creation failed:&quot;);</span>
<span class="line-added">+             PENDING_EXCEPTION-&gt;print();</span>
<span class="line-added">+           }</span>
<span class="line-added">+           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Check if another thread has beaten us during the Java calls.</span>
<span class="line-added">+         if (_compilers[1]-&gt;num_compiler_threads() != i) break;</span>
<span class="line-added">+         jobject thread_handle = JNIHandles::make_global(thread_oop);</span>
<span class="line-added">+         assert(compiler2_object(i) == NULL, &quot;Old one must be released!&quot;);</span>
<span class="line-added">+         _compiler2_objects[i] = thread_handle;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       JavaThread *ct = make_thread(compiler2_object(i), _c2_compile_queue, _compilers[1], THREAD);</span>
        if (ct == NULL) break;
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 932,11 ***</span>
          _c1_compile_queue-&gt;size() / 4,
          (int)(available_memory / (100*M)),
          (int)(available_cc_p / (128*K)));
  
      for (int i = old_c1_count; i &lt; new_c1_count; i++) {
<span class="line-modified">!       JavaThread *ct = make_thread(compiler1_object(i), _c1_compile_queue, _compilers[0], CHECK);</span>
        if (ct == NULL) break;
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
<span class="line-new-header">--- 989,11 ---</span>
          _c1_compile_queue-&gt;size() / 4,
          (int)(available_memory / (100*M)),
          (int)(available_cc_p / (128*K)));
  
      for (int i = old_c1_count; i &lt; new_c1_count; i++) {
<span class="line-modified">!       JavaThread *ct = make_thread(compiler1_object(i), _c1_compile_queue, _compilers[0], THREAD);</span>
        if (ct == NULL) break;
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,11 ***</span>
    CompileTask* task     = NULL;
    CompileQueue* queue  = compile_queue(comp_level);
  
    // Acquire our lock.
    {
<span class="line-modified">!     MutexLocker locker(MethodCompileQueue_lock, thread);</span>
  
      // Make sure the method has not slipped into the queues since
      // last we checked; note that those checks were &quot;fast bail-outs&quot;.
      // Here we need to be more careful, see 14012000 below.
      if (compilation_is_in_queue(method)) {
<span class="line-new-header">--- 1100,11 ---</span>
    CompileTask* task     = NULL;
    CompileQueue* queue  = compile_queue(comp_level);
  
    // Acquire our lock.
    {
<span class="line-modified">!     MutexLocker locker(thread, MethodCompileQueue_lock);</span>
  
      // Make sure the method has not slipped into the queues since
      // last we checked; note that those checks were &quot;fast bail-outs&quot;.
      // Here we need to be more careful, see 14012000 below.
      if (compilation_is_in_queue(method)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1069,40 ***</span>
        // The compilation falls outside the allowed range.
        return;
      }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!     if (UseJVMCICompiler) {</span>
<span class="line-modified">!       if (blocking) {</span>
<span class="line-modified">!         // Don&#39;t allow blocking compiles for requests triggered by JVMCI.</span>
<span class="line-modified">!         if (thread-&gt;is_Compiler_thread()) {</span>
<span class="line-modified">!           blocking = false;</span>
<span class="line-removed">-         }</span>
  
          // Don&#39;t allow blocking compiles if inside a class initializer or while performing class loading
          vframeStream vfst((JavaThread*) thread);
          for (; !vfst.at_end(); vfst.next()) {
            if (vfst.method()-&gt;is_static_initializer() ||
                (vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) &amp;&amp;
                    vfst.method()-&gt;name() == vmSymbols::loadClass_name())) {
              blocking = false;
              break;
            }
          }
  
<span class="line-modified">!         // Don&#39;t allow blocking compilation requests to JVMCI</span>
<span class="line-modified">!         // if JVMCI itself is not yet initialized</span>
<span class="line-modified">!         if (!JVMCIRuntime::is_HotSpotJVMCIRuntime_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {</span>
<span class="line-modified">!           blocking = false;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown</span>
<span class="line-modified">!         // to avoid deadlock between compiler thread(s) and threads run at shutdown</span>
<span class="line-modified">!         // such as the DestroyJavaVM thread.</span>
<span class="line-modified">!         if (JVMCIRuntime::shutdown_called()) {</span>
<span class="line-modified">!           blocking = false;</span>
<span class="line-removed">-         }</span>
        }
      }
  #endif // INCLUDE_JVMCI
  
      // We will enter the compilation in the queue.
<span class="line-new-header">--- 1126,40 ---</span>
        // The compilation falls outside the allowed range.
        return;
      }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!     if (UseJVMCICompiler &amp;&amp; blocking) {</span>
<span class="line-modified">!       // Don&#39;t allow blocking compiles for requests triggered by JVMCI.</span>
<span class="line-modified">!       if (thread-&gt;is_Compiler_thread()) {</span>
<span class="line-modified">!         blocking = false;</span>
<span class="line-modified">!       }</span>
  
<span class="line-added">+       if (!UseJVMCINativeLibrary) {</span>
          // Don&#39;t allow blocking compiles if inside a class initializer or while performing class loading
          vframeStream vfst((JavaThread*) thread);
          for (; !vfst.at_end(); vfst.next()) {
            if (vfst.method()-&gt;is_static_initializer() ||
                (vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) &amp;&amp;
                    vfst.method()-&gt;name() == vmSymbols::loadClass_name())) {
              blocking = false;
              break;
            }
          }
<span class="line-added">+       }</span>
  
<span class="line-modified">!       // Don&#39;t allow blocking compilation requests to JVMCI</span>
<span class="line-modified">!       // if JVMCI itself is not yet initialized</span>
<span class="line-modified">!       if (!JVMCI::is_compiler_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {</span>
<span class="line-modified">!         blocking = false;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown</span>
<span class="line-modified">!       // to avoid deadlock between compiler thread(s) and threads run at shutdown</span>
<span class="line-modified">!       // such as the DestroyJavaVM thread.</span>
<span class="line-modified">!       if (JVMCI::shutdown_called()) {</span>
<span class="line-modified">!         blocking = false;</span>
        }
      }
  #endif // INCLUDE_JVMCI
  
      // We will enter the compilation in the queue.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1198,11 ***</span>
        compilation_is_prohibited(method, osr_bci, comp_level, directive-&gt;ExcludeOption)) {
      return NULL;
    }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!   if (comp-&gt;is_jvmci() &amp;&amp; !JVMCIRuntime::can_initialize_JVMCI()) {</span>
      return NULL;
    }
  #endif
  
    if (osr_bci == InvocationEntryBci) {
<span class="line-new-header">--- 1255,11 ---</span>
        compilation_is_prohibited(method, osr_bci, comp_level, directive-&gt;ExcludeOption)) {
      return NULL;
    }
  
  #if INCLUDE_JVMCI
<span class="line-modified">!   if (comp-&gt;is_jvmci() &amp;&amp; !JVMCI::can_initialize_JVMCI()) {</span>
      return NULL;
    }
  #endif
  
    if (osr_bci == InvocationEntryBci) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,11 ***</span>
      bool in_base_library;
      address adr = NativeLookup::lookup(method, in_base_library, THREAD);
      if (HAS_PENDING_EXCEPTION) {
        // In case of an exception looking up the method, we just forget
        // about it. The interpreter will kick-in and throw the exception.
<span class="line-modified">!       method-&gt;set_not_compilable(); // implies is_not_osr_compilable()</span>
        CLEAR_PENDING_EXCEPTION;
        return NULL;
      }
      assert(method-&gt;has_native_function(), &quot;must have native code by now&quot;);
    }
<span class="line-new-header">--- 1305,11 ---</span>
      bool in_base_library;
      address adr = NativeLookup::lookup(method, in_base_library, THREAD);
      if (HAS_PENDING_EXCEPTION) {
        // In case of an exception looking up the method, we just forget
        // about it. The interpreter will kick-in and throw the exception.
<span class="line-modified">!       method-&gt;set_not_compilable(&quot;NativeLookup::lookup failed&quot;); // implies is_not_osr_compilable()</span>
        CLEAR_PENDING_EXCEPTION;
        return NULL;
      }
      assert(method-&gt;has_native_function(), &quot;must have native code by now&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,19 ***</span>
    bool is_native = method-&gt;is_native();
    // Some compilers may not support the compilation of natives.
    AbstractCompiler *comp = compiler(comp_level);
    if (is_native &amp;&amp;
        (!CICompileNatives || comp == NULL || !comp-&gt;supports_native())) {
<span class="line-modified">!     method-&gt;set_not_compilable_quietly(comp_level);</span>
      return true;
    }
  
    bool is_osr = (osr_bci != standard_entry_bci);
    // Some compilers may not support on stack replacement.
    if (is_osr &amp;&amp;
        (!CICompileOSR || comp == NULL || !comp-&gt;supports_osr())) {
<span class="line-modified">!     method-&gt;set_not_osr_compilable(comp_level);</span>
      return true;
    }
  
    // The method may be explicitly excluded by the user.
    double scale;
<span class="line-new-header">--- 1433,19 ---</span>
    bool is_native = method-&gt;is_native();
    // Some compilers may not support the compilation of natives.
    AbstractCompiler *comp = compiler(comp_level);
    if (is_native &amp;&amp;
        (!CICompileNatives || comp == NULL || !comp-&gt;supports_native())) {
<span class="line-modified">!     method-&gt;set_not_compilable_quietly(&quot;native methods not supported&quot;, comp_level);</span>
      return true;
    }
  
    bool is_osr = (osr_bci != standard_entry_bci);
    // Some compilers may not support on stack replacement.
    if (is_osr &amp;&amp;
        (!CICompileOSR || comp == NULL || !comp-&gt;supports_osr())) {
<span class="line-modified">!     method-&gt;set_not_osr_compilable(&quot;OSR not supported&quot;, comp_level);</span>
      return true;
    }
  
    // The method may be explicitly excluded by the user.
    double scale;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1401,11 ***</span>
                   method-&gt;is_native() ? &quot;generation of native wrapper&quot; : &quot;compile&quot;,
                   (method-&gt;is_static() ? &quot; static&quot; : &quot;&quot;));
        method-&gt;print_short_name(tty);
        tty-&gt;cr();
      }
<span class="line-modified">!     method-&gt;set_not_compilable(comp_level, !quietly, &quot;excluded by CompileCommand&quot;);</span>
    }
  
    return false;
  }
  
<span class="line-new-header">--- 1458,11 ---</span>
                   method-&gt;is_native() ? &quot;generation of native wrapper&quot; : &quot;compile&quot;,
                   (method-&gt;is_static() ? &quot; static&quot; : &quot;&quot;));
        method-&gt;print_short_name(tty);
        tty-&gt;cr();
      }
<span class="line-modified">!     method-&gt;set_not_compilable(&quot;excluded by CompileCommand&quot;, comp_level, !quietly);</span>
    }
  
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1420,50 ***</span>
    int id;
    if (method-&gt;is_native()) {
      assert(!is_osr, &quot;can&#39;t be osr&quot;);
      // Adapters, native wrappers and method handle intrinsics
      // should be generated always.
<span class="line-modified">!     return Atomic::add(1, &amp;_compilation_id);</span>
    } else if (CICountOSR &amp;&amp; is_osr) {
<span class="line-modified">!     id = Atomic::add(1, &amp;_osr_compilation_id);</span>
      if (CIStartOSR &lt;= id &amp;&amp; id &lt; CIStopOSR) {
        return id;
      }
    } else {
<span class="line-modified">!     id = Atomic::add(1, &amp;_compilation_id);</span>
      if (CIStart &lt;= id &amp;&amp; id &lt; CIStop) {
        return id;
      }
    }
  
    // Method was not in the appropriate compilation range.
<span class="line-modified">!   method-&gt;set_not_compilable_quietly();</span>
    return 0;
  #else
    // CICountOSR is a develop flag and set to &#39;false&#39; by default. In a product built,
    // only _compilation_id is incremented.
<span class="line-modified">!   return Atomic::add(1, &amp;_compilation_id);</span>
  #endif
  }
  
  // ------------------------------------------------------------------
  // CompileBroker::assign_compile_id_unlocked
  //
  // Public wrapper for assign_compile_id that acquires the needed locks
  uint CompileBroker::assign_compile_id_unlocked(Thread* thread, const methodHandle&amp; method, int osr_bci) {
<span class="line-modified">!   MutexLocker locker(MethodCompileQueue_lock, thread);</span>
    return assign_compile_id(method, osr_bci);
  }
  
<span class="line-removed">- // ------------------------------------------------------------------</span>
<span class="line-removed">- // CompileBroker::preload_classes</span>
<span class="line-removed">- void CompileBroker::preload_classes(const methodHandle&amp; method, TRAPS) {</span>
<span class="line-removed">-   // Move this code over from c1_Compiler.cpp</span>
<span class="line-removed">-   ShouldNotReachHere();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // ------------------------------------------------------------------
  // CompileBroker::create_compile_task
  //
  // Create a CompileTask object representing the current request for
  // compilation.  Add this task to the queue.
<span class="line-new-header">--- 1477,42 ---</span>
    int id;
    if (method-&gt;is_native()) {
      assert(!is_osr, &quot;can&#39;t be osr&quot;);
      // Adapters, native wrappers and method handle intrinsics
      // should be generated always.
<span class="line-modified">!     return Atomic::add(&amp;_compilation_id, 1);</span>
    } else if (CICountOSR &amp;&amp; is_osr) {
<span class="line-modified">!     id = Atomic::add(&amp;_osr_compilation_id, 1);</span>
      if (CIStartOSR &lt;= id &amp;&amp; id &lt; CIStopOSR) {
        return id;
      }
    } else {
<span class="line-modified">!     id = Atomic::add(&amp;_compilation_id, 1);</span>
      if (CIStart &lt;= id &amp;&amp; id &lt; CIStop) {
        return id;
      }
    }
  
    // Method was not in the appropriate compilation range.
<span class="line-modified">!   method-&gt;set_not_compilable_quietly(&quot;Not in requested compile id range&quot;);</span>
    return 0;
  #else
    // CICountOSR is a develop flag and set to &#39;false&#39; by default. In a product built,
    // only _compilation_id is incremented.
<span class="line-modified">!   return Atomic::add(&amp;_compilation_id, 1);</span>
  #endif
  }
  
  // ------------------------------------------------------------------
  // CompileBroker::assign_compile_id_unlocked
  //
  // Public wrapper for assign_compile_id that acquires the needed locks
  uint CompileBroker::assign_compile_id_unlocked(Thread* thread, const methodHandle&amp; method, int osr_bci) {
<span class="line-modified">!   MutexLocker locker(thread, MethodCompileQueue_lock);</span>
    return assign_compile_id(method, osr_bci);
  }
  
  // ------------------------------------------------------------------
  // CompileBroker::create_compile_task
  //
  // Create a CompileTask object representing the current request for
  // compilation.  Add this task to the queue.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1501,15 ***</span>
   * JVMCI_COMPILATION_PROGRESS_WAIT_ATTEMPTS.
   *
   * @return true if this thread needs to free/recycle the task
   */
  bool CompileBroker::wait_for_jvmci_completion(JVMCICompiler* jvmci, CompileTask* task, JavaThread* thread) {
<span class="line-modified">!   MutexLocker waiter(task-&gt;lock(), thread);</span>
    int progress_wait_attempts = 0;
    int methods_compiled = jvmci-&gt;methods_compiled();
    while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever() &amp;&amp;
<span class="line-modified">!          task-&gt;lock()-&gt;wait(!Mutex::_no_safepoint_check_flag, JVMCI_COMPILATION_PROGRESS_WAIT_TIMESLICE)) {</span>
      CompilerThread* jvmci_compiler_thread = task-&gt;jvmci_compiler_thread();
  
      bool progress;
      if (jvmci_compiler_thread != NULL) {
        // If the JVMCI compiler thread is not blocked or suspended, we deem it to be making progress.
<span class="line-new-header">--- 1550,15 ---</span>
   * JVMCI_COMPILATION_PROGRESS_WAIT_ATTEMPTS.
   *
   * @return true if this thread needs to free/recycle the task
   */
  bool CompileBroker::wait_for_jvmci_completion(JVMCICompiler* jvmci, CompileTask* task, JavaThread* thread) {
<span class="line-modified">!   MonitorLocker ml(thread, task-&gt;lock());</span>
    int progress_wait_attempts = 0;
    int methods_compiled = jvmci-&gt;methods_compiled();
    while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever() &amp;&amp;
<span class="line-modified">!          ml.wait(JVMCI_COMPILATION_PROGRESS_WAIT_TIMESLICE)) {</span>
      CompilerThread* jvmci_compiler_thread = task-&gt;jvmci_compiler_thread();
  
      bool progress;
      if (jvmci_compiler_thread != NULL) {
        // If the JVMCI compiler thread is not blocked or suspended, we deem it to be making progress.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1552,29 ***</span>
    }
  
    assert(task-&gt;is_blocking(), &quot;can only wait on blocking task&quot;);
  
    JavaThread* thread = JavaThread::current();
<span class="line-removed">-   thread-&gt;set_blocked_on_compilation(true);</span>
  
    methodHandle method(thread, task-&gt;method());
    bool free_task;
  #if INCLUDE_JVMCI
    AbstractCompiler* comp = compiler(task-&gt;comp_level());
    if (comp-&gt;is_jvmci()) {
      free_task = wait_for_jvmci_completion((JVMCICompiler*) comp, task, thread);
    } else
  #endif
    {
<span class="line-modified">!     MutexLocker waiter(task-&gt;lock(), thread);</span>
      free_task = true;
      while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever()) {
<span class="line-modified">!       task-&gt;lock()-&gt;wait();</span>
      }
    }
  
<span class="line-removed">-   thread-&gt;set_blocked_on_compilation(false);</span>
    if (free_task) {
      if (is_compilation_disabled_forever()) {
        CompileTask::free(task);
        return;
      }
<span class="line-new-header">--- 1601,27 ---</span>
    }
  
    assert(task-&gt;is_blocking(), &quot;can only wait on blocking task&quot;);
  
    JavaThread* thread = JavaThread::current();
  
    methodHandle method(thread, task-&gt;method());
    bool free_task;
  #if INCLUDE_JVMCI
    AbstractCompiler* comp = compiler(task-&gt;comp_level());
    if (comp-&gt;is_jvmci()) {
      free_task = wait_for_jvmci_completion((JVMCICompiler*) comp, task, thread);
    } else
  #endif
    {
<span class="line-modified">!     MonitorLocker ml(thread, task-&gt;lock());</span>
      free_task = true;
      while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever()) {
<span class="line-modified">!       ml.wait();</span>
      }
    }
  
    if (free_task) {
      if (is_compilation_disabled_forever()) {
        CompileTask::free(task);
        return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1601,20 ***</span>
    CompilerThread* thread = CompilerThread::current();
    AbstractCompiler* comp = thread-&gt;compiler();
    // Final sanity check - the compiler object must exist
    guarantee(comp != NULL, &quot;Compiler object must exist&quot;);
  
<span class="line-removed">-   int system_dictionary_modification_counter;</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     MutexLocker locker(Compile_lock, thread);</span>
<span class="line-removed">-     system_dictionary_modification_counter = SystemDictionary::number_of_modifications();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    {
      // Must switch to native to allocate ci_env
      ThreadToNativeFromVM ttn(thread);
<span class="line-modified">!     ciEnv ci_env(NULL, system_dictionary_modification_counter);</span>
      // Cache Jvmti state
      ci_env.cache_jvmti_state();
      // Cache DTrace flags
      ci_env.cache_dtrace_flags();
  
<span class="line-new-header">--- 1648,14 ---</span>
    CompilerThread* thread = CompilerThread::current();
    AbstractCompiler* comp = thread-&gt;compiler();
    // Final sanity check - the compiler object must exist
    guarantee(comp != NULL, &quot;Compiler object must exist&quot;);
  
    {
      // Must switch to native to allocate ci_env
      ThreadToNativeFromVM ttn(thread);
<span class="line-modified">!     ciEnv ci_env((CompileTask*)NULL);</span>
      // Cache Jvmti state
      ci_env.cache_jvmti_state();
      // Cache DTrace flags
      ci_env.cache_dtrace_flags();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1649,11 ***</span>
   * out to be a problem.
   */
  void CompileBroker::shutdown_compiler_runtime(AbstractCompiler* comp, CompilerThread* thread) {
    // Free buffer blob, if allocated
    if (thread-&gt;get_buffer_blob() != NULL) {
<span class="line-modified">!     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::free(thread-&gt;get_buffer_blob());
    }
  
    if (comp-&gt;should_perform_shutdown()) {
      // There are two reasons for shutting down the compiler
<span class="line-new-header">--- 1690,11 ---</span>
   * out to be a problem.
   */
  void CompileBroker::shutdown_compiler_runtime(AbstractCompiler* comp, CompilerThread* thread) {
    // Free buffer blob, if allocated
    if (thread-&gt;get_buffer_blob() != NULL) {
<span class="line-modified">!     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::free(thread-&gt;get_buffer_blob());
    }
  
    if (comp-&gt;should_perform_shutdown()) {
      // There are two reasons for shutting down the compiler
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1701,11 ***</span>
    // Find Compiler number by its threadObj.
    oop compiler_obj = ct-&gt;threadObj();
    int compiler_number = 0;
    bool found = false;
    for (; compiler_number &lt; count; compiler_number++) {
<span class="line-modified">!     if (oopDesc::equals(JNIHandles::resolve_non_null(compiler_objects[compiler_number]), compiler_obj)) {</span>
        found = true;
        break;
      }
    }
    assert(found, &quot;Compiler must exist at this point&quot;);
<span class="line-new-header">--- 1742,11 ---</span>
    // Find Compiler number by its threadObj.
    oop compiler_obj = ct-&gt;threadObj();
    int compiler_number = 0;
    bool found = false;
    for (; compiler_number &lt; count; compiler_number++) {
<span class="line-modified">!     if (JNIHandles::resolve_non_null(compiler_objects[compiler_number]) == compiler_obj) {</span>
        found = true;
        break;
      }
    }
    assert(found, &quot;Compiler must exist at this point&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1740,11 ***</span>
  
    // First thread to get here will initialize the compiler interface
  
    {
      ASSERT_IN_VM;
<span class="line-modified">!     MutexLocker only_one (CompileThread_lock, thread);</span>
      if (!ciObjectFactory::is_initialized()) {
        ciObjectFactory::initialize();
      }
    }
  
<span class="line-new-header">--- 1781,11 ---</span>
  
    // First thread to get here will initialize the compiler interface
  
    {
      ASSERT_IN_VM;
<span class="line-modified">!     MutexLocker only_one (thread, CompileThread_lock);</span>
      if (!ciObjectFactory::is_initialized()) {
        ciObjectFactory::initialize();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1785,11 ***</span>
              tty-&gt;print_cr(&quot;Removing compiler thread %s after &quot; JLONG_FORMAT &quot; ms idle time&quot;,
                            thread-&gt;name(), thread-&gt;idle_time_millis());
            }
            // Free buffer blob, if allocated
            if (thread-&gt;get_buffer_blob() != NULL) {
<span class="line-modified">!             MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
              CodeCache::free(thread-&gt;get_buffer_blob());
            }
            return; // Stop this thread.
          }
        }
<span class="line-new-header">--- 1826,11 ---</span>
              tty-&gt;print_cr(&quot;Removing compiler thread %s after &quot; JLONG_FORMAT &quot; ms idle time&quot;,
                            thread-&gt;name(), thread-&gt;idle_time_millis());
            }
            // Free buffer blob, if allocated
            if (thread-&gt;get_buffer_blob() != NULL) {
<span class="line-modified">!             MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
              CodeCache::free(thread-&gt;get_buffer_blob());
            }
            return; // Stop this thread.
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1815,11 ***</span>
            task-&gt;set_failure_reason(&quot;compilation is disabled&quot;);
          }
        }
  
        if (UseDynamicNumberOfCompilerThreads) {
<span class="line-modified">!         possibly_add_compiler_threads();</span>
        }
      }
    }
  
    // Shut down compiler runtime
<span class="line-new-header">--- 1856,12 ---</span>
            task-&gt;set_failure_reason(&quot;compilation is disabled&quot;);
          }
        }
  
        if (UseDynamicNumberOfCompilerThreads) {
<span class="line-modified">!         possibly_add_compiler_threads(thread);</span>
<span class="line-added">+         assert(!thread-&gt;has_pending_exception(), &quot;should have been handled&quot;);</span>
        }
      }
    }
  
    // Shut down compiler runtime
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1915,11 ***</span>
  {
    ResourceMark rm;
    stringStream s;
    // Dump code cache  into a buffer before locking the tty,
    {
<span class="line-modified">!     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
    ttyLocker ttyl;
    tty-&gt;print(&quot;%s&quot;, s.as_string());
  }
<span class="line-new-header">--- 1957,11 ---</span>
  {
    ResourceMark rm;
    stringStream s;
    // Dump code cache  into a buffer before locking the tty,
    {
<span class="line-modified">!     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
    ttyLocker ttyl;
    tty-&gt;print(&quot;%s&quot;, s.as_string());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1929,11 ***</span>
    ResourceMark rm;
    stringStream s;
  
    // Dump code cache into a buffer
    {
<span class="line-modified">!     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
  
    char* remaining_log = s.as_string();
    while (*remaining_log != &#39;\0&#39;) {
<span class="line-new-header">--- 1971,11 ---</span>
    ResourceMark rm;
    stringStream s;
  
    // Dump code cache into a buffer
    {
<span class="line-modified">!     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
  
    char* remaining_log = s.as_string();
    while (*remaining_log != &#39;\0&#39;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1975,12 ***</span>
  }
  
  static void post_compilation_event(EventCompilation* event, CompileTask* task) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
<span class="line-modified">!   event-&gt;set_method(task-&gt;method());</span>
    event-&gt;set_compileId(task-&gt;compile_id());
    event-&gt;set_compileLevel(task-&gt;comp_level());
    event-&gt;set_succeded(task-&gt;is_success());
    event-&gt;set_isOsr(task-&gt;osr_bci() != CompileBroker::standard_entry_bci);
    event-&gt;set_codeSize((task-&gt;code() == NULL) ? 0 : task-&gt;code()-&gt;total_size());
    event-&gt;set_inlinedBytes(task-&gt;num_inlined_bytecodes());
<span class="line-new-header">--- 2017,14 ---</span>
  }
  
  static void post_compilation_event(EventCompilation* event, CompileTask* task) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
<span class="line-modified">!   assert(task != NULL, &quot;invariant&quot;);</span>
    event-&gt;set_compileId(task-&gt;compile_id());
<span class="line-added">+   event-&gt;set_compiler(task-&gt;compiler()-&gt;type());</span>
<span class="line-added">+   event-&gt;set_method(task-&gt;method());</span>
    event-&gt;set_compileLevel(task-&gt;comp_level());
    event-&gt;set_succeded(task-&gt;is_success());
    event-&gt;set_isOsr(task-&gt;osr_bci() != CompileBroker::standard_entry_bci);
    event-&gt;set_codeSize((task-&gt;code() == NULL) ? 0 : task-&gt;code()-&gt;total_size());
    event-&gt;set_inlinedBytes(task-&gt;num_inlined_bytecodes());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2030,12 ***</span>
      assert(!method-&gt;is_native(), &quot;no longer compile natives&quot;);
  
      // Look up matching directives
      directive = DirectivesStack::getMatchingDirective(method, comp);
  
<span class="line-modified">!     // Save information about this method in case of failure.</span>
<span class="line-modified">!     set_last_compile(thread, method, is_osr, task_level);</span>
  
      DTRACE_METHOD_COMPILE_BEGIN_PROBE(method, compiler_name(task_level));
    }
  
    should_break = directive-&gt;BreakAtExecuteOption || task-&gt;check_break_at_flags();
<span class="line-new-header">--- 2074,14 ---</span>
      assert(!method-&gt;is_native(), &quot;no longer compile natives&quot;);
  
      // Look up matching directives
      directive = DirectivesStack::getMatchingDirective(method, comp);
  
<span class="line-modified">!     // Update compile information when using perfdata.</span>
<span class="line-modified">!     if (UsePerfData) {</span>
<span class="line-added">+       update_compile_perf_data(thread, method, is_osr);</span>
<span class="line-added">+     }</span>
  
      DTRACE_METHOD_COMPILE_BEGIN_PROBE(method, compiler_name(task_level));
    }
  
    should_break = directive-&gt;BreakAtExecuteOption || task-&gt;check_break_at_flags();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2049,39 ***</span>
    int compilable = ciEnv::MethodCompilable;
    const char* failure_reason = NULL;
    bool failure_reason_on_C_heap = false;
    const char* retry_message = NULL;
  
<span class="line-removed">-   int system_dictionary_modification_counter;</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     MutexLocker locker(Compile_lock, thread);</span>
<span class="line-removed">-     system_dictionary_modification_counter = SystemDictionary::number_of_modifications();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
  #if INCLUDE_JVMCI
    if (UseJVMCICompiler &amp;&amp; comp != NULL &amp;&amp; comp-&gt;is_jvmci()) {
      JVMCICompiler* jvmci = (JVMCICompiler*) comp;
  
      TraceTime t1(&quot;compilation&quot;, &amp;time);
      EventCompilation event;
  
      // Skip redefined methods
      if (target_handle-&gt;is_old()) {
<span class="line-modified">!         failure_reason = &quot;redefined method&quot;;</span>
<span class="line-modified">!         retry_message = &quot;not retryable&quot;;</span>
<span class="line-modified">!         compilable = ciEnv::MethodCompilable_never;</span>
      } else {
<span class="line-modified">!         JVMCIEnv env(task, system_dictionary_modification_counter);</span>
<span class="line-modified">!         methodHandle method(thread, target_handle);</span>
<span class="line-modified">!         jvmci-&gt;compile_method(method, osr_bci, &amp;env);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         failure_reason = env.failure_reason();</span>
<span class="line-modified">!         failure_reason_on_C_heap = env.failure_reason_on_C_heap();</span>
<span class="line-modified">!         if (!env.retryable()) {</span>
<span class="line-modified">!           retry_message = &quot;not retryable&quot;;</span>
<span class="line-modified">!           compilable = ciEnv::MethodCompilable_not_at_tier;</span>
<span class="line-modified">!         }</span>
      }
      post_compile(thread, task, task-&gt;code() != NULL, NULL, compilable, failure_reason);
      if (event.should_commit()) {
        post_compilation_event(&amp;event, task);
      }
<span class="line-new-header">--- 2095,37 ---</span>
    int compilable = ciEnv::MethodCompilable;
    const char* failure_reason = NULL;
    bool failure_reason_on_C_heap = false;
    const char* retry_message = NULL;
  
  #if INCLUDE_JVMCI
    if (UseJVMCICompiler &amp;&amp; comp != NULL &amp;&amp; comp-&gt;is_jvmci()) {
      JVMCICompiler* jvmci = (JVMCICompiler*) comp;
  
      TraceTime t1(&quot;compilation&quot;, &amp;time);
      EventCompilation event;
  
      // Skip redefined methods
      if (target_handle-&gt;is_old()) {
<span class="line-modified">!       failure_reason = &quot;redefined method&quot;;</span>
<span class="line-modified">!       retry_message = &quot;not retryable&quot;;</span>
<span class="line-modified">!       compilable = ciEnv::MethodCompilable_never;</span>
      } else {
<span class="line-modified">!       JVMCICompileState compile_state(task);</span>
<span class="line-modified">!       JVMCIEnv env(thread, &amp;compile_state, __FILE__, __LINE__);</span>
<span class="line-modified">!       methodHandle method(thread, target_handle);</span>
<span class="line-modified">!       env.runtime()-&gt;compile_method(&amp;env, jvmci, method, osr_bci);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       failure_reason = compile_state.failure_reason();</span>
<span class="line-modified">!       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();</span>
<span class="line-modified">!       if (!compile_state.retryable()) {</span>
<span class="line-modified">!         retry_message = &quot;not retryable&quot;;</span>
<span class="line-modified">!         compilable = ciEnv::MethodCompilable_not_at_tier;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (task-&gt;code() == NULL) {</span>
<span class="line-added">+         assert(failure_reason != NULL, &quot;must specify failure_reason&quot;);</span>
<span class="line-added">+       }</span>
      }
      post_compile(thread, task, task-&gt;code() != NULL, NULL, compilable, failure_reason);
      if (event.should_commit()) {
        post_compilation_event(&amp;event, task);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2090,11 ***</span>
  #endif // INCLUDE_JVMCI
    {
      NoHandleMark  nhm;
      ThreadToNativeFromVM ttn(thread);
  
<span class="line-modified">!     ciEnv ci_env(task, system_dictionary_modification_counter);</span>
      if (should_break) {
        ci_env.set_break_at_compile(true);
      }
      if (should_log) {
        ci_env.set_log(thread-&gt;log());
<span class="line-new-header">--- 2134,11 ---</span>
  #endif // INCLUDE_JVMCI
    {
      NoHandleMark  nhm;
      ThreadToNativeFromVM ttn(thread);
  
<span class="line-modified">!     ciEnv ci_env(task);</span>
      if (should_break) {
        ci_env.set_break_at_compile(true);
      }
      if (should_log) {
        ci_env.set_log(thread-&gt;log());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2115,13 ***</span>
  
      if (comp == NULL) {
        ci_env.record_method_not_compilable(&quot;no compiler&quot;, !TieredCompilation);
      } else {
        if (WhiteBoxAPI &amp;&amp; WhiteBox::compilation_locked) {
<span class="line-modified">!         MonitorLockerEx locker(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
          while (WhiteBox::compilation_locked) {
<span class="line-modified">!           locker.wait(Mutex::_no_safepoint_check_flag);</span>
          }
        }
        comp-&gt;compile_method(&amp;ci_env, target, osr_bci, directive);
      }
  
<span class="line-new-header">--- 2159,13 ---</span>
  
      if (comp == NULL) {
        ci_env.record_method_not_compilable(&quot;no compiler&quot;, !TieredCompilation);
      } else {
        if (WhiteBoxAPI &amp;&amp; WhiteBox::compilation_locked) {
<span class="line-modified">!         MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
          while (WhiteBox::compilation_locked) {
<span class="line-modified">!           locker.wait();</span>
          }
        }
        comp-&gt;compile_method(&amp;ci_env, target, osr_bci, directive);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2195,19 ***</span>
    }
    // Disable compilation, if required.
    switch (compilable) {
    case ciEnv::MethodCompilable_never:
      if (is_osr)
<span class="line-modified">!       method-&gt;set_not_osr_compilable_quietly();</span>
      else
<span class="line-modified">!       method-&gt;set_not_compilable_quietly();</span>
      break;
    case ciEnv::MethodCompilable_not_at_tier:
      if (is_osr)
<span class="line-modified">!       method-&gt;set_not_osr_compilable_quietly(task_level);</span>
      else
<span class="line-modified">!       method-&gt;set_not_compilable_quietly(task_level);</span>
      break;
    }
  
    // Note that the queued_for_compilation bits are cleared without
    // protection of a mutex. [They were set by the requester thread,
<span class="line-new-header">--- 2239,19 ---</span>
    }
    // Disable compilation, if required.
    switch (compilable) {
    case ciEnv::MethodCompilable_never:
      if (is_osr)
<span class="line-modified">!       method-&gt;set_not_osr_compilable_quietly(&quot;MethodCompilable_never&quot;);</span>
      else
<span class="line-modified">!       method-&gt;set_not_compilable_quietly(&quot;MethodCompilable_never&quot;);</span>
      break;
    case ciEnv::MethodCompilable_not_at_tier:
      if (is_osr)
<span class="line-modified">!       method-&gt;set_not_osr_compilable_quietly(&quot;MethodCompilable_not_at_tier&quot;, task_level);</span>
      else
<span class="line-modified">!       method-&gt;set_not_compilable_quietly(&quot;MethodCompilable_not_at_tier&quot;, task_level);</span>
      break;
    }
  
    // Note that the queued_for_compilation bits are cleared without
    // protection of a mutex. [They were set by the requester thread,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2262,62 ***</span>
      CodeCache::report_codemem_full(code_blob_type, should_print_compiler_warning());
    }
  }
  
  // ------------------------------------------------------------------
<span class="line-modified">! // CompileBroker::set_last_compile</span>
  //
  // Record this compilation for debugging purposes.
<span class="line-modified">! void CompileBroker::set_last_compile(CompilerThread* thread, const methodHandle&amp; method, bool is_osr, int comp_level) {</span>
    ResourceMark rm;
    char* method_name = method-&gt;name()-&gt;as_C_string();
<span class="line-removed">-   strncpy(_last_method_compiled, method_name, CompileBroker::name_buffer_length);</span>
<span class="line-removed">-   _last_method_compiled[CompileBroker::name_buffer_length - 1] = &#39;\0&#39;; // ensure null terminated</span>
    char current_method[CompilerCounters::cmname_buffer_length];
    size_t maxLen = CompilerCounters::cmname_buffer_length;
  
<span class="line-modified">!   if (UsePerfData) {</span>
<span class="line-removed">-     const char* class_name = method-&gt;method_holder()-&gt;name()-&gt;as_C_string();</span>
  
<span class="line-modified">!     size_t s1len = strlen(class_name);</span>
<span class="line-modified">!     size_t s2len = strlen(method_name);</span>
  
<span class="line-modified">!     // check if we need to truncate the string</span>
<span class="line-modified">!     if (s1len + s2len + 2 &gt; maxLen) {</span>
  
<span class="line-modified">!       // the strategy is to lop off the leading characters of the</span>
<span class="line-modified">!       // class name and the trailing characters of the method name.</span>
  
<span class="line-modified">!       if (s2len + 2 &gt; maxLen) {</span>
<span class="line-modified">!         // lop of the entire class name string, let snprintf handle</span>
<span class="line-modified">!         // truncation of the method name.</span>
<span class="line-modified">!         class_name += s1len; // null string</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       else {</span>
<span class="line-modified">!         // lop off the extra characters from the front of the class name</span>
<span class="line-modified">!         class_name += ((s1len + s2len + 2) - maxLen);</span>
<span class="line-removed">-       }</span>
      }
<span class="line-removed">- </span>
<span class="line-removed">-     jio_snprintf(current_method, maxLen, &quot;%s %s&quot;, class_name, method_name);</span>
    }
  
    if (CICountOSR &amp;&amp; is_osr) {
<span class="line-modified">!     _last_compile_type = osr_compile;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _last_compile_type = normal_compile;</span>
    }
<span class="line-removed">-   _last_compile_level = comp_level;</span>
  
<span class="line-modified">!   if (UsePerfData) {</span>
<span class="line-modified">!     CompilerCounters* counters = thread-&gt;counters();</span>
<span class="line-modified">!     counters-&gt;set_current_method(current_method);</span>
<span class="line-removed">-     counters-&gt;set_compile_type((jlong)_last_compile_type);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- </span>
  // ------------------------------------------------------------------
  // CompileBroker::push_jni_handle_block
  //
  // Push on a new block of JNI handles.
  void CompileBroker::push_jni_handle_block() {
<span class="line-new-header">--- 2306,53 ---</span>
      CodeCache::report_codemem_full(code_blob_type, should_print_compiler_warning());
    }
  }
  
  // ------------------------------------------------------------------
<span class="line-modified">! // CompileBroker::update_compile_perf_data</span>
  //
  // Record this compilation for debugging purposes.
<span class="line-modified">! void CompileBroker::update_compile_perf_data(CompilerThread* thread, const methodHandle&amp; method, bool is_osr) {</span>
    ResourceMark rm;
    char* method_name = method-&gt;name()-&gt;as_C_string();
    char current_method[CompilerCounters::cmname_buffer_length];
    size_t maxLen = CompilerCounters::cmname_buffer_length;
  
<span class="line-modified">!   const char* class_name = method-&gt;method_holder()-&gt;name()-&gt;as_C_string();</span>
  
<span class="line-modified">!   size_t s1len = strlen(class_name);</span>
<span class="line-modified">!   size_t s2len = strlen(method_name);</span>
  
<span class="line-modified">!   // check if we need to truncate the string</span>
<span class="line-modified">!   if (s1len + s2len + 2 &gt; maxLen) {</span>
  
<span class="line-modified">!     // the strategy is to lop off the leading characters of the</span>
<span class="line-modified">!     // class name and the trailing characters of the method name.</span>
  
<span class="line-modified">!     if (s2len + 2 &gt; maxLen) {</span>
<span class="line-modified">!       // lop of the entire class name string, let snprintf handle</span>
<span class="line-modified">!       // truncation of the method name.</span>
<span class="line-modified">!       class_name += s1len; // null string</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     else {</span>
<span class="line-modified">!       // lop off the extra characters from the front of the class name</span>
<span class="line-modified">!       class_name += ((s1len + s2len + 2) - maxLen);</span>
      }
    }
  
<span class="line-added">+   jio_snprintf(current_method, maxLen, &quot;%s %s&quot;, class_name, method_name);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int last_compile_type = normal_compile;</span>
    if (CICountOSR &amp;&amp; is_osr) {
<span class="line-modified">!     last_compile_type = osr_compile;</span>
    }
  
<span class="line-modified">!   CompilerCounters* counters = thread-&gt;counters();</span>
<span class="line-modified">!   counters-&gt;set_current_method(current_method);</span>
<span class="line-modified">!   counters-&gt;set_compile_type((jlong) last_compile_type);</span>
  }
  
  // ------------------------------------------------------------------
  // CompileBroker::push_jni_handle_block
  //
  // Push on a new block of JNI handles.
  void CompileBroker::push_jni_handle_block() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2616,25 ***</span>
    tty-&gt;cr();
    tty-&gt;print_cr(&quot;  nmethod code size         : %8d bytes&quot;, nmethods_code_size);
    tty-&gt;print_cr(&quot;  nmethod total size        : %8d bytes&quot;, nmethods_size);
  }
  
<span class="line-removed">- // Debugging output for failure</span>
<span class="line-removed">- void CompileBroker::print_last_compile() {</span>
<span class="line-removed">-   if (_last_compile_level != CompLevel_none &amp;&amp;</span>
<span class="line-removed">-       compiler(_last_compile_level) != NULL &amp;&amp;</span>
<span class="line-removed">-       _last_compile_type != no_compile) {</span>
<span class="line-removed">-     if (_last_compile_type == osr_compile) {</span>
<span class="line-removed">-       tty-&gt;print_cr(&quot;Last parse:  [osr]%d+++(%d) %s&quot;,</span>
<span class="line-removed">-                     _osr_compilation_id, _last_compile_level, _last_method_compiled);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       tty-&gt;print_cr(&quot;Last parse:  %d+++(%d) %s&quot;,</span>
<span class="line-removed">-                     _compilation_id, _last_compile_level, _last_method_compiled);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Print general/accumulated JIT information.
  void CompileBroker::print_info(outputStream *out) {
    if (out == NULL) out = tty;
    out-&gt;cr();
    out-&gt;print_cr(&quot;======================&quot;);
<span class="line-new-header">--- 2651,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2664,11 ***</span>
  // Note: tty_lock must not be held upon entry to this function.
  //       Print functions called from herein do &quot;micro-locking&quot; on tty_lock.
  //       That&#39;s a tradeoff which keeps together important blocks of output.
  //       At the same time, continuous tty_lock hold time is kept in check,
  //       preventing concurrently printing threads from stalling a long time.
<span class="line-modified">! void CompileBroker::print_heapinfo(outputStream* out, const char* function, const char* granularity) {</span>
    TimeStamp ts_total;
    TimeStamp ts_global;
    TimeStamp ts;
  
    bool allFun = !strcmp(function, &quot;all&quot;);
<span class="line-new-header">--- 2684,11 ---</span>
  // Note: tty_lock must not be held upon entry to this function.
  //       Print functions called from herein do &quot;micro-locking&quot; on tty_lock.
  //       That&#39;s a tradeoff which keeps together important blocks of output.
  //       At the same time, continuous tty_lock hold time is kept in check,
  //       preventing concurrently printing threads from stalling a long time.
<span class="line-modified">! void CompileBroker::print_heapinfo(outputStream* out, const char* function, size_t granularity) {</span>
    TimeStamp ts_total;
    TimeStamp ts_global;
    TimeStamp ts;
  
    bool allFun = !strcmp(function, &quot;all&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2705,29 ***</span>
    // across user interaction.
    // Acquire this lock before acquiring the CodeCache_lock.
    // CodeHeapStateAnalytics_lock could be held by a concurrent thread for a long time,
    // leading to an unnecessarily long hold time of the CodeCache_lock.
    ts.update(); // record starting point
<span class="line-modified">!   MutexLockerEx mu1(CodeHeapStateAnalytics_lock, Mutex::_no_safepoint_check_flag);</span>
    out-&gt;print_cr(&quot;\n__ CodeHeapStateAnalytics lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
  
    // If we serve an &quot;allFun&quot; call, it is beneficial to hold the CodeCache_lock
    // for the entire duration of aggregation and printing. That makes sure
    // we see a consistent picture and do not run into issues caused by
    // the CodeHeap being altered concurrently.
<span class="line-modified">!   Monitor* global_lock   = allFun ? CodeCache_lock : NULL;</span>
<span class="line-modified">!   Monitor* function_lock = allFun ? NULL : CodeCache_lock;</span>
    ts_global.update(); // record starting point
<span class="line-modified">!   MutexLockerEx mu2(global_lock, Mutex::_no_safepoint_check_flag);</span>
    if (global_lock != NULL) {
      out-&gt;print_cr(&quot;\n__ CodeCache (global) lock wait took %10.3f seconds _________\n&quot;, ts_global.seconds());
      ts_global.update(); // record starting point
    }
  
    if (aggregate) {
      ts.update(); // record starting point
<span class="line-modified">!     MutexLockerEx mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      if (function_lock != NULL) {
        out-&gt;print_cr(&quot;\n__ CodeCache (function) lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
      }
  
      ts.update(); // record starting point
<span class="line-new-header">--- 2725,29 ---</span>
    // across user interaction.
    // Acquire this lock before acquiring the CodeCache_lock.
    // CodeHeapStateAnalytics_lock could be held by a concurrent thread for a long time,
    // leading to an unnecessarily long hold time of the CodeCache_lock.
    ts.update(); // record starting point
<span class="line-modified">!   MutexLocker mu1(CodeHeapStateAnalytics_lock, Mutex::_no_safepoint_check_flag);</span>
    out-&gt;print_cr(&quot;\n__ CodeHeapStateAnalytics lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
  
    // If we serve an &quot;allFun&quot; call, it is beneficial to hold the CodeCache_lock
    // for the entire duration of aggregation and printing. That makes sure
    // we see a consistent picture and do not run into issues caused by
    // the CodeHeap being altered concurrently.
<span class="line-modified">!   Mutex* global_lock   = allFun ? CodeCache_lock : NULL;</span>
<span class="line-modified">!   Mutex* function_lock = allFun ? NULL : CodeCache_lock;</span>
    ts_global.update(); // record starting point
<span class="line-modified">!   MutexLocker mu2(global_lock, Mutex::_no_safepoint_check_flag);</span>
    if (global_lock != NULL) {
      out-&gt;print_cr(&quot;\n__ CodeCache (global) lock wait took %10.3f seconds _________\n&quot;, ts_global.seconds());
      ts_global.update(); // record starting point
    }
  
    if (aggregate) {
      ts.update(); // record starting point
<span class="line-modified">!     MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      if (function_lock != NULL) {
        out-&gt;print_cr(&quot;\n__ CodeCache (function) lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
      }
  
      ts.update(); // record starting point
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2743,11 ***</span>
    if (methodSpace) CodeCache::print_space(out);
    if (methodAge) CodeCache::print_age(out);
    if (methodNames) {
      // print_names() has shown to be sensitive to concurrent CodeHeap modifications.
      // Therefore, request  the CodeCache_lock before calling...
<span class="line-modified">!     MutexLockerEx mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_names(out);
    }
    if (discard) CodeCache::discard(out);
  
    if (global_lock != NULL) {
<span class="line-new-header">--- 2763,11 ---</span>
    if (methodSpace) CodeCache::print_space(out);
    if (methodAge) CodeCache::print_age(out);
    if (methodNames) {
      // print_names() has shown to be sensitive to concurrent CodeHeap modifications.
      // Therefore, request  the CodeCache_lock before calling...
<span class="line-modified">!     MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_names(out);
    }
    if (discard) CodeCache::discard(out);
  
    if (global_lock != NULL) {
</pre>
<center><a href="abstractCompiler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileBroker.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
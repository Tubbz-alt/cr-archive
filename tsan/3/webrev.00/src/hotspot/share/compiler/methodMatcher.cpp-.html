<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/compiler/methodMatcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/methodMatcher.hpp&quot;
 27 #include &quot;memory/oopFactory.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 
 31 // The JVM specification defines the allowed characters.
 32 // Tokens that are disallowed by the JVM specification can have
 33 // a meaning to the parser so we need to include them here.
 34 // The parser does not enforce all rules of the JVMS - a successful parse
 35 // does not mean that it is an allowed name. Illegal names will
 36 // be ignored since they never can match a class or method.
 37 //
 38 // &#39;\0&#39; and 0xf0-0xff are disallowed in constant string values
 39 // 0x20 &#39; &#39;, 0x09 &#39;\t&#39; and, 0x2c &#39;,&#39; are used in the matching
 40 // 0x5b &#39;[&#39; and 0x5d &#39;]&#39; can not be used because of the matcher
 41 // 0x28 &#39;(&#39; and 0x29 &#39;)&#39; are used for the signature
 42 // 0x2e &#39;.&#39; is always replaced before the matching
 43 // 0x2f &#39;/&#39; is only used in the class name as package separator
 44 
 45 #define RANGEBASE &quot;\x1\x2\x3\x4\x5\x6\x7\x8\xa\xb\xc\xd\xe\xf&quot; \
 46     &quot;\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f&quot; \
 47     &quot;\x21\x22\x23\x24\x25\x26\x27\x2a\x2b\x2c\x2d&quot; \
 48     &quot;\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f&quot; \
 49     &quot;\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f&quot; \
 50     &quot;\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5c\x5e\x5f&quot; \
 51     &quot;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f&quot; \
 52     &quot;\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f&quot; \
 53     &quot;\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f&quot; \
 54     &quot;\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f&quot; \
 55     &quot;\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf&quot; \
 56     &quot;\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf&quot; \
 57     &quot;\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf&quot; \
 58     &quot;\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf&quot; \
 59     &quot;\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef&quot;
 60 
 61 #define RANGE0 &quot;[*&quot; RANGEBASE &quot;]&quot;
 62 #define RANGESLASH &quot;[*&quot; RANGEBASE &quot;/]&quot;
 63 
 64 MethodMatcher::MethodMatcher():
 65     _class_name(NULL)
 66   , _method_name(NULL)
 67   , _signature(NULL)
 68   , _class_mode(Exact)
 69   , _method_mode(Exact) {
 70 }
 71 
 72 MethodMatcher::~MethodMatcher() {
 73   if (_class_name != NULL) {
 74     _class_name-&gt;decrement_refcount();
 75   }
 76   if (_method_name != NULL) {
 77     _method_name-&gt;decrement_refcount();
 78   }
 79   if (_signature != NULL) {
 80     _signature-&gt;decrement_refcount();
 81   }
 82 }
 83 
 84 void MethodMatcher::init(Symbol* class_name, Mode class_mode,
 85                              Symbol* method_name, Mode method_mode,
 86                              Symbol* signature) {
 87  _class_mode = class_mode;
 88  _method_mode = method_mode;
 89  _class_name = class_name;
 90  _method_name = method_name;
 91  _signature = signature;
 92 }
 93 
 94 bool MethodMatcher::canonicalize(char * line, const char *&amp; error_msg) {
 95   char* colon = strstr(line, &quot;::&quot;);
 96   bool have_colon = (colon != NULL);
 97   if (have_colon) {
 98     // Don&#39;t allow multiple &#39;::&#39;
 99     if (colon[2] != &#39;\0&#39;) {
100       if (strstr(colon+2, &quot;::&quot;)) {
101         error_msg = &quot;Method pattern only allows one &#39;::&#39; allowed&quot;;
102         return false;
103       }
104     }
105 
106     bool in_signature = false;
107     char* pos = line;
108     if (pos != NULL) {
109       for (char* lp = pos + 1; *lp != &#39;\0&#39;; lp++) {
110         if (*lp == &#39;(&#39;) {
111           break;
112         }
113 
114         if (*lp == &#39;/&#39;) {
115           error_msg = &quot;Method pattern uses &#39;/&#39; together with &#39;::&#39;&quot;;
116           return false;
117         }
118       }
119     }
120   } else {
121     // Don&#39;t allow mixed package separators
122     char* pos = strchr(line, &#39;.&#39;);
123     bool in_signature = false;
124     if (pos != NULL) {
125       for (char* lp = pos + 1; *lp != &#39;\0&#39;; lp++) {
126         if (*lp == &#39;(&#39;) {
127           in_signature = true;
128         }
129 
130         // After any comma the method pattern has ended
131         if (*lp == &#39;,&#39;) {
132           break;
133         }
134 
135         if (!in_signature &amp;&amp; (*lp == &#39;/&#39;)) {
136           error_msg = &quot;Method pattern uses mixed &#39;/&#39; and &#39;.&#39; package separators&quot;;
137           return false;
138         }
139 
140         if (*lp == &#39;.&#39;) {
141           error_msg = &quot;Method pattern uses multiple &#39;.&#39; in pattern&quot;;
142           return false;
143         }
144       }
145     }
146   }
147 
148   for (char* lp = line; *lp != &#39;\0&#39;; lp++) {
149     // Allow &#39;.&#39; to separate the class name from the method name.
150     // This is the preferred spelling of methods:
151     //      exclude java/lang/String.indexOf(I)I
152     // Allow &#39;,&#39; for spaces (eases command line quoting).
153     //      exclude,java/lang/String.indexOf
154     // For backward compatibility, allow space as separator also.
155     //      exclude java/lang/String indexOf
156     //      exclude,java/lang/String,indexOf
157     // For easy cut-and-paste of method names, allow VM output format
158     // as produced by Method::print_short_name:
159     //      exclude java.lang.String::indexOf
160     // For simple implementation convenience here, convert them all to space.
161 
162     if (have_colon) {
163       if (*lp == &#39;.&#39;)  *lp = &#39;/&#39;;   // dots build the package prefix
164       if (*lp == &#39;:&#39;)  *lp = &#39; &#39;;
165     }
166     if (*lp == &#39;,&#39; || *lp == &#39;.&#39;)  *lp = &#39; &#39;;
167   }
168   return true;
169 }
170 
171 bool MethodMatcher::match(Symbol* candidate, Symbol* match, Mode match_mode) const {
172   if (match_mode == Any) {
173     return true;
174   }
175 
176   if (match_mode == Exact) {
177     return candidate == match;
178   }
179 
180   ResourceMark rm;
181   const char * candidate_string = candidate-&gt;as_C_string();
182   const char * match_string = match-&gt;as_C_string();
183 
184   switch (match_mode) {
185   case Prefix:
186     return strstr(candidate_string, match_string) == candidate_string;
187 
188   case Suffix: {
189     size_t clen = strlen(candidate_string);
190     size_t mlen = strlen(match_string);
191     return clen &gt;= mlen &amp;&amp; strcmp(candidate_string + clen - mlen, match_string) == 0;
192   }
193 
194   case Substring:
195     return strstr(candidate_string, match_string) != NULL;
196 
197   default:
198     return false;
199   }
200 }
201 
202 static MethodMatcher::Mode check_mode(char name[], const char*&amp; error_msg) {
203   int match = MethodMatcher::Exact;
204   if (name[0] == &#39;*&#39;) {
205     if (strlen(name) == 1) {
206       return MethodMatcher::Any;
207     }
208     match |= MethodMatcher::Suffix;
209     memmove(name, name + 1, strlen(name + 1) + 1);
210   }
211 
212   size_t len = strlen(name);
213   if (len &gt; 0 &amp;&amp; name[len - 1] == &#39;*&#39;) {
214     match |= MethodMatcher::Prefix;
215     name[--len] = &#39;\0&#39;;
216   }
217 
218   if (strlen(name) == 0) {
219     error_msg = &quot;** Not a valid pattern&quot;;
220     return MethodMatcher::Any;
221   }
222 
223   if (strstr(name, &quot;*&quot;) != NULL) {
224     error_msg = &quot; Embedded * not allowed&quot;;
225     return MethodMatcher::Unknown;
226   }
227   return (MethodMatcher::Mode)match;
228 }
229 
230 // Skip any leading spaces
231 void skip_leading_spaces(char*&amp; line, int* total_bytes_read ) {
232   int bytes_read = 0;
233   sscanf(line, &quot;%*[ \t]%n&quot;, &amp;bytes_read);
234   if (bytes_read &gt; 0) {
235     line += bytes_read;
236     *total_bytes_read += bytes_read;
237   }
238 }
239 
240 PRAGMA_DIAG_PUSH
241 // warning C4189: The file contains a character that cannot be represented
242 //                in the current code page
243 PRAGMA_DISABLE_MSVC_WARNING(4819)
244 void MethodMatcher::parse_method_pattern(char*&amp; line, const char*&amp; error_msg, MethodMatcher* matcher) {
245   MethodMatcher::Mode c_match;
246   MethodMatcher::Mode m_match;
247   char class_name[256] = {0};
248   char method_name[256] = {0};
249   char sig[1024] = {0};
250   int bytes_read = 0;
251   int total_bytes_read = 0;
252 
253   assert(error_msg == NULL, &quot;Dont call here with error_msg already set&quot;);
254 
255   if (!MethodMatcher::canonicalize(line, error_msg)) {
256     assert(error_msg != NULL, &quot;Message must be set if parsing failed&quot;);
257     return;
258   }
259 
260   skip_leading_spaces(line, &amp;total_bytes_read);
261 
262   if (2 == sscanf(line, &quot;%255&quot; RANGESLASH &quot;%*[ ]&quot; &quot;%255&quot;  RANGE0 &quot;%n&quot;, class_name, method_name, &amp;bytes_read)) {
263     c_match = check_mode(class_name, error_msg);
264     m_match = check_mode(method_name, error_msg);
265 
266     if ((strchr(class_name, &#39;&lt;&#39;) != NULL) || (strchr(class_name, &#39;&gt;&#39;) != NULL)) {
267       error_msg = &quot;Chars &#39;&lt;&#39; and &#39;&gt;&#39; not allowed in class name&quot;;
268       return;
269     }
270     if ((strchr(method_name, &#39;&lt;&#39;) != NULL) || (strchr(method_name, &#39;&gt;&#39;) != NULL)) {
271       if ((strncmp(&quot;&lt;init&gt;&quot;, method_name, 255) != 0) &amp;&amp; (strncmp(&quot;&lt;clinit&gt;&quot;, method_name, 255) != 0)) {
272         error_msg = &quot;Chars &#39;&lt;&#39; and &#39;&gt;&#39; only allowed in &lt;init&gt; and &lt;clinit&gt;&quot;;
273         return;
274       }
275     }
276 
277     if (c_match == MethodMatcher::Unknown || m_match == MethodMatcher::Unknown) {
278       assert(error_msg != NULL, &quot;Must have been set by check_mode()&quot;);
279       return;
280     }
281 
282     EXCEPTION_MARK;
283     Symbol* signature = NULL;
284     line += bytes_read;
285     bytes_read = 0;
286 
287     skip_leading_spaces(line, &amp;total_bytes_read);
288 
289     // there might be a signature following the method.
290     // signatures always begin with ( so match that by hand
291     if (line[0] == &#39;(&#39;) {
292       line++;
293       sig[0] = &#39;(&#39;;
294       // scan the rest
295       if (1 == sscanf(line, &quot;%1022[[);/&quot; RANGEBASE &quot;]%n&quot;, sig+1, &amp;bytes_read)) {
296         if (strchr(sig, &#39;*&#39;) != NULL) {
297           error_msg = &quot; Wildcard * not allowed in signature&quot;;
298           return;
299         }
300         line += bytes_read;
301       }
302       signature = SymbolTable::new_symbol(sig, CHECK);
303     }
304     Symbol* c_name = SymbolTable::new_symbol(class_name, CHECK);
305     Symbol* m_name = SymbolTable::new_symbol(method_name, CHECK);
306 
307     matcher-&gt;init(c_name, c_match, m_name, m_match, signature);
308     return;
309   } else {
310     error_msg = &quot;Could not parse method pattern&quot;;
311   }
312 }
313 PRAGMA_DIAG_POP
314 
315 bool MethodMatcher::matches(const methodHandle&amp; method) const {
316   Symbol* class_name  = method-&gt;method_holder()-&gt;name();
317   Symbol* method_name = method-&gt;name();
318   Symbol* signature = method-&gt;signature();
319 
320   if (match(class_name, this-&gt;class_name(), _class_mode) &amp;&amp;
321       match(method_name, this-&gt;method_name(), _method_mode) &amp;&amp;
322       ((this-&gt;signature() == NULL) || match(signature, this-&gt;signature(), Prefix))) {
323     return true;
324   }
325   return false;
326 }
327 
328 void MethodMatcher::print_symbol(outputStream* st, Symbol* h, Mode mode) {
329   if (mode == Suffix || mode == Substring || mode == Any) {
330     st-&gt;print(&quot;*&quot;);
331   }
332   if (mode != Any) {
333     h-&gt;print_utf8_on(st);
334   }
335   if (mode == Prefix || mode == Substring) {
336     st-&gt;print(&quot;*&quot;);
337   }
338 }
339 
340 void MethodMatcher::print_base(outputStream* st) {
341   ResourceMark rm;
342 
343   print_symbol(st, class_name(), _class_mode);
344   st-&gt;print(&quot;.&quot;);
345   print_symbol(st, method_name(), _method_mode);
346   if (signature() != NULL) {
347     signature()-&gt;print_utf8_on(st);
348   }
349 }
350 
351 BasicMatcher* BasicMatcher::parse_method_pattern(char* line, const char*&amp; error_msg) {
352   assert(error_msg == NULL, &quot;Don&#39;t call here with error_msg already set&quot;);
353   BasicMatcher* bm = new BasicMatcher();
354   MethodMatcher::parse_method_pattern(line, error_msg, bm);
355   if (error_msg != NULL) {
356     delete bm;
357     return NULL;
358   }
359 
360   // check for bad trailing characters
361   int bytes_read = 0;
362   sscanf(line, &quot;%*[ \t]%n&quot;, &amp;bytes_read);
363   if (line[bytes_read] != &#39;\0&#39;) {
364     error_msg = &quot;Unrecognized trailing text after method pattern&quot;;
365     delete bm;
366     return NULL;
367   }
368   return bm;
369 }
370 
371 bool BasicMatcher::match(const methodHandle&amp; method) {
372   for (BasicMatcher* current = this; current != NULL; current = current-&gt;next()) {
373     if (current-&gt;matches(method)) {
374       return true;
375     }
376   }
377   return false;
378 }
379 
380 void InlineMatcher::print(outputStream* st) {
381   if (_inline_action == InlineMatcher::force_inline) {
382     st-&gt;print(&quot;+&quot;);
383   } else {
384     st-&gt;print(&quot;-&quot;);
385   }
386   print_base(st);
387 }
388 
389 InlineMatcher* InlineMatcher::parse_method_pattern(char* line, const char*&amp; error_msg) {
390   assert(error_msg == NULL, &quot;Dont call here with error_msg already set&quot;);
391   InlineMatcher* im = new InlineMatcher();
392   MethodMatcher::parse_method_pattern(line, error_msg, im);
393   if (error_msg != NULL) {
394     delete im;
395     return NULL;
396   }
397   return im;
398 }
399 
400 bool InlineMatcher::match(const methodHandle&amp; method, int inline_action) {
401   for (InlineMatcher* current = this; current != NULL; current = current-&gt;next()) {
402     if (current-&gt;matches(method)) {
403       return (current-&gt;_inline_action == inline_action);
404     }
405   }
406   return false;
407 }
408 
409 InlineMatcher* InlineMatcher::parse_inline_pattern(char* str, const char*&amp; error_msg) {
410   // check first token is +/-
411   InlineType _inline_action;
412    switch (str[0]) {
413    case &#39;-&#39;:
414      _inline_action = InlineMatcher::dont_inline;
415      break;
416    case &#39;+&#39;:
417      _inline_action = InlineMatcher::force_inline;
418      break;
419    default:
420      error_msg = &quot;Missing leading inline type (+/-)&quot;;
421      return NULL;
422    }
423    str++;
424 
425    int bytes_read = 0;
426    assert(error_msg== NULL, &quot;error_msg must not be set yet&quot;);
427    InlineMatcher* im = InlineMatcher::parse_method_pattern(str, error_msg);
428    if (im == NULL) {
429      assert(error_msg != NULL, &quot;Must have error message&quot;);
430      return NULL;
431    }
432    im-&gt;set_action(_inline_action);
433    return im;
434 }
435 
436 InlineMatcher* InlineMatcher::clone() {
437    InlineMatcher* m = new InlineMatcher();
438    m-&gt;_class_mode =  _class_mode;
439    m-&gt;_method_mode = _method_mode;
440    m-&gt;_inline_action = _inline_action;
441    m-&gt;_class_name = _class_name;
442    if(_class_name != NULL) {
443      _class_name-&gt;increment_refcount();
444    }
445    m-&gt;_method_name = _method_name;
446    if (_method_name != NULL) {
447      _method_name-&gt;increment_refcount();
448    }
449    m-&gt;_signature = _signature;
450    if (_signature != NULL) {
451      _signature-&gt;increment_refcount();
452    }
453    return m;
454 }
    </pre>
  </body>
</html>
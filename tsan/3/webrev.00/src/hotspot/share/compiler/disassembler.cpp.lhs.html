<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/compiler/disassembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a>
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;ci/ciUtilities.hpp&quot;
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;compiler/disassembler.hpp&quot;
 31 #include &quot;gc/shared/cardTable.hpp&quot;
 32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 33 #include &quot;gc/shared/collectedHeap.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/os.inline.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;utilities/resourceHash.hpp&quot;
 41 #include CPU_HEADER(depChecker)
 42 
 43 void*       Disassembler::_library               = NULL;
 44 bool        Disassembler::_tried_to_load_library = false;
<a name="4" id="anc4"></a>
 45 
 46 // This routine is in the shared library:
 47 Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;
 48 Disassembler::decode_func Disassembler::_decode_instructions = NULL;
 49 
 50 static const char hsdis_library_name[] = &quot;hsdis-&quot; HOTSPOT_LIB_ARCH;
 51 static const char decode_instructions_virtual_name[] = &quot;decode_instructions_virtual&quot;;
 52 static const char decode_instructions_name[] = &quot;decode_instructions&quot;;
 53 static bool use_new_version = true;
 54 #define COMMENT_COLUMN  52 LP64_ONLY(+8) /*could be an option*/
 55 #define BYTES_COMMENT   &quot;;...&quot;  /* funky byte display comment */
 56 
<a name="5" id="anc5"></a><span class="line-removed"> 57 bool Disassembler::load_library() {</span>
<span class="line-removed"> 58   if (_decode_instructions_virtual != NULL || _decode_instructions != NULL) {</span>
<span class="line-removed"> 59     // Already succeeded.</span>
<span class="line-removed"> 60     return true;</span>
<span class="line-removed"> 61   }</span>
<span class="line-removed"> 62   if (_tried_to_load_library) {</span>
<span class="line-removed"> 63     // Do not try twice.</span>
<span class="line-removed"> 64     // To force retry in debugger: assign _tried_to_load_library=0</span>
<span class="line-removed"> 65     return false;</span>
<span class="line-removed"> 66   }</span>
<span class="line-removed"> 67   // Try to load it.</span>
<span class="line-removed"> 68   char ebuf[1024];</span>
<span class="line-removed"> 69   char buf[JVM_MAXPATHLEN];</span>
<span class="line-removed"> 70   os::jvm_path(buf, sizeof(buf));</span>
<span class="line-removed"> 71   int jvm_offset = -1;</span>
<span class="line-removed"> 72   int lib_offset = -1;</span>
<span class="line-removed"> 73 #ifdef STATIC_BUILD</span>
<span class="line-removed"> 74   char* p = strrchr(buf, &#39;/&#39;);</span>
<span class="line-removed"> 75   *p = &#39;\0&#39;;</span>
<span class="line-removed"> 76   strcat(p, &quot;/lib/&quot;);</span>
<span class="line-removed"> 77   lib_offset = jvm_offset = strlen(buf);</span>
<span class="line-removed"> 78 #else</span>
<span class="line-removed"> 79   {</span>
<span class="line-removed"> 80     // Match &quot;jvm[^/]*&quot; in jvm_path.</span>
<span class="line-removed"> 81     const char* base = buf;</span>
<span class="line-removed"> 82     const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-removed"> 83     if (p != NULL) lib_offset = p - base + 1;</span>
<span class="line-removed"> 84     p = strstr(p ? p : base, &quot;jvm&quot;);</span>
<span class="line-removed"> 85     if (p != NULL) jvm_offset = p - base;</span>
<span class="line-removed"> 86   }</span>
<span class="line-removed"> 87 #endif</span>
<span class="line-removed"> 88   // Find the disassembler shared library.</span>
<span class="line-removed"> 89   // Search for several paths derived from libjvm, in this order:</span>
<span class="line-removed"> 90   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)</span>
<span class="line-removed"> 91   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed"> 92   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed"> 93   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-removed"> 94   if (jvm_offset &gt;= 0) {</span>
<span class="line-removed"> 95     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so</span>
<span class="line-removed"> 96     strcpy(&amp;buf[jvm_offset], hsdis_library_name);</span>
<span class="line-removed"> 97     strcat(&amp;buf[jvm_offset], os::dll_file_extension());</span>
<span class="line-removed"> 98     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed"> 99     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {</span>
<span class="line-removed">100       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed">101       strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-removed">102       strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-removed">103       _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed">104     }</span>
<span class="line-removed">105     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {</span>
<span class="line-removed">106       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed">107       buf[lib_offset - 1] = &#39;\0&#39;;</span>
<span class="line-removed">108       const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-removed">109       if (p != NULL) {</span>
<span class="line-removed">110         lib_offset = p - buf + 1;</span>
<span class="line-removed">111         strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-removed">112         strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-removed">113         _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed">114       }</span>
<span class="line-removed">115     }</span>
<span class="line-removed">116   }</span>
<span class="line-removed">117   if (_library == NULL) {</span>
<span class="line-removed">118     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-removed">119     strcpy(&amp;buf[0], hsdis_library_name);</span>
<span class="line-removed">120     strcat(&amp;buf[0], os::dll_file_extension());</span>
<span class="line-removed">121     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed">122   }</span>
<span class="line-removed">123   if (_library != NULL) {</span>
<span class="line-removed">124     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,</span>
<span class="line-removed">125                                           os::dll_lookup(_library, decode_instructions_virtual_name));</span>
<span class="line-removed">126   }</span>
<span class="line-removed">127   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {</span>
<span class="line-removed">128     // could not spot in new version, try old version</span>
<span class="line-removed">129     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,</span>
<span class="line-removed">130                                           os::dll_lookup(_library, decode_instructions_name));</span>
<span class="line-removed">131     use_new_version = false;</span>
<span class="line-removed">132   } else {</span>
<span class="line-removed">133     use_new_version = true;</span>
<span class="line-removed">134   }</span>
<span class="line-removed">135   _tried_to_load_library = true;</span>
<span class="line-removed">136   if (_decode_instructions_virtual == NULL &amp;&amp; _decode_instructions == NULL) {</span>
<span class="line-removed">137     tty-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;, buf,</span>
<span class="line-removed">138                   ((_library != NULL)</span>
<span class="line-removed">139                    ? &quot;entry point is missing&quot;</span>
<span class="line-removed">140                    : (WizardMode || PrintMiscellaneous)</span>
<span class="line-removed">141                    ? (const char*)ebuf</span>
<span class="line-removed">142                    : &quot;library not loadable&quot;),</span>
<span class="line-removed">143                   &quot;PrintAssembly is disabled&quot;);</span>
<span class="line-removed">144     return false;</span>
<span class="line-removed">145   }</span>
<span class="line-removed">146 </span>
<span class="line-removed">147   // Success.</span>
<span class="line-removed">148   tty-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);</span>
<span class="line-removed">149   return true;</span>
<span class="line-removed">150 }</span>
<span class="line-removed">151 </span>
<span class="line-removed">152 </span>
153 class decode_env {
154  private:
<a name="6" id="anc6"></a><span class="line-modified">155   nmethod*      _nm;</span>
<span class="line-modified">156   CodeBlob*     _code;</span>


157   CodeStrings   _strings;
<a name="7" id="anc7"></a><span class="line-modified">158   outputStream* _output;</span>
<span class="line-modified">159   address       _start, _end;</span>
<span class="line-removed">160   ptrdiff_t     _offset;</span>
161 
162   char          _option_buf[512];
163   char          _print_raw;
<a name="8" id="anc8"></a><span class="line-modified">164   bool          _print_pc;</span>
<span class="line-modified">165   bool          _print_bytes;</span>
<span class="line-modified">166   address       _cur_insn;</span>
<span class="line-modified">167   int           _bytes_per_line; // arch-specific formatting option</span>
168   bool          _print_file_name;
<a name="9" id="anc9"></a>






169 
<a name="10" id="anc10"></a>


170   static bool match(const char* event, const char* tag) {
<a name="11" id="anc11"></a><span class="line-modified">171     size_t taglen = strlen(tag);</span>
<span class="line-modified">172     if (strncmp(event, tag, taglen) != 0)</span>



173       return false;
174     char delim = event[taglen];
175     return delim == &#39;\0&#39; || delim == &#39; &#39; || delim == &#39;/&#39; || delim == &#39;=&#39;;
176   }
177 
<a name="12" id="anc12"></a>
178   void collect_options(const char* p) {
179     if (p == NULL || p[0] == &#39;\0&#39;)  return;
180     size_t opt_so_far = strlen(_option_buf);
181     if (opt_so_far + 1 + strlen(p) + 1 &gt; sizeof(_option_buf))  return;
182     char* fillp = &amp;_option_buf[opt_so_far];
183     if (opt_so_far &gt; 0) *fillp++ = &#39;,&#39;;
184     strcat(fillp, p);
185     // replace white space by commas:
186     char* q = fillp;
187     while ((q = strpbrk(q, &quot; \t\n&quot;)) != NULL)
188       *q++ = &#39;,&#39;;
<a name="13" id="anc13"></a><span class="line-removed">189     // Note that multiple PrintAssemblyOptions flags accumulate with \n,</span>
<span class="line-removed">190     // which we want to be changed to a comma...</span>
191   }
192 
<a name="14" id="anc14"></a>

193   void print_insn_labels();
<a name="15" id="anc15"></a><span class="line-modified">194   void print_insn_bytes(address pc0, address pc);</span>
195   void print_address(address value);
196 
<a name="16" id="anc16"></a>












































197   struct SourceFileInfo {
198     struct Link : public CHeapObj&lt;mtCode&gt; {
199       const char* file;
200       int line;
201       Link* next;
202       Link(const char* f, int l) : file(f), line(l), next(NULL) {}
203     };
204     Link *head, *tail;
205 
206     static unsigned hash(const address&amp; a) {
207       return primitive_hash&lt;address&gt;(a);
208     }
209     static bool equals(const address&amp; a0, const address&amp; a1) {
210       return primitive_equals&lt;address&gt;(a0, a1);
211     }
212     void append(const char* file, int line) {
213       if (tail != NULL &amp;&amp; tail-&gt;file == file &amp;&amp; tail-&gt;line == line) {
214         // Don&#39;t print duplicated lines at the same address. This could happen with C
215         // macros that end up having multiple &quot;__&quot; tokens on the same __LINE__.
216         return;
217       }
218       Link *link = new Link(file, line);
219       if (head == NULL) {
220         head = tail = link;
221       } else {
222         tail-&gt;next = link;
223         tail = link;
224       }
225     }
226     SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {
227       append(file, line);
228     }
229   };
230 
231   typedef ResourceHashtable&lt;
232       address, SourceFileInfo,
233       SourceFileInfo::hash,
234       SourceFileInfo::equals,
235       15889,      // prime number
236       ResourceObj::C_HEAP&gt; SourceFileInfoTable;
237 
238   static SourceFileInfoTable _src_table;
239   static const char* _cached_src;
240   static GrowableArray&lt;const char*&gt;* _cached_src_lines;
241 
242  public:
<a name="17" id="anc17"></a><span class="line-modified">243   decode_env(CodeBlob* code, outputStream* output,</span>
<span class="line-modified">244              CodeStrings c = CodeStrings(), ptrdiff_t offset = 0);</span>




245 
<a name="18" id="anc18"></a><span class="line-modified">246   address decode_instructions(address start, address end);</span>
<span class="line-modified">247 </span>
<span class="line-modified">248   void start_insn(address pc) {</span>
<span class="line-removed">249     _cur_insn = pc;</span>
<span class="line-removed">250     output()-&gt;bol();</span>
<span class="line-removed">251     print_insn_labels();</span>
<span class="line-removed">252   }</span>
<span class="line-removed">253 </span>
<span class="line-removed">254   void end_insn(address pc) {</span>
<span class="line-removed">255     address pc0 = cur_insn();</span>
<span class="line-removed">256     outputStream* st = output();</span>
<span class="line-removed">257     if (_print_bytes &amp;&amp; pc &gt; pc0)</span>
<span class="line-removed">258       print_insn_bytes(pc0, pc);</span>
<span class="line-removed">259     if (_nm != NULL) {</span>
<span class="line-removed">260       _nm-&gt;print_code_comment_on(st, COMMENT_COLUMN, pc0, pc);</span>
<span class="line-removed">261       // this calls reloc_string_for which calls oop::print_value_on</span>
<span class="line-removed">262     }</span>
<span class="line-removed">263     print_hook_comments(pc0, _nm != NULL);</span>
<span class="line-removed">264     // follow each complete insn by a nice newline</span>
<span class="line-removed">265     st-&gt;cr();</span>
<span class="line-removed">266   }</span>
267 
268   address handle_event(const char* event, address arg);
269 
<a name="19" id="anc19"></a><span class="line-modified">270   outputStream* output() { return _output; }</span>
<span class="line-modified">271   address cur_insn() { return _cur_insn; }</span>
<span class="line-modified">272   const char* options() { return _option_buf; }</span>
<span class="line-modified">273   static void hook(const char* file, int line, address pc);</span>
274   void print_hook_comments(address pc, bool newline);
275 };
276 
<a name="20" id="anc20"></a>

277 decode_env::SourceFileInfoTable decode_env::_src_table;
278 const char* decode_env::_cached_src = NULL;
279 GrowableArray&lt;const char*&gt;* decode_env::_cached_src_lines = NULL;
280 
281 void decode_env::hook(const char* file, int line, address pc) {
282   // For simplication, we never free from this table. It&#39;s really not
283   // necessary as we add to the table only when PrintInterpreter is true,
284   // which means we are debugging the VM and a little bit of extra
285   // memory usage doesn&#39;t matter.
286   SourceFileInfo* found = _src_table.get(pc);
287   if (found != NULL) {
288     found-&gt;append(file, line);
289   } else {
290     SourceFileInfo sfi(file, line);
291     _src_table.put(pc, sfi); // sfi is copied by value
292   }
293 }
294 
295 void decode_env::print_hook_comments(address pc, bool newline) {
296   SourceFileInfo* found = _src_table.get(pc);
297   outputStream* st = output();
298   if (found != NULL) {
299     for (SourceFileInfo::Link *link = found-&gt;head; link; link = link-&gt;next) {
300       const char* file = link-&gt;file;
301       int line = link-&gt;line;
302       if (_cached_src == NULL || strcmp(_cached_src, file) != 0) {
303         FILE* fp;
304 
305         // _cached_src_lines is a single cache of the lines of a source file, and we refill this cache
306         // every time we need to print a line from a different source file. It&#39;s not the fastest,
307         // but seems bearable.
308         if (_cached_src_lines != NULL) {
309           for (int i=0; i&lt;_cached_src_lines-&gt;length(); i++) {
310             os::free((void*)_cached_src_lines-&gt;at(i));
311           }
312           _cached_src_lines-&gt;clear();
313         } else {
314           _cached_src_lines = new (ResourceObj::C_HEAP, mtCode)GrowableArray&lt;const char*&gt;(0, true);
315         }
316 
317         if ((fp = fopen(file, &quot;r&quot;)) == NULL) {
318           _cached_src = NULL;
319           return;
320         }
321         _cached_src = file;
322 
323         char line[500]; // don&#39;t write lines that are too long in your source files!
324         while (fgets(line, sizeof(line), fp) != NULL) {
325           size_t len = strlen(line);
326           if (len &gt; 0 &amp;&amp; line[len-1] == &#39;\n&#39;) {
327             line[len-1] = &#39;\0&#39;;
328           }
329           _cached_src_lines-&gt;append(os::strdup(line));
330         }
331         fclose(fp);
332         _print_file_name = true;
333       }
334 
335       if (_print_file_name) {
336         // We print the file name whenever we switch to a new file, or when
337         // Disassembler::decode is called to disassemble a new block of code.
338         _print_file_name = false;
339         if (newline) {
340           st-&gt;cr();
341         }
342         st-&gt;move_to(COMMENT_COLUMN);
343         st-&gt;print(&quot;;;@FILE: %s&quot;, file);
344         newline = true;
345       }
346 
347       int index = line - 1; // 1-based line number -&gt; 0-based index.
348       if (index &gt;= _cached_src_lines-&gt;length()) {
349         // This could happen if source file is mismatched.
350       } else {
351         const char* source_line = _cached_src_lines-&gt;at(index);
352         if (newline) {
353           st-&gt;cr();
354         }
355         st-&gt;move_to(COMMENT_COLUMN);
356         st-&gt;print(&quot;;;%5d: %s&quot;, line, source_line);
357         newline = true;
358       }
359     }
360   }
361 }
362 
<a name="21" id="anc21"></a><span class="line-modified">363 decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c,</span>
<span class="line-modified">364                        ptrdiff_t offset) {</span>
<span class="line-modified">365   memset(this, 0, sizeof(*this)); // Beware, this zeroes bits of fields.</span>
<span class="line-modified">366   _output = output ? output : tty;</span>
<span class="line-modified">367   _code = code;</span>
<span class="line-modified">368   if (code != NULL &amp;&amp; code-&gt;is_nmethod())</span>
<span class="line-modified">369     _nm = (nmethod*) code;</span>


































370   _strings.copy(c);
<a name="22" id="anc22"></a><span class="line-modified">371   _offset = offset;</span>

372 
<a name="23" id="anc23"></a><span class="line-modified">373   // by default, output pc but not bytes:</span>
<span class="line-modified">374   _print_pc       = true;</span>
<span class="line-modified">375   _print_bytes    = false;</span>
<span class="line-modified">376   _bytes_per_line = Disassembler::pd_instruction_alignment();</span>
<span class="line-modified">377   _print_file_name= true;</span>










































378 
<a name="24" id="anc24"></a><span class="line-modified">379   // parse the global option string:</span>









380   collect_options(Disassembler::pd_cpu_opts());
381   collect_options(PrintAssemblyOptions);
382 
<a name="25" id="anc25"></a><span class="line-modified">383   if (strstr(options(), &quot;hsdis-&quot;)) {</span>
<span class="line-modified">384     if (strstr(options(), &quot;hsdis-print-raw&quot;))</span>
<span class="line-removed">385       _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);</span>
<span class="line-removed">386     if (strstr(options(), &quot;hsdis-print-pc&quot;))</span>
<span class="line-removed">387       _print_pc = !_print_pc;</span>
<span class="line-removed">388     if (strstr(options(), &quot;hsdis-print-bytes&quot;))</span>
<span class="line-removed">389       _print_bytes = !_print_bytes;</span>
390   }
<a name="26" id="anc26"></a>


391   if (strstr(options(), &quot;help&quot;)) {
<a name="27" id="anc27"></a><span class="line-modified">392     tty-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);</span>
<span class="line-modified">393     tty-&gt;print_cr(&quot;  hsdis-print-raw       test plugin by requesting raw output&quot;);</span>
<span class="line-modified">394     tty-&gt;print_cr(&quot;  hsdis-print-raw-xml   test plugin by requesting raw xml&quot;);</span>
<span class="line-modified">395     tty-&gt;print_cr(&quot;  hsdis-print-pc        turn off PC printing (on by default)&quot;);</span>
<span class="line-modified">396     tty-&gt;print_cr(&quot;  hsdis-print-bytes     turn on instruction byte output&quot;);</span>
<span class="line-modified">397     tty-&gt;print_cr(&quot;combined options: %s&quot;, options());</span>













































398   }
399 }
400 
<a name="28" id="anc28"></a>





























401 address decode_env::handle_event(const char* event, address arg) {
<a name="29" id="anc29"></a><span class="line-modified">402   if (match(event, &quot;insn&quot;)) {</span>























403     start_insn(arg);
404   } else if (match(event, &quot;/insn&quot;)) {
405     end_insn(arg);
406   } else if (match(event, &quot;addr&quot;)) {
407     if (arg != NULL) {
408       print_address(arg);
409       return arg;
410     }
<a name="30" id="anc30"></a><span class="line-modified">411   } else if (match(event, &quot;mach&quot;)) {</span>
<span class="line-modified">412     static char buffer[32] = { 0, };</span>
<span class="line-modified">413     if (strcmp(buffer, (const char*)arg) != 0 ||</span>
<span class="line-modified">414         strlen((const char*)arg) &gt; sizeof(buffer) - 1) {</span>
























415       // Only print this when the mach changes
416       strncpy(buffer, (const char*)arg, sizeof(buffer) - 1);
417       buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
<a name="31" id="anc31"></a><span class="line-modified">418       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, arg);</span>
419     }
<a name="32" id="anc32"></a><span class="line-modified">420   } else if (match(event, &quot;format bytes-per-line&quot;)) {</span>




421     _bytes_per_line = (int) (intptr_t) arg;
<a name="33" id="anc33"></a><span class="line-modified">422   } else {</span>
<span class="line-removed">423     // ignore unrecognized markup</span>
424   }
<a name="34" id="anc34"></a>
425   return NULL;
426 }
427 
<a name="35" id="anc35"></a>




428 // called by the disassembler to print out jump targets and data addresses
429 void decode_env::print_address(address adr) {
<a name="36" id="anc36"></a><span class="line-modified">430   outputStream* st = _output;</span>
431 
432   if (adr == NULL) {
433     st-&gt;print(&quot;NULL&quot;);
434     return;
435   }
436 
437   int small_num = (int)(intptr_t)adr;
438   if ((intptr_t)adr == (intptr_t)small_num
439       &amp;&amp; -1 &lt;= small_num &amp;&amp; small_num &lt;= 9) {
440     st-&gt;print(&quot;%d&quot;, small_num);
441     return;
442   }
443 
444   if (Universe::is_fully_initialized()) {
445     if (StubRoutines::contains(adr)) {
446       StubCodeDesc* desc = StubCodeDesc::desc_for(adr);
447       if (desc == NULL) {
448         desc = StubCodeDesc::desc_for(adr + frame::pc_return_offset);
449       }
450       if (desc != NULL) {
451         st-&gt;print(&quot;Stub::%s&quot;, desc-&gt;name());
452         if (desc-&gt;begin() != adr) {
453           st-&gt;print(INTX_FORMAT_W(+) &quot; &quot; PTR_FORMAT, adr - desc-&gt;begin(), p2i(adr));
454         } else if (WizardMode) {
455           st-&gt;print(&quot; &quot; PTR_FORMAT, p2i(adr));
456         }
457         return;
458       }
459       st-&gt;print(&quot;Stub::&lt;unknown&gt; &quot; PTR_FORMAT, p2i(adr));
460       return;
461     }
462 
463     BarrierSet* bs = BarrierSet::barrier_set();
464     if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
465         adr == ci_card_table_address_as&lt;address&gt;()) {
466       st-&gt;print(&quot;word_map_base&quot;);
467       if (WizardMode) st-&gt;print(&quot; &quot; INTPTR_FORMAT, p2i(adr));
468       return;
469     }
470   }
471 
472   if (_nm == NULL) {
473     // Don&#39;t do this for native methods, as the function name will be printed in
474     // nmethod::reloc_string_for().
<a name="37" id="anc37"></a><span class="line-modified">475     ResourceMark rm;</span>


476     const int buflen = 1024;
<a name="38" id="anc38"></a><span class="line-modified">477     char* buf = NEW_RESOURCE_ARRAY(char, buflen);</span>
478     int offset;
479     if (os::dll_address_to_function_name(adr, buf, buflen, &amp;offset)) {
480       st-&gt;print(PTR_FORMAT &quot; = %s&quot;,  p2i(adr), buf);
481       if (offset != 0) {
482         st-&gt;print(&quot;+%d&quot;, offset);
483       }
484       return;
485     }
486   }
487 
488   // Fall through to a simple (hexadecimal) numeral.
489   st-&gt;print(PTR_FORMAT, p2i(adr));
490 }
491 
492 void decode_env::print_insn_labels() {
<a name="39" id="anc39"></a><span class="line-modified">493   address p = cur_insn();</span>
<span class="line-modified">494   outputStream* st = output();</span>
<span class="line-modified">495   CodeBlob* cb = _code;</span>
<span class="line-removed">496   if (cb != NULL) {</span>
<span class="line-removed">497     cb-&gt;print_block_comment(st, p);</span>
<span class="line-removed">498   }</span>
<span class="line-removed">499   _strings.print_block_comment(st, (intptr_t)(p - _start + _offset));</span>
<span class="line-removed">500   if (_print_pc) {</span>
<span class="line-removed">501     st-&gt;print(&quot;  &quot; PTR_FORMAT &quot;: &quot;, p2i(p));</span>
<span class="line-removed">502   }</span>
<span class="line-removed">503 }</span>
504 
<a name="40" id="anc40"></a><span class="line-modified">505 void decode_env::print_insn_bytes(address pc, address pc_limit) {</span>
<span class="line-modified">506   outputStream* st = output();</span>
<span class="line-modified">507   size_t incr = 1;</span>
<span class="line-modified">508   size_t perline = _bytes_per_line;</span>
<span class="line-modified">509   if ((size_t) Disassembler::pd_instruction_alignment() &gt;= sizeof(int)</span>
<span class="line-modified">510       &amp;&amp; !((uintptr_t)pc % sizeof(int))</span>
<span class="line-modified">511       &amp;&amp; !((uintptr_t)pc_limit % sizeof(int))) {</span>
<span class="line-modified">512     incr = sizeof(int);</span>
<span class="line-modified">513     if (perline % incr)  perline += incr - (perline % incr);</span>
<span class="line-modified">514   }</span>
<span class="line-modified">515   while (pc &lt; pc_limit) {</span>
<span class="line-removed">516     // tab to the desired column:</span>
<span class="line-removed">517     st-&gt;move_to(COMMENT_COLUMN);</span>
<span class="line-removed">518     address pc0 = pc;</span>
<span class="line-removed">519     address pc1 = pc + perline;</span>
<span class="line-removed">520     if (pc1 &gt; pc_limit)  pc1 = pc_limit;</span>
<span class="line-removed">521     for (; pc &lt; pc1; pc += incr) {</span>
<span class="line-removed">522       if (pc == pc0) {</span>
<span class="line-removed">523         st-&gt;print(BYTES_COMMENT);</span>
<span class="line-removed">524       } else if ((uint)(pc - pc0) % sizeof(int) == 0) {</span>
<span class="line-removed">525         st-&gt;print(&quot; &quot;);         // put out a space on word boundaries</span>
<span class="line-removed">526       }</span>
<span class="line-removed">527       if (incr == sizeof(int)) {</span>
<span class="line-removed">528         st-&gt;print(&quot;%08x&quot;, *(int*)pc);</span>
<span class="line-removed">529       } else {</span>
<span class="line-removed">530         st-&gt;print(&quot;%02x&quot;, (*pc)&amp;0xFF);</span>
<span class="line-removed">531       }</span>
532     }
<a name="41" id="anc41"></a><span class="line-modified">533     st-&gt;cr();</span>
534   }
535 }
536 
<a name="42" id="anc42"></a><span class="line-modified">537 </span>
<span class="line-modified">538 static void* event_to_env(void* env_pv, const char* event, void* arg) {</span>
<span class="line-modified">539   decode_env* env = (decode_env*) env_pv;</span>
<span class="line-modified">540   return env-&gt;handle_event(event, (address) arg);</span>

541 }
542 
543 ATTRIBUTE_PRINTF(2, 3)
544 static int printf_to_env(void* env_pv, const char* format, ...) {
545   decode_env* env = (decode_env*) env_pv;
546   outputStream* st = env-&gt;output();
547   size_t flen = strlen(format);
548   const char* raw = NULL;
549   if (flen == 0)  return 0;
550   if (flen == 1 &amp;&amp; format[0] == &#39;\n&#39;) { st-&gt;bol(); return 1; }
551   if (flen &lt; 2 ||
552       strchr(format, &#39;%&#39;) == NULL) {
553     raw = format;
554   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;%&#39; &amp;&amp;
555              strchr(format+2, &#39;%&#39;) == NULL) {
556     // happens a lot on machines with names like %foo
557     flen--;
558     raw = format+1;
559   }
560   if (raw != NULL) {
561     st-&gt;print_raw(raw, (int) flen);
562     return (int) flen;
563   }
564   va_list ap;
565   va_start(ap, format);
566   julong cnt0 = st-&gt;count();
567   st-&gt;vprint(format, ap);
568   julong cnt1 = st-&gt;count();
569   va_end(ap);
570   return (int)(cnt1 - cnt0);
571 }
572 
<a name="43" id="anc43"></a><span class="line-modified">573 address decode_env::decode_instructions(address start, address end) {</span>
<span class="line-modified">574   _start = start; _end = end;</span>
<span class="line-modified">575 </span>
<span class="line-modified">576   assert(((((intptr_t)start | (intptr_t)end) % Disassembler::pd_instruction_alignment()) == 0), &quot;misaligned insn addr&quot;);</span>
<span class="line-modified">577 </span>
<span class="line-modified">578   const int show_bytes = false; // for disassembler debugging</span>








579 
<a name="44" id="anc44"></a><span class="line-modified">580   //_version = Disassembler::pd_cpu_version();</span>





581 
<a name="45" id="anc45"></a><span class="line-modified">582   if (!Disassembler::can_decode()) {</span>


583     return NULL;
584   }
585 
586   // decode a series of instructions and return the end of the last instruction
587 
588   if (_print_raw) {
589     // Print whatever the library wants to print, w/o fancy callbacks.
590     // This is mainly for debugging the library itself.
591     FILE* out = stdout;
592     FILE* xmlout = (_print_raw &gt; 1 ? out : NULL);
593     return use_new_version ?
594       (address)
595       (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
596                                                     start, end - start,
597                                                     NULL, (void*) xmlout,
598                                                     NULL, (void*) out,
599                                                     options(), 0/*nice new line*/)
600       :
601       (address)
602       (*Disassembler::_decode_instructions)(start, end,
603                                             NULL, (void*) xmlout,
604                                             NULL, (void*) out,
605                                             options());
606   }
607 
608   return use_new_version ?
609     (address)
610     (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
611                                                   start, end - start,
612                                                   &amp;event_to_env,  (void*) this,
613                                                   &amp;printf_to_env, (void*) this,
614                                                   options(), 0/*nice new line*/)
615     :
616     (address)
617     (*Disassembler::_decode_instructions)(start, end,
618                                           &amp;event_to_env,  (void*) this,
619                                           &amp;printf_to_env, (void*) this,
620                                           options());
621 }
622 
<a name="46" id="anc46"></a>




623 
<a name="47" id="anc47"></a><span class="line-modified">624 void Disassembler::decode(CodeBlob* cb, outputStream* st) {</span>
<span class="line-modified">625   ttyLocker ttyl;</span>
<span class="line-modified">626   if (!load_library())  return;</span>






























































































































































627   if (cb-&gt;is_nmethod()) {
<a name="48" id="anc48"></a><span class="line-modified">628     decode((nmethod*)cb, st);</span>


629     return;
630   }
<a name="49" id="anc49"></a>
631   decode_env env(cb, st);
<a name="50" id="anc50"></a><span class="line-modified">632   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
633   if (cb-&gt;is_aot()) {
634     env.output()-&gt;print(&quot;A &quot;);
635     if (cb-&gt;is_compiled()) {
636       CompiledMethod* cm = (CompiledMethod*)cb;
637       env.output()-&gt;print(&quot;%d &quot;,cm-&gt;compile_id());
638       cm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());
639       env.output()-&gt;print(&quot;.&quot;);
640       cm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());
641       cm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
642     } else {
643       env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
644     }
645   } else {
<a name="51" id="anc51"></a><span class="line-modified">646     env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());</span>



647   }
<a name="52" id="anc52"></a><span class="line-modified">648   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())) * sizeof(unsigned char*));</span>
<span class="line-removed">649   env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());</span>
<span class="line-removed">650 }</span>
651 
<a name="53" id="anc53"></a><span class="line-modified">652 void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c,</span>
<span class="line-modified">653                           ptrdiff_t offset) {</span>
<span class="line-modified">654   ttyLocker ttyl;</span>
<span class="line-modified">655   if (!load_library())  return;</span>
<span class="line-modified">656   decode_env env(CodeCache::find_blob_unsafe(start), st, c, offset);</span>
<span class="line-modified">657   env.decode_instructions(start, end);</span>

658 }
659 
<a name="54" id="anc54"></a><span class="line-modified">660 void Disassembler::decode(nmethod* nm, outputStream* st) {</span>




661   ttyLocker ttyl;
<a name="55" id="anc55"></a><span class="line-removed">662   if (!load_library())  return;</span>
<span class="line-removed">663   decode_env env(nm, st);</span>
<span class="line-removed">664   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
<span class="line-removed">665 </span>
<span class="line-removed">666   unsigned char* p   = nm-&gt;code_begin();</span>
<span class="line-removed">667   unsigned char* end = nm-&gt;code_end();</span>
668 
<a name="56" id="anc56"></a><span class="line-modified">669   nm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified">670   env.output()-&gt;print(&quot;.&quot;);</span>
<span class="line-modified">671   nm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified">672   nm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified">673 #if INCLUDE_JVMCI</span>
<span class="line-modified">674   {</span>
<span class="line-modified">675     char buffer[O_BUFLEN];</span>
<span class="line-modified">676     char* jvmciName = nm-&gt;jvmci_installed_code_name(buffer, O_BUFLEN);</span>
<span class="line-modified">677     if (jvmciName != NULL) {</span>
<span class="line-removed">678       env.output()-&gt;print(&quot; (%s)&quot;, jvmciName);</span>
<span class="line-removed">679     }</span>
680   }
<a name="57" id="anc57"></a>
681 #endif
<a name="58" id="anc58"></a><span class="line-modified">682   env.output()-&gt;print_cr(&quot;  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(p), p2i(end), ((jlong)(end - p)));</span>
<span class="line-modified">683 </span>
<span class="line-modified">684   // Print constant table.</span>
<span class="line-modified">685   if (nm-&gt;consts_size() &gt; 0) {</span>
<span class="line-modified">686     nm-&gt;print_nmethod_labels(env.output(), nm-&gt;consts_begin());</span>
<span class="line-modified">687     int offset = 0;</span>
<span class="line-modified">688     for (address p = nm-&gt;consts_begin(); p &lt; nm-&gt;consts_end(); p += 4, offset += 4) {</span>
<span class="line-modified">689       if ((offset % 8) == 0) {</span>
<span class="line-modified">690         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT &quot;   &quot; PTR64_FORMAT, p2i(p), offset, *((int32_t*) p), *((int64_t*) p));</span>
<span class="line-modified">691       } else {</span>
<span class="line-removed">692         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT,                    p2i(p), offset, *((int32_t*) p));</span>
<span class="line-removed">693       }</span>
694     }
<a name="59" id="anc59"></a>
695   }
696 
<a name="60" id="anc60"></a><span class="line-modified">697   env.decode_instructions(p, end);</span>






















698 }
699 
700 // To prevent excessive code expansion in the interpreter generator, we
701 // do not inline this function into Disassembler::hook().
702 void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {
703   decode_env::hook(file, line, masm-&gt;code_section()-&gt;end());
704 }
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="61" type="hidden" />
</body>
</html>
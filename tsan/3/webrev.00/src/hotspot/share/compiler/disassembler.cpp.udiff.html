<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/compiler/disassembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerOracle.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/disassembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,29 +21,32 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;asm/assembler.inline.hpp&quot;</span>
  #include &quot;asm/macroAssembler.hpp&quot;
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/stubCodeGenerator.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  #include CPU_HEADER(depChecker)
  
  void*       Disassembler::_library               = NULL;
  bool        Disassembler::_tried_to_load_library = false;
<span class="udiff-line-added">+ bool        Disassembler::_library_usable        = false;</span>
  
  // This routine is in the shared library:
  Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;
  Disassembler::decode_func Disassembler::_decode_instructions = NULL;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52,131 +55,50 @@</span>
  static const char decode_instructions_name[] = &quot;decode_instructions&quot;;
  static bool use_new_version = true;
  #define COMMENT_COLUMN  52 LP64_ONLY(+8) /*could be an option*/
  #define BYTES_COMMENT   &quot;;...&quot;  /* funky byte display comment */
  
<span class="udiff-line-removed">- bool Disassembler::load_library() {</span>
<span class="udiff-line-removed">-   if (_decode_instructions_virtual != NULL || _decode_instructions != NULL) {</span>
<span class="udiff-line-removed">-     // Already succeeded.</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_tried_to_load_library) {</span>
<span class="udiff-line-removed">-     // Do not try twice.</span>
<span class="udiff-line-removed">-     // To force retry in debugger: assign _tried_to_load_library=0</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // Try to load it.</span>
<span class="udiff-line-removed">-   char ebuf[1024];</span>
<span class="udiff-line-removed">-   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-removed">-   os::jvm_path(buf, sizeof(buf));</span>
<span class="udiff-line-removed">-   int jvm_offset = -1;</span>
<span class="udiff-line-removed">-   int lib_offset = -1;</span>
<span class="udiff-line-removed">- #ifdef STATIC_BUILD</span>
<span class="udiff-line-removed">-   char* p = strrchr(buf, &#39;/&#39;);</span>
<span class="udiff-line-removed">-   *p = &#39;\0&#39;;</span>
<span class="udiff-line-removed">-   strcat(p, &quot;/lib/&quot;);</span>
<span class="udiff-line-removed">-   lib_offset = jvm_offset = strlen(buf);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     // Match &quot;jvm[^/]*&quot; in jvm_path.</span>
<span class="udiff-line-removed">-     const char* base = buf;</span>
<span class="udiff-line-removed">-     const char* p = strrchr(buf, *os::file_separator());</span>
<span class="udiff-line-removed">-     if (p != NULL) lib_offset = p - base + 1;</span>
<span class="udiff-line-removed">-     p = strstr(p ? p : base, &quot;jvm&quot;);</span>
<span class="udiff-line-removed">-     if (p != NULL) jvm_offset = p - base;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   // Find the disassembler shared library.</span>
<span class="udiff-line-removed">-   // Search for several paths derived from libjvm, in this order:</span>
<span class="udiff-line-removed">-   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)</span>
<span class="udiff-line-removed">-   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-removed">-   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-removed">-   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="udiff-line-removed">-   if (jvm_offset &gt;= 0) {</span>
<span class="udiff-line-removed">-     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-removed">-     strcpy(&amp;buf[jvm_offset], hsdis_library_name);</span>
<span class="udiff-line-removed">-     strcat(&amp;buf[jvm_offset], os::dll_file_extension());</span>
<span class="udiff-line-removed">-     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-removed">-     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {</span>
<span class="udiff-line-removed">-       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-removed">-       strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="udiff-line-removed">-       strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="udiff-line-removed">-       _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {</span>
<span class="udiff-line-removed">-       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-removed">-       buf[lib_offset - 1] = &#39;\0&#39;;</span>
<span class="udiff-line-removed">-       const char* p = strrchr(buf, *os::file_separator());</span>
<span class="udiff-line-removed">-       if (p != NULL) {</span>
<span class="udiff-line-removed">-         lib_offset = p - buf + 1;</span>
<span class="udiff-line-removed">-         strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="udiff-line-removed">-         strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="udiff-line-removed">-         _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_library == NULL) {</span>
<span class="udiff-line-removed">-     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="udiff-line-removed">-     strcpy(&amp;buf[0], hsdis_library_name);</span>
<span class="udiff-line-removed">-     strcat(&amp;buf[0], os::dll_file_extension());</span>
<span class="udiff-line-removed">-     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_library != NULL) {</span>
<span class="udiff-line-removed">-     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,</span>
<span class="udiff-line-removed">-                                           os::dll_lookup(_library, decode_instructions_virtual_name));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {</span>
<span class="udiff-line-removed">-     // could not spot in new version, try old version</span>
<span class="udiff-line-removed">-     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,</span>
<span class="udiff-line-removed">-                                           os::dll_lookup(_library, decode_instructions_name));</span>
<span class="udiff-line-removed">-     use_new_version = false;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     use_new_version = true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   _tried_to_load_library = true;</span>
<span class="udiff-line-removed">-   if (_decode_instructions_virtual == NULL &amp;&amp; _decode_instructions == NULL) {</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;, buf,</span>
<span class="udiff-line-removed">-                   ((_library != NULL)</span>
<span class="udiff-line-removed">-                    ? &quot;entry point is missing&quot;</span>
<span class="udiff-line-removed">-                    : (WizardMode || PrintMiscellaneous)</span>
<span class="udiff-line-removed">-                    ? (const char*)ebuf</span>
<span class="udiff-line-removed">-                    : &quot;library not loadable&quot;),</span>
<span class="udiff-line-removed">-                   &quot;PrintAssembly is disabled&quot;);</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Success.</span>
<span class="udiff-line-removed">-   tty-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  class decode_env {
   private:
<span class="udiff-line-modified-removed">-   nmethod*      _nm;</span>
<span class="udiff-line-modified-removed">-   CodeBlob*     _code;</span>
<span class="udiff-line-modified-added">+   outputStream* _output;      // where the disassembly is directed to</span>
<span class="udiff-line-modified-added">+   CodeBuffer*   _codeBuffer;  // != NULL only when decoding a CodeBuffer</span>
<span class="udiff-line-added">+   CodeBlob*     _codeBlob;    // != NULL only when decoding a CodeBlob</span>
<span class="udiff-line-added">+   nmethod*      _nm;          // != NULL only when decoding a nmethod</span>
    CodeStrings   _strings;
<span class="udiff-line-modified-removed">-   outputStream* _output;</span>
<span class="udiff-line-modified-removed">-   address       _start, _end;</span>
<span class="udiff-line-removed">-   ptrdiff_t     _offset;</span>
<span class="udiff-line-modified-added">+   address       _start;       // != NULL when decoding a range of unknown type</span>
<span class="udiff-line-modified-added">+   address       _end;         // != NULL when decoding a range of unknown type</span>
  
    char          _option_buf[512];
    char          _print_raw;
<span class="udiff-line-modified-removed">-   bool          _print_pc;</span>
<span class="udiff-line-modified-removed">-   bool          _print_bytes;</span>
<span class="udiff-line-modified-removed">-   address       _cur_insn;</span>
<span class="udiff-line-modified-removed">-   int           _bytes_per_line; // arch-specific formatting option</span>
<span class="udiff-line-modified-added">+   address       _cur_insn;        // address of instruction currently being decoded</span>
<span class="udiff-line-modified-added">+   int           _bytes_per_line;  // arch-specific formatting option</span>
<span class="udiff-line-modified-added">+   int           _pre_decode_alignment;</span>
<span class="udiff-line-modified-added">+   int           _post_decode_alignment;</span>
    bool          _print_file_name;
<span class="udiff-line-added">+   bool          _print_help;</span>
<span class="udiff-line-added">+   bool          _helpPrinted;</span>
<span class="udiff-line-added">+   static bool   _optionsParsed;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   enum {</span>
<span class="udiff-line-added">+     tabspacing = 8</span>
<span class="udiff-line-added">+   };</span>
  
<span class="udiff-line-added">+   // Check if the event matches the expected tag</span>
<span class="udiff-line-added">+   // The tag must be a substring of the event, and</span>
<span class="udiff-line-added">+   // the tag must be a token in the event, i.e. separated by delimiters</span>
    static bool match(const char* event, const char* tag) {
<span class="udiff-line-modified-removed">-     size_t taglen = strlen(tag);</span>
<span class="udiff-line-modified-removed">-     if (strncmp(event, tag, taglen) != 0)</span>
<span class="udiff-line-modified-added">+     size_t eventlen = strlen(event);</span>
<span class="udiff-line-modified-added">+     size_t taglen   = strlen(tag);</span>
<span class="udiff-line-added">+     if (eventlen &lt; taglen)  // size mismatch</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     if (strncmp(event, tag, taglen) != 0)  // string mismatch</span>
        return false;
      char delim = event[taglen];
      return delim == &#39;\0&#39; || delim == &#39; &#39; || delim == &#39;/&#39; || delim == &#39;=&#39;;
    }
  
<span class="udiff-line-added">+   // Merge new option string with previously recorded options</span>
    void collect_options(const char* p) {
      if (p == NULL || p[0] == &#39;\0&#39;)  return;
      size_t opt_so_far = strlen(_option_buf);
      if (opt_so_far + 1 + strlen(p) + 1 &gt; sizeof(_option_buf))  return;
      char* fillp = &amp;_option_buf[opt_so_far];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,18 +106,63 @@</span>
      strcat(fillp, p);
      // replace white space by commas:
      char* q = fillp;
      while ((q = strpbrk(q, &quot; \t\n&quot;)) != NULL)
        *q++ = &#39;,&#39;;
<span class="udiff-line-removed">-     // Note that multiple PrintAssemblyOptions flags accumulate with \n,</span>
<span class="udiff-line-removed">-     // which we want to be changed to a comma...</span>
    }
  
<span class="udiff-line-added">+   void process_options(outputStream* ost);</span>
<span class="udiff-line-added">+ </span>
    void print_insn_labels();
<span class="udiff-line-modified-removed">-   void print_insn_bytes(address pc0, address pc);</span>
<span class="udiff-line-modified-added">+   void print_insn_prefix();</span>
    void print_address(address value);
  
<span class="udiff-line-added">+   // Properly initializes _start/_end. Overwritten too often if</span>
<span class="udiff-line-added">+   // printing of instructions is called for each instruction.</span>
<span class="udiff-line-added">+   void set_start(address s)   { _start = s; }</span>
<span class="udiff-line-added">+   void set_end  (address e)   { _end = e; }</span>
<span class="udiff-line-added">+   void set_nm   (nmethod* nm) { _nm = nm; }</span>
<span class="udiff-line-added">+   void set_output(outputStream* st) { _output = st; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   // The disassembler library (sometimes) uses tabs to nicely align the instruction operands.</span>
<span class="udiff-line-added">+   // Depending on the mnemonic length and the column position where the</span>
<span class="udiff-line-added">+   // mnemonic is printed, alignment may turn out to be not so nice.</span>
<span class="udiff-line-added">+   // To improve, we assume 8-character tab spacing and left-align the mnemonic on a tab position.</span>
<span class="udiff-line-added">+   // Instruction comments are aligned 4 tab positions to the right of the mnemonic.</span>
<span class="udiff-line-added">+   void calculate_alignment() {</span>
<span class="udiff-line-added">+     _pre_decode_alignment  = ((output()-&gt;position()+tabspacing-1)/tabspacing)*tabspacing;</span>
<span class="udiff-line-added">+     _post_decode_alignment = _pre_decode_alignment + 4*tabspacing;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void start_insn(address pc) {</span>
<span class="udiff-line-added">+     _cur_insn = pc;</span>
<span class="udiff-line-added">+     output()-&gt;bol();</span>
<span class="udiff-line-added">+     print_insn_labels();</span>
<span class="udiff-line-added">+     print_insn_prefix();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void end_insn(address pc) {</span>
<span class="udiff-line-added">+     address pc0 = cur_insn();</span>
<span class="udiff-line-added">+     outputStream* st = output();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (AbstractDisassembler::show_comment()) {</span>
<span class="udiff-line-added">+       if ((_nm != NULL) &amp;&amp; _nm-&gt;has_code_comment(pc0, pc)) {</span>
<span class="udiff-line-added">+         _nm-&gt;print_code_comment_on</span>
<span class="udiff-line-added">+                (st,</span>
<span class="udiff-line-added">+                 _post_decode_alignment ? _post_decode_alignment : COMMENT_COLUMN,</span>
<span class="udiff-line-added">+                 pc0, pc);</span>
<span class="udiff-line-added">+         // this calls reloc_string_for which calls oop::print_value_on</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       print_hook_comments(pc0, _nm != NULL);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Disassembler::annotate(pc0, output());</span>
<span class="udiff-line-added">+     // follow each complete insn by a nice newline</span>
<span class="udiff-line-added">+     st-&gt;bol();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    struct SourceFileInfo {
      struct Link : public CHeapObj&lt;mtCode&gt; {
        const char* file;
        int line;
        Link* next;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,44 +205,32 @@</span>
    static SourceFileInfoTable _src_table;
    static const char* _cached_src;
    static GrowableArray&lt;const char*&gt;* _cached_src_lines;
  
   public:
<span class="udiff-line-modified-removed">-   decode_env(CodeBlob* code, outputStream* output,</span>
<span class="udiff-line-modified-removed">-              CodeStrings c = CodeStrings(), ptrdiff_t offset = 0);</span>
<span class="udiff-line-modified-added">+   decode_env(CodeBuffer* code, outputStream* output);</span>
<span class="udiff-line-modified-added">+   decode_env(CodeBlob*   code, outputStream* output, CodeStrings c = CodeStrings() /* , ptrdiff_t offset */);</span>
<span class="udiff-line-added">+   decode_env(nmethod*    code, outputStream* output, CodeStrings c = CodeStrings());</span>
<span class="udiff-line-added">+   // Constructor for a &#39;decode_env&#39; to decode an arbitrary</span>
<span class="udiff-line-added">+   // piece of memory, hopefully containing code.</span>
<span class="udiff-line-added">+   decode_env(address start, address end, outputStream* output);</span>
  
<span class="udiff-line-modified-removed">-   address decode_instructions(address start, address end);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   void start_insn(address pc) {</span>
<span class="udiff-line-removed">-     _cur_insn = pc;</span>
<span class="udiff-line-removed">-     output()-&gt;bol();</span>
<span class="udiff-line-removed">-     print_insn_labels();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void end_insn(address pc) {</span>
<span class="udiff-line-removed">-     address pc0 = cur_insn();</span>
<span class="udiff-line-removed">-     outputStream* st = output();</span>
<span class="udiff-line-removed">-     if (_print_bytes &amp;&amp; pc &gt; pc0)</span>
<span class="udiff-line-removed">-       print_insn_bytes(pc0, pc);</span>
<span class="udiff-line-removed">-     if (_nm != NULL) {</span>
<span class="udiff-line-removed">-       _nm-&gt;print_code_comment_on(st, COMMENT_COLUMN, pc0, pc);</span>
<span class="udiff-line-removed">-       // this calls reloc_string_for which calls oop::print_value_on</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     print_hook_comments(pc0, _nm != NULL);</span>
<span class="udiff-line-removed">-     // follow each complete insn by a nice newline</span>
<span class="udiff-line-removed">-     st-&gt;cr();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Add &#39;original_start&#39; argument which is the the original address</span>
<span class="udiff-line-modified-added">+   // the instructions were located at (if this is not equal to &#39;start&#39;).</span>
<span class="udiff-line-modified-added">+   address decode_instructions(address start, address end, address original_start = NULL);</span>
  
    address handle_event(const char* event, address arg);
  
<span class="udiff-line-modified-removed">-   outputStream* output() { return _output; }</span>
<span class="udiff-line-modified-removed">-   address cur_insn() { return _cur_insn; }</span>
<span class="udiff-line-modified-removed">-   const char* options() { return _option_buf; }</span>
<span class="udiff-line-modified-removed">-   static void hook(const char* file, int line, address pc);</span>
<span class="udiff-line-modified-added">+   outputStream* output()   { return _output; }</span>
<span class="udiff-line-modified-added">+   address       cur_insn() { return _cur_insn; }</span>
<span class="udiff-line-modified-added">+   const char*   options()  { return _option_buf; }</span>
<span class="udiff-line-modified-added">+   static void   hook(const char* file, int line, address pc);</span>
    void print_hook_comments(address pc, bool newline);
  };
  
<span class="udiff-line-added">+ bool decode_env::_optionsParsed = false;</span>
<span class="udiff-line-added">+ </span>
  decode_env::SourceFileInfoTable decode_env::_src_table;
  const char* decode_env::_cached_src = NULL;
  GrowableArray&lt;const char*&gt;* decode_env::_cached_src_lines = NULL;
  
  void decode_env::hook(const char* file, int line, address pc) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,78 +313,293 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c,</span>
<span class="udiff-line-modified-removed">-                        ptrdiff_t offset) {</span>
<span class="udiff-line-modified-removed">-   memset(this, 0, sizeof(*this)); // Beware, this zeroes bits of fields.</span>
<span class="udiff-line-modified-removed">-   _output = output ? output : tty;</span>
<span class="udiff-line-modified-removed">-   _code = code;</span>
<span class="udiff-line-modified-removed">-   if (code != NULL &amp;&amp; code-&gt;is_nmethod())</span>
<span class="udiff-line-modified-removed">-     _nm = (nmethod*) code;</span>
<span class="udiff-line-modified-added">+ decode_env::decode_env(CodeBuffer* code, outputStream* output) :</span>
<span class="udiff-line-modified-added">+   _output(output ? output : tty),</span>
<span class="udiff-line-modified-added">+   _codeBuffer(code),</span>
<span class="udiff-line-modified-added">+   _codeBlob(NULL),</span>
<span class="udiff-line-modified-added">+   _nm(NULL),</span>
<span class="udiff-line-modified-added">+   _strings(),</span>
<span class="udiff-line-modified-added">+   _start(NULL),</span>
<span class="udiff-line-added">+   _end(NULL),</span>
<span class="udiff-line-added">+   _option_buf(),</span>
<span class="udiff-line-added">+   _print_raw(0),</span>
<span class="udiff-line-added">+   _cur_insn(NULL),</span>
<span class="udiff-line-added">+   _bytes_per_line(0),</span>
<span class="udiff-line-added">+   _pre_decode_alignment(0),</span>
<span class="udiff-line-added">+   _post_decode_alignment(0),</span>
<span class="udiff-line-added">+   _print_file_name(false),</span>
<span class="udiff-line-added">+   _print_help(false),</span>
<span class="udiff-line-added">+   _helpPrinted(false) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="udiff-line-added">+   process_options(_output);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c) :</span>
<span class="udiff-line-added">+   _output(output ? output : tty),</span>
<span class="udiff-line-added">+   _codeBuffer(NULL),</span>
<span class="udiff-line-added">+   _codeBlob(code),</span>
<span class="udiff-line-added">+   _nm(_codeBlob != NULL &amp;&amp; _codeBlob-&gt;is_nmethod() ? (nmethod*) code : NULL),</span>
<span class="udiff-line-added">+   _strings(),</span>
<span class="udiff-line-added">+   _start(NULL),</span>
<span class="udiff-line-added">+   _end(NULL),</span>
<span class="udiff-line-added">+   _option_buf(),</span>
<span class="udiff-line-added">+   _print_raw(0),</span>
<span class="udiff-line-added">+   _cur_insn(NULL),</span>
<span class="udiff-line-added">+   _bytes_per_line(0),</span>
<span class="udiff-line-added">+   _pre_decode_alignment(0),</span>
<span class="udiff-line-added">+   _post_decode_alignment(0),</span>
<span class="udiff-line-added">+   _print_file_name(false),</span>
<span class="udiff-line-added">+   _print_help(false),</span>
<span class="udiff-line-added">+   _helpPrinted(false) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   memset(_option_buf, 0, sizeof(_option_buf));</span>
    _strings.copy(c);
<span class="udiff-line-modified-removed">-   _offset = offset;</span>
<span class="udiff-line-modified-added">+   process_options(_output);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   // by default, output pc but not bytes:</span>
<span class="udiff-line-modified-removed">-   _print_pc       = true;</span>
<span class="udiff-line-modified-removed">-   _print_bytes    = false;</span>
<span class="udiff-line-modified-removed">-   _bytes_per_line = Disassembler::pd_instruction_alignment();</span>
<span class="udiff-line-modified-removed">-   _print_file_name= true;</span>
<span class="udiff-line-modified-added">+ decode_env::decode_env(nmethod* code, outputStream* output, CodeStrings c) :</span>
<span class="udiff-line-modified-added">+   _output(output ? output : tty),</span>
<span class="udiff-line-modified-added">+   _codeBuffer(NULL),</span>
<span class="udiff-line-modified-added">+   _codeBlob(NULL),</span>
<span class="udiff-line-modified-added">+   _nm(code),</span>
<span class="udiff-line-added">+   _strings(),</span>
<span class="udiff-line-added">+   _start(_nm-&gt;code_begin()),</span>
<span class="udiff-line-added">+   _end(_nm-&gt;code_end()),</span>
<span class="udiff-line-added">+   _option_buf(),</span>
<span class="udiff-line-added">+   _print_raw(0),</span>
<span class="udiff-line-added">+   _cur_insn(NULL),</span>
<span class="udiff-line-added">+   _bytes_per_line(0),</span>
<span class="udiff-line-added">+   _pre_decode_alignment(0),</span>
<span class="udiff-line-added">+   _post_decode_alignment(0),</span>
<span class="udiff-line-added">+   _print_file_name(false),</span>
<span class="udiff-line-added">+   _print_help(false),</span>
<span class="udiff-line-added">+   _helpPrinted(false) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="udiff-line-added">+   _strings.copy(c);</span>
<span class="udiff-line-added">+   process_options(_output);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Constructor for a &#39;decode_env&#39; to decode a memory range [start, end)</span>
<span class="udiff-line-added">+ // of unknown origin, assuming it contains code.</span>
<span class="udiff-line-added">+ decode_env::decode_env(address start, address end, outputStream* output) :</span>
<span class="udiff-line-added">+   _output(output ? output : tty),</span>
<span class="udiff-line-added">+   _codeBuffer(NULL),</span>
<span class="udiff-line-added">+   _codeBlob(NULL),</span>
<span class="udiff-line-added">+   _nm(NULL),</span>
<span class="udiff-line-added">+   _strings(),</span>
<span class="udiff-line-added">+   _start(start),</span>
<span class="udiff-line-added">+   _end(end),</span>
<span class="udiff-line-added">+   _option_buf(),</span>
<span class="udiff-line-added">+   _print_raw(0),</span>
<span class="udiff-line-added">+   _cur_insn(NULL),</span>
<span class="udiff-line-added">+   _bytes_per_line(0),</span>
<span class="udiff-line-added">+   _pre_decode_alignment(0),</span>
<span class="udiff-line-added">+   _post_decode_alignment(0),</span>
<span class="udiff-line-added">+   _print_file_name(false),</span>
<span class="udiff-line-added">+   _print_help(false),</span>
<span class="udiff-line-added">+   _helpPrinted(false) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(start &lt; end, &quot;Range must have a positive size, [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;).&quot;, p2i(start), p2i(end));</span>
<span class="udiff-line-added">+   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="udiff-line-added">+   process_options(_output);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   // parse the global option string:</span>
<span class="udiff-line-modified-added">+ void decode_env::process_options(outputStream* ost) {</span>
<span class="udiff-line-added">+   // by default, output pc but not bytes:</span>
<span class="udiff-line-added">+   _print_help      = false;</span>
<span class="udiff-line-added">+   _bytes_per_line  = Disassembler::pd_instruction_alignment();</span>
<span class="udiff-line-added">+   _print_file_name = true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // parse the global option string</span>
<span class="udiff-line-added">+   // We need to fill the options buffer for each newly created</span>
<span class="udiff-line-added">+   // decode_env instance. The hsdis_* library looks for options</span>
<span class="udiff-line-added">+   // in that buffer.</span>
    collect_options(Disassembler::pd_cpu_opts());
    collect_options(PrintAssemblyOptions);
  
<span class="udiff-line-modified-removed">-   if (strstr(options(), &quot;hsdis-&quot;)) {</span>
<span class="udiff-line-modified-removed">-     if (strstr(options(), &quot;hsdis-print-raw&quot;))</span>
<span class="udiff-line-removed">-       _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);</span>
<span class="udiff-line-removed">-     if (strstr(options(), &quot;hsdis-print-pc&quot;))</span>
<span class="udiff-line-removed">-       _print_pc = !_print_pc;</span>
<span class="udiff-line-removed">-     if (strstr(options(), &quot;hsdis-print-bytes&quot;))</span>
<span class="udiff-line-removed">-       _print_bytes = !_print_bytes;</span>
<span class="udiff-line-modified-added">+   if (strstr(options(), &quot;print-raw&quot;)) {</span>
<span class="udiff-line-modified-added">+     _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (_optionsParsed) return;  // parse only once</span>
<span class="udiff-line-added">+ </span>
    if (strstr(options(), &quot;help&quot;)) {
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;  hsdis-print-raw       test plugin by requesting raw output&quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;  hsdis-print-raw-xml   test plugin by requesting raw xml&quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;  hsdis-print-pc        turn off PC printing (on by default)&quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;  hsdis-print-bytes     turn on instruction byte output&quot;);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;combined options: %s&quot;, options());</span>
<span class="udiff-line-modified-added">+     _print_help = true;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (strstr(options(), &quot;align-instr&quot;)) {</span>
<span class="udiff-line-modified-added">+     AbstractDisassembler::toggle_align_instr();</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (strstr(options(), &quot;show-pc&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_pc();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-offset&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_offset();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-bytes&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_bytes();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-data-hex&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_data_hex();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-data-int&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_data_int();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-data-float&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_data_float();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-structs&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_structs();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-comment&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_comment();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (strstr(options(), &quot;show-block-comment&quot;)) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::toggle_show_block_comment();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _optionsParsed = true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (_print_help &amp;&amp; ! _helpPrinted) {</span>
<span class="udiff-line-added">+     _helpPrinted = true;</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  print-raw       test plugin by requesting raw output&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  print-raw-xml   test plugin by requesting raw xml&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;cr();</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-pc            toggle printing current pc,        currently %s&quot;, AbstractDisassembler::show_pc()            ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-offset        toggle printing current offset,    currently %s&quot;, AbstractDisassembler::show_offset()        ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-bytes         toggle printing instruction bytes, currently %s&quot;, AbstractDisassembler::show_bytes()         ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-data-hex      toggle formatting data as hex,     currently %s&quot;, AbstractDisassembler::show_data_hex()      ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-data-int      toggle formatting data as int,     currently %s&quot;, AbstractDisassembler::show_data_int()      ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-data-float    toggle formatting data as float,   currently %s&quot;, AbstractDisassembler::show_data_float()    ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-structs       toggle compiler data structures,   currently %s&quot;, AbstractDisassembler::show_structs()       ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-comment       toggle instruction comments,       currently %s&quot;, AbstractDisassembler::show_comment()       ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  show-block-comment toggle block comments,             currently %s&quot;, AbstractDisassembler::show_block_comment() ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;  align-instr        toggle instruction alignment,      currently %s&quot;, AbstractDisassembler::align_instr()        ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="udiff-line-added">+     ost-&gt;print_cr(&quot;combined options: %s&quot;, options());</span>
    }
  }
  
<span class="udiff-line-added">+ // Disassembly Event Handler.</span>
<span class="udiff-line-added">+ // This method receives events from the disassembler library hsdis</span>
<span class="udiff-line-added">+ // via event_to_env for each decoding step (installed by</span>
<span class="udiff-line-added">+ // Disassembler::decode_instructions(), replacing the default</span>
<span class="udiff-line-added">+ // callback method). This enables dumping additional info</span>
<span class="udiff-line-added">+ // and custom line formatting.</span>
<span class="udiff-line-added">+ // In a future extension, calling a custom decode method will be</span>
<span class="udiff-line-added">+ // supported. We can use such a method to decode instructions the</span>
<span class="udiff-line-added">+ // binutils decoder does not handle to our liking (suboptimal</span>
<span class="udiff-line-added">+ // formatting, incomplete information, ...).</span>
<span class="udiff-line-added">+ // Returns:</span>
<span class="udiff-line-added">+ // - NULL for all standard invocations. The function result is not</span>
<span class="udiff-line-added">+ //        examined (as of now, 20190409) by the hsdis decoder loop.</span>
<span class="udiff-line-added">+ // - next for &#39;insn0&#39; invocations.</span>
<span class="udiff-line-added">+ //        next == arg: the custom decoder didn&#39;t do anything.</span>
<span class="udiff-line-added">+ //        next &gt;  arg: the custom decoder did decode the instruction.</span>
<span class="udiff-line-added">+ //                     next points to the next undecoded instruction</span>
<span class="udiff-line-added">+ //                     (continuation point for decoder loop).</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // &quot;Normal&quot; sequence of events:</span>
<span class="udiff-line-added">+ //  insns   - start of instruction stream decoding</span>
<span class="udiff-line-added">+ //  mach    - display architecture</span>
<span class="udiff-line-added">+ //  format  - display bytes-per-line</span>
<span class="udiff-line-added">+ //  for each instruction:</span>
<span class="udiff-line-added">+ //    insn    - start of instruction decoding</span>
<span class="udiff-line-added">+ //    insn0   - custom decoder invocation (if any)</span>
<span class="udiff-line-added">+ //    addr    - print address value</span>
<span class="udiff-line-added">+ //    /insn   - end of instruction decoding</span>
<span class="udiff-line-added">+ //  /insns  - premature end of instruction stream due to no progress</span>
<span class="udiff-line-added">+ //</span>
  address decode_env::handle_event(const char* event, address arg) {
<span class="udiff-line-modified-removed">-   if (match(event, &quot;insn&quot;)) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: end decoding loop (error, no progress)  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;/insns&quot;)) {</span>
<span class="udiff-line-added">+     // Nothing to be done here.</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: start decoding loop  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;insns&quot;)) {</span>
<span class="udiff-line-added">+     // Nothing to be done here.</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: finish decoding an instruction  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;/insn&quot;)) {</span>
<span class="udiff-line-added">+     output()-&gt;fill_to(_post_decode_alignment);</span>
<span class="udiff-line-added">+     end_insn(arg);</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: start decoding an instruction  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;insn&quot;)) {</span>
      start_insn(arg);
    } else if (match(event, &quot;/insn&quot;)) {
      end_insn(arg);
    } else if (match(event, &quot;addr&quot;)) {
      if (arg != NULL) {
        print_address(arg);
        return arg;
      }
<span class="udiff-line-modified-removed">-   } else if (match(event, &quot;mach&quot;)) {</span>
<span class="udiff-line-modified-removed">-     static char buffer[32] = { 0, };</span>
<span class="udiff-line-modified-removed">-     if (strcmp(buffer, (const char*)arg) != 0 ||</span>
<span class="udiff-line-modified-removed">-         strlen((const char*)arg) &gt; sizeof(buffer) - 1) {</span>
<span class="udiff-line-modified-added">+     calculate_alignment();</span>
<span class="udiff-line-modified-added">+     output()-&gt;fill_to(_pre_decode_alignment);</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: call custom decoder (platform specific)  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;insn0&quot;)) {</span>
<span class="udiff-line-added">+     return Disassembler::decode_instruction0(arg, output(), arg);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: Print address  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;addr&quot;)) {</span>
<span class="udiff-line-added">+     print_address(arg);</span>
<span class="udiff-line-added">+     return arg;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: mach (inform about machine architecture)  &gt;---</span>
<span class="udiff-line-added">+   // This event is problematic because it messes up the output.</span>
<span class="udiff-line-added">+   // The event is fired after the instruction address has already</span>
<span class="udiff-line-added">+   // been printed. The decoded instruction (event &quot;insn&quot;) is</span>
<span class="udiff-line-added">+   // printed afterwards. That doesn&#39;t look nice.</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;mach&quot;)) {</span>
<span class="udiff-line-added">+     guarantee(arg != NULL, &quot;event_to_env - arg must not be NULL for event &#39;mach&#39;&quot;);</span>
<span class="udiff-line-added">+     static char buffer[64] = { 0, };</span>
<span class="udiff-line-added">+     // Output suppressed because it messes up disassembly.</span>
<span class="udiff-line-added">+     // Only print this when the mach changes.</span>
<span class="udiff-line-added">+     if (false &amp;&amp; (strcmp(buffer, (const char*)arg) != 0 ||</span>
<span class="udiff-line-added">+                   strlen((const char*)arg) &gt; sizeof(buffer) - 1)) {</span>
        // Only print this when the mach changes
        strncpy(buffer, (const char*)arg, sizeof(buffer) - 1);
        buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
<span class="udiff-line-modified-removed">-       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, arg);</span>
<span class="udiff-line-modified-added">+       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, (const char*)arg);</span>
      }
<span class="udiff-line-modified-removed">-   } else if (match(event, &quot;format bytes-per-line&quot;)) {</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   //---&lt;  Event: format bytes-per-line  &gt;---</span>
<span class="udiff-line-added">+   if (decode_env::match(event, &quot;format bytes-per-line&quot;)) {</span>
      _bytes_per_line = (int) (intptr_t) arg;
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-removed">-     // ignore unrecognized markup</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
    }
<span class="udiff-line-added">+ #endif</span>
    return NULL;
  }
  
<span class="udiff-line-added">+ static void* event_to_env(void* env_pv, const char* event, void* arg) {</span>
<span class="udiff-line-added">+   decode_env* env = (decode_env*) env_pv;</span>
<span class="udiff-line-added">+   return env-&gt;handle_event(event, (address) arg);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // called by the disassembler to print out jump targets and data addresses
  void decode_env::print_address(address adr) {
<span class="udiff-line-modified-removed">-   outputStream* st = _output;</span>
<span class="udiff-line-modified-added">+   outputStream* st = output();</span>
  
    if (adr == NULL) {
      st-&gt;print(&quot;NULL&quot;);
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -470,13 +640,15 @@</span>
    }
  
    if (_nm == NULL) {
      // Don&#39;t do this for native methods, as the function name will be printed in
      // nmethod::reloc_string_for().
<span class="udiff-line-modified-removed">-     ResourceMark rm;</span>
<span class="udiff-line-modified-added">+     // Allocate the buffer on the stack instead of as RESOURCE array.</span>
<span class="udiff-line-added">+     // In case we do DecodeErrorFile, Thread will not be initialized,</span>
<span class="udiff-line-added">+     // causing a &quot;assert(current != __null) failed&quot; failure.</span>
      const int buflen = 1024;
<span class="udiff-line-modified-removed">-     char* buf = NEW_RESOURCE_ARRAY(char, buflen);</span>
<span class="udiff-line-modified-added">+     char buf[buflen];</span>
      int offset;
      if (os::dll_address_to_function_name(adr, buf, buflen, &amp;offset)) {
        st-&gt;print(PTR_FORMAT &quot; = %s&quot;,  p2i(adr), buf);
        if (offset != 0) {
          st-&gt;print(&quot;+%d&quot;, offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -488,58 +660,35 @@</span>
    // Fall through to a simple (hexadecimal) numeral.
    st-&gt;print(PTR_FORMAT, p2i(adr));
  }
  
  void decode_env::print_insn_labels() {
<span class="udiff-line-modified-removed">-   address p = cur_insn();</span>
<span class="udiff-line-modified-removed">-   outputStream* st = output();</span>
<span class="udiff-line-modified-removed">-   CodeBlob* cb = _code;</span>
<span class="udiff-line-removed">-   if (cb != NULL) {</span>
<span class="udiff-line-removed">-     cb-&gt;print_block_comment(st, p);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   _strings.print_block_comment(st, (intptr_t)(p - _start + _offset));</span>
<span class="udiff-line-removed">-   if (_print_pc) {</span>
<span class="udiff-line-removed">-     st-&gt;print(&quot;  &quot; PTR_FORMAT &quot;: &quot;, p2i(p));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   if (AbstractDisassembler::show_block_comment()) {</span>
<span class="udiff-line-modified-added">+     address       p  = cur_insn();</span>
<span class="udiff-line-modified-added">+     outputStream* st = output();</span>
  
<span class="udiff-line-modified-removed">- void decode_env::print_insn_bytes(address pc, address pc_limit) {</span>
<span class="udiff-line-modified-removed">-   outputStream* st = output();</span>
<span class="udiff-line-modified-removed">-   size_t incr = 1;</span>
<span class="udiff-line-modified-removed">-   size_t perline = _bytes_per_line;</span>
<span class="udiff-line-modified-removed">-   if ((size_t) Disassembler::pd_instruction_alignment() &gt;= sizeof(int)</span>
<span class="udiff-line-modified-removed">-       &amp;&amp; !((uintptr_t)pc % sizeof(int))</span>
<span class="udiff-line-modified-removed">-       &amp;&amp; !((uintptr_t)pc_limit % sizeof(int))) {</span>
<span class="udiff-line-modified-removed">-     incr = sizeof(int);</span>
<span class="udiff-line-modified-removed">-     if (perline % incr)  perline += incr - (perline % incr);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   while (pc &lt; pc_limit) {</span>
<span class="udiff-line-removed">-     // tab to the desired column:</span>
<span class="udiff-line-removed">-     st-&gt;move_to(COMMENT_COLUMN);</span>
<span class="udiff-line-removed">-     address pc0 = pc;</span>
<span class="udiff-line-removed">-     address pc1 = pc + perline;</span>
<span class="udiff-line-removed">-     if (pc1 &gt; pc_limit)  pc1 = pc_limit;</span>
<span class="udiff-line-removed">-     for (; pc &lt; pc1; pc += incr) {</span>
<span class="udiff-line-removed">-       if (pc == pc0) {</span>
<span class="udiff-line-removed">-         st-&gt;print(BYTES_COMMENT);</span>
<span class="udiff-line-removed">-       } else if ((uint)(pc - pc0) % sizeof(int) == 0) {</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot; &quot;);         // put out a space on word boundaries</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (incr == sizeof(int)) {</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot;%08x&quot;, *(int*)pc);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot;%02x&quot;, (*pc)&amp;0xFF);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+     //---&lt;  Block comments for nmethod  &gt;---</span>
<span class="udiff-line-modified-added">+     // Outputs a bol() before and a cr() after, but only if a comment is printed.</span>
<span class="udiff-line-modified-added">+     // Prints nmethod_section_label as well.</span>
<span class="udiff-line-modified-added">+     if (_nm != NULL) {</span>
<span class="udiff-line-modified-added">+       _nm-&gt;print_block_comment(st, p);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (_codeBlob != NULL) {</span>
<span class="udiff-line-modified-added">+       _codeBlob-&gt;print_block_comment(st, p);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if (_codeBuffer != NULL) {</span>
<span class="udiff-line-modified-added">+       _codeBuffer-&gt;print_block_comment(st, p);</span>
      }
<span class="udiff-line-modified-removed">-     st-&gt;cr();</span>
<span class="udiff-line-modified-added">+     _strings.print_block_comment(st, (intptr_t)(p - _start));</span>
    }
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- static void* event_to_env(void* env_pv, const char* event, void* arg) {</span>
<span class="udiff-line-modified-removed">-   decode_env* env = (decode_env*) env_pv;</span>
<span class="udiff-line-modified-removed">-   return env-&gt;handle_event(event, (address) arg);</span>
<span class="udiff-line-modified-added">+ void decode_env::print_insn_prefix() {</span>
<span class="udiff-line-modified-added">+   address       p  = cur_insn();</span>
<span class="udiff-line-modified-added">+   outputStream* st = output();</span>
<span class="udiff-line-modified-added">+   AbstractDisassembler::print_location(p, _start, _end, st, false, false);</span>
<span class="udiff-line-added">+   AbstractDisassembler::print_instruction(p, Assembler::instr_len(p), Assembler::instr_maxlen(), st, true, false);</span>
  }
  
  ATTRIBUTE_PRINTF(2, 3)
  static int printf_to_env(void* env_pv, const char* format, ...) {
    decode_env* env = (decode_env*) env_pv;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -568,20 +717,35 @@</span>
    julong cnt1 = st-&gt;count();
    va_end(ap);
    return (int)(cnt1 - cnt0);
  }
  
<span class="udiff-line-modified-removed">- address decode_env::decode_instructions(address start, address end) {</span>
<span class="udiff-line-modified-removed">-   _start = start; _end = end;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   assert(((((intptr_t)start | (intptr_t)end) % Disassembler::pd_instruction_alignment()) == 0), &quot;misaligned insn addr&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   const int show_bytes = false; // for disassembler debugging</span>
<span class="udiff-line-modified-added">+ // The &#39;original_start&#39; argument holds the the original address where</span>
<span class="udiff-line-modified-added">+ // the instructions were located in the originating system. If zero (NULL)</span>
<span class="udiff-line-modified-added">+ // is passed in, there is no original address.</span>
<span class="udiff-line-modified-added">+ address decode_env::decode_instructions(address start, address end, address original_start /* = 0*/) {</span>
<span class="udiff-line-modified-added">+   // CodeComment in Stubs.</span>
<span class="udiff-line-modified-added">+   // Properly initialize _start/_end. Overwritten too often if</span>
<span class="udiff-line-added">+   // printing of instructions is called for each instruction.</span>
<span class="udiff-line-added">+   assert((_start == NULL) || (start == NULL) || (_start == start), &quot;don&#39;t overwrite CTOR values&quot;);</span>
<span class="udiff-line-added">+   assert((_end   == NULL) || (end   == NULL) || (_end   == end  ), &quot;don&#39;t overwrite CTOR values&quot;);</span>
<span class="udiff-line-added">+   if (start != NULL) set_start(start);</span>
<span class="udiff-line-added">+   if (end   != NULL) set_end(end);</span>
<span class="udiff-line-added">+   if (original_start == NULL) {</span>
<span class="udiff-line-added">+     original_start = start;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   //_version = Disassembler::pd_cpu_version();</span>
<span class="udiff-line-modified-added">+   //---&lt;  Check (and correct) alignment  &gt;---</span>
<span class="udiff-line-added">+   // Don&#39;t check alignment of end, it is not aligned.</span>
<span class="udiff-line-added">+   if (((uint64_t)start &amp; ((uint64_t)Disassembler::pd_instruction_alignment() - 1)) != 0) {</span>
<span class="udiff-line-added">+     output()-&gt;print_cr(&quot;Decode range start:&quot; PTR_FORMAT &quot;: ... (unaligned)&quot;, p2i(start));</span>
<span class="udiff-line-added">+     start = (address)((uint64_t)start &amp; ~((uint64_t)Disassembler::pd_instruction_alignment() - 1));</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   if (!Disassembler::can_decode()) {</span>
<span class="udiff-line-modified-added">+   // Trying to decode instructions doesn&#39;t make sense if we</span>
<span class="udiff-line-added">+   // couldn&#39;t load the disassembler library.</span>
<span class="udiff-line-added">+   if (Disassembler::is_abstract()) {</span>
      return NULL;
    }
  
    // decode a series of instructions and return the end of the last instruction
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -618,20 +782,186 @@</span>
                                            &amp;event_to_env,  (void*) this,
                                            &amp;printf_to_env, (void*) this,
                                            options());
  }
  
<span class="udiff-line-added">+ // ----------------------------------------------------------------------------</span>
<span class="udiff-line-added">+ // Disassembler</span>
<span class="udiff-line-added">+ // Used as a static wrapper for decode_env.</span>
<span class="udiff-line-added">+ // Each method will create a decode_env before decoding.</span>
<span class="udiff-line-added">+ // You can call the decode_env methods directly if you already have one.</span>
  
<span class="udiff-line-modified-removed">- void Disassembler::decode(CodeBlob* cb, outputStream* st) {</span>
<span class="udiff-line-modified-removed">-   ttyLocker ttyl;</span>
<span class="udiff-line-modified-removed">-   if (!load_library())  return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool Disassembler::load_library(outputStream* st) {</span>
<span class="udiff-line-modified-added">+   // Do not try to load multiple times. Failed once -&gt; fails always.</span>
<span class="udiff-line-added">+   // To force retry in debugger: assign _tried_to_load_library=0</span>
<span class="udiff-line-added">+   if (_tried_to_load_library) {</span>
<span class="udiff-line-added">+     return _library_usable;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   // Print to given stream, if any.</span>
<span class="udiff-line-added">+   // Print to tty if Verbose is on and no stream given.</span>
<span class="udiff-line-added">+   st = ((st == NULL) &amp;&amp; Verbose) ? tty : st;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Compute fully qualified library name.</span>
<span class="udiff-line-added">+   char ebuf[1024];</span>
<span class="udiff-line-added">+   char buf[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   os::jvm_path(buf, sizeof(buf));</span>
<span class="udiff-line-added">+   int jvm_offset = -1;</span>
<span class="udiff-line-added">+   int lib_offset = -1;</span>
<span class="udiff-line-added">+ #ifdef STATIC_BUILD</span>
<span class="udiff-line-added">+   char* p = strrchr(buf, &#39;/&#39;);</span>
<span class="udiff-line-added">+   *p = &#39;\0&#39;;</span>
<span class="udiff-line-added">+   strcat(p, &quot;/lib/&quot;);</span>
<span class="udiff-line-added">+   lib_offset = jvm_offset = strlen(buf);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     // Match &quot;libjvm&quot; instead of &quot;jvm&quot; on *nix platforms. Creates better matches.</span>
<span class="udiff-line-added">+     // Match &quot;[lib]jvm[^/]*&quot; in jvm_path.</span>
<span class="udiff-line-added">+     const char* base = buf;</span>
<span class="udiff-line-added">+     const char* p = strrchr(buf, *os::file_separator());</span>
<span class="udiff-line-added">+     if (p != NULL) lib_offset = p - base + 1; // this points to the first char after separator</span>
<span class="udiff-line-added">+ #ifdef _WIN32</span>
<span class="udiff-line-added">+     p = strstr(p ? p : base, &quot;jvm&quot;);</span>
<span class="udiff-line-added">+     if (p != NULL) jvm_offset = p - base;     // this points to &#39;j&#39; in jvm.</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     p = strstr(p ? p : base, &quot;libjvm&quot;);</span>
<span class="udiff-line-added">+     if (p != NULL) jvm_offset = p - base + 3; // this points to &#39;j&#39; in libjvm.</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Find the disassembler shared library.</span>
<span class="udiff-line-added">+   // Search for several paths derived from libjvm, in this order:</span>
<span class="udiff-line-added">+   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)</span>
<span class="udiff-line-added">+   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-added">+   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-added">+   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="udiff-line-added">+   if (jvm_offset &gt;= 0) {</span>
<span class="udiff-line-added">+     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-added">+     strcpy(&amp;buf[jvm_offset], hsdis_library_name);</span>
<span class="udiff-line-added">+     strcat(&amp;buf[jvm_offset], os::dll_file_extension());</span>
<span class="udiff-line-added">+     if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="udiff-line-added">+     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-added">+     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {</span>
<span class="udiff-line-added">+       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-added">+       strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="udiff-line-added">+       strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="udiff-line-added">+       if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="udiff-line-added">+       _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {</span>
<span class="udiff-line-added">+       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="udiff-line-added">+       buf[lib_offset - 1] = &#39;\0&#39;;</span>
<span class="udiff-line-added">+       const char* p = strrchr(buf, *os::file_separator());</span>
<span class="udiff-line-added">+       if (p != NULL) {</span>
<span class="udiff-line-added">+         lib_offset = p - buf + 1;</span>
<span class="udiff-line-added">+         strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="udiff-line-added">+         strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="udiff-line-added">+         if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="udiff-line-added">+         _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_library == NULL) {</span>
<span class="udiff-line-added">+     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="udiff-line-added">+     strcpy(&amp;buf[0], hsdis_library_name);</span>
<span class="udiff-line-added">+     strcat(&amp;buf[0], os::dll_file_extension());</span>
<span class="udiff-line-added">+     if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s via LD_LIBRARY_PATH or equivalent&quot;, buf);</span>
<span class="udiff-line-added">+     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // load the decoder function to use (new or old version).</span>
<span class="udiff-line-added">+   if (_library != NULL) {</span>
<span class="udiff-line-added">+     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,</span>
<span class="udiff-line-added">+                                           os::dll_lookup(_library, decode_instructions_virtual_name));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {</span>
<span class="udiff-line-added">+     // could not spot in new version, try old version</span>
<span class="udiff-line-added">+     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,</span>
<span class="udiff-line-added">+                                           os::dll_lookup(_library, decode_instructions_name));</span>
<span class="udiff-line-added">+     use_new_version = false;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     use_new_version = true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _tried_to_load_library = true;</span>
<span class="udiff-line-added">+   _library_usable        = _decode_instructions_virtual != NULL || _decode_instructions != NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Create a dummy environment to initialize PrintAssemblyOptions.</span>
<span class="udiff-line-added">+   // The PrintAssemblyOptions must be known for abstract disassemblies as well.</span>
<span class="udiff-line-added">+   decode_env dummy((unsigned char*)(&amp;buf[0]), (unsigned char*)(&amp;buf[1]), st);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Report problems during dll_load or dll_lookup, if any.</span>
<span class="udiff-line-added">+   if (st != NULL) {</span>
<span class="udiff-line-added">+     // Success.</span>
<span class="udiff-line-added">+     if (_library_usable) {</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       st-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;,</span>
<span class="udiff-line-added">+                    buf,</span>
<span class="udiff-line-added">+                    ((_library != NULL)</span>
<span class="udiff-line-added">+                     ? &quot;entry point is missing&quot;</span>
<span class="udiff-line-added">+                     : ((WizardMode || PrintMiscellaneous)</span>
<span class="udiff-line-added">+                        ? (const char*)ebuf</span>
<span class="udiff-line-added">+                        : &quot;library not loadable&quot;)),</span>
<span class="udiff-line-added">+                    &quot;PrintAssembly defaults to abstract disassembly.&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   return _library_usable;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Directly disassemble code buffer.</span>
<span class="udiff-line-added">+ void Disassembler::decode(CodeBuffer* cb, address start, address end, outputStream* st) {</span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   //---&lt;  Test memory before decoding  &gt;---</span>
<span class="udiff-line-added">+   if (!(cb-&gt;contains(start) &amp;&amp; cb-&gt;contains(end))) {</span>
<span class="udiff-line-added">+     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="udiff-line-added">+     if (st != NULL) {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not contained in CodeBuffer&quot;, p2i(start), p2i(end));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!os::is_readable_range(start, end)) {</span>
<span class="udiff-line-added">+     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="udiff-line-added">+     if (st != NULL) {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not readable&quot;, p2i(start), p2i(end));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   decode_env env(cb, st);</span>
<span class="udiff-line-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-added">+   env.output()-&gt;print(&quot;Decoding CodeBuffer (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb));</span>
<span class="udiff-line-added">+   if (cb-&gt;name() != NULL) {</span>
<span class="udiff-line-added">+     env.output()-&gt;print(&quot;, name: %s,&quot;, cb-&gt;name());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(start), p2i(end), ((jlong)(end - start)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (is_abstract()) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::decode_abstract(start, end, env.output(), Assembler::instr_maxlen());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     env.decode_instructions(start, end);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Directly disassemble code blob.</span>
<span class="udiff-line-added">+ void Disassembler::decode(CodeBlob* cb, outputStream* st, CodeStrings c) {</span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
    if (cb-&gt;is_nmethod()) {
<span class="udiff-line-modified-removed">-     decode((nmethod*)cb, st);</span>
<span class="udiff-line-modified-added">+     // If we  have an nmethod at hand,</span>
<span class="udiff-line-added">+     // call the specialized decoder directly.</span>
<span class="udiff-line-added">+     decode((nmethod*)cb, st, c);</span>
      return;
    }
<span class="udiff-line-added">+ </span>
    decode_env env(cb, st);
<span class="udiff-line-modified-removed">-   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
    if (cb-&gt;is_aot()) {
      env.output()-&gt;print(&quot;A &quot;);
      if (cb-&gt;is_compiled()) {
        CompiledMethod* cm = (CompiledMethod*)cb;
        env.output()-&gt;print(&quot;%d &quot;,cm-&gt;compile_id());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -641,62 +971,82 @@</span>
        cm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
      } else {
        env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
      }
    } else {
<span class="udiff-line-modified-removed">-     env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());</span>
<span class="udiff-line-modified-added">+     env.output()-&gt;print(&quot;Decoding CodeBlob&quot;);</span>
<span class="udiff-line-added">+     if (cb-&gt;name() != NULL) {</span>
<span class="udiff-line-added">+       env.output()-&gt;print(&quot;, name: %s,&quot;, cb-&gt;name());</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-modified-removed">-   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())) * sizeof(unsigned char*));</span>
<span class="udiff-line-removed">-   env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())));</span>
  
<span class="udiff-line-modified-removed">- void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c,</span>
<span class="udiff-line-modified-removed">-                           ptrdiff_t offset) {</span>
<span class="udiff-line-modified-removed">-   ttyLocker ttyl;</span>
<span class="udiff-line-modified-removed">-   if (!load_library())  return;</span>
<span class="udiff-line-modified-removed">-   decode_env env(CodeCache::find_blob_unsafe(start), st, c, offset);</span>
<span class="udiff-line-modified-removed">-   env.decode_instructions(start, end);</span>
<span class="udiff-line-modified-added">+   if (is_abstract()) {</span>
<span class="udiff-line-modified-added">+     AbstractDisassembler::decode_abstract(cb-&gt;code_begin(), cb-&gt;code_end(), env.output(), Assembler::instr_maxlen());</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
<span class="udiff-line-modified-removed">- void Disassembler::decode(nmethod* nm, outputStream* st) {</span>
<span class="udiff-line-modified-added">+ // Decode a nmethod.</span>
<span class="udiff-line-added">+ // This includes printing the constant pool and all code segments.</span>
<span class="udiff-line-added">+ // The nmethod data structures (oop maps, relocations and the like) are not printed.</span>
<span class="udiff-line-added">+ void Disassembler::decode(nmethod* nm, outputStream* st, CodeStrings c) {</span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
    ttyLocker ttyl;
<span class="udiff-line-removed">-   if (!load_library())  return;</span>
<span class="udiff-line-removed">-   decode_env env(nm, st);</span>
<span class="udiff-line-removed">-   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   unsigned char* p   = nm-&gt;code_begin();</span>
<span class="udiff-line-removed">-   unsigned char* end = nm-&gt;code_end();</span>
  
<span class="udiff-line-modified-removed">-   nm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="udiff-line-modified-removed">-   env.output()-&gt;print(&quot;.&quot;);</span>
<span class="udiff-line-modified-removed">-   nm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="udiff-line-modified-removed">-   nm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());</span>
<span class="udiff-line-modified-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-removed">-     char buffer[O_BUFLEN];</span>
<span class="udiff-line-modified-removed">-     char* jvmciName = nm-&gt;jvmci_installed_code_name(buffer, O_BUFLEN);</span>
<span class="udiff-line-modified-removed">-     if (jvmciName != NULL) {</span>
<span class="udiff-line-removed">-       env.output()-&gt;print(&quot; (%s)&quot;, jvmciName);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   decode_env env(nm, st);</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-modified-added">+   nm-&gt;print_constant_pool(env.output());</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-modified-added">+   env.output()-&gt;cr();</span>
<span class="udiff-line-modified-added">+   if (is_abstract()) {</span>
<span class="udiff-line-modified-added">+     AbstractDisassembler::decode_abstract(nm-&gt;code_begin(), nm-&gt;code_end(), env.output(), Assembler::instr_maxlen());</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     env.decode_instructions(nm-&gt;code_begin(), nm-&gt;code_end());</span>
    }
<span class="udiff-line-added">+   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
  #endif
<span class="udiff-line-modified-removed">-   env.output()-&gt;print_cr(&quot;  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(p), p2i(end), ((jlong)(end - p)));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Print constant table.</span>
<span class="udiff-line-modified-removed">-   if (nm-&gt;consts_size() &gt; 0) {</span>
<span class="udiff-line-modified-removed">-     nm-&gt;print_nmethod_labels(env.output(), nm-&gt;consts_begin());</span>
<span class="udiff-line-modified-removed">-     int offset = 0;</span>
<span class="udiff-line-modified-removed">-     for (address p = nm-&gt;consts_begin(); p &lt; nm-&gt;consts_end(); p += 4, offset += 4) {</span>
<span class="udiff-line-modified-removed">-       if ((offset % 8) == 0) {</span>
<span class="udiff-line-modified-removed">-         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT &quot;   &quot; PTR64_FORMAT, p2i(p), offset, *((int32_t*) p), *((int64_t*) p));</span>
<span class="udiff-line-modified-removed">-       } else {</span>
<span class="udiff-line-removed">-         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT,                    p2i(p), offset, *((int32_t*) p));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Decode a range, given as [start address, end address)</span>
<span class="udiff-line-modified-added">+ void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c /*, ptrdiff_t offset */) {</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-modified-added">+   //---&lt;  Test memory before decoding  &gt;---</span>
<span class="udiff-line-modified-added">+   if (!os::is_readable_range(start, end)) {</span>
<span class="udiff-line-modified-added">+     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="udiff-line-modified-added">+     if (st != NULL) {</span>
<span class="udiff-line-modified-added">+       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not readable&quot;, p2i(start), p2i(end));</span>
      }
<span class="udiff-line-added">+     return;</span>
    }
  
<span class="udiff-line-modified-removed">-   env.decode_instructions(p, end);</span>
<span class="udiff-line-modified-added">+   if (is_abstract()) {</span>
<span class="udiff-line-added">+     AbstractDisassembler::decode_abstract(start, end, st, Assembler::instr_maxlen());</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Don&#39;t do that fancy stuff. If we just have two addresses, live with it</span>
<span class="udiff-line-added">+ // and treat the memory contents as &quot;amorphic&quot; piece of code.</span>
<span class="udiff-line-added">+ #if 0</span>
<span class="udiff-line-added">+   CodeBlob* cb = CodeCache::find_blob_unsafe(start);</span>
<span class="udiff-line-added">+   if (cb != NULL) {</span>
<span class="udiff-line-added">+     // If we  have an CodeBlob at hand,</span>
<span class="udiff-line-added">+     // call the specialized decoder directly.</span>
<span class="udiff-line-added">+     decode(cb, st, c);</span>
<span class="udiff-line-added">+   } else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     // This seems to be just a chunk of memory.</span>
<span class="udiff-line-added">+     decode_env env(start, end, st);</span>
<span class="udiff-line-added">+     env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-added">+     env.decode_instructions(start, end);</span>
<span class="udiff-line-added">+     env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  // To prevent excessive code expansion in the interpreter generator, we
  // do not inline this function into Disassembler::hook().
  void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {
</pre>
<center><a href="compilerOracle.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/compiler/compilerDefinitions.cpp b/src/hotspot/share/compiler/compilerDefinitions.cpp
--- a/src/hotspot/share/compiler/compilerDefinitions.cpp
+++ b/src/hotspot/share/compiler/compilerDefinitions.cpp
@@ -35,28 +35,44 @@
   "c1",
   "c2",
   "jvmci"
 };
 
+#ifdef TIERED
+bool CompilationModeFlag::_quick_only = false;
+bool CompilationModeFlag::_high_only = false;
+bool CompilationModeFlag::_high_only_quick_internal = false;
+
+
+bool CompilationModeFlag::initialize() {
+  if (CompilationMode != NULL) {
+    if (strcmp(CompilationMode, "default") == 0) {
+      // Do nothing, just support the "default" keyword.
+    } else if (strcmp(CompilationMode, "quick-only") == 0) {
+      _quick_only = true;
+    } else if (strcmp(CompilationMode, "high-only") == 0) {
+      _high_only = true;
+    } else if (strcmp(CompilationMode, "high-only-quick-internal") == 0) {
+      _high_only_quick_internal = true;
+    } else {
+      jio_fprintf(defaultStream::error_stream(), "Unsupported compilation mode '%s', supported modes are: quick-only, high-only, high-only-quick-internal\n", CompilationMode);
+      return false;
+    }
+  }
+  return true;
+}
+
+#endif
+
 #if defined(COMPILER2)
 CompLevel  CompLevel_highest_tier      = CompLevel_full_optimization;  // pure C2 and tiered or JVMCI and tiered
 #elif defined(COMPILER1)
 CompLevel  CompLevel_highest_tier      = CompLevel_simple;             // pure C1 or JVMCI
 #else
 CompLevel  CompLevel_highest_tier      = CompLevel_none;
 #endif
 
-#if defined(TIERED)
-CompLevel  CompLevel_initial_compile   = CompLevel_full_profile;        // tiered
-#elif defined(COMPILER1) || INCLUDE_JVMCI
-CompLevel  CompLevel_initial_compile   = CompLevel_simple;              // pure C1 or JVMCI
-#elif defined(COMPILER2)
-CompLevel  CompLevel_initial_compile   = CompLevel_full_optimization;   // pure C2
-#else
-CompLevel  CompLevel_initial_compile   = CompLevel_none;
-#endif
-
 #if defined(COMPILER2)
 CompMode  Compilation_mode             = CompMode_server;
 #elif defined(COMPILER1)
 CompMode  Compilation_mode             = CompMode_client;
 #else
@@ -114,57 +130,56 @@
 
 #ifdef TIERED
 void set_client_compilation_mode() {
   Compilation_mode = CompMode_client;
   CompLevel_highest_tier = CompLevel_simple;
-  CompLevel_initial_compile = CompLevel_simple;
-  FLAG_SET_ERGO(bool, TieredCompilation, false);
-  FLAG_SET_ERGO(bool, ProfileInterpreter, false);
+  FLAG_SET_ERGO(TieredCompilation, false);
+  FLAG_SET_ERGO(ProfileInterpreter, false);
 #if INCLUDE_JVMCI
-  FLAG_SET_ERGO(bool, EnableJVMCI, false);
-  FLAG_SET_ERGO(bool, UseJVMCICompiler, false);
+  FLAG_SET_ERGO(EnableJVMCI, false);
+  FLAG_SET_ERGO(UseJVMCICompiler, false);
 #endif
 #if INCLUDE_AOT
-  FLAG_SET_ERGO(bool, UseAOT, false);
+  FLAG_SET_ERGO(UseAOT, false);
 #endif
   if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {
-    FLAG_SET_ERGO(bool, NeverActAsServerClassMachine, true);
+    FLAG_SET_ERGO(NeverActAsServerClassMachine, true);
   }
   if (FLAG_IS_DEFAULT(InitialCodeCacheSize)) {
-    FLAG_SET_ERGO(uintx, InitialCodeCacheSize, 160*K);
+    FLAG_SET_ERGO(InitialCodeCacheSize, 160*K);
   }
   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
-    FLAG_SET_ERGO(uintx, ReservedCodeCacheSize, 32*M);
+    FLAG_SET_ERGO(ReservedCodeCacheSize, 32*M);
   }
   if (FLAG_IS_DEFAULT(NonProfiledCodeHeapSize)) {
-    FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 27*M);
+    FLAG_SET_ERGO(NonProfiledCodeHeapSize, 27*M);
   }
   if (FLAG_IS_DEFAULT(ProfiledCodeHeapSize)) {
-    FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0);
+    FLAG_SET_ERGO(ProfiledCodeHeapSize, 0);
   }
   if (FLAG_IS_DEFAULT(NonNMethodCodeHeapSize)) {
-    FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 5*M);
+    FLAG_SET_ERGO(NonNMethodCodeHeapSize, 5*M);
   }
   if (FLAG_IS_DEFAULT(CodeCacheExpansionSize)) {
-    FLAG_SET_ERGO(uintx, CodeCacheExpansionSize, 32*K);
+    FLAG_SET_ERGO(CodeCacheExpansionSize, 32*K);
   }
   if (FLAG_IS_DEFAULT(MetaspaceSize)) {
-    FLAG_SET_ERGO(size_t, MetaspaceSize, MIN2(12*M, MaxMetaspaceSize));
+    FLAG_SET_ERGO(MetaspaceSize, MIN2(12*M, MaxMetaspaceSize));
   }
   if (FLAG_IS_DEFAULT(MaxRAM)) {
     // Do not use FLAG_SET_ERGO to update MaxRAM, as this will impact
     // heap setting done based on available phys_mem (see Arguments::set_heap_size).
     FLAG_SET_DEFAULT(MaxRAM, 1ULL*G);
   }
   if (FLAG_IS_DEFAULT(CompileThreshold)) {
-    FLAG_SET_ERGO(intx, CompileThreshold, 1500);
+    FLAG_SET_ERGO(CompileThreshold, 1500);
   }
   if (FLAG_IS_DEFAULT(OnStackReplacePercentage)) {
-    FLAG_SET_ERGO(intx, OnStackReplacePercentage, 933);
+    FLAG_SET_ERGO(OnStackReplacePercentage, 933);
   }
   if (FLAG_IS_DEFAULT(CICompilerCount)) {
-    FLAG_SET_ERGO(intx, CICompilerCount, 1);
+    FLAG_SET_ERGO(CICompilerCount, 1);
   }
 }
 
 bool compilation_mode_selected() {
   return !FLAG_IS_DEFAULT(TieredCompilation) ||
@@ -175,111 +190,163 @@
 }
 
 void select_compilation_mode_ergonomically() {
 #if defined(_WINDOWS) && !defined(_LP64)
   if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {
-    FLAG_SET_ERGO(bool, NeverActAsServerClassMachine, true);
+    FLAG_SET_ERGO(NeverActAsServerClassMachine, true);
   }
 #endif
   if (NeverActAsServerClassMachine) {
     set_client_compilation_mode();
   }
 }
 
-#endif // TIERED
 
 void CompilerConfig::set_tiered_flags() {
-  // With tiered, set default policy to SimpleThresholdPolicy, which is 2.
-  if (FLAG_IS_DEFAULT(CompilationPolicyChoice)) {
-    FLAG_SET_DEFAULT(CompilationPolicyChoice, 2);
-  }
-  if (CompilationPolicyChoice < 2) {
-    vm_exit_during_initialization(
-      "Incompatible compilation policy selected", NULL);
-  }
   // Increase the code cache size - tiered compiles a lot more.
   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
-    FLAG_SET_ERGO(uintx, ReservedCodeCacheSize,
+    FLAG_SET_ERGO(ReservedCodeCacheSize,
                   MIN2(CODE_CACHE_DEFAULT_LIMIT, (size_t)ReservedCodeCacheSize * 5));
   }
   // Enable SegmentedCodeCache if TieredCompilation is enabled, ReservedCodeCacheSize >= 240M
   // and the code cache contains at least 8 pages (segmentation disables advantage of huge pages).
   if (FLAG_IS_DEFAULT(SegmentedCodeCache) && ReservedCodeCacheSize >= 240*M &&
       8 * CodeCache::page_size() <= ReservedCodeCacheSize) {
-    FLAG_SET_ERGO(bool, SegmentedCodeCache, true);
+    FLAG_SET_ERGO(SegmentedCodeCache, true);
   }
   if (!UseInterpreter) { // -Xcomp
     Tier3InvokeNotifyFreqLog = 0;
     Tier4InvocationThreshold = 0;
   }
 
   if (CompileThresholdScaling < 0) {
     vm_exit_during_initialization("Negative value specified for CompileThresholdScaling", NULL);
   }
 
+  if (CompilationModeFlag::disable_intermediate()) {
+    if (FLAG_IS_DEFAULT(Tier0ProfilingStartPercentage)) {
+      FLAG_SET_DEFAULT(Tier0ProfilingStartPercentage, 33);
+    }
+  }
+
   // Scale tiered compilation thresholds.
   // CompileThresholdScaling == 0.0 is equivalent to -Xint and leaves compilation thresholds unchanged.
   if (!FLAG_IS_DEFAULT(CompileThresholdScaling) && CompileThresholdScaling > 0.0) {
-    FLAG_SET_ERGO(intx, Tier0InvokeNotifyFreqLog, scaled_freq_log(Tier0InvokeNotifyFreqLog));
-    FLAG_SET_ERGO(intx, Tier0BackedgeNotifyFreqLog, scaled_freq_log(Tier0BackedgeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier0InvokeNotifyFreqLog, scaled_freq_log(Tier0InvokeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier0BackedgeNotifyFreqLog, scaled_freq_log(Tier0BackedgeNotifyFreqLog));
 
-    FLAG_SET_ERGO(intx, Tier3InvocationThreshold, scaled_compile_threshold(Tier3InvocationThreshold));
-    FLAG_SET_ERGO(intx, Tier3MinInvocationThreshold, scaled_compile_threshold(Tier3MinInvocationThreshold));
-    FLAG_SET_ERGO(intx, Tier3CompileThreshold, scaled_compile_threshold(Tier3CompileThreshold));
-    FLAG_SET_ERGO(intx, Tier3BackEdgeThreshold, scaled_compile_threshold(Tier3BackEdgeThreshold));
+    FLAG_SET_ERGO(Tier3InvocationThreshold, scaled_compile_threshold(Tier3InvocationThreshold));
+    FLAG_SET_ERGO(Tier3MinInvocationThreshold, scaled_compile_threshold(Tier3MinInvocationThreshold));
+    FLAG_SET_ERGO(Tier3CompileThreshold, scaled_compile_threshold(Tier3CompileThreshold));
+    FLAG_SET_ERGO(Tier3BackEdgeThreshold, scaled_compile_threshold(Tier3BackEdgeThreshold));
 
     // Tier2{Invocation,MinInvocation,Compile,Backedge}Threshold should be scaled here
     // once these thresholds become supported.
 
-    FLAG_SET_ERGO(intx, Tier2InvokeNotifyFreqLog, scaled_freq_log(Tier2InvokeNotifyFreqLog));
-    FLAG_SET_ERGO(intx, Tier2BackedgeNotifyFreqLog, scaled_freq_log(Tier2BackedgeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier2InvokeNotifyFreqLog, scaled_freq_log(Tier2InvokeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier2BackedgeNotifyFreqLog, scaled_freq_log(Tier2BackedgeNotifyFreqLog));
+
+    FLAG_SET_ERGO(Tier3InvokeNotifyFreqLog, scaled_freq_log(Tier3InvokeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier3BackedgeNotifyFreqLog, scaled_freq_log(Tier3BackedgeNotifyFreqLog));
 
-    FLAG_SET_ERGO(intx, Tier3InvokeNotifyFreqLog, scaled_freq_log(Tier3InvokeNotifyFreqLog));
-    FLAG_SET_ERGO(intx, Tier3BackedgeNotifyFreqLog, scaled_freq_log(Tier3BackedgeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier23InlineeNotifyFreqLog, scaled_freq_log(Tier23InlineeNotifyFreqLog));
 
-    FLAG_SET_ERGO(intx, Tier23InlineeNotifyFreqLog, scaled_freq_log(Tier23InlineeNotifyFreqLog));
+    FLAG_SET_ERGO(Tier4InvocationThreshold, scaled_compile_threshold(Tier4InvocationThreshold));
+    FLAG_SET_ERGO(Tier4MinInvocationThreshold, scaled_compile_threshold(Tier4MinInvocationThreshold));
+    FLAG_SET_ERGO(Tier4CompileThreshold, scaled_compile_threshold(Tier4CompileThreshold));
+    FLAG_SET_ERGO(Tier4BackEdgeThreshold, scaled_compile_threshold(Tier4BackEdgeThreshold));
 
-    FLAG_SET_ERGO(intx, Tier4InvocationThreshold, scaled_compile_threshold(Tier4InvocationThreshold));
-    FLAG_SET_ERGO(intx, Tier4MinInvocationThreshold, scaled_compile_threshold(Tier4MinInvocationThreshold));
-    FLAG_SET_ERGO(intx, Tier4CompileThreshold, scaled_compile_threshold(Tier4CompileThreshold));
-    FLAG_SET_ERGO(intx, Tier4BackEdgeThreshold, scaled_compile_threshold(Tier4BackEdgeThreshold));
+    if (CompilationModeFlag::disable_intermediate()) {
+      FLAG_SET_ERGO(Tier40InvocationThreshold, scaled_compile_threshold(Tier40InvocationThreshold));
+      FLAG_SET_ERGO(Tier40MinInvocationThreshold, scaled_compile_threshold(Tier40MinInvocationThreshold));
+      FLAG_SET_ERGO(Tier40CompileThreshold, scaled_compile_threshold(Tier40CompileThreshold));
+      FLAG_SET_ERGO(Tier40BackEdgeThreshold, scaled_compile_threshold(Tier40BackEdgeThreshold));
+    }
+
+#if INCLUDE_AOT
+    if (UseAOT) {
+      FLAG_SET_ERGO(Tier3AOTInvocationThreshold, scaled_compile_threshold(Tier3AOTInvocationThreshold));
+      FLAG_SET_ERGO(Tier3AOTMinInvocationThreshold, scaled_compile_threshold(Tier3AOTMinInvocationThreshold));
+      FLAG_SET_ERGO(Tier3AOTCompileThreshold, scaled_compile_threshold(Tier3AOTCompileThreshold));
+      FLAG_SET_ERGO(Tier3AOTBackEdgeThreshold, scaled_compile_threshold(Tier3AOTBackEdgeThreshold));
+
+      if (CompilationModeFlag::disable_intermediate()) {
+        FLAG_SET_ERGO(Tier0AOTInvocationThreshold, scaled_compile_threshold(Tier0AOTInvocationThreshold));
+        FLAG_SET_ERGO(Tier0AOTMinInvocationThreshold, scaled_compile_threshold(Tier0AOTMinInvocationThreshold));
+        FLAG_SET_ERGO(Tier0AOTCompileThreshold, scaled_compile_threshold(Tier0AOTCompileThreshold));
+        FLAG_SET_ERGO(Tier0AOTBackEdgeThreshold, scaled_compile_threshold(Tier0AOTBackEdgeThreshold));
+      }
+    }
+#endif // INCLUDE_AOT
   }
 }
 
+#endif // TIERED
+
 #if INCLUDE_JVMCI
 void set_jvmci_specific_flags() {
   if (UseJVMCICompiler) {
     Compilation_mode = CompMode_server;
 
     if (FLAG_IS_DEFAULT(TypeProfileWidth)) {
       FLAG_SET_DEFAULT(TypeProfileWidth, 8);
     }
-    if (FLAG_IS_DEFAULT(OnStackReplacePercentage)) {
-      FLAG_SET_DEFAULT(OnStackReplacePercentage, 933);
-    }
-    // JVMCI needs values not less than defaults
-    if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
-      FLAG_SET_DEFAULT(ReservedCodeCacheSize, MAX2(64*M, ReservedCodeCacheSize));
-    }
-    if (FLAG_IS_DEFAULT(InitialCodeCacheSize)) {
-      FLAG_SET_DEFAULT(InitialCodeCacheSize, MAX2(16*M, InitialCodeCacheSize));
-    }
-    if (FLAG_IS_DEFAULT(MetaspaceSize)) {
-      FLAG_SET_DEFAULT(MetaspaceSize, MIN2(MAX2(12*M, MetaspaceSize), MaxMetaspaceSize));
-    }
-    if (FLAG_IS_DEFAULT(NewSizeThreadIncrease)) {
-      FLAG_SET_DEFAULT(NewSizeThreadIncrease, MAX2(4*K, NewSizeThreadIncrease));
-    }
-    if (TieredStopAtLevel != CompLevel_full_optimization) {
-      // Currently JVMCI compiler can only work at the full optimization level
-      warning("forcing TieredStopAtLevel to full optimization because JVMCI is enabled");
-      FLAG_SET_ERGO(intx, TieredStopAtLevel, CompLevel_full_optimization);
-    }
     if (FLAG_IS_DEFAULT(TypeProfileLevel)) {
       FLAG_SET_DEFAULT(TypeProfileLevel, 0);
     }
-  }
+
+    if (UseJVMCINativeLibrary) {
+      // SVM compiled code requires more stack space
+      if (FLAG_IS_DEFAULT(CompilerThreadStackSize)) {
+        // Duplicate logic in the implementations of os::create_thread
+        // so that we can then double the computed stack size. Once
+        // the stack size requirements of SVM are better understood,
+        // this logic can be pushed down into os::create_thread.
+        int stack_size = CompilerThreadStackSize;
+        if (stack_size == 0) {
+          stack_size = VMThreadStackSize;
+        }
+        if (stack_size != 0) {
+          FLAG_SET_DEFAULT(CompilerThreadStackSize, stack_size * 2);
+        }
+      }
+    } else {
+#ifdef TIERED
+      if (!TieredCompilation) {
+         warning("Disabling tiered compilation with non-native JVMCI compiler is not recommended. "
+                 "Turning on tiered compilation and disabling intermediate compilation levels instead. ");
+         FLAG_SET_ERGO(TieredCompilation, true);
+         if (CompilationModeFlag::normal()) {
+           CompilationModeFlag::set_high_only_quick_internal(true);
+         }
+         if (CICompilerCount < 2 && CompilationModeFlag::quick_internal()) {
+            warning("Increasing number of compiler threads for JVMCI compiler.");
+            FLAG_SET_ERGO(CICompilerCount, 2);
+         }
+      }
+#else // TIERED
+      // Adjust the on stack replacement percentage to avoid early
+      // OSR compilations while JVMCI itself is warming up
+      if (FLAG_IS_DEFAULT(OnStackReplacePercentage)) {
+        FLAG_SET_DEFAULT(OnStackReplacePercentage, 933);
+      }
+#endif // !TIERED
+      // JVMCI needs values not less than defaults
+      if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
+        FLAG_SET_DEFAULT(ReservedCodeCacheSize, MAX2(64*M, ReservedCodeCacheSize));
+      }
+      if (FLAG_IS_DEFAULT(InitialCodeCacheSize)) {
+        FLAG_SET_DEFAULT(InitialCodeCacheSize, MAX2(16*M, InitialCodeCacheSize));
+      }
+      if (FLAG_IS_DEFAULT(MetaspaceSize)) {
+        FLAG_SET_DEFAULT(MetaspaceSize, MIN2(MAX2(12*M, MetaspaceSize), MaxMetaspaceSize));
+      }
+      if (FLAG_IS_DEFAULT(NewSizeThreadIncrease)) {
+        FLAG_SET_DEFAULT(NewSizeThreadIncrease, MAX2(4*K, NewSizeThreadIncrease));
+      }
+    } // !UseJVMCINativeLibrary
+  } // UseJVMCICompiler
 }
 #endif // INCLUDE_JVMCI
 
 bool CompilerConfig::check_args_consistency(bool status) {
   // Check lower bounds of the code cache
@@ -316,19 +383,19 @@
 
   if (BackgroundCompilation && ReplayCompiles) {
     if (!FLAG_IS_DEFAULT(BackgroundCompilation)) {
       warning("BackgroundCompilation disabled due to ReplayCompiles option.");
     }
-    FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
+    FLAG_SET_CMDLINE(BackgroundCompilation, false);
   }
 
 #ifdef COMPILER2
   if (PostLoopMultiversioning && !RangeCheckElimination) {
     if (!FLAG_IS_DEFAULT(PostLoopMultiversioning)) {
       warning("PostLoopMultiversioning disabled because RangeCheckElimination is disabled.");
     }
-    FLAG_SET_CMDLINE(bool, PostLoopMultiversioning, false);
+    FLAG_SET_CMDLINE(PostLoopMultiversioning, false);
   }
   if (UseCountedLoopSafepoints && LoopStripMiningIter == 0) {
     if (!FLAG_IS_DEFAULT(UseCountedLoopSafepoints) || !FLAG_IS_DEFAULT(LoopStripMiningIter)) {
       warning("When counted loop safepoints are enabled, LoopStripMiningIter must be at least 1 (a safepoint every 1 iteration): setting it to 1");
     }
@@ -344,31 +411,31 @@
   if (Arguments::is_interpreter_only()) {
     if (UseCompiler) {
       if (!FLAG_IS_DEFAULT(UseCompiler)) {
         warning("UseCompiler disabled due to -Xint.");
       }
-      FLAG_SET_CMDLINE(bool, UseCompiler, false);
+      FLAG_SET_CMDLINE(UseCompiler, false);
     }
     if (ProfileInterpreter) {
       if (!FLAG_IS_DEFAULT(ProfileInterpreter)) {
         warning("ProfileInterpreter disabled due to -Xint.");
       }
-      FLAG_SET_CMDLINE(bool, ProfileInterpreter, false);
+      FLAG_SET_CMDLINE(ProfileInterpreter, false);
     }
     if (TieredCompilation) {
       if (!FLAG_IS_DEFAULT(TieredCompilation)) {
         warning("TieredCompilation disabled due to -Xint.");
       }
-      FLAG_SET_CMDLINE(bool, TieredCompilation, false);
+      FLAG_SET_CMDLINE(TieredCompilation, false);
     }
 #if INCLUDE_JVMCI
     if (EnableJVMCI) {
       if (!FLAG_IS_DEFAULT(EnableJVMCI) || !FLAG_IS_DEFAULT(UseJVMCICompiler)) {
         warning("JVMCI Compiler disabled due to -Xint.");
       }
-      FLAG_SET_CMDLINE(bool, EnableJVMCI, false);
-      FLAG_SET_CMDLINE(bool, UseJVMCICompiler, false);
+      FLAG_SET_CMDLINE(EnableJVMCI, false);
+      FLAG_SET_CMDLINE(UseJVMCICompiler, false);
     }
 #endif
   } else {
 #if INCLUDE_JVMCI
     status = status && JVMCIGlobals::check_jvmci_flags_are_consistent();
@@ -390,31 +457,25 @@
 
 #if INCLUDE_JVMCI
   // Check that JVMCI compiler supports selested GC.
   // Should be done after GCConfig::initialize() was called.
   JVMCIGlobals::check_jvmci_supported_gc();
+
+  // Do JVMCI specific settings
   set_jvmci_specific_flags();
 #endif
 
+#ifdef TIERED
   if (TieredCompilation) {
     set_tiered_flags();
-  } else {
-    int max_compilation_policy_choice = 1;
-#ifdef COMPILER2
-    if (is_server_compilation_mode_vm()) {
-      max_compilation_policy_choice = 2;
-    }
+  } else
 #endif
-    // Check if the policy is valid.
-    if (CompilationPolicyChoice >= max_compilation_policy_choice) {
-      vm_exit_during_initialization(
-        "Incompatible compilation policy selected", NULL);
-    }
+  {
     // Scale CompileThreshold
     // CompileThresholdScaling == 0.0 is equivalent to -Xint and leaves CompileThreshold unchanged.
     if (!FLAG_IS_DEFAULT(CompileThresholdScaling) && CompileThresholdScaling > 0.0) {
-      FLAG_SET_ERGO(intx, CompileThreshold, scaled_compile_threshold(CompileThreshold));
+      FLAG_SET_ERGO(CompileThreshold, scaled_compile_threshold(CompileThreshold));
     }
   }
 
   if (UseOnStackReplacement && !UseLoopCounter) {
     warning("On-stack-replacement requires loop counters; enabling loop counters");
@@ -431,11 +492,11 @@
 #ifndef PRODUCT
   if (!IncrementalInline) {
     AlwaysIncrementalInline = false;
   }
   if (PrintIdealGraphLevel > 0) {
-    FLAG_SET_ERGO(bool, PrintIdealGraph, true);
+    FLAG_SET_ERGO(PrintIdealGraph, true);
   }
 #endif
   if (!UseTypeSpeculation && FLAG_IS_DEFAULT(TypeProfileLevel)) {
     // nothing to use the profiling, turn if off
     FLAG_SET_DEFAULT(TypeProfileLevel, 0);

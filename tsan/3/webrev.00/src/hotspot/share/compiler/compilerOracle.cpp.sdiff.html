<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/compilerOracle.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerDirectives.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerOracle.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compilerOracle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;

 27 #include &quot;compiler/compilerOracle.hpp&quot;
 28 #include &quot;compiler/methodMatcher.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/oopFactory.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/klass.hpp&quot;
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/symbol.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/jniHandles.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 
 39 enum OptionType {
 40   IntxType,
 41   UintxType,
 42   BoolType,
 43   CcstrType,
 44   DoubleType,
 45   UnknownType
 46 };
</pre>
<hr />
<pre>
362 bool CompilerOracle::should_print_methods() {
363   return lists[PrintCommand] != NULL;
364 }
365 
366 bool CompilerOracle::should_log(const methodHandle&amp; method) {
367   if (!LogCompilation)            return false;
368   if (lists[LogCommand] == NULL)  return true;  // by default, log all
369   return (check_predicate(LogCommand, method));
370 }
371 
372 bool CompilerOracle::should_break_at(const methodHandle&amp; method) {
373   return check_predicate(BreakCommand, method);
374 }
375 
376 static OracleCommand parse_command_name(const char * line, int* bytes_read) {
377   assert(ARRAY_SIZE(command_names) == OracleCommandCount,
378          &quot;command_names size mismatch&quot;);
379 
380   *bytes_read = 0;
381   char command[33];
<span class="line-modified">382   int result = sscanf(line, &quot;%32[a-z]%n&quot;, command, bytes_read);</span>
<span class="line-modified">383   for (uint i = 0; i &lt; ARRAY_SIZE(command_names); i++) {</span>
<span class="line-modified">384     if (strcmp(command, command_names[i]) == 0) {</span>
<span class="line-modified">385       return (OracleCommand)i;</span>


386     }
387   }
388   return UnknownCommand;
389 }
390 
391 static void usage() {
392   tty-&gt;cr();
393   tty-&gt;print_cr(&quot;The CompileCommand option enables the user of the JVM to control specific&quot;);
394   tty-&gt;print_cr(&quot;behavior of the dynamic compilers. Many commands require a pattern that defines&quot;);
395   tty-&gt;print_cr(&quot;the set of methods the command shall be applied to. The CompileCommand&quot;);
396   tty-&gt;print_cr(&quot;option provides the following commands:&quot;);
397   tty-&gt;cr();
398   tty-&gt;print_cr(&quot;  break,&lt;pattern&gt;       - debug breakpoint in compiler and in generated code&quot;);
399   tty-&gt;print_cr(&quot;  print,&lt;pattern&gt;       - print assembly&quot;);
400   tty-&gt;print_cr(&quot;  exclude,&lt;pattern&gt;     - don&#39;t compile or inline&quot;);
401   tty-&gt;print_cr(&quot;  inline,&lt;pattern&gt;      - always inline&quot;);
402   tty-&gt;print_cr(&quot;  dontinline,&lt;pattern&gt;  - don&#39;t inline&quot;);
403   tty-&gt;print_cr(&quot;  compileonly,&lt;pattern&gt; - compile only&quot;);
404   tty-&gt;print_cr(&quot;  log,&lt;pattern&gt;         - log compilation&quot;);
405   tty-&gt;print_cr(&quot;  option,&lt;pattern&gt;,&lt;option type&gt;,&lt;option name&gt;,&lt;value&gt;&quot;);
</pre>
<hr />
<pre>
721 
722 void CompilerOracle::parse_from_string(const char* str, void (*parse_line)(char*)) {
723   char token[1024];
724   int  pos = 0;
725   const char* sp = str;
726   int  c = *sp++;
727   while (c != &#39;\0&#39; &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
728     if (c == &#39;\n&#39;) {
729       token[pos++] = &#39;\0&#39;;
730       parse_line(token);
731       pos = 0;
732     } else {
733       token[pos++] = c;
734     }
735     c = *sp++;
736   }
737   token[pos++] = &#39;\0&#39;;
738   parse_line(token);
739 }
740 
<span class="line-removed">741 void CompilerOracle::append_comment_to_file(const char* message) {</span>
<span class="line-removed">742   assert(has_command_file(), &quot;command file must be specified&quot;);</span>
<span class="line-removed">743   fileStream stream(fopen(cc_file(), &quot;at&quot;));</span>
<span class="line-removed">744   stream.print(&quot;# &quot;);</span>
<span class="line-removed">745   for (int index = 0; message[index] != &#39;\0&#39;; index++) {</span>
<span class="line-removed">746     stream.put(message[index]);</span>
<span class="line-removed">747     if (message[index] == &#39;\n&#39;) stream.print(&quot;# &quot;);</span>
<span class="line-removed">748   }</span>
<span class="line-removed">749   stream.cr();</span>
<span class="line-removed">750 }</span>
<span class="line-removed">751 </span>
<span class="line-removed">752 void CompilerOracle::append_exclude_to_file(const methodHandle&amp; method) {</span>
<span class="line-removed">753   assert(has_command_file(), &quot;command file must be specified&quot;);</span>
<span class="line-removed">754   fileStream stream(fopen(cc_file(), &quot;at&quot;));</span>
<span class="line-removed">755   stream.print(&quot;exclude &quot;);</span>
<span class="line-removed">756   method-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">757   stream.print(&quot;.&quot;);</span>
<span class="line-removed">758   method-&gt;name()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">759   method-&gt;signature()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">760   stream.cr();</span>
<span class="line-removed">761   stream.cr();</span>
<span class="line-removed">762 }</span>
<span class="line-removed">763 </span>
<span class="line-removed">764 </span>
765 void compilerOracle_init() {
766   CompilerOracle::parse_from_string(CompileCommand, CompilerOracle::parse_from_line);
767   CompilerOracle::parse_from_string(CompileOnly, CompilerOracle::parse_compile_only);
768   if (CompilerOracle::has_command_file()) {
769     CompilerOracle::parse_from_file();
770   } else {
771     struct stat buf;
772     if (os::stat(default_cc_file, &amp;buf) == 0) {
773       warning(&quot;%s file is present but has been ignored.  &quot;
774               &quot;Run with -XX:CompileCommandFile=%s to load the file.&quot;,
775               default_cc_file, default_cc_file);
776     }
777   }
778   if (lists[PrintCommand] != NULL) {
779     if (PrintAssembly) {
780       warning(&quot;CompileCommand and/or %s file contains &#39;print&#39; commands, but PrintAssembly is also enabled&quot;, default_cc_file);
781     } else if (FLAG_IS_DEFAULT(DebugNonSafepoints)) {
782       warning(&quot;printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output&quot;);
783       DebugNonSafepoints = true;
784     }
</pre>
<hr />
<pre>
835       if (className == NULL) {
836         ShouldNotReachHere();
837       } else {
838         // missing class name handled as &quot;Any&quot; class match
839         if (className[0] == &#39;\0&#39;) {
840           c_match = MethodMatcher::Any;
841         }
842       }
843     }
844 
845     // each directive is terminated by , or NUL or . followed by NUL
846     if (*line == &#39;,&#39; || *line == &#39;\0&#39; || (line[0] == &#39;.&#39; &amp;&amp; line[1] == &#39;\0&#39;)) {
847       if (methodName == NULL) {
848         methodName = &quot;&quot;;
849         if (*line != method_sep) {
850           m_match = MethodMatcher::Any;
851         }
852       }
853 
854       EXCEPTION_MARK;
<span class="line-modified">855       Symbol* c_name = SymbolTable::new_symbol(className, CHECK);</span>
<span class="line-modified">856       Symbol* m_name = SymbolTable::new_symbol(methodName, CHECK);</span>
857       Symbol* signature = NULL;
858 
859       BasicMatcher* bm = new BasicMatcher();
860       bm-&gt;init(c_name, c_match, m_name, m_match, signature);
861       add_predicate(CompileOnlyCommand, bm);
862       if (PrintVMOptions) {
863         tty-&gt;print(&quot;CompileOnly: compileonly &quot;);
864         lists[CompileOnlyCommand]-&gt;print_all(tty);
865       }
866 
867       className = NULL;
868       methodName = NULL;
869     }
870 
871     line = *line == &#39;\0&#39; ? line : line + 1;
872   }
873 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
<span class="line-added"> 27 #include &quot;classfile/symbolTable.hpp&quot;</span>
 28 #include &quot;compiler/compilerOracle.hpp&quot;
 29 #include &quot;compiler/methodMatcher.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/oopFactory.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;oops/klass.hpp&quot;
 34 #include &quot;oops/method.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/jniHandles.hpp&quot;
 38 #include &quot;runtime/os.hpp&quot;
 39 
 40 enum OptionType {
 41   IntxType,
 42   UintxType,
 43   BoolType,
 44   CcstrType,
 45   DoubleType,
 46   UnknownType
 47 };
</pre>
<hr />
<pre>
363 bool CompilerOracle::should_print_methods() {
364   return lists[PrintCommand] != NULL;
365 }
366 
367 bool CompilerOracle::should_log(const methodHandle&amp; method) {
368   if (!LogCompilation)            return false;
369   if (lists[LogCommand] == NULL)  return true;  // by default, log all
370   return (check_predicate(LogCommand, method));
371 }
372 
373 bool CompilerOracle::should_break_at(const methodHandle&amp; method) {
374   return check_predicate(BreakCommand, method);
375 }
376 
377 static OracleCommand parse_command_name(const char * line, int* bytes_read) {
378   assert(ARRAY_SIZE(command_names) == OracleCommandCount,
379          &quot;command_names size mismatch&quot;);
380 
381   *bytes_read = 0;
382   char command[33];
<span class="line-modified">383   int matches = sscanf(line, &quot;%32[a-z]%n&quot;, command, bytes_read);</span>
<span class="line-modified">384   if (matches &gt; 0) {</span>
<span class="line-modified">385     for (uint i = 0; i &lt; ARRAY_SIZE(command_names); i++) {</span>
<span class="line-modified">386       if (strcmp(command, command_names[i]) == 0) {</span>
<span class="line-added">387         return (OracleCommand)i;</span>
<span class="line-added">388       }</span>
389     }
390   }
391   return UnknownCommand;
392 }
393 
394 static void usage() {
395   tty-&gt;cr();
396   tty-&gt;print_cr(&quot;The CompileCommand option enables the user of the JVM to control specific&quot;);
397   tty-&gt;print_cr(&quot;behavior of the dynamic compilers. Many commands require a pattern that defines&quot;);
398   tty-&gt;print_cr(&quot;the set of methods the command shall be applied to. The CompileCommand&quot;);
399   tty-&gt;print_cr(&quot;option provides the following commands:&quot;);
400   tty-&gt;cr();
401   tty-&gt;print_cr(&quot;  break,&lt;pattern&gt;       - debug breakpoint in compiler and in generated code&quot;);
402   tty-&gt;print_cr(&quot;  print,&lt;pattern&gt;       - print assembly&quot;);
403   tty-&gt;print_cr(&quot;  exclude,&lt;pattern&gt;     - don&#39;t compile or inline&quot;);
404   tty-&gt;print_cr(&quot;  inline,&lt;pattern&gt;      - always inline&quot;);
405   tty-&gt;print_cr(&quot;  dontinline,&lt;pattern&gt;  - don&#39;t inline&quot;);
406   tty-&gt;print_cr(&quot;  compileonly,&lt;pattern&gt; - compile only&quot;);
407   tty-&gt;print_cr(&quot;  log,&lt;pattern&gt;         - log compilation&quot;);
408   tty-&gt;print_cr(&quot;  option,&lt;pattern&gt;,&lt;option type&gt;,&lt;option name&gt;,&lt;value&gt;&quot;);
</pre>
<hr />
<pre>
724 
725 void CompilerOracle::parse_from_string(const char* str, void (*parse_line)(char*)) {
726   char token[1024];
727   int  pos = 0;
728   const char* sp = str;
729   int  c = *sp++;
730   while (c != &#39;\0&#39; &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
731     if (c == &#39;\n&#39;) {
732       token[pos++] = &#39;\0&#39;;
733       parse_line(token);
734       pos = 0;
735     } else {
736       token[pos++] = c;
737     }
738     c = *sp++;
739   }
740   token[pos++] = &#39;\0&#39;;
741   parse_line(token);
742 }
743 
























744 void compilerOracle_init() {
745   CompilerOracle::parse_from_string(CompileCommand, CompilerOracle::parse_from_line);
746   CompilerOracle::parse_from_string(CompileOnly, CompilerOracle::parse_compile_only);
747   if (CompilerOracle::has_command_file()) {
748     CompilerOracle::parse_from_file();
749   } else {
750     struct stat buf;
751     if (os::stat(default_cc_file, &amp;buf) == 0) {
752       warning(&quot;%s file is present but has been ignored.  &quot;
753               &quot;Run with -XX:CompileCommandFile=%s to load the file.&quot;,
754               default_cc_file, default_cc_file);
755     }
756   }
757   if (lists[PrintCommand] != NULL) {
758     if (PrintAssembly) {
759       warning(&quot;CompileCommand and/or %s file contains &#39;print&#39; commands, but PrintAssembly is also enabled&quot;, default_cc_file);
760     } else if (FLAG_IS_DEFAULT(DebugNonSafepoints)) {
761       warning(&quot;printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output&quot;);
762       DebugNonSafepoints = true;
763     }
</pre>
<hr />
<pre>
814       if (className == NULL) {
815         ShouldNotReachHere();
816       } else {
817         // missing class name handled as &quot;Any&quot; class match
818         if (className[0] == &#39;\0&#39;) {
819           c_match = MethodMatcher::Any;
820         }
821       }
822     }
823 
824     // each directive is terminated by , or NUL or . followed by NUL
825     if (*line == &#39;,&#39; || *line == &#39;\0&#39; || (line[0] == &#39;.&#39; &amp;&amp; line[1] == &#39;\0&#39;)) {
826       if (methodName == NULL) {
827         methodName = &quot;&quot;;
828         if (*line != method_sep) {
829           m_match = MethodMatcher::Any;
830         }
831       }
832 
833       EXCEPTION_MARK;
<span class="line-modified">834       Symbol* c_name = SymbolTable::new_symbol(className);</span>
<span class="line-modified">835       Symbol* m_name = SymbolTable::new_symbol(methodName);</span>
836       Symbol* signature = NULL;
837 
838       BasicMatcher* bm = new BasicMatcher();
839       bm-&gt;init(c_name, c_match, m_name, m_match, signature);
840       add_predicate(CompileOnlyCommand, bm);
841       if (PrintVMOptions) {
842         tty-&gt;print(&quot;CompileOnly: compileonly &quot;);
843         lists[CompileOnlyCommand]-&gt;print_all(tty);
844       }
845 
846       className = NULL;
847       methodName = NULL;
848     }
849 
850     line = *line == &#39;\0&#39; ? line : line + 1;
851   }
852 }
</pre>
</td>
</tr>
</table>
<center><a href="compilerDirectives.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerOracle.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
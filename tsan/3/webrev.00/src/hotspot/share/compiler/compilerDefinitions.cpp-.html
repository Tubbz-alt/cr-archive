<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/compiler/compilerDefinitions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;runtime/globals.hpp&quot;
 28 #include &quot;runtime/globals_extension.hpp&quot;
 29 #include &quot;compiler/compilerDefinitions.hpp&quot;
 30 #include &quot;gc/shared/gcConfig.hpp&quot;
 31 #include &quot;utilities/defaultStream.hpp&quot;
 32 
 33 const char* compilertype2name_tab[compiler_number_of_types] = {
 34   &quot;&quot;,
 35   &quot;c1&quot;,
 36   &quot;c2&quot;,
 37   &quot;jvmci&quot;
 38 };
 39 
 40 #if defined(COMPILER2)
 41 CompLevel  CompLevel_highest_tier      = CompLevel_full_optimization;  // pure C2 and tiered or JVMCI and tiered
 42 #elif defined(COMPILER1)
 43 CompLevel  CompLevel_highest_tier      = CompLevel_simple;             // pure C1 or JVMCI
 44 #else
 45 CompLevel  CompLevel_highest_tier      = CompLevel_none;
 46 #endif
 47 
 48 #if defined(TIERED)
 49 CompLevel  CompLevel_initial_compile   = CompLevel_full_profile;        // tiered
 50 #elif defined(COMPILER1) || INCLUDE_JVMCI
 51 CompLevel  CompLevel_initial_compile   = CompLevel_simple;              // pure C1 or JVMCI
 52 #elif defined(COMPILER2)
 53 CompLevel  CompLevel_initial_compile   = CompLevel_full_optimization;   // pure C2
 54 #else
 55 CompLevel  CompLevel_initial_compile   = CompLevel_none;
 56 #endif
 57 
 58 #if defined(COMPILER2)
 59 CompMode  Compilation_mode             = CompMode_server;
 60 #elif defined(COMPILER1)
 61 CompMode  Compilation_mode             = CompMode_client;
 62 #else
 63 CompMode  Compilation_mode             = CompMode_none;
 64 #endif
 65 
 66 // Returns threshold scaled with CompileThresholdScaling
 67 intx CompilerConfig::scaled_compile_threshold(intx threshold) {
 68   return scaled_compile_threshold(threshold, CompileThresholdScaling);
 69 }
 70 
 71 // Returns freq_log scaled with CompileThresholdScaling
 72 intx CompilerConfig::scaled_freq_log(intx freq_log) {
 73   return scaled_freq_log(freq_log, CompileThresholdScaling);
 74 }
 75 
 76 // Returns threshold scaled with the value of scale.
 77 // If scale &lt; 0.0, threshold is returned without scaling.
 78 intx CompilerConfig::scaled_compile_threshold(intx threshold, double scale) {
 79   if (scale == 1.0 || scale &lt; 0.0) {
 80     return threshold;
 81   } else {
 82     return (intx)(threshold * scale);
 83   }
 84 }
 85 
 86 // Returns freq_log scaled with the value of scale.
 87 // Returned values are in the range of [0, InvocationCounter::number_of_count_bits + 1].
 88 // If scale &lt; 0.0, freq_log is returned without scaling.
 89 intx CompilerConfig::scaled_freq_log(intx freq_log, double scale) {
 90   // Check if scaling is necessary or if negative value was specified.
 91   if (scale == 1.0 || scale &lt; 0.0) {
 92     return freq_log;
 93   }
 94   // Check values to avoid calculating log2 of 0.
 95   if (scale == 0.0 || freq_log == 0) {
 96     return 0;
 97   }
 98   // Determine the maximum notification frequency value currently supported.
 99   // The largest mask value that the interpreter/C1 can handle is
100   // of length InvocationCounter::number_of_count_bits. Mask values are always
101   // one bit shorter then the value of the notification frequency. Set
102   // max_freq_bits accordingly.
103   intx max_freq_bits = InvocationCounter::number_of_count_bits + 1;
104   intx scaled_freq = scaled_compile_threshold((intx)1 &lt;&lt; freq_log, scale);
105   if (scaled_freq == 0) {
106     // Return 0 right away to avoid calculating log2 of 0.
107     return 0;
108   } else if (scaled_freq &gt; nth_bit(max_freq_bits)) {
109     return max_freq_bits;
110   } else {
111     return log2_intptr(scaled_freq);
112   }
113 }
114 
115 #ifdef TIERED
116 void set_client_compilation_mode() {
117   Compilation_mode = CompMode_client;
118   CompLevel_highest_tier = CompLevel_simple;
119   CompLevel_initial_compile = CompLevel_simple;
120   FLAG_SET_ERGO(bool, TieredCompilation, false);
121   FLAG_SET_ERGO(bool, ProfileInterpreter, false);
122 #if INCLUDE_JVMCI
123   FLAG_SET_ERGO(bool, EnableJVMCI, false);
124   FLAG_SET_ERGO(bool, UseJVMCICompiler, false);
125 #endif
126 #if INCLUDE_AOT
127   FLAG_SET_ERGO(bool, UseAOT, false);
128 #endif
129   if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {
130     FLAG_SET_ERGO(bool, NeverActAsServerClassMachine, true);
131   }
132   if (FLAG_IS_DEFAULT(InitialCodeCacheSize)) {
133     FLAG_SET_ERGO(uintx, InitialCodeCacheSize, 160*K);
134   }
135   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
136     FLAG_SET_ERGO(uintx, ReservedCodeCacheSize, 32*M);
137   }
138   if (FLAG_IS_DEFAULT(NonProfiledCodeHeapSize)) {
139     FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 27*M);
140   }
141   if (FLAG_IS_DEFAULT(ProfiledCodeHeapSize)) {
142     FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0);
143   }
144   if (FLAG_IS_DEFAULT(NonNMethodCodeHeapSize)) {
145     FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 5*M);
146   }
147   if (FLAG_IS_DEFAULT(CodeCacheExpansionSize)) {
148     FLAG_SET_ERGO(uintx, CodeCacheExpansionSize, 32*K);
149   }
150   if (FLAG_IS_DEFAULT(MetaspaceSize)) {
151     FLAG_SET_ERGO(size_t, MetaspaceSize, MIN2(12*M, MaxMetaspaceSize));
152   }
153   if (FLAG_IS_DEFAULT(MaxRAM)) {
154     // Do not use FLAG_SET_ERGO to update MaxRAM, as this will impact
155     // heap setting done based on available phys_mem (see Arguments::set_heap_size).
156     FLAG_SET_DEFAULT(MaxRAM, 1ULL*G);
157   }
158   if (FLAG_IS_DEFAULT(CompileThreshold)) {
159     FLAG_SET_ERGO(intx, CompileThreshold, 1500);
160   }
161   if (FLAG_IS_DEFAULT(OnStackReplacePercentage)) {
162     FLAG_SET_ERGO(intx, OnStackReplacePercentage, 933);
163   }
164   if (FLAG_IS_DEFAULT(CICompilerCount)) {
165     FLAG_SET_ERGO(intx, CICompilerCount, 1);
166   }
167 }
168 
169 bool compilation_mode_selected() {
170   return !FLAG_IS_DEFAULT(TieredCompilation) ||
171          !FLAG_IS_DEFAULT(TieredStopAtLevel) ||
172          !FLAG_IS_DEFAULT(UseAOT)
173          JVMCI_ONLY(|| !FLAG_IS_DEFAULT(EnableJVMCI)
174                     || !FLAG_IS_DEFAULT(UseJVMCICompiler));
175 }
176 
177 void select_compilation_mode_ergonomically() {
178 #if defined(_WINDOWS) &amp;&amp; !defined(_LP64)
179   if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {
180     FLAG_SET_ERGO(bool, NeverActAsServerClassMachine, true);
181   }
182 #endif
183   if (NeverActAsServerClassMachine) {
184     set_client_compilation_mode();
185   }
186 }
187 
188 #endif // TIERED
189 
190 void CompilerConfig::set_tiered_flags() {
191   // With tiered, set default policy to SimpleThresholdPolicy, which is 2.
192   if (FLAG_IS_DEFAULT(CompilationPolicyChoice)) {
193     FLAG_SET_DEFAULT(CompilationPolicyChoice, 2);
194   }
195   if (CompilationPolicyChoice &lt; 2) {
196     vm_exit_during_initialization(
197       &quot;Incompatible compilation policy selected&quot;, NULL);
198   }
199   // Increase the code cache size - tiered compiles a lot more.
200   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
201     FLAG_SET_ERGO(uintx, ReservedCodeCacheSize,
202                   MIN2(CODE_CACHE_DEFAULT_LIMIT, (size_t)ReservedCodeCacheSize * 5));
203   }
204   // Enable SegmentedCodeCache if TieredCompilation is enabled, ReservedCodeCacheSize &gt;= 240M
205   // and the code cache contains at least 8 pages (segmentation disables advantage of huge pages).
206   if (FLAG_IS_DEFAULT(SegmentedCodeCache) &amp;&amp; ReservedCodeCacheSize &gt;= 240*M &amp;&amp;
207       8 * CodeCache::page_size() &lt;= ReservedCodeCacheSize) {
208     FLAG_SET_ERGO(bool, SegmentedCodeCache, true);
209   }
210   if (!UseInterpreter) { // -Xcomp
211     Tier3InvokeNotifyFreqLog = 0;
212     Tier4InvocationThreshold = 0;
213   }
214 
215   if (CompileThresholdScaling &lt; 0) {
216     vm_exit_during_initialization(&quot;Negative value specified for CompileThresholdScaling&quot;, NULL);
217   }
218 
219   // Scale tiered compilation thresholds.
220   // CompileThresholdScaling == 0.0 is equivalent to -Xint and leaves compilation thresholds unchanged.
221   if (!FLAG_IS_DEFAULT(CompileThresholdScaling) &amp;&amp; CompileThresholdScaling &gt; 0.0) {
222     FLAG_SET_ERGO(intx, Tier0InvokeNotifyFreqLog, scaled_freq_log(Tier0InvokeNotifyFreqLog));
223     FLAG_SET_ERGO(intx, Tier0BackedgeNotifyFreqLog, scaled_freq_log(Tier0BackedgeNotifyFreqLog));
224 
225     FLAG_SET_ERGO(intx, Tier3InvocationThreshold, scaled_compile_threshold(Tier3InvocationThreshold));
226     FLAG_SET_ERGO(intx, Tier3MinInvocationThreshold, scaled_compile_threshold(Tier3MinInvocationThreshold));
227     FLAG_SET_ERGO(intx, Tier3CompileThreshold, scaled_compile_threshold(Tier3CompileThreshold));
228     FLAG_SET_ERGO(intx, Tier3BackEdgeThreshold, scaled_compile_threshold(Tier3BackEdgeThreshold));
229 
230     // Tier2{Invocation,MinInvocation,Compile,Backedge}Threshold should be scaled here
231     // once these thresholds become supported.
232 
233     FLAG_SET_ERGO(intx, Tier2InvokeNotifyFreqLog, scaled_freq_log(Tier2InvokeNotifyFreqLog));
234     FLAG_SET_ERGO(intx, Tier2BackedgeNotifyFreqLog, scaled_freq_log(Tier2BackedgeNotifyFreqLog));
235 
236     FLAG_SET_ERGO(intx, Tier3InvokeNotifyFreqLog, scaled_freq_log(Tier3InvokeNotifyFreqLog));
237     FLAG_SET_ERGO(intx, Tier3BackedgeNotifyFreqLog, scaled_freq_log(Tier3BackedgeNotifyFreqLog));
238 
239     FLAG_SET_ERGO(intx, Tier23InlineeNotifyFreqLog, scaled_freq_log(Tier23InlineeNotifyFreqLog));
240 
241     FLAG_SET_ERGO(intx, Tier4InvocationThreshold, scaled_compile_threshold(Tier4InvocationThreshold));
242     FLAG_SET_ERGO(intx, Tier4MinInvocationThreshold, scaled_compile_threshold(Tier4MinInvocationThreshold));
243     FLAG_SET_ERGO(intx, Tier4CompileThreshold, scaled_compile_threshold(Tier4CompileThreshold));
244     FLAG_SET_ERGO(intx, Tier4BackEdgeThreshold, scaled_compile_threshold(Tier4BackEdgeThreshold));
245   }
246 }
247 
248 #if INCLUDE_JVMCI
249 void set_jvmci_specific_flags() {
250   if (UseJVMCICompiler) {
251     Compilation_mode = CompMode_server;
252 
253     if (FLAG_IS_DEFAULT(TypeProfileWidth)) {
254       FLAG_SET_DEFAULT(TypeProfileWidth, 8);
255     }
256     if (FLAG_IS_DEFAULT(OnStackReplacePercentage)) {
257       FLAG_SET_DEFAULT(OnStackReplacePercentage, 933);
258     }
259     // JVMCI needs values not less than defaults
260     if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
261       FLAG_SET_DEFAULT(ReservedCodeCacheSize, MAX2(64*M, ReservedCodeCacheSize));
262     }
263     if (FLAG_IS_DEFAULT(InitialCodeCacheSize)) {
264       FLAG_SET_DEFAULT(InitialCodeCacheSize, MAX2(16*M, InitialCodeCacheSize));
265     }
266     if (FLAG_IS_DEFAULT(MetaspaceSize)) {
267       FLAG_SET_DEFAULT(MetaspaceSize, MIN2(MAX2(12*M, MetaspaceSize), MaxMetaspaceSize));
268     }
269     if (FLAG_IS_DEFAULT(NewSizeThreadIncrease)) {
270       FLAG_SET_DEFAULT(NewSizeThreadIncrease, MAX2(4*K, NewSizeThreadIncrease));
271     }
272     if (TieredStopAtLevel != CompLevel_full_optimization) {
273       // Currently JVMCI compiler can only work at the full optimization level
274       warning(&quot;forcing TieredStopAtLevel to full optimization because JVMCI is enabled&quot;);
275       FLAG_SET_ERGO(intx, TieredStopAtLevel, CompLevel_full_optimization);
276     }
277     if (FLAG_IS_DEFAULT(TypeProfileLevel)) {
278       FLAG_SET_DEFAULT(TypeProfileLevel, 0);
279     }
280   }
281 }
282 #endif // INCLUDE_JVMCI
283 
284 bool CompilerConfig::check_args_consistency(bool status) {
285   // Check lower bounds of the code cache
286   // Template Interpreter code is approximately 3X larger in debug builds.
287   uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);
288   if (ReservedCodeCacheSize &lt; InitialCodeCacheSize) {
289     jio_fprintf(defaultStream::error_stream(),
290                 &quot;Invalid ReservedCodeCacheSize: %dK. Must be at least InitialCodeCacheSize=%dK.\n&quot;,
291                 ReservedCodeCacheSize/K, InitialCodeCacheSize/K);
292     status = false;
293   } else if (ReservedCodeCacheSize &lt; min_code_cache_size) {
294     jio_fprintf(defaultStream::error_stream(),
295                 &quot;Invalid ReservedCodeCacheSize=%dK. Must be at least %uK.\n&quot;, ReservedCodeCacheSize/K,
296                 min_code_cache_size/K);
297     status = false;
298   } else if (ReservedCodeCacheSize &gt; CODE_CACHE_SIZE_LIMIT) {
299     // Code cache size larger than CODE_CACHE_SIZE_LIMIT is not supported.
300     jio_fprintf(defaultStream::error_stream(),
301                 &quot;Invalid ReservedCodeCacheSize=%dM. Must be at most %uM.\n&quot;, ReservedCodeCacheSize/M,
302                 CODE_CACHE_SIZE_LIMIT/M);
303     status = false;
304   } else if (NonNMethodCodeHeapSize &lt; min_code_cache_size) {
305     jio_fprintf(defaultStream::error_stream(),
306                 &quot;Invalid NonNMethodCodeHeapSize=%dK. Must be at least %uK.\n&quot;, NonNMethodCodeHeapSize/K,
307                 min_code_cache_size/K);
308     status = false;
309   }
310 
311 #ifdef _LP64
312   if (!FLAG_IS_DEFAULT(CICompilerCount) &amp;&amp; !FLAG_IS_DEFAULT(CICompilerCountPerCPU) &amp;&amp; CICompilerCountPerCPU) {
313     warning(&quot;The VM option CICompilerCountPerCPU overrides CICompilerCount.&quot;);
314   }
315 #endif
316 
317   if (BackgroundCompilation &amp;&amp; ReplayCompiles) {
318     if (!FLAG_IS_DEFAULT(BackgroundCompilation)) {
319       warning(&quot;BackgroundCompilation disabled due to ReplayCompiles option.&quot;);
320     }
321     FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
322   }
323 
324 #ifdef COMPILER2
325   if (PostLoopMultiversioning &amp;&amp; !RangeCheckElimination) {
326     if (!FLAG_IS_DEFAULT(PostLoopMultiversioning)) {
327       warning(&quot;PostLoopMultiversioning disabled because RangeCheckElimination is disabled.&quot;);
328     }
329     FLAG_SET_CMDLINE(bool, PostLoopMultiversioning, false);
330   }
331   if (UseCountedLoopSafepoints &amp;&amp; LoopStripMiningIter == 0) {
332     if (!FLAG_IS_DEFAULT(UseCountedLoopSafepoints) || !FLAG_IS_DEFAULT(LoopStripMiningIter)) {
333       warning(&quot;When counted loop safepoints are enabled, LoopStripMiningIter must be at least 1 (a safepoint every 1 iteration): setting it to 1&quot;);
334     }
335     LoopStripMiningIter = 1;
336   } else if (!UseCountedLoopSafepoints &amp;&amp; LoopStripMiningIter &gt; 0) {
337     if (!FLAG_IS_DEFAULT(UseCountedLoopSafepoints) || !FLAG_IS_DEFAULT(LoopStripMiningIter)) {
338       warning(&quot;Disabling counted safepoints implies no loop strip mining: setting LoopStripMiningIter to 0&quot;);
339     }
340     LoopStripMiningIter = 0;
341   }
342 #endif // COMPILER2
343 
344   if (Arguments::is_interpreter_only()) {
345     if (UseCompiler) {
346       if (!FLAG_IS_DEFAULT(UseCompiler)) {
347         warning(&quot;UseCompiler disabled due to -Xint.&quot;);
348       }
349       FLAG_SET_CMDLINE(bool, UseCompiler, false);
350     }
351     if (ProfileInterpreter) {
352       if (!FLAG_IS_DEFAULT(ProfileInterpreter)) {
353         warning(&quot;ProfileInterpreter disabled due to -Xint.&quot;);
354       }
355       FLAG_SET_CMDLINE(bool, ProfileInterpreter, false);
356     }
357     if (TieredCompilation) {
358       if (!FLAG_IS_DEFAULT(TieredCompilation)) {
359         warning(&quot;TieredCompilation disabled due to -Xint.&quot;);
360       }
361       FLAG_SET_CMDLINE(bool, TieredCompilation, false);
362     }
363 #if INCLUDE_JVMCI
364     if (EnableJVMCI) {
365       if (!FLAG_IS_DEFAULT(EnableJVMCI) || !FLAG_IS_DEFAULT(UseJVMCICompiler)) {
366         warning(&quot;JVMCI Compiler disabled due to -Xint.&quot;);
367       }
368       FLAG_SET_CMDLINE(bool, EnableJVMCI, false);
369       FLAG_SET_CMDLINE(bool, UseJVMCICompiler, false);
370     }
371 #endif
372   } else {
373 #if INCLUDE_JVMCI
374     status = status &amp;&amp; JVMCIGlobals::check_jvmci_flags_are_consistent();
375 #endif
376   }
377   return status;
378 }
379 
380 void CompilerConfig::ergo_initialize() {
381   if (Arguments::is_interpreter_only()) {
382     return; // Nothing to do.
383   }
384 
385 #ifdef TIERED
386   if (!compilation_mode_selected()) {
387     select_compilation_mode_ergonomically();
388   }
389 #endif
390 
391 #if INCLUDE_JVMCI
392   // Check that JVMCI compiler supports selested GC.
393   // Should be done after GCConfig::initialize() was called.
394   JVMCIGlobals::check_jvmci_supported_gc();
395   set_jvmci_specific_flags();
396 #endif
397 
398   if (TieredCompilation) {
399     set_tiered_flags();
400   } else {
401     int max_compilation_policy_choice = 1;
402 #ifdef COMPILER2
403     if (is_server_compilation_mode_vm()) {
404       max_compilation_policy_choice = 2;
405     }
406 #endif
407     // Check if the policy is valid.
408     if (CompilationPolicyChoice &gt;= max_compilation_policy_choice) {
409       vm_exit_during_initialization(
410         &quot;Incompatible compilation policy selected&quot;, NULL);
411     }
412     // Scale CompileThreshold
413     // CompileThresholdScaling == 0.0 is equivalent to -Xint and leaves CompileThreshold unchanged.
414     if (!FLAG_IS_DEFAULT(CompileThresholdScaling) &amp;&amp; CompileThresholdScaling &gt; 0.0) {
415       FLAG_SET_ERGO(intx, CompileThreshold, scaled_compile_threshold(CompileThreshold));
416     }
417   }
418 
419   if (UseOnStackReplacement &amp;&amp; !UseLoopCounter) {
420     warning(&quot;On-stack-replacement requires loop counters; enabling loop counters&quot;);
421     FLAG_SET_DEFAULT(UseLoopCounter, true);
422   }
423 
424 #ifdef COMPILER2
425   if (!EliminateLocks) {
426     EliminateNestedLocks = false;
427   }
428   if (!Inline) {
429     IncrementalInline = false;
430   }
431 #ifndef PRODUCT
432   if (!IncrementalInline) {
433     AlwaysIncrementalInline = false;
434   }
435   if (PrintIdealGraphLevel &gt; 0) {
436     FLAG_SET_ERGO(bool, PrintIdealGraph, true);
437   }
438 #endif
439   if (!UseTypeSpeculation &amp;&amp; FLAG_IS_DEFAULT(TypeProfileLevel)) {
440     // nothing to use the profiling, turn if off
441     FLAG_SET_DEFAULT(TypeProfileLevel, 0);
442   }
443   if (!FLAG_IS_DEFAULT(OptoLoopAlignment) &amp;&amp; FLAG_IS_DEFAULT(MaxLoopPad)) {
444     FLAG_SET_DEFAULT(MaxLoopPad, OptoLoopAlignment-1);
445   }
446   if (FLAG_IS_DEFAULT(LoopStripMiningIterShortLoop)) {
447     // blind guess
448     LoopStripMiningIterShortLoop = LoopStripMiningIter / 10;
449   }
450 #endif // COMPILER2
451 }
    </pre>
  </body>
</html>
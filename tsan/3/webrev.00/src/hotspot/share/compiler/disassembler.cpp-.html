<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/compiler/disassembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;ci/ciUtilities.hpp&quot;
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;compiler/disassembler.hpp&quot;
 31 #include &quot;gc/shared/cardTable.hpp&quot;
 32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 33 #include &quot;gc/shared/collectedHeap.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/os.inline.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;utilities/resourceHash.hpp&quot;
 41 #include CPU_HEADER(depChecker)
 42 
 43 void*       Disassembler::_library               = NULL;
 44 bool        Disassembler::_tried_to_load_library = false;
 45 
 46 // This routine is in the shared library:
 47 Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;
 48 Disassembler::decode_func Disassembler::_decode_instructions = NULL;
 49 
 50 static const char hsdis_library_name[] = &quot;hsdis-&quot; HOTSPOT_LIB_ARCH;
 51 static const char decode_instructions_virtual_name[] = &quot;decode_instructions_virtual&quot;;
 52 static const char decode_instructions_name[] = &quot;decode_instructions&quot;;
 53 static bool use_new_version = true;
 54 #define COMMENT_COLUMN  52 LP64_ONLY(+8) /*could be an option*/
 55 #define BYTES_COMMENT   &quot;;...&quot;  /* funky byte display comment */
 56 
 57 bool Disassembler::load_library() {
 58   if (_decode_instructions_virtual != NULL || _decode_instructions != NULL) {
 59     // Already succeeded.
 60     return true;
 61   }
 62   if (_tried_to_load_library) {
 63     // Do not try twice.
 64     // To force retry in debugger: assign _tried_to_load_library=0
 65     return false;
 66   }
 67   // Try to load it.
 68   char ebuf[1024];
 69   char buf[JVM_MAXPATHLEN];
 70   os::jvm_path(buf, sizeof(buf));
 71   int jvm_offset = -1;
 72   int lib_offset = -1;
 73 #ifdef STATIC_BUILD
 74   char* p = strrchr(buf, &#39;/&#39;);
 75   *p = &#39;\0&#39;;
 76   strcat(p, &quot;/lib/&quot;);
 77   lib_offset = jvm_offset = strlen(buf);
 78 #else
 79   {
 80     // Match &quot;jvm[^/]*&quot; in jvm_path.
 81     const char* base = buf;
 82     const char* p = strrchr(buf, *os::file_separator());
 83     if (p != NULL) lib_offset = p - base + 1;
 84     p = strstr(p ? p : base, &quot;jvm&quot;);
 85     if (p != NULL) jvm_offset = p - base;
 86   }
 87 #endif
 88   // Find the disassembler shared library.
 89   // Search for several paths derived from libjvm, in this order:
 90   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)
 91   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so
 92   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so
 93   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)
 94   if (jvm_offset &gt;= 0) {
 95     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so
 96     strcpy(&amp;buf[jvm_offset], hsdis_library_name);
 97     strcat(&amp;buf[jvm_offset], os::dll_file_extension());
 98     _library = os::dll_load(buf, ebuf, sizeof ebuf);
 99     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {
100       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so
101       strcpy(&amp;buf[lib_offset], hsdis_library_name);
102       strcat(&amp;buf[lib_offset], os::dll_file_extension());
103       _library = os::dll_load(buf, ebuf, sizeof ebuf);
104     }
105     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {
106       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so
107       buf[lib_offset - 1] = &#39;\0&#39;;
108       const char* p = strrchr(buf, *os::file_separator());
109       if (p != NULL) {
110         lib_offset = p - buf + 1;
111         strcpy(&amp;buf[lib_offset], hsdis_library_name);
112         strcat(&amp;buf[lib_offset], os::dll_file_extension());
113         _library = os::dll_load(buf, ebuf, sizeof ebuf);
114       }
115     }
116   }
117   if (_library == NULL) {
118     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)
119     strcpy(&amp;buf[0], hsdis_library_name);
120     strcat(&amp;buf[0], os::dll_file_extension());
121     _library = os::dll_load(buf, ebuf, sizeof ebuf);
122   }
123   if (_library != NULL) {
124     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,
125                                           os::dll_lookup(_library, decode_instructions_virtual_name));
126   }
127   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {
128     // could not spot in new version, try old version
129     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,
130                                           os::dll_lookup(_library, decode_instructions_name));
131     use_new_version = false;
132   } else {
133     use_new_version = true;
134   }
135   _tried_to_load_library = true;
136   if (_decode_instructions_virtual == NULL &amp;&amp; _decode_instructions == NULL) {
137     tty-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;, buf,
138                   ((_library != NULL)
139                    ? &quot;entry point is missing&quot;
140                    : (WizardMode || PrintMiscellaneous)
141                    ? (const char*)ebuf
142                    : &quot;library not loadable&quot;),
143                   &quot;PrintAssembly is disabled&quot;);
144     return false;
145   }
146 
147   // Success.
148   tty-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);
149   return true;
150 }
151 
152 
153 class decode_env {
154  private:
155   nmethod*      _nm;
156   CodeBlob*     _code;
157   CodeStrings   _strings;
158   outputStream* _output;
159   address       _start, _end;
160   ptrdiff_t     _offset;
161 
162   char          _option_buf[512];
163   char          _print_raw;
164   bool          _print_pc;
165   bool          _print_bytes;
166   address       _cur_insn;
167   int           _bytes_per_line; // arch-specific formatting option
168   bool          _print_file_name;
169 
170   static bool match(const char* event, const char* tag) {
171     size_t taglen = strlen(tag);
172     if (strncmp(event, tag, taglen) != 0)
173       return false;
174     char delim = event[taglen];
175     return delim == &#39;\0&#39; || delim == &#39; &#39; || delim == &#39;/&#39; || delim == &#39;=&#39;;
176   }
177 
178   void collect_options(const char* p) {
179     if (p == NULL || p[0] == &#39;\0&#39;)  return;
180     size_t opt_so_far = strlen(_option_buf);
181     if (opt_so_far + 1 + strlen(p) + 1 &gt; sizeof(_option_buf))  return;
182     char* fillp = &amp;_option_buf[opt_so_far];
183     if (opt_so_far &gt; 0) *fillp++ = &#39;,&#39;;
184     strcat(fillp, p);
185     // replace white space by commas:
186     char* q = fillp;
187     while ((q = strpbrk(q, &quot; \t\n&quot;)) != NULL)
188       *q++ = &#39;,&#39;;
189     // Note that multiple PrintAssemblyOptions flags accumulate with \n,
190     // which we want to be changed to a comma...
191   }
192 
193   void print_insn_labels();
194   void print_insn_bytes(address pc0, address pc);
195   void print_address(address value);
196 
197   struct SourceFileInfo {
198     struct Link : public CHeapObj&lt;mtCode&gt; {
199       const char* file;
200       int line;
201       Link* next;
202       Link(const char* f, int l) : file(f), line(l), next(NULL) {}
203     };
204     Link *head, *tail;
205 
206     static unsigned hash(const address&amp; a) {
207       return primitive_hash&lt;address&gt;(a);
208     }
209     static bool equals(const address&amp; a0, const address&amp; a1) {
210       return primitive_equals&lt;address&gt;(a0, a1);
211     }
212     void append(const char* file, int line) {
213       if (tail != NULL &amp;&amp; tail-&gt;file == file &amp;&amp; tail-&gt;line == line) {
214         // Don&#39;t print duplicated lines at the same address. This could happen with C
215         // macros that end up having multiple &quot;__&quot; tokens on the same __LINE__.
216         return;
217       }
218       Link *link = new Link(file, line);
219       if (head == NULL) {
220         head = tail = link;
221       } else {
222         tail-&gt;next = link;
223         tail = link;
224       }
225     }
226     SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {
227       append(file, line);
228     }
229   };
230 
231   typedef ResourceHashtable&lt;
232       address, SourceFileInfo,
233       SourceFileInfo::hash,
234       SourceFileInfo::equals,
235       15889,      // prime number
236       ResourceObj::C_HEAP&gt; SourceFileInfoTable;
237 
238   static SourceFileInfoTable _src_table;
239   static const char* _cached_src;
240   static GrowableArray&lt;const char*&gt;* _cached_src_lines;
241 
242  public:
243   decode_env(CodeBlob* code, outputStream* output,
244              CodeStrings c = CodeStrings(), ptrdiff_t offset = 0);
245 
246   address decode_instructions(address start, address end);
247 
248   void start_insn(address pc) {
249     _cur_insn = pc;
250     output()-&gt;bol();
251     print_insn_labels();
252   }
253 
254   void end_insn(address pc) {
255     address pc0 = cur_insn();
256     outputStream* st = output();
257     if (_print_bytes &amp;&amp; pc &gt; pc0)
258       print_insn_bytes(pc0, pc);
259     if (_nm != NULL) {
260       _nm-&gt;print_code_comment_on(st, COMMENT_COLUMN, pc0, pc);
261       // this calls reloc_string_for which calls oop::print_value_on
262     }
263     print_hook_comments(pc0, _nm != NULL);
264     // follow each complete insn by a nice newline
265     st-&gt;cr();
266   }
267 
268   address handle_event(const char* event, address arg);
269 
270   outputStream* output() { return _output; }
271   address cur_insn() { return _cur_insn; }
272   const char* options() { return _option_buf; }
273   static void hook(const char* file, int line, address pc);
274   void print_hook_comments(address pc, bool newline);
275 };
276 
277 decode_env::SourceFileInfoTable decode_env::_src_table;
278 const char* decode_env::_cached_src = NULL;
279 GrowableArray&lt;const char*&gt;* decode_env::_cached_src_lines = NULL;
280 
281 void decode_env::hook(const char* file, int line, address pc) {
282   // For simplication, we never free from this table. It&#39;s really not
283   // necessary as we add to the table only when PrintInterpreter is true,
284   // which means we are debugging the VM and a little bit of extra
285   // memory usage doesn&#39;t matter.
286   SourceFileInfo* found = _src_table.get(pc);
287   if (found != NULL) {
288     found-&gt;append(file, line);
289   } else {
290     SourceFileInfo sfi(file, line);
291     _src_table.put(pc, sfi); // sfi is copied by value
292   }
293 }
294 
295 void decode_env::print_hook_comments(address pc, bool newline) {
296   SourceFileInfo* found = _src_table.get(pc);
297   outputStream* st = output();
298   if (found != NULL) {
299     for (SourceFileInfo::Link *link = found-&gt;head; link; link = link-&gt;next) {
300       const char* file = link-&gt;file;
301       int line = link-&gt;line;
302       if (_cached_src == NULL || strcmp(_cached_src, file) != 0) {
303         FILE* fp;
304 
305         // _cached_src_lines is a single cache of the lines of a source file, and we refill this cache
306         // every time we need to print a line from a different source file. It&#39;s not the fastest,
307         // but seems bearable.
308         if (_cached_src_lines != NULL) {
309           for (int i=0; i&lt;_cached_src_lines-&gt;length(); i++) {
310             os::free((void*)_cached_src_lines-&gt;at(i));
311           }
312           _cached_src_lines-&gt;clear();
313         } else {
314           _cached_src_lines = new (ResourceObj::C_HEAP, mtCode)GrowableArray&lt;const char*&gt;(0, true);
315         }
316 
317         if ((fp = fopen(file, &quot;r&quot;)) == NULL) {
318           _cached_src = NULL;
319           return;
320         }
321         _cached_src = file;
322 
323         char line[500]; // don&#39;t write lines that are too long in your source files!
324         while (fgets(line, sizeof(line), fp) != NULL) {
325           size_t len = strlen(line);
326           if (len &gt; 0 &amp;&amp; line[len-1] == &#39;\n&#39;) {
327             line[len-1] = &#39;\0&#39;;
328           }
329           _cached_src_lines-&gt;append(os::strdup(line));
330         }
331         fclose(fp);
332         _print_file_name = true;
333       }
334 
335       if (_print_file_name) {
336         // We print the file name whenever we switch to a new file, or when
337         // Disassembler::decode is called to disassemble a new block of code.
338         _print_file_name = false;
339         if (newline) {
340           st-&gt;cr();
341         }
342         st-&gt;move_to(COMMENT_COLUMN);
343         st-&gt;print(&quot;;;@FILE: %s&quot;, file);
344         newline = true;
345       }
346 
347       int index = line - 1; // 1-based line number -&gt; 0-based index.
348       if (index &gt;= _cached_src_lines-&gt;length()) {
349         // This could happen if source file is mismatched.
350       } else {
351         const char* source_line = _cached_src_lines-&gt;at(index);
352         if (newline) {
353           st-&gt;cr();
354         }
355         st-&gt;move_to(COMMENT_COLUMN);
356         st-&gt;print(&quot;;;%5d: %s&quot;, line, source_line);
357         newline = true;
358       }
359     }
360   }
361 }
362 
363 decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c,
364                        ptrdiff_t offset) {
365   memset(this, 0, sizeof(*this)); // Beware, this zeroes bits of fields.
366   _output = output ? output : tty;
367   _code = code;
368   if (code != NULL &amp;&amp; code-&gt;is_nmethod())
369     _nm = (nmethod*) code;
370   _strings.copy(c);
371   _offset = offset;
372 
373   // by default, output pc but not bytes:
374   _print_pc       = true;
375   _print_bytes    = false;
376   _bytes_per_line = Disassembler::pd_instruction_alignment();
377   _print_file_name= true;
378 
379   // parse the global option string:
380   collect_options(Disassembler::pd_cpu_opts());
381   collect_options(PrintAssemblyOptions);
382 
383   if (strstr(options(), &quot;hsdis-&quot;)) {
384     if (strstr(options(), &quot;hsdis-print-raw&quot;))
385       _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);
386     if (strstr(options(), &quot;hsdis-print-pc&quot;))
387       _print_pc = !_print_pc;
388     if (strstr(options(), &quot;hsdis-print-bytes&quot;))
389       _print_bytes = !_print_bytes;
390   }
391   if (strstr(options(), &quot;help&quot;)) {
392     tty-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);
393     tty-&gt;print_cr(&quot;  hsdis-print-raw       test plugin by requesting raw output&quot;);
394     tty-&gt;print_cr(&quot;  hsdis-print-raw-xml   test plugin by requesting raw xml&quot;);
395     tty-&gt;print_cr(&quot;  hsdis-print-pc        turn off PC printing (on by default)&quot;);
396     tty-&gt;print_cr(&quot;  hsdis-print-bytes     turn on instruction byte output&quot;);
397     tty-&gt;print_cr(&quot;combined options: %s&quot;, options());
398   }
399 }
400 
401 address decode_env::handle_event(const char* event, address arg) {
402   if (match(event, &quot;insn&quot;)) {
403     start_insn(arg);
404   } else if (match(event, &quot;/insn&quot;)) {
405     end_insn(arg);
406   } else if (match(event, &quot;addr&quot;)) {
407     if (arg != NULL) {
408       print_address(arg);
409       return arg;
410     }
411   } else if (match(event, &quot;mach&quot;)) {
412     static char buffer[32] = { 0, };
413     if (strcmp(buffer, (const char*)arg) != 0 ||
414         strlen((const char*)arg) &gt; sizeof(buffer) - 1) {
415       // Only print this when the mach changes
416       strncpy(buffer, (const char*)arg, sizeof(buffer) - 1);
417       buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
418       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, arg);
419     }
420   } else if (match(event, &quot;format bytes-per-line&quot;)) {
421     _bytes_per_line = (int) (intptr_t) arg;
422   } else {
423     // ignore unrecognized markup
424   }
425   return NULL;
426 }
427 
428 // called by the disassembler to print out jump targets and data addresses
429 void decode_env::print_address(address adr) {
430   outputStream* st = _output;
431 
432   if (adr == NULL) {
433     st-&gt;print(&quot;NULL&quot;);
434     return;
435   }
436 
437   int small_num = (int)(intptr_t)adr;
438   if ((intptr_t)adr == (intptr_t)small_num
439       &amp;&amp; -1 &lt;= small_num &amp;&amp; small_num &lt;= 9) {
440     st-&gt;print(&quot;%d&quot;, small_num);
441     return;
442   }
443 
444   if (Universe::is_fully_initialized()) {
445     if (StubRoutines::contains(adr)) {
446       StubCodeDesc* desc = StubCodeDesc::desc_for(adr);
447       if (desc == NULL) {
448         desc = StubCodeDesc::desc_for(adr + frame::pc_return_offset);
449       }
450       if (desc != NULL) {
451         st-&gt;print(&quot;Stub::%s&quot;, desc-&gt;name());
452         if (desc-&gt;begin() != adr) {
453           st-&gt;print(INTX_FORMAT_W(+) &quot; &quot; PTR_FORMAT, adr - desc-&gt;begin(), p2i(adr));
454         } else if (WizardMode) {
455           st-&gt;print(&quot; &quot; PTR_FORMAT, p2i(adr));
456         }
457         return;
458       }
459       st-&gt;print(&quot;Stub::&lt;unknown&gt; &quot; PTR_FORMAT, p2i(adr));
460       return;
461     }
462 
463     BarrierSet* bs = BarrierSet::barrier_set();
464     if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
465         adr == ci_card_table_address_as&lt;address&gt;()) {
466       st-&gt;print(&quot;word_map_base&quot;);
467       if (WizardMode) st-&gt;print(&quot; &quot; INTPTR_FORMAT, p2i(adr));
468       return;
469     }
470   }
471 
472   if (_nm == NULL) {
473     // Don&#39;t do this for native methods, as the function name will be printed in
474     // nmethod::reloc_string_for().
475     ResourceMark rm;
476     const int buflen = 1024;
477     char* buf = NEW_RESOURCE_ARRAY(char, buflen);
478     int offset;
479     if (os::dll_address_to_function_name(adr, buf, buflen, &amp;offset)) {
480       st-&gt;print(PTR_FORMAT &quot; = %s&quot;,  p2i(adr), buf);
481       if (offset != 0) {
482         st-&gt;print(&quot;+%d&quot;, offset);
483       }
484       return;
485     }
486   }
487 
488   // Fall through to a simple (hexadecimal) numeral.
489   st-&gt;print(PTR_FORMAT, p2i(adr));
490 }
491 
492 void decode_env::print_insn_labels() {
493   address p = cur_insn();
494   outputStream* st = output();
495   CodeBlob* cb = _code;
496   if (cb != NULL) {
497     cb-&gt;print_block_comment(st, p);
498   }
499   _strings.print_block_comment(st, (intptr_t)(p - _start + _offset));
500   if (_print_pc) {
501     st-&gt;print(&quot;  &quot; PTR_FORMAT &quot;: &quot;, p2i(p));
502   }
503 }
504 
505 void decode_env::print_insn_bytes(address pc, address pc_limit) {
506   outputStream* st = output();
507   size_t incr = 1;
508   size_t perline = _bytes_per_line;
509   if ((size_t) Disassembler::pd_instruction_alignment() &gt;= sizeof(int)
510       &amp;&amp; !((uintptr_t)pc % sizeof(int))
511       &amp;&amp; !((uintptr_t)pc_limit % sizeof(int))) {
512     incr = sizeof(int);
513     if (perline % incr)  perline += incr - (perline % incr);
514   }
515   while (pc &lt; pc_limit) {
516     // tab to the desired column:
517     st-&gt;move_to(COMMENT_COLUMN);
518     address pc0 = pc;
519     address pc1 = pc + perline;
520     if (pc1 &gt; pc_limit)  pc1 = pc_limit;
521     for (; pc &lt; pc1; pc += incr) {
522       if (pc == pc0) {
523         st-&gt;print(BYTES_COMMENT);
524       } else if ((uint)(pc - pc0) % sizeof(int) == 0) {
525         st-&gt;print(&quot; &quot;);         // put out a space on word boundaries
526       }
527       if (incr == sizeof(int)) {
528         st-&gt;print(&quot;%08x&quot;, *(int*)pc);
529       } else {
530         st-&gt;print(&quot;%02x&quot;, (*pc)&amp;0xFF);
531       }
532     }
533     st-&gt;cr();
534   }
535 }
536 
537 
538 static void* event_to_env(void* env_pv, const char* event, void* arg) {
539   decode_env* env = (decode_env*) env_pv;
540   return env-&gt;handle_event(event, (address) arg);
541 }
542 
543 ATTRIBUTE_PRINTF(2, 3)
544 static int printf_to_env(void* env_pv, const char* format, ...) {
545   decode_env* env = (decode_env*) env_pv;
546   outputStream* st = env-&gt;output();
547   size_t flen = strlen(format);
548   const char* raw = NULL;
549   if (flen == 0)  return 0;
550   if (flen == 1 &amp;&amp; format[0] == &#39;\n&#39;) { st-&gt;bol(); return 1; }
551   if (flen &lt; 2 ||
552       strchr(format, &#39;%&#39;) == NULL) {
553     raw = format;
554   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;%&#39; &amp;&amp;
555              strchr(format+2, &#39;%&#39;) == NULL) {
556     // happens a lot on machines with names like %foo
557     flen--;
558     raw = format+1;
559   }
560   if (raw != NULL) {
561     st-&gt;print_raw(raw, (int) flen);
562     return (int) flen;
563   }
564   va_list ap;
565   va_start(ap, format);
566   julong cnt0 = st-&gt;count();
567   st-&gt;vprint(format, ap);
568   julong cnt1 = st-&gt;count();
569   va_end(ap);
570   return (int)(cnt1 - cnt0);
571 }
572 
573 address decode_env::decode_instructions(address start, address end) {
574   _start = start; _end = end;
575 
576   assert(((((intptr_t)start | (intptr_t)end) % Disassembler::pd_instruction_alignment()) == 0), &quot;misaligned insn addr&quot;);
577 
578   const int show_bytes = false; // for disassembler debugging
579 
580   //_version = Disassembler::pd_cpu_version();
581 
582   if (!Disassembler::can_decode()) {
583     return NULL;
584   }
585 
586   // decode a series of instructions and return the end of the last instruction
587 
588   if (_print_raw) {
589     // Print whatever the library wants to print, w/o fancy callbacks.
590     // This is mainly for debugging the library itself.
591     FILE* out = stdout;
592     FILE* xmlout = (_print_raw &gt; 1 ? out : NULL);
593     return use_new_version ?
594       (address)
595       (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
596                                                     start, end - start,
597                                                     NULL, (void*) xmlout,
598                                                     NULL, (void*) out,
599                                                     options(), 0/*nice new line*/)
600       :
601       (address)
602       (*Disassembler::_decode_instructions)(start, end,
603                                             NULL, (void*) xmlout,
604                                             NULL, (void*) out,
605                                             options());
606   }
607 
608   return use_new_version ?
609     (address)
610     (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
611                                                   start, end - start,
612                                                   &amp;event_to_env,  (void*) this,
613                                                   &amp;printf_to_env, (void*) this,
614                                                   options(), 0/*nice new line*/)
615     :
616     (address)
617     (*Disassembler::_decode_instructions)(start, end,
618                                           &amp;event_to_env,  (void*) this,
619                                           &amp;printf_to_env, (void*) this,
620                                           options());
621 }
622 
623 
624 void Disassembler::decode(CodeBlob* cb, outputStream* st) {
625   ttyLocker ttyl;
626   if (!load_library())  return;
627   if (cb-&gt;is_nmethod()) {
628     decode((nmethod*)cb, st);
629     return;
630   }
631   decode_env env(cb, st);
632   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
633   if (cb-&gt;is_aot()) {
634     env.output()-&gt;print(&quot;A &quot;);
635     if (cb-&gt;is_compiled()) {
636       CompiledMethod* cm = (CompiledMethod*)cb;
637       env.output()-&gt;print(&quot;%d &quot;,cm-&gt;compile_id());
638       cm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());
639       env.output()-&gt;print(&quot;.&quot;);
640       cm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());
641       cm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
642     } else {
643       env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
644     }
645   } else {
646     env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
647   }
648   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())) * sizeof(unsigned char*));
649   env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());
650 }
651 
652 void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c,
653                           ptrdiff_t offset) {
654   ttyLocker ttyl;
655   if (!load_library())  return;
656   decode_env env(CodeCache::find_blob_unsafe(start), st, c, offset);
657   env.decode_instructions(start, end);
658 }
659 
660 void Disassembler::decode(nmethod* nm, outputStream* st) {
661   ttyLocker ttyl;
662   if (!load_library())  return;
663   decode_env env(nm, st);
664   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);
665 
666   unsigned char* p   = nm-&gt;code_begin();
667   unsigned char* end = nm-&gt;code_end();
668 
669   nm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());
670   env.output()-&gt;print(&quot;.&quot;);
671   nm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());
672   nm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
673 #if INCLUDE_JVMCI
674   {
675     char buffer[O_BUFLEN];
676     char* jvmciName = nm-&gt;jvmci_installed_code_name(buffer, O_BUFLEN);
677     if (jvmciName != NULL) {
678       env.output()-&gt;print(&quot; (%s)&quot;, jvmciName);
679     }
680   }
681 #endif
682   env.output()-&gt;print_cr(&quot;  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(p), p2i(end), ((jlong)(end - p)));
683 
684   // Print constant table.
685   if (nm-&gt;consts_size() &gt; 0) {
686     nm-&gt;print_nmethod_labels(env.output(), nm-&gt;consts_begin());
687     int offset = 0;
688     for (address p = nm-&gt;consts_begin(); p &lt; nm-&gt;consts_end(); p += 4, offset += 4) {
689       if ((offset % 8) == 0) {
690         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT &quot;   &quot; PTR64_FORMAT, p2i(p), offset, *((int32_t*) p), *((int64_t*) p));
691       } else {
692         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT,                    p2i(p), offset, *((int32_t*) p));
693       }
694     }
695   }
696 
697   env.decode_instructions(p, end);
698 }
699 
700 // To prevent excessive code expansion in the interpreter generator, we
701 // do not inline this function into Disassembler::hook().
702 void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {
703   decode_env::hook(file, line, masm-&gt;code_section()-&gt;end());
704 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/compiler/compileBroker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compileBroker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileTask.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,10 +27,11 @@</span>
  
  #include &quot;ci/compilerInterface.hpp&quot;
  #include &quot;compiler/abstractCompiler.hpp&quot;
  #include &quot;compiler/compileTask.hpp&quot;
  #include &quot;compiler/compilerDirectives.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;utilities/stack.hpp&quot;
  #if INCLUDE_JVMCI
  #include &quot;jvmci/jvmciCompiler.hpp&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -171,14 +172,10 @@</span>
  
    // These counters are used for assigning id&#39;s to each compilation
    static volatile jint _compilation_id;
    static volatile jint _osr_compilation_id;
  
<span class="udiff-line-removed">-   static int  _last_compile_type;</span>
<span class="udiff-line-removed">-   static int  _last_compile_level;</span>
<span class="udiff-line-removed">-   static char _last_method_compiled[name_buffer_length];</span>
<span class="udiff-line-removed">- </span>
    static CompileQueue* _c2_compile_queue;
    static CompileQueue* _c1_compile_queue;
  
    // performance counters
    static PerfCounter* _perf_total_compilation;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228,16 +225,14 @@</span>
    static long _peak_compilation_time;
  
    static volatile int _print_compilation_warning;
  
    static Handle create_thread_oop(const char* name, TRAPS);
<span class="udiff-line-modified-removed">-   static JavaThread* make_thread(jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, TRAPS);</span>
<span class="udiff-line-modified-added">+   static JavaThread* make_thread(jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD);</span>
    static void init_compiler_sweeper_threads();
<span class="udiff-line-modified-removed">-   static void possibly_add_compiler_threads();</span>
<span class="udiff-line-removed">-   static bool compilation_is_complete  (const methodHandle&amp; method, int osr_bci, int comp_level);</span>
<span class="udiff-line-modified-added">+   static void possibly_add_compiler_threads(Thread* THREAD);</span>
    static bool compilation_is_prohibited(const methodHandle&amp; method, int osr_bci, int comp_level, bool excluded);
<span class="udiff-line-removed">-   static void preload_classes          (const methodHandle&amp; method, TRAPS);</span>
  
    static CompileTask* create_compile_task(CompileQueue*       queue,
                                            int                 compile_id,
                                            const methodHandle&amp; method,
                                            int                 osr_bci,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,11 +247,12 @@</span>
  #endif
  
    static void invoke_compiler_on_method(CompileTask* task);
    static void post_compile(CompilerThread* thread, CompileTask* task, bool success, ciEnv* ci_env,
                             int compilable, const char* failure_reason);
<span class="udiff-line-modified-removed">-   static void set_last_compile(CompilerThread *thread, const methodHandle&amp; method, bool is_osr, int comp_level);</span>
<span class="udiff-line-modified-added">+   static void update_compile_perf_data(CompilerThread *thread, const methodHandle&amp; method, bool is_osr);</span>
<span class="udiff-line-added">+ </span>
    static void push_jni_handle_block();
    static void pop_jni_handle_block();
    static void collect_statistics(CompilerThread* thread, elapsedTimer time, CompileTask* task);
  
    static void compile_method_base(const methodHandle&amp; method,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,18 +282,19 @@</span>
      if (is_c2_compile(comp_level)) return _compilers[1]; // C2
      if (is_c1_compile(comp_level)) return _compilers[0]; // C1
      return NULL;
    }
  
<span class="udiff-line-added">+   static bool compilation_is_complete(const methodHandle&amp; method, int osr_bci, int comp_level);</span>
    static bool compilation_is_in_queue(const methodHandle&amp; method);
    static void print_compile_queues(outputStream* st);
    static void print_directives(outputStream* st);
    static int queue_size(int comp_level) {
      CompileQueue *q = compile_queue(comp_level);
      return q != NULL ? q-&gt;size() : 0;
    }
<span class="udiff-line-modified-removed">-   static void compilation_init_phase1(TRAPS);</span>
<span class="udiff-line-modified-added">+   static void compilation_init_phase1(Thread* THREAD);</span>
    static void compilation_init_phase2();
    static void init_compiler_thread_log();
    static nmethod* compile_method(const methodHandle&amp; method,
                                   int osr_bci,
                                   int comp_level,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -337,11 +334,11 @@</span>
  
    static jint get_compilation_activity_mode() { return _should_compile_new_jobs; }
    static bool should_compile_new_jobs() { return UseCompiler &amp;&amp; (_should_compile_new_jobs == run_compilation); }
    static bool set_should_compile_new_jobs(jint new_state) {
      // Return success if the current caller set it
<span class="udiff-line-modified-removed">-     jint old = Atomic::cmpxchg(new_state, &amp;_should_compile_new_jobs, 1-new_state);</span>
<span class="udiff-line-modified-added">+     jint old = Atomic::cmpxchg(&amp;_should_compile_new_jobs, 1-new_state, new_state);</span>
      bool success = (old == (1-new_state));
      if (success) {
        if (new_state == run_compilation) {
          _total_compiler_restarted_count++;
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,20 +349,20 @@</span>
    }
  
    static void disable_compilation_forever() {
      UseCompiler               = false;
      AlwaysCompileLoopMethods  = false;
<span class="udiff-line-modified-removed">-     Atomic::xchg(jint(shutdown_compilation), &amp;_should_compile_new_jobs);</span>
<span class="udiff-line-modified-added">+     Atomic::xchg(&amp;_should_compile_new_jobs, jint(shutdown_compilation));</span>
    }
  
    static bool is_compilation_disabled_forever() {
      return _should_compile_new_jobs == shutdown_compilation;
    }
    static void handle_full_code_cache(int code_blob_type);
    // Ensures that warning is only printed once.
    static bool should_print_compiler_warning() {
<span class="udiff-line-modified-removed">-     jint old = Atomic::cmpxchg(1, &amp;_print_compilation_warning, 0);</span>
<span class="udiff-line-modified-added">+     jint old = Atomic::cmpxchg(&amp;_print_compilation_warning, 0, 1);</span>
      return old == 0;
    }
    // Return total compilation ticks
    static jlong total_compilation_ticks() {
      return _perf_total_compilation != NULL ? _perf_total_compilation-&gt;get_value() : 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -380,13 +377,10 @@</span>
  #endif
  
    // Print a detailed accounting of compilation time
    static void print_times(bool per_compiler = true, bool aggregate = true);
  
<span class="udiff-line-removed">-   // Debugging output for failure</span>
<span class="udiff-line-removed">-   static void print_last_compile();</span>
<span class="udiff-line-removed">- </span>
    // compiler name for debugging
    static const char* compiler_name(int comp_level);
  
    // Provide access to compiler thread Java objects
    static jobject compiler1_object(int idx) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,10 +393,12 @@</span>
      assert(_compiler2_objects != NULL, &quot;must be initialized&quot;);
      assert(idx &lt; _c2_count, &quot;oob&quot;);
      return _compiler2_objects[idx];
    }
  
<span class="udiff-line-added">+   static bool can_remove(CompilerThread *ct, bool do_it);</span>
<span class="udiff-line-added">+ </span>
    static CompileLog* get_log(CompilerThread* ct);
  
    static int get_total_compile_count() {            return _total_compile_count; }
    static int get_total_bailout_count() {            return _total_bailout_count; }
    static int get_total_invalidated_count() {        return _total_invalidated_count; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,9 +417,9 @@</span>
    // Log that compilation profiling is skipped because metaspace is full.
    static void log_metaspace_failure();
  
    // CodeHeap State Analytics.
    static void print_info(outputStream *out);
<span class="udiff-line-modified-removed">-   static void print_heapinfo(outputStream *out, const char* function, const char* granularity );</span>
<span class="udiff-line-modified-added">+   static void print_heapinfo(outputStream *out, const char* function, size_t granularity);</span>
  };
  
  #endif // SHARE_COMPILER_COMPILEBROKER_HPP
</pre>
<center><a href="compileBroker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileTask.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/compiler/oopMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopMap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/epsilon/epsilonArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/oopMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  
  #include &quot;code/compressedStream.hpp&quot;
  #include &quot;code/vmreg.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-removed">- #include &quot;utilities/growableArray.hpp&quot;</span>
  
  // Interface for generating the frame map for compiled code.  A frame map
  // describes for a specific pc whether each register and frame stack slot is:
  //   Oop         - A GC root for current frame
  //   Dead        - Dead; can be Zapped for debugging
<span class="line-new-header">--- 27,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  //
  // OopMapValue describes a single OopMap entry
  
  class frame;
  class RegisterMap;
<span class="line-removed">- class DerivedPointerEntry;</span>
  class OopClosure;
  
  class OopMapValue: public StackObj {
    friend class VMStructs;
  private:
<span class="line-new-header">--- 39,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,34 ***</span>
    void set_value(int value)                         { _value = value; }
    short _content_reg;
  
  public:
    // Constants
<span class="line-modified">!   enum { type_bits                = 4,</span>
           register_bits            = BitsPerShort - type_bits };
  
    enum { type_shift               = 0,
           register_shift           = type_bits };
  
    enum { type_mask                = right_n_bits(type_bits),
           type_mask_in_place       = type_mask &lt;&lt; type_shift,
           register_mask            = right_n_bits(register_bits),
           register_mask_in_place   = register_mask &lt;&lt; register_shift };
  
<span class="line-modified">!   enum oop_types {              // must fit in type_bits</span>
<span class="line-modified">!          unused_value =0,       // powers of 2, for masking OopMapStream</span>
<span class="line-modified">!          oop_value = 1,</span>
<span class="line-modified">!          narrowoop_value = 2,</span>
<span class="line-modified">!          callee_saved_value = 4,</span>
<span class="line-modified">!          derived_oop_value= 8 };</span>
  
    // Constructors
    OopMapValue () { set_value(0); set_content_reg(VMRegImpl::Bad()); }
<span class="line-modified">!   OopMapValue (VMReg reg, oop_types t) { set_reg_type(reg, t); set_content_reg(VMRegImpl::Bad()); }</span>
<span class="line-modified">!   OopMapValue (VMReg reg, oop_types t, VMReg reg2) { set_reg_type(reg, t); set_content_reg(reg2); }</span>
<span class="line-modified">!   OopMapValue (CompressedReadStream* stream) { read_from(stream); }</span>
  
    // Archiving
    void write_on(CompressedWriteStream* stream) {
      stream-&gt;write_int(value());
      if(is_callee_saved() || is_derived_oop()) {
        stream-&gt;write_int(content_reg()-&gt;value());
<span class="line-new-header">--- 51,56 ---</span>
    void set_value(int value)                         { _value = value; }
    short _content_reg;
  
  public:
    // Constants
<span class="line-modified">!   enum { type_bits                = 2,</span>
           register_bits            = BitsPerShort - type_bits };
  
    enum { type_shift               = 0,
           register_shift           = type_bits };
  
    enum { type_mask                = right_n_bits(type_bits),
           type_mask_in_place       = type_mask &lt;&lt; type_shift,
           register_mask            = right_n_bits(register_bits),
           register_mask_in_place   = register_mask &lt;&lt; register_shift };
  
<span class="line-modified">!   enum oop_types {</span>
<span class="line-modified">!          oop_value,</span>
<span class="line-modified">!          narrowoop_value,</span>
<span class="line-modified">!          callee_saved_value,</span>
<span class="line-modified">!          derived_oop_value,</span>
<span class="line-modified">!          unused_value = -1          // Only used as a sentinel value</span>
<span class="line-added">+   };</span>
  
    // Constructors
    OopMapValue () { set_value(0); set_content_reg(VMRegImpl::Bad()); }
<span class="line-modified">!   OopMapValue (VMReg reg, oop_types t, VMReg reg2) {</span>
<span class="line-modified">!     set_reg_type(reg, t);</span>
<span class="line-modified">!     set_content_reg(reg2);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+  private:</span>
<span class="line-added">+     void set_reg_type(VMReg p, oop_types t) {</span>
<span class="line-added">+     set_value((p-&gt;value() &lt;&lt; register_shift) | t);</span>
<span class="line-added">+     assert(reg() == p, &quot;sanity check&quot; );</span>
<span class="line-added">+     assert(type() == t, &quot;sanity check&quot; );</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_content_reg(VMReg r) {</span>
<span class="line-added">+     if (is_callee_saved()) {</span>
<span class="line-added">+       // This can never be a stack location, so we don&#39;t need to transform it.</span>
<span class="line-added">+       assert(r-&gt;is_reg(), &quot;Trying to callee save a stack location&quot;);</span>
<span class="line-added">+     } else if (is_derived_oop()) {</span>
<span class="line-added">+       assert (r-&gt;is_valid(), &quot;must have a valid VMReg&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert (!r-&gt;is_valid(), &quot;valid VMReg not allowed&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     _content_reg = r-&gt;value();</span>
<span class="line-added">+   }</span>
  
<span class="line-added">+  public:</span>
    // Archiving
    void write_on(CompressedWriteStream* stream) {
      stream-&gt;write_int(value());
      if(is_callee_saved() || is_derived_oop()) {
        stream-&gt;write_int(content_reg()-&gt;value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,35 ***</span>
      }
    }
  
    // Querying
    bool is_oop()               { return mask_bits(value(), type_mask_in_place) == oop_value; }
<span class="line-modified">!   bool is_narrowoop()           { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }</span>
    bool is_callee_saved()      { return mask_bits(value(), type_mask_in_place) == callee_saved_value; }
    bool is_derived_oop()       { return mask_bits(value(), type_mask_in_place) == derived_oop_value; }
  
<span class="line-removed">-   void set_oop()              { set_value((value() &amp; register_mask_in_place) | oop_value); }</span>
<span class="line-removed">-   void set_narrowoop()          { set_value((value() &amp; register_mask_in_place) | narrowoop_value); }</span>
<span class="line-removed">-   void set_callee_saved()     { set_value((value() &amp; register_mask_in_place) | callee_saved_value); }</span>
<span class="line-removed">-   void set_derived_oop()      { set_value((value() &amp; register_mask_in_place) | derived_oop_value); }</span>
<span class="line-removed">- </span>
    VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) &gt;&gt; register_shift); }
    oop_types type() const      { return (oop_types)mask_bits(value(), type_mask_in_place); }
  
    static bool legal_vm_reg_name(VMReg p) {
      return (p-&gt;value()  == (p-&gt;value() &amp; register_mask));
    }
  
<span class="line-removed">-   void set_reg_type(VMReg p, oop_types t) {</span>
<span class="line-removed">-     set_value((p-&gt;value() &lt;&lt; register_shift) | t);</span>
<span class="line-removed">-     assert(reg() == p, &quot;sanity check&quot; );</span>
<span class="line-removed">-     assert(type() == t, &quot;sanity check&quot; );</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
    VMReg content_reg() const       { return VMRegImpl::as_VMReg(_content_reg, true); }
<span class="line-removed">-   void set_content_reg(VMReg r)   { _content_reg = r-&gt;value(); }</span>
  
    // Physical location queries
    bool is_register_loc()      { return reg()-&gt;is_reg(); }
    bool is_stack_loc()         { return reg()-&gt;is_stack(); }
  
<span class="line-new-header">--- 114,22 ---</span>
      }
    }
  
    // Querying
    bool is_oop()               { return mask_bits(value(), type_mask_in_place) == oop_value; }
<span class="line-modified">!   bool is_narrowoop()         { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }</span>
    bool is_callee_saved()      { return mask_bits(value(), type_mask_in_place) == callee_saved_value; }
    bool is_derived_oop()       { return mask_bits(value(), type_mask_in_place) == derived_oop_value; }
  
    VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) &gt;&gt; register_shift); }
    oop_types type() const      { return (oop_types)mask_bits(value(), type_mask_in_place); }
  
    static bool legal_vm_reg_name(VMReg p) {
      return (p-&gt;value()  == (p-&gt;value() &amp; register_mask));
    }
  
    VMReg content_reg() const       { return VMRegImpl::as_VMReg(_content_reg, true); }
  
    // Physical location queries
    bool is_register_loc()      { return reg()-&gt;is_reg(); }
    bool is_stack_loc()         { return reg()-&gt;is_stack(); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,11 ***</span>
      assert(is_stack_loc(), &quot;must be stack location&quot;);
      return reg()-&gt;reg2stack();
    }
  
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const { print_on(tty); }</span>
  };
  
  
  class OopMap: public ResourceObj {
    friend class OopMapStream;
<span class="line-new-header">--- 138,11 ---</span>
      assert(is_stack_loc(), &quot;must be stack location&quot;);
      return reg()-&gt;reg2stack();
    }
  
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const;</span>
  };
  
  
  class OopMap: public ResourceObj {
    friend class OopMapStream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,10 ***</span>
<span class="line-new-header">--- 163,12 ---</span>
  
   private:
    enum DeepCopyToken { _deep_copy_token };
    OopMap(DeepCopyToken, OopMap* source);  // used only by deep_copy
  
<span class="line-added">+   void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);</span>
<span class="line-added">+ </span>
   public:
    OopMap(int frame_size, int arg_count);
  
    // pc-offset handling
    int offset() const     { return _pc_offset; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,30 ***</span>
  
    // Construction
    // frame_size units are stack-slots (4 bytes) NOT intptr_t; we can name odd
    // slots to hold 4-byte values like ints and floats in the LP64 build.
    void set_oop  ( VMReg local);
<span class="line-removed">-   void set_value( VMReg local);</span>
    void set_narrowoop(VMReg local);
<span class="line-removed">-   void set_dead ( VMReg local);</span>
    void set_callee_saved( VMReg local, VMReg caller_machine_register );
    void set_derived_oop ( VMReg local, VMReg derived_from_local_register );
<span class="line-removed">-   void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);</span>
  
    int heap_size() const;
    void copy_data_to(address addr) const;
    OopMap* deep_copy();
  
<span class="line-removed">-   bool has_derived_pointer() const PRODUCT_RETURN0;</span>
<span class="line-removed">- </span>
    bool legal_vm_reg_name(VMReg local) {
       return OopMapValue::legal_vm_reg_name(local);
    }
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const { print_on(tty); }</span>
    bool equals(const OopMap* other) const;
  };
  
  
  class OopMapSet : public ResourceObj {
<span class="line-new-header">--- 182,25 ---</span>
  
    // Construction
    // frame_size units are stack-slots (4 bytes) NOT intptr_t; we can name odd
    // slots to hold 4-byte values like ints and floats in the LP64 build.
    void set_oop  ( VMReg local);
    void set_narrowoop(VMReg local);
    void set_callee_saved( VMReg local, VMReg caller_machine_register );
    void set_derived_oop ( VMReg local, VMReg derived_from_local_register );
  
    int heap_size() const;
    void copy_data_to(address addr) const;
    OopMap* deep_copy();
  
    bool legal_vm_reg_name(VMReg local) {
       return OopMapValue::legal_vm_reg_name(local);
    }
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const;</span>
    bool equals(const OopMap* other) const;
  };
  
  
  class OopMapSet : public ResourceObj {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,11 ***</span>
    OopMap* find_map_at_offset(int pc_offset) const;
  
    int heap_size() const;
  
    // Methods oops_do() and all_do() filter out NULL oops and
<span class="line-modified">!   // oop == Universe::narrow_oop_base() before passing oops</span>
    // to closures.
  
    // Iterates through frame for a compiled method
    static void oops_do            (const frame* fr,
                                    const RegisterMap* reg_map, OopClosure* f);
<span class="line-new-header">--- 239,11 ---</span>
    OopMap* find_map_at_offset(int pc_offset) const;
  
    int heap_size() const;
  
    // Methods oops_do() and all_do() filter out NULL oops and
<span class="line-modified">!   // oop == CompressedOops::base() before passing oops</span>
    // to closures.
  
    // Iterates through frame for a compiled method
    static void oops_do            (const frame* fr,
                                    const RegisterMap* reg_map, OopClosure* f);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,11 ***</span>
                       void derived_oop_fn(oop* base, oop* derived),
                       OopClosure* value_fn);
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const { print_on(tty); }</span>
  };
  
  class ImmutableOopMapBuilder;
  
  class ImmutableOopMap {
<span class="line-new-header">--- 255,11 ---</span>
                       void derived_oop_fn(oop* base, oop* derived),
                       OopClosure* value_fn);
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const;</span>
  };
  
  class ImmutableOopMapBuilder;
  
  class ImmutableOopMap {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,19 ***</span>
  
    address data_addr() const { return (address) this + sizeof(ImmutableOopMap); }
  public:
    ImmutableOopMap(const OopMap* oopmap);
  
<span class="line-removed">-   bool has_derived_pointer() const PRODUCT_RETURN0;</span>
    int count() const { return _count; }
  #ifdef ASSERT
    int nr_of_bytes() const; // this is an expensive operation, only used in debug builds
  #endif
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const { print_on(tty); }</span>
  };
  
  class ImmutableOopMapSet;
  class ImmutableOopMap;
  class OopMapSet;
<span class="line-new-header">--- 273,18 ---</span>
  
    address data_addr() const { return (address) this + sizeof(ImmutableOopMap); }
  public:
    ImmutableOopMap(const OopMap* oopmap);
  
    int count() const { return _count; }
  #ifdef ASSERT
    int nr_of_bytes() const; // this is an expensive operation, only used in debug builds
  #endif
  
    // Printing
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const;</span>
  };
  
  class ImmutableOopMapSet;
  class ImmutableOopMap;
  class OopMapSet;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,26 ***</span>
  
    int count() const { return _count; }
    int nr_of_bytes() const { return _size; }
  
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const { print_on(tty); }</span>
  };
  
  class OopMapStream : public StackObj {
   private:
    CompressedReadStream* _stream;
<span class="line-removed">-   int _mask;</span>
    int _size;
    int _position;
    bool _valid_omv;
    OopMapValue _omv;
    void find_next();
  
   public:
<span class="line-modified">!   OopMapStream(OopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);</span>
<span class="line-modified">!   OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);</span>
    bool is_done()                        { if(!_valid_omv) { find_next(); } return !_valid_omv; }
    void next()                           { find_next(); }
    OopMapValue current()                 { return _omv; }
  #ifdef ASSERT
    int stream_position() const           { return _stream-&gt;position(); }
<span class="line-new-header">--- 331,25 ---</span>
  
    int count() const { return _count; }
    int nr_of_bytes() const { return _size; }
  
    void print_on(outputStream* st) const;
<span class="line-modified">!   void print() const;</span>
  };
  
  class OopMapStream : public StackObj {
   private:
    CompressedReadStream* _stream;
    int _size;
    int _position;
    bool _valid_omv;
    OopMapValue _omv;
    void find_next();
  
   public:
<span class="line-modified">!   OopMapStream(OopMap* oop_map);</span>
<span class="line-modified">!   OopMapStream(const ImmutableOopMap* oop_map);</span>
    bool is_done()                        { if(!_valid_omv) { find_next(); } return !_valid_omv; }
    void next()                           { find_next(); }
    OopMapValue current()                 { return _omv; }
  #ifdef ASSERT
    int stream_position() const           { return _stream-&gt;position(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,17 ***</span>
  // pointers are updated based on their base pointers new value and an offset.
  #if COMPILER2_OR_JVMCI
  class DerivedPointerTable : public AllStatic {
    friend class VMStructs;
   private:
<span class="line-modified">!    static GrowableArray&lt;DerivedPointerEntry*&gt;* _list;</span>
<span class="line-modified">!    static bool _active;                      // do not record pointers for verify pass etc.</span>
   public:
    static void clear();                       // Called before scavenge/GC
    static void add(oop *derived, oop *base);  // Called during scavenge/GC
    static void update_pointers();             // Called after  scavenge/GC
<span class="line-modified">!   static bool is_empty()                     { return _list == NULL || _list-&gt;is_empty(); }</span>
    static bool is_active()                    { return _active; }
    static void set_active(bool value)         { _active = value; }
  };
  
  // A utility class to temporarily &quot;deactivate&quot; the DerivedPointerTable.
<span class="line-new-header">--- 433,18 ---</span>
  // pointers are updated based on their base pointers new value and an offset.
  #if COMPILER2_OR_JVMCI
  class DerivedPointerTable : public AllStatic {
    friend class VMStructs;
   private:
<span class="line-modified">!   class Entry;</span>
<span class="line-modified">!   static bool _active;                      // do not record pointers for verify pass etc.</span>
<span class="line-added">+ </span>
   public:
    static void clear();                       // Called before scavenge/GC
    static void add(oop *derived, oop *base);  // Called during scavenge/GC
    static void update_pointers();             // Called after  scavenge/GC
<span class="line-modified">!   static bool is_empty();</span>
    static bool is_active()                    { return _active; }
    static void set_active(bool value)         { _active = value; }
  };
  
  // A utility class to temporarily &quot;deactivate&quot; the DerivedPointerTable.
</pre>
<center><a href="oopMap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/epsilon/epsilonArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/compilerDirectives.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerDefinitions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerDirectives.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compilerDirectives.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
439 
440 // Create a new dirstack and push a default directive
441 void DirectivesStack::init() {
442   CompilerDirectives* _default_directives = new CompilerDirectives();
443   char str[] = &quot;*.*&quot;;
444   const char* error_msg = NULL;
445   _default_directives-&gt;add_match(str, error_msg);
446 #if defined(COMPILER1) || INCLUDE_JVMCI
447   _default_directives-&gt;_c1_store-&gt;EnableOption = true;
448 #endif
449 #ifdef COMPILER2
450   if (is_server_compilation_mode_vm()) {
451     _default_directives-&gt;_c2_store-&gt;EnableOption = true;
452   }
453 #endif
454   assert(error_msg == NULL, &quot;Must succeed.&quot;);
455   push(_default_directives);
456 }
457 
458 DirectiveSet* DirectivesStack::getDefaultDirective(AbstractCompiler* comp) {
<span class="line-modified">459   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
460 
461   assert(_bottom != NULL, &quot;Must never be empty&quot;);
462   _bottom-&gt;inc_refcount();
463   return _bottom-&gt;get_for(comp);
464 }
465 
466 void DirectivesStack::push(CompilerDirectives* directive) {
<span class="line-modified">467   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
468 
469   directive-&gt;inc_refcount();
470   if (_top == NULL) {
471     assert(_bottom == NULL, &quot;There can only be one default directive&quot;);
472     _bottom = directive; // default directive, can never be removed.
473   }
474 
475   directive-&gt;set_next(_top);
476   _top = directive;
477   _depth++;
478 }
479 
480 void DirectivesStack::pop(int count) {
<span class="line-modified">481   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
482   assert(count &gt; -1, &quot;No negative values&quot;);
483   for (int i = 0; i &lt; count; i++) {
484     pop_inner();
485   }
486 }
487 
488 void DirectivesStack::pop_inner() {
489   assert(DirectivesStack_lock-&gt;owned_by_self(), &quot;&quot;);
490 
491   if (_top-&gt;next() == NULL) {
492     return; // Do nothing - don&#39;t allow an empty stack
493   }
494   CompilerDirectives* tmp = _top;
495   _top = _top-&gt;next();
496   _depth--;
497 
498   DirectivesStack::release(tmp);
499 }
500 
501 bool DirectivesStack::check_capacity(int request_size, outputStream* st) {
502   if ((request_size + _depth) &gt; CompilerDirectivesLimit) {
503     st-&gt;print_cr(&quot;Could not add %i more directives. Currently %i/%i directives.&quot;, request_size, _depth, CompilerDirectivesLimit);
504     return false;
505   }
506   return true;
507 }
508 
509 void DirectivesStack::clear() {
510   // holding the lock during the whole operation ensuring consistent result
<span class="line-modified">511   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
512   while (_top-&gt;next() != NULL) {
513     pop_inner();
514   }
515 }
516 
517 void DirectivesStack::print(outputStream* st) {
<span class="line-modified">518   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
519   CompilerDirectives* tmp = _top;
520   while (tmp != NULL) {
521     tmp-&gt;print(st);
522     tmp = tmp-&gt;next();
523     st-&gt;cr();
524   }
525 }
526 
527 void DirectivesStack::release(DirectiveSet* set) {
528   assert(set != NULL, &quot;Never NULL&quot;);
<span class="line-modified">529   MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
530   if (set-&gt;is_exclusive_copy()) {
531     // Old CompilecCmmands forced us to create an exclusive copy
532     delete set;
533   } else {
534     assert(set-&gt;directive() != NULL, &quot;Never NULL&quot;);
535     release(set-&gt;directive());
536   }
537 }
538 
539 
540 void DirectivesStack::release(CompilerDirectives* dir) {
541   assert(DirectivesStack_lock-&gt;owned_by_self(), &quot;&quot;);
542   dir-&gt;dec_refcount();
543   if (dir-&gt;refcount() == 0) {
544     delete dir;
545   }
546 }
547 
548 DirectiveSet* DirectivesStack::getMatchingDirective(const methodHandle&amp; method, AbstractCompiler *comp) {
549   assert(_depth &gt; 0, &quot;Must never be empty&quot;);
550 
551   DirectiveSet* match = NULL;
552   {
<span class="line-modified">553     MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
554 
555     CompilerDirectives* dir = _top;
556     assert(dir != NULL, &quot;Must be initialized&quot;);
557 
558     while (dir != NULL) {
559       if (dir-&gt;is_default_directive() || dir-&gt;match(method)) {
560         match = dir-&gt;get_for(comp);
561         assert(match != NULL, &quot;Consistency&quot;);
562         if (match-&gt;EnableOption) {
563           // The directiveSet for this compile is also enabled -&gt; success
564           dir-&gt;inc_refcount();
565           break;
566         }
567       }
568       dir = dir-&gt;next();
569     }
570   }
571   guarantee(match != NULL, &quot;There should always be a default directive that matches&quot;);
572 
573   // Check for legacy compile commands update, without DirectivesStack_lock
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
439 
440 // Create a new dirstack and push a default directive
441 void DirectivesStack::init() {
442   CompilerDirectives* _default_directives = new CompilerDirectives();
443   char str[] = &quot;*.*&quot;;
444   const char* error_msg = NULL;
445   _default_directives-&gt;add_match(str, error_msg);
446 #if defined(COMPILER1) || INCLUDE_JVMCI
447   _default_directives-&gt;_c1_store-&gt;EnableOption = true;
448 #endif
449 #ifdef COMPILER2
450   if (is_server_compilation_mode_vm()) {
451     _default_directives-&gt;_c2_store-&gt;EnableOption = true;
452   }
453 #endif
454   assert(error_msg == NULL, &quot;Must succeed.&quot;);
455   push(_default_directives);
456 }
457 
458 DirectiveSet* DirectivesStack::getDefaultDirective(AbstractCompiler* comp) {
<span class="line-modified">459   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
460 
461   assert(_bottom != NULL, &quot;Must never be empty&quot;);
462   _bottom-&gt;inc_refcount();
463   return _bottom-&gt;get_for(comp);
464 }
465 
466 void DirectivesStack::push(CompilerDirectives* directive) {
<span class="line-modified">467   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
468 
469   directive-&gt;inc_refcount();
470   if (_top == NULL) {
471     assert(_bottom == NULL, &quot;There can only be one default directive&quot;);
472     _bottom = directive; // default directive, can never be removed.
473   }
474 
475   directive-&gt;set_next(_top);
476   _top = directive;
477   _depth++;
478 }
479 
480 void DirectivesStack::pop(int count) {
<span class="line-modified">481   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
482   assert(count &gt; -1, &quot;No negative values&quot;);
483   for (int i = 0; i &lt; count; i++) {
484     pop_inner();
485   }
486 }
487 
488 void DirectivesStack::pop_inner() {
489   assert(DirectivesStack_lock-&gt;owned_by_self(), &quot;&quot;);
490 
491   if (_top-&gt;next() == NULL) {
492     return; // Do nothing - don&#39;t allow an empty stack
493   }
494   CompilerDirectives* tmp = _top;
495   _top = _top-&gt;next();
496   _depth--;
497 
498   DirectivesStack::release(tmp);
499 }
500 
501 bool DirectivesStack::check_capacity(int request_size, outputStream* st) {
502   if ((request_size + _depth) &gt; CompilerDirectivesLimit) {
503     st-&gt;print_cr(&quot;Could not add %i more directives. Currently %i/%i directives.&quot;, request_size, _depth, CompilerDirectivesLimit);
504     return false;
505   }
506   return true;
507 }
508 
509 void DirectivesStack::clear() {
510   // holding the lock during the whole operation ensuring consistent result
<span class="line-modified">511   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
512   while (_top-&gt;next() != NULL) {
513     pop_inner();
514   }
515 }
516 
517 void DirectivesStack::print(outputStream* st) {
<span class="line-modified">518   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
519   CompilerDirectives* tmp = _top;
520   while (tmp != NULL) {
521     tmp-&gt;print(st);
522     tmp = tmp-&gt;next();
523     st-&gt;cr();
524   }
525 }
526 
527 void DirectivesStack::release(DirectiveSet* set) {
528   assert(set != NULL, &quot;Never NULL&quot;);
<span class="line-modified">529   MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
530   if (set-&gt;is_exclusive_copy()) {
531     // Old CompilecCmmands forced us to create an exclusive copy
532     delete set;
533   } else {
534     assert(set-&gt;directive() != NULL, &quot;Never NULL&quot;);
535     release(set-&gt;directive());
536   }
537 }
538 
539 
540 void DirectivesStack::release(CompilerDirectives* dir) {
541   assert(DirectivesStack_lock-&gt;owned_by_self(), &quot;&quot;);
542   dir-&gt;dec_refcount();
543   if (dir-&gt;refcount() == 0) {
544     delete dir;
545   }
546 }
547 
548 DirectiveSet* DirectivesStack::getMatchingDirective(const methodHandle&amp; method, AbstractCompiler *comp) {
549   assert(_depth &gt; 0, &quot;Must never be empty&quot;);
550 
551   DirectiveSet* match = NULL;
552   {
<span class="line-modified">553     MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);</span>
554 
555     CompilerDirectives* dir = _top;
556     assert(dir != NULL, &quot;Must be initialized&quot;);
557 
558     while (dir != NULL) {
559       if (dir-&gt;is_default_directive() || dir-&gt;match(method)) {
560         match = dir-&gt;get_for(comp);
561         assert(match != NULL, &quot;Consistency&quot;);
562         if (match-&gt;EnableOption) {
563           // The directiveSet for this compile is also enabled -&gt; success
564           dir-&gt;inc_refcount();
565           break;
566         }
567       }
568       dir = dir-&gt;next();
569     }
570   }
571   guarantee(match != NULL, &quot;There should always be a default directive that matches&quot;);
572 
573   // Check for legacy compile commands update, without DirectivesStack_lock
</pre>
</td>
</tr>
</table>
<center><a href="compilerDefinitions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerDirectives.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
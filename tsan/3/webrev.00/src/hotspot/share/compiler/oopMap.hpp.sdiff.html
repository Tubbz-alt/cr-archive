<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/oopMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/epsilon/epsilonArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/oopMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_COMPILER_OOPMAP_HPP
 26 #define SHARE_COMPILER_OOPMAP_HPP
 27 
 28 #include &quot;code/compressedStream.hpp&quot;
 29 #include &quot;code/vmreg.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
<span class="line-removed"> 32 #include &quot;utilities/growableArray.hpp&quot;</span>
 33 
 34 // Interface for generating the frame map for compiled code.  A frame map
 35 // describes for a specific pc whether each register and frame stack slot is:
 36 //   Oop         - A GC root for current frame
 37 //   Dead        - Dead; can be Zapped for debugging
 38 //   CalleeXX    - Callee saved; also describes which caller register is saved
 39 //   DerivedXX   - A derived oop; original oop is described.
 40 //
 41 // OopMapValue describes a single OopMap entry
 42 
 43 class frame;
 44 class RegisterMap;
<span class="line-removed"> 45 class DerivedPointerEntry;</span>
 46 class OopClosure;
 47 
 48 class OopMapValue: public StackObj {
 49   friend class VMStructs;
 50 private:
 51   short _value;
 52   int value() const                                 { return _value; }
 53   void set_value(int value)                         { _value = value; }
 54   short _content_reg;
 55 
 56 public:
 57   // Constants
<span class="line-modified"> 58   enum { type_bits                = 4,</span>
 59          register_bits            = BitsPerShort - type_bits };
 60 
 61   enum { type_shift               = 0,
 62          register_shift           = type_bits };
 63 
 64   enum { type_mask                = right_n_bits(type_bits),
 65          type_mask_in_place       = type_mask &lt;&lt; type_shift,
 66          register_mask            = right_n_bits(register_bits),
 67          register_mask_in_place   = register_mask &lt;&lt; register_shift };
 68 
<span class="line-modified"> 69   enum oop_types {              // must fit in type_bits</span>
<span class="line-modified"> 70          unused_value =0,       // powers of 2, for masking OopMapStream</span>
<span class="line-modified"> 71          oop_value = 1,</span>
<span class="line-modified"> 72          narrowoop_value = 2,</span>
<span class="line-modified"> 73          callee_saved_value = 4,</span>
<span class="line-modified"> 74          derived_oop_value= 8 };</span>

 75 
 76   // Constructors
 77   OopMapValue () { set_value(0); set_content_reg(VMRegImpl::Bad()); }
<span class="line-modified"> 78   OopMapValue (VMReg reg, oop_types t) { set_reg_type(reg, t); set_content_reg(VMRegImpl::Bad()); }</span>
<span class="line-modified"> 79   OopMapValue (VMReg reg, oop_types t, VMReg reg2) { set_reg_type(reg, t); set_content_reg(reg2); }</span>
<span class="line-modified"> 80   OopMapValue (CompressedReadStream* stream) { read_from(stream); }</span>




















 81 

 82   // Archiving
 83   void write_on(CompressedWriteStream* stream) {
 84     stream-&gt;write_int(value());
 85     if(is_callee_saved() || is_derived_oop()) {
 86       stream-&gt;write_int(content_reg()-&gt;value());
 87     }
 88   }
 89 
 90   void read_from(CompressedReadStream* stream) {
 91     set_value(stream-&gt;read_int());
 92     if (is_callee_saved() || is_derived_oop()) {
 93       set_content_reg(VMRegImpl::as_VMReg(stream-&gt;read_int(), true));
 94     }
 95   }
 96 
 97   // Querying
 98   bool is_oop()               { return mask_bits(value(), type_mask_in_place) == oop_value; }
<span class="line-modified"> 99   bool is_narrowoop()           { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }</span>
100   bool is_callee_saved()      { return mask_bits(value(), type_mask_in_place) == callee_saved_value; }
101   bool is_derived_oop()       { return mask_bits(value(), type_mask_in_place) == derived_oop_value; }
102 
<span class="line-removed">103   void set_oop()              { set_value((value() &amp; register_mask_in_place) | oop_value); }</span>
<span class="line-removed">104   void set_narrowoop()          { set_value((value() &amp; register_mask_in_place) | narrowoop_value); }</span>
<span class="line-removed">105   void set_callee_saved()     { set_value((value() &amp; register_mask_in_place) | callee_saved_value); }</span>
<span class="line-removed">106   void set_derived_oop()      { set_value((value() &amp; register_mask_in_place) | derived_oop_value); }</span>
<span class="line-removed">107 </span>
108   VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) &gt;&gt; register_shift); }
109   oop_types type() const      { return (oop_types)mask_bits(value(), type_mask_in_place); }
110 
111   static bool legal_vm_reg_name(VMReg p) {
112     return (p-&gt;value()  == (p-&gt;value() &amp; register_mask));
113   }
114 
<span class="line-removed">115   void set_reg_type(VMReg p, oop_types t) {</span>
<span class="line-removed">116     set_value((p-&gt;value() &lt;&lt; register_shift) | t);</span>
<span class="line-removed">117     assert(reg() == p, &quot;sanity check&quot; );</span>
<span class="line-removed">118     assert(type() == t, &quot;sanity check&quot; );</span>
<span class="line-removed">119   }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 </span>
122   VMReg content_reg() const       { return VMRegImpl::as_VMReg(_content_reg, true); }
<span class="line-removed">123   void set_content_reg(VMReg r)   { _content_reg = r-&gt;value(); }</span>
124 
125   // Physical location queries
126   bool is_register_loc()      { return reg()-&gt;is_reg(); }
127   bool is_stack_loc()         { return reg()-&gt;is_stack(); }
128 
129   // Returns offset from sp.
130   int stack_offset() {
131     assert(is_stack_loc(), &quot;must be stack location&quot;);
132     return reg()-&gt;reg2stack();
133   }
134 
135   void print_on(outputStream* st) const;
<span class="line-modified">136   void print() const { print_on(tty); }</span>
137 };
138 
139 
140 class OopMap: public ResourceObj {
141   friend class OopMapStream;
142   friend class VMStructs;
143  private:
144   int  _pc_offset; // offset in the code that this OopMap corresponds to
145   int  _omv_count; // number of OopMapValues in the stream
146   CompressedWriteStream* _write_stream;
147 
148   debug_only( OopMapValue::oop_types* _locs_used; int _locs_length;)
149 
150   // Accessors
151   int omv_count() const                       { return _omv_count; }
152   void set_omv_count(int value)               { _omv_count = value; }
153   void increment_count()                      { _omv_count++; }
154   CompressedWriteStream* write_stream() const { return _write_stream; }
155   void set_write_stream(CompressedWriteStream* value) { _write_stream = value; }
156 
157  private:
158   enum DeepCopyToken { _deep_copy_token };
159   OopMap(DeepCopyToken, OopMap* source);  // used only by deep_copy
160 


161  public:
162   OopMap(int frame_size, int arg_count);
163 
164   // pc-offset handling
165   int offset() const     { return _pc_offset; }
166   void set_offset(int o) { _pc_offset = o; }
167   int count() const { return _omv_count; }
168   int data_size() const  { return write_stream()-&gt;position(); }
169   address data() const { return write_stream()-&gt;buffer(); }
170 
171   // Check to avoid double insertion
172   debug_only(OopMapValue::oop_types locs_used( int indx ) { return _locs_used[indx]; })
173 
174   // Construction
175   // frame_size units are stack-slots (4 bytes) NOT intptr_t; we can name odd
176   // slots to hold 4-byte values like ints and floats in the LP64 build.
177   void set_oop  ( VMReg local);
<span class="line-removed">178   void set_value( VMReg local);</span>
179   void set_narrowoop(VMReg local);
<span class="line-removed">180   void set_dead ( VMReg local);</span>
181   void set_callee_saved( VMReg local, VMReg caller_machine_register );
182   void set_derived_oop ( VMReg local, VMReg derived_from_local_register );
<span class="line-removed">183   void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);</span>
184 
185   int heap_size() const;
186   void copy_data_to(address addr) const;
187   OopMap* deep_copy();
188 
<span class="line-removed">189   bool has_derived_pointer() const PRODUCT_RETURN0;</span>
<span class="line-removed">190 </span>
191   bool legal_vm_reg_name(VMReg local) {
192      return OopMapValue::legal_vm_reg_name(local);
193   }
194 
195   // Printing
196   void print_on(outputStream* st) const;
<span class="line-modified">197   void print() const { print_on(tty); }</span>
198   bool equals(const OopMap* other) const;
199 };
200 
201 
202 class OopMapSet : public ResourceObj {
203   friend class VMStructs;
204  private:
205   int _om_count;
206   int _om_size;
207   OopMap** _om_data;
208 
209   int om_count() const              { return _om_count; }
210   void set_om_count(int value)      { _om_count = value; }
211   void increment_count()            { _om_count++; }
212   int om_size() const               { return _om_size; }
213   void set_om_size(int value)       { _om_size = value; }
214   OopMap** om_data() const          { return _om_data; }
215   void set_om_data(OopMap** value)  { _om_data = value; }
216   void grow_om_data();
217   void set(int index,OopMap* value) { assert((index == 0) || ((index &gt; 0) &amp;&amp; (index &lt; om_size())),&quot;bad index&quot;); _om_data[index] = value; }
</pre>
<hr />
<pre>
220   OopMapSet();
221 
222   // returns the number of OopMaps in this OopMapSet
223   int size() const            { return _om_count; }
224   // returns the OopMap at a given index
225   OopMap* at(int index) const { assert((index &gt;= 0) &amp;&amp; (index &lt;= om_count()),&quot;bad index&quot;); return _om_data[index]; }
226 
227   // Collect OopMaps.
228   void add_gc_map(int pc, OopMap* map);
229 
230   // Returns the only oop map. Used for reconstructing
231   // Adapter frames during deoptimization
232   OopMap* singular_oop_map();
233 
234   // returns OopMap in that is anchored to the pc
235   OopMap* find_map_at_offset(int pc_offset) const;
236 
237   int heap_size() const;
238 
239   // Methods oops_do() and all_do() filter out NULL oops and
<span class="line-modified">240   // oop == Universe::narrow_oop_base() before passing oops</span>
241   // to closures.
242 
243   // Iterates through frame for a compiled method
244   static void oops_do            (const frame* fr,
245                                   const RegisterMap* reg_map, OopClosure* f);
246   static void update_register_map(const frame* fr, RegisterMap *reg_map);
247 
248   // Iterates through frame for a compiled method for dead ones and values, too
249   static void all_do(const frame* fr, const RegisterMap* reg_map,
250                      OopClosure* oop_fn,
251                      void derived_oop_fn(oop* base, oop* derived),
252                      OopClosure* value_fn);
253 
254   // Printing
255   void print_on(outputStream* st) const;
<span class="line-modified">256   void print() const { print_on(tty); }</span>
257 };
258 
259 class ImmutableOopMapBuilder;
260 
261 class ImmutableOopMap {
262   friend class OopMapStream;
263   friend class VMStructs;
264 #ifdef ASSERT
265   friend class ImmutableOopMapBuilder;
266 #endif
267 private:
268   int _count; // contains the number of entries in this OopMap
269 
270   address data_addr() const { return (address) this + sizeof(ImmutableOopMap); }
271 public:
272   ImmutableOopMap(const OopMap* oopmap);
273 
<span class="line-removed">274   bool has_derived_pointer() const PRODUCT_RETURN0;</span>
275   int count() const { return _count; }
276 #ifdef ASSERT
277   int nr_of_bytes() const; // this is an expensive operation, only used in debug builds
278 #endif
279 
280   // Printing
281   void print_on(outputStream* st) const;
<span class="line-modified">282   void print() const { print_on(tty); }</span>
283 };
284 
285 class ImmutableOopMapSet;
286 class ImmutableOopMap;
287 class OopMapSet;
288 
289 class ImmutableOopMapPair {
290   friend class VMStructs;
291 private:
292   int _pc_offset; // program counter offset from the beginning of the method
293   int _oopmap_offset; // offset in the data in the ImmutableOopMapSet where the ImmutableOopMap is located
294 public:
295   ImmutableOopMapPair(int pc_offset, int oopmap_offset) : _pc_offset(pc_offset), _oopmap_offset(oopmap_offset) {
296     assert(pc_offset &gt;= 0 &amp;&amp; oopmap_offset &gt;= 0, &quot;check&quot;);
297   }
298   const ImmutableOopMap* get_from(const ImmutableOopMapSet* set) const;
299 
300   int pc_offset() const { return _pc_offset; }
301   int oopmap_offset() const { return _oopmap_offset; }
302 };
</pre>
<hr />
<pre>
313   ImmutableOopMapSet(const OopMapSet* oopmap_set, int size) : _count(oopmap_set-&gt;size()), _size(size) {}
314 
315   ImmutableOopMap* oopmap_at_offset(int offset) const {
316     assert(offset &gt;= 0 &amp;&amp; offset &lt; _size, &quot;must be within boundaries&quot;);
317     address addr = data() + offset;
318     return (ImmutableOopMap*) addr;
319   }
320 
321   ImmutableOopMapPair* get_pairs() const { return (ImmutableOopMapPair*) ((address) this + sizeof(*this)); }
322 
323   static ImmutableOopMapSet* build_from(const OopMapSet* oopmap_set);
324 
325   const ImmutableOopMap* find_map_at_offset(int pc_offset) const;
326 
327   const ImmutableOopMapPair* pair_at(int index) const { assert(index &gt;= 0 &amp;&amp; index &lt; _count, &quot;check&quot;); return &amp;get_pairs()[index]; }
328 
329   int count() const { return _count; }
330   int nr_of_bytes() const { return _size; }
331 
332   void print_on(outputStream* st) const;
<span class="line-modified">333   void print() const { print_on(tty); }</span>
334 };
335 
336 class OopMapStream : public StackObj {
337  private:
338   CompressedReadStream* _stream;
<span class="line-removed">339   int _mask;</span>
340   int _size;
341   int _position;
342   bool _valid_omv;
343   OopMapValue _omv;
344   void find_next();
345 
346  public:
<span class="line-modified">347   OopMapStream(OopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);</span>
<span class="line-modified">348   OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);</span>
349   bool is_done()                        { if(!_valid_omv) { find_next(); } return !_valid_omv; }
350   void next()                           { find_next(); }
351   OopMapValue current()                 { return _omv; }
352 #ifdef ASSERT
353   int stream_position() const           { return _stream-&gt;position(); }
354 #endif
355 };
356 
357 class ImmutableOopMapBuilder {
358 private:
359   class Mapping;
360 
361 private:
362   const OopMapSet* _set;
363   const OopMap* _empty;
364   const OopMap* _last;
365   int _empty_offset;
366   int _last_offset;
367   int _offset;
368   int _required;
</pre>
<hr />
<pre>
416   bool has_empty() const {
417     return _empty_offset != -1;
418   }
419 
420   int size_for(const OopMap* map) const;
421   void fill_pair(ImmutableOopMapPair* pair, const OopMap* map, int offset, const ImmutableOopMapSet* set);
422   int fill_map(ImmutableOopMapPair* pair, const OopMap* map, int offset, const ImmutableOopMapSet* set);
423   void fill(ImmutableOopMapSet* set, int size);
424 };
425 
426 
427 // Derived pointer support. This table keeps track of all derived points on a
428 // stack.  It is cleared before each scavenge/GC.  During the traversal of all
429 // oops, it is filled in with references to all locations that contains a
430 // derived oop (assumed to be very few).  When the GC is complete, the derived
431 // pointers are updated based on their base pointers new value and an offset.
432 #if COMPILER2_OR_JVMCI
433 class DerivedPointerTable : public AllStatic {
434   friend class VMStructs;
435  private:
<span class="line-modified">436    static GrowableArray&lt;DerivedPointerEntry*&gt;* _list;</span>
<span class="line-modified">437    static bool _active;                      // do not record pointers for verify pass etc.</span>

438  public:
439   static void clear();                       // Called before scavenge/GC
440   static void add(oop *derived, oop *base);  // Called during scavenge/GC
441   static void update_pointers();             // Called after  scavenge/GC
<span class="line-modified">442   static bool is_empty()                     { return _list == NULL || _list-&gt;is_empty(); }</span>
443   static bool is_active()                    { return _active; }
444   static void set_active(bool value)         { _active = value; }
445 };
446 
447 // A utility class to temporarily &quot;deactivate&quot; the DerivedPointerTable.
448 // (Note: clients are responsible for any MT-safety issues)
449 class DerivedPointerTableDeactivate: public StackObj {
450  private:
451   bool _active;
452  public:
453   DerivedPointerTableDeactivate() {
454     _active = DerivedPointerTable::is_active();
455     if (_active) {
456       DerivedPointerTable::set_active(false);
457     }
458   }
459 
460   ~DerivedPointerTableDeactivate() {
461     assert(!DerivedPointerTable::is_active(),
462            &quot;Inconsistency: not MT-safe&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_COMPILER_OOPMAP_HPP
 26 #define SHARE_COMPILER_OOPMAP_HPP
 27 
 28 #include &quot;code/compressedStream.hpp&quot;
 29 #include &quot;code/vmreg.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;

 32 
 33 // Interface for generating the frame map for compiled code.  A frame map
 34 // describes for a specific pc whether each register and frame stack slot is:
 35 //   Oop         - A GC root for current frame
 36 //   Dead        - Dead; can be Zapped for debugging
 37 //   CalleeXX    - Callee saved; also describes which caller register is saved
 38 //   DerivedXX   - A derived oop; original oop is described.
 39 //
 40 // OopMapValue describes a single OopMap entry
 41 
 42 class frame;
 43 class RegisterMap;

 44 class OopClosure;
 45 
 46 class OopMapValue: public StackObj {
 47   friend class VMStructs;
 48 private:
 49   short _value;
 50   int value() const                                 { return _value; }
 51   void set_value(int value)                         { _value = value; }
 52   short _content_reg;
 53 
 54 public:
 55   // Constants
<span class="line-modified"> 56   enum { type_bits                = 2,</span>
 57          register_bits            = BitsPerShort - type_bits };
 58 
 59   enum { type_shift               = 0,
 60          register_shift           = type_bits };
 61 
 62   enum { type_mask                = right_n_bits(type_bits),
 63          type_mask_in_place       = type_mask &lt;&lt; type_shift,
 64          register_mask            = right_n_bits(register_bits),
 65          register_mask_in_place   = register_mask &lt;&lt; register_shift };
 66 
<span class="line-modified"> 67   enum oop_types {</span>
<span class="line-modified"> 68          oop_value,</span>
<span class="line-modified"> 69          narrowoop_value,</span>
<span class="line-modified"> 70          callee_saved_value,</span>
<span class="line-modified"> 71          derived_oop_value,</span>
<span class="line-modified"> 72          unused_value = -1          // Only used as a sentinel value</span>
<span class="line-added"> 73   };</span>
 74 
 75   // Constructors
 76   OopMapValue () { set_value(0); set_content_reg(VMRegImpl::Bad()); }
<span class="line-modified"> 77   OopMapValue (VMReg reg, oop_types t, VMReg reg2) {</span>
<span class="line-modified"> 78     set_reg_type(reg, t);</span>
<span class="line-modified"> 79     set_content_reg(reg2);</span>
<span class="line-added"> 80   }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82  private:</span>
<span class="line-added"> 83     void set_reg_type(VMReg p, oop_types t) {</span>
<span class="line-added"> 84     set_value((p-&gt;value() &lt;&lt; register_shift) | t);</span>
<span class="line-added"> 85     assert(reg() == p, &quot;sanity check&quot; );</span>
<span class="line-added"> 86     assert(type() == t, &quot;sanity check&quot; );</span>
<span class="line-added"> 87   }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89   void set_content_reg(VMReg r) {</span>
<span class="line-added"> 90     if (is_callee_saved()) {</span>
<span class="line-added"> 91       // This can never be a stack location, so we don&#39;t need to transform it.</span>
<span class="line-added"> 92       assert(r-&gt;is_reg(), &quot;Trying to callee save a stack location&quot;);</span>
<span class="line-added"> 93     } else if (is_derived_oop()) {</span>
<span class="line-added"> 94       assert (r-&gt;is_valid(), &quot;must have a valid VMReg&quot;);</span>
<span class="line-added"> 95     } else {</span>
<span class="line-added"> 96       assert (!r-&gt;is_valid(), &quot;valid VMReg not allowed&quot;);</span>
<span class="line-added"> 97     }</span>
<span class="line-added"> 98     _content_reg = r-&gt;value();</span>
<span class="line-added"> 99   }</span>
100 
<span class="line-added">101  public:</span>
102   // Archiving
103   void write_on(CompressedWriteStream* stream) {
104     stream-&gt;write_int(value());
105     if(is_callee_saved() || is_derived_oop()) {
106       stream-&gt;write_int(content_reg()-&gt;value());
107     }
108   }
109 
110   void read_from(CompressedReadStream* stream) {
111     set_value(stream-&gt;read_int());
112     if (is_callee_saved() || is_derived_oop()) {
113       set_content_reg(VMRegImpl::as_VMReg(stream-&gt;read_int(), true));
114     }
115   }
116 
117   // Querying
118   bool is_oop()               { return mask_bits(value(), type_mask_in_place) == oop_value; }
<span class="line-modified">119   bool is_narrowoop()         { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }</span>
120   bool is_callee_saved()      { return mask_bits(value(), type_mask_in_place) == callee_saved_value; }
121   bool is_derived_oop()       { return mask_bits(value(), type_mask_in_place) == derived_oop_value; }
122 





123   VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) &gt;&gt; register_shift); }
124   oop_types type() const      { return (oop_types)mask_bits(value(), type_mask_in_place); }
125 
126   static bool legal_vm_reg_name(VMReg p) {
127     return (p-&gt;value()  == (p-&gt;value() &amp; register_mask));
128   }
129 







130   VMReg content_reg() const       { return VMRegImpl::as_VMReg(_content_reg, true); }

131 
132   // Physical location queries
133   bool is_register_loc()      { return reg()-&gt;is_reg(); }
134   bool is_stack_loc()         { return reg()-&gt;is_stack(); }
135 
136   // Returns offset from sp.
137   int stack_offset() {
138     assert(is_stack_loc(), &quot;must be stack location&quot;);
139     return reg()-&gt;reg2stack();
140   }
141 
142   void print_on(outputStream* st) const;
<span class="line-modified">143   void print() const;</span>
144 };
145 
146 
147 class OopMap: public ResourceObj {
148   friend class OopMapStream;
149   friend class VMStructs;
150  private:
151   int  _pc_offset; // offset in the code that this OopMap corresponds to
152   int  _omv_count; // number of OopMapValues in the stream
153   CompressedWriteStream* _write_stream;
154 
155   debug_only( OopMapValue::oop_types* _locs_used; int _locs_length;)
156 
157   // Accessors
158   int omv_count() const                       { return _omv_count; }
159   void set_omv_count(int value)               { _omv_count = value; }
160   void increment_count()                      { _omv_count++; }
161   CompressedWriteStream* write_stream() const { return _write_stream; }
162   void set_write_stream(CompressedWriteStream* value) { _write_stream = value; }
163 
164  private:
165   enum DeepCopyToken { _deep_copy_token };
166   OopMap(DeepCopyToken, OopMap* source);  // used only by deep_copy
167 
<span class="line-added">168   void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);</span>
<span class="line-added">169 </span>
170  public:
171   OopMap(int frame_size, int arg_count);
172 
173   // pc-offset handling
174   int offset() const     { return _pc_offset; }
175   void set_offset(int o) { _pc_offset = o; }
176   int count() const { return _omv_count; }
177   int data_size() const  { return write_stream()-&gt;position(); }
178   address data() const { return write_stream()-&gt;buffer(); }
179 
180   // Check to avoid double insertion
181   debug_only(OopMapValue::oop_types locs_used( int indx ) { return _locs_used[indx]; })
182 
183   // Construction
184   // frame_size units are stack-slots (4 bytes) NOT intptr_t; we can name odd
185   // slots to hold 4-byte values like ints and floats in the LP64 build.
186   void set_oop  ( VMReg local);

187   void set_narrowoop(VMReg local);

188   void set_callee_saved( VMReg local, VMReg caller_machine_register );
189   void set_derived_oop ( VMReg local, VMReg derived_from_local_register );

190 
191   int heap_size() const;
192   void copy_data_to(address addr) const;
193   OopMap* deep_copy();
194 


195   bool legal_vm_reg_name(VMReg local) {
196      return OopMapValue::legal_vm_reg_name(local);
197   }
198 
199   // Printing
200   void print_on(outputStream* st) const;
<span class="line-modified">201   void print() const;</span>
202   bool equals(const OopMap* other) const;
203 };
204 
205 
206 class OopMapSet : public ResourceObj {
207   friend class VMStructs;
208  private:
209   int _om_count;
210   int _om_size;
211   OopMap** _om_data;
212 
213   int om_count() const              { return _om_count; }
214   void set_om_count(int value)      { _om_count = value; }
215   void increment_count()            { _om_count++; }
216   int om_size() const               { return _om_size; }
217   void set_om_size(int value)       { _om_size = value; }
218   OopMap** om_data() const          { return _om_data; }
219   void set_om_data(OopMap** value)  { _om_data = value; }
220   void grow_om_data();
221   void set(int index,OopMap* value) { assert((index == 0) || ((index &gt; 0) &amp;&amp; (index &lt; om_size())),&quot;bad index&quot;); _om_data[index] = value; }
</pre>
<hr />
<pre>
224   OopMapSet();
225 
226   // returns the number of OopMaps in this OopMapSet
227   int size() const            { return _om_count; }
228   // returns the OopMap at a given index
229   OopMap* at(int index) const { assert((index &gt;= 0) &amp;&amp; (index &lt;= om_count()),&quot;bad index&quot;); return _om_data[index]; }
230 
231   // Collect OopMaps.
232   void add_gc_map(int pc, OopMap* map);
233 
234   // Returns the only oop map. Used for reconstructing
235   // Adapter frames during deoptimization
236   OopMap* singular_oop_map();
237 
238   // returns OopMap in that is anchored to the pc
239   OopMap* find_map_at_offset(int pc_offset) const;
240 
241   int heap_size() const;
242 
243   // Methods oops_do() and all_do() filter out NULL oops and
<span class="line-modified">244   // oop == CompressedOops::base() before passing oops</span>
245   // to closures.
246 
247   // Iterates through frame for a compiled method
248   static void oops_do            (const frame* fr,
249                                   const RegisterMap* reg_map, OopClosure* f);
250   static void update_register_map(const frame* fr, RegisterMap *reg_map);
251 
252   // Iterates through frame for a compiled method for dead ones and values, too
253   static void all_do(const frame* fr, const RegisterMap* reg_map,
254                      OopClosure* oop_fn,
255                      void derived_oop_fn(oop* base, oop* derived),
256                      OopClosure* value_fn);
257 
258   // Printing
259   void print_on(outputStream* st) const;
<span class="line-modified">260   void print() const;</span>
261 };
262 
263 class ImmutableOopMapBuilder;
264 
265 class ImmutableOopMap {
266   friend class OopMapStream;
267   friend class VMStructs;
268 #ifdef ASSERT
269   friend class ImmutableOopMapBuilder;
270 #endif
271 private:
272   int _count; // contains the number of entries in this OopMap
273 
274   address data_addr() const { return (address) this + sizeof(ImmutableOopMap); }
275 public:
276   ImmutableOopMap(const OopMap* oopmap);
277 

278   int count() const { return _count; }
279 #ifdef ASSERT
280   int nr_of_bytes() const; // this is an expensive operation, only used in debug builds
281 #endif
282 
283   // Printing
284   void print_on(outputStream* st) const;
<span class="line-modified">285   void print() const;</span>
286 };
287 
288 class ImmutableOopMapSet;
289 class ImmutableOopMap;
290 class OopMapSet;
291 
292 class ImmutableOopMapPair {
293   friend class VMStructs;
294 private:
295   int _pc_offset; // program counter offset from the beginning of the method
296   int _oopmap_offset; // offset in the data in the ImmutableOopMapSet where the ImmutableOopMap is located
297 public:
298   ImmutableOopMapPair(int pc_offset, int oopmap_offset) : _pc_offset(pc_offset), _oopmap_offset(oopmap_offset) {
299     assert(pc_offset &gt;= 0 &amp;&amp; oopmap_offset &gt;= 0, &quot;check&quot;);
300   }
301   const ImmutableOopMap* get_from(const ImmutableOopMapSet* set) const;
302 
303   int pc_offset() const { return _pc_offset; }
304   int oopmap_offset() const { return _oopmap_offset; }
305 };
</pre>
<hr />
<pre>
316   ImmutableOopMapSet(const OopMapSet* oopmap_set, int size) : _count(oopmap_set-&gt;size()), _size(size) {}
317 
318   ImmutableOopMap* oopmap_at_offset(int offset) const {
319     assert(offset &gt;= 0 &amp;&amp; offset &lt; _size, &quot;must be within boundaries&quot;);
320     address addr = data() + offset;
321     return (ImmutableOopMap*) addr;
322   }
323 
324   ImmutableOopMapPair* get_pairs() const { return (ImmutableOopMapPair*) ((address) this + sizeof(*this)); }
325 
326   static ImmutableOopMapSet* build_from(const OopMapSet* oopmap_set);
327 
328   const ImmutableOopMap* find_map_at_offset(int pc_offset) const;
329 
330   const ImmutableOopMapPair* pair_at(int index) const { assert(index &gt;= 0 &amp;&amp; index &lt; _count, &quot;check&quot;); return &amp;get_pairs()[index]; }
331 
332   int count() const { return _count; }
333   int nr_of_bytes() const { return _size; }
334 
335   void print_on(outputStream* st) const;
<span class="line-modified">336   void print() const;</span>
337 };
338 
339 class OopMapStream : public StackObj {
340  private:
341   CompressedReadStream* _stream;

342   int _size;
343   int _position;
344   bool _valid_omv;
345   OopMapValue _omv;
346   void find_next();
347 
348  public:
<span class="line-modified">349   OopMapStream(OopMap* oop_map);</span>
<span class="line-modified">350   OopMapStream(const ImmutableOopMap* oop_map);</span>
351   bool is_done()                        { if(!_valid_omv) { find_next(); } return !_valid_omv; }
352   void next()                           { find_next(); }
353   OopMapValue current()                 { return _omv; }
354 #ifdef ASSERT
355   int stream_position() const           { return _stream-&gt;position(); }
356 #endif
357 };
358 
359 class ImmutableOopMapBuilder {
360 private:
361   class Mapping;
362 
363 private:
364   const OopMapSet* _set;
365   const OopMap* _empty;
366   const OopMap* _last;
367   int _empty_offset;
368   int _last_offset;
369   int _offset;
370   int _required;
</pre>
<hr />
<pre>
418   bool has_empty() const {
419     return _empty_offset != -1;
420   }
421 
422   int size_for(const OopMap* map) const;
423   void fill_pair(ImmutableOopMapPair* pair, const OopMap* map, int offset, const ImmutableOopMapSet* set);
424   int fill_map(ImmutableOopMapPair* pair, const OopMap* map, int offset, const ImmutableOopMapSet* set);
425   void fill(ImmutableOopMapSet* set, int size);
426 };
427 
428 
429 // Derived pointer support. This table keeps track of all derived points on a
430 // stack.  It is cleared before each scavenge/GC.  During the traversal of all
431 // oops, it is filled in with references to all locations that contains a
432 // derived oop (assumed to be very few).  When the GC is complete, the derived
433 // pointers are updated based on their base pointers new value and an offset.
434 #if COMPILER2_OR_JVMCI
435 class DerivedPointerTable : public AllStatic {
436   friend class VMStructs;
437  private:
<span class="line-modified">438   class Entry;</span>
<span class="line-modified">439   static bool _active;                      // do not record pointers for verify pass etc.</span>
<span class="line-added">440 </span>
441  public:
442   static void clear();                       // Called before scavenge/GC
443   static void add(oop *derived, oop *base);  // Called during scavenge/GC
444   static void update_pointers();             // Called after  scavenge/GC
<span class="line-modified">445   static bool is_empty();</span>
446   static bool is_active()                    { return _active; }
447   static void set_active(bool value)         { _active = value; }
448 };
449 
450 // A utility class to temporarily &quot;deactivate&quot; the DerivedPointerTable.
451 // (Note: clients are responsible for any MT-safety issues)
452 class DerivedPointerTableDeactivate: public StackObj {
453  private:
454   bool _active;
455  public:
456   DerivedPointerTableDeactivate() {
457     _active = DerivedPointerTable::is_active();
458     if (_active) {
459       DerivedPointerTable::set_active(false);
460     }
461   }
462 
463   ~DerivedPointerTableDeactivate() {
464     assert(!DerivedPointerTable::is_active(),
465            &quot;Inconsistency: not MT-safe&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="oopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/epsilon/epsilonArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/compiler/compilerDirectives.cpp b/src/hotspot/share/compiler/compilerDirectives.cpp
--- a/src/hotspot/share/compiler/compilerDirectives.cpp
+++ b/src/hotspot/share/compiler/compilerDirectives.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -454,19 +454,19 @@
   assert(error_msg == NULL, "Must succeed.");
   push(_default_directives);
 }
 
 DirectiveSet* DirectivesStack::getDefaultDirective(AbstractCompiler* comp) {
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
 
   assert(_bottom != NULL, "Must never be empty");
   _bottom->inc_refcount();
   return _bottom->get_for(comp);
 }
 
 void DirectivesStack::push(CompilerDirectives* directive) {
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
 
   directive->inc_refcount();
   if (_top == NULL) {
     assert(_bottom == NULL, "There can only be one default directive");
     _bottom = directive; // default directive, can never be removed.
@@ -476,11 +476,11 @@
   _top = directive;
   _depth++;
 }
 
 void DirectivesStack::pop(int count) {
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
   assert(count > -1, "No negative values");
   for (int i = 0; i < count; i++) {
     pop_inner();
   }
 }
@@ -506,29 +506,29 @@
   return true;
 }
 
 void DirectivesStack::clear() {
   // holding the lock during the whole operation ensuring consistent result
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
   while (_top->next() != NULL) {
     pop_inner();
   }
 }
 
 void DirectivesStack::print(outputStream* st) {
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
   CompilerDirectives* tmp = _top;
   while (tmp != NULL) {
     tmp->print(st);
     tmp = tmp->next();
     st->cr();
   }
 }
 
 void DirectivesStack::release(DirectiveSet* set) {
   assert(set != NULL, "Never NULL");
-  MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
   if (set->is_exclusive_copy()) {
     // Old CompilecCmmands forced us to create an exclusive copy
     delete set;
   } else {
     assert(set->directive() != NULL, "Never NULL");
@@ -548,11 +548,11 @@
 DirectiveSet* DirectivesStack::getMatchingDirective(const methodHandle& method, AbstractCompiler *comp) {
   assert(_depth > 0, "Must never be empty");
 
   DirectiveSet* match = NULL;
   {
-    MutexLockerEx locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
+    MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);
 
     CompilerDirectives* dir = _top;
     assert(dir != NULL, "Must be initialized");
 
     while (dir != NULL) {

diff a/src/hotspot/share/compiler/oopMap.hpp b/src/hotspot/share/compiler/oopMap.hpp
--- a/src/hotspot/share/compiler/oopMap.hpp
+++ b/src/hotspot/share/compiler/oopMap.hpp
@@ -27,11 +27,10 @@
 
 #include "code/compressedStream.hpp"
 #include "code/vmreg.hpp"
 #include "memory/allocation.hpp"
 #include "oops/oopsHierarchy.hpp"
-#include "utilities/growableArray.hpp"
 
 // Interface for generating the frame map for compiled code.  A frame map
 // describes for a specific pc whether each register and frame stack slot is:
 //   Oop         - A GC root for current frame
 //   Dead        - Dead; can be Zapped for debugging
@@ -40,11 +39,10 @@
 //
 // OopMapValue describes a single OopMap entry
 
 class frame;
 class RegisterMap;
-class DerivedPointerEntry;
 class OopClosure;
 
 class OopMapValue: public StackObj {
   friend class VMStructs;
 private:
@@ -53,34 +51,56 @@
   void set_value(int value)                         { _value = value; }
   short _content_reg;
 
 public:
   // Constants
-  enum { type_bits                = 4,
+  enum { type_bits                = 2,
          register_bits            = BitsPerShort - type_bits };
 
   enum { type_shift               = 0,
          register_shift           = type_bits };
 
   enum { type_mask                = right_n_bits(type_bits),
          type_mask_in_place       = type_mask << type_shift,
          register_mask            = right_n_bits(register_bits),
          register_mask_in_place   = register_mask << register_shift };
 
-  enum oop_types {              // must fit in type_bits
-         unused_value =0,       // powers of 2, for masking OopMapStream
-         oop_value = 1,
-         narrowoop_value = 2,
-         callee_saved_value = 4,
-         derived_oop_value= 8 };
+  enum oop_types {
+         oop_value,
+         narrowoop_value,
+         callee_saved_value,
+         derived_oop_value,
+         unused_value = -1          // Only used as a sentinel value
+  };
 
   // Constructors
   OopMapValue () { set_value(0); set_content_reg(VMRegImpl::Bad()); }
-  OopMapValue (VMReg reg, oop_types t) { set_reg_type(reg, t); set_content_reg(VMRegImpl::Bad()); }
-  OopMapValue (VMReg reg, oop_types t, VMReg reg2) { set_reg_type(reg, t); set_content_reg(reg2); }
-  OopMapValue (CompressedReadStream* stream) { read_from(stream); }
+  OopMapValue (VMReg reg, oop_types t, VMReg reg2) {
+    set_reg_type(reg, t);
+    set_content_reg(reg2);
+  }
+
+ private:
+    void set_reg_type(VMReg p, oop_types t) {
+    set_value((p->value() << register_shift) | t);
+    assert(reg() == p, "sanity check" );
+    assert(type() == t, "sanity check" );
+  }
+
+  void set_content_reg(VMReg r) {
+    if (is_callee_saved()) {
+      // This can never be a stack location, so we don't need to transform it.
+      assert(r->is_reg(), "Trying to callee save a stack location");
+    } else if (is_derived_oop()) {
+      assert (r->is_valid(), "must have a valid VMReg");
+    } else {
+      assert (!r->is_valid(), "valid VMReg not allowed");
+    }
+    _content_reg = r->value();
+  }
 
+ public:
   // Archiving
   void write_on(CompressedWriteStream* stream) {
     stream->write_int(value());
     if(is_callee_saved() || is_derived_oop()) {
       stream->write_int(content_reg()->value());
@@ -94,35 +114,22 @@
     }
   }
 
   // Querying
   bool is_oop()               { return mask_bits(value(), type_mask_in_place) == oop_value; }
-  bool is_narrowoop()           { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }
+  bool is_narrowoop()         { return mask_bits(value(), type_mask_in_place) == narrowoop_value; }
   bool is_callee_saved()      { return mask_bits(value(), type_mask_in_place) == callee_saved_value; }
   bool is_derived_oop()       { return mask_bits(value(), type_mask_in_place) == derived_oop_value; }
 
-  void set_oop()              { set_value((value() & register_mask_in_place) | oop_value); }
-  void set_narrowoop()          { set_value((value() & register_mask_in_place) | narrowoop_value); }
-  void set_callee_saved()     { set_value((value() & register_mask_in_place) | callee_saved_value); }
-  void set_derived_oop()      { set_value((value() & register_mask_in_place) | derived_oop_value); }
-
   VMReg reg() const { return VMRegImpl::as_VMReg(mask_bits(value(), register_mask_in_place) >> register_shift); }
   oop_types type() const      { return (oop_types)mask_bits(value(), type_mask_in_place); }
 
   static bool legal_vm_reg_name(VMReg p) {
     return (p->value()  == (p->value() & register_mask));
   }
 
-  void set_reg_type(VMReg p, oop_types t) {
-    set_value((p->value() << register_shift) | t);
-    assert(reg() == p, "sanity check" );
-    assert(type() == t, "sanity check" );
-  }
-
-
   VMReg content_reg() const       { return VMRegImpl::as_VMReg(_content_reg, true); }
-  void set_content_reg(VMReg r)   { _content_reg = r->value(); }
 
   // Physical location queries
   bool is_register_loc()      { return reg()->is_reg(); }
   bool is_stack_loc()         { return reg()->is_stack(); }
 
@@ -131,11 +138,11 @@
     assert(is_stack_loc(), "must be stack location");
     return reg()->reg2stack();
   }
 
   void print_on(outputStream* st) const;
-  void print() const { print_on(tty); }
+  void print() const;
 };
 
 
 class OopMap: public ResourceObj {
   friend class OopMapStream;
@@ -156,10 +163,12 @@
 
  private:
   enum DeepCopyToken { _deep_copy_token };
   OopMap(DeepCopyToken, OopMap* source);  // used only by deep_copy
 
+  void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);
+
  public:
   OopMap(int frame_size, int arg_count);
 
   // pc-offset handling
   int offset() const     { return _pc_offset; }
@@ -173,30 +182,25 @@
 
   // Construction
   // frame_size units are stack-slots (4 bytes) NOT intptr_t; we can name odd
   // slots to hold 4-byte values like ints and floats in the LP64 build.
   void set_oop  ( VMReg local);
-  void set_value( VMReg local);
   void set_narrowoop(VMReg local);
-  void set_dead ( VMReg local);
   void set_callee_saved( VMReg local, VMReg caller_machine_register );
   void set_derived_oop ( VMReg local, VMReg derived_from_local_register );
-  void set_xxx(VMReg reg, OopMapValue::oop_types x, VMReg optional);
 
   int heap_size() const;
   void copy_data_to(address addr) const;
   OopMap* deep_copy();
 
-  bool has_derived_pointer() const PRODUCT_RETURN0;
-
   bool legal_vm_reg_name(VMReg local) {
      return OopMapValue::legal_vm_reg_name(local);
   }
 
   // Printing
   void print_on(outputStream* st) const;
-  void print() const { print_on(tty); }
+  void print() const;
   bool equals(const OopMap* other) const;
 };
 
 
 class OopMapSet : public ResourceObj {
@@ -235,11 +239,11 @@
   OopMap* find_map_at_offset(int pc_offset) const;
 
   int heap_size() const;
 
   // Methods oops_do() and all_do() filter out NULL oops and
-  // oop == Universe::narrow_oop_base() before passing oops
+  // oop == CompressedOops::base() before passing oops
   // to closures.
 
   // Iterates through frame for a compiled method
   static void oops_do            (const frame* fr,
                                   const RegisterMap* reg_map, OopClosure* f);
@@ -251,11 +255,11 @@
                      void derived_oop_fn(oop* base, oop* derived),
                      OopClosure* value_fn);
 
   // Printing
   void print_on(outputStream* st) const;
-  void print() const { print_on(tty); }
+  void print() const;
 };
 
 class ImmutableOopMapBuilder;
 
 class ImmutableOopMap {
@@ -269,19 +273,18 @@
 
   address data_addr() const { return (address) this + sizeof(ImmutableOopMap); }
 public:
   ImmutableOopMap(const OopMap* oopmap);
 
-  bool has_derived_pointer() const PRODUCT_RETURN0;
   int count() const { return _count; }
 #ifdef ASSERT
   int nr_of_bytes() const; // this is an expensive operation, only used in debug builds
 #endif
 
   // Printing
   void print_on(outputStream* st) const;
-  void print() const { print_on(tty); }
+  void print() const;
 };
 
 class ImmutableOopMapSet;
 class ImmutableOopMap;
 class OopMapSet;
@@ -328,26 +331,25 @@
 
   int count() const { return _count; }
   int nr_of_bytes() const { return _size; }
 
   void print_on(outputStream* st) const;
-  void print() const { print_on(tty); }
+  void print() const;
 };
 
 class OopMapStream : public StackObj {
  private:
   CompressedReadStream* _stream;
-  int _mask;
   int _size;
   int _position;
   bool _valid_omv;
   OopMapValue _omv;
   void find_next();
 
  public:
-  OopMapStream(OopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);
-  OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask = OopMapValue::type_mask_in_place);
+  OopMapStream(OopMap* oop_map);
+  OopMapStream(const ImmutableOopMap* oop_map);
   bool is_done()                        { if(!_valid_omv) { find_next(); } return !_valid_omv; }
   void next()                           { find_next(); }
   OopMapValue current()                 { return _omv; }
 #ifdef ASSERT
   int stream_position() const           { return _stream->position(); }
@@ -431,17 +433,18 @@
 // pointers are updated based on their base pointers new value and an offset.
 #if COMPILER2_OR_JVMCI
 class DerivedPointerTable : public AllStatic {
   friend class VMStructs;
  private:
-   static GrowableArray<DerivedPointerEntry*>* _list;
-   static bool _active;                      // do not record pointers for verify pass etc.
+  class Entry;
+  static bool _active;                      // do not record pointers for verify pass etc.
+
  public:
   static void clear();                       // Called before scavenge/GC
   static void add(oop *derived, oop *base);  // Called during scavenge/GC
   static void update_pointers();             // Called after  scavenge/GC
-  static bool is_empty()                     { return _list == NULL || _list->is_empty(); }
+  static bool is_empty();
   static bool is_active()                    { return _active; }
   static void set_active(bool value)         { _active = value; }
 };
 
 // A utility class to temporarily "deactivate" the DerivedPointerTable.

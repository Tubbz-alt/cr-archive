<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/compileBroker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compileBroker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileTask.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_COMPILER_COMPILEBROKER_HPP
 26 #define SHARE_COMPILER_COMPILEBROKER_HPP
 27 
 28 #include &quot;ci/compilerInterface.hpp&quot;
 29 #include &quot;compiler/abstractCompiler.hpp&quot;
 30 #include &quot;compiler/compileTask.hpp&quot;
 31 #include &quot;compiler/compilerDirectives.hpp&quot;

 32 #include &quot;runtime/perfData.hpp&quot;
 33 #include &quot;utilities/stack.hpp&quot;
 34 #if INCLUDE_JVMCI
 35 #include &quot;jvmci/jvmciCompiler.hpp&quot;
 36 #endif
 37 
 38 class nmethod;
 39 class nmethodLocker;
 40 
 41 // CompilerCounters
 42 //
 43 // Per Compiler Performance Counters.
 44 //
 45 class CompilerCounters : public CHeapObj&lt;mtCompiler&gt; {
 46 
 47   public:
 48     enum {
 49       cmname_buffer_length = 160
 50     };
 51 
</pre>
<hr />
<pre>
156 
157   // This flag can be used to stop compilation or turn it back on
158   static volatile jint _should_compile_new_jobs;
159 
160   // The installed compiler(s)
161   static AbstractCompiler* _compilers[2];
162 
163   // The maximum numbers of compiler threads to be determined during startup.
164   static int _c1_count, _c2_count;
165 
166   // An array of compiler thread Java objects
167   static jobject *_compiler1_objects, *_compiler2_objects;
168 
169   // An array of compiler logs
170   static CompileLog **_compiler1_logs, **_compiler2_logs;
171 
172   // These counters are used for assigning id&#39;s to each compilation
173   static volatile jint _compilation_id;
174   static volatile jint _osr_compilation_id;
175 
<span class="line-removed">176   static int  _last_compile_type;</span>
<span class="line-removed">177   static int  _last_compile_level;</span>
<span class="line-removed">178   static char _last_method_compiled[name_buffer_length];</span>
<span class="line-removed">179 </span>
180   static CompileQueue* _c2_compile_queue;
181   static CompileQueue* _c1_compile_queue;
182 
183   // performance counters
184   static PerfCounter* _perf_total_compilation;
185   static PerfCounter* _perf_native_compilation;
186   static PerfCounter* _perf_osr_compilation;
187   static PerfCounter* _perf_standard_compilation;
188 
189   static PerfCounter* _perf_total_bailout_count;
190   static PerfCounter* _perf_total_invalidated_count;
191   static PerfCounter* _perf_total_compile_count;
192   static PerfCounter* _perf_total_native_compile_count;
193   static PerfCounter* _perf_total_osr_compile_count;
194   static PerfCounter* _perf_total_standard_compile_count;
195 
196   static PerfCounter* _perf_sum_osr_bytes_compiled;
197   static PerfCounter* _perf_sum_standard_bytes_compiled;
198   static PerfCounter* _perf_sum_nmethod_size;
199   static PerfCounter* _perf_sum_nmethod_code_size;
</pre>
<hr />
<pre>
213   static elapsedTimer _t_invalidated_compilation;
214   static elapsedTimer _t_bailedout_compilation;
215 
216   static int _total_compile_count;
217   static int _total_bailout_count;
218   static int _total_invalidated_count;
219   static int _total_native_compile_count;
220   static int _total_osr_compile_count;
221   static int _total_standard_compile_count;
222   static int _total_compiler_stopped_count;
223   static int _total_compiler_restarted_count;
224   static int _sum_osr_bytes_compiled;
225   static int _sum_standard_bytes_compiled;
226   static int _sum_nmethod_size;
227   static int _sum_nmethod_code_size;
228   static long _peak_compilation_time;
229 
230   static volatile int _print_compilation_warning;
231 
232   static Handle create_thread_oop(const char* name, TRAPS);
<span class="line-modified">233   static JavaThread* make_thread(jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, TRAPS);</span>
234   static void init_compiler_sweeper_threads();
<span class="line-modified">235   static void possibly_add_compiler_threads();</span>
<span class="line-removed">236   static bool compilation_is_complete  (const methodHandle&amp; method, int osr_bci, int comp_level);</span>
237   static bool compilation_is_prohibited(const methodHandle&amp; method, int osr_bci, int comp_level, bool excluded);
<span class="line-removed">238   static void preload_classes          (const methodHandle&amp; method, TRAPS);</span>
239 
240   static CompileTask* create_compile_task(CompileQueue*       queue,
241                                           int                 compile_id,
242                                           const methodHandle&amp; method,
243                                           int                 osr_bci,
244                                           int                 comp_level,
245                                           const methodHandle&amp; hot_method,
246                                           int                 hot_count,
247                                           CompileTask::CompileReason compile_reason,
248                                           bool                blocking);
249   static void wait_for_completion(CompileTask* task);
250 #if INCLUDE_JVMCI
251   static bool wait_for_jvmci_completion(JVMCICompiler* comp, CompileTask* task, JavaThread* thread);
252 #endif
253 
254   static void invoke_compiler_on_method(CompileTask* task);
255   static void post_compile(CompilerThread* thread, CompileTask* task, bool success, ciEnv* ci_env,
256                            int compilable, const char* failure_reason);
<span class="line-modified">257   static void set_last_compile(CompilerThread *thread, const methodHandle&amp; method, bool is_osr, int comp_level);</span>

258   static void push_jni_handle_block();
259   static void pop_jni_handle_block();
260   static void collect_statistics(CompilerThread* thread, elapsedTimer time, CompileTask* task);
261 
262   static void compile_method_base(const methodHandle&amp; method,
263                                   int osr_bci,
264                                   int comp_level,
265                                   const methodHandle&amp; hot_method,
266                                   int hot_count,
267                                   CompileTask::CompileReason compile_reason,
268                                   bool blocking,
269                                   Thread* thread);
270 
271   static CompileQueue* compile_queue(int comp_level);
272   static bool init_compiler_runtime();
273   static void shutdown_compiler_runtime(AbstractCompiler* comp, CompilerThread* thread);
274 
275 public:
276 
277   static DirectivesStack* dirstack();
278   static void set_dirstack(DirectivesStack* stack);
279 
280   enum {
281     // The entry bci used for non-OSR compilations.
282     standard_entry_bci = InvocationEntryBci
283   };
284 
285   static AbstractCompiler* compiler(int comp_level) {
286     if (is_c2_compile(comp_level)) return _compilers[1]; // C2
287     if (is_c1_compile(comp_level)) return _compilers[0]; // C1
288     return NULL;
289   }
290 

291   static bool compilation_is_in_queue(const methodHandle&amp; method);
292   static void print_compile_queues(outputStream* st);
293   static void print_directives(outputStream* st);
294   static int queue_size(int comp_level) {
295     CompileQueue *q = compile_queue(comp_level);
296     return q != NULL ? q-&gt;size() : 0;
297   }
<span class="line-modified">298   static void compilation_init_phase1(TRAPS);</span>
299   static void compilation_init_phase2();
300   static void init_compiler_thread_log();
301   static nmethod* compile_method(const methodHandle&amp; method,
302                                  int osr_bci,
303                                  int comp_level,
304                                  const methodHandle&amp; hot_method,
305                                  int hot_count,
306                                  CompileTask::CompileReason compile_reason,
307                                  Thread* thread);
308 
309   static nmethod* compile_method(const methodHandle&amp; method,
310                                    int osr_bci,
311                                    int comp_level,
312                                    const methodHandle&amp; hot_method,
313                                    int hot_count,
314                                    CompileTask::CompileReason compile_reason,
315                                    DirectiveSet* directive,
316                                    Thread* thread);
317 
318   // Acquire any needed locks and assign a compile id
</pre>
<hr />
<pre>
322   static uint get_compilation_id() { return _compilation_id; }
323 
324   // Set _should_block.
325   // Call this from the VM, with Threads_lock held and a safepoint requested.
326   static void set_should_block();
327 
328   // Call this from the compiler at convenient points, to poll for _should_block.
329   static void maybe_block();
330 
331   enum CompilerActivity {
332     // Flags for toggling compiler activity
333     stop_compilation     = 0,
334     run_compilation      = 1,
335     shutdown_compilation = 2
336   };
337 
338   static jint get_compilation_activity_mode() { return _should_compile_new_jobs; }
339   static bool should_compile_new_jobs() { return UseCompiler &amp;&amp; (_should_compile_new_jobs == run_compilation); }
340   static bool set_should_compile_new_jobs(jint new_state) {
341     // Return success if the current caller set it
<span class="line-modified">342     jint old = Atomic::cmpxchg(new_state, &amp;_should_compile_new_jobs, 1-new_state);</span>
343     bool success = (old == (1-new_state));
344     if (success) {
345       if (new_state == run_compilation) {
346         _total_compiler_restarted_count++;
347       } else {
348         _total_compiler_stopped_count++;
349       }
350     }
351     return success;
352   }
353 
354   static void disable_compilation_forever() {
355     UseCompiler               = false;
356     AlwaysCompileLoopMethods  = false;
<span class="line-modified">357     Atomic::xchg(jint(shutdown_compilation), &amp;_should_compile_new_jobs);</span>
358   }
359 
360   static bool is_compilation_disabled_forever() {
361     return _should_compile_new_jobs == shutdown_compilation;
362   }
363   static void handle_full_code_cache(int code_blob_type);
364   // Ensures that warning is only printed once.
365   static bool should_print_compiler_warning() {
<span class="line-modified">366     jint old = Atomic::cmpxchg(1, &amp;_print_compilation_warning, 0);</span>
367     return old == 0;
368   }
369   // Return total compilation ticks
370   static jlong total_compilation_ticks() {
371     return _perf_total_compilation != NULL ? _perf_total_compilation-&gt;get_value() : 0;
372   }
373 
374   // Redefine Classes support
375   static void mark_on_stack();
376 
377 #if INCLUDE_JVMCI
378   // Print curent compilation time stats for a given compiler
379   static void print_times(AbstractCompiler* comp);
380 #endif
381 
382   // Print a detailed accounting of compilation time
383   static void print_times(bool per_compiler = true, bool aggregate = true);
384 
<span class="line-removed">385   // Debugging output for failure</span>
<span class="line-removed">386   static void print_last_compile();</span>
<span class="line-removed">387 </span>
388   // compiler name for debugging
389   static const char* compiler_name(int comp_level);
390 
391   // Provide access to compiler thread Java objects
392   static jobject compiler1_object(int idx) {
393     assert(_compiler1_objects != NULL, &quot;must be initialized&quot;);
394     assert(idx &lt; _c1_count, &quot;oob&quot;);
395     return _compiler1_objects[idx];
396   }
397 
398   static jobject compiler2_object(int idx) {
399     assert(_compiler2_objects != NULL, &quot;must be initialized&quot;);
400     assert(idx &lt; _c2_count, &quot;oob&quot;);
401     return _compiler2_objects[idx];
402   }
403 


404   static CompileLog* get_log(CompilerThread* ct);
405 
406   static int get_total_compile_count() {            return _total_compile_count; }
407   static int get_total_bailout_count() {            return _total_bailout_count; }
408   static int get_total_invalidated_count() {        return _total_invalidated_count; }
409   static int get_total_native_compile_count() {     return _total_native_compile_count; }
410   static int get_total_osr_compile_count() {        return _total_osr_compile_count; }
411   static int get_total_standard_compile_count() {   return _total_standard_compile_count; }
412   static int get_total_compiler_stopped_count() {   return _total_compiler_stopped_count; }
413   static int get_total_compiler_restarted_count() { return _total_compiler_restarted_count; }
414   static int get_sum_osr_bytes_compiled() {         return _sum_osr_bytes_compiled; }
415   static int get_sum_standard_bytes_compiled() {    return _sum_standard_bytes_compiled; }
416   static int get_sum_nmethod_size() {               return _sum_nmethod_size;}
417   static int get_sum_nmethod_code_size() {          return _sum_nmethod_code_size; }
418   static long get_peak_compilation_time() {         return _peak_compilation_time; }
419   static long get_total_compilation_time() {        return _t_total_compilation.milliseconds(); }
420 
421   // Log that compilation profiling is skipped because metaspace is full.
422   static void log_metaspace_failure();
423 
424   // CodeHeap State Analytics.
425   static void print_info(outputStream *out);
<span class="line-modified">426   static void print_heapinfo(outputStream *out, const char* function, const char* granularity );</span>
427 };
428 
429 #endif // SHARE_COMPILER_COMPILEBROKER_HPP
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_COMPILER_COMPILEBROKER_HPP
 26 #define SHARE_COMPILER_COMPILEBROKER_HPP
 27 
 28 #include &quot;ci/compilerInterface.hpp&quot;
 29 #include &quot;compiler/abstractCompiler.hpp&quot;
 30 #include &quot;compiler/compileTask.hpp&quot;
 31 #include &quot;compiler/compilerDirectives.hpp&quot;
<span class="line-added"> 32 #include &quot;runtime/atomic.hpp&quot;</span>
 33 #include &quot;runtime/perfData.hpp&quot;
 34 #include &quot;utilities/stack.hpp&quot;
 35 #if INCLUDE_JVMCI
 36 #include &quot;jvmci/jvmciCompiler.hpp&quot;
 37 #endif
 38 
 39 class nmethod;
 40 class nmethodLocker;
 41 
 42 // CompilerCounters
 43 //
 44 // Per Compiler Performance Counters.
 45 //
 46 class CompilerCounters : public CHeapObj&lt;mtCompiler&gt; {
 47 
 48   public:
 49     enum {
 50       cmname_buffer_length = 160
 51     };
 52 
</pre>
<hr />
<pre>
157 
158   // This flag can be used to stop compilation or turn it back on
159   static volatile jint _should_compile_new_jobs;
160 
161   // The installed compiler(s)
162   static AbstractCompiler* _compilers[2];
163 
164   // The maximum numbers of compiler threads to be determined during startup.
165   static int _c1_count, _c2_count;
166 
167   // An array of compiler thread Java objects
168   static jobject *_compiler1_objects, *_compiler2_objects;
169 
170   // An array of compiler logs
171   static CompileLog **_compiler1_logs, **_compiler2_logs;
172 
173   // These counters are used for assigning id&#39;s to each compilation
174   static volatile jint _compilation_id;
175   static volatile jint _osr_compilation_id;
176 




177   static CompileQueue* _c2_compile_queue;
178   static CompileQueue* _c1_compile_queue;
179 
180   // performance counters
181   static PerfCounter* _perf_total_compilation;
182   static PerfCounter* _perf_native_compilation;
183   static PerfCounter* _perf_osr_compilation;
184   static PerfCounter* _perf_standard_compilation;
185 
186   static PerfCounter* _perf_total_bailout_count;
187   static PerfCounter* _perf_total_invalidated_count;
188   static PerfCounter* _perf_total_compile_count;
189   static PerfCounter* _perf_total_native_compile_count;
190   static PerfCounter* _perf_total_osr_compile_count;
191   static PerfCounter* _perf_total_standard_compile_count;
192 
193   static PerfCounter* _perf_sum_osr_bytes_compiled;
194   static PerfCounter* _perf_sum_standard_bytes_compiled;
195   static PerfCounter* _perf_sum_nmethod_size;
196   static PerfCounter* _perf_sum_nmethod_code_size;
</pre>
<hr />
<pre>
210   static elapsedTimer _t_invalidated_compilation;
211   static elapsedTimer _t_bailedout_compilation;
212 
213   static int _total_compile_count;
214   static int _total_bailout_count;
215   static int _total_invalidated_count;
216   static int _total_native_compile_count;
217   static int _total_osr_compile_count;
218   static int _total_standard_compile_count;
219   static int _total_compiler_stopped_count;
220   static int _total_compiler_restarted_count;
221   static int _sum_osr_bytes_compiled;
222   static int _sum_standard_bytes_compiled;
223   static int _sum_nmethod_size;
224   static int _sum_nmethod_code_size;
225   static long _peak_compilation_time;
226 
227   static volatile int _print_compilation_warning;
228 
229   static Handle create_thread_oop(const char* name, TRAPS);
<span class="line-modified">230   static JavaThread* make_thread(jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD);</span>
231   static void init_compiler_sweeper_threads();
<span class="line-modified">232   static void possibly_add_compiler_threads(Thread* THREAD);</span>

233   static bool compilation_is_prohibited(const methodHandle&amp; method, int osr_bci, int comp_level, bool excluded);

234 
235   static CompileTask* create_compile_task(CompileQueue*       queue,
236                                           int                 compile_id,
237                                           const methodHandle&amp; method,
238                                           int                 osr_bci,
239                                           int                 comp_level,
240                                           const methodHandle&amp; hot_method,
241                                           int                 hot_count,
242                                           CompileTask::CompileReason compile_reason,
243                                           bool                blocking);
244   static void wait_for_completion(CompileTask* task);
245 #if INCLUDE_JVMCI
246   static bool wait_for_jvmci_completion(JVMCICompiler* comp, CompileTask* task, JavaThread* thread);
247 #endif
248 
249   static void invoke_compiler_on_method(CompileTask* task);
250   static void post_compile(CompilerThread* thread, CompileTask* task, bool success, ciEnv* ci_env,
251                            int compilable, const char* failure_reason);
<span class="line-modified">252   static void update_compile_perf_data(CompilerThread *thread, const methodHandle&amp; method, bool is_osr);</span>
<span class="line-added">253 </span>
254   static void push_jni_handle_block();
255   static void pop_jni_handle_block();
256   static void collect_statistics(CompilerThread* thread, elapsedTimer time, CompileTask* task);
257 
258   static void compile_method_base(const methodHandle&amp; method,
259                                   int osr_bci,
260                                   int comp_level,
261                                   const methodHandle&amp; hot_method,
262                                   int hot_count,
263                                   CompileTask::CompileReason compile_reason,
264                                   bool blocking,
265                                   Thread* thread);
266 
267   static CompileQueue* compile_queue(int comp_level);
268   static bool init_compiler_runtime();
269   static void shutdown_compiler_runtime(AbstractCompiler* comp, CompilerThread* thread);
270 
271 public:
272 
273   static DirectivesStack* dirstack();
274   static void set_dirstack(DirectivesStack* stack);
275 
276   enum {
277     // The entry bci used for non-OSR compilations.
278     standard_entry_bci = InvocationEntryBci
279   };
280 
281   static AbstractCompiler* compiler(int comp_level) {
282     if (is_c2_compile(comp_level)) return _compilers[1]; // C2
283     if (is_c1_compile(comp_level)) return _compilers[0]; // C1
284     return NULL;
285   }
286 
<span class="line-added">287   static bool compilation_is_complete(const methodHandle&amp; method, int osr_bci, int comp_level);</span>
288   static bool compilation_is_in_queue(const methodHandle&amp; method);
289   static void print_compile_queues(outputStream* st);
290   static void print_directives(outputStream* st);
291   static int queue_size(int comp_level) {
292     CompileQueue *q = compile_queue(comp_level);
293     return q != NULL ? q-&gt;size() : 0;
294   }
<span class="line-modified">295   static void compilation_init_phase1(Thread* THREAD);</span>
296   static void compilation_init_phase2();
297   static void init_compiler_thread_log();
298   static nmethod* compile_method(const methodHandle&amp; method,
299                                  int osr_bci,
300                                  int comp_level,
301                                  const methodHandle&amp; hot_method,
302                                  int hot_count,
303                                  CompileTask::CompileReason compile_reason,
304                                  Thread* thread);
305 
306   static nmethod* compile_method(const methodHandle&amp; method,
307                                    int osr_bci,
308                                    int comp_level,
309                                    const methodHandle&amp; hot_method,
310                                    int hot_count,
311                                    CompileTask::CompileReason compile_reason,
312                                    DirectiveSet* directive,
313                                    Thread* thread);
314 
315   // Acquire any needed locks and assign a compile id
</pre>
<hr />
<pre>
319   static uint get_compilation_id() { return _compilation_id; }
320 
321   // Set _should_block.
322   // Call this from the VM, with Threads_lock held and a safepoint requested.
323   static void set_should_block();
324 
325   // Call this from the compiler at convenient points, to poll for _should_block.
326   static void maybe_block();
327 
328   enum CompilerActivity {
329     // Flags for toggling compiler activity
330     stop_compilation     = 0,
331     run_compilation      = 1,
332     shutdown_compilation = 2
333   };
334 
335   static jint get_compilation_activity_mode() { return _should_compile_new_jobs; }
336   static bool should_compile_new_jobs() { return UseCompiler &amp;&amp; (_should_compile_new_jobs == run_compilation); }
337   static bool set_should_compile_new_jobs(jint new_state) {
338     // Return success if the current caller set it
<span class="line-modified">339     jint old = Atomic::cmpxchg(&amp;_should_compile_new_jobs, 1-new_state, new_state);</span>
340     bool success = (old == (1-new_state));
341     if (success) {
342       if (new_state == run_compilation) {
343         _total_compiler_restarted_count++;
344       } else {
345         _total_compiler_stopped_count++;
346       }
347     }
348     return success;
349   }
350 
351   static void disable_compilation_forever() {
352     UseCompiler               = false;
353     AlwaysCompileLoopMethods  = false;
<span class="line-modified">354     Atomic::xchg(&amp;_should_compile_new_jobs, jint(shutdown_compilation));</span>
355   }
356 
357   static bool is_compilation_disabled_forever() {
358     return _should_compile_new_jobs == shutdown_compilation;
359   }
360   static void handle_full_code_cache(int code_blob_type);
361   // Ensures that warning is only printed once.
362   static bool should_print_compiler_warning() {
<span class="line-modified">363     jint old = Atomic::cmpxchg(&amp;_print_compilation_warning, 0, 1);</span>
364     return old == 0;
365   }
366   // Return total compilation ticks
367   static jlong total_compilation_ticks() {
368     return _perf_total_compilation != NULL ? _perf_total_compilation-&gt;get_value() : 0;
369   }
370 
371   // Redefine Classes support
372   static void mark_on_stack();
373 
374 #if INCLUDE_JVMCI
375   // Print curent compilation time stats for a given compiler
376   static void print_times(AbstractCompiler* comp);
377 #endif
378 
379   // Print a detailed accounting of compilation time
380   static void print_times(bool per_compiler = true, bool aggregate = true);
381 



382   // compiler name for debugging
383   static const char* compiler_name(int comp_level);
384 
385   // Provide access to compiler thread Java objects
386   static jobject compiler1_object(int idx) {
387     assert(_compiler1_objects != NULL, &quot;must be initialized&quot;);
388     assert(idx &lt; _c1_count, &quot;oob&quot;);
389     return _compiler1_objects[idx];
390   }
391 
392   static jobject compiler2_object(int idx) {
393     assert(_compiler2_objects != NULL, &quot;must be initialized&quot;);
394     assert(idx &lt; _c2_count, &quot;oob&quot;);
395     return _compiler2_objects[idx];
396   }
397 
<span class="line-added">398   static bool can_remove(CompilerThread *ct, bool do_it);</span>
<span class="line-added">399 </span>
400   static CompileLog* get_log(CompilerThread* ct);
401 
402   static int get_total_compile_count() {            return _total_compile_count; }
403   static int get_total_bailout_count() {            return _total_bailout_count; }
404   static int get_total_invalidated_count() {        return _total_invalidated_count; }
405   static int get_total_native_compile_count() {     return _total_native_compile_count; }
406   static int get_total_osr_compile_count() {        return _total_osr_compile_count; }
407   static int get_total_standard_compile_count() {   return _total_standard_compile_count; }
408   static int get_total_compiler_stopped_count() {   return _total_compiler_stopped_count; }
409   static int get_total_compiler_restarted_count() { return _total_compiler_restarted_count; }
410   static int get_sum_osr_bytes_compiled() {         return _sum_osr_bytes_compiled; }
411   static int get_sum_standard_bytes_compiled() {    return _sum_standard_bytes_compiled; }
412   static int get_sum_nmethod_size() {               return _sum_nmethod_size;}
413   static int get_sum_nmethod_code_size() {          return _sum_nmethod_code_size; }
414   static long get_peak_compilation_time() {         return _peak_compilation_time; }
415   static long get_total_compilation_time() {        return _t_total_compilation.milliseconds(); }
416 
417   // Log that compilation profiling is skipped because metaspace is full.
418   static void log_metaspace_failure();
419 
420   // CodeHeap State Analytics.
421   static void print_info(outputStream *out);
<span class="line-modified">422   static void print_heapinfo(outputStream *out, const char* function, size_t granularity);</span>
423 };
424 
425 #endif // SHARE_COMPILER_COMPILEBROKER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="compileBroker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileTask.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
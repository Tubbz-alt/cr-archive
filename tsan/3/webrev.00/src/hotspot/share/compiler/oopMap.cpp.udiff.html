<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/compiler/oopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodMatcher.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/oopMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,46 +30,45 @@</span>
  #include &quot;compiler/oopMap.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/lockFreeStack.hpp&quot;</span>
  #ifdef COMPILER1
  #include &quot;c1/c1_Defs.hpp&quot;
  #endif
  #ifdef COMPILER2
  #include &quot;opto/optoreg.hpp&quot;
  #endif
  
  // OopMapStream
  
<span class="udiff-line-modified-removed">- OopMapStream::OopMapStream(OopMap* oop_map, int oop_types_mask) {</span>
<span class="udiff-line-modified-added">+ OopMapStream::OopMapStream(OopMap* oop_map) {</span>
    _stream = new CompressedReadStream(oop_map-&gt;write_stream()-&gt;buffer());
<span class="udiff-line-removed">-   _mask = oop_types_mask;</span>
    _size = oop_map-&gt;omv_count();
    _position = 0;
    _valid_omv = false;
  }
  
<span class="udiff-line-modified-removed">- OopMapStream::OopMapStream(const ImmutableOopMap* oop_map, int oop_types_mask) {</span>
<span class="udiff-line-modified-added">+ OopMapStream::OopMapStream(const ImmutableOopMap* oop_map) {</span>
    _stream = new CompressedReadStream(oop_map-&gt;data_addr());
<span class="udiff-line-removed">-   _mask = oop_types_mask;</span>
    _size = oop_map-&gt;count();
    _position = 0;
    _valid_omv = false;
  }
  
  void OopMapStream::find_next() {
<span class="udiff-line-modified-removed">-   while(_position++ &lt; _size) {</span>
<span class="udiff-line-modified-added">+   if (_position++ &lt; _size) {</span>
      _omv.read_from(_stream);
<span class="udiff-line-modified-removed">-     if(((int)_omv.type() &amp; _mask) &gt; 0) {</span>
<span class="udiff-line-modified-removed">-       _valid_omv = true;</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     _valid_omv = true;</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
    _valid_omv = false;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,35 +134,21 @@</span>
  
    assert(reg-&gt;value() &lt; _locs_length, &quot;too big reg value for stack size&quot;);
    assert( _locs_used[reg-&gt;value()] == OopMapValue::unused_value, &quot;cannot insert twice&quot; );
    debug_only( _locs_used[reg-&gt;value()] = x; )
  
<span class="udiff-line-modified-removed">-   OopMapValue o(reg, x);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if(x == OopMapValue::callee_saved_value) {</span>
<span class="udiff-line-removed">-     // This can never be a stack location, so we don&#39;t need to transform it.</span>
<span class="udiff-line-removed">-     assert(optional-&gt;is_reg(), &quot;Trying to callee save a stack location&quot;);</span>
<span class="udiff-line-removed">-     o.set_content_reg(optional);</span>
<span class="udiff-line-removed">-   } else if(x == OopMapValue::derived_oop_value) {</span>
<span class="udiff-line-removed">-     o.set_content_reg(optional);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   OopMapValue o(reg, x, optional);</span>
    o.write_on(write_stream());
    increment_count();
  }
  
  
  void OopMap::set_oop(VMReg reg) {
    set_xxx(reg, OopMapValue::oop_value, VMRegImpl::Bad());
  }
  
  
<span class="udiff-line-removed">- void OopMap::set_value(VMReg reg) {</span>
<span class="udiff-line-removed">-   // At this time, we don&#39;t need value entries in our OopMap.</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void OopMap::set_narrowoop(VMReg reg) {
    set_xxx(reg, OopMapValue::narrowoop_value, VMRegImpl::Bad());
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -321,80 +306,70 @@</span>
    const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(fr-&gt;pc());
    assert(map != NULL, &quot;no ptr map found&quot;);
  
    // handle derived pointers first (otherwise base pointer may be
    // changed before derived pointer offset has been collected)
<span class="udiff-line-removed">-   OopMapValue omv;</span>
    {
<span class="udiff-line-modified-removed">-     OopMapStream oms(map,OopMapValue::derived_oop_value);</span>
<span class="udiff-line-modified-removed">-     if (!oms.is_done()) {</span>
<span class="udiff-line-modified-added">+     for (OopMapStream oms(map); !oms.is_done(); oms.next()) {</span>
<span class="udiff-line-modified-added">+       OopMapValue omv = oms.current();</span>
<span class="udiff-line-added">+       if (omv.type() != OopMapValue::derived_oop_value) {</span>
<span class="udiff-line-added">+         continue;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
  #ifndef TIERED
        COMPILER1_PRESENT(ShouldNotReachHere();)
  #if INCLUDE_JVMCI
        if (UseJVMCICompiler) {
          ShouldNotReachHere();
        }
  #endif
  #endif // !TIERED
<span class="udiff-line-modified-removed">-       // Protect the operation on the derived pointers.  This</span>
<span class="udiff-line-modified-removed">-       // protects the addition of derived pointers to the shared</span>
<span class="udiff-line-modified-removed">-       // derived pointer table in DerivedPointerTable::add().</span>
<span class="udiff-line-modified-removed">-       MutexLockerEx x(DerivedPointerTableGC_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-       do {</span>
<span class="udiff-line-modified-removed">-         omv = oms.current();</span>
<span class="udiff-line-modified-removed">-         oop* loc = fr-&gt;oopmapreg_to_location(omv.reg(),reg_map);</span>
<span class="udiff-line-modified-removed">-         guarantee(loc != NULL, &quot;missing saved register&quot;);</span>
<span class="udiff-line-modified-removed">-         oop *derived_loc = loc;</span>
<span class="udiff-line-modified-removed">-         oop *base_loc    = fr-&gt;oopmapreg_to_location(omv.content_reg(), reg_map);</span>
<span class="udiff-line-modified-removed">-         // Ignore NULL oops and decoded NULL narrow oops which</span>
<span class="udiff-line-modified-removed">-         // equal to Universe::narrow_oop_base when a narrow oop</span>
<span class="udiff-line-removed">-         // implicit null check is used in compiled code.</span>
<span class="udiff-line-removed">-         // The narrow_oop_base could be NULL or be the address</span>
<span class="udiff-line-removed">-         // of the page below heap depending on compressed oops mode.</span>
<span class="udiff-line-removed">-         if (base_loc != NULL &amp;&amp; *base_loc != NULL &amp;&amp; !Universe::is_narrow_oop_base(*base_loc)) {</span>
<span class="udiff-line-removed">-           derived_oop_fn(base_loc, derived_loc);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         oms.next();</span>
<span class="udiff-line-removed">-       }  while (!oms.is_done());</span>
<span class="udiff-line-modified-added">+       oop* loc = fr-&gt;oopmapreg_to_location(omv.reg(),reg_map);</span>
<span class="udiff-line-modified-added">+       guarantee(loc != NULL, &quot;missing saved register&quot;);</span>
<span class="udiff-line-modified-added">+       oop *derived_loc = loc;</span>
<span class="udiff-line-modified-added">+       oop *base_loc    = fr-&gt;oopmapreg_to_location(omv.content_reg(), reg_map);</span>
<span class="udiff-line-modified-added">+       // Ignore NULL oops and decoded NULL narrow oops which</span>
<span class="udiff-line-modified-added">+       // equal to CompressedOops::base() when a narrow oop</span>
<span class="udiff-line-modified-added">+       // implicit null check is used in compiled code.</span>
<span class="udiff-line-modified-added">+       // The narrow_oop_base could be NULL or be the address</span>
<span class="udiff-line-modified-added">+       // of the page below heap depending on compressed oops mode.</span>
<span class="udiff-line-modified-added">+       if (base_loc != NULL &amp;&amp; *base_loc != NULL &amp;&amp; !CompressedOops::is_base(*base_loc)) {</span>
<span class="udiff-line-modified-added">+         derived_oop_fn(base_loc, derived_loc);</span>
<span class="udiff-line-modified-added">+       }</span>
      }
    }
  
<span class="udiff-line-removed">-   // We want coop and oop oop_types</span>
<span class="udiff-line-removed">-   int mask = OopMapValue::oop_value | OopMapValue::narrowoop_value;</span>
    {
<span class="udiff-line-modified-removed">-     for (OopMapStream oms(map,mask); !oms.is_done(); oms.next()) {</span>
<span class="udiff-line-modified-removed">-       omv = oms.current();</span>
<span class="udiff-line-modified-added">+     // We want coop and oop oop_types</span>
<span class="udiff-line-modified-added">+     for (OopMapStream oms(map); !oms.is_done(); oms.next()) {</span>
<span class="udiff-line-added">+       OopMapValue omv = oms.current();</span>
        oop* loc = fr-&gt;oopmapreg_to_location(omv.reg(),reg_map);
        // It should be an error if no location can be found for a
        // register mentioned as contained an oop of some kind.  Maybe
        // this was allowed previously because value_value items might
        // be missing?
        guarantee(loc != NULL, &quot;missing saved register&quot;);
        if ( omv.type() == OopMapValue::oop_value ) {
          oop val = *loc;
<span class="udiff-line-modified-removed">-         if (val == NULL || Universe::is_narrow_oop_base(val)) {</span>
<span class="udiff-line-modified-added">+         if (val == NULL || CompressedOops::is_base(val)) {</span>
            // Ignore NULL oops and decoded NULL narrow oops which
<span class="udiff-line-modified-removed">-           // equal to Universe::narrow_oop_base when a narrow oop</span>
<span class="udiff-line-modified-added">+           // equal to CompressedOops::base() when a narrow oop</span>
            // implicit null check is used in compiled code.
            // The narrow_oop_base could be NULL or be the address
            // of the page below heap depending on compressed oops mode.
            continue;
          }
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-         // We can not verify the oop here if we are using ZGC, the oop</span>
<span class="udiff-line-modified-removed">-         // will be bad in case we had a safepoint between a load and a</span>
<span class="udiff-line-removed">-         // load barrier.</span>
<span class="udiff-line-removed">-         if (!UseZGC &amp;&amp;</span>
<span class="udiff-line-removed">-             ((((uintptr_t)loc &amp; (sizeof(*loc)-1)) != 0) ||</span>
<span class="udiff-line-removed">-              !Universe::heap()-&gt;is_in_or_null(*loc))) {</span>
<span class="udiff-line-modified-added">+         if ((((uintptr_t)loc &amp; (sizeof(*loc)-1)) != 0) ||</span>
<span class="udiff-line-modified-added">+             !Universe::heap()-&gt;is_in_or_null(*loc)) {</span>
            tty-&gt;print_cr(&quot;# Found non oop pointer.  Dumping state at failure&quot;);
            // try to dump out some helpful debugging information
            trace_codeblob_maps(fr, reg_map);
            omv.print();
            tty-&gt;print_cr(&quot;register r&quot;);
            omv.reg()-&gt;print();
<span class="udiff-line-modified-removed">-           tty-&gt;print_cr(&quot;loc = %p *loc = %p\n&quot;, loc, (address)*loc);</span>
<span class="udiff-line-modified-added">+           tty-&gt;print_cr(&quot;loc = %p *loc = %p\n&quot;, loc, cast_from_oop&lt;address&gt;(*loc));</span>
            // do the real assert.
            assert(Universe::heap()-&gt;is_in_or_null(*loc), &quot;found non oop pointer&quot;);
          }
  #endif // ASSERT
          oop_fn-&gt;do_oop(loc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -439,45 +414,28 @@</span>
    address pc = fr-&gt;pc();
    const ImmutableOopMap* map  = cb-&gt;oop_map_for_return_address(pc);
    assert(map != NULL, &quot;no ptr map found&quot;);
    DEBUG_ONLY(int nof_callee = 0;)
  
<span class="udiff-line-modified-removed">-   for (OopMapStream oms(map, OopMapValue::callee_saved_value); !oms.is_done(); oms.next()) {</span>
<span class="udiff-line-modified-added">+   for (OopMapStream oms(map); !oms.is_done(); oms.next()) {</span>
      OopMapValue omv = oms.current();
<span class="udiff-line-modified-removed">-     VMReg reg = omv.content_reg();</span>
<span class="udiff-line-modified-removed">-     oop* loc = fr-&gt;oopmapreg_to_location(omv.reg(), reg_map);</span>
<span class="udiff-line-modified-removed">-     reg_map-&gt;set_location(reg, (address) loc);</span>
<span class="udiff-line-modified-removed">-     DEBUG_ONLY(nof_callee++;)</span>
<span class="udiff-line-modified-added">+     if (omv.type() == OopMapValue::callee_saved_value) {</span>
<span class="udiff-line-modified-added">+       VMReg reg = omv.content_reg();</span>
<span class="udiff-line-modified-added">+       oop* loc = fr-&gt;oopmapreg_to_location(omv.reg(), reg_map);</span>
<span class="udiff-line-modified-added">+       reg_map-&gt;set_location(reg, (address) loc);</span>
<span class="udiff-line-added">+       DEBUG_ONLY(nof_callee++;)</span>
<span class="udiff-line-added">+     }</span>
    }
  
    // Check that runtime stubs save all callee-saved registers
  #ifdef COMPILER2
    assert(cb-&gt;is_compiled_by_c1() || cb-&gt;is_compiled_by_jvmci() || !cb-&gt;is_runtime_stub() ||
           (nof_callee &gt;= SAVED_ON_ENTRY_REG_COUNT || nof_callee &gt;= C_SAVED_ON_ENTRY_REG_COUNT),
           &quot;must save all&quot;);
  #endif // COMPILER2
  }
  
<span class="udiff-line-removed">- //=============================================================================</span>
<span class="udiff-line-removed">- // Non-Product code</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ImmutableOopMap::has_derived_pointer() const {</span>
<span class="udiff-line-removed">- #if !defined(TIERED) &amp;&amp; !INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-   COMPILER1_PRESENT(return false);</span>
<span class="udiff-line-removed">- #endif // !TIERED</span>
<span class="udiff-line-removed">- #if COMPILER2_OR_JVMCI</span>
<span class="udiff-line-removed">-   OopMapStream oms(this,OopMapValue::derived_oop_value);</span>
<span class="udiff-line-removed">-   return oms.is_done();</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- #endif // COMPILER2_OR_JVMCI</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #endif //PRODUCT</span>
<span class="udiff-line-removed">- </span>
  // Printing code is present in product build for -XX:+PrintAssembly.
  
  static
  void print_register_type(OopMapValue::oop_types x, VMReg optional,
                           outputStream* st) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,58 +464,75 @@</span>
    st-&gt;print(&quot;=&quot;);
    print_register_type(type(),content_reg(),st);
    st-&gt;print(&quot; &quot;);
  }
  
<span class="udiff-line-added">+ void OopMapValue::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  void ImmutableOopMap::print_on(outputStream* st) const {
    OopMapValue omv;
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;ImmutableOopMap{&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;ImmutableOopMap {&quot;);</span>
    for(OopMapStream oms(this); !oms.is_done(); oms.next()) {
      omv = oms.current();
      omv.print_on(st);
    }
    st-&gt;print(&quot;}&quot;);
  }
  
<span class="udiff-line-added">+ void ImmutableOopMap::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  void OopMap::print_on(outputStream* st) const {
    OopMapValue omv;
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;OopMap{&quot;);</span>
<span class="udiff-line-modified-added">+   st-&gt;print(&quot;OopMap {&quot;);</span>
    for(OopMapStream oms((OopMap*)this); !oms.is_done(); oms.next()) {
      omv = oms.current();
      omv.print_on(st);
    }
<span class="udiff-line-modified-removed">-   st-&gt;print(&quot;off=%d}&quot;, (int) offset());</span>
<span class="udiff-line-modified-added">+   // Print hex offset in addition.</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;off=%d/0x%x}&quot;, (int) offset(), (int) offset());</span>
  }
  
<span class="udiff-line-added">+ void OopMap::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  void ImmutableOopMapSet::print_on(outputStream* st) const {
    const ImmutableOopMap* last = NULL;
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; _count; ++i) {</span>
<span class="udiff-line-modified-added">+   const int len = count();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;ImmutableOopMapSet contains %d OopMaps&quot;, len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; len; i++) {</span>
      const ImmutableOopMapPair* pair = pair_at(i);
      const ImmutableOopMap* map = pair-&gt;get_from(this);
      if (map != last) {
        st-&gt;cr();
        map-&gt;print_on(st);
<span class="udiff-line-modified-removed">-       st-&gt;print(&quot;pc offsets: &quot;);</span>
<span class="udiff-line-modified-added">+       st-&gt;print(&quot; pc offsets: &quot;);</span>
      }
      last = map;
      st-&gt;print(&quot;%d &quot;, pair-&gt;pc_offset());
    }
<span class="udiff-line-added">+   st-&gt;cr();</span>
  }
  
<span class="udiff-line-added">+ void ImmutableOopMapSet::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  void OopMapSet::print_on(outputStream* st) const {
<span class="udiff-line-modified-removed">-   int i, len = om_count();</span>
<span class="udiff-line-modified-added">+   const int len = om_count();</span>
  
<span class="udiff-line-modified-removed">-   st-&gt;print_cr(&quot;OopMapSet contains %d OopMaps\n&quot;,len);</span>
<span class="udiff-line-modified-added">+   st-&gt;print_cr(&quot;OopMapSet contains %d OopMaps&quot;, len);</span>
  
<span class="udiff-line-modified-removed">-   for( i = 0; i &lt; len; i++) {</span>
<span class="udiff-line-modified-added">+   for( int i = 0; i &lt; len; i++) {</span>
      OopMap* m = at(i);
      st-&gt;print_cr(&quot;#%d &quot;,i);
      m-&gt;print_on(st);
      st-&gt;cr();
    }
<span class="udiff-line-added">+   st-&gt;cr();</span>
  }
  
<span class="udiff-line-added">+ void OopMapSet::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  bool OopMap::equals(const OopMap* other) const {
    if (other-&gt;_omv_count != _omv_count) {
      return false;
    }
    if (other-&gt;write_stream()-&gt;position() != write_stream()-&gt;position()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -569,19 +544,21 @@</span>
    return true;
  }
  
  const ImmutableOopMap* ImmutableOopMapSet::find_map_at_offset(int pc_offset) const {
    ImmutableOopMapPair* pairs = get_pairs();
<span class="udiff-line-added">+   ImmutableOopMapPair* last  = NULL;</span>
  
<span class="udiff-line-modified-removed">-   int i;</span>
<span class="udiff-line-removed">-   for (i = 0; i &lt; _count; ++i) {</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; _count; ++i) {</span>
      if (pairs[i].pc_offset() &gt;= pc_offset) {
<span class="udiff-line-added">+       last = &amp;pairs[i];</span>
        break;
      }
    }
<span class="udiff-line-removed">-   ImmutableOopMapPair* last = &amp;pairs[i];</span>
  
<span class="udiff-line-added">+   // Heal Coverity issue: potential index out of bounds access.</span>
<span class="udiff-line-added">+   guarantee(last != NULL, &quot;last may not be null&quot;);</span>
    assert(last-&gt;pc_offset() == pc_offset, &quot;oopmap not found&quot;);
    return last-&gt;get_from(this);
  }
  
  const ImmutableOopMap* ImmutableOopMapPair::get_from(const ImmutableOopMapSet* set) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -716,11 +693,11 @@</span>
  
  ImmutableOopMapSet* ImmutableOopMapBuilder::build() {
    _required = heap_size();
  
    // We need to allocate a chunk big enough to hold the ImmutableOopMapSet and all of its ImmutableOopMaps
<span class="udiff-line-modified-removed">-   address buffer = (address) NEW_C_HEAP_ARRAY(unsigned char, _required, mtCode);</span>
<span class="udiff-line-modified-added">+   address buffer = NEW_C_HEAP_ARRAY(unsigned char, _required, mtCode);</span>
    return generate_into(buffer);
  }
  
  ImmutableOopMapSet* ImmutableOopMapSet::build_from(const OopMapSet* oopmap_set) {
    ResourceMark mark;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -731,97 +708,104 @@</span>
  
  //------------------------------DerivedPointerTable---------------------------
  
  #if COMPILER2_OR_JVMCI
  
<span class="udiff-line-modified-removed">- class DerivedPointerEntry : public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="udiff-line-modified-removed">-  private:</span>
<span class="udiff-line-modified-removed">-   oop*     _location; // Location of derived pointer (also pointing to the base)</span>
<span class="udiff-line-modified-removed">-   intptr_t _offset;   // Offset from base pointer</span>
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   DerivedPointerEntry(oop* location, intptr_t offset) { _location = location; _offset = offset; }</span>
<span class="udiff-line-modified-removed">-   oop* location()    { return _location; }</span>
<span class="udiff-line-modified-removed">-   intptr_t  offset() { return _offset; }</span>
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-added">+ class DerivedPointerTable::Entry : public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="udiff-line-modified-added">+   oop* _location;   // Location of derived pointer, also pointing to base</span>
<span class="udiff-line-modified-added">+   intptr_t _offset; // Offset from base pointer</span>
<span class="udiff-line-modified-added">+   Entry* volatile _next;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   static Entry* volatile* next_ptr(Entry&amp; entry) { return &amp;entry._next; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   Entry(oop* location, intptr_t offset) :</span>
<span class="udiff-line-added">+     _location(location), _offset(offset), _next(NULL) {}</span>
  
<span class="udiff-line-added">+   oop* location() const { return _location; }</span>
<span class="udiff-line-added">+   intptr_t offset() const { return _offset; }</span>
<span class="udiff-line-added">+   Entry* next() const { return _next; }</span>
  
<span class="udiff-line-modified-removed">- GrowableArray&lt;DerivedPointerEntry*&gt;* DerivedPointerTable::_list = NULL;</span>
<span class="udiff-line-modified-added">+   typedef LockFreeStack&lt;Entry, &amp;next_ptr&gt; List;</span>
<span class="udiff-line-added">+   static List* _list;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DerivedPointerTable::Entry::List* DerivedPointerTable::Entry::_list = NULL;</span>
  bool DerivedPointerTable::_active = false;
  
<span class="udiff-line-added">+ bool DerivedPointerTable::is_empty() {</span>
<span class="udiff-line-added">+   return Entry::_list == NULL || Entry::_list-&gt;empty();</span>
<span class="udiff-line-added">+ }</span>
  
  void DerivedPointerTable::clear() {
    // The first time, we create the list.  Otherwise it should be
    // empty.  If not, then we have probably forgotton to call
    // update_pointers after last GC/Scavenge.
    assert (!_active, &quot;should not be active&quot;);
<span class="udiff-line-modified-removed">-   assert(_list == NULL || _list-&gt;length() == 0, &quot;table not empty&quot;);</span>
<span class="udiff-line-modified-removed">-   if (_list == NULL) {</span>
<span class="udiff-line-modified-removed">-     _list = new (ResourceObj::C_HEAP, mtCompiler) GrowableArray&lt;DerivedPointerEntry*&gt;(10, true); // Allocated on C heap</span>
<span class="udiff-line-modified-added">+   assert(is_empty(), &quot;table not empty&quot;);</span>
<span class="udiff-line-modified-added">+   if (Entry::_list == NULL) {</span>
<span class="udiff-line-modified-added">+     void* mem = NEW_C_HEAP_OBJ(Entry::List, mtCompiler);</span>
<span class="udiff-line-added">+     Entry::_list = ::new (mem) Entry::List();</span>
    }
    _active = true;
  }
  
<span class="udiff-line-removed">- </span>
  // Returns value of location as an int
<span class="udiff-line-modified-removed">- intptr_t value_of_loc(oop *pointer) { return cast_from_oop&lt;intptr_t&gt;((*pointer)); }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ inline intptr_t value_of_loc(oop *pointer) {</span>
<span class="udiff-line-modified-added">+   return cast_from_oop&lt;intptr_t&gt;((*pointer));</span>
<span class="udiff-line-added">+ }</span>
  
  void DerivedPointerTable::add(oop *derived_loc, oop *base_loc) {
    assert(Universe::heap()-&gt;is_in_or_null(*base_loc), &quot;not an oop&quot;);
    assert(derived_loc != base_loc, &quot;Base and derived in same location&quot;);
    if (_active) {
      assert(*derived_loc != (void*)base_loc, &quot;location already added&quot;);
<span class="udiff-line-modified-removed">-     assert(_list != NULL, &quot;list must exist&quot;);</span>
<span class="udiff-line-modified-added">+     assert(Entry::_list != NULL, &quot;list must exist&quot;);</span>
      intptr_t offset = value_of_loc(derived_loc) - value_of_loc(base_loc);
      // This assert is invalid because derived pointers can be
      // arbitrarily far away from their base.
      // assert(offset &gt;= -1000000, &quot;wrong derived pointer info&quot;);
  
      if (TraceDerivedPointers) {
        tty-&gt;print_cr(
          &quot;Add derived pointer@&quot; INTPTR_FORMAT
          &quot; - Derived: &quot; INTPTR_FORMAT
          &quot; Base: &quot; INTPTR_FORMAT &quot; (@&quot; INTPTR_FORMAT &quot;) (Offset: &quot; INTX_FORMAT &quot;)&quot;,
<span class="udiff-line-modified-removed">-         p2i(derived_loc), p2i((address)*derived_loc), p2i((address)*base_loc), p2i(base_loc), offset</span>
<span class="udiff-line-modified-added">+         p2i(derived_loc), p2i(*derived_loc), p2i(*base_loc), p2i(base_loc), offset</span>
        );
      }
      // Set derived oop location to point to base.
      *derived_loc = (oop)base_loc;
<span class="udiff-line-modified-removed">-     assert_lock_strong(DerivedPointerTableGC_lock);</span>
<span class="udiff-line-modified-removed">-     DerivedPointerEntry *entry = new DerivedPointerEntry(derived_loc, offset);</span>
<span class="udiff-line-removed">-     _list-&gt;append(entry);</span>
<span class="udiff-line-modified-added">+     Entry* entry = new Entry(derived_loc, offset);</span>
<span class="udiff-line-modified-added">+     Entry::_list-&gt;push(*entry);</span>
    }
  }
  
<span class="udiff-line-removed">- </span>
  void DerivedPointerTable::update_pointers() {
<span class="udiff-line-modified-removed">-   assert(_list != NULL, &quot;list must exist&quot;);</span>
<span class="udiff-line-modified-removed">-   for(int i = 0; i &lt; _list-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     DerivedPointerEntry* entry = _list-&gt;at(i);</span>
<span class="udiff-line-modified-added">+   assert(Entry::_list != NULL, &quot;list must exist&quot;);</span>
<span class="udiff-line-modified-added">+   Entry* entries = Entry::_list-&gt;pop_all();</span>
<span class="udiff-line-modified-added">+   while (entries != NULL) {</span>
<span class="udiff-line-added">+     Entry* entry = entries;</span>
<span class="udiff-line-added">+     entries = entry-&gt;next();</span>
      oop* derived_loc = entry-&gt;location();
      intptr_t offset  = entry-&gt;offset();
      // The derived oop was setup to point to location of base
<span class="udiff-line-modified-removed">-     oop  base        = **(oop**)derived_loc;</span>
<span class="udiff-line-modified-added">+     oop base = **(oop**)derived_loc;</span>
      assert(Universe::heap()-&gt;is_in_or_null(base), &quot;must be an oop&quot;);
  
<span class="udiff-line-modified-removed">-     *derived_loc = (oop)(((address)base) + offset);</span>
<span class="udiff-line-modified-added">+     *derived_loc = (oop)(cast_from_oop&lt;address&gt;(base) + offset);</span>
      assert(value_of_loc(derived_loc) - value_of_loc(&amp;base) == offset, &quot;sanity check&quot;);
  
      if (TraceDerivedPointers) {
        tty-&gt;print_cr(&quot;Updating derived pointer@&quot; INTPTR_FORMAT
                      &quot; - Derived: &quot; INTPTR_FORMAT &quot;  Base: &quot; INTPTR_FORMAT &quot; (Offset: &quot; INTX_FORMAT &quot;)&quot;,
<span class="udiff-line-modified-removed">-           p2i(derived_loc), p2i((address)*derived_loc), p2i((address)base), offset);</span>
<span class="udiff-line-modified-added">+           p2i(derived_loc), p2i(*derived_loc), p2i(base), offset);</span>
      }
  
      // Delete entry
      delete entry;
<span class="udiff-line-removed">-     _list-&gt;at_put(i, NULL);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // Clear list, so it is ready for next traversal (this is an invariant)</span>
<span class="udiff-line-removed">-   if (TraceDerivedPointers &amp;&amp; !_list-&gt;is_empty()) {</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;--------------------------&quot;);</span>
    }
<span class="udiff-line-modified-removed">-   _list-&gt;clear();</span>
<span class="udiff-line-modified-added">+   assert(Entry::_list-&gt;empty(), &quot;invariant&quot;);</span>
    _active = false;
  }
  
  #endif // COMPILER2_OR_JVMCI
</pre>
<center><a href="methodMatcher.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopMap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/compiler/compilerOracle.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
<a name="2" id="anc2"></a>
 27 #include &quot;compiler/compilerOracle.hpp&quot;
 28 #include &quot;compiler/methodMatcher.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/oopFactory.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/klass.hpp&quot;
 33 #include &quot;oops/method.hpp&quot;
 34 #include &quot;oops/symbol.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/jniHandles.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 
 39 enum OptionType {
 40   IntxType,
 41   UintxType,
 42   BoolType,
 43   CcstrType,
 44   DoubleType,
 45   UnknownType
 46 };
 47 
 48 /* Methods to map real type names to OptionType */
 49 template&lt;typename T&gt;
 50 static OptionType get_type_for() {
 51   return UnknownType;
 52 };
 53 
 54 template&lt;&gt; OptionType get_type_for&lt;intx&gt;() {
 55   return IntxType;
 56 }
 57 
 58 template&lt;&gt; OptionType get_type_for&lt;uintx&gt;() {
 59   return UintxType;
 60 }
 61 
 62 template&lt;&gt; OptionType get_type_for&lt;bool&gt;() {
 63   return BoolType;
 64 }
 65 
 66 template&lt;&gt; OptionType get_type_for&lt;ccstr&gt;() {
 67   return CcstrType;
 68 }
 69 
 70 template&lt;&gt; OptionType get_type_for&lt;double&gt;() {
 71   return DoubleType;
 72 }
 73 
 74 // this must parallel the command_names below
 75 enum OracleCommand {
 76   UnknownCommand = -1,
 77   OracleFirstCommand = 0,
 78   BreakCommand = OracleFirstCommand,
 79   PrintCommand,
 80   ExcludeCommand,
 81   InlineCommand,
 82   DontInlineCommand,
 83   CompileOnlyCommand,
 84   LogCommand,
 85   OptionCommand,
 86   QuietCommand,
 87   HelpCommand,
 88   OracleCommandCount
 89 };
 90 
 91 // this must parallel the enum OracleCommand
 92 static const char * command_names[] = {
 93   &quot;break&quot;,
 94   &quot;print&quot;,
 95   &quot;exclude&quot;,
 96   &quot;inline&quot;,
 97   &quot;dontinline&quot;,
 98   &quot;compileonly&quot;,
 99   &quot;log&quot;,
100   &quot;option&quot;,
101   &quot;quiet&quot;,
102   &quot;help&quot;
103 };
104 
105 class MethodMatcher;
106 class TypedMethodOptionMatcher;
107 
108 static BasicMatcher* lists[OracleCommandCount] = { 0, };
109 static TypedMethodOptionMatcher* option_list = NULL;
110 static bool any_set = false;
111 
112 class TypedMethodOptionMatcher : public MethodMatcher {
113  private:
114   TypedMethodOptionMatcher* _next;
115   const char*   _option;
116   OptionType    _type;
117  public:
118 
119   union {
120     bool bool_value;
121     intx intx_value;
122     uintx uintx_value;
123     double double_value;
124     ccstr ccstr_value;
125   } _u;
126 
127   TypedMethodOptionMatcher() : MethodMatcher(),
128     _next(NULL),
129     _type(UnknownType) {
130       _option = NULL;
131       memset(&amp;_u, 0, sizeof(_u));
132   }
133 
134   static TypedMethodOptionMatcher* parse_method_pattern(char*&amp; line, const char*&amp; error_msg);
135   TypedMethodOptionMatcher* match(const methodHandle&amp; method, const char* opt, OptionType type);
136 
137   void init(const char* opt, OptionType type, TypedMethodOptionMatcher* next) {
138     _next = next;
139     _type = type;
140     _option = os::strdup_check_oom(opt);
141   }
142 
143   void set_next(TypedMethodOptionMatcher* next) {_next = next; }
144   TypedMethodOptionMatcher* next() { return _next; }
145   OptionType type() { return _type; }
146   template&lt;typename T&gt; T value();
147   template&lt;typename T&gt; void set_value(T value);
148   void print();
149   void print_all();
150   TypedMethodOptionMatcher* clone();
151   ~TypedMethodOptionMatcher();
152 };
153 
154 // A few templated accessors instead of a full template class.
155 template&lt;&gt; intx TypedMethodOptionMatcher::value&lt;intx&gt;() {
156   return _u.intx_value;
157 }
158 
159 template&lt;&gt; uintx TypedMethodOptionMatcher::value&lt;uintx&gt;() {
160   return _u.uintx_value;
161 }
162 
163 template&lt;&gt; bool TypedMethodOptionMatcher::value&lt;bool&gt;() {
164   return _u.bool_value;
165 }
166 
167 template&lt;&gt; double TypedMethodOptionMatcher::value&lt;double&gt;() {
168   return _u.double_value;
169 }
170 
171 template&lt;&gt; ccstr TypedMethodOptionMatcher::value&lt;ccstr&gt;() {
172   return _u.ccstr_value;
173 }
174 
175 template&lt;&gt; void TypedMethodOptionMatcher::set_value(intx value) {
176   _u.intx_value = value;
177 }
178 
179 template&lt;&gt; void TypedMethodOptionMatcher::set_value(uintx value) {
180   _u.uintx_value = value;
181 }
182 
183 template&lt;&gt; void TypedMethodOptionMatcher::set_value(double value) {
184   _u.double_value = value;
185 }
186 
187 template&lt;&gt; void TypedMethodOptionMatcher::set_value(bool value) {
188   _u.bool_value = value;
189 }
190 
191 template&lt;&gt; void TypedMethodOptionMatcher::set_value(ccstr value) {
192   _u.ccstr_value = (const ccstr)os::strdup_check_oom(value);
193 }
194 
195 void TypedMethodOptionMatcher::print() {
196   ttyLocker ttyl;
197   print_base(tty);
198   switch (_type) {
199   case IntxType:
200     tty-&gt;print_cr(&quot; intx %s = &quot; INTX_FORMAT, _option, value&lt;intx&gt;());
201     break;
202   case UintxType:
203     tty-&gt;print_cr(&quot; uintx %s = &quot; UINTX_FORMAT, _option, value&lt;uintx&gt;());
204     break;
205   case BoolType:
206     tty-&gt;print_cr(&quot; bool %s = %s&quot;, _option, value&lt;bool&gt;() ? &quot;true&quot; : &quot;false&quot;);
207     break;
208   case DoubleType:
209     tty-&gt;print_cr(&quot; double %s = %f&quot;, _option, value&lt;double&gt;());
210     break;
211   case CcstrType:
212     tty-&gt;print_cr(&quot; const char* %s = &#39;%s&#39;&quot;, _option, value&lt;ccstr&gt;());
213     break;
214   default:
215     ShouldNotReachHere();
216   }
217 }
218 
219 void TypedMethodOptionMatcher::print_all() {
220    print();
221    if (_next != NULL) {
222      tty-&gt;print(&quot; &quot;);
223      _next-&gt;print_all();
224    }
225  }
226 
227 TypedMethodOptionMatcher* TypedMethodOptionMatcher::clone() {
228   TypedMethodOptionMatcher* m = new TypedMethodOptionMatcher();
229   m-&gt;_class_mode = _class_mode;
230   m-&gt;_class_name = _class_name;
231   m-&gt;_method_mode = _method_mode;
232   m-&gt;_method_name = _method_name;
233   m-&gt;_signature = _signature;
234   // Need to ref count the symbols
235   if (_class_name != NULL) {
236     _class_name-&gt;increment_refcount();
237   }
238   if (_method_name != NULL) {
239     _method_name-&gt;increment_refcount();
240   }
241   if (_signature != NULL) {
242     _signature-&gt;increment_refcount();
243   }
244   return m;
245 }
246 
247 TypedMethodOptionMatcher::~TypedMethodOptionMatcher() {
248   if (_option != NULL) {
249     os::free((void*)_option);
250   }
251 }
252 
253 TypedMethodOptionMatcher* TypedMethodOptionMatcher::parse_method_pattern(char*&amp; line, const char*&amp; error_msg) {
254   assert(error_msg == NULL, &quot;Dont call here with error_msg already set&quot;);
255   TypedMethodOptionMatcher* tom = new TypedMethodOptionMatcher();
256   MethodMatcher::parse_method_pattern(line, error_msg, tom);
257   if (error_msg != NULL) {
258     delete tom;
259     return NULL;
260   }
261   return tom;
262 }
263 
264 TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle&amp; method, const char* opt, OptionType type) {
265   TypedMethodOptionMatcher* current = this;
266   while (current != NULL) {
267     // Fastest compare first.
268     if (current-&gt;type() == type) {
269       if (strcmp(current-&gt;_option, opt) == 0) {
270         if (current-&gt;matches(method)) {
271           return current;
272         }
273       }
274     }
275     current = current-&gt;next();
276   }
277   return NULL;
278 }
279 
280 template&lt;typename T&gt;
281 static void add_option_string(TypedMethodOptionMatcher* matcher,
282                                         const char* option,
283                                         T value) {
284   assert(matcher != option_list, &quot;No circular lists please&quot;);
285   matcher-&gt;init(option, get_type_for&lt;T&gt;(), option_list);
286   matcher-&gt;set_value&lt;T&gt;(value);
287   option_list = matcher;
288   any_set = true;
289   return;
290 }
291 
292 static bool check_predicate(OracleCommand command, const methodHandle&amp; method) {
293   return ((lists[command] != NULL) &amp;&amp;
294           !method.is_null() &amp;&amp;
295           lists[command]-&gt;match(method));
296 }
297 
298 static void add_predicate(OracleCommand command, BasicMatcher* bm) {
299   assert(command != OptionCommand, &quot;must use add_option_string&quot;);
300   if (command == LogCommand &amp;&amp; !LogCompilation &amp;&amp; lists[LogCommand] == NULL) {
301     tty-&gt;print_cr(&quot;Warning:  +LogCompilation must be enabled in order for individual methods to be logged.&quot;);
302   }
303   bm-&gt;set_next(lists[command]);
304   lists[command] = bm;
305   if ((command != DontInlineCommand) &amp;&amp; (command != InlineCommand)) {
306     any_set = true;
307   }
308   return;
309 }
310 
311 template&lt;typename T&gt;
312 bool CompilerOracle::has_option_value(const methodHandle&amp; method, const char* option, T&amp; value) {
313   if (option_list != NULL) {
314     TypedMethodOptionMatcher* m = option_list-&gt;match(method, option, get_type_for&lt;T&gt;());
315     if (m != NULL) {
316       value = m-&gt;value&lt;T&gt;();
317       return true;
318     }
319   }
320   return false;
321 }
322 
323 bool CompilerOracle::has_any_option() {
324   return any_set;
325 }
326 
327 // Explicit instantiation for all OptionTypes supported.
328 template bool CompilerOracle::has_option_value&lt;intx&gt;(const methodHandle&amp; method, const char* option, intx&amp; value);
329 template bool CompilerOracle::has_option_value&lt;uintx&gt;(const methodHandle&amp; method, const char* option, uintx&amp; value);
330 template bool CompilerOracle::has_option_value&lt;bool&gt;(const methodHandle&amp; method, const char* option, bool&amp; value);
331 template bool CompilerOracle::has_option_value&lt;ccstr&gt;(const methodHandle&amp; method, const char* option, ccstr&amp; value);
332 template bool CompilerOracle::has_option_value&lt;double&gt;(const methodHandle&amp; method, const char* option, double&amp; value);
333 
334 bool CompilerOracle::has_option_string(const methodHandle&amp; method, const char* option) {
335   bool value = false;
336   has_option_value(method, option, value);
337   return value;
338 }
339 
340 bool CompilerOracle::should_exclude(const methodHandle&amp; method) {
341   if (check_predicate(ExcludeCommand, method)) {
342     return true;
343   }
344   if (lists[CompileOnlyCommand] != NULL) {
345     return !lists[CompileOnlyCommand]-&gt;match(method);
346   }
347   return false;
348 }
349 
350 bool CompilerOracle::should_inline(const methodHandle&amp; method) {
351   return (check_predicate(InlineCommand, method));
352 }
353 
354 bool CompilerOracle::should_not_inline(const methodHandle&amp; method) {
355   return check_predicate(DontInlineCommand, method) || check_predicate(ExcludeCommand, method);
356 }
357 
358 bool CompilerOracle::should_print(const methodHandle&amp; method) {
359   return check_predicate(PrintCommand, method);
360 }
361 
362 bool CompilerOracle::should_print_methods() {
363   return lists[PrintCommand] != NULL;
364 }
365 
366 bool CompilerOracle::should_log(const methodHandle&amp; method) {
367   if (!LogCompilation)            return false;
368   if (lists[LogCommand] == NULL)  return true;  // by default, log all
369   return (check_predicate(LogCommand, method));
370 }
371 
372 bool CompilerOracle::should_break_at(const methodHandle&amp; method) {
373   return check_predicate(BreakCommand, method);
374 }
375 
376 static OracleCommand parse_command_name(const char * line, int* bytes_read) {
377   assert(ARRAY_SIZE(command_names) == OracleCommandCount,
378          &quot;command_names size mismatch&quot;);
379 
380   *bytes_read = 0;
381   char command[33];
<a name="3" id="anc3"></a><span class="line-modified">382   int result = sscanf(line, &quot;%32[a-z]%n&quot;, command, bytes_read);</span>
<span class="line-modified">383   for (uint i = 0; i &lt; ARRAY_SIZE(command_names); i++) {</span>
<span class="line-modified">384     if (strcmp(command, command_names[i]) == 0) {</span>
<span class="line-modified">385       return (OracleCommand)i;</span>


386     }
387   }
388   return UnknownCommand;
389 }
390 
391 static void usage() {
392   tty-&gt;cr();
393   tty-&gt;print_cr(&quot;The CompileCommand option enables the user of the JVM to control specific&quot;);
394   tty-&gt;print_cr(&quot;behavior of the dynamic compilers. Many commands require a pattern that defines&quot;);
395   tty-&gt;print_cr(&quot;the set of methods the command shall be applied to. The CompileCommand&quot;);
396   tty-&gt;print_cr(&quot;option provides the following commands:&quot;);
397   tty-&gt;cr();
398   tty-&gt;print_cr(&quot;  break,&lt;pattern&gt;       - debug breakpoint in compiler and in generated code&quot;);
399   tty-&gt;print_cr(&quot;  print,&lt;pattern&gt;       - print assembly&quot;);
400   tty-&gt;print_cr(&quot;  exclude,&lt;pattern&gt;     - don&#39;t compile or inline&quot;);
401   tty-&gt;print_cr(&quot;  inline,&lt;pattern&gt;      - always inline&quot;);
402   tty-&gt;print_cr(&quot;  dontinline,&lt;pattern&gt;  - don&#39;t inline&quot;);
403   tty-&gt;print_cr(&quot;  compileonly,&lt;pattern&gt; - compile only&quot;);
404   tty-&gt;print_cr(&quot;  log,&lt;pattern&gt;         - log compilation&quot;);
405   tty-&gt;print_cr(&quot;  option,&lt;pattern&gt;,&lt;option type&gt;,&lt;option name&gt;,&lt;value&gt;&quot;);
406   tty-&gt;print_cr(&quot;                        - set value of custom option&quot;);
407   tty-&gt;print_cr(&quot;  option,&lt;pattern&gt;,&lt;bool option name&gt;&quot;);
408   tty-&gt;print_cr(&quot;                        - shorthand for setting boolean flag&quot;);
409   tty-&gt;print_cr(&quot;  quiet                 - silence the compile command output&quot;);
410   tty-&gt;print_cr(&quot;  help                  - print this text&quot;);
411   tty-&gt;cr();
412   tty-&gt;print_cr(&quot;The preferred format for the method matching pattern is:&quot;);
413   tty-&gt;print_cr(&quot;  package/Class.method()&quot;);
414   tty-&gt;cr();
415   tty-&gt;print_cr(&quot;For backward compatibility this form is also allowed:&quot;);
416   tty-&gt;print_cr(&quot;  package.Class::method()&quot;);
417   tty-&gt;cr();
418   tty-&gt;print_cr(&quot;The signature can be separated by an optional whitespace or comma:&quot;);
419   tty-&gt;print_cr(&quot;  package/Class.method ()&quot;);
420   tty-&gt;cr();
421   tty-&gt;print_cr(&quot;The class and method identifier can be used together with leading or&quot;);
422   tty-&gt;print_cr(&quot;trailing *&#39;s for a small amount of wildcarding:&quot;);
423   tty-&gt;print_cr(&quot;  *ackage/Clas*.*etho*()&quot;);
424   tty-&gt;cr();
425   tty-&gt;print_cr(&quot;It is possible to use more than one CompileCommand on the command line:&quot;);
426   tty-&gt;print_cr(&quot;  -XX:CompileCommand=exclude,java/*.* -XX:CompileCommand=log,java*.*&quot;);
427   tty-&gt;cr();
428   tty-&gt;print_cr(&quot;The CompileCommands can be loaded from a file with the flag&quot;);
429   tty-&gt;print_cr(&quot;-XX:CompileCommandFile=&lt;file&gt; or be added to the file &#39;.hotspot_compiler&#39;&quot;);
430   tty-&gt;print_cr(&quot;Use the same format in the file as the argument to the CompileCommand flag.&quot;);
431   tty-&gt;print_cr(&quot;Add one command on each line.&quot;);
432   tty-&gt;print_cr(&quot;  exclude java/*.*&quot;);
433   tty-&gt;print_cr(&quot;  option java/*.* ReplayInline&quot;);
434   tty-&gt;cr();
435   tty-&gt;print_cr(&quot;The following commands have conflicting behavior: &#39;exclude&#39;, &#39;inline&#39;, &#39;dontinline&#39;,&quot;);
436   tty-&gt;print_cr(&quot;and &#39;compileonly&#39;. There is no priority of commands. Applying (a subset of) these&quot;);
437   tty-&gt;print_cr(&quot;commands to the same method results in undefined behavior.&quot;);
438   tty-&gt;cr();
439 };
440 
441 // Scan next flag and value in line, return MethodMatcher object on success, NULL on failure.
442 // On failure, error_msg contains description for the first error.
443 // For future extensions: set error_msg on first error.
444 static void scan_flag_and_value(const char* type, const char* line, int&amp; total_bytes_read,
445                                             TypedMethodOptionMatcher* matcher,
446                                             char* errorbuf, const int buf_size) {
447   total_bytes_read = 0;
448   int bytes_read = 0;
449   char flag[256];
450 
451   // Read flag name.
452   if (sscanf(line, &quot;%*[ \t]%255[a-zA-Z0-9]%n&quot;, flag, &amp;bytes_read) == 1) {
453     line += bytes_read;
454     total_bytes_read += bytes_read;
455 
456     // Read value.
457     if (strcmp(type, &quot;intx&quot;) == 0) {
458       intx value;
459       if (sscanf(line, &quot;%*[ \t]&quot; INTX_FORMAT &quot;%n&quot;, &amp;value, &amp;bytes_read) == 1) {
460         total_bytes_read += bytes_read;
461         add_option_string(matcher, flag, value);
462         return;
463       } else {
464         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s &quot;, flag, type);
465       }
466     } else if (strcmp(type, &quot;uintx&quot;) == 0) {
467       uintx value;
468       if (sscanf(line, &quot;%*[ \t]&quot; UINTX_FORMAT &quot;%n&quot;, &amp;value, &amp;bytes_read) == 1) {
469         total_bytes_read += bytes_read;
470         add_option_string(matcher, flag, value);
471         return;
472       } else {
473         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
474       }
475     } else if (strcmp(type, &quot;ccstr&quot;) == 0) {
476       ResourceMark rm;
477       char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);
478       if (sscanf(line, &quot;%*[ \t]%255[_a-zA-Z0-9]%n&quot;, value, &amp;bytes_read) == 1) {
479         total_bytes_read += bytes_read;
480         add_option_string(matcher, flag, (ccstr)value);
481         return;
482       } else {
483         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
484       }
485     } else if (strcmp(type, &quot;ccstrlist&quot;) == 0) {
486       // Accumulates several strings into one. The internal type is ccstr.
487       ResourceMark rm;
488       char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);
489       char* next_value = value;
490       if (sscanf(line, &quot;%*[ \t]%255[_a-zA-Z0-9]%n&quot;, next_value, &amp;bytes_read) == 1) {
491         total_bytes_read += bytes_read;
492         line += bytes_read;
493         next_value += bytes_read;
494         char* end_value = next_value-1;
495         while (sscanf(line, &quot;%*[ \t]%255[_a-zA-Z0-9]%n&quot;, next_value, &amp;bytes_read) == 1) {
496           total_bytes_read += bytes_read;
497           line += bytes_read;
498           *end_value = &#39; &#39;; // override &#39;\0&#39;
499           next_value += bytes_read;
500           end_value = next_value-1;
501         }
502         add_option_string(matcher, flag, (ccstr)value);
503         return;
504       } else {
505         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
506       }
507     } else if (strcmp(type, &quot;bool&quot;) == 0) {
508       char value[256];
509       if (sscanf(line, &quot;%*[ \t]%255[a-zA-Z]%n&quot;, value, &amp;bytes_read) == 1) {
510         if (strcmp(value, &quot;true&quot;) == 0) {
511           total_bytes_read += bytes_read;
512           add_option_string(matcher, flag, true);
513           return;
514         } else if (strcmp(value, &quot;false&quot;) == 0) {
515           total_bytes_read += bytes_read;
516           add_option_string(matcher, flag, false);
517           return;
518         } else {
519           jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
520         }
521       } else {
522         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
523       }
524     } else if (strcmp(type, &quot;double&quot;) == 0) {
525       char buffer[2][256];
526       // Decimal separator &#39;.&#39; has been replaced with &#39; &#39; or &#39;/&#39; earlier,
527       // so read integer and fraction part of double value separately.
528       if (sscanf(line, &quot;%*[ \t]%255[0-9]%*[ /\t]%255[0-9]%n&quot;, buffer[0], buffer[1], &amp;bytes_read) == 2) {
529         char value[512] = &quot;&quot;;
530         jio_snprintf(value, sizeof(value), &quot;%s.%s&quot;, buffer[0], buffer[1]);
531         total_bytes_read += bytes_read;
532         add_option_string(matcher, flag, atof(value));
533         return;
534       } else {
535         jio_snprintf(errorbuf, buf_size, &quot;  Value cannot be read for flag %s of type %s&quot;, flag, type);
536       }
537     } else {
538       jio_snprintf(errorbuf, buf_size, &quot;  Type %s not supported &quot;, type);
539     }
540   } else {
541     jio_snprintf(errorbuf, buf_size, &quot;  Flag name for type %s should be alphanumeric &quot;, type);
542   }
543   return;
544 }
545 
546 int skip_whitespace(char* line) {
547   // Skip any leading spaces
548   int whitespace_read = 0;
549   sscanf(line, &quot;%*[ \t]%n&quot;, &amp;whitespace_read);
550   return whitespace_read;
551 }
552 
553 void CompilerOracle::print_parse_error(const char*&amp;  error_msg, char* original_line) {
554   assert(error_msg != NULL, &quot;Must have error_message&quot;);
555 
556   ttyLocker ttyl;
557   tty-&gt;print_cr(&quot;CompileCommand: An error occurred during parsing&quot;);
558   tty-&gt;print_cr(&quot;Line: %s&quot;, original_line);
559   tty-&gt;print_cr(&quot;Error: %s&quot;, error_msg);
560   CompilerOracle::print_tip();
561 }
562 
563 void CompilerOracle::parse_from_line(char* line) {
564   if (line[0] == &#39;\0&#39;) return;
565   if (line[0] == &#39;#&#39;)  return;
566 
567   char* original_line = line;
568   int bytes_read;
569   OracleCommand command = parse_command_name(line, &amp;bytes_read);
570   line += bytes_read;
571   ResourceMark rm;
572 
573   if (command == UnknownCommand) {
574     ttyLocker ttyl;
575     tty-&gt;print_cr(&quot;CompileCommand: unrecognized command&quot;);
576     tty-&gt;print_cr(&quot;  \&quot;%s\&quot;&quot;, original_line);
577     CompilerOracle::print_tip();
578     return;
579   }
580 
581   if (command == QuietCommand) {
582     _quiet = true;
583     return;
584   }
585 
586   if (command == HelpCommand) {
587     usage();
588     return;
589   }
590 
591   const char* error_msg = NULL;
592   if (command == OptionCommand) {
593     // Look for trailing options.
594     //
595     // Two types of trailing options are
596     // supported:
597     //
598     // (1) CompileCommand=option,Klass::method,flag
599     // (2) CompileCommand=option,Klass::method,type,flag,value
600     //
601     // Type (1) is used to enable a boolean flag for a method.
602     //
603     // Type (2) is used to support options with a value. Values can have the
604     // the following types: intx, uintx, bool, ccstr, ccstrlist, and double.
605     //
606     // For future extensions: extend scan_flag_and_value()
607 
608     char option[256]; // stores flag for Type (1) and type of Type (2)
609     line++; // skip the &#39;,&#39;
610     TypedMethodOptionMatcher* archetype = TypedMethodOptionMatcher::parse_method_pattern(line, error_msg);
611     if (archetype == NULL) {
612       assert(error_msg != NULL, &quot;Must have error_message&quot;);
613       print_parse_error(error_msg, original_line);
614       return;
615     }
616 
617     line += skip_whitespace(line);
618 
619     // This is unnecessarily complex. Should retire multi-option lines and skip while loop
620     while (sscanf(line, &quot;%255[a-zA-Z0-9]%n&quot;, option, &amp;bytes_read) == 1) {
621       line += bytes_read;
622 
623       // typed_matcher is used as a blueprint for each option, deleted at the end
624       TypedMethodOptionMatcher* typed_matcher = archetype-&gt;clone();
625       if (strcmp(option, &quot;intx&quot;) == 0
626           || strcmp(option, &quot;uintx&quot;) == 0
627           || strcmp(option, &quot;bool&quot;) == 0
628           || strcmp(option, &quot;ccstr&quot;) == 0
629           || strcmp(option, &quot;ccstrlist&quot;) == 0
630           || strcmp(option, &quot;double&quot;) == 0
631           ) {
632         char errorbuf[1024] = {0};
633         // Type (2) option: parse flag name and value.
634         scan_flag_and_value(option, line, bytes_read, typed_matcher, errorbuf, sizeof(errorbuf));
635         if (*errorbuf != &#39;\0&#39;) {
636           error_msg = errorbuf;
637           print_parse_error(error_msg, original_line);
638           return;
639         }
640         line += bytes_read;
641       } else {
642         // Type (1) option
643         add_option_string(typed_matcher, option, true);
644       }
645       if (typed_matcher != NULL &amp;&amp; !_quiet) {
646         // Print out the last match added
647         assert(error_msg == NULL, &quot;No error here&quot;);
648         ttyLocker ttyl;
649         tty-&gt;print(&quot;CompileCommand: %s &quot;, command_names[command]);
650         typed_matcher-&gt;print();
651       }
652       line += skip_whitespace(line);
653     } // while(
654     delete archetype;
655   } else {  // not an OptionCommand)
656     assert(error_msg == NULL, &quot;Don&#39;t call here with error_msg already set&quot;);
657 
658     BasicMatcher* matcher = BasicMatcher::parse_method_pattern(line, error_msg);
659     if (error_msg != NULL) {
660       assert(matcher == NULL, &quot;consistency&quot;);
661       print_parse_error(error_msg, original_line);
662       return;
663     }
664 
665     add_predicate(command, matcher);
666     if (!_quiet) {
667       ttyLocker ttyl;
668       tty-&gt;print(&quot;CompileCommand: %s &quot;, command_names[command]);
669       matcher-&gt;print(tty);
670       tty-&gt;cr();
671     }
672   }
673 }
674 
675 void CompilerOracle::print_tip() {
676   tty-&gt;cr();
677   tty-&gt;print_cr(&quot;Usage: &#39;-XX:CompileCommand=command,\&quot;package/Class.method()\&quot;&#39;&quot;);
678   tty-&gt;print_cr(&quot;Use:   &#39;-XX:CompileCommand=help&#39; for more information.&quot;);
679   tty-&gt;cr();
680 }
681 
682 static const char* default_cc_file = &quot;.hotspot_compiler&quot;;
683 
684 static const char* cc_file() {
685 #ifdef ASSERT
686   if (CompileCommandFile == NULL)
687     return default_cc_file;
688 #endif
689   return CompileCommandFile;
690 }
691 
692 bool CompilerOracle::has_command_file() {
693   return cc_file() != NULL;
694 }
695 
696 bool CompilerOracle::_quiet = false;
697 
698 void CompilerOracle::parse_from_file() {
699   assert(has_command_file(), &quot;command file must be specified&quot;);
700   FILE* stream = fopen(cc_file(), &quot;rt&quot;);
701   if (stream == NULL) return;
702 
703   char token[1024];
704   int  pos = 0;
705   int  c = getc(stream);
706   while(c != EOF &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
707     if (c == &#39;\n&#39;) {
708       token[pos++] = &#39;\0&#39;;
709       parse_from_line(token);
710       pos = 0;
711     } else {
712       token[pos++] = c;
713     }
714     c = getc(stream);
715   }
716   token[pos++] = &#39;\0&#39;;
717   parse_from_line(token);
718 
719   fclose(stream);
720 }
721 
722 void CompilerOracle::parse_from_string(const char* str, void (*parse_line)(char*)) {
723   char token[1024];
724   int  pos = 0;
725   const char* sp = str;
726   int  c = *sp++;
727   while (c != &#39;\0&#39; &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
728     if (c == &#39;\n&#39;) {
729       token[pos++] = &#39;\0&#39;;
730       parse_line(token);
731       pos = 0;
732     } else {
733       token[pos++] = c;
734     }
735     c = *sp++;
736   }
737   token[pos++] = &#39;\0&#39;;
738   parse_line(token);
739 }
740 
<a name="4" id="anc4"></a><span class="line-removed">741 void CompilerOracle::append_comment_to_file(const char* message) {</span>
<span class="line-removed">742   assert(has_command_file(), &quot;command file must be specified&quot;);</span>
<span class="line-removed">743   fileStream stream(fopen(cc_file(), &quot;at&quot;));</span>
<span class="line-removed">744   stream.print(&quot;# &quot;);</span>
<span class="line-removed">745   for (int index = 0; message[index] != &#39;\0&#39;; index++) {</span>
<span class="line-removed">746     stream.put(message[index]);</span>
<span class="line-removed">747     if (message[index] == &#39;\n&#39;) stream.print(&quot;# &quot;);</span>
<span class="line-removed">748   }</span>
<span class="line-removed">749   stream.cr();</span>
<span class="line-removed">750 }</span>
<span class="line-removed">751 </span>
<span class="line-removed">752 void CompilerOracle::append_exclude_to_file(const methodHandle&amp; method) {</span>
<span class="line-removed">753   assert(has_command_file(), &quot;command file must be specified&quot;);</span>
<span class="line-removed">754   fileStream stream(fopen(cc_file(), &quot;at&quot;));</span>
<span class="line-removed">755   stream.print(&quot;exclude &quot;);</span>
<span class="line-removed">756   method-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">757   stream.print(&quot;.&quot;);</span>
<span class="line-removed">758   method-&gt;name()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">759   method-&gt;signature()-&gt;print_symbol_on(&amp;stream);</span>
<span class="line-removed">760   stream.cr();</span>
<span class="line-removed">761   stream.cr();</span>
<span class="line-removed">762 }</span>
<span class="line-removed">763 </span>
<span class="line-removed">764 </span>
765 void compilerOracle_init() {
766   CompilerOracle::parse_from_string(CompileCommand, CompilerOracle::parse_from_line);
767   CompilerOracle::parse_from_string(CompileOnly, CompilerOracle::parse_compile_only);
768   if (CompilerOracle::has_command_file()) {
769     CompilerOracle::parse_from_file();
770   } else {
771     struct stat buf;
772     if (os::stat(default_cc_file, &amp;buf) == 0) {
773       warning(&quot;%s file is present but has been ignored.  &quot;
774               &quot;Run with -XX:CompileCommandFile=%s to load the file.&quot;,
775               default_cc_file, default_cc_file);
776     }
777   }
778   if (lists[PrintCommand] != NULL) {
779     if (PrintAssembly) {
780       warning(&quot;CompileCommand and/or %s file contains &#39;print&#39; commands, but PrintAssembly is also enabled&quot;, default_cc_file);
781     } else if (FLAG_IS_DEFAULT(DebugNonSafepoints)) {
782       warning(&quot;printing of assembly code is enabled; turning on DebugNonSafepoints to gain additional output&quot;);
783       DebugNonSafepoints = true;
784     }
785   }
786 }
787 
788 
789 void CompilerOracle::parse_compile_only(char * line) {
790   int i;
791   char name[1024];
792   const char* className = NULL;
793   const char* methodName = NULL;
794 
795   bool have_colon = (strstr(line, &quot;::&quot;) != NULL);
796   char method_sep = have_colon ? &#39;:&#39; : &#39;.&#39;;
797 
798   if (Verbose) {
799     tty-&gt;print_cr(&quot;%s&quot;, line);
800   }
801 
802   ResourceMark rm;
803   while (*line != &#39;\0&#39;) {
804     MethodMatcher::Mode c_match = MethodMatcher::Exact;
805     MethodMatcher::Mode m_match = MethodMatcher::Exact;
806 
807     for (i = 0;
808          i &lt; 1024 &amp;&amp; *line != &#39;\0&#39; &amp;&amp; *line != method_sep &amp;&amp; *line != &#39;,&#39; &amp;&amp; !isspace(*line);
809          line++, i++) {
810       name[i] = *line;
811       if (name[i] == &#39;.&#39;)  name[i] = &#39;/&#39;;  // package prefix uses &#39;/&#39;
812     }
813 
814     if (i &gt; 0) {
815       char* newName = NEW_RESOURCE_ARRAY( char, i + 1);
816       if (newName == NULL)
817         return;
818       strncpy(newName, name, i);
819       newName[i] = &#39;\0&#39;;
820 
821       if (className == NULL) {
822         className = newName;
823       } else {
824         methodName = newName;
825       }
826     }
827 
828     if (*line == method_sep) {
829       if (className == NULL) {
830         className = &quot;&quot;;
831         c_match = MethodMatcher::Any;
832       }
833     } else {
834       // got foo or foo/bar
835       if (className == NULL) {
836         ShouldNotReachHere();
837       } else {
838         // missing class name handled as &quot;Any&quot; class match
839         if (className[0] == &#39;\0&#39;) {
840           c_match = MethodMatcher::Any;
841         }
842       }
843     }
844 
845     // each directive is terminated by , or NUL or . followed by NUL
846     if (*line == &#39;,&#39; || *line == &#39;\0&#39; || (line[0] == &#39;.&#39; &amp;&amp; line[1] == &#39;\0&#39;)) {
847       if (methodName == NULL) {
848         methodName = &quot;&quot;;
849         if (*line != method_sep) {
850           m_match = MethodMatcher::Any;
851         }
852       }
853 
854       EXCEPTION_MARK;
<a name="5" id="anc5"></a><span class="line-modified">855       Symbol* c_name = SymbolTable::new_symbol(className, CHECK);</span>
<span class="line-modified">856       Symbol* m_name = SymbolTable::new_symbol(methodName, CHECK);</span>
857       Symbol* signature = NULL;
858 
859       BasicMatcher* bm = new BasicMatcher();
860       bm-&gt;init(c_name, c_match, m_name, m_match, signature);
861       add_predicate(CompileOnlyCommand, bm);
862       if (PrintVMOptions) {
863         tty-&gt;print(&quot;CompileOnly: compileonly &quot;);
864         lists[CompileOnlyCommand]-&gt;print_all(tty);
865       }
866 
867       className = NULL;
868       methodName = NULL;
869     }
870 
871     line = *line == &#39;\0&#39; ? line : line + 1;
872   }
873 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
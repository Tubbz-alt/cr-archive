<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/compiler/compileBroker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractCompiler.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileBroker.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,28 +28,29 @@</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/codeHeapState.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
<span class="udiff-line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compileLog.hpp&quot;
  #include &quot;compiler/compilerOracle.hpp&quot;
  #include &quot;compiler/directivesParser.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/whitebox.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,14 +67,12 @@</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Compiler.hpp&quot;
  #endif
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">- #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/vframe.hpp&quot;</span>
  #endif
  #ifdef COMPILER2
  #include &quot;opto/c2compiler.hpp&quot;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133,15 +132,10 @@</span>
  
  // These counters are used to assign an unique ID to each compilation.
  volatile jint CompileBroker::_compilation_id     = 0;
  volatile jint CompileBroker::_osr_compilation_id = 0;
  
<span class="udiff-line-removed">- // Debugging information</span>
<span class="udiff-line-removed">- int  CompileBroker::_last_compile_type     = no_compile;</span>
<span class="udiff-line-removed">- int  CompileBroker::_last_compile_level    = CompLevel_none;</span>
<span class="udiff-line-removed">- char CompileBroker::_last_method_compiled[CompileBroker::name_buffer_length];</span>
<span class="udiff-line-removed">- </span>
  // Performance counters
  PerfCounter* CompileBroker::_perf_total_compilation = NULL;
  PerfCounter* CompileBroker::_perf_osr_compilation = NULL;
  PerfCounter* CompileBroker::_perf_standard_compilation = NULL;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -191,16 +185,16 @@</span>
  
  
  
  class CompilationLog : public StringEventLog {
   public:
<span class="udiff-line-modified-removed">-   CompilationLog() : StringEventLog(&quot;Compilation events&quot;) {</span>
<span class="udiff-line-modified-added">+   CompilationLog() : StringEventLog(&quot;Compilation events&quot;, &quot;jit&quot;) {</span>
    }
  
    void log_compile(JavaThread* thread, CompileTask* task) {
      StringLogMessage lm;
<span class="udiff-line-modified-removed">-     stringStream sstr = lm.stream();</span>
<span class="udiff-line-modified-added">+     stringStream sstr(lm.buffer(), lm.size());</span>
      // msg.time_stamp().update_to(tty-&gt;time_stamp().ticks());
      task-&gt;print(&amp;sstr, NULL, true, false);
      log(thread, &quot;%s&quot;, (const char*)lm);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,11 +264,11 @@</span>
    task-&gt;set_code_handle(NULL);
    thread-&gt;set_env(NULL);
    if (task-&gt;is_blocking()) {
      bool free_task = false;
      {
<span class="udiff-line-modified-removed">-       MutexLocker notifier(task-&gt;lock(), thread);</span>
<span class="udiff-line-modified-added">+       MutexLocker notifier(thread, task-&gt;lock());</span>
        task-&gt;mark_complete();
  #if INCLUDE_JVMCI
        if (CompileBroker::compiler(task-&gt;comp_level())-&gt;is_jvmci()) {
          if (!task-&gt;has_waiter()) {
            // The waiting thread timed out and thus did not free the task.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -303,11 +297,11 @@</span>
  }
  
  /**
   * Check if a CompilerThread can be removed and update count if requested.
   */
<span class="udiff-line-modified-removed">- static bool can_remove(CompilerThread *ct, bool do_it) {</span>
<span class="udiff-line-modified-added">+ bool CompileBroker::can_remove(CompilerThread *ct, bool do_it) {</span>
    assert(UseDynamicNumberOfCompilerThreads, &quot;or shouldn&#39;t be here&quot;);
    if (!ReduceNumberOfCompilerThreads) return false;
  
    AbstractCompiler *compiler = ct-&gt;compiler();
    int compiler_count = compiler-&gt;num_compiler_threads();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -317,17 +311,36 @@</span>
    if (compiler_count &lt; 2) return false;
  
    // Keep thread alive for at least some time.
    if (ct-&gt;idle_time_millis() &lt; (c1 ? 500 : 100)) return false;
  
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+   if (compiler-&gt;is_jvmci()) {</span>
<span class="udiff-line-added">+     // Handles for JVMCI thread objects may get released concurrently.</span>
<span class="udiff-line-added">+     if (do_it) {</span>
<span class="udiff-line-added">+       assert(CompileThread_lock-&gt;owner() == ct, &quot;must be holding lock&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Skip check if it&#39;s the last thread and let caller check again.</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    // We only allow the last compiler thread of each type to get removed.
<span class="udiff-line-modified-removed">-   jobject last_compiler = c1 ? CompileBroker::compiler1_object(compiler_count - 1)</span>
<span class="udiff-line-modified-removed">-                              : CompileBroker::compiler2_object(compiler_count - 1);</span>
<span class="udiff-line-modified-removed">-   if (oopDesc::equals(ct-&gt;threadObj(), JNIHandles::resolve_non_null(last_compiler))) {</span>
<span class="udiff-line-modified-added">+   jobject last_compiler = c1 ? compiler1_object(compiler_count - 1)</span>
<span class="udiff-line-modified-added">+                              : compiler2_object(compiler_count - 1);</span>
<span class="udiff-line-modified-added">+   if (ct-&gt;threadObj() == JNIHandles::resolve_non_null(last_compiler)) {</span>
      if (do_it) {
        assert_locked_or_safepoint(CompileThread_lock); // Update must be consistent.
        compiler-&gt;set_num_compiler_threads(compiler_count - 1);
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+       if (compiler-&gt;is_jvmci()) {</span>
<span class="udiff-line-added">+         // Old j.l.Thread object can die when no longer referenced elsewhere.</span>
<span class="udiff-line-added">+         JNIHandles::destroy_global(compiler2_object(compiler_count - 1));</span>
<span class="udiff-line-added">+         _compiler2_objects[compiler_count - 1] = NULL;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ #endif</span>
      }
      return true;
    }
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,11 +418,11 @@</span>
    // save methods from RedefineClasses across safepoint
    // across MethodCompileQueue_lock below.
    methodHandle save_method;
    methodHandle save_hot_method;
  
<span class="udiff-line-modified-removed">-   MutexLocker locker(MethodCompileQueue_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker locker(MethodCompileQueue_lock);</span>
    // If _first is NULL we have no more compile jobs. There are two reasons for
    // having no compile jobs: First, we compiled everything we wanted. Second,
    // we ran out of code cache so compilation has been disabled. In the latter
    // case we perform code cache sweeps to free memory such that we can re-enable
    // compilation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -426,15 +439,15 @@</span>
      // the stable state, i.e., we do not want to evict methods from the
      // code cache if it is unnecessary.
      // We need a timed wait here, since compiler threads can exit if compilation
      // is disabled forever. We use 5 seconds wait time; the exiting of compiler threads
      // is not critical and we do not want idle compiler threads to wake up too often.
<span class="udiff-line-modified-removed">-     MethodCompileQueue_lock-&gt;wait(!Mutex::_no_safepoint_check_flag, 5*1000);</span>
<span class="udiff-line-modified-added">+     locker.wait(5*1000);</span>
  
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; _first == NULL) {
        // Still nothing to compile. Give caller a chance to stop this thread.
<span class="udiff-line-modified-removed">-       if (can_remove(CompilerThread::current(), false)) return NULL;</span>
<span class="udiff-line-modified-added">+       if (CompileBroker::can_remove(CompilerThread::current(), false)) return NULL;</span>
      }
    }
  
    if (CompileBroker::is_compilation_disabled_forever()) {
      return NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -450,16 +463,17 @@</span>
    }
  
    if (task != NULL) {
      // Save method pointers across unlock safepoint.  The task is removed from
      // the compilation queue, which is walked during RedefineClasses.
<span class="udiff-line-modified-removed">-     save_method = methodHandle(task-&gt;method());</span>
<span class="udiff-line-modified-removed">-     save_hot_method = methodHandle(task-&gt;hot_method());</span>
<span class="udiff-line-modified-added">+     Thread* thread = Thread::current();</span>
<span class="udiff-line-modified-added">+     save_method = methodHandle(thread, task-&gt;method());</span>
<span class="udiff-line-added">+     save_hot_method = methodHandle(thread, task-&gt;hot_method());</span>
  
      remove(task);
<span class="udiff-line-removed">-     purge_stale_tasks(); // may temporarily release MCQ lock</span>
    }
<span class="udiff-line-added">+   purge_stale_tasks(); // may temporarily release MCQ lock</span>
    return task;
  }
  
  // Clean &amp; deallocate stale compile tasks.
  // Temporarily releases MethodCompileQueue lock.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,12 +575,18 @@</span>
    }
    st-&gt;cr();
  }
  
  void CompileQueue::print_tty() {
<span class="udiff-line-modified-removed">-   ttyLocker ttyl;</span>
<span class="udiff-line-modified-removed">-   print(tty);</span>
<span class="udiff-line-modified-added">+   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   stringStream ss;</span>
<span class="udiff-line-added">+   // Dump the compile queue into a buffer before locking the tty</span>
<span class="udiff-line-added">+   print(&amp;ss);</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     ttyLocker ttyl;</span>
<span class="udiff-line-added">+     tty-&gt;print(&quot;%s&quot;, ss.as_string());</span>
<span class="udiff-line-added">+   }</span>
  }
  
  CompilerCounters::CompilerCounters() {
    _current_method[0] = &#39;\0&#39;;
    _compile_type = CompileBroker::no_compile;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -574,13 +594,11 @@</span>
  
  // ------------------------------------------------------------------
  // CompileBroker::compilation_init
  //
  // Initialize the Compilation object
<span class="udiff-line-modified-removed">- void CompileBroker::compilation_init_phase1(TRAPS) {</span>
<span class="udiff-line-removed">-   _last_method_compiled[0] = &#39;\0&#39;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ void CompileBroker::compilation_init_phase1(Thread* THREAD) {</span>
    // No need to initialize compilation system if we do not use it.
    if (!UseCompiler) {
      return;
    }
    // Set the interface to the current compiler(s).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -627,10 +645,11 @@</span>
    // Start the compiler thread(s) and the sweeper thread
    init_compiler_sweeper_threads();
    // totalTime performance counter is always created as it is required
    // by the implementation of java.lang.management.CompilationMBean.
    {
<span class="udiff-line-added">+     // Ensure OOM leads to vm_exit_during_initialization.</span>
      EXCEPTION_MARK;
      _perf_total_compilation =
                   PerfDataManager::create_counter(JAVA_CI, &quot;totalTime&quot;,
                                                   PerfData::U_Ticks, CHECK);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -741,21 +760,21 @@</span>
                         string,
                         CHECK_NH);
  }
  
  
<span class="udiff-line-modified-removed">- JavaThread* CompileBroker::make_thread(jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   JavaThread* thread = NULL;</span>
<span class="udiff-line-modified-added">+ JavaThread* CompileBroker::make_thread(jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD) {</span>
<span class="udiff-line-modified-added">+   JavaThread* new_thread = NULL;</span>
    {
<span class="udiff-line-modified-removed">-     MutexLocker mu(Threads_lock, THREAD);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(THREAD, Threads_lock);</span>
      if (comp != NULL) {
        if (!InjectCompilerCreationFailure || comp-&gt;num_compiler_threads() == 0) {
          CompilerCounters* counters = new CompilerCounters();
<span class="udiff-line-modified-removed">-         thread = new CompilerThread(queue, counters);</span>
<span class="udiff-line-modified-added">+         new_thread = new CompilerThread(queue, counters);</span>
        }
      } else {
<span class="udiff-line-modified-removed">-       thread = new CodeCacheSweeperThread();</span>
<span class="udiff-line-modified-added">+       new_thread = new CodeCacheSweeperThread();</span>
      }
      // At this point the new CompilerThread data-races with this startup
      // thread (which I believe is the primoridal thread and NOT the VM
      // thread).  This means Java bytecodes being executed at startup can
      // queue compile jobs which will run at whatever default priority the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -766,13 +785,13 @@</span>
      // JavaThread due to lack of memory. We would have to throw an exception
      // in that case. However, since this must work and we do not allow
      // exceptions anyway, check and abort if this fails. But first release the
      // lock.
  
<span class="udiff-line-modified-removed">-     if (thread != NULL &amp;&amp; thread-&gt;osthread() != NULL) {</span>
<span class="udiff-line-modified-added">+     if (new_thread != NULL &amp;&amp; new_thread-&gt;osthread() != NULL) {</span>
  
<span class="udiff-line-modified-removed">-       java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), thread);</span>
<span class="udiff-line-modified-added">+       java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), new_thread);</span>
  
        // Note that this only sets the JavaThread _priority field, which by
        // definition is limited to Java priorities and not OS priorities.
        // The os-priority is set in the CompilerThread startup code itself
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -789,43 +808,44 @@</span>
            native_prio = os::java_to_os_priority[CriticalPriority];
          } else {
            native_prio = os::java_to_os_priority[NearMaxPriority];
          }
        }
<span class="udiff-line-modified-removed">-       os::set_native_priority(thread, native_prio);</span>
<span class="udiff-line-modified-added">+       os::set_native_priority(new_thread, native_prio);</span>
  
        java_lang_Thread::set_daemon(JNIHandles::resolve_non_null(thread_handle));
  
<span class="udiff-line-modified-removed">-       thread-&gt;set_threadObj(JNIHandles::resolve_non_null(thread_handle));</span>
<span class="udiff-line-modified-added">+       new_thread-&gt;set_threadObj(JNIHandles::resolve_non_null(thread_handle));</span>
        if (comp != NULL) {
<span class="udiff-line-modified-removed">-         thread-&gt;as_CompilerThread()-&gt;set_compiler(comp);</span>
<span class="udiff-line-modified-added">+         new_thread-&gt;as_CompilerThread()-&gt;set_compiler(comp);</span>
        }
<span class="udiff-line-modified-removed">-       Threads::add(thread);</span>
<span class="udiff-line-modified-removed">-       Thread::start(thread);</span>
<span class="udiff-line-modified-added">+       Threads::add(new_thread);</span>
<span class="udiff-line-modified-added">+       Thread::start(new_thread);</span>
      }
    }
  
    // First release lock before aborting VM.
<span class="udiff-line-modified-removed">-   if (thread == NULL || thread-&gt;osthread() == NULL) {</span>
<span class="udiff-line-modified-added">+   if (new_thread == NULL || new_thread-&gt;osthread() == NULL) {</span>
      if (UseDynamicNumberOfCompilerThreads &amp;&amp; comp != NULL &amp;&amp; comp-&gt;num_compiler_threads() &gt; 0) {
<span class="udiff-line-modified-removed">-       if (thread != NULL) {</span>
<span class="udiff-line-modified-removed">-         thread-&gt;smr_delete();</span>
<span class="udiff-line-modified-added">+       if (new_thread != NULL) {</span>
<span class="udiff-line-modified-added">+         new_thread-&gt;smr_delete();</span>
        }
        return NULL;
      }
      vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,
                                    os::native_thread_creation_failed_msg());
    }
  
    // Let go of Threads_lock before yielding
    os::naked_yield(); // make sure that the compiler thread is started early (especially helpful on SOLARIS)
  
<span class="udiff-line-modified-removed">-   return thread;</span>
<span class="udiff-line-modified-added">+   return new_thread;</span>
  }
  
  
  void CompileBroker::init_compiler_sweeper_threads() {
<span class="udiff-line-added">+   // Ensure any exceptions lead to vm_exit_during_initialization.</span>
    EXCEPTION_MARK;
  #if !defined(ZERO)
    assert(_c2_count &gt; 0 || _c1_count &gt; 0, &quot;No compilers?&quot;);
  #endif // !ZERO
    // Initialize the compilation queue
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -842,19 +862,24 @@</span>
    }
  
    char name_buffer[256];
  
    for (int i = 0; i &lt; _c2_count; i++) {
<span class="udiff-line-added">+     jobject thread_handle = NULL;</span>
<span class="udiff-line-added">+     // Create all j.l.Thread objects for C1 and C2 threads here, but only one</span>
<span class="udiff-line-added">+     // for JVMCI compiler which can create further ones on demand.</span>
<span class="udiff-line-added">+     JVMCI_ONLY(if (!UseJVMCICompiler || !UseDynamicNumberOfCompilerThreads || i == 0) {)</span>
      // Create a name for our thread.
      sprintf(name_buffer, &quot;%s CompilerThread%d&quot;, _compilers[1]-&gt;name(), i);
      Handle thread_oop = create_thread_oop(name_buffer, CHECK);
<span class="udiff-line-modified-removed">-     jobject thread_handle = JNIHandles::make_global(thread_oop);</span>
<span class="udiff-line-modified-added">+     thread_handle = JNIHandles::make_global(thread_oop);</span>
<span class="udiff-line-added">+     JVMCI_ONLY(})</span>
      _compiler2_objects[i] = thread_handle;
      _compiler2_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="udiff-line-modified-removed">-       JavaThread *ct = make_thread(thread_handle, _c2_compile_queue, _compilers[1], CHECK);</span>
<span class="udiff-line-modified-added">+       JavaThread *ct = make_thread(thread_handle, _c2_compile_queue, _compilers[1], THREAD);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -870,11 +895,11 @@</span>
      jobject thread_handle = JNIHandles::make_global(thread_oop);
      _compiler1_objects[i] = thread_handle;
      _compiler1_logs[i] = NULL;
  
      if (!UseDynamicNumberOfCompilerThreads || i == 0) {
<span class="udiff-line-modified-removed">-       JavaThread *ct = make_thread(thread_handle, _c1_compile_queue, _compilers[0], CHECK);</span>
<span class="udiff-line-modified-added">+       JavaThread *ct = make_thread(thread_handle, _c1_compile_queue, _compilers[0], THREAD);</span>
        assert(ct != NULL, &quot;should have been handled for initial thread&quot;);
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -889,16 +914,15 @@</span>
  
    if (MethodFlushing) {
      // Initialize the sweeper thread
      Handle thread_oop = create_thread_oop(&quot;Sweeper thread&quot;, CHECK);
      jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());
<span class="udiff-line-modified-removed">-     make_thread(thread_handle, NULL, NULL, CHECK);</span>
<span class="udiff-line-modified-added">+     make_thread(thread_handle, NULL, NULL, THREAD);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void CompileBroker::possibly_add_compiler_threads() {</span>
<span class="udiff-line-removed">-   EXCEPTION_MARK;</span>
<span class="udiff-line-modified-added">+ void CompileBroker::possibly_add_compiler_threads(Thread* THREAD) {</span>
  
    julong available_memory = os::available_memory();
    // If SegmentedCodeCache is off, both values refer to the single heap (with type CodeBlobType::All).
    size_t available_cc_np  = CodeCache::unallocated_capacity(CodeBlobType::MethodNonProfiled),
           available_cc_p   = CodeCache::unallocated_capacity(CodeBlobType::MethodProfiled);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -912,11 +936,44 @@</span>
          _c2_compile_queue-&gt;size() / 2,
          (int)(available_memory / (200*M)),
          (int)(available_cc_np / (128*K)));
  
      for (int i = old_c2_count; i &lt; new_c2_count; i++) {
<span class="udiff-line-modified-removed">-       JavaThread *ct = make_thread(compiler2_object(i), _c2_compile_queue, _compilers[1], CHECK);</span>
<span class="udiff-line-modified-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+       if (UseJVMCICompiler) {</span>
<span class="udiff-line-added">+         // Native compiler threads as used in C1/C2 can reuse the j.l.Thread</span>
<span class="udiff-line-added">+         // objects as their existence is completely hidden from the rest of</span>
<span class="udiff-line-added">+         // the VM (and those compiler threads can&#39;t call Java code to do the</span>
<span class="udiff-line-added">+         // creation anyway). For JVMCI we have to create new j.l.Thread objects</span>
<span class="udiff-line-added">+         // as they are visible and we can see unexpected thread lifecycle</span>
<span class="udiff-line-added">+         // transitions if we bind them to new JavaThreads.</span>
<span class="udiff-line-added">+         if (!THREAD-&gt;can_call_java()) break;</span>
<span class="udiff-line-added">+         char name_buffer[256];</span>
<span class="udiff-line-added">+         sprintf(name_buffer, &quot;%s CompilerThread%d&quot;, _compilers[1]-&gt;name(), i);</span>
<span class="udiff-line-added">+         Handle thread_oop;</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           // We have to give up the lock temporarily for the Java calls.</span>
<span class="udiff-line-added">+           MutexUnlocker mu(CompileThread_lock);</span>
<span class="udiff-line-added">+           thread_oop = create_thread_oop(name_buffer, THREAD);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-added">+           if (TraceCompilerThreads) {</span>
<span class="udiff-line-added">+             ResourceMark rm;</span>
<span class="udiff-line-added">+             tty-&gt;print_cr(&quot;JVMCI compiler thread creation failed:&quot;);</span>
<span class="udiff-line-added">+             PENDING_EXCEPTION-&gt;print();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           CLEAR_PENDING_EXCEPTION;</span>
<span class="udiff-line-added">+           break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // Check if another thread has beaten us during the Java calls.</span>
<span class="udiff-line-added">+         if (_compilers[1]-&gt;num_compiler_threads() != i) break;</span>
<span class="udiff-line-added">+         jobject thread_handle = JNIHandles::make_global(thread_oop);</span>
<span class="udiff-line-added">+         assert(compiler2_object(i) == NULL, &quot;Old one must be released!&quot;);</span>
<span class="udiff-line-added">+         _compiler2_objects[i] = thread_handle;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       JavaThread *ct = make_thread(compiler2_object(i), _c2_compile_queue, _compilers[1], THREAD);</span>
        if (ct == NULL) break;
        _compilers[1]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -932,11 +989,11 @@</span>
          _c1_compile_queue-&gt;size() / 4,
          (int)(available_memory / (100*M)),
          (int)(available_cc_p / (128*K)));
  
      for (int i = old_c1_count; i &lt; new_c1_count; i++) {
<span class="udiff-line-modified-removed">-       JavaThread *ct = make_thread(compiler1_object(i), _c1_compile_queue, _compilers[0], CHECK);</span>
<span class="udiff-line-modified-added">+       JavaThread *ct = make_thread(compiler1_object(i), _c1_compile_queue, _compilers[0], THREAD);</span>
        if (ct == NULL) break;
        _compilers[0]-&gt;set_num_compiler_threads(i + 1);
        if (TraceCompilerThreads) {
          ResourceMark rm;
          MutexLocker mu(Threads_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1043,11 +1100,11 @@</span>
    CompileTask* task     = NULL;
    CompileQueue* queue  = compile_queue(comp_level);
  
    // Acquire our lock.
    {
<span class="udiff-line-modified-removed">-     MutexLocker locker(MethodCompileQueue_lock, thread);</span>
<span class="udiff-line-modified-added">+     MutexLocker locker(thread, MethodCompileQueue_lock);</span>
  
      // Make sure the method has not slipped into the queues since
      // last we checked; note that those checks were &quot;fast bail-outs&quot;.
      // Here we need to be more careful, see 14012000 below.
      if (compilation_is_in_queue(method)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1069,40 +1126,40 @@</span>
        // The compilation falls outside the allowed range.
        return;
      }
  
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-     if (UseJVMCICompiler) {</span>
<span class="udiff-line-modified-removed">-       if (blocking) {</span>
<span class="udiff-line-modified-removed">-         // Don&#39;t allow blocking compiles for requests triggered by JVMCI.</span>
<span class="udiff-line-modified-removed">-         if (thread-&gt;is_Compiler_thread()) {</span>
<span class="udiff-line-modified-removed">-           blocking = false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     if (UseJVMCICompiler &amp;&amp; blocking) {</span>
<span class="udiff-line-modified-added">+       // Don&#39;t allow blocking compiles for requests triggered by JVMCI.</span>
<span class="udiff-line-modified-added">+       if (thread-&gt;is_Compiler_thread()) {</span>
<span class="udiff-line-modified-added">+         blocking = false;</span>
<span class="udiff-line-modified-added">+       }</span>
  
<span class="udiff-line-added">+       if (!UseJVMCINativeLibrary) {</span>
          // Don&#39;t allow blocking compiles if inside a class initializer or while performing class loading
          vframeStream vfst((JavaThread*) thread);
          for (; !vfst.at_end(); vfst.next()) {
            if (vfst.method()-&gt;is_static_initializer() ||
                (vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) &amp;&amp;
                    vfst.method()-&gt;name() == vmSymbols::loadClass_name())) {
              blocking = false;
              break;
            }
          }
<span class="udiff-line-added">+       }</span>
  
<span class="udiff-line-modified-removed">-         // Don&#39;t allow blocking compilation requests to JVMCI</span>
<span class="udiff-line-modified-removed">-         // if JVMCI itself is not yet initialized</span>
<span class="udiff-line-modified-removed">-         if (!JVMCIRuntime::is_HotSpotJVMCIRuntime_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {</span>
<span class="udiff-line-modified-removed">-           blocking = false;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+       // Don&#39;t allow blocking compilation requests to JVMCI</span>
<span class="udiff-line-modified-added">+       // if JVMCI itself is not yet initialized</span>
<span class="udiff-line-modified-added">+       if (!JVMCI::is_compiler_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {</span>
<span class="udiff-line-modified-added">+         blocking = false;</span>
<span class="udiff-line-modified-added">+       }</span>
  
<span class="udiff-line-modified-removed">-         // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown</span>
<span class="udiff-line-modified-removed">-         // to avoid deadlock between compiler thread(s) and threads run at shutdown</span>
<span class="udiff-line-modified-removed">-         // such as the DestroyJavaVM thread.</span>
<span class="udiff-line-modified-removed">-         if (JVMCIRuntime::shutdown_called()) {</span>
<span class="udiff-line-modified-removed">-           blocking = false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown</span>
<span class="udiff-line-modified-added">+       // to avoid deadlock between compiler thread(s) and threads run at shutdown</span>
<span class="udiff-line-modified-added">+       // such as the DestroyJavaVM thread.</span>
<span class="udiff-line-modified-added">+       if (JVMCI::shutdown_called()) {</span>
<span class="udiff-line-modified-added">+         blocking = false;</span>
        }
      }
  #endif // INCLUDE_JVMCI
  
      // We will enter the compilation in the queue.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1198,11 +1255,11 @@</span>
        compilation_is_prohibited(method, osr_bci, comp_level, directive-&gt;ExcludeOption)) {
      return NULL;
    }
  
  #if INCLUDE_JVMCI
<span class="udiff-line-modified-removed">-   if (comp-&gt;is_jvmci() &amp;&amp; !JVMCIRuntime::can_initialize_JVMCI()) {</span>
<span class="udiff-line-modified-added">+   if (comp-&gt;is_jvmci() &amp;&amp; !JVMCI::can_initialize_JVMCI()) {</span>
      return NULL;
    }
  #endif
  
    if (osr_bci == InvocationEntryBci) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1248,11 +1305,11 @@</span>
      bool in_base_library;
      address adr = NativeLookup::lookup(method, in_base_library, THREAD);
      if (HAS_PENDING_EXCEPTION) {
        // In case of an exception looking up the method, we just forget
        // about it. The interpreter will kick-in and throw the exception.
<span class="udiff-line-modified-removed">-       method-&gt;set_not_compilable(); // implies is_not_osr_compilable()</span>
<span class="udiff-line-modified-added">+       method-&gt;set_not_compilable(&quot;NativeLookup::lookup failed&quot;); // implies is_not_osr_compilable()</span>
        CLEAR_PENDING_EXCEPTION;
        return NULL;
      }
      assert(method-&gt;has_native_function(), &quot;must have native code by now&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1376,19 +1433,19 @@</span>
    bool is_native = method-&gt;is_native();
    // Some compilers may not support the compilation of natives.
    AbstractCompiler *comp = compiler(comp_level);
    if (is_native &amp;&amp;
        (!CICompileNatives || comp == NULL || !comp-&gt;supports_native())) {
<span class="udiff-line-modified-removed">-     method-&gt;set_not_compilable_quietly(comp_level);</span>
<span class="udiff-line-modified-added">+     method-&gt;set_not_compilable_quietly(&quot;native methods not supported&quot;, comp_level);</span>
      return true;
    }
  
    bool is_osr = (osr_bci != standard_entry_bci);
    // Some compilers may not support on stack replacement.
    if (is_osr &amp;&amp;
        (!CICompileOSR || comp == NULL || !comp-&gt;supports_osr())) {
<span class="udiff-line-modified-removed">-     method-&gt;set_not_osr_compilable(comp_level);</span>
<span class="udiff-line-modified-added">+     method-&gt;set_not_osr_compilable(&quot;OSR not supported&quot;, comp_level);</span>
      return true;
    }
  
    // The method may be explicitly excluded by the user.
    double scale;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1401,11 +1458,11 @@</span>
                   method-&gt;is_native() ? &quot;generation of native wrapper&quot; : &quot;compile&quot;,
                   (method-&gt;is_static() ? &quot; static&quot; : &quot;&quot;));
        method-&gt;print_short_name(tty);
        tty-&gt;cr();
      }
<span class="udiff-line-modified-removed">-     method-&gt;set_not_compilable(comp_level, !quietly, &quot;excluded by CompileCommand&quot;);</span>
<span class="udiff-line-modified-added">+     method-&gt;set_not_compilable(&quot;excluded by CompileCommand&quot;, comp_level, !quietly);</span>
    }
  
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1420,50 +1477,42 @@</span>
    int id;
    if (method-&gt;is_native()) {
      assert(!is_osr, &quot;can&#39;t be osr&quot;);
      // Adapters, native wrappers and method handle intrinsics
      // should be generated always.
<span class="udiff-line-modified-removed">-     return Atomic::add(1, &amp;_compilation_id);</span>
<span class="udiff-line-modified-added">+     return Atomic::add(&amp;_compilation_id, 1);</span>
    } else if (CICountOSR &amp;&amp; is_osr) {
<span class="udiff-line-modified-removed">-     id = Atomic::add(1, &amp;_osr_compilation_id);</span>
<span class="udiff-line-modified-added">+     id = Atomic::add(&amp;_osr_compilation_id, 1);</span>
      if (CIStartOSR &lt;= id &amp;&amp; id &lt; CIStopOSR) {
        return id;
      }
    } else {
<span class="udiff-line-modified-removed">-     id = Atomic::add(1, &amp;_compilation_id);</span>
<span class="udiff-line-modified-added">+     id = Atomic::add(&amp;_compilation_id, 1);</span>
      if (CIStart &lt;= id &amp;&amp; id &lt; CIStop) {
        return id;
      }
    }
  
    // Method was not in the appropriate compilation range.
<span class="udiff-line-modified-removed">-   method-&gt;set_not_compilable_quietly();</span>
<span class="udiff-line-modified-added">+   method-&gt;set_not_compilable_quietly(&quot;Not in requested compile id range&quot;);</span>
    return 0;
  #else
    // CICountOSR is a develop flag and set to &#39;false&#39; by default. In a product built,
    // only _compilation_id is incremented.
<span class="udiff-line-modified-removed">-   return Atomic::add(1, &amp;_compilation_id);</span>
<span class="udiff-line-modified-added">+   return Atomic::add(&amp;_compilation_id, 1);</span>
  #endif
  }
  
  // ------------------------------------------------------------------
  // CompileBroker::assign_compile_id_unlocked
  //
  // Public wrapper for assign_compile_id that acquires the needed locks
  uint CompileBroker::assign_compile_id_unlocked(Thread* thread, const methodHandle&amp; method, int osr_bci) {
<span class="udiff-line-modified-removed">-   MutexLocker locker(MethodCompileQueue_lock, thread);</span>
<span class="udiff-line-modified-added">+   MutexLocker locker(thread, MethodCompileQueue_lock);</span>
    return assign_compile_id(method, osr_bci);
  }
  
<span class="udiff-line-removed">- // ------------------------------------------------------------------</span>
<span class="udiff-line-removed">- // CompileBroker::preload_classes</span>
<span class="udiff-line-removed">- void CompileBroker::preload_classes(const methodHandle&amp; method, TRAPS) {</span>
<span class="udiff-line-removed">-   // Move this code over from c1_Compiler.cpp</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  // ------------------------------------------------------------------
  // CompileBroker::create_compile_task
  //
  // Create a CompileTask object representing the current request for
  // compilation.  Add this task to the queue.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1501,15 +1550,15 @@</span>
   * JVMCI_COMPILATION_PROGRESS_WAIT_ATTEMPTS.
   *
   * @return true if this thread needs to free/recycle the task
   */
  bool CompileBroker::wait_for_jvmci_completion(JVMCICompiler* jvmci, CompileTask* task, JavaThread* thread) {
<span class="udiff-line-modified-removed">-   MutexLocker waiter(task-&gt;lock(), thread);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(thread, task-&gt;lock());</span>
    int progress_wait_attempts = 0;
    int methods_compiled = jvmci-&gt;methods_compiled();
    while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever() &amp;&amp;
<span class="udiff-line-modified-removed">-          task-&gt;lock()-&gt;wait(!Mutex::_no_safepoint_check_flag, JVMCI_COMPILATION_PROGRESS_WAIT_TIMESLICE)) {</span>
<span class="udiff-line-modified-added">+          ml.wait(JVMCI_COMPILATION_PROGRESS_WAIT_TIMESLICE)) {</span>
      CompilerThread* jvmci_compiler_thread = task-&gt;jvmci_compiler_thread();
  
      bool progress;
      if (jvmci_compiler_thread != NULL) {
        // If the JVMCI compiler thread is not blocked or suspended, we deem it to be making progress.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1552,29 +1601,27 @@</span>
    }
  
    assert(task-&gt;is_blocking(), &quot;can only wait on blocking task&quot;);
  
    JavaThread* thread = JavaThread::current();
<span class="udiff-line-removed">-   thread-&gt;set_blocked_on_compilation(true);</span>
  
    methodHandle method(thread, task-&gt;method());
    bool free_task;
  #if INCLUDE_JVMCI
    AbstractCompiler* comp = compiler(task-&gt;comp_level());
    if (comp-&gt;is_jvmci()) {
      free_task = wait_for_jvmci_completion((JVMCICompiler*) comp, task, thread);
    } else
  #endif
    {
<span class="udiff-line-modified-removed">-     MutexLocker waiter(task-&gt;lock(), thread);</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(thread, task-&gt;lock());</span>
      free_task = true;
      while (!task-&gt;is_complete() &amp;&amp; !is_compilation_disabled_forever()) {
<span class="udiff-line-modified-removed">-       task-&gt;lock()-&gt;wait();</span>
<span class="udiff-line-modified-added">+       ml.wait();</span>
      }
    }
  
<span class="udiff-line-removed">-   thread-&gt;set_blocked_on_compilation(false);</span>
    if (free_task) {
      if (is_compilation_disabled_forever()) {
        CompileTask::free(task);
        return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1601,20 +1648,14 @@</span>
    CompilerThread* thread = CompilerThread::current();
    AbstractCompiler* comp = thread-&gt;compiler();
    // Final sanity check - the compiler object must exist
    guarantee(comp != NULL, &quot;Compiler object must exist&quot;);
  
<span class="udiff-line-removed">-   int system_dictionary_modification_counter;</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     MutexLocker locker(Compile_lock, thread);</span>
<span class="udiff-line-removed">-     system_dictionary_modification_counter = SystemDictionary::number_of_modifications();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    {
      // Must switch to native to allocate ci_env
      ThreadToNativeFromVM ttn(thread);
<span class="udiff-line-modified-removed">-     ciEnv ci_env(NULL, system_dictionary_modification_counter);</span>
<span class="udiff-line-modified-added">+     ciEnv ci_env((CompileTask*)NULL);</span>
      // Cache Jvmti state
      ci_env.cache_jvmti_state();
      // Cache DTrace flags
      ci_env.cache_dtrace_flags();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1649,11 +1690,11 @@</span>
   * out to be a problem.
   */
  void CompileBroker::shutdown_compiler_runtime(AbstractCompiler* comp, CompilerThread* thread) {
    // Free buffer blob, if allocated
    if (thread-&gt;get_buffer_blob() != NULL) {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::free(thread-&gt;get_buffer_blob());
    }
  
    if (comp-&gt;should_perform_shutdown()) {
      // There are two reasons for shutting down the compiler
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1701,11 +1742,11 @@</span>
    // Find Compiler number by its threadObj.
    oop compiler_obj = ct-&gt;threadObj();
    int compiler_number = 0;
    bool found = false;
    for (; compiler_number &lt; count; compiler_number++) {
<span class="udiff-line-modified-removed">-     if (oopDesc::equals(JNIHandles::resolve_non_null(compiler_objects[compiler_number]), compiler_obj)) {</span>
<span class="udiff-line-modified-added">+     if (JNIHandles::resolve_non_null(compiler_objects[compiler_number]) == compiler_obj) {</span>
        found = true;
        break;
      }
    }
    assert(found, &quot;Compiler must exist at this point&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1740,11 +1781,11 @@</span>
  
    // First thread to get here will initialize the compiler interface
  
    {
      ASSERT_IN_VM;
<span class="udiff-line-modified-removed">-     MutexLocker only_one (CompileThread_lock, thread);</span>
<span class="udiff-line-modified-added">+     MutexLocker only_one (thread, CompileThread_lock);</span>
      if (!ciObjectFactory::is_initialized()) {
        ciObjectFactory::initialize();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1785,11 +1826,11 @@</span>
              tty-&gt;print_cr(&quot;Removing compiler thread %s after &quot; JLONG_FORMAT &quot; ms idle time&quot;,
                            thread-&gt;name(), thread-&gt;idle_time_millis());
            }
            // Free buffer blob, if allocated
            if (thread-&gt;get_buffer_blob() != NULL) {
<span class="udiff-line-modified-removed">-             MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+             MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
              CodeCache::free(thread-&gt;get_buffer_blob());
            }
            return; // Stop this thread.
          }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1815,11 +1856,12 @@</span>
            task-&gt;set_failure_reason(&quot;compilation is disabled&quot;);
          }
        }
  
        if (UseDynamicNumberOfCompilerThreads) {
<span class="udiff-line-modified-removed">-         possibly_add_compiler_threads();</span>
<span class="udiff-line-modified-added">+         possibly_add_compiler_threads(thread);</span>
<span class="udiff-line-added">+         assert(!thread-&gt;has_pending_exception(), &quot;should have been handled&quot;);</span>
        }
      }
    }
  
    // Shut down compiler runtime
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1915,11 +1957,11 @@</span>
  {
    ResourceMark rm;
    stringStream s;
    // Dump code cache  into a buffer before locking the tty,
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
    ttyLocker ttyl;
    tty-&gt;print(&quot;%s&quot;, s.as_string());
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1929,11 +1971,11 @@</span>
    ResourceMark rm;
    stringStream s;
  
    // Dump code cache into a buffer
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_summary(&amp;s, detailed);
    }
  
    char* remaining_log = s.as_string();
    while (*remaining_log != &#39;\0&#39;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1975,12 +2017,14 @@</span>
  }
  
  static void post_compilation_event(EventCompilation* event, CompileTask* task) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   event-&gt;set_method(task-&gt;method());</span>
<span class="udiff-line-modified-added">+   assert(task != NULL, &quot;invariant&quot;);</span>
    event-&gt;set_compileId(task-&gt;compile_id());
<span class="udiff-line-added">+   event-&gt;set_compiler(task-&gt;compiler()-&gt;type());</span>
<span class="udiff-line-added">+   event-&gt;set_method(task-&gt;method());</span>
    event-&gt;set_compileLevel(task-&gt;comp_level());
    event-&gt;set_succeded(task-&gt;is_success());
    event-&gt;set_isOsr(task-&gt;osr_bci() != CompileBroker::standard_entry_bci);
    event-&gt;set_codeSize((task-&gt;code() == NULL) ? 0 : task-&gt;code()-&gt;total_size());
    event-&gt;set_inlinedBytes(task-&gt;num_inlined_bytecodes());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2030,12 +2074,14 @@</span>
      assert(!method-&gt;is_native(), &quot;no longer compile natives&quot;);
  
      // Look up matching directives
      directive = DirectivesStack::getMatchingDirective(method, comp);
  
<span class="udiff-line-modified-removed">-     // Save information about this method in case of failure.</span>
<span class="udiff-line-modified-removed">-     set_last_compile(thread, method, is_osr, task_level);</span>
<span class="udiff-line-modified-added">+     // Update compile information when using perfdata.</span>
<span class="udiff-line-modified-added">+     if (UsePerfData) {</span>
<span class="udiff-line-added">+       update_compile_perf_data(thread, method, is_osr);</span>
<span class="udiff-line-added">+     }</span>
  
      DTRACE_METHOD_COMPILE_BEGIN_PROBE(method, compiler_name(task_level));
    }
  
    should_break = directive-&gt;BreakAtExecuteOption || task-&gt;check_break_at_flags();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2049,39 +2095,37 @@</span>
    int compilable = ciEnv::MethodCompilable;
    const char* failure_reason = NULL;
    bool failure_reason_on_C_heap = false;
    const char* retry_message = NULL;
  
<span class="udiff-line-removed">-   int system_dictionary_modification_counter;</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     MutexLocker locker(Compile_lock, thread);</span>
<span class="udiff-line-removed">-     system_dictionary_modification_counter = SystemDictionary::number_of_modifications();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
  #if INCLUDE_JVMCI
    if (UseJVMCICompiler &amp;&amp; comp != NULL &amp;&amp; comp-&gt;is_jvmci()) {
      JVMCICompiler* jvmci = (JVMCICompiler*) comp;
  
      TraceTime t1(&quot;compilation&quot;, &amp;time);
      EventCompilation event;
  
      // Skip redefined methods
      if (target_handle-&gt;is_old()) {
<span class="udiff-line-modified-removed">-         failure_reason = &quot;redefined method&quot;;</span>
<span class="udiff-line-modified-removed">-         retry_message = &quot;not retryable&quot;;</span>
<span class="udiff-line-modified-removed">-         compilable = ciEnv::MethodCompilable_never;</span>
<span class="udiff-line-modified-added">+       failure_reason = &quot;redefined method&quot;;</span>
<span class="udiff-line-modified-added">+       retry_message = &quot;not retryable&quot;;</span>
<span class="udiff-line-modified-added">+       compilable = ciEnv::MethodCompilable_never;</span>
      } else {
<span class="udiff-line-modified-removed">-         JVMCIEnv env(task, system_dictionary_modification_counter);</span>
<span class="udiff-line-modified-removed">-         methodHandle method(thread, target_handle);</span>
<span class="udiff-line-modified-removed">-         jvmci-&gt;compile_method(method, osr_bci, &amp;env);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         failure_reason = env.failure_reason();</span>
<span class="udiff-line-modified-removed">-         failure_reason_on_C_heap = env.failure_reason_on_C_heap();</span>
<span class="udiff-line-modified-removed">-         if (!env.retryable()) {</span>
<span class="udiff-line-modified-removed">-           retry_message = &quot;not retryable&quot;;</span>
<span class="udiff-line-modified-removed">-           compilable = ciEnv::MethodCompilable_not_at_tier;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+       JVMCICompileState compile_state(task);</span>
<span class="udiff-line-modified-added">+       JVMCIEnv env(thread, &amp;compile_state, __FILE__, __LINE__);</span>
<span class="udiff-line-modified-added">+       methodHandle method(thread, target_handle);</span>
<span class="udiff-line-modified-added">+       env.runtime()-&gt;compile_method(&amp;env, jvmci, method, osr_bci);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       failure_reason = compile_state.failure_reason();</span>
<span class="udiff-line-modified-added">+       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();</span>
<span class="udiff-line-modified-added">+       if (!compile_state.retryable()) {</span>
<span class="udiff-line-modified-added">+         retry_message = &quot;not retryable&quot;;</span>
<span class="udiff-line-modified-added">+         compilable = ciEnv::MethodCompilable_not_at_tier;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (task-&gt;code() == NULL) {</span>
<span class="udiff-line-added">+         assert(failure_reason != NULL, &quot;must specify failure_reason&quot;);</span>
<span class="udiff-line-added">+       }</span>
      }
      post_compile(thread, task, task-&gt;code() != NULL, NULL, compilable, failure_reason);
      if (event.should_commit()) {
        post_compilation_event(&amp;event, task);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2090,11 +2134,11 @@</span>
  #endif // INCLUDE_JVMCI
    {
      NoHandleMark  nhm;
      ThreadToNativeFromVM ttn(thread);
  
<span class="udiff-line-modified-removed">-     ciEnv ci_env(task, system_dictionary_modification_counter);</span>
<span class="udiff-line-modified-added">+     ciEnv ci_env(task);</span>
      if (should_break) {
        ci_env.set_break_at_compile(true);
      }
      if (should_log) {
        ci_env.set_log(thread-&gt;log());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2115,13 +2159,13 @@</span>
  
      if (comp == NULL) {
        ci_env.record_method_not_compilable(&quot;no compiler&quot;, !TieredCompilation);
      } else {
        if (WhiteBoxAPI &amp;&amp; WhiteBox::compilation_locked) {
<span class="udiff-line-modified-removed">-         MonitorLockerEx locker(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+         MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);</span>
          while (WhiteBox::compilation_locked) {
<span class="udiff-line-modified-removed">-           locker.wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+           locker.wait();</span>
          }
        }
        comp-&gt;compile_method(&amp;ci_env, target, osr_bci, directive);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2195,19 +2239,19 @@</span>
    }
    // Disable compilation, if required.
    switch (compilable) {
    case ciEnv::MethodCompilable_never:
      if (is_osr)
<span class="udiff-line-modified-removed">-       method-&gt;set_not_osr_compilable_quietly();</span>
<span class="udiff-line-modified-added">+       method-&gt;set_not_osr_compilable_quietly(&quot;MethodCompilable_never&quot;);</span>
      else
<span class="udiff-line-modified-removed">-       method-&gt;set_not_compilable_quietly();</span>
<span class="udiff-line-modified-added">+       method-&gt;set_not_compilable_quietly(&quot;MethodCompilable_never&quot;);</span>
      break;
    case ciEnv::MethodCompilable_not_at_tier:
      if (is_osr)
<span class="udiff-line-modified-removed">-       method-&gt;set_not_osr_compilable_quietly(task_level);</span>
<span class="udiff-line-modified-added">+       method-&gt;set_not_osr_compilable_quietly(&quot;MethodCompilable_not_at_tier&quot;, task_level);</span>
      else
<span class="udiff-line-modified-removed">-       method-&gt;set_not_compilable_quietly(task_level);</span>
<span class="udiff-line-modified-added">+       method-&gt;set_not_compilable_quietly(&quot;MethodCompilable_not_at_tier&quot;, task_level);</span>
      break;
    }
  
    // Note that the queued_for_compilation bits are cleared without
    // protection of a mutex. [They were set by the requester thread,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2262,62 +2306,53 @@</span>
      CodeCache::report_codemem_full(code_blob_type, should_print_compiler_warning());
    }
  }
  
  // ------------------------------------------------------------------
<span class="udiff-line-modified-removed">- // CompileBroker::set_last_compile</span>
<span class="udiff-line-modified-added">+ // CompileBroker::update_compile_perf_data</span>
  //
  // Record this compilation for debugging purposes.
<span class="udiff-line-modified-removed">- void CompileBroker::set_last_compile(CompilerThread* thread, const methodHandle&amp; method, bool is_osr, int comp_level) {</span>
<span class="udiff-line-modified-added">+ void CompileBroker::update_compile_perf_data(CompilerThread* thread, const methodHandle&amp; method, bool is_osr) {</span>
    ResourceMark rm;
    char* method_name = method-&gt;name()-&gt;as_C_string();
<span class="udiff-line-removed">-   strncpy(_last_method_compiled, method_name, CompileBroker::name_buffer_length);</span>
<span class="udiff-line-removed">-   _last_method_compiled[CompileBroker::name_buffer_length - 1] = &#39;\0&#39;; // ensure null terminated</span>
    char current_method[CompilerCounters::cmname_buffer_length];
    size_t maxLen = CompilerCounters::cmname_buffer_length;
  
<span class="udiff-line-modified-removed">-   if (UsePerfData) {</span>
<span class="udiff-line-removed">-     const char* class_name = method-&gt;method_holder()-&gt;name()-&gt;as_C_string();</span>
<span class="udiff-line-modified-added">+   const char* class_name = method-&gt;method_holder()-&gt;name()-&gt;as_C_string();</span>
  
<span class="udiff-line-modified-removed">-     size_t s1len = strlen(class_name);</span>
<span class="udiff-line-modified-removed">-     size_t s2len = strlen(method_name);</span>
<span class="udiff-line-modified-added">+   size_t s1len = strlen(class_name);</span>
<span class="udiff-line-modified-added">+   size_t s2len = strlen(method_name);</span>
  
<span class="udiff-line-modified-removed">-     // check if we need to truncate the string</span>
<span class="udiff-line-modified-removed">-     if (s1len + s2len + 2 &gt; maxLen) {</span>
<span class="udiff-line-modified-added">+   // check if we need to truncate the string</span>
<span class="udiff-line-modified-added">+   if (s1len + s2len + 2 &gt; maxLen) {</span>
  
<span class="udiff-line-modified-removed">-       // the strategy is to lop off the leading characters of the</span>
<span class="udiff-line-modified-removed">-       // class name and the trailing characters of the method name.</span>
<span class="udiff-line-modified-added">+     // the strategy is to lop off the leading characters of the</span>
<span class="udiff-line-modified-added">+     // class name and the trailing characters of the method name.</span>
  
<span class="udiff-line-modified-removed">-       if (s2len + 2 &gt; maxLen) {</span>
<span class="udiff-line-modified-removed">-         // lop of the entire class name string, let snprintf handle</span>
<span class="udiff-line-modified-removed">-         // truncation of the method name.</span>
<span class="udiff-line-modified-removed">-         class_name += s1len; // null string</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       else {</span>
<span class="udiff-line-modified-removed">-         // lop off the extra characters from the front of the class name</span>
<span class="udiff-line-modified-removed">-         class_name += ((s1len + s2len + 2) - maxLen);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+     if (s2len + 2 &gt; maxLen) {</span>
<span class="udiff-line-modified-added">+       // lop of the entire class name string, let snprintf handle</span>
<span class="udiff-line-modified-added">+       // truncation of the method name.</span>
<span class="udiff-line-modified-added">+       class_name += s1len; // null string</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     else {</span>
<span class="udiff-line-modified-added">+       // lop off the extra characters from the front of the class name</span>
<span class="udiff-line-modified-added">+       class_name += ((s1len + s2len + 2) - maxLen);</span>
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     jio_snprintf(current_method, maxLen, &quot;%s %s&quot;, class_name, method_name);</span>
    }
  
<span class="udiff-line-added">+   jio_snprintf(current_method, maxLen, &quot;%s %s&quot;, class_name, method_name);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int last_compile_type = normal_compile;</span>
    if (CICountOSR &amp;&amp; is_osr) {
<span class="udiff-line-modified-removed">-     _last_compile_type = osr_compile;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     _last_compile_type = normal_compile;</span>
<span class="udiff-line-modified-added">+     last_compile_type = osr_compile;</span>
    }
<span class="udiff-line-removed">-   _last_compile_level = comp_level;</span>
  
<span class="udiff-line-modified-removed">-   if (UsePerfData) {</span>
<span class="udiff-line-modified-removed">-     CompilerCounters* counters = thread-&gt;counters();</span>
<span class="udiff-line-modified-removed">-     counters-&gt;set_current_method(current_method);</span>
<span class="udiff-line-removed">-     counters-&gt;set_compile_type((jlong)_last_compile_type);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   CompilerCounters* counters = thread-&gt;counters();</span>
<span class="udiff-line-modified-added">+   counters-&gt;set_current_method(current_method);</span>
<span class="udiff-line-modified-added">+   counters-&gt;set_compile_type((jlong) last_compile_type);</span>
  }
  
<span class="udiff-line-removed">- </span>
  // ------------------------------------------------------------------
  // CompileBroker::push_jni_handle_block
  //
  // Push on a new block of JNI handles.
  void CompileBroker::push_jni_handle_block() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2616,25 +2651,10 @@</span>
    tty-&gt;cr();
    tty-&gt;print_cr(&quot;  nmethod code size         : %8d bytes&quot;, nmethods_code_size);
    tty-&gt;print_cr(&quot;  nmethod total size        : %8d bytes&quot;, nmethods_size);
  }
  
<span class="udiff-line-removed">- // Debugging output for failure</span>
<span class="udiff-line-removed">- void CompileBroker::print_last_compile() {</span>
<span class="udiff-line-removed">-   if (_last_compile_level != CompLevel_none &amp;&amp;</span>
<span class="udiff-line-removed">-       compiler(_last_compile_level) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-       _last_compile_type != no_compile) {</span>
<span class="udiff-line-removed">-     if (_last_compile_type == osr_compile) {</span>
<span class="udiff-line-removed">-       tty-&gt;print_cr(&quot;Last parse:  [osr]%d+++(%d) %s&quot;,</span>
<span class="udiff-line-removed">-                     _osr_compilation_id, _last_compile_level, _last_method_compiled);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       tty-&gt;print_cr(&quot;Last parse:  %d+++(%d) %s&quot;,</span>
<span class="udiff-line-removed">-                     _compilation_id, _last_compile_level, _last_method_compiled);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Print general/accumulated JIT information.
  void CompileBroker::print_info(outputStream *out) {
    if (out == NULL) out = tty;
    out-&gt;cr();
    out-&gt;print_cr(&quot;======================&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2664,11 +2684,11 @@</span>
  // Note: tty_lock must not be held upon entry to this function.
  //       Print functions called from herein do &quot;micro-locking&quot; on tty_lock.
  //       That&#39;s a tradeoff which keeps together important blocks of output.
  //       At the same time, continuous tty_lock hold time is kept in check,
  //       preventing concurrently printing threads from stalling a long time.
<span class="udiff-line-modified-removed">- void CompileBroker::print_heapinfo(outputStream* out, const char* function, const char* granularity) {</span>
<span class="udiff-line-modified-added">+ void CompileBroker::print_heapinfo(outputStream* out, const char* function, size_t granularity) {</span>
    TimeStamp ts_total;
    TimeStamp ts_global;
    TimeStamp ts;
  
    bool allFun = !strcmp(function, &quot;all&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2705,29 +2725,29 @@</span>
    // across user interaction.
    // Acquire this lock before acquiring the CodeCache_lock.
    // CodeHeapStateAnalytics_lock could be held by a concurrent thread for a long time,
    // leading to an unnecessarily long hold time of the CodeCache_lock.
    ts.update(); // record starting point
<span class="udiff-line-modified-removed">-   MutexLockerEx mu1(CodeHeapStateAnalytics_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu1(CodeHeapStateAnalytics_lock, Mutex::_no_safepoint_check_flag);</span>
    out-&gt;print_cr(&quot;\n__ CodeHeapStateAnalytics lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
  
    // If we serve an &quot;allFun&quot; call, it is beneficial to hold the CodeCache_lock
    // for the entire duration of aggregation and printing. That makes sure
    // we see a consistent picture and do not run into issues caused by
    // the CodeHeap being altered concurrently.
<span class="udiff-line-modified-removed">-   Monitor* global_lock   = allFun ? CodeCache_lock : NULL;</span>
<span class="udiff-line-modified-removed">-   Monitor* function_lock = allFun ? NULL : CodeCache_lock;</span>
<span class="udiff-line-modified-added">+   Mutex* global_lock   = allFun ? CodeCache_lock : NULL;</span>
<span class="udiff-line-modified-added">+   Mutex* function_lock = allFun ? NULL : CodeCache_lock;</span>
    ts_global.update(); // record starting point
<span class="udiff-line-modified-removed">-   MutexLockerEx mu2(global_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker mu2(global_lock, Mutex::_no_safepoint_check_flag);</span>
    if (global_lock != NULL) {
      out-&gt;print_cr(&quot;\n__ CodeCache (global) lock wait took %10.3f seconds _________\n&quot;, ts_global.seconds());
      ts_global.update(); // record starting point
    }
  
    if (aggregate) {
      ts.update(); // record starting point
<span class="udiff-line-modified-removed">-     MutexLockerEx mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      if (function_lock != NULL) {
        out-&gt;print_cr(&quot;\n__ CodeCache (function) lock wait took %10.3f seconds _________\n&quot;, ts.seconds());
      }
  
      ts.update(); // record starting point
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2743,11 +2763,11 @@</span>
    if (methodSpace) CodeCache::print_space(out);
    if (methodAge) CodeCache::print_age(out);
    if (methodNames) {
      // print_names() has shown to be sensitive to concurrent CodeHeap modifications.
      // Therefore, request  the CodeCache_lock before calling...
<span class="udiff-line-modified-removed">-     MutexLockerEx mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);</span>
      CodeCache::print_names(out);
    }
    if (discard) CodeCache::discard(out);
  
    if (global_lock != NULL) {
</pre>
<center><a href="abstractCompiler.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compileBroker.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
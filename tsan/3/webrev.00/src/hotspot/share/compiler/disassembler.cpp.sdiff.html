<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/disassembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerOracle.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/disassembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.hpp&quot;
  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;gc/shared/cardTable.hpp&quot;
  32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  33 #include &quot;gc/shared/collectedHeap.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;

  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;runtime/handles.inline.hpp&quot;
  37 #include &quot;runtime/os.inline.hpp&quot;
  38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;utilities/resourceHash.hpp&quot;
  41 #include CPU_HEADER(depChecker)
  42 
  43 void*       Disassembler::_library               = NULL;
  44 bool        Disassembler::_tried_to_load_library = false;

  45 
  46 // This routine is in the shared library:
  47 Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;
  48 Disassembler::decode_func Disassembler::_decode_instructions = NULL;
  49 
  50 static const char hsdis_library_name[] = &quot;hsdis-&quot; HOTSPOT_LIB_ARCH;
  51 static const char decode_instructions_virtual_name[] = &quot;decode_instructions_virtual&quot;;
  52 static const char decode_instructions_name[] = &quot;decode_instructions&quot;;
  53 static bool use_new_version = true;
  54 #define COMMENT_COLUMN  52 LP64_ONLY(+8) /*could be an option*/
  55 #define BYTES_COMMENT   &quot;;...&quot;  /* funky byte display comment */
  56 
<span class="line-removed">  57 bool Disassembler::load_library() {</span>
<span class="line-removed">  58   if (_decode_instructions_virtual != NULL || _decode_instructions != NULL) {</span>
<span class="line-removed">  59     // Already succeeded.</span>
<span class="line-removed">  60     return true;</span>
<span class="line-removed">  61   }</span>
<span class="line-removed">  62   if (_tried_to_load_library) {</span>
<span class="line-removed">  63     // Do not try twice.</span>
<span class="line-removed">  64     // To force retry in debugger: assign _tried_to_load_library=0</span>
<span class="line-removed">  65     return false;</span>
<span class="line-removed">  66   }</span>
<span class="line-removed">  67   // Try to load it.</span>
<span class="line-removed">  68   char ebuf[1024];</span>
<span class="line-removed">  69   char buf[JVM_MAXPATHLEN];</span>
<span class="line-removed">  70   os::jvm_path(buf, sizeof(buf));</span>
<span class="line-removed">  71   int jvm_offset = -1;</span>
<span class="line-removed">  72   int lib_offset = -1;</span>
<span class="line-removed">  73 #ifdef STATIC_BUILD</span>
<span class="line-removed">  74   char* p = strrchr(buf, &#39;/&#39;);</span>
<span class="line-removed">  75   *p = &#39;\0&#39;;</span>
<span class="line-removed">  76   strcat(p, &quot;/lib/&quot;);</span>
<span class="line-removed">  77   lib_offset = jvm_offset = strlen(buf);</span>
<span class="line-removed">  78 #else</span>
<span class="line-removed">  79   {</span>
<span class="line-removed">  80     // Match &quot;jvm[^/]*&quot; in jvm_path.</span>
<span class="line-removed">  81     const char* base = buf;</span>
<span class="line-removed">  82     const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-removed">  83     if (p != NULL) lib_offset = p - base + 1;</span>
<span class="line-removed">  84     p = strstr(p ? p : base, &quot;jvm&quot;);</span>
<span class="line-removed">  85     if (p != NULL) jvm_offset = p - base;</span>
<span class="line-removed">  86   }</span>
<span class="line-removed">  87 #endif</span>
<span class="line-removed">  88   // Find the disassembler shared library.</span>
<span class="line-removed">  89   // Search for several paths derived from libjvm, in this order:</span>
<span class="line-removed">  90   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)</span>
<span class="line-removed">  91   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed">  92   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed">  93   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-removed">  94   if (jvm_offset &gt;= 0) {</span>
<span class="line-removed">  95     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so</span>
<span class="line-removed">  96     strcpy(&amp;buf[jvm_offset], hsdis_library_name);</span>
<span class="line-removed">  97     strcat(&amp;buf[jvm_offset], os::dll_file_extension());</span>
<span class="line-removed">  98     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed">  99     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {</span>
<span class="line-removed"> 100       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed"> 101       strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-removed"> 102       strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-removed"> 103       _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed"> 104     }</span>
<span class="line-removed"> 105     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {</span>
<span class="line-removed"> 106       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-removed"> 107       buf[lib_offset - 1] = &#39;\0&#39;;</span>
<span class="line-removed"> 108       const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-removed"> 109       if (p != NULL) {</span>
<span class="line-removed"> 110         lib_offset = p - buf + 1;</span>
<span class="line-removed"> 111         strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-removed"> 112         strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-removed"> 113         _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed"> 114       }</span>
<span class="line-removed"> 115     }</span>
<span class="line-removed"> 116   }</span>
<span class="line-removed"> 117   if (_library == NULL) {</span>
<span class="line-removed"> 118     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-removed"> 119     strcpy(&amp;buf[0], hsdis_library_name);</span>
<span class="line-removed"> 120     strcat(&amp;buf[0], os::dll_file_extension());</span>
<span class="line-removed"> 121     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-removed"> 122   }</span>
<span class="line-removed"> 123   if (_library != NULL) {</span>
<span class="line-removed"> 124     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,</span>
<span class="line-removed"> 125                                           os::dll_lookup(_library, decode_instructions_virtual_name));</span>
<span class="line-removed"> 126   }</span>
<span class="line-removed"> 127   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {</span>
<span class="line-removed"> 128     // could not spot in new version, try old version</span>
<span class="line-removed"> 129     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,</span>
<span class="line-removed"> 130                                           os::dll_lookup(_library, decode_instructions_name));</span>
<span class="line-removed"> 131     use_new_version = false;</span>
<span class="line-removed"> 132   } else {</span>
<span class="line-removed"> 133     use_new_version = true;</span>
<span class="line-removed"> 134   }</span>
<span class="line-removed"> 135   _tried_to_load_library = true;</span>
<span class="line-removed"> 136   if (_decode_instructions_virtual == NULL &amp;&amp; _decode_instructions == NULL) {</span>
<span class="line-removed"> 137     tty-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;, buf,</span>
<span class="line-removed"> 138                   ((_library != NULL)</span>
<span class="line-removed"> 139                    ? &quot;entry point is missing&quot;</span>
<span class="line-removed"> 140                    : (WizardMode || PrintMiscellaneous)</span>
<span class="line-removed"> 141                    ? (const char*)ebuf</span>
<span class="line-removed"> 142                    : &quot;library not loadable&quot;),</span>
<span class="line-removed"> 143                   &quot;PrintAssembly is disabled&quot;);</span>
<span class="line-removed"> 144     return false;</span>
<span class="line-removed"> 145   }</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147   // Success.</span>
<span class="line-removed"> 148   tty-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);</span>
<span class="line-removed"> 149   return true;</span>
<span class="line-removed"> 150 }</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 </span>
 153 class decode_env {
 154  private:
<span class="line-modified"> 155   nmethod*      _nm;</span>
<span class="line-modified"> 156   CodeBlob*     _code;</span>


 157   CodeStrings   _strings;
<span class="line-modified"> 158   outputStream* _output;</span>
<span class="line-modified"> 159   address       _start, _end;</span>
<span class="line-removed"> 160   ptrdiff_t     _offset;</span>
 161 
 162   char          _option_buf[512];
 163   char          _print_raw;
<span class="line-modified"> 164   bool          _print_pc;</span>
<span class="line-modified"> 165   bool          _print_bytes;</span>
<span class="line-modified"> 166   address       _cur_insn;</span>
<span class="line-modified"> 167   int           _bytes_per_line; // arch-specific formatting option</span>
 168   bool          _print_file_name;







 169 



 170   static bool match(const char* event, const char* tag) {
<span class="line-modified"> 171     size_t taglen = strlen(tag);</span>
<span class="line-modified"> 172     if (strncmp(event, tag, taglen) != 0)</span>



 173       return false;
 174     char delim = event[taglen];
 175     return delim == &#39;\0&#39; || delim == &#39; &#39; || delim == &#39;/&#39; || delim == &#39;=&#39;;
 176   }
 177 

 178   void collect_options(const char* p) {
 179     if (p == NULL || p[0] == &#39;\0&#39;)  return;
 180     size_t opt_so_far = strlen(_option_buf);
 181     if (opt_so_far + 1 + strlen(p) + 1 &gt; sizeof(_option_buf))  return;
 182     char* fillp = &amp;_option_buf[opt_so_far];
 183     if (opt_so_far &gt; 0) *fillp++ = &#39;,&#39;;
 184     strcat(fillp, p);
 185     // replace white space by commas:
 186     char* q = fillp;
 187     while ((q = strpbrk(q, &quot; \t\n&quot;)) != NULL)
 188       *q++ = &#39;,&#39;;
<span class="line-removed"> 189     // Note that multiple PrintAssemblyOptions flags accumulate with \n,</span>
<span class="line-removed"> 190     // which we want to be changed to a comma...</span>
 191   }
 192 


 193   void print_insn_labels();
<span class="line-modified"> 194   void print_insn_bytes(address pc0, address pc);</span>
 195   void print_address(address value);
 196 













































 197   struct SourceFileInfo {
 198     struct Link : public CHeapObj&lt;mtCode&gt; {
 199       const char* file;
 200       int line;
 201       Link* next;
 202       Link(const char* f, int l) : file(f), line(l), next(NULL) {}
 203     };
 204     Link *head, *tail;
 205 
 206     static unsigned hash(const address&amp; a) {
 207       return primitive_hash&lt;address&gt;(a);
 208     }
 209     static bool equals(const address&amp; a0, const address&amp; a1) {
 210       return primitive_equals&lt;address&gt;(a0, a1);
 211     }
 212     void append(const char* file, int line) {
 213       if (tail != NULL &amp;&amp; tail-&gt;file == file &amp;&amp; tail-&gt;line == line) {
 214         // Don&#39;t print duplicated lines at the same address. This could happen with C
 215         // macros that end up having multiple &quot;__&quot; tokens on the same __LINE__.
 216         return;
</pre>
<hr />
<pre>
 223         tail = link;
 224       }
 225     }
 226     SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {
 227       append(file, line);
 228     }
 229   };
 230 
 231   typedef ResourceHashtable&lt;
 232       address, SourceFileInfo,
 233       SourceFileInfo::hash,
 234       SourceFileInfo::equals,
 235       15889,      // prime number
 236       ResourceObj::C_HEAP&gt; SourceFileInfoTable;
 237 
 238   static SourceFileInfoTable _src_table;
 239   static const char* _cached_src;
 240   static GrowableArray&lt;const char*&gt;* _cached_src_lines;
 241 
 242  public:
<span class="line-modified"> 243   decode_env(CodeBlob* code, outputStream* output,</span>
<span class="line-modified"> 244              CodeStrings c = CodeStrings(), ptrdiff_t offset = 0);</span>




 245 
<span class="line-modified"> 246   address decode_instructions(address start, address end);</span>
<span class="line-modified"> 247 </span>
<span class="line-modified"> 248   void start_insn(address pc) {</span>
<span class="line-removed"> 249     _cur_insn = pc;</span>
<span class="line-removed"> 250     output()-&gt;bol();</span>
<span class="line-removed"> 251     print_insn_labels();</span>
<span class="line-removed"> 252   }</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254   void end_insn(address pc) {</span>
<span class="line-removed"> 255     address pc0 = cur_insn();</span>
<span class="line-removed"> 256     outputStream* st = output();</span>
<span class="line-removed"> 257     if (_print_bytes &amp;&amp; pc &gt; pc0)</span>
<span class="line-removed"> 258       print_insn_bytes(pc0, pc);</span>
<span class="line-removed"> 259     if (_nm != NULL) {</span>
<span class="line-removed"> 260       _nm-&gt;print_code_comment_on(st, COMMENT_COLUMN, pc0, pc);</span>
<span class="line-removed"> 261       // this calls reloc_string_for which calls oop::print_value_on</span>
<span class="line-removed"> 262     }</span>
<span class="line-removed"> 263     print_hook_comments(pc0, _nm != NULL);</span>
<span class="line-removed"> 264     // follow each complete insn by a nice newline</span>
<span class="line-removed"> 265     st-&gt;cr();</span>
<span class="line-removed"> 266   }</span>
 267 
 268   address handle_event(const char* event, address arg);
 269 
<span class="line-modified"> 270   outputStream* output() { return _output; }</span>
<span class="line-modified"> 271   address cur_insn() { return _cur_insn; }</span>
<span class="line-modified"> 272   const char* options() { return _option_buf; }</span>
<span class="line-modified"> 273   static void hook(const char* file, int line, address pc);</span>
 274   void print_hook_comments(address pc, bool newline);
 275 };
 276 


 277 decode_env::SourceFileInfoTable decode_env::_src_table;
 278 const char* decode_env::_cached_src = NULL;
 279 GrowableArray&lt;const char*&gt;* decode_env::_cached_src_lines = NULL;
 280 
 281 void decode_env::hook(const char* file, int line, address pc) {
 282   // For simplication, we never free from this table. It&#39;s really not
 283   // necessary as we add to the table only when PrintInterpreter is true,
 284   // which means we are debugging the VM and a little bit of extra
 285   // memory usage doesn&#39;t matter.
 286   SourceFileInfo* found = _src_table.get(pc);
 287   if (found != NULL) {
 288     found-&gt;append(file, line);
 289   } else {
 290     SourceFileInfo sfi(file, line);
 291     _src_table.put(pc, sfi); // sfi is copied by value
 292   }
 293 }
 294 
 295 void decode_env::print_hook_comments(address pc, bool newline) {
 296   SourceFileInfo* found = _src_table.get(pc);
</pre>
<hr />
<pre>
 343         st-&gt;print(&quot;;;@FILE: %s&quot;, file);
 344         newline = true;
 345       }
 346 
 347       int index = line - 1; // 1-based line number -&gt; 0-based index.
 348       if (index &gt;= _cached_src_lines-&gt;length()) {
 349         // This could happen if source file is mismatched.
 350       } else {
 351         const char* source_line = _cached_src_lines-&gt;at(index);
 352         if (newline) {
 353           st-&gt;cr();
 354         }
 355         st-&gt;move_to(COMMENT_COLUMN);
 356         st-&gt;print(&quot;;;%5d: %s&quot;, line, source_line);
 357         newline = true;
 358       }
 359     }
 360   }
 361 }
 362 
<span class="line-modified"> 363 decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c,</span>
<span class="line-modified"> 364                        ptrdiff_t offset) {</span>
<span class="line-modified"> 365   memset(this, 0, sizeof(*this)); // Beware, this zeroes bits of fields.</span>
<span class="line-modified"> 366   _output = output ? output : tty;</span>
<span class="line-modified"> 367   _code = code;</span>
<span class="line-modified"> 368   if (code != NULL &amp;&amp; code-&gt;is_nmethod())</span>
<span class="line-modified"> 369     _nm = (nmethod*) code;</span>


































 370   _strings.copy(c);
<span class="line-modified"> 371   _offset = offset;</span>

 372 
<span class="line-modified"> 373   // by default, output pc but not bytes:</span>
<span class="line-modified"> 374   _print_pc       = true;</span>
<span class="line-modified"> 375   _print_bytes    = false;</span>
<span class="line-modified"> 376   _bytes_per_line = Disassembler::pd_instruction_alignment();</span>
<span class="line-modified"> 377   _print_file_name= true;</span>










































 378 
<span class="line-modified"> 379   // parse the global option string:</span>









 380   collect_options(Disassembler::pd_cpu_opts());
 381   collect_options(PrintAssemblyOptions);
 382 
<span class="line-modified"> 383   if (strstr(options(), &quot;hsdis-&quot;)) {</span>
<span class="line-modified"> 384     if (strstr(options(), &quot;hsdis-print-raw&quot;))</span>
<span class="line-removed"> 385       _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);</span>
<span class="line-removed"> 386     if (strstr(options(), &quot;hsdis-print-pc&quot;))</span>
<span class="line-removed"> 387       _print_pc = !_print_pc;</span>
<span class="line-removed"> 388     if (strstr(options(), &quot;hsdis-print-bytes&quot;))</span>
<span class="line-removed"> 389       _print_bytes = !_print_bytes;</span>
 390   }



 391   if (strstr(options(), &quot;help&quot;)) {
<span class="line-modified"> 392     tty-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);</span>
<span class="line-modified"> 393     tty-&gt;print_cr(&quot;  hsdis-print-raw       test plugin by requesting raw output&quot;);</span>
<span class="line-modified"> 394     tty-&gt;print_cr(&quot;  hsdis-print-raw-xml   test plugin by requesting raw xml&quot;);</span>
<span class="line-modified"> 395     tty-&gt;print_cr(&quot;  hsdis-print-pc        turn off PC printing (on by default)&quot;);</span>
<span class="line-modified"> 396     tty-&gt;print_cr(&quot;  hsdis-print-bytes     turn on instruction byte output&quot;);</span>
<span class="line-modified"> 397     tty-&gt;print_cr(&quot;combined options: %s&quot;, options());</span>













































 398   }
 399 }
 400 






























 401 address decode_env::handle_event(const char* event, address arg) {
<span class="line-modified"> 402   if (match(event, &quot;insn&quot;)) {</span>























 403     start_insn(arg);
 404   } else if (match(event, &quot;/insn&quot;)) {
 405     end_insn(arg);
 406   } else if (match(event, &quot;addr&quot;)) {
 407     if (arg != NULL) {
 408       print_address(arg);
 409       return arg;
 410     }
<span class="line-modified"> 411   } else if (match(event, &quot;mach&quot;)) {</span>
<span class="line-modified"> 412     static char buffer[32] = { 0, };</span>
<span class="line-modified"> 413     if (strcmp(buffer, (const char*)arg) != 0 ||</span>
<span class="line-modified"> 414         strlen((const char*)arg) &gt; sizeof(buffer) - 1) {</span>
























 415       // Only print this when the mach changes
 416       strncpy(buffer, (const char*)arg, sizeof(buffer) - 1);
 417       buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
<span class="line-modified"> 418       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, arg);</span>
 419     }
<span class="line-modified"> 420   } else if (match(event, &quot;format bytes-per-line&quot;)) {</span>




 421     _bytes_per_line = (int) (intptr_t) arg;
<span class="line-modified"> 422   } else {</span>
<span class="line-removed"> 423     // ignore unrecognized markup</span>
 424   }

 425   return NULL;
 426 }
 427 





 428 // called by the disassembler to print out jump targets and data addresses
 429 void decode_env::print_address(address adr) {
<span class="line-modified"> 430   outputStream* st = _output;</span>
 431 
 432   if (adr == NULL) {
 433     st-&gt;print(&quot;NULL&quot;);
 434     return;
 435   }
 436 
 437   int small_num = (int)(intptr_t)adr;
 438   if ((intptr_t)adr == (intptr_t)small_num
 439       &amp;&amp; -1 &lt;= small_num &amp;&amp; small_num &lt;= 9) {
 440     st-&gt;print(&quot;%d&quot;, small_num);
 441     return;
 442   }
 443 
 444   if (Universe::is_fully_initialized()) {
 445     if (StubRoutines::contains(adr)) {
 446       StubCodeDesc* desc = StubCodeDesc::desc_for(adr);
 447       if (desc == NULL) {
 448         desc = StubCodeDesc::desc_for(adr + frame::pc_return_offset);
 449       }
 450       if (desc != NULL) {
</pre>
<hr />
<pre>
 455           st-&gt;print(&quot; &quot; PTR_FORMAT, p2i(adr));
 456         }
 457         return;
 458       }
 459       st-&gt;print(&quot;Stub::&lt;unknown&gt; &quot; PTR_FORMAT, p2i(adr));
 460       return;
 461     }
 462 
 463     BarrierSet* bs = BarrierSet::barrier_set();
 464     if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
 465         adr == ci_card_table_address_as&lt;address&gt;()) {
 466       st-&gt;print(&quot;word_map_base&quot;);
 467       if (WizardMode) st-&gt;print(&quot; &quot; INTPTR_FORMAT, p2i(adr));
 468       return;
 469     }
 470   }
 471 
 472   if (_nm == NULL) {
 473     // Don&#39;t do this for native methods, as the function name will be printed in
 474     // nmethod::reloc_string_for().
<span class="line-modified"> 475     ResourceMark rm;</span>


 476     const int buflen = 1024;
<span class="line-modified"> 477     char* buf = NEW_RESOURCE_ARRAY(char, buflen);</span>
 478     int offset;
 479     if (os::dll_address_to_function_name(adr, buf, buflen, &amp;offset)) {
 480       st-&gt;print(PTR_FORMAT &quot; = %s&quot;,  p2i(adr), buf);
 481       if (offset != 0) {
 482         st-&gt;print(&quot;+%d&quot;, offset);
 483       }
 484       return;
 485     }
 486   }
 487 
 488   // Fall through to a simple (hexadecimal) numeral.
 489   st-&gt;print(PTR_FORMAT, p2i(adr));
 490 }
 491 
 492 void decode_env::print_insn_labels() {
<span class="line-modified"> 493   address p = cur_insn();</span>
<span class="line-modified"> 494   outputStream* st = output();</span>
<span class="line-modified"> 495   CodeBlob* cb = _code;</span>
<span class="line-removed"> 496   if (cb != NULL) {</span>
<span class="line-removed"> 497     cb-&gt;print_block_comment(st, p);</span>
<span class="line-removed"> 498   }</span>
<span class="line-removed"> 499   _strings.print_block_comment(st, (intptr_t)(p - _start + _offset));</span>
<span class="line-removed"> 500   if (_print_pc) {</span>
<span class="line-removed"> 501     st-&gt;print(&quot;  &quot; PTR_FORMAT &quot;: &quot;, p2i(p));</span>
<span class="line-removed"> 502   }</span>
<span class="line-removed"> 503 }</span>
 504 
<span class="line-modified"> 505 void decode_env::print_insn_bytes(address pc, address pc_limit) {</span>
<span class="line-modified"> 506   outputStream* st = output();</span>
<span class="line-modified"> 507   size_t incr = 1;</span>
<span class="line-modified"> 508   size_t perline = _bytes_per_line;</span>
<span class="line-modified"> 509   if ((size_t) Disassembler::pd_instruction_alignment() &gt;= sizeof(int)</span>
<span class="line-modified"> 510       &amp;&amp; !((uintptr_t)pc % sizeof(int))</span>
<span class="line-modified"> 511       &amp;&amp; !((uintptr_t)pc_limit % sizeof(int))) {</span>
<span class="line-modified"> 512     incr = sizeof(int);</span>
<span class="line-modified"> 513     if (perline % incr)  perline += incr - (perline % incr);</span>
<span class="line-modified"> 514   }</span>
<span class="line-modified"> 515   while (pc &lt; pc_limit) {</span>
<span class="line-removed"> 516     // tab to the desired column:</span>
<span class="line-removed"> 517     st-&gt;move_to(COMMENT_COLUMN);</span>
<span class="line-removed"> 518     address pc0 = pc;</span>
<span class="line-removed"> 519     address pc1 = pc + perline;</span>
<span class="line-removed"> 520     if (pc1 &gt; pc_limit)  pc1 = pc_limit;</span>
<span class="line-removed"> 521     for (; pc &lt; pc1; pc += incr) {</span>
<span class="line-removed"> 522       if (pc == pc0) {</span>
<span class="line-removed"> 523         st-&gt;print(BYTES_COMMENT);</span>
<span class="line-removed"> 524       } else if ((uint)(pc - pc0) % sizeof(int) == 0) {</span>
<span class="line-removed"> 525         st-&gt;print(&quot; &quot;);         // put out a space on word boundaries</span>
<span class="line-removed"> 526       }</span>
<span class="line-removed"> 527       if (incr == sizeof(int)) {</span>
<span class="line-removed"> 528         st-&gt;print(&quot;%08x&quot;, *(int*)pc);</span>
<span class="line-removed"> 529       } else {</span>
<span class="line-removed"> 530         st-&gt;print(&quot;%02x&quot;, (*pc)&amp;0xFF);</span>
<span class="line-removed"> 531       }</span>
 532     }
<span class="line-modified"> 533     st-&gt;cr();</span>
 534   }
 535 }
 536 
<span class="line-modified"> 537 </span>
<span class="line-modified"> 538 static void* event_to_env(void* env_pv, const char* event, void* arg) {</span>
<span class="line-modified"> 539   decode_env* env = (decode_env*) env_pv;</span>
<span class="line-modified"> 540   return env-&gt;handle_event(event, (address) arg);</span>

 541 }
 542 
 543 ATTRIBUTE_PRINTF(2, 3)
 544 static int printf_to_env(void* env_pv, const char* format, ...) {
 545   decode_env* env = (decode_env*) env_pv;
 546   outputStream* st = env-&gt;output();
 547   size_t flen = strlen(format);
 548   const char* raw = NULL;
 549   if (flen == 0)  return 0;
 550   if (flen == 1 &amp;&amp; format[0] == &#39;\n&#39;) { st-&gt;bol(); return 1; }
 551   if (flen &lt; 2 ||
 552       strchr(format, &#39;%&#39;) == NULL) {
 553     raw = format;
 554   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;%&#39; &amp;&amp;
 555              strchr(format+2, &#39;%&#39;) == NULL) {
 556     // happens a lot on machines with names like %foo
 557     flen--;
 558     raw = format+1;
 559   }
 560   if (raw != NULL) {
 561     st-&gt;print_raw(raw, (int) flen);
 562     return (int) flen;
 563   }
 564   va_list ap;
 565   va_start(ap, format);
 566   julong cnt0 = st-&gt;count();
 567   st-&gt;vprint(format, ap);
 568   julong cnt1 = st-&gt;count();
 569   va_end(ap);
 570   return (int)(cnt1 - cnt0);
 571 }
 572 
<span class="line-modified"> 573 address decode_env::decode_instructions(address start, address end) {</span>
<span class="line-modified"> 574   _start = start; _end = end;</span>
<span class="line-modified"> 575 </span>
<span class="line-modified"> 576   assert(((((intptr_t)start | (intptr_t)end) % Disassembler::pd_instruction_alignment()) == 0), &quot;misaligned insn addr&quot;);</span>
<span class="line-modified"> 577 </span>
<span class="line-modified"> 578   const int show_bytes = false; // for disassembler debugging</span>








 579 
<span class="line-modified"> 580   //_version = Disassembler::pd_cpu_version();</span>





 581 
<span class="line-modified"> 582   if (!Disassembler::can_decode()) {</span>


 583     return NULL;
 584   }
 585 
 586   // decode a series of instructions and return the end of the last instruction
 587 
 588   if (_print_raw) {
 589     // Print whatever the library wants to print, w/o fancy callbacks.
 590     // This is mainly for debugging the library itself.
 591     FILE* out = stdout;
 592     FILE* xmlout = (_print_raw &gt; 1 ? out : NULL);
 593     return use_new_version ?
 594       (address)
 595       (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
 596                                                     start, end - start,
 597                                                     NULL, (void*) xmlout,
 598                                                     NULL, (void*) out,
 599                                                     options(), 0/*nice new line*/)
 600       :
 601       (address)
 602       (*Disassembler::_decode_instructions)(start, end,
 603                                             NULL, (void*) xmlout,
 604                                             NULL, (void*) out,
 605                                             options());
 606   }
 607 
 608   return use_new_version ?
 609     (address)
 610     (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
 611                                                   start, end - start,
 612                                                   &amp;event_to_env,  (void*) this,
 613                                                   &amp;printf_to_env, (void*) this,
 614                                                   options(), 0/*nice new line*/)
 615     :
 616     (address)
 617     (*Disassembler::_decode_instructions)(start, end,
 618                                           &amp;event_to_env,  (void*) this,
 619                                           &amp;printf_to_env, (void*) this,
 620                                           options());
 621 }
 622 





 623 
<span class="line-modified"> 624 void Disassembler::decode(CodeBlob* cb, outputStream* st) {</span>
<span class="line-modified"> 625   ttyLocker ttyl;</span>
<span class="line-modified"> 626   if (!load_library())  return;</span>






























































































































































 627   if (cb-&gt;is_nmethod()) {
<span class="line-modified"> 628     decode((nmethod*)cb, st);</span>


 629     return;
 630   }

 631   decode_env env(cb, st);
<span class="line-modified"> 632   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
 633   if (cb-&gt;is_aot()) {
 634     env.output()-&gt;print(&quot;A &quot;);
 635     if (cb-&gt;is_compiled()) {
 636       CompiledMethod* cm = (CompiledMethod*)cb;
 637       env.output()-&gt;print(&quot;%d &quot;,cm-&gt;compile_id());
 638       cm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());
 639       env.output()-&gt;print(&quot;.&quot;);
 640       cm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());
 641       cm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
 642     } else {
 643       env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
 644     }
 645   } else {
<span class="line-modified"> 646     env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());</span>



 647   }
<span class="line-modified"> 648   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())) * sizeof(unsigned char*));</span>
<span class="line-removed"> 649   env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());</span>
<span class="line-removed"> 650 }</span>
 651 
<span class="line-modified"> 652 void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c,</span>
<span class="line-modified"> 653                           ptrdiff_t offset) {</span>
<span class="line-modified"> 654   ttyLocker ttyl;</span>
<span class="line-modified"> 655   if (!load_library())  return;</span>
<span class="line-modified"> 656   decode_env env(CodeCache::find_blob_unsafe(start), st, c, offset);</span>
<span class="line-modified"> 657   env.decode_instructions(start, end);</span>

 658 }
 659 
<span class="line-modified"> 660 void Disassembler::decode(nmethod* nm, outputStream* st) {</span>




 661   ttyLocker ttyl;
<span class="line-removed"> 662   if (!load_library())  return;</span>
<span class="line-removed"> 663   decode_env env(nm, st);</span>
<span class="line-removed"> 664   env.output()-&gt;print_cr(&quot;----------------------------------------------------------------------&quot;);</span>
<span class="line-removed"> 665 </span>
<span class="line-removed"> 666   unsigned char* p   = nm-&gt;code_begin();</span>
<span class="line-removed"> 667   unsigned char* end = nm-&gt;code_end();</span>
 668 
<span class="line-modified"> 669   nm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified"> 670   env.output()-&gt;print(&quot;.&quot;);</span>
<span class="line-modified"> 671   nm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified"> 672   nm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());</span>
<span class="line-modified"> 673 #if INCLUDE_JVMCI</span>
<span class="line-modified"> 674   {</span>
<span class="line-modified"> 675     char buffer[O_BUFLEN];</span>
<span class="line-modified"> 676     char* jvmciName = nm-&gt;jvmci_installed_code_name(buffer, O_BUFLEN);</span>
<span class="line-modified"> 677     if (jvmciName != NULL) {</span>
<span class="line-removed"> 678       env.output()-&gt;print(&quot; (%s)&quot;, jvmciName);</span>
<span class="line-removed"> 679     }</span>
 680   }

 681 #endif
<span class="line-modified"> 682   env.output()-&gt;print_cr(&quot;  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(p), p2i(end), ((jlong)(end - p)));</span>
<span class="line-modified"> 683 </span>
<span class="line-modified"> 684   // Print constant table.</span>
<span class="line-modified"> 685   if (nm-&gt;consts_size() &gt; 0) {</span>
<span class="line-modified"> 686     nm-&gt;print_nmethod_labels(env.output(), nm-&gt;consts_begin());</span>
<span class="line-modified"> 687     int offset = 0;</span>
<span class="line-modified"> 688     for (address p = nm-&gt;consts_begin(); p &lt; nm-&gt;consts_end(); p += 4, offset += 4) {</span>
<span class="line-modified"> 689       if ((offset % 8) == 0) {</span>
<span class="line-modified"> 690         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT &quot;   &quot; PTR64_FORMAT, p2i(p), offset, *((int32_t*) p), *((int64_t*) p));</span>
<span class="line-modified"> 691       } else {</span>
<span class="line-removed"> 692         env.output()-&gt;print_cr(&quot;  &quot; PTR_FORMAT &quot; (offset: %4d): &quot; PTR32_FORMAT,                    p2i(p), offset, *((int32_t*) p));</span>
<span class="line-removed"> 693       }</span>
 694     }

 695   }
 696 
<span class="line-modified"> 697   env.decode_instructions(p, end);</span>






















 698 }
 699 
 700 // To prevent excessive code expansion in the interpreter generator, we
 701 // do not inline this function into Disassembler::hook().
 702 void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {
 703   decode_env::hook(file, line, masm-&gt;code_section()-&gt;end());
 704 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;asm/assembler.inline.hpp&quot;</span>
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;ci/ciUtilities.hpp&quot;
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;code/codeCache.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;gc/shared/cardTable.hpp&quot;
  33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  34 #include &quot;gc/shared/collectedHeap.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  36 #include &quot;memory/universe.hpp&quot;</span>
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/os.inline.hpp&quot;
  40 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;utilities/resourceHash.hpp&quot;
  43 #include CPU_HEADER(depChecker)
  44 
  45 void*       Disassembler::_library               = NULL;
  46 bool        Disassembler::_tried_to_load_library = false;
<span class="line-added">  47 bool        Disassembler::_library_usable        = false;</span>
  48 
  49 // This routine is in the shared library:
  50 Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;
  51 Disassembler::decode_func Disassembler::_decode_instructions = NULL;
  52 
  53 static const char hsdis_library_name[] = &quot;hsdis-&quot; HOTSPOT_LIB_ARCH;
  54 static const char decode_instructions_virtual_name[] = &quot;decode_instructions_virtual&quot;;
  55 static const char decode_instructions_name[] = &quot;decode_instructions&quot;;
  56 static bool use_new_version = true;
  57 #define COMMENT_COLUMN  52 LP64_ONLY(+8) /*could be an option*/
  58 #define BYTES_COMMENT   &quot;;...&quot;  /* funky byte display comment */
  59 
































































































  60 class decode_env {
  61  private:
<span class="line-modified">  62   outputStream* _output;      // where the disassembly is directed to</span>
<span class="line-modified">  63   CodeBuffer*   _codeBuffer;  // != NULL only when decoding a CodeBuffer</span>
<span class="line-added">  64   CodeBlob*     _codeBlob;    // != NULL only when decoding a CodeBlob</span>
<span class="line-added">  65   nmethod*      _nm;          // != NULL only when decoding a nmethod</span>
  66   CodeStrings   _strings;
<span class="line-modified">  67   address       _start;       // != NULL when decoding a range of unknown type</span>
<span class="line-modified">  68   address       _end;         // != NULL when decoding a range of unknown type</span>

  69 
  70   char          _option_buf[512];
  71   char          _print_raw;
<span class="line-modified">  72   address       _cur_insn;        // address of instruction currently being decoded</span>
<span class="line-modified">  73   int           _bytes_per_line;  // arch-specific formatting option</span>
<span class="line-modified">  74   int           _pre_decode_alignment;</span>
<span class="line-modified">  75   int           _post_decode_alignment;</span>
  76   bool          _print_file_name;
<span class="line-added">  77   bool          _print_help;</span>
<span class="line-added">  78   bool          _helpPrinted;</span>
<span class="line-added">  79   static bool   _optionsParsed;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81   enum {</span>
<span class="line-added">  82     tabspacing = 8</span>
<span class="line-added">  83   };</span>
  84 
<span class="line-added">  85   // Check if the event matches the expected tag</span>
<span class="line-added">  86   // The tag must be a substring of the event, and</span>
<span class="line-added">  87   // the tag must be a token in the event, i.e. separated by delimiters</span>
  88   static bool match(const char* event, const char* tag) {
<span class="line-modified">  89     size_t eventlen = strlen(event);</span>
<span class="line-modified">  90     size_t taglen   = strlen(tag);</span>
<span class="line-added">  91     if (eventlen &lt; taglen)  // size mismatch</span>
<span class="line-added">  92       return false;</span>
<span class="line-added">  93     if (strncmp(event, tag, taglen) != 0)  // string mismatch</span>
  94       return false;
  95     char delim = event[taglen];
  96     return delim == &#39;\0&#39; || delim == &#39; &#39; || delim == &#39;/&#39; || delim == &#39;=&#39;;
  97   }
  98 
<span class="line-added">  99   // Merge new option string with previously recorded options</span>
 100   void collect_options(const char* p) {
 101     if (p == NULL || p[0] == &#39;\0&#39;)  return;
 102     size_t opt_so_far = strlen(_option_buf);
 103     if (opt_so_far + 1 + strlen(p) + 1 &gt; sizeof(_option_buf))  return;
 104     char* fillp = &amp;_option_buf[opt_so_far];
 105     if (opt_so_far &gt; 0) *fillp++ = &#39;,&#39;;
 106     strcat(fillp, p);
 107     // replace white space by commas:
 108     char* q = fillp;
 109     while ((q = strpbrk(q, &quot; \t\n&quot;)) != NULL)
 110       *q++ = &#39;,&#39;;


 111   }
 112 
<span class="line-added"> 113   void process_options(outputStream* ost);</span>
<span class="line-added"> 114 </span>
 115   void print_insn_labels();
<span class="line-modified"> 116   void print_insn_prefix();</span>
 117   void print_address(address value);
 118 
<span class="line-added"> 119   // Properly initializes _start/_end. Overwritten too often if</span>
<span class="line-added"> 120   // printing of instructions is called for each instruction.</span>
<span class="line-added"> 121   void set_start(address s)   { _start = s; }</span>
<span class="line-added"> 122   void set_end  (address e)   { _end = e; }</span>
<span class="line-added"> 123   void set_nm   (nmethod* nm) { _nm = nm; }</span>
<span class="line-added"> 124   void set_output(outputStream* st) { _output = st; }</span>
<span class="line-added"> 125 </span>
<span class="line-added"> 126 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added"> 127   // The disassembler library (sometimes) uses tabs to nicely align the instruction operands.</span>
<span class="line-added"> 128   // Depending on the mnemonic length and the column position where the</span>
<span class="line-added"> 129   // mnemonic is printed, alignment may turn out to be not so nice.</span>
<span class="line-added"> 130   // To improve, we assume 8-character tab spacing and left-align the mnemonic on a tab position.</span>
<span class="line-added"> 131   // Instruction comments are aligned 4 tab positions to the right of the mnemonic.</span>
<span class="line-added"> 132   void calculate_alignment() {</span>
<span class="line-added"> 133     _pre_decode_alignment  = ((output()-&gt;position()+tabspacing-1)/tabspacing)*tabspacing;</span>
<span class="line-added"> 134     _post_decode_alignment = _pre_decode_alignment + 4*tabspacing;</span>
<span class="line-added"> 135   }</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137   void start_insn(address pc) {</span>
<span class="line-added"> 138     _cur_insn = pc;</span>
<span class="line-added"> 139     output()-&gt;bol();</span>
<span class="line-added"> 140     print_insn_labels();</span>
<span class="line-added"> 141     print_insn_prefix();</span>
<span class="line-added"> 142   }</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144   void end_insn(address pc) {</span>
<span class="line-added"> 145     address pc0 = cur_insn();</span>
<span class="line-added"> 146     outputStream* st = output();</span>
<span class="line-added"> 147 </span>
<span class="line-added"> 148     if (AbstractDisassembler::show_comment()) {</span>
<span class="line-added"> 149       if ((_nm != NULL) &amp;&amp; _nm-&gt;has_code_comment(pc0, pc)) {</span>
<span class="line-added"> 150         _nm-&gt;print_code_comment_on</span>
<span class="line-added"> 151                (st,</span>
<span class="line-added"> 152                 _post_decode_alignment ? _post_decode_alignment : COMMENT_COLUMN,</span>
<span class="line-added"> 153                 pc0, pc);</span>
<span class="line-added"> 154         // this calls reloc_string_for which calls oop::print_value_on</span>
<span class="line-added"> 155       }</span>
<span class="line-added"> 156       print_hook_comments(pc0, _nm != NULL);</span>
<span class="line-added"> 157     }</span>
<span class="line-added"> 158     Disassembler::annotate(pc0, output());</span>
<span class="line-added"> 159     // follow each complete insn by a nice newline</span>
<span class="line-added"> 160     st-&gt;bol();</span>
<span class="line-added"> 161   }</span>
<span class="line-added"> 162 #endif</span>
<span class="line-added"> 163 </span>
 164   struct SourceFileInfo {
 165     struct Link : public CHeapObj&lt;mtCode&gt; {
 166       const char* file;
 167       int line;
 168       Link* next;
 169       Link(const char* f, int l) : file(f), line(l), next(NULL) {}
 170     };
 171     Link *head, *tail;
 172 
 173     static unsigned hash(const address&amp; a) {
 174       return primitive_hash&lt;address&gt;(a);
 175     }
 176     static bool equals(const address&amp; a0, const address&amp; a1) {
 177       return primitive_equals&lt;address&gt;(a0, a1);
 178     }
 179     void append(const char* file, int line) {
 180       if (tail != NULL &amp;&amp; tail-&gt;file == file &amp;&amp; tail-&gt;line == line) {
 181         // Don&#39;t print duplicated lines at the same address. This could happen with C
 182         // macros that end up having multiple &quot;__&quot; tokens on the same __LINE__.
 183         return;
</pre>
<hr />
<pre>
 190         tail = link;
 191       }
 192     }
 193     SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {
 194       append(file, line);
 195     }
 196   };
 197 
 198   typedef ResourceHashtable&lt;
 199       address, SourceFileInfo,
 200       SourceFileInfo::hash,
 201       SourceFileInfo::equals,
 202       15889,      // prime number
 203       ResourceObj::C_HEAP&gt; SourceFileInfoTable;
 204 
 205   static SourceFileInfoTable _src_table;
 206   static const char* _cached_src;
 207   static GrowableArray&lt;const char*&gt;* _cached_src_lines;
 208 
 209  public:
<span class="line-modified"> 210   decode_env(CodeBuffer* code, outputStream* output);</span>
<span class="line-modified"> 211   decode_env(CodeBlob*   code, outputStream* output, CodeStrings c = CodeStrings() /* , ptrdiff_t offset */);</span>
<span class="line-added"> 212   decode_env(nmethod*    code, outputStream* output, CodeStrings c = CodeStrings());</span>
<span class="line-added"> 213   // Constructor for a &#39;decode_env&#39; to decode an arbitrary</span>
<span class="line-added"> 214   // piece of memory, hopefully containing code.</span>
<span class="line-added"> 215   decode_env(address start, address end, outputStream* output);</span>
 216 
<span class="line-modified"> 217   // Add &#39;original_start&#39; argument which is the the original address</span>
<span class="line-modified"> 218   // the instructions were located at (if this is not equal to &#39;start&#39;).</span>
<span class="line-modified"> 219   address decode_instructions(address start, address end, address original_start = NULL);</span>


















 220 
 221   address handle_event(const char* event, address arg);
 222 
<span class="line-modified"> 223   outputStream* output()   { return _output; }</span>
<span class="line-modified"> 224   address       cur_insn() { return _cur_insn; }</span>
<span class="line-modified"> 225   const char*   options()  { return _option_buf; }</span>
<span class="line-modified"> 226   static void   hook(const char* file, int line, address pc);</span>
 227   void print_hook_comments(address pc, bool newline);
 228 };
 229 
<span class="line-added"> 230 bool decode_env::_optionsParsed = false;</span>
<span class="line-added"> 231 </span>
 232 decode_env::SourceFileInfoTable decode_env::_src_table;
 233 const char* decode_env::_cached_src = NULL;
 234 GrowableArray&lt;const char*&gt;* decode_env::_cached_src_lines = NULL;
 235 
 236 void decode_env::hook(const char* file, int line, address pc) {
 237   // For simplication, we never free from this table. It&#39;s really not
 238   // necessary as we add to the table only when PrintInterpreter is true,
 239   // which means we are debugging the VM and a little bit of extra
 240   // memory usage doesn&#39;t matter.
 241   SourceFileInfo* found = _src_table.get(pc);
 242   if (found != NULL) {
 243     found-&gt;append(file, line);
 244   } else {
 245     SourceFileInfo sfi(file, line);
 246     _src_table.put(pc, sfi); // sfi is copied by value
 247   }
 248 }
 249 
 250 void decode_env::print_hook_comments(address pc, bool newline) {
 251   SourceFileInfo* found = _src_table.get(pc);
</pre>
<hr />
<pre>
 298         st-&gt;print(&quot;;;@FILE: %s&quot;, file);
 299         newline = true;
 300       }
 301 
 302       int index = line - 1; // 1-based line number -&gt; 0-based index.
 303       if (index &gt;= _cached_src_lines-&gt;length()) {
 304         // This could happen if source file is mismatched.
 305       } else {
 306         const char* source_line = _cached_src_lines-&gt;at(index);
 307         if (newline) {
 308           st-&gt;cr();
 309         }
 310         st-&gt;move_to(COMMENT_COLUMN);
 311         st-&gt;print(&quot;;;%5d: %s&quot;, line, source_line);
 312         newline = true;
 313       }
 314     }
 315   }
 316 }
 317 
<span class="line-modified"> 318 decode_env::decode_env(CodeBuffer* code, outputStream* output) :</span>
<span class="line-modified"> 319   _output(output ? output : tty),</span>
<span class="line-modified"> 320   _codeBuffer(code),</span>
<span class="line-modified"> 321   _codeBlob(NULL),</span>
<span class="line-modified"> 322   _nm(NULL),</span>
<span class="line-modified"> 323   _strings(),</span>
<span class="line-modified"> 324   _start(NULL),</span>
<span class="line-added"> 325   _end(NULL),</span>
<span class="line-added"> 326   _option_buf(),</span>
<span class="line-added"> 327   _print_raw(0),</span>
<span class="line-added"> 328   _cur_insn(NULL),</span>
<span class="line-added"> 329   _bytes_per_line(0),</span>
<span class="line-added"> 330   _pre_decode_alignment(0),</span>
<span class="line-added"> 331   _post_decode_alignment(0),</span>
<span class="line-added"> 332   _print_file_name(false),</span>
<span class="line-added"> 333   _print_help(false),</span>
<span class="line-added"> 334   _helpPrinted(false) {</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="line-added"> 337   process_options(_output);</span>
<span class="line-added"> 338 }</span>
<span class="line-added"> 339 </span>
<span class="line-added"> 340 decode_env::decode_env(CodeBlob* code, outputStream* output, CodeStrings c) :</span>
<span class="line-added"> 341   _output(output ? output : tty),</span>
<span class="line-added"> 342   _codeBuffer(NULL),</span>
<span class="line-added"> 343   _codeBlob(code),</span>
<span class="line-added"> 344   _nm(_codeBlob != NULL &amp;&amp; _codeBlob-&gt;is_nmethod() ? (nmethod*) code : NULL),</span>
<span class="line-added"> 345   _strings(),</span>
<span class="line-added"> 346   _start(NULL),</span>
<span class="line-added"> 347   _end(NULL),</span>
<span class="line-added"> 348   _option_buf(),</span>
<span class="line-added"> 349   _print_raw(0),</span>
<span class="line-added"> 350   _cur_insn(NULL),</span>
<span class="line-added"> 351   _bytes_per_line(0),</span>
<span class="line-added"> 352   _pre_decode_alignment(0),</span>
<span class="line-added"> 353   _post_decode_alignment(0),</span>
<span class="line-added"> 354   _print_file_name(false),</span>
<span class="line-added"> 355   _print_help(false),</span>
<span class="line-added"> 356   _helpPrinted(false) {</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358   memset(_option_buf, 0, sizeof(_option_buf));</span>
 359   _strings.copy(c);
<span class="line-modified"> 360   process_options(_output);</span>
<span class="line-added"> 361 }</span>
 362 
<span class="line-modified"> 363 decode_env::decode_env(nmethod* code, outputStream* output, CodeStrings c) :</span>
<span class="line-modified"> 364   _output(output ? output : tty),</span>
<span class="line-modified"> 365   _codeBuffer(NULL),</span>
<span class="line-modified"> 366   _codeBlob(NULL),</span>
<span class="line-modified"> 367   _nm(code),</span>
<span class="line-added"> 368   _strings(),</span>
<span class="line-added"> 369   _start(_nm-&gt;code_begin()),</span>
<span class="line-added"> 370   _end(_nm-&gt;code_end()),</span>
<span class="line-added"> 371   _option_buf(),</span>
<span class="line-added"> 372   _print_raw(0),</span>
<span class="line-added"> 373   _cur_insn(NULL),</span>
<span class="line-added"> 374   _bytes_per_line(0),</span>
<span class="line-added"> 375   _pre_decode_alignment(0),</span>
<span class="line-added"> 376   _post_decode_alignment(0),</span>
<span class="line-added"> 377   _print_file_name(false),</span>
<span class="line-added"> 378   _print_help(false),</span>
<span class="line-added"> 379   _helpPrinted(false) {</span>
<span class="line-added"> 380 </span>
<span class="line-added"> 381   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="line-added"> 382   _strings.copy(c);</span>
<span class="line-added"> 383   process_options(_output);</span>
<span class="line-added"> 384 }</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386 // Constructor for a &#39;decode_env&#39; to decode a memory range [start, end)</span>
<span class="line-added"> 387 // of unknown origin, assuming it contains code.</span>
<span class="line-added"> 388 decode_env::decode_env(address start, address end, outputStream* output) :</span>
<span class="line-added"> 389   _output(output ? output : tty),</span>
<span class="line-added"> 390   _codeBuffer(NULL),</span>
<span class="line-added"> 391   _codeBlob(NULL),</span>
<span class="line-added"> 392   _nm(NULL),</span>
<span class="line-added"> 393   _strings(),</span>
<span class="line-added"> 394   _start(start),</span>
<span class="line-added"> 395   _end(end),</span>
<span class="line-added"> 396   _option_buf(),</span>
<span class="line-added"> 397   _print_raw(0),</span>
<span class="line-added"> 398   _cur_insn(NULL),</span>
<span class="line-added"> 399   _bytes_per_line(0),</span>
<span class="line-added"> 400   _pre_decode_alignment(0),</span>
<span class="line-added"> 401   _post_decode_alignment(0),</span>
<span class="line-added"> 402   _print_file_name(false),</span>
<span class="line-added"> 403   _print_help(false),</span>
<span class="line-added"> 404   _helpPrinted(false) {</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406   assert(start &lt; end, &quot;Range must have a positive size, [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;).&quot;, p2i(start), p2i(end));</span>
<span class="line-added"> 407   memset(_option_buf, 0, sizeof(_option_buf));</span>
<span class="line-added"> 408   process_options(_output);</span>
<span class="line-added"> 409 }</span>
 410 
<span class="line-modified"> 411 void decode_env::process_options(outputStream* ost) {</span>
<span class="line-added"> 412   // by default, output pc but not bytes:</span>
<span class="line-added"> 413   _print_help      = false;</span>
<span class="line-added"> 414   _bytes_per_line  = Disassembler::pd_instruction_alignment();</span>
<span class="line-added"> 415   _print_file_name = true;</span>
<span class="line-added"> 416 </span>
<span class="line-added"> 417   // parse the global option string</span>
<span class="line-added"> 418   // We need to fill the options buffer for each newly created</span>
<span class="line-added"> 419   // decode_env instance. The hsdis_* library looks for options</span>
<span class="line-added"> 420   // in that buffer.</span>
 421   collect_options(Disassembler::pd_cpu_opts());
 422   collect_options(PrintAssemblyOptions);
 423 
<span class="line-modified"> 424   if (strstr(options(), &quot;print-raw&quot;)) {</span>
<span class="line-modified"> 425     _print_raw = (strstr(options(), &quot;xml&quot;) ? 2 : 1);</span>





 426   }
<span class="line-added"> 427 </span>
<span class="line-added"> 428   if (_optionsParsed) return;  // parse only once</span>
<span class="line-added"> 429 </span>
 430   if (strstr(options(), &quot;help&quot;)) {
<span class="line-modified"> 431     _print_help = true;</span>
<span class="line-modified"> 432   }</span>
<span class="line-modified"> 433   if (strstr(options(), &quot;align-instr&quot;)) {</span>
<span class="line-modified"> 434     AbstractDisassembler::toggle_align_instr();</span>
<span class="line-modified"> 435   }</span>
<span class="line-modified"> 436   if (strstr(options(), &quot;show-pc&quot;)) {</span>
<span class="line-added"> 437     AbstractDisassembler::toggle_show_pc();</span>
<span class="line-added"> 438   }</span>
<span class="line-added"> 439   if (strstr(options(), &quot;show-offset&quot;)) {</span>
<span class="line-added"> 440     AbstractDisassembler::toggle_show_offset();</span>
<span class="line-added"> 441   }</span>
<span class="line-added"> 442   if (strstr(options(), &quot;show-bytes&quot;)) {</span>
<span class="line-added"> 443     AbstractDisassembler::toggle_show_bytes();</span>
<span class="line-added"> 444   }</span>
<span class="line-added"> 445   if (strstr(options(), &quot;show-data-hex&quot;)) {</span>
<span class="line-added"> 446     AbstractDisassembler::toggle_show_data_hex();</span>
<span class="line-added"> 447   }</span>
<span class="line-added"> 448   if (strstr(options(), &quot;show-data-int&quot;)) {</span>
<span class="line-added"> 449     AbstractDisassembler::toggle_show_data_int();</span>
<span class="line-added"> 450   }</span>
<span class="line-added"> 451   if (strstr(options(), &quot;show-data-float&quot;)) {</span>
<span class="line-added"> 452     AbstractDisassembler::toggle_show_data_float();</span>
<span class="line-added"> 453   }</span>
<span class="line-added"> 454   if (strstr(options(), &quot;show-structs&quot;)) {</span>
<span class="line-added"> 455     AbstractDisassembler::toggle_show_structs();</span>
<span class="line-added"> 456   }</span>
<span class="line-added"> 457   if (strstr(options(), &quot;show-comment&quot;)) {</span>
<span class="line-added"> 458     AbstractDisassembler::toggle_show_comment();</span>
<span class="line-added"> 459   }</span>
<span class="line-added"> 460   if (strstr(options(), &quot;show-block-comment&quot;)) {</span>
<span class="line-added"> 461     AbstractDisassembler::toggle_show_block_comment();</span>
<span class="line-added"> 462   }</span>
<span class="line-added"> 463   _optionsParsed = true;</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465   if (_print_help &amp;&amp; ! _helpPrinted) {</span>
<span class="line-added"> 466     _helpPrinted = true;</span>
<span class="line-added"> 467     ost-&gt;print_cr(&quot;PrintAssemblyOptions help:&quot;);</span>
<span class="line-added"> 468     ost-&gt;print_cr(&quot;  print-raw       test plugin by requesting raw output&quot;);</span>
<span class="line-added"> 469     ost-&gt;print_cr(&quot;  print-raw-xml   test plugin by requesting raw xml&quot;);</span>
<span class="line-added"> 470     ost-&gt;cr();</span>
<span class="line-added"> 471     ost-&gt;print_cr(&quot;  show-pc            toggle printing current pc,        currently %s&quot;, AbstractDisassembler::show_pc()            ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 472     ost-&gt;print_cr(&quot;  show-offset        toggle printing current offset,    currently %s&quot;, AbstractDisassembler::show_offset()        ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 473     ost-&gt;print_cr(&quot;  show-bytes         toggle printing instruction bytes, currently %s&quot;, AbstractDisassembler::show_bytes()         ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 474     ost-&gt;print_cr(&quot;  show-data-hex      toggle formatting data as hex,     currently %s&quot;, AbstractDisassembler::show_data_hex()      ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 475     ost-&gt;print_cr(&quot;  show-data-int      toggle formatting data as int,     currently %s&quot;, AbstractDisassembler::show_data_int()      ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 476     ost-&gt;print_cr(&quot;  show-data-float    toggle formatting data as float,   currently %s&quot;, AbstractDisassembler::show_data_float()    ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 477     ost-&gt;print_cr(&quot;  show-structs       toggle compiler data structures,   currently %s&quot;, AbstractDisassembler::show_structs()       ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 478     ost-&gt;print_cr(&quot;  show-comment       toggle instruction comments,       currently %s&quot;, AbstractDisassembler::show_comment()       ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 479     ost-&gt;print_cr(&quot;  show-block-comment toggle block comments,             currently %s&quot;, AbstractDisassembler::show_block_comment() ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 480     ost-&gt;print_cr(&quot;  align-instr        toggle instruction alignment,      currently %s&quot;, AbstractDisassembler::align_instr()        ? &quot;ON&quot; : &quot;OFF&quot;);</span>
<span class="line-added"> 481     ost-&gt;print_cr(&quot;combined options: %s&quot;, options());</span>
 482   }
 483 }
 484 
<span class="line-added"> 485 // Disassembly Event Handler.</span>
<span class="line-added"> 486 // This method receives events from the disassembler library hsdis</span>
<span class="line-added"> 487 // via event_to_env for each decoding step (installed by</span>
<span class="line-added"> 488 // Disassembler::decode_instructions(), replacing the default</span>
<span class="line-added"> 489 // callback method). This enables dumping additional info</span>
<span class="line-added"> 490 // and custom line formatting.</span>
<span class="line-added"> 491 // In a future extension, calling a custom decode method will be</span>
<span class="line-added"> 492 // supported. We can use such a method to decode instructions the</span>
<span class="line-added"> 493 // binutils decoder does not handle to our liking (suboptimal</span>
<span class="line-added"> 494 // formatting, incomplete information, ...).</span>
<span class="line-added"> 495 // Returns:</span>
<span class="line-added"> 496 // - NULL for all standard invocations. The function result is not</span>
<span class="line-added"> 497 //        examined (as of now, 20190409) by the hsdis decoder loop.</span>
<span class="line-added"> 498 // - next for &#39;insn0&#39; invocations.</span>
<span class="line-added"> 499 //        next == arg: the custom decoder didn&#39;t do anything.</span>
<span class="line-added"> 500 //        next &gt;  arg: the custom decoder did decode the instruction.</span>
<span class="line-added"> 501 //                     next points to the next undecoded instruction</span>
<span class="line-added"> 502 //                     (continuation point for decoder loop).</span>
<span class="line-added"> 503 //</span>
<span class="line-added"> 504 // &quot;Normal&quot; sequence of events:</span>
<span class="line-added"> 505 //  insns   - start of instruction stream decoding</span>
<span class="line-added"> 506 //  mach    - display architecture</span>
<span class="line-added"> 507 //  format  - display bytes-per-line</span>
<span class="line-added"> 508 //  for each instruction:</span>
<span class="line-added"> 509 //    insn    - start of instruction decoding</span>
<span class="line-added"> 510 //    insn0   - custom decoder invocation (if any)</span>
<span class="line-added"> 511 //    addr    - print address value</span>
<span class="line-added"> 512 //    /insn   - end of instruction decoding</span>
<span class="line-added"> 513 //  /insns  - premature end of instruction stream due to no progress</span>
<span class="line-added"> 514 //</span>
 515 address decode_env::handle_event(const char* event, address arg) {
<span class="line-modified"> 516 </span>
<span class="line-added"> 517 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519   //---&lt;  Event: end decoding loop (error, no progress)  &gt;---</span>
<span class="line-added"> 520   if (decode_env::match(event, &quot;/insns&quot;)) {</span>
<span class="line-added"> 521     // Nothing to be done here.</span>
<span class="line-added"> 522     return NULL;</span>
<span class="line-added"> 523   }</span>
<span class="line-added"> 524 </span>
<span class="line-added"> 525   //---&lt;  Event: start decoding loop  &gt;---</span>
<span class="line-added"> 526   if (decode_env::match(event, &quot;insns&quot;)) {</span>
<span class="line-added"> 527     // Nothing to be done here.</span>
<span class="line-added"> 528     return NULL;</span>
<span class="line-added"> 529   }</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531   //---&lt;  Event: finish decoding an instruction  &gt;---</span>
<span class="line-added"> 532   if (decode_env::match(event, &quot;/insn&quot;)) {</span>
<span class="line-added"> 533     output()-&gt;fill_to(_post_decode_alignment);</span>
<span class="line-added"> 534     end_insn(arg);</span>
<span class="line-added"> 535     return NULL;</span>
<span class="line-added"> 536   }</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538   //---&lt;  Event: start decoding an instruction  &gt;---</span>
<span class="line-added"> 539   if (decode_env::match(event, &quot;insn&quot;)) {</span>
 540     start_insn(arg);
 541   } else if (match(event, &quot;/insn&quot;)) {
 542     end_insn(arg);
 543   } else if (match(event, &quot;addr&quot;)) {
 544     if (arg != NULL) {
 545       print_address(arg);
 546       return arg;
 547     }
<span class="line-modified"> 548     calculate_alignment();</span>
<span class="line-modified"> 549     output()-&gt;fill_to(_pre_decode_alignment);</span>
<span class="line-modified"> 550     return NULL;</span>
<span class="line-modified"> 551   }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553   //---&lt;  Event: call custom decoder (platform specific)  &gt;---</span>
<span class="line-added"> 554   if (decode_env::match(event, &quot;insn0&quot;)) {</span>
<span class="line-added"> 555     return Disassembler::decode_instruction0(arg, output(), arg);</span>
<span class="line-added"> 556   }</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558   //---&lt;  Event: Print address  &gt;---</span>
<span class="line-added"> 559   if (decode_env::match(event, &quot;addr&quot;)) {</span>
<span class="line-added"> 560     print_address(arg);</span>
<span class="line-added"> 561     return arg;</span>
<span class="line-added"> 562   }</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564   //---&lt;  Event: mach (inform about machine architecture)  &gt;---</span>
<span class="line-added"> 565   // This event is problematic because it messes up the output.</span>
<span class="line-added"> 566   // The event is fired after the instruction address has already</span>
<span class="line-added"> 567   // been printed. The decoded instruction (event &quot;insn&quot;) is</span>
<span class="line-added"> 568   // printed afterwards. That doesn&#39;t look nice.</span>
<span class="line-added"> 569   if (decode_env::match(event, &quot;mach&quot;)) {</span>
<span class="line-added"> 570     guarantee(arg != NULL, &quot;event_to_env - arg must not be NULL for event &#39;mach&#39;&quot;);</span>
<span class="line-added"> 571     static char buffer[64] = { 0, };</span>
<span class="line-added"> 572     // Output suppressed because it messes up disassembly.</span>
<span class="line-added"> 573     // Only print this when the mach changes.</span>
<span class="line-added"> 574     if (false &amp;&amp; (strcmp(buffer, (const char*)arg) != 0 ||</span>
<span class="line-added"> 575                   strlen((const char*)arg) &gt; sizeof(buffer) - 1)) {</span>
 576       // Only print this when the mach changes
 577       strncpy(buffer, (const char*)arg, sizeof(buffer) - 1);
 578       buffer[sizeof(buffer) - 1] = &#39;\0&#39;;
<span class="line-modified"> 579       output()-&gt;print_cr(&quot;[Disassembling for mach=&#39;%s&#39;]&quot;, (const char*)arg);</span>
 580     }
<span class="line-modified"> 581     return NULL;</span>
<span class="line-added"> 582   }</span>
<span class="line-added"> 583 </span>
<span class="line-added"> 584   //---&lt;  Event: format bytes-per-line  &gt;---</span>
<span class="line-added"> 585   if (decode_env::match(event, &quot;format bytes-per-line&quot;)) {</span>
 586     _bytes_per_line = (int) (intptr_t) arg;
<span class="line-modified"> 587     return NULL;</span>

 588   }
<span class="line-added"> 589 #endif</span>
 590   return NULL;
 591 }
 592 
<span class="line-added"> 593 static void* event_to_env(void* env_pv, const char* event, void* arg) {</span>
<span class="line-added"> 594   decode_env* env = (decode_env*) env_pv;</span>
<span class="line-added"> 595   return env-&gt;handle_event(event, (address) arg);</span>
<span class="line-added"> 596 }</span>
<span class="line-added"> 597 </span>
 598 // called by the disassembler to print out jump targets and data addresses
 599 void decode_env::print_address(address adr) {
<span class="line-modified"> 600   outputStream* st = output();</span>
 601 
 602   if (adr == NULL) {
 603     st-&gt;print(&quot;NULL&quot;);
 604     return;
 605   }
 606 
 607   int small_num = (int)(intptr_t)adr;
 608   if ((intptr_t)adr == (intptr_t)small_num
 609       &amp;&amp; -1 &lt;= small_num &amp;&amp; small_num &lt;= 9) {
 610     st-&gt;print(&quot;%d&quot;, small_num);
 611     return;
 612   }
 613 
 614   if (Universe::is_fully_initialized()) {
 615     if (StubRoutines::contains(adr)) {
 616       StubCodeDesc* desc = StubCodeDesc::desc_for(adr);
 617       if (desc == NULL) {
 618         desc = StubCodeDesc::desc_for(adr + frame::pc_return_offset);
 619       }
 620       if (desc != NULL) {
</pre>
<hr />
<pre>
 625           st-&gt;print(&quot; &quot; PTR_FORMAT, p2i(adr));
 626         }
 627         return;
 628       }
 629       st-&gt;print(&quot;Stub::&lt;unknown&gt; &quot; PTR_FORMAT, p2i(adr));
 630       return;
 631     }
 632 
 633     BarrierSet* bs = BarrierSet::barrier_set();
 634     if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
 635         adr == ci_card_table_address_as&lt;address&gt;()) {
 636       st-&gt;print(&quot;word_map_base&quot;);
 637       if (WizardMode) st-&gt;print(&quot; &quot; INTPTR_FORMAT, p2i(adr));
 638       return;
 639     }
 640   }
 641 
 642   if (_nm == NULL) {
 643     // Don&#39;t do this for native methods, as the function name will be printed in
 644     // nmethod::reloc_string_for().
<span class="line-modified"> 645     // Allocate the buffer on the stack instead of as RESOURCE array.</span>
<span class="line-added"> 646     // In case we do DecodeErrorFile, Thread will not be initialized,</span>
<span class="line-added"> 647     // causing a &quot;assert(current != __null) failed&quot; failure.</span>
 648     const int buflen = 1024;
<span class="line-modified"> 649     char buf[buflen];</span>
 650     int offset;
 651     if (os::dll_address_to_function_name(adr, buf, buflen, &amp;offset)) {
 652       st-&gt;print(PTR_FORMAT &quot; = %s&quot;,  p2i(adr), buf);
 653       if (offset != 0) {
 654         st-&gt;print(&quot;+%d&quot;, offset);
 655       }
 656       return;
 657     }
 658   }
 659 
 660   // Fall through to a simple (hexadecimal) numeral.
 661   st-&gt;print(PTR_FORMAT, p2i(adr));
 662 }
 663 
 664 void decode_env::print_insn_labels() {
<span class="line-modified"> 665   if (AbstractDisassembler::show_block_comment()) {</span>
<span class="line-modified"> 666     address       p  = cur_insn();</span>
<span class="line-modified"> 667     outputStream* st = output();</span>








 668 
<span class="line-modified"> 669     //---&lt;  Block comments for nmethod  &gt;---</span>
<span class="line-modified"> 670     // Outputs a bol() before and a cr() after, but only if a comment is printed.</span>
<span class="line-modified"> 671     // Prints nmethod_section_label as well.</span>
<span class="line-modified"> 672     if (_nm != NULL) {</span>
<span class="line-modified"> 673       _nm-&gt;print_block_comment(st, p);</span>
<span class="line-modified"> 674     }</span>
<span class="line-modified"> 675     if (_codeBlob != NULL) {</span>
<span class="line-modified"> 676       _codeBlob-&gt;print_block_comment(st, p);</span>
<span class="line-modified"> 677     }</span>
<span class="line-modified"> 678     if (_codeBuffer != NULL) {</span>
<span class="line-modified"> 679       _codeBuffer-&gt;print_block_comment(st, p);</span>
















 680     }
<span class="line-modified"> 681     _strings.print_block_comment(st, (intptr_t)(p - _start));</span>
 682   }
 683 }
 684 
<span class="line-modified"> 685 void decode_env::print_insn_prefix() {</span>
<span class="line-modified"> 686   address       p  = cur_insn();</span>
<span class="line-modified"> 687   outputStream* st = output();</span>
<span class="line-modified"> 688   AbstractDisassembler::print_location(p, _start, _end, st, false, false);</span>
<span class="line-added"> 689   AbstractDisassembler::print_instruction(p, Assembler::instr_len(p), Assembler::instr_maxlen(), st, true, false);</span>
 690 }
 691 
 692 ATTRIBUTE_PRINTF(2, 3)
 693 static int printf_to_env(void* env_pv, const char* format, ...) {
 694   decode_env* env = (decode_env*) env_pv;
 695   outputStream* st = env-&gt;output();
 696   size_t flen = strlen(format);
 697   const char* raw = NULL;
 698   if (flen == 0)  return 0;
 699   if (flen == 1 &amp;&amp; format[0] == &#39;\n&#39;) { st-&gt;bol(); return 1; }
 700   if (flen &lt; 2 ||
 701       strchr(format, &#39;%&#39;) == NULL) {
 702     raw = format;
 703   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;%&#39; &amp;&amp;
 704              strchr(format+2, &#39;%&#39;) == NULL) {
 705     // happens a lot on machines with names like %foo
 706     flen--;
 707     raw = format+1;
 708   }
 709   if (raw != NULL) {
 710     st-&gt;print_raw(raw, (int) flen);
 711     return (int) flen;
 712   }
 713   va_list ap;
 714   va_start(ap, format);
 715   julong cnt0 = st-&gt;count();
 716   st-&gt;vprint(format, ap);
 717   julong cnt1 = st-&gt;count();
 718   va_end(ap);
 719   return (int)(cnt1 - cnt0);
 720 }
 721 
<span class="line-modified"> 722 // The &#39;original_start&#39; argument holds the the original address where</span>
<span class="line-modified"> 723 // the instructions were located in the originating system. If zero (NULL)</span>
<span class="line-modified"> 724 // is passed in, there is no original address.</span>
<span class="line-modified"> 725 address decode_env::decode_instructions(address start, address end, address original_start /* = 0*/) {</span>
<span class="line-modified"> 726   // CodeComment in Stubs.</span>
<span class="line-modified"> 727   // Properly initialize _start/_end. Overwritten too often if</span>
<span class="line-added"> 728   // printing of instructions is called for each instruction.</span>
<span class="line-added"> 729   assert((_start == NULL) || (start == NULL) || (_start == start), &quot;don&#39;t overwrite CTOR values&quot;);</span>
<span class="line-added"> 730   assert((_end   == NULL) || (end   == NULL) || (_end   == end  ), &quot;don&#39;t overwrite CTOR values&quot;);</span>
<span class="line-added"> 731   if (start != NULL) set_start(start);</span>
<span class="line-added"> 732   if (end   != NULL) set_end(end);</span>
<span class="line-added"> 733   if (original_start == NULL) {</span>
<span class="line-added"> 734     original_start = start;</span>
<span class="line-added"> 735   }</span>
 736 
<span class="line-modified"> 737   //---&lt;  Check (and correct) alignment  &gt;---</span>
<span class="line-added"> 738   // Don&#39;t check alignment of end, it is not aligned.</span>
<span class="line-added"> 739   if (((uint64_t)start &amp; ((uint64_t)Disassembler::pd_instruction_alignment() - 1)) != 0) {</span>
<span class="line-added"> 740     output()-&gt;print_cr(&quot;Decode range start:&quot; PTR_FORMAT &quot;: ... (unaligned)&quot;, p2i(start));</span>
<span class="line-added"> 741     start = (address)((uint64_t)start &amp; ~((uint64_t)Disassembler::pd_instruction_alignment() - 1));</span>
<span class="line-added"> 742   }</span>
 743 
<span class="line-modified"> 744   // Trying to decode instructions doesn&#39;t make sense if we</span>
<span class="line-added"> 745   // couldn&#39;t load the disassembler library.</span>
<span class="line-added"> 746   if (Disassembler::is_abstract()) {</span>
 747     return NULL;
 748   }
 749 
 750   // decode a series of instructions and return the end of the last instruction
 751 
 752   if (_print_raw) {
 753     // Print whatever the library wants to print, w/o fancy callbacks.
 754     // This is mainly for debugging the library itself.
 755     FILE* out = stdout;
 756     FILE* xmlout = (_print_raw &gt; 1 ? out : NULL);
 757     return use_new_version ?
 758       (address)
 759       (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
 760                                                     start, end - start,
 761                                                     NULL, (void*) xmlout,
 762                                                     NULL, (void*) out,
 763                                                     options(), 0/*nice new line*/)
 764       :
 765       (address)
 766       (*Disassembler::_decode_instructions)(start, end,
 767                                             NULL, (void*) xmlout,
 768                                             NULL, (void*) out,
 769                                             options());
 770   }
 771 
 772   return use_new_version ?
 773     (address)
 774     (*Disassembler::_decode_instructions_virtual)((uintptr_t)start, (uintptr_t)end,
 775                                                   start, end - start,
 776                                                   &amp;event_to_env,  (void*) this,
 777                                                   &amp;printf_to_env, (void*) this,
 778                                                   options(), 0/*nice new line*/)
 779     :
 780     (address)
 781     (*Disassembler::_decode_instructions)(start, end,
 782                                           &amp;event_to_env,  (void*) this,
 783                                           &amp;printf_to_env, (void*) this,
 784                                           options());
 785 }
 786 
<span class="line-added"> 787 // ----------------------------------------------------------------------------</span>
<span class="line-added"> 788 // Disassembler</span>
<span class="line-added"> 789 // Used as a static wrapper for decode_env.</span>
<span class="line-added"> 790 // Each method will create a decode_env before decoding.</span>
<span class="line-added"> 791 // You can call the decode_env methods directly if you already have one.</span>
 792 
<span class="line-modified"> 793 </span>
<span class="line-modified"> 794 bool Disassembler::load_library(outputStream* st) {</span>
<span class="line-modified"> 795   // Do not try to load multiple times. Failed once -&gt; fails always.</span>
<span class="line-added"> 796   // To force retry in debugger: assign _tried_to_load_library=0</span>
<span class="line-added"> 797   if (_tried_to_load_library) {</span>
<span class="line-added"> 798     return _library_usable;</span>
<span class="line-added"> 799   }</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added"> 802   // Print to given stream, if any.</span>
<span class="line-added"> 803   // Print to tty if Verbose is on and no stream given.</span>
<span class="line-added"> 804   st = ((st == NULL) &amp;&amp; Verbose) ? tty : st;</span>
<span class="line-added"> 805 </span>
<span class="line-added"> 806   // Compute fully qualified library name.</span>
<span class="line-added"> 807   char ebuf[1024];</span>
<span class="line-added"> 808   char buf[JVM_MAXPATHLEN];</span>
<span class="line-added"> 809   os::jvm_path(buf, sizeof(buf));</span>
<span class="line-added"> 810   int jvm_offset = -1;</span>
<span class="line-added"> 811   int lib_offset = -1;</span>
<span class="line-added"> 812 #ifdef STATIC_BUILD</span>
<span class="line-added"> 813   char* p = strrchr(buf, &#39;/&#39;);</span>
<span class="line-added"> 814   *p = &#39;\0&#39;;</span>
<span class="line-added"> 815   strcat(p, &quot;/lib/&quot;);</span>
<span class="line-added"> 816   lib_offset = jvm_offset = strlen(buf);</span>
<span class="line-added"> 817 #else</span>
<span class="line-added"> 818   {</span>
<span class="line-added"> 819     // Match &quot;libjvm&quot; instead of &quot;jvm&quot; on *nix platforms. Creates better matches.</span>
<span class="line-added"> 820     // Match &quot;[lib]jvm[^/]*&quot; in jvm_path.</span>
<span class="line-added"> 821     const char* base = buf;</span>
<span class="line-added"> 822     const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-added"> 823     if (p != NULL) lib_offset = p - base + 1; // this points to the first char after separator</span>
<span class="line-added"> 824 #ifdef _WIN32</span>
<span class="line-added"> 825     p = strstr(p ? p : base, &quot;jvm&quot;);</span>
<span class="line-added"> 826     if (p != NULL) jvm_offset = p - base;     // this points to &#39;j&#39; in jvm.</span>
<span class="line-added"> 827 #else</span>
<span class="line-added"> 828     p = strstr(p ? p : base, &quot;libjvm&quot;);</span>
<span class="line-added"> 829     if (p != NULL) jvm_offset = p - base + 3; // this points to &#39;j&#39; in libjvm.</span>
<span class="line-added"> 830 #endif</span>
<span class="line-added"> 831   }</span>
<span class="line-added"> 832 #endif</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834   // Find the disassembler shared library.</span>
<span class="line-added"> 835   // Search for several paths derived from libjvm, in this order:</span>
<span class="line-added"> 836   // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so  (for compatibility)</span>
<span class="line-added"> 837   // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-added"> 838   // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-added"> 839   // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-added"> 840   if (jvm_offset &gt;= 0) {</span>
<span class="line-added"> 841     // 1. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/libhsdis-&lt;arch&gt;.so</span>
<span class="line-added"> 842     strcpy(&amp;buf[jvm_offset], hsdis_library_name);</span>
<span class="line-added"> 843     strcat(&amp;buf[jvm_offset], os::dll_file_extension());</span>
<span class="line-added"> 844     if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="line-added"> 845     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-added"> 846     if (_library == NULL &amp;&amp; lib_offset &gt;= 0) {</span>
<span class="line-added"> 847       // 2. &lt;home&gt;/jre/lib/&lt;arch&gt;/&lt;vm&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-added"> 848       strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-added"> 849       strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-added"> 850       if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="line-added"> 851       _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-added"> 852     }</span>
<span class="line-added"> 853     if (_library == NULL &amp;&amp; lib_offset &gt; 0) {</span>
<span class="line-added"> 854       // 3. &lt;home&gt;/jre/lib/&lt;arch&gt;/hsdis-&lt;arch&gt;.so</span>
<span class="line-added"> 855       buf[lib_offset - 1] = &#39;\0&#39;;</span>
<span class="line-added"> 856       const char* p = strrchr(buf, *os::file_separator());</span>
<span class="line-added"> 857       if (p != NULL) {</span>
<span class="line-added"> 858         lib_offset = p - buf + 1;</span>
<span class="line-added"> 859         strcpy(&amp;buf[lib_offset], hsdis_library_name);</span>
<span class="line-added"> 860         strcat(&amp;buf[lib_offset], os::dll_file_extension());</span>
<span class="line-added"> 861         if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s&quot;, buf);</span>
<span class="line-added"> 862         _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-added"> 863       }</span>
<span class="line-added"> 864     }</span>
<span class="line-added"> 865   }</span>
<span class="line-added"> 866   if (_library == NULL) {</span>
<span class="line-added"> 867     // 4. hsdis-&lt;arch&gt;.so  (using LD_LIBRARY_PATH)</span>
<span class="line-added"> 868     strcpy(&amp;buf[0], hsdis_library_name);</span>
<span class="line-added"> 869     strcat(&amp;buf[0], os::dll_file_extension());</span>
<span class="line-added"> 870     if (Verbose) st-&gt;print_cr(&quot;Trying to load: %s via LD_LIBRARY_PATH or equivalent&quot;, buf);</span>
<span class="line-added"> 871     _library = os::dll_load(buf, ebuf, sizeof ebuf);</span>
<span class="line-added"> 872   }</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874   // load the decoder function to use (new or old version).</span>
<span class="line-added"> 875   if (_library != NULL) {</span>
<span class="line-added"> 876     _decode_instructions_virtual = CAST_TO_FN_PTR(Disassembler::decode_func_virtual,</span>
<span class="line-added"> 877                                           os::dll_lookup(_library, decode_instructions_virtual_name));</span>
<span class="line-added"> 878   }</span>
<span class="line-added"> 879   if (_decode_instructions_virtual == NULL &amp;&amp; _library != NULL) {</span>
<span class="line-added"> 880     // could not spot in new version, try old version</span>
<span class="line-added"> 881     _decode_instructions = CAST_TO_FN_PTR(Disassembler::decode_func,</span>
<span class="line-added"> 882                                           os::dll_lookup(_library, decode_instructions_name));</span>
<span class="line-added"> 883     use_new_version = false;</span>
<span class="line-added"> 884   } else {</span>
<span class="line-added"> 885     use_new_version = true;</span>
<span class="line-added"> 886   }</span>
<span class="line-added"> 887   _tried_to_load_library = true;</span>
<span class="line-added"> 888   _library_usable        = _decode_instructions_virtual != NULL || _decode_instructions != NULL;</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890   // Create a dummy environment to initialize PrintAssemblyOptions.</span>
<span class="line-added"> 891   // The PrintAssemblyOptions must be known for abstract disassemblies as well.</span>
<span class="line-added"> 892   decode_env dummy((unsigned char*)(&amp;buf[0]), (unsigned char*)(&amp;buf[1]), st);</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894   // Report problems during dll_load or dll_lookup, if any.</span>
<span class="line-added"> 895   if (st != NULL) {</span>
<span class="line-added"> 896     // Success.</span>
<span class="line-added"> 897     if (_library_usable) {</span>
<span class="line-added"> 898       st-&gt;print_cr(&quot;Loaded disassembler from %s&quot;, buf);</span>
<span class="line-added"> 899     } else {</span>
<span class="line-added"> 900       st-&gt;print_cr(&quot;Could not load %s; %s; %s&quot;,</span>
<span class="line-added"> 901                    buf,</span>
<span class="line-added"> 902                    ((_library != NULL)</span>
<span class="line-added"> 903                     ? &quot;entry point is missing&quot;</span>
<span class="line-added"> 904                     : ((WizardMode || PrintMiscellaneous)</span>
<span class="line-added"> 905                        ? (const char*)ebuf</span>
<span class="line-added"> 906                        : &quot;library not loadable&quot;)),</span>
<span class="line-added"> 907                    &quot;PrintAssembly defaults to abstract disassembly.&quot;);</span>
<span class="line-added"> 908     }</span>
<span class="line-added"> 909   }</span>
<span class="line-added"> 910 #endif</span>
<span class="line-added"> 911   return _library_usable;</span>
<span class="line-added"> 912 }</span>
<span class="line-added"> 913 </span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915 // Directly disassemble code buffer.</span>
<span class="line-added"> 916 void Disassembler::decode(CodeBuffer* cb, address start, address end, outputStream* st) {</span>
<span class="line-added"> 917 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-added"> 918   //---&lt;  Test memory before decoding  &gt;---</span>
<span class="line-added"> 919   if (!(cb-&gt;contains(start) &amp;&amp; cb-&gt;contains(end))) {</span>
<span class="line-added"> 920     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="line-added"> 921     if (st != NULL) {</span>
<span class="line-added"> 922       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not contained in CodeBuffer&quot;, p2i(start), p2i(end));</span>
<span class="line-added"> 923     }</span>
<span class="line-added"> 924     return;</span>
<span class="line-added"> 925   }</span>
<span class="line-added"> 926   if (!os::is_readable_range(start, end)) {</span>
<span class="line-added"> 927     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="line-added"> 928     if (st != NULL) {</span>
<span class="line-added"> 929       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not readable&quot;, p2i(start), p2i(end));</span>
<span class="line-added"> 930     }</span>
<span class="line-added"> 931     return;</span>
<span class="line-added"> 932   }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934   decode_env env(cb, st);</span>
<span class="line-added"> 935   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-added"> 936   env.output()-&gt;print(&quot;Decoding CodeBuffer (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb));</span>
<span class="line-added"> 937   if (cb-&gt;name() != NULL) {</span>
<span class="line-added"> 938     env.output()-&gt;print(&quot;, name: %s,&quot;, cb-&gt;name());</span>
<span class="line-added"> 939   }</span>
<span class="line-added"> 940   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(start), p2i(end), ((jlong)(end - start)));</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942   if (is_abstract()) {</span>
<span class="line-added"> 943     AbstractDisassembler::decode_abstract(start, end, env.output(), Assembler::instr_maxlen());</span>
<span class="line-added"> 944   } else {</span>
<span class="line-added"> 945     env.decode_instructions(start, end);</span>
<span class="line-added"> 946   }</span>
<span class="line-added"> 947   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-added"> 948 #endif</span>
<span class="line-added"> 949 }</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951 // Directly disassemble code blob.</span>
<span class="line-added"> 952 void Disassembler::decode(CodeBlob* cb, outputStream* st, CodeStrings c) {</span>
<span class="line-added"> 953 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
 954   if (cb-&gt;is_nmethod()) {
<span class="line-modified"> 955     // If we  have an nmethod at hand,</span>
<span class="line-added"> 956     // call the specialized decoder directly.</span>
<span class="line-added"> 957     decode((nmethod*)cb, st, c);</span>
 958     return;
 959   }
<span class="line-added"> 960 </span>
 961   decode_env env(cb, st);
<span class="line-modified"> 962   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
 963   if (cb-&gt;is_aot()) {
 964     env.output()-&gt;print(&quot;A &quot;);
 965     if (cb-&gt;is_compiled()) {
 966       CompiledMethod* cm = (CompiledMethod*)cb;
 967       env.output()-&gt;print(&quot;%d &quot;,cm-&gt;compile_id());
 968       cm-&gt;method()-&gt;method_holder()-&gt;name()-&gt;print_symbol_on(env.output());
 969       env.output()-&gt;print(&quot;.&quot;);
 970       cm-&gt;method()-&gt;name()-&gt;print_symbol_on(env.output());
 971       cm-&gt;method()-&gt;signature()-&gt;print_symbol_on(env.output());
 972     } else {
 973       env.output()-&gt;print_cr(&quot;%s&quot;, cb-&gt;name());
 974     }
 975   } else {
<span class="line-modified"> 976     env.output()-&gt;print(&quot;Decoding CodeBlob&quot;);</span>
<span class="line-added"> 977     if (cb-&gt;name() != NULL) {</span>
<span class="line-added"> 978       env.output()-&gt;print(&quot;, name: %s,&quot;, cb-&gt;name());</span>
<span class="line-added"> 979     }</span>
 980   }
<span class="line-modified"> 981   env.output()-&gt;print_cr(&quot; at  [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]  &quot; JLONG_FORMAT &quot; bytes&quot;, p2i(cb-&gt;code_begin()), p2i(cb-&gt;code_end()), ((jlong)(cb-&gt;code_end() - cb-&gt;code_begin())));</span>


 982 
<span class="line-modified"> 983   if (is_abstract()) {</span>
<span class="line-modified"> 984     AbstractDisassembler::decode_abstract(cb-&gt;code_begin(), cb-&gt;code_end(), env.output(), Assembler::instr_maxlen());</span>
<span class="line-modified"> 985   } else {</span>
<span class="line-modified"> 986     env.decode_instructions(cb-&gt;code_begin(), cb-&gt;code_end());</span>
<span class="line-modified"> 987   }</span>
<span class="line-modified"> 988   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-added"> 989 #endif</span>
 990 }
 991 
<span class="line-modified"> 992 // Decode a nmethod.</span>
<span class="line-added"> 993 // This includes printing the constant pool and all code segments.</span>
<span class="line-added"> 994 // The nmethod data structures (oop maps, relocations and the like) are not printed.</span>
<span class="line-added"> 995 void Disassembler::decode(nmethod* nm, outputStream* st, CodeStrings c) {</span>
<span class="line-added"> 996 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
 997   ttyLocker ttyl;






 998 
<span class="line-modified"> 999   decode_env env(nm, st);</span>
<span class="line-modified">1000   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-modified">1001   nm-&gt;print_constant_pool(env.output());</span>
<span class="line-modified">1002   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-modified">1003   env.output()-&gt;cr();</span>
<span class="line-modified">1004   if (is_abstract()) {</span>
<span class="line-modified">1005     AbstractDisassembler::decode_abstract(nm-&gt;code_begin(), nm-&gt;code_end(), env.output(), Assembler::instr_maxlen());</span>
<span class="line-modified">1006   } else {</span>
<span class="line-modified">1007     env.decode_instructions(nm-&gt;code_begin(), nm-&gt;code_end());</span>


1008   }
<span class="line-added">1009   env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
1010 #endif
<span class="line-modified">1011 }</span>
<span class="line-modified">1012 </span>
<span class="line-modified">1013 // Decode a range, given as [start address, end address)</span>
<span class="line-modified">1014 void Disassembler::decode(address start, address end, outputStream* st, CodeStrings c /*, ptrdiff_t offset */) {</span>
<span class="line-modified">1015 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="line-modified">1016   //---&lt;  Test memory before decoding  &gt;---</span>
<span class="line-modified">1017   if (!os::is_readable_range(start, end)) {</span>
<span class="line-modified">1018     //---&lt;  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  &gt;---</span>
<span class="line-modified">1019     if (st != NULL) {</span>
<span class="line-modified">1020       st-&gt;print(&quot;Memory range [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;] not readable&quot;, p2i(start), p2i(end));</span>


1021     }
<span class="line-added">1022     return;</span>
1023   }
1024 
<span class="line-modified">1025   if (is_abstract()) {</span>
<span class="line-added">1026     AbstractDisassembler::decode_abstract(start, end, st, Assembler::instr_maxlen());</span>
<span class="line-added">1027     return;</span>
<span class="line-added">1028   }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030 // Don&#39;t do that fancy stuff. If we just have two addresses, live with it</span>
<span class="line-added">1031 // and treat the memory contents as &quot;amorphic&quot; piece of code.</span>
<span class="line-added">1032 #if 0</span>
<span class="line-added">1033   CodeBlob* cb = CodeCache::find_blob_unsafe(start);</span>
<span class="line-added">1034   if (cb != NULL) {</span>
<span class="line-added">1035     // If we  have an CodeBlob at hand,</span>
<span class="line-added">1036     // call the specialized decoder directly.</span>
<span class="line-added">1037     decode(cb, st, c);</span>
<span class="line-added">1038   } else</span>
<span class="line-added">1039 #endif</span>
<span class="line-added">1040   {</span>
<span class="line-added">1041     // This seems to be just a chunk of memory.</span>
<span class="line-added">1042     decode_env env(start, end, st);</span>
<span class="line-added">1043     env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-added">1044     env.decode_instructions(start, end);</span>
<span class="line-added">1045     env.output()-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
<span class="line-added">1046   }</span>
<span class="line-added">1047 #endif</span>
1048 }
1049 
1050 // To prevent excessive code expansion in the interpreter generator, we
1051 // do not inline this function into Disassembler::hook().
1052 void Disassembler::_hook(const char* file, int line, MacroAssembler* masm) {
1053   decode_env::hook(file, line, masm-&gt;code_section()-&gt;end());
1054 }
</pre>
</td>
</tr>
</table>
<center><a href="compilerOracle.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderDataGraph.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderDataGraph.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderDataGraph.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADERDATAGRAPH_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADERDATAGRAPH_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 // GC root for walking class loader data created
 34 
 35 class ClassLoaderDataGraph : public AllStatic {
 36   friend class ClassLoaderData;
 37   friend class ClassLoaderDataGraphMetaspaceIterator;
 38   friend class ClassLoaderDataGraphKlassIteratorAtomic;
 39   friend class ClassLoaderDataGraphKlassIteratorStatic;
 40   friend class ClassLoaderDataGraphIterator;
 41   friend class VMStructs;
 42  private:
 43   // All CLDs (except the null CLD) can be reached by walking _head-&gt;_next-&gt;...
<span class="line-modified"> 44   static ClassLoaderData* _head;</span>
 45   static ClassLoaderData* _unloading;
<span class="line-removed"> 46   // CMS support.</span>
<span class="line-removed"> 47   static ClassLoaderData* _saved_head;</span>
<span class="line-removed"> 48   static ClassLoaderData* _saved_unloading;</span>
<span class="line-removed"> 49   static bool _should_purge;</span>
 50 
 51   // Set if there&#39;s anything to purge in the deallocate lists or previous versions
 52   // during a safepoint after class unloading in a full GC.
 53   static bool _should_clean_deallocate_lists;
 54   static bool _safepoint_cleanup_needed;
 55 
 56   // OOM has been seen in metaspace allocation. Used to prevent some
 57   // allocations until class unloading
 58   static bool _metaspace_oom;
 59 
 60   static volatile size_t  _num_instance_classes;
 61   static volatile size_t  _num_array_classes;
 62 
 63   static ClassLoaderData* add_to_graph(Handle class_loader, bool is_unsafe_anonymous);
 64   static ClassLoaderData* add(Handle class_loader, bool is_unsafe_anonymous);
 65 
 66  public:
 67   static ClassLoaderData* find_or_create(Handle class_loader);
 68   static void clean_module_and_package_info();
 69   static void purge();
 70   static void clear_claimed_marks();

 71   // Iteration through CLDG inside a safepoint; GC support
 72   static void cld_do(CLDClosure* cl);
 73   static void cld_unloading_do(CLDClosure* cl);
 74   static void roots_cld_do(CLDClosure* strong, CLDClosure* weak);
 75   static void always_strong_cld_do(CLDClosure* cl);
 76   // Iteration through CLDG not by GC.
 77   static void loaded_cld_do(CLDClosure* cl);
 78   // klass do
 79   // Walking classes through the ClassLoaderDataGraph include array classes.  It also includes
 80   // classes that are allocated but not loaded, classes that have errors, and scratch classes
 81   // for redefinition.  These classes are removed during the next class unloading.
 82   // Walking the ClassLoaderDataGraph also includes unsafe anonymous classes.
 83   static void classes_do(KlassClosure* klass_closure);
 84   static void classes_do(void f(Klass* const));
 85   static void methods_do(void f(Method*));
 86   static void modules_do(void f(ModuleEntry*));
 87   static void modules_unloading_do(void f(ModuleEntry*));
 88   static void packages_do(void f(PackageEntry*));
 89   static void packages_unloading_do(void f(PackageEntry*));
 90   static void loaded_classes_do(KlassClosure* klass_closure);
</pre>
<hr />
<pre>
 95   // Expose state to avoid logging overhead in safepoint cleanup tasks.
 96   static inline bool should_clean_metaspaces_and_reset();
 97   static void set_should_clean_deallocate_lists() { _should_clean_deallocate_lists = true; }
 98   static void clean_deallocate_lists(bool purge_previous_versions);
 99   static void walk_metadata_and_clean_metaspaces();
100 
101   // dictionary do
102   // Iterate over all klasses in dictionary, but
103   // just the classes from defining class loaders.
104   static void dictionary_classes_do(void f(InstanceKlass*));
105   // Added for initialize_itable_for_klass to handle exceptions.
106   static void dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS);
107 
108   // VM_CounterDecay iteration support
109   static InstanceKlass* try_get_next_class();
110   static void adjust_saved_class(ClassLoaderData* cld);
111   static void adjust_saved_class(Klass* klass);
112 
113   static void verify_dictionary();
114   static void print_dictionary(outputStream* st);
<span class="line-modified">115   static void print_dictionary_statistics(outputStream* st);</span>
<span class="line-removed">116 </span>
<span class="line-removed">117   // CMS support.</span>
<span class="line-removed">118   static void remember_new_clds(bool remember) { _saved_head = (remember ? _head : NULL); }</span>
<span class="line-removed">119   static GrowableArray&lt;ClassLoaderData*&gt;* new_clds();</span>
<span class="line-removed">120 </span>
<span class="line-removed">121   static void set_should_purge(bool b) { _should_purge = b; }</span>
<span class="line-removed">122   static void purge_if_needed() {</span>
<span class="line-removed">123     // Only purge the CLDG for CMS if concurrent sweep is complete.</span>
<span class="line-removed">124     if (_should_purge) {</span>
<span class="line-removed">125       purge();</span>
<span class="line-removed">126       // reset for next time.</span>
<span class="line-removed">127       set_should_purge(false);</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129   }</span>
130 
<span class="line-modified">131   static int resize_if_needed();</span>
132 
133   static bool has_metaspace_oom()           { return _metaspace_oom; }
134   static void set_metaspace_oom(bool value) { _metaspace_oom = value; }
135 
136   static void print_on(outputStream * const out) PRODUCT_RETURN;
<span class="line-modified">137   static void print() { print_on(tty); }</span>
138   static void verify();
139 
140   // instance and array class counters
141   static inline size_t num_instance_classes();
142   static inline size_t num_array_classes();
143   static inline void inc_instance_classes(size_t count);
144   static inline void dec_instance_classes(size_t count);
145   static inline void inc_array_classes(size_t count);
146   static inline void dec_array_classes(size_t count);
147 
148 #ifndef PRODUCT
149   static bool contains_loader_data(ClassLoaderData* loader_data);
150 #endif
151 
152   // Check if ClassLoaderData is part of the ClassLoaderDataGraph (not unloaded)
153   // Usage without lock only allowed during error reporting.
154   static bool is_valid(ClassLoaderData* loader_data);
155 };
156 
157 class LockedClassesDo : public KlassClosure {
158   typedef void (*classes_do_func_t)(Klass*);
159   classes_do_func_t _function;

160 public:
161   LockedClassesDo();  // For callers who provide their own do_klass
162   LockedClassesDo(classes_do_func_t function);
163   ~LockedClassesDo();
164 
165   void do_klass(Klass* k) {
166     (*_function)(k);
167   }
168 };
169 
170 // An iterator that distributes Klasses to parallel worker threads.
171 class ClassLoaderDataGraphKlassIteratorAtomic : public StackObj {
172  Klass* volatile _next_klass;
173  public:
174   ClassLoaderDataGraphKlassIteratorAtomic();
175   Klass* next_klass();
176  private:
177   static Klass* next_klass_in_cldg(Klass* klass);
178 };
179 
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADERDATAGRAPH_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADERDATAGRAPH_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 // GC root for walking class loader data created
 34 
 35 class ClassLoaderDataGraph : public AllStatic {
 36   friend class ClassLoaderData;
 37   friend class ClassLoaderDataGraphMetaspaceIterator;
 38   friend class ClassLoaderDataGraphKlassIteratorAtomic;
 39   friend class ClassLoaderDataGraphKlassIteratorStatic;
 40   friend class ClassLoaderDataGraphIterator;
 41   friend class VMStructs;
 42  private:
 43   // All CLDs (except the null CLD) can be reached by walking _head-&gt;_next-&gt;...
<span class="line-modified"> 44   static ClassLoaderData* volatile _head;</span>
 45   static ClassLoaderData* _unloading;




 46 
 47   // Set if there&#39;s anything to purge in the deallocate lists or previous versions
 48   // during a safepoint after class unloading in a full GC.
 49   static bool _should_clean_deallocate_lists;
 50   static bool _safepoint_cleanup_needed;
 51 
 52   // OOM has been seen in metaspace allocation. Used to prevent some
 53   // allocations until class unloading
 54   static bool _metaspace_oom;
 55 
 56   static volatile size_t  _num_instance_classes;
 57   static volatile size_t  _num_array_classes;
 58 
 59   static ClassLoaderData* add_to_graph(Handle class_loader, bool is_unsafe_anonymous);
 60   static ClassLoaderData* add(Handle class_loader, bool is_unsafe_anonymous);
 61 
 62  public:
 63   static ClassLoaderData* find_or_create(Handle class_loader);
 64   static void clean_module_and_package_info();
 65   static void purge();
 66   static void clear_claimed_marks();
<span class="line-added"> 67   static void clear_claimed_marks(int claim);</span>
 68   // Iteration through CLDG inside a safepoint; GC support
 69   static void cld_do(CLDClosure* cl);
 70   static void cld_unloading_do(CLDClosure* cl);
 71   static void roots_cld_do(CLDClosure* strong, CLDClosure* weak);
 72   static void always_strong_cld_do(CLDClosure* cl);
 73   // Iteration through CLDG not by GC.
 74   static void loaded_cld_do(CLDClosure* cl);
 75   // klass do
 76   // Walking classes through the ClassLoaderDataGraph include array classes.  It also includes
 77   // classes that are allocated but not loaded, classes that have errors, and scratch classes
 78   // for redefinition.  These classes are removed during the next class unloading.
 79   // Walking the ClassLoaderDataGraph also includes unsafe anonymous classes.
 80   static void classes_do(KlassClosure* klass_closure);
 81   static void classes_do(void f(Klass* const));
 82   static void methods_do(void f(Method*));
 83   static void modules_do(void f(ModuleEntry*));
 84   static void modules_unloading_do(void f(ModuleEntry*));
 85   static void packages_do(void f(PackageEntry*));
 86   static void packages_unloading_do(void f(PackageEntry*));
 87   static void loaded_classes_do(KlassClosure* klass_closure);
</pre>
<hr />
<pre>
 92   // Expose state to avoid logging overhead in safepoint cleanup tasks.
 93   static inline bool should_clean_metaspaces_and_reset();
 94   static void set_should_clean_deallocate_lists() { _should_clean_deallocate_lists = true; }
 95   static void clean_deallocate_lists(bool purge_previous_versions);
 96   static void walk_metadata_and_clean_metaspaces();
 97 
 98   // dictionary do
 99   // Iterate over all klasses in dictionary, but
100   // just the classes from defining class loaders.
101   static void dictionary_classes_do(void f(InstanceKlass*));
102   // Added for initialize_itable_for_klass to handle exceptions.
103   static void dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS);
104 
105   // VM_CounterDecay iteration support
106   static InstanceKlass* try_get_next_class();
107   static void adjust_saved_class(ClassLoaderData* cld);
108   static void adjust_saved_class(Klass* klass);
109 
110   static void verify_dictionary();
111   static void print_dictionary(outputStream* st);
<span class="line-modified">112   static void print_table_statistics(outputStream* st);</span>














113 
<span class="line-modified">114   static int resize_dictionaries();</span>
115 
116   static bool has_metaspace_oom()           { return _metaspace_oom; }
117   static void set_metaspace_oom(bool value) { _metaspace_oom = value; }
118 
119   static void print_on(outputStream * const out) PRODUCT_RETURN;
<span class="line-modified">120   static void print();</span>
121   static void verify();
122 
123   // instance and array class counters
124   static inline size_t num_instance_classes();
125   static inline size_t num_array_classes();
126   static inline void inc_instance_classes(size_t count);
127   static inline void dec_instance_classes(size_t count);
128   static inline void inc_array_classes(size_t count);
129   static inline void dec_array_classes(size_t count);
130 
131 #ifndef PRODUCT
132   static bool contains_loader_data(ClassLoaderData* loader_data);
133 #endif
134 
135   // Check if ClassLoaderData is part of the ClassLoaderDataGraph (not unloaded)
136   // Usage without lock only allowed during error reporting.
137   static bool is_valid(ClassLoaderData* loader_data);
138 };
139 
140 class LockedClassesDo : public KlassClosure {
141   typedef void (*classes_do_func_t)(Klass*);
142   classes_do_func_t _function;
<span class="line-added">143   bool _do_lock;</span>
144 public:
145   LockedClassesDo();  // For callers who provide their own do_klass
146   LockedClassesDo(classes_do_func_t function);
147   ~LockedClassesDo();
148 
149   void do_klass(Klass* k) {
150     (*_function)(k);
151   }
152 };
153 
154 // An iterator that distributes Klasses to parallel worker threads.
155 class ClassLoaderDataGraphKlassIteratorAtomic : public StackObj {
156  Klass* volatile _next_klass;
157  public:
158   ClassLoaderDataGraphKlassIteratorAtomic();
159   Klass* next_klass();
160  private:
161   static Klass* next_klass_in_cldg(Klass* klass);
162 };
163 
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderDataGraph.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
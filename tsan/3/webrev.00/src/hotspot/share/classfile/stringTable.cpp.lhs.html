<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/stringTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/altHashing.hpp&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;classfile/stringTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 33 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;</span>
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/filemap.hpp&quot;
 38 #include &quot;memory/heapShared.inline.hpp&quot;
 39 #include &quot;memory/resourceArea.hpp&quot;
 40 #include &quot;memory/universe.hpp&quot;
 41 #include &quot;oops/access.inline.hpp&quot;
<a name="2" id="anc2"></a>
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 44 #include &quot;oops/weakHandle.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/safepointVerifiers.hpp&quot;
 49 #include &quot;runtime/timerTrace.hpp&quot;
 50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 51 #include &quot;services/diagnosticCommand.hpp&quot;
 52 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 53 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
 54 #include &quot;utilities/macros.hpp&quot;
<a name="3" id="anc3"></a>
 55 
 56 // We prefer short chains of avg 2
 57 const double PREF_AVG_LIST_LEN = 2.0;
 58 // 2^24 is max size
 59 const size_t END_SIZE = 24;
<a name="4" id="anc4"></a><span class="line-modified"> 60 // If a chain gets to 32 something might be wrong</span>
<span class="line-modified"> 61 const size_t REHASH_LEN = 32;</span>
 62 // If we have as many dead items as 50% of the number of bucket
 63 const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;
 64 
 65 #if INCLUDE_CDS_JAVA_HEAP
 66 inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {
 67   assert(sizeof(narrowOop) == sizeof(offset), &quot;must be&quot;);
 68   narrowOop v = (narrowOop)offset;
 69   return HeapShared::decode_from_archive(v);
 70 }
 71 
 72 static CompactHashtable&lt;
 73   const jchar*, oop,
 74   read_string_from_compact_hashtable,
 75   java_lang_String::equals
 76 &gt; _shared_table;
 77 #endif
 78 
 79 // --------------------------------------------------------------------------
<a name="5" id="anc5"></a><span class="line-removed"> 80 StringTable* StringTable::_the_table = NULL;</span>
<span class="line-removed"> 81 volatile bool StringTable::_alt_hash = false;</span>
 82 
<a name="6" id="anc6"></a>











 83 static juint murmur_seed = 0;
 84 
 85 uintx hash_string(const jchar* s, int len, bool useAlt) {
 86   return  useAlt ?
 87     AltHashing::murmur3_32(murmur_seed, s, len) :
 88     java_lang_String::hash_code(s, len);
 89 }
 90 
<a name="7" id="anc7"></a><span class="line-modified"> 91 class StringTableConfig : public StringTableHash::BaseConfig {</span>
 92  private:
 93  public:
<a name="8" id="anc8"></a><span class="line-modified"> 94   static uintx get_hash(WeakHandle&lt;vm_string_table_data&gt; const&amp; value,</span>
<span class="line-modified"> 95                         bool* is_dead) {</span>

 96     EXCEPTION_MARK;
 97     oop val_oop = value.peek();
 98     if (val_oop == NULL) {
 99       *is_dead = true;
100       return 0;
101     }
102     *is_dead = false;
103     ResourceMark rm(THREAD);
104     // All String oops are hashed as unicode
105     int length;
106     jchar* chars = java_lang_String::as_unicode_string(val_oop, length, THREAD);
107     if (chars != NULL) {
<a name="9" id="anc9"></a><span class="line-modified">108       return hash_string(chars, length, StringTable::_alt_hash);</span>
109     }
110     vm_exit_out_of_memory(length, OOM_MALLOC_ERROR, &quot;get hash from oop&quot;);
111     return 0;
112   }
113   // We use default allocation/deallocation but counted
<a name="10" id="anc10"></a><span class="line-modified">114   static void* allocate_node(size_t size,</span>
<span class="line-removed">115                              WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
116     StringTable::item_added();
<a name="11" id="anc11"></a><span class="line-modified">117     return StringTableHash::BaseConfig::allocate_node(size, value);</span>
118   }
<a name="12" id="anc12"></a><span class="line-modified">119   static void free_node(void* memory,</span>
<span class="line-removed">120                         WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
121     value.release();
<a name="13" id="anc13"></a><span class="line-modified">122     StringTableHash::BaseConfig::free_node(memory, value);</span>
123     StringTable::item_removed();
124   }
125 };
126 
127 class StringTableLookupJchar : StackObj {
128  private:
129   Thread* _thread;
130   uintx _hash;
131   int _len;
132   const jchar* _str;
133   Handle _found;
134 
135  public:
136   StringTableLookupJchar(Thread* thread, uintx hash, const jchar* key, int len)
137     : _thread(thread), _hash(hash), _len(len), _str(key) {
138   }
139   uintx get_hash() const {
140     return _hash;
141   }
142   bool equals(WeakHandle&lt;vm_string_table_data&gt;* value, bool* is_dead) {
143     oop val_oop = value-&gt;peek();
144     if (val_oop == NULL) {
145       // dead oop, mark this hash dead for cleaning
146       *is_dead = true;
147       return false;
148     }
149     bool equals = java_lang_String::equals(val_oop, _str, _len);
150     if (!equals) {
151       return false;
152     }
153     // Need to resolve weak handle and Handleize through possible safepoint.
154      _found = Handle(_thread, value-&gt;resolve());
155     return true;
156   }
157 };
158 
159 class StringTableLookupOop : public StackObj {
160  private:
161   Thread* _thread;
162   uintx _hash;
163   Handle _find;
164   Handle _found;  // Might be a different oop with the same value that&#39;s already
165                   // in the table, which is the point.
166  public:
167   StringTableLookupOop(Thread* thread, uintx hash, Handle handle)
168     : _thread(thread), _hash(hash), _find(handle) { }
169 
170   uintx get_hash() const {
171     return _hash;
172   }
173 
174   bool equals(WeakHandle&lt;vm_string_table_data&gt;* value, bool* is_dead) {
175     oop val_oop = value-&gt;peek();
176     if (val_oop == NULL) {
177       // dead oop, mark this hash dead for cleaning
178       *is_dead = true;
179       return false;
180     }
181     bool equals = java_lang_String::equals(_find(), val_oop);
182     if (!equals) {
183       return false;
184     }
185     // Need to resolve weak handle and Handleize through possible safepoint.
186     _found = Handle(_thread, value-&gt;resolve());
187     return true;
188   }
189 };
190 
191 static size_t ceil_log2(size_t val) {
192   size_t ret;
193   for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; val; ++ret);
194   return ret;
195 }
196 
<a name="14" id="anc14"></a><span class="line-modified">197 StringTable::StringTable() : _local_table(NULL), _current_size(0), _has_work(0),</span>
<span class="line-removed">198   _needs_rehashing(false), _weak_handles(NULL), _items_count(0), _uncleaned_items_count(0) {</span>
<span class="line-removed">199   _weak_handles = new OopStorage(&quot;StringTable weak&quot;,</span>
<span class="line-removed">200                                  StringTableWeakAlloc_lock,</span>
<span class="line-removed">201                                  StringTableWeakActive_lock);</span>
202   size_t start_size_log_2 = ceil_log2(StringTableSize);
203   _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
204   log_trace(stringtable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
205                          _current_size, start_size_log_2);
206   _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
207 }
208 
<a name="15" id="anc15"></a><span class="line-removed">209 void StringTable::update_needs_rehash(bool rehash) {</span>
<span class="line-removed">210   if (rehash) {</span>
<span class="line-removed">211     _needs_rehashing = true;</span>
<span class="line-removed">212   }</span>
<span class="line-removed">213 }</span>
<span class="line-removed">214 </span>
215 size_t StringTable::item_added() {
<a name="16" id="anc16"></a><span class="line-modified">216   return Atomic::add((size_t)1, &amp;(the_table()-&gt;_items_count));</span>
217 }
218 
219 size_t StringTable::add_items_to_clean(size_t ndead) {
<a name="17" id="anc17"></a><span class="line-modified">220   size_t total = Atomic::add((size_t)ndead, &amp;(the_table()-&gt;_uncleaned_items_count));</span>
221   log_trace(stringtable)(
222      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,
<a name="18" id="anc18"></a><span class="line-modified">223      the_table()-&gt;_uncleaned_items_count, ndead, total);</span>
224   return total;
225 }
226 
227 void StringTable::item_removed() {
<a name="19" id="anc19"></a><span class="line-modified">228   Atomic::add((size_t)-1, &amp;(the_table()-&gt;_items_count));</span>
229 }
230 
<a name="20" id="anc20"></a><span class="line-modified">231 double StringTable::get_load_factor() const {</span>
232   return (double)_items_count/_current_size;
233 }
234 
<a name="21" id="anc21"></a><span class="line-modified">235 double StringTable::get_dead_factor() const {</span>
236   return (double)_uncleaned_items_count/_current_size;
237 }
238 
239 size_t StringTable::table_size() {
240   return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
241 }
242 
243 void StringTable::trigger_concurrent_work() {
<a name="22" id="anc22"></a><span class="line-modified">244   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">245   the_table()-&gt;_has_work = true;</span>
246   Service_lock-&gt;notify_all();
247 }
248 
249 // Probing
250 oop StringTable::lookup(Symbol* symbol) {
251   ResourceMark rm;
252   int length;
253   jchar* chars = symbol-&gt;as_unicode(length);
254   return lookup(chars, length);
255 }
256 
257 oop StringTable::lookup(const jchar* name, int len) {
258   unsigned int hash = java_lang_String::hash_code(name, len);
<a name="23" id="anc23"></a><span class="line-modified">259   oop string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
260   if (string != NULL) {
261     return string;
262   }
<a name="24" id="anc24"></a><span class="line-modified">263   if (StringTable::_alt_hash) {</span>
264     hash = hash_string(name, len, true);
265   }
<a name="25" id="anc25"></a><span class="line-modified">266   return StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
267 }
268 
269 class StringTableGet : public StackObj {
270   Thread* _thread;
271   Handle  _return;
272  public:
273   StringTableGet(Thread* thread) : _thread(thread) {}
274   void operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
275     oop result = val-&gt;resolve();
276     assert(result != NULL, &quot;Result should be reachable&quot;);
277     _return = Handle(_thread, result);
278   }
279   oop get_res_oop() {
280     return _return();
281   }
282 };
283 
284 oop StringTable::do_lookup(const jchar* name, int len, uintx hash) {
285   Thread* thread = Thread::current();
286   StringTableLookupJchar lookup(thread, hash, name, len);
287   StringTableGet stg(thread);
288   bool rehash_warning;
289   _local_table-&gt;get(thread, lookup, stg, &amp;rehash_warning);
290   update_needs_rehash(rehash_warning);
291   return stg.get_res_oop();
292 }
293 
294 // Interning
295 oop StringTable::intern(Symbol* symbol, TRAPS) {
296   if (symbol == NULL) return NULL;
297   ResourceMark rm(THREAD);
298   int length;
299   jchar* chars = symbol-&gt;as_unicode(length);
300   Handle string;
301   oop result = intern(string, chars, length, CHECK_NULL);
302   return result;
303 }
304 
305 oop StringTable::intern(oop string, TRAPS) {
306   if (string == NULL) return NULL;
307   ResourceMark rm(THREAD);
308   int length;
309   Handle h_string (THREAD, string);
310   jchar* chars = java_lang_String::as_unicode_string(string, length,
311                                                      CHECK_NULL);
312   oop result = intern(h_string, chars, length, CHECK_NULL);
313   return result;
314 }
315 
316 oop StringTable::intern(const char* utf8_string, TRAPS) {
317   if (utf8_string == NULL) return NULL;
318   ResourceMark rm(THREAD);
319   int length = UTF8::unicode_length(utf8_string);
320   jchar* chars = NEW_RESOURCE_ARRAY(jchar, length);
321   UTF8::convert_to_unicode(utf8_string, chars, length);
322   Handle string;
323   oop result = intern(string, chars, length, CHECK_NULL);
324   return result;
325 }
326 
327 oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
328   // shared table always uses java_lang_String::hash_code
329   unsigned int hash = java_lang_String::hash_code(name, len);
<a name="26" id="anc26"></a><span class="line-modified">330   oop found_string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
331   if (found_string != NULL) {
332     return found_string;
333   }
<a name="27" id="anc27"></a><span class="line-modified">334   if (StringTable::_alt_hash) {</span>
335     hash = hash_string(name, len, true);
336   }
<a name="28" id="anc28"></a><span class="line-modified">337   found_string = StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
338   if (found_string != NULL) {
339     return found_string;
340   }
<a name="29" id="anc29"></a><span class="line-modified">341   return StringTable::the_table()-&gt;do_intern(string_or_null_h, name, len,</span>
<span class="line-removed">342                                              hash, CHECK_NULL);</span>
343 }
344 
345 oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,
346                            int len, uintx hash, TRAPS) {
347   HandleMark hm(THREAD);  // cleanup strings created
348   Handle string_h;
349 
350   if (!string_or_null_h.is_null()) {
351     string_h = string_or_null_h;
352   } else {
353     string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
354   }
355 
356   // Deduplicate the string before it is interned. Note that we should never
357   // deduplicate a string after it has been interned. Doing so will counteract
358   // compiler optimizations done on e.g. interned string literals.
359   Universe::heap()-&gt;deduplicate_string(string_h());
360 
361   assert(java_lang_String::equals(string_h(), name, len),
362          &quot;string must be properly initialized&quot;);
363   assert(len == java_lang_String::length(string_h()), &quot;Must be same length&quot;);
364 
365   StringTableLookupOop lookup(THREAD, hash, string_h);
366   StringTableGet stg(THREAD);
367 
368   bool rehash_warning;
369   do {
<a name="30" id="anc30"></a><span class="line-modified">370     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-removed">371       update_needs_rehash(rehash_warning);</span>
<span class="line-removed">372       return stg.get_res_oop();</span>
<span class="line-removed">373     }</span>
374     WeakHandle&lt;vm_string_table_data&gt; wh = WeakHandle&lt;vm_string_table_data&gt;::create(string_h);
375     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.
376     if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) {
377       update_needs_rehash(rehash_warning);
378       return wh.resolve();
379     }
<a name="31" id="anc31"></a>





380   } while(true);
381 }
382 
<a name="32" id="anc32"></a><span class="line-removed">383 void StringTable::oops_do(OopClosure* f) {</span>
<span class="line-removed">384   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">385   StringTable::the_table()-&gt;_weak_handles-&gt;oops_do(f);</span>
<span class="line-removed">386 }</span>
<span class="line-removed">387 </span>
<span class="line-removed">388 void StringTable::possibly_parallel_oops_do(</span>
<span class="line-removed">389    OopStorage::ParState&lt;false /* concurrent */, false /* const */&gt;*</span>
<span class="line-removed">390    _par_state_string, OopClosure* f)</span>
<span class="line-removed">391 {</span>
<span class="line-removed">392   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">393   _par_state_string-&gt;oops_do(f);</span>
<span class="line-removed">394 }</span>
<span class="line-removed">395 </span>
396 // Concurrent work
397 void StringTable::grow(JavaThread* jt) {
398   StringTableHash::GrowTask gt(_local_table);
399   if (!gt.prepare(jt)) {
400     return;
401   }
402   log_trace(stringtable)(&quot;Started to grow&quot;);
403   {
404     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, stringtable, perf));
405     while (gt.do_task(jt)) {
406       gt.pause(jt);
407       {
408         ThreadBlockInVM tbivm(jt);
409       }
410       gt.cont(jt);
411     }
412   }
413   gt.done(jt);
414   _current_size = table_size();
415   log_debug(stringtable)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);
416 }
417 
418 struct StringTableDoDelete : StackObj {
419   void operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
420     /* do nothing */
421   }
422 };
423 
424 struct StringTableDeleteCheck : StackObj {
425   long _count;
426   long _item;
427   StringTableDeleteCheck() : _count(0), _item(0) {}
428   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
429     ++_item;
430     oop tmp = val-&gt;peek();
431     if (tmp == NULL) {
432       ++_count;
433       return true;
434     } else {
435       return false;
436     }
437   }
438 };
439 
440 void StringTable::clean_dead_entries(JavaThread* jt) {
441   StringTableHash::BulkDeleteTask bdt(_local_table);
442   if (!bdt.prepare(jt)) {
443     return;
444   }
445 
446   StringTableDeleteCheck stdc;
447   StringTableDoDelete stdd;
448   {
449     TraceTime timer(&quot;Clean&quot;, TRACETIME_LOG(Debug, stringtable, perf));
450     while(bdt.do_task(jt, stdc, stdd)) {
451       bdt.pause(jt);
452       {
453         ThreadBlockInVM tbivm(jt);
454       }
455       bdt.cont(jt);
456     }
457     bdt.done(jt);
458   }
459   log_debug(stringtable)(&quot;Cleaned %ld of %ld&quot;, stdc._count, stdc._item);
460 }
461 
462 void StringTable::check_concurrent_work() {
463   if (_has_work) {
464     return;
465   }
466 
467   double load_factor = StringTable::get_load_factor();
468   double dead_factor = StringTable::get_dead_factor();
469   // We should clean/resize if we have more dead than alive,
470   // more items than preferred load factor or
471   // more dead items than water mark.
472   if ((dead_factor &gt; load_factor) ||
473       (load_factor &gt; PREF_AVG_LIST_LEN) ||
474       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {
475     log_debug(stringtable)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,
476                            load_factor, dead_factor);
477     trigger_concurrent_work();
478   }
479 }
480 
<a name="33" id="anc33"></a><span class="line-modified">481 void StringTable::concurrent_work(JavaThread* jt) {</span>
482   _has_work = false;
483   double load_factor = get_load_factor();
484   log_debug(stringtable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
485   // We prefer growing, since that also removes dead items
486   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
487     grow(jt);
488   } else {
489     clean_dead_entries(jt);
490   }
491 }
492 
<a name="34" id="anc34"></a><span class="line-removed">493 void StringTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-removed">494   StringTable::the_table()-&gt;concurrent_work(jt);</span>
<span class="line-removed">495 }</span>
<span class="line-removed">496 </span>
497 // Rehash
498 bool StringTable::do_rehash() {
499   if (!_local_table-&gt;is_safepoint_safe()) {
500     return false;
501   }
502 
<a name="35" id="anc35"></a><span class="line-modified">503   // We use max size</span>
<span class="line-modified">504   StringTableHash* new_table = new StringTableHash(END_SIZE, END_SIZE, REHASH_LEN);</span>

505   // Use alt hash from now on
506   _alt_hash = true;
507   if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
508     _alt_hash = false;
509     delete new_table;
510     return false;
511   }
512 
513   // free old table
514   delete _local_table;
515   _local_table = new_table;
516 
517   return true;
518 }
519 
<a name="36" id="anc36"></a><span class="line-modified">520 void StringTable::try_rehash_table() {</span>
521   static bool rehashed = false;
522   log_debug(stringtable)(&quot;Table imbalanced, rehashing called.&quot;);
523 
524   // Grow instead of rehash.
525   if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
526       !_local_table-&gt;is_max_size_reached()) {
527     log_debug(stringtable)(&quot;Choosing growing over rehashing.&quot;);
528     trigger_concurrent_work();
529     _needs_rehashing = false;
530     return;
531   }
532   // Already rehashed.
533   if (rehashed) {
534     log_warning(stringtable)(&quot;Rehashing already done, still long lists.&quot;);
535     trigger_concurrent_work();
536     _needs_rehashing = false;
537     return;
538   }
539 
540   murmur_seed = AltHashing::compute_seed();
541   {
542     if (do_rehash()) {
543       rehashed = true;
544     } else {
545       log_info(stringtable)(&quot;Resizes in progress rehashing skipped.&quot;);
546     }
547   }
548   _needs_rehashing = false;
549 }
550 
<a name="37" id="anc37"></a><span class="line-removed">551 void StringTable::rehash_table() {</span>
<span class="line-removed">552   StringTable::the_table()-&gt;try_rehash_table();</span>
<span class="line-removed">553 }</span>
<span class="line-removed">554 </span>
555 // Statistics
556 static int literal_size(oop obj) {
557   // NOTE: this would over-count if (pre-JDK8)
558   // java_lang_Class::has_offset_field() is true and the String.value array is
559   // shared by several Strings. However, starting from JDK8, the String.value
560   // array is not shared anymore.
561   if (obj == NULL) {
562     return 0;
563   } else if (obj-&gt;klass() == SystemDictionary::String_klass()) {
564     return (obj-&gt;size() + java_lang_String::value(obj)-&gt;size()) * HeapWordSize;
565   } else {
566     return obj-&gt;size();
567   }
568 }
569 
570 struct SizeFunc : StackObj {
571   size_t operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
572     oop s = val-&gt;peek();
573     if (s == NULL) {
574       // Dead
575       return 0;
576     }
577     return literal_size(s);
578   };
579 };
580 
<a name="38" id="anc38"></a>






581 void StringTable::print_table_statistics(outputStream* st,
582                                          const char* table_name) {
583   SizeFunc sz;
584   _local_table-&gt;statistics_to(Thread::current(), sz, st, table_name);
585 }
586 
587 // Verification
588 class VerifyStrings : StackObj {
589  public:
590   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
591     oop s = val-&gt;peek();
592     if (s != NULL) {
593       assert(java_lang_String::length(s) &gt;= 0, &quot;Length on string must work.&quot;);
594     }
595     return true;
596   };
597 };
598 
599 // This verification is part of Universe::verify() and needs to be quick.
600 void StringTable::verify() {
601   Thread* thr = Thread::current();
602   VerifyStrings vs;
<a name="39" id="anc39"></a><span class="line-modified">603   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vs)) {</span>
604     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
605   }
606 }
607 
608 // Verification and comp
609 class VerifyCompStrings : StackObj {
610   GrowableArray&lt;oop&gt;* _oops;
611  public:
612   size_t _errors;
613   VerifyCompStrings(GrowableArray&lt;oop&gt;* oops) : _oops(oops), _errors(0) {}
614   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
615     oop s = val-&gt;resolve();
616     if (s == NULL) {
617       return true;
618     }
619     int len = _oops-&gt;length();
620     for (int i = 0; i &lt; len; i++) {
621       bool eq = java_lang_String::equals(s, _oops-&gt;at(i));
622       assert(!eq, &quot;Duplicate strings&quot;);
623       if (eq) {
624         _errors++;
625       }
626     }
627     _oops-&gt;push(s);
628     return true;
629   };
630 };
631 
632 size_t StringTable::verify_and_compare_entries() {
633   Thread* thr = Thread::current();
634   GrowableArray&lt;oop&gt;* oops =
635     new (ResourceObj::C_HEAP, mtInternal)
<a name="40" id="anc40"></a><span class="line-modified">636       GrowableArray&lt;oop&gt;((int)the_table()-&gt;_current_size, true);</span>
637 
638   VerifyCompStrings vcs(oops);
<a name="41" id="anc41"></a><span class="line-modified">639   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vcs)) {</span>
640     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
641   }
642   delete oops;
643   return vcs._errors;
644 }
645 
646 // Dumping
647 class PrintString : StackObj {
648   Thread* _thr;
649   outputStream* _st;
650  public:
651   PrintString(Thread* thr, outputStream* st) : _thr(thr), _st(st) {}
652   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
653     oop s = val-&gt;peek();
654     if (s == NULL) {
655       return true;
656     }
657     typeArrayOop value     = java_lang_String::value_no_keepalive(s);
658     int          length    = java_lang_String::length(s);
659     bool         is_latin1 = java_lang_String::is_latin1(s);
660 
661     if (length &lt;= 0) {
662       _st-&gt;print(&quot;%d: &quot;, length);
663     } else {
664       ResourceMark rm(_thr);
665       int utf8_length = length;
666       char* utf8_string;
667 
668       if (!is_latin1) {
669         jchar* chars = value-&gt;char_at_addr(0);
670         utf8_string = UNICODE::as_utf8(chars, utf8_length);
671       } else {
672         jbyte* bytes = value-&gt;byte_at_addr(0);
673         utf8_string = UNICODE::as_utf8(bytes, utf8_length);
674       }
675 
676       _st-&gt;print(&quot;%d: &quot;, utf8_length);
677       HashtableTextDump::put_utf8(_st, utf8_string, utf8_length);
678     }
679     _st-&gt;cr();
680     return true;
681   };
682 };
683 
684 void StringTable::dump(outputStream* st, bool verbose) {
685   if (!verbose) {
<a name="42" id="anc42"></a><span class="line-modified">686     the_table()-&gt;print_table_statistics(st, &quot;StringTable&quot;);</span>
687   } else {
688     Thread* thr = Thread::current();
689     ResourceMark rm(thr);
690     st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
691     PrintString ps(thr, st);
<a name="43" id="anc43"></a><span class="line-modified">692     if (!the_table()-&gt;_local_table-&gt;try_scan(thr, ps)) {</span>
693       st-&gt;print_cr(&quot;dump unavailable at this moment&quot;);
694     }
695   }
696 }
697 
698 // Utility for dumping strings
699 StringtableDCmd::StringtableDCmd(outputStream* output, bool heap) :
700                                  DCmdWithParser(output, heap),
701   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each string in the table&quot;,
702            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
703   _dcmdparser.add_dcmd_option(&amp;_verbose);
704 }
705 
706 void StringtableDCmd::execute(DCmdSource source, TRAPS) {
707   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpStrings,
708                          _verbose.value());
709   VMThread::execute(&amp;dumper);
710 }
711 
712 int StringtableDCmd::num_arguments() {
713   ResourceMark rm;
714   StringtableDCmd* dcmd = new StringtableDCmd(NULL, false);
715   if (dcmd != NULL) {
716     DCmdMark mark(dcmd);
717     return dcmd-&gt;_dcmdparser.num_arguments();
718   } else {
719     return 0;
720   }
721 }
722 
723 // Sharing
724 #if INCLUDE_CDS_JAVA_HEAP
725 oop StringTable::lookup_shared(const jchar* name, int len, unsigned int hash) {
726   assert(hash == java_lang_String::hash_code(name, len),
727          &quot;hash must be computed using java_lang_String::hash_code&quot;);
728   return _shared_table.lookup(name, hash, len);
729 }
730 
731 oop StringTable::create_archived_string(oop s, Thread* THREAD) {
732   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);
733 
734   if (HeapShared::is_archived_object(s)) {
735     return s;
736   }
737 
738   oop new_s = NULL;
739   typeArrayOop v = java_lang_String::value_no_keepalive(s);
740   typeArrayOop new_v = (typeArrayOop)HeapShared::archive_heap_object(v, THREAD);
741   if (new_v == NULL) {
742     return NULL;
743   }
744   new_s = HeapShared::archive_heap_object(s, THREAD);
745   if (new_s == NULL) {
746     return NULL;
747   }
748 
749   // adjust the pointer to the &#39;value&#39; field in the new String oop
750   java_lang_String::set_value_raw(new_s, new_v);
751   return new_s;
752 }
753 
754 struct CopyToArchive : StackObj {
755   CompactHashtableWriter* _writer;
756   CopyToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
757   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
758     oop s = val-&gt;peek();
759     if (s == NULL) {
760       return true;
761     }
762     unsigned int hash = java_lang_String::hash_code(s);
<a name="44" id="anc44"></a><span class="line-removed">763     if (hash == 0) {</span>
<span class="line-removed">764       // We do not archive Strings with a 0 hashcode because ......</span>
<span class="line-removed">765       return true;</span>
<span class="line-removed">766     }</span>
<span class="line-removed">767 </span>
<span class="line-removed">768     java_lang_String::set_hash(s, hash);</span>
769     oop new_s = StringTable::create_archived_string(s, Thread::current());
770     if (new_s == NULL) {
771       return true;
772     }
773 
774     val-&gt;replace(new_s);
775     // add to the compact table
776     _writer-&gt;add(hash, CompressedOops::encode(new_s));
777     return true;
778   }
779 };
780 
781 void StringTable::copy_shared_string_table(CompactHashtableWriter* writer) {
782   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
783 
784   CopyToArchive copy(writer);
<a name="45" id="anc45"></a><span class="line-modified">785   StringTable::the_table()-&gt;_local_table-&gt;do_safepoint_scan(copy);</span>
786 }
787 
788 void StringTable::write_to_archive() {
789   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
790 
791   _shared_table.reset();
<a name="46" id="anc46"></a><span class="line-modified">792   int num_buckets = CompactHashtableWriter::default_num_buckets(</span>
<span class="line-removed">793       StringTable::the_table()-&gt;_items_count);</span>
<span class="line-removed">794   CompactHashtableWriter writer(num_buckets,</span>
<span class="line-removed">795                                 &amp;MetaspaceShared::stats()-&gt;string);</span>
796 
797   // Copy the interned strings into the &quot;string space&quot; within the java heap
798   copy_shared_string_table(&amp;writer);
799   writer.dump(&amp;_shared_table, &quot;string&quot;);
800 }
801 
802 void StringTable::serialize_shared_table_header(SerializeClosure* soc) {
803   _shared_table.serialize_header(soc);
804 
805   if (soc-&gt;writing()) {
806     // Sanity. Make sure we don&#39;t use the shared table at dump time
807     _shared_table.reset();
808   } else if (!HeapShared::closed_archive_heap_region_mapped()) {
809     _shared_table.reset();
810   }
811 }
812 
813 class SharedStringIterator {
814   OopClosure* _oop_closure;
815 public:
816   SharedStringIterator(OopClosure* f) : _oop_closure(f) {}
817   void do_value(oop string) {
818     _oop_closure-&gt;do_oop(&amp;string);
819   }
820 };
821 
822 void StringTable::shared_oops_do(OopClosure* f) {
823   SharedStringIterator iter(f);
824   _shared_table.iterate(&amp;iter);
825 }
826 #endif //INCLUDE_CDS_JAVA_HEAP
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>
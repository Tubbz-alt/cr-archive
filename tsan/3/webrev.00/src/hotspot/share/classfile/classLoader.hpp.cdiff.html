<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classLoader.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #ifndef SHARE_CLASSFILE_CLASSLOADER_HPP
  #define SHARE_CLASSFILE_CLASSLOADER_HPP
  
  #include &quot;jimage.hpp&quot;
<span class="line-added">+ #include &quot;runtime/arguments.hpp&quot;</span>
  #include &quot;runtime/handles.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;utilities/exceptions.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,41 ***</span>
  template &lt;typename T&gt; class GrowableArray;
  
  class ClassPathEntry : public CHeapObj&lt;mtClass&gt; {
  private:
    ClassPathEntry* volatile _next;
  public:
    ClassPathEntry* next() const;
    virtual ~ClassPathEntry() {}
    void set_next(ClassPathEntry* next);
<span class="line-modified">!   virtual bool is_modules_image() const = 0;</span>
<span class="line-modified">!   virtual bool is_jar_file() const = 0;</span>
    virtual const char* name() const = 0;
<span class="line-modified">!   virtual JImageFile* jimage() const = 0;</span>
<span class="line-modified">!   virtual void close_jimage() = 0;</span>
    // Constructor
    ClassPathEntry() : _next(NULL) {}
    // Attempt to locate file_name through this class path entry.
    // Returns a class file parsing stream if successfull.
    virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;
  };
  
  class ClassPathDirEntry: public ClassPathEntry {
   private:
    const char* _dir;           // Name of directory
   public:
<span class="line-removed">-   bool is_modules_image() const { return false; }</span>
<span class="line-removed">-   bool is_jar_file() const { return false;  }</span>
    const char* name() const { return _dir; }
<span class="line-modified">!   JImageFile* jimage() const { return NULL; }</span>
<span class="line-modified">!   void close_jimage() {}</span>
<span class="line-modified">!   ClassPathDirEntry(const char* dir);</span>
    virtual ~ClassPathDirEntry() {}
    ClassFileStream* open_stream(const char* name, TRAPS);
  };
  
<span class="line-removed">- </span>
  // Type definitions for zip file and zip file entry
  typedef void* jzfile;
  typedef struct {
    char *name;                   /* entry name */
    jlong time;                   /* modification time */
<span class="line-new-header">--- 46,46 ---</span>
  template &lt;typename T&gt; class GrowableArray;
  
  class ClassPathEntry : public CHeapObj&lt;mtClass&gt; {
  private:
    ClassPathEntry* volatile _next;
<span class="line-added">+ protected:</span>
<span class="line-added">+   const char* copy_path(const char*path);</span>
  public:
    ClassPathEntry* next() const;
    virtual ~ClassPathEntry() {}
    void set_next(ClassPathEntry* next);
<span class="line-modified">!   virtual bool is_modules_image() const { return false; }</span>
<span class="line-modified">!   virtual bool is_jar_file() const { return false; }</span>
<span class="line-added">+   // Is this entry created from the &quot;Class-path&quot; attribute from a JAR Manifest?</span>
<span class="line-added">+   virtual bool from_class_path_attr() const { return false; }</span>
    virtual const char* name() const = 0;
<span class="line-modified">!   virtual JImageFile* jimage() const { return NULL; }</span>
<span class="line-modified">!   virtual void close_jimage() {}</span>
    // Constructor
    ClassPathEntry() : _next(NULL) {}
    // Attempt to locate file_name through this class path entry.
    // Returns a class file parsing stream if successfull.
    virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;
<span class="line-added">+   // Open the stream for a specific class loader</span>
<span class="line-added">+   virtual ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {</span>
<span class="line-added">+     return open_stream(name, THREAD);</span>
<span class="line-added">+   }</span>
  };
  
  class ClassPathDirEntry: public ClassPathEntry {
   private:
    const char* _dir;           // Name of directory
   public:
    const char* name() const { return _dir; }
<span class="line-modified">!   ClassPathDirEntry(const char* dir) {</span>
<span class="line-modified">!     _dir = copy_path(dir);</span>
<span class="line-modified">!   }</span>
    virtual ~ClassPathDirEntry() {}
    ClassFileStream* open_stream(const char* name, TRAPS);
  };
  
  // Type definitions for zip file and zip file entry
  typedef void* jzfile;
  typedef struct {
    char *name;                   /* entry name */
    jlong time;                   /* modification time */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,17 ***</span>
  
  class ClassPathZipEntry: public ClassPathEntry {
   private:
    jzfile* _zip;              // The zip archive
    const char*   _zip_name;   // Name of zip archive
   public:
<span class="line-removed">-   bool is_modules_image() const { return false; }</span>
    bool is_jar_file() const { return true;  }
    const char* name() const { return _zip_name; }
<span class="line-modified">!   JImageFile* jimage() const { return NULL; }</span>
<span class="line-removed">-   void close_jimage() {}</span>
<span class="line-removed">-   ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append);</span>
    virtual ~ClassPathZipEntry();
    u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
    ClassFileStream* open_stream(const char* name, TRAPS);
    void contents_do(void f(const char* name, void* context), void* context);
  };
<span class="line-new-header">--- 99,16 ---</span>
  
  class ClassPathZipEntry: public ClassPathEntry {
   private:
    jzfile* _zip;              // The zip archive
    const char*   _zip_name;   // Name of zip archive
<span class="line-added">+   bool _from_class_path_attr; // From the &quot;Class-path&quot; attribute of a jar file</span>
   public:
    bool is_jar_file() const { return true;  }
<span class="line-added">+   bool from_class_path_attr() const { return _from_class_path_attr; }</span>
    const char* name() const { return _zip_name; }
<span class="line-modified">!   ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append, bool from_class_path_attr);</span>
    virtual ~ClassPathZipEntry();
    u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
    ClassFileStream* open_stream(const char* name, TRAPS);
    void contents_do(void f(const char* name, void* context), void* context);
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,20 ***</span>
  // For java image files
  class ClassPathImageEntry: public ClassPathEntry {
  private:
    JImageFile* _jimage;
    const char* _name;
  public:
    bool is_modules_image() const;
<span class="line-removed">-   bool is_jar_file() const { return false; }</span>
    bool is_open() const { return _jimage != NULL; }
    const char* name() const { return _name == NULL ? &quot;&quot; : _name; }
    JImageFile* jimage() const { return _jimage; }
    void close_jimage();
    ClassPathImageEntry(JImageFile* jimage, const char* name);
    virtual ~ClassPathImageEntry();
    ClassFileStream* open_stream(const char* name, TRAPS);
  };
  
  // ModuleClassPathList contains a linked list of ClassPathEntry&#39;s
  // that have been specified for a specific module.  Currently,
  // the only way to specify a module/path pair is via the --patch-module
<span class="line-new-header">--- 117,21 ---</span>
  // For java image files
  class ClassPathImageEntry: public ClassPathEntry {
  private:
    JImageFile* _jimage;
    const char* _name;
<span class="line-added">+   DEBUG_ONLY(static ClassPathImageEntry* _singleton;)</span>
  public:
    bool is_modules_image() const;
    bool is_open() const { return _jimage != NULL; }
    const char* name() const { return _name == NULL ? &quot;&quot; : _name; }
    JImageFile* jimage() const { return _jimage; }
    void close_jimage();
    ClassPathImageEntry(JImageFile* jimage, const char* name);
    virtual ~ClassPathImageEntry();
    ClassFileStream* open_stream(const char* name, TRAPS);
<span class="line-added">+   ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS);</span>
  };
  
  // ModuleClassPathList contains a linked list of ClassPathEntry&#39;s
  // that have been specified for a specific module.  Currently,
  // the only way to specify a module/path pair is via the --patch-module
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,12 ***</span>
    ModuleClassPathList(Symbol* module_name);
    ~ModuleClassPathList();
    void add_to_list(ClassPathEntry* new_entry);
  };
  
<span class="line-removed">- class SharedPathsMiscInfo;</span>
<span class="line-removed">- </span>
  class ClassLoader: AllStatic {
   public:
    enum ClassLoaderType {
      BOOT_LOADER = 1,      /* boot loader */
      PLATFORM_LOADER  = 2, /* PlatformClassLoader */
<span class="line-new-header">--- 148,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,12 ***</span>
    static ClassPathEntry* _first_append_entry;
    // Last entry in linked list of appended ClassPathEntry instances
    static ClassPathEntry* _last_append_entry;
  
    // Info used by CDS
<span class="line-removed">-   CDS_ONLY(static SharedPathsMiscInfo * _shared_paths_misc_info;)</span>
<span class="line-removed">- </span>
    CDS_ONLY(static ClassPathEntry* _app_classpath_entries;)
    CDS_ONLY(static ClassPathEntry* _last_app_classpath_entry;)
    CDS_ONLY(static ClassPathEntry* _module_path_entries;)
    CDS_ONLY(static ClassPathEntry* _last_module_path_entry;)
    CDS_ONLY(static void setup_app_search_path(const char* class_path);)
<span class="line-new-header">--- 220,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,27 ***</span>
                                             ClassPathEntry* entry);)
   public:
    CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})
    CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})
  
   protected:
    // Initialization:
    //   - setup the boot loader&#39;s system class path
    //   - setup the boot loader&#39;s patch mod entries, if present
    //   - create the ModuleEntry for java.base
    static void setup_bootstrap_search_path();
    static void setup_boot_search_path(const char *class_path);
    static void setup_patch_mod_entries();
    static void create_javabase();
  
    static void load_zip_library();
    static void load_jimage_library();
  
   public:
    static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,
                                                   bool throw_exception,
<span class="line-modified">!                                                  bool is_boot_append, TRAPS);</span>
  
    // If the package for the fully qualified class name is in the boot
    // loader&#39;s package entry table then add_package() sets the classpath_index
    // field so that get_system_package() will know to return a non-null value
    // for the package&#39;s location.  And, so that the package will be added to
<span class="line-new-header">--- 235,32 ---</span>
                                             ClassPathEntry* entry);)
   public:
    CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})
    CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})
  
<span class="line-added">+   static bool has_bootclasspath_append() { return _first_append_entry != NULL; }</span>
<span class="line-added">+ </span>
   protected:
    // Initialization:
    //   - setup the boot loader&#39;s system class path
    //   - setup the boot loader&#39;s patch mod entries, if present
    //   - create the ModuleEntry for java.base
    static void setup_bootstrap_search_path();
    static void setup_boot_search_path(const char *class_path);
    static void setup_patch_mod_entries();
    static void create_javabase();
  
<span class="line-added">+   static void* dll_lookup(void* lib, const char* name, const char* path);</span>
<span class="line-added">+   static void load_java_library();</span>
    static void load_zip_library();
    static void load_jimage_library();
  
   public:
    static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,
                                                   bool throw_exception,
<span class="line-modified">!                                                  bool is_boot_append,</span>
<span class="line-added">+                                                  bool from_class_path_attr, TRAPS);</span>
  
    // If the package for the fully qualified class name is in the boot
    // loader&#39;s package entry table then add_package() sets the classpath_index
    // field so that get_system_package() will know to return a non-null value
    // for the package&#39;s location.  And, so that the package will be added to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,15 ***</span>
    static const char* file_name_for_class_name(const char* class_name,
                                                int class_name_len);
    static PackageEntry* get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS);
  
   public:
<span class="line-removed">-   static jboolean decompress(void *in, u8 inSize, void *out, u8 outSize, char **pmsg);</span>
    static int crc32(int crc, const char* buf, int len);
    static bool update_class_path_entry_list(const char *path,
                                             bool check_for_duplicates,
                                             bool is_boot_append,
                                             bool throw_exception=true);
    CDS_ONLY(static void update_module_path_entry_list(const char *path, TRAPS);)
    static void print_bootclasspath();
  
    // Timing
<span class="line-new-header">--- 275,15 ---</span>
    static const char* file_name_for_class_name(const char* class_name,
                                                int class_name_len);
    static PackageEntry* get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS);
  
   public:
    static int crc32(int crc, const char* buf, int len);
    static bool update_class_path_entry_list(const char *path,
                                             bool check_for_duplicates,
                                             bool is_boot_append,
<span class="line-added">+                                            bool from_class_path_attr,</span>
                                             bool throw_exception=true);
    CDS_ONLY(static void update_module_path_entry_list(const char *path, TRAPS);)
    static void print_bootclasspath();
  
    // Timing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,27 ***</span>
    static int num_app_classpath_entries();
  
    // Helper function used by CDS code to get the number of module path
    // entries during shared classpath setup time.
    static int num_module_path_entries() {
<span class="line-modified">!     assert(DumpSharedSpaces, &quot;Should only be called at CDS dump time&quot;);</span>
      int num_entries = 0;
      ClassPathEntry* e= ClassLoader::_module_path_entries;
      while (e != NULL) {
        num_entries ++;
        e = e-&gt;next();
      }
      return num_entries;
    }
<span class="line-removed">-   static void  finalize_shared_paths_misc_info();</span>
<span class="line-removed">-   static int   get_shared_paths_misc_info_size();</span>
<span class="line-removed">-   static void* get_shared_paths_misc_info();</span>
<span class="line-removed">-   static bool  check_shared_paths_misc_info(void* info, int size);</span>
    static void  exit_with_path_failure(const char* error, const char* message);
    static char* skip_uri_protocol(char* source);
    static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
  #endif
    static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,
                                                  const char* file_name, jlong &amp;size);
  
    static void  trace_class_path(const char* msg, const char* name = NULL);
  
<span class="line-new-header">--- 397,26 ---</span>
    static int num_app_classpath_entries();
  
    // Helper function used by CDS code to get the number of module path
    // entries during shared classpath setup time.
    static int num_module_path_entries() {
<span class="line-modified">!     Arguments::assert_is_dumping_archive();</span>
      int num_entries = 0;
      ClassPathEntry* e= ClassLoader::_module_path_entries;
      while (e != NULL) {
        num_entries ++;
        e = e-&gt;next();
      }
      return num_entries;
    }
    static void  exit_with_path_failure(const char* error, const char* message);
    static char* skip_uri_protocol(char* source);
    static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
  #endif
<span class="line-added">+ </span>
<span class="line-added">+   static char* lookup_vm_options();</span>
<span class="line-added">+ </span>
    static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,
                                                  const char* file_name, jlong &amp;size);
  
    static void  trace_class_path(const char* msg, const char* name = NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,12 ***</span>
    // obtain package name from a fully qualified class name
    // *bad_class_name is set to true if there&#39;s a problem with parsing class_name, to
    // distinguish from a class_name with no package name, as both cases have a NULL return value
    static const char* package_from_name(const char* const class_name, bool* bad_class_name = NULL);
  
<span class="line-removed">-   static bool is_modules_image(const char* name) { return string_ends_with(name, MODULES_IMAGE_NAME); }</span>
<span class="line-removed">- </span>
    // Debugging
    static void verify()              PRODUCT_RETURN;
  };
  
  // PerfClassTraceTime is used to measure time for class loading related events.
<span class="line-new-header">--- 443,10 ---</span>
</pre>
<center><a href="classLoader.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
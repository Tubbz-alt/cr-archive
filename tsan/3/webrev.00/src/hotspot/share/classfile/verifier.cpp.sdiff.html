<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;

  28 #include &quot;classfile/javaClasses.hpp&quot;
  29 #include &quot;classfile/stackMapTable.hpp&quot;
  30 #include &quot;classfile/stackMapFrame.hpp&quot;
  31 #include &quot;classfile/stackMapTableFormat.hpp&quot;

  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;classfile/vmSymbols.hpp&quot;
  35 #include &quot;interpreter/bytecodes.hpp&quot;
  36 #include &quot;interpreter/bytecodeStream.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;logging/logStream.hpp&quot;
  39 #include &quot;memory/oopFactory.hpp&quot;
  40 #include &quot;memory/resourceArea.hpp&quot;

  41 #include &quot;oops/constantPool.inline.hpp&quot;
  42 #include &quot;oops/instanceKlass.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">  50 #include &quot;runtime/orderAccess.hpp&quot;</span>
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/safepointVerifiers.hpp&quot;
  53 #include &quot;runtime/thread.hpp&quot;
  54 #include &quot;services/threadService.hpp&quot;
  55 #include &quot;utilities/align.hpp&quot;
  56 #include &quot;utilities/bytes.hpp&quot;
  57 
  58 #define NOFAILOVER_MAJOR_VERSION                       51
  59 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  60 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
  61 #define MAX_ARRAY_DIMENSIONS 255
  62 
<span class="line-modified">  63 // Access to external entry for VerifyClassCodes - old byte code verifier</span>
  64 
  65 extern &quot;C&quot; {
<span class="line-modified">  66   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint);</span>
<span class="line-removed">  67   typedef jboolean (*verify_byte_codes_fn_new_t)(JNIEnv *, jclass, char *, jint, jint);</span>
  68 }
  69 
<span class="line-modified">  70 static void* volatile _verify_byte_codes_fn = NULL;</span>
  71 
<span class="line-modified">  72 static volatile jint _is_new_verify_byte_codes_fn = (jint) true;</span>
  73 
<span class="line-modified">  74 static void* verify_byte_codes_fn() {</span>
<span class="line-modified">  75   if (OrderAccess::load_acquire(&amp;_verify_byte_codes_fn) == NULL) {</span>
<span class="line-modified">  76     void *lib_handle = os::native_java_library();</span>
<span class="line-modified">  77     void *func = os::dll_lookup(lib_handle, &quot;VerifyClassCodesForMajorVersion&quot;);</span>
<span class="line-modified">  78     OrderAccess::release_store(&amp;_verify_byte_codes_fn, func);</span>
<span class="line-modified">  79     if (func == NULL) {</span>
<span class="line-modified">  80       _is_new_verify_byte_codes_fn = false;</span>
<span class="line-modified">  81       func = os::dll_lookup(lib_handle, &quot;VerifyClassCodes&quot;);</span>
<span class="line-modified">  82       OrderAccess::release_store(&amp;_verify_byte_codes_fn, func);</span>
<span class="line-modified">  83     }</span>
<span class="line-modified">  84   }</span>
<span class="line-modified">  85   return (void*)_verify_byte_codes_fn;</span>











  86 }
  87 
  88 
  89 // Methods in Verifier
  90 
  91 bool Verifier::should_verify_for(oop class_loader, bool should_verify_class) {
  92   return (class_loader == NULL || !should_verify_class) ?
  93     BytecodeVerificationLocal : BytecodeVerificationRemote;
  94 }
  95 
  96 bool Verifier::relax_access_for(oop loader) {
  97   bool trusted = java_lang_ClassLoader::is_trusted_loader(loader);
  98   bool need_verify =
  99     // verifyAll
 100     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
 101     // verifyRemote
 102     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
 103   return !need_verify;
 104 }
 105 
</pre>
<hr />
<pre>
 145   // is IMPORTANT:
 146   if (klass-&gt;java_mirror() != NULL) {
 147     klass-&gt;java_mirror()-&gt;identity_hash();
 148   }
 149 
 150   if (!is_eligible_for_verification(klass, should_verify_class)) {
 151     return true;
 152   }
 153 
 154   // Timer includes any side effects of class verification (resolution,
 155   // etc), but not recursive calls to Verifier::verify().
 156   JavaThread* jt = (JavaThread*)THREAD;
 157   PerfClassTraceTime timer(ClassLoader::perf_class_verify_time(),
 158                            ClassLoader::perf_class_verify_selftime(),
 159                            ClassLoader::perf_classes_verified(),
 160                            jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 161                            jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 162                            PerfClassTraceTime::CLASS_VERIFY);
 163 
 164   // If the class should be verified, first see if we can use the split
<span class="line-modified"> 165   // verifier.  If not, or if verification fails and FailOverToOldVerifier</span>
<span class="line-modified"> 166   // is set, then call the inference verifier.</span>
 167   Symbol* exception_name = NULL;
 168   const size_t message_buffer_len = klass-&gt;name()-&gt;utf8_length() + 1024;
 169   char* message_buffer = NULL;
 170   char* exception_message = NULL;
 171 
<span class="line-removed"> 172   bool can_failover = FailOverToOldVerifier &amp;&amp;</span>
<span class="line-removed"> 173      klass-&gt;major_version() &lt; NOFAILOVER_MAJOR_VERSION;</span>
<span class="line-removed"> 174 </span>
 175   log_info(class, init)(&quot;Start class verification for: %s&quot;, klass-&gt;external_name());
 176   if (klass-&gt;major_version() &gt;= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
 177     ClassVerifier split_verifier(klass, THREAD);
 178     split_verifier.verify_class(THREAD);
 179     exception_name = split_verifier.result();
<span class="line-modified"> 180     if (can_failover &amp;&amp; !HAS_PENDING_EXCEPTION &amp;&amp;</span>









 181         (exception_name == vmSymbols::java_lang_VerifyError() ||
 182          exception_name == vmSymbols::java_lang_ClassFormatError())) {
 183       log_info(verification)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
 184       log_info(class, init)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
 185       message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
 186       exception_message = message_buffer;
 187       exception_name = inference_verify(
 188         klass, message_buffer, message_buffer_len, THREAD);
 189     }
 190     if (exception_name != NULL) {
 191       exception_message = split_verifier.exception_message();
 192     }
 193   } else {
 194     message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
 195     exception_message = message_buffer;
 196     exception_name = inference_verify(
 197         klass, message_buffer, message_buffer_len, THREAD);
 198   }
 199 
 200   LogTarget(Info, class, init) lt1;
</pre>
<hr />
<pre>
 256     // already been rewritten to contain constant pool cache indices,
 257     // which the verifier can&#39;t understand.
 258     // Shared classes shouldn&#39;t have stackmaps either.
 259     !klass-&gt;is_shared() &amp;&amp;
 260 
 261     // As of the fix for 4486457 we disable verification for all of the
 262     // dynamically-generated bytecodes associated with the 1.4
 263     // reflection implementation, not just those associated with
 264     // jdk/internal/reflect/SerializationConstructorAccessor.
 265     // NOTE: this is called too early in the bootstrapping process to be
 266     // guarded by Universe::is_gte_jdk14x_version().
 267     // Also for lambda generated code, gte jdk8
 268     (!is_reflect));
 269 }
 270 
 271 Symbol* Verifier::inference_verify(
 272     InstanceKlass* klass, char* message, size_t message_len, TRAPS) {
 273   JavaThread* thread = (JavaThread*)THREAD;
 274   JNIEnv *env = thread-&gt;jni_environment();
 275 
<span class="line-modified"> 276   void* verify_func = verify_byte_codes_fn();</span>
 277 
 278   if (verify_func == NULL) {
 279     jio_snprintf(message, message_len, &quot;Could not link verifier&quot;);
 280     return vmSymbols::java_lang_VerifyError();
 281   }
 282 
 283   ResourceMark rm(THREAD);
 284   log_info(verification)(&quot;Verifying class %s with old format&quot;, klass-&gt;external_name());
 285 
 286   jclass cls = (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
 287   jint result;
 288 
 289   {
 290     HandleMark hm(thread);
 291     ThreadToNativeFromVM ttn(thread);
 292     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
 293     // code knows that we have left the VM
 294 
<span class="line-modified"> 295     if (_is_new_verify_byte_codes_fn) {</span>
<span class="line-removed"> 296       verify_byte_codes_fn_new_t func =</span>
<span class="line-removed"> 297         CAST_TO_FN_PTR(verify_byte_codes_fn_new_t, verify_func);</span>
<span class="line-removed"> 298       result = (*func)(env, cls, message, (int)message_len,</span>
<span class="line-removed"> 299           klass-&gt;major_version());</span>
<span class="line-removed"> 300     } else {</span>
<span class="line-removed"> 301       verify_byte_codes_fn_t func =</span>
<span class="line-removed"> 302         CAST_TO_FN_PTR(verify_byte_codes_fn_t, verify_func);</span>
<span class="line-removed"> 303       result = (*func)(env, cls, message, (int)message_len);</span>
<span class="line-removed"> 304     }</span>
 305   }
 306 
 307   JNIHandles::destroy_local(cls);
 308 
 309   // These numbers are chosen so that VerifyClassCodes interface doesn&#39;t need
 310   // to be changed (still return jboolean (unsigned char)), and result is
 311   // 1 when verification is passed.
 312   if (result == 0) {
 313     return vmSymbols::java_lang_VerifyError();
 314   } else if (result == 1) {
 315     return NULL; // verified.
 316   } else if (result == 2) {
 317     THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, NULL);
 318   } else if (result == 3) {
 319     return vmSymbols::java_lang_ClassFormatError();
 320   } else {
 321     ShouldNotReachHere();
 322     return NULL;
 323   }
 324 }
</pre>
<hr />
<pre>
 557     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 558     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 559       ss-&gt;indent();
 560       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 561         sm_frame-&gt;print_truncated(ss, current_offset);
 562         return;
 563       }
 564       sm_frame-&gt;print_on(ss, current_offset);
 565       ss-&gt;cr();
 566       current_offset += sm_frame-&gt;offset_delta();
 567       sm_frame = sm_frame-&gt;next();
 568     }
 569   }
 570 }
 571 
 572 // Methods in ClassVerifier
 573 
 574 ClassVerifier::ClassVerifier(
 575     InstanceKlass* klass, TRAPS)
 576     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
<span class="line-modified"> 577       _message(NULL), _klass(klass) {</span>
 578   _this_type = VerificationType::reference_type(klass-&gt;name());
 579 }
 580 
 581 ClassVerifier::~ClassVerifier() {
 582   // Decrement the reference count for any symbols created.
 583   if (_symbols != NULL) {
 584     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 585       Symbol* s = _symbols-&gt;at(i);
 586       s-&gt;decrement_refcount();
 587     }
 588   }
 589 }
 590 
 591 VerificationType ClassVerifier::object_type() const {
 592   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 593 }
 594 
<span class="line-modified"> 595 TypeOrigin ClassVerifier::ref_ctx(const char* sig, TRAPS) {</span>
 596   VerificationType vt = VerificationType::reference_type(
<span class="line-modified"> 597       create_temporary_symbol(sig, (int)strlen(sig), THREAD));</span>
 598   return TypeOrigin::implicit(vt);
 599 }
 600 
 601 void ClassVerifier::verify_class(TRAPS) {
 602   log_info(verification)(&quot;Verifying class %s with new format&quot;, _klass-&gt;external_name());
 603 







 604   Array&lt;Method*&gt;* methods = _klass-&gt;methods();
 605   int num_methods = methods-&gt;length();
 606 
 607   for (int index = 0; index &lt; num_methods; index++) {
 608     // Check for recursive re-verification before each method.
 609     if (was_recursively_verified())  return;
 610 
 611     Method* m = methods-&gt;at(index);
 612     if (m-&gt;is_native() || m-&gt;is_abstract() || m-&gt;is_overpass()) {
 613       // If m is native or abstract, skip it.  It is checked in class file
 614       // parser that methods do not override a final method.  Overpass methods
 615       // are trusted since the VM generates them.
 616       continue;
 617     }
 618     verify_method(methodHandle(THREAD, m), CHECK_VERIFY(this));
 619   }
 620 
 621   if (was_recursively_verified()){
 622     log_info(verification)(&quot;Recursive verification detected for: %s&quot;, _klass-&gt;external_name());
 623     log_info(class, init)(&quot;Recursive verification detected for: %s&quot;,
 624                         _klass-&gt;external_name());
 625   }
 626 }
 627 

















































 628 void ClassVerifier::verify_method(const methodHandle&amp; m, TRAPS) {
 629   HandleMark hm(THREAD);
 630   _method = m;   // initialize _method
 631   log_info(verification)(&quot;Verifying method %s&quot;, m-&gt;name_and_sig_as_C_string());
 632 
 633 // For clang, the only good constant format string is a literal constant format string.
 634 #define bad_type_msg &quot;Bad type on operand stack in %s&quot;
 635 
 636   int32_t max_stack = m-&gt;verifier_max_stack();
 637   int32_t max_locals = m-&gt;max_locals();
 638   constantPoolHandle cp(THREAD, m-&gt;constants());
 639 
 640   // Method signature was checked in ClassFileParser.
 641   assert(SignatureVerifier::is_valid_method_signature(m-&gt;signature()),
 642          &quot;Invalid method signature&quot;);
 643 
 644   // Initial stack map frame: offset is 0, stack is initially empty.
 645   StackMapFrame current_frame(max_locals, max_stack, this);
 646   // Set initial locals
 647   VerificationType return_type = current_frame.set_locals_from_arg(
</pre>
<hr />
<pre>
 657   int ex_min = code_length;
 658   int ex_max = -1;
 659   // Look through each item on the exception table. Each of the fields must refer
 660   // to a legal instruction.
 661   if (was_recursively_verified()) return;
 662   verify_exception_handler_table(
 663     code_length, code_data, ex_min, ex_max, CHECK_VERIFY(this));
 664 
 665   // Look through each entry on the local variable table and make sure
 666   // its range of code array offsets is valid. (4169817)
 667   if (m-&gt;has_localvariable_table()) {
 668     verify_local_variable_table(code_length, code_data, CHECK_VERIFY(this));
 669   }
 670 
 671   Array&lt;u1&gt;* stackmap_data = m-&gt;stackmap_data();
 672   StackMapStream stream(stackmap_data);
 673   StackMapReader reader(this, &amp;stream, code_data, code_length, THREAD);
 674   StackMapTable stackmap_table(&amp;reader, &amp;current_frame, max_locals, max_stack,
 675                                code_data, code_length, CHECK_VERIFY(this));
 676 
<span class="line-modified"> 677   LogTarget(Info, verification) lt;</span>
 678   if (lt.is_enabled()) {
 679     ResourceMark rm(THREAD);
 680     LogStream ls(lt);
 681     stackmap_table.print_on(&amp;ls);
 682   }
 683 
 684   RawBytecodeStream bcs(m);
 685 
 686   // Scan the byte code linearly from the start to the end
 687   bool no_control_flow = false; // Set to true when there is no direct control
 688                                 // flow from current instruction to the next
 689                                 // instruction in sequence
 690 
 691   Bytecodes::Code opcode;
 692   while (!bcs.is_last_bytecode()) {
 693     // Check for recursive re-verification before each bytecode.
 694     if (was_recursively_verified())  return;
 695 
 696     opcode = bcs.raw_next();
 697     u2 bci = bcs.bci();
</pre>
<hr />
<pre>
 701     current_frame.set_mark();
 702 
 703     // Make sure every offset in stackmap table point to the beginning to
 704     // an instruction. Match current_frame to stackmap_table entry with
 705     // the same offset if exists.
 706     stackmap_index = verify_stackmap_table(
 707       stackmap_index, bci, &amp;current_frame, &amp;stackmap_table,
 708       no_control_flow, CHECK_VERIFY(this));
 709 
 710 
 711     bool this_uninit = false;  // Set to true when invokespecial &lt;init&gt; initialized &#39;this&#39;
 712     bool verified_exc_handlers = false;
 713 
 714     // Merge with the next instruction
 715     {
 716       u2 index;
 717       int target;
 718       VerificationType type, type2;
 719       VerificationType atype;
 720 
<span class="line-modified"> 721       LogTarget(Info, verification) lt;</span>
 722       if (lt.is_enabled()) {
 723         ResourceMark rm(THREAD);
 724         LogStream ls(lt);
 725         current_frame.print_on(&amp;ls);
 726         lt.print(&quot;offset = %d,  opcode = %s&quot;, bci,
 727                  opcode == Bytecodes::_illegal ? &quot;illegal&quot; : Bytecodes::name(opcode));
 728       }
 729 
 730       // Make sure wide instruction is in correct format
 731       if (bcs.is_wide()) {
 732         if (opcode != Bytecodes::_iinc   &amp;&amp; opcode != Bytecodes::_iload  &amp;&amp;
 733             opcode != Bytecodes::_aload  &amp;&amp; opcode != Bytecodes::_lload  &amp;&amp;
 734             opcode != Bytecodes::_istore &amp;&amp; opcode != Bytecodes::_astore &amp;&amp;
 735             opcode != Bytecodes::_lstore &amp;&amp; opcode != Bytecodes::_fload  &amp;&amp;
 736             opcode != Bytecodes::_dload  &amp;&amp; opcode != Bytecodes::_fstore &amp;&amp;
 737             opcode != Bytecodes::_dstore) {
 738           /* Unreachable?  RawBytecodeStream&#39;s raw_next() returns &#39;illegal&#39;
 739            * if we encounter a wide instruction that modifies an invalid
 740            * opcode (not one of the ones listed above) */
 741           verify_error(ErrorContext::bad_code(bci), &quot;Bad wide instruction&quot;);
</pre>
<hr />
<pre>
 849           index = opcode - Bytecodes::_dload_0;
 850           verify_dload(index, &amp;current_frame, CHECK_VERIFY(this));
 851           no_control_flow = false; break;
 852         case Bytecodes::_aload :
 853           verify_aload(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
 854           no_control_flow = false; break;
 855         case Bytecodes::_aload_0 :
 856         case Bytecodes::_aload_1 :
 857         case Bytecodes::_aload_2 :
 858         case Bytecodes::_aload_3 :
 859           index = opcode - Bytecodes::_aload_0;
 860           verify_aload(index, &amp;current_frame, CHECK_VERIFY(this));
 861           no_control_flow = false; break;
 862         case Bytecodes::_iaload :
 863           type = current_frame.pop_stack(
 864             VerificationType::integer_type(), CHECK_VERIFY(this));
 865           atype = current_frame.pop_stack(
 866             VerificationType::reference_check(), CHECK_VERIFY(this));
 867           if (!atype.is_int_array()) {
 868             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 869                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;, THREAD)),</span>
 870                 bad_type_msg, &quot;iaload&quot;);
 871             return;
 872           }
 873           current_frame.push_stack(
 874             VerificationType::integer_type(), CHECK_VERIFY(this));
 875           no_control_flow = false; break;
 876         case Bytecodes::_baload :
 877           type = current_frame.pop_stack(
 878             VerificationType::integer_type(), CHECK_VERIFY(this));
 879           atype = current_frame.pop_stack(
 880             VerificationType::reference_check(), CHECK_VERIFY(this));
 881           if (!atype.is_bool_array() &amp;&amp; !atype.is_byte_array()) {
 882             verify_error(
 883                 ErrorContext::bad_type(bci, current_frame.stack_top_ctx()),
 884                 bad_type_msg, &quot;baload&quot;);
 885             return;
 886           }
 887           current_frame.push_stack(
 888             VerificationType::integer_type(), CHECK_VERIFY(this));
 889           no_control_flow = false; break;
 890         case Bytecodes::_caload :
 891           type = current_frame.pop_stack(
 892             VerificationType::integer_type(), CHECK_VERIFY(this));
 893           atype = current_frame.pop_stack(
 894             VerificationType::reference_check(), CHECK_VERIFY(this));
 895           if (!atype.is_char_array()) {
 896             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 897                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;, THREAD)),</span>
 898                 bad_type_msg, &quot;caload&quot;);
 899             return;
 900           }
 901           current_frame.push_stack(
 902             VerificationType::integer_type(), CHECK_VERIFY(this));
 903           no_control_flow = false; break;
 904         case Bytecodes::_saload :
 905           type = current_frame.pop_stack(
 906             VerificationType::integer_type(), CHECK_VERIFY(this));
 907           atype = current_frame.pop_stack(
 908             VerificationType::reference_check(), CHECK_VERIFY(this));
 909           if (!atype.is_short_array()) {
 910             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 911                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;, THREAD)),</span>
 912                 bad_type_msg, &quot;saload&quot;);
 913             return;
 914           }
 915           current_frame.push_stack(
 916             VerificationType::integer_type(), CHECK_VERIFY(this));
 917           no_control_flow = false; break;
 918         case Bytecodes::_laload :
 919           type = current_frame.pop_stack(
 920             VerificationType::integer_type(), CHECK_VERIFY(this));
 921           atype = current_frame.pop_stack(
 922             VerificationType::reference_check(), CHECK_VERIFY(this));
 923           if (!atype.is_long_array()) {
 924             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 925                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;, THREAD)),</span>
 926                 bad_type_msg, &quot;laload&quot;);
 927             return;
 928           }
 929           current_frame.push_stack_2(
 930             VerificationType::long_type(),
 931             VerificationType::long2_type(), CHECK_VERIFY(this));
 932           no_control_flow = false; break;
 933         case Bytecodes::_faload :
 934           type = current_frame.pop_stack(
 935             VerificationType::integer_type(), CHECK_VERIFY(this));
 936           atype = current_frame.pop_stack(
 937             VerificationType::reference_check(), CHECK_VERIFY(this));
 938           if (!atype.is_float_array()) {
 939             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 940                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;, THREAD)),</span>
 941                 bad_type_msg, &quot;faload&quot;);
 942             return;
 943           }
 944           current_frame.push_stack(
 945             VerificationType::float_type(), CHECK_VERIFY(this));
 946           no_control_flow = false; break;
 947         case Bytecodes::_daload :
 948           type = current_frame.pop_stack(
 949             VerificationType::integer_type(), CHECK_VERIFY(this));
 950           atype = current_frame.pop_stack(
 951             VerificationType::reference_check(), CHECK_VERIFY(this));
 952           if (!atype.is_double_array()) {
 953             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 954                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;, THREAD)),</span>
 955                 bad_type_msg, &quot;daload&quot;);
 956             return;
 957           }
 958           current_frame.push_stack_2(
 959             VerificationType::double_type(),
 960             VerificationType::double2_type(), CHECK_VERIFY(this));
 961           no_control_flow = false; break;
 962         case Bytecodes::_aaload : {
 963           type = current_frame.pop_stack(
 964             VerificationType::integer_type(), CHECK_VERIFY(this));
 965           atype = current_frame.pop_stack(
 966             VerificationType::reference_check(), CHECK_VERIFY(this));
 967           if (!atype.is_reference_array()) {
 968             verify_error(ErrorContext::bad_type(bci,
 969                 current_frame.stack_top_ctx(),
 970                 TypeOrigin::implicit(VerificationType::reference_check())),
 971                 bad_type_msg, &quot;aaload&quot;);
 972             return;
 973           }
 974           if (atype.is_null()) {
</pre>
<hr />
<pre>
1023           no_control_flow = false; break;
1024         case Bytecodes::_astore :
1025           verify_astore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1026           no_control_flow = false; break;
1027         case Bytecodes::_astore_0 :
1028         case Bytecodes::_astore_1 :
1029         case Bytecodes::_astore_2 :
1030         case Bytecodes::_astore_3 :
1031           index = opcode - Bytecodes::_astore_0;
1032           verify_astore(index, &amp;current_frame, CHECK_VERIFY(this));
1033           no_control_flow = false; break;
1034         case Bytecodes::_iastore :
1035           type = current_frame.pop_stack(
1036             VerificationType::integer_type(), CHECK_VERIFY(this));
1037           type2 = current_frame.pop_stack(
1038             VerificationType::integer_type(), CHECK_VERIFY(this));
1039           atype = current_frame.pop_stack(
1040             VerificationType::reference_check(), CHECK_VERIFY(this));
1041           if (!atype.is_int_array()) {
1042             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1043                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;, THREAD)),</span>
1044                 bad_type_msg, &quot;iastore&quot;);
1045             return;
1046           }
1047           no_control_flow = false; break;
1048         case Bytecodes::_bastore :
1049           type = current_frame.pop_stack(
1050             VerificationType::integer_type(), CHECK_VERIFY(this));
1051           type2 = current_frame.pop_stack(
1052             VerificationType::integer_type(), CHECK_VERIFY(this));
1053           atype = current_frame.pop_stack(
1054             VerificationType::reference_check(), CHECK_VERIFY(this));
1055           if (!atype.is_bool_array() &amp;&amp; !atype.is_byte_array()) {
1056             verify_error(
1057                 ErrorContext::bad_type(bci, current_frame.stack_top_ctx()),
1058                 bad_type_msg, &quot;bastore&quot;);
1059             return;
1060           }
1061           no_control_flow = false; break;
1062         case Bytecodes::_castore :
1063           current_frame.pop_stack(
1064             VerificationType::integer_type(), CHECK_VERIFY(this));
1065           current_frame.pop_stack(
1066             VerificationType::integer_type(), CHECK_VERIFY(this));
1067           atype = current_frame.pop_stack(
1068             VerificationType::reference_check(), CHECK_VERIFY(this));
1069           if (!atype.is_char_array()) {
1070             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1071                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;, THREAD)),</span>
1072                 bad_type_msg, &quot;castore&quot;);
1073             return;
1074           }
1075           no_control_flow = false; break;
1076         case Bytecodes::_sastore :
1077           current_frame.pop_stack(
1078             VerificationType::integer_type(), CHECK_VERIFY(this));
1079           current_frame.pop_stack(
1080             VerificationType::integer_type(), CHECK_VERIFY(this));
1081           atype = current_frame.pop_stack(
1082             VerificationType::reference_check(), CHECK_VERIFY(this));
1083           if (!atype.is_short_array()) {
1084             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1085                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;, THREAD)),</span>
1086                 bad_type_msg, &quot;sastore&quot;);
1087             return;
1088           }
1089           no_control_flow = false; break;
1090         case Bytecodes::_lastore :
1091           current_frame.pop_stack_2(
1092             VerificationType::long2_type(),
1093             VerificationType::long_type(), CHECK_VERIFY(this));
1094           current_frame.pop_stack(
1095             VerificationType::integer_type(), CHECK_VERIFY(this));
1096           atype = current_frame.pop_stack(
1097             VerificationType::reference_check(), CHECK_VERIFY(this));
1098           if (!atype.is_long_array()) {
1099             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1100                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;, THREAD)),</span>
1101                 bad_type_msg, &quot;lastore&quot;);
1102             return;
1103           }
1104           no_control_flow = false; break;
1105         case Bytecodes::_fastore :
1106           current_frame.pop_stack(
1107             VerificationType::float_type(), CHECK_VERIFY(this));
1108           current_frame.pop_stack
1109             (VerificationType::integer_type(), CHECK_VERIFY(this));
1110           atype = current_frame.pop_stack(
1111             VerificationType::reference_check(), CHECK_VERIFY(this));
1112           if (!atype.is_float_array()) {
1113             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1114                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;, THREAD)),</span>
1115                 bad_type_msg, &quot;fastore&quot;);
1116             return;
1117           }
1118           no_control_flow = false; break;
1119         case Bytecodes::_dastore :
1120           current_frame.pop_stack_2(
1121             VerificationType::double2_type(),
1122             VerificationType::double_type(), CHECK_VERIFY(this));
1123           current_frame.pop_stack(
1124             VerificationType::integer_type(), CHECK_VERIFY(this));
1125           atype = current_frame.pop_stack(
1126             VerificationType::reference_check(), CHECK_VERIFY(this));
1127           if (!atype.is_double_array()) {
1128             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1129                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;, THREAD)),</span>
1130                 bad_type_msg, &quot;dastore&quot;);
1131             return;
1132           }
1133           no_control_flow = false; break;
1134         case Bytecodes::_aastore :
1135           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1136           type2 = current_frame.pop_stack(
1137             VerificationType::integer_type(), CHECK_VERIFY(this));
1138           atype = current_frame.pop_stack(
1139             VerificationType::reference_check(), CHECK_VERIFY(this));
1140           // more type-checking is done at runtime
1141           if (!atype.is_reference_array()) {
1142             verify_error(ErrorContext::bad_type(bci,
1143                 current_frame.stack_top_ctx(),
1144                 TypeOrigin::implicit(VerificationType::reference_check())),
1145                 bad_type_msg, &quot;aastore&quot;);
1146             return;
1147           }
1148           // 4938384: relaxed constraint in JVMS 3nd edition.
1149           no_control_flow = false; break;
</pre>
<hr />
<pre>
1986   va_list va;
1987   va_start(va, msg);
1988   ss.vprint(msg, va);
1989   va_end(va);
1990   _message = ss.as_string();
1991 #ifdef ASSERT
1992   ResourceMark rm;
1993   const char* exception_name = _exception_type-&gt;as_C_string();
1994   Exceptions::debug_check_abort(exception_name, NULL);
1995 #endif // ndef ASSERT
1996 }
1997 
1998 void ClassVerifier::class_format_error(const char* msg, ...) {
1999   stringStream ss;
2000   _exception_type = vmSymbols::java_lang_ClassFormatError();
2001   va_list va;
2002   va_start(va, msg);
2003   ss.vprint(msg, va);
2004   va_end(va);
2005   if (!_method.is_null()) {
<span class="line-modified">2006     ss.print(&quot; in method %s&quot;, _method-&gt;name_and_sig_as_C_string());</span>


2007   }
2008   _message = ss.as_string();
2009 }
2010 
2011 Klass* ClassVerifier::load_class(Symbol* name, TRAPS) {
2012   HandleMark hm(THREAD);
2013   // Get current loader and protection domain first.
2014   oop loader = current_class()-&gt;class_loader();
2015   oop protection_domain = current_class()-&gt;protection_domain();
2016 
2017   Klass* kls = SystemDictionary::resolve_or_fail(
2018     name, Handle(THREAD, loader), Handle(THREAD, protection_domain),
2019     true, THREAD);
2020 
2021   if (kls != NULL) {
2022     if (log_is_enabled(Debug, class, resolve)) {
2023       Verifier::trace_class_resolution(kls, current_class());
2024     }
2025   }
2026   return kls;
</pre>
<hr />
<pre>
2105       VerificationType::long_type(),
2106       VerificationType::long2_type(), CHECK_VERIFY(this));
2107   } else if (tag.is_method_handle()) {
2108     current_frame-&gt;push_stack(
2109       VerificationType::reference_type(
2110         vmSymbols::java_lang_invoke_MethodHandle()), CHECK_VERIFY(this));
2111   } else if (tag.is_method_type()) {
2112     current_frame-&gt;push_stack(
2113       VerificationType::reference_type(
2114         vmSymbols::java_lang_invoke_MethodType()), CHECK_VERIFY(this));
2115   } else if (tag.is_dynamic_constant()) {
2116     Symbol* constant_type = cp-&gt;uncached_signature_ref_at(index);
2117     // Field signature was checked in ClassFileParser.
2118     assert(SignatureVerifier::is_valid_type_signature(constant_type),
2119            &quot;Invalid type for dynamic constant&quot;);
2120     assert(sizeof(VerificationType) == sizeof(uintptr_t),
2121           &quot;buffer type must match VerificationType size&quot;);
2122     uintptr_t constant_type_buffer[2];
2123     VerificationType* v_constant_type = (VerificationType*)constant_type_buffer;
2124     SignatureStream sig_stream(constant_type, false);
<span class="line-modified">2125     int n = change_sig_to_verificationType(</span>
<span class="line-removed">2126       &amp;sig_stream, v_constant_type, CHECK_VERIFY(this));</span>
2127     int opcode_n = (opcode == Bytecodes::_ldc2_w ? 2 : 1);
2128     if (n != opcode_n) {
2129       // wrong kind of ldc; reverify against updated type mask
2130       types &amp;= ~(1 &lt;&lt; JVM_CONSTANT_Dynamic);
2131       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2132     }
2133     for (int i = 0; i &lt; n; i++) {
2134       current_frame-&gt;push_stack(v_constant_type[i], CHECK_VERIFY(this));
2135     }
2136   } else {
2137     /* Unreachable? verify_cp_type has already validated the cp type. */
2138     verify_error(
2139         ErrorContext::bad_cp_index(bci, index), &quot;Invalid index in ldc&quot;);
2140     return;
2141   }
2142 }
2143 
2144 void ClassVerifier::verify_switch(
2145     RawBytecodeStream* bcs, u4 code_length, char* code_data,
2146     StackMapFrame* current_frame, StackMapTable* stackmap_table, TRAPS) {
</pre>
<hr />
<pre>
2247     (!allow_arrays || !ref_class_type.is_array())) {
2248     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2249         TypeOrigin::cp(index, ref_class_type)),
2250         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2251         _klass-&gt;external_name(), index);
2252     return;
2253   }
2254   VerificationType target_class_type = ref_class_type;
2255 
2256   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2257         &quot;buffer type must match VerificationType size&quot;);
2258   uintptr_t field_type_buffer[2];
2259   VerificationType* field_type = (VerificationType*)field_type_buffer;
2260   // If we make a VerificationType[2] array directly, the compiler calls
2261   // to the c-runtime library to do the allocation instead of just
2262   // stack allocating it.  Plus it would run constructors.  This shows up
2263   // in performance profiles.
2264 
2265   SignatureStream sig_stream(field_sig, false);
2266   VerificationType stack_object_type;
<span class="line-modified">2267   int n = change_sig_to_verificationType(</span>
<span class="line-removed">2268     &amp;sig_stream, field_type, CHECK_VERIFY(this));</span>
2269   u2 bci = bcs-&gt;bci();
2270   bool is_assignable;
2271   switch (bcs-&gt;raw_code()) {
2272     case Bytecodes::_getstatic: {
2273       for (int i = 0; i &lt; n; i++) {
2274         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2275       }
2276       break;
2277     }
2278     case Bytecodes::_putstatic: {
2279       for (int i = n - 1; i &gt;= 0; i--) {
2280         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2281       }
2282       break;
2283     }
2284     case Bytecodes::_getfield: {
2285       stack_object_type = current_frame-&gt;pop_stack(
2286         target_class_type, CHECK_VERIFY(this));
2287       for (int i = 0; i &lt; n; i++) {
2288         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
</pre>
<hr />
<pre>
2566           TypeOrigin::implicit(current_type())),
2567           &quot;Bad &lt;init&gt; method call&quot;);
2568       return;
2569     }
2570 
2571     // If this invokespecial call is done from inside of a TRY block then make
2572     // sure that all catch clause paths end in a throw.  Otherwise, this can
2573     // result in returning an incomplete object.
2574     if (in_try_block) {
2575       ExceptionTable exhandlers(_method());
2576       int exlength = exhandlers.length();
2577       for(int i = 0; i &lt; exlength; i++) {
2578         u2 start_pc = exhandlers.start_pc(i);
2579         u2 end_pc = exhandlers.end_pc(i);
2580 
2581         if (bci &gt;= start_pc &amp;&amp; bci &lt; end_pc) {
2582           if (!ends_in_athrow(exhandlers.handler_pc(i))) {
2583             verify_error(ErrorContext::bad_code(bci),
2584               &quot;Bad &lt;init&gt; method call from after the start of a try block&quot;);
2585             return;
<span class="line-modified">2586           } else if (log_is_enabled(Info, verification)) {</span>
2587             ResourceMark rm(THREAD);
<span class="line-modified">2588             log_info(verification)(&quot;Survived call to ends_in_athrow(): %s&quot;,</span>
2589                                           current_class()-&gt;name()-&gt;as_C_string());
2590           }
2591         }
2592       }
2593 
2594       // Check the exception handler target stackmaps with the locals from the
2595       // incoming stackmap (before initialize_object() changes them to outgoing
2596       // state).
2597       if (was_recursively_verified()) return;
2598       verify_exception_handler_targets(bci, true, current_frame,
2599                                        stackmap_table, CHECK_VERIFY(this));
2600     } // in_try_block
2601 
2602     current_frame-&gt;initialize_object(type, current_type());
2603     *this_uninit = true;
2604   } else if (type.is_uninitialized()) {
2605     u2 new_offset = type.bci();
2606     address new_bcp = bcs-&gt;bcp() - bci + new_offset;
2607     if (new_offset &gt; (code_length - 3) || (*new_bcp) != Bytecodes::_new) {
2608       /* Unreachable?  Stack map parsing ensures valid type and new
</pre>
<hr />
<pre>
2717   Symbol* method_name = cp-&gt;name_ref_at(index);
2718   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2719 
2720   // Method signature was checked in ClassFileParser.
2721   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2722          &quot;Invalid method signature&quot;);
2723 
2724   // Get referenced class type
2725   VerificationType ref_class_type;
2726   if (opcode == Bytecodes::_invokedynamic) {
2727     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2728       class_format_error(
2729         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2730         _klass-&gt;major_version(), _klass-&gt;external_name());
2731       return;
2732     }
2733   } else {
2734     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2735   }
2736 
<span class="line-removed">2737   // For a small signature length, we just allocate 128 bytes instead</span>
<span class="line-removed">2738   // of parsing the signature once to find its size.</span>
<span class="line-removed">2739   // -3 is for &#39;(&#39;, &#39;)&#39; and return descriptor; multiply by 2 is for</span>
<span class="line-removed">2740   // longs/doubles to be consertive.</span>
2741   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2742         &quot;buffer type must match VerificationType size&quot;);
<span class="line-removed">2743   uintptr_t on_stack_sig_types_buffer[128];</span>
<span class="line-removed">2744   // If we make a VerificationType[128] array directly, the compiler calls</span>
<span class="line-removed">2745   // to the c-runtime library to do the allocation instead of just</span>
<span class="line-removed">2746   // stack allocating it.  Plus it would run constructors.  This shows up</span>
<span class="line-removed">2747   // in performance profiles.</span>
2748 
<span class="line-modified">2749   VerificationType* sig_types;</span>
<span class="line-modified">2750   int size = (method_sig-&gt;utf8_length() - 3) * 2;</span>
<span class="line-removed">2751   if (size &gt; 128) {</span>
<span class="line-removed">2752     // Long and double occupies two slots here.</span>
<span class="line-removed">2753     ArgumentSizeComputer size_it(method_sig);</span>
<span class="line-removed">2754     size = size_it.size();</span>
<span class="line-removed">2755     sig_types = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, VerificationType, size);</span>
<span class="line-removed">2756   } else{</span>
<span class="line-removed">2757     sig_types = (VerificationType*)on_stack_sig_types_buffer;</span>
<span class="line-removed">2758   }</span>
<span class="line-removed">2759   SignatureStream sig_stream(method_sig);</span>
<span class="line-removed">2760   int sig_i = 0;</span>
<span class="line-removed">2761   while (!sig_stream.at_return_type()) {</span>
<span class="line-removed">2762     sig_i += change_sig_to_verificationType(</span>
<span class="line-removed">2763       &amp;sig_stream, &amp;sig_types[sig_i], CHECK_VERIFY(this));</span>
<span class="line-removed">2764     sig_stream.next();</span>
<span class="line-removed">2765   }</span>
<span class="line-removed">2766   int nargs = sig_i;</span>
2767 
<span class="line-modified">2768 #ifdef ASSERT</span>
<span class="line-modified">2769   {</span>
<span class="line-modified">2770     ArgumentSizeComputer size_it(method_sig);</span>
<span class="line-modified">2771     assert(nargs == size_it.size(), &quot;Argument sizes do not match&quot;);</span>
<span class="line-modified">2772     assert(nargs &lt;= (method_sig-&gt;utf8_length() - 3) * 2, &quot;estimate of max size isn&#39;t conservative enough&quot;);</span>







2773   }
<span class="line-modified">2774 #endif</span>


2775 
2776   // Check instruction operands
2777   u2 bci = bcs-&gt;bci();
2778   if (opcode == Bytecodes::_invokeinterface) {
2779     address bcp = bcs-&gt;bcp();
2780     // 4905268: count operand in invokeinterface should be nargs+1, not nargs.
2781     // JSR202 spec: The count operand of an invokeinterface instruction is valid if it is
2782     // the difference between the size of the operand stack before and after the instruction
2783     // executes.
2784     if (*(bcp+3) != (nargs+1)) {
2785       verify_error(ErrorContext::bad_code(bci),
2786           &quot;Inconsistent args count operand in invokeinterface&quot;);
2787       return;
2788     }
2789     if (*(bcp+4) != 0) {
2790       verify_error(ErrorContext::bad_code(bci),
2791           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2792       return;
2793     }
2794   }
2795 
2796   if (opcode == Bytecodes::_invokedynamic) {
2797     address bcp = bcs-&gt;bcp();
2798     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2799       verify_error(ErrorContext::bad_code(bci),
2800           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2801       return;
2802     }
2803   }
2804 
<span class="line-modified">2805   if (method_name-&gt;char_at(0) == &#39;&lt;&#39;) {</span>
2806     // Make sure &lt;init&gt; can only be invoked by invokespecial
2807     if (opcode != Bytecodes::_invokespecial ||
2808         method_name != vmSymbols::object_initializer_name()) {
2809       verify_error(ErrorContext::bad_code(bci),
2810           &quot;Illegal call to internal method&quot;);
2811       return;
2812     }
2813   } else if (opcode == Bytecodes::_invokespecial
2814              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2815              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
2816                   current_class()-&gt;super()-&gt;name()))) {
2817     bool subtype = false;
2818     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2819     if (!current_class()-&gt;is_unsafe_anonymous()) {
2820       subtype = ref_class_type.is_assignable_from(
2821                  current_type(), this, false, CHECK_VERIFY(this));
2822     } else {
2823       VerificationType unsafe_anonymous_host_type =
2824                         VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());
2825       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
2827       // If invokespecial of IMR, need to recheck for same or
2828       // direct interface relative to the host class
2829       have_imr_indirect = (have_imr_indirect &amp;&amp;
2830                            !is_same_or_direct_interface(
2831                              current_class()-&gt;unsafe_anonymous_host(),
2832                              unsafe_anonymous_host_type, ref_class_type));
2833     }
2834     if (!subtype) {
2835       verify_error(ErrorContext::bad_code(bci),
2836           &quot;Bad invokespecial instruction: &quot;
2837           &quot;current class isn&#39;t assignable to reference class.&quot;);
2838        return;
2839     } else if (have_imr_indirect) {
2840       verify_error(ErrorContext::bad_code(bci),
2841           &quot;Bad invokespecial instruction: &quot;
2842           &quot;interface method reference is in an indirect superinterface.&quot;);
2843       return;
2844     }
2845 
2846   }




2847   // Match method descriptor with operand stack
<span class="line-modified">2848   for (int i = nargs - 1; i &gt;= 0; i--) {  // Run backwards</span>
<span class="line-modified">2849     current_frame-&gt;pop_stack(sig_types[i], CHECK_VERIFY(this));</span>

2850   }

2851   // Check objectref on operand stack
2852   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2853       opcode != Bytecodes::_invokedynamic) {
2854     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2855       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2856         code_length, in_try_block, this_uninit, cp, stackmap_table,
2857         CHECK_VERIFY(this));
2858       if (was_recursively_verified()) return;
2859     } else {   // other methods
2860       // Ensures that target class is assignable to method class.
2861       if (opcode == Bytecodes::_invokespecial) {
2862         if (!current_class()-&gt;is_unsafe_anonymous()) {
2863           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2864         } else {
2865           // anonymous class invokespecial calls: check if the
2866           // objectref is a subtype of the unsafe_anonymous_host of the current class
2867           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2868           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2869           VerificationType hosttype =
2870             VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());
</pre>
<hr />
<pre>
2902                   // Special case: arrays pretend to implement public Object
2903                   // clone().
2904                 } else {
2905                   verify_error(ErrorContext::bad_type(bci,
2906                       current_frame-&gt;stack_top_ctx(),
2907                       TypeOrigin::implicit(current_type())),
2908                       &quot;Bad access to protected data in invokevirtual&quot;);
2909                   return;
2910                 }
2911               }
2912             }
2913           }
2914         }
2915       } else {
2916         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
2917         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2918       }
2919     }
2920   }
2921   // Push the result type.
<span class="line-modified">2922   if (sig_stream.type() != T_VOID) {</span>

2923     if (method_name == vmSymbols::object_initializer_name()) {
2924       // &lt;init&gt; method must have a void return type
2925       /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have
2926        * void return */
2927       verify_error(ErrorContext::bad_code(bci),
2928           &quot;Return type must be void in &lt;init&gt; method&quot;);
2929       return;
2930     }
<span class="line-modified">2931     VerificationType return_type[2];</span>
<span class="line-modified">2932     int n = change_sig_to_verificationType(</span>
<span class="line-modified">2933       &amp;sig_stream, return_type, CHECK_VERIFY(this));</span>
<span class="line-modified">2934     for (int i = 0; i &lt; n; i++) {</span>
<span class="line-modified">2935       current_frame-&gt;push_stack(return_type[i], CHECK_VERIFY(this)); // push types backwards</span>


2936     }
2937   }
2938 }
2939 
2940 VerificationType ClassVerifier::get_newarray_type(
2941     u2 index, u2 bci, TRAPS) {
2942   const char* from_bt[] = {
2943     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
2944   };
2945   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
2946     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
2947     return VerificationType::bogus_type();
2948   }
2949 
2950   // from_bt[index] contains the array signature which has a length of 2
<span class="line-modified">2951   Symbol* sig = create_temporary_symbol(</span>
<span class="line-removed">2952     from_bt[index], 2, CHECK_(VerificationType::bogus_type()));</span>
2953   return VerificationType::reference_type(sig);
2954 }
2955 
2956 void ClassVerifier::verify_anewarray(
2957     u2 bci, u2 index, const constantPoolHandle&amp; cp,
2958     StackMapFrame* current_frame, TRAPS) {
2959   verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
2960   current_frame-&gt;pop_stack(
2961     VerificationType::integer_type(), CHECK_VERIFY(this));
2962 
2963   if (was_recursively_verified()) return;
2964   VerificationType component_type =
2965     cp_index_to_type(index, cp, CHECK_VERIFY(this));
2966   int length;
2967   char* arr_sig_str;
2968   if (component_type.is_array()) {     // it&#39;s an array
2969     const char* component_name = component_type.name()-&gt;as_utf8();
2970     // Check for more than MAX_ARRAY_DIMENSIONS
2971     length = (int)strlen(component_name);
2972     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
<span class="line-modified">2973         component_name[MAX_ARRAY_DIMENSIONS - 1] == &#39;[&#39;) {</span>
2974       verify_error(ErrorContext::bad_code(bci),
2975         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
2976     }
2977     // add one dimension to component
2978     length++;
2979     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">2980     int n = os::snprintf(arr_sig_str, length + 1, &quot;[%s&quot;, component_name);</span>

2981     assert(n == length, &quot;Unexpected number of characters in string&quot;);
2982   } else {         // it&#39;s an object or interface
2983     const char* component_name = component_type.name()-&gt;as_utf8();
2984     // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.
2985     length = (int)strlen(component_name) + 3;
2986     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">2987     int n = os::snprintf(arr_sig_str, length + 1, &quot;[L%s;&quot;, component_name);</span>

2988     assert(n == length, &quot;Unexpected number of characters in string&quot;);
2989   }
<span class="line-modified">2990   Symbol* arr_sig = create_temporary_symbol(</span>
<span class="line-removed">2991     arr_sig_str, length, CHECK_VERIFY(this));</span>
2992   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
2993   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
2994 }
2995 
2996 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
2997   current_frame-&gt;get_local(
2998     index, VerificationType::integer_type(), CHECK_VERIFY(this));
2999   current_frame-&gt;push_stack(
3000     VerificationType::integer_type(), CHECK_VERIFY(this));
3001 }
3002 
3003 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3004   current_frame-&gt;get_local_2(
3005     index, VerificationType::long_type(),
3006     VerificationType::long2_type(), CHECK_VERIFY(this));
3007   current_frame-&gt;push_stack_2(
3008     VerificationType::long_type(),
3009     VerificationType::long2_type(), CHECK_VERIFY(this));
3010 }
3011 
</pre>
<hr />
<pre>
3079     StackMapFrame* current_frame, TRAPS) {
3080   if (return_type == VerificationType::bogus_type()) {
3081     verify_error(ErrorContext::bad_type(bci,
3082         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3083         &quot;Method expects a return value&quot;);
3084     return;
3085   }
3086   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3087   if (!match) {
3088     verify_error(ErrorContext::bad_type(bci,
3089         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3090         &quot;Bad return type&quot;);
3091     return;
3092   }
3093 }
3094 
3095 // The verifier creates symbols which are substrings of Symbols.
3096 // These are stored in the verifier until the end of verification so that
3097 // they can be reference counted.
3098 Symbol* ClassVerifier::create_temporary_symbol(const Symbol *s, int begin,
<span class="line-modified">3099                                                int end, TRAPS) {</span>
3100   const char* name = (const char*)s-&gt;base() + begin;
3101   int length = end - begin;
<span class="line-modified">3102   return create_temporary_symbol(name, length, CHECK_NULL);</span>
3103 }
3104 
<span class="line-modified">3105 Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length, TRAPS) {</span>
3106   // Quick deduplication check
3107   if (_previous_symbol != NULL &amp;&amp; _previous_symbol-&gt;equals(name, length)) {
3108     return _previous_symbol;
3109   }
<span class="line-modified">3110   Symbol* sym = SymbolTable::new_symbol(name, length, CHECK_NULL);</span>
3111   if (!sym-&gt;is_permanent()) {
3112     if (_symbols == NULL) {
3113       _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
3114     }
3115     _symbols-&gt;push(sym);
3116   }
3117   _previous_symbol = sym;
3118   return sym;
3119 }
</pre>
</td>
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
<span class="line-added">  28 #include &quot;classfile/classLoader.hpp&quot;</span>
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;classfile/stackMapTable.hpp&quot;
  31 #include &quot;classfile/stackMapFrame.hpp&quot;
  32 #include &quot;classfile/stackMapTableFormat.hpp&quot;
<span class="line-added">  33 #include &quot;classfile/symbolTable.hpp&quot;</span>
  34 #include &quot;classfile/systemDictionary.hpp&quot;
  35 #include &quot;classfile/verifier.hpp&quot;
  36 #include &quot;classfile/vmSymbols.hpp&quot;
  37 #include &quot;interpreter/bytecodes.hpp&quot;
  38 #include &quot;interpreter/bytecodeStream.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logStream.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  43 #include &quot;memory/universe.hpp&quot;</span>
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;

  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
  63 #define MAX_ARRAY_DIMENSIONS 255
  64 
<span class="line-modified">  65 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier</span>
  66 
  67 extern &quot;C&quot; {
<span class="line-modified">  68   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);</span>

  69 }
  70 
<span class="line-modified">  71 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;</span>
  72 
<span class="line-modified">  73 static verify_byte_codes_fn_t verify_byte_codes_fn() {</span>
  74 
<span class="line-modified">  75   if (_verify_byte_codes_fn != NULL)</span>
<span class="line-modified">  76     return _verify_byte_codes_fn;</span>
<span class="line-modified">  77 </span>
<span class="line-modified">  78   MutexLocker locker(Verify_lock);</span>
<span class="line-modified">  79 </span>
<span class="line-modified">  80   if (_verify_byte_codes_fn != NULL)</span>
<span class="line-modified">  81     return _verify_byte_codes_fn;</span>
<span class="line-modified">  82 </span>
<span class="line-modified">  83   // Load verify dll</span>
<span class="line-modified">  84   char buffer[JVM_MAXPATHLEN];</span>
<span class="line-modified">  85   char ebuf[1024];</span>
<span class="line-modified">  86   if (!os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(), &quot;verify&quot;))</span>
<span class="line-added">  87     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">  88 </span>
<span class="line-added">  89   void *lib_handle = os::dll_load(buffer, ebuf, sizeof(ebuf));</span>
<span class="line-added">  90   if (lib_handle == NULL)</span>
<span class="line-added">  91     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">  92 </span>
<span class="line-added">  93   void *fn = os::dll_lookup(lib_handle, &quot;VerifyClassForMajorVersion&quot;);</span>
<span class="line-added">  94   if (fn == NULL)</span>
<span class="line-added">  95     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">  96 </span>
<span class="line-added">  97   return _verify_byte_codes_fn = CAST_TO_FN_PTR(verify_byte_codes_fn_t, fn);</span>
  98 }
  99 
 100 
 101 // Methods in Verifier
 102 
 103 bool Verifier::should_verify_for(oop class_loader, bool should_verify_class) {
 104   return (class_loader == NULL || !should_verify_class) ?
 105     BytecodeVerificationLocal : BytecodeVerificationRemote;
 106 }
 107 
 108 bool Verifier::relax_access_for(oop loader) {
 109   bool trusted = java_lang_ClassLoader::is_trusted_loader(loader);
 110   bool need_verify =
 111     // verifyAll
 112     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
 113     // verifyRemote
 114     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
 115   return !need_verify;
 116 }
 117 
</pre>
<hr />
<pre>
 157   // is IMPORTANT:
 158   if (klass-&gt;java_mirror() != NULL) {
 159     klass-&gt;java_mirror()-&gt;identity_hash();
 160   }
 161 
 162   if (!is_eligible_for_verification(klass, should_verify_class)) {
 163     return true;
 164   }
 165 
 166   // Timer includes any side effects of class verification (resolution,
 167   // etc), but not recursive calls to Verifier::verify().
 168   JavaThread* jt = (JavaThread*)THREAD;
 169   PerfClassTraceTime timer(ClassLoader::perf_class_verify_time(),
 170                            ClassLoader::perf_class_verify_selftime(),
 171                            ClassLoader::perf_classes_verified(),
 172                            jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 173                            jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 174                            PerfClassTraceTime::CLASS_VERIFY);
 175 
 176   // If the class should be verified, first see if we can use the split
<span class="line-modified"> 177   // verifier.  If not, or if verification fails and can failover, then</span>
<span class="line-modified"> 178   // call the inference verifier.</span>
 179   Symbol* exception_name = NULL;
 180   const size_t message_buffer_len = klass-&gt;name()-&gt;utf8_length() + 1024;
 181   char* message_buffer = NULL;
 182   char* exception_message = NULL;
 183 



 184   log_info(class, init)(&quot;Start class verification for: %s&quot;, klass-&gt;external_name());
 185   if (klass-&gt;major_version() &gt;= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
 186     ClassVerifier split_verifier(klass, THREAD);
 187     split_verifier.verify_class(THREAD);
 188     exception_name = split_verifier.result();
<span class="line-modified"> 189 </span>
<span class="line-added"> 190     // If DumpSharedSpaces is set then don&#39;t fall back to the old verifier on</span>
<span class="line-added"> 191     // verification failure. If a class fails verification with the split verifier,</span>
<span class="line-added"> 192     // it might fail the CDS runtime verifier constraint check. In that case, we</span>
<span class="line-added"> 193     // don&#39;t want to share the class. We only archive classes that pass the split</span>
<span class="line-added"> 194     // verifier.</span>
<span class="line-added"> 195     bool can_failover = !DumpSharedSpaces &amp;&amp;</span>
<span class="line-added"> 196       klass-&gt;major_version() &lt; NOFAILOVER_MAJOR_VERSION;</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198     if (can_failover &amp;&amp; !HAS_PENDING_EXCEPTION &amp;&amp;  // Split verifier doesn&#39;t set PENDING_EXCEPTION for failure</span>
 199         (exception_name == vmSymbols::java_lang_VerifyError() ||
 200          exception_name == vmSymbols::java_lang_ClassFormatError())) {
 201       log_info(verification)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
 202       log_info(class, init)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
 203       message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
 204       exception_message = message_buffer;
 205       exception_name = inference_verify(
 206         klass, message_buffer, message_buffer_len, THREAD);
 207     }
 208     if (exception_name != NULL) {
 209       exception_message = split_verifier.exception_message();
 210     }
 211   } else {
 212     message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
 213     exception_message = message_buffer;
 214     exception_name = inference_verify(
 215         klass, message_buffer, message_buffer_len, THREAD);
 216   }
 217 
 218   LogTarget(Info, class, init) lt1;
</pre>
<hr />
<pre>
 274     // already been rewritten to contain constant pool cache indices,
 275     // which the verifier can&#39;t understand.
 276     // Shared classes shouldn&#39;t have stackmaps either.
 277     !klass-&gt;is_shared() &amp;&amp;
 278 
 279     // As of the fix for 4486457 we disable verification for all of the
 280     // dynamically-generated bytecodes associated with the 1.4
 281     // reflection implementation, not just those associated with
 282     // jdk/internal/reflect/SerializationConstructorAccessor.
 283     // NOTE: this is called too early in the bootstrapping process to be
 284     // guarded by Universe::is_gte_jdk14x_version().
 285     // Also for lambda generated code, gte jdk8
 286     (!is_reflect));
 287 }
 288 
 289 Symbol* Verifier::inference_verify(
 290     InstanceKlass* klass, char* message, size_t message_len, TRAPS) {
 291   JavaThread* thread = (JavaThread*)THREAD;
 292   JNIEnv *env = thread-&gt;jni_environment();
 293 
<span class="line-modified"> 294   verify_byte_codes_fn_t verify_func = verify_byte_codes_fn();</span>
 295 
 296   if (verify_func == NULL) {
 297     jio_snprintf(message, message_len, &quot;Could not link verifier&quot;);
 298     return vmSymbols::java_lang_VerifyError();
 299   }
 300 
 301   ResourceMark rm(THREAD);
 302   log_info(verification)(&quot;Verifying class %s with old format&quot;, klass-&gt;external_name());
 303 
 304   jclass cls = (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
 305   jint result;
 306 
 307   {
 308     HandleMark hm(thread);
 309     ThreadToNativeFromVM ttn(thread);
 310     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
 311     // code knows that we have left the VM
 312 
<span class="line-modified"> 313     result = (*verify_func)(env, cls, message, (int)message_len, klass-&gt;major_version());</span>









 314   }
 315 
 316   JNIHandles::destroy_local(cls);
 317 
 318   // These numbers are chosen so that VerifyClassCodes interface doesn&#39;t need
 319   // to be changed (still return jboolean (unsigned char)), and result is
 320   // 1 when verification is passed.
 321   if (result == 0) {
 322     return vmSymbols::java_lang_VerifyError();
 323   } else if (result == 1) {
 324     return NULL; // verified.
 325   } else if (result == 2) {
 326     THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, NULL);
 327   } else if (result == 3) {
 328     return vmSymbols::java_lang_ClassFormatError();
 329   } else {
 330     ShouldNotReachHere();
 331     return NULL;
 332   }
 333 }
</pre>
<hr />
<pre>
 566     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 567     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 568       ss-&gt;indent();
 569       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 570         sm_frame-&gt;print_truncated(ss, current_offset);
 571         return;
 572       }
 573       sm_frame-&gt;print_on(ss, current_offset);
 574       ss-&gt;cr();
 575       current_offset += sm_frame-&gt;offset_delta();
 576       sm_frame = sm_frame-&gt;next();
 577     }
 578   }
 579 }
 580 
 581 // Methods in ClassVerifier
 582 
 583 ClassVerifier::ClassVerifier(
 584     InstanceKlass* klass, TRAPS)
 585     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
<span class="line-modified"> 586       _message(NULL), _method_signatures_table(NULL), _klass(klass) {</span>
 587   _this_type = VerificationType::reference_type(klass-&gt;name());
 588 }
 589 
 590 ClassVerifier::~ClassVerifier() {
 591   // Decrement the reference count for any symbols created.
 592   if (_symbols != NULL) {
 593     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 594       Symbol* s = _symbols-&gt;at(i);
 595       s-&gt;decrement_refcount();
 596     }
 597   }
 598 }
 599 
 600 VerificationType ClassVerifier::object_type() const {
 601   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 602 }
 603 
<span class="line-modified"> 604 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {</span>
 605   VerificationType vt = VerificationType::reference_type(
<span class="line-modified"> 606                          create_temporary_symbol(sig, (int)strlen(sig)));</span>
 607   return TypeOrigin::implicit(vt);
 608 }
 609 
 610 void ClassVerifier::verify_class(TRAPS) {
 611   log_info(verification)(&quot;Verifying class %s with new format&quot;, _klass-&gt;external_name());
 612 
<span class="line-added"> 613   // Either verifying both local and remote classes or just remote classes.</span>
<span class="line-added"> 614   assert(BytecodeVerificationRemote, &quot;Should not be here&quot;);</span>
<span class="line-added"> 615 </span>
<span class="line-added"> 616   // Create hash table containing method signatures.</span>
<span class="line-added"> 617   method_signatures_table_type method_signatures_table;</span>
<span class="line-added"> 618   set_method_signatures_table(&amp;method_signatures_table);</span>
<span class="line-added"> 619 </span>
 620   Array&lt;Method*&gt;* methods = _klass-&gt;methods();
 621   int num_methods = methods-&gt;length();
 622 
 623   for (int index = 0; index &lt; num_methods; index++) {
 624     // Check for recursive re-verification before each method.
 625     if (was_recursively_verified())  return;
 626 
 627     Method* m = methods-&gt;at(index);
 628     if (m-&gt;is_native() || m-&gt;is_abstract() || m-&gt;is_overpass()) {
 629       // If m is native or abstract, skip it.  It is checked in class file
 630       // parser that methods do not override a final method.  Overpass methods
 631       // are trusted since the VM generates them.
 632       continue;
 633     }
 634     verify_method(methodHandle(THREAD, m), CHECK_VERIFY(this));
 635   }
 636 
 637   if (was_recursively_verified()){
 638     log_info(verification)(&quot;Recursive verification detected for: %s&quot;, _klass-&gt;external_name());
 639     log_info(class, init)(&quot;Recursive verification detected for: %s&quot;,
 640                         _klass-&gt;external_name());
 641   }
 642 }
 643 
<span class="line-added"> 644 // Translate the signature entries into verification types and save them in</span>
<span class="line-added"> 645 // the growable array.  Also, save the count of arguments.</span>
<span class="line-added"> 646 void ClassVerifier::translate_signature(Symbol* const method_sig,</span>
<span class="line-added"> 647                                         sig_as_verification_types* sig_verif_types,</span>
<span class="line-added"> 648                                         TRAPS) {</span>
<span class="line-added"> 649   SignatureStream sig_stream(method_sig);</span>
<span class="line-added"> 650   VerificationType sig_type[2];</span>
<span class="line-added"> 651   int sig_i = 0;</span>
<span class="line-added"> 652   GrowableArray&lt;VerificationType&gt;* verif_types = sig_verif_types-&gt;sig_verif_types();</span>
<span class="line-added"> 653 </span>
<span class="line-added"> 654   // Translate the signature arguments into verification types.</span>
<span class="line-added"> 655   while (!sig_stream.at_return_type()) {</span>
<span class="line-added"> 656     int n = change_sig_to_verificationType(&amp;sig_stream, sig_type);</span>
<span class="line-added"> 657     assert(n &lt;= 2, &quot;Unexpected signature type&quot;);</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659     // Store verification type(s).  Longs and Doubles each have two verificationTypes.</span>
<span class="line-added"> 660     for (int x = 0; x &lt; n; x++) {</span>
<span class="line-added"> 661       verif_types-&gt;push(sig_type[x]);</span>
<span class="line-added"> 662     }</span>
<span class="line-added"> 663     sig_i += n;</span>
<span class="line-added"> 664     sig_stream.next();</span>
<span class="line-added"> 665   }</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667   // Set final arg count, not including the return type.  The final arg count will</span>
<span class="line-added"> 668   // be compared with sig_verify_types&#39; length to see if there is a return type.</span>
<span class="line-added"> 669   sig_verif_types-&gt;set_num_args(sig_i);</span>
<span class="line-added"> 670 </span>
<span class="line-added"> 671   // Store verification type(s) for the return type, if there is one.</span>
<span class="line-added"> 672   if (sig_stream.type() != T_VOID) {</span>
<span class="line-added"> 673     int n = change_sig_to_verificationType(&amp;sig_stream, sig_type);</span>
<span class="line-added"> 674     assert(n &lt;= 2, &quot;Unexpected signature return type&quot;);</span>
<span class="line-added"> 675     for (int y = 0; y &lt; n; y++) {</span>
<span class="line-added"> 676       verif_types-&gt;push(sig_type[y]);</span>
<span class="line-added"> 677     }</span>
<span class="line-added"> 678   }</span>
<span class="line-added"> 679 }</span>
<span class="line-added"> 680 </span>
<span class="line-added"> 681 void ClassVerifier::create_method_sig_entry(sig_as_verification_types* sig_verif_types,</span>
<span class="line-added"> 682                                             int sig_index, TRAPS) {</span>
<span class="line-added"> 683   // Translate the signature into verification types.</span>
<span class="line-added"> 684   ConstantPool* cp = _klass-&gt;constants();</span>
<span class="line-added"> 685   Symbol* const method_sig = cp-&gt;symbol_at(sig_index);</span>
<span class="line-added"> 686   translate_signature(method_sig, sig_verif_types, CHECK_VERIFY(this));</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688   // Add the list of this signature&#39;s verification types to the table.</span>
<span class="line-added"> 689   bool is_unique = method_signatures_table()-&gt;put(sig_index, sig_verif_types);</span>
<span class="line-added"> 690   assert(is_unique, &quot;Duplicate entries in method_signature_table&quot;);</span>
<span class="line-added"> 691 }</span>
<span class="line-added"> 692 </span>
 693 void ClassVerifier::verify_method(const methodHandle&amp; m, TRAPS) {
 694   HandleMark hm(THREAD);
 695   _method = m;   // initialize _method
 696   log_info(verification)(&quot;Verifying method %s&quot;, m-&gt;name_and_sig_as_C_string());
 697 
 698 // For clang, the only good constant format string is a literal constant format string.
 699 #define bad_type_msg &quot;Bad type on operand stack in %s&quot;
 700 
 701   int32_t max_stack = m-&gt;verifier_max_stack();
 702   int32_t max_locals = m-&gt;max_locals();
 703   constantPoolHandle cp(THREAD, m-&gt;constants());
 704 
 705   // Method signature was checked in ClassFileParser.
 706   assert(SignatureVerifier::is_valid_method_signature(m-&gt;signature()),
 707          &quot;Invalid method signature&quot;);
 708 
 709   // Initial stack map frame: offset is 0, stack is initially empty.
 710   StackMapFrame current_frame(max_locals, max_stack, this);
 711   // Set initial locals
 712   VerificationType return_type = current_frame.set_locals_from_arg(
</pre>
<hr />
<pre>
 722   int ex_min = code_length;
 723   int ex_max = -1;
 724   // Look through each item on the exception table. Each of the fields must refer
 725   // to a legal instruction.
 726   if (was_recursively_verified()) return;
 727   verify_exception_handler_table(
 728     code_length, code_data, ex_min, ex_max, CHECK_VERIFY(this));
 729 
 730   // Look through each entry on the local variable table and make sure
 731   // its range of code array offsets is valid. (4169817)
 732   if (m-&gt;has_localvariable_table()) {
 733     verify_local_variable_table(code_length, code_data, CHECK_VERIFY(this));
 734   }
 735 
 736   Array&lt;u1&gt;* stackmap_data = m-&gt;stackmap_data();
 737   StackMapStream stream(stackmap_data);
 738   StackMapReader reader(this, &amp;stream, code_data, code_length, THREAD);
 739   StackMapTable stackmap_table(&amp;reader, &amp;current_frame, max_locals, max_stack,
 740                                code_data, code_length, CHECK_VERIFY(this));
 741 
<span class="line-modified"> 742   LogTarget(Debug, verification) lt;</span>
 743   if (lt.is_enabled()) {
 744     ResourceMark rm(THREAD);
 745     LogStream ls(lt);
 746     stackmap_table.print_on(&amp;ls);
 747   }
 748 
 749   RawBytecodeStream bcs(m);
 750 
 751   // Scan the byte code linearly from the start to the end
 752   bool no_control_flow = false; // Set to true when there is no direct control
 753                                 // flow from current instruction to the next
 754                                 // instruction in sequence
 755 
 756   Bytecodes::Code opcode;
 757   while (!bcs.is_last_bytecode()) {
 758     // Check for recursive re-verification before each bytecode.
 759     if (was_recursively_verified())  return;
 760 
 761     opcode = bcs.raw_next();
 762     u2 bci = bcs.bci();
</pre>
<hr />
<pre>
 766     current_frame.set_mark();
 767 
 768     // Make sure every offset in stackmap table point to the beginning to
 769     // an instruction. Match current_frame to stackmap_table entry with
 770     // the same offset if exists.
 771     stackmap_index = verify_stackmap_table(
 772       stackmap_index, bci, &amp;current_frame, &amp;stackmap_table,
 773       no_control_flow, CHECK_VERIFY(this));
 774 
 775 
 776     bool this_uninit = false;  // Set to true when invokespecial &lt;init&gt; initialized &#39;this&#39;
 777     bool verified_exc_handlers = false;
 778 
 779     // Merge with the next instruction
 780     {
 781       u2 index;
 782       int target;
 783       VerificationType type, type2;
 784       VerificationType atype;
 785 
<span class="line-modified"> 786       LogTarget(Debug, verification) lt;</span>
 787       if (lt.is_enabled()) {
 788         ResourceMark rm(THREAD);
 789         LogStream ls(lt);
 790         current_frame.print_on(&amp;ls);
 791         lt.print(&quot;offset = %d,  opcode = %s&quot;, bci,
 792                  opcode == Bytecodes::_illegal ? &quot;illegal&quot; : Bytecodes::name(opcode));
 793       }
 794 
 795       // Make sure wide instruction is in correct format
 796       if (bcs.is_wide()) {
 797         if (opcode != Bytecodes::_iinc   &amp;&amp; opcode != Bytecodes::_iload  &amp;&amp;
 798             opcode != Bytecodes::_aload  &amp;&amp; opcode != Bytecodes::_lload  &amp;&amp;
 799             opcode != Bytecodes::_istore &amp;&amp; opcode != Bytecodes::_astore &amp;&amp;
 800             opcode != Bytecodes::_lstore &amp;&amp; opcode != Bytecodes::_fload  &amp;&amp;
 801             opcode != Bytecodes::_dload  &amp;&amp; opcode != Bytecodes::_fstore &amp;&amp;
 802             opcode != Bytecodes::_dstore) {
 803           /* Unreachable?  RawBytecodeStream&#39;s raw_next() returns &#39;illegal&#39;
 804            * if we encounter a wide instruction that modifies an invalid
 805            * opcode (not one of the ones listed above) */
 806           verify_error(ErrorContext::bad_code(bci), &quot;Bad wide instruction&quot;);
</pre>
<hr />
<pre>
 914           index = opcode - Bytecodes::_dload_0;
 915           verify_dload(index, &amp;current_frame, CHECK_VERIFY(this));
 916           no_control_flow = false; break;
 917         case Bytecodes::_aload :
 918           verify_aload(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
 919           no_control_flow = false; break;
 920         case Bytecodes::_aload_0 :
 921         case Bytecodes::_aload_1 :
 922         case Bytecodes::_aload_2 :
 923         case Bytecodes::_aload_3 :
 924           index = opcode - Bytecodes::_aload_0;
 925           verify_aload(index, &amp;current_frame, CHECK_VERIFY(this));
 926           no_control_flow = false; break;
 927         case Bytecodes::_iaload :
 928           type = current_frame.pop_stack(
 929             VerificationType::integer_type(), CHECK_VERIFY(this));
 930           atype = current_frame.pop_stack(
 931             VerificationType::reference_check(), CHECK_VERIFY(this));
 932           if (!atype.is_int_array()) {
 933             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 934                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;)),</span>
 935                 bad_type_msg, &quot;iaload&quot;);
 936             return;
 937           }
 938           current_frame.push_stack(
 939             VerificationType::integer_type(), CHECK_VERIFY(this));
 940           no_control_flow = false; break;
 941         case Bytecodes::_baload :
 942           type = current_frame.pop_stack(
 943             VerificationType::integer_type(), CHECK_VERIFY(this));
 944           atype = current_frame.pop_stack(
 945             VerificationType::reference_check(), CHECK_VERIFY(this));
 946           if (!atype.is_bool_array() &amp;&amp; !atype.is_byte_array()) {
 947             verify_error(
 948                 ErrorContext::bad_type(bci, current_frame.stack_top_ctx()),
 949                 bad_type_msg, &quot;baload&quot;);
 950             return;
 951           }
 952           current_frame.push_stack(
 953             VerificationType::integer_type(), CHECK_VERIFY(this));
 954           no_control_flow = false; break;
 955         case Bytecodes::_caload :
 956           type = current_frame.pop_stack(
 957             VerificationType::integer_type(), CHECK_VERIFY(this));
 958           atype = current_frame.pop_stack(
 959             VerificationType::reference_check(), CHECK_VERIFY(this));
 960           if (!atype.is_char_array()) {
 961             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 962                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;)),</span>
 963                 bad_type_msg, &quot;caload&quot;);
 964             return;
 965           }
 966           current_frame.push_stack(
 967             VerificationType::integer_type(), CHECK_VERIFY(this));
 968           no_control_flow = false; break;
 969         case Bytecodes::_saload :
 970           type = current_frame.pop_stack(
 971             VerificationType::integer_type(), CHECK_VERIFY(this));
 972           atype = current_frame.pop_stack(
 973             VerificationType::reference_check(), CHECK_VERIFY(this));
 974           if (!atype.is_short_array()) {
 975             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 976                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;)),</span>
 977                 bad_type_msg, &quot;saload&quot;);
 978             return;
 979           }
 980           current_frame.push_stack(
 981             VerificationType::integer_type(), CHECK_VERIFY(this));
 982           no_control_flow = false; break;
 983         case Bytecodes::_laload :
 984           type = current_frame.pop_stack(
 985             VerificationType::integer_type(), CHECK_VERIFY(this));
 986           atype = current_frame.pop_stack(
 987             VerificationType::reference_check(), CHECK_VERIFY(this));
 988           if (!atype.is_long_array()) {
 989             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified"> 990                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;)),</span>
 991                 bad_type_msg, &quot;laload&quot;);
 992             return;
 993           }
 994           current_frame.push_stack_2(
 995             VerificationType::long_type(),
 996             VerificationType::long2_type(), CHECK_VERIFY(this));
 997           no_control_flow = false; break;
 998         case Bytecodes::_faload :
 999           type = current_frame.pop_stack(
1000             VerificationType::integer_type(), CHECK_VERIFY(this));
1001           atype = current_frame.pop_stack(
1002             VerificationType::reference_check(), CHECK_VERIFY(this));
1003           if (!atype.is_float_array()) {
1004             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1005                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;)),</span>
1006                 bad_type_msg, &quot;faload&quot;);
1007             return;
1008           }
1009           current_frame.push_stack(
1010             VerificationType::float_type(), CHECK_VERIFY(this));
1011           no_control_flow = false; break;
1012         case Bytecodes::_daload :
1013           type = current_frame.pop_stack(
1014             VerificationType::integer_type(), CHECK_VERIFY(this));
1015           atype = current_frame.pop_stack(
1016             VerificationType::reference_check(), CHECK_VERIFY(this));
1017           if (!atype.is_double_array()) {
1018             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1019                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),</span>
1020                 bad_type_msg, &quot;daload&quot;);
1021             return;
1022           }
1023           current_frame.push_stack_2(
1024             VerificationType::double_type(),
1025             VerificationType::double2_type(), CHECK_VERIFY(this));
1026           no_control_flow = false; break;
1027         case Bytecodes::_aaload : {
1028           type = current_frame.pop_stack(
1029             VerificationType::integer_type(), CHECK_VERIFY(this));
1030           atype = current_frame.pop_stack(
1031             VerificationType::reference_check(), CHECK_VERIFY(this));
1032           if (!atype.is_reference_array()) {
1033             verify_error(ErrorContext::bad_type(bci,
1034                 current_frame.stack_top_ctx(),
1035                 TypeOrigin::implicit(VerificationType::reference_check())),
1036                 bad_type_msg, &quot;aaload&quot;);
1037             return;
1038           }
1039           if (atype.is_null()) {
</pre>
<hr />
<pre>
1088           no_control_flow = false; break;
1089         case Bytecodes::_astore :
1090           verify_astore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1091           no_control_flow = false; break;
1092         case Bytecodes::_astore_0 :
1093         case Bytecodes::_astore_1 :
1094         case Bytecodes::_astore_2 :
1095         case Bytecodes::_astore_3 :
1096           index = opcode - Bytecodes::_astore_0;
1097           verify_astore(index, &amp;current_frame, CHECK_VERIFY(this));
1098           no_control_flow = false; break;
1099         case Bytecodes::_iastore :
1100           type = current_frame.pop_stack(
1101             VerificationType::integer_type(), CHECK_VERIFY(this));
1102           type2 = current_frame.pop_stack(
1103             VerificationType::integer_type(), CHECK_VERIFY(this));
1104           atype = current_frame.pop_stack(
1105             VerificationType::reference_check(), CHECK_VERIFY(this));
1106           if (!atype.is_int_array()) {
1107             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1108                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;)),</span>
1109                 bad_type_msg, &quot;iastore&quot;);
1110             return;
1111           }
1112           no_control_flow = false; break;
1113         case Bytecodes::_bastore :
1114           type = current_frame.pop_stack(
1115             VerificationType::integer_type(), CHECK_VERIFY(this));
1116           type2 = current_frame.pop_stack(
1117             VerificationType::integer_type(), CHECK_VERIFY(this));
1118           atype = current_frame.pop_stack(
1119             VerificationType::reference_check(), CHECK_VERIFY(this));
1120           if (!atype.is_bool_array() &amp;&amp; !atype.is_byte_array()) {
1121             verify_error(
1122                 ErrorContext::bad_type(bci, current_frame.stack_top_ctx()),
1123                 bad_type_msg, &quot;bastore&quot;);
1124             return;
1125           }
1126           no_control_flow = false; break;
1127         case Bytecodes::_castore :
1128           current_frame.pop_stack(
1129             VerificationType::integer_type(), CHECK_VERIFY(this));
1130           current_frame.pop_stack(
1131             VerificationType::integer_type(), CHECK_VERIFY(this));
1132           atype = current_frame.pop_stack(
1133             VerificationType::reference_check(), CHECK_VERIFY(this));
1134           if (!atype.is_char_array()) {
1135             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1136                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;)),</span>
1137                 bad_type_msg, &quot;castore&quot;);
1138             return;
1139           }
1140           no_control_flow = false; break;
1141         case Bytecodes::_sastore :
1142           current_frame.pop_stack(
1143             VerificationType::integer_type(), CHECK_VERIFY(this));
1144           current_frame.pop_stack(
1145             VerificationType::integer_type(), CHECK_VERIFY(this));
1146           atype = current_frame.pop_stack(
1147             VerificationType::reference_check(), CHECK_VERIFY(this));
1148           if (!atype.is_short_array()) {
1149             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1150                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;)),</span>
1151                 bad_type_msg, &quot;sastore&quot;);
1152             return;
1153           }
1154           no_control_flow = false; break;
1155         case Bytecodes::_lastore :
1156           current_frame.pop_stack_2(
1157             VerificationType::long2_type(),
1158             VerificationType::long_type(), CHECK_VERIFY(this));
1159           current_frame.pop_stack(
1160             VerificationType::integer_type(), CHECK_VERIFY(this));
1161           atype = current_frame.pop_stack(
1162             VerificationType::reference_check(), CHECK_VERIFY(this));
1163           if (!atype.is_long_array()) {
1164             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1165                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;)),</span>
1166                 bad_type_msg, &quot;lastore&quot;);
1167             return;
1168           }
1169           no_control_flow = false; break;
1170         case Bytecodes::_fastore :
1171           current_frame.pop_stack(
1172             VerificationType::float_type(), CHECK_VERIFY(this));
1173           current_frame.pop_stack
1174             (VerificationType::integer_type(), CHECK_VERIFY(this));
1175           atype = current_frame.pop_stack(
1176             VerificationType::reference_check(), CHECK_VERIFY(this));
1177           if (!atype.is_float_array()) {
1178             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1179                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;)),</span>
1180                 bad_type_msg, &quot;fastore&quot;);
1181             return;
1182           }
1183           no_control_flow = false; break;
1184         case Bytecodes::_dastore :
1185           current_frame.pop_stack_2(
1186             VerificationType::double2_type(),
1187             VerificationType::double_type(), CHECK_VERIFY(this));
1188           current_frame.pop_stack(
1189             VerificationType::integer_type(), CHECK_VERIFY(this));
1190           atype = current_frame.pop_stack(
1191             VerificationType::reference_check(), CHECK_VERIFY(this));
1192           if (!atype.is_double_array()) {
1193             verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">1194                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),</span>
1195                 bad_type_msg, &quot;dastore&quot;);
1196             return;
1197           }
1198           no_control_flow = false; break;
1199         case Bytecodes::_aastore :
1200           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1201           type2 = current_frame.pop_stack(
1202             VerificationType::integer_type(), CHECK_VERIFY(this));
1203           atype = current_frame.pop_stack(
1204             VerificationType::reference_check(), CHECK_VERIFY(this));
1205           // more type-checking is done at runtime
1206           if (!atype.is_reference_array()) {
1207             verify_error(ErrorContext::bad_type(bci,
1208                 current_frame.stack_top_ctx(),
1209                 TypeOrigin::implicit(VerificationType::reference_check())),
1210                 bad_type_msg, &quot;aastore&quot;);
1211             return;
1212           }
1213           // 4938384: relaxed constraint in JVMS 3nd edition.
1214           no_control_flow = false; break;
</pre>
<hr />
<pre>
2051   va_list va;
2052   va_start(va, msg);
2053   ss.vprint(msg, va);
2054   va_end(va);
2055   _message = ss.as_string();
2056 #ifdef ASSERT
2057   ResourceMark rm;
2058   const char* exception_name = _exception_type-&gt;as_C_string();
2059   Exceptions::debug_check_abort(exception_name, NULL);
2060 #endif // ndef ASSERT
2061 }
2062 
2063 void ClassVerifier::class_format_error(const char* msg, ...) {
2064   stringStream ss;
2065   _exception_type = vmSymbols::java_lang_ClassFormatError();
2066   va_list va;
2067   va_start(va, msg);
2068   ss.vprint(msg, va);
2069   va_end(va);
2070   if (!_method.is_null()) {
<span class="line-modified">2071     ss.print(&quot; in method &#39;&quot;);</span>
<span class="line-added">2072     _method-&gt;print_external_name(&amp;ss);</span>
<span class="line-added">2073     ss.print(&quot;&#39;&quot;);</span>
2074   }
2075   _message = ss.as_string();
2076 }
2077 
2078 Klass* ClassVerifier::load_class(Symbol* name, TRAPS) {
2079   HandleMark hm(THREAD);
2080   // Get current loader and protection domain first.
2081   oop loader = current_class()-&gt;class_loader();
2082   oop protection_domain = current_class()-&gt;protection_domain();
2083 
2084   Klass* kls = SystemDictionary::resolve_or_fail(
2085     name, Handle(THREAD, loader), Handle(THREAD, protection_domain),
2086     true, THREAD);
2087 
2088   if (kls != NULL) {
2089     if (log_is_enabled(Debug, class, resolve)) {
2090       Verifier::trace_class_resolution(kls, current_class());
2091     }
2092   }
2093   return kls;
</pre>
<hr />
<pre>
2172       VerificationType::long_type(),
2173       VerificationType::long2_type(), CHECK_VERIFY(this));
2174   } else if (tag.is_method_handle()) {
2175     current_frame-&gt;push_stack(
2176       VerificationType::reference_type(
2177         vmSymbols::java_lang_invoke_MethodHandle()), CHECK_VERIFY(this));
2178   } else if (tag.is_method_type()) {
2179     current_frame-&gt;push_stack(
2180       VerificationType::reference_type(
2181         vmSymbols::java_lang_invoke_MethodType()), CHECK_VERIFY(this));
2182   } else if (tag.is_dynamic_constant()) {
2183     Symbol* constant_type = cp-&gt;uncached_signature_ref_at(index);
2184     // Field signature was checked in ClassFileParser.
2185     assert(SignatureVerifier::is_valid_type_signature(constant_type),
2186            &quot;Invalid type for dynamic constant&quot;);
2187     assert(sizeof(VerificationType) == sizeof(uintptr_t),
2188           &quot;buffer type must match VerificationType size&quot;);
2189     uintptr_t constant_type_buffer[2];
2190     VerificationType* v_constant_type = (VerificationType*)constant_type_buffer;
2191     SignatureStream sig_stream(constant_type, false);
<span class="line-modified">2192     int n = change_sig_to_verificationType(&amp;sig_stream, v_constant_type);</span>

2193     int opcode_n = (opcode == Bytecodes::_ldc2_w ? 2 : 1);
2194     if (n != opcode_n) {
2195       // wrong kind of ldc; reverify against updated type mask
2196       types &amp;= ~(1 &lt;&lt; JVM_CONSTANT_Dynamic);
2197       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2198     }
2199     for (int i = 0; i &lt; n; i++) {
2200       current_frame-&gt;push_stack(v_constant_type[i], CHECK_VERIFY(this));
2201     }
2202   } else {
2203     /* Unreachable? verify_cp_type has already validated the cp type. */
2204     verify_error(
2205         ErrorContext::bad_cp_index(bci, index), &quot;Invalid index in ldc&quot;);
2206     return;
2207   }
2208 }
2209 
2210 void ClassVerifier::verify_switch(
2211     RawBytecodeStream* bcs, u4 code_length, char* code_data,
2212     StackMapFrame* current_frame, StackMapTable* stackmap_table, TRAPS) {
</pre>
<hr />
<pre>
2313     (!allow_arrays || !ref_class_type.is_array())) {
2314     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2315         TypeOrigin::cp(index, ref_class_type)),
2316         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2317         _klass-&gt;external_name(), index);
2318     return;
2319   }
2320   VerificationType target_class_type = ref_class_type;
2321 
2322   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2323         &quot;buffer type must match VerificationType size&quot;);
2324   uintptr_t field_type_buffer[2];
2325   VerificationType* field_type = (VerificationType*)field_type_buffer;
2326   // If we make a VerificationType[2] array directly, the compiler calls
2327   // to the c-runtime library to do the allocation instead of just
2328   // stack allocating it.  Plus it would run constructors.  This shows up
2329   // in performance profiles.
2330 
2331   SignatureStream sig_stream(field_sig, false);
2332   VerificationType stack_object_type;
<span class="line-modified">2333   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);</span>

2334   u2 bci = bcs-&gt;bci();
2335   bool is_assignable;
2336   switch (bcs-&gt;raw_code()) {
2337     case Bytecodes::_getstatic: {
2338       for (int i = 0; i &lt; n; i++) {
2339         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2340       }
2341       break;
2342     }
2343     case Bytecodes::_putstatic: {
2344       for (int i = n - 1; i &gt;= 0; i--) {
2345         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2346       }
2347       break;
2348     }
2349     case Bytecodes::_getfield: {
2350       stack_object_type = current_frame-&gt;pop_stack(
2351         target_class_type, CHECK_VERIFY(this));
2352       for (int i = 0; i &lt; n; i++) {
2353         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
</pre>
<hr />
<pre>
2631           TypeOrigin::implicit(current_type())),
2632           &quot;Bad &lt;init&gt; method call&quot;);
2633       return;
2634     }
2635 
2636     // If this invokespecial call is done from inside of a TRY block then make
2637     // sure that all catch clause paths end in a throw.  Otherwise, this can
2638     // result in returning an incomplete object.
2639     if (in_try_block) {
2640       ExceptionTable exhandlers(_method());
2641       int exlength = exhandlers.length();
2642       for(int i = 0; i &lt; exlength; i++) {
2643         u2 start_pc = exhandlers.start_pc(i);
2644         u2 end_pc = exhandlers.end_pc(i);
2645 
2646         if (bci &gt;= start_pc &amp;&amp; bci &lt; end_pc) {
2647           if (!ends_in_athrow(exhandlers.handler_pc(i))) {
2648             verify_error(ErrorContext::bad_code(bci),
2649               &quot;Bad &lt;init&gt; method call from after the start of a try block&quot;);
2650             return;
<span class="line-modified">2651           } else if (log_is_enabled(Debug, verification)) {</span>
2652             ResourceMark rm(THREAD);
<span class="line-modified">2653             log_debug(verification)(&quot;Survived call to ends_in_athrow(): %s&quot;,</span>
2654                                           current_class()-&gt;name()-&gt;as_C_string());
2655           }
2656         }
2657       }
2658 
2659       // Check the exception handler target stackmaps with the locals from the
2660       // incoming stackmap (before initialize_object() changes them to outgoing
2661       // state).
2662       if (was_recursively_verified()) return;
2663       verify_exception_handler_targets(bci, true, current_frame,
2664                                        stackmap_table, CHECK_VERIFY(this));
2665     } // in_try_block
2666 
2667     current_frame-&gt;initialize_object(type, current_type());
2668     *this_uninit = true;
2669   } else if (type.is_uninitialized()) {
2670     u2 new_offset = type.bci();
2671     address new_bcp = bcs-&gt;bcp() - bci + new_offset;
2672     if (new_offset &gt; (code_length - 3) || (*new_bcp) != Bytecodes::_new) {
2673       /* Unreachable?  Stack map parsing ensures valid type and new
</pre>
<hr />
<pre>
2782   Symbol* method_name = cp-&gt;name_ref_at(index);
2783   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2784 
2785   // Method signature was checked in ClassFileParser.
2786   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2787          &quot;Invalid method signature&quot;);
2788 
2789   // Get referenced class type
2790   VerificationType ref_class_type;
2791   if (opcode == Bytecodes::_invokedynamic) {
2792     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2793       class_format_error(
2794         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2795         _klass-&gt;major_version(), _klass-&gt;external_name());
2796       return;
2797     }
2798   } else {
2799     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2800   }
2801 




2802   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2803         &quot;buffer type must match VerificationType size&quot;);





2804 
<span class="line-modified">2805   // Get the UTF8 index for this signature.</span>
<span class="line-modified">2806   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));</span>
















2807 
<span class="line-modified">2808   // Get the signature&#39;s verification types.</span>
<span class="line-modified">2809   sig_as_verification_types* mth_sig_verif_types;</span>
<span class="line-modified">2810   sig_as_verification_types** mth_sig_verif_types_ptr = method_signatures_table()-&gt;get(sig_index);</span>
<span class="line-modified">2811   if (mth_sig_verif_types_ptr != NULL) {</span>
<span class="line-modified">2812     // Found the entry for the signature&#39;s verification types in the hash table.</span>
<span class="line-added">2813     mth_sig_verif_types = *mth_sig_verif_types_ptr;</span>
<span class="line-added">2814     assert(mth_sig_verif_types != NULL, &quot;Unexpected NULL sig_as_verification_types value&quot;);</span>
<span class="line-added">2815   } else {</span>
<span class="line-added">2816     // Not found, add the entry to the table.</span>
<span class="line-added">2817     GrowableArray&lt;VerificationType&gt;* verif_types = new GrowableArray&lt;VerificationType&gt;(10);</span>
<span class="line-added">2818     mth_sig_verif_types = new sig_as_verification_types(verif_types);</span>
<span class="line-added">2819     create_method_sig_entry(mth_sig_verif_types, sig_index, CHECK_VERIFY(this));</span>
2820   }
<span class="line-modified">2821 </span>
<span class="line-added">2822   // Get the number of arguments for this signature.</span>
<span class="line-added">2823   int nargs = mth_sig_verif_types-&gt;num_args();</span>
2824 
2825   // Check instruction operands
2826   u2 bci = bcs-&gt;bci();
2827   if (opcode == Bytecodes::_invokeinterface) {
2828     address bcp = bcs-&gt;bcp();
2829     // 4905268: count operand in invokeinterface should be nargs+1, not nargs.
2830     // JSR202 spec: The count operand of an invokeinterface instruction is valid if it is
2831     // the difference between the size of the operand stack before and after the instruction
2832     // executes.
2833     if (*(bcp+3) != (nargs+1)) {
2834       verify_error(ErrorContext::bad_code(bci),
2835           &quot;Inconsistent args count operand in invokeinterface&quot;);
2836       return;
2837     }
2838     if (*(bcp+4) != 0) {
2839       verify_error(ErrorContext::bad_code(bci),
2840           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2841       return;
2842     }
2843   }
2844 
2845   if (opcode == Bytecodes::_invokedynamic) {
2846     address bcp = bcs-&gt;bcp();
2847     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2848       verify_error(ErrorContext::bad_code(bci),
2849           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2850       return;
2851     }
2852   }
2853 
<span class="line-modified">2854   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {</span>
2855     // Make sure &lt;init&gt; can only be invoked by invokespecial
2856     if (opcode != Bytecodes::_invokespecial ||
2857         method_name != vmSymbols::object_initializer_name()) {
2858       verify_error(ErrorContext::bad_code(bci),
2859           &quot;Illegal call to internal method&quot;);
2860       return;
2861     }
2862   } else if (opcode == Bytecodes::_invokespecial
2863              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2864              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
2865                   current_class()-&gt;super()-&gt;name()))) {
2866     bool subtype = false;
2867     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2868     if (!current_class()-&gt;is_unsafe_anonymous()) {
2869       subtype = ref_class_type.is_assignable_from(
2870                  current_type(), this, false, CHECK_VERIFY(this));
2871     } else {
2872       VerificationType unsafe_anonymous_host_type =
2873                         VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());
2874       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
2876       // If invokespecial of IMR, need to recheck for same or
2877       // direct interface relative to the host class
2878       have_imr_indirect = (have_imr_indirect &amp;&amp;
2879                            !is_same_or_direct_interface(
2880                              current_class()-&gt;unsafe_anonymous_host(),
2881                              unsafe_anonymous_host_type, ref_class_type));
2882     }
2883     if (!subtype) {
2884       verify_error(ErrorContext::bad_code(bci),
2885           &quot;Bad invokespecial instruction: &quot;
2886           &quot;current class isn&#39;t assignable to reference class.&quot;);
2887        return;
2888     } else if (have_imr_indirect) {
2889       verify_error(ErrorContext::bad_code(bci),
2890           &quot;Bad invokespecial instruction: &quot;
2891           &quot;interface method reference is in an indirect superinterface.&quot;);
2892       return;
2893     }
2894 
2895   }
<span class="line-added">2896 </span>
<span class="line-added">2897   // Get the verification types for the method&#39;s arguments.</span>
<span class="line-added">2898   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();</span>
<span class="line-added">2899   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);</span>
2900   // Match method descriptor with operand stack
<span class="line-modified">2901   // The arguments are on the stack in descending order.</span>
<span class="line-modified">2902   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards</span>
<span class="line-added">2903     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));</span>
2904   }
<span class="line-added">2905 </span>
2906   // Check objectref on operand stack
2907   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2908       opcode != Bytecodes::_invokedynamic) {
2909     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2910       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2911         code_length, in_try_block, this_uninit, cp, stackmap_table,
2912         CHECK_VERIFY(this));
2913       if (was_recursively_verified()) return;
2914     } else {   // other methods
2915       // Ensures that target class is assignable to method class.
2916       if (opcode == Bytecodes::_invokespecial) {
2917         if (!current_class()-&gt;is_unsafe_anonymous()) {
2918           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2919         } else {
2920           // anonymous class invokespecial calls: check if the
2921           // objectref is a subtype of the unsafe_anonymous_host of the current class
2922           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2923           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2924           VerificationType hosttype =
2925             VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());
</pre>
<hr />
<pre>
2957                   // Special case: arrays pretend to implement public Object
2958                   // clone().
2959                 } else {
2960                   verify_error(ErrorContext::bad_type(bci,
2961                       current_frame-&gt;stack_top_ctx(),
2962                       TypeOrigin::implicit(current_type())),
2963                       &quot;Bad access to protected data in invokevirtual&quot;);
2964                   return;
2965                 }
2966               }
2967             }
2968           }
2969         }
2970       } else {
2971         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
2972         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2973       }
2974     }
2975   }
2976   // Push the result type.
<span class="line-modified">2977   int sig_verif_types_len = sig_verif_types-&gt;length();</span>
<span class="line-added">2978   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type</span>
2979     if (method_name == vmSymbols::object_initializer_name()) {
2980       // &lt;init&gt; method must have a void return type
2981       /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have
2982        * void return */
2983       verify_error(ErrorContext::bad_code(bci),
2984           &quot;Return type must be void in &lt;init&gt; method&quot;);
2985       return;
2986     }
<span class="line-modified">2987 </span>
<span class="line-modified">2988     assert(sig_verif_types_len &lt;= nargs + 2,</span>
<span class="line-modified">2989            &quot;Signature verification types array return type is bogus&quot;);</span>
<span class="line-modified">2990     for (int i = nargs; i &lt; sig_verif_types_len; i++) {</span>
<span class="line-modified">2991       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||</span>
<span class="line-added">2992              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);</span>
<span class="line-added">2993       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));</span>
2994     }
2995   }
2996 }
2997 
2998 VerificationType ClassVerifier::get_newarray_type(
2999     u2 index, u2 bci, TRAPS) {
3000   const char* from_bt[] = {
3001     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
3002   };
3003   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
3004     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
3005     return VerificationType::bogus_type();
3006   }
3007 
3008   // from_bt[index] contains the array signature which has a length of 2
<span class="line-modified">3009   Symbol* sig = create_temporary_symbol(from_bt[index], 2);</span>

3010   return VerificationType::reference_type(sig);
3011 }
3012 
3013 void ClassVerifier::verify_anewarray(
3014     u2 bci, u2 index, const constantPoolHandle&amp; cp,
3015     StackMapFrame* current_frame, TRAPS) {
3016   verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
3017   current_frame-&gt;pop_stack(
3018     VerificationType::integer_type(), CHECK_VERIFY(this));
3019 
3020   if (was_recursively_verified()) return;
3021   VerificationType component_type =
3022     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3023   int length;
3024   char* arr_sig_str;
3025   if (component_type.is_array()) {     // it&#39;s an array
3026     const char* component_name = component_type.name()-&gt;as_utf8();
3027     // Check for more than MAX_ARRAY_DIMENSIONS
3028     length = (int)strlen(component_name);
3029     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
<span class="line-modified">3030         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {</span>
3031       verify_error(ErrorContext::bad_code(bci),
3032         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3033     }
3034     // add one dimension to component
3035     length++;
3036     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">3037     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,</span>
<span class="line-added">3038                          JVM_SIGNATURE_ARRAY, component_name);</span>
3039     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3040   } else {         // it&#39;s an object or interface
3041     const char* component_name = component_type.name()-&gt;as_utf8();
3042     // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.
3043     length = (int)strlen(component_name) + 3;
3044     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">3045     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,</span>
<span class="line-added">3046                          JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);</span>
3047     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3048   }
<span class="line-modified">3049   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);</span>

3050   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3051   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3052 }
3053 
3054 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3055   current_frame-&gt;get_local(
3056     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3057   current_frame-&gt;push_stack(
3058     VerificationType::integer_type(), CHECK_VERIFY(this));
3059 }
3060 
3061 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3062   current_frame-&gt;get_local_2(
3063     index, VerificationType::long_type(),
3064     VerificationType::long2_type(), CHECK_VERIFY(this));
3065   current_frame-&gt;push_stack_2(
3066     VerificationType::long_type(),
3067     VerificationType::long2_type(), CHECK_VERIFY(this));
3068 }
3069 
</pre>
<hr />
<pre>
3137     StackMapFrame* current_frame, TRAPS) {
3138   if (return_type == VerificationType::bogus_type()) {
3139     verify_error(ErrorContext::bad_type(bci,
3140         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3141         &quot;Method expects a return value&quot;);
3142     return;
3143   }
3144   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3145   if (!match) {
3146     verify_error(ErrorContext::bad_type(bci,
3147         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3148         &quot;Bad return type&quot;);
3149     return;
3150   }
3151 }
3152 
3153 // The verifier creates symbols which are substrings of Symbols.
3154 // These are stored in the verifier until the end of verification so that
3155 // they can be reference counted.
3156 Symbol* ClassVerifier::create_temporary_symbol(const Symbol *s, int begin,
<span class="line-modified">3157                                                int end) {</span>
3158   const char* name = (const char*)s-&gt;base() + begin;
3159   int length = end - begin;
<span class="line-modified">3160   return create_temporary_symbol(name, length);</span>
3161 }
3162 
<span class="line-modified">3163 Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length) {</span>
3164   // Quick deduplication check
3165   if (_previous_symbol != NULL &amp;&amp; _previous_symbol-&gt;equals(name, length)) {
3166     return _previous_symbol;
3167   }
<span class="line-modified">3168   Symbol* sym = SymbolTable::new_symbol(name, length);</span>
3169   if (!sym-&gt;is_permanent()) {
3170     if (_symbols == NULL) {
3171       _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
3172     }
3173     _symbols-&gt;push(sym);
3174   }
3175   _previous_symbol = sym;
3176   return sym;
3177 }
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
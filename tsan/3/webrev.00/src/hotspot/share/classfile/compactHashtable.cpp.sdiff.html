<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/compactHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderStats.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compactHashtable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/compactHashtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;logging/logMessage.hpp&quot;

 30 #include &quot;memory/heapShared.inline.hpp&quot;
 31 #include &quot;memory/metadataFactory.hpp&quot;
 32 #include &quot;memory/metaspaceShared.hpp&quot;
<span class="line-removed"> 33 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
 34 #include &quot;runtime/vmThread.hpp&quot;
 35 #include &quot;utilities/numberSeq.hpp&quot;
 36 #include &lt;sys/stat.h&gt;
 37 
 38 #if INCLUDE_CDS
 39 /////////////////////////////////////////////////////
 40 //
 41 // The compact hash table writer implementations
 42 //
<span class="line-modified"> 43 CompactHashtableWriter::CompactHashtableWriter(int num_buckets,</span>
 44                                                CompactHashtableStats* stats) {
<span class="line-modified"> 45   assert(DumpSharedSpaces, &quot;dump-time only&quot;);</span>
<span class="line-modified"> 46   assert(num_buckets &gt; 0, &quot;no buckets&quot;);</span>
<span class="line-modified"> 47   _num_buckets = num_buckets;</span>
<span class="line-modified"> 48   _num_entries = 0;</span>


 49   _buckets = NEW_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _num_buckets, mtSymbol);
 50   for (int i=0; i&lt;_num_buckets; i++) {
 51     _buckets[i] = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray&lt;Entry&gt;(0, true, mtSymbol);
 52   }
 53 
 54   _stats = stats;
 55   _compact_buckets = NULL;
 56   _compact_entries = NULL;
 57   _num_empty_buckets = 0;
 58   _num_value_only_buckets = 0;
 59   _num_other_buckets = 0;
 60 }
 61 
 62 CompactHashtableWriter::~CompactHashtableWriter() {
 63   for (int index = 0; index &lt; _num_buckets; index++) {
 64     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 65     delete bucket;
 66   }
 67 
 68   FREE_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _buckets);
 69 }
 70 













 71 // Add a symbol entry to the temporary hash table
 72 void CompactHashtableWriter::add(unsigned int hash, u4 value) {
 73   int index = hash % _num_buckets;
 74   _buckets[index]-&gt;append_if_missing(Entry(hash, value));
<span class="line-modified"> 75   _num_entries++;</span>
 76 }
 77 
 78 void CompactHashtableWriter::allocate_table() {
 79   int entries_space = 0;
 80   for (int index = 0; index &lt; _num_buckets; index++) {
 81     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 82     int bucket_size = bucket-&gt;length();
 83     if (bucket_size == 1) {
 84       entries_space++;
<span class="line-modified"> 85     } else {</span>
 86       entries_space += 2 * bucket_size;
 87     }
 88   }
 89 
 90   if (entries_space &amp; ~BUCKET_OFFSET_MASK) {
 91     vm_exit_during_initialization(&quot;CompactHashtableWriter::allocate_table: Overflow! &quot;
 92                                   &quot;Too many entries.&quot;);
 93   }
 94 
 95   _compact_buckets = MetaspaceShared::new_ro_array&lt;u4&gt;(_num_buckets + 1);
 96   _compact_entries = MetaspaceShared::new_ro_array&lt;u4&gt;(entries_space);
 97 
 98   _stats-&gt;bucket_count    = _num_buckets;
 99   _stats-&gt;bucket_bytes    = _compact_buckets-&gt;size() * BytesPerWord;
<span class="line-modified">100   _stats-&gt;hashentry_count = _num_entries;</span>
101   _stats-&gt;hashentry_bytes = _compact_entries-&gt;size() * BytesPerWord;
102 }
103 
104 // Write the compact table&#39;s buckets
105 void CompactHashtableWriter::dump_table(NumberSeq* summary) {
106   u4 offset = 0;
107   for (int index = 0; index &lt; _num_buckets; index++) {
108     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
109     int bucket_size = bucket-&gt;length();
110     if (bucket_size == 1) {
111       // bucket with one entry is compacted and only has the symbol offset
112       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, VALUE_ONLY_BUCKET_TYPE));
113 
114       Entry ent = bucket-&gt;at(0);
115       _compact_entries-&gt;at_put(offset++, ent.value());
116       _num_value_only_buckets++;
117     } else {
118       // regular bucket, each entry is a symbol (hash, offset) pair
119       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, REGULAR_BUCKET_TYPE));
120 
</pre>
<hr />
<pre>
128       } else {
129         _num_other_buckets++;
130       }
131     }
132     summary-&gt;add(bucket_size);
133   }
134 
135   // Mark the end of the buckets
136   _compact_buckets-&gt;at_put(_num_buckets, BUCKET_INFO(offset, TABLEEND_BUCKET_TYPE));
137   assert(offset == (u4)_compact_entries-&gt;length(), &quot;sanity&quot;);
138 }
139 
140 
141 // Write the compact table
142 void CompactHashtableWriter::dump(SimpleCompactHashtable *cht, const char* table_name) {
143   NumberSeq summary;
144   allocate_table();
145   dump_table(&amp;summary);
146 
147   int table_bytes = _stats-&gt;bucket_bytes + _stats-&gt;hashentry_bytes;
<span class="line-modified">148   address base_address = address(MetaspaceShared::shared_rs()-&gt;base());</span>
<span class="line-modified">149   cht-&gt;init(base_address,  _num_entries, _num_buckets,</span>
150             _compact_buckets-&gt;data(), _compact_entries-&gt;data());
151 
152   LogMessage(cds, hashtables) msg;
153   if (msg.is_info()) {
154     double avg_cost = 0.0;
<span class="line-modified">155     if (_num_entries &gt; 0) {</span>
<span class="line-modified">156       avg_cost = double(table_bytes)/double(_num_entries);</span>
157     }
158     msg.info(&quot;Shared %s table stats -------- base: &quot; PTR_FORMAT,
159                          table_name, (intptr_t)base_address);
<span class="line-modified">160     msg.info(&quot;Number of entries       : %9d&quot;, _num_entries);</span>
161     msg.info(&quot;Total bytes used        : %9d&quot;, table_bytes);
162     msg.info(&quot;Average bytes per entry : %9.3f&quot;, avg_cost);
163     msg.info(&quot;Average bucket size     : %9.3f&quot;, summary.avg());
164     msg.info(&quot;Variance of bucket size : %9.3f&quot;, summary.variance());
165     msg.info(&quot;Std. dev. of bucket size: %9.3f&quot;, summary.sd());
166     msg.info(&quot;Maximum bucket size     : %9d&quot;, (int)summary.maximum());
167     msg.info(&quot;Empty buckets           : %9d&quot;, _num_empty_buckets);
168     msg.info(&quot;Value_Only buckets      : %9d&quot;, _num_value_only_buckets);
169     msg.info(&quot;Other buckets           : %9d&quot;, _num_other_buckets);
170   }
171 }
172 
173 /////////////////////////////////////////////////////////////
174 //
175 // The CompactHashtable implementation
176 //
177 



















178 void SimpleCompactHashtable::serialize_header(SerializeClosure* soc) {


179   soc-&gt;do_ptr((void**)&amp;_base_address);
180   soc-&gt;do_u4(&amp;_entry_count);
181   soc-&gt;do_u4(&amp;_bucket_count);
182   soc-&gt;do_ptr((void**)&amp;_buckets);
183   soc-&gt;do_ptr((void**)&amp;_entries);
184 }
185 #endif // INCLUDE_CDS
186 
187 #ifndef O_BINARY       // if defined (Win32) use binary files.
188 #define O_BINARY 0     // otherwise do nothing.
189 #endif
190 
191 ////////////////////////////////////////////////////////
192 //
193 // HashtableTextDump
194 //
195 HashtableTextDump::HashtableTextDump(const char* filename) : _fd(-1) {
196   struct stat st;
197   if (os::stat(filename, &amp;st) != 0) {
198     quit(&quot;Unable to get hashtable dump file size&quot;, filename);
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;logging/logMessage.hpp&quot;
<span class="line-added"> 30 #include &quot;memory/dynamicArchive.hpp&quot;</span>
 31 #include &quot;memory/heapShared.inline.hpp&quot;
 32 #include &quot;memory/metadataFactory.hpp&quot;
 33 #include &quot;memory/metaspaceShared.hpp&quot;

 34 #include &quot;runtime/vmThread.hpp&quot;
 35 #include &quot;utilities/numberSeq.hpp&quot;
 36 #include &lt;sys/stat.h&gt;
 37 
 38 #if INCLUDE_CDS
 39 /////////////////////////////////////////////////////
 40 //
 41 // The compact hash table writer implementations
 42 //
<span class="line-modified"> 43 CompactHashtableWriter::CompactHashtableWriter(int num_entries,</span>
 44                                                CompactHashtableStats* stats) {
<span class="line-modified"> 45   Arguments::assert_is_dumping_archive();</span>
<span class="line-modified"> 46   assert(num_entries &gt;= 0, &quot;sanity&quot;);</span>
<span class="line-modified"> 47   _num_buckets = calculate_num_buckets(num_entries);</span>
<span class="line-modified"> 48   assert(_num_buckets &gt; 0, &quot;no buckets&quot;);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50   _num_entries_written = 0;</span>
 51   _buckets = NEW_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _num_buckets, mtSymbol);
 52   for (int i=0; i&lt;_num_buckets; i++) {
 53     _buckets[i] = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray&lt;Entry&gt;(0, true, mtSymbol);
 54   }
 55 
 56   _stats = stats;
 57   _compact_buckets = NULL;
 58   _compact_entries = NULL;
 59   _num_empty_buckets = 0;
 60   _num_value_only_buckets = 0;
 61   _num_other_buckets = 0;
 62 }
 63 
 64 CompactHashtableWriter::~CompactHashtableWriter() {
 65   for (int index = 0; index &lt; _num_buckets; index++) {
 66     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 67     delete bucket;
 68   }
 69 
 70   FREE_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _buckets);
 71 }
 72 
<span class="line-added"> 73 size_t CompactHashtableWriter::estimate_size(int num_entries) {</span>
<span class="line-added"> 74   int num_buckets = calculate_num_buckets(num_entries);</span>
<span class="line-added"> 75   size_t bucket_bytes = MetaspaceShared::ro_array_bytesize&lt;u4&gt;(num_buckets + 1);</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   // In worst case, we have no VALUE_ONLY_BUCKET_TYPE, so each entry takes 2 slots</span>
<span class="line-added"> 78   int entries_space = 2 * num_entries;</span>
<span class="line-added"> 79   size_t entry_bytes = MetaspaceShared::ro_array_bytesize&lt;u4&gt;(entries_space);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   return bucket_bytes</span>
<span class="line-added"> 82        + entry_bytes</span>
<span class="line-added"> 83        + SimpleCompactHashtable::calculate_header_size();</span>
<span class="line-added"> 84 }</span>
<span class="line-added"> 85 </span>
 86 // Add a symbol entry to the temporary hash table
 87 void CompactHashtableWriter::add(unsigned int hash, u4 value) {
 88   int index = hash % _num_buckets;
 89   _buckets[index]-&gt;append_if_missing(Entry(hash, value));
<span class="line-modified"> 90   _num_entries_written++;</span>
 91 }
 92 
 93 void CompactHashtableWriter::allocate_table() {
 94   int entries_space = 0;
 95   for (int index = 0; index &lt; _num_buckets; index++) {
 96     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 97     int bucket_size = bucket-&gt;length();
 98     if (bucket_size == 1) {
 99       entries_space++;
<span class="line-modified">100     } else if (bucket_size &gt; 1) {</span>
101       entries_space += 2 * bucket_size;
102     }
103   }
104 
105   if (entries_space &amp; ~BUCKET_OFFSET_MASK) {
106     vm_exit_during_initialization(&quot;CompactHashtableWriter::allocate_table: Overflow! &quot;
107                                   &quot;Too many entries.&quot;);
108   }
109 
110   _compact_buckets = MetaspaceShared::new_ro_array&lt;u4&gt;(_num_buckets + 1);
111   _compact_entries = MetaspaceShared::new_ro_array&lt;u4&gt;(entries_space);
112 
113   _stats-&gt;bucket_count    = _num_buckets;
114   _stats-&gt;bucket_bytes    = _compact_buckets-&gt;size() * BytesPerWord;
<span class="line-modified">115   _stats-&gt;hashentry_count = _num_entries_written;</span>
116   _stats-&gt;hashentry_bytes = _compact_entries-&gt;size() * BytesPerWord;
117 }
118 
119 // Write the compact table&#39;s buckets
120 void CompactHashtableWriter::dump_table(NumberSeq* summary) {
121   u4 offset = 0;
122   for (int index = 0; index &lt; _num_buckets; index++) {
123     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
124     int bucket_size = bucket-&gt;length();
125     if (bucket_size == 1) {
126       // bucket with one entry is compacted and only has the symbol offset
127       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, VALUE_ONLY_BUCKET_TYPE));
128 
129       Entry ent = bucket-&gt;at(0);
130       _compact_entries-&gt;at_put(offset++, ent.value());
131       _num_value_only_buckets++;
132     } else {
133       // regular bucket, each entry is a symbol (hash, offset) pair
134       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, REGULAR_BUCKET_TYPE));
135 
</pre>
<hr />
<pre>
143       } else {
144         _num_other_buckets++;
145       }
146     }
147     summary-&gt;add(bucket_size);
148   }
149 
150   // Mark the end of the buckets
151   _compact_buckets-&gt;at_put(_num_buckets, BUCKET_INFO(offset, TABLEEND_BUCKET_TYPE));
152   assert(offset == (u4)_compact_entries-&gt;length(), &quot;sanity&quot;);
153 }
154 
155 
156 // Write the compact table
157 void CompactHashtableWriter::dump(SimpleCompactHashtable *cht, const char* table_name) {
158   NumberSeq summary;
159   allocate_table();
160   dump_table(&amp;summary);
161 
162   int table_bytes = _stats-&gt;bucket_bytes + _stats-&gt;hashentry_bytes;
<span class="line-modified">163   address base_address = address(SharedBaseAddress);</span>
<span class="line-modified">164   cht-&gt;init(base_address,  _num_entries_written, _num_buckets,</span>
165             _compact_buckets-&gt;data(), _compact_entries-&gt;data());
166 
167   LogMessage(cds, hashtables) msg;
168   if (msg.is_info()) {
169     double avg_cost = 0.0;
<span class="line-modified">170     if (_num_entries_written &gt; 0) {</span>
<span class="line-modified">171       avg_cost = double(table_bytes)/double(_num_entries_written);</span>
172     }
173     msg.info(&quot;Shared %s table stats -------- base: &quot; PTR_FORMAT,
174                          table_name, (intptr_t)base_address);
<span class="line-modified">175     msg.info(&quot;Number of entries       : %9d&quot;, _num_entries_written);</span>
176     msg.info(&quot;Total bytes used        : %9d&quot;, table_bytes);
177     msg.info(&quot;Average bytes per entry : %9.3f&quot;, avg_cost);
178     msg.info(&quot;Average bucket size     : %9.3f&quot;, summary.avg());
179     msg.info(&quot;Variance of bucket size : %9.3f&quot;, summary.variance());
180     msg.info(&quot;Std. dev. of bucket size: %9.3f&quot;, summary.sd());
181     msg.info(&quot;Maximum bucket size     : %9d&quot;, (int)summary.maximum());
182     msg.info(&quot;Empty buckets           : %9d&quot;, _num_empty_buckets);
183     msg.info(&quot;Value_Only buckets      : %9d&quot;, _num_value_only_buckets);
184     msg.info(&quot;Other buckets           : %9d&quot;, _num_other_buckets);
185   }
186 }
187 
188 /////////////////////////////////////////////////////////////
189 //
190 // The CompactHashtable implementation
191 //
192 
<span class="line-added">193 void SimpleCompactHashtable::init(address base_address, u4 entry_count, u4 bucket_count, u4* buckets, u4* entries) {</span>
<span class="line-added">194   _bucket_count = bucket_count;</span>
<span class="line-added">195   _entry_count = entry_count;</span>
<span class="line-added">196   _base_address = base_address;</span>
<span class="line-added">197   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">198     _buckets = DynamicArchive::buffer_to_target(buckets);</span>
<span class="line-added">199     _entries = DynamicArchive::buffer_to_target(entries);</span>
<span class="line-added">200   } else {</span>
<span class="line-added">201     _buckets = buckets;</span>
<span class="line-added">202     _entries = entries;</span>
<span class="line-added">203   }</span>
<span class="line-added">204 }</span>
<span class="line-added">205 </span>
<span class="line-added">206 size_t SimpleCompactHashtable::calculate_header_size() {</span>
<span class="line-added">207   // We have 5 fields. Each takes up sizeof(intptr_t). See WriteClosure::do_u4</span>
<span class="line-added">208   size_t bytes = sizeof(intptr_t) * 5;</span>
<span class="line-added">209   return bytes;</span>
<span class="line-added">210 }</span>
<span class="line-added">211 </span>
212 void SimpleCompactHashtable::serialize_header(SerializeClosure* soc) {
<span class="line-added">213   // NOTE: if you change this function, you MUST change the number 5 in</span>
<span class="line-added">214   // calculate_header_size() accordingly.</span>
215   soc-&gt;do_ptr((void**)&amp;_base_address);
216   soc-&gt;do_u4(&amp;_entry_count);
217   soc-&gt;do_u4(&amp;_bucket_count);
218   soc-&gt;do_ptr((void**)&amp;_buckets);
219   soc-&gt;do_ptr((void**)&amp;_entries);
220 }
221 #endif // INCLUDE_CDS
222 
223 #ifndef O_BINARY       // if defined (Win32) use binary files.
224 #define O_BINARY 0     // otherwise do nothing.
225 #endif
226 
227 ////////////////////////////////////////////////////////
228 //
229 // HashtableTextDump
230 //
231 HashtableTextDump::HashtableTextDump(const char* filename) : _fd(-1) {
232   struct stat st;
233   if (os::stat(filename, &amp;st) != 0) {
234     quit(&quot;Unable to get hashtable dump file size&quot;, filename);
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderStats.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compactHashtable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
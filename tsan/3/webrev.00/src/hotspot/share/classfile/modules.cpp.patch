diff a/src/hotspot/share/classfile/modules.cpp b/src/hotspot/share/classfile/modules.cpp
--- a/src/hotspot/share/classfile/modules.cpp
+++ b/src/hotspot/share/classfile/modules.cpp
@@ -1,7 +1,7 @@
 /*
-* Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+* Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
@@ -109,11 +109,11 @@
 }
 
 static PackageEntry* get_package_entry(ModuleEntry* module_entry, const char* package_name, TRAPS) {
   ResourceMark rm(THREAD);
   if (package_name == NULL) return NULL;
-  TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name, CHECK_NULL);
+  TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name);
   PackageEntryTable* package_entry_table = module_entry->loader_data()->packages();
   assert(package_entry_table != NULL, "Unexpected null package entry table");
   return package_entry_table->lookup_only(pkg_symbol);
 }
 
@@ -146,11 +146,11 @@
 
   // Obtain java.base's module version
   const char* module_version = get_module_version(version);
   TempNewSymbol version_symbol;
   if (module_version != NULL) {
-    version_symbol = SymbolTable::new_symbol(module_version, CHECK);
+    version_symbol = SymbolTable::new_symbol(module_version);
   } else {
     version_symbol = NULL;
   }
 
   // Obtain java.base's location
@@ -158,11 +158,11 @@
   TempNewSymbol location_symbol = NULL;
   if (location != NULL) {
     module_location =
       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
     if (module_location != NULL) {
-      location_symbol = SymbolTable::new_symbol(module_location, CHECK);
+      location_symbol = SymbolTable::new_symbol(module_location);
     }
   }
 
 
   // Check that the packages are syntactically ok.
@@ -171,11 +171,11 @@
     const char *package_name = packages[x];
     if (!Modules::verify_package_name(package_name)) {
       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
                 err_msg("Invalid package name: %s for module: " JAVA_BASE_NAME, package_name));
     }
-    Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);
+    Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);
     pkg_list->append(pkg_symbol);
   }
 
   // Validate java_base's loader is the boot loader.
   oop loader = java_lang_Module::loader(module_handle());
@@ -192,11 +192,11 @@
   // Ensure java.base's ModuleEntry has been created
   assert(ModuleEntryTable::javabase_moduleEntry() != NULL, "No ModuleEntry for " JAVA_BASE_NAME);
 
   bool duplicate_javabase = false;
   {
-    MutexLocker m1(Module_lock, THREAD);
+    MutexLocker m1(THREAD, Module_lock);
 
     if (ModuleEntryTable::javabase_defined()) {
       duplicate_javabase = true;
     } else {
 
@@ -304,11 +304,11 @@
 
   const char* module_version = get_module_version(version);
 
   oop loader = java_lang_Module::loader(module_handle());
   // Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.
-  if (!oopDesc::equals(loader, java_lang_ClassLoader::non_reflection_class_loader(loader))) {
+  if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {
     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
               "Class loader is an invalid delegating class loader");
   }
   Handle h_loader = Handle(THREAD, loader);
   // define_module can be called during start-up, before the class loader's ClassLoaderData
@@ -329,11 +329,11 @@
 
     // Only modules defined to either the boot or platform class loader, can define a "java/" package.
     if (!h_loader.is_null() &&
         !SystemDictionary::is_platform_class_loader(h_loader()) &&
         (strncmp(package_name, JAVAPKG, JAVAPKG_LEN) == 0 &&
-          (package_name[JAVAPKG_LEN] == '/' || package_name[JAVAPKG_LEN] == '\0'))) {
+          (package_name[JAVAPKG_LEN] == JVM_SIGNATURE_SLASH || package_name[JAVAPKG_LEN] == '\0'))) {
       const char* class_loader_name = loader_data->loader_name_and_id();
       size_t pkg_len = strlen(package_name);
       char* pkg_name = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, pkg_len + 1);
       strncpy(pkg_name, package_name, pkg_len + 1);
       StringUtils::replace_no_expand(pkg_name, "/", ".");
@@ -343,26 +343,26 @@
       char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);
       jio_snprintf(message, len, "%s%s%s%s", msg_text1, class_loader_name, msg_text2, pkg_name);
       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), message);
     }
 
-    Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);
+    Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);
     pkg_list->append(pkg_symbol);
   }
 
   ModuleEntryTable* module_table = get_module_entry_table(h_loader);
   assert(module_table != NULL, "module entry table shouldn't be null");
 
   // Create symbol* entry for module name.
-  TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name, CHECK);
+  TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name);
 
   bool dupl_modules = false;
 
   // Create symbol* entry for module version.
   TempNewSymbol version_symbol;
   if (module_version != NULL) {
-    version_symbol = SymbolTable::new_symbol(module_version, CHECK);
+    version_symbol = SymbolTable::new_symbol(module_version);
   } else {
     version_symbol = NULL;
   }
 
   // Create symbol* entry for module location.
@@ -370,18 +370,18 @@
   TempNewSymbol location_symbol = NULL;
   if (location != NULL) {
     module_location =
       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
     if (module_location != NULL) {
-      location_symbol = SymbolTable::new_symbol(module_location, CHECK);
+      location_symbol = SymbolTable::new_symbol(module_location);
     }
   }
 
   PackageEntryTable* package_table = NULL;
   PackageEntry* existing_pkg = NULL;
   {
-    MutexLocker ml(Module_lock, THREAD);
+    MutexLocker ml(THREAD, Module_lock);
 
     if (num_packages > 0) {
       package_table = get_package_entry_table(h_loader);
       assert(package_table != NULL, "Missing package_table");
 
@@ -655,11 +655,11 @@
   assert(package_name != NULL, "the package_name should not be NULL");
 
   if (strlen(package_name) == 0) {
     return NULL;
   }
-  TempNewSymbol package_sym = SymbolTable::new_symbol(package_name, CHECK_NULL);
+  TempNewSymbol package_sym = SymbolTable::new_symbol(package_name);
   const PackageEntry* const pkg_entry =
     get_package_entry_by_name(package_sym, h_loader, THREAD);
   const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry->module() : NULL);
 
   if (module_entry != NULL && module_entry->module() != NULL && module_entry->is_named()) {

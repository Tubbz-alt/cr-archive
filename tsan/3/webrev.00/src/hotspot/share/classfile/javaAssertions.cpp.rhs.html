<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaAssertions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaAssertions.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;classfile/vmSymbols.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/oopFactory.hpp&quot;
 32 #include &quot;oops/objArrayOop.inline.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 
 37 bool                            JavaAssertions::_userDefault = false;
 38 bool                            JavaAssertions::_sysDefault = false;
 39 JavaAssertions::OptionList*     JavaAssertions::_classes = 0;
 40 JavaAssertions::OptionList*     JavaAssertions::_packages = 0;
 41 
 42 JavaAssertions::OptionList::OptionList(const char* name, bool enabled,
 43   OptionList* next) {
 44   assert(name != 0, &quot;need a name&quot;);
 45   _name = name;
 46   _enabled = enabled;
 47   _next = next;
 48 }
 49 
 50 int JavaAssertions::OptionList::count(OptionList* p) {
 51   int rc;
 52   for (rc = 0; p != 0; p = p-&gt;next(), ++rc) /* empty */;
 53   return rc;
 54 }
 55 
 56 void JavaAssertions::addOption(const char* name, bool enable) {
 57   assert(name != 0, &quot;must have a name&quot;);
 58 
 59   // Copy the name.  The storage needs to exist for the the lifetime of the vm;
 60   // it is never freed, so will be leaked (along with other option strings -
 61   // e.g., bootclasspath) if a process creates/destroys multiple VMs.
 62   int len = (int)strlen(name);
 63   char *name_copy = NEW_C_HEAP_ARRAY(char, len + 1, mtClass);
 64   strcpy(name_copy, name);
 65 
 66   // Figure out which list the new item should go on.  Names that end in &quot;...&quot;
 67   // go on the package tree list.
 68   OptionList** head = &amp;_classes;
 69   if (len &gt;= 3 &amp;&amp; strcmp(name_copy + len - 3, &quot;...&quot;) == 0) {
 70     // Delete the &quot;...&quot;.
 71     len -= 3;
 72     name_copy[len] = &#39;\0&#39;;
 73     head = &amp;_packages;
 74   }
 75 
 76   // Convert class/package names to internal format.  Will have to convert back
 77   // when copying to java in createJavaAssertionStatusDirectives, but that
 78   // should happen only once.  Alternative would require that
 79   // JVM_DesiredAssertionStatus pass the external_name() to
 80   // JavaAssertion::enabled(), but that is done once per loaded class.
 81   for (int i = 0; i &lt; len; ++i) {
<a name="1" id="anc1"></a><span class="line-modified"> 82     if (name_copy[i] == JVM_SIGNATURE_DOT) name_copy[i] = JVM_SIGNATURE_SLASH;</span>
 83   }
 84 
 85   if (TraceJavaAssertions) {
 86     tty-&gt;print_cr(&quot;JavaAssertions: adding %s %s=%d&quot;,
 87       head == &amp;_classes ? &quot;class&quot; : &quot;package&quot;,
 88       name_copy[0] != &#39;\0&#39; ? name_copy : &quot;&#39;default&#39;&quot;,
 89       enable);
 90   }
 91 
 92   // Prepend a new item to the list.  Items added later take precedence, so
 93   // prepending allows us to stop searching the list after the first match.
 94   *head = new OptionList(name_copy, enable, *head);
 95 }
 96 
 97 oop JavaAssertions::createAssertionStatusDirectives(TRAPS) {
 98   Symbol* asd_sym = vmSymbols::java_lang_AssertionStatusDirectives();
 99   Klass* k = SystemDictionary::resolve_or_fail(asd_sym, true, CHECK_NULL);
100   InstanceKlass* asd_klass = InstanceKlass::cast(k);
101   asd_klass-&gt;initialize(CHECK_NULL);
102   Handle h = asd_klass-&gt;allocate_instance_handle(CHECK_NULL);
103 
104   int len;
105   typeArrayOop t;
106   len = OptionList::count(_packages);
107   objArrayOop pn = oopFactory::new_objArray(SystemDictionary::String_klass(), len, CHECK_NULL);
108   objArrayHandle pkgNames (THREAD, pn);
109   t = oopFactory::new_typeArray(T_BOOLEAN, len, CHECK_NULL);
110   typeArrayHandle pkgEnabled(THREAD, t);
111   fillJavaArrays(_packages, len, pkgNames, pkgEnabled, CHECK_NULL);
112 
113   len = OptionList::count(_classes);
114   objArrayOop cn = oopFactory::new_objArray(SystemDictionary::String_klass(), len, CHECK_NULL);
115   objArrayHandle classNames (THREAD, cn);
116   t = oopFactory::new_typeArray(T_BOOLEAN, len, CHECK_NULL);
117   typeArrayHandle classEnabled(THREAD, t);
118   fillJavaArrays(_classes, len, classNames, classEnabled, CHECK_NULL);
119 
120   java_lang_AssertionStatusDirectives::set_packages(h(), pkgNames());
121   java_lang_AssertionStatusDirectives::set_packageEnabled(h(), pkgEnabled());
122   java_lang_AssertionStatusDirectives::set_classes(h(), classNames());
123   java_lang_AssertionStatusDirectives::set_classEnabled(h(), classEnabled());
124   java_lang_AssertionStatusDirectives::set_deflt(h(), userClassDefault());
125   return h();
126 }
127 
128 void JavaAssertions::fillJavaArrays(const OptionList* p, int len,
129 objArrayHandle names, typeArrayHandle enabled, TRAPS) {
130   // Fill in the parallel names and enabled (boolean) arrays.  Start at the end
131   // of the array and work backwards, so the order of items in the arrays
132   // matches the order on the command line (the list is in reverse order, since
133   // it was created by prepending successive items from the command line).
134   int index;
135   for (index = len - 1; p != 0; p = p-&gt;next(), --index) {
136     assert(index &gt;= 0, &quot;length does not match list&quot;);
137     Handle s = java_lang_String::create_from_str(p-&gt;name(), CHECK);
<a name="2" id="anc2"></a><span class="line-modified">138     s = java_lang_String::char_converter(s, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, CHECK);</span>
139     names-&gt;obj_at_put(index, s());
140     enabled-&gt;bool_at_put(index, p-&gt;enabled());
141   }
142   assert(index == -1, &quot;length does not match list&quot;);
143 }
144 
145 inline JavaAssertions::OptionList*
146 JavaAssertions::match_class(const char* classname) {
147   for (OptionList* p = _classes; p != 0; p = p-&gt;next()) {
148     if (strcmp(p-&gt;name(), classname) == 0) {
149       return p;
150     }
151   }
152   return 0;
153 }
154 
155 JavaAssertions::OptionList*
156 JavaAssertions::match_package(const char* classname) {
157   // Search the package list for any items that apply to classname.  Each
158   // sub-package in classname is checked, from most-specific to least, until one
159   // is found.
160   if (_packages == 0) return 0;
161 
162   // Find the length of the &quot;most-specific&quot; package in classname.  If classname
163   // does not include a package, length will be 0 which will match items for the
164   // default package (from options &quot;-ea:...&quot;  or &quot;-da:...&quot;).
165   size_t len = strlen(classname);
<a name="3" id="anc3"></a><span class="line-modified">166   for (/* empty */; len &gt; 0 &amp;&amp; classname[len] != JVM_SIGNATURE_SLASH; --len) /* empty */;</span>
167 
168   do {
<a name="4" id="anc4"></a><span class="line-modified">169     assert(len == 0 || classname[len] == JVM_SIGNATURE_SLASH, &quot;not a package name&quot;);</span>
170     for (OptionList* p = _packages; p != 0; p = p-&gt;next()) {
171       if (strncmp(p-&gt;name(), classname, len) == 0 &amp;&amp; p-&gt;name()[len] == &#39;\0&#39;) {
172         return p;
173       }
174     }
175 
176     // Find the length of the next package, taking care to avoid decrementing
177     // past 0 (len is unsigned).
<a name="5" id="anc5"></a><span class="line-modified">178     while (len &gt; 0 &amp;&amp; classname[--len] != JVM_SIGNATURE_SLASH) /* empty */;</span>
179   } while (len &gt; 0);
180 
181   return 0;
182 }
183 
184 inline void JavaAssertions::trace(const char* name,
185 const char* typefound, const char* namefound, bool enabled) {
186   if (TraceJavaAssertions) {
187     tty-&gt;print_cr(&quot;JavaAssertions:  search for %s found %s %s=%d&quot;,
188       name, typefound, namefound[0] != &#39;\0&#39; ? namefound : &quot;&#39;default&#39;&quot;, enabled);
189   }
190 }
191 
192 bool JavaAssertions::enabled(const char* classname, bool systemClass) {
193   assert(classname != 0, &quot;must have a classname&quot;);
194 
195   // This will be slow if the number of assertion options on the command line is
196   // large--it traverses two lists, one of them multiple times.  Could use a
197   // single n-ary tree instead of lists if someone ever notices.
198 
199   // First check options that apply to classes.  If we find a match we&#39;re done.
200   OptionList* p;
201   if ((p = match_class(classname))) {
202     trace(classname, &quot;class&quot;, p-&gt;name(), p-&gt;enabled());
203     return p-&gt;enabled();
204   }
205 
206   // Now check packages, from most specific to least.
207   if ((p = match_package(classname))) {
208     trace(classname, &quot;package&quot;, p-&gt;name(), p-&gt;enabled());
209     return p-&gt;enabled();
210   }
211 
212   // No match.  Return the default status.
213   bool result = systemClass ? systemClassDefault() : userClassDefault();
214   trace(classname, systemClass ? &quot;system&quot; : &quot;user&quot;, &quot;default&quot;, result);
215   return result;
216 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
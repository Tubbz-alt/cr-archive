<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderDataGraph.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderDataGraph.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 #include &quot;classfile/packageEntry.hpp&quot;
 32 #include &quot;code/dependencyContext.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;logging/logStream.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/metaspace.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/mutex.hpp&quot;
 41 #include &quot;runtime/safepoint.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 #include &quot;utilities/macros.hpp&quot;
 45 #include &quot;utilities/ostream.hpp&quot;
 46 
 47 volatile size_t ClassLoaderDataGraph::_num_array_classes = 0;
 48 volatile size_t ClassLoaderDataGraph::_num_instance_classes = 0;
 49 
 50 void ClassLoaderDataGraph::clear_claimed_marks() {
<span class="line-modified"> 51   for (ClassLoaderData* cld = _head; cld != NULL; cld = cld-&gt;next()) {</span>










 52     cld-&gt;clear_claim();
 53   }
 54 }
 55 





 56 // Class iterator used by the compiler.  It gets some number of classes at
 57 // a safepoint to decay invocation counters on the methods.
 58 class ClassLoaderDataGraphKlassIteratorStatic {
 59   ClassLoaderData* _current_loader_data;
 60   Klass*           _current_class_entry;
 61  public:
 62 
 63   ClassLoaderDataGraphKlassIteratorStatic() : _current_loader_data(NULL), _current_class_entry(NULL) {}
 64 
 65   InstanceKlass* try_get_next_class() {
 66     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
 67     size_t max_classes = ClassLoaderDataGraph::num_instance_classes();
 68     assert(max_classes &gt; 0, &quot;should not be called with no instance classes&quot;);
 69     for (size_t i = 0; i &lt; max_classes; ) {
 70 
 71       if (_current_class_entry != NULL) {
 72         Klass* k = _current_class_entry;
 73         _current_class_entry = _current_class_entry-&gt;next_link();
 74 
 75         if (k-&gt;is_instance_klass()) {
</pre>
<hr />
<pre>
146       loaders_processed++;
147     }
148   }
149   log_debug(class, loader, data)(&quot;clean_deallocate_lists: loaders processed %u %s&quot;,
150                                  loaders_processed, walk_previous_versions ? &quot;walk_previous_versions&quot; : &quot;&quot;);
151 }
152 
153 void ClassLoaderDataGraph::walk_metadata_and_clean_metaspaces() {
154   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called at safepoint&quot;);
155 
156   _should_clean_deallocate_lists = false; // assume everything gets cleaned
157 
158   // Mark metadata seen on the stack so we can delete unreferenced entries.
159   // Walk all metadata, including the expensive code cache walk, only for class redefinition.
160   // The MetadataOnStackMark walk during redefinition saves previous versions if it finds old methods
161   // on the stack or in the code cache, so we only have to repeat the full walk if
162   // they were found at that time.
163   // TODO: have redefinition clean old methods out of the code cache.  They still exist in some places.
164   bool walk_all_metadata = InstanceKlass::has_previous_versions_and_reset();
165 
<span class="line-modified">166   MetadataOnStackMark md_on_stack(walk_all_metadata);</span>
167   clean_deallocate_lists(walk_all_metadata);
168 }
169 
170 // GC root of class loader data created.
<span class="line-modified">171 ClassLoaderData* ClassLoaderDataGraph::_head = NULL;</span>
172 ClassLoaderData* ClassLoaderDataGraph::_unloading = NULL;
<span class="line-removed">173 ClassLoaderData* ClassLoaderDataGraph::_saved_unloading = NULL;</span>
<span class="line-removed">174 ClassLoaderData* ClassLoaderDataGraph::_saved_head = NULL;</span>
175 
<span class="line-removed">176 bool ClassLoaderDataGraph::_should_purge = false;</span>
177 bool ClassLoaderDataGraph::_should_clean_deallocate_lists = false;
178 bool ClassLoaderDataGraph::_safepoint_cleanup_needed = false;
179 bool ClassLoaderDataGraph::_metaspace_oom = false;
180 
181 // Add a new class loader data node to the list.  Assign the newly created
182 // ClassLoaderData into the java/lang/ClassLoader object as a hidden field
183 ClassLoaderData* ClassLoaderDataGraph::add_to_graph(Handle loader, bool is_unsafe_anonymous) {
184 
185   assert_lock_strong(ClassLoaderDataGraph_lock);
186 
187   ClassLoaderData* cld;
188 
189   // First check if another thread beat us to creating the CLD and installing
190   // it into the loader while we were waiting for the lock.
191   if (!is_unsafe_anonymous &amp;&amp; loader.not_null()) {
192     cld = java_lang_ClassLoader::loader_data_acquire(loader());
193     if (cld != NULL) {
194       return cld;
195     }
196   }
197 
198   // We mustn&#39;t GC until we&#39;ve installed the ClassLoaderData in the Graph since the CLD
199   // contains oops in _handles that must be walked.  GC doesn&#39;t walk CLD from the
200   // loader oop in all collections, particularly young collections.
201   NoSafepointVerifier no_safepoints;
202 
203   cld = new ClassLoaderData(loader, is_unsafe_anonymous);
204 
205   // First install the new CLD to the Graph.
206   cld-&gt;set_next(_head);
<span class="line-modified">207   _head = cld;</span>
208 
209   // Next associate with the class_loader.
210   if (!is_unsafe_anonymous) {
211     // Use OrderAccess, since readers need to get the loader_data only after
212     // it&#39;s added to the Graph
213     java_lang_ClassLoader::release_set_loader_data(loader(), cld);
214   }
215 
216   // Lastly log, if requested
217   LogTarget(Trace, class, loader, data) lt;
218   if (lt.is_enabled()) {
219     ResourceMark rm;
220     LogStream ls(lt);
221     ls.print(&quot;create &quot;);
222     cld-&gt;print_value_on(&amp;ls);
223     ls.cr();
224   }
225   return cld;
226 }
227 
228 ClassLoaderData* ClassLoaderDataGraph::add(Handle loader, bool is_unsafe_anonymous) {
229   MutexLocker ml(ClassLoaderDataGraph_lock);
230   ClassLoaderData* loader_data = add_to_graph(loader, is_unsafe_anonymous);
231   return loader_data;
232 }
233 
234 void ClassLoaderDataGraph::cld_unloading_do(CLDClosure* cl) {
235   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
<span class="line-modified">236   // Only walk the head until any clds not purged from prior unloading</span>
<span class="line-removed">237   // (CMS doesn&#39;t purge right away).</span>
<span class="line-removed">238   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
239     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
240     cl-&gt;do_cld(cld);
241   }
242 }
243 
244 // These are functions called by the GC, which require all of the CLDs, including the
245 // unloading ones.
246 void ClassLoaderDataGraph::cld_do(CLDClosure* cl) {
247   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
248   for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld-&gt;_next) {
249     cl-&gt;do_cld(cld);
250   }
251 }
252 
253 void ClassLoaderDataGraph::roots_cld_do(CLDClosure* strong, CLDClosure* weak) {
254   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
255   for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld-&gt;_next) {
256     CLDClosure* closure = cld-&gt;keep_alive() ? strong : weak;
257     if (closure != NULL) {
258       closure-&gt;do_cld(cld);
259     }
260   }
261 }
262 
263 void ClassLoaderDataGraph::always_strong_cld_do(CLDClosure* cl) {
264   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
265   if (ClassUnloading) {
266     roots_cld_do(cl, NULL);
267   } else {
268     cld_do(cl);
269   }
270 }
271 
<span class="line-modified">272 // Closure for locking and iterating through classes.</span>
<span class="line-modified">273 LockedClassesDo::LockedClassesDo(classes_do_func_t f) : _function(f) {</span>
<span class="line-modified">274   ClassLoaderDataGraph_lock-&gt;lock();</span>



275 }
276 
<span class="line-modified">277 LockedClassesDo::LockedClassesDo() : _function(NULL) {</span>

278   // callers provide their own do_klass
<span class="line-modified">279   ClassLoaderDataGraph_lock-&gt;lock();</span>


280 }
281 
<span class="line-modified">282 LockedClassesDo::~LockedClassesDo() { ClassLoaderDataGraph_lock-&gt;unlock(); }</span>




283 
284 
285 // Iterating over the CLDG needs to be locked because
286 // unloading can remove entries concurrently soon.
287 class ClassLoaderDataGraphIterator : public StackObj {
288   ClassLoaderData* _next;
289   HandleMark       _hm;  // clean up handles when this is done.
290   Handle           _holder;
291   Thread*          _thread;
292   NoSafepointVerifier _nsv; // No safepoints allowed in this scope
293                             // unless verifying at a safepoint.
294 
295 public:
<span class="line-modified">296   ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head),</span>
<span class="line-removed">297      _nsv(true, !SafepointSynchronize::is_at_safepoint()) {</span>
298     _thread = Thread::current();
299     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
300   }
301 
302   ClassLoaderData* get_next() {
303     ClassLoaderData* cld = _next;
304     // Skip already unloaded CLD for concurrent unloading.
305     while (cld != NULL &amp;&amp; !cld-&gt;is_alive()) {
306       cld = cld-&gt;next();
307     }
308     if (cld != NULL) {
309       // Keep cld that is being returned alive.
310       _holder = Handle(_thread, cld-&gt;holder_phantom());
311       _next = cld-&gt;next();
312     } else {
313       _next = NULL;
314     }
315     return cld;
316   }
317 };
</pre>
<hr />
<pre>
339   }
340 }
341 
342 void ClassLoaderDataGraph::methods_do(void f(Method*)) {
343   ClassLoaderDataGraphIterator iter;
344   while (ClassLoaderData* cld = iter.get_next()) {
345     cld-&gt;methods_do(f);
346   }
347 }
348 
349 void ClassLoaderDataGraph::modules_do(void f(ModuleEntry*)) {
350   assert_locked_or_safepoint(Module_lock);
351   ClassLoaderDataGraphIterator iter;
352   while (ClassLoaderData* cld = iter.get_next()) {
353     cld-&gt;modules_do(f);
354   }
355 }
356 
357 void ClassLoaderDataGraph::modules_unloading_do(void f(ModuleEntry*)) {
358   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">359   // Only walk the head until any clds not purged from prior unloading</span>
<span class="line-removed">360   // (CMS doesn&#39;t purge right away).</span>
<span class="line-removed">361   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
362     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
363     cld-&gt;modules_do(f);
364   }
365 }
366 
367 void ClassLoaderDataGraph::packages_do(void f(PackageEntry*)) {
368   assert_locked_or_safepoint(Module_lock);
369   ClassLoaderDataGraphIterator iter;
370   while (ClassLoaderData* cld = iter.get_next()) {
371     cld-&gt;packages_do(f);
372   }
373 }
374 
375 void ClassLoaderDataGraph::packages_unloading_do(void f(PackageEntry*)) {
376   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">377   // Only walk the head until any clds not purged from prior unloading</span>
<span class="line-removed">378   // (CMS doesn&#39;t purge right away).</span>
<span class="line-removed">379   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
380     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
381     cld-&gt;packages_do(f);
382   }
383 }
384 
385 void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {
386   ClassLoaderDataGraphIterator iter;
387   while (ClassLoaderData* cld = iter.get_next()) {
388     cld-&gt;loaded_classes_do(klass_closure);
389   }
390 }
391 
392 // This case can block but cannot do unloading (called from CDS)
393 void ClassLoaderDataGraph::unlocked_loaded_classes_do(KlassClosure* klass_closure) {
394   for (ClassLoaderData* cld = _head; cld != NULL; cld = cld-&gt;next()) {
395     cld-&gt;loaded_classes_do(klass_closure);
396   }
397 }
398 
399 
400 void ClassLoaderDataGraph::classes_unloading_do(void f(Klass* const)) {
401   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">402   // Only walk the head until any clds not purged from prior unloading</span>
<span class="line-removed">403   // (CMS doesn&#39;t purge right away).</span>
<span class="line-removed">404   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
405     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
406     cld-&gt;classes_do(f);
407   }
408 }
409 
410 #define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \
411                                 while (ClassLoaderData* X = iter.get_next()) \
412                                   if (X-&gt;dictionary() != NULL)
413 
414 // Walk classes in the loaded class dictionaries in various forms.
415 // Only walks the classes defined in this class loader.
416 void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*)) {
417   FOR_ALL_DICTIONARY(cld) {
418     cld-&gt;dictionary()-&gt;classes_do(f);
419   }
420 }
421 
422 // Only walks the classes defined in this class loader.
423 void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {
424   FOR_ALL_DICTIONARY(cld) {
425     cld-&gt;dictionary()-&gt;classes_do(f, CHECK);
426   }
427 }
428 
429 void ClassLoaderDataGraph::verify_dictionary() {
430   FOR_ALL_DICTIONARY(cld) {
431     cld-&gt;dictionary()-&gt;verify();
432   }
433 }
434 
435 void ClassLoaderDataGraph::print_dictionary(outputStream* st) {
436   FOR_ALL_DICTIONARY(cld) {
437     st-&gt;print(&quot;Dictionary for &quot;);
438     cld-&gt;print_value_on(st);
439     st-&gt;cr();
440     cld-&gt;dictionary()-&gt;print_on(st);
441     st-&gt;cr();
442   }
443 }
444 
<span class="line-modified">445 void ClassLoaderDataGraph::print_dictionary_statistics(outputStream* st) {</span>
446   FOR_ALL_DICTIONARY(cld) {
447     ResourceMark rm;
448     stringStream tempst;
449     tempst.print(&quot;System Dictionary for %s class loader&quot;, cld-&gt;loader_name_and_id());
450     cld-&gt;dictionary()-&gt;print_table_statistics(st, tempst.as_string());
451   }
452 }
453 
<span class="line-removed">454 GrowableArray&lt;ClassLoaderData*&gt;* ClassLoaderDataGraph::new_clds() {</span>
<span class="line-removed">455   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="line-removed">456   assert(_head == NULL || _saved_head != NULL, &quot;remember_new_clds(true) not called?&quot;);</span>
<span class="line-removed">457 </span>
<span class="line-removed">458   GrowableArray&lt;ClassLoaderData*&gt;* array = new GrowableArray&lt;ClassLoaderData*&gt;();</span>
<span class="line-removed">459 </span>
<span class="line-removed">460   // The CLDs in [_head, _saved_head] were all added during last call to remember_new_clds(true);</span>
<span class="line-removed">461   ClassLoaderData* curr = _head;</span>
<span class="line-removed">462   while (curr != _saved_head) {</span>
<span class="line-removed">463     if (!curr-&gt;claimed()) {</span>
<span class="line-removed">464       array-&gt;push(curr);</span>
<span class="line-removed">465       LogTarget(Debug, class, loader, data) lt;</span>
<span class="line-removed">466       if (lt.is_enabled()) {</span>
<span class="line-removed">467         LogStream ls(lt);</span>
<span class="line-removed">468         ls.print(&quot;found new CLD: &quot;);</span>
<span class="line-removed">469         curr-&gt;print_value_on(&amp;ls);</span>
<span class="line-removed">470         ls.cr();</span>
<span class="line-removed">471       }</span>
<span class="line-removed">472     }</span>
<span class="line-removed">473 </span>
<span class="line-removed">474     curr = curr-&gt;_next;</span>
<span class="line-removed">475   }</span>
<span class="line-removed">476 </span>
<span class="line-removed">477   return array;</span>
<span class="line-removed">478 }</span>
<span class="line-removed">479 </span>
480 #ifndef PRODUCT
481 bool ClassLoaderDataGraph::contains_loader_data(ClassLoaderData* loader_data) {
482   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
483   for (ClassLoaderData* data = _head; data != NULL; data = data-&gt;next()) {
484     if (loader_data == data) {
485       return true;
486     }
487   }
488 
489   return false;
490 }
491 #endif // PRODUCT
492 
493 bool ClassLoaderDataGraph::is_valid(ClassLoaderData* loader_data) {
494   DEBUG_ONLY( if (!VMError::is_error_reported()) { assert_locked_or_safepoint(ClassLoaderDataGraph_lock); } )
495   if (loader_data != NULL) {
496     if (loader_data == ClassLoaderData::the_null_class_loader_data()) {
497       return true;
498     }
499     for (ClassLoaderData* data = _head; data != NULL; data = data-&gt;next()) {
</pre>
<hr />
<pre>
502       }
503     }
504   }
505   return false;
506 }
507 
508 // Move class loader data from main list to the unloaded list for unloading
509 // and deallocation later.
510 bool ClassLoaderDataGraph::do_unloading() {
511   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
512 
513   // Indicate whether safepoint cleanup is needed.
514   _safepoint_cleanup_needed = true;
515 
516   ClassLoaderData* data = _head;
517   ClassLoaderData* prev = NULL;
518   bool seen_dead_loader = false;
519   uint loaders_processed = 0;
520   uint loaders_removed = 0;
521 
<span class="line-removed">522   // Save previous _unloading pointer for CMS which may add to unloading list before</span>
<span class="line-removed">523   // purging and we don&#39;t want to rewalk the previously unloaded class loader data.</span>
<span class="line-removed">524   _saved_unloading = _unloading;</span>
<span class="line-removed">525 </span>
526   data = _head;
527   while (data != NULL) {
528     if (data-&gt;is_alive()) {
529       prev = data;
530       data = data-&gt;next();
531       loaders_processed++;
532       continue;
533     }
534     seen_dead_loader = true;
535     loaders_removed++;
536     ClassLoaderData* dead = data;
537     dead-&gt;unload();
538     data = data-&gt;next();
539     // Remove from loader list.
540     // This class loader data will no longer be found
541     // in the ClassLoaderDataGraph.
542     if (prev != NULL) {
543       prev-&gt;set_next(data);
544     } else {
545       assert(dead == _head, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
578 }
579 
580 void ClassLoaderDataGraph::purge() {
581   ClassLoaderData* list = _unloading;
582   _unloading = NULL;
583   ClassLoaderData* next = list;
584   bool classes_unloaded = false;
585   while (next != NULL) {
586     ClassLoaderData* purge_me = next;
587     next = purge_me-&gt;next();
588     delete purge_me;
589     classes_unloaded = true;
590   }
591   if (classes_unloaded) {
592     Metaspace::purge();
593     set_metaspace_oom(false);
594   }
595   DependencyContext::purge_dependency_contexts();
596 }
597 
<span class="line-modified">598 int ClassLoaderDataGraph::resize_if_needed() {</span>
599   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
600   int resized = 0;
<span class="line-modified">601   if (Dictionary::does_any_dictionary_needs_resizing()) {</span>
<span class="line-modified">602     FOR_ALL_DICTIONARY(cld) {</span>
<span class="line-modified">603       if (cld-&gt;dictionary()-&gt;resize_if_needed()) {</span>
<span class="line-modified">604         resized++;</span>
<span class="line-removed">605       }</span>
606     }
607   }
608   return resized;
609 }
610 
611 ClassLoaderDataGraphKlassIteratorAtomic::ClassLoaderDataGraphKlassIteratorAtomic()
612     : _next_klass(NULL) {
613   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
614   ClassLoaderData* cld = ClassLoaderDataGraph::_head;
615   Klass* klass = NULL;
616 
617   // Find the first klass in the CLDG.
618   while (cld != NULL) {
619     assert_locked_or_safepoint(cld-&gt;metaspace_lock());
620     klass = cld-&gt;_klasses;
621     if (klass != NULL) {
622       _next_klass = klass;
623       return;
624     }
625     cld = cld-&gt;next();
</pre>
<hr />
<pre>
635   // No more klasses in the current CLD. Time to find a new CLD.
636   ClassLoaderData* cld = klass-&gt;class_loader_data();
637   assert_locked_or_safepoint(cld-&gt;metaspace_lock());
638   while (next == NULL) {
639     cld = cld-&gt;next();
640     if (cld == NULL) {
641       break;
642     }
643     next = cld-&gt;_klasses;
644   }
645 
646   return next;
647 }
648 
649 Klass* ClassLoaderDataGraphKlassIteratorAtomic::next_klass() {
650   Klass* head = _next_klass;
651 
652   while (head != NULL) {
653     Klass* next = next_klass_in_cldg(head);
654 
<span class="line-modified">655     Klass* old_head = Atomic::cmpxchg(next, &amp;_next_klass, head);</span>
656 
657     if (old_head == head) {
658       return head; // Won the CAS.
659     }
660 
661     head = old_head;
662   }
663 
664   // Nothing more for the iterator to hand out.
665   assert(head == NULL, &quot;head is &quot; PTR_FORMAT &quot;, expected not null:&quot;, p2i(head));
666   return NULL;
667 }
668 
669 ClassLoaderDataGraphMetaspaceIterator::ClassLoaderDataGraphMetaspaceIterator() {
670   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
671   _data = ClassLoaderDataGraph::_head;
672 }
673 
674 ClassLoaderDataGraphMetaspaceIterator::~ClassLoaderDataGraphMetaspaceIterator() {}
675 
</pre>
<hr />
<pre>
689 extern &quot;C&quot; int print_loader_data_graph() {
690   ResourceMark rm;
691   ClassLoaderDataGraph::print_on(tty);
692   return 0;
693 }
694 
695 void ClassLoaderDataGraph::verify() {
696   ClassLoaderDataGraphIterator iter;
697   while (ClassLoaderData* cld = iter.get_next()) {
698     cld-&gt;verify();
699   }
700 }
701 
702 void ClassLoaderDataGraph::print_on(outputStream * const out) {
703   ClassLoaderDataGraphIterator iter;
704   while (ClassLoaderData* cld = iter.get_next()) {
705     cld-&gt;print_on(out);
706   }
707 }
708 #endif // PRODUCT


</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 #include &quot;classfile/packageEntry.hpp&quot;
 32 #include &quot;code/dependencyContext.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;logging/logStream.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;memory/metaspace.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/mutex.hpp&quot;
 41 #include &quot;runtime/safepoint.hpp&quot;
 42 #include &quot;runtime/safepointVerifiers.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 #include &quot;utilities/macros.hpp&quot;
 45 #include &quot;utilities/ostream.hpp&quot;
 46 
 47 volatile size_t ClassLoaderDataGraph::_num_array_classes = 0;
 48 volatile size_t ClassLoaderDataGraph::_num_instance_classes = 0;
 49 
 50 void ClassLoaderDataGraph::clear_claimed_marks() {
<span class="line-modified"> 51   // The claimed marks of the CLDs in the ClassLoaderDataGraph are cleared</span>
<span class="line-added"> 52   // outside a safepoint and without locking the ClassLoaderDataGraph_lock.</span>
<span class="line-added"> 53   // This is required to avoid a deadlock between concurrent GC threads and safepointing.</span>
<span class="line-added"> 54   //</span>
<span class="line-added"> 55   // We need to make sure that the CLD contents are fully visible to the</span>
<span class="line-added"> 56   // reader thread. This is accomplished by acquire/release of the _head,</span>
<span class="line-added"> 57   // and is sufficient.</span>
<span class="line-added"> 58   //</span>
<span class="line-added"> 59   // Any ClassLoaderData added after or during walking the list are prepended to</span>
<span class="line-added"> 60   // _head. Their claim mark need not be handled here.</span>
<span class="line-added"> 61   for (ClassLoaderData* cld = Atomic::load_acquire(&amp;_head); cld != NULL; cld = cld-&gt;next()) {</span>
 62     cld-&gt;clear_claim();
 63   }
 64 }
 65 
<span class="line-added"> 66 void ClassLoaderDataGraph::clear_claimed_marks(int claim) {</span>
<span class="line-added"> 67  for (ClassLoaderData* cld = Atomic::load_acquire(&amp;_head); cld != NULL; cld = cld-&gt;next()) {</span>
<span class="line-added"> 68     cld-&gt;clear_claim(claim);</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70 }</span>
 71 // Class iterator used by the compiler.  It gets some number of classes at
 72 // a safepoint to decay invocation counters on the methods.
 73 class ClassLoaderDataGraphKlassIteratorStatic {
 74   ClassLoaderData* _current_loader_data;
 75   Klass*           _current_class_entry;
 76  public:
 77 
 78   ClassLoaderDataGraphKlassIteratorStatic() : _current_loader_data(NULL), _current_class_entry(NULL) {}
 79 
 80   InstanceKlass* try_get_next_class() {
 81     assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
 82     size_t max_classes = ClassLoaderDataGraph::num_instance_classes();
 83     assert(max_classes &gt; 0, &quot;should not be called with no instance classes&quot;);
 84     for (size_t i = 0; i &lt; max_classes; ) {
 85 
 86       if (_current_class_entry != NULL) {
 87         Klass* k = _current_class_entry;
 88         _current_class_entry = _current_class_entry-&gt;next_link();
 89 
 90         if (k-&gt;is_instance_klass()) {
</pre>
<hr />
<pre>
161       loaders_processed++;
162     }
163   }
164   log_debug(class, loader, data)(&quot;clean_deallocate_lists: loaders processed %u %s&quot;,
165                                  loaders_processed, walk_previous_versions ? &quot;walk_previous_versions&quot; : &quot;&quot;);
166 }
167 
168 void ClassLoaderDataGraph::walk_metadata_and_clean_metaspaces() {
169   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called at safepoint&quot;);
170 
171   _should_clean_deallocate_lists = false; // assume everything gets cleaned
172 
173   // Mark metadata seen on the stack so we can delete unreferenced entries.
174   // Walk all metadata, including the expensive code cache walk, only for class redefinition.
175   // The MetadataOnStackMark walk during redefinition saves previous versions if it finds old methods
176   // on the stack or in the code cache, so we only have to repeat the full walk if
177   // they were found at that time.
178   // TODO: have redefinition clean old methods out of the code cache.  They still exist in some places.
179   bool walk_all_metadata = InstanceKlass::has_previous_versions_and_reset();
180 
<span class="line-modified">181   MetadataOnStackMark md_on_stack(walk_all_metadata, /*redefinition_walk*/false);</span>
182   clean_deallocate_lists(walk_all_metadata);
183 }
184 
185 // GC root of class loader data created.
<span class="line-modified">186 ClassLoaderData* volatile ClassLoaderDataGraph::_head = NULL;</span>
187 ClassLoaderData* ClassLoaderDataGraph::_unloading = NULL;


188 

189 bool ClassLoaderDataGraph::_should_clean_deallocate_lists = false;
190 bool ClassLoaderDataGraph::_safepoint_cleanup_needed = false;
191 bool ClassLoaderDataGraph::_metaspace_oom = false;
192 
193 // Add a new class loader data node to the list.  Assign the newly created
194 // ClassLoaderData into the java/lang/ClassLoader object as a hidden field
195 ClassLoaderData* ClassLoaderDataGraph::add_to_graph(Handle loader, bool is_unsafe_anonymous) {
196 
197   assert_lock_strong(ClassLoaderDataGraph_lock);
198 
199   ClassLoaderData* cld;
200 
201   // First check if another thread beat us to creating the CLD and installing
202   // it into the loader while we were waiting for the lock.
203   if (!is_unsafe_anonymous &amp;&amp; loader.not_null()) {
204     cld = java_lang_ClassLoader::loader_data_acquire(loader());
205     if (cld != NULL) {
206       return cld;
207     }
208   }
209 
210   // We mustn&#39;t GC until we&#39;ve installed the ClassLoaderData in the Graph since the CLD
211   // contains oops in _handles that must be walked.  GC doesn&#39;t walk CLD from the
212   // loader oop in all collections, particularly young collections.
213   NoSafepointVerifier no_safepoints;
214 
215   cld = new ClassLoaderData(loader, is_unsafe_anonymous);
216 
217   // First install the new CLD to the Graph.
218   cld-&gt;set_next(_head);
<span class="line-modified">219   Atomic::release_store(&amp;_head, cld);</span>
220 
221   // Next associate with the class_loader.
222   if (!is_unsafe_anonymous) {
223     // Use OrderAccess, since readers need to get the loader_data only after
224     // it&#39;s added to the Graph
225     java_lang_ClassLoader::release_set_loader_data(loader(), cld);
226   }
227 
228   // Lastly log, if requested
229   LogTarget(Trace, class, loader, data) lt;
230   if (lt.is_enabled()) {
231     ResourceMark rm;
232     LogStream ls(lt);
233     ls.print(&quot;create &quot;);
234     cld-&gt;print_value_on(&amp;ls);
235     ls.cr();
236   }
237   return cld;
238 }
239 
240 ClassLoaderData* ClassLoaderDataGraph::add(Handle loader, bool is_unsafe_anonymous) {
241   MutexLocker ml(ClassLoaderDataGraph_lock);
242   ClassLoaderData* loader_data = add_to_graph(loader, is_unsafe_anonymous);
243   return loader_data;
244 }
245 
246 void ClassLoaderDataGraph::cld_unloading_do(CLDClosure* cl) {
247   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
<span class="line-modified">248   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>


249     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
250     cl-&gt;do_cld(cld);
251   }
252 }
253 
254 // These are functions called by the GC, which require all of the CLDs, including the
255 // unloading ones.
256 void ClassLoaderDataGraph::cld_do(CLDClosure* cl) {
257   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
258   for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld-&gt;_next) {
259     cl-&gt;do_cld(cld);
260   }
261 }
262 
263 void ClassLoaderDataGraph::roots_cld_do(CLDClosure* strong, CLDClosure* weak) {
264   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
265   for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld-&gt;_next) {
266     CLDClosure* closure = cld-&gt;keep_alive() ? strong : weak;
267     if (closure != NULL) {
268       closure-&gt;do_cld(cld);
269     }
270   }
271 }
272 
273 void ClassLoaderDataGraph::always_strong_cld_do(CLDClosure* cl) {
274   assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
275   if (ClassUnloading) {
276     roots_cld_do(cl, NULL);
277   } else {
278     cld_do(cl);
279   }
280 }
281 
<span class="line-modified">282 // Closure for locking and iterating through classes. Only lock outside of safepoint.</span>
<span class="line-modified">283 LockedClassesDo::LockedClassesDo(classes_do_func_t f) : _function(f),</span>
<span class="line-modified">284   _do_lock(!SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-added">285   if (_do_lock) {</span>
<span class="line-added">286     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="line-added">287   }</span>
288 }
289 
<span class="line-modified">290 LockedClassesDo::LockedClassesDo() : _function(NULL),</span>
<span class="line-added">291   _do_lock(!SafepointSynchronize::is_at_safepoint()) {</span>
292   // callers provide their own do_klass
<span class="line-modified">293   if (_do_lock) {</span>
<span class="line-added">294     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="line-added">295   }</span>
296 }
297 
<span class="line-modified">298 LockedClassesDo::~LockedClassesDo() {</span>
<span class="line-added">299   if (_do_lock) {</span>
<span class="line-added">300     ClassLoaderDataGraph_lock-&gt;unlock();</span>
<span class="line-added">301   }</span>
<span class="line-added">302 }</span>
303 
304 
305 // Iterating over the CLDG needs to be locked because
306 // unloading can remove entries concurrently soon.
307 class ClassLoaderDataGraphIterator : public StackObj {
308   ClassLoaderData* _next;
309   HandleMark       _hm;  // clean up handles when this is done.
310   Handle           _holder;
311   Thread*          _thread;
312   NoSafepointVerifier _nsv; // No safepoints allowed in this scope
313                             // unless verifying at a safepoint.
314 
315 public:
<span class="line-modified">316   ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head) {</span>

317     _thread = Thread::current();
318     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
319   }
320 
321   ClassLoaderData* get_next() {
322     ClassLoaderData* cld = _next;
323     // Skip already unloaded CLD for concurrent unloading.
324     while (cld != NULL &amp;&amp; !cld-&gt;is_alive()) {
325       cld = cld-&gt;next();
326     }
327     if (cld != NULL) {
328       // Keep cld that is being returned alive.
329       _holder = Handle(_thread, cld-&gt;holder_phantom());
330       _next = cld-&gt;next();
331     } else {
332       _next = NULL;
333     }
334     return cld;
335   }
336 };
</pre>
<hr />
<pre>
358   }
359 }
360 
361 void ClassLoaderDataGraph::methods_do(void f(Method*)) {
362   ClassLoaderDataGraphIterator iter;
363   while (ClassLoaderData* cld = iter.get_next()) {
364     cld-&gt;methods_do(f);
365   }
366 }
367 
368 void ClassLoaderDataGraph::modules_do(void f(ModuleEntry*)) {
369   assert_locked_or_safepoint(Module_lock);
370   ClassLoaderDataGraphIterator iter;
371   while (ClassLoaderData* cld = iter.get_next()) {
372     cld-&gt;modules_do(f);
373   }
374 }
375 
376 void ClassLoaderDataGraph::modules_unloading_do(void f(ModuleEntry*)) {
377   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">378   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>


379     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
380     cld-&gt;modules_do(f);
381   }
382 }
383 
384 void ClassLoaderDataGraph::packages_do(void f(PackageEntry*)) {
385   assert_locked_or_safepoint(Module_lock);
386   ClassLoaderDataGraphIterator iter;
387   while (ClassLoaderData* cld = iter.get_next()) {
388     cld-&gt;packages_do(f);
389   }
390 }
391 
392 void ClassLoaderDataGraph::packages_unloading_do(void f(PackageEntry*)) {
393   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">394   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>


395     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
396     cld-&gt;packages_do(f);
397   }
398 }
399 
400 void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {
401   ClassLoaderDataGraphIterator iter;
402   while (ClassLoaderData* cld = iter.get_next()) {
403     cld-&gt;loaded_classes_do(klass_closure);
404   }
405 }
406 
407 // This case can block but cannot do unloading (called from CDS)
408 void ClassLoaderDataGraph::unlocked_loaded_classes_do(KlassClosure* klass_closure) {
409   for (ClassLoaderData* cld = _head; cld != NULL; cld = cld-&gt;next()) {
410     cld-&gt;loaded_classes_do(klass_closure);
411   }
412 }
413 
414 
415 void ClassLoaderDataGraph::classes_unloading_do(void f(Klass* const)) {
416   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="line-modified">417   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>


418     assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
419     cld-&gt;classes_do(f);
420   }
421 }
422 
423 #define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \
424                                 while (ClassLoaderData* X = iter.get_next()) \
425                                   if (X-&gt;dictionary() != NULL)
426 
427 // Walk classes in the loaded class dictionaries in various forms.
428 // Only walks the classes defined in this class loader.
429 void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*)) {
430   FOR_ALL_DICTIONARY(cld) {
431     cld-&gt;dictionary()-&gt;classes_do(f);
432   }
433 }
434 
435 // Only walks the classes defined in this class loader.
436 void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {
437   FOR_ALL_DICTIONARY(cld) {
438     cld-&gt;dictionary()-&gt;classes_do(f, CHECK);
439   }
440 }
441 
442 void ClassLoaderDataGraph::verify_dictionary() {
443   FOR_ALL_DICTIONARY(cld) {
444     cld-&gt;dictionary()-&gt;verify();
445   }
446 }
447 
448 void ClassLoaderDataGraph::print_dictionary(outputStream* st) {
449   FOR_ALL_DICTIONARY(cld) {
450     st-&gt;print(&quot;Dictionary for &quot;);
451     cld-&gt;print_value_on(st);
452     st-&gt;cr();
453     cld-&gt;dictionary()-&gt;print_on(st);
454     st-&gt;cr();
455   }
456 }
457 
<span class="line-modified">458 void ClassLoaderDataGraph::print_table_statistics(outputStream* st) {</span>
459   FOR_ALL_DICTIONARY(cld) {
460     ResourceMark rm;
461     stringStream tempst;
462     tempst.print(&quot;System Dictionary for %s class loader&quot;, cld-&gt;loader_name_and_id());
463     cld-&gt;dictionary()-&gt;print_table_statistics(st, tempst.as_string());
464   }
465 }
466 


























467 #ifndef PRODUCT
468 bool ClassLoaderDataGraph::contains_loader_data(ClassLoaderData* loader_data) {
469   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
470   for (ClassLoaderData* data = _head; data != NULL; data = data-&gt;next()) {
471     if (loader_data == data) {
472       return true;
473     }
474   }
475 
476   return false;
477 }
478 #endif // PRODUCT
479 
480 bool ClassLoaderDataGraph::is_valid(ClassLoaderData* loader_data) {
481   DEBUG_ONLY( if (!VMError::is_error_reported()) { assert_locked_or_safepoint(ClassLoaderDataGraph_lock); } )
482   if (loader_data != NULL) {
483     if (loader_data == ClassLoaderData::the_null_class_loader_data()) {
484       return true;
485     }
486     for (ClassLoaderData* data = _head; data != NULL; data = data-&gt;next()) {
</pre>
<hr />
<pre>
489       }
490     }
491   }
492   return false;
493 }
494 
495 // Move class loader data from main list to the unloaded list for unloading
496 // and deallocation later.
497 bool ClassLoaderDataGraph::do_unloading() {
498   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
499 
500   // Indicate whether safepoint cleanup is needed.
501   _safepoint_cleanup_needed = true;
502 
503   ClassLoaderData* data = _head;
504   ClassLoaderData* prev = NULL;
505   bool seen_dead_loader = false;
506   uint loaders_processed = 0;
507   uint loaders_removed = 0;
508 




509   data = _head;
510   while (data != NULL) {
511     if (data-&gt;is_alive()) {
512       prev = data;
513       data = data-&gt;next();
514       loaders_processed++;
515       continue;
516     }
517     seen_dead_loader = true;
518     loaders_removed++;
519     ClassLoaderData* dead = data;
520     dead-&gt;unload();
521     data = data-&gt;next();
522     // Remove from loader list.
523     // This class loader data will no longer be found
524     // in the ClassLoaderDataGraph.
525     if (prev != NULL) {
526       prev-&gt;set_next(data);
527     } else {
528       assert(dead == _head, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
561 }
562 
563 void ClassLoaderDataGraph::purge() {
564   ClassLoaderData* list = _unloading;
565   _unloading = NULL;
566   ClassLoaderData* next = list;
567   bool classes_unloaded = false;
568   while (next != NULL) {
569     ClassLoaderData* purge_me = next;
570     next = purge_me-&gt;next();
571     delete purge_me;
572     classes_unloaded = true;
573   }
574   if (classes_unloaded) {
575     Metaspace::purge();
576     set_metaspace_oom(false);
577   }
578   DependencyContext::purge_dependency_contexts();
579 }
580 
<span class="line-modified">581 int ClassLoaderDataGraph::resize_dictionaries() {</span>
582   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
583   int resized = 0;
<span class="line-modified">584   assert (Dictionary::does_any_dictionary_needs_resizing(), &quot;some dictionary should need resizing&quot;);</span>
<span class="line-modified">585   FOR_ALL_DICTIONARY(cld) {</span>
<span class="line-modified">586     if (cld-&gt;dictionary()-&gt;resize_if_needed()) {</span>
<span class="line-modified">587       resized++;</span>

588     }
589   }
590   return resized;
591 }
592 
593 ClassLoaderDataGraphKlassIteratorAtomic::ClassLoaderDataGraphKlassIteratorAtomic()
594     : _next_klass(NULL) {
595   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
596   ClassLoaderData* cld = ClassLoaderDataGraph::_head;
597   Klass* klass = NULL;
598 
599   // Find the first klass in the CLDG.
600   while (cld != NULL) {
601     assert_locked_or_safepoint(cld-&gt;metaspace_lock());
602     klass = cld-&gt;_klasses;
603     if (klass != NULL) {
604       _next_klass = klass;
605       return;
606     }
607     cld = cld-&gt;next();
</pre>
<hr />
<pre>
617   // No more klasses in the current CLD. Time to find a new CLD.
618   ClassLoaderData* cld = klass-&gt;class_loader_data();
619   assert_locked_or_safepoint(cld-&gt;metaspace_lock());
620   while (next == NULL) {
621     cld = cld-&gt;next();
622     if (cld == NULL) {
623       break;
624     }
625     next = cld-&gt;_klasses;
626   }
627 
628   return next;
629 }
630 
631 Klass* ClassLoaderDataGraphKlassIteratorAtomic::next_klass() {
632   Klass* head = _next_klass;
633 
634   while (head != NULL) {
635     Klass* next = next_klass_in_cldg(head);
636 
<span class="line-modified">637     Klass* old_head = Atomic::cmpxchg(&amp;_next_klass, head, next);</span>
638 
639     if (old_head == head) {
640       return head; // Won the CAS.
641     }
642 
643     head = old_head;
644   }
645 
646   // Nothing more for the iterator to hand out.
647   assert(head == NULL, &quot;head is &quot; PTR_FORMAT &quot;, expected not null:&quot;, p2i(head));
648   return NULL;
649 }
650 
651 ClassLoaderDataGraphMetaspaceIterator::ClassLoaderDataGraphMetaspaceIterator() {
652   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
653   _data = ClassLoaderDataGraph::_head;
654 }
655 
656 ClassLoaderDataGraphMetaspaceIterator::~ClassLoaderDataGraphMetaspaceIterator() {}
657 
</pre>
<hr />
<pre>
671 extern &quot;C&quot; int print_loader_data_graph() {
672   ResourceMark rm;
673   ClassLoaderDataGraph::print_on(tty);
674   return 0;
675 }
676 
677 void ClassLoaderDataGraph::verify() {
678   ClassLoaderDataGraphIterator iter;
679   while (ClassLoaderData* cld = iter.get_next()) {
680     cld-&gt;verify();
681   }
682 }
683 
684 void ClassLoaderDataGraph::print_on(outputStream * const out) {
685   ClassLoaderDataGraphIterator iter;
686   while (ClassLoaderData* cld = iter.get_next()) {
687     cld-&gt;print_on(out);
688   }
689 }
690 #endif // PRODUCT
<span class="line-added">691 </span>
<span class="line-added">692 void ClassLoaderDataGraph::print() { print_on(tty); }</span>
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 void java_lang_String::set_coder(oop string, jbyte coder) {
 34   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 35   string-&gt;byte_field_put(coder_offset, coder);
 36 }
 37 
 38 void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {
 39   assert(initialized, &quot;Must be initialized&quot;);
 40   string-&gt;obj_field_put_raw(value_offset, buffer);
 41 }
 42 
 43 void java_lang_String::set_value(oop string, typeArrayOop buffer) {
 44   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 45   string-&gt;obj_field_put(value_offset, (oop)buffer);
 46 }
 47 
<span class="line-modified"> 48 void java_lang_String::set_hash(oop string, unsigned int hash) {</span>
<span class="line-modified"> 49   assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-modified"> 50   string-&gt;int_field_put(hash_offset, hash);</span>
 51 }
 52 
 53 // Accessors
 54 bool java_lang_String::value_equals(typeArrayOop str_value1, typeArrayOop str_value2) {
<span class="line-modified"> 55   return (oopDesc::equals(str_value1, str_value2) ||</span>
 56           (str_value1-&gt;length() == str_value2-&gt;length() &amp;&amp;
 57            (!memcmp(str_value1-&gt;base(T_BYTE),
 58                     str_value2-&gt;base(T_BYTE),
 59                     str_value2-&gt;length() * sizeof(jbyte)))));
 60 }
 61 
 62 typeArrayOop java_lang_String::value(oop java_string) {
 63   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 64   assert(is_instance(java_string), &quot;must be java_string&quot;);
 65   return (typeArrayOop) java_string-&gt;obj_field(value_offset);
 66 }
 67 
 68 typeArrayOop java_lang_String::value_no_keepalive(oop java_string) {
 69   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 70   assert(is_instance(java_string), &quot;must be java_string&quot;);
 71   return (typeArrayOop) java_string-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(value_offset);
 72 }
 73 
<span class="line-removed"> 74 unsigned int java_lang_String::hash(oop java_string) {</span>
<span class="line-removed"> 75   assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-removed"> 76   assert(is_instance(java_string), &quot;must be java_string&quot;);</span>
<span class="line-removed"> 77   return java_string-&gt;int_field(hash_offset);</span>
<span class="line-removed"> 78 }</span>
<span class="line-removed"> 79 </span>
 80 bool java_lang_String::is_latin1(oop java_string) {
 81   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 82   assert(is_instance(java_string), &quot;must be java_string&quot;);
 83   jbyte coder = java_string-&gt;byte_field(coder_offset);
 84   assert(CompactStrings || coder == CODER_UTF16, &quot;Must be UTF16 without CompactStrings&quot;);
 85   return coder == CODER_LATIN1;
 86 }
 87 
 88 int java_lang_String::length(oop java_string, typeArrayOop value) {
 89   assert(initialized, &quot;Must be initialized&quot;);
 90   assert(is_instance(java_string), &quot;must be java_string&quot;);
 91   assert(value_equals(value, java_lang_String::value(java_string)),
 92          &quot;value must be equal to java_lang_String::value(java_string)&quot;);
 93   if (value == NULL) {
 94     return 0;
 95   }
 96   int arr_length = value-&gt;length();
 97   if (!is_latin1(java_string)) {
 98     assert((arr_length &amp; 1) == 0, &quot;should be even for UTF16 string&quot;);
 99     arr_length &gt;&gt;= 1; // convert number of bytes to number of elements
</pre>
<hr />
<pre>
168 bool java_lang_ref_Reference::is_phantom(oop ref) {
169   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_PHANTOM;
170 }
171 
172 inline void java_lang_invoke_CallSite::set_target_volatile(oop site, oop target) {
173   site-&gt;obj_field_put_volatile(_target_offset, target);
174 }
175 
176 inline oop  java_lang_invoke_CallSite::target(oop site) {
177   return site-&gt;obj_field(_target_offset);
178 }
179 
180 inline void java_lang_invoke_CallSite::set_target(oop site, oop target) {
181   site-&gt;obj_field_put(_target_offset, target);
182 }
183 
184 inline bool java_lang_invoke_CallSite::is_instance(oop obj) {
185   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
186 }
187 








188 inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {
189   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
190 }
191 
192 inline bool java_lang_invoke_MemberName::is_instance(oop obj) {
193   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MemberName_klass();
194 }
195 
196 inline bool java_lang_invoke_ResolvedMethodName::is_instance(oop obj) {
197   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::ResolvedMethodName_klass();
198 }
199 
200 inline bool java_lang_invoke_MethodType::is_instance(oop obj) {
201   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MethodType_klass();
202 }
203 
204 inline bool java_lang_invoke_MethodHandle::is_instance(oop obj) {
205   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
206 }
207 
</pre>
<hr />
<pre>
253   assert((jushort)cpref == cpref, &quot;cpref should be short&quot;);
254   return build_int_from_shorts(cpref, mid);
255 }
256 
257 inline int Backtrace::bci_at(unsigned int merged) {
258   return extract_high_short_from_int(merged);
259 }
260 
261 inline int Backtrace::version_at(unsigned int merged) {
262   return extract_low_short_from_int(merged);
263 }
264 
265 inline int Backtrace::mid_at(unsigned int merged) {
266   return extract_high_short_from_int(merged);
267 }
268 
269 inline int Backtrace::cpref_at(unsigned int merged) {
270   return extract_low_short_from_int(merged);
271 }
272 
<span class="line-modified">273 inline int Backtrace::get_line_number(const methodHandle&amp; method, int bci) {</span>
274   int line_number = 0;
275   if (method-&gt;is_native()) {
276     // Negative value different from -1 below, enabling Java code in
277     // class java.lang.StackTraceElement to distinguish &quot;native&quot; from
278     // &quot;no LineNumberTable&quot;.  JDK tests for -2.
279     line_number = -2;
280   } else {
281     // Returns -1 if no LineNumberTable, and otherwise actual line number
282     line_number = method-&gt;line_number_from_bci(bci);
<span class="line-removed">283     if (line_number == -1 &amp;&amp; ShowHiddenFrames) {</span>
<span class="line-removed">284       line_number = bci + 1000000;</span>
<span class="line-removed">285     }</span>
286   }
287   return line_number;
288 }
289 
290 inline Symbol* Backtrace::get_source_file_name(InstanceKlass* holder, int version) {
291   // RedefineClasses() currently permits redefine operations to
292   // happen in parallel using a &quot;last one wins&quot; philosophy. That
293   // spec laxness allows the constant pool entry associated with
294   // the source_file_name_index for any older constant pool version
295   // to be unstable so we shouldn&#39;t try to use it.
296   if (holder-&gt;constants()-&gt;version() != version) {
297     return NULL;
298   } else {
299     return holder-&gt;source_file_name();
300   }
301 }
302 
303 #endif // SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 void java_lang_String::set_coder(oop string, jbyte coder) {
 34   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 35   string-&gt;byte_field_put(coder_offset, coder);
 36 }
 37 
 38 void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {
 39   assert(initialized, &quot;Must be initialized&quot;);
 40   string-&gt;obj_field_put_raw(value_offset, buffer);
 41 }
 42 
 43 void java_lang_String::set_value(oop string, typeArrayOop buffer) {
 44   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 45   string-&gt;obj_field_put(value_offset, (oop)buffer);
 46 }
 47 
<span class="line-modified"> 48 bool java_lang_String::hash_is_set(oop java_string) {</span>
<span class="line-modified"> 49   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-modified"> 50   return java_string-&gt;int_field(hash_offset) != 0 || java_string-&gt;bool_field(hashIsZero_offset) != 0;</span>
 51 }
 52 
 53 // Accessors
 54 bool java_lang_String::value_equals(typeArrayOop str_value1, typeArrayOop str_value2) {
<span class="line-modified"> 55   return ((str_value1 == str_value2) ||</span>
 56           (str_value1-&gt;length() == str_value2-&gt;length() &amp;&amp;
 57            (!memcmp(str_value1-&gt;base(T_BYTE),
 58                     str_value2-&gt;base(T_BYTE),
 59                     str_value2-&gt;length() * sizeof(jbyte)))));
 60 }
 61 
 62 typeArrayOop java_lang_String::value(oop java_string) {
 63   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 64   assert(is_instance(java_string), &quot;must be java_string&quot;);
 65   return (typeArrayOop) java_string-&gt;obj_field(value_offset);
 66 }
 67 
 68 typeArrayOop java_lang_String::value_no_keepalive(oop java_string) {
 69   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 70   assert(is_instance(java_string), &quot;must be java_string&quot;);
 71   return (typeArrayOop) java_string-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(value_offset);
 72 }
 73 






 74 bool java_lang_String::is_latin1(oop java_string) {
 75   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 76   assert(is_instance(java_string), &quot;must be java_string&quot;);
 77   jbyte coder = java_string-&gt;byte_field(coder_offset);
 78   assert(CompactStrings || coder == CODER_UTF16, &quot;Must be UTF16 without CompactStrings&quot;);
 79   return coder == CODER_LATIN1;
 80 }
 81 
 82 int java_lang_String::length(oop java_string, typeArrayOop value) {
 83   assert(initialized, &quot;Must be initialized&quot;);
 84   assert(is_instance(java_string), &quot;must be java_string&quot;);
 85   assert(value_equals(value, java_lang_String::value(java_string)),
 86          &quot;value must be equal to java_lang_String::value(java_string)&quot;);
 87   if (value == NULL) {
 88     return 0;
 89   }
 90   int arr_length = value-&gt;length();
 91   if (!is_latin1(java_string)) {
 92     assert((arr_length &amp; 1) == 0, &quot;should be even for UTF16 string&quot;);
 93     arr_length &gt;&gt;= 1; // convert number of bytes to number of elements
</pre>
<hr />
<pre>
162 bool java_lang_ref_Reference::is_phantom(oop ref) {
163   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_PHANTOM;
164 }
165 
166 inline void java_lang_invoke_CallSite::set_target_volatile(oop site, oop target) {
167   site-&gt;obj_field_put_volatile(_target_offset, target);
168 }
169 
170 inline oop  java_lang_invoke_CallSite::target(oop site) {
171   return site-&gt;obj_field(_target_offset);
172 }
173 
174 inline void java_lang_invoke_CallSite::set_target(oop site, oop target) {
175   site-&gt;obj_field_put(_target_offset, target);
176 }
177 
178 inline bool java_lang_invoke_CallSite::is_instance(oop obj) {
179   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
180 }
181 
<span class="line-added">182 inline jboolean java_lang_invoke_ConstantCallSite::is_frozen(oop site) {</span>
<span class="line-added">183   return site-&gt;bool_field(_is_frozen_offset);</span>
<span class="line-added">184 }</span>
<span class="line-added">185 </span>
<span class="line-added">186 inline bool java_lang_invoke_ConstantCallSite::is_instance(oop obj) {</span>
<span class="line-added">187   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());</span>
<span class="line-added">188 }</span>
<span class="line-added">189 </span>
190 inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {
191   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
192 }
193 
194 inline bool java_lang_invoke_MemberName::is_instance(oop obj) {
195   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MemberName_klass();
196 }
197 
198 inline bool java_lang_invoke_ResolvedMethodName::is_instance(oop obj) {
199   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::ResolvedMethodName_klass();
200 }
201 
202 inline bool java_lang_invoke_MethodType::is_instance(oop obj) {
203   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MethodType_klass();
204 }
205 
206 inline bool java_lang_invoke_MethodHandle::is_instance(oop obj) {
207   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
208 }
209 
</pre>
<hr />
<pre>
255   assert((jushort)cpref == cpref, &quot;cpref should be short&quot;);
256   return build_int_from_shorts(cpref, mid);
257 }
258 
259 inline int Backtrace::bci_at(unsigned int merged) {
260   return extract_high_short_from_int(merged);
261 }
262 
263 inline int Backtrace::version_at(unsigned int merged) {
264   return extract_low_short_from_int(merged);
265 }
266 
267 inline int Backtrace::mid_at(unsigned int merged) {
268   return extract_high_short_from_int(merged);
269 }
270 
271 inline int Backtrace::cpref_at(unsigned int merged) {
272   return extract_low_short_from_int(merged);
273 }
274 
<span class="line-modified">275 inline int Backtrace::get_line_number(Method* method, int bci) {</span>
276   int line_number = 0;
277   if (method-&gt;is_native()) {
278     // Negative value different from -1 below, enabling Java code in
279     // class java.lang.StackTraceElement to distinguish &quot;native&quot; from
280     // &quot;no LineNumberTable&quot;.  JDK tests for -2.
281     line_number = -2;
282   } else {
283     // Returns -1 if no LineNumberTable, and otherwise actual line number
284     line_number = method-&gt;line_number_from_bci(bci);



285   }
286   return line_number;
287 }
288 
289 inline Symbol* Backtrace::get_source_file_name(InstanceKlass* holder, int version) {
290   // RedefineClasses() currently permits redefine operations to
291   // happen in parallel using a &quot;last one wins&quot; philosophy. That
292   // spec laxness allows the constant pool entry associated with
293   // the source_file_name_index for any older constant pool version
294   // to be unstable so we shouldn&#39;t try to use it.
295   if (holder-&gt;constants()-&gt;version() != version) {
296     return NULL;
297   } else {
298     return holder-&gt;source_file_name();
299   }
300 }
301 
302 #endif // SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klassFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
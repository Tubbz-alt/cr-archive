<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/symbolTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbolTable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/symbolTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,12 +26,11 @@</span>
  #define SHARE_CLASSFILE_SYMBOLTABLE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;utilities/concurrentHashTable.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;utilities/hashtable.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;utilities/tableStatistics.hpp&quot;</span>
  
  class JavaThread;
  
  // TempNewSymbol acts as a handle class in a handle/body idiom and is
  // responsible for proper resource management of the body (which is a Symbol*).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,11 +40,11 @@</span>
  //
  // Routines in SymbolTable will initialize the reference count of a Symbol* before
  // it becomes &quot;managed&quot; by TempNewSymbol instances. As a handle class, TempNewSymbol
  // needs to maintain proper reference counting in context of copy semantics.
  //
<span class="udiff-line-modified-removed">- // In SymbolTable, new_symbol() and lookup() will create a Symbol* if not already in the</span>
<span class="udiff-line-modified-added">+ // In SymbolTable, new_symbol() will create a Symbol* if not already in the</span>
  // symbol table and add to the symbol&#39;s reference count.
  // probe() and lookup_only() will increment the refcount if symbol is found.
  class TempNewSymbol : public StackObj {
    Symbol* _temp;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88,117 +87,89 @@</span>
  
  class CompactHashtableWriter;
  class SerializeClosure;
  
  class SymbolTableConfig;
<span class="udiff-line-removed">- typedef ConcurrentHashTable&lt;Symbol*,</span>
<span class="udiff-line-removed">-                               SymbolTableConfig, mtSymbol&gt; SymbolTableHash;</span>
<span class="udiff-line-removed">- </span>
  class SymbolTableCreateEntry;
  
<span class="udiff-line-modified-removed">- class SymbolTable : public CHeapObj&lt;mtSymbol&gt; {</span>
<span class="udiff-line-modified-added">+ class constantPoolHandle;</span>
<span class="udiff-line-added">+ class SymbolClosure;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class SymbolTable : public AllStatic {</span>
    friend class VMStructs;
    friend class Symbol;
    friend class ClassFileParser;
    friend class SymbolTableConfig;
    friend class SymbolTableCreateEntry;
  
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-   static void delete_symbol(Symbol* sym);</span>
<span class="udiff-line-removed">-   void grow(JavaThread* jt);</span>
<span class="udiff-line-removed">-   void clean_dead_entries(JavaThread* jt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The symbol table</span>
<span class="udiff-line-removed">-   static SymbolTable* _the_table;</span>
<span class="udiff-line-removed">-   static volatile bool _lookup_shared_first;</span>
<span class="udiff-line-removed">-   static volatile bool _alt_hash;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For statistics</span>
<span class="udiff-line-removed">-   volatile size_t _symbols_removed;</span>
<span class="udiff-line-removed">-   volatile size_t _symbols_counted;</span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-modified-added">+   static volatile bool _has_work;</span>
  
<span class="udiff-line-removed">-   SymbolTableHash* _local_table;</span>
<span class="udiff-line-removed">-   size_t _current_size;</span>
<span class="udiff-line-removed">-   volatile bool _has_work;</span>
    // Set if one bucket is out of balance due to hash algorithm deficiency
<span class="udiff-line-modified-removed">-   volatile bool _needs_rehashing;</span>
<span class="udiff-line-modified-added">+   static volatile bool _needs_rehashing;</span>
  
<span class="udiff-line-modified-removed">-   volatile size_t _items_count;</span>
<span class="udiff-line-modified-removed">-   volatile bool   _has_items_to_clean;</span>
<span class="udiff-line-modified-added">+   static void delete_symbol(Symbol* sym);</span>
<span class="udiff-line-modified-added">+   static void grow(JavaThread* jt);</span>
<span class="udiff-line-added">+   static void clean_dead_entries(JavaThread* jt);</span>
  
<span class="udiff-line-modified-removed">-   double get_load_factor() const;</span>
<span class="udiff-line-modified-added">+   static double get_load_factor();</span>
  
<span class="udiff-line-modified-removed">-   void check_concurrent_work();</span>
<span class="udiff-line-modified-added">+   static void check_concurrent_work();</span>
  
    static void item_added();
    static void item_removed();
  
    // For cleaning
<span class="udiff-line-modified-removed">-   void reset_has_items_to_clean();</span>
<span class="udiff-line-modified-removed">-   void mark_has_items_to_clean();</span>
<span class="udiff-line-modified-removed">-   bool has_items_to_clean() const;</span>
<span class="udiff-line-modified-added">+   static void reset_has_items_to_clean();</span>
<span class="udiff-line-modified-added">+   static void mark_has_items_to_clean();</span>
<span class="udiff-line-modified-added">+   static bool has_items_to_clean();</span>
  
<span class="udiff-line-modified-removed">-   SymbolTable();</span>
<span class="udiff-line-modified-added">+   static Symbol* allocate_symbol(const char* name, int len, bool c_heap); // Assumes no characters larger than 0x7F</span>
<span class="udiff-line-added">+   static Symbol* do_lookup(const char* name, int len, uintx hash);</span>
<span class="udiff-line-added">+   static Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool heap);</span>
  
<span class="udiff-line-modified-removed">-   Symbol* allocate_symbol(const char* name, int len, bool c_heap, TRAPS); // Assumes no characters larger than 0x7F</span>
<span class="udiff-line-modified-removed">-   Symbol* do_lookup(const char* name, int len, uintx hash);</span>
<span class="udiff-line-modified-removed">-   Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool heap, TRAPS);</span>
<span class="udiff-line-modified-added">+   // lookup only, won&#39;t add. Also calculate hash. Used by the ClassfileParser.</span>
<span class="udiff-line-modified-added">+   static Symbol* lookup_only(const char* name, int len, unsigned int&amp; hash);</span>
<span class="udiff-line-modified-added">+   static Symbol* lookup_only_unicode(const jchar* name, int len, unsigned int&amp; hash);</span>
  
    // Adding elements
    static void new_symbols(ClassLoaderData* loader_data,
                            const constantPoolHandle&amp; cp, int names_count,
                            const char** name, int* lengths,
<span class="udiff-line-modified-removed">-                           int* cp_indices, unsigned int* hashValues,</span>
<span class="udiff-line-removed">-                           TRAPS);</span>
<span class="udiff-line-modified-added">+                           int* cp_indices, unsigned int* hashValues);</span>
  
<span class="udiff-line-modified-removed">-   static Symbol* lookup_shared(const char* name, int len, unsigned int hash);</span>
<span class="udiff-line-modified-removed">-   Symbol* lookup_dynamic(const char* name, int len, unsigned int hash);</span>
<span class="udiff-line-modified-removed">-   Symbol* lookup_common(const char* name, int len, unsigned int hash);</span>
<span class="udiff-line-modified-added">+   static Symbol* lookup_shared(const char* name, int len, unsigned int hash) NOT_CDS_RETURN_(NULL);</span>
<span class="udiff-line-modified-added">+   static Symbol* lookup_dynamic(const char* name, int len, unsigned int hash);</span>
<span class="udiff-line-modified-added">+   static Symbol* lookup_common(const char* name, int len, unsigned int hash);</span>
  
    // Arena for permanent symbols (null class loader) that are never unloaded
    static Arena*  _arena;
    static Arena* arena() { return _arena; }  // called for statistics
  
<span class="udiff-line-modified-removed">-   static void initialize_symbols(int arena_alloc_size = 0);</span>
<span class="udiff-line-modified-added">+   static void print_table_statistics(outputStream* st, const char* table_name);</span>
  
<span class="udiff-line-modified-removed">-   void concurrent_work(JavaThread* jt);</span>
<span class="udiff-line-modified-removed">-   void print_table_statistics(outputStream* st, const char* table_name);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void try_rehash_table();</span>
<span class="udiff-line-removed">-   bool do_rehash();</span>
<span class="udiff-line-removed">-   inline void update_needs_rehash(bool rehash);</span>
<span class="udiff-line-modified-added">+   static void try_rehash_table();</span>
<span class="udiff-line-modified-added">+   static bool do_rehash();</span>
  
  public:
    // The symbol table
<span class="udiff-line-modified-removed">-   static SymbolTable* the_table() { return _the_table; }</span>
<span class="udiff-line-modified-removed">-   size_t table_size();</span>
<span class="udiff-line-modified-added">+   static size_t table_size();</span>
<span class="udiff-line-modified-added">+   static TableStatistics get_table_statistics();</span>
  
    enum {
      symbol_alloc_batch_size = 8,
      // Pick initial size based on java -version size measurements
      symbol_alloc_arena_size = 360*K // TODO (revisit)
    };
  
<span class="udiff-line-modified-removed">-   static void create_table() {</span>
<span class="udiff-line-removed">-     assert(_the_table == NULL, &quot;One symbol table allowed.&quot;);</span>
<span class="udiff-line-removed">-     _the_table = new SymbolTable();</span>
<span class="udiff-line-removed">-     initialize_symbols(symbol_alloc_arena_size);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   static void create_table();</span>
  
    static void do_concurrent_work(JavaThread* jt);
<span class="udiff-line-modified-removed">-   static bool has_work() { return the_table()-&gt;_has_work; }</span>
<span class="udiff-line-modified-added">+   static bool has_work() { return _has_work; }</span>
    static void trigger_cleanup();
  
    // Probing
<span class="udiff-line-removed">-   static Symbol* lookup(const char* name, int len, TRAPS);</span>
<span class="udiff-line-removed">-   // lookup only, won&#39;t add. Also calculate hash.</span>
<span class="udiff-line-removed">-   static Symbol* lookup_only(const char* name, int len, unsigned int&amp; hash);</span>
<span class="udiff-line-removed">-   // adds new symbol if not found</span>
<span class="udiff-line-removed">-   static Symbol* lookup(const Symbol* sym, int begin, int end, TRAPS);</span>
<span class="udiff-line-removed">-   // jchar (UTF16) version of lookups</span>
<span class="udiff-line-removed">-   static Symbol* lookup_unicode(const jchar* name, int len, TRAPS);</span>
<span class="udiff-line-removed">-   static Symbol* lookup_only_unicode(const jchar* name, int len, unsigned int&amp; hash);</span>
    // Needed for preloading classes in signatures when compiling.
    // Returns the symbol is already present in symbol table, otherwise
    // NULL.  NO ALLOCATION IS GUARANTEED!
    static Symbol* probe(const char* name, int len) {
      unsigned int ignore_hash;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,46 +178,49 @@</span>
    static Symbol* probe_unicode(const jchar* name, int len) {
      unsigned int ignore_hash;
      return lookup_only_unicode(name, len, ignore_hash);
    }
  
<span class="udiff-line-modified-removed">-   // Symbol creation</span>
<span class="udiff-line-modified-removed">-   static Symbol* new_symbol(const char* utf8_buffer, int length, TRAPS) {</span>
<span class="udiff-line-modified-removed">-     assert(utf8_buffer != NULL, &quot;just checking&quot;);</span>
<span class="udiff-line-modified-removed">-     return lookup(utf8_buffer, length, THREAD);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   static Symbol* new_symbol(const char* name, TRAPS) {</span>
<span class="udiff-line-modified-removed">-     return new_symbol(name, (int)strlen(name), THREAD);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">-   static Symbol* new_symbol(const Symbol* sym, int begin, int end, TRAPS) {</span>
<span class="udiff-line-removed">-     assert(begin &lt;= end &amp;&amp; end &lt;= sym-&gt;utf8_length(), &quot;just checking&quot;);</span>
<span class="udiff-line-removed">-     return lookup(sym, begin, end, THREAD);</span>
<span class="udiff-line-modified-added">+   // Symbol lookup and create if not found.</span>
<span class="udiff-line-modified-added">+   // jchar (UTF16) version of lookup</span>
<span class="udiff-line-modified-added">+   static Symbol* new_symbol(const jchar* name, int len);</span>
<span class="udiff-line-modified-added">+   // char (UTF8) versions</span>
<span class="udiff-line-modified-added">+   static Symbol* new_symbol(const Symbol* sym, int begin, int end);</span>
<span class="udiff-line-modified-added">+   static Symbol* new_symbol(const char* utf8_buffer, int length);</span>
<span class="udiff-line-modified-added">+   static Symbol* new_symbol(const char* name) {</span>
<span class="udiff-line-modified-added">+     return new_symbol(name, (int)strlen(name));</span>
    }
<span class="udiff-line-added">+ </span>
    // Create a symbol in the arena for symbols that are not deleted
<span class="udiff-line-modified-removed">-   static Symbol* new_permanent_symbol(const char* name, TRAPS);</span>
<span class="udiff-line-modified-added">+   static Symbol* new_permanent_symbol(const char* name);</span>
  
    // Rehash the string table if it gets out of balance
    static void rehash_table();
<span class="udiff-line-modified-removed">-   static bool needs_rehashing()</span>
<span class="udiff-line-modified-removed">-     { return SymbolTable::the_table()-&gt;_needs_rehashing; }</span>
<span class="udiff-line-modified-added">+   static bool needs_rehashing() { return _needs_rehashing; }</span>
<span class="udiff-line-modified-added">+   static inline void update_needs_rehash(bool rehash) {</span>
<span class="udiff-line-added">+     if (rehash) {</span>
<span class="udiff-line-added">+       _needs_rehashing = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
    // Heap dumper and CDS
    static void symbols_do(SymbolClosure *cl);
  
    // Sharing
  private:
    static void copy_shared_symbol_table(CompactHashtableWriter* ch_table);
  public:
<span class="udiff-line-modified-removed">-   static void write_to_archive() NOT_CDS_RETURN;</span>
<span class="udiff-line-modified-removed">-   static void serialize_shared_table_header(SerializeClosure* soc) NOT_CDS_RETURN;</span>
<span class="udiff-line-modified-added">+   static size_t estimate_size_for_archive() NOT_CDS_RETURN_(0);</span>
<span class="udiff-line-modified-added">+   static void write_to_archive(bool is_static_archive = true) NOT_CDS_RETURN;</span>
<span class="udiff-line-added">+   static void serialize_shared_table_header(SerializeClosure* soc,</span>
<span class="udiff-line-added">+                                             bool is_static_archive = true) NOT_CDS_RETURN;</span>
    static void metaspace_pointers_do(MetaspaceClosure* it);
  
    // Jcmd
    static void dump(outputStream* st, bool verbose=false);
    // Debugging
    static void verify();
<span class="udiff-line-removed">-   static void read(const char* filename, TRAPS);</span>
  
    // Histogram
    static void print_histogram() PRODUCT_RETURN;
  };
  
</pre>
<center><a href="symbolTable.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
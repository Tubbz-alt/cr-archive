<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/compactHashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;logging/logMessage.hpp&quot;
 30 #include &quot;memory/heapShared.inline.hpp&quot;
 31 #include &quot;memory/metadataFactory.hpp&quot;
 32 #include &quot;memory/metaspaceShared.hpp&quot;
 33 #include &quot;oops/compressedOops.inline.hpp&quot;
 34 #include &quot;runtime/vmThread.hpp&quot;
 35 #include &quot;utilities/numberSeq.hpp&quot;
 36 #include &lt;sys/stat.h&gt;
 37 
 38 #if INCLUDE_CDS
 39 /////////////////////////////////////////////////////
 40 //
 41 // The compact hash table writer implementations
 42 //
 43 CompactHashtableWriter::CompactHashtableWriter(int num_buckets,
 44                                                CompactHashtableStats* stats) {
 45   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 46   assert(num_buckets &gt; 0, &quot;no buckets&quot;);
 47   _num_buckets = num_buckets;
 48   _num_entries = 0;
 49   _buckets = NEW_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _num_buckets, mtSymbol);
 50   for (int i=0; i&lt;_num_buckets; i++) {
 51     _buckets[i] = new (ResourceObj::C_HEAP, mtSymbol) GrowableArray&lt;Entry&gt;(0, true, mtSymbol);
 52   }
 53 
 54   _stats = stats;
 55   _compact_buckets = NULL;
 56   _compact_entries = NULL;
 57   _num_empty_buckets = 0;
 58   _num_value_only_buckets = 0;
 59   _num_other_buckets = 0;
 60 }
 61 
 62 CompactHashtableWriter::~CompactHashtableWriter() {
 63   for (int index = 0; index &lt; _num_buckets; index++) {
 64     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 65     delete bucket;
 66   }
 67 
 68   FREE_C_HEAP_ARRAY(GrowableArray&lt;Entry&gt;*, _buckets);
 69 }
 70 
 71 // Add a symbol entry to the temporary hash table
 72 void CompactHashtableWriter::add(unsigned int hash, u4 value) {
 73   int index = hash % _num_buckets;
 74   _buckets[index]-&gt;append_if_missing(Entry(hash, value));
 75   _num_entries++;
 76 }
 77 
 78 void CompactHashtableWriter::allocate_table() {
 79   int entries_space = 0;
 80   for (int index = 0; index &lt; _num_buckets; index++) {
 81     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
 82     int bucket_size = bucket-&gt;length();
 83     if (bucket_size == 1) {
 84       entries_space++;
 85     } else {
 86       entries_space += 2 * bucket_size;
 87     }
 88   }
 89 
 90   if (entries_space &amp; ~BUCKET_OFFSET_MASK) {
 91     vm_exit_during_initialization(&quot;CompactHashtableWriter::allocate_table: Overflow! &quot;
 92                                   &quot;Too many entries.&quot;);
 93   }
 94 
 95   _compact_buckets = MetaspaceShared::new_ro_array&lt;u4&gt;(_num_buckets + 1);
 96   _compact_entries = MetaspaceShared::new_ro_array&lt;u4&gt;(entries_space);
 97 
 98   _stats-&gt;bucket_count    = _num_buckets;
 99   _stats-&gt;bucket_bytes    = _compact_buckets-&gt;size() * BytesPerWord;
100   _stats-&gt;hashentry_count = _num_entries;
101   _stats-&gt;hashentry_bytes = _compact_entries-&gt;size() * BytesPerWord;
102 }
103 
104 // Write the compact table&#39;s buckets
105 void CompactHashtableWriter::dump_table(NumberSeq* summary) {
106   u4 offset = 0;
107   for (int index = 0; index &lt; _num_buckets; index++) {
108     GrowableArray&lt;Entry&gt;* bucket = _buckets[index];
109     int bucket_size = bucket-&gt;length();
110     if (bucket_size == 1) {
111       // bucket with one entry is compacted and only has the symbol offset
112       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, VALUE_ONLY_BUCKET_TYPE));
113 
114       Entry ent = bucket-&gt;at(0);
115       _compact_entries-&gt;at_put(offset++, ent.value());
116       _num_value_only_buckets++;
117     } else {
118       // regular bucket, each entry is a symbol (hash, offset) pair
119       _compact_buckets-&gt;at_put(index, BUCKET_INFO(offset, REGULAR_BUCKET_TYPE));
120 
121       for (int i=0; i&lt;bucket_size; i++) {
122         Entry ent = bucket-&gt;at(i);
123         _compact_entries-&gt;at_put(offset++, u4(ent.hash())); // write entry hash
124         _compact_entries-&gt;at_put(offset++, ent.value());
125       }
126       if (bucket_size == 0) {
127         _num_empty_buckets++;
128       } else {
129         _num_other_buckets++;
130       }
131     }
132     summary-&gt;add(bucket_size);
133   }
134 
135   // Mark the end of the buckets
136   _compact_buckets-&gt;at_put(_num_buckets, BUCKET_INFO(offset, TABLEEND_BUCKET_TYPE));
137   assert(offset == (u4)_compact_entries-&gt;length(), &quot;sanity&quot;);
138 }
139 
140 
141 // Write the compact table
142 void CompactHashtableWriter::dump(SimpleCompactHashtable *cht, const char* table_name) {
143   NumberSeq summary;
144   allocate_table();
145   dump_table(&amp;summary);
146 
147   int table_bytes = _stats-&gt;bucket_bytes + _stats-&gt;hashentry_bytes;
148   address base_address = address(MetaspaceShared::shared_rs()-&gt;base());
149   cht-&gt;init(base_address,  _num_entries, _num_buckets,
150             _compact_buckets-&gt;data(), _compact_entries-&gt;data());
151 
152   LogMessage(cds, hashtables) msg;
153   if (msg.is_info()) {
154     double avg_cost = 0.0;
155     if (_num_entries &gt; 0) {
156       avg_cost = double(table_bytes)/double(_num_entries);
157     }
158     msg.info(&quot;Shared %s table stats -------- base: &quot; PTR_FORMAT,
159                          table_name, (intptr_t)base_address);
160     msg.info(&quot;Number of entries       : %9d&quot;, _num_entries);
161     msg.info(&quot;Total bytes used        : %9d&quot;, table_bytes);
162     msg.info(&quot;Average bytes per entry : %9.3f&quot;, avg_cost);
163     msg.info(&quot;Average bucket size     : %9.3f&quot;, summary.avg());
164     msg.info(&quot;Variance of bucket size : %9.3f&quot;, summary.variance());
165     msg.info(&quot;Std. dev. of bucket size: %9.3f&quot;, summary.sd());
166     msg.info(&quot;Maximum bucket size     : %9d&quot;, (int)summary.maximum());
167     msg.info(&quot;Empty buckets           : %9d&quot;, _num_empty_buckets);
168     msg.info(&quot;Value_Only buckets      : %9d&quot;, _num_value_only_buckets);
169     msg.info(&quot;Other buckets           : %9d&quot;, _num_other_buckets);
170   }
171 }
172 
173 /////////////////////////////////////////////////////////////
174 //
175 // The CompactHashtable implementation
176 //
177 
178 void SimpleCompactHashtable::serialize_header(SerializeClosure* soc) {
179   soc-&gt;do_ptr((void**)&amp;_base_address);
180   soc-&gt;do_u4(&amp;_entry_count);
181   soc-&gt;do_u4(&amp;_bucket_count);
182   soc-&gt;do_ptr((void**)&amp;_buckets);
183   soc-&gt;do_ptr((void**)&amp;_entries);
184 }
185 #endif // INCLUDE_CDS
186 
187 #ifndef O_BINARY       // if defined (Win32) use binary files.
188 #define O_BINARY 0     // otherwise do nothing.
189 #endif
190 
191 ////////////////////////////////////////////////////////
192 //
193 // HashtableTextDump
194 //
195 HashtableTextDump::HashtableTextDump(const char* filename) : _fd(-1) {
196   struct stat st;
197   if (os::stat(filename, &amp;st) != 0) {
198     quit(&quot;Unable to get hashtable dump file size&quot;, filename);
199   }
200   _size = st.st_size;
201   _fd = os::open(filename, O_RDONLY | O_BINARY, 0);
202   if (_fd &lt; 0) {
203     quit(&quot;Unable to open hashtable dump file&quot;, filename);
204   }
205   _base = os::map_memory(_fd, filename, 0, NULL, _size, true, false);
206   if (_base == NULL) {
207     quit(&quot;Unable to map hashtable dump file&quot;, filename);
208   }
209   _p = _base;
210   _end = _base + st.st_size;
211   _filename = filename;
212   _prefix_type = Unknown;
213   _line_no = 1;
214 }
215 
216 HashtableTextDump::~HashtableTextDump() {
217   os::unmap_memory((char*)_base, _size);
218   if (_fd &gt;= 0) {
219     close(_fd);
220   }
221 }
222 
223 void HashtableTextDump::quit(const char* err, const char* msg) {
224   vm_exit_during_initialization(err, msg);
225 }
226 
227 void HashtableTextDump::corrupted(const char *p, const char* msg) {
228   char info[100];
229   jio_snprintf(info, sizeof(info),
230                &quot;%s. Corrupted at line %d (file pos %d)&quot;,
231                msg, _line_no, (int)(p - _base));
232   quit(info, _filename);
233 }
234 
235 bool HashtableTextDump::skip_newline() {
236   if (_p[0] == &#39;\r&#39; &amp;&amp; _p[1] == &#39;\n&#39;) {
237     _p += 2;
238   } else if (_p[0] == &#39;\n&#39;) {
239     _p += 1;
240   } else {
241     corrupted(_p, &quot;Unexpected character&quot;);
242   }
243   _line_no++;
244   return true;
245 }
246 
247 int HashtableTextDump::skip(char must_be_char) {
248   corrupted_if(remain() &lt; 1, &quot;Truncated&quot;);
249   corrupted_if(*_p++ != must_be_char, &quot;Unexpected character&quot;);
250   return 0;
251 }
252 
253 void HashtableTextDump::skip_past(char c) {
254   for (;;) {
255     corrupted_if(remain() &lt; 1, &quot;Truncated&quot;);
256     if (*_p++ == c) {
257       return;
258     }
259   }
260 }
261 
262 void HashtableTextDump::check_version(const char* ver) {
263   int len = (int)strlen(ver);
264   corrupted_if(remain() &lt; len, &quot;Truncated&quot;);
265   if (strncmp(_p, ver, len) != 0) {
266     quit(&quot;wrong version of hashtable dump file&quot;, _filename);
267   }
268   _p += len;
269   skip_newline();
270 }
271 
272 void HashtableTextDump::scan_prefix_type() {
273   _p++;
274   if (strncmp(_p, &quot;SECTION: String&quot;, 15) == 0) {
275     _p += 15;
276     _prefix_type = StringPrefix;
277   } else if (strncmp(_p, &quot;SECTION: Symbol&quot;, 15) == 0) {
278     _p += 15;
279     _prefix_type = SymbolPrefix;
280   } else {
281     _prefix_type = Unknown;
282   }
283   skip_newline();
284 }
285 
286 int HashtableTextDump::scan_prefix(int* utf8_length) {
287   if (*_p == &#39;@&#39;) {
288     scan_prefix_type();
289   }
290 
291   switch (_prefix_type) {
292   case SymbolPrefix:
293     *utf8_length = scan_symbol_prefix(); break;
294   case StringPrefix:
295     *utf8_length = scan_string_prefix(); break;
296   default:
297     tty-&gt;print_cr(&quot;Shared input data type: Unknown.&quot;);
298     corrupted(_p, &quot;Unknown data type&quot;);
299   }
300 
301   return _prefix_type;
302 }
303 
304 int HashtableTextDump::scan_string_prefix() {
305   // Expect /[0-9]+: /
306   int utf8_length = 0;
307   get_num(&#39;:&#39;, &amp;utf8_length);
308   if (*_p != &#39; &#39;) {
309     corrupted(_p, &quot;Wrong prefix format for string&quot;);
310   }
311   _p++;
312   return utf8_length;
313 }
314 
315 int HashtableTextDump::scan_symbol_prefix() {
316   // Expect /[0-9]+ (-|)[0-9]+: /
317   int utf8_length = 0;
318   get_num(&#39; &#39;, &amp;utf8_length);
319   if (*_p == &#39;-&#39;) {
320     _p++;
321   }
322   int ref_num;
323   get_num(&#39;:&#39;, &amp;ref_num);
324   if (*_p != &#39; &#39;) {
325     corrupted(_p, &quot;Wrong prefix format for symbol&quot;);
326   }
327   _p++;
328   return utf8_length;
329 }
330 
331 jchar HashtableTextDump::unescape(const char* from, const char* end, int count) {
332   jchar value = 0;
333 
334   corrupted_if(from + count &gt; end, &quot;Truncated&quot;);
335 
336   for (int i=0; i&lt;count; i++) {
337     char c = *from++;
338     switch (c) {
339     case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
340     case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
341       value = (value &lt;&lt; 4) + c - &#39;0&#39;;
342       break;
343     case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
344     case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
345       value = (value &lt;&lt; 4) + 10 + c - &#39;a&#39;;
346       break;
347     case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
348     case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
349       value = (value &lt;&lt; 4) + 10 + c - &#39;A&#39;;
350       break;
351     default:
352       ShouldNotReachHere();
353     }
354   }
355   return value;
356 }
357 
358 void HashtableTextDump::get_utf8(char* utf8_buffer, int utf8_length) {
359   // cache in local vars
360   const char* from = _p;
361   const char* end = _end;
362   char* to = utf8_buffer;
363   int n = utf8_length;
364 
365   for (; n &gt; 0 &amp;&amp; from &lt; end; n--) {
366     if (*from != &#39;\\&#39;) {
367       *to++ = *from++;
368     } else {
369       corrupted_if(from + 2 &gt; end, &quot;Truncated&quot;);
370       char c = from[1];
371       from += 2;
372       switch (c) {
373       case &#39;x&#39;:
374         {
375           jchar value = unescape(from, end, 2);
376           from += 2;
377           assert(value &lt;= 0xff, &quot;sanity&quot;);
378           *to++ = (char)(value &amp; 0xff);
379         }
380         break;
381       case &#39;t&#39;:  *to++ = &#39;\t&#39;; break;
382       case &#39;n&#39;:  *to++ = &#39;\n&#39;; break;
383       case &#39;r&#39;:  *to++ = &#39;\r&#39;; break;
384       case &#39;\\&#39;: *to++ = &#39;\\&#39;; break;
385       default:
386         corrupted(_p, &quot;Unsupported character&quot;);
387       }
388     }
389   }
390   corrupted_if(n &gt; 0, &quot;Truncated&quot;); // expected more chars but file has ended
391   _p = from;
392   skip_newline();
393 }
394 
395 // NOTE: the content is NOT the same as
396 // UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen).
397 // We want to escape \r\n\t so that output [1] is more readable; [2] can be more easily
398 // parsed by scripts; [3] quickly processed by HashtableTextDump::get_utf8()
399 void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, int utf8_length) {
400   const char *c = utf8_string;
401   const char *end = c + utf8_length;
402   for (; c &lt; end; c++) {
403     switch (*c) {
404     case &#39;\t&#39;: st-&gt;print(&quot;\\t&quot;); break;
405     case &#39;\r&#39;: st-&gt;print(&quot;\\r&quot;); break;
406     case &#39;\n&#39;: st-&gt;print(&quot;\\n&quot;); break;
407     case &#39;\\&#39;: st-&gt;print(&quot;\\\\&quot;); break;
408     default:
409       if (isprint(*c)) {
410         st-&gt;print(&quot;%c&quot;, *c);
411       } else {
412         st-&gt;print(&quot;\\x%02x&quot;, ((unsigned int)*c) &amp; 0xff);
413       }
414     }
415   }
416 }
    </pre>
  </body>
</html>
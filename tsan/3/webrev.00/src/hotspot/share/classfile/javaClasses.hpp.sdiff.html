<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
<span class="line-modified">  32 #include &quot;utilities/utf8.hpp&quot;</span>

  33 
  34 // Interface for manipulating the basic Java classes.
  35 //
  36 // All dependencies on layout of actual Java classes should be kept here.
  37 // If the layout of any of the classes above changes the offsets must be adjusted.
  38 //
  39 // For most classes we hardwire the offsets for performance reasons. In certain
  40 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  41 // startup since the layout here differs between JDK1.2 and JDK1.3.
  42 //
  43 // Note that fields (static and non-static) are arranged with oops before non-oops
  44 // on a per class basis. The offsets below have to reflect this ordering.
  45 //
  46 // When editing the layouts please update the check_offset verification code
  47 // correspondingly. The names in the enums must be identical to the actual field
  48 // names in order for the verification code to work.
  49 
  50 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  51   f(java_lang_Class) \
  52   f(java_lang_String) \
  53   //end
  54 
  55 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  56   f(java_lang_System) \
  57   f(java_lang_ClassLoader) \
  58   f(java_lang_Throwable) \
  59   f(java_lang_Thread) \
  60   f(java_lang_ThreadGroup) \
  61   f(java_lang_AssertionStatusDirectives) \
  62   f(java_lang_ref_SoftReference) \
  63   f(java_lang_invoke_MethodHandle) \
  64   f(java_lang_invoke_DirectMethodHandle) \
  65   f(java_lang_invoke_MemberName) \
  66   f(java_lang_invoke_ResolvedMethodName) \
  67   f(java_lang_invoke_LambdaForm) \
  68   f(java_lang_invoke_MethodType) \
  69   f(java_lang_invoke_CallSite) \

  70   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  71   f(java_security_AccessControlContext) \
  72   f(java_lang_reflect_AccessibleObject) \
  73   f(java_lang_reflect_Method) \
  74   f(java_lang_reflect_Constructor) \
  75   f(java_lang_reflect_Field) \

  76   f(java_nio_Buffer) \
  77   f(reflect_ConstantPool) \
  78   f(reflect_UnsafeStaticFieldAccessorImpl) \
  79   f(java_lang_reflect_Parameter) \
  80   f(java_lang_Module) \
  81   f(java_lang_StackTraceElement) \
  82   f(java_lang_StackFrameInfo) \
  83   f(java_lang_LiveStackFrameInfo) \
  84   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \

  85   //end
  86 
  87 #define BASIC_JAVA_CLASSES_DO(f) \
  88         BASIC_JAVA_CLASSES_DO_PART1(f) \
  89         BASIC_JAVA_CLASSES_DO_PART2(f)
  90 







  91 // Interface to java.lang.String objects
  92 
  93 class java_lang_String : AllStatic {
  94  private:
  95   static int value_offset;
  96   static int hash_offset;

  97   static int coder_offset;
  98 
  99   static bool initialized;
 100 
 101   static Handle basic_create(int length, bool byte_arr, TRAPS);
 102 
 103   static inline void set_coder(oop string, jbyte coder);
 104 
 105  public:
 106 
 107   // Coders
 108   enum Coder {
 109     CODER_LATIN1 =  0,
 110     CODER_UTF16  =  1
 111   };
 112 
 113   static void compute_offsets();
 114   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 115 
 116   // Instance creation
 117   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 118   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 119   static Handle create_from_str(const char* utf8_str, TRAPS);
 120   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 121   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 122   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 123   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 124 
 125   static void set_compact_strings(bool value);
 126 
 127   static int value_offset_in_bytes()  {
 128     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 129     return value_offset;
 130   }
 131   static int hash_offset_in_bytes()   {
 132     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 133     return hash_offset;
 134   }




 135   static int coder_offset_in_bytes()   {
 136     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 137     return coder_offset;
 138   }
 139 
 140   static inline void set_value_raw(oop string, typeArrayOop buffer);
 141   static inline void set_value(oop string, typeArrayOop buffer);
<span class="line-removed"> 142   static inline void set_hash(oop string, unsigned int hash);</span>
 143 
 144   // Accessors
 145   static inline typeArrayOop value(oop java_string);
 146   static inline typeArrayOop value_no_keepalive(oop java_string);
<span class="line-modified"> 147   static inline unsigned int hash(oop java_string);</span>
 148   static inline bool is_latin1(oop java_string);
 149   static inline int length(oop java_string);
 150   static inline int length(oop java_string, typeArrayOop string_value);
 151   static int utf8_length(oop java_string);
 152   static int utf8_length(oop java_string, typeArrayOop string_value);
 153 
 154   // String converters
 155   static char*  as_utf8_string(oop java_string);
 156   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 157   static char*  as_utf8_string(oop java_string, int start, int len);
 158   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 159   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 160   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 161   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 162   // produce an ascii string with all other values quoted using \u####
 163   static char*  as_quoted_ascii(oop java_string);
 164 
 165   // Compute the hash value for a java.lang.String object which would
 166   // contain the characters passed in.
 167   //
</pre>
<hr />
<pre>
 180     }
 181     return h;
 182   }
 183 
 184   static unsigned int hash_code(const jbyte* s, int len) {
 185     unsigned int h = 0;
 186     while (len-- &gt; 0) {
 187       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 188       s++;
 189     }
 190     return h;
 191   }
 192 
 193   static unsigned int hash_code(oop java_string);
 194 
 195   static bool equals(oop java_string, const jchar* chars, int len);
 196   static bool equals(oop str1, oop str2);
 197   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 198 
 199   // Conversion between &#39;.&#39; and &#39;/&#39; formats
<span class="line-modified"> 200   static Handle externalize_classname(Handle java_string, TRAPS) { return char_converter(java_string, &#39;/&#39;, &#39;.&#39;, THREAD); }</span>
<span class="line-modified"> 201   static Handle internalize_classname(Handle java_string, TRAPS) { return char_converter(java_string, &#39;.&#39;, &#39;/&#39;, THREAD); }</span>

 202 
 203   // Conversion
<span class="line-modified"> 204   static Symbol* as_symbol(oop java_string, TRAPS);</span>
 205   static Symbol* as_symbol_or_null(oop java_string);
 206 
 207   // Testers
 208   static bool is_instance(oop obj);
 209   static inline bool is_instance_inlined(oop obj);
 210 
 211   // Debugging
 212   static void print(oop java_string, outputStream* st);
 213   friend class JavaClasses;
 214   friend class StringTable;
 215 };
 216 
 217 
 218 // Interface to java.lang.Class objects
 219 
 220 #define CLASS_INJECTED_FIELDS(macro)                                       \
 221   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 222   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 223   macro(java_lang_Class, oop_size,               int_signature,     false) \
 224   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
</pre>
<hr />
<pre>
 252   static int classRedefinedCount_offset;
 253 
 254   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 255   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 256 
 257   static void set_init_lock(oop java_class, oop init_lock);
 258   static void set_protection_domain(oop java_class, oop protection_domain);
 259   static void set_class_loader(oop java_class, oop class_loader);
 260   static void set_component_mirror(oop java_class, oop comp_mirror);
 261   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
 262   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 263  public:
 264   static void allocate_fixup_lists();
 265   static void compute_offsets();
 266 
 267   // Instance creation
 268   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 269                             Handle protection_domain, TRAPS);
 270   static void fixup_mirror(Klass* k, TRAPS);
 271   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);


 272 
 273   // Archiving
 274   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 275   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 276   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 277   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 278                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 279   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 280                                       Handle protection_domain,
 281                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 282 
 283   static void fixup_module_field(Klass* k, Handle module);
 284 
 285   // Conversion
 286   static Klass* as_Klass(oop java_class);
 287   static Klass* as_Klass_raw(oop java_class);
 288   static void set_klass(oop java_class, Klass* klass);
 289   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
<span class="line-modified"> 290   static Symbol* as_signature(oop java_class, bool intern_if_not_found, TRAPS);</span>
 291   static void print_signature(oop java_class, outputStream *st);
 292   static const char* as_external_name(oop java_class);
 293   // Testing
 294   static bool is_instance(oop obj);
 295 
 296   static bool is_primitive(oop java_class);
 297   static BasicType primitive_type(oop java_class);
 298   static oop primitive_mirror(BasicType t);
 299   // JVM_NewArray support
 300   static Klass* array_klass_acquire(oop java_class);
 301   static void release_set_array_klass(oop java_class, Klass* klass);
 302   // compiler support for class operations
 303   static int klass_offset_in_bytes()                { return _klass_offset; }
 304   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 305   // Support for classRedefinedCount field
 306   static int classRedefinedCount(oop the_class_mirror);
 307   static void set_classRedefinedCount(oop the_class_mirror, int value);
 308 
 309   // Support for embedded per-class oops
 310   static oop  protection_domain(oop java_class);
</pre>
<hr />
<pre>
 348   }
 349 
 350   // Debugging
 351   friend class JavaClasses;
 352   friend class InstanceKlass;   // verification code accesses offsets
 353   friend class ClassFileParser; // access to number_of_fake_fields
 354 };
 355 
 356 // Interface to java.lang.Thread objects
 357 
 358 class java_lang_Thread : AllStatic {
 359  private:
 360   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 361   // so we compute the offsets at startup rather than hard-wiring them.
 362   static int _name_offset;
 363   static int _group_offset;
 364   static int _contextClassLoader_offset;
 365   static int _inheritedAccessControlContext_offset;
 366   static int _priority_offset;
 367   static int _eetop_offset;

 368   static int _daemon_offset;
 369   static int _stillborn_offset;
 370   static int _stackSize_offset;
 371   static int _tid_offset;
 372   static int _thread_status_offset;
 373   static int _park_blocker_offset;
<span class="line-removed"> 374   static int _park_event_offset ;</span>
 375 
 376   static void compute_offsets();
 377 
 378  public:
 379   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 380 
 381   // Instance creation
 382   static oop create();
 383   // Returns the JavaThread associated with the thread obj
 384   static JavaThread* thread(oop java_thread);
 385   // Set JavaThread for instance
 386   static void set_thread(oop java_thread, JavaThread* thread);



 387   // Name
 388   static oop name(oop java_thread);
 389   static void set_name(oop java_thread, oop name);
 390   // Priority
 391   static ThreadPriority priority(oop java_thread);
 392   static void set_priority(oop java_thread, ThreadPriority priority);
 393   // Thread group
 394   static oop  threadGroup(oop java_thread);
 395   // Stillborn
 396   static bool is_stillborn(oop java_thread);
 397   static void set_stillborn(oop java_thread);
 398   // Alive (NOTE: this is not really a field, but provides the correct
 399   // definition without doing a Java call)
 400   static bool is_alive(oop java_thread);
 401   // Daemon
 402   static bool is_daemon(oop java_thread);
 403   static void set_daemon(oop java_thread);
 404   // Context ClassLoader
 405   static oop context_class_loader(oop java_thread);
 406   // Control context
 407   static oop inherited_access_control_context(oop java_thread);
 408   // Stack size hint
 409   static jlong stackSize(oop java_thread);
 410   // Thread ID
 411   static jlong thread_id(oop java_thread);
 412 
 413   // Blocker object responsible for thread parking
 414   static oop park_blocker(oop java_thread);
 415 
<span class="line-removed"> 416   // Pointer to type-stable park handler, encoded as jlong.</span>
<span class="line-removed"> 417   // Should be set when apparently null</span>
<span class="line-removed"> 418   // For details, see unsafe.cpp Unsafe_Unpark</span>
<span class="line-removed"> 419   static jlong park_event(oop java_thread);</span>
<span class="line-removed"> 420   static bool set_park_event(oop java_thread, jlong ptr);</span>
<span class="line-removed"> 421 </span>
 422   // Java Thread Status for JVMTI and M&amp;M use.
 423   // This thread status info is saved in threadStatus field of
 424   // java.lang.Thread java class.
 425   enum ThreadStatus {
 426     NEW                      = 0,
 427     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 428                                JVMTI_THREAD_STATE_RUNNABLE,
 429     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 430                                JVMTI_THREAD_STATE_WAITING +
 431                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 432                                JVMTI_THREAD_STATE_SLEEPING,
 433     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 434                                JVMTI_THREAD_STATE_WAITING +
 435                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 436                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 437     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 438                                JVMTI_THREAD_STATE_WAITING +
 439                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 440                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 441     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
</pre>
<hr />
<pre>
 509 
 510 class java_lang_Throwable: AllStatic {
 511   friend class BacktraceBuilder;
 512   friend class BacktraceIterator;
 513 
 514  private:
 515   // Offsets
 516   enum {
 517     hc_backtrace_offset     =  0,
 518     hc_detailMessage_offset =  1,
 519     hc_cause_offset         =  2,  // New since 1.4
 520     hc_stackTrace_offset    =  3   // New since 1.4
 521   };
 522   // Trace constants
 523   enum {
 524     trace_methods_offset = 0,
 525     trace_bcis_offset    = 1,
 526     trace_mirrors_offset = 2,
 527     trace_names_offset   = 3,
 528     trace_next_offset    = 4,
<span class="line-modified"> 529     trace_size           = 5,</span>

 530     trace_chunk_size     = 32
 531   };
 532 
 533   static int backtrace_offset;
 534   static int detailMessage_offset;
 535   static int stackTrace_offset;
 536   static int depth_offset;
 537   static int static_unassigned_stacktrace_offset;
 538 
 539   // StackTrace (programmatic access, new since 1.4)
 540   static void clear_stacktrace(oop throwable);
 541   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 542   static void set_stacktrace(oop throwable, oop st_element_array);
 543   static oop unassigned_stacktrace();
 544 
 545  public:
 546   // Backtrace
 547   static oop backtrace(oop throwable);
 548   static void set_backtrace(oop throwable, oop value);
 549   static int depth(oop throwable);
 550   static void set_depth(oop throwable, int value);
 551   // Needed by JVMTI to filter out this internal field.
 552   static int get_backtrace_offset() { return backtrace_offset;}
 553   static int get_detailMessage_offset() { return detailMessage_offset;}
 554   // Message
 555   static oop message(oop throwable);
 556   static void set_message(oop throwable, oop value);
 557   static Symbol* detail_message(oop throwable);
<span class="line-modified"> 558   static void print_stack_element(outputStream *st, const methodHandle&amp; method, int bci);</span>
 559   static void print_stack_usage(Handle stream);
 560 
 561   static void compute_offsets();
 562   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 563 
 564   // Allocate space for backtrace (created but stack trace not filled in)
 565   static void allocate_backtrace(Handle throwable, TRAPS);
 566   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 567   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 568   // Fill in current stack trace, can cause GC
 569   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 570   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 571   // Programmatic access to stack trace
 572   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 573   // Printing
 574   static void print(oop throwable, outputStream* st);
 575   static void print_stack_trace(Handle throwable, outputStream* st);
 576   static void java_printStackTrace(Handle throwable, TRAPS);
 577   // Debugging
 578   friend class JavaClasses;


 579 };
 580 
 581 
 582 // Interface to java.lang.reflect.AccessibleObject objects
 583 
 584 class java_lang_reflect_AccessibleObject: AllStatic {
 585  private:
 586   // Note that to reduce dependencies on the JDK we compute these
 587   // offsets at run-time.
 588   static int override_offset;
 589 
 590   static void compute_offsets();
 591 
 592  public:
 593   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 594 
 595   // Accessors
 596   static jboolean override(oop reflect);
 597   static void set_override(oop reflect, jboolean value);
 598 
</pre>
<hr />
<pre>
1046 
1047 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1048   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1049   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1050 
1051 class java_lang_invoke_ResolvedMethodName : AllStatic {
1052   friend class JavaClasses;
1053 
1054   static int _vmtarget_offset;
1055   static int _vmholder_offset;
1056 
1057   static void compute_offsets();
1058  public:
1059   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1060 
1061   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1062 
1063   static Method* vmtarget(oop resolved_method);
1064   static void set_vmtarget(oop resolved_method, Method* method);
1065 


1066   // find or create resolved member name
1067   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1068 
1069   static bool is_instance(oop resolved_method);
1070 };
1071 
1072 
1073 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1074   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1075 
1076 
1077 class java_lang_invoke_MemberName: AllStatic {
1078   friend class JavaClasses;
1079 
1080  private:
1081   // From java.lang.invoke.MemberName:
1082   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1083   //    private String     name;        // may be null if not yet materialized
1084   //    private Object     type;        // may be null if not yet materialized
1085   //    private int        flags;       // modifier bits; see reflect.Modifier
</pre>
<hr />
<pre>
1154   friend class JavaClasses;
1155 
1156  private:
1157   static int _rtype_offset;
1158   static int _ptypes_offset;
1159 
1160   static void compute_offsets();
1161 
1162  public:
1163   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1164   // Accessors
1165   static oop            rtype(oop mt);
1166   static objArrayOop    ptypes(oop mt);
1167 
1168   static oop            ptype(oop mt, int index);
1169   static int            ptype_count(oop mt);
1170 
1171   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1172   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1173 
<span class="line-modified">1174   static Symbol*        as_signature(oop mt, bool intern_if_not_found, TRAPS);</span>
1175   static void           print_signature(oop mt, outputStream* st);
1176 
1177   static bool is_instance(oop obj);
1178 
1179   static bool equals(oop mt1, oop mt2);
1180 
1181   // Accessors for code generation:
1182   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1183   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1184 };
1185 
1186 
1187 // Interface to java.lang.invoke.CallSite objects
1188 
1189 class java_lang_invoke_CallSite: AllStatic {
1190   friend class JavaClasses;
1191 
1192 private:
1193   static int _target_offset;
1194   static int _context_offset;
</pre>
<hr />
<pre>
1197 
1198 public:
1199   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1200   // Accessors
1201   static oop              target(          oop site);
1202   static void         set_target(          oop site, oop target);
1203   static void         set_target_volatile( oop site, oop target);
1204 
1205   static oop context_no_keepalive(oop site);
1206 
1207   // Testers
1208   static bool is_subclass(Klass* klass) {
1209     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1210   }
1211   static bool is_instance(oop obj);
1212 
1213   // Accessors for code generation:
1214   static int target_offset_in_bytes()           { return _target_offset; }
1215 };
1216 






















1217 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1218 
1219 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1220   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1221   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1222 
1223 class DependencyContext;
1224 
1225 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1226   friend class JavaClasses;
1227 
1228 private:
1229   static int _vmdependencies_offset;
1230   static int _last_cleanup_offset;
1231 
1232   static void compute_offsets();
1233 
1234 public:
1235   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1236   // Accessors
</pre>
<hr />
<pre>
1346  private:
1347   static int declaringClassObject_offset;
1348   static int classLoaderName_offset;
1349   static int moduleName_offset;
1350   static int moduleVersion_offset;
1351   static int declaringClass_offset;
1352   static int methodName_offset;
1353   static int fileName_offset;
1354   static int lineNumber_offset;
1355 
1356   // Setters
1357   static void set_classLoaderName(oop element, oop value);
1358   static void set_moduleName(oop element, oop value);
1359   static void set_moduleVersion(oop element, oop value);
1360   static void set_declaringClass(oop element, oop value);
1361   static void set_methodName(oop element, oop value);
1362   static void set_fileName(oop element, oop value);
1363   static void set_lineNumber(oop element, int value);
1364   static void set_declaringClassObject(oop element, oop value);
1365 




1366  public:
1367   // Create an instance of StackTraceElement
1368   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1369 
1370   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1371                       int version, int bci, Symbol* name, TRAPS);
1372 
1373   static void compute_offsets();
1374   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1375 




1376   // Debugging
1377   friend class JavaClasses;
1378 };
1379 
1380 
1381 class Backtrace: AllStatic {
1382  public:
1383   // Helper backtrace functions to store bci|version together.
1384   static int merge_bci_and_version(int bci, int version);
1385   static int merge_mid_and_cpref(int mid, int cpref);
1386   static int bci_at(unsigned int merged);
1387   static int version_at(unsigned int merged);
1388   static int mid_at(unsigned int merged);
1389   static int cpref_at(unsigned int merged);
<span class="line-modified">1390   static int get_line_number(const methodHandle&amp; method, int bci);</span>
1391   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1392 
1393   // Debugging
1394   friend class JavaClasses;
1395 };
1396 
1397 // Interface to java.lang.StackFrameInfo objects
1398 
1399 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1400   macro(java_lang_StackFrameInfo, version, short_signature, false)
1401 
1402 class java_lang_StackFrameInfo: AllStatic {
1403 private:
1404   static int _memberName_offset;
1405   static int _bci_offset;
1406   static int _version_offset;
1407 
1408   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1409 
1410 public:
</pre>
<hr />
<pre>
1426 class java_lang_LiveStackFrameInfo: AllStatic {
1427  private:
1428   static int _monitors_offset;
1429   static int _locals_offset;
1430   static int _operands_offset;
1431   static int _mode_offset;
1432 
1433  public:
1434   static void set_monitors(oop info, oop value);
1435   static void set_locals(oop info, oop value);
1436   static void set_operands(oop info, oop value);
1437   static void set_mode(oop info, int value);
1438 
1439   static void compute_offsets();
1440   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1441 
1442   // Debugging
1443   friend class JavaClasses;
1444 };
1445 

































1446 // Interface to java.lang.AssertionStatusDirectives objects
1447 
1448 class java_lang_AssertionStatusDirectives: AllStatic {
1449  private:
1450   static int classes_offset;
1451   static int classEnabled_offset;
1452   static int packages_offset;
1453   static int packageEnabled_offset;
1454   static int deflt_offset;
1455 
1456  public:
1457   // Setters
1458   static void set_classes(oop obj, oop val);
1459   static void set_classEnabled(oop obj, oop val);
1460   static void set_packages(oop obj, oop val);
1461   static void set_packageEnabled(oop obj, oop val);
1462   static void set_deflt(oop obj, bool val);
1463 
1464   static void compute_offsets();
1465   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
</pre>
<hr />
<pre>
1471 
1472 class java_nio_Buffer: AllStatic {
1473  private:
1474   static int _limit_offset;
1475 
1476  public:
1477   static int  limit_offset();
1478   static void compute_offsets();
1479   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1480 };
1481 
1482 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1483  private:
1484   static int  _owner_offset;
1485  public:
1486   static void compute_offsets();
1487   static oop  get_owner_threadObj(oop obj);
1488   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1489 };
1490 

































































































1491 // Use to declare fields that need to be injected into Java classes
1492 // for the JVM to use.  The name_index and signature_index are
1493 // declared in vmSymbols.  The may_be_java flag is used to declare
1494 // fields that might already exist in Java but should be injected if
1495 // they don&#39;t.  Otherwise the field is unconditionally injected and
1496 // the JVM uses the injected one.  This is to ensure that name
1497 // collisions don&#39;t occur.  In general may_be_java should be false
1498 // unless there&#39;s a good reason.
1499 
1500 class InjectedField {
1501  public:
1502   const SystemDictionary::WKID klass_id;
1503   const vmSymbols::SID name_index;
1504   const vmSymbols::SID signature_index;
1505   const bool           may_be_java;
1506 
1507 
1508   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1509   Symbol* name() const      { return lookup_symbol(name_index); }
1510   Symbol* signature() const { return lookup_symbol(signature_index); }
</pre>
<hr />
<pre>
1533 
1534 class JavaClasses : AllStatic {
1535  private:
1536 
1537   static InjectedField _injected_fields[];
1538 
1539   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1540  public:
1541   enum InjectedFieldID {
1542     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1543     MAX_enum
1544   };
1545 
1546   static int compute_injected_offset(InjectedFieldID id);
1547 
1548   static void compute_hard_coded_offsets();
1549   static void compute_offsets();
1550   static void check_offsets() PRODUCT_RETURN;
1551   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1552   static InjectedField* get_injected(Symbol* class_name, int* field_count);

1553 };
1554 
1555 #undef DECLARE_INJECTED_FIELD_ENUM
1556 
1557 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
<span class="line-modified">  32 </span>
<span class="line-added">  33 class RecordComponent;</span>
  34 
  35 // Interface for manipulating the basic Java classes.
  36 //
  37 // All dependencies on layout of actual Java classes should be kept here.
  38 // If the layout of any of the classes above changes the offsets must be adjusted.
  39 //
  40 // For most classes we hardwire the offsets for performance reasons. In certain
  41 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  42 // startup since the layout here differs between JDK1.2 and JDK1.3.
  43 //
  44 // Note that fields (static and non-static) are arranged with oops before non-oops
  45 // on a per class basis. The offsets below have to reflect this ordering.
  46 //
  47 // When editing the layouts please update the check_offset verification code
  48 // correspondingly. The names in the enums must be identical to the actual field
  49 // names in order for the verification code to work.
  50 
  51 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  52   f(java_lang_Class) \
  53   f(java_lang_String) \
  54   //end
  55 
  56 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  57   f(java_lang_System) \
  58   f(java_lang_ClassLoader) \
  59   f(java_lang_Throwable) \
  60   f(java_lang_Thread) \
  61   f(java_lang_ThreadGroup) \
  62   f(java_lang_AssertionStatusDirectives) \
  63   f(java_lang_ref_SoftReference) \
  64   f(java_lang_invoke_MethodHandle) \
  65   f(java_lang_invoke_DirectMethodHandle) \
  66   f(java_lang_invoke_MemberName) \
  67   f(java_lang_invoke_ResolvedMethodName) \
  68   f(java_lang_invoke_LambdaForm) \
  69   f(java_lang_invoke_MethodType) \
  70   f(java_lang_invoke_CallSite) \
<span class="line-added">  71   f(java_lang_invoke_ConstantCallSite) \</span>
  72   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  73   f(java_security_AccessControlContext) \
  74   f(java_lang_reflect_AccessibleObject) \
  75   f(java_lang_reflect_Method) \
  76   f(java_lang_reflect_Constructor) \
  77   f(java_lang_reflect_Field) \
<span class="line-added">  78   f(java_lang_reflect_RecordComponent) \</span>
  79   f(java_nio_Buffer) \
  80   f(reflect_ConstantPool) \
  81   f(reflect_UnsafeStaticFieldAccessorImpl) \
  82   f(java_lang_reflect_Parameter) \
  83   f(java_lang_Module) \
  84   f(java_lang_StackTraceElement) \
  85   f(java_lang_StackFrameInfo) \
  86   f(java_lang_LiveStackFrameInfo) \
  87   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
<span class="line-added">  88   f(jdk_internal_misc_UnsafeConstants) \</span>
  89   //end
  90 
  91 #define BASIC_JAVA_CLASSES_DO(f) \
  92         BASIC_JAVA_CLASSES_DO_PART1(f) \
  93         BASIC_JAVA_CLASSES_DO_PART2(f)
  94 
<span class="line-added">  95 // Interface to java.lang.Object objects</span>
<span class="line-added">  96 </span>
<span class="line-added">  97 class java_lang_Object : AllStatic {</span>
<span class="line-added">  98  public:</span>
<span class="line-added">  99   static void register_natives(TRAPS);</span>
<span class="line-added"> 100 };</span>
<span class="line-added"> 101 </span>
 102 // Interface to java.lang.String objects
 103 
 104 class java_lang_String : AllStatic {
 105  private:
 106   static int value_offset;
 107   static int hash_offset;
<span class="line-added"> 108   static int hashIsZero_offset;</span>
 109   static int coder_offset;
 110 
 111   static bool initialized;
 112 
 113   static Handle basic_create(int length, bool byte_arr, TRAPS);
 114 
 115   static inline void set_coder(oop string, jbyte coder);
 116 
 117  public:
 118 
 119   // Coders
 120   enum Coder {
 121     CODER_LATIN1 =  0,
 122     CODER_UTF16  =  1
 123   };
 124 
 125   static void compute_offsets();
 126   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 127 
 128   // Instance creation
 129   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 130   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 131   static Handle create_from_str(const char* utf8_str, TRAPS);
 132   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 133   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 134   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 135   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 136 
 137   static void set_compact_strings(bool value);
 138 
 139   static int value_offset_in_bytes()  {
 140     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 141     return value_offset;
 142   }
 143   static int hash_offset_in_bytes()   {
 144     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 145     return hash_offset;
 146   }
<span class="line-added"> 147   static int hashIsZero_offset_in_bytes()   {</span>
<span class="line-added"> 148     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-added"> 149     return hashIsZero_offset;</span>
<span class="line-added"> 150   }</span>
 151   static int coder_offset_in_bytes()   {
 152     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 153     return coder_offset;
 154   }
 155 
 156   static inline void set_value_raw(oop string, typeArrayOop buffer);
 157   static inline void set_value(oop string, typeArrayOop buffer);

 158 
 159   // Accessors
 160   static inline typeArrayOop value(oop java_string);
 161   static inline typeArrayOop value_no_keepalive(oop java_string);
<span class="line-modified"> 162   static inline bool hash_is_set(oop string);</span>
 163   static inline bool is_latin1(oop java_string);
 164   static inline int length(oop java_string);
 165   static inline int length(oop java_string, typeArrayOop string_value);
 166   static int utf8_length(oop java_string);
 167   static int utf8_length(oop java_string, typeArrayOop string_value);
 168 
 169   // String converters
 170   static char*  as_utf8_string(oop java_string);
 171   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 172   static char*  as_utf8_string(oop java_string, int start, int len);
 173   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 174   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 175   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 176   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 177   // produce an ascii string with all other values quoted using \u####
 178   static char*  as_quoted_ascii(oop java_string);
 179 
 180   // Compute the hash value for a java.lang.String object which would
 181   // contain the characters passed in.
 182   //
</pre>
<hr />
<pre>
 195     }
 196     return h;
 197   }
 198 
 199   static unsigned int hash_code(const jbyte* s, int len) {
 200     unsigned int h = 0;
 201     while (len-- &gt; 0) {
 202       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 203       s++;
 204     }
 205     return h;
 206   }
 207 
 208   static unsigned int hash_code(oop java_string);
 209 
 210   static bool equals(oop java_string, const jchar* chars, int len);
 211   static bool equals(oop str1, oop str2);
 212   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 213 
 214   // Conversion between &#39;.&#39; and &#39;/&#39; formats
<span class="line-modified"> 215   static Handle externalize_classname(Handle java_string, TRAPS) {</span>
<span class="line-modified"> 216     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);</span>
<span class="line-added"> 217   }</span>
 218 
 219   // Conversion
<span class="line-modified"> 220   static Symbol* as_symbol(oop java_string);</span>
 221   static Symbol* as_symbol_or_null(oop java_string);
 222 
 223   // Testers
 224   static bool is_instance(oop obj);
 225   static inline bool is_instance_inlined(oop obj);
 226 
 227   // Debugging
 228   static void print(oop java_string, outputStream* st);
 229   friend class JavaClasses;
 230   friend class StringTable;
 231 };
 232 
 233 
 234 // Interface to java.lang.Class objects
 235 
 236 #define CLASS_INJECTED_FIELDS(macro)                                       \
 237   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 238   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 239   macro(java_lang_Class, oop_size,               int_signature,     false) \
 240   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
</pre>
<hr />
<pre>
 268   static int classRedefinedCount_offset;
 269 
 270   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 271   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 272 
 273   static void set_init_lock(oop java_class, oop init_lock);
 274   static void set_protection_domain(oop java_class, oop protection_domain);
 275   static void set_class_loader(oop java_class, oop class_loader);
 276   static void set_component_mirror(oop java_class, oop comp_mirror);
 277   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
 278   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 279  public:
 280   static void allocate_fixup_lists();
 281   static void compute_offsets();
 282 
 283   // Instance creation
 284   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 285                             Handle protection_domain, TRAPS);
 286   static void fixup_mirror(Klass* k, TRAPS);
 287   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
<span class="line-added"> 288   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;</span>
<span class="line-added"> 289   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;</span>
 290 
 291   // Archiving
 292   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 293   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 294   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 295   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 296                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 297   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 298                                       Handle protection_domain,
 299                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 300 
 301   static void fixup_module_field(Klass* k, Handle module);
 302 
 303   // Conversion
 304   static Klass* as_Klass(oop java_class);
 305   static Klass* as_Klass_raw(oop java_class);
 306   static void set_klass(oop java_class, Klass* klass);
 307   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
<span class="line-modified"> 308   static Symbol* as_signature(oop java_class, bool intern_if_not_found);</span>
 309   static void print_signature(oop java_class, outputStream *st);
 310   static const char* as_external_name(oop java_class);
 311   // Testing
 312   static bool is_instance(oop obj);
 313 
 314   static bool is_primitive(oop java_class);
 315   static BasicType primitive_type(oop java_class);
 316   static oop primitive_mirror(BasicType t);
 317   // JVM_NewArray support
 318   static Klass* array_klass_acquire(oop java_class);
 319   static void release_set_array_klass(oop java_class, Klass* klass);
 320   // compiler support for class operations
 321   static int klass_offset_in_bytes()                { return _klass_offset; }
 322   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 323   // Support for classRedefinedCount field
 324   static int classRedefinedCount(oop the_class_mirror);
 325   static void set_classRedefinedCount(oop the_class_mirror, int value);
 326 
 327   // Support for embedded per-class oops
 328   static oop  protection_domain(oop java_class);
</pre>
<hr />
<pre>
 366   }
 367 
 368   // Debugging
 369   friend class JavaClasses;
 370   friend class InstanceKlass;   // verification code accesses offsets
 371   friend class ClassFileParser; // access to number_of_fake_fields
 372 };
 373 
 374 // Interface to java.lang.Thread objects
 375 
 376 class java_lang_Thread : AllStatic {
 377  private:
 378   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 379   // so we compute the offsets at startup rather than hard-wiring them.
 380   static int _name_offset;
 381   static int _group_offset;
 382   static int _contextClassLoader_offset;
 383   static int _inheritedAccessControlContext_offset;
 384   static int _priority_offset;
 385   static int _eetop_offset;
<span class="line-added"> 386   static int _interrupted_offset;</span>
 387   static int _daemon_offset;
 388   static int _stillborn_offset;
 389   static int _stackSize_offset;
 390   static int _tid_offset;
 391   static int _thread_status_offset;
 392   static int _park_blocker_offset;

 393 
 394   static void compute_offsets();
 395 
 396  public:
 397   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 398 
 399   // Instance creation
 400   static oop create();
 401   // Returns the JavaThread associated with the thread obj
 402   static JavaThread* thread(oop java_thread);
 403   // Set JavaThread for instance
 404   static void set_thread(oop java_thread, JavaThread* thread);
<span class="line-added"> 405   // Interrupted status</span>
<span class="line-added"> 406   static bool interrupted(oop java_thread);</span>
<span class="line-added"> 407   static void set_interrupted(oop java_thread, bool val);</span>
 408   // Name
 409   static oop name(oop java_thread);
 410   static void set_name(oop java_thread, oop name);
 411   // Priority
 412   static ThreadPriority priority(oop java_thread);
 413   static void set_priority(oop java_thread, ThreadPriority priority);
 414   // Thread group
 415   static oop  threadGroup(oop java_thread);
 416   // Stillborn
 417   static bool is_stillborn(oop java_thread);
 418   static void set_stillborn(oop java_thread);
 419   // Alive (NOTE: this is not really a field, but provides the correct
 420   // definition without doing a Java call)
 421   static bool is_alive(oop java_thread);
 422   // Daemon
 423   static bool is_daemon(oop java_thread);
 424   static void set_daemon(oop java_thread);
 425   // Context ClassLoader
 426   static oop context_class_loader(oop java_thread);
 427   // Control context
 428   static oop inherited_access_control_context(oop java_thread);
 429   // Stack size hint
 430   static jlong stackSize(oop java_thread);
 431   // Thread ID
 432   static jlong thread_id(oop java_thread);
 433 
 434   // Blocker object responsible for thread parking
 435   static oop park_blocker(oop java_thread);
 436 






 437   // Java Thread Status for JVMTI and M&amp;M use.
 438   // This thread status info is saved in threadStatus field of
 439   // java.lang.Thread java class.
 440   enum ThreadStatus {
 441     NEW                      = 0,
 442     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 443                                JVMTI_THREAD_STATE_RUNNABLE,
 444     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 445                                JVMTI_THREAD_STATE_WAITING +
 446                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 447                                JVMTI_THREAD_STATE_SLEEPING,
 448     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 449                                JVMTI_THREAD_STATE_WAITING +
 450                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 451                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 452     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 453                                JVMTI_THREAD_STATE_WAITING +
 454                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 455                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 456     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
</pre>
<hr />
<pre>
 524 
 525 class java_lang_Throwable: AllStatic {
 526   friend class BacktraceBuilder;
 527   friend class BacktraceIterator;
 528 
 529  private:
 530   // Offsets
 531   enum {
 532     hc_backtrace_offset     =  0,
 533     hc_detailMessage_offset =  1,
 534     hc_cause_offset         =  2,  // New since 1.4
 535     hc_stackTrace_offset    =  3   // New since 1.4
 536   };
 537   // Trace constants
 538   enum {
 539     trace_methods_offset = 0,
 540     trace_bcis_offset    = 1,
 541     trace_mirrors_offset = 2,
 542     trace_names_offset   = 3,
 543     trace_next_offset    = 4,
<span class="line-modified"> 544     trace_hidden_offset  = 5,</span>
<span class="line-added"> 545     trace_size           = 6,</span>
 546     trace_chunk_size     = 32
 547   };
 548 
 549   static int backtrace_offset;
 550   static int detailMessage_offset;
 551   static int stackTrace_offset;
 552   static int depth_offset;
 553   static int static_unassigned_stacktrace_offset;
 554 
 555   // StackTrace (programmatic access, new since 1.4)
 556   static void clear_stacktrace(oop throwable);
 557   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 558   static void set_stacktrace(oop throwable, oop st_element_array);
 559   static oop unassigned_stacktrace();
 560 
 561  public:
 562   // Backtrace
 563   static oop backtrace(oop throwable);
 564   static void set_backtrace(oop throwable, oop value);
 565   static int depth(oop throwable);
 566   static void set_depth(oop throwable, int value);
 567   // Needed by JVMTI to filter out this internal field.
 568   static int get_backtrace_offset() { return backtrace_offset;}
 569   static int get_detailMessage_offset() { return detailMessage_offset;}
 570   // Message
 571   static oop message(oop throwable);
 572   static void set_message(oop throwable, oop value);
 573   static Symbol* detail_message(oop throwable);
<span class="line-modified"> 574   static void print_stack_element(outputStream *st, Method* method, int bci);</span>
 575   static void print_stack_usage(Handle stream);
 576 
 577   static void compute_offsets();
 578   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 579 
 580   // Allocate space for backtrace (created but stack trace not filled in)
 581   static void allocate_backtrace(Handle throwable, TRAPS);
 582   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 583   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 584   // Fill in current stack trace, can cause GC
 585   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 586   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 587   // Programmatic access to stack trace
 588   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 589   // Printing
 590   static void print(oop throwable, outputStream* st);
 591   static void print_stack_trace(Handle throwable, outputStream* st);
 592   static void java_printStackTrace(Handle throwable, TRAPS);
 593   // Debugging
 594   friend class JavaClasses;
<span class="line-added"> 595   // Gets the method and bci of the top frame (TOS). Returns false if this failed.</span>
<span class="line-added"> 596   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);</span>
 597 };
 598 
 599 
 600 // Interface to java.lang.reflect.AccessibleObject objects
 601 
 602 class java_lang_reflect_AccessibleObject: AllStatic {
 603  private:
 604   // Note that to reduce dependencies on the JDK we compute these
 605   // offsets at run-time.
 606   static int override_offset;
 607 
 608   static void compute_offsets();
 609 
 610  public:
 611   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 612 
 613   // Accessors
 614   static jboolean override(oop reflect);
 615   static void set_override(oop reflect, jboolean value);
 616 
</pre>
<hr />
<pre>
1064 
1065 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1066   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1067   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1068 
1069 class java_lang_invoke_ResolvedMethodName : AllStatic {
1070   friend class JavaClasses;
1071 
1072   static int _vmtarget_offset;
1073   static int _vmholder_offset;
1074 
1075   static void compute_offsets();
1076  public:
1077   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1078 
1079   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1080 
1081   static Method* vmtarget(oop resolved_method);
1082   static void set_vmtarget(oop resolved_method, Method* method);
1083 
<span class="line-added">1084   static void set_vmholder(oop resolved_method, oop holder);</span>
<span class="line-added">1085 </span>
1086   // find or create resolved member name
1087   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1088 
1089   static bool is_instance(oop resolved_method);
1090 };
1091 
1092 
1093 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1094   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1095 
1096 
1097 class java_lang_invoke_MemberName: AllStatic {
1098   friend class JavaClasses;
1099 
1100  private:
1101   // From java.lang.invoke.MemberName:
1102   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1103   //    private String     name;        // may be null if not yet materialized
1104   //    private Object     type;        // may be null if not yet materialized
1105   //    private int        flags;       // modifier bits; see reflect.Modifier
</pre>
<hr />
<pre>
1174   friend class JavaClasses;
1175 
1176  private:
1177   static int _rtype_offset;
1178   static int _ptypes_offset;
1179 
1180   static void compute_offsets();
1181 
1182  public:
1183   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1184   // Accessors
1185   static oop            rtype(oop mt);
1186   static objArrayOop    ptypes(oop mt);
1187 
1188   static oop            ptype(oop mt, int index);
1189   static int            ptype_count(oop mt);
1190 
1191   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1192   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1193 
<span class="line-modified">1194   static Symbol*        as_signature(oop mt, bool intern_if_not_found);</span>
1195   static void           print_signature(oop mt, outputStream* st);
1196 
1197   static bool is_instance(oop obj);
1198 
1199   static bool equals(oop mt1, oop mt2);
1200 
1201   // Accessors for code generation:
1202   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1203   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1204 };
1205 
1206 
1207 // Interface to java.lang.invoke.CallSite objects
1208 
1209 class java_lang_invoke_CallSite: AllStatic {
1210   friend class JavaClasses;
1211 
1212 private:
1213   static int _target_offset;
1214   static int _context_offset;
</pre>
<hr />
<pre>
1217 
1218 public:
1219   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1220   // Accessors
1221   static oop              target(          oop site);
1222   static void         set_target(          oop site, oop target);
1223   static void         set_target_volatile( oop site, oop target);
1224 
1225   static oop context_no_keepalive(oop site);
1226 
1227   // Testers
1228   static bool is_subclass(Klass* klass) {
1229     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1230   }
1231   static bool is_instance(oop obj);
1232 
1233   // Accessors for code generation:
1234   static int target_offset_in_bytes()           { return _target_offset; }
1235 };
1236 
<span class="line-added">1237 // Interface to java.lang.invoke.ConstantCallSite objects</span>
<span class="line-added">1238 </span>
<span class="line-added">1239 class java_lang_invoke_ConstantCallSite: AllStatic {</span>
<span class="line-added">1240   friend class JavaClasses;</span>
<span class="line-added">1241 </span>
<span class="line-added">1242 private:</span>
<span class="line-added">1243   static int _is_frozen_offset;</span>
<span class="line-added">1244 </span>
<span class="line-added">1245   static void compute_offsets();</span>
<span class="line-added">1246 </span>
<span class="line-added">1247 public:</span>
<span class="line-added">1248   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1249   // Accessors</span>
<span class="line-added">1250   static jboolean is_frozen(oop site);</span>
<span class="line-added">1251 </span>
<span class="line-added">1252   // Testers</span>
<span class="line-added">1253   static bool is_subclass(Klass* klass) {</span>
<span class="line-added">1254     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());</span>
<span class="line-added">1255   }</span>
<span class="line-added">1256   static bool is_instance(oop obj);</span>
<span class="line-added">1257 };</span>
<span class="line-added">1258 </span>
1259 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1260 
1261 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1262   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1263   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1264 
1265 class DependencyContext;
1266 
1267 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1268   friend class JavaClasses;
1269 
1270 private:
1271   static int _vmdependencies_offset;
1272   static int _last_cleanup_offset;
1273 
1274   static void compute_offsets();
1275 
1276 public:
1277   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1278   // Accessors
</pre>
<hr />
<pre>
1388  private:
1389   static int declaringClassObject_offset;
1390   static int classLoaderName_offset;
1391   static int moduleName_offset;
1392   static int moduleVersion_offset;
1393   static int declaringClass_offset;
1394   static int methodName_offset;
1395   static int fileName_offset;
1396   static int lineNumber_offset;
1397 
1398   // Setters
1399   static void set_classLoaderName(oop element, oop value);
1400   static void set_moduleName(oop element, oop value);
1401   static void set_moduleVersion(oop element, oop value);
1402   static void set_declaringClass(oop element, oop value);
1403   static void set_methodName(oop element, oop value);
1404   static void set_fileName(oop element, oop value);
1405   static void set_lineNumber(oop element, int value);
1406   static void set_declaringClassObject(oop element, oop value);
1407 
<span class="line-added">1408   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,</span>
<span class="line-added">1409                                    const methodHandle&amp; method, int bci,</span>
<span class="line-added">1410                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);</span>
<span class="line-added">1411 </span>
1412  public:
1413   // Create an instance of StackTraceElement
1414   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1415 
1416   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1417                       int version, int bci, Symbol* name, TRAPS);
1418 
1419   static void compute_offsets();
1420   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1421 
<span class="line-added">1422 #if INCLUDE_JVMCI</span>
<span class="line-added">1423   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);</span>
<span class="line-added">1424 #endif</span>
<span class="line-added">1425 </span>
1426   // Debugging
1427   friend class JavaClasses;
1428 };
1429 
1430 
1431 class Backtrace: AllStatic {
1432  public:
1433   // Helper backtrace functions to store bci|version together.
1434   static int merge_bci_and_version(int bci, int version);
1435   static int merge_mid_and_cpref(int mid, int cpref);
1436   static int bci_at(unsigned int merged);
1437   static int version_at(unsigned int merged);
1438   static int mid_at(unsigned int merged);
1439   static int cpref_at(unsigned int merged);
<span class="line-modified">1440   static int get_line_number(Method* method, int bci);</span>
1441   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1442 
1443   // Debugging
1444   friend class JavaClasses;
1445 };
1446 
1447 // Interface to java.lang.StackFrameInfo objects
1448 
1449 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1450   macro(java_lang_StackFrameInfo, version, short_signature, false)
1451 
1452 class java_lang_StackFrameInfo: AllStatic {
1453 private:
1454   static int _memberName_offset;
1455   static int _bci_offset;
1456   static int _version_offset;
1457 
1458   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1459 
1460 public:
</pre>
<hr />
<pre>
1476 class java_lang_LiveStackFrameInfo: AllStatic {
1477  private:
1478   static int _monitors_offset;
1479   static int _locals_offset;
1480   static int _operands_offset;
1481   static int _mode_offset;
1482 
1483  public:
1484   static void set_monitors(oop info, oop value);
1485   static void set_locals(oop info, oop value);
1486   static void set_operands(oop info, oop value);
1487   static void set_mode(oop info, int value);
1488 
1489   static void compute_offsets();
1490   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1491 
1492   // Debugging
1493   friend class JavaClasses;
1494 };
1495 
<span class="line-added">1496 // Interface to java.lang.reflect.RecordComponent objects</span>
<span class="line-added">1497 </span>
<span class="line-added">1498 class java_lang_reflect_RecordComponent: AllStatic {</span>
<span class="line-added">1499  private:</span>
<span class="line-added">1500   static int clazz_offset;</span>
<span class="line-added">1501   static int name_offset;</span>
<span class="line-added">1502   static int type_offset;</span>
<span class="line-added">1503   static int accessor_offset;</span>
<span class="line-added">1504   static int signature_offset;</span>
<span class="line-added">1505   static int annotations_offset;</span>
<span class="line-added">1506   static int typeAnnotations_offset;</span>
<span class="line-added">1507 </span>
<span class="line-added">1508   // Setters</span>
<span class="line-added">1509   static void set_clazz(oop element, oop value);</span>
<span class="line-added">1510   static void set_name(oop element, oop value);</span>
<span class="line-added">1511   static void set_type(oop element, oop value);</span>
<span class="line-added">1512   static void set_accessor(oop element, oop value);</span>
<span class="line-added">1513   static void set_signature(oop element, oop value);</span>
<span class="line-added">1514   static void set_annotations(oop element, oop value);</span>
<span class="line-added">1515   static void set_typeAnnotations(oop element, oop value);</span>
<span class="line-added">1516 </span>
<span class="line-added">1517  public:</span>
<span class="line-added">1518   // Create an instance of RecordComponent</span>
<span class="line-added">1519   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);</span>
<span class="line-added">1520 </span>
<span class="line-added">1521   static void compute_offsets();</span>
<span class="line-added">1522   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1523 </span>
<span class="line-added">1524   // Debugging</span>
<span class="line-added">1525   friend class JavaClasses;</span>
<span class="line-added">1526 };</span>
<span class="line-added">1527 </span>
<span class="line-added">1528 </span>
1529 // Interface to java.lang.AssertionStatusDirectives objects
1530 
1531 class java_lang_AssertionStatusDirectives: AllStatic {
1532  private:
1533   static int classes_offset;
1534   static int classEnabled_offset;
1535   static int packages_offset;
1536   static int packageEnabled_offset;
1537   static int deflt_offset;
1538 
1539  public:
1540   // Setters
1541   static void set_classes(oop obj, oop val);
1542   static void set_classEnabled(oop obj, oop val);
1543   static void set_packages(oop obj, oop val);
1544   static void set_packageEnabled(oop obj, oop val);
1545   static void set_deflt(oop obj, bool val);
1546 
1547   static void compute_offsets();
1548   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
</pre>
<hr />
<pre>
1554 
1555 class java_nio_Buffer: AllStatic {
1556  private:
1557   static int _limit_offset;
1558 
1559  public:
1560   static int  limit_offset();
1561   static void compute_offsets();
1562   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1563 };
1564 
1565 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1566  private:
1567   static int  _owner_offset;
1568  public:
1569   static void compute_offsets();
1570   static oop  get_owner_threadObj(oop obj);
1571   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1572 };
1573 
<span class="line-added">1574  // Interface to jdk.internal.misc.UnsafeConsants</span>
<span class="line-added">1575 </span>
<span class="line-added">1576 class jdk_internal_misc_UnsafeConstants : AllStatic {</span>
<span class="line-added">1577  public:</span>
<span class="line-added">1578   static void set_unsafe_constants();</span>
<span class="line-added">1579   static void compute_offsets() { }</span>
<span class="line-added">1580   static void serialize_offsets(SerializeClosure* f) { }</span>
<span class="line-added">1581 };</span>
<span class="line-added">1582 </span>
<span class="line-added">1583 class java_lang_Integer : AllStatic {</span>
<span class="line-added">1584 public:</span>
<span class="line-added">1585   static jint value(oop obj);</span>
<span class="line-added">1586 };</span>
<span class="line-added">1587 </span>
<span class="line-added">1588 class java_lang_Long : AllStatic {</span>
<span class="line-added">1589 public:</span>
<span class="line-added">1590   static jlong value(oop obj);</span>
<span class="line-added">1591 };</span>
<span class="line-added">1592 </span>
<span class="line-added">1593 class java_lang_Character : AllStatic {</span>
<span class="line-added">1594 public:</span>
<span class="line-added">1595   static jchar value(oop obj);</span>
<span class="line-added">1596 };</span>
<span class="line-added">1597 </span>
<span class="line-added">1598 class java_lang_Short : AllStatic {</span>
<span class="line-added">1599 public:</span>
<span class="line-added">1600   static jshort value(oop obj);</span>
<span class="line-added">1601 };</span>
<span class="line-added">1602 </span>
<span class="line-added">1603 class java_lang_Byte : AllStatic {</span>
<span class="line-added">1604 public:</span>
<span class="line-added">1605   static jbyte value(oop obj);</span>
<span class="line-added">1606 };</span>
<span class="line-added">1607 </span>
<span class="line-added">1608 class java_lang_Boolean : AllStatic {</span>
<span class="line-added">1609  private:</span>
<span class="line-added">1610   static int _static_TRUE_offset;</span>
<span class="line-added">1611   static int _static_FALSE_offset;</span>
<span class="line-added">1612  public:</span>
<span class="line-added">1613   static Symbol* symbol();</span>
<span class="line-added">1614   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1615   static oop  get_TRUE(InstanceKlass *k);</span>
<span class="line-added">1616   static oop  get_FALSE(InstanceKlass *k);</span>
<span class="line-added">1617   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1618   static jboolean value(oop obj);</span>
<span class="line-added">1619 };</span>
<span class="line-added">1620 </span>
<span class="line-added">1621 class java_lang_Integer_IntegerCache : AllStatic {</span>
<span class="line-added">1622  private:</span>
<span class="line-added">1623   static int _static_cache_offset;</span>
<span class="line-added">1624  public:</span>
<span class="line-added">1625   static Symbol* symbol();</span>
<span class="line-added">1626   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1627   static objArrayOop  cache(InstanceKlass *k);</span>
<span class="line-added">1628   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1629 };</span>
<span class="line-added">1630 </span>
<span class="line-added">1631 class java_lang_Long_LongCache : AllStatic {</span>
<span class="line-added">1632  private:</span>
<span class="line-added">1633   static int _static_cache_offset;</span>
<span class="line-added">1634  public:</span>
<span class="line-added">1635   static Symbol* symbol();</span>
<span class="line-added">1636   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1637   static objArrayOop  cache(InstanceKlass *k);</span>
<span class="line-added">1638   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1639 };</span>
<span class="line-added">1640 </span>
<span class="line-added">1641 class java_lang_Character_CharacterCache : AllStatic {</span>
<span class="line-added">1642  private:</span>
<span class="line-added">1643   static int _static_cache_offset;</span>
<span class="line-added">1644  public:</span>
<span class="line-added">1645   static Symbol* symbol();</span>
<span class="line-added">1646   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1647   static objArrayOop  cache(InstanceKlass *k);</span>
<span class="line-added">1648   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1649 };</span>
<span class="line-added">1650 </span>
<span class="line-added">1651 class java_lang_Short_ShortCache : AllStatic {</span>
<span class="line-added">1652  private:</span>
<span class="line-added">1653   static int _static_cache_offset;</span>
<span class="line-added">1654  public:</span>
<span class="line-added">1655   static Symbol* symbol();</span>
<span class="line-added">1656   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1657   static objArrayOop  cache(InstanceKlass *k);</span>
<span class="line-added">1658   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1659 };</span>
<span class="line-added">1660 </span>
<span class="line-added">1661 class java_lang_Byte_ByteCache : AllStatic {</span>
<span class="line-added">1662  private:</span>
<span class="line-added">1663   static int _static_cache_offset;</span>
<span class="line-added">1664  public:</span>
<span class="line-added">1665   static Symbol* symbol();</span>
<span class="line-added">1666   static void compute_offsets(InstanceKlass* k);</span>
<span class="line-added">1667   static objArrayOop  cache(InstanceKlass *k);</span>
<span class="line-added">1668   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1669 };</span>
<span class="line-added">1670 </span>
1671 // Use to declare fields that need to be injected into Java classes
1672 // for the JVM to use.  The name_index and signature_index are
1673 // declared in vmSymbols.  The may_be_java flag is used to declare
1674 // fields that might already exist in Java but should be injected if
1675 // they don&#39;t.  Otherwise the field is unconditionally injected and
1676 // the JVM uses the injected one.  This is to ensure that name
1677 // collisions don&#39;t occur.  In general may_be_java should be false
1678 // unless there&#39;s a good reason.
1679 
1680 class InjectedField {
1681  public:
1682   const SystemDictionary::WKID klass_id;
1683   const vmSymbols::SID name_index;
1684   const vmSymbols::SID signature_index;
1685   const bool           may_be_java;
1686 
1687 
1688   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1689   Symbol* name() const      { return lookup_symbol(name_index); }
1690   Symbol* signature() const { return lookup_symbol(signature_index); }
</pre>
<hr />
<pre>
1713 
1714 class JavaClasses : AllStatic {
1715  private:
1716 
1717   static InjectedField _injected_fields[];
1718 
1719   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1720  public:
1721   enum InjectedFieldID {
1722     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1723     MAX_enum
1724   };
1725 
1726   static int compute_injected_offset(InjectedFieldID id);
1727 
1728   static void compute_hard_coded_offsets();
1729   static void compute_offsets();
1730   static void check_offsets() PRODUCT_RETURN;
1731   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1732   static InjectedField* get_injected(Symbol* class_name, int* field_count);
<span class="line-added">1733   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);</span>
1734 };
1735 
1736 #undef DECLARE_INJECTED_FIELD_ENUM
1737 
1738 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
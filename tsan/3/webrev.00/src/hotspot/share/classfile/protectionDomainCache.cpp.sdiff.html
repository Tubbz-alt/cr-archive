<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/protectionDomainCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="placeholders.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="protectionDomainCache.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/protectionDomainCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/weakHandle.inline.hpp&quot;
 36 #include &quot;utilities/hashtable.inline.hpp&quot;
 37 
 38 unsigned int ProtectionDomainCacheTable::compute_hash(Handle protection_domain) {
 39   // Identity hash can safepoint, so keep protection domain in a Handle.
 40   return (unsigned int)(protection_domain-&gt;identity_hash());
 41 }
 42 
 43 int ProtectionDomainCacheTable::index_for(Handle protection_domain) {
 44   return hash_to_index(compute_hash(protection_domain));
 45 }
 46 
 47 ProtectionDomainCacheTable::ProtectionDomainCacheTable(int table_size)
<span class="line-modified"> 48   : Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;(table_size, sizeof(ProtectionDomainCacheEntry))</span>
 49 {   _dead_entries = false;
 50     _total_oops_removed = 0;
 51 }
 52 
 53 void ProtectionDomainCacheTable::trigger_cleanup() {
<span class="line-modified"> 54   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
 55   _dead_entries = true;
 56   Service_lock-&gt;notify_all();
 57 }
 58 
 59 class CleanProtectionDomainEntries : public CLDClosure {
 60   void do_cld(ClassLoaderData* data) {
 61     Dictionary* dictionary = data-&gt;dictionary();
 62     if (dictionary != NULL) {
 63       dictionary-&gt;clean_cached_protection_domains();
 64     }
 65   }
 66 };
 67 
 68 void ProtectionDomainCacheTable::unlink() {
 69   {
 70     // First clean cached pd lists in loaded CLDs
 71     // It&#39;s unlikely, but some loaded classes in a dictionary might
 72     // point to a protection_domain that has been unloaded.
 73     // The dictionary pd_set points at entries in the ProtectionDomainCacheTable.
 74     MutexLocker ml(ClassLoaderDataGraph_lock);
</pre>
<hr />
<pre>
143 void ProtectionDomainCacheEntry::verify() {
144   guarantee(object_no_keepalive() == NULL || oopDesc::is_oop(object_no_keepalive()), &quot;must be an oop&quot;);
145 }
146 
147 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::get(Handle protection_domain) {
148   unsigned int hash = compute_hash(protection_domain);
149   int index = hash_to_index(hash);
150 
151   ProtectionDomainCacheEntry* entry = find_entry(index, protection_domain);
152   if (entry == NULL) {
153     entry = add_entry(index, hash, protection_domain);
154   }
155   // keep entry alive
156   (void)entry-&gt;object();
157   return entry;
158 }
159 
160 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::find_entry(int index, Handle protection_domain) {
161   assert_locked_or_safepoint(SystemDictionary_lock);
162   for (ProtectionDomainCacheEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
<span class="line-modified">163     if (oopDesc::equals(e-&gt;object_no_keepalive(), protection_domain())) {</span>
164       return e;
165     }
166   }
167 
168   return NULL;
169 }
170 
171 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::add_entry(int index, unsigned int hash, Handle protection_domain) {
172   assert_locked_or_safepoint(SystemDictionary_lock);
173   assert(index == index_for(protection_domain), &quot;incorrect index?&quot;);
174   assert(find_entry(index, protection_domain) == NULL, &quot;no double entry&quot;);
175 
176   LogTarget(Debug, protectiondomain, table) lt;
177   if (lt.is_enabled()) {
178     LogStream ls(lt);
179     ls.print(&quot;protection domain added &quot;);
180     protection_domain-&gt;print_value_on(&amp;ls);
181     ls.cr();
182   }
<span class="line-modified">183   ClassLoaderWeakHandle w = ClassLoaderWeakHandle::create(protection_domain);</span>
184   ProtectionDomainCacheEntry* p = new_entry(hash, w);
<span class="line-modified">185   Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;::add_entry(index, p);</span>
186   return p;
187 }
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/weakHandle.inline.hpp&quot;
 36 #include &quot;utilities/hashtable.inline.hpp&quot;
 37 
 38 unsigned int ProtectionDomainCacheTable::compute_hash(Handle protection_domain) {
 39   // Identity hash can safepoint, so keep protection domain in a Handle.
 40   return (unsigned int)(protection_domain-&gt;identity_hash());
 41 }
 42 
 43 int ProtectionDomainCacheTable::index_for(Handle protection_domain) {
 44   return hash_to_index(compute_hash(protection_domain));
 45 }
 46 
 47 ProtectionDomainCacheTable::ProtectionDomainCacheTable(int table_size)
<span class="line-modified"> 48   : Hashtable&lt;WeakHandle&lt;vm_class_loader_data&gt;, mtClass&gt;(table_size, sizeof(ProtectionDomainCacheEntry))</span>
 49 {   _dead_entries = false;
 50     _total_oops_removed = 0;
 51 }
 52 
 53 void ProtectionDomainCacheTable::trigger_cleanup() {
<span class="line-modified"> 54   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
 55   _dead_entries = true;
 56   Service_lock-&gt;notify_all();
 57 }
 58 
 59 class CleanProtectionDomainEntries : public CLDClosure {
 60   void do_cld(ClassLoaderData* data) {
 61     Dictionary* dictionary = data-&gt;dictionary();
 62     if (dictionary != NULL) {
 63       dictionary-&gt;clean_cached_protection_domains();
 64     }
 65   }
 66 };
 67 
 68 void ProtectionDomainCacheTable::unlink() {
 69   {
 70     // First clean cached pd lists in loaded CLDs
 71     // It&#39;s unlikely, but some loaded classes in a dictionary might
 72     // point to a protection_domain that has been unloaded.
 73     // The dictionary pd_set points at entries in the ProtectionDomainCacheTable.
 74     MutexLocker ml(ClassLoaderDataGraph_lock);
</pre>
<hr />
<pre>
143 void ProtectionDomainCacheEntry::verify() {
144   guarantee(object_no_keepalive() == NULL || oopDesc::is_oop(object_no_keepalive()), &quot;must be an oop&quot;);
145 }
146 
147 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::get(Handle protection_domain) {
148   unsigned int hash = compute_hash(protection_domain);
149   int index = hash_to_index(hash);
150 
151   ProtectionDomainCacheEntry* entry = find_entry(index, protection_domain);
152   if (entry == NULL) {
153     entry = add_entry(index, hash, protection_domain);
154   }
155   // keep entry alive
156   (void)entry-&gt;object();
157   return entry;
158 }
159 
160 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::find_entry(int index, Handle protection_domain) {
161   assert_locked_or_safepoint(SystemDictionary_lock);
162   for (ProtectionDomainCacheEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
<span class="line-modified">163     if (e-&gt;object_no_keepalive() == protection_domain()) {</span>
164       return e;
165     }
166   }
167 
168   return NULL;
169 }
170 
171 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::add_entry(int index, unsigned int hash, Handle protection_domain) {
172   assert_locked_or_safepoint(SystemDictionary_lock);
173   assert(index == index_for(protection_domain), &quot;incorrect index?&quot;);
174   assert(find_entry(index, protection_domain) == NULL, &quot;no double entry&quot;);
175 
176   LogTarget(Debug, protectiondomain, table) lt;
177   if (lt.is_enabled()) {
178     LogStream ls(lt);
179     ls.print(&quot;protection domain added &quot;);
180     protection_domain-&gt;print_value_on(&amp;ls);
181     ls.cr();
182   }
<span class="line-modified">183   WeakHandle&lt;vm_class_loader_data&gt; w = WeakHandle&lt;vm_class_loader_data&gt;::create(protection_domain);</span>
184   ProtectionDomainCacheEntry* p = new_entry(hash, w);
<span class="line-modified">185   Hashtable&lt;WeakHandle&lt;vm_class_loader_data&gt;, mtClass&gt;::add_entry(index, p);</span>
186   return p;
187 }
</pre>
</td>
</tr>
</table>
<center><a href="placeholders.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="protectionDomainCache.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
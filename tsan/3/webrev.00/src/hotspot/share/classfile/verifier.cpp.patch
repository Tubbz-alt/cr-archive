diff a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -23,33 +23,35 @@
  */
 
 #include "precompiled.hpp"
 #include "jvm.h"
 #include "classfile/classFileStream.hpp"
+#include "classfile/classLoader.hpp"
 #include "classfile/javaClasses.hpp"
 #include "classfile/stackMapTable.hpp"
 #include "classfile/stackMapFrame.hpp"
 #include "classfile/stackMapTableFormat.hpp"
+#include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/verifier.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "interpreter/bytecodes.hpp"
 #include "interpreter/bytecodeStream.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "oops/constantPool.inline.hpp"
 #include "oops/instanceKlass.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.hpp"
 #include "runtime/fieldDescriptor.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/jniHandles.inline.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/os.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/thread.hpp"
 #include "services/threadService.hpp"
 #include "utilities/align.hpp"
@@ -58,33 +60,43 @@
 #define NOFAILOVER_MAJOR_VERSION                       51
 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
 #define MAX_ARRAY_DIMENSIONS 255
 
-// Access to external entry for VerifyClassCodes - old byte code verifier
+// Access to external entry for VerifyClassForMajorVersion - old byte code verifier
 
 extern "C" {
-  typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint);
-  typedef jboolean (*verify_byte_codes_fn_new_t)(JNIEnv *, jclass, char *, jint, jint);
+  typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
 }
 
-static void* volatile _verify_byte_codes_fn = NULL;
+static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
 
-static volatile jint _is_new_verify_byte_codes_fn = (jint) true;
+static verify_byte_codes_fn_t verify_byte_codes_fn() {
 
-static void* verify_byte_codes_fn() {
-  if (OrderAccess::load_acquire(&_verify_byte_codes_fn) == NULL) {
-    void *lib_handle = os::native_java_library();
-    void *func = os::dll_lookup(lib_handle, "VerifyClassCodesForMajorVersion");
-    OrderAccess::release_store(&_verify_byte_codes_fn, func);
-    if (func == NULL) {
-      _is_new_verify_byte_codes_fn = false;
-      func = os::dll_lookup(lib_handle, "VerifyClassCodes");
-      OrderAccess::release_store(&_verify_byte_codes_fn, func);
-    }
-  }
-  return (void*)_verify_byte_codes_fn;
+  if (_verify_byte_codes_fn != NULL)
+    return _verify_byte_codes_fn;
+
+  MutexLocker locker(Verify_lock);
+
+  if (_verify_byte_codes_fn != NULL)
+    return _verify_byte_codes_fn;
+
+  // Load verify dll
+  char buffer[JVM_MAXPATHLEN];
+  char ebuf[1024];
+  if (!os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(), "verify"))
+    return NULL; // Caller will throw VerifyError
+
+  void *lib_handle = os::dll_load(buffer, ebuf, sizeof(ebuf));
+  if (lib_handle == NULL)
+    return NULL; // Caller will throw VerifyError
+
+  void *fn = os::dll_lookup(lib_handle, "VerifyClassForMajorVersion");
+  if (fn == NULL)
+    return NULL; // Caller will throw VerifyError
+
+  return _verify_byte_codes_fn = CAST_TO_FN_PTR(verify_byte_codes_fn_t, fn);
 }
 
 
 // Methods in Verifier
 
@@ -160,26 +172,32 @@
                            jt->get_thread_stat()->perf_recursion_counts_addr(),
                            jt->get_thread_stat()->perf_timers_addr(),
                            PerfClassTraceTime::CLASS_VERIFY);
 
   // If the class should be verified, first see if we can use the split
-  // verifier.  If not, or if verification fails and FailOverToOldVerifier
-  // is set, then call the inference verifier.
+  // verifier.  If not, or if verification fails and can failover, then
+  // call the inference verifier.
   Symbol* exception_name = NULL;
   const size_t message_buffer_len = klass->name()->utf8_length() + 1024;
   char* message_buffer = NULL;
   char* exception_message = NULL;
 
-  bool can_failover = FailOverToOldVerifier &&
-     klass->major_version() < NOFAILOVER_MAJOR_VERSION;
-
   log_info(class, init)("Start class verification for: %s", klass->external_name());
   if (klass->major_version() >= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
     ClassVerifier split_verifier(klass, THREAD);
     split_verifier.verify_class(THREAD);
     exception_name = split_verifier.result();
-    if (can_failover && !HAS_PENDING_EXCEPTION &&
+
+    // If DumpSharedSpaces is set then don't fall back to the old verifier on
+    // verification failure. If a class fails verification with the split verifier,
+    // it might fail the CDS runtime verifier constraint check. In that case, we
+    // don't want to share the class. We only archive classes that pass the split
+    // verifier.
+    bool can_failover = !DumpSharedSpaces &&
+      klass->major_version() < NOFAILOVER_MAJOR_VERSION;
+
+    if (can_failover && !HAS_PENDING_EXCEPTION &&  // Split verifier doesn't set PENDING_EXCEPTION for failure
         (exception_name == vmSymbols::java_lang_VerifyError() ||
          exception_name == vmSymbols::java_lang_ClassFormatError())) {
       log_info(verification)("Fail over class verification to old verifier for: %s", klass->external_name());
       log_info(class, init)("Fail over class verification to old verifier for: %s", klass->external_name());
       message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
@@ -271,11 +289,11 @@
 Symbol* Verifier::inference_verify(
     InstanceKlass* klass, char* message, size_t message_len, TRAPS) {
   JavaThread* thread = (JavaThread*)THREAD;
   JNIEnv *env = thread->jni_environment();
 
-  void* verify_func = verify_byte_codes_fn();
+  verify_byte_codes_fn_t verify_func = verify_byte_codes_fn();
 
   if (verify_func == NULL) {
     jio_snprintf(message, message_len, "Could not link verifier");
     return vmSymbols::java_lang_VerifyError();
   }
@@ -290,20 +308,11 @@
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
     // code knows that we have left the VM
 
-    if (_is_new_verify_byte_codes_fn) {
-      verify_byte_codes_fn_new_t func =
-        CAST_TO_FN_PTR(verify_byte_codes_fn_new_t, verify_func);
-      result = (*func)(env, cls, message, (int)message_len,
-          klass->major_version());
-    } else {
-      verify_byte_codes_fn_t func =
-        CAST_TO_FN_PTR(verify_byte_codes_fn_t, verify_func);
-      result = (*func)(env, cls, message, (int)message_len);
-    }
+    result = (*verify_func)(env, cls, message, (int)message_len, klass->major_version());
   }
 
   JNIHandles::destroy_local(cls);
 
   // These numbers are chosen so that VerifyClassCodes interface doesn't need
@@ -572,11 +581,11 @@
 // Methods in ClassVerifier
 
 ClassVerifier::ClassVerifier(
     InstanceKlass* klass, TRAPS)
     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
-      _message(NULL), _klass(klass) {
+      _message(NULL), _method_signatures_table(NULL), _klass(klass) {
   _this_type = VerificationType::reference_type(klass->name());
 }
 
 ClassVerifier::~ClassVerifier() {
   // Decrement the reference count for any symbols created.
@@ -590,19 +599,26 @@
 
 VerificationType ClassVerifier::object_type() const {
   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 }
 
-TypeOrigin ClassVerifier::ref_ctx(const char* sig, TRAPS) {
+TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
   VerificationType vt = VerificationType::reference_type(
-      create_temporary_symbol(sig, (int)strlen(sig), THREAD));
+                         create_temporary_symbol(sig, (int)strlen(sig)));
   return TypeOrigin::implicit(vt);
 }
 
 void ClassVerifier::verify_class(TRAPS) {
   log_info(verification)("Verifying class %s with new format", _klass->external_name());
 
+  // Either verifying both local and remote classes or just remote classes.
+  assert(BytecodeVerificationRemote, "Should not be here");
+
+  // Create hash table containing method signatures.
+  method_signatures_table_type method_signatures_table;
+  set_method_signatures_table(&method_signatures_table);
+
   Array<Method*>* methods = _klass->methods();
   int num_methods = methods->length();
 
   for (int index = 0; index < num_methods; index++) {
     // Check for recursive re-verification before each method.
@@ -623,10 +639,59 @@
     log_info(class, init)("Recursive verification detected for: %s",
                         _klass->external_name());
   }
 }
 
+// Translate the signature entries into verification types and save them in
+// the growable array.  Also, save the count of arguments.
+void ClassVerifier::translate_signature(Symbol* const method_sig,
+                                        sig_as_verification_types* sig_verif_types,
+                                        TRAPS) {
+  SignatureStream sig_stream(method_sig);
+  VerificationType sig_type[2];
+  int sig_i = 0;
+  GrowableArray<VerificationType>* verif_types = sig_verif_types->sig_verif_types();
+
+  // Translate the signature arguments into verification types.
+  while (!sig_stream.at_return_type()) {
+    int n = change_sig_to_verificationType(&sig_stream, sig_type);
+    assert(n <= 2, "Unexpected signature type");
+
+    // Store verification type(s).  Longs and Doubles each have two verificationTypes.
+    for (int x = 0; x < n; x++) {
+      verif_types->push(sig_type[x]);
+    }
+    sig_i += n;
+    sig_stream.next();
+  }
+
+  // Set final arg count, not including the return type.  The final arg count will
+  // be compared with sig_verify_types' length to see if there is a return type.
+  sig_verif_types->set_num_args(sig_i);
+
+  // Store verification type(s) for the return type, if there is one.
+  if (sig_stream.type() != T_VOID) {
+    int n = change_sig_to_verificationType(&sig_stream, sig_type);
+    assert(n <= 2, "Unexpected signature return type");
+    for (int y = 0; y < n; y++) {
+      verif_types->push(sig_type[y]);
+    }
+  }
+}
+
+void ClassVerifier::create_method_sig_entry(sig_as_verification_types* sig_verif_types,
+                                            int sig_index, TRAPS) {
+  // Translate the signature into verification types.
+  ConstantPool* cp = _klass->constants();
+  Symbol* const method_sig = cp->symbol_at(sig_index);
+  translate_signature(method_sig, sig_verif_types, CHECK_VERIFY(this));
+
+  // Add the list of this signature's verification types to the table.
+  bool is_unique = method_signatures_table()->put(sig_index, sig_verif_types);
+  assert(is_unique, "Duplicate entries in method_signature_table");
+}
+
 void ClassVerifier::verify_method(const methodHandle& m, TRAPS) {
   HandleMark hm(THREAD);
   _method = m;   // initialize _method
   log_info(verification)("Verifying method %s", m->name_and_sig_as_C_string());
 
@@ -672,11 +737,11 @@
   StackMapStream stream(stackmap_data);
   StackMapReader reader(this, &stream, code_data, code_length, THREAD);
   StackMapTable stackmap_table(&reader, &current_frame, max_locals, max_stack,
                                code_data, code_length, CHECK_VERIFY(this));
 
-  LogTarget(Info, verification) lt;
+  LogTarget(Debug, verification) lt;
   if (lt.is_enabled()) {
     ResourceMark rm(THREAD);
     LogStream ls(lt);
     stackmap_table.print_on(&ls);
   }
@@ -716,11 +781,11 @@
       u2 index;
       int target;
       VerificationType type, type2;
       VerificationType atype;
 
-      LogTarget(Info, verification) lt;
+      LogTarget(Debug, verification) lt;
       if (lt.is_enabled()) {
         ResourceMark rm(THREAD);
         LogStream ls(lt);
         current_frame.print_on(&ls);
         lt.print("offset = %d,  opcode = %s", bci,
@@ -864,11 +929,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_int_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[I", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[I")),
                 bad_type_msg, "iaload");
             return;
           }
           current_frame.push_stack(
             VerificationType::integer_type(), CHECK_VERIFY(this));
@@ -892,11 +957,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_char_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[C", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[C")),
                 bad_type_msg, "caload");
             return;
           }
           current_frame.push_stack(
             VerificationType::integer_type(), CHECK_VERIFY(this));
@@ -906,11 +971,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_short_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[S", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[S")),
                 bad_type_msg, "saload");
             return;
           }
           current_frame.push_stack(
             VerificationType::integer_type(), CHECK_VERIFY(this));
@@ -920,11 +985,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_long_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[J", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[J")),
                 bad_type_msg, "laload");
             return;
           }
           current_frame.push_stack_2(
             VerificationType::long_type(),
@@ -935,11 +1000,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_float_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[F", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[F")),
                 bad_type_msg, "faload");
             return;
           }
           current_frame.push_stack(
             VerificationType::float_type(), CHECK_VERIFY(this));
@@ -949,11 +1014,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_double_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[D", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[D")),
                 bad_type_msg, "daload");
             return;
           }
           current_frame.push_stack_2(
             VerificationType::double_type(),
@@ -1038,11 +1103,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_int_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[I", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[I")),
                 bad_type_msg, "iastore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_bastore :
@@ -1066,11 +1131,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_char_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[C", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[C")),
                 bad_type_msg, "castore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_sastore :
@@ -1080,11 +1145,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_short_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[S", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[S")),
                 bad_type_msg, "sastore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_lastore :
@@ -1095,11 +1160,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_long_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[J", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[J")),
                 bad_type_msg, "lastore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_fastore :
@@ -1109,11 +1174,11 @@
             (VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_float_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[F", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[F")),
                 bad_type_msg, "fastore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_dastore :
@@ -1124,11 +1189,11 @@
             VerificationType::integer_type(), CHECK_VERIFY(this));
           atype = current_frame.pop_stack(
             VerificationType::reference_check(), CHECK_VERIFY(this));
           if (!atype.is_double_array()) {
             verify_error(ErrorContext::bad_type(bci,
-                current_frame.stack_top_ctx(), ref_ctx("[D", THREAD)),
+                current_frame.stack_top_ctx(), ref_ctx("[D")),
                 bad_type_msg, "dastore");
             return;
           }
           no_control_flow = false; break;
         case Bytecodes::_aastore :
@@ -2001,11 +2066,13 @@
   va_list va;
   va_start(va, msg);
   ss.vprint(msg, va);
   va_end(va);
   if (!_method.is_null()) {
-    ss.print(" in method %s", _method->name_and_sig_as_C_string());
+    ss.print(" in method '");
+    _method->print_external_name(&ss);
+    ss.print("'");
   }
   _message = ss.as_string();
 }
 
 Klass* ClassVerifier::load_class(Symbol* name, TRAPS) {
@@ -2120,12 +2187,11 @@
     assert(sizeof(VerificationType) == sizeof(uintptr_t),
           "buffer type must match VerificationType size");
     uintptr_t constant_type_buffer[2];
     VerificationType* v_constant_type = (VerificationType*)constant_type_buffer;
     SignatureStream sig_stream(constant_type, false);
-    int n = change_sig_to_verificationType(
-      &sig_stream, v_constant_type, CHECK_VERIFY(this));
+    int n = change_sig_to_verificationType(&sig_stream, v_constant_type);
     int opcode_n = (opcode == Bytecodes::_ldc2_w ? 2 : 1);
     if (n != opcode_n) {
       // wrong kind of ldc; reverify against updated type mask
       types &= ~(1 << JVM_CONSTANT_Dynamic);
       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
@@ -2262,12 +2328,11 @@
   // stack allocating it.  Plus it would run constructors.  This shows up
   // in performance profiles.
 
   SignatureStream sig_stream(field_sig, false);
   VerificationType stack_object_type;
-  int n = change_sig_to_verificationType(
-    &sig_stream, field_type, CHECK_VERIFY(this));
+  int n = change_sig_to_verificationType(&sig_stream, field_type);
   u2 bci = bcs->bci();
   bool is_assignable;
   switch (bcs->raw_code()) {
     case Bytecodes::_getstatic: {
       for (int i = 0; i < n; i++) {
@@ -2581,13 +2646,13 @@
         if (bci >= start_pc && bci < end_pc) {
           if (!ends_in_athrow(exhandlers.handler_pc(i))) {
             verify_error(ErrorContext::bad_code(bci),
               "Bad <init> method call from after the start of a try block");
             return;
-          } else if (log_is_enabled(Info, verification)) {
+          } else if (log_is_enabled(Debug, verification)) {
             ResourceMark rm(THREAD);
-            log_info(verification)("Survived call to ends_in_athrow(): %s",
+            log_debug(verification)("Survived call to ends_in_athrow(): %s",
                                           current_class()->name()->as_C_string());
           }
         }
       }
 
@@ -2732,48 +2797,32 @@
     }
   } else {
     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
   }
 
-  // For a small signature length, we just allocate 128 bytes instead
-  // of parsing the signature once to find its size.
-  // -3 is for '(', ')' and return descriptor; multiply by 2 is for
-  // longs/doubles to be consertive.
   assert(sizeof(VerificationType) == sizeof(uintptr_t),
         "buffer type must match VerificationType size");
-  uintptr_t on_stack_sig_types_buffer[128];
-  // If we make a VerificationType[128] array directly, the compiler calls
-  // to the c-runtime library to do the allocation instead of just
-  // stack allocating it.  Plus it would run constructors.  This shows up
-  // in performance profiles.
 
-  VerificationType* sig_types;
-  int size = (method_sig->utf8_length() - 3) * 2;
-  if (size > 128) {
-    // Long and double occupies two slots here.
-    ArgumentSizeComputer size_it(method_sig);
-    size = size_it.size();
-    sig_types = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, VerificationType, size);
-  } else{
-    sig_types = (VerificationType*)on_stack_sig_types_buffer;
-  }
-  SignatureStream sig_stream(method_sig);
-  int sig_i = 0;
-  while (!sig_stream.at_return_type()) {
-    sig_i += change_sig_to_verificationType(
-      &sig_stream, &sig_types[sig_i], CHECK_VERIFY(this));
-    sig_stream.next();
-  }
-  int nargs = sig_i;
+  // Get the UTF8 index for this signature.
+  int sig_index = cp->signature_ref_index_at(cp->name_and_type_ref_index_at(index));
 
-#ifdef ASSERT
-  {
-    ArgumentSizeComputer size_it(method_sig);
-    assert(nargs == size_it.size(), "Argument sizes do not match");
-    assert(nargs <= (method_sig->utf8_length() - 3) * 2, "estimate of max size isn't conservative enough");
+  // Get the signature's verification types.
+  sig_as_verification_types* mth_sig_verif_types;
+  sig_as_verification_types** mth_sig_verif_types_ptr = method_signatures_table()->get(sig_index);
+  if (mth_sig_verif_types_ptr != NULL) {
+    // Found the entry for the signature's verification types in the hash table.
+    mth_sig_verif_types = *mth_sig_verif_types_ptr;
+    assert(mth_sig_verif_types != NULL, "Unexpected NULL sig_as_verification_types value");
+  } else {
+    // Not found, add the entry to the table.
+    GrowableArray<VerificationType>* verif_types = new GrowableArray<VerificationType>(10);
+    mth_sig_verif_types = new sig_as_verification_types(verif_types);
+    create_method_sig_entry(mth_sig_verif_types, sig_index, CHECK_VERIFY(this));
   }
-#endif
+
+  // Get the number of arguments for this signature.
+  int nargs = mth_sig_verif_types->num_args();
 
   // Check instruction operands
   u2 bci = bcs->bci();
   if (opcode == Bytecodes::_invokeinterface) {
     address bcp = bcs->bcp();
@@ -2800,11 +2849,11 @@
           "Third and fourth operand bytes of invokedynamic must be zero");
       return;
     }
   }
 
-  if (method_name->char_at(0) == '<') {
+  if (method_name->char_at(0) == JVM_SIGNATURE_SPECIAL) {
     // Make sure <init> can only be invoked by invokespecial
     if (opcode != Bytecodes::_invokespecial ||
         method_name != vmSymbols::object_initializer_name()) {
       verify_error(ErrorContext::bad_code(bci),
           "Illegal call to internal method");
@@ -2842,14 +2891,20 @@
           "interface method reference is in an indirect superinterface.");
       return;
     }
 
   }
+
+  // Get the verification types for the method's arguments.
+  GrowableArray<VerificationType>* sig_verif_types = mth_sig_verif_types->sig_verif_types();
+  assert(sig_verif_types != NULL, "Missing signature's array of verification types");
   // Match method descriptor with operand stack
-  for (int i = nargs - 1; i >= 0; i--) {  // Run backwards
-    current_frame->pop_stack(sig_types[i], CHECK_VERIFY(this));
+  // The arguments are on the stack in descending order.
+  for (int i = nargs - 1; i >= 0; i--) { // Run backwards
+    current_frame->pop_stack(sig_verif_types->at(i), CHECK_VERIFY(this));
   }
+
   // Check objectref on operand stack
   if (opcode != Bytecodes::_invokestatic &&
       opcode != Bytecodes::_invokedynamic) {
     if (method_name == vmSymbols::object_initializer_name()) {  // <init> method
       verify_invoke_init(bcs, index, ref_class_type, current_frame,
@@ -2917,24 +2972,27 @@
         current_frame->pop_stack(ref_class_type, CHECK_VERIFY(this));
       }
     }
   }
   // Push the result type.
-  if (sig_stream.type() != T_VOID) {
+  int sig_verif_types_len = sig_verif_types->length();
+  if (sig_verif_types_len > nargs) {  // There's a return type
     if (method_name == vmSymbols::object_initializer_name()) {
       // <init> method must have a void return type
       /* Unreachable?  Class file parser verifies that methods with '<' have
        * void return */
       verify_error(ErrorContext::bad_code(bci),
           "Return type must be void in <init> method");
       return;
     }
-    VerificationType return_type[2];
-    int n = change_sig_to_verificationType(
-      &sig_stream, return_type, CHECK_VERIFY(this));
-    for (int i = 0; i < n; i++) {
-      current_frame->push_stack(return_type[i], CHECK_VERIFY(this)); // push types backwards
+
+    assert(sig_verif_types_len <= nargs + 2,
+           "Signature verification types array return type is bogus");
+    for (int i = nargs; i < sig_verif_types_len; i++) {
+      assert(i == nargs || sig_verif_types->at(i).is_long2() ||
+             sig_verif_types->at(i).is_double2(), "Unexpected return verificationType");
+      current_frame->push_stack(sig_verif_types->at(i), CHECK_VERIFY(this));
     }
   }
 }
 
 VerificationType ClassVerifier::get_newarray_type(
@@ -2946,12 +3004,11 @@
     verify_error(ErrorContext::bad_code(bci), "Illegal newarray instruction");
     return VerificationType::bogus_type();
   }
 
   // from_bt[index] contains the array signature which has a length of 2
-  Symbol* sig = create_temporary_symbol(
-    from_bt[index], 2, CHECK_(VerificationType::bogus_type()));
+  Symbol* sig = create_temporary_symbol(from_bt[index], 2);
   return VerificationType::reference_type(sig);
 }
 
 void ClassVerifier::verify_anewarray(
     u2 bci, u2 index, const constantPoolHandle& cp,
@@ -2968,29 +3025,30 @@
   if (component_type.is_array()) {     // it's an array
     const char* component_name = component_type.name()->as_utf8();
     // Check for more than MAX_ARRAY_DIMENSIONS
     length = (int)strlen(component_name);
     if (length > MAX_ARRAY_DIMENSIONS &&
-        component_name[MAX_ARRAY_DIMENSIONS - 1] == '[') {
+        component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
       verify_error(ErrorContext::bad_code(bci),
         "Illegal anewarray instruction, array has more than 255 dimensions");
     }
     // add one dimension to component
     length++;
     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
-    int n = os::snprintf(arr_sig_str, length + 1, "[%s", component_name);
+    int n = os::snprintf(arr_sig_str, length + 1, "%c%s",
+                         JVM_SIGNATURE_ARRAY, component_name);
     assert(n == length, "Unexpected number of characters in string");
   } else {         // it's an object or interface
     const char* component_name = component_type.name()->as_utf8();
     // add one dimension to component with 'L' prepended and ';' postpended.
     length = (int)strlen(component_name) + 3;
     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
-    int n = os::snprintf(arr_sig_str, length + 1, "[L%s;", component_name);
+    int n = os::snprintf(arr_sig_str, length + 1, "%c%c%s;",
+                         JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);
     assert(n == length, "Unexpected number of characters in string");
   }
-  Symbol* arr_sig = create_temporary_symbol(
-    arr_sig_str, length, CHECK_VERIFY(this));
+  Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
   current_frame->push_stack(new_array_type, CHECK_VERIFY(this));
 }
 
 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
@@ -3094,22 +3152,22 @@
 
 // The verifier creates symbols which are substrings of Symbols.
 // These are stored in the verifier until the end of verification so that
 // they can be reference counted.
 Symbol* ClassVerifier::create_temporary_symbol(const Symbol *s, int begin,
-                                               int end, TRAPS) {
+                                               int end) {
   const char* name = (const char*)s->base() + begin;
   int length = end - begin;
-  return create_temporary_symbol(name, length, CHECK_NULL);
+  return create_temporary_symbol(name, length);
 }
 
-Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length, TRAPS) {
+Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length) {
   // Quick deduplication check
   if (_previous_symbol != NULL && _previous_symbol->equals(name, length)) {
     return _previous_symbol;
   }
-  Symbol* sym = SymbolTable::new_symbol(name, length, CHECK_NULL);
+  Symbol* sym = SymbolTable::new_symbol(name, length);
   if (!sym->is_permanent()) {
     if (_symbols == NULL) {
       _symbols = new GrowableArray<Symbol*>(50, 0, NULL);
     }
     _symbols->push(sym);

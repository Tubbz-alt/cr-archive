<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verificationType.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verificationType.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
192     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical &#39;ands&#39;).
193     // Since noone should call this on a query type anyway, this is ok.
194     assert(!is_check(), &quot;Must not be a check type (wrong value returned)&quot;);
195     return ((_u._data &amp; Category1) != Primitive);
196     // should only return false if it&#39;s a primitive, and the category1 flag
197     // is not set.
198   }
199   bool is_category2() const { return ((_u._data &amp; Category2) == Category2); }
200   bool is_category2_2nd() const {
201     return ((_u._data &amp; Category2_2nd) == Category2_2nd);
202   }
203   bool is_reference_check() const { return _u._data == ReferenceQuery; }
204   bool is_category1_check() const { return _u._data == Category1Query; }
205   bool is_category2_check() const { return _u._data == Category2Query; }
206   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
207   bool is_check() const { return (_u._data &amp; TypeQuery) == TypeQuery; }
208 
209   bool is_x_array(char sig) const {
210     return is_null() || (is_array() &amp;&amp; (name()-&gt;char_at(1) == sig));
211   }
<span class="line-modified">212   bool is_int_array() const { return is_x_array(&#39;I&#39;); }</span>
<span class="line-modified">213   bool is_byte_array() const { return is_x_array(&#39;B&#39;); }</span>
<span class="line-modified">214   bool is_bool_array() const { return is_x_array(&#39;Z&#39;); }</span>
<span class="line-modified">215   bool is_char_array() const { return is_x_array(&#39;C&#39;); }</span>
<span class="line-modified">216   bool is_short_array() const { return is_x_array(&#39;S&#39;); }</span>
<span class="line-modified">217   bool is_long_array() const { return is_x_array(&#39;J&#39;); }</span>
<span class="line-modified">218   bool is_float_array() const { return is_x_array(&#39;F&#39;); }</span>
<span class="line-modified">219   bool is_double_array() const { return is_x_array(&#39;D&#39;); }</span>
<span class="line-modified">220   bool is_object_array() const { return is_x_array(&#39;L&#39;); }</span>
<span class="line-modified">221   bool is_array_array() const { return is_x_array(&#39;[&#39;); }</span>
222   bool is_reference_array() const
223     { return is_object_array() || is_array_array(); }
224   bool is_object() const
225     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 1 &amp;&amp;
<span class="line-modified">226               name()-&gt;char_at(0) != &#39;[&#39;); }</span>
227   bool is_array() const
228     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 2 &amp;&amp;
<span class="line-modified">229               name()-&gt;char_at(0) == &#39;[&#39;); }</span>
230   bool is_uninitialized() const
231     { return ((_u._data &amp; Uninitialized) == Uninitialized); }
232   bool is_uninitialized_this() const
233     { return is_uninitialized() &amp;&amp; bci() == BciForThis; }
234 
235   VerificationType to_category2_2nd() const {
236     assert(is_category2(), &quot;Must be a double word&quot;);
237     return VerificationType(is_long() ? Long_2nd : Double_2nd);
238   }
239 
240   u2 bci() const {
241     assert(is_uninitialized(), &quot;Must be uninitialized type&quot;);
242     return ((_u._data &amp; BciMask) &gt;&gt; 1 * BitsPerByte);
243   }
244 
245   Symbol* name() const {
246     assert(is_reference() &amp;&amp; !is_null(), &quot;Must be a non-null reference&quot;);
247     return _u._sym;
248   }
249 
</pre>
<hr />
<pre>
305     if (equals(from) || is_bogus()) {
306       return true;
307     } else {
308       switch(_u._data) {
309         case Boolean:
310         case Byte:
311         case Char:
312         case Short:
313           return false;
314         default:
315           return is_assignable_from(from, context, from_field_is_protected, THREAD);
316       }
317     }
318   }
319 
320   VerificationType get_component(ClassVerifier* context, TRAPS) const;
321 
322   int dimensions() const {
323     assert(is_array(), &quot;Must be an array&quot;);
324     int index = 0;
<span class="line-modified">325     while (name()-&gt;char_at(index) == &#39;[&#39;) index++;</span>
326     return index;
327   }
328 
329   void print_on(outputStream* st) const;
330 
331  private:
332 
333   bool is_reference_assignable_from(
334     const VerificationType&amp;, ClassVerifier*, bool from_field_is_protected,
335     TRAPS) const;
336 
337  public:
338   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
339                                               Symbol* from_name, bool from_field_is_protected,
340                                               bool from_is_array, bool from_is_object,
341                                               TRAPS);
342 };
343 
344 #endif // SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
</pre>
</td>
<td>
<hr />
<pre>
192     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical &#39;ands&#39;).
193     // Since noone should call this on a query type anyway, this is ok.
194     assert(!is_check(), &quot;Must not be a check type (wrong value returned)&quot;);
195     return ((_u._data &amp; Category1) != Primitive);
196     // should only return false if it&#39;s a primitive, and the category1 flag
197     // is not set.
198   }
199   bool is_category2() const { return ((_u._data &amp; Category2) == Category2); }
200   bool is_category2_2nd() const {
201     return ((_u._data &amp; Category2_2nd) == Category2_2nd);
202   }
203   bool is_reference_check() const { return _u._data == ReferenceQuery; }
204   bool is_category1_check() const { return _u._data == Category1Query; }
205   bool is_category2_check() const { return _u._data == Category2Query; }
206   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
207   bool is_check() const { return (_u._data &amp; TypeQuery) == TypeQuery; }
208 
209   bool is_x_array(char sig) const {
210     return is_null() || (is_array() &amp;&amp; (name()-&gt;char_at(1) == sig));
211   }
<span class="line-modified">212   bool is_int_array() const { return is_x_array(JVM_SIGNATURE_INT); }</span>
<span class="line-modified">213   bool is_byte_array() const { return is_x_array(JVM_SIGNATURE_BYTE); }</span>
<span class="line-modified">214   bool is_bool_array() const { return is_x_array(JVM_SIGNATURE_BOOLEAN); }</span>
<span class="line-modified">215   bool is_char_array() const { return is_x_array(JVM_SIGNATURE_CHAR); }</span>
<span class="line-modified">216   bool is_short_array() const { return is_x_array(JVM_SIGNATURE_SHORT); }</span>
<span class="line-modified">217   bool is_long_array() const { return is_x_array(JVM_SIGNATURE_LONG); }</span>
<span class="line-modified">218   bool is_float_array() const { return is_x_array(JVM_SIGNATURE_FLOAT); }</span>
<span class="line-modified">219   bool is_double_array() const { return is_x_array(JVM_SIGNATURE_DOUBLE); }</span>
<span class="line-modified">220   bool is_object_array() const { return is_x_array(JVM_SIGNATURE_CLASS); }</span>
<span class="line-modified">221   bool is_array_array() const { return is_x_array(JVM_SIGNATURE_ARRAY); }</span>
222   bool is_reference_array() const
223     { return is_object_array() || is_array_array(); }
224   bool is_object() const
225     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 1 &amp;&amp;
<span class="line-modified">226               name()-&gt;char_at(0) != JVM_SIGNATURE_ARRAY); }</span>
227   bool is_array() const
228     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 2 &amp;&amp;
<span class="line-modified">229               name()-&gt;char_at(0) == JVM_SIGNATURE_ARRAY); }</span>
230   bool is_uninitialized() const
231     { return ((_u._data &amp; Uninitialized) == Uninitialized); }
232   bool is_uninitialized_this() const
233     { return is_uninitialized() &amp;&amp; bci() == BciForThis; }
234 
235   VerificationType to_category2_2nd() const {
236     assert(is_category2(), &quot;Must be a double word&quot;);
237     return VerificationType(is_long() ? Long_2nd : Double_2nd);
238   }
239 
240   u2 bci() const {
241     assert(is_uninitialized(), &quot;Must be uninitialized type&quot;);
242     return ((_u._data &amp; BciMask) &gt;&gt; 1 * BitsPerByte);
243   }
244 
245   Symbol* name() const {
246     assert(is_reference() &amp;&amp; !is_null(), &quot;Must be a non-null reference&quot;);
247     return _u._sym;
248   }
249 
</pre>
<hr />
<pre>
305     if (equals(from) || is_bogus()) {
306       return true;
307     } else {
308       switch(_u._data) {
309         case Boolean:
310         case Byte:
311         case Char:
312         case Short:
313           return false;
314         default:
315           return is_assignable_from(from, context, from_field_is_protected, THREAD);
316       }
317     }
318   }
319 
320   VerificationType get_component(ClassVerifier* context, TRAPS) const;
321 
322   int dimensions() const {
323     assert(is_array(), &quot;Must be an array&quot;);
324     int index = 0;
<span class="line-modified">325     while (name()-&gt;char_at(index) == JVM_SIGNATURE_ARRAY) index++;</span>
326     return index;
327   }
328 
329   void print_on(outputStream* st) const;
330 
331  private:
332 
333   bool is_reference_assignable_from(
334     const VerificationType&amp;, ClassVerifier*, bool from_field_is_protected,
335     TRAPS) const;
336 
337  public:
338   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
339                                               Symbol* from_name, bool from_field_is_protected,
340                                               bool from_is_array, bool from_is_object,
341                                               TRAPS);
342 };
343 
344 #endif // SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classListParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileStream.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classListParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;jimage.hpp&quot;
 28 #include &quot;classfile/classListParser.hpp&quot;
 29 #include &quot;classfile/classLoaderExt.hpp&quot;
 30 #include &quot;classfile/symbolTable.hpp&quot;
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;classfile/systemDictionaryShared.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;logging/logTag.hpp&quot;
 35 #include &quot;memory/metaspaceShared.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed"> 37 #include &quot;runtime/fieldType.hpp&quot;</span>
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 #include &quot;runtime/javaCalls.hpp&quot;
 40 #include &quot;utilities/defaultStream.hpp&quot;
 41 #include &quot;utilities/hashtable.inline.hpp&quot;
 42 #include &quot;utilities/macros.hpp&quot;
 43 
 44 ClassListParser* ClassListParser::_instance = NULL;
 45 
 46 ClassListParser::ClassListParser(const char* file) {
 47   assert(_instance == NULL, &quot;must be singleton&quot;);
 48   _instance = this;
 49   _classlist_file = file;
 50   _file = NULL;
 51   // Use os::open() because neither fopen() nor os::fopen()
 52   // can handle long path name on Windows.
 53   int fd = os::open(file, O_RDONLY, S_IREAD);
 54   if (fd != -1) {
 55     // Obtain a File* from the file descriptor so that fgets()
 56     // can be used in parse_one_line()
 57     _file = os::open(fd, &quot;r&quot;);
</pre>
<hr />
<pre>
212     if (*value != _unspecified) {
213       error(&quot;%s specified twice&quot;, option_name);
214     } else {
215       parse_int(value);
216       return true;
217     }
218   }
219   return false;
220 }
221 
222 void ClassListParser::print_specified_interfaces() {
223   const int n = _interfaces-&gt;length();
224   jio_fprintf(defaultStream::error_stream(), &quot;Currently specified interfaces[%d] = {\n&quot;, n);
225   for (int i=0; i&lt;n; i++) {
226     InstanceKlass* k = lookup_class_by_id(_interfaces-&gt;at(i));
227     jio_fprintf(defaultStream::error_stream(), &quot;  %4d = %s\n&quot;, _interfaces-&gt;at(i), k-&gt;name()-&gt;as_klass_external_name());
228   }
229   jio_fprintf(defaultStream::error_stream(), &quot;}\n&quot;);
230 }
231 
<span class="line-modified">232 void ClassListParser::print_actual_interfaces(InstanceKlass *ik) {</span>
233   int n = ik-&gt;local_interfaces()-&gt;length();
234   jio_fprintf(defaultStream::error_stream(), &quot;Actual interfaces[%d] = {\n&quot;, n);
235   for (int i = 0; i &lt; n; i++) {
<span class="line-modified">236     InstanceKlass* e = InstanceKlass::cast(ik-&gt;local_interfaces()-&gt;at(i));</span>
237     jio_fprintf(defaultStream::error_stream(), &quot;  %s\n&quot;, e-&gt;name()-&gt;as_klass_external_name());
238   }
239   jio_fprintf(defaultStream::error_stream(), &quot;}\n&quot;);
240 }
241 
<span class="line-modified">242 void ClassListParser::error(const char *msg, ...) {</span>
243   va_list ap;
244   va_start(ap, msg);
245   int error_index = _token - _line;
246   if (error_index &gt;= _line_len) {
247     error_index = _line_len - 1;
248   }
249   if (error_index &lt; 0) {
250     error_index = 0;
251   }
252 
253   jio_fprintf(defaultStream::error_stream(),
254               &quot;An error has occurred while processing class list file %s %d:%d.\n&quot;,
255               _classlist_file, _line_no, (error_index + 1));
256   jio_vfprintf(defaultStream::error_stream(), msg, ap);
257 
258   if (_line_len &lt;= 0) {
259     jio_fprintf(defaultStream::error_stream(), &quot;\n&quot;);
260   } else {
261     jio_fprintf(defaultStream::error_stream(), &quot;:\n&quot;);
262     for (int i=0; i&lt;_line_len; i++) {
</pre>
<hr />
<pre>
278   va_end(ap);
279 }
280 
281 // This function is used for loading classes for customized class loaders
282 // during archive dumping.
283 InstanceKlass* ClassListParser::load_class_from_source(Symbol* class_name, TRAPS) {
284 #if !(defined(_LP64) &amp;&amp; (defined(LINUX)|| defined(SOLARIS) || defined(__APPLE__)))
285   // The only supported platforms are: (1) Linux/64-bit and (2) Solaris/64-bit and
286   // (3) MacOSX/64-bit
287   // This #if condition should be in sync with the areCustomLoadersSupportedForCDS
288   // method in test/lib/jdk/test/lib/Platform.java.
289   error(&quot;AppCDS custom class loaders not supported on this platform&quot;);
290 #endif
291 
292   if (!is_super_specified()) {
293     error(&quot;If source location is specified, super class must be also specified&quot;);
294   }
295   if (!is_id_specified()) {
296     error(&quot;If source location is specified, id must be also specified&quot;);
297   }
<span class="line-removed">298   InstanceKlass* k = ClassLoaderExt::load_class(class_name, _source, CHECK_NULL);</span>
<span class="line-removed">299 </span>
300   if (strncmp(_class_name, &quot;java/&quot;, 5) == 0) {
301     log_info(cds)(&quot;Prohibited package for non-bootstrap classes: %s.class from %s&quot;,
302           _class_name, _source);
303     return NULL;
304   }
305 


306   if (k != NULL) {
307     if (k-&gt;local_interfaces()-&gt;length() != _interfaces-&gt;length()) {
308       print_specified_interfaces();
309       print_actual_interfaces(k);
310       error(&quot;The number of interfaces (%d) specified in class list does not match the class file (%d)&quot;,
311             _interfaces-&gt;length(), k-&gt;local_interfaces()-&gt;length());
312     }
313 
314     bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);
315     if (!added) {
316       // We allow only a single unregistered class for each unique name.
317       error(&quot;Duplicated class %s&quot;, _class_name);
318     }
319 
320     // This tells JVM_FindLoadedClass to not find this class.
321     k-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
322     k-&gt;clear_class_loader_type();
323   }
324 
325   return k;
326 }
327 
328 Klass* ClassListParser::load_current_class(TRAPS) {
<span class="line-modified">329   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name, THREAD);</span>
<span class="line-removed">330   guarantee(!HAS_PENDING_EXCEPTION, &quot;Exception creating a symbol.&quot;);</span>
331 
<span class="line-modified">332   Klass *klass = NULL;</span>
333   if (!is_loading_from_source()) {
334     // Load classes for the boot/platform/app loaders only.
335     if (is_super_specified()) {
336       error(&quot;If source location is not specified, super class must not be specified&quot;);
337     }
338     if (are_interfaces_specified()) {
339       error(&quot;If source location is not specified, interface(s) must not be specified&quot;);
340     }
341 
<span class="line-modified">342     bool non_array = !FieldType::is_array(class_name_symbol);</span>
343 
344     JavaValue result(T_OBJECT);
345     if (non_array) {
346       // At this point, we are executing in the context of the boot loader. We
347       // cannot call Class.forName because that is context dependent and
348       // would load only classes for the boot loader.
349       //
350       // Instead, let&#39;s call java_system_loader().loadClass() directly, which will
351       // delegate to the correct loader (boot, platform or app) depending on
352       // the class name.
353 
354       Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_0);
355       // ClassLoader.loadClass() wants external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
356       Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_0);
357       Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
358 
359       JavaCalls::call_virtual(&amp;result,
360                               loader, //SystemDictionary::java_system_loader(),
361                               SystemDictionary::ClassLoader_klass(),
362                               vmSymbols::loadClass_name(),
</pre>
<hr />
<pre>
445     error(&quot;Class %s implements the interface %s, but no interface has been specified in the input line&quot;,
446           _class_name, interface_name-&gt;as_klass_external_name());
447     ShouldNotReachHere();
448   }
449 
450   int i;
451   for (i=0; i&lt;n; i++) {
452     InstanceKlass* k = lookup_class_by_id(_interfaces-&gt;at(i));
453     if (interface_name == k-&gt;name()) {
454       return k;
455     }
456   }
457 
458   // interface_name is not specified by the &quot;interfaces:&quot; keyword.
459   print_specified_interfaces();
460   error(&quot;The interface %s implemented by class %s does not match any of the specified interface IDs&quot;,
461         interface_name-&gt;as_klass_external_name(), _class_name);
462   ShouldNotReachHere();
463   return NULL;
464 }
<span class="line-removed">465 </span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;jimage.hpp&quot;
 28 #include &quot;classfile/classListParser.hpp&quot;
 29 #include &quot;classfile/classLoaderExt.hpp&quot;
 30 #include &quot;classfile/symbolTable.hpp&quot;
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;classfile/systemDictionaryShared.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;logging/logTag.hpp&quot;
 35 #include &quot;memory/metaspaceShared.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;

 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/javaCalls.hpp&quot;
 39 #include &quot;utilities/defaultStream.hpp&quot;
 40 #include &quot;utilities/hashtable.inline.hpp&quot;
 41 #include &quot;utilities/macros.hpp&quot;
 42 
 43 ClassListParser* ClassListParser::_instance = NULL;
 44 
 45 ClassListParser::ClassListParser(const char* file) {
 46   assert(_instance == NULL, &quot;must be singleton&quot;);
 47   _instance = this;
 48   _classlist_file = file;
 49   _file = NULL;
 50   // Use os::open() because neither fopen() nor os::fopen()
 51   // can handle long path name on Windows.
 52   int fd = os::open(file, O_RDONLY, S_IREAD);
 53   if (fd != -1) {
 54     // Obtain a File* from the file descriptor so that fgets()
 55     // can be used in parse_one_line()
 56     _file = os::open(fd, &quot;r&quot;);
</pre>
<hr />
<pre>
211     if (*value != _unspecified) {
212       error(&quot;%s specified twice&quot;, option_name);
213     } else {
214       parse_int(value);
215       return true;
216     }
217   }
218   return false;
219 }
220 
221 void ClassListParser::print_specified_interfaces() {
222   const int n = _interfaces-&gt;length();
223   jio_fprintf(defaultStream::error_stream(), &quot;Currently specified interfaces[%d] = {\n&quot;, n);
224   for (int i=0; i&lt;n; i++) {
225     InstanceKlass* k = lookup_class_by_id(_interfaces-&gt;at(i));
226     jio_fprintf(defaultStream::error_stream(), &quot;  %4d = %s\n&quot;, _interfaces-&gt;at(i), k-&gt;name()-&gt;as_klass_external_name());
227   }
228   jio_fprintf(defaultStream::error_stream(), &quot;}\n&quot;);
229 }
230 
<span class="line-modified">231 void ClassListParser::print_actual_interfaces(InstanceKlass* ik) {</span>
232   int n = ik-&gt;local_interfaces()-&gt;length();
233   jio_fprintf(defaultStream::error_stream(), &quot;Actual interfaces[%d] = {\n&quot;, n);
234   for (int i = 0; i &lt; n; i++) {
<span class="line-modified">235     InstanceKlass* e = ik-&gt;local_interfaces()-&gt;at(i);</span>
236     jio_fprintf(defaultStream::error_stream(), &quot;  %s\n&quot;, e-&gt;name()-&gt;as_klass_external_name());
237   }
238   jio_fprintf(defaultStream::error_stream(), &quot;}\n&quot;);
239 }
240 
<span class="line-modified">241 void ClassListParser::error(const char* msg, ...) {</span>
242   va_list ap;
243   va_start(ap, msg);
244   int error_index = _token - _line;
245   if (error_index &gt;= _line_len) {
246     error_index = _line_len - 1;
247   }
248   if (error_index &lt; 0) {
249     error_index = 0;
250   }
251 
252   jio_fprintf(defaultStream::error_stream(),
253               &quot;An error has occurred while processing class list file %s %d:%d.\n&quot;,
254               _classlist_file, _line_no, (error_index + 1));
255   jio_vfprintf(defaultStream::error_stream(), msg, ap);
256 
257   if (_line_len &lt;= 0) {
258     jio_fprintf(defaultStream::error_stream(), &quot;\n&quot;);
259   } else {
260     jio_fprintf(defaultStream::error_stream(), &quot;:\n&quot;);
261     for (int i=0; i&lt;_line_len; i++) {
</pre>
<hr />
<pre>
277   va_end(ap);
278 }
279 
280 // This function is used for loading classes for customized class loaders
281 // during archive dumping.
282 InstanceKlass* ClassListParser::load_class_from_source(Symbol* class_name, TRAPS) {
283 #if !(defined(_LP64) &amp;&amp; (defined(LINUX)|| defined(SOLARIS) || defined(__APPLE__)))
284   // The only supported platforms are: (1) Linux/64-bit and (2) Solaris/64-bit and
285   // (3) MacOSX/64-bit
286   // This #if condition should be in sync with the areCustomLoadersSupportedForCDS
287   // method in test/lib/jdk/test/lib/Platform.java.
288   error(&quot;AppCDS custom class loaders not supported on this platform&quot;);
289 #endif
290 
291   if (!is_super_specified()) {
292     error(&quot;If source location is specified, super class must be also specified&quot;);
293   }
294   if (!is_id_specified()) {
295     error(&quot;If source location is specified, id must be also specified&quot;);
296   }


297   if (strncmp(_class_name, &quot;java/&quot;, 5) == 0) {
298     log_info(cds)(&quot;Prohibited package for non-bootstrap classes: %s.class from %s&quot;,
299           _class_name, _source);
300     return NULL;
301   }
302 
<span class="line-added">303   InstanceKlass* k = ClassLoaderExt::load_class(class_name, _source, CHECK_NULL);</span>
<span class="line-added">304 </span>
305   if (k != NULL) {
306     if (k-&gt;local_interfaces()-&gt;length() != _interfaces-&gt;length()) {
307       print_specified_interfaces();
308       print_actual_interfaces(k);
309       error(&quot;The number of interfaces (%d) specified in class list does not match the class file (%d)&quot;,
310             _interfaces-&gt;length(), k-&gt;local_interfaces()-&gt;length());
311     }
312 
313     bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);
314     if (!added) {
315       // We allow only a single unregistered class for each unique name.
316       error(&quot;Duplicated class %s&quot;, _class_name);
317     }
318 
319     // This tells JVM_FindLoadedClass to not find this class.
320     k-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
321     k-&gt;clear_class_loader_type();
322   }
323 
324   return k;
325 }
326 
327 Klass* ClassListParser::load_current_class(TRAPS) {
<span class="line-modified">328   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);</span>

329 
<span class="line-modified">330   Klass* klass = NULL;</span>
331   if (!is_loading_from_source()) {
332     // Load classes for the boot/platform/app loaders only.
333     if (is_super_specified()) {
334       error(&quot;If source location is not specified, super class must not be specified&quot;);
335     }
336     if (are_interfaces_specified()) {
337       error(&quot;If source location is not specified, interface(s) must not be specified&quot;);
338     }
339 
<span class="line-modified">340     bool non_array = !Signature::is_array(class_name_symbol);</span>
341 
342     JavaValue result(T_OBJECT);
343     if (non_array) {
344       // At this point, we are executing in the context of the boot loader. We
345       // cannot call Class.forName because that is context dependent and
346       // would load only classes for the boot loader.
347       //
348       // Instead, let&#39;s call java_system_loader().loadClass() directly, which will
349       // delegate to the correct loader (boot, platform or app) depending on
350       // the class name.
351 
352       Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_0);
353       // ClassLoader.loadClass() wants external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
354       Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_0);
355       Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
356 
357       JavaCalls::call_virtual(&amp;result,
358                               loader, //SystemDictionary::java_system_loader(),
359                               SystemDictionary::ClassLoader_klass(),
360                               vmSymbols::loadClass_name(),
</pre>
<hr />
<pre>
443     error(&quot;Class %s implements the interface %s, but no interface has been specified in the input line&quot;,
444           _class_name, interface_name-&gt;as_klass_external_name());
445     ShouldNotReachHere();
446   }
447 
448   int i;
449   for (i=0; i&lt;n; i++) {
450     InstanceKlass* k = lookup_class_by_id(_interfaces-&gt;at(i));
451     if (interface_name == k-&gt;name()) {
452       return k;
453     }
454   }
455 
456   // interface_name is not specified by the &quot;interfaces:&quot; keyword.
457   print_specified_interfaces();
458   error(&quot;The interface %s implemented by class %s does not match any of the specified interface IDs&quot;,
459         interface_name-&gt;as_klass_external_name(), _class_name);
460   ShouldNotReachHere();
461   return NULL;
462 }

</pre>
</td>
</tr>
</table>
<center><a href="classFileStream.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
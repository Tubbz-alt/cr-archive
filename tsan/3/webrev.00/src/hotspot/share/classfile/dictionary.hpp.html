<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/dictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_DICTIONARY_HPP
 26 #define SHARE_CLASSFILE_DICTIONARY_HPP
 27 
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;oops/instanceKlass.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;utilities/hashtable.hpp&quot;
 33 #include &quot;utilities/ostream.hpp&quot;
 34 
 35 class DictionaryEntry;
 36 class BoolObjectClosure;
 37 
 38 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 39 // The data structure for the class loader data dictionaries.
 40 
 41 class Dictionary : public Hashtable&lt;InstanceKlass*, mtClass&gt; {
 42   friend class VMStructs;
 43 
 44   static bool _some_dictionary_needs_resizing;
 45   bool _resizable;
 46   bool _needs_resizing;
 47   void check_if_needs_resize();
 48 
 49   ClassLoaderData* _loader_data;  // backpointer to owning loader
 50   ClassLoaderData* loader_data() const { return _loader_data; }
 51 
 52   DictionaryEntry* get_entry(int index, unsigned int hash, Symbol* name);
 53 
 54 public:
 55   Dictionary(ClassLoaderData* loader_data, int table_size, bool resizable = false);
 56   Dictionary(ClassLoaderData* loader_data, int table_size, HashtableBucket&lt;mtClass&gt;* t, int number_of_entries, bool resizable = false);
 57   ~Dictionary();
 58 
 59   static bool does_any_dictionary_needs_resizing();
 60   bool resize_if_needed();
 61 
 62   void add_klass(unsigned int hash, Symbol* class_name, InstanceKlass* obj);
 63 
 64   InstanceKlass* find_class(int index, unsigned int hash, Symbol* name);
 65 
 66   void classes_do(void f(InstanceKlass*));
 67   void classes_do(void f(InstanceKlass*, TRAPS), TRAPS);
 68   void all_entries_do(KlassClosure* closure);
 69   void classes_do(MetaspaceClosure* it);
 70 
 71   void clean_cached_protection_domains();
 72 
 73   // Protection domains
 74   InstanceKlass* find(unsigned int hash, Symbol* name, Handle protection_domain);
 75   bool is_valid_protection_domain(unsigned int hash,
 76                                   Symbol* name,
 77                                   Handle protection_domain);
 78   void add_protection_domain(int index, unsigned int hash,
 79                              InstanceKlass* klass,
 80                              Handle protection_domain, TRAPS);
 81 
 82   void print_on(outputStream* st) const;
 83   void verify();
 84 
 85  private:
 86   DictionaryEntry* new_entry(unsigned int hash, InstanceKlass* klass);
 87 
 88   DictionaryEntry* bucket(int i) const {
 89     return (DictionaryEntry*)Hashtable&lt;InstanceKlass*, mtClass&gt;::bucket(i);
 90   }
 91 
 92   // The following method is not MT-safe and must be done under lock.
 93   DictionaryEntry** bucket_addr(int i) {
 94     return (DictionaryEntry**)Hashtable&lt;InstanceKlass*, mtClass&gt;::bucket_addr(i);
 95   }
 96 
 97   void add_entry(int index, DictionaryEntry* new_entry) {
 98     Hashtable&lt;InstanceKlass*, mtClass&gt;::add_entry(index, (HashtableEntry&lt;InstanceKlass*, mtClass&gt;*)new_entry);
 99   }
100 
101   void unlink_entry(DictionaryEntry* entry) {
102     Hashtable&lt;InstanceKlass*, mtClass&gt;::unlink_entry((HashtableEntry&lt;InstanceKlass*, mtClass&gt;*)entry);
103   }
104 
105   void free_entry(DictionaryEntry* entry);
106 };
107 
108 // An entry in the class loader data dictionaries, this describes a class as
109 // { InstanceKlass*, protection_domain }.
110 
111 class DictionaryEntry : public HashtableEntry&lt;InstanceKlass*, mtClass&gt; {
112   friend class VMStructs;
113  private:
114   // Contains the set of approved protection domains that can access
115   // this dictionary entry.
116   //
117   // This protection domain set is a set of tuples:
118   //
119   // (InstanceKlass C, initiating class loader ICL, Protection Domain PD)
120   //
121   // [Note that C.protection_domain(), which is stored in the java.lang.Class
122   // mirror of C, is NOT the same as PD]
123   //
124   // If such an entry (C, ICL, PD) exists in the table, it means that
125   // it is okay for a class Foo to reference C, where
126   //
127   //    Foo.protection_domain() == PD, and
128   //    Foo&#39;s defining class loader == ICL
129   //
130   // The usage of the PD set can be seen in SystemDictionary::validate_protection_domain()
131   // It is essentially a cache to avoid repeated Java up-calls to
132   // ClassLoader.checkPackageAccess().
133   //
134   ProtectionDomainEntry* volatile _pd_set;
135 
136  public:
137   // Tells whether a protection is in the approved set.
138   bool contains_protection_domain(oop protection_domain) const;
139   // Adds a protection domain to the approved set.
140   void add_protection_domain(Dictionary* dict, Handle protection_domain);
141 
142   InstanceKlass* instance_klass() const { return literal(); }
143   InstanceKlass** klass_addr() { return (InstanceKlass**)literal_addr(); }
144 
145   DictionaryEntry* next() const {
146     return (DictionaryEntry*)HashtableEntry&lt;InstanceKlass*, mtClass&gt;::next();
147   }
148 
149   DictionaryEntry** next_addr() {
150     return (DictionaryEntry**)HashtableEntry&lt;InstanceKlass*, mtClass&gt;::next_addr();
151   }
152 
153   ProtectionDomainEntry* pd_set() const            { return _pd_set; }
154   void set_pd_set(ProtectionDomainEntry* new_head) {  _pd_set = new_head; }
155 
156   // Tells whether the initiating class&#39; protection domain can access the klass in this entry
157   bool is_valid_protection_domain(Handle protection_domain) {
158     if (!ProtectionDomainVerification) return true;
159 
160     return protection_domain() == NULL
161          ? true
162          : contains_protection_domain(protection_domain());
163   }
164 
165   void verify_protection_domain_set();
166 
167   bool equals(const Symbol* class_name) const {
168     InstanceKlass* klass = (InstanceKlass*)literal();
169     return (klass-&gt;name() == class_name);
170   }
171 
172   void print_count(outputStream *st);
173   void verify();
174 };
175 
176 // Entry in a SymbolPropertyTable, mapping a single Symbol*
177 // to a managed and an unmanaged pointer.
178 class SymbolPropertyEntry : public HashtableEntry&lt;Symbol*, mtSymbol&gt; {
179   friend class VMStructs;
180  private:
181   intptr_t _symbol_mode;  // secondary key
182   Method*   _method;
183   oop       _method_type;
184 
185  public:
186   Symbol* symbol() const            { return literal(); }
187 
188   intptr_t symbol_mode() const      { return _symbol_mode; }
189   void set_symbol_mode(intptr_t m)  { _symbol_mode = m; }
190 
191   Method*        method() const     { return _method; }
192   void set_method(Method* p)        { _method = p; }
193 
194   oop      method_type() const      { return _method_type; }
195   oop*     method_type_addr()       { return &amp;_method_type; }
196   void set_method_type(oop p)       { _method_type = p; }
197 
198   SymbolPropertyEntry* next() const {
199     return (SymbolPropertyEntry*)HashtableEntry&lt;Symbol*, mtSymbol&gt;::next();
200   }
201 
202   SymbolPropertyEntry** next_addr() {
203     return (SymbolPropertyEntry**)HashtableEntry&lt;Symbol*, mtSymbol&gt;::next_addr();
204   }
205 
206   void print_entry(outputStream* st) const {
207     symbol()-&gt;print_value_on(st);
208     st-&gt;print(&quot;/mode=&quot; INTX_FORMAT, symbol_mode());
209     st-&gt;print(&quot; -&gt; &quot;);
210     bool printed = false;
211     if (method() != NULL) {
212       method()-&gt;print_value_on(st);
213       printed = true;
214     }
215     if (method_type() != NULL) {
216       if (printed)  st-&gt;print(&quot; and &quot;);
217       st-&gt;print(INTPTR_FORMAT, p2i((void *)method_type()));
218       printed = true;
219     }
220     st-&gt;print_cr(printed ? &quot;&quot; : &quot;(empty)&quot;);
221   }
222 };
223 
224 // A system-internal mapping of symbols to pointers, both managed
225 // and unmanaged.  Used to record the auto-generation of each method
226 // MethodHandle.invoke(S)T, for all signatures (S)T.
227 class SymbolPropertyTable : public Hashtable&lt;Symbol*, mtSymbol&gt; {
228   friend class VMStructs;
229 private:
230   // The following method is not MT-safe and must be done under lock.
231   SymbolPropertyEntry** bucket_addr(int i) {
232     return (SymbolPropertyEntry**) Hashtable&lt;Symbol*, mtSymbol&gt;::bucket_addr(i);
233   }
234 
235   void add_entry(int index, SymbolPropertyEntry* new_entry) {
236     ShouldNotReachHere();
237   }
238   void set_entry(int index, SymbolPropertyEntry* new_entry) {
239     ShouldNotReachHere();
240   }
241 
242   SymbolPropertyEntry* new_entry(unsigned int hash, Symbol* symbol, intptr_t symbol_mode) {
243     SymbolPropertyEntry* entry = (SymbolPropertyEntry*) Hashtable&lt;Symbol*, mtSymbol&gt;::new_entry(hash, symbol);
244     // Hashtable with Symbol* literal must increment and decrement refcount.
245     symbol-&gt;increment_refcount();
246     entry-&gt;set_symbol_mode(symbol_mode);
247     entry-&gt;set_method(NULL);
248     entry-&gt;set_method_type(NULL);
249     return entry;
250   }
251 
252 public:
253   SymbolPropertyTable(int table_size);
254   SymbolPropertyTable(int table_size, HashtableBucket&lt;mtSymbol&gt;* t, int number_of_entries);
255 
256   void free_entry(SymbolPropertyEntry* entry) {
257     // decrement Symbol refcount here because hashtable doesn&#39;t.
258     entry-&gt;literal()-&gt;decrement_refcount();
259     Hashtable&lt;Symbol*, mtSymbol&gt;::free_entry(entry);
260   }
261 
262   unsigned int compute_hash(Symbol* sym, intptr_t symbol_mode) {
263     // Use the regular identity_hash.
264     return Hashtable&lt;Symbol*, mtSymbol&gt;::compute_hash(sym) ^ symbol_mode;
265   }
266 
267   int index_for(Symbol* name, intptr_t symbol_mode) {
268     return hash_to_index(compute_hash(name, symbol_mode));
269   }
270 
271   // need not be locked; no state change
272   SymbolPropertyEntry* find_entry(int index, unsigned int hash, Symbol* name, intptr_t name_mode);
273 
274   // must be done under SystemDictionary_lock
275   SymbolPropertyEntry* add_entry(int index, unsigned int hash, Symbol* name, intptr_t name_mode);
276 
277   // GC support
278   void oops_do(OopClosure* f);
279 
280   void methods_do(void f(Method*));
281 
282   void verify();
283 
284   SymbolPropertyEntry* bucket(int i) {
285     return (SymbolPropertyEntry*) Hashtable&lt;Symbol*, mtSymbol&gt;::bucket(i);
286   }
287 };
288 #endif // SHARE_CLASSFILE_DICTIONARY_HPP
    </pre>
  </body>
</html>
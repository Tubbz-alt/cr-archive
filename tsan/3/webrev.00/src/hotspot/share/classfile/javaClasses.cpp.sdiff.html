<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaAssertions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;

  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;code/debugInfo.hpp&quot;
  33 #include &quot;code/dependencyContext.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;interpreter/linkResolver.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;logging/logStream.hpp&quot;
  39 #include &quot;memory/heapShared.inline.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
<span class="line-modified">  44 #include &quot;oops/fieldStreams.hpp&quot;</span>
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  47 #include &quot;oops/klass.hpp&quot;
  48 #include &quot;oops/method.inline.hpp&quot;
  49 #include &quot;oops/objArrayOop.inline.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/symbol.hpp&quot;

  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;prims/jvmtiExport.hpp&quot;
  54 #include &quot;prims/resolvedMethodTable.hpp&quot;
  55 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  56 #include &quot;runtime/frame.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;

  58 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  59 #include &quot;runtime/java.hpp&quot;
  60 #include &quot;runtime/javaCalls.hpp&quot;
  61 #include &quot;runtime/jniHandles.inline.hpp&quot;
  62 #include &quot;runtime/safepoint.hpp&quot;
  63 #include &quot;runtime/safepointVerifiers.hpp&quot;
  64 #include &quot;runtime/thread.inline.hpp&quot;
  65 #include &quot;runtime/vframe.inline.hpp&quot;

  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/preserveException.hpp&quot;

  68 #if INCLUDE_JVMCI
  69 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  70 #endif
  71 
  72 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  73   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  74 
  75 #if INCLUDE_CDS
  76 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  77   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  78 #endif
  79 
  80 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  81   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  82 
  83 InjectedField JavaClasses::_injected_fields[] = {
  84   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  85 };
  86 















  87 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
  88   return _injected_fields[id].compute_offset();
  89 }
  90 
  91 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
  92   *field_count = 0;
  93 
  94   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
  95   if (sid == vmSymbols::NO_SID) {
  96     // Only well known classes can inject fields
  97     return NULL;
  98   }
  99 
 100   int count = 0;
 101   int start = -1;
 102 
 103 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 104   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 105     count++;                                                       \
 106     if (start == -1) start = klass##_##name##_enum;                \
</pre>
<hr />
<pre>
 142     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 143   }
 144   dest_offset = fd.offset();
 145 }
 146 
 147 // Overloading to pass name as a string.
 148 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 149                            const char* name_string, Symbol* signature_symbol,
 150                            bool is_static = false) {
 151   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 152   if (name == NULL) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 155     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 156   }
 157   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 158 }
 159 
 160 int java_lang_String::value_offset  = 0;
 161 int java_lang_String::hash_offset   = 0;

 162 int java_lang_String::coder_offset  = 0;
 163 
 164 bool java_lang_String::initialized  = false;
 165 
 166 bool java_lang_String::is_instance(oop obj) {
 167   return is_instance_inlined(obj);
 168 }
 169 
 170 #if INCLUDE_CDS
 171 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 172   f-&gt;do_u4((u4*)&amp;offset)
 173 #endif
 174 
 175 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 176   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 177 
 178 #define STRING_FIELDS_DO(macro) \
 179   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 180   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
<span class="line-modified"> 181   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false)</span>

 182 
 183 void java_lang_String::compute_offsets() {
 184   if (initialized) {
 185     return;
 186   }
 187 
 188   InstanceKlass* k = SystemDictionary::String_klass();
 189   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 190 
 191   initialized = true;
 192 }
 193 
 194 #if INCLUDE_CDS
 195 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 196   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 197   f-&gt;do_u4((u4*)&amp;initialized);</span>
 198 }
 199 #endif
 200 
 201 class CompactStringsFixup : public FieldClosure {
 202 private:
 203   bool _value;
 204 
 205 public:
 206   CompactStringsFixup(bool value) : _value(value) {}
 207 
 208   void do_field(fieldDescriptor* fd) {
 209     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 210       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 211       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 212       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 213       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 214     }
 215   }
 216 };
 217 
 218 void java_lang_String::set_compact_strings(bool value) {
 219   CompactStringsFixup fix(value);
<span class="line-modified"> 220   InstanceKlass::cast(SystemDictionary::String_klass())-&gt;do_local_static_fields(&amp;fix);</span>
 221 }
 222 
 223 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 224   assert(initialized, &quot;Must be initialized&quot;);
 225   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 226 
 227   // Create the String object first, so there&#39;s a chance that the String
 228   // and the char array it points to end up in the same cache line.
 229   oop obj;
 230   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 231 
 232   // Create the char array.  The String object must be handlized here
 233   // because GC can happen as a result of the allocation attempt.
 234   Handle h_obj(THREAD, obj);
 235   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 236   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 237 
 238   // Point the String at the char array
 239   obj = h_obj();
 240   set_value(obj, buffer);
</pre>
<hr />
<pre>
 350 
 351 #ifdef ASSERT
 352   {
 353     ResourceMark rm;
 354     const char* expected = symbol-&gt;as_utf8();
 355     char* actual = as_utf8_string(h_obj());
 356     if (strncmp(expected, actual, utf8_len) != 0) {
 357       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 358       ShouldNotReachHere();
 359     }
 360   }
 361 #endif
 362 
 363   return h_obj;
 364 }
 365 
 366 // Converts a C string to a Java String based on current encoding
 367 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 368   assert(str != NULL, &quot;bad arguments&quot;);
 369 
<span class="line-modified"> 370   typedef jstring (*to_java_string_fn_t)(JNIEnv*, const char *);</span>
 371   static to_java_string_fn_t _to_java_string_fn = NULL;
 372 
 373   if (_to_java_string_fn == NULL) {
 374     void *lib_handle = os::native_java_library();
<span class="line-modified"> 375     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;NewStringPlatform&quot;));</span>






 376     if (_to_java_string_fn == NULL) {
<span class="line-modified"> 377       fatal(&quot;NewStringPlatform missing&quot;);</span>
 378     }
 379   }
 380 
 381   jstring js = NULL;
<span class="line-modified"> 382   { JavaThread* thread = (JavaThread*)THREAD;</span>
<span class="line-modified"> 383     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>

 384     HandleMark hm(thread);
 385     ThreadToNativeFromVM ttn(thread);
 386     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 387   }
<span class="line-modified"> 388   return Handle(THREAD, JNIHandles::resolve(js));</span>



 389 }
 390 
 391 // Converts a Java String to a native C string that can be used for
 392 // native OS calls.
 393 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 394   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 395   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 396 
 397   if (_to_platform_string_fn == NULL) {
 398     void *lib_handle = os::native_java_library();
 399     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 400     if (_to_platform_string_fn == NULL) {
 401       fatal(&quot;GetStringPlatformChars missing&quot;);
 402     }
 403   }
 404 
 405   char *native_platform_string;
 406   { JavaThread* thread = (JavaThread*)THREAD;
 407     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 408     JNIEnv *env = thread-&gt;jni_environment();
</pre>
<hr />
<pre>
 489   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 490 
 491   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 492   if (result != NULL) {
 493     if (!is_latin1) {
 494       for (int index = 0; index &lt; length; index++) {
 495         result[index] = value-&gt;char_at(index);
 496       }
 497     } else {
 498       for (int index = 0; index &lt; length; index++) {
 499         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 500       }
 501     }
 502   } else {
 503     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 504   }
 505   return result;
 506 }
 507 
 508 unsigned int java_lang_String::hash_code(oop java_string) {
<span class="line-modified"> 509   typeArrayOop value  = java_lang_String::value(java_string);</span>
<span class="line-modified"> 510   int          length = java_lang_String::length(java_string, value);</span>
<span class="line-modified"> 511   // Zero length string will hash to zero with String.hashCode() function.</span>
<span class="line-modified"> 512   if (length == 0) return 0;</span>








 513 
<span class="line-modified"> 514   bool      is_latin1 = java_lang_String::is_latin1(java_string);</span>


 515 
<span class="line-modified"> 516   if (is_latin1) {</span>
<span class="line-modified"> 517     return java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);</span>









 518   } else {
<span class="line-modified"> 519     return java_lang_String::hash_code(value-&gt;char_at_addr(0), length);</span>
 520   }

 521 }
 522 
 523 char* java_lang_String::as_quoted_ascii(oop java_string) {
 524   typeArrayOop value  = java_lang_String::value(java_string);
 525   int          length = java_lang_String::length(java_string, value);
 526   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 527 
 528   if (length == 0) return NULL;
 529 
 530   char* result;
 531   int result_length;
 532   if (!is_latin1) {
 533     jchar* base = value-&gt;char_at_addr(0);
 534     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 535     result = NEW_RESOURCE_ARRAY(char, result_length);
 536     UNICODE::as_quoted_ascii(base, length, result, result_length);
 537   } else {
 538     jbyte* base = value-&gt;byte_at_addr(0);
 539     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 540     result = NEW_RESOURCE_ARRAY(char, result_length);
 541     UNICODE::as_quoted_ascii(base, length, result, result_length);
 542   }
 543   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 544   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 545   return result;
 546 }
 547 
<span class="line-modified"> 548 Symbol* java_lang_String::as_symbol(oop java_string, TRAPS) {</span>
 549   typeArrayOop value  = java_lang_String::value(java_string);
 550   int          length = java_lang_String::length(java_string, value);
 551   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 552   if (!is_latin1) {
 553     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
<span class="line-modified"> 554     Symbol* sym = SymbolTable::lookup_unicode(base, length, THREAD);</span>
 555     return sym;
 556   } else {
 557     ResourceMark rm;
 558     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 559     const char* base = UNICODE::as_utf8(position, length);
<span class="line-modified"> 560     Symbol* sym = SymbolTable::lookup(base, length, THREAD);</span>
 561     return sym;
 562   }
 563 }
 564 
 565 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 566   typeArrayOop value  = java_lang_String::value(java_string);
 567   int          length = java_lang_String::length(java_string, value);
 568   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 569   if (!is_latin1) {
 570     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 571     return SymbolTable::probe_unicode(base, length);
 572   } else {
 573     ResourceMark rm;
 574     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 575     const char* base = UNICODE::as_utf8(position, length);
 576     return SymbolTable::probe(base, length);
 577   }
 578 }
 579 
 580 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
</pre>
<hr />
<pre>
 813   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 814   set_init_lock(mirror(), r);
 815 
 816   // Set protection domain also
 817   set_protection_domain(mirror(), protection_domain());
 818 
 819   // Initialize static fields
 820   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 821 }
 822 
 823 // Set the java.lang.Module module field in the java_lang_Class mirror
 824 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 825   if (module.is_null()) {
 826     // During startup, the module may be NULL only if java.base has not been defined yet.
 827     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 828     // for java.base is known. But note that since we captured the NULL module another
 829     // thread may have completed that initialization.
 830 
 831     bool javabase_was_defined = false;
 832     {
<span class="line-modified"> 833       MutexLocker m1(Module_lock, THREAD);</span>
 834       // Keep list of classes needing java.base module fixup
 835       if (!ModuleEntryTable::javabase_defined()) {
 836         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 837         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 838         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 839         fixup_module_field_list()-&gt;push(k);
 840       } else {
 841         javabase_was_defined = true;
 842       }
 843     }
 844 
 845     // If java.base was already defined then patch this particular class with java.base.
 846     if (javabase_was_defined) {
 847       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 848       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 849              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 850       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 851       set_module(mirror(), javabase_handle());
 852     }
 853   } else {
 854     assert(Universe::is_module_initialized() ||
 855            (ModuleEntryTable::javabase_defined() &amp;&amp;
<span class="line-modified"> 856             (oopDesc::equals(module(), ModuleEntryTable::javabase_moduleEntry()-&gt;module()))),</span>
 857            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 858     set_module(mirror(), module());
 859   }
 860 }
 861 
 862 // Statically allocate fixup lists because they always get created.
 863 void java_lang_Class::allocate_fixup_lists() {
 864   GrowableArray&lt;Klass*&gt;* mirror_list =
 865     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 866   set_fixup_mirror_list(mirror_list);
 867 
 868   GrowableArray&lt;Klass*&gt;* module_list =
 869     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 870   set_fixup_module_field_list(module_list);
 871 }
 872 
 873 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 874                                     Handle module, Handle protection_domain, TRAPS) {
 875   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 876   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
</pre>
<hr />
<pre>
 913       // Two-way link between the array klass and its component mirror:
 914       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 915       set_component_mirror(mirror(), comp_mirror());
 916       // See below for ordering dependencies between field array_klass in component mirror
 917       // and java_mirror in this klass.
 918     } else {
 919       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 920 
 921       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 922       if (HAS_PENDING_EXCEPTION) {
 923         // If any of the fields throws an exception like OOM remove the klass field
 924         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 925         // This mirror looks like a primitive type, which logically it is because it
 926         // it represents no class.
 927         java_lang_Class::set_klass(mirror(), NULL);
 928         return;
 929       }
 930     }
 931 
 932     // set the classLoader field in the java_lang_Class instance
<span class="line-modified"> 933     assert(oopDesc::equals(class_loader(), k-&gt;class_loader()), &quot;should be same&quot;);</span>
 934     set_class_loader(mirror(), class_loader());
 935 
 936     // Setup indirection from klass-&gt;mirror
 937     // after any exceptions can happen during allocations.
 938     k-&gt;set_java_mirror(mirror);
 939 
 940     // Set the module field in the java_lang_Class instance.  This must be done
 941     // after the mirror is set.
 942     set_mirror_module_field(k, mirror, module, THREAD);
 943 
 944     if (comp_mirror() != NULL) {
 945       // Set after k-&gt;java_mirror() is published, because compiled code running
 946       // concurrently doesn&#39;t expect a k to have a null java_mirror.
 947       release_set_array_klass(comp_mirror(), k);
 948     }
 949   } else {
 950     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
 951     fixup_mirror_list()-&gt;push(k);
 952   }
 953 }
</pre>
<hr />
<pre>
1009       default:
1010         ShouldNotReachHere();
1011         break;
1012      }
1013   }
1014 };
1015 
1016 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1017   assert(HeapShared::is_heap_object_archiving_allowed(),
1018          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1019 
1020   for (int t = 0; t &lt;= T_VOID; t++) {
1021     oop m = Universe::_mirrors[t];
1022     if (m != NULL) {
1023       // Update the field at _array_klass_offset to point to the relocated array klass.
1024       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1025       assert(archived_m != NULL, &quot;sanity&quot;);
1026       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1027       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1028       if (ak != NULL) {
<span class="line-modified">1029         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak);</span>
1030         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1031       }
1032 
1033       // Clear the fields. Just to be safe
1034       Klass *k = m-&gt;klass();
1035       Handle archived_mirror_h(THREAD, archived_m);
1036       ResetMirrorField reset(archived_mirror_h);
1037       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1038 
1039       log_trace(cds, heap, mirror)(
1040         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1041         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1042 
1043       Universe::_mirrors[t] = archived_m;
1044     }
1045   }
1046 
1047   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1048          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1049          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
</pre>
<hr />
<pre>
1154     }
1155     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1156   } else {
1157     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1158 
1159     // Reset local static fields in the mirror
1160     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1161 
1162     java_lang_Class:set_init_lock(archived_mirror, NULL);
1163 
1164     set_protection_domain(archived_mirror, NULL);
1165   }
1166 
1167   // clear class loader and mirror_module_field
1168   set_class_loader(archived_mirror, NULL);
1169   set_module(archived_mirror, NULL);
1170 
1171   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1172   // klass. Updated the field in the archived mirror to point to the relocated
1173   // klass in the archive.
<span class="line-modified">1174   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror));</span>
1175   log_debug(cds, heap, mirror)(
1176     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1177     p2i(as_Klass(mirror)), p2i(reloc_k));
1178   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1179 
1180   // The field at _array_klass_offset is pointing to the original one dimension
1181   // higher array klass if exists. Relocate the pointer.
1182   Klass *arr = array_klass_acquire(mirror);
1183   if (arr != NULL) {
<span class="line-modified">1184     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr);</span>
1185     log_debug(cds, heap, mirror)(
1186       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1187       p2i(arr), p2i(reloc_arr));
1188     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1189   }
1190   return archived_mirror;
1191 }
1192 



























1193 // Returns true if the mirror is updated, false if no archived mirror
1194 // data is present. After the archived mirror object is restored, the
1195 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1196 bool java_lang_Class::restore_archived_mirror(Klass *k,
1197                                               Handle class_loader, Handle module,
1198                                               Handle protection_domain, TRAPS) {
1199   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1200   // see more details in SystemDictionary::resolve_well_known_classes().
1201   if (!SystemDictionary::Class_klass_loaded()) {
1202     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1203     fixup_mirror_list()-&gt;push(k);
1204     return true;
1205   }
1206 
1207   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
<span class="line-removed">1208 </span>
1209   if (m == NULL) {
1210     return false;
1211   }
1212 
<span class="line-removed">1213   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));</span>
<span class="line-removed">1214 </span>
1215   // mirror is archived, restore

1216   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);


1217   Handle mirror(THREAD, m);
1218 
1219   if (!k-&gt;is_array_klass()) {
1220     // - local static final fields with initial values were initialized at dump time
1221 
1222     // create the init_lock
1223     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1224     set_init_lock(mirror(), r);
1225 
1226     if (protection_domain.not_null()) {
1227       set_protection_domain(mirror(), protection_domain());
1228     }
1229   }
1230 
1231   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1232   if (class_loader.not_null()) {
1233     set_class_loader(mirror(), class_loader());
1234   }
1235 
1236   k-&gt;set_java_mirror(mirror);
1237   k-&gt;clear_has_raw_archived_mirror();
1238 
1239   set_mirror_module_field(k, mirror, module, THREAD);
1240 
<span class="line-modified">1241   ResourceMark rm;</span>
<span class="line-modified">1242   log_trace(cds, heap, mirror)(</span>
<span class="line-modified">1243     &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));</span>


1244 
1245   return true;
1246 }
1247 #endif // INCLUDE_CDS_JAVA_HEAP
1248 
1249 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1250   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1251   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1252 }
1253 
1254 int  java_lang_Class::oop_size(oop java_class) {
1255   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1256   int size = java_class-&gt;int_field(_oop_size_offset);
1257   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1258   return size;
1259 }
1260 
1261 
1262 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1263   assert(_oop_size_offset != 0, &quot;must be set&quot;);
</pre>
<hr />
<pre>
1309   return java_class-&gt;obj_field_addr_raw&lt;oop&gt;(_init_lock_offset);
1310 }
1311 #endif  // INCLUDE_TSAN
1312 
1313 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1314   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1315   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1316 }
1317 
1318 objArrayOop java_lang_Class::signers(oop java_class) {
1319   assert(_signers_offset != 0, &quot;must be set&quot;);
1320   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1321 }
1322 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1323   assert(_signers_offset != 0, &quot;must be set&quot;);
1324   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1325 }
1326 
1327 
1328 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
<span class="line-modified">1329   // jdk7 runs Queens in bootstrapping and jdk8-9 has no coordinated pushes yet.</span>
<span class="line-modified">1330   if (_class_loader_offset != 0) {</span>
<span class="line-removed">1331     java_class-&gt;obj_field_put(_class_loader_offset, loader);</span>
<span class="line-removed">1332   }</span>
1333 }
1334 
1335 oop java_lang_Class::class_loader(oop java_class) {
1336   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1337   return java_class-&gt;obj_field(_class_loader_offset);
1338 }
1339 
1340 oop java_lang_Class::module(oop java_class) {
1341   assert(_module_offset != 0, &quot;must be set&quot;);
1342   return java_class-&gt;obj_field(_module_offset);
1343 }
1344 
1345 void java_lang_Class::set_module(oop java_class, oop module) {
1346   assert(_module_offset != 0, &quot;must be set&quot;);
1347   java_class-&gt;obj_field_put(_module_offset, module);
1348 }
1349 
1350 oop java_lang_Class::name(Handle java_class, TRAPS) {
1351   assert(_name_offset != 0, &quot;must be set&quot;);
1352   oop o = java_class-&gt;obj_field(_name_offset);
</pre>
<hr />
<pre>
1410 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1411   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1412   Symbol* name = NULL;
1413   bool is_instance = false;
1414   if (is_primitive(java_class)) {
1415     name = vmSymbols::type_signature(primitive_type(java_class));
1416   } else {
1417     Klass* k = as_Klass(java_class);
1418     is_instance = k-&gt;is_instance_klass();
1419     name = k-&gt;name();
1420   }
1421   if (name == NULL) {
1422     st-&gt;print(&quot;&lt;null&gt;&quot;);
1423     return;
1424   }
1425   if (is_instance)  st-&gt;print(&quot;L&quot;);
1426   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1427   if (is_instance)  st-&gt;print(&quot;;&quot;);
1428 }
1429 
<span class="line-modified">1430 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found, TRAPS) {</span>
1431   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1432   Symbol* name;
1433   if (is_primitive(java_class)) {
1434     name = vmSymbols::type_signature(primitive_type(java_class));
1435     // Because this can create a new symbol, the caller has to decrement
1436     // the refcount, so make adjustment here and below for symbols returned
1437     // that are not created or incremented due to a successful lookup.
1438     name-&gt;increment_refcount();
1439   } else {
1440     Klass* k = as_Klass(java_class);
1441     if (!k-&gt;is_instance_klass()) {
1442       name = k-&gt;name();
1443       name-&gt;increment_refcount();
1444     } else {
1445       ResourceMark rm;
1446       const char* sigstr = k-&gt;signature_name();
1447       int         siglen = (int) strlen(sigstr);
1448       if (!intern_if_not_found) {
1449         name = SymbolTable::probe(sigstr, siglen);
1450       } else {
<span class="line-modified">1451         name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
1452       }
1453     }
1454   }
1455   return name;
1456 }
1457 
1458 // Returns the Java name for this Java mirror (Resource allocated)
1459 // See Klass::external_name().
1460 // For primitive type Java mirrors, its type name is returned.
1461 const char* java_lang_Class::as_external_name(oop java_class) {
1462   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1463   const char* name = NULL;
1464   if (is_primitive(java_class)) {
1465     name = type2name(primitive_type(java_class));
1466   } else {
1467     name = as_Klass(java_class)-&gt;external_name();
1468   }
1469   if (name == NULL) {
1470     name = &quot;&lt;null&gt;&quot;;
1471   }
</pre>
<hr />
<pre>
1476   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1477   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1478   return k;
1479 }
1480 
1481 
1482 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1483   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1484   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1485 }
1486 
1487 
1488 BasicType java_lang_Class::primitive_type(oop java_class) {
1489   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1490   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1491   BasicType type = T_VOID;
1492   if (ak != NULL) {
1493     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1494     type = ArrayKlass::cast(ak)-&gt;element_type();
1495   } else {
<span class="line-modified">1496     assert(oopDesc::equals(java_class, Universe::void_mirror()), &quot;only valid non-array primitive&quot;);</span>
1497   }
<span class="line-modified">1498   assert(oopDesc::equals(Universe::java_mirror(type), java_class), &quot;must be consistent&quot;);</span>
1499   return type;
1500 }
1501 
1502 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1503   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1504   if (is_primitive(java_class)) {
1505     if (reference_klass != NULL)
1506       (*reference_klass) = NULL;
1507     return primitive_type(java_class);
1508   } else {
1509     if (reference_klass != NULL)
1510       (*reference_klass) = as_Klass(java_class);
1511     return T_OBJECT;
1512   }
1513 }
1514 
1515 
1516 oop java_lang_Class::primitive_mirror(BasicType t) {
1517   oop mirror = Universe::java_mirror(t);
1518   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1519   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1520   return mirror;
1521 }
1522 
1523 bool java_lang_Class::offsets_computed = false;
1524 int  java_lang_Class::classRedefinedCount_offset = -1;
1525 
1526 #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">1527   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false) ; \</span>
1528   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1529   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1530   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1531   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1532 
1533 void java_lang_Class::compute_offsets() {
1534   if (offsets_computed) {
1535     return;
1536   }
1537 
1538   offsets_computed = true;
1539 
1540   InstanceKlass* k = SystemDictionary::Class_klass();
1541   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1542 
1543   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1544   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1545   // GC treats them the same.
1546   _init_lock_offset = _component_mirror_offset;
1547 
1548   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1549 }
1550 
1551 #if INCLUDE_CDS
1552 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1553   f-&gt;do_u4((u4*)&amp;offsets_computed);</span>
1554   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1555 
1556   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1557 
1558   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1559 }
1560 #endif
1561 
1562 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1563   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">1564     // If we don&#39;t have an offset for it then just return -1 as a marker.</span>
<span class="line-removed">1565     return -1;</span>
<span class="line-removed">1566   }</span>
<span class="line-removed">1567 </span>
1568   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1569 }
1570 
1571 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1572   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">1573     // If we don&#39;t have an offset for it then nothing to set.</span>
<span class="line-removed">1574     return;</span>
<span class="line-removed">1575   }</span>
<span class="line-removed">1576 </span>
1577   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1578 }
1579 
1580 
1581 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1582 //       platform thread structure, and a eetop offset which was used for thread
1583 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1584 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1585 //       instead of the privateInfo_offset.
1586 //
1587 // Note: The stackSize field is only present starting in 1.4.
1588 
1589 int java_lang_Thread::_name_offset = 0;
1590 int java_lang_Thread::_group_offset = 0;
1591 int java_lang_Thread::_contextClassLoader_offset = 0;
1592 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1593 int java_lang_Thread::_priority_offset = 0;
1594 int java_lang_Thread::_eetop_offset = 0;

1595 int java_lang_Thread::_daemon_offset = 0;
1596 int java_lang_Thread::_stillborn_offset = 0;
1597 int java_lang_Thread::_stackSize_offset = 0;
1598 int java_lang_Thread::_tid_offset = 0;
1599 int java_lang_Thread::_thread_status_offset = 0;
1600 int java_lang_Thread::_park_blocker_offset = 0;
<span class="line-removed">1601 int java_lang_Thread::_park_event_offset = 0 ;</span>
1602 
1603 #define THREAD_FIELDS_DO(macro) \
1604   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1605   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1606   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1607   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1608   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1609   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1610   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \

1611   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1612   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1613   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1614   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
<span class="line-modified">1615   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false); \</span>
<span class="line-removed">1616   macro(_park_event_offset,    k, &quot;nativeParkEventPointer&quot;, long_signature, false)</span>
1617 
1618 void java_lang_Thread::compute_offsets() {
1619   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1620 
1621   InstanceKlass* k = SystemDictionary::Thread_klass();
1622   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1623 }
1624 
1625 #if INCLUDE_CDS
1626 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1627   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1628 }
1629 #endif
1630 
1631 JavaThread* java_lang_Thread::thread(oop java_thread) {
1632   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1633 }
1634 
1635 
1636 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1637   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1638 }
1639 


















1640 
1641 oop java_lang_Thread::name(oop java_thread) {
1642   return java_thread-&gt;obj_field(_name_offset);
1643 }
1644 
1645 
1646 void java_lang_Thread::set_name(oop java_thread, oop name) {
1647   java_thread-&gt;obj_field_put(_name_offset, name);
1648 }
1649 
1650 
1651 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1652   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1653 }
1654 
1655 
1656 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1657   java_thread-&gt;int_field_put(_priority_offset, priority);
1658 }
1659 
</pre>
<hr />
<pre>
1682 
1683 bool java_lang_Thread::is_daemon(oop java_thread) {
1684   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1685 }
1686 
1687 
1688 void java_lang_Thread::set_daemon(oop java_thread) {
1689   java_thread-&gt;bool_field_put(_daemon_offset, true);
1690 }
1691 
1692 oop java_lang_Thread::context_class_loader(oop java_thread) {
1693   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1694 }
1695 
1696 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1697   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1698 }
1699 
1700 
1701 jlong java_lang_Thread::stackSize(oop java_thread) {
<span class="line-modified">1702   if (_stackSize_offset &gt; 0) {</span>
<span class="line-removed">1703     return java_thread-&gt;long_field(_stackSize_offset);</span>
<span class="line-removed">1704   } else {</span>
<span class="line-removed">1705     return 0;</span>
<span class="line-removed">1706   }</span>
1707 }
1708 
1709 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1710 void java_lang_Thread::set_thread_status(oop java_thread,
1711                                          java_lang_Thread::ThreadStatus status) {
<span class="line-modified">1712   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">1713   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">1714     java_thread-&gt;int_field_put(_thread_status_offset, status);</span>
<span class="line-removed">1715   }</span>
1716 }
1717 
1718 // Read thread status value from threadStatus field in java.lang.Thread java class.
1719 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1720   // Make sure the caller is operating on behalf of the VM or is
1721   // running VM code (state == _thread_in_vm).
1722   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1723          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1724          &quot;Java Thread is not running in vm&quot;);
<span class="line-modified">1725   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">1726   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">1727     return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);</span>
<span class="line-removed">1728   } else {</span>
<span class="line-removed">1729     // All we can easily figure out is if it is alive, but that is</span>
<span class="line-removed">1730     // enough info for a valid unknown status.</span>
<span class="line-removed">1731     // These aren&#39;t restricted to valid set ThreadStatus values, so</span>
<span class="line-removed">1732     // use JVMTI values and cast.</span>
<span class="line-removed">1733     JavaThread* thr = java_lang_Thread::thread(java_thread);</span>
<span class="line-removed">1734     if (thr == NULL) {</span>
<span class="line-removed">1735       // the thread hasn&#39;t run yet or is in the process of exiting</span>
<span class="line-removed">1736       return NEW;</span>
<span class="line-removed">1737     }</span>
<span class="line-removed">1738     return (java_lang_Thread::ThreadStatus)JVMTI_THREAD_STATE_ALIVE;</span>
<span class="line-removed">1739   }</span>
1740 }
1741 
1742 
1743 jlong java_lang_Thread::thread_id(oop java_thread) {
<span class="line-modified">1744   // The thread ID field is only present starting in 1.5</span>
<span class="line-removed">1745   if (_tid_offset &gt; 0) {</span>
<span class="line-removed">1746     return java_thread-&gt;long_field(_tid_offset);</span>
<span class="line-removed">1747   } else {</span>
<span class="line-removed">1748     return 0;</span>
<span class="line-removed">1749   }</span>
1750 }
1751 
1752 oop java_lang_Thread::park_blocker(oop java_thread) {
<span class="line-modified">1753   assert(JDK_Version::current().supports_thread_park_blocker() &amp;&amp;</span>
<span class="line-removed">1754          _park_blocker_offset != 0, &quot;Must support parkBlocker field&quot;);</span>
<span class="line-removed">1755 </span>
<span class="line-removed">1756   if (_park_blocker_offset &gt; 0) {</span>
<span class="line-removed">1757     return java_thread-&gt;obj_field(_park_blocker_offset);</span>
<span class="line-removed">1758   }</span>
<span class="line-removed">1759 </span>
<span class="line-removed">1760   return NULL;</span>
<span class="line-removed">1761 }</span>
<span class="line-removed">1762 </span>
<span class="line-removed">1763 jlong java_lang_Thread::park_event(oop java_thread) {</span>
<span class="line-removed">1764   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">1765     return java_thread-&gt;long_field(_park_event_offset);</span>
<span class="line-removed">1766   }</span>
<span class="line-removed">1767   return 0;</span>
1768 }
1769 
<span class="line-removed">1770 bool java_lang_Thread::set_park_event(oop java_thread, jlong ptr) {</span>
<span class="line-removed">1771   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">1772     java_thread-&gt;long_field_put(_park_event_offset, ptr);</span>
<span class="line-removed">1773     return true;</span>
<span class="line-removed">1774   }</span>
<span class="line-removed">1775   return false;</span>
<span class="line-removed">1776 }</span>
<span class="line-removed">1777 </span>
<span class="line-removed">1778 </span>
1779 const char* java_lang_Thread::thread_status_name(oop java_thread) {
<span class="line-removed">1780   assert(_thread_status_offset != 0, &quot;Must have thread status&quot;);</span>
1781   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1782   switch (status) {
1783     case NEW                      : return &quot;NEW&quot;;
1784     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1785     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1786     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1787     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1788     case PARKED                   : return &quot;WAITING (parking)&quot;;
1789     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1790     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1791     case TERMINATED               : return &quot;TERMINATED&quot;;
1792     default                       : return &quot;UNKNOWN&quot;;
1793   };
1794 }
1795 int java_lang_ThreadGroup::_parent_offset = 0;
1796 int java_lang_ThreadGroup::_name_offset = 0;
1797 int java_lang_ThreadGroup::_threads_offset = 0;
1798 int java_lang_ThreadGroup::_groups_offset = 0;
1799 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1800 int java_lang_ThreadGroup::_destroyed_offset = 0;
</pre>
<hr />
<pre>
1914 }
1915 
1916 int java_lang_Throwable::depth(oop throwable) {
1917   return throwable-&gt;int_field(depth_offset);
1918 }
1919 
1920 void java_lang_Throwable::set_depth(oop throwable, int value) {
1921   throwable-&gt;int_field_put(depth_offset, value);
1922 }
1923 
1924 oop java_lang_Throwable::message(oop throwable) {
1925   return throwable-&gt;obj_field(detailMessage_offset);
1926 }
1927 
1928 
1929 // Return Symbol for detailed_message or NULL
1930 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1931   PRESERVE_EXCEPTION_MARK;  // Keep original exception
1932   oop detailed_message = java_lang_Throwable::message(throwable);
1933   if (detailed_message != NULL) {
<span class="line-modified">1934     return java_lang_String::as_symbol(detailed_message, THREAD);</span>
1935   }
1936   return NULL;
1937 }
1938 
1939 void java_lang_Throwable::set_message(oop throwable, oop value) {
1940   throwable-&gt;obj_field_put(detailMessage_offset, value);
1941 }
1942 
1943 
1944 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
1945   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
1946 }
1947 
1948 void java_lang_Throwable::clear_stacktrace(oop throwable) {
1949   set_stacktrace(throwable, NULL);
1950 }
1951 
1952 
1953 void java_lang_Throwable::print(oop throwable, outputStream* st) {
1954   ResourceMark rm;
1955   Klass* k = throwable-&gt;klass();
1956   assert(k != NULL, &quot;just checking&quot;);
1957   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
1958   oop msg = message(throwable);
1959   if (msg != NULL) {
1960     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
1961   }
1962 }
1963 
1964 // After this many redefines, the stack trace is unreliable.
1965 const int MAX_VERSION = USHRT_MAX;
1966 
1967 static inline bool version_matches(Method* method, int version) {
1968   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
1969   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
1970 }
1971 
<span class="line-removed">1972 </span>
1973 // This class provides a simple wrapper over the internal structure of
1974 // exception backtrace to insulate users of the backtrace from needing
1975 // to know what it looks like.


1976 class BacktraceBuilder: public StackObj {
1977  friend class BacktraceIterator;
1978  private:
1979   Handle          _backtrace;
1980   objArrayOop     _head;
1981   typeArrayOop    _methods;
1982   typeArrayOop    _bcis;
1983   objArrayOop     _mirrors;
<span class="line-modified">1984   typeArrayOop    _names; // needed to insulate method name against redefinition</span>




1985   int             _index;
1986   NoSafepointVerifier _nsv;
1987 
1988   enum {
1989     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
1990     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
1991     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
1992     trace_names_offset   = java_lang_Throwable::trace_names_offset,
1993     trace_next_offset    = java_lang_Throwable::trace_next_offset,

1994     trace_size           = java_lang_Throwable::trace_size,
1995     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
1996   };
1997 
1998   // get info out of chunks
1999   static typeArrayOop get_methods(objArrayHandle chunk) {
2000     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2001     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2002     return methods;
2003   }
2004   static typeArrayOop get_bcis(objArrayHandle chunk) {
2005     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2006     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2007     return bcis;
2008   }
2009   static objArrayOop get_mirrors(objArrayHandle chunk) {
2010     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2011     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2012     return mirrors;
2013   }
2014   static typeArrayOop get_names(objArrayHandle chunk) {
2015     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2016     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2017     return names;
2018   }




2019 
2020  public:
2021 
2022   // constructor for new backtrace
<span class="line-modified">2023   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL) {</span>
2024     expand(CHECK);
2025     _backtrace = Handle(THREAD, _head);
2026     _index = 0;
2027   }
2028 
2029   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2030     _methods = get_methods(backtrace);
2031     _bcis = get_bcis(backtrace);
2032     _mirrors = get_mirrors(backtrace);
2033     _names = get_names(backtrace);

2034     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2035            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2036            _mirrors-&gt;length() == _names-&gt;length(),
2037            &quot;method and source information arrays should match&quot;);
2038 
2039     // head is the preallocated backtrace
2040     _head = backtrace();
2041     _backtrace = Handle(thread, _head);
2042     _index = 0;
2043   }
2044 
2045   void expand(TRAPS) {
2046     objArrayHandle old_head(THREAD, _head);
2047     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2048 
2049     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2050     objArrayHandle new_head(THREAD, head);
2051 
2052     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2053     typeArrayHandle new_methods(THREAD, methods);
2054 
2055     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2056     typeArrayHandle new_bcis(THREAD, bcis);
2057 
2058     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2059     objArrayHandle new_mirrors(THREAD, mirrors);
2060 
2061     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2062     typeArrayHandle new_names(THREAD, names);
2063 
2064     if (!old_head.is_null()) {
2065       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2066     }
2067     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2068     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2069     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2070     new_head-&gt;obj_at_put(trace_names_offset, new_names());

2071 
2072     _head    = new_head();
2073     _methods = new_methods();
2074     _bcis = new_bcis();
2075     _mirrors = new_mirrors();
2076     _names  = new_names();
2077     _index = 0;
2078   }
2079 
2080   oop backtrace() {
2081     return _backtrace();
2082   }
2083 
2084   inline void push(Method* method, int bci, TRAPS) {
2085     // Smear the -1 bci to 0 since the array only holds unsigned
2086     // shorts.  The later line number lookup would just smear the -1
2087     // to a 0 even if it could be recorded.
2088     if (bci == SynchronizationEntryBCI) bci = 0;
2089 
2090     if (_index &gt;= trace_chunk_size) {
2091       methodHandle mhandle(THREAD, method);
2092       expand(CHECK);
2093       method = mhandle();
2094     }
2095 
2096     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2097     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2098 
2099     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2100     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2101     Symbol* name = method-&gt;name();
2102     _names-&gt;symbol_at_put(_index, name);
2103 
2104     // We need to save the mirrors in the backtrace to keep the class
2105     // from being unloaded while we still have this stack trace.
2106     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2107     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2108     _index++;
2109   }
2110 














2111 };
2112 
2113 struct BacktraceElement : public StackObj {
2114   int _method_id;
2115   int _bci;
2116   int _version;
2117   Symbol* _name;
2118   Handle _mirror;
2119   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2120                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2121 };
2122 
2123 class BacktraceIterator : public StackObj {
2124   int _index;
2125   objArrayHandle  _result;
2126   objArrayHandle  _mirrors;
2127   typeArrayHandle _methods;
2128   typeArrayHandle _bcis;
2129   typeArrayHandle _names;
2130 
</pre>
<hr />
<pre>
2226       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2227         // Sourcename and linenumber
2228         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2229       } else if (source_file_name != NULL) {
2230         // Just sourcename
2231         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2232       } else {
2233         // Neither sourcename nor linenumber
2234         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2235       }
2236       CompiledMethod* nm = method-&gt;code();
2237       if (WizardMode &amp;&amp; nm != NULL) {
2238         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2239       }
2240     }
2241   }
2242 
2243   st-&gt;print_cr(&quot;%s&quot;, buf);
2244 }
2245 
<span class="line-modified">2246 void java_lang_Throwable::print_stack_element(outputStream *st, const methodHandle&amp; method, int bci) {</span>
2247   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2248   int method_id = method-&gt;orig_method_idnum();
2249   int version = method-&gt;constants()-&gt;version();
2250   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2251 }
2252 
2253 /**
2254  * Print the throwable message and its stack trace plus all causes by walking the
2255  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2256  */
2257 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2258   // First, print the message.
2259   print(throwable(), st);
2260   st-&gt;cr();
2261 
2262   // Now print the stack trace.
2263   Thread* THREAD = Thread::current();
2264   while (throwable.not_null()) {
2265     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2266     if (result.is_null()) {
</pre>
<hr />
<pre>
2332   // If there is no Java frame just return the method that was being called
2333   // with bci 0
2334   if (!thread-&gt;has_last_Java_frame()) {
2335     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2336       bt.push(method(), 0, CHECK);
2337       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2338       set_depth(throwable(), 1);
2339       set_backtrace(throwable(), bt.backtrace());
2340     }
2341     return;
2342   }
2343 
2344   // Instead of using vframe directly, this version of fill_in_stack_trace
2345   // basically handles everything by hand. This significantly improved the
2346   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2347   // See bug 6333838 for  more details.
2348   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2349   // trace as utilizing vframe.
2350 #ifdef ASSERT
2351   vframeStream st(thread);
<span class="line-removed">2352   methodHandle st_method(THREAD, st.method());</span>
2353 #endif
2354   int total_count = 0;
2355   RegisterMap map(thread, false);
2356   int decode_offset = 0;
2357   CompiledMethod* nm = NULL;
2358   bool skip_fillInStackTrace_check = false;
2359   bool skip_throwableInit_check = false;
2360   bool skip_hidden = !ShowHiddenFrames;
2361 
2362   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2363     Method* method = NULL;
2364     int bci = 0;
2365 
2366     // Compiled java method case.
2367     if (decode_offset != 0) {
2368       DebugInfoReadStream stream(nm, decode_offset);
2369       decode_offset = stream.read_int();
2370       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2371       bci = stream.read_bci();
2372     } else {
</pre>
<hr />
<pre>
2382         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2383         // but non nmethod
2384         fr = fr.sender(&amp;map);
2385         if (cb == NULL || !cb-&gt;is_compiled()) {
2386           continue;
2387         }
2388         nm = cb-&gt;as_compiled_method();
2389         if (nm-&gt;method()-&gt;is_native()) {
2390           method = nm-&gt;method();
2391           bci = 0;
2392         } else {
2393           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2394           decode_offset = pd-&gt;scope_decode_offset();
2395           // if decode_offset is not equal to 0, it will execute the
2396           // &quot;compiled java method case&quot; at the beginning of the loop.
2397           continue;
2398         }
2399       }
2400     }
2401 #ifdef ASSERT
<span class="line-modified">2402     assert(st_method() == method &amp;&amp; st.bci() == bci,</span>
2403            &quot;Wrong stack trace&quot;);
2404     st.next();
<span class="line-removed">2405     // vframeStream::method isn&#39;t GC-safe so store off a copy</span>
<span class="line-removed">2406     // of the Method* in case we GC.</span>
<span class="line-removed">2407     if (!st.at_end()) {</span>
<span class="line-removed">2408       st_method = st.method();</span>
<span class="line-removed">2409     }</span>
2410 #endif
2411 
2412     // the format of the stacktrace will be:
2413     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2414     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2415     // - rest of the stack
2416 
2417     if (!skip_fillInStackTrace_check) {
2418       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2419           throwable-&gt;is_a(method-&gt;method_holder())) {
2420         continue;
2421       }
2422       else {
2423         skip_fillInStackTrace_check = true; // gone past them all
2424       }
2425     }
2426     if (!skip_throwableInit_check) {
2427       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2428 
2429       // skip &lt;init&gt; methods of the exception class and superclasses
2430       // This is simlar to classic VM.
2431       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
2432           throwable-&gt;is_a(method-&gt;method_holder())) {
2433         continue;
2434       } else {
2435         // there are none or we&#39;ve seen them all - either way stop checking
2436         skip_throwableInit_check = true;
2437       }
2438     }
2439     if (method-&gt;is_hidden()) {
<span class="line-modified">2440       if (skip_hidden)  continue;</span>






2441     }
2442     bt.push(method, bci, CHECK);
2443     total_count++;
2444   }
2445 
2446   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2447 
2448   // Put completed stack trace into throwable object
2449   set_backtrace(throwable(), bt.backtrace());
2450   set_depth(throwable(), total_count);
2451 }
2452 
2453 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2454   // No-op if stack trace is disabled
2455   if (!StackTraceInThrowable) {
2456     return;
2457   }
2458 
2459   // Disable stack traces for some preallocated out of memory errors
2460   if (!Universe::should_fill_in_stack_trace(throwable)) {
</pre>
<hr />
<pre>
2537   while (iter.repeat()) {
2538     BacktraceElement bte = iter.next(THREAD);
2539 
2540     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2541 
2542     if (stack_trace_element.is_null()) {
2543       THROW(vmSymbols::java_lang_NullPointerException());
2544     }
2545 
2546     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2547     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2548 
2549     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2550                                          method,
2551                                          bte._version,
2552                                          bte._bci,
2553                                          bte._name, CHECK);
2554   }
2555 }
2556 































2557 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2558   // Allocate java.lang.StackTraceElement instance
2559   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2560   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2561   if (k-&gt;should_be_initialized()) {
2562     k-&gt;initialize(CHECK_0);
2563   }
2564 
2565   Handle element = k-&gt;allocate_instance_handle(CHECK_0);
2566 
2567   int version = method-&gt;constants()-&gt;version();
2568   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_0);
2569   return element();
2570 }
2571 
2572 void java_lang_StackTraceElement::fill_in(Handle element,
2573                                           InstanceKlass* holder, const methodHandle&amp; method,
2574                                           int version, int bci, Symbol* name, TRAPS) {
2575   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2576 
</pre>
<hr />
<pre>
2596 
2597   // Fill in module name and version
2598   ModuleEntry* module = holder-&gt;module();
2599   if (module-&gt;is_named()) {
2600     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2601     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2602     oop module_version;
2603     if (module-&gt;version() != NULL) {
2604       module_version = StringTable::intern(module-&gt;version(), CHECK);
2605     } else {
2606       module_version = NULL;
2607     }
2608     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2609   }
2610 
2611   if (method() == NULL || !version_matches(method(), version)) {
2612     // The method was redefined, accurate line number information isn&#39;t available
2613     java_lang_StackTraceElement::set_fileName(element(), NULL);
2614     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2615   } else {
<span class="line-modified">2616     // Fill in source file name and line number.</span>
<span class="line-modified">2617     Symbol* source = Backtrace::get_source_file_name(holder, version);</span>
<span class="line-modified">2618     oop source_file = java_lang_Class::source_file(java_class());</span>
<span class="line-modified">2619     if (source != NULL) {</span>
<span class="line-removed">2620       // Class was not redefined. We can trust its cache if set,</span>
<span class="line-removed">2621       // else we have to initialize it.</span>
<span class="line-removed">2622       if (source_file == NULL) {</span>
<span class="line-removed">2623         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">2624         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">2625       }</span>
<span class="line-removed">2626     } else {</span>
<span class="line-removed">2627       // Class was redefined. Dump the cache if it was set.</span>
<span class="line-removed">2628       if (source_file != NULL) {</span>
<span class="line-removed">2629         source_file = NULL;</span>
<span class="line-removed">2630         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">2631       }</span>
<span class="line-removed">2632       if (ShowHiddenFrames) {</span>
<span class="line-removed">2633         source = vmSymbols::unknown_class_name();</span>
<span class="line-removed">2634         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">2635       }</span>
<span class="line-removed">2636     }</span>
<span class="line-removed">2637     java_lang_StackTraceElement::set_fileName(element(), source_file);</span>
2638 
<span class="line-modified">2639     int line_number = Backtrace::get_line_number(method, bci);</span>
2640     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2641   }
2642 }
2643 













































2644 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2645   HandleMark hm(THREAD);
2646   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2647   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2648   // we should expand MemberName::name when Throwable uses StackTrace
2649   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2650   return method;
2651 }
2652 
2653 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2654   // set Method* or mid/cpref
2655   HandleMark hm(THREAD);
2656   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2657   InstanceKlass* ik = method-&gt;method_holder();
2658   CallInfo info(method(), ik, CHECK);
2659   MethodHandles::init_method_MemberName(mname, info);
2660   // set bci
2661   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2662   // method may be redefined; store the version
2663   int version = method-&gt;constants()-&gt;version();
2664   assert((jushort)version == version, &quot;version should be short&quot;);
2665   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2666 }
2667 
2668 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2669   ResourceMark rm(THREAD);
2670   HandleMark hm(THREAD);
2671   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2672   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2673   InstanceKlass* holder = InstanceKlass::cast(clazz);
2674   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2675 
2676   short version = stackFrame-&gt;short_field(_version_offset);
<span class="line-modified">2677   short bci = stackFrame-&gt;short_field(_bci_offset);</span>
2678   Symbol* name = method-&gt;name();
<span class="line-modified">2679   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, method, version, bci, name, CHECK);</span>

2680 }
2681 
2682 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2683   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
<span class="line-modified">2684   macro(_bci_offset,            k, &quot;bci&quot;,         short_signature,  false)</span>
2685 
2686 void java_lang_StackFrameInfo::compute_offsets() {
2687   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2688   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2689   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2690 }
2691 
2692 #if INCLUDE_CDS
2693 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2694   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2695   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2696 }
2697 #endif
2698 
2699 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2700   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2701   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2702   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2703   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2704 
</pre>
<hr />
<pre>
3004 int java_lang_reflect_Field::modifiers(oop field) {
3005   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3006   return field-&gt;int_field(modifiers_offset);
3007 }
3008 
3009 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3010   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3011   field-&gt;int_field_put(modifiers_offset, value);
3012 }
3013 
3014 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3015   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3016   field-&gt;obj_field_put(signature_offset, value);
3017 }
3018 
3019 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3020   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3021   field-&gt;obj_field_put(annotations_offset, value);
3022 }
3023 


























































3024 #define CONSTANTPOOL_FIELDS_DO(macro) \
3025   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3026 
3027 void reflect_ConstantPool::compute_offsets() {
3028   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3029   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3030   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3031 }
3032 
3033 #if INCLUDE_CDS
3034 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3035   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3036 }
3037 #endif
3038 
3039 #define PARAMETER_FIELDS_DO(macro) \
3040   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3041   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3042   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3043   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
</pre>
<hr />
<pre>
3603 
3604 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3605   assert(is_instance(mname), &quot;wrong type&quot;);
3606   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3607 }
3608 
3609 
3610 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3611   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3612   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3613   assert(m-&gt;is_method(), &quot;must be&quot;);
3614   return m;
3615 }
3616 
3617 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3618 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3619   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3620   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3621 }
3622 





3623 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {


3624   // lookup ResolvedMethod oop in the table, or create a new one and intern it
<span class="line-modified">3625   oop resolved_method = ResolvedMethodTable::find_method(m());</span>
<span class="line-modified">3626   if (resolved_method == NULL) {</span>
<span class="line-modified">3627     InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();</span>
<span class="line-removed">3628     if (!k-&gt;is_initialized()) {</span>
<span class="line-removed">3629       k-&gt;initialize(CHECK_NULL);</span>
<span class="line-removed">3630     }</span>
<span class="line-removed">3631     oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-removed">3632     new_resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m());</span>
<span class="line-removed">3633     // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have</span>
<span class="line-removed">3634     // distinct loaders) to ensure the metadata is kept alive.</span>
<span class="line-removed">3635     // This mirror may be different than the one in clazz field.</span>
<span class="line-removed">3636     new_resolved_method-&gt;obj_field_put(_vmholder_offset, m-&gt;method_holder()-&gt;java_mirror());</span>
<span class="line-removed">3637     resolved_method = ResolvedMethodTable::add_method(m, Handle(THREAD, new_resolved_method));</span>
3638   }
<span class="line-modified">3639   return resolved_method;</span>




























3640 }
3641 
3642 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3643   assert(is_instance(lform), &quot;wrong type&quot;);
3644   return lform-&gt;obj_field(_vmentry_offset);
3645 }
3646 
3647 
3648 // Support for java_lang_invoke_MethodType
3649 
3650 int java_lang_invoke_MethodType::_rtype_offset;
3651 int java_lang_invoke_MethodType::_ptypes_offset;
3652 
3653 #define METHODTYPE_FIELDS_DO(macro) \
3654   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3655   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3656 
3657 void java_lang_invoke_MethodType::compute_offsets() {
3658   InstanceKlass* k = SystemDictionary::MethodType_klass();
3659   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3660 }
3661 
3662 #if INCLUDE_CDS
3663 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3664   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3665 }
3666 #endif
3667 
3668 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3669   st-&gt;print(&quot;(&quot;);
3670   objArrayOop pts = ptypes(mt);
3671   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3672     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3673   }
3674   st-&gt;print(&quot;)&quot;);
3675   java_lang_Class::print_signature(rtype(mt), st);
3676 }
3677 
<span class="line-modified">3678 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found, TRAPS) {</span>
3679   ResourceMark rm;
3680   stringStream buffer(128);
3681   print_signature(mt, &amp;buffer);
3682   const char* sigstr =       buffer.base();
3683   int         siglen = (int) buffer.size();
3684   Symbol *name;
3685   if (!intern_if_not_found) {
3686     name = SymbolTable::probe(sigstr, siglen);
3687   } else {
<span class="line-modified">3688     name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
3689   }
3690   return name;
3691 }
3692 
3693 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
<span class="line-modified">3694   if (oopDesc::equals(mt1, mt2))</span>
3695     return true;
<span class="line-modified">3696   if (!oopDesc::equals(rtype(mt1), rtype(mt2)))</span>
3697     return false;
3698   if (ptype_count(mt1) != ptype_count(mt2))
3699     return false;
3700   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
<span class="line-modified">3701     if (!oopDesc::equals(ptype(mt1, i), ptype(mt2, i)))</span>
3702       return false;
3703   }
3704   return true;
3705 }
3706 
3707 oop java_lang_invoke_MethodType::rtype(oop mt) {
3708   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3709   return mt-&gt;obj_field(_rtype_offset);
3710 }
3711 
3712 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
3713   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3714   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
3715 }
3716 
3717 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
3718   return ptypes(mt)-&gt;obj_at(idx);
3719 }
3720 
3721 int java_lang_invoke_MethodType::ptype_count(oop mt) {
</pre>
<hr />
<pre>
3749   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
3750 
3751 void java_lang_invoke_CallSite::compute_offsets() {
3752   InstanceKlass* k = SystemDictionary::CallSite_klass();
3753   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3754 }
3755 
3756 #if INCLUDE_CDS
3757 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
3758   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3759 }
3760 #endif
3761 
3762 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
3763   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
3764 
3765   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
3766   return dep_oop;
3767 }
3768 


















3769 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
3770 
3771 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
3772 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
3773 
3774 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
3775   InstanceKlass* k = SystemDictionary::Context_klass();
3776   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3777 }
3778 
3779 #if INCLUDE_CDS
3780 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
3781   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3782 }
3783 #endif
3784 
3785 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
3786   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
3787   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
3788   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
</pre>
<hr />
<pre>
3800 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
3801   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
3802   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
3803   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
3804   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
3805 
3806 void java_security_AccessControlContext::compute_offsets() {
3807   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
3808   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
3809   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3810 }
3811 
3812 #if INCLUDE_CDS
3813 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
3814   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3815 }
3816 #endif
3817 
3818 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
3819   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);

3820   // Ensure klass is initialized
3821   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);
3822   // Allocate result
3823   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);
3824   // Fill in values
3825   result-&gt;obj_field_put(_context_offset, context());
3826   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
3827   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
<span class="line-modified">3828   // whitelist AccessControlContexts created by the JVM if present</span>
<span class="line-modified">3829   if (_isAuthorized_offset != -1) {</span>
<span class="line-removed">3830     result-&gt;bool_field_put(_isAuthorized_offset, true);</span>
<span class="line-removed">3831   }</span>
3832   return result;
3833 }
3834 
3835 
3836 // Support for java_lang_ClassLoader
3837 
3838 bool java_lang_ClassLoader::offsets_computed = false;
3839 int  java_lang_ClassLoader::_loader_data_offset = -1;
3840 int  java_lang_ClassLoader::parallelCapable_offset = -1;
3841 int  java_lang_ClassLoader::name_offset = -1;
3842 int  java_lang_ClassLoader::nameAndId_offset = -1;
3843 int  java_lang_ClassLoader::unnamedModule_offset = -1;
3844 
3845 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
<span class="line-modified">3846   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3847   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
3848 }
3849 
3850 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
<span class="line-modified">3851   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3852   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
3853 }
3854 
3855 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
<span class="line-modified">3856   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>

3857   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
3858 }
3859 
3860 #define CLASSLOADER_FIELDS_DO(macro) \
3861   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
3862   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
3863   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
3864   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
3865   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
3866 
3867 void java_lang_ClassLoader::compute_offsets() {
3868   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
3869   offsets_computed = true;
3870 
3871   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
3872   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3873 
3874   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3875 }
3876 
</pre>
<hr />
<pre>
3895 
3896 // Returns the nameAndId field of this class loader. The format is
3897 // as follows:
3898 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
3899 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
3900 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
3901 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
3902 oop java_lang_ClassLoader::nameAndId(oop loader) {
3903   assert(is_instance(loader), &quot;loader must be oop&quot;);
3904   return loader-&gt;obj_field(nameAndId_offset);
3905 }
3906 
3907 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
3908   assert(is_instance(loader), &quot;loader must be oop&quot;);
3909   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
3910   oop acl = loader;
3911   debug_only(jint loop_count = 0);
3912   // This loop taken verbatim from ClassLoader.java:
3913   do {
3914     acl = parent(acl);
<span class="line-modified">3915     if (oopDesc::equals(cl, acl)) {</span>
3916       return true;
3917     }
3918     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
3919   } while (acl != NULL);
3920   return false;
3921 }
3922 
3923 bool java_lang_ClassLoader::is_instance(oop obj) {
3924   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3925 }
3926 
3927 
3928 // For class loader classes, parallelCapable defined
3929 // based on non-null field
3930 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
3931 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">3932   if (parallelCapable_offset == -1) {</span>
<span class="line-removed">3933      // Default for backward compatibility is false</span>
<span class="line-removed">3934      return false;</span>
<span class="line-removed">3935   }</span>
3936   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
3937 }
3938 
3939 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
3940   // Fix for 4474172; see evaluation for more details
3941   loader = non_reflection_class_loader(loader);
3942 
3943   oop cl = SystemDictionary::java_system_loader();
3944   while(cl != NULL) {
<span class="line-modified">3945     if (oopDesc::equals(cl, loader)) return true;</span>
3946     cl = parent(cl);
3947   }
3948   return false;
3949 }
3950 
3951 // Return true if this is one of the class loaders associated with
3952 // the generated bytecodes for reflection.
3953 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
3954   if (loader != NULL) {
3955     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
3956     // This might be null in non-1.4 JDKs
3957     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
3958   }
3959   return false;
3960 }
3961 
3962 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
3963   // See whether this is one of the class loaders associated with
3964   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
3965   // delegate to its parent to prevent class loading from occurring
</pre>
<hr />
<pre>
3981   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
3982   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
3983   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
3984   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
3985 
3986 void java_lang_System::compute_offsets() {
3987   InstanceKlass* k = SystemDictionary::System_klass();
3988   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3989 }
3990 
3991 #if INCLUDE_CDS
3992 void java_lang_System::serialize_offsets(SerializeClosure* f) {
3993    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3994 }
3995 #endif
3996 
3997 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
3998 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
3999 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4000 














































4001 int java_lang_Class::_klass_offset;
4002 int java_lang_Class::_array_klass_offset;
4003 int java_lang_Class::_oop_size_offset;
4004 int java_lang_Class::_static_oop_field_count_offset;
4005 int java_lang_Class::_class_loader_offset;
4006 int java_lang_Class::_module_offset;
4007 int java_lang_Class::_protection_domain_offset;
4008 int java_lang_Class::_component_mirror_offset;
4009 int java_lang_Class::_init_lock_offset;
4010 int java_lang_Class::_signers_offset;
4011 int java_lang_Class::_name_offset;
4012 int java_lang_Class::_source_file_offset;
4013 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4014 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4015 int java_lang_Throwable::backtrace_offset;
4016 int java_lang_Throwable::detailMessage_offset;
4017 int java_lang_Throwable::stackTrace_offset;
4018 int java_lang_Throwable::depth_offset;
4019 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4020 int java_lang_reflect_AccessibleObject::override_offset;
</pre>
<hr />
<pre>
4068 int java_lang_StackTraceElement::moduleVersion_offset;
4069 int java_lang_StackTraceElement::classLoaderName_offset;
4070 int java_lang_StackTraceElement::declaringClass_offset;
4071 int java_lang_StackTraceElement::declaringClassObject_offset;
4072 int java_lang_StackFrameInfo::_memberName_offset;
4073 int java_lang_StackFrameInfo::_bci_offset;
4074 int java_lang_StackFrameInfo::_version_offset;
4075 int java_lang_LiveStackFrameInfo::_monitors_offset;
4076 int java_lang_LiveStackFrameInfo::_locals_offset;
4077 int java_lang_LiveStackFrameInfo::_operands_offset;
4078 int java_lang_LiveStackFrameInfo::_mode_offset;
4079 int java_lang_AssertionStatusDirectives::classes_offset;
4080 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4081 int java_lang_AssertionStatusDirectives::packages_offset;
4082 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4083 int java_lang_AssertionStatusDirectives::deflt_offset;
4084 int java_nio_Buffer::_limit_offset;
4085 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4086 int reflect_ConstantPool::_oop_offset;
4087 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;















4088 
4089 
4090 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4091   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4092   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4093   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4094   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4095   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4096   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4097   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4098   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4099 
4100 // Support for java_lang_StackTraceElement
4101 void java_lang_StackTraceElement::compute_offsets() {
4102   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4103   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4104 }
4105 
4106 #if INCLUDE_CDS
4107 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
</pre>
<hr />
<pre>
4129   element-&gt;obj_field_put(moduleName_offset, value);
4130 }
4131 
4132 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4133   element-&gt;obj_field_put(moduleVersion_offset, value);
4134 }
4135 
4136 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4137   element-&gt;obj_field_put(classLoaderName_offset, value);
4138 }
4139 
4140 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4141   element-&gt;obj_field_put(declaringClassObject_offset, value);
4142 }
4143 
4144 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4145   element-&gt;short_field_put(_version_offset, value);
4146 }
4147 
4148 void java_lang_StackFrameInfo::set_bci(oop element, int value) {

4149   element-&gt;int_field_put(_bci_offset, value);
4150 }
4151 
4152 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4153   element-&gt;obj_field_put(_monitors_offset, value);
4154 }
4155 
4156 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4157   element-&gt;obj_field_put(_locals_offset, value);
4158 }
4159 
4160 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4161   element-&gt;obj_field_put(_operands_offset, value);
4162 }
4163 
4164 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4165   element-&gt;int_field_put(_mode_offset, value);
4166 }
4167 
4168 // Support for java Assertions - java_lang_AssertionStatusDirectives.
</pre>
<hr />
<pre>
4227 
4228 #define AOS_FIELDS_DO(macro) \
4229   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4230 
4231 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4232   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4233   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4234 }
4235 
4236 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4237   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4238   return obj-&gt;obj_field(_owner_offset);
4239 }
4240 
4241 #if INCLUDE_CDS
4242 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4243   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4244 }
4245 #endif
4246 


























































































































































































4247 static int member_offset(int hardcoded_offset) {
4248   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
4249 }
4250 

















































4251 // Compute hard-coded offsets
4252 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4253 // are not available to determine the offset_of_static_fields.
4254 void JavaClasses::compute_hard_coded_offsets() {
4255 
4256   // java_lang_boxing_object
4257   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4258   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4259 
4260   // java_lang_ref_Reference
4261   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4262   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4263   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4264   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4265 }
4266 
4267 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4268 
4269 // Compute non-hard-coded field offsets of all the classes in this file
4270 void JavaClasses::compute_offsets() {
4271   if (UseSharedSpaces) {
4272     assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4273                                               JvmtiExport::has_early_class_hook_env()),
4274            &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;);
4275     // None of the classes used by the rest of this function can be replaced by
4276     // JMVTI ClassFileLoadHook.
4277     // We are safe to use the archived offsets, which have already been restored
4278     // by JavaClasses::serialize_offsets, without computing the offsets again.
4279     return;
4280   }
4281 
4282   // We have already called the compute_offsets() of the
4283   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4284   // earlier inside SystemDictionary::resolve_well_known_classes()
4285   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
<span class="line-removed">4286 </span>
<span class="line-removed">4287   // generated interpreter code wants to know about the offsets we just computed:</span>
<span class="line-removed">4288   AbstractAssembler::update_delayed_values();</span>
4289 }
4290 
4291 #if INCLUDE_CDS
4292 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4293 
4294 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4295   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4296 }
4297 #endif
4298 






















4299 
4300 #ifndef PRODUCT
4301 
4302 // These functions exist to assert the validity of hard-coded field offsets to guard
4303 // against changes in the class files
4304 
4305 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
4306   EXCEPTION_MARK;
4307   fieldDescriptor fd;
<span class="line-modified">4308   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);</span>
4309   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4310   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">4311   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);</span>
<span class="line-modified">4312   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);</span>
4313   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4314     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4315     return false;
4316   }
4317   if (fd.is_static()) {
4318     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4319     return false;
4320   }
4321   if (fd.offset() == hardcoded_offset ) {
4322     return true;
4323   } else {
4324     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
4325                   klass_name, field_name, hardcoded_offset, fd.offset());
4326     return false;
4327   }
4328 }
4329 
4330 // Check the hard-coded field offsets of all the classes in this file
4331 
4332 void JavaClasses::check_offsets() {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">  31 #include &quot;classfile/symbolTable.hpp&quot;</span>
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
<span class="line-modified">  45 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  53 #include &quot;oops/recordComponent.hpp&quot;</span>
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added">  60 #include &quot;runtime/init.hpp&quot;</span>
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
<span class="line-added">  69 #include &quot;runtime/vm_version.hpp&quot;</span>
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
<span class="line-added">  72 #include &quot;utilities/utf8.hpp&quot;</span>
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  75 #endif
  76 
  77 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  78   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  79 
  80 #if INCLUDE_CDS
  81 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  82   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  83 #endif
  84 
  85 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  86   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  87 
  88 InjectedField JavaClasses::_injected_fields[] = {
  89   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  90 };
  91 
<span class="line-added">  92 // Register native methods of Object</span>
<span class="line-added">  93 void java_lang_Object::register_natives(TRAPS) {</span>
<span class="line-added">  94   InstanceKlass* obj = SystemDictionary::Object_klass();</span>
<span class="line-added">  95   Method::register_native(obj, vmSymbols::hashCode_name(),</span>
<span class="line-added">  96                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);</span>
<span class="line-added">  97   Method::register_native(obj, vmSymbols::wait_name(),</span>
<span class="line-added">  98                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);</span>
<span class="line-added">  99   Method::register_native(obj, vmSymbols::notify_name(),</span>
<span class="line-added"> 100                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);</span>
<span class="line-added"> 101   Method::register_native(obj, vmSymbols::notifyAll_name(),</span>
<span class="line-added"> 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);</span>
<span class="line-added"> 103   Method::register_native(obj, vmSymbols::clone_name(),</span>
<span class="line-added"> 104                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);</span>
<span class="line-added"> 105 }</span>
<span class="line-added"> 106 </span>
 107 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 108   return _injected_fields[id].compute_offset();
 109 }
 110 
 111 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 112   *field_count = 0;
 113 
 114   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 115   if (sid == vmSymbols::NO_SID) {
 116     // Only well known classes can inject fields
 117     return NULL;
 118   }
 119 
 120   int count = 0;
 121   int start = -1;
 122 
 123 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 124   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 125     count++;                                                       \
 126     if (start == -1) start = klass##_##name##_enum;                \
</pre>
<hr />
<pre>
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
 180 int java_lang_String::value_offset  = 0;
 181 int java_lang_String::hash_offset   = 0;
<span class="line-added"> 182 int java_lang_String::hashIsZero_offset = 0;</span>
 183 int java_lang_String::coder_offset  = 0;
 184 
 185 bool java_lang_String::initialized  = false;
 186 
 187 bool java_lang_String::is_instance(oop obj) {
 188   return is_instance_inlined(obj);
 189 }
 190 
 191 #if INCLUDE_CDS
 192 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 193   f-&gt;do_u4((u4*)&amp;offset)
 194 #endif
 195 
 196 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 197   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 198 
 199 #define STRING_FIELDS_DO(macro) \
 200   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 201   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
<span class="line-modified"> 202   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-added"> 203   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
 204 
 205 void java_lang_String::compute_offsets() {
 206   if (initialized) {
 207     return;
 208   }
 209 
 210   InstanceKlass* k = SystemDictionary::String_klass();
 211   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 212 
 213   initialized = true;
 214 }
 215 
 216 #if INCLUDE_CDS
 217 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 218   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 219   f-&gt;do_bool(&amp;initialized);</span>
 220 }
 221 #endif
 222 
 223 class CompactStringsFixup : public FieldClosure {
 224 private:
 225   bool _value;
 226 
 227 public:
 228   CompactStringsFixup(bool value) : _value(value) {}
 229 
 230   void do_field(fieldDescriptor* fd) {
 231     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 232       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 233       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 234       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 235       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 236     }
 237   }
 238 };
 239 
 240 void java_lang_String::set_compact_strings(bool value) {
 241   CompactStringsFixup fix(value);
<span class="line-modified"> 242   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);</span>
 243 }
 244 
 245 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 246   assert(initialized, &quot;Must be initialized&quot;);
 247   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 248 
 249   // Create the String object first, so there&#39;s a chance that the String
 250   // and the char array it points to end up in the same cache line.
 251   oop obj;
 252   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 253 
 254   // Create the char array.  The String object must be handlized here
 255   // because GC can happen as a result of the allocation attempt.
 256   Handle h_obj(THREAD, obj);
 257   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 258   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 259 
 260   // Point the String at the char array
 261   obj = h_obj();
 262   set_value(obj, buffer);
</pre>
<hr />
<pre>
 372 
 373 #ifdef ASSERT
 374   {
 375     ResourceMark rm;
 376     const char* expected = symbol-&gt;as_utf8();
 377     char* actual = as_utf8_string(h_obj());
 378     if (strncmp(expected, actual, utf8_len) != 0) {
 379       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 380       ShouldNotReachHere();
 381     }
 382   }
 383 #endif
 384 
 385   return h_obj;
 386 }
 387 
 388 // Converts a C string to a Java String based on current encoding
 389 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 390   assert(str != NULL, &quot;bad arguments&quot;);
 391 
<span class="line-modified"> 392   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);</span>
 393   static to_java_string_fn_t _to_java_string_fn = NULL;
 394 
 395   if (_to_java_string_fn == NULL) {
 396     void *lib_handle = os::native_java_library();
<span class="line-modified"> 397     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));</span>
<span class="line-added"> 398 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)</span>
<span class="line-added"> 399     if (_to_java_string_fn == NULL) {</span>
<span class="line-added"> 400       // On 32 bit Windows, also try __stdcall decorated name</span>
<span class="line-added"> 401       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));</span>
<span class="line-added"> 402     }</span>
<span class="line-added"> 403 #endif</span>
 404     if (_to_java_string_fn == NULL) {
<span class="line-modified"> 405       fatal(&quot;JNU_NewStringPlatform missing&quot;);</span>
 406     }
 407   }
 408 
 409   jstring js = NULL;
<span class="line-modified"> 410   {</span>
<span class="line-modified"> 411     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>
<span class="line-added"> 412     JavaThread* thread = (JavaThread*)THREAD;</span>
 413     HandleMark hm(thread);
 414     ThreadToNativeFromVM ttn(thread);
 415     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 416   }
<span class="line-modified"> 417 </span>
<span class="line-added"> 418   Handle native_platform_string(THREAD, JNIHandles::resolve(js));</span>
<span class="line-added"> 419   JNIHandles::destroy_local(js);  // destroy local JNIHandle.</span>
<span class="line-added"> 420   return native_platform_string;</span>
 421 }
 422 
 423 // Converts a Java String to a native C string that can be used for
 424 // native OS calls.
 425 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 426   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 427   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 428 
 429   if (_to_platform_string_fn == NULL) {
 430     void *lib_handle = os::native_java_library();
 431     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 432     if (_to_platform_string_fn == NULL) {
 433       fatal(&quot;GetStringPlatformChars missing&quot;);
 434     }
 435   }
 436 
 437   char *native_platform_string;
 438   { JavaThread* thread = (JavaThread*)THREAD;
 439     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 440     JNIEnv *env = thread-&gt;jni_environment();
</pre>
<hr />
<pre>
 521   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 522 
 523   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 524   if (result != NULL) {
 525     if (!is_latin1) {
 526       for (int index = 0; index &lt; length; index++) {
 527         result[index] = value-&gt;char_at(index);
 528       }
 529     } else {
 530       for (int index = 0; index &lt; length; index++) {
 531         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 532       }
 533     }
 534   } else {
 535     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 536   }
 537   return result;
 538 }
 539 
 540 unsigned int java_lang_String::hash_code(oop java_string) {
<span class="line-modified"> 541   // The hash and hashIsZero fields are subject to a benign data race,</span>
<span class="line-modified"> 542   // making it crucial to ensure that any observable result of the</span>
<span class="line-modified"> 543   // calculation in this method stays correct under any possible read of</span>
<span class="line-modified"> 544   // these fields. Necessary restrictions to allow this to be correct</span>
<span class="line-added"> 545   // without explicit memory fences or similar concurrency primitives is</span>
<span class="line-added"> 546   // that we can ever only write to one of these two fields for a given</span>
<span class="line-added"> 547   // String instance, and that the computation is idempotent and derived</span>
<span class="line-added"> 548   // from immutable state</span>
<span class="line-added"> 549   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-added"> 550   if (java_lang_String::hash_is_set(java_string)) {</span>
<span class="line-added"> 551     return java_string-&gt;int_field(hash_offset);</span>
<span class="line-added"> 552   }</span>
 553 
<span class="line-modified"> 554   typeArrayOop value = java_lang_String::value(java_string);</span>
<span class="line-added"> 555   int         length = java_lang_String::length(java_string, value);</span>
<span class="line-added"> 556   bool     is_latin1 = java_lang_String::is_latin1(java_string);</span>
 557 
<span class="line-modified"> 558   unsigned int hash = 0;</span>
<span class="line-modified"> 559   if (length &gt; 0) {</span>
<span class="line-added"> 560     if (is_latin1) {</span>
<span class="line-added"> 561       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);</span>
<span class="line-added"> 562     } else {</span>
<span class="line-added"> 563       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);</span>
<span class="line-added"> 564     }</span>
<span class="line-added"> 565   }</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567   if (hash != 0) {</span>
<span class="line-added"> 568     java_string-&gt;int_field_put(hash_offset, hash);</span>
 569   } else {
<span class="line-modified"> 570     java_string-&gt;bool_field_put(hashIsZero_offset, true);</span>
 571   }
<span class="line-added"> 572   return hash;</span>
 573 }
 574 
 575 char* java_lang_String::as_quoted_ascii(oop java_string) {
 576   typeArrayOop value  = java_lang_String::value(java_string);
 577   int          length = java_lang_String::length(java_string, value);
 578   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 579 
 580   if (length == 0) return NULL;
 581 
 582   char* result;
 583   int result_length;
 584   if (!is_latin1) {
 585     jchar* base = value-&gt;char_at_addr(0);
 586     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 587     result = NEW_RESOURCE_ARRAY(char, result_length);
 588     UNICODE::as_quoted_ascii(base, length, result, result_length);
 589   } else {
 590     jbyte* base = value-&gt;byte_at_addr(0);
 591     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 592     result = NEW_RESOURCE_ARRAY(char, result_length);
 593     UNICODE::as_quoted_ascii(base, length, result, result_length);
 594   }
 595   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 596   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 597   return result;
 598 }
 599 
<span class="line-modified"> 600 Symbol* java_lang_String::as_symbol(oop java_string) {</span>
 601   typeArrayOop value  = java_lang_String::value(java_string);
 602   int          length = java_lang_String::length(java_string, value);
 603   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 604   if (!is_latin1) {
 605     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
<span class="line-modified"> 606     Symbol* sym = SymbolTable::new_symbol(base, length);</span>
 607     return sym;
 608   } else {
 609     ResourceMark rm;
 610     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 611     const char* base = UNICODE::as_utf8(position, length);
<span class="line-modified"> 612     Symbol* sym = SymbolTable::new_symbol(base, length);</span>
 613     return sym;
 614   }
 615 }
 616 
 617 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 618   typeArrayOop value  = java_lang_String::value(java_string);
 619   int          length = java_lang_String::length(java_string, value);
 620   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 621   if (!is_latin1) {
 622     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 623     return SymbolTable::probe_unicode(base, length);
 624   } else {
 625     ResourceMark rm;
 626     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 627     const char* base = UNICODE::as_utf8(position, length);
 628     return SymbolTable::probe(base, length);
 629   }
 630 }
 631 
 632 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
</pre>
<hr />
<pre>
 865   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 866   set_init_lock(mirror(), r);
 867 
 868   // Set protection domain also
 869   set_protection_domain(mirror(), protection_domain());
 870 
 871   // Initialize static fields
 872   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 873 }
 874 
 875 // Set the java.lang.Module module field in the java_lang_Class mirror
 876 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 877   if (module.is_null()) {
 878     // During startup, the module may be NULL only if java.base has not been defined yet.
 879     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 880     // for java.base is known. But note that since we captured the NULL module another
 881     // thread may have completed that initialization.
 882 
 883     bool javabase_was_defined = false;
 884     {
<span class="line-modified"> 885       MutexLocker m1(THREAD, Module_lock);</span>
 886       // Keep list of classes needing java.base module fixup
 887       if (!ModuleEntryTable::javabase_defined()) {
 888         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 889         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 890         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 891         fixup_module_field_list()-&gt;push(k);
 892       } else {
 893         javabase_was_defined = true;
 894       }
 895     }
 896 
 897     // If java.base was already defined then patch this particular class with java.base.
 898     if (javabase_was_defined) {
 899       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 900       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 901              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 902       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 903       set_module(mirror(), javabase_handle());
 904     }
 905   } else {
 906     assert(Universe::is_module_initialized() ||
 907            (ModuleEntryTable::javabase_defined() &amp;&amp;
<span class="line-modified"> 908             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),</span>
 909            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 910     set_module(mirror(), module());
 911   }
 912 }
 913 
 914 // Statically allocate fixup lists because they always get created.
 915 void java_lang_Class::allocate_fixup_lists() {
 916   GrowableArray&lt;Klass*&gt;* mirror_list =
 917     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 918   set_fixup_mirror_list(mirror_list);
 919 
 920   GrowableArray&lt;Klass*&gt;* module_list =
 921     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 922   set_fixup_module_field_list(module_list);
 923 }
 924 
 925 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 926                                     Handle module, Handle protection_domain, TRAPS) {
 927   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 928   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
</pre>
<hr />
<pre>
 965       // Two-way link between the array klass and its component mirror:
 966       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 967       set_component_mirror(mirror(), comp_mirror());
 968       // See below for ordering dependencies between field array_klass in component mirror
 969       // and java_mirror in this klass.
 970     } else {
 971       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
 972 
 973       initialize_mirror_fields(k, mirror, protection_domain, THREAD);
 974       if (HAS_PENDING_EXCEPTION) {
 975         // If any of the fields throws an exception like OOM remove the klass field
 976         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
 977         // This mirror looks like a primitive type, which logically it is because it
 978         // it represents no class.
 979         java_lang_Class::set_klass(mirror(), NULL);
 980         return;
 981       }
 982     }
 983 
 984     // set the classLoader field in the java_lang_Class instance
<span class="line-modified"> 985     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);</span>
 986     set_class_loader(mirror(), class_loader());
 987 
 988     // Setup indirection from klass-&gt;mirror
 989     // after any exceptions can happen during allocations.
 990     k-&gt;set_java_mirror(mirror);
 991 
 992     // Set the module field in the java_lang_Class instance.  This must be done
 993     // after the mirror is set.
 994     set_mirror_module_field(k, mirror, module, THREAD);
 995 
 996     if (comp_mirror() != NULL) {
 997       // Set after k-&gt;java_mirror() is published, because compiled code running
 998       // concurrently doesn&#39;t expect a k to have a null java_mirror.
 999       release_set_array_klass(comp_mirror(), k);
1000     }
1001   } else {
1002     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1003     fixup_mirror_list()-&gt;push(k);
1004   }
1005 }
</pre>
<hr />
<pre>
1061       default:
1062         ShouldNotReachHere();
1063         break;
1064      }
1065   }
1066 };
1067 
1068 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1069   assert(HeapShared::is_heap_object_archiving_allowed(),
1070          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1071 
1072   for (int t = 0; t &lt;= T_VOID; t++) {
1073     oop m = Universe::_mirrors[t];
1074     if (m != NULL) {
1075       // Update the field at _array_klass_offset to point to the relocated array klass.
1076       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1077       assert(archived_m != NULL, &quot;sanity&quot;);
1078       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1079       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1080       if (ak != NULL) {
<span class="line-modified">1081         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);</span>
1082         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1083       }
1084 
1085       // Clear the fields. Just to be safe
1086       Klass *k = m-&gt;klass();
1087       Handle archived_mirror_h(THREAD, archived_m);
1088       ResetMirrorField reset(archived_mirror_h);
1089       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1090 
1091       log_trace(cds, heap, mirror)(
1092         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1093         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1094 
1095       Universe::_mirrors[t] = archived_m;
1096     }
1097   }
1098 
1099   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1100          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1101          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
</pre>
<hr />
<pre>
1206     }
1207     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1208   } else {
1209     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1210 
1211     // Reset local static fields in the mirror
1212     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1213 
1214     java_lang_Class:set_init_lock(archived_mirror, NULL);
1215 
1216     set_protection_domain(archived_mirror, NULL);
1217   }
1218 
1219   // clear class loader and mirror_module_field
1220   set_class_loader(archived_mirror, NULL);
1221   set_module(archived_mirror, NULL);
1222 
1223   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1224   // klass. Updated the field in the archived mirror to point to the relocated
1225   // klass in the archive.
<span class="line-modified">1226   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);</span>
1227   log_debug(cds, heap, mirror)(
1228     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1229     p2i(as_Klass(mirror)), p2i(reloc_k));
1230   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1231 
1232   // The field at _array_klass_offset is pointing to the original one dimension
1233   // higher array klass if exists. Relocate the pointer.
1234   Klass *arr = array_klass_acquire(mirror);
1235   if (arr != NULL) {
<span class="line-modified">1236     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);</span>
1237     log_debug(cds, heap, mirror)(
1238       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1239       p2i(arr), p2i(reloc_arr));
1240     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1241   }
1242   return archived_mirror;
1243 }
1244 
<span class="line-added">1245 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {</span>
<span class="line-added">1246   if (MetaspaceShared::relocation_delta() != 0) {</span>
<span class="line-added">1247     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-added">1250     if (ak != NULL) {</span>
<span class="line-added">1251       archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-added">1252           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">1253     }</span>
<span class="line-added">1254   }</span>
<span class="line-added">1255 }</span>
<span class="line-added">1256 </span>
<span class="line-added">1257 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {</span>
<span class="line-added">1258   if (MetaspaceShared::relocation_delta() != 0) {</span>
<span class="line-added">1259     Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));</span>
<span class="line-added">1260     archived_mirror-&gt;metadata_field_put(_klass_offset,</span>
<span class="line-added">1261         (Klass*)(address(k) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">1262 </span>
<span class="line-added">1263     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-added">1264     if (ak != NULL) {</span>
<span class="line-added">1265       archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-added">1266           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">1267     }</span>
<span class="line-added">1268   }</span>
<span class="line-added">1269 }</span>
<span class="line-added">1270 </span>
<span class="line-added">1271 </span>
1272 // Returns true if the mirror is updated, false if no archived mirror
1273 // data is present. After the archived mirror object is restored, the
1274 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1275 bool java_lang_Class::restore_archived_mirror(Klass *k,
1276                                               Handle class_loader, Handle module,
1277                                               Handle protection_domain, TRAPS) {
1278   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1279   // see more details in SystemDictionary::resolve_well_known_classes().
1280   if (!SystemDictionary::Class_klass_loaded()) {
1281     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1282     fixup_mirror_list()-&gt;push(k);
1283     return true;
1284   }
1285 
1286   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());

1287   if (m == NULL) {
1288     return false;
1289   }
1290 


1291   // mirror is archived, restore
<span class="line-added">1292   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));</span>
1293   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
<span class="line-added">1294   update_archived_mirror_native_pointers(m);</span>
<span class="line-added">1295   assert(as_Klass(m) == k, &quot;must be&quot;);</span>
1296   Handle mirror(THREAD, m);
1297 
1298   if (!k-&gt;is_array_klass()) {
1299     // - local static final fields with initial values were initialized at dump time
1300 
1301     // create the init_lock
1302     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1303     set_init_lock(mirror(), r);
1304 
1305     if (protection_domain.not_null()) {
1306       set_protection_domain(mirror(), protection_domain());
1307     }
1308   }
1309 
1310   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1311   if (class_loader.not_null()) {
1312     set_class_loader(mirror(), class_loader());
1313   }
1314 
1315   k-&gt;set_java_mirror(mirror);
1316   k-&gt;clear_has_raw_archived_mirror();
1317 
1318   set_mirror_module_field(k, mirror, module, THREAD);
1319 
<span class="line-modified">1320   if (log_is_enabled(Trace, cds, heap, mirror)) {</span>
<span class="line-modified">1321     ResourceMark rm(THREAD);</span>
<span class="line-modified">1322     log_trace(cds, heap, mirror)(</span>
<span class="line-added">1323         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));</span>
<span class="line-added">1324   }</span>
1325 
1326   return true;
1327 }
1328 #endif // INCLUDE_CDS_JAVA_HEAP
1329 
1330 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1331   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1332   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1333 }
1334 
1335 int  java_lang_Class::oop_size(oop java_class) {
1336   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1337   int size = java_class-&gt;int_field(_oop_size_offset);
1338   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1339   return size;
1340 }
1341 
1342 
1343 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1344   assert(_oop_size_offset != 0, &quot;must be set&quot;);
</pre>
<hr />
<pre>
1390   return java_class-&gt;obj_field_addr_raw&lt;oop&gt;(_init_lock_offset);
1391 }
1392 #endif  // INCLUDE_TSAN
1393 
1394 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1395   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1396   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1397 }
1398 
1399 objArrayOop java_lang_Class::signers(oop java_class) {
1400   assert(_signers_offset != 0, &quot;must be set&quot;);
1401   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1402 }
1403 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1404   assert(_signers_offset != 0, &quot;must be set&quot;);
1405   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1406 }
1407 
1408 
1409 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
<span class="line-modified">1410   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1411   java_class-&gt;obj_field_put(_class_loader_offset, loader);</span>


1412 }
1413 
1414 oop java_lang_Class::class_loader(oop java_class) {
1415   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1416   return java_class-&gt;obj_field(_class_loader_offset);
1417 }
1418 
1419 oop java_lang_Class::module(oop java_class) {
1420   assert(_module_offset != 0, &quot;must be set&quot;);
1421   return java_class-&gt;obj_field(_module_offset);
1422 }
1423 
1424 void java_lang_Class::set_module(oop java_class, oop module) {
1425   assert(_module_offset != 0, &quot;must be set&quot;);
1426   java_class-&gt;obj_field_put(_module_offset, module);
1427 }
1428 
1429 oop java_lang_Class::name(Handle java_class, TRAPS) {
1430   assert(_name_offset != 0, &quot;must be set&quot;);
1431   oop o = java_class-&gt;obj_field(_name_offset);
</pre>
<hr />
<pre>
1489 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1490   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1491   Symbol* name = NULL;
1492   bool is_instance = false;
1493   if (is_primitive(java_class)) {
1494     name = vmSymbols::type_signature(primitive_type(java_class));
1495   } else {
1496     Klass* k = as_Klass(java_class);
1497     is_instance = k-&gt;is_instance_klass();
1498     name = k-&gt;name();
1499   }
1500   if (name == NULL) {
1501     st-&gt;print(&quot;&lt;null&gt;&quot;);
1502     return;
1503   }
1504   if (is_instance)  st-&gt;print(&quot;L&quot;);
1505   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1506   if (is_instance)  st-&gt;print(&quot;;&quot;);
1507 }
1508 
<span class="line-modified">1509 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {</span>
1510   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1511   Symbol* name;
1512   if (is_primitive(java_class)) {
1513     name = vmSymbols::type_signature(primitive_type(java_class));
1514     // Because this can create a new symbol, the caller has to decrement
1515     // the refcount, so make adjustment here and below for symbols returned
1516     // that are not created or incremented due to a successful lookup.
1517     name-&gt;increment_refcount();
1518   } else {
1519     Klass* k = as_Klass(java_class);
1520     if (!k-&gt;is_instance_klass()) {
1521       name = k-&gt;name();
1522       name-&gt;increment_refcount();
1523     } else {
1524       ResourceMark rm;
1525       const char* sigstr = k-&gt;signature_name();
1526       int         siglen = (int) strlen(sigstr);
1527       if (!intern_if_not_found) {
1528         name = SymbolTable::probe(sigstr, siglen);
1529       } else {
<span class="line-modified">1530         name = SymbolTable::new_symbol(sigstr, siglen);</span>
1531       }
1532     }
1533   }
1534   return name;
1535 }
1536 
1537 // Returns the Java name for this Java mirror (Resource allocated)
1538 // See Klass::external_name().
1539 // For primitive type Java mirrors, its type name is returned.
1540 const char* java_lang_Class::as_external_name(oop java_class) {
1541   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1542   const char* name = NULL;
1543   if (is_primitive(java_class)) {
1544     name = type2name(primitive_type(java_class));
1545   } else {
1546     name = as_Klass(java_class)-&gt;external_name();
1547   }
1548   if (name == NULL) {
1549     name = &quot;&lt;null&gt;&quot;;
1550   }
</pre>
<hr />
<pre>
1555   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1556   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1557   return k;
1558 }
1559 
1560 
1561 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1562   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1563   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1564 }
1565 
1566 
1567 BasicType java_lang_Class::primitive_type(oop java_class) {
1568   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1569   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1570   BasicType type = T_VOID;
1571   if (ak != NULL) {
1572     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1573     type = ArrayKlass::cast(ak)-&gt;element_type();
1574   } else {
<span class="line-modified">1575     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);</span>
1576   }
<span class="line-modified">1577   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);</span>
1578   return type;
1579 }
1580 
1581 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1582   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1583   if (is_primitive(java_class)) {
1584     if (reference_klass != NULL)
1585       (*reference_klass) = NULL;
1586     return primitive_type(java_class);
1587   } else {
1588     if (reference_klass != NULL)
1589       (*reference_klass) = as_Klass(java_class);
1590     return T_OBJECT;
1591   }
1592 }
1593 
1594 
1595 oop java_lang_Class::primitive_mirror(BasicType t) {
1596   oop mirror = Universe::java_mirror(t);
1597   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1598   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1599   return mirror;
1600 }
1601 
1602 bool java_lang_Class::offsets_computed = false;
1603 int  java_lang_Class::classRedefinedCount_offset = -1;
1604 
1605 #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">1606   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
1607   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1608   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1609   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1610   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
1611 
1612 void java_lang_Class::compute_offsets() {
1613   if (offsets_computed) {
1614     return;
1615   }
1616 
1617   offsets_computed = true;
1618 
1619   InstanceKlass* k = SystemDictionary::Class_klass();
1620   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1621 
1622   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1623   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1624   // GC treats them the same.
1625   _init_lock_offset = _component_mirror_offset;
1626 
1627   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1628 }
1629 
1630 #if INCLUDE_CDS
1631 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1632   f-&gt;do_bool(&amp;offsets_computed);</span>
1633   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1634 
1635   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1636 
1637   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1638 }
1639 #endif
1640 
1641 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1642   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>




1643   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1644 }
1645 
1646 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1647   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>




1648   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1649 }
1650 
1651 
1652 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1653 //       platform thread structure, and a eetop offset which was used for thread
1654 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1655 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1656 //       instead of the privateInfo_offset.
1657 //
1658 // Note: The stackSize field is only present starting in 1.4.
1659 
1660 int java_lang_Thread::_name_offset = 0;
1661 int java_lang_Thread::_group_offset = 0;
1662 int java_lang_Thread::_contextClassLoader_offset = 0;
1663 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1664 int java_lang_Thread::_priority_offset = 0;
1665 int java_lang_Thread::_eetop_offset = 0;
<span class="line-added">1666 int java_lang_Thread::_interrupted_offset = 0;</span>
1667 int java_lang_Thread::_daemon_offset = 0;
1668 int java_lang_Thread::_stillborn_offset = 0;
1669 int java_lang_Thread::_stackSize_offset = 0;
1670 int java_lang_Thread::_tid_offset = 0;
1671 int java_lang_Thread::_thread_status_offset = 0;
1672 int java_lang_Thread::_park_blocker_offset = 0;

1673 
1674 #define THREAD_FIELDS_DO(macro) \
1675   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1676   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1677   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1678   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1679   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1680   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1681   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
<span class="line-added">1682   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \</span>
1683   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1684   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1685   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1686   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
<span class="line-modified">1687   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)</span>

1688 
1689 void java_lang_Thread::compute_offsets() {
1690   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1691 
1692   InstanceKlass* k = SystemDictionary::Thread_klass();
1693   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1694 }
1695 
1696 #if INCLUDE_CDS
1697 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1698   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1699 }
1700 #endif
1701 
1702 JavaThread* java_lang_Thread::thread(oop java_thread) {
1703   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1704 }
1705 
1706 
1707 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1708   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1709 }
1710 
<span class="line-added">1711 bool java_lang_Thread::interrupted(oop java_thread) {</span>
<span class="line-added">1712   // Make sure the caller can safely access oops.</span>
<span class="line-added">1713   assert(Thread::current()-&gt;is_VM_thread() ||</span>
<span class="line-added">1714          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;</span>
<span class="line-added">1715           JavaThread::current()-&gt;thread_state() != _thread_in_native),</span>
<span class="line-added">1716          &quot;Unsafe access to oop&quot;);</span>
<span class="line-added">1717   return java_thread-&gt;bool_field_volatile(_interrupted_offset);</span>
<span class="line-added">1718 }</span>
<span class="line-added">1719 </span>
<span class="line-added">1720 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {</span>
<span class="line-added">1721   // Make sure the caller can safely access oops.</span>
<span class="line-added">1722   assert(Thread::current()-&gt;is_VM_thread() ||</span>
<span class="line-added">1723          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;</span>
<span class="line-added">1724           JavaThread::current()-&gt;thread_state() != _thread_in_native),</span>
<span class="line-added">1725          &quot;Unsafe access to oop&quot;);</span>
<span class="line-added">1726   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);</span>
<span class="line-added">1727 }</span>
<span class="line-added">1728 </span>
1729 
1730 oop java_lang_Thread::name(oop java_thread) {
1731   return java_thread-&gt;obj_field(_name_offset);
1732 }
1733 
1734 
1735 void java_lang_Thread::set_name(oop java_thread, oop name) {
1736   java_thread-&gt;obj_field_put(_name_offset, name);
1737 }
1738 
1739 
1740 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1741   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1742 }
1743 
1744 
1745 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1746   java_thread-&gt;int_field_put(_priority_offset, priority);
1747 }
1748 
</pre>
<hr />
<pre>
1771 
1772 bool java_lang_Thread::is_daemon(oop java_thread) {
1773   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1774 }
1775 
1776 
1777 void java_lang_Thread::set_daemon(oop java_thread) {
1778   java_thread-&gt;bool_field_put(_daemon_offset, true);
1779 }
1780 
1781 oop java_lang_Thread::context_class_loader(oop java_thread) {
1782   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1783 }
1784 
1785 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1786   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1787 }
1788 
1789 
1790 jlong java_lang_Thread::stackSize(oop java_thread) {
<span class="line-modified">1791   return java_thread-&gt;long_field(_stackSize_offset);</span>




1792 }
1793 
1794 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1795 void java_lang_Thread::set_thread_status(oop java_thread,
1796                                          java_lang_Thread::ThreadStatus status) {
<span class="line-modified">1797   java_thread-&gt;int_field_put(_thread_status_offset, status);</span>



1798 }
1799 
1800 // Read thread status value from threadStatus field in java.lang.Thread java class.
1801 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1802   // Make sure the caller is operating on behalf of the VM or is
1803   // running VM code (state == _thread_in_vm).
1804   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1805          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1806          &quot;Java Thread is not running in vm&quot;);
<span class="line-modified">1807   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);</span>














1808 }
1809 
1810 
1811 jlong java_lang_Thread::thread_id(oop java_thread) {
<span class="line-modified">1812   return java_thread-&gt;long_field(_tid_offset);</span>





1813 }
1814 
1815 oop java_lang_Thread::park_blocker(oop java_thread) {
<span class="line-modified">1816   return java_thread-&gt;obj_field(_park_blocker_offset);</span>














1817 }
1818 









1819 const char* java_lang_Thread::thread_status_name(oop java_thread) {

1820   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1821   switch (status) {
1822     case NEW                      : return &quot;NEW&quot;;
1823     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1824     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1825     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1826     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1827     case PARKED                   : return &quot;WAITING (parking)&quot;;
1828     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1829     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1830     case TERMINATED               : return &quot;TERMINATED&quot;;
1831     default                       : return &quot;UNKNOWN&quot;;
1832   };
1833 }
1834 int java_lang_ThreadGroup::_parent_offset = 0;
1835 int java_lang_ThreadGroup::_name_offset = 0;
1836 int java_lang_ThreadGroup::_threads_offset = 0;
1837 int java_lang_ThreadGroup::_groups_offset = 0;
1838 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1839 int java_lang_ThreadGroup::_destroyed_offset = 0;
</pre>
<hr />
<pre>
1953 }
1954 
1955 int java_lang_Throwable::depth(oop throwable) {
1956   return throwable-&gt;int_field(depth_offset);
1957 }
1958 
1959 void java_lang_Throwable::set_depth(oop throwable, int value) {
1960   throwable-&gt;int_field_put(depth_offset, value);
1961 }
1962 
1963 oop java_lang_Throwable::message(oop throwable) {
1964   return throwable-&gt;obj_field(detailMessage_offset);
1965 }
1966 
1967 
1968 // Return Symbol for detailed_message or NULL
1969 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1970   PRESERVE_EXCEPTION_MARK;  // Keep original exception
1971   oop detailed_message = java_lang_Throwable::message(throwable);
1972   if (detailed_message != NULL) {
<span class="line-modified">1973     return java_lang_String::as_symbol(detailed_message);</span>
1974   }
1975   return NULL;
1976 }
1977 
1978 void java_lang_Throwable::set_message(oop throwable, oop value) {
1979   throwable-&gt;obj_field_put(detailMessage_offset, value);
1980 }
1981 
1982 
1983 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
1984   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
1985 }
1986 
1987 void java_lang_Throwable::clear_stacktrace(oop throwable) {
1988   set_stacktrace(throwable, NULL);
1989 }
1990 
1991 
1992 void java_lang_Throwable::print(oop throwable, outputStream* st) {
1993   ResourceMark rm;
1994   Klass* k = throwable-&gt;klass();
1995   assert(k != NULL, &quot;just checking&quot;);
1996   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
1997   oop msg = message(throwable);
1998   if (msg != NULL) {
1999     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2000   }
2001 }
2002 
2003 // After this many redefines, the stack trace is unreliable.
2004 const int MAX_VERSION = USHRT_MAX;
2005 
2006 static inline bool version_matches(Method* method, int version) {
2007   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2008   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2009 }
2010 

2011 // This class provides a simple wrapper over the internal structure of
2012 // exception backtrace to insulate users of the backtrace from needing
2013 // to know what it looks like.
<span class="line-added">2014 // The code of this class is not GC safe. Allocations can only happen</span>
<span class="line-added">2015 // in expand().</span>
2016 class BacktraceBuilder: public StackObj {
2017  friend class BacktraceIterator;
2018  private:
2019   Handle          _backtrace;
2020   objArrayOop     _head;
2021   typeArrayOop    _methods;
2022   typeArrayOop    _bcis;
2023   objArrayOop     _mirrors;
<span class="line-modified">2024   typeArrayOop    _names; // Needed to insulate method name against redefinition.</span>
<span class="line-added">2025   // This is set to a java.lang.Boolean(true) if the top frame</span>
<span class="line-added">2026   // of the backtrace is omitted because it shall be hidden.</span>
<span class="line-added">2027   // Else it is null.</span>
<span class="line-added">2028   oop             _has_hidden_top_frame;</span>
2029   int             _index;
2030   NoSafepointVerifier _nsv;
2031 
2032   enum {
2033     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2034     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2035     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2036     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2037     trace_next_offset    = java_lang_Throwable::trace_next_offset,
<span class="line-added">2038     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,</span>
2039     trace_size           = java_lang_Throwable::trace_size,
2040     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2041   };
2042 
2043   // get info out of chunks
2044   static typeArrayOop get_methods(objArrayHandle chunk) {
2045     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2046     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2047     return methods;
2048   }
2049   static typeArrayOop get_bcis(objArrayHandle chunk) {
2050     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2051     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2052     return bcis;
2053   }
2054   static objArrayOop get_mirrors(objArrayHandle chunk) {
2055     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2056     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2057     return mirrors;
2058   }
2059   static typeArrayOop get_names(objArrayHandle chunk) {
2060     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2061     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2062     return names;
2063   }
<span class="line-added">2064   static oop get_has_hidden_top_frame(objArrayHandle chunk) {</span>
<span class="line-added">2065     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);</span>
<span class="line-added">2066     return hidden;</span>
<span class="line-added">2067   }</span>
2068 
2069  public:
2070 
2071   // constructor for new backtrace
<span class="line-modified">2072   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(NULL) {</span>
2073     expand(CHECK);
2074     _backtrace = Handle(THREAD, _head);
2075     _index = 0;
2076   }
2077 
2078   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2079     _methods = get_methods(backtrace);
2080     _bcis = get_bcis(backtrace);
2081     _mirrors = get_mirrors(backtrace);
2082     _names = get_names(backtrace);
<span class="line-added">2083     _has_hidden_top_frame = get_has_hidden_top_frame(backtrace);</span>
2084     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2085            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2086            _mirrors-&gt;length() == _names-&gt;length(),
2087            &quot;method and source information arrays should match&quot;);
2088 
2089     // head is the preallocated backtrace
2090     _head = backtrace();
2091     _backtrace = Handle(thread, _head);
2092     _index = 0;
2093   }
2094 
2095   void expand(TRAPS) {
2096     objArrayHandle old_head(THREAD, _head);
2097     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2098 
2099     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2100     objArrayHandle new_head(THREAD, head);
2101 
2102     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2103     typeArrayHandle new_methods(THREAD, methods);
2104 
2105     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2106     typeArrayHandle new_bcis(THREAD, bcis);
2107 
2108     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2109     objArrayHandle new_mirrors(THREAD, mirrors);
2110 
2111     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2112     typeArrayHandle new_names(THREAD, names);
2113 
2114     if (!old_head.is_null()) {
2115       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2116     }
2117     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2118     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2119     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2120     new_head-&gt;obj_at_put(trace_names_offset, new_names());
<span class="line-added">2121     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);</span>
2122 
2123     _head    = new_head();
2124     _methods = new_methods();
2125     _bcis = new_bcis();
2126     _mirrors = new_mirrors();
2127     _names  = new_names();
2128     _index = 0;
2129   }
2130 
2131   oop backtrace() {
2132     return _backtrace();
2133   }
2134 
2135   inline void push(Method* method, int bci, TRAPS) {
2136     // Smear the -1 bci to 0 since the array only holds unsigned
2137     // shorts.  The later line number lookup would just smear the -1
2138     // to a 0 even if it could be recorded.
2139     if (bci == SynchronizationEntryBCI) bci = 0;
2140 
2141     if (_index &gt;= trace_chunk_size) {
2142       methodHandle mhandle(THREAD, method);
2143       expand(CHECK);
2144       method = mhandle();
2145     }
2146 
2147     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2148     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2149 
2150     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2151     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2152     Symbol* name = method-&gt;name();
2153     _names-&gt;symbol_at_put(_index, name);
2154 
2155     // We need to save the mirrors in the backtrace to keep the class
2156     // from being unloaded while we still have this stack trace.
2157     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2158     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2159     _index++;
2160   }
2161 
<span class="line-added">2162   void set_has_hidden_top_frame(TRAPS) {</span>
<span class="line-added">2163     if (_has_hidden_top_frame == NULL) {</span>
<span class="line-added">2164       // It would be nice to add java/lang/Boolean::TRUE here</span>
<span class="line-added">2165       // to indicate that this backtrace has a hidden top frame.</span>
<span class="line-added">2166       // But this code is used before TRUE is allocated.</span>
<span class="line-added">2167       // Therefor let&#39;s just use an arbitrary legal oop</span>
<span class="line-added">2168       // available right here. We only test for != null</span>
<span class="line-added">2169       // anyways. _methods is a short[].</span>
<span class="line-added">2170       assert(_methods != NULL, &quot;we need a legal oop&quot;);</span>
<span class="line-added">2171       _has_hidden_top_frame = _methods;</span>
<span class="line-added">2172       _head-&gt;obj_at_put(trace_hidden_offset, _has_hidden_top_frame);</span>
<span class="line-added">2173     }</span>
<span class="line-added">2174   }</span>
<span class="line-added">2175 </span>
2176 };
2177 
2178 struct BacktraceElement : public StackObj {
2179   int _method_id;
2180   int _bci;
2181   int _version;
2182   Symbol* _name;
2183   Handle _mirror;
2184   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2185                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2186 };
2187 
2188 class BacktraceIterator : public StackObj {
2189   int _index;
2190   objArrayHandle  _result;
2191   objArrayHandle  _mirrors;
2192   typeArrayHandle _methods;
2193   typeArrayHandle _bcis;
2194   typeArrayHandle _names;
2195 
</pre>
<hr />
<pre>
2291       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2292         // Sourcename and linenumber
2293         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2294       } else if (source_file_name != NULL) {
2295         // Just sourcename
2296         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2297       } else {
2298         // Neither sourcename nor linenumber
2299         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2300       }
2301       CompiledMethod* nm = method-&gt;code();
2302       if (WizardMode &amp;&amp; nm != NULL) {
2303         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2304       }
2305     }
2306   }
2307 
2308   st-&gt;print_cr(&quot;%s&quot;, buf);
2309 }
2310 
<span class="line-modified">2311 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {</span>
2312   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2313   int method_id = method-&gt;orig_method_idnum();
2314   int version = method-&gt;constants()-&gt;version();
2315   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2316 }
2317 
2318 /**
2319  * Print the throwable message and its stack trace plus all causes by walking the
2320  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2321  */
2322 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2323   // First, print the message.
2324   print(throwable(), st);
2325   st-&gt;cr();
2326 
2327   // Now print the stack trace.
2328   Thread* THREAD = Thread::current();
2329   while (throwable.not_null()) {
2330     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2331     if (result.is_null()) {
</pre>
<hr />
<pre>
2397   // If there is no Java frame just return the method that was being called
2398   // with bci 0
2399   if (!thread-&gt;has_last_Java_frame()) {
2400     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2401       bt.push(method(), 0, CHECK);
2402       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2403       set_depth(throwable(), 1);
2404       set_backtrace(throwable(), bt.backtrace());
2405     }
2406     return;
2407   }
2408 
2409   // Instead of using vframe directly, this version of fill_in_stack_trace
2410   // basically handles everything by hand. This significantly improved the
2411   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2412   // See bug 6333838 for  more details.
2413   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2414   // trace as utilizing vframe.
2415 #ifdef ASSERT
2416   vframeStream st(thread);

2417 #endif
2418   int total_count = 0;
2419   RegisterMap map(thread, false);
2420   int decode_offset = 0;
2421   CompiledMethod* nm = NULL;
2422   bool skip_fillInStackTrace_check = false;
2423   bool skip_throwableInit_check = false;
2424   bool skip_hidden = !ShowHiddenFrames;
2425 
2426   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2427     Method* method = NULL;
2428     int bci = 0;
2429 
2430     // Compiled java method case.
2431     if (decode_offset != 0) {
2432       DebugInfoReadStream stream(nm, decode_offset);
2433       decode_offset = stream.read_int();
2434       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2435       bci = stream.read_bci();
2436     } else {
</pre>
<hr />
<pre>
2446         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2447         // but non nmethod
2448         fr = fr.sender(&amp;map);
2449         if (cb == NULL || !cb-&gt;is_compiled()) {
2450           continue;
2451         }
2452         nm = cb-&gt;as_compiled_method();
2453         if (nm-&gt;method()-&gt;is_native()) {
2454           method = nm-&gt;method();
2455           bci = 0;
2456         } else {
2457           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2458           decode_offset = pd-&gt;scope_decode_offset();
2459           // if decode_offset is not equal to 0, it will execute the
2460           // &quot;compiled java method case&quot; at the beginning of the loop.
2461           continue;
2462         }
2463       }
2464     }
2465 #ifdef ASSERT
<span class="line-modified">2466     assert(st.method() == method &amp;&amp; st.bci() == bci,</span>
2467            &quot;Wrong stack trace&quot;);
2468     st.next();





2469 #endif
2470 
2471     // the format of the stacktrace will be:
2472     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2473     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2474     // - rest of the stack
2475 
2476     if (!skip_fillInStackTrace_check) {
2477       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2478           throwable-&gt;is_a(method-&gt;method_holder())) {
2479         continue;
2480       }
2481       else {
2482         skip_fillInStackTrace_check = true; // gone past them all
2483       }
2484     }
2485     if (!skip_throwableInit_check) {
2486       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2487 
2488       // skip &lt;init&gt; methods of the exception class and superclasses
2489       // This is simlar to classic VM.
2490       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
2491           throwable-&gt;is_a(method-&gt;method_holder())) {
2492         continue;
2493       } else {
2494         // there are none or we&#39;ve seen them all - either way stop checking
2495         skip_throwableInit_check = true;
2496       }
2497     }
2498     if (method-&gt;is_hidden()) {
<span class="line-modified">2499       if (skip_hidden) {</span>
<span class="line-added">2500         if (total_count == 0) {</span>
<span class="line-added">2501           // The top frame will be hidden from the stack trace.</span>
<span class="line-added">2502           bt.set_has_hidden_top_frame(CHECK);</span>
<span class="line-added">2503         }</span>
<span class="line-added">2504         continue;</span>
<span class="line-added">2505       }</span>
2506     }
2507     bt.push(method, bci, CHECK);
2508     total_count++;
2509   }
2510 
2511   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2512 
2513   // Put completed stack trace into throwable object
2514   set_backtrace(throwable(), bt.backtrace());
2515   set_depth(throwable(), total_count);
2516 }
2517 
2518 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2519   // No-op if stack trace is disabled
2520   if (!StackTraceInThrowable) {
2521     return;
2522   }
2523 
2524   // Disable stack traces for some preallocated out of memory errors
2525   if (!Universe::should_fill_in_stack_trace(throwable)) {
</pre>
<hr />
<pre>
2602   while (iter.repeat()) {
2603     BacktraceElement bte = iter.next(THREAD);
2604 
2605     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2606 
2607     if (stack_trace_element.is_null()) {
2608       THROW(vmSymbols::java_lang_NullPointerException());
2609     }
2610 
2611     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2612     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2613 
2614     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2615                                          method,
2616                                          bte._version,
2617                                          bte._bci,
2618                                          bte._name, CHECK);
2619   }
2620 }
2621 
<span class="line-added">2622 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {</span>
<span class="line-added">2623   Thread* THREAD = Thread::current();</span>
<span class="line-added">2624   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));</span>
<span class="line-added">2625   BacktraceIterator iter(result, THREAD);</span>
<span class="line-added">2626   // No backtrace available.</span>
<span class="line-added">2627   if (!iter.repeat()) return false;</span>
<span class="line-added">2628 </span>
<span class="line-added">2629   // If the exception happened in a frame that has been hidden, i.e.,</span>
<span class="line-added">2630   // omitted from the back trace, we can not compute the message.</span>
<span class="line-added">2631   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);</span>
<span class="line-added">2632   if (hidden != NULL) {</span>
<span class="line-added">2633     return false;</span>
<span class="line-added">2634   }</span>
<span class="line-added">2635 </span>
<span class="line-added">2636   // Get first backtrace element.</span>
<span class="line-added">2637   BacktraceElement bte = iter.next(THREAD);</span>
<span class="line-added">2638 </span>
<span class="line-added">2639   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));</span>
<span class="line-added">2640   assert(holder != NULL, &quot;first element should be non-null&quot;);</span>
<span class="line-added">2641   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);</span>
<span class="line-added">2642 </span>
<span class="line-added">2643   // Original version is no longer available.</span>
<span class="line-added">2644   if (m == NULL || !version_matches(m, bte._version)) {</span>
<span class="line-added">2645     return false;</span>
<span class="line-added">2646   }</span>
<span class="line-added">2647 </span>
<span class="line-added">2648   *method = m;</span>
<span class="line-added">2649   *bci = bte._bci;</span>
<span class="line-added">2650   return true;</span>
<span class="line-added">2651 }</span>
<span class="line-added">2652 </span>
2653 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2654   // Allocate java.lang.StackTraceElement instance
2655   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2656   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2657   if (k-&gt;should_be_initialized()) {
2658     k-&gt;initialize(CHECK_0);
2659   }
2660 
2661   Handle element = k-&gt;allocate_instance_handle(CHECK_0);
2662 
2663   int version = method-&gt;constants()-&gt;version();
2664   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_0);
2665   return element();
2666 }
2667 
2668 void java_lang_StackTraceElement::fill_in(Handle element,
2669                                           InstanceKlass* holder, const methodHandle&amp; method,
2670                                           int version, int bci, Symbol* name, TRAPS) {
2671   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2672 
</pre>
<hr />
<pre>
2692 
2693   // Fill in module name and version
2694   ModuleEntry* module = holder-&gt;module();
2695   if (module-&gt;is_named()) {
2696     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2697     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2698     oop module_version;
2699     if (module-&gt;version() != NULL) {
2700       module_version = StringTable::intern(module-&gt;version(), CHECK);
2701     } else {
2702       module_version = NULL;
2703     }
2704     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2705   }
2706 
2707   if (method() == NULL || !version_matches(method(), version)) {
2708     // The method was redefined, accurate line number information isn&#39;t available
2709     java_lang_StackTraceElement::set_fileName(element(), NULL);
2710     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2711   } else {
<span class="line-modified">2712     Symbol* source;</span>
<span class="line-modified">2713     oop source_file;</span>
<span class="line-modified">2714     int line_number;</span>
<span class="line-modified">2715     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);</span>


















2716 
<span class="line-modified">2717     java_lang_StackTraceElement::set_fileName(element(), source_file);</span>
2718     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2719   }
2720 }
2721 
<span class="line-added">2722 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,</span>
<span class="line-added">2723                                                        InstanceKlass* holder,</span>
<span class="line-added">2724                                                        int version,</span>
<span class="line-added">2725                                                        const methodHandle&amp; method,</span>
<span class="line-added">2726                                                        int bci,</span>
<span class="line-added">2727                                                        Symbol*&amp; source,</span>
<span class="line-added">2728                                                        oop&amp; source_file,</span>
<span class="line-added">2729                                                        int&amp; line_number, TRAPS) {</span>
<span class="line-added">2730   // Fill in source file name and line number.</span>
<span class="line-added">2731   source = Backtrace::get_source_file_name(holder, version);</span>
<span class="line-added">2732   source_file = java_lang_Class::source_file(java_class());</span>
<span class="line-added">2733   if (source != NULL) {</span>
<span class="line-added">2734     // Class was not redefined. We can trust its cache if set,</span>
<span class="line-added">2735     // else we have to initialize it.</span>
<span class="line-added">2736     if (source_file == NULL) {</span>
<span class="line-added">2737       source_file = StringTable::intern(source, CHECK);</span>
<span class="line-added">2738       java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-added">2739     }</span>
<span class="line-added">2740   } else {</span>
<span class="line-added">2741     // Class was redefined. Dump the cache if it was set.</span>
<span class="line-added">2742     if (source_file != NULL) {</span>
<span class="line-added">2743       source_file = NULL;</span>
<span class="line-added">2744       java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-added">2745     }</span>
<span class="line-added">2746   }</span>
<span class="line-added">2747   line_number = Backtrace::get_line_number(method(), bci);</span>
<span class="line-added">2748 }</span>
<span class="line-added">2749 </span>
<span class="line-added">2750 #if INCLUDE_JVMCI</span>
<span class="line-added">2751 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,</span>
<span class="line-added">2752                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {</span>
<span class="line-added">2753   ResourceMark rm(THREAD);</span>
<span class="line-added">2754   HandleMark hm(THREAD);</span>
<span class="line-added">2755 </span>
<span class="line-added">2756   filename = NULL;</span>
<span class="line-added">2757   line_number = -1;</span>
<span class="line-added">2758 </span>
<span class="line-added">2759   oop source_file;</span>
<span class="line-added">2760   int version = method-&gt;constants()-&gt;version();</span>
<span class="line-added">2761   InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-added">2762   Handle java_class(THREAD, holder-&gt;java_mirror());</span>
<span class="line-added">2763   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);</span>
<span class="line-added">2764 }</span>
<span class="line-added">2765 #endif // INCLUDE_JVMCI</span>
<span class="line-added">2766 </span>
2767 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2768   HandleMark hm(THREAD);
2769   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2770   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2771   // we should expand MemberName::name when Throwable uses StackTrace
2772   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2773   return method;
2774 }
2775 
2776 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2777   // set Method* or mid/cpref
2778   HandleMark hm(THREAD);
2779   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2780   InstanceKlass* ik = method-&gt;method_holder();
2781   CallInfo info(method(), ik, CHECK);
2782   MethodHandles::init_method_MemberName(mname, info);
2783   // set bci
2784   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2785   // method may be redefined; store the version
2786   int version = method-&gt;constants()-&gt;version();
2787   assert((jushort)version == version, &quot;version should be short&quot;);
2788   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2789 }
2790 
2791 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2792   ResourceMark rm(THREAD);
2793   HandleMark hm(THREAD);
2794   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2795   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2796   InstanceKlass* holder = InstanceKlass::cast(clazz);
2797   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2798 
2799   short version = stackFrame-&gt;short_field(_version_offset);
<span class="line-modified">2800   int bci = stackFrame-&gt;int_field(_bci_offset);</span>
2801   Symbol* name = method-&gt;name();
<span class="line-modified">2802   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),</span>
<span class="line-added">2803                                        version, bci, name, CHECK);</span>
2804 }
2805 
2806 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2807   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
<span class="line-modified">2808   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
2809 
2810 void java_lang_StackFrameInfo::compute_offsets() {
2811   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2812   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2813   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2814 }
2815 
2816 #if INCLUDE_CDS
2817 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2818   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2819   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2820 }
2821 #endif
2822 
2823 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2824   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2825   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2826   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2827   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2828 
</pre>
<hr />
<pre>
3128 int java_lang_reflect_Field::modifiers(oop field) {
3129   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3130   return field-&gt;int_field(modifiers_offset);
3131 }
3132 
3133 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3134   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3135   field-&gt;int_field_put(modifiers_offset, value);
3136 }
3137 
3138 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3139   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3140   field-&gt;obj_field_put(signature_offset, value);
3141 }
3142 
3143 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3144   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3145   field-&gt;obj_field_put(annotations_offset, value);
3146 }
3147 
<span class="line-added">3148 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {</span>
<span class="line-added">3149   // Allocate java.lang.reflect.RecordComponent instance</span>
<span class="line-added">3150   HandleMark hm(THREAD);</span>
<span class="line-added">3151   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();</span>
<span class="line-added">3152   assert(ik != NULL, &quot;must be loaded&quot;);</span>
<span class="line-added">3153   ik-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">3154 </span>
<span class="line-added">3155   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-added">3156 </span>
<span class="line-added">3157   Handle decl_class(THREAD, holder-&gt;java_mirror());</span>
<span class="line-added">3158   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());</span>
<span class="line-added">3159 </span>
<span class="line-added">3160   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8</span>
<span class="line-added">3161   oop component_name = StringTable::intern(name, CHECK_NULL);</span>
<span class="line-added">3162   java_lang_reflect_RecordComponent::set_name(element(), component_name);</span>
<span class="line-added">3163 </span>
<span class="line-added">3164   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());</span>
<span class="line-added">3165   Handle component_type_h =</span>
<span class="line-added">3166     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);</span>
<span class="line-added">3167   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());</span>
<span class="line-added">3168 </span>
<span class="line-added">3169   Method* accessor_method = NULL;</span>
<span class="line-added">3170   {</span>
<span class="line-added">3171     // Prepend &quot;()&quot; to type to create the full method signature.</span>
<span class="line-added">3172     ResourceMark rm(THREAD);</span>
<span class="line-added">3173     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char</span>
<span class="line-added">3174     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);</span>
<span class="line-added">3175     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());</span>
<span class="line-added">3176     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);</span>
<span class="line-added">3177     accessor_method = holder-&gt;find_instance_method(name, full_sig);</span>
<span class="line-added">3178   }</span>
<span class="line-added">3179 </span>
<span class="line-added">3180   if (accessor_method != NULL) {</span>
<span class="line-added">3181     methodHandle method(THREAD, accessor_method);</span>
<span class="line-added">3182     oop m = Reflection::new_method(method, false, CHECK_NULL);</span>
<span class="line-added">3183     java_lang_reflect_RecordComponent::set_accessor(element(), m);</span>
<span class="line-added">3184   } else {</span>
<span class="line-added">3185     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);</span>
<span class="line-added">3186   }</span>
<span class="line-added">3187 </span>
<span class="line-added">3188   int sig_index = component-&gt;generic_signature_index();</span>
<span class="line-added">3189   if (sig_index &gt; 0) {</span>
<span class="line-added">3190     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8</span>
<span class="line-added">3191     oop component_sig = StringTable::intern(sig, CHECK_NULL);</span>
<span class="line-added">3192     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);</span>
<span class="line-added">3193   } else {</span>
<span class="line-added">3194     java_lang_reflect_RecordComponent::set_signature(element(), NULL);</span>
<span class="line-added">3195   }</span>
<span class="line-added">3196 </span>
<span class="line-added">3197   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);</span>
<span class="line-added">3198   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);</span>
<span class="line-added">3199 </span>
<span class="line-added">3200   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);</span>
<span class="line-added">3201   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);</span>
<span class="line-added">3202 </span>
<span class="line-added">3203   return element();</span>
<span class="line-added">3204 }</span>
<span class="line-added">3205 </span>
3206 #define CONSTANTPOOL_FIELDS_DO(macro) \
3207   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3208 
3209 void reflect_ConstantPool::compute_offsets() {
3210   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3211   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3212   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3213 }
3214 
3215 #if INCLUDE_CDS
3216 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3217   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3218 }
3219 #endif
3220 
3221 #define PARAMETER_FIELDS_DO(macro) \
3222   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3223   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3224   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3225   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
</pre>
<hr />
<pre>
3785 
3786 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3787   assert(is_instance(mname), &quot;wrong type&quot;);
3788   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3789 }
3790 
3791 
3792 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3793   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3794   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3795   assert(m-&gt;is_method(), &quot;must be&quot;);
3796   return m;
3797 }
3798 
3799 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3800 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3801   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3802   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3803 }
3804 
<span class="line-added">3805 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {</span>
<span class="line-added">3806   assert(is_instance(resolved_method), &quot;wrong type&quot;);</span>
<span class="line-added">3807   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);</span>
<span class="line-added">3808 }</span>
<span class="line-added">3809 </span>
3810 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
<span class="line-added">3811   const Method* method = m();</span>
<span class="line-added">3812 </span>
3813   // lookup ResolvedMethod oop in the table, or create a new one and intern it
<span class="line-modified">3814   oop resolved_method = ResolvedMethodTable::find_method(method);</span>
<span class="line-modified">3815   if (resolved_method != NULL) {</span>
<span class="line-modified">3816     return resolved_method;</span>










3817   }
<span class="line-modified">3818 </span>
<span class="line-added">3819   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();</span>
<span class="line-added">3820   if (!k-&gt;is_initialized()) {</span>
<span class="line-added">3821     k-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">3822   }</span>
<span class="line-added">3823 </span>
<span class="line-added">3824   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3825 </span>
<span class="line-added">3826   NoSafepointVerifier nsv;</span>
<span class="line-added">3827 </span>
<span class="line-added">3828   if (method-&gt;is_old()) {</span>
<span class="line-added">3829     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :</span>
<span class="line-added">3830                                       method-&gt;get_new_method();</span>
<span class="line-added">3831   }</span>
<span class="line-added">3832 </span>
<span class="line-added">3833   InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-added">3834 </span>
<span class="line-added">3835   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));</span>
<span class="line-added">3836   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have</span>
<span class="line-added">3837   // distinct loaders) to ensure the metadata is kept alive.</span>
<span class="line-added">3838   // This mirror may be different than the one in clazz field.</span>
<span class="line-added">3839   set_vmholder(new_resolved_method, holder-&gt;java_mirror());</span>
<span class="line-added">3840 </span>
<span class="line-added">3841   // Set flag in class to indicate this InstanceKlass has entries in the table</span>
<span class="line-added">3842   // to avoid walking table during redefinition if none of the redefined classes</span>
<span class="line-added">3843   // have any membernames in the table.</span>
<span class="line-added">3844   holder-&gt;set_has_resolved_methods();</span>
<span class="line-added">3845 </span>
<span class="line-added">3846   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));</span>
3847 }
3848 
3849 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3850   assert(is_instance(lform), &quot;wrong type&quot;);
3851   return lform-&gt;obj_field(_vmentry_offset);
3852 }
3853 
3854 
3855 // Support for java_lang_invoke_MethodType
3856 
3857 int java_lang_invoke_MethodType::_rtype_offset;
3858 int java_lang_invoke_MethodType::_ptypes_offset;
3859 
3860 #define METHODTYPE_FIELDS_DO(macro) \
3861   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3862   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3863 
3864 void java_lang_invoke_MethodType::compute_offsets() {
3865   InstanceKlass* k = SystemDictionary::MethodType_klass();
3866   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3867 }
3868 
3869 #if INCLUDE_CDS
3870 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3871   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3872 }
3873 #endif
3874 
3875 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3876   st-&gt;print(&quot;(&quot;);
3877   objArrayOop pts = ptypes(mt);
3878   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3879     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3880   }
3881   st-&gt;print(&quot;)&quot;);
3882   java_lang_Class::print_signature(rtype(mt), st);
3883 }
3884 
<span class="line-modified">3885 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {</span>
3886   ResourceMark rm;
3887   stringStream buffer(128);
3888   print_signature(mt, &amp;buffer);
3889   const char* sigstr =       buffer.base();
3890   int         siglen = (int) buffer.size();
3891   Symbol *name;
3892   if (!intern_if_not_found) {
3893     name = SymbolTable::probe(sigstr, siglen);
3894   } else {
<span class="line-modified">3895     name = SymbolTable::new_symbol(sigstr, siglen);</span>
3896   }
3897   return name;
3898 }
3899 
3900 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
<span class="line-modified">3901   if (mt1 == mt2)</span>
3902     return true;
<span class="line-modified">3903   if (rtype(mt1) != rtype(mt2))</span>
3904     return false;
3905   if (ptype_count(mt1) != ptype_count(mt2))
3906     return false;
3907   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
<span class="line-modified">3908     if (ptype(mt1, i) != ptype(mt2, i))</span>
3909       return false;
3910   }
3911   return true;
3912 }
3913 
3914 oop java_lang_invoke_MethodType::rtype(oop mt) {
3915   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3916   return mt-&gt;obj_field(_rtype_offset);
3917 }
3918 
3919 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
3920   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3921   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
3922 }
3923 
3924 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
3925   return ptypes(mt)-&gt;obj_at(idx);
3926 }
3927 
3928 int java_lang_invoke_MethodType::ptype_count(oop mt) {
</pre>
<hr />
<pre>
3956   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
3957 
3958 void java_lang_invoke_CallSite::compute_offsets() {
3959   InstanceKlass* k = SystemDictionary::CallSite_klass();
3960   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3961 }
3962 
3963 #if INCLUDE_CDS
3964 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
3965   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3966 }
3967 #endif
3968 
3969 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
3970   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
3971 
3972   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
3973   return dep_oop;
3974 }
3975 
<span class="line-added">3976 // Support for java_lang_invoke_ConstantCallSite</span>
<span class="line-added">3977 </span>
<span class="line-added">3978 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;</span>
<span class="line-added">3979 </span>
<span class="line-added">3980 #define CONSTANTCALLSITE_FIELDS_DO(macro) \</span>
<span class="line-added">3981   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)</span>
<span class="line-added">3982 </span>
<span class="line-added">3983 void java_lang_invoke_ConstantCallSite::compute_offsets() {</span>
<span class="line-added">3984   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();</span>
<span class="line-added">3985   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3986 }</span>
<span class="line-added">3987 </span>
<span class="line-added">3988 #if INCLUDE_CDS</span>
<span class="line-added">3989 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3990   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3991 }</span>
<span class="line-added">3992 #endif</span>
<span class="line-added">3993 </span>
3994 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
3995 
3996 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
3997 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
3998 
3999 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4000   InstanceKlass* k = SystemDictionary::Context_klass();
4001   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4002 }
4003 
4004 #if INCLUDE_CDS
4005 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4006   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4007 }
4008 #endif
4009 
4010 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4011   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4012   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4013   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
</pre>
<hr />
<pre>
4025 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4026   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4027   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4028   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4029   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4030 
4031 void java_security_AccessControlContext::compute_offsets() {
4032   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4033   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4034   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4035 }
4036 
4037 #if INCLUDE_CDS
4038 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4039   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4040 }
4041 #endif
4042 
4043 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4044   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-added">4045   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);</span>
4046   // Ensure klass is initialized
4047   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);
4048   // Allocate result
4049   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);
4050   // Fill in values
4051   result-&gt;obj_field_put(_context_offset, context());
4052   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4053   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
<span class="line-modified">4054   // whitelist AccessControlContexts created by the JVM</span>
<span class="line-modified">4055   result-&gt;bool_field_put(_isAuthorized_offset, true);</span>


4056   return result;
4057 }
4058 
4059 
4060 // Support for java_lang_ClassLoader
4061 
4062 bool java_lang_ClassLoader::offsets_computed = false;
4063 int  java_lang_ClassLoader::_loader_data_offset = -1;
4064 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4065 int  java_lang_ClassLoader::name_offset = -1;
4066 int  java_lang_ClassLoader::nameAndId_offset = -1;
4067 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4068 
4069 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
<span class="line-modified">4070   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">4071   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
4072   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4073 }
4074 
4075 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
<span class="line-modified">4076   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">4077   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
4078   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4079 }
4080 
4081 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
<span class="line-modified">4082   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">4083   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
4084   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4085 }
4086 
4087 #define CLASSLOADER_FIELDS_DO(macro) \
4088   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4089   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4090   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4091   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4092   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4093 
4094 void java_lang_ClassLoader::compute_offsets() {
4095   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4096   offsets_computed = true;
4097 
4098   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4099   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4100 
4101   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4102 }
4103 
</pre>
<hr />
<pre>
4122 
4123 // Returns the nameAndId field of this class loader. The format is
4124 // as follows:
4125 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4126 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4127 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4128 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4129 oop java_lang_ClassLoader::nameAndId(oop loader) {
4130   assert(is_instance(loader), &quot;loader must be oop&quot;);
4131   return loader-&gt;obj_field(nameAndId_offset);
4132 }
4133 
4134 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4135   assert(is_instance(loader), &quot;loader must be oop&quot;);
4136   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4137   oop acl = loader;
4138   debug_only(jint loop_count = 0);
4139   // This loop taken verbatim from ClassLoader.java:
4140   do {
4141     acl = parent(acl);
<span class="line-modified">4142     if (cl == acl) {</span>
4143       return true;
4144     }
4145     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4146   } while (acl != NULL);
4147   return false;
4148 }
4149 
4150 bool java_lang_ClassLoader::is_instance(oop obj) {
4151   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4152 }
4153 
4154 
4155 // For class loader classes, parallelCapable defined
4156 // based on non-null field
4157 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4158 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">4159   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);</span>



4160   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4161 }
4162 
4163 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4164   // Fix for 4474172; see evaluation for more details
4165   loader = non_reflection_class_loader(loader);
4166 
4167   oop cl = SystemDictionary::java_system_loader();
4168   while(cl != NULL) {
<span class="line-modified">4169     if (cl == loader) return true;</span>
4170     cl = parent(cl);
4171   }
4172   return false;
4173 }
4174 
4175 // Return true if this is one of the class loaders associated with
4176 // the generated bytecodes for reflection.
4177 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4178   if (loader != NULL) {
4179     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4180     // This might be null in non-1.4 JDKs
4181     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4182   }
4183   return false;
4184 }
4185 
4186 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4187   // See whether this is one of the class loaders associated with
4188   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4189   // delegate to its parent to prevent class loading from occurring
</pre>
<hr />
<pre>
4205   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4206   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4207   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4208   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4209 
4210 void java_lang_System::compute_offsets() {
4211   InstanceKlass* k = SystemDictionary::System_klass();
4212   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4213 }
4214 
4215 #if INCLUDE_CDS
4216 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4217    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4218 }
4219 #endif
4220 
4221 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4222 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4223 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4224 
<span class="line-added">4225 // Support for jdk_internal_misc_UnsafeConstants</span>
<span class="line-added">4226 //</span>
<span class="line-added">4227 class UnsafeConstantsFixup : public FieldClosure {</span>
<span class="line-added">4228 private:</span>
<span class="line-added">4229   int _address_size;</span>
<span class="line-added">4230   int _page_size;</span>
<span class="line-added">4231   bool _big_endian;</span>
<span class="line-added">4232   bool _use_unaligned_access;</span>
<span class="line-added">4233   int _data_cache_line_flush_size;</span>
<span class="line-added">4234 public:</span>
<span class="line-added">4235   UnsafeConstantsFixup() {</span>
<span class="line-added">4236     // round up values for all static final fields</span>
<span class="line-added">4237     _address_size = sizeof(void*);</span>
<span class="line-added">4238     _page_size = os::vm_page_size();</span>
<span class="line-added">4239     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);</span>
<span class="line-added">4240     _use_unaligned_access = UseUnalignedAccesses;</span>
<span class="line-added">4241     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();</span>
<span class="line-added">4242   }</span>
<span class="line-added">4243 </span>
<span class="line-added">4244   void do_field(fieldDescriptor* fd) {</span>
<span class="line-added">4245     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();</span>
<span class="line-added">4246     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);</span>
<span class="line-added">4247     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);</span>
<span class="line-added">4248     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);</span>
<span class="line-added">4249     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);</span>
<span class="line-added">4250     if (fd-&gt;name() == vmSymbols::address_size_name()) {</span>
<span class="line-added">4251       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);</span>
<span class="line-added">4252     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {</span>
<span class="line-added">4253       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);</span>
<span class="line-added">4254     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {</span>
<span class="line-added">4255       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);</span>
<span class="line-added">4256     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {</span>
<span class="line-added">4257       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);</span>
<span class="line-added">4258     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {</span>
<span class="line-added">4259       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);</span>
<span class="line-added">4260     } else {</span>
<span class="line-added">4261       assert(false, &quot;unexpected UnsafeConstants field&quot;);</span>
<span class="line-added">4262     }</span>
<span class="line-added">4263   }</span>
<span class="line-added">4264 };</span>
<span class="line-added">4265 </span>
<span class="line-added">4266 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {</span>
<span class="line-added">4267   UnsafeConstantsFixup fixup;</span>
<span class="line-added">4268   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);</span>
<span class="line-added">4269 }</span>
<span class="line-added">4270 </span>
4271 int java_lang_Class::_klass_offset;
4272 int java_lang_Class::_array_klass_offset;
4273 int java_lang_Class::_oop_size_offset;
4274 int java_lang_Class::_static_oop_field_count_offset;
4275 int java_lang_Class::_class_loader_offset;
4276 int java_lang_Class::_module_offset;
4277 int java_lang_Class::_protection_domain_offset;
4278 int java_lang_Class::_component_mirror_offset;
4279 int java_lang_Class::_init_lock_offset;
4280 int java_lang_Class::_signers_offset;
4281 int java_lang_Class::_name_offset;
4282 int java_lang_Class::_source_file_offset;
4283 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4284 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4285 int java_lang_Throwable::backtrace_offset;
4286 int java_lang_Throwable::detailMessage_offset;
4287 int java_lang_Throwable::stackTrace_offset;
4288 int java_lang_Throwable::depth_offset;
4289 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4290 int java_lang_reflect_AccessibleObject::override_offset;
</pre>
<hr />
<pre>
4338 int java_lang_StackTraceElement::moduleVersion_offset;
4339 int java_lang_StackTraceElement::classLoaderName_offset;
4340 int java_lang_StackTraceElement::declaringClass_offset;
4341 int java_lang_StackTraceElement::declaringClassObject_offset;
4342 int java_lang_StackFrameInfo::_memberName_offset;
4343 int java_lang_StackFrameInfo::_bci_offset;
4344 int java_lang_StackFrameInfo::_version_offset;
4345 int java_lang_LiveStackFrameInfo::_monitors_offset;
4346 int java_lang_LiveStackFrameInfo::_locals_offset;
4347 int java_lang_LiveStackFrameInfo::_operands_offset;
4348 int java_lang_LiveStackFrameInfo::_mode_offset;
4349 int java_lang_AssertionStatusDirectives::classes_offset;
4350 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4351 int java_lang_AssertionStatusDirectives::packages_offset;
4352 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4353 int java_lang_AssertionStatusDirectives::deflt_offset;
4354 int java_nio_Buffer::_limit_offset;
4355 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4356 int reflect_ConstantPool::_oop_offset;
4357 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
<span class="line-added">4358 int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-added">4359 int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-added">4360 int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-added">4361 int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-added">4362 int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-added">4363 int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-added">4364 int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-added">4365 int java_lang_reflect_RecordComponent::clazz_offset;</span>
<span class="line-added">4366 int java_lang_reflect_RecordComponent::name_offset;</span>
<span class="line-added">4367 int java_lang_reflect_RecordComponent::type_offset;</span>
<span class="line-added">4368 int java_lang_reflect_RecordComponent::accessor_offset;</span>
<span class="line-added">4369 int java_lang_reflect_RecordComponent::signature_offset;</span>
<span class="line-added">4370 int java_lang_reflect_RecordComponent::annotations_offset;</span>
<span class="line-added">4371 int java_lang_reflect_RecordComponent::typeAnnotations_offset;</span>
<span class="line-added">4372 </span>
4373 
4374 
4375 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4376   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4377   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4378   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4379   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4380   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4381   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4382   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4383   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4384 
4385 // Support for java_lang_StackTraceElement
4386 void java_lang_StackTraceElement::compute_offsets() {
4387   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4388   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4389 }
4390 
4391 #if INCLUDE_CDS
4392 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
</pre>
<hr />
<pre>
4414   element-&gt;obj_field_put(moduleName_offset, value);
4415 }
4416 
4417 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4418   element-&gt;obj_field_put(moduleVersion_offset, value);
4419 }
4420 
4421 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4422   element-&gt;obj_field_put(classLoaderName_offset, value);
4423 }
4424 
4425 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4426   element-&gt;obj_field_put(declaringClassObject_offset, value);
4427 }
4428 
4429 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4430   element-&gt;short_field_put(_version_offset, value);
4431 }
4432 
4433 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
<span class="line-added">4434   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
4435   element-&gt;int_field_put(_bci_offset, value);
4436 }
4437 
4438 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4439   element-&gt;obj_field_put(_monitors_offset, value);
4440 }
4441 
4442 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4443   element-&gt;obj_field_put(_locals_offset, value);
4444 }
4445 
4446 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4447   element-&gt;obj_field_put(_operands_offset, value);
4448 }
4449 
4450 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4451   element-&gt;int_field_put(_mode_offset, value);
4452 }
4453 
4454 // Support for java Assertions - java_lang_AssertionStatusDirectives.
</pre>
<hr />
<pre>
4513 
4514 #define AOS_FIELDS_DO(macro) \
4515   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4516 
4517 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4518   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4519   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4520 }
4521 
4522 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4523   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4524   return obj-&gt;obj_field(_owner_offset);
4525 }
4526 
4527 #if INCLUDE_CDS
4528 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4529   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4530 }
4531 #endif
4532 
<span class="line-added">4533 #define INTEGER_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">4534   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)</span>
<span class="line-added">4535 </span>
<span class="line-added">4536 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4537   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4538   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4539 }</span>
<span class="line-added">4540 </span>
<span class="line-added">4541 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">4542   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4543   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">4544 }</span>
<span class="line-added">4545 </span>
<span class="line-added">4546 Symbol* java_lang_Integer_IntegerCache::symbol() {</span>
<span class="line-added">4547   return vmSymbols::java_lang_Integer_IntegerCache();</span>
<span class="line-added">4548 }</span>
<span class="line-added">4549 </span>
<span class="line-added">4550 #if INCLUDE_CDS</span>
<span class="line-added">4551 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4552   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4553 }</span>
<span class="line-added">4554 #endif</span>
<span class="line-added">4555 #undef INTEGER_CACHE_FIELDS_DO</span>
<span class="line-added">4556 </span>
<span class="line-added">4557 jint java_lang_Integer::value(oop obj) {</span>
<span class="line-added">4558    jvalue v;</span>
<span class="line-added">4559    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4560    return v.i;</span>
<span class="line-added">4561 }</span>
<span class="line-added">4562 </span>
<span class="line-added">4563 #define LONG_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">4564   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)</span>
<span class="line-added">4565 </span>
<span class="line-added">4566 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4567   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4568   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4569 }</span>
<span class="line-added">4570 </span>
<span class="line-added">4571 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">4572   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4573   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">4574 }</span>
<span class="line-added">4575 </span>
<span class="line-added">4576 Symbol* java_lang_Long_LongCache::symbol() {</span>
<span class="line-added">4577   return vmSymbols::java_lang_Long_LongCache();</span>
<span class="line-added">4578 }</span>
<span class="line-added">4579 </span>
<span class="line-added">4580 #if INCLUDE_CDS</span>
<span class="line-added">4581 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4582   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4583 }</span>
<span class="line-added">4584 #endif</span>
<span class="line-added">4585 #undef LONG_CACHE_FIELDS_DO</span>
<span class="line-added">4586 </span>
<span class="line-added">4587 jlong java_lang_Long::value(oop obj) {</span>
<span class="line-added">4588    jvalue v;</span>
<span class="line-added">4589    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4590    return v.j;</span>
<span class="line-added">4591 }</span>
<span class="line-added">4592 </span>
<span class="line-added">4593 #define CHARACTER_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">4594   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)</span>
<span class="line-added">4595 </span>
<span class="line-added">4596 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4597   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4598   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4599 }</span>
<span class="line-added">4600 </span>
<span class="line-added">4601 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">4602   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4603   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">4604 }</span>
<span class="line-added">4605 </span>
<span class="line-added">4606 Symbol* java_lang_Character_CharacterCache::symbol() {</span>
<span class="line-added">4607   return vmSymbols::java_lang_Character_CharacterCache();</span>
<span class="line-added">4608 }</span>
<span class="line-added">4609 </span>
<span class="line-added">4610 #if INCLUDE_CDS</span>
<span class="line-added">4611 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4612   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4613 }</span>
<span class="line-added">4614 #endif</span>
<span class="line-added">4615 #undef CHARACTER_CACHE_FIELDS_DO</span>
<span class="line-added">4616 </span>
<span class="line-added">4617 jchar java_lang_Character::value(oop obj) {</span>
<span class="line-added">4618    jvalue v;</span>
<span class="line-added">4619    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4620    return v.c;</span>
<span class="line-added">4621 }</span>
<span class="line-added">4622 </span>
<span class="line-added">4623 #define SHORT_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">4624   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)</span>
<span class="line-added">4625 </span>
<span class="line-added">4626 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4627   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4628   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4629 }</span>
<span class="line-added">4630 </span>
<span class="line-added">4631 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">4632   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4633   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">4634 }</span>
<span class="line-added">4635 </span>
<span class="line-added">4636 Symbol* java_lang_Short_ShortCache::symbol() {</span>
<span class="line-added">4637   return vmSymbols::java_lang_Short_ShortCache();</span>
<span class="line-added">4638 }</span>
<span class="line-added">4639 </span>
<span class="line-added">4640 #if INCLUDE_CDS</span>
<span class="line-added">4641 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4642   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4643 }</span>
<span class="line-added">4644 #endif</span>
<span class="line-added">4645 #undef SHORT_CACHE_FIELDS_DO</span>
<span class="line-added">4646 </span>
<span class="line-added">4647 jshort java_lang_Short::value(oop obj) {</span>
<span class="line-added">4648    jvalue v;</span>
<span class="line-added">4649    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4650    return v.s;</span>
<span class="line-added">4651 }</span>
<span class="line-added">4652 </span>
<span class="line-added">4653 #define BYTE_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">4654   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)</span>
<span class="line-added">4655 </span>
<span class="line-added">4656 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4657   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4658   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4659 }</span>
<span class="line-added">4660 </span>
<span class="line-added">4661 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">4662   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4663   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">4664 }</span>
<span class="line-added">4665 </span>
<span class="line-added">4666 Symbol* java_lang_Byte_ByteCache::symbol() {</span>
<span class="line-added">4667   return vmSymbols::java_lang_Byte_ByteCache();</span>
<span class="line-added">4668 }</span>
<span class="line-added">4669 </span>
<span class="line-added">4670 #if INCLUDE_CDS</span>
<span class="line-added">4671 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4672   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4673 }</span>
<span class="line-added">4674 #endif</span>
<span class="line-added">4675 #undef BYTE_CACHE_FIELDS_DO</span>
<span class="line-added">4676 </span>
<span class="line-added">4677 jbyte java_lang_Byte::value(oop obj) {</span>
<span class="line-added">4678    jvalue v;</span>
<span class="line-added">4679    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4680    return v.b;</span>
<span class="line-added">4681 }</span>
<span class="line-added">4682 #define BOOLEAN_FIELDS_DO(macro) \</span>
<span class="line-added">4683   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \</span>
<span class="line-added">4684   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)</span>
<span class="line-added">4685 </span>
<span class="line-added">4686 </span>
<span class="line-added">4687 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">4688   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">4689   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4690 }</span>
<span class="line-added">4691 </span>
<span class="line-added">4692 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {</span>
<span class="line-added">4693   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4694   return base-&gt;obj_field(_static_TRUE_offset);</span>
<span class="line-added">4695 }</span>
<span class="line-added">4696 </span>
<span class="line-added">4697 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {</span>
<span class="line-added">4698   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">4699   return base-&gt;obj_field(_static_FALSE_offset);</span>
<span class="line-added">4700 }</span>
<span class="line-added">4701 </span>
<span class="line-added">4702 Symbol* java_lang_Boolean::symbol() {</span>
<span class="line-added">4703   return vmSymbols::java_lang_Boolean();</span>
<span class="line-added">4704 }</span>
<span class="line-added">4705 </span>
<span class="line-added">4706 #if INCLUDE_CDS</span>
<span class="line-added">4707 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4708   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4709 }</span>
<span class="line-added">4710 #endif</span>
<span class="line-added">4711 #undef BOOLEAN_CACHE_FIELDS_DO</span>
<span class="line-added">4712 </span>
<span class="line-added">4713 jboolean java_lang_Boolean::value(oop obj) {</span>
<span class="line-added">4714    jvalue v;</span>
<span class="line-added">4715    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">4716    return v.z;</span>
<span class="line-added">4717 }</span>
<span class="line-added">4718 </span>
4719 static int member_offset(int hardcoded_offset) {
4720   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
4721 }
4722 
<span class="line-added">4723 #define RECORDCOMPONENT_FIELDS_DO(macro) \</span>
<span class="line-added">4724   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-added">4725   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-added">4726   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-added">4727   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-added">4728   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-added">4729   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-added">4730   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
<span class="line-added">4731 </span>
<span class="line-added">4732 // Support for java_lang_reflect_RecordComponent</span>
<span class="line-added">4733 void java_lang_reflect_RecordComponent::compute_offsets() {</span>
<span class="line-added">4734   InstanceKlass* k = SystemDictionary::RecordComponent_klass();</span>
<span class="line-added">4735   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4736 }</span>
<span class="line-added">4737 </span>
<span class="line-added">4738 #if INCLUDE_CDS</span>
<span class="line-added">4739 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4740   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4741 }</span>
<span class="line-added">4742 #endif</span>
<span class="line-added">4743 </span>
<span class="line-added">4744 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {</span>
<span class="line-added">4745   element-&gt;obj_field_put(clazz_offset, value);</span>
<span class="line-added">4746 }</span>
<span class="line-added">4747 </span>
<span class="line-added">4748 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {</span>
<span class="line-added">4749   element-&gt;obj_field_put(name_offset, value);</span>
<span class="line-added">4750 }</span>
<span class="line-added">4751 </span>
<span class="line-added">4752 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {</span>
<span class="line-added">4753   element-&gt;obj_field_put(type_offset, value);</span>
<span class="line-added">4754 }</span>
<span class="line-added">4755 </span>
<span class="line-added">4756 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {</span>
<span class="line-added">4757   element-&gt;obj_field_put(accessor_offset, value);</span>
<span class="line-added">4758 }</span>
<span class="line-added">4759 </span>
<span class="line-added">4760 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {</span>
<span class="line-added">4761   element-&gt;obj_field_put(signature_offset, value);</span>
<span class="line-added">4762 }</span>
<span class="line-added">4763 </span>
<span class="line-added">4764 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {</span>
<span class="line-added">4765   element-&gt;obj_field_put(annotations_offset, value);</span>
<span class="line-added">4766 }</span>
<span class="line-added">4767 </span>
<span class="line-added">4768 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {</span>
<span class="line-added">4769   element-&gt;obj_field_put(typeAnnotations_offset, value);</span>
<span class="line-added">4770 }</span>
<span class="line-added">4771 </span>
4772 // Compute hard-coded offsets
4773 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4774 // are not available to determine the offset_of_static_fields.
4775 void JavaClasses::compute_hard_coded_offsets() {
4776 
4777   // java_lang_boxing_object
4778   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4779   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4780 
4781   // java_lang_ref_Reference
4782   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4783   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4784   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4785   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4786 }
4787 
4788 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4789 
4790 // Compute non-hard-coded field offsets of all the classes in this file
4791 void JavaClasses::compute_offsets() {
4792   if (UseSharedSpaces) {
4793     assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4794                                               JvmtiExport::has_early_class_hook_env()),
4795            &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;);
4796     // None of the classes used by the rest of this function can be replaced by
4797     // JMVTI ClassFileLoadHook.
4798     // We are safe to use the archived offsets, which have already been restored
4799     // by JavaClasses::serialize_offsets, without computing the offsets again.
4800     return;
4801   }
4802 
4803   // We have already called the compute_offsets() of the
4804   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4805   // earlier inside SystemDictionary::resolve_well_known_classes()
4806   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);



4807 }
4808 
4809 #if INCLUDE_CDS
4810 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4811 
4812 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4813   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4814 }
4815 #endif
4816 
<span class="line-added">4817 #if INCLUDE_CDS_JAVA_HEAP</span>
<span class="line-added">4818 bool JavaClasses::is_supported_for_archiving(oop obj) {</span>
<span class="line-added">4819   Klass* klass = obj-&gt;klass();</span>
<span class="line-added">4820 </span>
<span class="line-added">4821   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.</span>
<span class="line-added">4822       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed</span>
<span class="line-added">4823       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in</span>
<span class="line-added">4824       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes</span>
<span class="line-added">4825       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.</span>
<span class="line-added">4826       // So for now we cannot not support these classes for archiving.</span>
<span class="line-added">4827       //</span>
<span class="line-added">4828       // These objects typically are not referenced by static fields, but rather by resolved</span>
<span class="line-added">4829       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.</span>
<span class="line-added">4830       klass == SystemDictionary::ResolvedMethodName_klass() ||</span>
<span class="line-added">4831       klass == SystemDictionary::MemberName_klass() ||</span>
<span class="line-added">4832       klass == SystemDictionary::Context_klass()) {</span>
<span class="line-added">4833     return false;</span>
<span class="line-added">4834   }</span>
<span class="line-added">4835 </span>
<span class="line-added">4836   return true;</span>
<span class="line-added">4837 }</span>
<span class="line-added">4838 #endif</span>
4839 
4840 #ifndef PRODUCT
4841 
4842 // These functions exist to assert the validity of hard-coded field offsets to guard
4843 // against changes in the class files
4844 
4845 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
4846   EXCEPTION_MARK;
4847   fieldDescriptor fd;
<span class="line-modified">4848   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);</span>
4849   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4850   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">4851   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);</span>
<span class="line-modified">4852   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);</span>
4853   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4854     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4855     return false;
4856   }
4857   if (fd.is_static()) {
4858     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4859     return false;
4860   }
4861   if (fd.offset() == hardcoded_offset ) {
4862     return true;
4863   } else {
4864     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
4865                   klass_name, field_name, hardcoded_offset, fd.offset());
4866     return false;
4867   }
4868 }
4869 
4870 // Check the hard-coded field offsets of all the classes in this file
4871 
4872 void JavaClasses::check_offsets() {
</pre>
</td>
</tr>
</table>
<center><a href="javaAssertions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
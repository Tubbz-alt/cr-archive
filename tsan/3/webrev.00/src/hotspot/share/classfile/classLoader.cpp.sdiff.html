<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;jimage.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;

  37 #include &quot;classfile/systemDictionary.hpp&quot;

  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;compiler/compileBroker.hpp&quot;
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/oopMapCache.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;logging/logTag.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/instanceKlass.hpp&quot;
  51 #include &quot;oops/instanceRefKlass.hpp&quot;
  52 #include &quot;oops/method.inline.hpp&quot;
  53 #include &quot;oops/objArrayOop.inline.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;oops/symbol.hpp&quot;
  56 #include &quot;prims/jvm_misc.hpp&quot;
  57 #include &quot;runtime/arguments.hpp&quot;
<span class="line-removed">  58 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/os.inline.hpp&quot;
  65 #include &quot;runtime/threadCritical.hpp&quot;
  66 #include &quot;runtime/timer.hpp&quot;
  67 #include &quot;runtime/vm_version.hpp&quot;
  68 #include &quot;services/management.hpp&quot;
  69 #include &quot;services/threadService.hpp&quot;

  70 #include &quot;utilities/events.hpp&quot;
  71 #include &quot;utilities/hashtable.inline.hpp&quot;
  72 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  73 #if INCLUDE_CDS</span>
<span class="line-modified">  74 #include &quot;classfile/sharedPathsMiscInfo.hpp&quot;</span>
<span class="line-modified">  75 #endif</span>



  76 
  77 // Entry points in zip.dll for loading zip/jar file entries
  78 
  79 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
<span class="line-modified">  80 typedef void (*ZipClose_t)(jzfile *zip);</span>
  81 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  82 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  83 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
<span class="line-removed">  84 typedef jboolean (*ZipInflateFully_t)(void *inBuf, jlong inLen, void *outBuf, jlong outLen, char **pmsg);</span>
  85 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  86 
  87 static ZipOpen_t         ZipOpen            = NULL;
  88 static ZipClose_t        ZipClose           = NULL;
  89 static FindEntry_t       FindEntry          = NULL;
  90 static ReadEntry_t       ReadEntry          = NULL;
  91 static GetNextEntry_t    GetNextEntry       = NULL;
<span class="line-removed">  92 static canonicalize_fn_t CanonicalizeEntry  = NULL;</span>
<span class="line-removed">  93 static ZipInflateFully_t ZipInflateFully    = NULL;</span>
  94 static Crc32_t           Crc32              = NULL;
  95 
  96 // Entry points for jimage.dll for loading jimage file entries
  97 
  98 static JImageOpen_t                    JImageOpen             = NULL;
  99 static JImageClose_t                   JImageClose            = NULL;
 100 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 101 static JImageFindResource_t            JImageFindResource     = NULL;
 102 static JImageGetResource_t             JImageGetResource      = NULL;
 103 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 104 
 105 // Globals
 106 
 107 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 108 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 109 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 110 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 111 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
</pre>
<hr />
<pre>
 127 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 128 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 129 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 130 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 131 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 132 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 133 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 134 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 136 
 137 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 138 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
 139 ClassPathEntry* ClassLoader::_jrt_entry = NULL;
 140 ClassPathEntry* ClassLoader::_first_append_entry = NULL;
 141 ClassPathEntry* ClassLoader::_last_append_entry  = NULL;
 142 #if INCLUDE_CDS
 143 ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
 144 ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
 145 ClassPathEntry* ClassLoader::_module_path_entries = NULL;
 146 ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;
<span class="line-removed"> 147 SharedPathsMiscInfo* ClassLoader::_shared_paths_misc_info = NULL;</span>
 148 #endif
 149 
 150 // helper routines
 151 bool string_starts_with(const char* str, const char* str_to_find) {
 152   size_t str_len = strlen(str);
 153   size_t str_to_find_len = strlen(str_to_find);
 154   if (str_to_find_len &gt; str_len) {
 155     return false;
 156   }
 157   return (strncmp(str, str_to_find, str_to_find_len) == 0);
 158 }
 159 
 160 static const char* get_jimage_version_string() {
 161   static char version_string[10] = &quot;&quot;;
 162   if (version_string[0] == &#39;\0&#39;) {
 163     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 164                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 165   }
 166   return (const char*)version_string;
 167 }
</pre>
<hr />
<pre>
 172   if (str_to_find_len &gt; str_len) {
 173     return false;
 174   }
 175   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 176 }
 177 
 178 // Used to obtain the package name from a fully qualified class name.
 179 // It is the responsibility of the caller to establish a ResourceMark.
 180 const char* ClassLoader::package_from_name(const char* const class_name, bool* bad_class_name) {
 181   if (class_name == NULL) {
 182     if (bad_class_name != NULL) {
 183       *bad_class_name = true;
 184     }
 185     return NULL;
 186   }
 187 
 188   if (bad_class_name != NULL) {
 189     *bad_class_name = false;
 190   }
 191 
<span class="line-modified"> 192   const char* const last_slash = strrchr(class_name, &#39;/&#39;);</span>
 193   if (last_slash == NULL) {
 194     // No package name
 195     return NULL;
 196   }
 197 
 198   char* class_name_ptr = (char*) class_name;
 199   // Skip over &#39;[&#39;s
<span class="line-modified"> 200   if (*class_name_ptr == &#39;[&#39;) {</span>
 201     do {
 202       class_name_ptr++;
<span class="line-modified"> 203     } while (*class_name_ptr == &#39;[&#39;);</span>
 204 
 205     // Fully qualified class names should not contain a &#39;L&#39;.
 206     // Set bad_class_name to true to indicate that the package name
 207     // could not be obtained due to an error condition.
 208     // In this situation, is_same_class_package returns false.
<span class="line-modified"> 209     if (*class_name_ptr == &#39;L&#39;) {</span>
 210       if (bad_class_name != NULL) {
 211         *bad_class_name = true;
 212       }
 213       return NULL;
 214     }
 215   }
 216 
 217   int length = last_slash - class_name_ptr;
 218 
 219   // A class name could have just the slash character in the name.
 220   if (length &lt;= 0) {
 221     // No package name
 222     if (bad_class_name != NULL) {
 223       *bad_class_name = true;
 224     }
 225     return NULL;
 226   }
 227 
 228   // drop name after last slash (including slash)
 229   // Ex., &quot;java/lang/String.class&quot; =&gt; &quot;java/lang&quot;
 230   char* pkg_name = NEW_RESOURCE_ARRAY(char, length + 1);
 231   strncpy(pkg_name, class_name_ptr, length);
 232   *(pkg_name+length) = &#39;\0&#39;;
 233 
 234   return (const char *)pkg_name;
 235 }
 236 
 237 // Given a fully qualified class name, find its defining package in the class loader&#39;s
 238 // package entry table.
 239 PackageEntry* ClassLoader::get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS) {
 240   ResourceMark rm(THREAD);
 241   const char *pkg_name = ClassLoader::package_from_name(class_name);
 242   if (pkg_name == NULL) {
 243     return NULL;
 244   }
 245   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 246   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name, CHECK_NULL);</span>
 247   return pkgEntryTable-&gt;lookup_only(pkg_symbol);
 248 }
 249 
<span class="line-modified"> 250 ClassPathDirEntry::ClassPathDirEntry(const char* dir) : ClassPathEntry() {</span>
<span class="line-modified"> 251   char* copy = NEW_C_HEAP_ARRAY(char, strlen(dir)+1, mtClass);</span>
<span class="line-modified"> 252   strcpy(copy, dir);</span>
<span class="line-modified"> 253   _dir = copy;</span>
 254 }
 255 
<span class="line-removed"> 256 </span>
 257 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 258   // construct full path name
 259   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 260   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 261   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 262   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 263   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 264   // check if file exists
 265   struct stat st;
 266   if (os::stat(path, &amp;st) == 0) {
 267     // found file, open it
 268     int file_handle = os::open(path, 0, 0);
 269     if (file_handle != -1) {
 270       // read contents into resource array
 271       u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);
 272       size_t num_read = os::read(file_handle, (char*) buffer, st.st_size);
 273       // close file
 274       os::close(file_handle);
 275       // construct ClassFileStream
 276       if (num_read == (size_t)st.st_size) {
 277         if (UsePerfData) {
 278           ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(num_read);
 279         }
 280         FREE_RESOURCE_ARRAY(char, path, path_len);
 281         // Resource allocated
 282         return new ClassFileStream(buffer,
 283                                    st.st_size,
 284                                    _dir,
 285                                    ClassFileStream::verify);
 286       }
 287     }
 288   }
 289   FREE_RESOURCE_ARRAY(char, path, path_len);
 290   return NULL;
 291 }
 292 
<span class="line-modified"> 293 ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append) : ClassPathEntry() {</span>

 294   _zip = zip;
<span class="line-modified"> 295   char *copy = NEW_C_HEAP_ARRAY(char, strlen(zip_name)+1, mtClass);</span>
<span class="line-modified"> 296   strcpy(copy, zip_name);</span>
<span class="line-removed"> 297   _zip_name = copy;</span>
 298 }
 299 
 300 ClassPathZipEntry::~ClassPathZipEntry() {
<span class="line-modified"> 301   if (ZipClose != NULL) {</span>
<span class="line-removed"> 302     (*ZipClose)(_zip);</span>
<span class="line-removed"> 303   }</span>
 304   FREE_C_HEAP_ARRAY(char, _zip_name);
 305 }
 306 
 307 u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
 308     // enable call to C land
 309   JavaThread* thread = JavaThread::current();
 310   ThreadToNativeFromVM ttn(thread);
 311   // check whether zip archive contains name
 312   jint name_len;
 313   jzentry* entry = (*FindEntry)(_zip, name, filesize, &amp;name_len);
 314   if (entry == NULL) return NULL;
 315   u1* buffer;
 316   char name_buf[128];
 317   char* filename;
 318   if (name_len &lt; 128) {
 319     filename = name_buf;
 320   } else {
 321     filename = NEW_RESOURCE_ARRAY(char, name_len + 1);
 322   }
 323 
</pre>
<hr />
<pre>
 344   }
 345   // Resource allocated
 346   return new ClassFileStream(buffer,
 347                              filesize,
 348                              _zip_name,
 349                              ClassFileStream::verify);
 350 }
 351 
 352 // invoke function for each entry in the zip file
 353 void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {
 354   JavaThread* thread = JavaThread::current();
 355   HandleMark  handle_mark(thread);
 356   ThreadToNativeFromVM ttn(thread);
 357   for (int n = 0; ; n++) {
 358     jzentry * ze = ((*GetNextEntry)(_zip, n));
 359     if (ze == NULL) break;
 360     (*f)(ze-&gt;name, context);
 361   }
 362 }
 363 


 364 void ClassPathImageEntry::close_jimage() {
 365   if (_jimage != NULL) {
 366     (*JImageClose)(_jimage);
 367     _jimage = NULL;
 368   }
 369 }
 370 
 371 ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
 372   ClassPathEntry(),
 373   _jimage(jimage) {
 374   guarantee(jimage != NULL, &quot;jimage file is null&quot;);
 375   guarantee(name != NULL, &quot;jimage file name is null&quot;);


 376   size_t len = strlen(name) + 1;
<span class="line-modified"> 377   _name = NEW_C_HEAP_ARRAY(const char, len, mtClass);</span>
<span class="line-removed"> 378   strncpy((char *)_name, name, len);</span>
 379 }
 380 
 381 ClassPathImageEntry::~ClassPathImageEntry() {
<span class="line-modified"> 382   if (_name != NULL) {</span>
<span class="line-modified"> 383     FREE_C_HEAP_ARRAY(const char, _name);</span>
<span class="line-modified"> 384     _name = NULL;</span>
<span class="line-modified"> 385   }</span>

 386   if (_jimage != NULL) {
 387     (*JImageClose)(_jimage);
 388     _jimage = NULL;
 389   }
 390 }
 391 




 392 // For a class in a named module, look it up in the jimage file using this syntax:
 393 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 394 //
 395 // Assumptions:
 396 //     1. There are no unnamed modules in the jimage file.
 397 //     2. A package is in at most one module in the jimage file.
 398 //
<span class="line-modified"> 399 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {</span>
 400   jlong size;
 401   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 402 
 403   if (location == 0) {
 404     ResourceMark rm;
 405     const char* pkg_name = ClassLoader::package_from_name(name);
 406 
 407     if (pkg_name != NULL) {
 408       if (!Universe::is_module_initialized()) {
 409         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
<span class="line-removed"> 410 #if INCLUDE_CDS</span>
<span class="line-removed"> 411         // CDS uses the boot class loader to load classes whose packages are in</span>
<span class="line-removed"> 412         // modules defined for other class loaders.  So, for now, get their module</span>
<span class="line-removed"> 413         // names from the &quot;modules&quot; jimage file.</span>
<span class="line-removed"> 414         if (DumpSharedSpaces &amp;&amp; location == 0) {</span>
<span class="line-removed"> 415           const char* module_name = (*JImagePackageToModule)(_jimage, pkg_name);</span>
<span class="line-removed"> 416           if (module_name != NULL) {</span>
<span class="line-removed"> 417             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);</span>
<span class="line-removed"> 418           }</span>
<span class="line-removed"> 419         }</span>
<span class="line-removed"> 420 #endif</span>
<span class="line-removed"> 421 </span>
 422       } else {
<span class="line-modified"> 423         PackageEntry* package_entry = ClassLoader::get_package_entry(name, ClassLoaderData::the_null_class_loader_data(), CHECK_NULL);</span>
 424         if (package_entry != NULL) {
 425           ResourceMark rm;
 426           // Get the module name
 427           ModuleEntry* module = package_entry-&gt;module();
 428           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 429           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 430           const char* module_name = module-&gt;name()-&gt;as_C_string();
 431           if (module_name != NULL) {
 432             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 433           }
 434         }
 435       }
 436     }
 437   }
 438   if (location != 0) {
 439     if (UsePerfData) {
 440       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 441     }
 442     char* data = NEW_RESOURCE_ARRAY(char, size);
 443     (*JImageGetResource)(_jimage, location, data, size);
 444     // Resource allocated

 445     return new ClassFileStream((u1*)data,
 446                                (int)size,
 447                                _name,
<span class="line-modified"> 448                                ClassFileStream::verify);</span>

 449   }
 450 
 451   return NULL;
 452 }
 453 
 454 JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,
 455                                                     const char* module_name,
 456                                                     const char* file_name,
 457                                                     jlong &amp;size) {
 458   return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
 459 }
 460 
 461 bool ClassPathImageEntry::is_modules_image() const {
<span class="line-modified"> 462   return ClassLoader::is_modules_image(name());</span>


 463 }
 464 
 465 #if INCLUDE_CDS
 466 void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
<span class="line-modified"> 467   assert(DumpSharedSpaces, &quot;only called at dump time&quot;);</span>
 468   tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
 469   vm_exit_during_initialization(error, message);
 470 }
 471 #endif
 472 
 473 ModuleClassPathList::ModuleClassPathList(Symbol* module_name) {
 474   _module_name = module_name;
 475   _module_first_entry = NULL;
 476   _module_last_entry = NULL;
 477 }
 478 
 479 ModuleClassPathList::~ModuleClassPathList() {
 480   // Clean out each ClassPathEntry on list
 481   ClassPathEntry* e = _module_first_entry;
 482   while (e != NULL) {
 483     ClassPathEntry* next_entry = e-&gt;next();
 484     delete e;
 485     e = next_entry;
 486   }
 487 }
</pre>
<hr />
<pre>
 512         // as print_cr() has a length limit
 513         while (name[0] != &#39;\0&#39;) {
 514           ls.print(&quot;%c&quot;, name[0]);
 515           name++;
 516         }
 517       }
 518     }
 519     ls.cr();
 520   }
 521 }
 522 
 523 void ClassLoader::setup_bootstrap_search_path() {
 524   const char* sys_class_path = Arguments::get_sysclasspath();
 525   assert(sys_class_path != NULL, &quot;System boot class path must not be NULL&quot;);
 526   if (PrintSharedArchiveAndExit) {
 527     // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
 528     // the same as the bootcp of the shared archive.
 529   } else {
 530     trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
 531   }
<span class="line-removed"> 532 #if INCLUDE_CDS</span>
<span class="line-removed"> 533   if (DumpSharedSpaces) {</span>
<span class="line-removed"> 534     _shared_paths_misc_info-&gt;add_boot_classpath(sys_class_path);</span>
<span class="line-removed"> 535   }</span>
<span class="line-removed"> 536 #endif</span>
 537   setup_boot_search_path(sys_class_path);
 538 }
 539 
 540 #if INCLUDE_CDS
<span class="line-removed"> 541 int ClassLoader::get_shared_paths_misc_info_size() {</span>
<span class="line-removed"> 542   return _shared_paths_misc_info-&gt;get_used_bytes();</span>
<span class="line-removed"> 543 }</span>
<span class="line-removed"> 544 </span>
<span class="line-removed"> 545 void* ClassLoader::get_shared_paths_misc_info() {</span>
<span class="line-removed"> 546   return _shared_paths_misc_info-&gt;buffer();</span>
<span class="line-removed"> 547 }</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549 bool ClassLoader::check_shared_paths_misc_info(void *buf, int size) {</span>
<span class="line-removed"> 550   SharedPathsMiscInfo* checker = new SharedPathsMiscInfo((char*)buf, size);</span>
<span class="line-removed"> 551   bool result = checker-&gt;check();</span>
<span class="line-removed"> 552   delete checker;</span>
<span class="line-removed"> 553   return result;</span>
<span class="line-removed"> 554 }</span>
<span class="line-removed"> 555 </span>
 556 void ClassLoader::setup_app_search_path(const char *class_path) {

 557 
<span class="line-modified"> 558   assert(DumpSharedSpaces, &quot;Sanity&quot;);</span>
<span class="line-modified"> 559 </span>
<span class="line-removed"> 560   Thread* THREAD = Thread::current();</span>
<span class="line-removed"> 561   int len = (int)strlen(class_path);</span>
<span class="line-removed"> 562   int end = 0;</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   // Iterate over class path entries</span>
<span class="line-removed"> 565   for (int start = 0; start &lt; len; start = end) {</span>
<span class="line-removed"> 566     while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="line-removed"> 567       end++;</span>
<span class="line-removed"> 568     }</span>
<span class="line-removed"> 569     EXCEPTION_MARK;</span>
<span class="line-removed"> 570     ResourceMark rm(THREAD);</span>
<span class="line-removed"> 571     char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="line-removed"> 572     strncpy(path, &amp;class_path[start], end - start);</span>
<span class="line-removed"> 573     path[end - start] = &#39;\0&#39;;</span>
<span class="line-removed"> 574 </span>
<span class="line-removed"> 575     update_class_path_entry_list(path, false, false);</span>
 576 
<span class="line-modified"> 577     while (class_path[end] == os::path_separator()[0]) {</span>
<span class="line-modified"> 578       end++;</span>
<span class="line-modified"> 579     }</span>
 580   }
 581 }
 582 
 583 void ClassLoader::add_to_module_path_entries(const char* path,
 584                                              ClassPathEntry* entry) {
 585   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
<span class="line-modified"> 586   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
 587 
 588   // The entry does not exist, add to the list
 589   if (_module_path_entries == NULL) {
 590     assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
 591     _module_path_entries = _last_module_path_entry = entry;
 592   } else {
 593     _last_module_path_entry-&gt;set_next(entry);
 594     _last_module_path_entry = entry;
 595   }
 596 }
 597 
 598 // Add a module path to the _module_path_entries list.
 599 void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
<span class="line-modified"> 600   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
 601   struct stat st;
 602   if (os::stat(path, &amp;st) != 0) {
 603     tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
 604       errno, os::errno_name(errno), path);
 605     vm_exit_during_initialization();
 606   }
 607   // File or directory found
 608   ClassPathEntry* new_entry = NULL;
 609   new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
<span class="line-modified"> 610                                       false /*is_boot_append */, CHECK);</span>
 611   if (new_entry == NULL) {
 612     return;
 613   }
 614 
 615   add_to_module_path_entries(path, new_entry);
 616   return;
 617 }
 618 
 619 void ClassLoader::setup_module_search_path(const char* path, TRAPS) {
 620   update_module_path_entry_list(path, THREAD);
 621 }
 622 
 623 #endif // INCLUDE_CDS
 624 
 625 void ClassLoader::close_jrt_image() {
 626   // Not applicable for exploded builds
 627   if (!ClassLoader::has_jrt_entry()) return;
 628   _jrt_entry-&gt;close_jimage();
 629 }
 630 
 631 // Construct the array of module/path pairs as specified to --patch-module
 632 // for the boot loader to search ahead of the jimage, if the class being
 633 // loaded is defined to a module that has been specified to --patch-module.
 634 void ClassLoader::setup_patch_mod_entries() {
 635   Thread* THREAD = Thread::current();
 636   GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
 637   int num_of_entries = patch_mod_args-&gt;length();
 638 
<span class="line-removed"> 639 </span>
 640   // Set up the boot loader&#39;s _patch_mod_entries list
 641   _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
 642 
 643   for (int i = 0; i &lt; num_of_entries; i++) {
 644     const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
<span class="line-modified"> 645     Symbol* const module_sym = SymbolTable::lookup(module_name, (int)strlen(module_name), CHECK);</span>
 646     assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
 647     ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 648 
 649     char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
<span class="line-modified"> 650     int len = (int)strlen(class_path);</span>
<span class="line-modified"> 651     int end = 0;</span>
<span class="line-removed"> 652     // Iterate over the module&#39;s class path entries</span>
<span class="line-removed"> 653     for (int start = 0; start &lt; len; start = end) {</span>
<span class="line-removed"> 654       while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="line-removed"> 655         end++;</span>
<span class="line-removed"> 656       }</span>
<span class="line-removed"> 657       EXCEPTION_MARK;</span>
<span class="line-removed"> 658       ResourceMark rm(THREAD);</span>
<span class="line-removed"> 659       char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="line-removed"> 660       strncpy(path, &amp;class_path[start], end - start);</span>
<span class="line-removed"> 661       path[end - start] = &#39;\0&#39;;</span>
 662 


 663       struct stat st;
 664       if (os::stat(path, &amp;st) == 0) {
 665         // File or directory found
<span class="line-modified"> 666         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
 667         // If the path specification is valid, enter it into this module&#39;s list
 668         if (new_entry != NULL) {
 669           module_cpl-&gt;add_to_list(new_entry);
 670         }
 671       }
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673       while (class_path[end] == os::path_separator()[0]) {</span>
<span class="line-removed"> 674         end++;</span>
<span class="line-removed"> 675       }</span>
 676     }
 677 
 678     // Record the module into the list of --patch-module entries only if
 679     // valid ClassPathEntrys have been created
 680     if (module_cpl-&gt;module_first_entry() != NULL) {
 681       _patch_mod_entries-&gt;push(module_cpl);
 682     }
 683   }
 684 }
 685 
 686 // Determine whether the module has been patched via the command-line
 687 // option --patch-module
 688 bool ClassLoader::is_in_patch_mod_entries(Symbol* module_name) {
 689   if (_patch_mod_entries != NULL &amp;&amp; _patch_mod_entries-&gt;is_nonempty()) {
 690     int table_len = _patch_mod_entries-&gt;length();
 691     for (int i = 0; i &lt; table_len; i++) {
 692       ModuleClassPathList* patch_mod = _patch_mod_entries-&gt;at(i);
 693       if (module_name-&gt;fast_compare(patch_mod-&gt;module_name()) == 0) {
 694         return true;
 695       }
 696     }
 697   }
 698   return false;
 699 }
 700 
 701 // Set up the _jrt_entry if present and boot append path
 702 void ClassLoader::setup_boot_search_path(const char *class_path) {
<span class="line-modified"> 703   int len = (int)strlen(class_path);</span>
<span class="line-modified"> 704   int end = 0;</span>

 705   bool set_base_piece = true;
 706 
 707 #if INCLUDE_CDS
<span class="line-modified"> 708   if (DumpSharedSpaces) {</span>
 709     if (!Arguments::has_jimage()) {
 710       vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
 711     }
 712   }
 713 #endif
 714 
<span class="line-modified"> 715   // Iterate over class path entries</span>
<span class="line-modified"> 716   for (int start = 0; start &lt; len; start = end) {</span>
<span class="line-removed"> 717     while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="line-removed"> 718       end++;</span>
<span class="line-removed"> 719     }</span>
<span class="line-removed"> 720     EXCEPTION_MARK;</span>
<span class="line-removed"> 721     ResourceMark rm(THREAD);</span>
<span class="line-removed"> 722     char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="line-removed"> 723     strncpy(path, &amp;class_path[start], end - start);</span>
<span class="line-removed"> 724     path[end - start] = &#39;\0&#39;;</span>
 725 
 726     if (set_base_piece) {
 727       // The first time through the bootstrap_search setup, it must be determined
 728       // what the base or core piece of the boot loader search is.  Either a java runtime
 729       // image is present or this is an exploded module build situation.
 730       assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
 731              &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
 732       struct stat st;
 733       if (os::stat(path, &amp;st) == 0) {
 734         // Directory found
<span class="line-modified"> 735         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
 736 
 737         // Check for a jimage
 738         if (Arguments::has_jimage()) {
 739           assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);
<span class="line-removed"> 740           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);</span>
 741           _jrt_entry = new_entry;

 742           assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
 743         }
 744       } else {
 745         // If path does not exist, exit
 746         vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
 747       }
 748       set_base_piece = false;
 749     } else {
 750       // Every entry on the system boot class path after the initial base piece,
 751       // which is set by os::set_boot_path(), is considered an appended entry.
<span class="line-modified"> 752       update_class_path_entry_list(path, false, true);</span>
<span class="line-removed"> 753     }</span>
<span class="line-removed"> 754 </span>
<span class="line-removed"> 755     while (class_path[end] == os::path_separator()[0]) {</span>
<span class="line-removed"> 756       end++;</span>
 757     }
 758   }
 759 }
 760 
 761 // During an exploded modules build, each module defined to the boot loader
 762 // will be added to the ClassLoader::_exploded_entries array.
 763 void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {
 764   assert(!ClassLoader::has_jrt_entry(), &quot;Exploded build not applicable&quot;);
 765   assert(_exploded_entries != NULL, &quot;_exploded_entries was not initialized&quot;);
 766 
 767   // Find the module&#39;s symbol
 768   ResourceMark rm(THREAD);
 769   const char *module_name = module_sym-&gt;as_C_string();
 770   const char *home = Arguments::get_java_home();
 771   const char file_sep = os::file_separator()[0];
 772   // 10 represents the length of &quot;modules&quot; + 2 file separators + \0
 773   size_t len = strlen(home) + strlen(module_name) + 10;
 774   char *path = NEW_RESOURCE_ARRAY(char, len);
 775   jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
 776 
 777   struct stat st;
 778   if (os::stat(path, &amp;st) == 0) {
 779     // Directory found
<span class="line-modified"> 780     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
 781 
 782     // If the path specification is valid, enter it into this module&#39;s list.
 783     // There is no need to check for duplicate modules in the exploded entry list,
 784     // since no two modules with the same name can be defined to the boot loader.
 785     // This is checked at module definition time in Modules::define_module.
 786     if (new_entry != NULL) {
 787       ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 788       module_cpl-&gt;add_to_list(new_entry);
 789       {
<span class="line-modified"> 790         MutexLocker ml(Module_lock, THREAD);</span>
 791         _exploded_entries-&gt;push(module_cpl);
 792       }
 793       log_info(class, load)(&quot;path: %s&quot;, path);
 794     }
 795   }
 796 }
 797 
 798 ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
 799                                                      bool throw_exception,
<span class="line-modified"> 800                                                      bool is_boot_append, TRAPS) {</span>


 801   JavaThread* thread = JavaThread::current();
 802   ClassPathEntry* new_entry = NULL;
 803   if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
 804     ResourceMark rm(thread);
 805     // Regular file, should be a zip or jimage file
 806     // Canonicalized filename
 807     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 808     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 809       // This matches the classic VM
 810       if (throw_exception) {
 811         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 812       } else {
 813         return NULL;
 814       }
 815     }
 816     jint error;
 817     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 818     if (jimage != NULL) {
 819       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 820     } else {
 821       char* error_msg = NULL;
 822       jzfile* zip;
 823       {
 824         // enable call to C land
 825         ThreadToNativeFromVM ttn(thread);
 826         HandleMark hm(thread);
 827         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 828       }
 829       if (zip != NULL &amp;&amp; error_msg == NULL) {
<span class="line-modified"> 830         new_entry = new ClassPathZipEntry(zip, path, is_boot_append);</span>
 831       } else {
 832         char *msg;
 833         if (error_msg == NULL) {
 834           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 835           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 836         } else {
 837           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 838           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 839           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 840         }
 841         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 842         if (throw_exception &amp;&amp; is_init_completed()) {
 843           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 844         } else {
 845           return NULL;
 846         }
 847       }
 848     }
 849     log_info(class, path)(&quot;opened: %s&quot;, path);
 850     log_info(class, load)(&quot;opened: %s&quot;, path);
</pre>
<hr />
<pre>
 860 // Create a class path zip entry for a given path (return NULL if not found
 861 // or zip/JAR file cannot be opened)
 862 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 863   // check for a regular file
 864   struct stat st;
 865   if (os::stat(path, &amp;st) == 0) {
 866     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 867       char canonical_path[JVM_MAXPATHLEN];
 868       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 869         char* error_msg = NULL;
 870         jzfile* zip;
 871         {
 872           // enable call to C land
 873           JavaThread* thread = JavaThread::current();
 874           ThreadToNativeFromVM ttn(thread);
 875           HandleMark hm(thread);
 876           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 877         }
 878         if (zip != NULL &amp;&amp; error_msg == NULL) {
 879           // create using canonical path
<span class="line-modified"> 880           return new ClassPathZipEntry(zip, canonical_path, is_boot_append);</span>
 881         }
 882       }
 883     }
 884   }
 885   return NULL;
 886 }
 887 
 888 // returns true if entry already on class path
 889 bool ClassLoader::contains_append_entry(const char* name) {
 890   ClassPathEntry* e = _first_append_entry;
 891   while (e != NULL) {
 892     // assume zip entries have been canonicalized
 893     if (strcmp(name, e-&gt;name()) == 0) {
 894       return true;
 895     }
 896     e = e-&gt;next();
 897   }
 898   return false;
 899 }
 900 
</pre>
<hr />
<pre>
 934 
 935   // The entry does not exist, add to the list
 936   if (_app_classpath_entries == NULL) {
 937     assert(_last_app_classpath_entry == NULL, &quot;Sanity&quot;);
 938     _app_classpath_entries = _last_app_classpath_entry = entry;
 939   } else {
 940     _last_app_classpath_entry-&gt;set_next(entry);
 941     _last_app_classpath_entry = entry;
 942   }
 943 
 944   if (entry-&gt;is_jar_file()) {
 945     ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates);
 946   }
 947 #endif
 948 }
 949 
 950 // Returns true IFF the file/dir exists and the entry was successfully created.
 951 bool ClassLoader::update_class_path_entry_list(const char *path,
 952                                                bool check_for_duplicates,
 953                                                bool is_boot_append,

 954                                                bool throw_exception) {
 955   struct stat st;
 956   if (os::stat(path, &amp;st) == 0) {
 957     // File or directory found
 958     ClassPathEntry* new_entry = NULL;
 959     Thread* THREAD = Thread::current();
<span class="line-modified"> 960     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, CHECK_(false));</span>
 961     if (new_entry == NULL) {
 962       return false;
 963     }
 964 
 965     // Do not reorder the bootclasspath which would break get_system_package().
 966     // Add new entry to linked list
 967     if (is_boot_append) {
 968       add_to_boot_append_entries(new_entry);
 969     } else {
 970       add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
 971     }
 972     return true;
 973   } else {
<span class="line-removed"> 974 #if INCLUDE_CDS</span>
<span class="line-removed"> 975     if (DumpSharedSpaces) {</span>
<span class="line-removed"> 976       _shared_paths_misc_info-&gt;add_nonexist_path(path);</span>
<span class="line-removed"> 977     }</span>
<span class="line-removed"> 978 #endif</span>
 979     return false;
 980   }
 981 }
 982 
 983 static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
 984   ResourceMark rm;
 985   int num_of_entries = module_list-&gt;length();
 986   for (int i = 0; i &lt; num_of_entries; i++) {
 987     ClassPathEntry* e;
 988     ModuleClassPathList* mpl = module_list-&gt;at(i);
 989     tty-&gt;print(&quot;%s=&quot;, mpl-&gt;module_name()-&gt;as_C_string());
 990     e = mpl-&gt;module_first_entry();
 991     while (e != NULL) {
 992       tty-&gt;print(&quot;%s&quot;, e-&gt;name());
 993       e = e-&gt;next();
 994       if (e != NULL) {
 995         tty-&gt;print(&quot;%s&quot;, os::path_separator());
 996       }
 997     }
 998     tty-&gt;print(&quot; ;&quot;);
</pre>
<hr />
<pre>
1011   // [jimage | exploded modules build]
1012   if (has_jrt_entry()) {
1013     // Print the location of the java runtime image
1014     tty-&gt;print(&quot;%s ;&quot;, _jrt_entry-&gt;name());
1015   } else {
1016     // Print exploded module build path specifications
1017     if (_exploded_entries != NULL) {
1018       print_module_entry_table(_exploded_entries);
1019     }
1020   }
1021 
1022   // appended entries
1023   e = _first_append_entry;
1024   while (e != NULL) {
1025     tty-&gt;print(&quot;%s ;&quot;, e-&gt;name());
1026     e = e-&gt;next();
1027   }
1028   tty-&gt;print_cr(&quot;]&quot;);
1029 }
1030 




















1031 void ClassLoader::load_zip_library() {
1032   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
<span class="line-removed">1033   // First make sure native library is loaded</span>
<span class="line-removed">1034   os::native_java_library();</span>
<span class="line-removed">1035   // Load zip library</span>
1036   char path[JVM_MAXPATHLEN];
1037   char ebuf[1024];
1038   void* handle = NULL;
1039   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
1040     handle = os::dll_load(path, ebuf, sizeof ebuf);
1041   }
1042   if (handle == NULL) {
<span class="line-modified">1043     vm_exit_during_initialization(&quot;Unable to load ZIP library&quot;, path);</span>
<span class="line-removed">1044   }</span>
<span class="line-removed">1045   // Lookup zip entry points</span>
<span class="line-removed">1046   ZipOpen      = CAST_TO_FN_PTR(ZipOpen_t, os::dll_lookup(handle, &quot;ZIP_Open&quot;));</span>
<span class="line-removed">1047   ZipClose     = CAST_TO_FN_PTR(ZipClose_t, os::dll_lookup(handle, &quot;ZIP_Close&quot;));</span>
<span class="line-removed">1048   FindEntry    = CAST_TO_FN_PTR(FindEntry_t, os::dll_lookup(handle, &quot;ZIP_FindEntry&quot;));</span>
<span class="line-removed">1049   ReadEntry    = CAST_TO_FN_PTR(ReadEntry_t, os::dll_lookup(handle, &quot;ZIP_ReadEntry&quot;));</span>
<span class="line-removed">1050   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, os::dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;));</span>
<span class="line-removed">1051   ZipInflateFully = CAST_TO_FN_PTR(ZipInflateFully_t, os::dll_lookup(handle, &quot;ZIP_InflateFully&quot;));</span>
<span class="line-removed">1052   Crc32        = CAST_TO_FN_PTR(Crc32_t, os::dll_lookup(handle, &quot;ZIP_CRC32&quot;));</span>
<span class="line-removed">1053 </span>
<span class="line-removed">1054   // ZIP_Close is not exported on Windows in JDK5.0 so don&#39;t abort if ZIP_Close is NULL</span>
<span class="line-removed">1055   if (ZipOpen == NULL || FindEntry == NULL || ReadEntry == NULL ||</span>
<span class="line-removed">1056       GetNextEntry == NULL || Crc32 == NULL) {</span>
<span class="line-removed">1057     vm_exit_during_initialization(&quot;Corrupted ZIP library&quot;, path);</span>
<span class="line-removed">1058   }</span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060   if (ZipInflateFully == NULL) {</span>
<span class="line-removed">1061     vm_exit_during_initialization(&quot;Corrupted ZIP library ZIP_InflateFully missing&quot;, path);</span>
1062   }
1063 
<span class="line-modified">1064   // Lookup canonicalize entry in libjava.dll</span>
<span class="line-modified">1065   void *javalib_handle = os::native_java_library();</span>
<span class="line-modified">1066   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, os::dll_lookup(javalib_handle, &quot;Canonicalize&quot;));</span>
<span class="line-modified">1067   // This lookup only works on 1.3. Do not check for non-null here</span>


1068 }
1069 
1070 void ClassLoader::load_jimage_library() {
<span class="line-modified">1071   // First make sure native library is loaded</span>
<span class="line-removed">1072   os::native_java_library();</span>
<span class="line-removed">1073   // Load jimage library</span>
1074   char path[JVM_MAXPATHLEN];
1075   char ebuf[1024];
1076   void* handle = NULL;
1077   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1078     handle = os::dll_load(path, ebuf, sizeof ebuf);
1079   }
1080   if (handle == NULL) {
1081     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1082   }
1083 
<span class="line-modified">1084   // Lookup jimage entry points</span>
<span class="line-modified">1085   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, os::dll_lookup(handle, &quot;JIMAGE_Open&quot;));</span>
<span class="line-modified">1086   guarantee(JImageOpen != NULL, &quot;function JIMAGE_Open not found&quot;);</span>
<span class="line-modified">1087   JImageClose = CAST_TO_FN_PTR(JImageClose_t, os::dll_lookup(handle, &quot;JIMAGE_Close&quot;));</span>
<span class="line-modified">1088   guarantee(JImageClose != NULL, &quot;function JIMAGE_Close not found&quot;);</span>
<span class="line-modified">1089   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, os::dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;));</span>
<span class="line-removed">1090   guarantee(JImagePackageToModule != NULL, &quot;function JIMAGE_PackageToModule not found&quot;);</span>
<span class="line-removed">1091   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, os::dll_lookup(handle, &quot;JIMAGE_FindResource&quot;));</span>
<span class="line-removed">1092   guarantee(JImageFindResource != NULL, &quot;function JIMAGE_FindResource not found&quot;);</span>
<span class="line-removed">1093   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, os::dll_lookup(handle, &quot;JIMAGE_GetResource&quot;));</span>
<span class="line-removed">1094   guarantee(JImageGetResource != NULL, &quot;function JIMAGE_GetResource not found&quot;);</span>
<span class="line-removed">1095   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, os::dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;));</span>
<span class="line-removed">1096   guarantee(JImageResourceIterator != NULL, &quot;function JIMAGE_ResourceIterator not found&quot;);</span>
<span class="line-removed">1097 }</span>
<span class="line-removed">1098 </span>
<span class="line-removed">1099 jboolean ClassLoader::decompress(void *in, u8 inSize, void *out, u8 outSize, char **pmsg) {</span>
<span class="line-removed">1100   return (*ZipInflateFully)(in, inSize, out, outSize, pmsg);</span>
1101 }
1102 
1103 int ClassLoader::crc32(int crc, const char* buf, int len) {
<span class="line-removed">1104   assert(Crc32 != NULL, &quot;ZIP_CRC32 is not found&quot;);</span>
1105   return (*Crc32)(crc, (const jbyte*)buf, len);
1106 }
1107 
1108 // Function add_package extracts the package from the fully qualified class name
1109 // and checks if the package is in the boot loader&#39;s package entry table.  If so,
1110 // then it sets the classpath_index in the package entry record.
1111 //
1112 // The classpath_index field is used to find the entry on the boot loader class
1113 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1114 // in an unnamed module.  It is also used to indicate (for all packages whose
1115 // classes are loaded by the boot loader) that at least one of the package&#39;s
1116 // classes has been loaded.
1117 bool ClassLoader::add_package(const char *fullq_class_name, s2 classpath_index, TRAPS) {
1118   assert(fullq_class_name != NULL, &quot;just checking&quot;);
1119 
1120   // Get package name from fully qualified class name.
<span class="line-modified">1121   ResourceMark rm;</span>
1122   const char *cp = package_from_name(fullq_class_name);
1123   if (cp != NULL) {
1124     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<span class="line-modified">1125     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp, CHECK_false);</span>
1126     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(pkg_symbol);
1127     if (pkg_entry != NULL) {
1128       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1129       pkg_entry-&gt;set_classpath_index(classpath_index);
1130     } else {
1131       return false;
1132     }
1133   }
1134   return true;
1135 }
1136 
1137 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1138   // Look up the name in the boot loader&#39;s package entry table.
1139   if (name != NULL) {
<span class="line-modified">1140     TempNewSymbol package_sym = SymbolTable::new_symbol(name, (int)strlen(name), CHECK_NULL);</span>
1141     // Look for the package entry in the boot loader&#39;s package entry table.
1142     PackageEntry* package =
1143       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1144 
1145     // Return NULL if package does not exist or if no classes in that package
1146     // have been loaded.
1147     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1148       ModuleEntry* module = package-&gt;module();
1149       if (module-&gt;location() != NULL) {
1150         ResourceMark rm(THREAD);
1151         Handle ml = java_lang_String::create_from_str(
1152           module-&gt;location()-&gt;as_C_string(), THREAD);
1153         return ml();
1154       }
1155       // Return entry on boot loader class path.
1156       Handle cph = java_lang_String::create_from_str(
1157         ClassLoader::classpath_entry(package-&gt;classpath_index())-&gt;name(), THREAD);
1158       return cph();
1159     }
1160   }
1161   return NULL;
1162 }
1163 
1164 objArrayOop ClassLoader::get_system_packages(TRAPS) {
1165   ResourceMark rm(THREAD);
1166   // List of pointers to PackageEntrys that have loaded classes.
1167   GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
1168   {
<span class="line-modified">1169     MutexLocker ml(Module_lock, THREAD);</span>
1170 
1171     PackageEntryTable* pe_table =
1172       ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1173 
1174     // Collect the packages that have at least one loaded class.
1175     for (int x = 0; x &lt; pe_table-&gt;table_size(); x++) {
1176       for (PackageEntry* package_entry = pe_table-&gt;bucket(x);
1177            package_entry != NULL;
1178            package_entry = package_entry-&gt;next()) {
1179         if (package_entry-&gt;has_loaded_class()) {
1180           loaded_class_pkgs-&gt;append(package_entry);
1181         }
1182       }
1183     }
1184   }
1185 
1186 
1187   // Allocate objArray and fill with java.lang.String
1188   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1189                                            loaded_class_pkgs-&gt;length(), CHECK_NULL);
</pre>
<hr />
<pre>
1246   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1247 
1248   // If the module system has not defined java.base yet, then
1249   // classes loaded are assumed to be defined to java.base.
1250   // When java.base is eventually defined by the module system,
1251   // all packages of classes that have been previously loaded
1252   // are verified in ModuleEntryTable::verify_javabase_packages().
1253   if (!Universe::is_module_initialized() &amp;&amp;
1254       !ModuleEntryTable::javabase_defined() &amp;&amp;
1255       mod_entry == NULL) {
1256     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1257   }
1258 
1259   // The module must be a named module
1260   ClassPathEntry* e = NULL;
1261   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1262     if (module_list == _exploded_entries) {
1263       // The exploded build entries can be added to at any time so a lock is
1264       // needed when searching them.
1265       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
<span class="line-modified">1266       MutexLocker ml(Module_lock, THREAD);</span>
1267       e = find_first_module_cpe(mod_entry, module_list);
1268     } else {
1269       e = find_first_module_cpe(mod_entry, module_list);
1270     }
1271   }
1272 
1273   // Try to load the class from the module&#39;s ClassPathEntry list.
1274   while (e != NULL) {
1275     stream = e-&gt;open_stream(file_name, CHECK_NULL);
1276     // No context.check is required since CDS is not supported
1277     // for an exploded modules build or if --patch-module is specified.
1278     if (NULL != stream) {
1279       return stream;
1280     }
1281     e = e-&gt;next();
1282   }
1283   // If the module was located, break out even if the class was not
1284   // located successfully from that module&#39;s ClassPathEntry list.
1285   // There will not be another valid entry for that module.
1286   return NULL;
</pre>
<hr />
<pre>
1313   //
1314   // If search_append_only is false, boot loader visibility boundaries are
1315   // set to be the --patch-module entries plus the base piece. This includes:
1316   //   [--patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*]; [jimage | exploded module build]
1317   //
1318 
1319   // Load Attempt #1: --patch-module
1320   // Determine the class&#39; defining module.  If it appears in the _patch_mod_entries,
1321   // attempt to load the class from those locations specific to the module.
1322   // Specifications to --patch-module can contain a partial number of classes
1323   // that are part of the overall module definition.  So if a particular class is not
1324   // found within its module specification, the search should continue to Load Attempt #2.
1325   // Note: The --patch-module entries are never searched if the boot loader&#39;s
1326   //       visibility boundary is limited to only searching the append entries.
1327   if (_patch_mod_entries != NULL &amp;&amp; !search_append_only) {
1328     // At CDS dump time, the --patch-module entries are ignored. That means a
1329     // class is still loaded from the runtime image even if it might
1330     // appear in the _patch_mod_entries. The runtime shared class visibility
1331     // check will determine if a shared class is visible based on the runtime
1332     // environemnt, including the runtime --patch-module setting.




1333     if (!DumpSharedSpaces) {
1334       stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
1335     }
1336   }
1337 
1338   // Load Attempt #2: [jimage | exploded build]
1339   if (!search_append_only &amp;&amp; (NULL == stream)) {
1340     if (has_jrt_entry()) {
1341       e = _jrt_entry;
1342       stream = _jrt_entry-&gt;open_stream(file_name, CHECK_NULL);
1343     } else {
1344       // Exploded build - attempt to locate class in its defining module&#39;s location.
1345       assert(_exploded_entries != NULL, &quot;No exploded build entries present&quot;);
1346       stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);
1347     }
1348   }
1349 
1350   // Load Attempt #3: [-Xbootclasspath/a]; [jvmti appended entries]
1351   if (search_append_only &amp;&amp; (NULL == stream)) {
1352     // For the boot loader append path search, the starting classpath_index
</pre>
<hr />
<pre>
1367   }
1368 
1369   if (NULL == stream) {
1370     return NULL;
1371   }
1372 
1373   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1374 
1375   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1376   Handle protection_domain;
1377 
1378   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1379                                                            name,
1380                                                            loader_data,
1381                                                            protection_domain,
1382                                                            NULL, // unsafe_anonymous_host
1383                                                            NULL, // cp_patches
1384                                                            THREAD);
1385   if (HAS_PENDING_EXCEPTION) {
1386     if (DumpSharedSpaces) {
<span class="line-modified">1387       tty-&gt;print_cr(&quot;Preload Error: Failed to load %s&quot;, class_name);</span>
1388     }
1389     return NULL;
1390   }
1391 
1392   if (!add_package(file_name, classpath_index, THREAD)) {
1393     return NULL;
1394   }
1395 
1396   return result;
1397 }
1398 
1399 #if INCLUDE_CDS
1400 char* ClassLoader::skip_uri_protocol(char* source) {
1401   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1402     // file: protocol path could start with file:/ or file:///
1403     // locate the char after all the forward slashes
1404     int offset = 5;
1405     while (*(source + offset) == &#39;/&#39;) {
1406         offset++;
1407     }
1408     source += offset;
1409   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1410 #ifndef _WINDOWS
1411     source -= 1;
1412 #endif
1413   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1414     source += 5;
1415   }
1416   return source;
1417 }
1418 
1419 // Record the shared classpath index and loader type for classes loaded
1420 // by the builtin loaders at dump time.
1421 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
<span class="line-modified">1422   assert(DumpSharedSpaces, &quot;sanity&quot;);</span>
1423   assert(stream != NULL, &quot;sanity&quot;);
1424 
1425   if (ik-&gt;is_unsafe_anonymous()) {
1426     // We do not archive unsafe anonymous classes.
1427     return;
1428   }
1429 
1430   oop loader = ik-&gt;class_loader();
1431   char* src = (char*)stream-&gt;source();
1432   if (src == NULL) {
1433     if (loader == NULL) {
1434       // JFR classes
1435       ik-&gt;set_shared_classpath_index(0);
1436       ik-&gt;set_class_loader_type(ClassLoader::BOOT_LOADER);
1437     }
1438     return;
1439   }
1440 
1441   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1442 
</pre>
<hr />
<pre>
1482               // -Xbootclasspath/a and jvmti appended entries.
1483               assert(loader == NULL, &quot;sanity&quot;);
1484               classpath_index = i;
1485               break;
1486             }
1487           }
1488         } else {
1489           // A class from a named module from the --module-path. Ensure the index is
1490           // within the --module-path range before assigning to the classpath_index.
1491           if ((pkg_entry != NULL) &amp;&amp; !(pkg_entry-&gt;in_unnamed_module()) &amp;&amp; (i &gt; 0)) {
1492             if (i &gt;= ClassLoaderExt::app_module_paths_start_index() &amp;&amp;
1493                 i &lt; FileMapInfo::get_number_of_shared_paths()) {
1494               classpath_index = i;
1495               break;
1496             }
1497           }
1498         }
1499       }
1500       // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
1501       // The class must be from the runtime modules image.
<span class="line-modified">1502       if (i == 0 &amp;&amp; (is_modules_image(src) || string_starts_with(src, &quot;jrt:&quot;))) {</span>
1503         classpath_index = i;
1504         break;
1505       }
1506     }
1507 
1508     // No path entry found for this class. Must be a shared class loaded by the
1509     // user defined classloader.
1510     if (classpath_index &lt; 0) {
1511       assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);


1512       return;
1513     }
1514   } else {
1515     // The shared path table is set up after module system initialization.
1516     // The path table contains no entry before that. Any classes loaded prior
1517     // to the setup of the shared path table must be from the modules image.
<span class="line-modified">1518     assert(is_modules_image(src), &quot;stream must be from modules image&quot;);</span>
1519     assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
1520     classpath_index = 0;
1521   }
1522 
1523   const char* const class_name = ik-&gt;name()-&gt;as_C_string();
1524   const char* const file_name = file_name_for_class_name(class_name,
1525                                                          ik-&gt;name()-&gt;utf8_length());
1526   assert(file_name != NULL, &quot;invariant&quot;);
1527 
1528   ClassLoaderExt::record_result(classpath_index, ik, THREAD);
1529 }
1530 #endif // INCLUDE_CDS
1531 
1532 // Initialize the class loader&#39;s access to methods in libzip.  Parse and
1533 // process the boot classpath into a list ClassPathEntry objects.  Once
1534 // this list has been created, it must not change order (see class PackageInfo)
1535 // it can be appended to and is by jvmti and the kernel vm.
1536 
1537 void ClassLoader::initialize() {
1538   EXCEPTION_MARK;
</pre>
<hr />
<pre>
1568     // The following performance counters are added for measuring the impact
1569     // of the bug fix of 6365597. They are mainly focused on finding out
1570     // the behavior of system &amp; user-defined classloader lock, whether
1571     // ClassLoader.loadClass/findClass is being called synchronized or not.
1572     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1573                         &quot;systemLoaderLockContentionRate&quot;);
1574     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1575                         &quot;nonSystemLoaderLockContentionRate&quot;);
1576     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1577                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1578     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1579                         &quot;jvmDefineClassNoLockCalls&quot;);
1580 
1581     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1582                         &quot;jniDefineClassNoLockCalls&quot;);
1583 
1584     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1585                         &quot;unsafeDefineClassCalls&quot;);
1586   }
1587 


1588   // lookup zip library entry points
1589   load_zip_library();
<span class="line-modified">1590   // lookup jimage library entry points</span>





















1591   load_jimage_library();
<span class="line-modified">1592 #if INCLUDE_CDS</span>
<span class="line-modified">1593   // initialize search path</span>
<span class="line-modified">1594   if (DumpSharedSpaces) {</span>
<span class="line-modified">1595     _shared_paths_misc_info = new SharedPathsMiscInfo();</span>

1596   }
<span class="line-modified">1597 #endif</span>
<span class="line-modified">1598   setup_bootstrap_search_path();</span>




1599 }
1600 
1601 #if INCLUDE_CDS
1602 void ClassLoader::initialize_shared_path() {
<span class="line-modified">1603   if (DumpSharedSpaces) {</span>
1604     ClassLoaderExt::setup_search_paths();
<span class="line-removed">1605     _shared_paths_misc_info-&gt;write_jint(0); // see comments in SharedPathsMiscInfo::check()</span>
1606   }
1607 }
1608 
1609 void ClassLoader::initialize_module_path(TRAPS) {
<span class="line-modified">1610   if (DumpSharedSpaces) {</span>
1611     ClassLoaderExt::setup_module_paths(THREAD);
1612     FileMapInfo::allocate_shared_path_table();
1613   }
1614 }
1615 #endif
1616 
1617 jlong ClassLoader::classloader_time_ms() {
1618   return UsePerfData ?
1619     Management::ticks_to_ms(_perf_accumulated_time-&gt;get_value()) : -1;
1620 }
1621 
1622 jlong ClassLoader::class_init_count() {
1623   return UsePerfData ? _perf_classes_inited-&gt;get_value() : -1;
1624 }
1625 
1626 jlong ClassLoader::class_init_time_ms() {
1627   return UsePerfData ?
1628     Management::ticks_to_ms(_perf_class_init_time-&gt;get_value()) : -1;
1629 }
1630 
</pre>
<hr />
<pre>
1656 }
1657 
1658 // Complete the ClassPathEntry setup for the boot loader
1659 void ClassLoader::classLoader_init2(TRAPS) {
1660   // Setup the list of module/path pairs for --patch-module processing
1661   // This must be done after the SymbolTable is created in order
1662   // to use fast_compare on module names instead of a string compare.
1663   if (Arguments::get_patch_mod_prefix() != NULL) {
1664     setup_patch_mod_entries();
1665   }
1666 
1667   // Create the ModuleEntry for java.base (must occur after setup_patch_mod_entries
1668   // to successfully determine if java.base has been patched)
1669   create_javabase();
1670 
1671   // Setup the initial java.base/path pair for the exploded build entries.
1672   // As more modules are defined during module system initialization, more
1673   // entries will be added to the exploded build array.
1674   if (!has_jrt_entry()) {
1675     assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);

1676     assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
1677     // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
1678     // done before loading any classes, by the same thread that will
1679     // subsequently do the first class load. So, no lock is needed for this.
1680     assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
1681     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
1682       GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
1683     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
1684   }
1685 }
1686 
<span class="line-removed">1687 </span>
1688 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
1689   assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
<span class="line-modified">1690   if (CanonicalizeEntry != NULL) {</span>
<span class="line-modified">1691     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-removed">1692     JNIEnv* env = THREAD-&gt;jni_environment();</span>
<span class="line-removed">1693     ResourceMark rm(THREAD);</span>
1694 
<span class="line-modified">1695     // os::native_path writes into orig_copy</span>
<span class="line-modified">1696     char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);</span>
<span class="line-modified">1697     strcpy(orig_copy, orig);</span>
<span class="line-modified">1698     if ((CanonicalizeEntry)(env, os::native_path(orig_copy), out, len) &lt; 0) {</span>
<span class="line-modified">1699       return false;</span>
<span class="line-removed">1700     }</span>
<span class="line-removed">1701   } else {</span>
<span class="line-removed">1702     // On JDK 1.2.2 the Canonicalize does not exist, so just do nothing</span>
<span class="line-removed">1703     strncpy(out, orig, len);</span>
<span class="line-removed">1704     out[len - 1] = &#39;\0&#39;;</span>
1705   }
1706   return true;
1707 }
1708 
1709 void ClassLoader::create_javabase() {
1710   Thread* THREAD = Thread::current();
1711 
1712   // Create java.base&#39;s module entry for the boot
1713   // class loader prior to loading j.l.Ojbect.
1714   ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
1715 
1716   // Get module entry table
1717   ModuleEntryTable* null_cld_modules = null_cld-&gt;modules();
1718   if (null_cld_modules == NULL) {
1719     vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
1720   }
1721 
1722   {
<span class="line-modified">1723     MutexLocker ml(Module_lock, THREAD);</span>
1724     ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
1725                                false, vmSymbols::java_base(), NULL, NULL, null_cld);
1726     if (jb_module == NULL) {
1727       vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
1728     }
1729     ModuleEntryTable::set_javabase_moduleEntry(jb_module);
1730   }
1731 }
1732 
1733 // Please keep following two functions at end of this file. With them placed at top or in middle of the file,
1734 // they could get inlined by agressive compiler, an unknown trick, see bug 6966589.
1735 void PerfClassTraceTime::initialize() {
1736   if (!UsePerfData) return;
1737 
1738   if (_eventp != NULL) {
1739     // increment the event counter
1740     _eventp-&gt;inc();
1741   }
1742 
1743   // stop the current active thread-local timer to measure inclusive time
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;jimage.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
<span class="line-added">  37 #include &quot;classfile/symbolTable.hpp&quot;</span>
  38 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">  39 #include &quot;classfile/systemDictionaryShared.hpp&quot;</span>
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;interpreter/bytecodeStream.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;logging/logTag.hpp&quot;
  47 #include &quot;memory/allocation.inline.hpp&quot;
  48 #include &quot;memory/filemap.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceRefKlass.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;

  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
<span class="line-added">  71 #include &quot;utilities/classpathStream.hpp&quot;</span>
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  75 </span>
<span class="line-modified">  76 // Entry point in java.dll for path canonicalization</span>
<span class="line-modified">  77 </span>
<span class="line-added">  78 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);</span>
<span class="line-added">  79 </span>
<span class="line-added">  80 static canonicalize_fn_t CanonicalizeEntry  = NULL;</span>
  81 
  82 // Entry points in zip.dll for loading zip/jar file entries
  83 
  84 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
<span class="line-modified">  85 typedef void     (*ZipClose_t)(jzfile *zip);</span>
  86 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  87 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  88 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);

  89 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  90 
  91 static ZipOpen_t         ZipOpen            = NULL;
  92 static ZipClose_t        ZipClose           = NULL;
  93 static FindEntry_t       FindEntry          = NULL;
  94 static ReadEntry_t       ReadEntry          = NULL;
  95 static GetNextEntry_t    GetNextEntry       = NULL;


  96 static Crc32_t           Crc32              = NULL;
  97 
  98 // Entry points for jimage.dll for loading jimage file entries
  99 
 100 static JImageOpen_t                    JImageOpen             = NULL;
 101 static JImageClose_t                   JImageClose            = NULL;
 102 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 103 static JImageFindResource_t            JImageFindResource     = NULL;
 104 static JImageGetResource_t             JImageGetResource      = NULL;
 105 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 106 
 107 // Globals
 108 
 109 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 110 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 111 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 113 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 114 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
</pre>
<hr />
<pre>
 129 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 130 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 132 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 137 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 138 
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 140 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
 141 ClassPathEntry* ClassLoader::_jrt_entry = NULL;
 142 ClassPathEntry* ClassLoader::_first_append_entry = NULL;
 143 ClassPathEntry* ClassLoader::_last_append_entry  = NULL;
 144 #if INCLUDE_CDS
 145 ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
 146 ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
 147 ClassPathEntry* ClassLoader::_module_path_entries = NULL;
 148 ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;

 149 #endif
 150 
 151 // helper routines
 152 bool string_starts_with(const char* str, const char* str_to_find) {
 153   size_t str_len = strlen(str);
 154   size_t str_to_find_len = strlen(str_to_find);
 155   if (str_to_find_len &gt; str_len) {
 156     return false;
 157   }
 158   return (strncmp(str, str_to_find, str_to_find_len) == 0);
 159 }
 160 
 161 static const char* get_jimage_version_string() {
 162   static char version_string[10] = &quot;&quot;;
 163   if (version_string[0] == &#39;\0&#39;) {
 164     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 165                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 166   }
 167   return (const char*)version_string;
 168 }
</pre>
<hr />
<pre>
 173   if (str_to_find_len &gt; str_len) {
 174     return false;
 175   }
 176   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 177 }
 178 
 179 // Used to obtain the package name from a fully qualified class name.
 180 // It is the responsibility of the caller to establish a ResourceMark.
 181 const char* ClassLoader::package_from_name(const char* const class_name, bool* bad_class_name) {
 182   if (class_name == NULL) {
 183     if (bad_class_name != NULL) {
 184       *bad_class_name = true;
 185     }
 186     return NULL;
 187   }
 188 
 189   if (bad_class_name != NULL) {
 190     *bad_class_name = false;
 191   }
 192 
<span class="line-modified"> 193   const char* const last_slash = strrchr(class_name, JVM_SIGNATURE_SLASH);</span>
 194   if (last_slash == NULL) {
 195     // No package name
 196     return NULL;
 197   }
 198 
 199   char* class_name_ptr = (char*) class_name;
 200   // Skip over &#39;[&#39;s
<span class="line-modified"> 201   if (*class_name_ptr == JVM_SIGNATURE_ARRAY) {</span>
 202     do {
 203       class_name_ptr++;
<span class="line-modified"> 204     } while (*class_name_ptr == JVM_SIGNATURE_ARRAY);</span>
 205 
 206     // Fully qualified class names should not contain a &#39;L&#39;.
 207     // Set bad_class_name to true to indicate that the package name
 208     // could not be obtained due to an error condition.
 209     // In this situation, is_same_class_package returns false.
<span class="line-modified"> 210     if (*class_name_ptr == JVM_SIGNATURE_CLASS) {</span>
 211       if (bad_class_name != NULL) {
 212         *bad_class_name = true;
 213       }
 214       return NULL;
 215     }
 216   }
 217 
 218   int length = last_slash - class_name_ptr;
 219 
 220   // A class name could have just the slash character in the name.
 221   if (length &lt;= 0) {
 222     // No package name
 223     if (bad_class_name != NULL) {
 224       *bad_class_name = true;
 225     }
 226     return NULL;
 227   }
 228 
 229   // drop name after last slash (including slash)
 230   // Ex., &quot;java/lang/String.class&quot; =&gt; &quot;java/lang&quot;
 231   char* pkg_name = NEW_RESOURCE_ARRAY(char, length + 1);
 232   strncpy(pkg_name, class_name_ptr, length);
 233   *(pkg_name+length) = &#39;\0&#39;;
 234 
 235   return (const char *)pkg_name;
 236 }
 237 
 238 // Given a fully qualified class name, find its defining package in the class loader&#39;s
 239 // package entry table.
 240 PackageEntry* ClassLoader::get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS) {
 241   ResourceMark rm(THREAD);
 242   const char *pkg_name = ClassLoader::package_from_name(class_name);
 243   if (pkg_name == NULL) {
 244     return NULL;
 245   }
 246   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 247   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name);</span>
 248   return pkgEntryTable-&gt;lookup_only(pkg_symbol);
 249 }
 250 
<span class="line-modified"> 251 const char* ClassPathEntry::copy_path(const char* path) {</span>
<span class="line-modified"> 252   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);</span>
<span class="line-modified"> 253   strcpy(copy, path);</span>
<span class="line-modified"> 254   return copy;</span>
 255 }
 256 

 257 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 258   // construct full path name
 259   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 260   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 261   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 262   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 263   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 264   // check if file exists
 265   struct stat st;
 266   if (os::stat(path, &amp;st) == 0) {
 267     // found file, open it
 268     int file_handle = os::open(path, 0, 0);
 269     if (file_handle != -1) {
 270       // read contents into resource array
 271       u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);
 272       size_t num_read = os::read(file_handle, (char*) buffer, st.st_size);
 273       // close file
 274       os::close(file_handle);
 275       // construct ClassFileStream
 276       if (num_read == (size_t)st.st_size) {
 277         if (UsePerfData) {
 278           ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(num_read);
 279         }
 280         FREE_RESOURCE_ARRAY(char, path, path_len);
 281         // Resource allocated
 282         return new ClassFileStream(buffer,
 283                                    st.st_size,
 284                                    _dir,
 285                                    ClassFileStream::verify);
 286       }
 287     }
 288   }
 289   FREE_RESOURCE_ARRAY(char, path, path_len);
 290   return NULL;
 291 }
 292 
<span class="line-modified"> 293 ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,</span>
<span class="line-added"> 294                                      bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {</span>
 295   _zip = zip;
<span class="line-modified"> 296   _zip_name = copy_path(zip_name);</span>
<span class="line-modified"> 297   _from_class_path_attr = from_class_path_attr;</span>

 298 }
 299 
 300 ClassPathZipEntry::~ClassPathZipEntry() {
<span class="line-modified"> 301   (*ZipClose)(_zip);</span>


 302   FREE_C_HEAP_ARRAY(char, _zip_name);
 303 }
 304 
 305 u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
 306     // enable call to C land
 307   JavaThread* thread = JavaThread::current();
 308   ThreadToNativeFromVM ttn(thread);
 309   // check whether zip archive contains name
 310   jint name_len;
 311   jzentry* entry = (*FindEntry)(_zip, name, filesize, &amp;name_len);
 312   if (entry == NULL) return NULL;
 313   u1* buffer;
 314   char name_buf[128];
 315   char* filename;
 316   if (name_len &lt; 128) {
 317     filename = name_buf;
 318   } else {
 319     filename = NEW_RESOURCE_ARRAY(char, name_len + 1);
 320   }
 321 
</pre>
<hr />
<pre>
 342   }
 343   // Resource allocated
 344   return new ClassFileStream(buffer,
 345                              filesize,
 346                              _zip_name,
 347                              ClassFileStream::verify);
 348 }
 349 
 350 // invoke function for each entry in the zip file
 351 void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {
 352   JavaThread* thread = JavaThread::current();
 353   HandleMark  handle_mark(thread);
 354   ThreadToNativeFromVM ttn(thread);
 355   for (int n = 0; ; n++) {
 356     jzentry * ze = ((*GetNextEntry)(_zip, n));
 357     if (ze == NULL) break;
 358     (*f)(ze-&gt;name, context);
 359   }
 360 }
 361 
<span class="line-added"> 362 DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)</span>
<span class="line-added"> 363 </span>
 364 void ClassPathImageEntry::close_jimage() {
 365   if (_jimage != NULL) {
 366     (*JImageClose)(_jimage);
 367     _jimage = NULL;
 368   }
 369 }
 370 
 371 ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
 372   ClassPathEntry(),
 373   _jimage(jimage) {
 374   guarantee(jimage != NULL, &quot;jimage file is null&quot;);
 375   guarantee(name != NULL, &quot;jimage file name is null&quot;);
<span class="line-added"> 376   assert(_singleton == NULL, &quot;VM supports only one jimage&quot;);</span>
<span class="line-added"> 377   DEBUG_ONLY(_singleton = this);</span>
 378   size_t len = strlen(name) + 1;
<span class="line-modified"> 379   _name = copy_path(name);</span>

 380 }
 381 
 382 ClassPathImageEntry::~ClassPathImageEntry() {
<span class="line-modified"> 383   assert(_singleton == this, &quot;must be&quot;);</span>
<span class="line-modified"> 384   DEBUG_ONLY(_singleton = NULL);</span>
<span class="line-modified"> 385 </span>
<span class="line-modified"> 386   FREE_C_HEAP_ARRAY(const char, _name);</span>
<span class="line-added"> 387 </span>
 388   if (_jimage != NULL) {
 389     (*JImageClose)(_jimage);
 390     _jimage = NULL;
 391   }
 392 }
 393 
<span class="line-added"> 394 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {</span>
<span class="line-added"> 395   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);</span>
<span class="line-added"> 396 }</span>
<span class="line-added"> 397 </span>
 398 // For a class in a named module, look it up in the jimage file using this syntax:
 399 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 400 //
 401 // Assumptions:
 402 //     1. There are no unnamed modules in the jimage file.
 403 //     2. A package is in at most one module in the jimage file.
 404 //
<span class="line-modified"> 405 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {</span>
 406   jlong size;
 407   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 408 
 409   if (location == 0) {
 410     ResourceMark rm;
 411     const char* pkg_name = ClassLoader::package_from_name(name);
 412 
 413     if (pkg_name != NULL) {
 414       if (!Universe::is_module_initialized()) {
 415         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);












 416       } else {
<span class="line-modified"> 417         PackageEntry* package_entry = ClassLoader::get_package_entry(name, loader_data, CHECK_NULL);</span>
 418         if (package_entry != NULL) {
 419           ResourceMark rm;
 420           // Get the module name
 421           ModuleEntry* module = package_entry-&gt;module();
 422           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 423           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 424           const char* module_name = module-&gt;name()-&gt;as_C_string();
 425           if (module_name != NULL) {
 426             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 427           }
 428         }
 429       }
 430     }
 431   }
 432   if (location != 0) {
 433     if (UsePerfData) {
 434       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 435     }
 436     char* data = NEW_RESOURCE_ARRAY(char, size);
 437     (*JImageGetResource)(_jimage, location, data, size);
 438     // Resource allocated
<span class="line-added"> 439     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);</span>
 440     return new ClassFileStream((u1*)data,
 441                                (int)size,
 442                                _name,
<span class="line-modified"> 443                                ClassFileStream::verify,</span>
<span class="line-added"> 444                                true); // from_boot_loader_modules_image</span>
 445   }
 446 
 447   return NULL;
 448 }
 449 
 450 JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,
 451                                                     const char* module_name,
 452                                                     const char* file_name,
 453                                                     jlong &amp;size) {
 454   return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
 455 }
 456 
 457 bool ClassPathImageEntry::is_modules_image() const {
<span class="line-modified"> 458   assert(this == _singleton, &quot;VM supports a single jimage&quot;);</span>
<span class="line-added"> 459   assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be used for jrt entry&quot;);</span>
<span class="line-added"> 460   return true;</span>
 461 }
 462 
 463 #if INCLUDE_CDS
 464 void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
<span class="line-modified"> 465   Arguments::assert_is_dumping_archive();</span>
 466   tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
 467   vm_exit_during_initialization(error, message);
 468 }
 469 #endif
 470 
 471 ModuleClassPathList::ModuleClassPathList(Symbol* module_name) {
 472   _module_name = module_name;
 473   _module_first_entry = NULL;
 474   _module_last_entry = NULL;
 475 }
 476 
 477 ModuleClassPathList::~ModuleClassPathList() {
 478   // Clean out each ClassPathEntry on list
 479   ClassPathEntry* e = _module_first_entry;
 480   while (e != NULL) {
 481     ClassPathEntry* next_entry = e-&gt;next();
 482     delete e;
 483     e = next_entry;
 484   }
 485 }
</pre>
<hr />
<pre>
 510         // as print_cr() has a length limit
 511         while (name[0] != &#39;\0&#39;) {
 512           ls.print(&quot;%c&quot;, name[0]);
 513           name++;
 514         }
 515       }
 516     }
 517     ls.cr();
 518   }
 519 }
 520 
 521 void ClassLoader::setup_bootstrap_search_path() {
 522   const char* sys_class_path = Arguments::get_sysclasspath();
 523   assert(sys_class_path != NULL, &quot;System boot class path must not be NULL&quot;);
 524   if (PrintSharedArchiveAndExit) {
 525     // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
 526     // the same as the bootcp of the shared archive.
 527   } else {
 528     trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
 529   }





 530   setup_boot_search_path(sys_class_path);
 531 }
 532 
 533 #if INCLUDE_CDS















 534 void ClassLoader::setup_app_search_path(const char *class_path) {
<span class="line-added"> 535   Arguments::assert_is_dumping_archive();</span>
 536 
<span class="line-modified"> 537   ResourceMark rm;</span>
<span class="line-modified"> 538   ClasspathStream cp_stream(class_path);</span>
















 539 
<span class="line-modified"> 540   while (cp_stream.has_next()) {</span>
<span class="line-modified"> 541     const char* path = cp_stream.get_next();</span>
<span class="line-modified"> 542     update_class_path_entry_list(path, false, false, false);</span>
 543   }
 544 }
 545 
 546 void ClassLoader::add_to_module_path_entries(const char* path,
 547                                              ClassPathEntry* entry) {
 548   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
<span class="line-modified"> 549   Arguments::assert_is_dumping_archive();</span>
 550 
 551   // The entry does not exist, add to the list
 552   if (_module_path_entries == NULL) {
 553     assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
 554     _module_path_entries = _last_module_path_entry = entry;
 555   } else {
 556     _last_module_path_entry-&gt;set_next(entry);
 557     _last_module_path_entry = entry;
 558   }
 559 }
 560 
 561 // Add a module path to the _module_path_entries list.
 562 void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
<span class="line-modified"> 563   Arguments::assert_is_dumping_archive();</span>
 564   struct stat st;
 565   if (os::stat(path, &amp;st) != 0) {
 566     tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
 567       errno, os::errno_name(errno), path);
 568     vm_exit_during_initialization();
 569   }
 570   // File or directory found
 571   ClassPathEntry* new_entry = NULL;
 572   new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
<span class="line-modified"> 573                                       false /*is_boot_append */, false /* from_class_path_attr */, CHECK);</span>
 574   if (new_entry == NULL) {
 575     return;
 576   }
 577 
 578   add_to_module_path_entries(path, new_entry);
 579   return;
 580 }
 581 
 582 void ClassLoader::setup_module_search_path(const char* path, TRAPS) {
 583   update_module_path_entry_list(path, THREAD);
 584 }
 585 
 586 #endif // INCLUDE_CDS
 587 
 588 void ClassLoader::close_jrt_image() {
 589   // Not applicable for exploded builds
 590   if (!ClassLoader::has_jrt_entry()) return;
 591   _jrt_entry-&gt;close_jimage();
 592 }
 593 
 594 // Construct the array of module/path pairs as specified to --patch-module
 595 // for the boot loader to search ahead of the jimage, if the class being
 596 // loaded is defined to a module that has been specified to --patch-module.
 597 void ClassLoader::setup_patch_mod_entries() {
 598   Thread* THREAD = Thread::current();
 599   GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
 600   int num_of_entries = patch_mod_args-&gt;length();
 601 

 602   // Set up the boot loader&#39;s _patch_mod_entries list
 603   _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
 604 
 605   for (int i = 0; i &lt; num_of_entries; i++) {
 606     const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
<span class="line-modified"> 607     Symbol* const module_sym = SymbolTable::new_symbol(module_name);</span>
 608     assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
 609     ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 610 
 611     char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
<span class="line-modified"> 612     ResourceMark rm(THREAD);</span>
<span class="line-modified"> 613     ClasspathStream cp_stream(class_path);</span>










 614 
<span class="line-added"> 615     while (cp_stream.has_next()) {</span>
<span class="line-added"> 616       const char* path = cp_stream.get_next();</span>
 617       struct stat st;
 618       if (os::stat(path, &amp;st) == 0) {
 619         // File or directory found
<span class="line-modified"> 620         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
 621         // If the path specification is valid, enter it into this module&#39;s list
 622         if (new_entry != NULL) {
 623           module_cpl-&gt;add_to_list(new_entry);
 624         }
 625       }




 626     }
 627 
 628     // Record the module into the list of --patch-module entries only if
 629     // valid ClassPathEntrys have been created
 630     if (module_cpl-&gt;module_first_entry() != NULL) {
 631       _patch_mod_entries-&gt;push(module_cpl);
 632     }
 633   }
 634 }
 635 
 636 // Determine whether the module has been patched via the command-line
 637 // option --patch-module
 638 bool ClassLoader::is_in_patch_mod_entries(Symbol* module_name) {
 639   if (_patch_mod_entries != NULL &amp;&amp; _patch_mod_entries-&gt;is_nonempty()) {
 640     int table_len = _patch_mod_entries-&gt;length();
 641     for (int i = 0; i &lt; table_len; i++) {
 642       ModuleClassPathList* patch_mod = _patch_mod_entries-&gt;at(i);
 643       if (module_name-&gt;fast_compare(patch_mod-&gt;module_name()) == 0) {
 644         return true;
 645       }
 646     }
 647   }
 648   return false;
 649 }
 650 
 651 // Set up the _jrt_entry if present and boot append path
 652 void ClassLoader::setup_boot_search_path(const char *class_path) {
<span class="line-modified"> 653   EXCEPTION_MARK;</span>
<span class="line-modified"> 654   ResourceMark rm(THREAD);</span>
<span class="line-added"> 655   ClasspathStream cp_stream(class_path);</span>
 656   bool set_base_piece = true;
 657 
 658 #if INCLUDE_CDS
<span class="line-modified"> 659   if (Arguments::is_dumping_archive()) {</span>
 660     if (!Arguments::has_jimage()) {
 661       vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
 662     }
 663   }
 664 #endif
 665 
<span class="line-modified"> 666   while (cp_stream.has_next()) {</span>
<span class="line-modified"> 667     const char* path = cp_stream.get_next();</span>








 668 
 669     if (set_base_piece) {
 670       // The first time through the bootstrap_search setup, it must be determined
 671       // what the base or core piece of the boot loader search is.  Either a java runtime
 672       // image is present or this is an exploded module build situation.
 673       assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
 674              &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
 675       struct stat st;
 676       if (os::stat(path, &amp;st) == 0) {
 677         // Directory found
<span class="line-modified"> 678         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
 679 
 680         // Check for a jimage
 681         if (Arguments::has_jimage()) {
 682           assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);

 683           _jrt_entry = new_entry;
<span class="line-added"> 684           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);</span>
 685           assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
 686         }
 687       } else {
 688         // If path does not exist, exit
 689         vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
 690       }
 691       set_base_piece = false;
 692     } else {
 693       // Every entry on the system boot class path after the initial base piece,
 694       // which is set by os::set_boot_path(), is considered an appended entry.
<span class="line-modified"> 695       update_class_path_entry_list(path, false, true, false);</span>




 696     }
 697   }
 698 }
 699 
 700 // During an exploded modules build, each module defined to the boot loader
 701 // will be added to the ClassLoader::_exploded_entries array.
 702 void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {
 703   assert(!ClassLoader::has_jrt_entry(), &quot;Exploded build not applicable&quot;);
 704   assert(_exploded_entries != NULL, &quot;_exploded_entries was not initialized&quot;);
 705 
 706   // Find the module&#39;s symbol
 707   ResourceMark rm(THREAD);
 708   const char *module_name = module_sym-&gt;as_C_string();
 709   const char *home = Arguments::get_java_home();
 710   const char file_sep = os::file_separator()[0];
 711   // 10 represents the length of &quot;modules&quot; + 2 file separators + \0
 712   size_t len = strlen(home) + strlen(module_name) + 10;
 713   char *path = NEW_RESOURCE_ARRAY(char, len);
 714   jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
 715 
 716   struct stat st;
 717   if (os::stat(path, &amp;st) == 0) {
 718     // Directory found
<span class="line-modified"> 719     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
 720 
 721     // If the path specification is valid, enter it into this module&#39;s list.
 722     // There is no need to check for duplicate modules in the exploded entry list,
 723     // since no two modules with the same name can be defined to the boot loader.
 724     // This is checked at module definition time in Modules::define_module.
 725     if (new_entry != NULL) {
 726       ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 727       module_cpl-&gt;add_to_list(new_entry);
 728       {
<span class="line-modified"> 729         MutexLocker ml(THREAD, Module_lock);</span>
 730         _exploded_entries-&gt;push(module_cpl);
 731       }
 732       log_info(class, load)(&quot;path: %s&quot;, path);
 733     }
 734   }
 735 }
 736 
 737 ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
 738                                                      bool throw_exception,
<span class="line-modified"> 739                                                      bool is_boot_append,</span>
<span class="line-added"> 740                                                      bool from_class_path_attr,</span>
<span class="line-added"> 741                                                      TRAPS) {</span>
 742   JavaThread* thread = JavaThread::current();
 743   ClassPathEntry* new_entry = NULL;
 744   if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
 745     ResourceMark rm(thread);
 746     // Regular file, should be a zip or jimage file
 747     // Canonicalized filename
 748     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 749     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 750       // This matches the classic VM
 751       if (throw_exception) {
 752         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 753       } else {
 754         return NULL;
 755       }
 756     }
 757     jint error;
 758     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 759     if (jimage != NULL) {
 760       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 761     } else {
 762       char* error_msg = NULL;
 763       jzfile* zip;
 764       {
 765         // enable call to C land
 766         ThreadToNativeFromVM ttn(thread);
 767         HandleMark hm(thread);
 768         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 769       }
 770       if (zip != NULL &amp;&amp; error_msg == NULL) {
<span class="line-modified"> 771         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);</span>
 772       } else {
 773         char *msg;
 774         if (error_msg == NULL) {
 775           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 776           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 777         } else {
 778           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 779           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 780           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 781         }
 782         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 783         if (throw_exception &amp;&amp; is_init_completed()) {
 784           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 785         } else {
 786           return NULL;
 787         }
 788       }
 789     }
 790     log_info(class, path)(&quot;opened: %s&quot;, path);
 791     log_info(class, load)(&quot;opened: %s&quot;, path);
</pre>
<hr />
<pre>
 801 // Create a class path zip entry for a given path (return NULL if not found
 802 // or zip/JAR file cannot be opened)
 803 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 804   // check for a regular file
 805   struct stat st;
 806   if (os::stat(path, &amp;st) == 0) {
 807     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 808       char canonical_path[JVM_MAXPATHLEN];
 809       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 810         char* error_msg = NULL;
 811         jzfile* zip;
 812         {
 813           // enable call to C land
 814           JavaThread* thread = JavaThread::current();
 815           ThreadToNativeFromVM ttn(thread);
 816           HandleMark hm(thread);
 817           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 818         }
 819         if (zip != NULL &amp;&amp; error_msg == NULL) {
 820           // create using canonical path
<span class="line-modified"> 821           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);</span>
 822         }
 823       }
 824     }
 825   }
 826   return NULL;
 827 }
 828 
 829 // returns true if entry already on class path
 830 bool ClassLoader::contains_append_entry(const char* name) {
 831   ClassPathEntry* e = _first_append_entry;
 832   while (e != NULL) {
 833     // assume zip entries have been canonicalized
 834     if (strcmp(name, e-&gt;name()) == 0) {
 835       return true;
 836     }
 837     e = e-&gt;next();
 838   }
 839   return false;
 840 }
 841 
</pre>
<hr />
<pre>
 875 
 876   // The entry does not exist, add to the list
 877   if (_app_classpath_entries == NULL) {
 878     assert(_last_app_classpath_entry == NULL, &quot;Sanity&quot;);
 879     _app_classpath_entries = _last_app_classpath_entry = entry;
 880   } else {
 881     _last_app_classpath_entry-&gt;set_next(entry);
 882     _last_app_classpath_entry = entry;
 883   }
 884 
 885   if (entry-&gt;is_jar_file()) {
 886     ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates);
 887   }
 888 #endif
 889 }
 890 
 891 // Returns true IFF the file/dir exists and the entry was successfully created.
 892 bool ClassLoader::update_class_path_entry_list(const char *path,
 893                                                bool check_for_duplicates,
 894                                                bool is_boot_append,
<span class="line-added"> 895                                                bool from_class_path_attr,</span>
 896                                                bool throw_exception) {
 897   struct stat st;
 898   if (os::stat(path, &amp;st) == 0) {
 899     // File or directory found
 900     ClassPathEntry* new_entry = NULL;
 901     Thread* THREAD = Thread::current();
<span class="line-modified"> 902     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, from_class_path_attr, CHECK_(false));</span>
 903     if (new_entry == NULL) {
 904       return false;
 905     }
 906 
 907     // Do not reorder the bootclasspath which would break get_system_package().
 908     // Add new entry to linked list
 909     if (is_boot_append) {
 910       add_to_boot_append_entries(new_entry);
 911     } else {
 912       add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
 913     }
 914     return true;
 915   } else {





 916     return false;
 917   }
 918 }
 919 
 920 static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
 921   ResourceMark rm;
 922   int num_of_entries = module_list-&gt;length();
 923   for (int i = 0; i &lt; num_of_entries; i++) {
 924     ClassPathEntry* e;
 925     ModuleClassPathList* mpl = module_list-&gt;at(i);
 926     tty-&gt;print(&quot;%s=&quot;, mpl-&gt;module_name()-&gt;as_C_string());
 927     e = mpl-&gt;module_first_entry();
 928     while (e != NULL) {
 929       tty-&gt;print(&quot;%s&quot;, e-&gt;name());
 930       e = e-&gt;next();
 931       if (e != NULL) {
 932         tty-&gt;print(&quot;%s&quot;, os::path_separator());
 933       }
 934     }
 935     tty-&gt;print(&quot; ;&quot;);
</pre>
<hr />
<pre>
 948   // [jimage | exploded modules build]
 949   if (has_jrt_entry()) {
 950     // Print the location of the java runtime image
 951     tty-&gt;print(&quot;%s ;&quot;, _jrt_entry-&gt;name());
 952   } else {
 953     // Print exploded module build path specifications
 954     if (_exploded_entries != NULL) {
 955       print_module_entry_table(_exploded_entries);
 956     }
 957   }
 958 
 959   // appended entries
 960   e = _first_append_entry;
 961   while (e != NULL) {
 962     tty-&gt;print(&quot;%s ;&quot;, e-&gt;name());
 963     e = e-&gt;next();
 964   }
 965   tty-&gt;print_cr(&quot;]&quot;);
 966 }
 967 
<span class="line-added"> 968 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {</span>
<span class="line-added"> 969   void* func = os::dll_lookup(lib, name);</span>
<span class="line-added"> 970   if (func == NULL) {</span>
<span class="line-added"> 971     char msg[256] = &quot;&quot;;</span>
<span class="line-added"> 972     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);</span>
<span class="line-added"> 973     vm_exit_during_initialization(msg, path);</span>
<span class="line-added"> 974   }</span>
<span class="line-added"> 975   return func;</span>
<span class="line-added"> 976 }</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978 void ClassLoader::load_java_library() {</span>
<span class="line-added"> 979   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);</span>
<span class="line-added"> 980   void *javalib_handle = os::native_java_library();</span>
<span class="line-added"> 981   if (javalib_handle == NULL) {</span>
<span class="line-added"> 982     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);</span>
<span class="line-added"> 983   }</span>
<span class="line-added"> 984 </span>
<span class="line-added"> 985   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));</span>
<span class="line-added"> 986 }</span>
<span class="line-added"> 987 </span>
 988 void ClassLoader::load_zip_library() {
 989   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);



 990   char path[JVM_MAXPATHLEN];
 991   char ebuf[1024];
 992   void* handle = NULL;
 993   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 994     handle = os::dll_load(path, ebuf, sizeof ebuf);
 995   }
 996   if (handle == NULL) {
<span class="line-modified"> 997     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);</span>


















 998   }
 999 
<span class="line-modified">1000   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));</span>
<span class="line-modified">1001   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));</span>
<span class="line-modified">1002   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));</span>
<span class="line-modified">1003   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));</span>
<span class="line-added">1004   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));</span>
<span class="line-added">1005   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));</span>
1006 }
1007 
1008 void ClassLoader::load_jimage_library() {
<span class="line-modified">1009   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);</span>


1010   char path[JVM_MAXPATHLEN];
1011   char ebuf[1024];
1012   void* handle = NULL;
1013   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1014     handle = os::dll_load(path, ebuf, sizeof ebuf);
1015   }
1016   if (handle == NULL) {
1017     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1018   }
1019 
<span class="line-modified">1020   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));</span>
<span class="line-modified">1021   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));</span>
<span class="line-modified">1022   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));</span>
<span class="line-modified">1023   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));</span>
<span class="line-modified">1024   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));</span>
<span class="line-modified">1025   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));</span>











1026 }
1027 
1028 int ClassLoader::crc32(int crc, const char* buf, int len) {

1029   return (*Crc32)(crc, (const jbyte*)buf, len);
1030 }
1031 
1032 // Function add_package extracts the package from the fully qualified class name
1033 // and checks if the package is in the boot loader&#39;s package entry table.  If so,
1034 // then it sets the classpath_index in the package entry record.
1035 //
1036 // The classpath_index field is used to find the entry on the boot loader class
1037 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1038 // in an unnamed module.  It is also used to indicate (for all packages whose
1039 // classes are loaded by the boot loader) that at least one of the package&#39;s
1040 // classes has been loaded.
1041 bool ClassLoader::add_package(const char *fullq_class_name, s2 classpath_index, TRAPS) {
1042   assert(fullq_class_name != NULL, &quot;just checking&quot;);
1043 
1044   // Get package name from fully qualified class name.
<span class="line-modified">1045   ResourceMark rm(THREAD);</span>
1046   const char *cp = package_from_name(fullq_class_name);
1047   if (cp != NULL) {
1048     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<span class="line-modified">1049     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp);</span>
1050     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(pkg_symbol);
1051     if (pkg_entry != NULL) {
1052       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1053       pkg_entry-&gt;set_classpath_index(classpath_index);
1054     } else {
1055       return false;
1056     }
1057   }
1058   return true;
1059 }
1060 
1061 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1062   // Look up the name in the boot loader&#39;s package entry table.
1063   if (name != NULL) {
<span class="line-modified">1064     TempNewSymbol package_sym = SymbolTable::new_symbol(name);</span>
1065     // Look for the package entry in the boot loader&#39;s package entry table.
1066     PackageEntry* package =
1067       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1068 
1069     // Return NULL if package does not exist or if no classes in that package
1070     // have been loaded.
1071     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1072       ModuleEntry* module = package-&gt;module();
1073       if (module-&gt;location() != NULL) {
1074         ResourceMark rm(THREAD);
1075         Handle ml = java_lang_String::create_from_str(
1076           module-&gt;location()-&gt;as_C_string(), THREAD);
1077         return ml();
1078       }
1079       // Return entry on boot loader class path.
1080       Handle cph = java_lang_String::create_from_str(
1081         ClassLoader::classpath_entry(package-&gt;classpath_index())-&gt;name(), THREAD);
1082       return cph();
1083     }
1084   }
1085   return NULL;
1086 }
1087 
1088 objArrayOop ClassLoader::get_system_packages(TRAPS) {
1089   ResourceMark rm(THREAD);
1090   // List of pointers to PackageEntrys that have loaded classes.
1091   GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
1092   {
<span class="line-modified">1093     MutexLocker ml(THREAD, Module_lock);</span>
1094 
1095     PackageEntryTable* pe_table =
1096       ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1097 
1098     // Collect the packages that have at least one loaded class.
1099     for (int x = 0; x &lt; pe_table-&gt;table_size(); x++) {
1100       for (PackageEntry* package_entry = pe_table-&gt;bucket(x);
1101            package_entry != NULL;
1102            package_entry = package_entry-&gt;next()) {
1103         if (package_entry-&gt;has_loaded_class()) {
1104           loaded_class_pkgs-&gt;append(package_entry);
1105         }
1106       }
1107     }
1108   }
1109 
1110 
1111   // Allocate objArray and fill with java.lang.String
1112   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1113                                            loaded_class_pkgs-&gt;length(), CHECK_NULL);
</pre>
<hr />
<pre>
1170   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1171 
1172   // If the module system has not defined java.base yet, then
1173   // classes loaded are assumed to be defined to java.base.
1174   // When java.base is eventually defined by the module system,
1175   // all packages of classes that have been previously loaded
1176   // are verified in ModuleEntryTable::verify_javabase_packages().
1177   if (!Universe::is_module_initialized() &amp;&amp;
1178       !ModuleEntryTable::javabase_defined() &amp;&amp;
1179       mod_entry == NULL) {
1180     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1181   }
1182 
1183   // The module must be a named module
1184   ClassPathEntry* e = NULL;
1185   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1186     if (module_list == _exploded_entries) {
1187       // The exploded build entries can be added to at any time so a lock is
1188       // needed when searching them.
1189       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
<span class="line-modified">1190       MutexLocker ml(THREAD, Module_lock);</span>
1191       e = find_first_module_cpe(mod_entry, module_list);
1192     } else {
1193       e = find_first_module_cpe(mod_entry, module_list);
1194     }
1195   }
1196 
1197   // Try to load the class from the module&#39;s ClassPathEntry list.
1198   while (e != NULL) {
1199     stream = e-&gt;open_stream(file_name, CHECK_NULL);
1200     // No context.check is required since CDS is not supported
1201     // for an exploded modules build or if --patch-module is specified.
1202     if (NULL != stream) {
1203       return stream;
1204     }
1205     e = e-&gt;next();
1206   }
1207   // If the module was located, break out even if the class was not
1208   // located successfully from that module&#39;s ClassPathEntry list.
1209   // There will not be another valid entry for that module.
1210   return NULL;
</pre>
<hr />
<pre>
1237   //
1238   // If search_append_only is false, boot loader visibility boundaries are
1239   // set to be the --patch-module entries plus the base piece. This includes:
1240   //   [--patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*]; [jimage | exploded module build]
1241   //
1242 
1243   // Load Attempt #1: --patch-module
1244   // Determine the class&#39; defining module.  If it appears in the _patch_mod_entries,
1245   // attempt to load the class from those locations specific to the module.
1246   // Specifications to --patch-module can contain a partial number of classes
1247   // that are part of the overall module definition.  So if a particular class is not
1248   // found within its module specification, the search should continue to Load Attempt #2.
1249   // Note: The --patch-module entries are never searched if the boot loader&#39;s
1250   //       visibility boundary is limited to only searching the append entries.
1251   if (_patch_mod_entries != NULL &amp;&amp; !search_append_only) {
1252     // At CDS dump time, the --patch-module entries are ignored. That means a
1253     // class is still loaded from the runtime image even if it might
1254     // appear in the _patch_mod_entries. The runtime shared class visibility
1255     // check will determine if a shared class is visible based on the runtime
1256     // environemnt, including the runtime --patch-module setting.
<span class="line-added">1257     //</span>
<span class="line-added">1258     // DynamicDumpSharedSpaces requires UseSharedSpaces to be enabled. Since --patch-module</span>
<span class="line-added">1259     // is not supported with UseSharedSpaces, it is not supported with DynamicDumpSharedSpaces.</span>
<span class="line-added">1260     assert(!DynamicDumpSharedSpaces, &quot;sanity&quot;);</span>
1261     if (!DumpSharedSpaces) {
1262       stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
1263     }
1264   }
1265 
1266   // Load Attempt #2: [jimage | exploded build]
1267   if (!search_append_only &amp;&amp; (NULL == stream)) {
1268     if (has_jrt_entry()) {
1269       e = _jrt_entry;
1270       stream = _jrt_entry-&gt;open_stream(file_name, CHECK_NULL);
1271     } else {
1272       // Exploded build - attempt to locate class in its defining module&#39;s location.
1273       assert(_exploded_entries != NULL, &quot;No exploded build entries present&quot;);
1274       stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);
1275     }
1276   }
1277 
1278   // Load Attempt #3: [-Xbootclasspath/a]; [jvmti appended entries]
1279   if (search_append_only &amp;&amp; (NULL == stream)) {
1280     // For the boot loader append path search, the starting classpath_index
</pre>
<hr />
<pre>
1295   }
1296 
1297   if (NULL == stream) {
1298     return NULL;
1299   }
1300 
1301   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1302 
1303   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1304   Handle protection_domain;
1305 
1306   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1307                                                            name,
1308                                                            loader_data,
1309                                                            protection_domain,
1310                                                            NULL, // unsafe_anonymous_host
1311                                                            NULL, // cp_patches
1312                                                            THREAD);
1313   if (HAS_PENDING_EXCEPTION) {
1314     if (DumpSharedSpaces) {
<span class="line-modified">1315       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);</span>
1316     }
1317     return NULL;
1318   }
1319 
1320   if (!add_package(file_name, classpath_index, THREAD)) {
1321     return NULL;
1322   }
1323 
1324   return result;
1325 }
1326 
1327 #if INCLUDE_CDS
1328 char* ClassLoader::skip_uri_protocol(char* source) {
1329   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1330     // file: protocol path could start with file:/ or file:///
1331     // locate the char after all the forward slashes
1332     int offset = 5;
1333     while (*(source + offset) == &#39;/&#39;) {
1334         offset++;
1335     }
1336     source += offset;
1337   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1338 #ifndef _WINDOWS
1339     source -= 1;
1340 #endif
1341   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1342     source += 5;
1343   }
1344   return source;
1345 }
1346 
1347 // Record the shared classpath index and loader type for classes loaded
1348 // by the builtin loaders at dump time.
1349 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
<span class="line-modified">1350   Arguments::assert_is_dumping_archive();</span>
1351   assert(stream != NULL, &quot;sanity&quot;);
1352 
1353   if (ik-&gt;is_unsafe_anonymous()) {
1354     // We do not archive unsafe anonymous classes.
1355     return;
1356   }
1357 
1358   oop loader = ik-&gt;class_loader();
1359   char* src = (char*)stream-&gt;source();
1360   if (src == NULL) {
1361     if (loader == NULL) {
1362       // JFR classes
1363       ik-&gt;set_shared_classpath_index(0);
1364       ik-&gt;set_class_loader_type(ClassLoader::BOOT_LOADER);
1365     }
1366     return;
1367   }
1368 
1369   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1370 
</pre>
<hr />
<pre>
1410               // -Xbootclasspath/a and jvmti appended entries.
1411               assert(loader == NULL, &quot;sanity&quot;);
1412               classpath_index = i;
1413               break;
1414             }
1415           }
1416         } else {
1417           // A class from a named module from the --module-path. Ensure the index is
1418           // within the --module-path range before assigning to the classpath_index.
1419           if ((pkg_entry != NULL) &amp;&amp; !(pkg_entry-&gt;in_unnamed_module()) &amp;&amp; (i &gt; 0)) {
1420             if (i &gt;= ClassLoaderExt::app_module_paths_start_index() &amp;&amp;
1421                 i &lt; FileMapInfo::get_number_of_shared_paths()) {
1422               classpath_index = i;
1423               break;
1424             }
1425           }
1426         }
1427       }
1428       // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
1429       // The class must be from the runtime modules image.
<span class="line-modified">1430       if (i == 0 &amp;&amp; (stream-&gt;from_boot_loader_modules_image() || string_starts_with(src, &quot;jrt:&quot;))) {</span>
1431         classpath_index = i;
1432         break;
1433       }
1434     }
1435 
1436     // No path entry found for this class. Must be a shared class loaded by the
1437     // user defined classloader.
1438     if (classpath_index &lt; 0) {
1439       assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);
<span class="line-added">1440       ik-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);</span>
<span class="line-added">1441       SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);</span>
1442       return;
1443     }
1444   } else {
1445     // The shared path table is set up after module system initialization.
1446     // The path table contains no entry before that. Any classes loaded prior
1447     // to the setup of the shared path table must be from the modules image.
<span class="line-modified">1448     assert(stream-&gt;from_boot_loader_modules_image(), &quot;stream must be loaded by boot loader from modules image&quot;);</span>
1449     assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
1450     classpath_index = 0;
1451   }
1452 
1453   const char* const class_name = ik-&gt;name()-&gt;as_C_string();
1454   const char* const file_name = file_name_for_class_name(class_name,
1455                                                          ik-&gt;name()-&gt;utf8_length());
1456   assert(file_name != NULL, &quot;invariant&quot;);
1457 
1458   ClassLoaderExt::record_result(classpath_index, ik, THREAD);
1459 }
1460 #endif // INCLUDE_CDS
1461 
1462 // Initialize the class loader&#39;s access to methods in libzip.  Parse and
1463 // process the boot classpath into a list ClassPathEntry objects.  Once
1464 // this list has been created, it must not change order (see class PackageInfo)
1465 // it can be appended to and is by jvmti and the kernel vm.
1466 
1467 void ClassLoader::initialize() {
1468   EXCEPTION_MARK;
</pre>
<hr />
<pre>
1498     // The following performance counters are added for measuring the impact
1499     // of the bug fix of 6365597. They are mainly focused on finding out
1500     // the behavior of system &amp; user-defined classloader lock, whether
1501     // ClassLoader.loadClass/findClass is being called synchronized or not.
1502     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1503                         &quot;systemLoaderLockContentionRate&quot;);
1504     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1505                         &quot;nonSystemLoaderLockContentionRate&quot;);
1506     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1507                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1508     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1509                         &quot;jvmDefineClassNoLockCalls&quot;);
1510 
1511     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1512                         &quot;jniDefineClassNoLockCalls&quot;);
1513 
1514     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1515                         &quot;unsafeDefineClassCalls&quot;);
1516   }
1517 
<span class="line-added">1518   // lookup java library entry points</span>
<span class="line-added">1519   load_java_library();</span>
1520   // lookup zip library entry points
1521   load_zip_library();
<span class="line-modified">1522   // jimage library entry points are loaded below, in lookup_vm_options</span>
<span class="line-added">1523   setup_bootstrap_search_path();</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
<span class="line-added">1526 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {</span>
<span class="line-added">1527   jlong size;</span>
<span class="line-added">1528   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);</span>
<span class="line-added">1529   if (location == 0)</span>
<span class="line-added">1530     return NULL;</span>
<span class="line-added">1531   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);</span>
<span class="line-added">1532   (*JImageGetResource)(jimage, location, val, size);</span>
<span class="line-added">1533   val[size] = &#39;\0&#39;;</span>
<span class="line-added">1534   return val;</span>
<span class="line-added">1535 }</span>
<span class="line-added">1536 </span>
<span class="line-added">1537 // Lookup VM options embedded in the modules jimage file</span>
<span class="line-added">1538 char* ClassLoader::lookup_vm_options() {</span>
<span class="line-added">1539   jint error;</span>
<span class="line-added">1540   char modules_path[JVM_MAXPATHLEN];</span>
<span class="line-added">1541   const char* fileSep = os::file_separator();</span>
<span class="line-added">1542 </span>
<span class="line-added">1543   // Initialize jimage library entry points</span>
1544   load_jimage_library();
<span class="line-modified">1545 </span>
<span class="line-modified">1546   jio_snprintf(modules_path, JVM_MAXPATHLEN, &quot;%s%slib%smodules&quot;, Arguments::get_java_home(), fileSep, fileSep);</span>
<span class="line-modified">1547   JImageFile* jimage =(*JImageOpen)(modules_path, &amp;error);</span>
<span class="line-modified">1548   if (jimage == NULL) {</span>
<span class="line-added">1549     return NULL;</span>
1550   }
<span class="line-modified">1551 </span>
<span class="line-modified">1552   const char *jimage_version = get_jimage_version_string();</span>
<span class="line-added">1553   char *options = lookup_vm_resource(jimage, jimage_version, &quot;jdk/internal/vm/options&quot;);</span>
<span class="line-added">1554 </span>
<span class="line-added">1555   (*JImageClose)(jimage);</span>
<span class="line-added">1556   return options;</span>
1557 }
1558 
1559 #if INCLUDE_CDS
1560 void ClassLoader::initialize_shared_path() {
<span class="line-modified">1561   if (Arguments::is_dumping_archive()) {</span>
1562     ClassLoaderExt::setup_search_paths();

1563   }
1564 }
1565 
1566 void ClassLoader::initialize_module_path(TRAPS) {
<span class="line-modified">1567   if (Arguments::is_dumping_archive()) {</span>
1568     ClassLoaderExt::setup_module_paths(THREAD);
1569     FileMapInfo::allocate_shared_path_table();
1570   }
1571 }
1572 #endif
1573 
1574 jlong ClassLoader::classloader_time_ms() {
1575   return UsePerfData ?
1576     Management::ticks_to_ms(_perf_accumulated_time-&gt;get_value()) : -1;
1577 }
1578 
1579 jlong ClassLoader::class_init_count() {
1580   return UsePerfData ? _perf_classes_inited-&gt;get_value() : -1;
1581 }
1582 
1583 jlong ClassLoader::class_init_time_ms() {
1584   return UsePerfData ?
1585     Management::ticks_to_ms(_perf_class_init_time-&gt;get_value()) : -1;
1586 }
1587 
</pre>
<hr />
<pre>
1613 }
1614 
1615 // Complete the ClassPathEntry setup for the boot loader
1616 void ClassLoader::classLoader_init2(TRAPS) {
1617   // Setup the list of module/path pairs for --patch-module processing
1618   // This must be done after the SymbolTable is created in order
1619   // to use fast_compare on module names instead of a string compare.
1620   if (Arguments::get_patch_mod_prefix() != NULL) {
1621     setup_patch_mod_entries();
1622   }
1623 
1624   // Create the ModuleEntry for java.base (must occur after setup_patch_mod_entries
1625   // to successfully determine if java.base has been patched)
1626   create_javabase();
1627 
1628   // Setup the initial java.base/path pair for the exploded build entries.
1629   // As more modules are defined during module system initialization, more
1630   // entries will be added to the exploded build array.
1631   if (!has_jrt_entry()) {
1632     assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);
<span class="line-added">1633     assert(!DynamicDumpSharedSpaces, &quot;DynamicDumpSharedSpaces not supported with exploded module builds&quot;);</span>
1634     assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
1635     // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
1636     // done before loading any classes, by the same thread that will
1637     // subsequently do the first class load. So, no lock is needed for this.
1638     assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
1639     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
1640       GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
1641     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
1642   }
1643 }
1644 

1645 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
1646   assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
<span class="line-modified">1647   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">1648   ResourceMark rm(THREAD);</span>


1649 
<span class="line-modified">1650   // os::native_path writes into orig_copy</span>
<span class="line-modified">1651   char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);</span>
<span class="line-modified">1652   strcpy(orig_copy, orig);</span>
<span class="line-modified">1653   if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) &lt; 0) {</span>
<span class="line-modified">1654     return false;</span>





1655   }
1656   return true;
1657 }
1658 
1659 void ClassLoader::create_javabase() {
1660   Thread* THREAD = Thread::current();
1661 
1662   // Create java.base&#39;s module entry for the boot
1663   // class loader prior to loading j.l.Ojbect.
1664   ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
1665 
1666   // Get module entry table
1667   ModuleEntryTable* null_cld_modules = null_cld-&gt;modules();
1668   if (null_cld_modules == NULL) {
1669     vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
1670   }
1671 
1672   {
<span class="line-modified">1673     MutexLocker ml(THREAD, Module_lock);</span>
1674     ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
1675                                false, vmSymbols::java_base(), NULL, NULL, null_cld);
1676     if (jb_module == NULL) {
1677       vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
1678     }
1679     ModuleEntryTable::set_javabase_moduleEntry(jb_module);
1680   }
1681 }
1682 
1683 // Please keep following two functions at end of this file. With them placed at top or in middle of the file,
1684 // they could get inlined by agressive compiler, an unknown trick, see bug 6966589.
1685 void PerfClassTraceTime::initialize() {
1686   if (!UsePerfData) return;
1687 
1688   if (_eventp != NULL) {
1689     // increment the event counter
1690     _eventp-&gt;inc();
1691   }
1692 
1693   // stop the current active thread-local timer to measure inclusive time
</pre>
</td>
</tr>
</table>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
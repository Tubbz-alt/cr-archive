<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/sharedPathsMiscInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoader.hpp&quot;
 27 #include &quot;classfile/sharedPathsMiscInfo.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;logging/logStream.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/filemap.hpp&quot;
 32 #include &quot;memory/metaspaceShared.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;runtime/arguments.hpp&quot;
 35 #include &quot;runtime/os.inline.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 
 38 SharedPathsMiscInfo::SharedPathsMiscInfo() {
 39   _app_offset = 0;
 40   _buf_size = INITIAL_BUF_SIZE;
 41   _cur_ptr = _buf_start = NEW_C_HEAP_ARRAY(char, _buf_size, mtClass);
 42   _allocated = true;
 43 }
 44 
 45 SharedPathsMiscInfo::~SharedPathsMiscInfo() {
 46   if (_allocated) {
 47     FREE_C_HEAP_ARRAY(char, _buf_start);
 48   }
 49 }
 50 
 51 void SharedPathsMiscInfo::add_path(const char* path, int type) {
 52   log_info(class, path)(&quot;type=%s &quot;, type_name(type));
 53   ClassLoader::trace_class_path(&quot;add misc shared path &quot;, path);
 54   write(path, strlen(path) + 1);
 55   write_jint(jint(type));
 56 }
 57 
 58 void SharedPathsMiscInfo::ensure_size(size_t needed_bytes) {
 59   assert(_allocated, &quot;cannot modify buffer during validation.&quot;);
 60   int used = get_used_bytes();
 61   int target = used + int(needed_bytes);
 62   if (target &gt; _buf_size) {
 63     _buf_size = _buf_size * 2 + (int)needed_bytes;
 64     _buf_start = REALLOC_C_HEAP_ARRAY(char, _buf_start, _buf_size, mtClass);
 65     _cur_ptr = _buf_start + used;
 66     _end_ptr = _buf_start + _buf_size;
 67   }
 68 }
 69 
 70 void SharedPathsMiscInfo::write(const void* ptr, size_t size) {
 71   ensure_size(size);
 72   memcpy(_cur_ptr, ptr, size);
 73   _cur_ptr += size;
 74 }
 75 
 76 bool SharedPathsMiscInfo::read(void* ptr, size_t size) {
 77   if (_cur_ptr + size &lt;= _end_ptr) {
 78     memcpy(ptr, _cur_ptr, size);
 79     _cur_ptr += size;
 80     return true;
 81   }
 82   return false;
 83 }
 84 
 85 bool SharedPathsMiscInfo::fail(const char* msg, const char* name) {
 86   ClassLoader::trace_class_path(msg, name);
 87   MetaspaceShared::set_archive_loading_failed();
 88   return false;
 89 }
 90 
 91 void SharedPathsMiscInfo::print_path(outputStream* out, int type, const char* path) {
 92   switch (type) {
 93   case BOOT_PATH:
 94     out-&gt;print(&quot;Expecting BOOT path=%s&quot;, path);
 95     break;
 96   case NON_EXIST:
 97     out-&gt;print(&quot;Expecting that %s does not exist&quot;, path);
 98     break;
 99   case APP_PATH:
100     ClassLoader::trace_class_path(&quot;Expecting -Djava.class.path=&quot;, path);
101     break;
102   default:
103     ShouldNotReachHere();
104   }
105 }
106 
107 bool SharedPathsMiscInfo::check() {
108   // The whole buffer must be 0 terminated so that we can use strlen and strcmp
109   // without fear.
110   _end_ptr -= sizeof(jint);
111   if (_cur_ptr &gt;= _end_ptr) {
112     return fail(&quot;Truncated archive file header&quot;);
113   }
114   if (*_end_ptr != 0) {
115     return fail(&quot;Corrupted archive file header&quot;);
116   }
117 
118   jshort cur_index = 0;
119   jshort max_cp_index = FileMapInfo::current_info()-&gt;header()-&gt;max_used_path_index();
120   jshort module_paths_start_index =
121     FileMapInfo::current_info()-&gt;header()-&gt;app_module_paths_start_index();
122   while (_cur_ptr &lt; _end_ptr) {
123     jint type;
124     const char* path = _cur_ptr;
125     _cur_ptr += strlen(path) + 1;
126 
127     if (!read_jint(&amp;type)) {
128       return fail(&quot;Corrupted archive file header&quot;);
129     }
130     LogTarget(Info, class, path) lt;
131     if (lt.is_enabled()) {
132       lt.print(&quot;type=%s &quot;, type_name(type));
133       LogStream ls(lt);
134       print_path(&amp;ls, type, path);
135       ls.cr();
136     }
137     // skip checking the class path(s) which was not referenced during CDS dump
138     if ((cur_index &lt;= max_cp_index) || (cur_index &gt;= module_paths_start_index)) {
139       if (!check(type, path)) {
140         if (!PrintSharedArchiveAndExit) {
141           return false;
142         }
143       } else {
144         ClassLoader::trace_class_path(&quot;ok&quot;);
145       }
146     } else {
147       ClassLoader::trace_class_path(&quot;skipped check&quot;);
148     }
149     cur_index++;
150   }
151 
152   return true;
153 }
154 
155 char* skip_first_path_entry(const char* path) {
156   size_t path_sep_len = strlen(os::path_separator());
157   char* p = strstr((char*)path, os::path_separator());
158   if (p != NULL) {
159     debug_only( {
160       size_t image_name_len = strlen(MODULES_IMAGE_NAME);
161       assert(strncmp(p - image_name_len, MODULES_IMAGE_NAME, image_name_len) == 0,
162              &quot;first entry must be the modules image&quot;);
163     } );
164     p += path_sep_len;
165   } else {
166     debug_only( {
167       assert(ClassLoader::string_ends_with(path, MODULES_IMAGE_NAME),
168              &quot;first entry must be the modules image&quot;);
169     } );
170   }
171   return p;
172 }
173 
174 bool SharedPathsMiscInfo::check(jint type, const char* path) {
175   assert(UseSharedSpaces, &quot;runtime only&quot;);
176   switch (type) {
177   case BOOT_PATH:
178     {
179       //
180       // - Archive contains boot classes only - relaxed boot path check:
181       //   Extra path elements appended to the boot path at runtime are allowed.
182       //
183       // - Archive contains application or platform classes - strict boot path check:
184       //   Validate the entire runtime boot path, which must be compactible
185       //   with the dump time boot path. Appending boot path at runtime is not
186       //   allowed.
187       //
188 
189       // The first entry in boot path is the modules_image (guaranteed by
190       // ClassLoader::setup_boot_search_path()). Skip the first entry. The
191       // path of the runtime modules_image may be different from the dump
192       // time path (e.g. the JDK image is copied to a different location
193       // after generating the shared archive), which is acceptable. For most
194       // common cases, the dump time boot path might contain modules_image only.
195       char* runtime_boot_path = Arguments::get_sysclasspath();
196       char* rp = skip_first_path_entry(runtime_boot_path);
197       char* dp = skip_first_path_entry(path);
198 
199       bool relaxed_check = !FileMapInfo::current_info()-&gt;header()-&gt;has_platform_or_app_classes();
200       if (dp == NULL &amp;&amp; rp == NULL) {
201         break;   // ok, both runtime and dump time boot paths have modules_images only
202       } else if (dp == NULL &amp;&amp; rp != NULL &amp;&amp; relaxed_check) {
203         break;   // ok, relaxed check, runtime has extra boot append path entries
204       } else if (dp != NULL &amp;&amp; rp != NULL) {
205         size_t num;
206         size_t dp_len = strlen(dp);
207         size_t rp_len = strlen(rp);
208         if (rp_len &gt;= dp_len) {
209           if (relaxed_check) {
210             // only check the leading entries in the runtime boot path, up to
211             // the length of the dump time boot path
212             num = dp_len;
213           } else {
214             // check the full runtime boot path, must match with dump time
215             num = rp_len;
216           }
217 
218           if (os::file_name_strncmp(dp, rp, num) == 0) {
219             // make sure it is the end of an entry in the runtime boot path
220             if (rp[dp_len] == &#39;\0&#39; || rp[dp_len] == os::path_separator()[0]) {
221               break; // ok, runtime and dump time paths match
222             }
223           }
224         }
225       }
226 
227       // The paths are different
228       return fail(&quot;[BOOT classpath mismatch, actual =&quot;, runtime_boot_path);
229     }
230     break;
231   case NON_EXIST:
232     {
233       struct stat st;
234       if (os::stat(path, &amp;st) == 0) {
235         // The file actually exists
236         // But we want it to not exist -&gt; fail
237         return fail(&quot;File must not exist&quot;);
238       }
239     }
240     break;
241   case APP_PATH:
242     {
243       size_t len = strlen(path);
244       const char *appcp = Arguments::get_appclasspath();
245       assert(appcp != NULL, &quot;NULL app classpath&quot;);
246       size_t appcp_len = strlen(appcp);
247       if (appcp_len &lt; len) {
248         return fail(&quot;Run time APP classpath is shorter than the one at dump time: &quot;, appcp);
249       }
250       // Prefix is OK: E.g., dump with -cp foo.jar, but run with -cp foo.jar:bar.jar.
251       if (os::file_name_strncmp(path, appcp, len) != 0) {
252         return fail(&quot;[APP classpath mismatch, actual: -Djava.class.path=&quot;, appcp);
253       }
254       if (appcp[len] != &#39;\0&#39; &amp;&amp; appcp[len] != os::path_separator()[0]) {
255         return fail(&quot;Dump time APP classpath is not a proper prefix of run time APP classpath: &quot;, appcp);
256       }
257     }
258     break;
259   default:
260     return fail(&quot;Corrupted archive file header&quot;);
261   }
262 
263   return true;
264 }
    </pre>
  </body>
</html>
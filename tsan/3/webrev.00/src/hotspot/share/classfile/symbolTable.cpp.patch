diff a/src/hotspot/share/classfile/symbolTable.cpp b/src/hotspot/share/classfile/symbolTable.cpp
--- a/src/hotspot/share/classfile/symbolTable.cpp
+++ b/src/hotspot/share/classfile/symbolTable.cpp
@@ -26,29 +26,29 @@
 #include "classfile/altHashing.hpp"
 #include "classfile/compactHashtable.hpp"
 #include "classfile/javaClasses.hpp"
 #include "classfile/symbolTable.hpp"
 #include "memory/allocation.inline.hpp"
+#include "memory/dynamicArchive.hpp"
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/resourceArea.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "services/diagnosticCommand.hpp"
 #include "utilities/concurrentHashTable.inline.hpp"
 #include "utilities/concurrentHashTableTasks.inline.hpp"
+#include "utilities/utf8.hpp"
 
 // We used to not resize at all, so let's be conservative
 // and not set it too short before we decide to resize,
 // to match previous startup behavior
 const double PREF_AVG_LIST_LEN = 8.0;
-// 2^17 (131,072) is max size, which is about 6.5 times as large
-// as the previous table size (used to be 20,011),
-// which never resized
-const size_t END_SIZE = 17;
+// 2^24 is max size, like StringTable.
+const size_t END_SIZE = 24;
 // If a chain gets to 100 something might be wrong
 const size_t REHASH_LEN = 100;
 
 const size_t ON_STACK_BUFFER_LENGTH = 128;
 
@@ -66,14 +66,35 @@
 static OffsetCompactHashtable<
   const char*, Symbol*,
   symbol_equals_compact_hashtable_entry
 > _shared_table;
 
+static OffsetCompactHashtable<
+  const char*, Symbol*,
+  symbol_equals_compact_hashtable_entry
+> _dynamic_shared_table;
+
 // --------------------------------------------------------------------------
-SymbolTable* SymbolTable::_the_table = NULL;
-volatile bool SymbolTable::_alt_hash = false;
-volatile bool SymbolTable::_lookup_shared_first = false;
+
+typedef ConcurrentHashTable<SymbolTableConfig, mtSymbol> SymbolTableHash;
+static SymbolTableHash* _local_table = NULL;
+
+volatile bool SymbolTable::_has_work = 0;
+volatile bool SymbolTable::_needs_rehashing = false;
+
+// For statistics
+static size_t _symbols_removed = 0;
+static size_t _symbols_counted = 0;
+static size_t _current_size = 0;
+
+static volatile size_t _items_count = 0;
+static volatile bool   _has_items_to_clean = false;
+
+
+static volatile bool _alt_hash = false;
+static volatile bool _lookup_shared_first = false;
+
 // Static arena for symbols that are not deallocated
 Arena* SymbolTable::_arena = NULL;
 
 static juint murmur_seed = 0;
 
@@ -89,31 +110,35 @@
   return useAlt ?
   AltHashing::murmur3_32(murmur_seed, (const jbyte*)s, len) :
   java_lang_String::hash_code((const jbyte*)s, len);
 }
 
+#if INCLUDE_CDS
 static uintx hash_shared_symbol(const char* s, int len) {
   return java_lang_String::hash_code((const jbyte*)s, len);
 }
+#endif
 
-class SymbolTableConfig : public SymbolTableHash::BaseConfig {
+class SymbolTableConfig : public AllStatic {
 private:
 public:
-  static uintx get_hash(Symbol* const& value, bool* is_dead) {
+  typedef Symbol* Value;  // value of the Node in the hashtable
+
+  static uintx get_hash(Value const& value, bool* is_dead) {
     *is_dead = (value->refcount() == 0);
     if (*is_dead) {
       return 0;
     } else {
-      return hash_symbol((const char*)value->bytes(), value->utf8_length(), SymbolTable::_alt_hash);
+      return hash_symbol((const char*)value->bytes(), value->utf8_length(), _alt_hash);
     }
   }
   // We use default allocation/deallocation but counted
-  static void* allocate_node(size_t size, Symbol* const& value) {
+  static void* allocate_node(size_t size, Value const& value) {
     SymbolTable::item_added();
-    return SymbolTableHash::BaseConfig::allocate_node(size, value);
+    return AllocateHeap(size, mtSymbol);
   }
-  static void free_node(void* memory, Symbol* const& value) {
+  static void free_node(void* memory, Value const& value) {
     // We get here because #1 some threads lost a race to insert a newly created Symbol
     // or #2 we're cleaning up unused symbol.
     // If #1, then the symbol can be either permanent (refcount==PERM_REFCOUNT),
     // or regular newly created one (refcount==1)
     // If #2, then the symbol is dead (refcount==0)
@@ -122,36 +147,39 @@
     if (value->refcount() == 1) {
       value->decrement_refcount();
       assert(value->refcount() == 0, "expected dead symbol");
     }
     SymbolTable::delete_symbol(value);
-    SymbolTableHash::BaseConfig::free_node(memory, value);
+    FreeHeap(memory);
     SymbolTable::item_removed();
   }
 };
 
 static size_t ceil_log2(size_t value) {
   size_t ret;
   for (ret = 1; ((size_t)1 << ret) < value; ++ret);
   return ret;
 }
 
-SymbolTable::SymbolTable() :
-  _symbols_removed(0), _symbols_counted(0), _local_table(NULL),
-  _current_size(0), _has_work(0), _needs_rehashing(false),
-  _items_count(0), _has_items_to_clean(false) {
-
+void SymbolTable::create_table ()  {
   size_t start_size_log_2 = ceil_log2(SymbolTableSize);
   _current_size = ((size_t)1) << start_size_log_2;
   log_trace(symboltable)("Start size: " SIZE_FORMAT " (" SIZE_FORMAT ")",
                          _current_size, start_size_log_2);
   _local_table = new SymbolTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
+
+  // Initialize the arena for global symbols, size passed in depends on CDS.
+  if (symbol_alloc_arena_size == 0) {
+    _arena = new (mtSymbol) Arena(mtSymbol);
+  } else {
+    _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);
+  }
 }
 
 void SymbolTable::delete_symbol(Symbol* sym) {
   if (sym->refcount() == PERM_REFCOUNT) {
-    MutexLockerEx ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena
+    MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena
     // Deleting permanent symbol should not occur very often (insert race condition),
     // so log it.
     log_trace_symboltable_helper(sym, "Freeing permanent symbol");
     if (!arena()->Afree(sym, sym->size())) {
       log_trace_symboltable_helper(sym, "Leaked permanent symbol");
@@ -159,71 +187,56 @@
   } else {
     delete sym;
   }
 }
 
-void SymbolTable::update_needs_rehash(bool rehash) {
-  if (rehash) {
-    _needs_rehashing = true;
-  }
-}
-
-void SymbolTable::reset_has_items_to_clean() { Atomic::store(false, &_has_items_to_clean); }
-void SymbolTable::mark_has_items_to_clean()  { Atomic::store(true, &_has_items_to_clean); }
-bool SymbolTable::has_items_to_clean() const { return Atomic::load(&_has_items_to_clean); }
+void SymbolTable::reset_has_items_to_clean() { Atomic::store(&_has_items_to_clean, false); }
+void SymbolTable::mark_has_items_to_clean()  { Atomic::store(&_has_items_to_clean, true); }
+bool SymbolTable::has_items_to_clean()       { return Atomic::load(&_has_items_to_clean); }
 
 void SymbolTable::item_added() {
-  Atomic::inc(&(SymbolTable::the_table()->_items_count));
+  Atomic::inc(&_items_count);
 }
 
 void SymbolTable::item_removed() {
-  Atomic::inc(&(SymbolTable::the_table()->_symbols_removed));
-  Atomic::dec(&(SymbolTable::the_table()->_items_count));
+  Atomic::inc(&(_symbols_removed));
+  Atomic::dec(&_items_count);
 }
 
-double SymbolTable::get_load_factor() const {
+double SymbolTable::get_load_factor() {
   return (double)_items_count/_current_size;
 }
 
 size_t SymbolTable::table_size() {
   return ((size_t)1) << _local_table->get_size_log2(Thread::current());
 }
 
 void SymbolTable::trigger_cleanup() {
-  MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);
-  SymbolTable::the_table()->_has_work = true;
+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);
+  _has_work = true;
   Service_lock->notify_all();
 }
 
-Symbol* SymbolTable::allocate_symbol(const char* name, int len, bool c_heap, TRAPS) {
+Symbol* SymbolTable::allocate_symbol(const char* name, int len, bool c_heap) {
   assert (len <= Symbol::max_length(), "should be checked by caller");
 
   Symbol* sym;
-  if (DumpSharedSpaces) {
+  if (Arguments::is_dumping_archive()) {
     c_heap = false;
   }
   if (c_heap) {
     // refcount starts as 1
-    sym = new (len, THREAD) Symbol((const u1*)name, len, 1);
+    sym = new (len) Symbol((const u1*)name, len, 1);
     assert(sym != NULL, "new should call vm_exit_out_of_memory if C_HEAP is exhausted");
   } else {
     // Allocate to global arena
-    MutexLockerEx ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena
-    sym = new (len, arena(), THREAD) Symbol((const u1*)name, len, PERM_REFCOUNT);
+    MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena
+    sym = new (len, arena()) Symbol((const u1*)name, len, PERM_REFCOUNT);
   }
   return sym;
 }
 
-void SymbolTable::initialize_symbols(int arena_alloc_size) {
-  // Initialize the arena for global symbols, size passed in depends on CDS.
-  if (arena_alloc_size == 0) {
-    _arena = new (mtSymbol) Arena(mtSymbol);
-  } else {
-    _arena = new (mtSymbol) Arena(mtSymbol, arena_alloc_size);
-  }
-}
-
 class SymbolsDo : StackObj {
   SymbolClosure *_cl;
 public:
   SymbolsDo(SymbolClosure *cl) : _cl(cl) {}
   bool operator()(Symbol** value) {
@@ -246,15 +259,16 @@
 // Call function for all symbols in the symbol table.
 void SymbolTable::symbols_do(SymbolClosure *cl) {
   // all symbols from shared table
   SharedSymbolIterator iter(cl);
   _shared_table.iterate(&iter);
+  _dynamic_shared_table.iterate(&iter);
 
   // all symbols from the dynamic table
   SymbolsDo sd(cl);
-  if (!SymbolTable::the_table()->_local_table->try_scan(Thread::current(), sd)) {
-    log_info(stringtable)("symbols_do unavailable at this moment");
+  if (!_local_table->try_scan(Thread::current(), sd)) {
+    log_info(symboltable)("symbols_do unavailable at this moment");
   }
 }
 
 class MetaspacePointersDo : StackObj {
   MetaspaceClosure *_it;
@@ -267,35 +281,40 @@
     return true;
   };
 };
 
 void SymbolTable::metaspace_pointers_do(MetaspaceClosure* it) {
-  assert(DumpSharedSpaces, "called only during dump time");
+  Arguments::assert_is_dumping_archive();
   MetaspacePointersDo mpd(it);
-  SymbolTable::the_table()->_local_table->do_safepoint_scan(mpd);
+  _local_table->do_safepoint_scan(mpd);
 }
 
 Symbol* SymbolTable::lookup_dynamic(const char* name,
                                     int len, unsigned int hash) {
-  Symbol* sym = SymbolTable::the_table()->do_lookup(name, len, hash);
+  Symbol* sym = do_lookup(name, len, hash);
   assert((sym == NULL) || sym->refcount() != 0, "refcount must not be zero");
   return sym;
 }
 
+#if INCLUDE_CDS
 Symbol* SymbolTable::lookup_shared(const char* name,
                                    int len, unsigned int hash) {
+  Symbol* sym = NULL;
   if (!_shared_table.empty()) {
-    if (SymbolTable::_alt_hash) {
+    if (_alt_hash) {
       // hash_code parameter may use alternate hashing algorithm but the shared table
       // always uses the same original hash code.
       hash = hash_shared_symbol(name, len);
     }
-    return _shared_table.lookup(name, hash, len);
-  } else {
-    return NULL;
+    sym = _shared_table.lookup(name, hash, len);
+    if (sym == NULL && DynamicArchive::is_mapped()) {
+      sym = _dynamic_shared_table.lookup(name, hash, len);
+    }
   }
+  return sym;
 }
+#endif
 
 Symbol* SymbolTable::lookup_common(const char* name,
                             int len, unsigned int hash) {
   Symbol* sym;
   if (_lookup_shared_first) {
@@ -314,29 +333,30 @@
     }
   }
   return sym;
 }
 
-Symbol* SymbolTable::lookup(const char* name, int len, TRAPS) {
-  unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);
-  Symbol* sym = SymbolTable::the_table()->lookup_common(name, len, hash);
+Symbol* SymbolTable::new_symbol(const char* name, int len) {
+  unsigned int hash = hash_symbol(name, len, _alt_hash);
+  Symbol* sym = lookup_common(name, len, hash);
   if (sym == NULL) {
-    sym = SymbolTable::the_table()->do_add_if_needed(name, len, hash, true, CHECK_NULL);
+    sym = do_add_if_needed(name, len, hash, true);
   }
   assert(sym->refcount() != 0, "lookup should have incremented the count");
   assert(sym->equals(name, len), "symbol must be properly initialized");
   return sym;
 }
 
-Symbol* SymbolTable::lookup(const Symbol* sym, int begin, int end, TRAPS) {
+Symbol* SymbolTable::new_symbol(const Symbol* sym, int begin, int end) {
+  assert(begin <= end && end <= sym->utf8_length(), "just checking");
   assert(sym->refcount() != 0, "require a valid symbol");
   const char* name = (const char*)sym->base() + begin;
   int len = end - begin;
-  unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);
-  Symbol* found = SymbolTable::the_table()->lookup_common(name, len, hash);
+  unsigned int hash = hash_symbol(name, len, _alt_hash);
+  Symbol* found = lookup_common(name, len, hash);
   if (found == NULL) {
-    found = SymbolTable::the_table()->do_add_if_needed(name, len, hash, true, THREAD);
+    found = do_add_if_needed(name, len, hash, true);
   }
   return found;
 }
 
 class SymbolTableLookup : StackObj {
@@ -344,12 +364,12 @@
   Thread* _thread;
   uintx _hash;
   int _len;
   const char* _str;
 public:
-  SymbolTableLookup(Thread* thread, const char* key, int len, uintx hash)
-  : _thread(thread), _hash(hash), _len(len), _str(key) {}
+  SymbolTableLookup(const char* key, int len, uintx hash)
+  : _hash(hash), _len(len), _str(key) {}
   uintx get_hash() const {
     return _hash;
   }
   bool equals(Symbol** value, bool* is_dead) {
     assert(value != NULL, "expected valid value");
@@ -385,45 +405,45 @@
   }
 };
 
 Symbol* SymbolTable::do_lookup(const char* name, int len, uintx hash) {
   Thread* thread = Thread::current();
-  SymbolTableLookup lookup(thread, name, len, hash);
+  SymbolTableLookup lookup(name, len, hash);
   SymbolTableGet stg;
   bool rehash_warning = false;
   _local_table->get(thread, lookup, stg, &rehash_warning);
   update_needs_rehash(rehash_warning);
   Symbol* sym = stg.get_res_sym();
   assert((sym == NULL) || sym->refcount() != 0, "found dead symbol");
   return sym;
 }
 
 Symbol* SymbolTable::lookup_only(const char* name, int len, unsigned int& hash) {
-  hash = hash_symbol(name, len, SymbolTable::_alt_hash);
-  return SymbolTable::the_table()->lookup_common(name, len, hash);
+  hash = hash_symbol(name, len, _alt_hash);
+  return lookup_common(name, len, hash);
 }
 
 // Suggestion: Push unicode-based lookup all the way into the hashing
 // and probing logic, so there is no need for convert_to_utf8 until
 // an actual new Symbol* is created.
-Symbol* SymbolTable::lookup_unicode(const jchar* name, int utf16_length, TRAPS) {
+Symbol* SymbolTable::new_symbol(const jchar* name, int utf16_length) {
   int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
   char stack_buf[ON_STACK_BUFFER_LENGTH];
   if (utf8_length < (int) sizeof(stack_buf)) {
     char* chars = stack_buf;
     UNICODE::convert_to_utf8(name, utf16_length, chars);
-    return lookup(chars, utf8_length, THREAD);
+    return new_symbol(chars, utf8_length);
   } else {
-    ResourceMark rm(THREAD);
+    ResourceMark rm;
     char* chars = NEW_RESOURCE_ARRAY(char, utf8_length + 1);
     UNICODE::convert_to_utf8(name, utf16_length, chars);
-    return lookup(chars, utf8_length, THREAD);
+    return new_symbol(chars, utf8_length);
   }
 }
 
 Symbol* SymbolTable::lookup_only_unicode(const jchar* name, int utf16_length,
-                                           unsigned int& hash) {
+                                         unsigned int& hash) {
   int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
   char stack_buf[ON_STACK_BUFFER_LENGTH];
   if (utf8_length < (int) sizeof(stack_buf)) {
     char* chars = stack_buf;
     UNICODE::convert_to_utf8(name, utf16_length, chars);
@@ -436,37 +456,41 @@
   }
 }
 
 void SymbolTable::new_symbols(ClassLoaderData* loader_data, const constantPoolHandle& cp,
                               int names_count, const char** names, int* lengths,
-                              int* cp_indices, unsigned int* hashValues, TRAPS) {
+                              int* cp_indices, unsigned int* hashValues) {
   bool c_heap = !loader_data->is_the_null_class_loader_data();
   for (int i = 0; i < names_count; i++) {
     const char *name = names[i];
     int len = lengths[i];
     unsigned int hash = hashValues[i];
-    assert(SymbolTable::the_table()->lookup_shared(name, len, hash) == NULL, "must have checked already");
-    Symbol* sym = SymbolTable::the_table()->do_add_if_needed(name, len, hash, c_heap, CHECK);
+    assert(lookup_shared(name, len, hash) == NULL, "must have checked already");
+    Symbol* sym = do_add_if_needed(name, len, hash, c_heap);
     assert(sym->refcount() != 0, "lookup should have incremented the count");
     cp->symbol_at_put(cp_indices[i], sym);
   }
 }
 
-Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool heap, TRAPS) {
-  SymbolTableLookup lookup(THREAD, name, len, hash);
+Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool heap) {
+  SymbolTableLookup lookup(name, len, hash);
   SymbolTableGet stg;
   bool clean_hint = false;
   bool rehash_warning = false;
   Symbol* sym = NULL;
+  Thread* THREAD = Thread::current();
 
   do {
-    if (_local_table->get(THREAD, lookup, stg, &rehash_warning)) {
-      sym = stg.get_res_sym();
+    // Callers have looked up the symbol once, insert the symbol.
+    sym = allocate_symbol(name, len, heap);
+    if (_local_table->insert(THREAD, lookup, sym, &rehash_warning, &clean_hint)) {
       break;
     }
-    sym = SymbolTable::the_table()->allocate_symbol(name, len, heap, THREAD);
-    if (_local_table->insert(THREAD, lookup, sym, &rehash_warning, &clean_hint)) {
+    // In case another thread did a concurrent add, return value already in the table.
+    // This could fail if the symbol got deleted concurrently, so loop back until success.
+    if (_local_table->get(THREAD, lookup, stg, &rehash_warning)) {
+      sym = stg.get_res_sym();
       break;
     }
   } while(true);
 
   update_needs_rehash(rehash_warning);
@@ -478,16 +502,16 @@
 
   assert((sym == NULL) || sym->refcount() != 0, "found dead symbol");
   return sym;
 }
 
-Symbol* SymbolTable::new_permanent_symbol(const char* name, TRAPS) {
+Symbol* SymbolTable::new_permanent_symbol(const char* name) {
   unsigned int hash = 0;
   int len = (int)strlen(name);
   Symbol* sym = SymbolTable::lookup_only(name, len, hash);
   if (sym == NULL) {
-    sym = SymbolTable::the_table()->do_add_if_needed(name, len, hash, false, CHECK_NULL);
+    sym = do_add_if_needed(name, len, hash, false);
   }
   if (!sym->is_permanent()) {
     sym->make_permanent();
     log_trace_symboltable_helper(sym, "Asked for a permanent symbol, but got a regular one");
   }
@@ -500,10 +524,17 @@
     assert(*value != NULL, "value should point to a symbol");
     return (*value)->size() * HeapWordSize;
   };
 };
 
+TableStatistics SymbolTable::get_table_statistics() {
+  static TableStatistics ts;
+  SizeFunc sz;
+  ts = _local_table->statistics_get(Thread::current(), sz, ts);
+  return ts;
+}
+
 void SymbolTable::print_table_statistics(outputStream* st,
                                          const char* table_name) {
   SizeFunc sz;
   _local_table->statistics_to(Thread::current(), sz, st, table_name);
 }
@@ -522,12 +553,12 @@
 };
 
 void SymbolTable::verify() {
   Thread* thr = Thread::current();
   VerifySymbols vs;
-  if (!SymbolTable::the_table()->_local_table->try_scan(thr, vs)) {
-    log_info(stringtable)("verify unavailable at this moment");
+  if (!_local_table->try_scan(thr, vs)) {
+    log_info(symboltable)("verify unavailable at this moment");
   }
 }
 
 // Dumping
 class DumpSymbol : StackObj {
@@ -548,17 +579,17 @@
   };
 };
 
 void SymbolTable::dump(outputStream* st, bool verbose) {
   if (!verbose) {
-    SymbolTable::the_table()->print_table_statistics(st, "SymbolTable");
+    print_table_statistics(st, "SymbolTable");
   } else {
     Thread* thr = Thread::current();
     ResourceMark rm(thr);
     st->print_cr("VERSION: 1.1");
     DumpSymbol ds(thr, st);
-    if (!SymbolTable::the_table()->_local_table->try_scan(thr, ds)) {
+    if (!_local_table->try_scan(thr, ds)) {
       log_info(symboltable)("dump unavailable at this moment");
     }
   }
 }
 
@@ -571,44 +602,59 @@
     assert(*value != NULL, "value should point to a symbol");
     Symbol* sym = *value;
     unsigned int fixed_hash = hash_shared_symbol((const char*)sym->bytes(), sym->utf8_length());
     assert(fixed_hash == hash_symbol((const char*)sym->bytes(), sym->utf8_length(), false),
            "must not rehash during dumping");
+    if (DynamicDumpSharedSpaces) {
+      sym = DynamicArchive::original_to_target(sym);
+    }
     _writer->add(fixed_hash, MetaspaceShared::object_delta_u4(sym));
     return true;
   }
 };
 
 void SymbolTable::copy_shared_symbol_table(CompactHashtableWriter* writer) {
   CopyToArchive copy(writer);
-  SymbolTable::the_table()->_local_table->do_safepoint_scan(copy);
+  _local_table->do_safepoint_scan(copy);
 }
 
-void SymbolTable::write_to_archive() {
-  _shared_table.reset();
+size_t SymbolTable::estimate_size_for_archive() {
+  return CompactHashtableWriter::estimate_size(int(_items_count));
+}
 
-  int num_buckets = CompactHashtableWriter::default_num_buckets(
-      SymbolTable::the_table()->_items_count);
-  CompactHashtableWriter writer(num_buckets,
+void SymbolTable::write_to_archive(bool is_static_archive) {
+  CompactHashtableWriter writer(int(_items_count),
                                 &MetaspaceShared::stats()->symbol);
   copy_shared_symbol_table(&writer);
-  writer.dump(&_shared_table, "symbol");
-
-  // Verify table is correct
-  Symbol* sym = vmSymbols::java_lang_Object();
-  const char* name = (const char*)sym->bytes();
-  int len = sym->utf8_length();
-  unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);
-  assert(sym == _shared_table.lookup(name, hash, len), "sanity");
+  if (is_static_archive) {
+    _shared_table.reset();
+    writer.dump(&_shared_table, "symbol");
+
+    // Verify table is correct
+    Symbol* sym = vmSymbols::java_lang_Object();
+    const char* name = (const char*)sym->bytes();
+    int len = sym->utf8_length();
+    unsigned int hash = hash_symbol(name, len, _alt_hash);
+    assert(sym == _shared_table.lookup(name, hash, len), "sanity");
+  } else {
+    _dynamic_shared_table.reset();
+    writer.dump(&_dynamic_shared_table, "symbol");
+  }
 }
 
-void SymbolTable::serialize_shared_table_header(SerializeClosure* soc) {
-  _shared_table.serialize_header(soc);
-
+void SymbolTable::serialize_shared_table_header(SerializeClosure* soc,
+                                                bool is_static_archive) {
+  OffsetCompactHashtable<const char*, Symbol*, symbol_equals_compact_hashtable_entry> * table;
+  if (is_static_archive) {
+    table = &_shared_table;
+  } else {
+    table = &_dynamic_shared_table;
+  }
+  table->serialize_header(soc);
   if (soc->writing()) {
     // Sanity. Make sure we don't use the shared table at dump time
-    _shared_table.reset();
+    table->reset();
   }
 }
 #endif //INCLUDE_CDS
 
 // Concurrent work
@@ -672,15 +718,15 @@
       {
         ThreadBlockInVM tbivm(jt);
       }
       bdt.cont(jt);
     }
-    SymbolTable::the_table()->reset_has_items_to_clean();
+    reset_has_items_to_clean();
     bdt.done(jt);
   }
 
-  Atomic::add(stdc._processed, &_symbols_counted);
+  Atomic::add(&_symbols_counted, stdc._processed);
 
   log_debug(symboltable)("Cleaned " SIZE_FORMAT " of " SIZE_FORMAT,
                          stdd._deleted, stdc._processed);
 }
 
@@ -696,11 +742,11 @@
                            get_load_factor(), has_items_to_clean() ? "true" : "false");
     trigger_cleanup();
   }
 }
 
-void SymbolTable::concurrent_work(JavaThread* jt) {
+void SymbolTable::do_concurrent_work(JavaThread* jt) {
   double load_factor = get_load_factor();
   log_debug(symboltable, perf)("Concurrent work, live factor: %g", load_factor);
   // We prefer growing, since that also removes dead items
   if (load_factor > PREF_AVG_LIST_LEN && !_local_table->is_max_size_reached()) {
     grow(jt);
@@ -708,22 +754,19 @@
     clean_dead_entries(jt);
   }
   _has_work = false;
 }
 
-void SymbolTable::do_concurrent_work(JavaThread* jt) {
-  SymbolTable::the_table()->concurrent_work(jt);
-}
-
 // Rehash
 bool SymbolTable::do_rehash() {
   if (!_local_table->is_safepoint_safe()) {
     return false;
   }
 
-  // We use max size
-  SymbolTableHash* new_table = new SymbolTableHash(END_SIZE, END_SIZE, REHASH_LEN);
+  // We use current size
+  size_t new_size = _local_table->get_size_log2(Thread::current());
+  SymbolTableHash* new_table = new SymbolTableHash(new_size, END_SIZE, REHASH_LEN);
   // Use alt hash from now on
   _alt_hash = true;
   if (!_local_table->try_move_nodes_to(Thread::current(), new_table)) {
     _alt_hash = false;
     delete new_table;
@@ -735,11 +778,11 @@
   _local_table = new_table;
 
   return true;
 }
 
-void SymbolTable::try_rehash_table() {
+void SymbolTable::rehash_table() {
   static bool rehashed = false;
   log_debug(symboltable)("Table imbalanced, rehashing called.");
 
   // Grow instead of rehash.
   if (get_load_factor() > PREF_AVG_LIST_LEN &&
@@ -767,14 +810,10 @@
   }
 
   _needs_rehashing = false;
 }
 
-void SymbolTable::rehash_table() {
-  SymbolTable::the_table()->try_rehash_table();
-}
-
 //---------------------------------------------------------------------------
 // Non-product code
 
 #ifndef PRODUCT
 
@@ -818,22 +857,21 @@
     return true;
   };
 };
 
 void SymbolTable::print_histogram() {
-  SymbolTable* st = SymbolTable::the_table();
   HistogramIterator hi;
-  st->_local_table->do_scan(Thread::current(), hi);
+  _local_table->do_scan(Thread::current(), hi);
   tty->print_cr("Symbol Table Histogram:");
   tty->print_cr("  Total number of symbols  " SIZE_FORMAT_W(7), hi.total_count);
   tty->print_cr("  Total size in memory     " SIZE_FORMAT_W(7) "K",
           (hi.total_size * wordSize) / 1024);
-  tty->print_cr("  Total counted            " SIZE_FORMAT_W(7), st->_symbols_counted);
-  tty->print_cr("  Total removed            " SIZE_FORMAT_W(7), st->_symbols_removed);
-  if (SymbolTable::the_table()->_symbols_counted > 0) {
+  tty->print_cr("  Total counted            " SIZE_FORMAT_W(7), _symbols_counted);
+  tty->print_cr("  Total removed            " SIZE_FORMAT_W(7), _symbols_removed);
+  if (_symbols_counted > 0) {
     tty->print_cr("  Percent removed          %3.2f",
-          ((float)st->_symbols_removed / st->_symbols_counted) * 100);
+          ((float)_symbols_removed / _symbols_counted) * 100);
   }
   tty->print_cr("  Reference counts         " SIZE_FORMAT_W(7), Symbol::_total_count);
   tty->print_cr("  Symbol arena used        " SIZE_FORMAT_W(7) "K", arena()->used() / 1024);
   tty->print_cr("  Symbol arena size        " SIZE_FORMAT_W(7) "K", arena()->size_in_bytes() / 1024);
   tty->print_cr("  Total symbol length      " SIZE_FORMAT_W(7), hi.total_length);

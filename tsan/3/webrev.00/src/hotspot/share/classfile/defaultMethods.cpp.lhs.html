<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/defaultMethods.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/bytecodeAssembler.hpp&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logStream.hpp&quot;
  32 #include &quot;memory/allocation.hpp&quot;
  33 #include &quot;memory/metadataFactory.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
  35 #include &quot;runtime/handles.inline.hpp&quot;
  36 #include &quot;runtime/signature.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;oops/instanceKlass.hpp&quot;
  39 #include &quot;oops/klass.hpp&quot;
  40 #include &quot;oops/method.hpp&quot;
  41 #include &quot;utilities/accessFlags.hpp&quot;
  42 #include &quot;utilities/exceptions.hpp&quot;
  43 #include &quot;utilities/ostream.hpp&quot;
  44 #include &quot;utilities/pair.hpp&quot;
  45 #include &quot;utilities/resourceHash.hpp&quot;
  46 
  47 typedef enum { QUALIFIED, DISQUALIFIED } QualifiedState;
  48 
<a name="3" id="anc3"></a><span class="line-removed">  49 // Because we use an iterative algorithm when iterating over the type</span>
<span class="line-removed">  50 // hierarchy, we can&#39;t use traditional scoped objects which automatically do</span>
<span class="line-removed">  51 // cleanup in the destructor when the scope is exited.  PseudoScope (and</span>
<span class="line-removed">  52 // PseudoScopeMark) provides a similar functionality, but for when you want a</span>
<span class="line-removed">  53 // scoped object in non-stack memory (such as in resource memory, as we do</span>
<span class="line-removed">  54 // here).  You&#39;ve just got to remember to call &#39;destroy()&#39; on the scope when</span>
<span class="line-removed">  55 // leaving it (and marks have to be explicitly added).</span>
<span class="line-removed">  56 class PseudoScopeMark : public ResourceObj {</span>
<span class="line-removed">  57  public:</span>
<span class="line-removed">  58   virtual void destroy() = 0;</span>
<span class="line-removed">  59 };</span>
<span class="line-removed">  60 </span>
<span class="line-removed">  61 class PseudoScope : public ResourceObj {</span>
<span class="line-removed">  62  private:</span>
<span class="line-removed">  63   GrowableArray&lt;PseudoScopeMark*&gt; _marks;</span>
<span class="line-removed">  64  public:</span>
<span class="line-removed">  65 </span>
<span class="line-removed">  66   static PseudoScope* cast(void* data) {</span>
<span class="line-removed">  67     return static_cast&lt;PseudoScope*&gt;(data);</span>
<span class="line-removed">  68   }</span>
<span class="line-removed">  69 </span>
<span class="line-removed">  70   void add_mark(PseudoScopeMark* psm) {</span>
<span class="line-removed">  71    _marks.append(psm);</span>
<span class="line-removed">  72   }</span>
<span class="line-removed">  73 </span>
<span class="line-removed">  74   void destroy() {</span>
<span class="line-removed">  75     for (int i = 0; i &lt; _marks.length(); ++i) {</span>
<span class="line-removed">  76       _marks.at(i)-&gt;destroy();</span>
<span class="line-removed">  77     }</span>
<span class="line-removed">  78   }</span>
<span class="line-removed">  79 };</span>
<span class="line-removed">  80 </span>
  81 static void print_slot(outputStream* str, Symbol* name, Symbol* signature) {
  82   str-&gt;print(&quot;%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
  83 }
  84 
  85 static void print_method(outputStream* str, Method* mo, bool with_class=true) {
  86   if (with_class) {
  87     str-&gt;print(&quot;%s.&quot;, mo-&gt;klass_name()-&gt;as_C_string());
  88   }
  89   print_slot(str, mo-&gt;name(), mo-&gt;signature());
  90 }
  91 
  92 /**
  93  * Perform a depth-first iteration over the class hierarchy, applying
  94  * algorithmic logic as it goes.
  95  *
  96  * This class is one half of the inheritance hierarchy analysis mechanism.
  97  * It is meant to be used in conjunction with another class, the algorithm,
  98  * which is indicated by the ALGO template parameter.  This class can be
  99  * paired with any algorithm class that provides the required methods.
 100  *
 101  * This class contains all the mechanics for iterating over the class hierarchy
 102  * starting at a particular root, without recursing (thus limiting stack growth
 103  * from this point).  It visits each superclass (if present) and superinterface
 104  * in a depth-first manner, with callbacks to the ALGO class as each class is
 105  * encountered (visit()), The algorithm can cut-off further exploration of a
 106  * particular branch by returning &#39;false&#39; from a visit() call.
 107  *
 108  * The ALGO class, must provide a visit() method, which each of which will be
 109  * called once for each node in the inheritance tree during the iteration.  In
<a name="4" id="anc4"></a><span class="line-modified"> 110  * addition, it can provide a memory block via new_node_data(InstanceKlass*),</span>
<span class="line-modified"> 111  * which it can use for node-specific storage (and access via the</span>
<span class="line-modified"> 112  * current_data() and data_at_depth(int) methods).</span>
 113  *
 114  * Bare minimum needed to be an ALGO class:
 115  * class Algo : public HierarchyVisitor&lt;Algo&gt; {
<a name="5" id="anc5"></a><span class="line-modified"> 116  *   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 117  *   void free_node_data(void* data) { return; }
 118  *   bool visit() { return true; }
 119  * };
 120  */
 121 template &lt;class ALGO&gt;
 122 class HierarchyVisitor : StackObj {
 123  private:
 124 
 125   class Node : public ResourceObj {
 126    public:
 127     InstanceKlass* _class;
 128     bool _super_was_visited;
 129     int _interface_index;
 130     void* _algorithm_data;
 131 
 132     Node(InstanceKlass* cls, void* data, bool visit_super)
 133         : _class(cls), _super_was_visited(!visit_super),
 134           _interface_index(0), _algorithm_data(data) {}
 135 
<a name="6" id="anc6"></a>





 136     int number_of_interfaces() { return _class-&gt;local_interfaces()-&gt;length(); }
 137     int interface_index() { return _interface_index; }
 138     void set_super_visited() { _super_was_visited = true; }
 139     void increment_visited_interface() { ++_interface_index; }
 140     void set_all_interfaces_visited() {
 141       _interface_index = number_of_interfaces();
 142     }
 143     bool has_visited_super() { return _super_was_visited; }
 144     bool has_visited_all_interfaces() {
 145       return interface_index() &gt;= number_of_interfaces();
 146     }
 147     InstanceKlass* interface_at(int index) {
<a name="7" id="anc7"></a><span class="line-modified"> 148       return InstanceKlass::cast(_class-&gt;local_interfaces()-&gt;at(index));</span>
 149     }
 150     InstanceKlass* next_super() { return _class-&gt;java_super(); }
 151     InstanceKlass* next_interface() {
 152       return interface_at(interface_index());
 153     }
 154   };
 155 
 156   bool _visited_Object;
<a name="8" id="anc8"></a>
 157   GrowableArray&lt;Node*&gt; _path;
<a name="9" id="anc9"></a>
 158 
 159   Node* current_top() const { return _path.top(); }
<a name="10" id="anc10"></a><span class="line-modified"> 160   bool has_more_nodes() const { return !_path.is_empty(); }</span>
<span class="line-modified"> 161   void push(InstanceKlass* cls, void* data) {</span>
 162     assert(cls != NULL, &quot;Requires a valid instance class&quot;);
<a name="11" id="anc11"></a><span class="line-removed"> 163     Node* node = new Node(cls, data, has_super(cls));</span>
 164     if (cls == SystemDictionary::Object_klass()) {
 165       _visited_Object = true;
 166     }
<a name="12" id="anc12"></a>







 167     _path.push(node);
 168   }
<a name="13" id="anc13"></a><span class="line-modified"> 169   void pop() { _path.pop(); }</span>




 170 
 171   // Since the starting point can be an interface, we must ensure we catch
 172   // j.l.Object as the super once in those cases. The _visited_Object flag
 173   // only ensures we don&#39;t then repeatedly enqueue Object for each interface
 174   // in the class hierarchy.
 175   bool has_super(InstanceKlass* cls) {
 176     return cls-&gt;super() != NULL &amp;&amp; (!_visited_Object || !cls-&gt;is_interface());
 177   }
 178 
 179   Node* node_at_depth(int i) const {
 180     return (i &gt;= _path.length()) ? NULL : _path.at(_path.length() - i - 1);
 181   }
 182 
 183  protected:
 184 
<a name="14" id="anc14"></a>




 185   // Accessors available to the algorithm
 186   int current_depth() const { return _path.length() - 1; }
 187 
 188   InstanceKlass* class_at_depth(int i) {
 189     Node* n = node_at_depth(i);
 190     return n == NULL ? NULL : n-&gt;_class;
 191   }
 192   InstanceKlass* current_class() { return class_at_depth(0); }
 193 
 194   void* data_at_depth(int i) {
 195     Node* n = node_at_depth(i);
 196     return n == NULL ? NULL : n-&gt;_algorithm_data;
 197   }
 198   void* current_data() { return data_at_depth(0); }
 199 
 200  public:
<a name="15" id="anc15"></a>
 201 
 202   void run(InstanceKlass* root) {
 203     ALGO* algo = static_cast&lt;ALGO*&gt;(this);
 204 
<a name="16" id="anc16"></a><span class="line-modified"> 205     void* algo_data = algo-&gt;new_node_data(root);</span>
<span class="line-removed"> 206     push(root, algo_data);</span>
 207     bool top_needs_visit = true;
<a name="17" id="anc17"></a><span class="line-removed"> 208 </span>
 209     do {
 210       Node* top = current_top();
 211       if (top_needs_visit) {
 212         if (algo-&gt;visit() == false) {
 213           // algorithm does not want to continue along this path.  Arrange
 214           // it so that this state is immediately popped off the stack
 215           top-&gt;set_super_visited();
 216           top-&gt;set_all_interfaces_visited();
 217         }
 218         top_needs_visit = false;
 219       }
 220 
 221       if (top-&gt;has_visited_super() &amp;&amp; top-&gt;has_visited_all_interfaces()) {
 222         algo-&gt;free_node_data(top-&gt;_algorithm_data);
 223         pop();
 224       } else {
 225         InstanceKlass* next = NULL;
 226         if (top-&gt;has_visited_super() == false) {
 227           next = top-&gt;next_super();
 228           top-&gt;set_super_visited();
 229         } else {
 230           next = top-&gt;next_interface();
 231           top-&gt;increment_visited_interface();
 232         }
 233         assert(next != NULL, &quot;Otherwise we shouldn&#39;t be here&quot;);
<a name="18" id="anc18"></a><span class="line-modified"> 234         algo_data = algo-&gt;new_node_data(next);</span>
<span class="line-removed"> 235         push(next, algo_data);</span>
 236         top_needs_visit = true;
 237       }
 238     } while (has_more_nodes());
 239   }
 240 };
 241 
 242 class PrintHierarchy : public HierarchyVisitor&lt;PrintHierarchy&gt; {
 243  private:
 244    outputStream* _st;
 245  public:
 246   bool visit() {
 247     InstanceKlass* cls = current_class();
 248     streamIndentor si(_st, current_depth() * 2);
 249     _st-&gt;indent().print_cr(&quot;%s&quot;, cls-&gt;name()-&gt;as_C_string());
 250     return true;
 251   }
 252 
<a name="19" id="anc19"></a><span class="line-modified"> 253   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 254   void free_node_data(void* data) { return; }
 255 
 256   PrintHierarchy(outputStream* st = tty) : _st(st) {}
 257 };
 258 
 259 // Used to register InstanceKlass objects and all related metadata structures
 260 // (Methods, ConstantPools) as &quot;in-use&quot; by the current thread so that they can&#39;t
 261 // be deallocated by class redefinition while we&#39;re using them.  The classes are
 262 // de-registered when this goes out of scope.
 263 //
 264 // Once a class is registered, we need not bother with methodHandles or
 265 // constantPoolHandles for it&#39;s associated metadata.
 266 class KeepAliveRegistrar : public StackObj {
 267  private:
 268   Thread* _thread;
 269   GrowableArray&lt;ConstantPool*&gt; _keep_alive;
 270 
 271  public:
<a name="20" id="anc20"></a><span class="line-modified"> 272   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(20) {</span>
 273     assert(thread == Thread::current(), &quot;Must be current thread&quot;);
 274   }
 275 
 276   ~KeepAliveRegistrar() {
 277     for (int i = _keep_alive.length() - 1; i &gt;= 0; --i) {
 278       ConstantPool* cp = _keep_alive.at(i);
 279       int idx = _thread-&gt;metadata_handles()-&gt;find_from_end(cp);
 280       assert(idx &gt; 0, &quot;Must be in the list&quot;);
 281       _thread-&gt;metadata_handles()-&gt;remove_at(idx);
 282     }
 283   }
 284 
 285   // Register a class as &#39;in-use&#39; by the thread.  It&#39;s fine to register a class
 286   // multiple times (though perhaps inefficient)
 287   void register_class(InstanceKlass* ik) {
 288     ConstantPool* cp = ik-&gt;constants();
 289     _keep_alive.push(cp);
 290     _thread-&gt;metadata_handles()-&gt;push(cp);
 291   }
 292 };
 293 
 294 class KeepAliveVisitor : public HierarchyVisitor&lt;KeepAliveVisitor&gt; {
 295  private:
 296   KeepAliveRegistrar* _registrar;
 297 
 298  public:
 299   KeepAliveVisitor(KeepAliveRegistrar* registrar) : _registrar(registrar) {}
 300 
<a name="21" id="anc21"></a><span class="line-modified"> 301   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 302   void free_node_data(void* data) { return; }
 303 
 304   bool visit() {
 305     _registrar-&gt;register_class(current_class());
 306     return true;
 307   }
 308 };
 309 
 310 
 311 // A method family contains a set of all methods that implement a single
 312 // erased method. As members of the set are collected while walking over the
 313 // hierarchy, they are tagged with a qualification state.  The qualification
 314 // state for an erased method is set to disqualified if there exists a path
 315 // from the root of hierarchy to the method that contains an interleaving
 316 // erased method defined in an interface.
 317 
<a name="22" id="anc22"></a>








 318 class MethodFamily : public ResourceObj {
 319  private:
 320 
<a name="23" id="anc23"></a><span class="line-modified"> 321   GrowableArray&lt;Pair&lt;Method*,QualifiedState&gt; &gt; _members;</span>
<span class="line-removed"> 322   ResourceHashtable&lt;Method*, int&gt; _member_index;</span>
 323 
 324   Method* _selected_target;  // Filled in later, if a unique target exists
 325   Symbol* _exception_message; // If no unique target is found
 326   Symbol* _exception_name;    // If no unique target is found
 327 
<a name="24" id="anc24"></a><span class="line-modified"> 328   bool contains_method(Method* method) {</span>
<span class="line-modified"> 329     int* lookup = _member_index.get(method);</span>
<span class="line-modified"> 330     return lookup != NULL;</span>




 331   }
 332 
 333   void add_method(Method* method, QualifiedState state) {
<a name="25" id="anc25"></a><span class="line-modified"> 334     Pair&lt;Method*,QualifiedState&gt; entry(method, state);</span>
<span class="line-modified"> 335     _member_index.put(method, _members.length());</span>
<span class="line-removed"> 336     _members.append(entry);</span>
<span class="line-removed"> 337   }</span>
<span class="line-removed"> 338 </span>
<span class="line-removed"> 339   void disqualify_method(Method* method) {</span>
<span class="line-removed"> 340     int* index = _member_index.get(method);</span>
<span class="line-removed"> 341     guarantee(index != NULL &amp;&amp; *index &gt;= 0 &amp;&amp; *index &lt; _members.length(), &quot;bad index&quot;);</span>
<span class="line-removed"> 342     _members.at(*index).second = DISQUALIFIED;</span>
 343   }
 344 
 345   Symbol* generate_no_defaults_message(TRAPS) const;
 346   Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;
<a name="26" id="anc26"></a><span class="line-modified"> 347   Symbol* generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const;</span>
 348 
 349  public:
 350 
 351   MethodFamily()
 352       : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}
 353 
 354   void set_target_if_empty(Method* m) {
 355     if (_selected_target == NULL &amp;&amp; !m-&gt;is_overpass()) {
 356       _selected_target = m;
 357     }
 358   }
 359 
<a name="27" id="anc27"></a><span class="line-modified"> 360   void record_qualified_method(Method* m) {</span>
<span class="line-modified"> 361     // If the method already exists in the set as qualified, this operation is</span>
<span class="line-modified"> 362     // redundant.  If it already exists as disqualified, then we leave it as</span>
<span class="line-modified"> 363     // disqualfied.  Thus we only add to the set if it&#39;s not already in the</span>
<span class="line-modified"> 364     // set.</span>
<span class="line-modified"> 365     if (!contains_method(m)) {</span>
<span class="line-modified"> 366       add_method(m, QUALIFIED);</span>
<span class="line-modified"> 367     }</span>
<span class="line-modified"> 368   }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370   void record_disqualified_method(Method* m) {</span>
<span class="line-removed"> 371     // If not in the set, add it as disqualified.  If it&#39;s already in the set,</span>
<span class="line-removed"> 372     // then set the state to disqualified no matter what the previous state was.</span>
<span class="line-removed"> 373     if (!contains_method(m)) {</span>
<span class="line-removed"> 374       add_method(m, DISQUALIFIED);</span>
<span class="line-removed"> 375     } else {</span>
<span class="line-removed"> 376       disqualify_method(m);</span>
 377     }
 378   }
 379 
 380   bool has_target() const { return _selected_target != NULL; }
 381   bool throws_exception() { return _exception_message != NULL; }
 382 
 383   Method* get_selected_target() { return _selected_target; }
 384   Symbol* get_exception_message() { return _exception_message; }
 385   Symbol* get_exception_name() { return _exception_name; }
 386 
 387   // Either sets the target or the exception error message
<a name="28" id="anc28"></a><span class="line-modified"> 388   void determine_target(InstanceKlass* root, TRAPS) {</span>
 389     if (has_target() || throws_exception()) {
 390       return;
 391     }
 392 
 393     // Qualified methods are maximally-specific methods
 394     // These include public, instance concrete (=default) and abstract methods
<a name="29" id="anc29"></a><span class="line-removed"> 395     GrowableArray&lt;Method*&gt; qualified_methods;</span>
 396     int num_defaults = 0;
 397     int default_index = -1;
<a name="30" id="anc30"></a><span class="line-modified"> 398     int qualified_index = -1;</span>
<span class="line-modified"> 399     for (int i = 0; i &lt; _members.length(); ++i) {</span>
<span class="line-modified"> 400       Pair&lt;Method*,QualifiedState&gt; entry = _members.at(i);</span>
<span class="line-modified"> 401       if (entry.second == QUALIFIED) {</span>
<span class="line-removed"> 402         qualified_methods.append(entry.first);</span>
<span class="line-removed"> 403         qualified_index++;</span>
<span class="line-removed"> 404         if (entry.first-&gt;is_default_method()) {</span>
 405           num_defaults++;
<a name="31" id="anc31"></a><span class="line-modified"> 406           default_index = qualified_index;</span>
<span class="line-removed"> 407 </span>
 408         }
 409       }
 410     }
 411 
<a name="32" id="anc32"></a>

















 412     if (num_defaults == 0) {
 413       // If the root klass has a static method with matching name and signature
 414       // then do not generate an overpass method because it will hide the
 415       // static method during resolution.
 416       if (qualified_methods.length() == 0) {
 417         _exception_message = generate_no_defaults_message(CHECK);
 418       } else {
 419         assert(root != NULL, &quot;Null root class&quot;);
 420         _exception_message = generate_method_message(root-&gt;name(), qualified_methods.at(0), CHECK);
 421       }
 422       _exception_name = vmSymbols::java_lang_AbstractMethodError();
<a name="33" id="anc33"></a><span class="line-modified"> 423 </span>
<span class="line-modified"> 424     // If only one qualified method is default, select that</span>
<span class="line-removed"> 425     } else if (num_defaults == 1) {</span>
<span class="line-removed"> 426         _selected_target = qualified_methods.at(default_index);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428     } else if (num_defaults &gt; 1) {</span>
<span class="line-removed"> 429       _exception_message = generate_conflicts_message(&amp;qualified_methods,CHECK);</span>
 430       _exception_name = vmSymbols::java_lang_IncompatibleClassChangeError();
 431       LogTarget(Debug, defaultmethods) lt;
 432       if (lt.is_enabled()) {
 433         LogStream ls(lt);
 434         _exception_message-&gt;print_value_on(&amp;ls);
 435         ls.cr();
 436       }
 437     }
 438   }
 439 
 440   void print_selected(outputStream* str, int indent) const {
 441     assert(has_target(), &quot;Should be called otherwise&quot;);
 442     streamIndentor si(str, indent * 2);
 443     str-&gt;indent().print(&quot;Selected method: &quot;);
 444     print_method(str, _selected_target);
 445     Klass* method_holder = _selected_target-&gt;method_holder();
 446     if (!method_holder-&gt;is_interface()) {
 447       str-&gt;print(&quot; : in superclass&quot;);
 448     }
 449     str-&gt;cr();
 450   }
 451 
 452   void print_exception(outputStream* str, int indent) {
 453     assert(throws_exception(), &quot;Should be called otherwise&quot;);
 454     assert(_exception_name != NULL, &quot;exception_name should be set&quot;);
 455     streamIndentor si(str, indent * 2);
 456     str-&gt;indent().print_cr(&quot;%s: %s&quot;, _exception_name-&gt;as_C_string(), _exception_message-&gt;as_C_string());
 457   }
 458 };
 459 
 460 Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {
<a name="34" id="anc34"></a><span class="line-modified"> 461   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;, THREAD);</span>
 462 }
 463 
 464 Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {
 465   stringStream ss;
 466   ss.print(&quot;Method &quot;);
 467   Symbol* name = method-&gt;name();
 468   Symbol* signature = method-&gt;signature();
 469   ss.write((const char*)klass_name-&gt;bytes(), klass_name-&gt;utf8_length());
 470   ss.print(&quot;.&quot;);
 471   ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());
 472   ss.write((const char*)signature-&gt;bytes(), signature-&gt;utf8_length());
 473   ss.print(&quot; is abstract&quot;);
<a name="35" id="anc35"></a><span class="line-modified"> 474   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
 475 }
 476 
<a name="36" id="anc36"></a><span class="line-modified"> 477 Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const {</span>
 478   stringStream ss;
 479   ss.print(&quot;Conflicting default methods:&quot;);
 480   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
<a name="37" id="anc37"></a><span class="line-modified"> 481     Method* method = methods-&gt;at(i);</span>
<span class="line-modified"> 482     Symbol* klass = method-&gt;klass_name();</span>
<span class="line-modified"> 483     Symbol* name = method-&gt;name();</span>
 484     ss.print(&quot; &quot;);
<a name="38" id="anc38"></a><span class="line-modified"> 485     ss.write((const char*)klass-&gt;bytes(), klass-&gt;utf8_length());</span>
 486     ss.print(&quot;.&quot;);
<a name="39" id="anc39"></a><span class="line-modified"> 487     ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());</span>
 488   }
<a name="40" id="anc40"></a><span class="line-modified"> 489   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
 490 }
 491 
 492 
<a name="41" id="anc41"></a><span class="line-modified"> 493 class StateRestorer;</span>
 494 
 495 // StatefulMethodFamily is a wrapper around a MethodFamily that maintains the
 496 // qualification state during hierarchy visitation, and applies that state
 497 // when adding members to the MethodFamily
 498 class StatefulMethodFamily : public ResourceObj {
 499   friend class StateRestorer;
 500  private:
 501   QualifiedState _qualification_state;
 502 
 503   void set_qualification_state(QualifiedState state) {
 504     _qualification_state = state;
 505   }
 506 
 507  protected:
 508   MethodFamily _method_family;
 509 
 510  public:
 511   StatefulMethodFamily() {
 512    _qualification_state = QUALIFIED;
 513   }
 514 
 515   void set_target_if_empty(Method* m) { _method_family.set_target_if_empty(m); }
 516 
 517   MethodFamily* get_method_family() { return &amp;_method_family; }
 518 
<a name="42" id="anc42"></a><span class="line-modified"> 519   StateRestorer* record_method_and_dq_further(Method* mo);</span>
 520 };
 521 
<a name="43" id="anc43"></a><span class="line-modified"> 522 class StateRestorer : public PseudoScopeMark {</span>
<span class="line-modified"> 523  private:</span>








 524   StatefulMethodFamily* _method;
 525   QualifiedState _state_to_restore;
<a name="44" id="anc44"></a><span class="line-modified"> 526  public:</span>
<span class="line-modified"> 527   StateRestorer(StatefulMethodFamily* dm, QualifiedState state)</span>
<span class="line-modified"> 528       : _method(dm), _state_to_restore(state) {}</span>
<span class="line-removed"> 529   ~StateRestorer() { destroy(); }</span>
 530   void restore_state() { _method-&gt;set_qualification_state(_state_to_restore); }
<a name="45" id="anc45"></a><span class="line-removed"> 531   virtual void destroy() { restore_state(); }</span>
 532 };
 533 
<a name="46" id="anc46"></a><span class="line-modified"> 534 StateRestorer* StatefulMethodFamily::record_method_and_dq_further(Method* mo) {</span>
<span class="line-modified"> 535   StateRestorer* mark = new StateRestorer(this, _qualification_state);</span>
<span class="line-modified"> 536   if (_qualification_state == QUALIFIED) {</span>
<span class="line-modified"> 537     _method_family.record_qualified_method(mo);</span>
<span class="line-modified"> 538   } else {</span>
<span class="line-modified"> 539     _method_family.record_disqualified_method(mo);</span>



 540   }
<a name="47" id="anc47"></a>































 541   // Everything found &quot;above&quot;??? this method in the hierarchy walk is set to
 542   // disqualified
 543   set_qualification_state(DISQUALIFIED);
<a name="48" id="anc48"></a><span class="line-removed"> 544   return mark;</span>
 545 }
 546 
 547 // Represents a location corresponding to a vtable slot for methods that
 548 // neither the class nor any of it&#39;s ancestors provide an implementaion.
 549 // Default methods may be present to fill this slot.
 550 class EmptyVtableSlot : public ResourceObj {
 551  private:
 552   Symbol* _name;
 553   Symbol* _signature;
 554   int _size_of_parameters;
 555   MethodFamily* _binding;
 556 
 557  public:
 558   EmptyVtableSlot(Method* method)
 559       : _name(method-&gt;name()), _signature(method-&gt;signature()),
 560         _size_of_parameters(method-&gt;size_of_parameters()), _binding(NULL) {}
 561 
 562   Symbol* name() const { return _name; }
 563   Symbol* signature() const { return _signature; }
 564   int size_of_parameters() const { return _size_of_parameters; }
 565 
 566   void bind_family(MethodFamily* lm) { _binding = lm; }
 567   bool is_bound() { return _binding != NULL; }
 568   MethodFamily* get_binding() { return _binding; }
 569 
 570   void print_on(outputStream* str) const {
 571     print_slot(str, name(), signature());
 572   }
 573 };
 574 
 575 static bool already_in_vtable_slots(GrowableArray&lt;EmptyVtableSlot*&gt;* slots, Method* m) {
 576   bool found = false;
 577   for (int j = 0; j &lt; slots-&gt;length(); ++j) {
 578     if (slots-&gt;at(j)-&gt;name() == m-&gt;name() &amp;&amp;
 579         slots-&gt;at(j)-&gt;signature() == m-&gt;signature() ) {
 580       found = true;
 581       break;
 582     }
 583   }
 584   return found;
 585 }
 586 
 587 static void find_empty_vtable_slots(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 588     InstanceKlass* klass, const GrowableArray&lt;Method*&gt;* mirandas, TRAPS) {
 589 
 590   assert(klass != NULL, &quot;Must be valid class&quot;);
 591 
 592   // All miranda methods are obvious candidates
 593   for (int i = 0; i &lt; mirandas-&gt;length(); ++i) {
 594     Method* m = mirandas-&gt;at(i);
 595     if (!already_in_vtable_slots(slots, m)) {
 596       slots-&gt;append(new EmptyVtableSlot(m));
 597     }
 598   }
 599 
 600   // Also any overpasses in our superclasses, that we haven&#39;t implemented.
 601   // (can&#39;t use the vtable because it is not guaranteed to be initialized yet)
 602   InstanceKlass* super = klass-&gt;java_super();
 603   while (super != NULL) {
 604     for (int i = 0; i &lt; super-&gt;methods()-&gt;length(); ++i) {
 605       Method* m = super-&gt;methods()-&gt;at(i);
 606       if (m-&gt;is_overpass() || m-&gt;is_static()) {
 607         // m is a method that would have been a miranda if not for the
 608         // default method processing that occurred on behalf of our superclass,
 609         // so it&#39;s a method we want to re-examine in this new context.  That is,
 610         // unless we have a real implementation of it in the current class.
 611         if (!already_in_vtable_slots(slots, m)) {
 612           Method *impl = klass-&gt;lookup_method(m-&gt;name(), m-&gt;signature());
 613           if (impl == NULL || impl-&gt;is_overpass() || impl-&gt;is_static()) {
 614             slots-&gt;append(new EmptyVtableSlot(m));
 615           }
 616         }
 617       }
 618     }
 619 
 620     // also any default methods in our superclasses
 621     if (super-&gt;default_methods() != NULL) {
 622       for (int i = 0; i &lt; super-&gt;default_methods()-&gt;length(); ++i) {
 623         Method* m = super-&gt;default_methods()-&gt;at(i);
 624         // m is a method that would have been a miranda if not for the
 625         // default method processing that occurred on behalf of our superclass,
 626         // so it&#39;s a method we want to re-examine in this new context.  That is,
 627         // unless we have a real implementation of it in the current class.
 628         if (!already_in_vtable_slots(slots, m)) {
 629           Method* impl = klass-&gt;lookup_method(m-&gt;name(), m-&gt;signature());
 630           if (impl == NULL || impl-&gt;is_overpass() || impl-&gt;is_static()) {
 631             slots-&gt;append(new EmptyVtableSlot(m));
 632           }
 633         }
 634       }
 635     }
 636     super = super-&gt;java_super();
 637   }
 638 
 639   LogTarget(Debug, defaultmethods) lt;
 640   if (lt.is_enabled()) {
 641     lt.print(&quot;Slots that need filling:&quot;);
 642     ResourceMark rm;
 643     LogStream ls(lt);
 644     streamIndentor si(&amp;ls);
 645     for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 646       ls.indent();
 647       slots-&gt;at(i)-&gt;print_on(&amp;ls);
 648       ls.cr();
 649     }
 650   }
 651 }
 652 
 653 // Iterates over the superinterface type hierarchy looking for all methods
 654 // with a specific erased signature.
 655 class FindMethodsByErasedSig : public HierarchyVisitor&lt;FindMethodsByErasedSig&gt; {
 656  private:
 657   // Context data
 658   Symbol* _method_name;
 659   Symbol* _method_signature;
 660   StatefulMethodFamily*  _family;
 661   bool _cur_class_is_interface;
<a name="49" id="anc49"></a><span class="line-modified"> 662 </span>


 663  public:
<a name="50" id="anc50"></a><span class="line-modified"> 664   FindMethodsByErasedSig(Symbol* name, Symbol* signature, bool is_interf) :</span>
<span class="line-modified"> 665       _method_name(name), _method_signature(signature), _family(NULL),</span>
<span class="line-modified"> 666       _cur_class_is_interface(is_interf) {}</span>






 667 
 668   void get_discovered_family(MethodFamily** family) {
 669       if (_family != NULL) {
 670         *family = _family-&gt;get_method_family();
 671       } else {
 672         *family = NULL;
 673       }
 674   }
 675 
<a name="51" id="anc51"></a><span class="line-modified"> 676   void* new_node_data(InstanceKlass* cls) { return new PseudoScope(); }</span>







 677   void free_node_data(void* node_data) {
<a name="52" id="anc52"></a><span class="line-modified"> 678     PseudoScope::cast(node_data)-&gt;destroy();</span>



 679   }
 680 
 681   // Find all methods on this hierarchy that match this
 682   // method&#39;s erased (name, signature)
 683   bool visit() {
<a name="53" id="anc53"></a><span class="line-modified"> 684     PseudoScope* scope = PseudoScope::cast(current_data());</span>
 685     InstanceKlass* iklass = current_class();
 686 
 687     Method* m = iklass-&gt;find_method(_method_name, _method_signature);
 688     // Private interface methods are not candidates for default methods.
 689     // invokespecial to private interface methods doesn&#39;t use default method logic.
 690     // Private class methods are not candidates for default methods.
 691     // Private methods do not override default methods, so need to perform
 692     // default method inheritance without including private methods.
 693     // The overpasses are your supertypes&#39; errors, we do not include them.
 694     // Non-public methods in java.lang.Object are not candidates for default
 695     // methods.
 696     // Future: take access controls into account for superclass methods
 697     if (m != NULL &amp;&amp; !m-&gt;is_static() &amp;&amp; !m-&gt;is_overpass() &amp;&amp; !m-&gt;is_private() &amp;&amp;
 698      (!_cur_class_is_interface || !SystemDictionary::is_nonpublic_Object_method(m))) {
 699       if (_family == NULL) {
 700         _family = new StatefulMethodFamily();
 701       }
 702 
 703       if (iklass-&gt;is_interface()) {
<a name="54" id="anc54"></a><span class="line-modified"> 704         StateRestorer* restorer = _family-&gt;record_method_and_dq_further(m);</span>
<span class="line-removed"> 705         scope-&gt;add_mark(restorer);</span>
 706       } else {
 707         // This is the rule that methods in classes &quot;win&quot; (bad word) over
 708         // methods in interfaces. This works because of single inheritance.
 709         // Private methods in classes do not &quot;win&quot;, they will be found
 710         // first on searching, but overriding for invokevirtual needs
 711         // to find default method candidates for the same signature
 712         _family-&gt;set_target_if_empty(m);
 713       }
 714     }
 715     return true;
 716   }
 717 
 718 };
 719 
 720 
 721 
 722 static void create_defaults_and_exceptions(
 723     GrowableArray&lt;EmptyVtableSlot*&gt;* slots, InstanceKlass* klass, TRAPS);
 724 
 725 static void generate_erased_defaults(
<a name="55" id="anc55"></a><span class="line-modified"> 726      InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {</span>

 727 
<a name="56" id="anc56"></a>



 728   // sets up a set of methods with the same exact erased signature
<a name="57" id="anc57"></a><span class="line-modified"> 729   FindMethodsByErasedSig visitor(slot-&gt;name(), slot-&gt;signature(), is_intf);</span>
<span class="line-removed"> 730   visitor.run(klass);</span>
 731 
 732   MethodFamily* family;
<a name="58" id="anc58"></a><span class="line-modified"> 733   visitor.get_discovered_family(&amp;family);</span>
 734   if (family != NULL) {
<a name="59" id="anc59"></a><span class="line-modified"> 735     family-&gt;determine_target(klass, CHECK);</span>
 736     slot-&gt;bind_family(family);
 737   }
 738 }
 739 
 740 static void merge_in_new_methods(InstanceKlass* klass,
 741     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 742 static void create_default_methods( InstanceKlass* klass,
 743     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 744 
 745 // This is the guts of the default methods implementation.  This is called just
 746 // after the classfile has been parsed if some ancestor has default methods.
 747 //
 748 // First it finds any name/signature slots that need any implementation (either
 749 // because they are miranda or a superclass&#39;s implementation is an overpass
 750 // itself).  For each slot, iterate over the hierarchy, to see if they contain a
 751 // signature that matches the slot we are looking at.
 752 //
 753 // For each slot filled, we either record the default method candidate in the
 754 // klass default_methods list or, only to handle exception cases, we create an
 755 // overpass method that throws an exception and add it to the klass methods list.
 756 // The JVM does not create bridges nor handle generic signatures here.
 757 void DefaultMethods::generate_default_methods(
 758     InstanceKlass* klass, const GrowableArray&lt;Method*&gt;* mirandas, TRAPS) {
 759   assert(klass != NULL, &quot;invariant&quot;);
 760   assert(klass != SystemDictionary::Object_klass(), &quot;Shouldn&#39;t be called for Object&quot;);
 761 
 762   // This resource mark is the bound for all memory allocation that takes
 763   // place during default method processing.  After this goes out of scope,
 764   // all (Resource) objects&#39; memory will be reclaimed.  Be careful if adding an
 765   // embedded resource mark under here as that memory can&#39;t be used outside
 766   // whatever scope it&#39;s in.
 767   ResourceMark rm(THREAD);
 768 
 769   // Keep entire hierarchy alive for the duration of the computation
 770   constantPoolHandle cp(THREAD, klass-&gt;constants());
 771   KeepAliveRegistrar keepAlive(THREAD);
 772   KeepAliveVisitor loadKeepAlive(&amp;keepAlive);
 773   loadKeepAlive.run(klass);
 774 
 775   LogTarget(Debug, defaultmethods) lt;
 776   if (lt.is_enabled()) {
 777     ResourceMark rm;
 778     lt.print(&quot;%s %s requires default method processing&quot;,
 779              klass-&gt;is_interface() ? &quot;Interface&quot; : &quot;Class&quot;,
 780              klass-&gt;name()-&gt;as_klass_external_name());
 781     LogStream ls(lt);
 782     PrintHierarchy printer(&amp;ls);
 783     printer.run(klass);
 784   }
 785 
 786   GrowableArray&lt;EmptyVtableSlot*&gt; empty_slots;
 787   find_empty_vtable_slots(&amp;empty_slots, klass, mirandas, CHECK);
 788 
 789   if (empty_slots.length() &gt; 0) {
<a name="60" id="anc60"></a>
 790     for (int i = 0; i &lt; empty_slots.length(); ++i) {
 791       EmptyVtableSlot* slot = empty_slots.at(i);
 792       LogTarget(Debug, defaultmethods) lt;
 793       if (lt.is_enabled()) {
 794         LogStream ls(lt);
 795         streamIndentor si(&amp;ls, 2);
 796         ls.indent().print(&quot;Looking for default methods for slot &quot;);
 797         slot-&gt;print_on(&amp;ls);
 798         ls.cr();
 799       }
<a name="61" id="anc61"></a><span class="line-modified"> 800       generate_erased_defaults(klass, slot, klass-&gt;is_interface(), CHECK);</span>
 801     }
 802     log_debug(defaultmethods)(&quot;Creating defaults and overpasses...&quot;);
 803     create_defaults_and_exceptions(&amp;empty_slots, klass, CHECK);
 804   }
 805   log_debug(defaultmethods)(&quot;Default method processing complete&quot;);
 806 }
 807 
 808 static int assemble_method_error(
 809     BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message, TRAPS) {
 810 
 811   Symbol* init = vmSymbols::object_initializer_name();
 812   Symbol* sig = vmSymbols::string_void_signature();
 813 
 814   BytecodeAssembler assem(buffer, cp);
 815 
 816   assem._new(errorName);
 817   assem.dup();
 818   assem.load_string(message);
 819   assem.invokespecial(errorName, init, sig);
 820   assem.athrow();
 821 
 822   return 3; // max stack size: [ exception, exception, string ]
 823 }
 824 
 825 static Method* new_method(
 826     BytecodeConstantPool* cp, BytecodeBuffer* bytecodes, Symbol* name,
 827     Symbol* sig, AccessFlags flags, int max_stack, int params,
 828     ConstMethod::MethodType mt, TRAPS) {
 829 
 830   address code_start = 0;
 831   int code_length = 0;
 832   InlineTableSizes sizes;
 833 
 834   if (bytecodes != NULL &amp;&amp; bytecodes-&gt;length() &gt; 0) {
 835     code_start = static_cast&lt;address&gt;(bytecodes-&gt;adr_at(0));
 836     code_length = bytecodes-&gt;length();
 837   }
 838 
 839   Method* m = Method::allocate(cp-&gt;pool_holder()-&gt;class_loader_data(),
 840                                code_length, flags, &amp;sizes,
 841                                mt, CHECK_NULL);
 842 
 843   m-&gt;set_constants(NULL); // This will get filled in later
 844   m-&gt;set_name_index(cp-&gt;utf8(name));
 845   m-&gt;set_signature_index(cp-&gt;utf8(sig));
<a name="62" id="anc62"></a><span class="line-modified"> 846   ResultTypeFinder rtf(sig);</span>
<span class="line-removed"> 847   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
 848   m-&gt;set_size_of_parameters(params);
 849   m-&gt;set_max_stack(max_stack);
 850   m-&gt;set_max_locals(params);
 851   m-&gt;constMethod()-&gt;set_stackmap_data(NULL);
 852   m-&gt;set_code(code_start);
 853 
 854   return m;
 855 }
 856 
 857 static void switchover_constant_pool(BytecodeConstantPool* bpool,
 858     InstanceKlass* klass, GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
 859 
 860   if (new_methods-&gt;length() &gt; 0) {
 861     ConstantPool* cp = bpool-&gt;create_constant_pool(CHECK);
 862     if (cp != klass-&gt;constants()) {
 863       // Copy resolved anonymous class into new constant pool.
 864       if (klass-&gt;is_unsafe_anonymous()) {
 865         cp-&gt;klass_at_put(klass-&gt;this_class_index(), klass);
 866       }
 867       klass-&gt;class_loader_data()-&gt;add_to_deallocate_list(klass-&gt;constants());
 868       klass-&gt;set_constants(cp);
 869       cp-&gt;set_pool_holder(klass);
 870 
 871       for (int i = 0; i &lt; new_methods-&gt;length(); ++i) {
 872         new_methods-&gt;at(i)-&gt;set_constants(cp);
 873       }
 874       for (int i = 0; i &lt; klass-&gt;methods()-&gt;length(); ++i) {
 875         Method* mo = klass-&gt;methods()-&gt;at(i);
 876         mo-&gt;set_constants(cp);
 877       }
 878     }
 879   }
 880 }
 881 
 882 // Create default_methods list for the current class.
 883 // With the VM only processing erased signatures, the VM only
 884 // creates an overpass in a conflict case or a case with no candidates.
 885 // This allows virtual methods to override the overpass, but ensures
 886 // that a local method search will find the exception rather than an abstract
 887 // or default method that is not a valid candidate.
 888 //
 889 // Note that if overpass method are ever created that are not exception
 890 // throwing methods then the loader constraint checking logic for vtable and
 891 // itable creation needs to be changed to check loader constraints for the
 892 // overpass methods that do not throw exceptions.
 893 static void create_defaults_and_exceptions(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 894     InstanceKlass* klass, TRAPS) {
 895 
 896   GrowableArray&lt;Method*&gt; overpasses;
 897   GrowableArray&lt;Method*&gt; defaults;
 898   BytecodeConstantPool bpool(klass-&gt;constants());
 899 
<a name="63" id="anc63"></a>
 900   for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 901     EmptyVtableSlot* slot = slots-&gt;at(i);
 902 
 903     if (slot-&gt;is_bound()) {
 904       MethodFamily* method = slot-&gt;get_binding();
<a name="64" id="anc64"></a><span class="line-removed"> 905       BytecodeBuffer buffer;</span>
 906 
 907       LogTarget(Debug, defaultmethods) lt;
 908       if (lt.is_enabled()) {
 909         ResourceMark rm(THREAD);
 910         LogStream ls(lt);
 911         ls.print(&quot;for slot: &quot;);
 912         slot-&gt;print_on(&amp;ls);
 913         ls.cr();
 914         if (method-&gt;has_target()) {
 915           method-&gt;print_selected(&amp;ls, 1);
 916         } else if (method-&gt;throws_exception()) {
 917           method-&gt;print_exception(&amp;ls, 1);
 918         }
 919       }
 920 
 921       if (method-&gt;has_target()) {
 922         Method* selected = method-&gt;get_selected_target();
 923         if (selected-&gt;method_holder()-&gt;is_interface()) {
 924           assert(!selected-&gt;is_private(), &quot;pushing private interface method as default&quot;);
 925           defaults.push(selected);
 926         }
 927       } else if (method-&gt;throws_exception()) {
<a name="65" id="anc65"></a><span class="line-modified"> 928         int max_stack = assemble_method_error(&amp;bpool, &amp;buffer,</span>





 929            method-&gt;get_exception_name(), method-&gt;get_exception_message(), CHECK);
 930         AccessFlags flags = accessFlags_from(
 931           JVM_ACC_PUBLIC | JVM_ACC_SYNTHETIC | JVM_ACC_BRIDGE);
<a name="66" id="anc66"></a><span class="line-modified"> 932          Method* m = new_method(&amp;bpool, &amp;buffer, slot-&gt;name(), slot-&gt;signature(),</span>
 933           flags, max_stack, slot-&gt;size_of_parameters(),
 934           ConstMethod::OVERPASS, CHECK);
 935         // We push to the methods list:
 936         // overpass methods which are exception throwing methods
 937         if (m != NULL) {
 938           overpasses.push(m);
 939         }
 940       }
 941     }
 942   }
 943 
 944 
 945   log_debug(defaultmethods)(&quot;Created %d overpass methods&quot;, overpasses.length());
 946   log_debug(defaultmethods)(&quot;Created %d default  methods&quot;, defaults.length());
 947 
 948   if (overpasses.length() &gt; 0) {
 949     switchover_constant_pool(&amp;bpool, klass, &amp;overpasses, CHECK);
 950     merge_in_new_methods(klass, &amp;overpasses, CHECK);
 951   }
 952   if (defaults.length() &gt; 0) {
 953     create_default_methods(klass, &amp;defaults, CHECK);
 954   }
 955 }
 956 
 957 static void create_default_methods(InstanceKlass* klass,
 958     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
 959 
 960   int new_size = new_methods-&gt;length();
 961   Array&lt;Method*&gt;* total_default_methods = MetadataFactory::new_array&lt;Method*&gt;(
 962       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
 963   for (int index = 0; index &lt; new_size; index++ ) {
 964     total_default_methods-&gt;at_put(index, new_methods-&gt;at(index));
 965   }
 966   Method::sort_methods(total_default_methods, /*set_idnums=*/false);
 967 
 968   klass-&gt;set_default_methods(total_default_methods);
 969 }
 970 
 971 static void sort_methods(GrowableArray&lt;Method*&gt;* methods) {
 972   // Note that this must sort using the same key as is used for sorting
 973   // methods in InstanceKlass.
 974   bool sorted = true;
 975   for (int i = methods-&gt;length() - 1; i &gt; 0; --i) {
 976     for (int j = 0; j &lt; i; ++j) {
 977       Method* m1 = methods-&gt;at(j);
 978       Method* m2 = methods-&gt;at(j + 1);
 979       if ((uintptr_t)m1-&gt;name() &gt; (uintptr_t)m2-&gt;name()) {
 980         methods-&gt;at_put(j, m2);
 981         methods-&gt;at_put(j + 1, m1);
 982         sorted = false;
 983       }
 984     }
 985     if (sorted) break;
 986     sorted = true;
 987   }
 988 #ifdef ASSERT
 989   uintptr_t prev = 0;
 990   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
 991     Method* mh = methods-&gt;at(i);
 992     uintptr_t nv = (uintptr_t)mh-&gt;name();
 993     assert(nv &gt;= prev, &quot;Incorrect overpass method ordering&quot;);
 994     prev = nv;
 995   }
 996 #endif
 997 }
 998 
 999 static void merge_in_new_methods(InstanceKlass* klass,
1000     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
1001 
1002   enum { ANNOTATIONS, PARAMETERS, DEFAULTS, NUM_ARRAYS };
1003 
1004   Array&lt;Method*&gt;* original_methods = klass-&gt;methods();
1005   Array&lt;int&gt;* original_ordering = klass-&gt;method_ordering();
1006   Array&lt;int&gt;* merged_ordering = Universe::the_empty_int_array();
1007 
1008   int new_size = klass-&gt;methods()-&gt;length() + new_methods-&gt;length();
1009 
1010   Array&lt;Method*&gt;* merged_methods = MetadataFactory::new_array&lt;Method*&gt;(
1011       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
1012 
1013   // original_ordering might be empty if this class has no methods of its own
<a name="67" id="anc67"></a><span class="line-modified">1014   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
1015     merged_ordering = MetadataFactory::new_array&lt;int&gt;(
1016         klass-&gt;class_loader_data(), new_size, CHECK);
1017   }
1018   int method_order_index = klass-&gt;methods()-&gt;length();
1019 
1020   sort_methods(new_methods);
1021 
1022   // Perform grand merge of existing methods and new methods
1023   int orig_idx = 0;
1024   int new_idx = 0;
1025 
1026   for (int i = 0; i &lt; new_size; ++i) {
1027     Method* orig_method = NULL;
1028     Method* new_method = NULL;
1029     if (orig_idx &lt; original_methods-&gt;length()) {
1030       orig_method = original_methods-&gt;at(orig_idx);
1031     }
1032     if (new_idx &lt; new_methods-&gt;length()) {
1033       new_method = new_methods-&gt;at(new_idx);
1034     }
1035 
1036     if (orig_method != NULL &amp;&amp;
1037         (new_method == NULL || orig_method-&gt;name() &lt; new_method-&gt;name())) {
1038       merged_methods-&gt;at_put(i, orig_method);
1039       original_methods-&gt;at_put(orig_idx, NULL);
1040       if (merged_ordering-&gt;length() &gt; 0) {
1041         assert(original_ordering != NULL &amp;&amp; original_ordering-&gt;length() &gt; 0,
1042                &quot;should have original order information for this method&quot;);
1043         merged_ordering-&gt;at_put(i, original_ordering-&gt;at(orig_idx));
1044       }
1045       ++orig_idx;
1046     } else {
1047       merged_methods-&gt;at_put(i, new_method);
1048       if (merged_ordering-&gt;length() &gt; 0) {
1049         merged_ordering-&gt;at_put(i, method_order_index++);
1050       }
1051       ++new_idx;
1052     }
1053     // update idnum for new location
1054     merged_methods-&gt;at(i)-&gt;set_method_idnum(i);
1055     merged_methods-&gt;at(i)-&gt;set_orig_method_idnum(i);
1056   }
1057 
1058   // Verify correct order
1059 #ifdef ASSERT
1060   uintptr_t prev = 0;
1061   for (int i = 0; i &lt; merged_methods-&gt;length(); ++i) {
1062     Method* mo = merged_methods-&gt;at(i);
1063     uintptr_t nv = (uintptr_t)mo-&gt;name();
1064     assert(nv &gt;= prev, &quot;Incorrect method ordering&quot;);
1065     prev = nv;
1066   }
1067 #endif
1068 
1069   // Replace klass methods with new merged lists
1070   klass-&gt;set_methods(merged_methods);
1071   klass-&gt;set_initial_method_idnum(new_size);
1072   klass-&gt;set_method_ordering(merged_ordering);
1073 
1074   // Free metadata
1075   ClassLoaderData* cld = klass-&gt;class_loader_data();
1076   if (original_methods-&gt;length() &gt; 0) {
1077     MetadataFactory::free_array(cld, original_methods);
1078   }
1079   if (original_ordering != NULL &amp;&amp; original_ordering-&gt;length() &gt; 0) {
1080     MetadataFactory::free_array(cld, original_ordering);
1081   }
1082 }
<a name="68" id="anc68"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="68" type="hidden" />
</body>
</html>
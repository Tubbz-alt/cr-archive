<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/stringTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackMapTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringTable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/stringTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,19 ***</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;oops/weakHandle.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-new-header">--- 28,20 ---</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;oops/weakHandle.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,17 ***</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;services/diagnosticCommand.hpp&quot;
  #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  // We prefer short chains of avg 2
  const double PREF_AVG_LIST_LEN = 2.0;
  // 2^24 is max size
  const size_t END_SIZE = 24;
<span class="line-modified">! // If a chain gets to 32 something might be wrong</span>
<span class="line-modified">! const size_t REHASH_LEN = 32;</span>
  // If we have as many dead items as 50% of the number of bucket
  const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;
  
  #if INCLUDE_CDS_JAVA_HEAP
  inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {
<span class="line-new-header">--- 51,18 ---</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;services/diagnosticCommand.hpp&quot;
  #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  
  // We prefer short chains of avg 2
  const double PREF_AVG_LIST_LEN = 2.0;
  // 2^24 is max size
  const size_t END_SIZE = 24;
<span class="line-modified">! // If a chain gets to 100 something might be wrong</span>
<span class="line-modified">! const size_t REHASH_LEN = 100;</span>
  // If we have as many dead items as 50% of the number of bucket
  const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;
  
  #if INCLUDE_CDS_JAVA_HEAP
  inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,26 ***</span>
    java_lang_String::equals
  &gt; _shared_table;
  #endif
  
  // --------------------------------------------------------------------------
<span class="line-removed">- StringTable* StringTable::_the_table = NULL;</span>
<span class="line-removed">- volatile bool StringTable::_alt_hash = false;</span>
  
  static juint murmur_seed = 0;
  
  uintx hash_string(const jchar* s, int len, bool useAlt) {
    return  useAlt ?
      AltHashing::murmur3_32(murmur_seed, s, len) :
      java_lang_String::hash_code(s, len);
  }
  
<span class="line-modified">! class StringTableConfig : public StringTableHash::BaseConfig {</span>
   private:
   public:
<span class="line-modified">!   static uintx get_hash(WeakHandle&lt;vm_string_table_data&gt; const&amp; value,</span>
<span class="line-modified">!                         bool* is_dead) {</span>
      EXCEPTION_MARK;
      oop val_oop = value.peek();
      if (val_oop == NULL) {
        *is_dead = true;
        return 0;
<span class="line-new-header">--- 77,37 ---</span>
    java_lang_String::equals
  &gt; _shared_table;
  #endif
  
  // --------------------------------------------------------------------------
  
<span class="line-added">+ typedef ConcurrentHashTable&lt;StringTableConfig, mtSymbol&gt; StringTableHash;</span>
<span class="line-added">+ static StringTableHash* _local_table = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ volatile bool StringTable::_has_work = false;</span>
<span class="line-added">+ volatile bool StringTable::_needs_rehashing = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ volatile size_t StringTable::_uncleaned_items_count = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static size_t _current_size = 0;</span>
<span class="line-added">+ static volatile size_t _items_count = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ volatile bool _alt_hash = false;</span>
  static juint murmur_seed = 0;
  
  uintx hash_string(const jchar* s, int len, bool useAlt) {
    return  useAlt ?
      AltHashing::murmur3_32(murmur_seed, s, len) :
      java_lang_String::hash_code(s, len);
  }
  
<span class="line-modified">! class StringTableConfig : public StackObj {</span>
   private:
   public:
<span class="line-modified">!   typedef WeakHandle&lt;vm_string_table_data&gt; Value;</span>
<span class="line-modified">! </span>
<span class="line-added">+   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
      EXCEPTION_MARK;
      oop val_oop = value.peek();
      if (val_oop == NULL) {
        *is_dead = true;
        return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,25 ***</span>
      ResourceMark rm(THREAD);
      // All String oops are hashed as unicode
      int length;
      jchar* chars = java_lang_String::as_unicode_string(val_oop, length, THREAD);
      if (chars != NULL) {
<span class="line-modified">!       return hash_string(chars, length, StringTable::_alt_hash);</span>
      }
      vm_exit_out_of_memory(length, OOM_MALLOC_ERROR, &quot;get hash from oop&quot;);
      return 0;
    }
    // We use default allocation/deallocation but counted
<span class="line-modified">!   static void* allocate_node(size_t size,</span>
<span class="line-removed">-                              WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
      StringTable::item_added();
<span class="line-modified">!     return StringTableHash::BaseConfig::allocate_node(size, value);</span>
    }
<span class="line-modified">!   static void free_node(void* memory,</span>
<span class="line-removed">-                         WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
      value.release();
<span class="line-modified">!     StringTableHash::BaseConfig::free_node(memory, value);</span>
      StringTable::item_removed();
    }
  };
  
  class StringTableLookupJchar : StackObj {
<span class="line-new-header">--- 116,23 ---</span>
      ResourceMark rm(THREAD);
      // All String oops are hashed as unicode
      int length;
      jchar* chars = java_lang_String::as_unicode_string(val_oop, length, THREAD);
      if (chars != NULL) {
<span class="line-modified">!       return hash_string(chars, length, _alt_hash);</span>
      }
      vm_exit_out_of_memory(length, OOM_MALLOC_ERROR, &quot;get hash from oop&quot;);
      return 0;
    }
    // We use default allocation/deallocation but counted
<span class="line-modified">!   static void* allocate_node(size_t size, Value const&amp; value) {</span>
      StringTable::item_added();
<span class="line-modified">!     return AllocateHeap(size, mtSymbol);</span>
    }
<span class="line-modified">!   static void free_node(void* memory, Value const&amp; value) {</span>
      value.release();
<span class="line-modified">!     FreeHeap(memory);</span>
      StringTable::item_removed();
    }
  };
  
  class StringTableLookupJchar : StackObj {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,59 ***</span>
    size_t ret;
    for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; val; ++ret);
    return ret;
  }
  
<span class="line-modified">! StringTable::StringTable() : _local_table(NULL), _current_size(0), _has_work(0),</span>
<span class="line-removed">-   _needs_rehashing(false), _weak_handles(NULL), _items_count(0), _uncleaned_items_count(0) {</span>
<span class="line-removed">-   _weak_handles = new OopStorage(&quot;StringTable weak&quot;,</span>
<span class="line-removed">-                                  StringTableWeakAlloc_lock,</span>
<span class="line-removed">-                                  StringTableWeakActive_lock);</span>
    size_t start_size_log_2 = ceil_log2(StringTableSize);
    _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
    log_trace(stringtable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
                           _current_size, start_size_log_2);
    _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
  }
  
<span class="line-removed">- void StringTable::update_needs_rehash(bool rehash) {</span>
<span class="line-removed">-   if (rehash) {</span>
<span class="line-removed">-     _needs_rehashing = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  size_t StringTable::item_added() {
<span class="line-modified">!   return Atomic::add((size_t)1, &amp;(the_table()-&gt;_items_count));</span>
  }
  
  size_t StringTable::add_items_to_clean(size_t ndead) {
<span class="line-modified">!   size_t total = Atomic::add((size_t)ndead, &amp;(the_table()-&gt;_uncleaned_items_count));</span>
    log_trace(stringtable)(
       &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,
<span class="line-modified">!      the_table()-&gt;_uncleaned_items_count, ndead, total);</span>
    return total;
  }
  
  void StringTable::item_removed() {
<span class="line-modified">!   Atomic::add((size_t)-1, &amp;(the_table()-&gt;_items_count));</span>
  }
  
<span class="line-modified">! double StringTable::get_load_factor() const {</span>
    return (double)_items_count/_current_size;
  }
  
<span class="line-modified">! double StringTable::get_dead_factor() const {</span>
    return (double)_uncleaned_items_count/_current_size;
  }
  
  size_t StringTable::table_size() {
    return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
  }
  
  void StringTable::trigger_concurrent_work() {
<span class="line-modified">!   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   the_table()-&gt;_has_work = true;</span>
    Service_lock-&gt;notify_all();
  }
  
  // Probing
  oop StringTable::lookup(Symbol* symbol) {
<span class="line-new-header">--- 203,49 ---</span>
    size_t ret;
    for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; val; ++ret);
    return ret;
  }
  
<span class="line-modified">! void StringTable::create_table() {</span>
    size_t start_size_log_2 = ceil_log2(StringTableSize);
    _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
    log_trace(stringtable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
                           _current_size, start_size_log_2);
    _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
  }
  
  size_t StringTable::item_added() {
<span class="line-modified">!   return Atomic::add(&amp;_items_count, (size_t)1);</span>
  }
  
  size_t StringTable::add_items_to_clean(size_t ndead) {
<span class="line-modified">!   size_t total = Atomic::add(&amp;_uncleaned_items_count, (size_t)ndead);</span>
    log_trace(stringtable)(
       &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,
<span class="line-modified">!      _uncleaned_items_count, ndead, total);</span>
    return total;
  }
  
  void StringTable::item_removed() {
<span class="line-modified">!   Atomic::add(&amp;_items_count, (size_t)-1);</span>
  }
  
<span class="line-modified">! double StringTable::get_load_factor() {</span>
    return (double)_items_count/_current_size;
  }
  
<span class="line-modified">! double StringTable::get_dead_factor() {</span>
    return (double)_uncleaned_items_count/_current_size;
  }
  
  size_t StringTable::table_size() {
    return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
  }
  
  void StringTable::trigger_concurrent_work() {
<span class="line-modified">!   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   _has_work = true;</span>
    Service_lock-&gt;notify_all();
  }
  
  // Probing
  oop StringTable::lookup(Symbol* symbol) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,18 ***</span>
    return lookup(chars, length);
  }
  
  oop StringTable::lookup(const jchar* name, int len) {
    unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">!   oop string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
    if (string != NULL) {
      return string;
    }
<span class="line-modified">!   if (StringTable::_alt_hash) {</span>
      hash = hash_string(name, len, true);
    }
<span class="line-modified">!   return StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
  }
  
  class StringTableGet : public StackObj {
    Thread* _thread;
    Handle  _return;
<span class="line-new-header">--- 255,18 ---</span>
    return lookup(chars, length);
  }
  
  oop StringTable::lookup(const jchar* name, int len) {
    unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">!   oop string = lookup_shared(name, len, hash);</span>
    if (string != NULL) {
      return string;
    }
<span class="line-modified">!   if (_alt_hash) {</span>
      hash = hash_string(name, len, true);
    }
<span class="line-modified">!   return do_lookup(name, len, hash);</span>
  }
  
  class StringTableGet : public StackObj {
    Thread* _thread;
    Handle  _return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,23 ***</span>
  }
  
  oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
    // shared table always uses java_lang_String::hash_code
    unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">!   oop found_string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
    if (found_string != NULL) {
      return found_string;
    }
<span class="line-modified">!   if (StringTable::_alt_hash) {</span>
      hash = hash_string(name, len, true);
    }
<span class="line-modified">!   found_string = StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
    if (found_string != NULL) {
      return found_string;
    }
<span class="line-modified">!   return StringTable::the_table()-&gt;do_intern(string_or_null_h, name, len,</span>
<span class="line-removed">-                                              hash, CHECK_NULL);</span>
  }
  
  oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,
                             int len, uintx hash, TRAPS) {
    HandleMark hm(THREAD);  // cleanup strings created
<span class="line-new-header">--- 326,22 ---</span>
  }
  
  oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
    // shared table always uses java_lang_String::hash_code
    unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">!   oop found_string = lookup_shared(name, len, hash);</span>
    if (found_string != NULL) {
      return found_string;
    }
<span class="line-modified">!   if (_alt_hash) {</span>
      hash = hash_string(name, len, true);
    }
<span class="line-modified">!   found_string = do_lookup(name, len, hash);</span>
    if (found_string != NULL) {
      return found_string;
    }
<span class="line-modified">!   return do_intern(string_or_null_h, name, len, hash, THREAD);</span>
  }
  
  oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,
                             int len, uintx hash, TRAPS) {
    HandleMark hm(THREAD);  // cleanup strings created
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,36 ***</span>
    StringTableLookupOop lookup(THREAD, hash, string_h);
    StringTableGet stg(THREAD);
  
    bool rehash_warning;
    do {
<span class="line-modified">!     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-removed">-       update_needs_rehash(rehash_warning);</span>
<span class="line-removed">-       return stg.get_res_oop();</span>
<span class="line-removed">-     }</span>
      WeakHandle&lt;vm_string_table_data&gt; wh = WeakHandle&lt;vm_string_table_data&gt;::create(string_h);
      // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.
      if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) {
        update_needs_rehash(rehash_warning);
        return wh.resolve();
      }
    } while(true);
  }
  
<span class="line-removed">- void StringTable::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">-   StringTable::the_table()-&gt;_weak_handles-&gt;oops_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void StringTable::possibly_parallel_oops_do(</span>
<span class="line-removed">-    OopStorage::ParState&lt;false /* concurrent */, false /* const */&gt;*</span>
<span class="line-removed">-    _par_state_string, OopClosure* f)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">-   _par_state_string-&gt;oops_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Concurrent work
  void StringTable::grow(JavaThread* jt) {
    StringTableHash::GrowTask gt(_local_table);
    if (!gt.prepare(jt)) {
      return;
<span class="line-new-header">--- 365,26 ---</span>
    StringTableLookupOop lookup(THREAD, hash, string_h);
    StringTableGet stg(THREAD);
  
    bool rehash_warning;
    do {
<span class="line-modified">!     // Callers have already looked up the String using the jchar* name, so just go to add.</span>
      WeakHandle&lt;vm_string_table_data&gt; wh = WeakHandle&lt;vm_string_table_data&gt;::create(string_h);
      // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.
      if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) {
        update_needs_rehash(rehash_warning);
        return wh.resolve();
      }
<span class="line-added">+     // In case another thread did a concurrent add, return value already in the table.</span>
<span class="line-added">+     // This could fail if the String got gc&#39;ed concurrently, so loop back until success.</span>
<span class="line-added">+     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-added">+       update_needs_rehash(rehash_warning);</span>
<span class="line-added">+       return stg.get_res_oop();</span>
<span class="line-added">+     }</span>
    } while(true);
  }
  
  // Concurrent work
  void StringTable::grow(JavaThread* jt) {
    StringTableHash::GrowTask gt(_local_table);
    if (!gt.prepare(jt)) {
      return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,11 ***</span>
                             load_factor, dead_factor);
      trigger_concurrent_work();
    }
  }
  
<span class="line-modified">! void StringTable::concurrent_work(JavaThread* jt) {</span>
    _has_work = false;
    double load_factor = get_load_factor();
    log_debug(stringtable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
    // We prefer growing, since that also removes dead items
    if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
<span class="line-new-header">--- 466,11 ---</span>
                             load_factor, dead_factor);
      trigger_concurrent_work();
    }
  }
  
<span class="line-modified">! void StringTable::do_concurrent_work(JavaThread* jt) {</span>
    _has_work = false;
    double load_factor = get_load_factor();
    log_debug(stringtable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
    // We prefer growing, since that also removes dead items
    if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,22 ***</span>
    } else {
      clean_dead_entries(jt);
    }
  }
  
<span class="line-removed">- void StringTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-removed">-   StringTable::the_table()-&gt;concurrent_work(jt);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Rehash
  bool StringTable::do_rehash() {
    if (!_local_table-&gt;is_safepoint_safe()) {
      return false;
    }
  
<span class="line-modified">!   // We use max size</span>
<span class="line-modified">!   StringTableHash* new_table = new StringTableHash(END_SIZE, END_SIZE, REHASH_LEN);</span>
    // Use alt hash from now on
    _alt_hash = true;
    if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
      _alt_hash = false;
      delete new_table;
<span class="line-new-header">--- 478,19 ---</span>
    } else {
      clean_dead_entries(jt);
    }
  }
  
  // Rehash
  bool StringTable::do_rehash() {
    if (!_local_table-&gt;is_safepoint_safe()) {
      return false;
    }
  
<span class="line-modified">!   // We use current size, not max size.</span>
<span class="line-modified">!   size_t new_size = _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="line-added">+   StringTableHash* new_table = new StringTableHash(new_size, END_SIZE, REHASH_LEN);</span>
    // Use alt hash from now on
    _alt_hash = true;
    if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
      _alt_hash = false;
      delete new_table;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,11 ***</span>
    _local_table = new_table;
  
    return true;
  }
  
<span class="line-modified">! void StringTable::try_rehash_table() {</span>
    static bool rehashed = false;
    log_debug(stringtable)(&quot;Table imbalanced, rehashing called.&quot;);
  
    // Grow instead of rehash.
    if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
<span class="line-new-header">--- 502,11 ---</span>
    _local_table = new_table;
  
    return true;
  }
  
<span class="line-modified">! void StringTable::rehash_table() {</span>
    static bool rehashed = false;
    log_debug(stringtable)(&quot;Table imbalanced, rehashing called.&quot;);
  
    // Grow instead of rehash.
    if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,14 ***</span>
      }
    }
    _needs_rehashing = false;
  }
  
<span class="line-removed">- void StringTable::rehash_table() {</span>
<span class="line-removed">-   StringTable::the_table()-&gt;try_rehash_table();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Statistics
  static int literal_size(oop obj) {
    // NOTE: this would over-count if (pre-JDK8)
    // java_lang_Class::has_offset_field() is true and the String.value array is
    // shared by several Strings. However, starting from JDK8, the String.value
<span class="line-new-header">--- 533,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,10 ***</span>
<span class="line-new-header">--- 559,17 ---</span>
      }
      return literal_size(s);
    };
  };
  
<span class="line-added">+ TableStatistics StringTable::get_table_statistics() {</span>
<span class="line-added">+   static TableStatistics ts;</span>
<span class="line-added">+   SizeFunc sz;</span>
<span class="line-added">+   ts = _local_table-&gt;statistics_get(Thread::current(), sz, ts);</span>
<span class="line-added">+   return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void StringTable::print_table_statistics(outputStream* st,
                                           const char* table_name) {
    SizeFunc sz;
    _local_table-&gt;statistics_to(Thread::current(), sz, st, table_name);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,11 ***</span>
  
  // This verification is part of Universe::verify() and needs to be quick.
  void StringTable::verify() {
    Thread* thr = Thread::current();
    VerifyStrings vs;
<span class="line-modified">!   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vs)) {</span>
      log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
    }
  }
  
  // Verification and comp
<span class="line-new-header">--- 588,11 ---</span>
  
  // This verification is part of Universe::verify() and needs to be quick.
  void StringTable::verify() {
    Thread* thr = Thread::current();
    VerifyStrings vs;
<span class="line-modified">!   if (!_local_table-&gt;try_scan(thr, vs)) {</span>
      log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
    }
  }
  
  // Verification and comp
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,14 ***</span>
  
  size_t StringTable::verify_and_compare_entries() {
    Thread* thr = Thread::current();
    GrowableArray&lt;oop&gt;* oops =
      new (ResourceObj::C_HEAP, mtInternal)
<span class="line-modified">!       GrowableArray&lt;oop&gt;((int)the_table()-&gt;_current_size, true);</span>
  
    VerifyCompStrings vcs(oops);
<span class="line-modified">!   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vcs)) {</span>
      log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
    }
    delete oops;
    return vcs._errors;
  }
<span class="line-new-header">--- 621,14 ---</span>
  
  size_t StringTable::verify_and_compare_entries() {
    Thread* thr = Thread::current();
    GrowableArray&lt;oop&gt;* oops =
      new (ResourceObj::C_HEAP, mtInternal)
<span class="line-modified">!       GrowableArray&lt;oop&gt;((int)_current_size, true);</span>
  
    VerifyCompStrings vcs(oops);
<span class="line-modified">!   if (!_local_table-&gt;try_scan(thr, vcs)) {</span>
      log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
    }
    delete oops;
    return vcs._errors;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 681,17 ***</span>
    };
  };
  
  void StringTable::dump(outputStream* st, bool verbose) {
    if (!verbose) {
<span class="line-modified">!     the_table()-&gt;print_table_statistics(st, &quot;StringTable&quot;);</span>
    } else {
      Thread* thr = Thread::current();
      ResourceMark rm(thr);
      st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
      PrintString ps(thr, st);
<span class="line-modified">!     if (!the_table()-&gt;_local_table-&gt;try_scan(thr, ps)) {</span>
        st-&gt;print_cr(&quot;dump unavailable at this moment&quot;);
      }
    }
  }
  
<span class="line-new-header">--- 671,17 ---</span>
    };
  };
  
  void StringTable::dump(outputStream* st, bool verbose) {
    if (!verbose) {
<span class="line-modified">!     print_table_statistics(st, &quot;StringTable&quot;);</span>
    } else {
      Thread* thr = Thread::current();
      ResourceMark rm(thr);
      st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
      PrintString ps(thr, st);
<span class="line-modified">!     if (!_local_table-&gt;try_scan(thr, ps)) {</span>
        st-&gt;print_cr(&quot;dump unavailable at this moment&quot;);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,16 ***</span>
      oop s = val-&gt;peek();
      if (s == NULL) {
        return true;
      }
      unsigned int hash = java_lang_String::hash_code(s);
<span class="line-removed">-     if (hash == 0) {</span>
<span class="line-removed">-       // We do not archive Strings with a 0 hashcode because ......</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     java_lang_String::set_hash(s, hash);</span>
      oop new_s = StringTable::create_archived_string(s, Thread::current());
      if (new_s == NULL) {
        return true;
      }
  
<span class="line-new-header">--- 748,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,21 ***</span>
  
  void StringTable::copy_shared_string_table(CompactHashtableWriter* writer) {
    assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
  
    CopyToArchive copy(writer);
<span class="line-modified">!   StringTable::the_table()-&gt;_local_table-&gt;do_safepoint_scan(copy);</span>
  }
  
  void StringTable::write_to_archive() {
    assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
  
    _shared_table.reset();
<span class="line-modified">!   int num_buckets = CompactHashtableWriter::default_num_buckets(</span>
<span class="line-removed">-       StringTable::the_table()-&gt;_items_count);</span>
<span class="line-removed">-   CompactHashtableWriter writer(num_buckets,</span>
<span class="line-removed">-                                 &amp;MetaspaceShared::stats()-&gt;string);</span>
  
    // Copy the interned strings into the &quot;string space&quot; within the java heap
    copy_shared_string_table(&amp;writer);
    writer.dump(&amp;_shared_table, &quot;string&quot;);
  }
<span class="line-new-header">--- 764,18 ---</span>
  
  void StringTable::copy_shared_string_table(CompactHashtableWriter* writer) {
    assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
  
    CopyToArchive copy(writer);
<span class="line-modified">!   _local_table-&gt;do_safepoint_scan(copy);</span>
  }
  
  void StringTable::write_to_archive() {
    assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
  
    _shared_table.reset();
<span class="line-modified">!   CompactHashtableWriter writer(_items_count, &amp;MetaspaceShared::stats()-&gt;string);</span>
  
    // Copy the interned strings into the &quot;string space&quot; within the java heap
    copy_shared_string_table(&amp;writer);
    writer.dump(&amp;_shared_table, &quot;string&quot;);
  }
</pre>
<center><a href="stackMapTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringTable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/modules.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="moduleEntry.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="packageEntry.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/modules.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">! * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">! * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,11 ***</span>
  }
  
  static PackageEntry* get_package_entry(ModuleEntry* module_entry, const char* package_name, TRAPS) {
    ResourceMark rm(THREAD);
    if (package_name == NULL) return NULL;
<span class="line-modified">!   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name, CHECK_NULL);</span>
    PackageEntryTable* package_entry_table = module_entry-&gt;loader_data()-&gt;packages();
    assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
    return package_entry_table-&gt;lookup_only(pkg_symbol);
  }
  
<span class="line-new-header">--- 109,11 ---</span>
  }
  
  static PackageEntry* get_package_entry(ModuleEntry* module_entry, const char* package_name, TRAPS) {
    ResourceMark rm(THREAD);
    if (package_name == NULL) return NULL;
<span class="line-modified">!   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name);</span>
    PackageEntryTable* package_entry_table = module_entry-&gt;loader_data()-&gt;packages();
    assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
    return package_entry_table-&gt;lookup_only(pkg_symbol);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
  
    // Obtain java.base&#39;s module version
    const char* module_version = get_module_version(version);
    TempNewSymbol version_symbol;
    if (module_version != NULL) {
<span class="line-modified">!     version_symbol = SymbolTable::new_symbol(module_version, CHECK);</span>
    } else {
      version_symbol = NULL;
    }
  
    // Obtain java.base&#39;s location
<span class="line-new-header">--- 146,11 ---</span>
  
    // Obtain java.base&#39;s module version
    const char* module_version = get_module_version(version);
    TempNewSymbol version_symbol;
    if (module_version != NULL) {
<span class="line-modified">!     version_symbol = SymbolTable::new_symbol(module_version);</span>
    } else {
      version_symbol = NULL;
    }
  
    // Obtain java.base&#39;s location
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
    TempNewSymbol location_symbol = NULL;
    if (location != NULL) {
      module_location =
        java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
      if (module_location != NULL) {
<span class="line-modified">!       location_symbol = SymbolTable::new_symbol(module_location, CHECK);</span>
      }
    }
  
  
    // Check that the packages are syntactically ok.
<span class="line-new-header">--- 158,11 ---</span>
    TempNewSymbol location_symbol = NULL;
    if (location != NULL) {
      module_location =
        java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
      if (module_location != NULL) {
<span class="line-modified">!       location_symbol = SymbolTable::new_symbol(module_location);</span>
      }
    }
  
  
    // Check that the packages are syntactically ok.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,11 ***</span>
      const char *package_name = packages[x];
      if (!Modules::verify_package_name(package_name)) {
        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
                  err_msg(&quot;Invalid package name: %s for module: &quot; JAVA_BASE_NAME, package_name));
      }
<span class="line-modified">!     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);</span>
      pkg_list-&gt;append(pkg_symbol);
    }
  
    // Validate java_base&#39;s loader is the boot loader.
    oop loader = java_lang_Module::loader(module_handle());
<span class="line-new-header">--- 171,11 ---</span>
      const char *package_name = packages[x];
      if (!Modules::verify_package_name(package_name)) {
        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
                  err_msg(&quot;Invalid package name: %s for module: &quot; JAVA_BASE_NAME, package_name));
      }
<span class="line-modified">!     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);</span>
      pkg_list-&gt;append(pkg_symbol);
    }
  
    // Validate java_base&#39;s loader is the boot loader.
    oop loader = java_lang_Module::loader(module_handle());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,11 ***</span>
    // Ensure java.base&#39;s ModuleEntry has been created
    assert(ModuleEntryTable::javabase_moduleEntry() != NULL, &quot;No ModuleEntry for &quot; JAVA_BASE_NAME);
  
    bool duplicate_javabase = false;
    {
<span class="line-modified">!     MutexLocker m1(Module_lock, THREAD);</span>
  
      if (ModuleEntryTable::javabase_defined()) {
        duplicate_javabase = true;
      } else {
  
<span class="line-new-header">--- 192,11 ---</span>
    // Ensure java.base&#39;s ModuleEntry has been created
    assert(ModuleEntryTable::javabase_moduleEntry() != NULL, &quot;No ModuleEntry for &quot; JAVA_BASE_NAME);
  
    bool duplicate_javabase = false;
    {
<span class="line-modified">!     MutexLocker m1(THREAD, Module_lock);</span>
  
      if (ModuleEntryTable::javabase_defined()) {
        duplicate_javabase = true;
      } else {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,11 ***</span>
  
    const char* module_version = get_module_version(version);
  
    oop loader = java_lang_Module::loader(module_handle());
    // Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.
<span class="line-modified">!   if (!oopDesc::equals(loader, java_lang_ClassLoader::non_reflection_class_loader(loader))) {</span>
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
                &quot;Class loader is an invalid delegating class loader&quot;);
    }
    Handle h_loader = Handle(THREAD, loader);
    // define_module can be called during start-up, before the class loader&#39;s ClassLoaderData
<span class="line-new-header">--- 304,11 ---</span>
  
    const char* module_version = get_module_version(version);
  
    oop loader = java_lang_Module::loader(module_handle());
    // Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.
<span class="line-modified">!   if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {</span>
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
                &quot;Class loader is an invalid delegating class loader&quot;);
    }
    Handle h_loader = Handle(THREAD, loader);
    // define_module can be called during start-up, before the class loader&#39;s ClassLoaderData
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,11 ***</span>
  
      // Only modules defined to either the boot or platform class loader, can define a &quot;java/&quot; package.
      if (!h_loader.is_null() &amp;&amp;
          !SystemDictionary::is_platform_class_loader(h_loader()) &amp;&amp;
          (strncmp(package_name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp;
<span class="line-modified">!           (package_name[JAVAPKG_LEN] == &#39;/&#39; || package_name[JAVAPKG_LEN] == &#39;\0&#39;))) {</span>
        const char* class_loader_name = loader_data-&gt;loader_name_and_id();
        size_t pkg_len = strlen(package_name);
        char* pkg_name = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, pkg_len + 1);
        strncpy(pkg_name, package_name, pkg_len + 1);
        StringUtils::replace_no_expand(pkg_name, &quot;/&quot;, &quot;.&quot;);
<span class="line-new-header">--- 329,11 ---</span>
  
      // Only modules defined to either the boot or platform class loader, can define a &quot;java/&quot; package.
      if (!h_loader.is_null() &amp;&amp;
          !SystemDictionary::is_platform_class_loader(h_loader()) &amp;&amp;
          (strncmp(package_name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp;
<span class="line-modified">!           (package_name[JAVAPKG_LEN] == JVM_SIGNATURE_SLASH || package_name[JAVAPKG_LEN] == &#39;\0&#39;))) {</span>
        const char* class_loader_name = loader_data-&gt;loader_name_and_id();
        size_t pkg_len = strlen(package_name);
        char* pkg_name = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, pkg_len + 1);
        strncpy(pkg_name, package_name, pkg_len + 1);
        StringUtils::replace_no_expand(pkg_name, &quot;/&quot;, &quot;.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,26 ***</span>
        char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);
        jio_snprintf(message, len, &quot;%s%s%s%s&quot;, msg_text1, class_loader_name, msg_text2, pkg_name);
        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), message);
      }
  
<span class="line-modified">!     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);</span>
      pkg_list-&gt;append(pkg_symbol);
    }
  
    ModuleEntryTable* module_table = get_module_entry_table(h_loader);
    assert(module_table != NULL, &quot;module entry table shouldn&#39;t be null&quot;);
  
    // Create symbol* entry for module name.
<span class="line-modified">!   TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name, CHECK);</span>
  
    bool dupl_modules = false;
  
    // Create symbol* entry for module version.
    TempNewSymbol version_symbol;
    if (module_version != NULL) {
<span class="line-modified">!     version_symbol = SymbolTable::new_symbol(module_version, CHECK);</span>
    } else {
      version_symbol = NULL;
    }
  
    // Create symbol* entry for module location.
<span class="line-new-header">--- 343,26 ---</span>
        char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);
        jio_snprintf(message, len, &quot;%s%s%s%s&quot;, msg_text1, class_loader_name, msg_text2, pkg_name);
        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), message);
      }
  
<span class="line-modified">!     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);</span>
      pkg_list-&gt;append(pkg_symbol);
    }
  
    ModuleEntryTable* module_table = get_module_entry_table(h_loader);
    assert(module_table != NULL, &quot;module entry table shouldn&#39;t be null&quot;);
  
    // Create symbol* entry for module name.
<span class="line-modified">!   TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name);</span>
  
    bool dupl_modules = false;
  
    // Create symbol* entry for module version.
    TempNewSymbol version_symbol;
    if (module_version != NULL) {
<span class="line-modified">!     version_symbol = SymbolTable::new_symbol(module_version);</span>
    } else {
      version_symbol = NULL;
    }
  
    // Create symbol* entry for module location.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,18 ***</span>
    TempNewSymbol location_symbol = NULL;
    if (location != NULL) {
      module_location =
        java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
      if (module_location != NULL) {
<span class="line-modified">!       location_symbol = SymbolTable::new_symbol(module_location, CHECK);</span>
      }
    }
  
    PackageEntryTable* package_table = NULL;
    PackageEntry* existing_pkg = NULL;
    {
<span class="line-modified">!     MutexLocker ml(Module_lock, THREAD);</span>
  
      if (num_packages &gt; 0) {
        package_table = get_package_entry_table(h_loader);
        assert(package_table != NULL, &quot;Missing package_table&quot;);
  
<span class="line-new-header">--- 370,18 ---</span>
    TempNewSymbol location_symbol = NULL;
    if (location != NULL) {
      module_location =
        java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
      if (module_location != NULL) {
<span class="line-modified">!       location_symbol = SymbolTable::new_symbol(module_location);</span>
      }
    }
  
    PackageEntryTable* package_table = NULL;
    PackageEntry* existing_pkg = NULL;
    {
<span class="line-modified">!     MutexLocker ml(THREAD, Module_lock);</span>
  
      if (num_packages &gt; 0) {
        package_table = get_package_entry_table(h_loader);
        assert(package_table != NULL, &quot;Missing package_table&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 655,11 ***</span>
    assert(package_name != NULL, &quot;the package_name should not be NULL&quot;);
  
    if (strlen(package_name) == 0) {
      return NULL;
    }
<span class="line-modified">!   TempNewSymbol package_sym = SymbolTable::new_symbol(package_name, CHECK_NULL);</span>
    const PackageEntry* const pkg_entry =
      get_package_entry_by_name(package_sym, h_loader, THREAD);
    const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
  
    if (module_entry != NULL &amp;&amp; module_entry-&gt;module() != NULL &amp;&amp; module_entry-&gt;is_named()) {
<span class="line-new-header">--- 655,11 ---</span>
    assert(package_name != NULL, &quot;the package_name should not be NULL&quot;);
  
    if (strlen(package_name) == 0) {
      return NULL;
    }
<span class="line-modified">!   TempNewSymbol package_sym = SymbolTable::new_symbol(package_name);</span>
    const PackageEntry* const pkg_entry =
      get_package_entry_by_name(package_sym, h_loader, THREAD);
    const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
  
    if (module_entry != NULL &amp;&amp; module_entry-&gt;module() != NULL &amp;&amp; module_entry-&gt;is_named()) {
</pre>
<center><a href="moduleEntry.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="packageEntry.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
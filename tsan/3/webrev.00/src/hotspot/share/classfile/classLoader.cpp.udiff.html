<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classListParser.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32,11 +32,13 @@</span>
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/klassFactory.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/systemDictionaryShared.hpp&quot;</span>
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;logging/log.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53,11 +55,10 @@</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,34 +66,35 @@</span>
  #include &quot;runtime/threadCritical.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;runtime/vm_version.hpp&quot;
  #include &quot;services/management.hpp&quot;
  #include &quot;services/threadService.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/classpathStream.hpp&quot;</span>
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/hashtable.inline.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-modified-removed">- #if INCLUDE_CDS</span>
<span class="udiff-line-modified-removed">- #include &quot;classfile/sharedPathsMiscInfo.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Entry point in java.dll for path canonicalization</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static canonicalize_fn_t CanonicalizeEntry  = NULL;</span>
  
  // Entry points in zip.dll for loading zip/jar file entries
  
  typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
<span class="udiff-line-modified-removed">- typedef void (*ZipClose_t)(jzfile *zip);</span>
<span class="udiff-line-modified-added">+ typedef void     (*ZipClose_t)(jzfile *zip);</span>
  typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
<span class="udiff-line-removed">- typedef jboolean (*ZipInflateFully_t)(void *inBuf, jlong inLen, void *outBuf, jlong outLen, char **pmsg);</span>
  typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  
  static ZipOpen_t         ZipOpen            = NULL;
  static ZipClose_t        ZipClose           = NULL;
  static FindEntry_t       FindEntry          = NULL;
  static ReadEntry_t       ReadEntry          = NULL;
  static GetNextEntry_t    GetNextEntry       = NULL;
<span class="udiff-line-removed">- static canonicalize_fn_t CanonicalizeEntry  = NULL;</span>
<span class="udiff-line-removed">- static ZipInflateFully_t ZipInflateFully    = NULL;</span>
  static Crc32_t           Crc32              = NULL;
  
  // Entry points for jimage.dll for loading jimage file entries
  
  static JImageOpen_t                    JImageOpen             = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142,11 +144,10 @@</span>
  #if INCLUDE_CDS
  ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
  ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
  ClassPathEntry* ClassLoader::_module_path_entries = NULL;
  ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;
<span class="udiff-line-removed">- SharedPathsMiscInfo* ClassLoader::_shared_paths_misc_info = NULL;</span>
  #endif
  
  // helper routines
  bool string_starts_with(const char* str, const char* str_to_find) {
    size_t str_len = strlen(str);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,28 +188,28 @@</span>
  
    if (bad_class_name != NULL) {
      *bad_class_name = false;
    }
  
<span class="udiff-line-modified-removed">-   const char* const last_slash = strrchr(class_name, &#39;/&#39;);</span>
<span class="udiff-line-modified-added">+   const char* const last_slash = strrchr(class_name, JVM_SIGNATURE_SLASH);</span>
    if (last_slash == NULL) {
      // No package name
      return NULL;
    }
  
    char* class_name_ptr = (char*) class_name;
    // Skip over &#39;[&#39;s
<span class="udiff-line-modified-removed">-   if (*class_name_ptr == &#39;[&#39;) {</span>
<span class="udiff-line-modified-added">+   if (*class_name_ptr == JVM_SIGNATURE_ARRAY) {</span>
      do {
        class_name_ptr++;
<span class="udiff-line-modified-removed">-     } while (*class_name_ptr == &#39;[&#39;);</span>
<span class="udiff-line-modified-added">+     } while (*class_name_ptr == JVM_SIGNATURE_ARRAY);</span>
  
      // Fully qualified class names should not contain a &#39;L&#39;.
      // Set bad_class_name to true to indicate that the package name
      // could not be obtained due to an error condition.
      // In this situation, is_same_class_package returns false.
<span class="udiff-line-modified-removed">-     if (*class_name_ptr == &#39;L&#39;) {</span>
<span class="udiff-line-modified-added">+     if (*class_name_ptr == JVM_SIGNATURE_CLASS) {</span>
        if (bad_class_name != NULL) {
          *bad_class_name = true;
        }
        return NULL;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,21 +242,20 @@</span>
    const char *pkg_name = ClassLoader::package_from_name(class_name);
    if (pkg_name == NULL) {
      return NULL;
    }
    PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="udiff-line-modified-removed">-   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name);</span>
    return pkgEntryTable-&gt;lookup_only(pkg_symbol);
  }
  
<span class="udiff-line-modified-removed">- ClassPathDirEntry::ClassPathDirEntry(const char* dir) : ClassPathEntry() {</span>
<span class="udiff-line-modified-removed">-   char* copy = NEW_C_HEAP_ARRAY(char, strlen(dir)+1, mtClass);</span>
<span class="udiff-line-modified-removed">-   strcpy(copy, dir);</span>
<span class="udiff-line-modified-removed">-   _dir = copy;</span>
<span class="udiff-line-modified-added">+ const char* ClassPathEntry::copy_path(const char* path) {</span>
<span class="udiff-line-modified-added">+   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);</span>
<span class="udiff-line-modified-added">+   strcpy(copy, path);</span>
<span class="udiff-line-modified-added">+   return copy;</span>
  }
  
<span class="udiff-line-removed">- </span>
  ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
    // construct full path name
    assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
    size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
    char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -288,21 +288,19 @@</span>
    }
    FREE_RESOURCE_ARRAY(char, path, path_len);
    return NULL;
  }
  
<span class="udiff-line-modified-removed">- ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append) : ClassPathEntry() {</span>
<span class="udiff-line-modified-added">+ ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,</span>
<span class="udiff-line-added">+                                      bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {</span>
    _zip = zip;
<span class="udiff-line-modified-removed">-   char *copy = NEW_C_HEAP_ARRAY(char, strlen(zip_name)+1, mtClass);</span>
<span class="udiff-line-modified-removed">-   strcpy(copy, zip_name);</span>
<span class="udiff-line-removed">-   _zip_name = copy;</span>
<span class="udiff-line-modified-added">+   _zip_name = copy_path(zip_name);</span>
<span class="udiff-line-modified-added">+   _from_class_path_attr = from_class_path_attr;</span>
  }
  
  ClassPathZipEntry::~ClassPathZipEntry() {
<span class="udiff-line-modified-removed">-   if (ZipClose != NULL) {</span>
<span class="udiff-line-removed">-     (*ZipClose)(_zip);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   (*ZipClose)(_zip);</span>
    FREE_C_HEAP_ARRAY(char, _zip_name);
  }
  
  u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
      // enable call to C land
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -359,10 +357,12 @@</span>
      if (ze == NULL) break;
      (*f)(ze-&gt;name, context);
    }
  }
  
<span class="udiff-line-added">+ DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)</span>
<span class="udiff-line-added">+ </span>
  void ClassPathImageEntry::close_jimage() {
    if (_jimage != NULL) {
      (*JImageClose)(_jimage);
      _jimage = NULL;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,58 +371,52 @@</span>
  ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
    ClassPathEntry(),
    _jimage(jimage) {
    guarantee(jimage != NULL, &quot;jimage file is null&quot;);
    guarantee(name != NULL, &quot;jimage file name is null&quot;);
<span class="udiff-line-added">+   assert(_singleton == NULL, &quot;VM supports only one jimage&quot;);</span>
<span class="udiff-line-added">+   DEBUG_ONLY(_singleton = this);</span>
    size_t len = strlen(name) + 1;
<span class="udiff-line-modified-removed">-   _name = NEW_C_HEAP_ARRAY(const char, len, mtClass);</span>
<span class="udiff-line-removed">-   strncpy((char *)_name, name, len);</span>
<span class="udiff-line-modified-added">+   _name = copy_path(name);</span>
  }
  
  ClassPathImageEntry::~ClassPathImageEntry() {
<span class="udiff-line-modified-removed">-   if (_name != NULL) {</span>
<span class="udiff-line-modified-removed">-     FREE_C_HEAP_ARRAY(const char, _name);</span>
<span class="udiff-line-modified-removed">-     _name = NULL;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   assert(_singleton == this, &quot;must be&quot;);</span>
<span class="udiff-line-modified-added">+   DEBUG_ONLY(_singleton = NULL);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(const char, _name);</span>
<span class="udiff-line-added">+ </span>
    if (_jimage != NULL) {
      (*JImageClose)(_jimage);
      _jimage = NULL;
    }
  }
  
<span class="udiff-line-added">+ ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {</span>
<span class="udiff-line-added">+   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // For a class in a named module, look it up in the jimage file using this syntax:
  //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
  //
  // Assumptions:
  //     1. There are no unnamed modules in the jimage file.
  //     2. A package is in at most one module in the jimage file.
  //
<span class="udiff-line-modified-removed">- ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {</span>
<span class="udiff-line-modified-added">+ ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {</span>
    jlong size;
    JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
  
    if (location == 0) {
      ResourceMark rm;
      const char* pkg_name = ClassLoader::package_from_name(name);
  
      if (pkg_name != NULL) {
        if (!Universe::is_module_initialized()) {
          location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
<span class="udiff-line-removed">- #if INCLUDE_CDS</span>
<span class="udiff-line-removed">-         // CDS uses the boot class loader to load classes whose packages are in</span>
<span class="udiff-line-removed">-         // modules defined for other class loaders.  So, for now, get their module</span>
<span class="udiff-line-removed">-         // names from the &quot;modules&quot; jimage file.</span>
<span class="udiff-line-removed">-         if (DumpSharedSpaces &amp;&amp; location == 0) {</span>
<span class="udiff-line-removed">-           const char* module_name = (*JImagePackageToModule)(_jimage, pkg_name);</span>
<span class="udiff-line-removed">-           if (module_name != NULL) {</span>
<span class="udiff-line-removed">-             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
        } else {
<span class="udiff-line-modified-removed">-         PackageEntry* package_entry = ClassLoader::get_package_entry(name, ClassLoaderData::the_null_class_loader_data(), CHECK_NULL);</span>
<span class="udiff-line-modified-added">+         PackageEntry* package_entry = ClassLoader::get_package_entry(name, loader_data, CHECK_NULL);</span>
          if (package_entry != NULL) {
            ResourceMark rm;
            // Get the module name
            ModuleEntry* module = package_entry-&gt;module();
            assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,14 +434,16 @@</span>
        ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
      }
      char* data = NEW_RESOURCE_ARRAY(char, size);
      (*JImageGetResource)(_jimage, location, data, size);
      // Resource allocated
<span class="udiff-line-added">+     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);</span>
      return new ClassFileStream((u1*)data,
                                 (int)size,
                                 _name,
<span class="udiff-line-modified-removed">-                                ClassFileStream::verify);</span>
<span class="udiff-line-modified-added">+                                ClassFileStream::verify,</span>
<span class="udiff-line-added">+                                true); // from_boot_loader_modules_image</span>
    }
  
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -457,16 +453,18 @@</span>
                                                      jlong &amp;size) {
    return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
  }
  
  bool ClassPathImageEntry::is_modules_image() const {
<span class="udiff-line-modified-removed">-   return ClassLoader::is_modules_image(name());</span>
<span class="udiff-line-modified-added">+   assert(this == _singleton, &quot;VM supports a single jimage&quot;);</span>
<span class="udiff-line-added">+   assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be used for jrt entry&quot;);</span>
<span class="udiff-line-added">+   return true;</span>
  }
  
  #if INCLUDE_CDS
  void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;only called at dump time&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
    tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
    vm_exit_during_initialization(error, message);
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -527,65 +525,30 @@</span>
      // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
      // the same as the bootcp of the shared archive.
    } else {
      trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
    }
<span class="udiff-line-removed">- #if INCLUDE_CDS</span>
<span class="udiff-line-removed">-   if (DumpSharedSpaces) {</span>
<span class="udiff-line-removed">-     _shared_paths_misc_info-&gt;add_boot_classpath(sys_class_path);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
    setup_boot_search_path(sys_class_path);
  }
  
  #if INCLUDE_CDS
<span class="udiff-line-removed">- int ClassLoader::get_shared_paths_misc_info_size() {</span>
<span class="udiff-line-removed">-   return _shared_paths_misc_info-&gt;get_used_bytes();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void* ClassLoader::get_shared_paths_misc_info() {</span>
<span class="udiff-line-removed">-   return _shared_paths_misc_info-&gt;buffer();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ClassLoader::check_shared_paths_misc_info(void *buf, int size) {</span>
<span class="udiff-line-removed">-   SharedPathsMiscInfo* checker = new SharedPathsMiscInfo((char*)buf, size);</span>
<span class="udiff-line-removed">-   bool result = checker-&gt;check();</span>
<span class="udiff-line-removed">-   delete checker;</span>
<span class="udiff-line-removed">-   return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void ClassLoader::setup_app_search_path(const char *class_path) {
<span class="udiff-line-added">+   Arguments::assert_is_dumping_archive();</span>
  
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;Sanity&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   Thread* THREAD = Thread::current();</span>
<span class="udiff-line-removed">-   int len = (int)strlen(class_path);</span>
<span class="udiff-line-removed">-   int end = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Iterate over class path entries</span>
<span class="udiff-line-removed">-   for (int start = 0; start &lt; len; start = end) {</span>
<span class="udiff-line-removed">-     while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="udiff-line-removed">-       end++;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     EXCEPTION_MARK;</span>
<span class="udiff-line-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-     char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="udiff-line-removed">-     strncpy(path, &amp;class_path[start], end - start);</span>
<span class="udiff-line-removed">-     path[end - start] = &#39;\0&#39;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     update_class_path_entry_list(path, false, false);</span>
<span class="udiff-line-modified-added">+   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   ClasspathStream cp_stream(class_path);</span>
  
<span class="udiff-line-modified-removed">-     while (class_path[end] == os::path_separator()[0]) {</span>
<span class="udiff-line-modified-removed">-       end++;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   while (cp_stream.has_next()) {</span>
<span class="udiff-line-modified-added">+     const char* path = cp_stream.get_next();</span>
<span class="udiff-line-modified-added">+     update_class_path_entry_list(path, false, false, false);</span>
    }
  }
  
  void ClassLoader::add_to_module_path_entries(const char* path,
                                               ClassPathEntry* entry) {
    assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
  
    // The entry does not exist, add to the list
    if (_module_path_entries == NULL) {
      assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
      _module_path_entries = _last_module_path_entry = entry;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -595,21 +558,21 @@</span>
    }
  }
  
  // Add a module path to the _module_path_entries list.
  void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;dump time only&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
    struct stat st;
    if (os::stat(path, &amp;st) != 0) {
      tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
        errno, os::errno_name(errno), path);
      vm_exit_during_initialization();
    }
    // File or directory found
    ClassPathEntry* new_entry = NULL;
    new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
<span class="udiff-line-modified-removed">-                                       false /*is_boot_append */, CHECK);</span>
<span class="udiff-line-modified-added">+                                       false /*is_boot_append */, false /* from_class_path_attr */, CHECK);</span>
    if (new_entry == NULL) {
      return;
    }
  
    add_to_module_path_entries(path, new_entry);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -634,47 +597,34 @@</span>
  void ClassLoader::setup_patch_mod_entries() {
    Thread* THREAD = Thread::current();
    GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
    int num_of_entries = patch_mod_args-&gt;length();
  
<span class="udiff-line-removed">- </span>
    // Set up the boot loader&#39;s _patch_mod_entries list
    _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
  
    for (int i = 0; i &lt; num_of_entries; i++) {
      const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
<span class="udiff-line-modified-removed">-     Symbol* const module_sym = SymbolTable::lookup(module_name, (int)strlen(module_name), CHECK);</span>
<span class="udiff-line-modified-added">+     Symbol* const module_sym = SymbolTable::new_symbol(module_name);</span>
      assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
      ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
  
      char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
<span class="udiff-line-modified-removed">-     int len = (int)strlen(class_path);</span>
<span class="udiff-line-modified-removed">-     int end = 0;</span>
<span class="udiff-line-removed">-     // Iterate over the module&#39;s class path entries</span>
<span class="udiff-line-removed">-     for (int start = 0; start &lt; len; start = end) {</span>
<span class="udiff-line-removed">-       while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="udiff-line-removed">-         end++;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       EXCEPTION_MARK;</span>
<span class="udiff-line-removed">-       ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-       char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="udiff-line-removed">-       strncpy(path, &amp;class_path[start], end - start);</span>
<span class="udiff-line-removed">-       path[end - start] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+     ClasspathStream cp_stream(class_path);</span>
  
<span class="udiff-line-added">+     while (cp_stream.has_next()) {</span>
<span class="udiff-line-added">+       const char* path = cp_stream.get_next();</span>
        struct stat st;
        if (os::stat(path, &amp;st) == 0) {
          // File or directory found
<span class="udiff-line-modified-removed">-         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
<span class="udiff-line-modified-added">+         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
          // If the path specification is valid, enter it into this module&#39;s list
          if (new_entry != NULL) {
            module_cpl-&gt;add_to_list(new_entry);
          }
        }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       while (class_path[end] == os::path_separator()[0]) {</span>
<span class="udiff-line-removed">-         end++;</span>
<span class="udiff-line-removed">-       }</span>
      }
  
      // Record the module into the list of --patch-module entries only if
      // valid ClassPathEntrys have been created
      if (module_cpl-&gt;module_first_entry() != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -698,64 +648,53 @@</span>
    return false;
  }
  
  // Set up the _jrt_entry if present and boot append path
  void ClassLoader::setup_boot_search_path(const char *class_path) {
<span class="udiff-line-modified-removed">-   int len = (int)strlen(class_path);</span>
<span class="udiff-line-modified-removed">-   int end = 0;</span>
<span class="udiff-line-modified-added">+   EXCEPTION_MARK;</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
<span class="udiff-line-added">+   ClasspathStream cp_stream(class_path);</span>
    bool set_base_piece = true;
  
  #if INCLUDE_CDS
<span class="udiff-line-modified-removed">-   if (DumpSharedSpaces) {</span>
<span class="udiff-line-modified-added">+   if (Arguments::is_dumping_archive()) {</span>
      if (!Arguments::has_jimage()) {
        vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
      }
    }
  #endif
  
<span class="udiff-line-modified-removed">-   // Iterate over class path entries</span>
<span class="udiff-line-modified-removed">-   for (int start = 0; start &lt; len; start = end) {</span>
<span class="udiff-line-removed">-     while (class_path[end] &amp;&amp; class_path[end] != os::path_separator()[0]) {</span>
<span class="udiff-line-removed">-       end++;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     EXCEPTION_MARK;</span>
<span class="udiff-line-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-removed">-     char* path = NEW_RESOURCE_ARRAY(char, end - start + 1);</span>
<span class="udiff-line-removed">-     strncpy(path, &amp;class_path[start], end - start);</span>
<span class="udiff-line-removed">-     path[end - start] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+   while (cp_stream.has_next()) {</span>
<span class="udiff-line-modified-added">+     const char* path = cp_stream.get_next();</span>
  
      if (set_base_piece) {
        // The first time through the bootstrap_search setup, it must be determined
        // what the base or core piece of the boot loader search is.  Either a java runtime
        // image is present or this is an exploded module build situation.
        assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
               &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
        struct stat st;
        if (os::stat(path, &amp;st) == 0) {
          // Directory found
<span class="udiff-line-modified-removed">-         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
<span class="udiff-line-modified-added">+         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
  
          // Check for a jimage
          if (Arguments::has_jimage()) {
            assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);
<span class="udiff-line-removed">-           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);</span>
            _jrt_entry = new_entry;
<span class="udiff-line-added">+           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);</span>
            assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
          }
        } else {
          // If path does not exist, exit
          vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
        }
        set_base_piece = false;
      } else {
        // Every entry on the system boot class path after the initial base piece,
        // which is set by os::set_boot_path(), is considered an appended entry.
<span class="udiff-line-modified-removed">-       update_class_path_entry_list(path, false, true);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     while (class_path[end] == os::path_separator()[0]) {</span>
<span class="udiff-line-removed">-       end++;</span>
<span class="udiff-line-modified-added">+       update_class_path_entry_list(path, false, true, false);</span>
      }
    }
  }
  
  // During an exploded modules build, each module defined to the boot loader
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -775,31 +714,33 @@</span>
    jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
  
    struct stat st;
    if (os::stat(path, &amp;st) == 0) {
      // Directory found
<span class="udiff-line-modified-removed">-     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK);</span>
<span class="udiff-line-modified-added">+     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);</span>
  
      // If the path specification is valid, enter it into this module&#39;s list.
      // There is no need to check for duplicate modules in the exploded entry list,
      // since no two modules with the same name can be defined to the boot loader.
      // This is checked at module definition time in Modules::define_module.
      if (new_entry != NULL) {
        ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
        module_cpl-&gt;add_to_list(new_entry);
        {
<span class="udiff-line-modified-removed">-         MutexLocker ml(Module_lock, THREAD);</span>
<span class="udiff-line-modified-added">+         MutexLocker ml(THREAD, Module_lock);</span>
          _exploded_entries-&gt;push(module_cpl);
        }
        log_info(class, load)(&quot;path: %s&quot;, path);
      }
    }
  }
  
  ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
                                                       bool throw_exception,
<span class="udiff-line-modified-removed">-                                                      bool is_boot_append, TRAPS) {</span>
<span class="udiff-line-modified-added">+                                                      bool is_boot_append,</span>
<span class="udiff-line-added">+                                                      bool from_class_path_attr,</span>
<span class="udiff-line-added">+                                                      TRAPS) {</span>
    JavaThread* thread = JavaThread::current();
    ClassPathEntry* new_entry = NULL;
    if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
      ResourceMark rm(thread);
      // Regular file, should be a zip or jimage file
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -825,11 +766,11 @@</span>
          ThreadToNativeFromVM ttn(thread);
          HandleMark hm(thread);
          zip = (*ZipOpen)(canonical_path, &amp;error_msg);
        }
        if (zip != NULL &amp;&amp; error_msg == NULL) {
<span class="udiff-line-modified-removed">-         new_entry = new ClassPathZipEntry(zip, path, is_boot_append);</span>
<span class="udiff-line-modified-added">+         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);</span>
        } else {
          char *msg;
          if (error_msg == NULL) {
            msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
            jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -875,11 +816,11 @@</span>
            HandleMark hm(thread);
            zip = (*ZipOpen)(canonical_path, &amp;error_msg);
          }
          if (zip != NULL &amp;&amp; error_msg == NULL) {
            // create using canonical path
<span class="udiff-line-modified-removed">-           return new ClassPathZipEntry(zip, canonical_path, is_boot_append);</span>
<span class="udiff-line-modified-added">+           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);</span>
          }
        }
      }
    }
    return NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -949,17 +890,18 @@</span>
  
  // Returns true IFF the file/dir exists and the entry was successfully created.
  bool ClassLoader::update_class_path_entry_list(const char *path,
                                                 bool check_for_duplicates,
                                                 bool is_boot_append,
<span class="udiff-line-added">+                                                bool from_class_path_attr,</span>
                                                 bool throw_exception) {
    struct stat st;
    if (os::stat(path, &amp;st) == 0) {
      // File or directory found
      ClassPathEntry* new_entry = NULL;
      Thread* THREAD = Thread::current();
<span class="udiff-line-modified-removed">-     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, CHECK_(false));</span>
<span class="udiff-line-modified-added">+     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, from_class_path_attr, CHECK_(false));</span>
      if (new_entry == NULL) {
        return false;
      }
  
      // Do not reorder the bootclasspath which would break get_system_package().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -969,15 +911,10 @@</span>
      } else {
        add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
      }
      return true;
    } else {
<span class="udiff-line-removed">- #if INCLUDE_CDS</span>
<span class="udiff-line-removed">-     if (DumpSharedSpaces) {</span>
<span class="udiff-line-removed">-       _shared_paths_misc_info-&gt;add_nonexist_path(path);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
      return false;
    }
  }
  
  static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1026,84 +963,71 @@</span>
      e = e-&gt;next();
    }
    tty-&gt;print_cr(&quot;]&quot;);
  }
  
<span class="udiff-line-added">+ void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {</span>
<span class="udiff-line-added">+   void* func = os::dll_lookup(lib, name);</span>
<span class="udiff-line-added">+   if (func == NULL) {</span>
<span class="udiff-line-added">+     char msg[256] = &quot;&quot;;</span>
<span class="udiff-line-added">+     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);</span>
<span class="udiff-line-added">+     vm_exit_during_initialization(msg, path);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return func;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ClassLoader::load_java_library() {</span>
<span class="udiff-line-added">+   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);</span>
<span class="udiff-line-added">+   void *javalib_handle = os::native_java_library();</span>
<span class="udiff-line-added">+   if (javalib_handle == NULL) {</span>
<span class="udiff-line-added">+     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void ClassLoader::load_zip_library() {
    assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
<span class="udiff-line-removed">-   // First make sure native library is loaded</span>
<span class="udiff-line-removed">-   os::native_java_library();</span>
<span class="udiff-line-removed">-   // Load zip library</span>
    char path[JVM_MAXPATHLEN];
    char ebuf[1024];
    void* handle = NULL;
    if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
      handle = os::dll_load(path, ebuf, sizeof ebuf);
    }
    if (handle == NULL) {
<span class="udiff-line-modified-removed">-     vm_exit_during_initialization(&quot;Unable to load ZIP library&quot;, path);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // Lookup zip entry points</span>
<span class="udiff-line-removed">-   ZipOpen      = CAST_TO_FN_PTR(ZipOpen_t, os::dll_lookup(handle, &quot;ZIP_Open&quot;));</span>
<span class="udiff-line-removed">-   ZipClose     = CAST_TO_FN_PTR(ZipClose_t, os::dll_lookup(handle, &quot;ZIP_Close&quot;));</span>
<span class="udiff-line-removed">-   FindEntry    = CAST_TO_FN_PTR(FindEntry_t, os::dll_lookup(handle, &quot;ZIP_FindEntry&quot;));</span>
<span class="udiff-line-removed">-   ReadEntry    = CAST_TO_FN_PTR(ReadEntry_t, os::dll_lookup(handle, &quot;ZIP_ReadEntry&quot;));</span>
<span class="udiff-line-removed">-   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, os::dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;));</span>
<span class="udiff-line-removed">-   ZipInflateFully = CAST_TO_FN_PTR(ZipInflateFully_t, os::dll_lookup(handle, &quot;ZIP_InflateFully&quot;));</span>
<span class="udiff-line-removed">-   Crc32        = CAST_TO_FN_PTR(Crc32_t, os::dll_lookup(handle, &quot;ZIP_CRC32&quot;));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // ZIP_Close is not exported on Windows in JDK5.0 so don&#39;t abort if ZIP_Close is NULL</span>
<span class="udiff-line-removed">-   if (ZipOpen == NULL || FindEntry == NULL || ReadEntry == NULL ||</span>
<span class="udiff-line-removed">-       GetNextEntry == NULL || Crc32 == NULL) {</span>
<span class="udiff-line-removed">-     vm_exit_during_initialization(&quot;Corrupted ZIP library&quot;, path);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ZipInflateFully == NULL) {</span>
<span class="udiff-line-removed">-     vm_exit_during_initialization(&quot;Corrupted ZIP library ZIP_InflateFully missing&quot;, path);</span>
<span class="udiff-line-modified-added">+     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);</span>
    }
  
<span class="udiff-line-modified-removed">-   // Lookup canonicalize entry in libjava.dll</span>
<span class="udiff-line-modified-removed">-   void *javalib_handle = os::native_java_library();</span>
<span class="udiff-line-modified-removed">-   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, os::dll_lookup(javalib_handle, &quot;Canonicalize&quot;));</span>
<span class="udiff-line-modified-removed">-   // This lookup only works on 1.3. Do not check for non-null here</span>
<span class="udiff-line-modified-added">+   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));</span>
<span class="udiff-line-modified-added">+   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));</span>
<span class="udiff-line-modified-added">+   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));</span>
<span class="udiff-line-modified-added">+   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));</span>
<span class="udiff-line-added">+   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));</span>
<span class="udiff-line-added">+   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));</span>
  }
  
  void ClassLoader::load_jimage_library() {
<span class="udiff-line-modified-removed">-   // First make sure native library is loaded</span>
<span class="udiff-line-removed">-   os::native_java_library();</span>
<span class="udiff-line-removed">-   // Load jimage library</span>
<span class="udiff-line-modified-added">+   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);</span>
    char path[JVM_MAXPATHLEN];
    char ebuf[1024];
    void* handle = NULL;
    if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
      handle = os::dll_load(path, ebuf, sizeof ebuf);
    }
    if (handle == NULL) {
      vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
    }
  
<span class="udiff-line-modified-removed">-   // Lookup jimage entry points</span>
<span class="udiff-line-modified-removed">-   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, os::dll_lookup(handle, &quot;JIMAGE_Open&quot;));</span>
<span class="udiff-line-modified-removed">-   guarantee(JImageOpen != NULL, &quot;function JIMAGE_Open not found&quot;);</span>
<span class="udiff-line-modified-removed">-   JImageClose = CAST_TO_FN_PTR(JImageClose_t, os::dll_lookup(handle, &quot;JIMAGE_Close&quot;));</span>
<span class="udiff-line-modified-removed">-   guarantee(JImageClose != NULL, &quot;function JIMAGE_Close not found&quot;);</span>
<span class="udiff-line-modified-removed">-   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, os::dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;));</span>
<span class="udiff-line-removed">-   guarantee(JImagePackageToModule != NULL, &quot;function JIMAGE_PackageToModule not found&quot;);</span>
<span class="udiff-line-removed">-   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, os::dll_lookup(handle, &quot;JIMAGE_FindResource&quot;));</span>
<span class="udiff-line-removed">-   guarantee(JImageFindResource != NULL, &quot;function JIMAGE_FindResource not found&quot;);</span>
<span class="udiff-line-removed">-   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, os::dll_lookup(handle, &quot;JIMAGE_GetResource&quot;));</span>
<span class="udiff-line-removed">-   guarantee(JImageGetResource != NULL, &quot;function JIMAGE_GetResource not found&quot;);</span>
<span class="udiff-line-removed">-   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, os::dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;));</span>
<span class="udiff-line-removed">-   guarantee(JImageResourceIterator != NULL, &quot;function JIMAGE_ResourceIterator not found&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- jboolean ClassLoader::decompress(void *in, u8 inSize, void *out, u8 outSize, char **pmsg) {</span>
<span class="udiff-line-removed">-   return (*ZipInflateFully)(in, inSize, out, outSize, pmsg);</span>
<span class="udiff-line-modified-added">+   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));</span>
<span class="udiff-line-modified-added">+   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));</span>
<span class="udiff-line-modified-added">+   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));</span>
<span class="udiff-line-modified-added">+   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));</span>
<span class="udiff-line-modified-added">+   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));</span>
<span class="udiff-line-modified-added">+   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));</span>
  }
  
  int ClassLoader::crc32(int crc, const char* buf, int len) {
<span class="udiff-line-removed">-   assert(Crc32 != NULL, &quot;ZIP_CRC32 is not found&quot;);</span>
    return (*Crc32)(crc, (const jbyte*)buf, len);
  }
  
  // Function add_package extracts the package from the fully qualified class name
  // and checks if the package is in the boot loader&#39;s package entry table.  If so,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1116,15 +1040,15 @@</span>
  // classes has been loaded.
  bool ClassLoader::add_package(const char *fullq_class_name, s2 classpath_index, TRAPS) {
    assert(fullq_class_name != NULL, &quot;just checking&quot;);
  
    // Get package name from fully qualified class name.
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
    const char *cp = package_from_name(fullq_class_name);
    if (cp != NULL) {
      PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<span class="udiff-line-modified-removed">-     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp, CHECK_false);</span>
<span class="udiff-line-modified-added">+     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp);</span>
      PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(pkg_symbol);
      if (pkg_entry != NULL) {
        assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
        pkg_entry-&gt;set_classpath_index(classpath_index);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1135,11 +1059,11 @@</span>
  }
  
  oop ClassLoader::get_system_package(const char* name, TRAPS) {
    // Look up the name in the boot loader&#39;s package entry table.
    if (name != NULL) {
<span class="udiff-line-modified-removed">-     TempNewSymbol package_sym = SymbolTable::new_symbol(name, (int)strlen(name), CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     TempNewSymbol package_sym = SymbolTable::new_symbol(name);</span>
      // Look for the package entry in the boot loader&#39;s package entry table.
      PackageEntry* package =
        ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
  
      // Return NULL if package does not exist or if no classes in that package
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,11 +1088,11 @@</span>
  objArrayOop ClassLoader::get_system_packages(TRAPS) {
    ResourceMark rm(THREAD);
    // List of pointers to PackageEntrys that have loaded classes.
    GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
    {
<span class="udiff-line-modified-removed">-     MutexLocker ml(Module_lock, THREAD);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(THREAD, Module_lock);</span>
  
      PackageEntryTable* pe_table =
        ClassLoaderData::the_null_class_loader_data()-&gt;packages();
  
      // Collect the packages that have at least one loaded class.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1261,11 +1185,11 @@</span>
    if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
      if (module_list == _exploded_entries) {
        // The exploded build entries can be added to at any time so a lock is
        // needed when searching them.
        assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
<span class="udiff-line-modified-removed">-       MutexLocker ml(Module_lock, THREAD);</span>
<span class="udiff-line-modified-added">+       MutexLocker ml(THREAD, Module_lock);</span>
        e = find_first_module_cpe(mod_entry, module_list);
      } else {
        e = find_first_module_cpe(mod_entry, module_list);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1328,10 +1252,14 @@</span>
      // At CDS dump time, the --patch-module entries are ignored. That means a
      // class is still loaded from the runtime image even if it might
      // appear in the _patch_mod_entries. The runtime shared class visibility
      // check will determine if a shared class is visible based on the runtime
      // environemnt, including the runtime --patch-module setting.
<span class="udiff-line-added">+     //</span>
<span class="udiff-line-added">+     // DynamicDumpSharedSpaces requires UseSharedSpaces to be enabled. Since --patch-module</span>
<span class="udiff-line-added">+     // is not supported with UseSharedSpaces, it is not supported with DynamicDumpSharedSpaces.</span>
<span class="udiff-line-added">+     assert(!DynamicDumpSharedSpaces, &quot;sanity&quot;);</span>
      if (!DumpSharedSpaces) {
        stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1382,11 +1310,11 @@</span>
                                                             NULL, // unsafe_anonymous_host
                                                             NULL, // cp_patches
                                                             THREAD);
    if (HAS_PENDING_EXCEPTION) {
      if (DumpSharedSpaces) {
<span class="udiff-line-modified-removed">-       tty-&gt;print_cr(&quot;Preload Error: Failed to load %s&quot;, class_name);</span>
<span class="udiff-line-modified-added">+       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);</span>
      }
      return NULL;
    }
  
    if (!add_package(file_name, classpath_index, THREAD)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1417,11 +1345,11 @@</span>
  }
  
  // Record the shared classpath index and loader type for classes loaded
  // by the builtin loaders at dump time.
  void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
<span class="udiff-line-modified-removed">-   assert(DumpSharedSpaces, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+   Arguments::assert_is_dumping_archive();</span>
    assert(stream != NULL, &quot;sanity&quot;);
  
    if (ik-&gt;is_unsafe_anonymous()) {
      // We do not archive unsafe anonymous classes.
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1497,27 +1425,29 @@</span>
            }
          }
        }
        // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
        // The class must be from the runtime modules image.
<span class="udiff-line-modified-removed">-       if (i == 0 &amp;&amp; (is_modules_image(src) || string_starts_with(src, &quot;jrt:&quot;))) {</span>
<span class="udiff-line-modified-added">+       if (i == 0 &amp;&amp; (stream-&gt;from_boot_loader_modules_image() || string_starts_with(src, &quot;jrt:&quot;))) {</span>
          classpath_index = i;
          break;
        }
      }
  
      // No path entry found for this class. Must be a shared class loaded by the
      // user defined classloader.
      if (classpath_index &lt; 0) {
        assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);
<span class="udiff-line-added">+       ik-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);</span>
<span class="udiff-line-added">+       SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);</span>
        return;
      }
    } else {
      // The shared path table is set up after module system initialization.
      // The path table contains no entry before that. Any classes loaded prior
      // to the setup of the shared path table must be from the modules image.
<span class="udiff-line-modified-removed">-     assert(is_modules_image(src), &quot;stream must be from modules image&quot;);</span>
<span class="udiff-line-modified-added">+     assert(stream-&gt;from_boot_loader_modules_image(), &quot;stream must be loaded by boot loader from modules image&quot;);</span>
      assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
      classpath_index = 0;
    }
  
    const char* const class_name = ik-&gt;name()-&gt;as_C_string();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1583,33 +1513,60 @@</span>
  
      NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
                          &quot;unsafeDefineClassCalls&quot;);
    }
  
<span class="udiff-line-added">+   // lookup java library entry points</span>
<span class="udiff-line-added">+   load_java_library();</span>
    // lookup zip library entry points
    load_zip_library();
<span class="udiff-line-modified-removed">-   // lookup jimage library entry points</span>
<span class="udiff-line-modified-added">+   // jimage library entry points are loaded below, in lookup_vm_options</span>
<span class="udiff-line-added">+   setup_bootstrap_search_path();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {</span>
<span class="udiff-line-added">+   jlong size;</span>
<span class="udiff-line-added">+   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);</span>
<span class="udiff-line-added">+   if (location == 0)</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);</span>
<span class="udiff-line-added">+   (*JImageGetResource)(jimage, location, val, size);</span>
<span class="udiff-line-added">+   val[size] = &#39;\0&#39;;</span>
<span class="udiff-line-added">+   return val;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Lookup VM options embedded in the modules jimage file</span>
<span class="udiff-line-added">+ char* ClassLoader::lookup_vm_options() {</span>
<span class="udiff-line-added">+   jint error;</span>
<span class="udiff-line-added">+   char modules_path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-added">+   const char* fileSep = os::file_separator();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Initialize jimage library entry points</span>
    load_jimage_library();
<span class="udiff-line-modified-removed">- #if INCLUDE_CDS</span>
<span class="udiff-line-modified-removed">-   // initialize search path</span>
<span class="udiff-line-modified-removed">-   if (DumpSharedSpaces) {</span>
<span class="udiff-line-modified-removed">-     _shared_paths_misc_info = new SharedPathsMiscInfo();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   jio_snprintf(modules_path, JVM_MAXPATHLEN, &quot;%s%slib%smodules&quot;, Arguments::get_java_home(), fileSep, fileSep);</span>
<span class="udiff-line-modified-added">+   JImageFile* jimage =(*JImageOpen)(modules_path, &amp;error);</span>
<span class="udiff-line-modified-added">+   if (jimage == NULL) {</span>
<span class="udiff-line-added">+     return NULL;</span>
    }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-   setup_bootstrap_search_path();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   const char *jimage_version = get_jimage_version_string();</span>
<span class="udiff-line-added">+   char *options = lookup_vm_resource(jimage, jimage_version, &quot;jdk/internal/vm/options&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   (*JImageClose)(jimage);</span>
<span class="udiff-line-added">+   return options;</span>
  }
  
  #if INCLUDE_CDS
  void ClassLoader::initialize_shared_path() {
<span class="udiff-line-modified-removed">-   if (DumpSharedSpaces) {</span>
<span class="udiff-line-modified-added">+   if (Arguments::is_dumping_archive()) {</span>
      ClassLoaderExt::setup_search_paths();
<span class="udiff-line-removed">-     _shared_paths_misc_info-&gt;write_jint(0); // see comments in SharedPathsMiscInfo::check()</span>
    }
  }
  
  void ClassLoader::initialize_module_path(TRAPS) {
<span class="udiff-line-modified-removed">-   if (DumpSharedSpaces) {</span>
<span class="udiff-line-modified-added">+   if (Arguments::is_dumping_archive()) {</span>
      ClassLoaderExt::setup_module_paths(THREAD);
      FileMapInfo::allocate_shared_path_table();
    }
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1671,10 +1628,11 @@</span>
    // Setup the initial java.base/path pair for the exploded build entries.
    // As more modules are defined during module system initialization, more
    // entries will be added to the exploded build array.
    if (!has_jrt_entry()) {
      assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);
<span class="udiff-line-added">+     assert(!DynamicDumpSharedSpaces, &quot;DynamicDumpSharedSpaces not supported with exploded module builds&quot;);</span>
      assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
      // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
      // done before loading any classes, by the same thread that will
      // subsequently do the first class load. So, no lock is needed for this.
      assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1682,28 +1640,20 @@</span>
        GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
      add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
    }
  }
  
<span class="udiff-line-removed">- </span>
  bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
    assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
<span class="udiff-line-modified-removed">-   if (CanonicalizeEntry != NULL) {</span>
<span class="udiff-line-modified-removed">-     JavaThread* THREAD = JavaThread::current();</span>
<span class="udiff-line-removed">-     JNIEnv* env = THREAD-&gt;jni_environment();</span>
<span class="udiff-line-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="udiff-line-modified-added">+   ResourceMark rm(THREAD);</span>
  
<span class="udiff-line-modified-removed">-     // os::native_path writes into orig_copy</span>
<span class="udiff-line-modified-removed">-     char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);</span>
<span class="udiff-line-modified-removed">-     strcpy(orig_copy, orig);</span>
<span class="udiff-line-modified-removed">-     if ((CanonicalizeEntry)(env, os::native_path(orig_copy), out, len) &lt; 0) {</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // On JDK 1.2.2 the Canonicalize does not exist, so just do nothing</span>
<span class="udiff-line-removed">-     strncpy(out, orig, len);</span>
<span class="udiff-line-removed">-     out[len - 1] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+   // os::native_path writes into orig_copy</span>
<span class="udiff-line-modified-added">+   char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);</span>
<span class="udiff-line-modified-added">+   strcpy(orig_copy, orig);</span>
<span class="udiff-line-modified-added">+   if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) &lt; 0) {</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
    return true;
  }
  
  void ClassLoader::create_javabase() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1718,11 +1668,11 @@</span>
    if (null_cld_modules == NULL) {
      vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
    }
  
    {
<span class="udiff-line-modified-removed">-     MutexLocker ml(Module_lock, THREAD);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(THREAD, Module_lock);</span>
      ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
                                 false, vmSymbols::java_base(), NULL, NULL, null_cld);
      if (jb_module == NULL) {
        vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
      }
</pre>
<center><a href="classListParser.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
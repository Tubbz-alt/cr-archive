diff a/src/hotspot/share/classfile/moduleEntry.cpp b/src/hotspot/share/classfile/moduleEntry.cpp
--- a/src/hotspot/share/classfile/moduleEntry.cpp
+++ b/src/hotspot/share/classfile/moduleEntry.cpp
@@ -22,15 +22,17 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "jni.h"
+#include "classfile/classLoader.hpp"
 #include "classfile/classLoaderData.inline.hpp"
 #include "classfile/javaClasses.inline.hpp"
 #include "classfile/moduleEntry.hpp"
 #include "logging/log.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "oops/oopHandle.inline.hpp"
 #include "oops/symbol.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/safepoint.hpp"
 #include "utilities/events.hpp"
@@ -280,11 +282,11 @@
 
 // When creating an unnamed module, this is called without holding the Module_lock.
 // This is okay because the unnamed module gets created before the ClassLoaderData
 // is available to other threads.
 ModuleEntry* ModuleEntry::new_unnamed_module_entry(Handle module_handle, ClassLoaderData* cld) {
-  ModuleEntry* entry = (ModuleEntry*) NEW_C_HEAP_ARRAY(char, sizeof(ModuleEntry), mtModule);
+  ModuleEntry* entry = NEW_C_HEAP_OBJ(ModuleEntry, mtModule);
 
   // Initialize everything BasicHashtable would
   entry->set_next(NULL);
   entry->set_hash(0);
   entry->set_literal(NULL);
@@ -307,11 +309,11 @@
   return entry;
 }
 
 void ModuleEntry::delete_unnamed_module() {
   // Do not need unlink_entry() since the unnamed module is not in the hashtable
-  FREE_C_HEAP_ARRAY(char, this);
+  FREE_C_HEAP_OBJ(this);
 }
 
 ModuleEntryTable::ModuleEntryTable(int table_size)
   : Hashtable<Symbol*, mtModule>(table_size, sizeof(ModuleEntry))
 {

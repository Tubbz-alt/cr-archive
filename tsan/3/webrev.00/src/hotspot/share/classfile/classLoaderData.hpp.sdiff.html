<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADERDATA_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADERDATA_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;memory/metaspace.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;
 32 #include &quot;oops/weakHandle.hpp&quot;

 33 #include &quot;runtime/mutex.hpp&quot;
 34 #include &quot;utilities/growableArray.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #if INCLUDE_JFR
 37 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 38 #endif
 39 
 40 // external name (synthetic) for the primordial &quot;bootstrap&quot; class loader instance
 41 #define BOOTSTRAP_LOADER_NAME &quot;bootstrap&quot;
 42 #define BOOTSTRAP_LOADER_NAME_LEN 9
 43 
 44 //
 45 // A class loader represents a linkset. Conceptually, a linkset identifies
 46 // the complete transitive closure of resolved links that a dynamic linker can
 47 // produce.
 48 //
 49 // A ClassLoaderData also encapsulates the allocation space, called a metaspace,
 50 // used by the dynamic linker to allocate the runtime representation of all
 51 // the types it defines.
 52 //
</pre>
<hr />
<pre>
106   friend class MetaDataFactory;
107   friend class Method;
108 
109   static ClassLoaderData * _the_null_class_loader_data;
110 
111   WeakHandle&lt;vm_class_loader_data&gt; _holder; // The oop that determines lifetime of this class loader
112   OopHandle _class_loader;    // The instance of java/lang/ClassLoader associated with
113                               // this ClassLoaderData
114 
115   ClassLoaderMetaspace * volatile _metaspace;  // Meta-space where meta-data defined by the
116                                     // classes in the class loader are allocated.
117   Mutex* _metaspace_lock;  // Locks the metaspace for allocations and setup.
118   bool _unloading;         // true if this class loader goes away
119   bool _is_unsafe_anonymous; // CLD is dedicated to one class and that class determines the CLDs lifecycle.
120                              // For example, an unsafe anonymous class.
121 
122   // Remembered sets support for the oops in the class loader data.
123   bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
124   bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
125 
<span class="line-modified">126   s2 _keep_alive;          // if this CLD is kept alive.</span>
127                            // Used for unsafe anonymous classes and the boot class
128                            // loader. _keep_alive does not need to be volatile or
129                            // atomic since there is one unique CLD per unsafe anonymous class.
130 
131   volatile int _claim; // non-zero if claimed, for example during GC traces.
132                        // To avoid applying oop closure more than once.
133   ChunkedHandleList _handles; // Handles to constant pool arrays, Modules, etc, which
134                               // have the same life cycle of the corresponding ClassLoader.
135 
136   NOT_PRODUCT(volatile int _dependency_count;)  // number of class loader dependencies
137 
138   Klass* volatile _klasses;              // The classes defined by the class loader.
139   PackageEntryTable* volatile _packages; // The packages defined by the class loader.
140   ModuleEntryTable*  volatile _modules;  // The modules defined by the class loader.
141   ModuleEntry* _unnamed_module;          // This class loader&#39;s unnamed module.
142   Dictionary*  _dictionary;              // The loaded InstanceKlasses, including initiated by this class loader
143 
144   // These method IDs are created for the class loader and set to NULL when the
145   // class loader is unloaded.  They are rarely freed, only for redefine classes
146   // and if they lose a data race in InstanceKlass.
147   JNIMethodBlock*                  _jmethod_ids;
148 
149   // Metadata to be deallocated when it&#39;s safe at class unloading, when
150   // this class loader isn&#39;t unloaded itself.
151   GrowableArray&lt;Metadata*&gt;*      _deallocate_list;
152 
153   // Support for walking class loader data objects
154   ClassLoaderData* _next; /// Next loader_datas created
155 
156   Klass*  _class_loader_klass;
157   Symbol* _name;
158   Symbol* _name_and_id;
159   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
160 
161   void set_next(ClassLoaderData* next) { _next = next; }
<span class="line-modified">162   ClassLoaderData* next() const        { return _next; }</span>
163 
164   ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous);
165   ~ClassLoaderData();
166 
167   // The CLD are not placed in the Heap, so the Card Table or
168   // the Mod Union Table can&#39;t be used to mark when CLD have modified oops.
169   // The CT and MUT bits saves this information for the whole class loader data.
170   void clear_modified_oops()             { _modified_oops = false; }
171  public:
172   void record_modified_oops()            { _modified_oops = true; }
173   bool has_modified_oops()               { return _modified_oops; }
174 
175   void accumulate_modified_oops()        { if (has_modified_oops()) _accumulated_modified_oops = true; }
176   void clear_accumulated_modified_oops() { _accumulated_modified_oops = false; }
177   bool has_accumulated_modified_oops()   { return _accumulated_modified_oops; }
178   oop holder_no_keepalive() const;
179   oop holder_phantom() const;
180 
181  private:
182   void unload();
</pre>
<hr />
<pre>
188   void methods_do(void f(Method*));
189   void modules_do(void f(ModuleEntry*));
190   void packages_do(void f(PackageEntry*));
191 
192   // Deallocate free list during class unloading.
193   void free_deallocate_list();                      // for the classes that are not unloaded
194   void free_deallocate_list_C_heap_structures();    // for the classes that are unloaded
195 
196   // Allocate out of this class loader data
197   MetaWord* allocate(size_t size);
198 
199   Dictionary* create_dictionary();
200 
201   void initialize_name(Handle class_loader);
202 
203  public:
204   // GC interface.
205 
206   // The &quot;claim&quot; is typically used to check if oops_do needs to be applied on
207   // the CLD or not. Most GCs only perform strong marking during the marking phase.
<span class="line-modified">208   enum {</span>
<span class="line-modified">209     _claim_none        = 0,</span>
<span class="line-modified">210     _claim_finalizable = 2,</span>
<span class="line-modified">211     _claim_strong      = 3</span>

212   };
213   void clear_claim() { _claim = 0; }

214   bool claimed() const { return _claim != 0; }

215   bool try_claim(int claim);
<span class="line-removed">216   int get_claim() const { return _claim; }</span>
<span class="line-removed">217   void set_claim(int claim) { _claim = claim; }</span>
218 
219   // Computes if the CLD is alive or not. This is safe to call in concurrent
220   // contexts.
221   bool is_alive() const;
222 
223   // Accessors
224   ClassLoaderMetaspace* metaspace_or_null() const { return _metaspace; }
225 
226   static ClassLoaderData* the_null_class_loader_data() {
227     return _the_null_class_loader_data;
228   }
229 
230   Mutex* metaspace_lock() const { return _metaspace_lock; }
231 
232   bool is_unsafe_anonymous() const { return _is_unsafe_anonymous; }
233 
234   static void init_null_class_loader_data();
235 
236   bool is_the_null_class_loader_data() const {
237     return this == _the_null_class_loader_data;
</pre>
<hr />
<pre>
265   bool is_unloading() const     {
266     assert(!(is_the_null_class_loader_data() &amp;&amp; _unloading), &quot;The null class loader can never be unloaded&quot;);
267     return _unloading;
268   }
269 
270   // Used to refcount an unsafe anonymous class&#39;s CLD in order to
271   // indicate their aliveness.
272   void inc_keep_alive();
273   void dec_keep_alive();
274 
275   void initialize_holder(Handle holder);
276 
277   void oops_do(OopClosure* f, int claim_value, bool clear_modified_oops = false);
278 
279   void classes_do(KlassClosure* klass_closure);
280   Klass* klasses() { return _klasses; }
281 
282   JNIMethodBlock* jmethod_ids() const              { return _jmethod_ids; }
283   void set_jmethod_ids(JNIMethodBlock* new_block)  { _jmethod_ids = new_block; }
284 
<span class="line-modified">285   void print()                                     { print_on(tty); }</span>
286   void print_on(outputStream* out) const PRODUCT_RETURN;
<span class="line-modified">287   void print_value()                               { print_value_on(tty); }</span>
288   void print_value_on(outputStream* out) const;
289   void verify();
290 
291   OopHandle add_handle(Handle h);
292   void remove_handle(OopHandle h);
293   void init_handle_locked(OopHandle&amp; pd, Handle h);  // used for concurrent access to ModuleEntry::_pd field
294   void add_class(Klass* k, bool publicize = true);
295   void remove_class(Klass* k);
296   bool contains_klass(Klass* k);
297   void record_dependency(const Klass* to);
298   PackageEntryTable* packages() { return _packages; }
299   ModuleEntry* unnamed_module() { return _unnamed_module; }
300   ModuleEntryTable* modules();
301   bool modules_defined() { return (_modules != NULL); }
302 




303   // Loaded class dictionary
304   Dictionary* dictionary() const { return _dictionary; }
305 
306   void add_to_deallocate_list(Metadata* m);
307 
308   static ClassLoaderData* class_loader_data(oop loader);
309   static ClassLoaderData* class_loader_data_or_null(oop loader);
310   static ClassLoaderData* unsafe_anonymous_class_loader_data(Handle loader);
311 
312   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
313   // Also works if unloading.
314   Klass* class_loader_klass() const { return _class_loader_klass; }
315 
316   // Returns the class loader&#39;s explict name as specified during
317   // construction or the class loader&#39;s qualified class name.
318   // Works during unloading.
319   const char* loader_name() const;
320   // Returns the explicitly specified class loader name or NULL.
321   Symbol* name() const { return _name; }
322 
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADERDATA_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADERDATA_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;memory/metaspace.hpp&quot;
 31 #include &quot;oops/oopHandle.hpp&quot;
 32 #include &quot;oops/weakHandle.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/atomic.hpp&quot;</span>
 34 #include &quot;runtime/mutex.hpp&quot;
 35 #include &quot;utilities/growableArray.hpp&quot;
 36 #include &quot;utilities/macros.hpp&quot;
 37 #if INCLUDE_JFR
 38 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 39 #endif
 40 
 41 // external name (synthetic) for the primordial &quot;bootstrap&quot; class loader instance
 42 #define BOOTSTRAP_LOADER_NAME &quot;bootstrap&quot;
 43 #define BOOTSTRAP_LOADER_NAME_LEN 9
 44 
 45 //
 46 // A class loader represents a linkset. Conceptually, a linkset identifies
 47 // the complete transitive closure of resolved links that a dynamic linker can
 48 // produce.
 49 //
 50 // A ClassLoaderData also encapsulates the allocation space, called a metaspace,
 51 // used by the dynamic linker to allocate the runtime representation of all
 52 // the types it defines.
 53 //
</pre>
<hr />
<pre>
107   friend class MetaDataFactory;
108   friend class Method;
109 
110   static ClassLoaderData * _the_null_class_loader_data;
111 
112   WeakHandle&lt;vm_class_loader_data&gt; _holder; // The oop that determines lifetime of this class loader
113   OopHandle _class_loader;    // The instance of java/lang/ClassLoader associated with
114                               // this ClassLoaderData
115 
116   ClassLoaderMetaspace * volatile _metaspace;  // Meta-space where meta-data defined by the
117                                     // classes in the class loader are allocated.
118   Mutex* _metaspace_lock;  // Locks the metaspace for allocations and setup.
119   bool _unloading;         // true if this class loader goes away
120   bool _is_unsafe_anonymous; // CLD is dedicated to one class and that class determines the CLDs lifecycle.
121                              // For example, an unsafe anonymous class.
122 
123   // Remembered sets support for the oops in the class loader data.
124   bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
125   bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
126 
<span class="line-modified">127   int _keep_alive;         // if this CLD is kept alive.</span>
128                            // Used for unsafe anonymous classes and the boot class
129                            // loader. _keep_alive does not need to be volatile or
130                            // atomic since there is one unique CLD per unsafe anonymous class.
131 
132   volatile int _claim; // non-zero if claimed, for example during GC traces.
133                        // To avoid applying oop closure more than once.
134   ChunkedHandleList _handles; // Handles to constant pool arrays, Modules, etc, which
135                               // have the same life cycle of the corresponding ClassLoader.
136 
137   NOT_PRODUCT(volatile int _dependency_count;)  // number of class loader dependencies
138 
139   Klass* volatile _klasses;              // The classes defined by the class loader.
140   PackageEntryTable* volatile _packages; // The packages defined by the class loader.
141   ModuleEntryTable*  volatile _modules;  // The modules defined by the class loader.
142   ModuleEntry* _unnamed_module;          // This class loader&#39;s unnamed module.
143   Dictionary*  _dictionary;              // The loaded InstanceKlasses, including initiated by this class loader
144 
145   // These method IDs are created for the class loader and set to NULL when the
146   // class loader is unloaded.  They are rarely freed, only for redefine classes
147   // and if they lose a data race in InstanceKlass.
148   JNIMethodBlock*                  _jmethod_ids;
149 
150   // Metadata to be deallocated when it&#39;s safe at class unloading, when
151   // this class loader isn&#39;t unloaded itself.
152   GrowableArray&lt;Metadata*&gt;*      _deallocate_list;
153 
154   // Support for walking class loader data objects
155   ClassLoaderData* _next; /// Next loader_datas created
156 
157   Klass*  _class_loader_klass;
158   Symbol* _name;
159   Symbol* _name_and_id;
160   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
161 
162   void set_next(ClassLoaderData* next) { _next = next; }
<span class="line-modified">163   ClassLoaderData* next() const        { return Atomic::load(&amp;_next); }</span>
164 
165   ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous);
166   ~ClassLoaderData();
167 
168   // The CLD are not placed in the Heap, so the Card Table or
169   // the Mod Union Table can&#39;t be used to mark when CLD have modified oops.
170   // The CT and MUT bits saves this information for the whole class loader data.
171   void clear_modified_oops()             { _modified_oops = false; }
172  public:
173   void record_modified_oops()            { _modified_oops = true; }
174   bool has_modified_oops()               { return _modified_oops; }
175 
176   void accumulate_modified_oops()        { if (has_modified_oops()) _accumulated_modified_oops = true; }
177   void clear_accumulated_modified_oops() { _accumulated_modified_oops = false; }
178   bool has_accumulated_modified_oops()   { return _accumulated_modified_oops; }
179   oop holder_no_keepalive() const;
180   oop holder_phantom() const;
181 
182  private:
183   void unload();
</pre>
<hr />
<pre>
189   void methods_do(void f(Method*));
190   void modules_do(void f(ModuleEntry*));
191   void packages_do(void f(PackageEntry*));
192 
193   // Deallocate free list during class unloading.
194   void free_deallocate_list();                      // for the classes that are not unloaded
195   void free_deallocate_list_C_heap_structures();    // for the classes that are unloaded
196 
197   // Allocate out of this class loader data
198   MetaWord* allocate(size_t size);
199 
200   Dictionary* create_dictionary();
201 
202   void initialize_name(Handle class_loader);
203 
204  public:
205   // GC interface.
206 
207   // The &quot;claim&quot; is typically used to check if oops_do needs to be applied on
208   // the CLD or not. Most GCs only perform strong marking during the marking phase.
<span class="line-modified">209   enum Claim {</span>
<span class="line-modified">210     _claim_none         = 0,</span>
<span class="line-modified">211     _claim_finalizable  = 2,</span>
<span class="line-modified">212     _claim_strong       = 3,</span>
<span class="line-added">213     _claim_other        = 4</span>
214   };
215   void clear_claim() { _claim = 0; }
<span class="line-added">216   void clear_claim(int claim);</span>
217   bool claimed() const { return _claim != 0; }
<span class="line-added">218   bool claimed(int claim) const { return (_claim &amp; claim) == claim; }</span>
219   bool try_claim(int claim);


220 
221   // Computes if the CLD is alive or not. This is safe to call in concurrent
222   // contexts.
223   bool is_alive() const;
224 
225   // Accessors
226   ClassLoaderMetaspace* metaspace_or_null() const { return _metaspace; }
227 
228   static ClassLoaderData* the_null_class_loader_data() {
229     return _the_null_class_loader_data;
230   }
231 
232   Mutex* metaspace_lock() const { return _metaspace_lock; }
233 
234   bool is_unsafe_anonymous() const { return _is_unsafe_anonymous; }
235 
236   static void init_null_class_loader_data();
237 
238   bool is_the_null_class_loader_data() const {
239     return this == _the_null_class_loader_data;
</pre>
<hr />
<pre>
267   bool is_unloading() const     {
268     assert(!(is_the_null_class_loader_data() &amp;&amp; _unloading), &quot;The null class loader can never be unloaded&quot;);
269     return _unloading;
270   }
271 
272   // Used to refcount an unsafe anonymous class&#39;s CLD in order to
273   // indicate their aliveness.
274   void inc_keep_alive();
275   void dec_keep_alive();
276 
277   void initialize_holder(Handle holder);
278 
279   void oops_do(OopClosure* f, int claim_value, bool clear_modified_oops = false);
280 
281   void classes_do(KlassClosure* klass_closure);
282   Klass* klasses() { return _klasses; }
283 
284   JNIMethodBlock* jmethod_ids() const              { return _jmethod_ids; }
285   void set_jmethod_ids(JNIMethodBlock* new_block)  { _jmethod_ids = new_block; }
286 
<span class="line-modified">287   void print() const;</span>
288   void print_on(outputStream* out) const PRODUCT_RETURN;
<span class="line-modified">289   void print_value() const;</span>
290   void print_value_on(outputStream* out) const;
291   void verify();
292 
293   OopHandle add_handle(Handle h);
294   void remove_handle(OopHandle h);
295   void init_handle_locked(OopHandle&amp; pd, Handle h);  // used for concurrent access to ModuleEntry::_pd field
296   void add_class(Klass* k, bool publicize = true);
297   void remove_class(Klass* k);
298   bool contains_klass(Klass* k);
299   void record_dependency(const Klass* to);
300   PackageEntryTable* packages() { return _packages; }
301   ModuleEntry* unnamed_module() { return _unnamed_module; }
302   ModuleEntryTable* modules();
303   bool modules_defined() { return (_modules != NULL); }
304 
<span class="line-added">305   // Offsets</span>
<span class="line-added">306   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }</span>
<span class="line-added">307   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }</span>
<span class="line-added">308 </span>
309   // Loaded class dictionary
310   Dictionary* dictionary() const { return _dictionary; }
311 
312   void add_to_deallocate_list(Metadata* m);
313 
314   static ClassLoaderData* class_loader_data(oop loader);
315   static ClassLoaderData* class_loader_data_or_null(oop loader);
316   static ClassLoaderData* unsafe_anonymous_class_loader_data(Handle loader);
317 
318   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
319   // Also works if unloading.
320   Klass* class_loader_klass() const { return _class_loader_klass; }
321 
322   // Returns the class loader&#39;s explict name as specified during
323   // construction or the class loader&#39;s qualified class name.
324   // Works during unloading.
325   const char* loader_name() const;
326   // Returns the explicitly specified class loader name or NULL.
327   Symbol* name() const { return _name; }
328 
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/verificationType.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
 26 #define SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
 27 
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;oops/instanceKlass.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;oops/symbol.hpp&quot;
 32 #include &quot;runtime/handles.hpp&quot;
 33 #include &quot;runtime/signature.hpp&quot;
 34 
 35 enum {
 36   // As specifed in the JVM spec
 37   ITEM_Top = 0,
 38   ITEM_Integer = 1,
 39   ITEM_Float = 2,
 40   ITEM_Double = 3,
 41   ITEM_Long = 4,
 42   ITEM_Null = 5,
 43   ITEM_UninitializedThis = 6,
 44   ITEM_Object = 7,
 45   ITEM_Uninitialized = 8,
 46   ITEM_Bogus = (uint)-1
 47 };
 48 
 49 class ClassVerifier;
 50 
 51 class VerificationType {
 52   private:
 53     // Least significant bits of _handle are always 0, so we use these as
 54     // the indicator that the _handle is valid.  Otherwise, the _data field
 55     // contains encoded data (as specified below).  Should the VM change
 56     // and the lower bits on oops aren&#39;t 0, the assert in the constructor
 57     // will catch this and we&#39;ll have to add a descriminator tag to this
 58     // structure.
 59     union {
 60       Symbol*   _sym;
 61       uintptr_t _data;
 62     } _u;
 63 
 64     enum {
 65       // These rest are not found in classfiles, but used by the verifier
 66       ITEM_Boolean = 9, ITEM_Byte, ITEM_Short, ITEM_Char,
 67       ITEM_Long_2nd, ITEM_Double_2nd
 68     };
 69 
 70     // Enum for the _data field
 71     enum {
 72       // Bottom two bits determine if the type is a reference, primitive,
 73       // uninitialized or a query-type.
 74       TypeMask           = 0x00000003,
 75 
 76       // Topmost types encoding
 77       Reference          = 0x0,        // _sym contains the name
 78       Primitive          = 0x1,        // see below for primitive list
 79       Uninitialized      = 0x2,        // 0x00ffff00 contains bci
 80       TypeQuery          = 0x3,        // Meta-types used for category testing
 81 
 82       // Utility flags
 83       ReferenceFlag      = 0x00,       // For reference query types
 84       Category1Flag      = 0x01,       // One-word values
 85       Category2Flag      = 0x02,       // First word of a two-word value
 86       Category2_2ndFlag  = 0x04,       // Second word of a two-word value
 87 
 88       // special reference values
 89       Null               = 0x00000000, // A reference with a 0 sym is null
 90 
 91       // Primitives categories (the second byte determines the category)
 92       Category1          = (Category1Flag     &lt;&lt; 1 * BitsPerByte) | Primitive,
 93       Category2          = (Category2Flag     &lt;&lt; 1 * BitsPerByte) | Primitive,
 94       Category2_2nd      = (Category2_2ndFlag &lt;&lt; 1 * BitsPerByte) | Primitive,
 95 
 96       // Primitive values (type descriminator stored in most-signifcant bytes)
 97       // Bogus needs the &quot; | Primitive&quot;.  Else, is_reference(Bogus) returns TRUE.
 98       Bogus              = (ITEM_Bogus      &lt;&lt; 2 * BitsPerByte) | Primitive,
 99       Boolean            = (ITEM_Boolean    &lt;&lt; 2 * BitsPerByte) | Category1,
100       Byte               = (ITEM_Byte       &lt;&lt; 2 * BitsPerByte) | Category1,
101       Short              = (ITEM_Short      &lt;&lt; 2 * BitsPerByte) | Category1,
102       Char               = (ITEM_Char       &lt;&lt; 2 * BitsPerByte) | Category1,
103       Integer            = (ITEM_Integer    &lt;&lt; 2 * BitsPerByte) | Category1,
104       Float              = (ITEM_Float      &lt;&lt; 2 * BitsPerByte) | Category1,
105       Long               = (ITEM_Long       &lt;&lt; 2 * BitsPerByte) | Category2,
106       Double             = (ITEM_Double     &lt;&lt; 2 * BitsPerByte) | Category2,
107       Long_2nd           = (ITEM_Long_2nd   &lt;&lt; 2 * BitsPerByte) | Category2_2nd,
108       Double_2nd         = (ITEM_Double_2nd &lt;&lt; 2 * BitsPerByte) | Category2_2nd,
109 
110       // Used by Uninitialized (second and third bytes hold the bci)
111       BciMask            = 0xffff &lt;&lt; 1 * BitsPerByte,
112       BciForThis         = ((u2)-1),   // A bci of -1 is an Unintialized-This
113 
114       // Query values
115       ReferenceQuery     = (ReferenceFlag     &lt;&lt; 1 * BitsPerByte) | TypeQuery,
116       Category1Query     = (Category1Flag     &lt;&lt; 1 * BitsPerByte) | TypeQuery,
117       Category2Query     = (Category2Flag     &lt;&lt; 1 * BitsPerByte) | TypeQuery,
118       Category2_2ndQuery = (Category2_2ndFlag &lt;&lt; 1 * BitsPerByte) | TypeQuery
119     };
120 
121   VerificationType(uintptr_t raw_data) {
122     _u._data = raw_data;
123   }
124 
125  public:
126 
127   VerificationType() { *this = bogus_type(); }
128 
129   // Create verification types
130   static VerificationType bogus_type() { return VerificationType(Bogus); }
131   static VerificationType top_type() { return bogus_type(); } // alias
132   static VerificationType null_type() { return VerificationType(Null); }
133   static VerificationType integer_type() { return VerificationType(Integer); }
134   static VerificationType float_type() { return VerificationType(Float); }
135   static VerificationType long_type() { return VerificationType(Long); }
136   static VerificationType long2_type() { return VerificationType(Long_2nd); }
137   static VerificationType double_type() { return VerificationType(Double); }
138   static VerificationType boolean_type() { return VerificationType(Boolean); }
139   static VerificationType byte_type() { return VerificationType(Byte); }
140   static VerificationType char_type() { return VerificationType(Char); }
141   static VerificationType short_type() { return VerificationType(Short); }
142   static VerificationType double2_type()
143     { return VerificationType(Double_2nd); }
144 
145   // &quot;check&quot; types are used for queries.  A &quot;check&quot; type is not assignable
146   // to anything, but the specified types are assignable to a &quot;check&quot;.  For
147   // example, any category1 primitive is assignable to category1_check and
148   // any reference is assignable to reference_check.
149   static VerificationType reference_check()
150     { return VerificationType(ReferenceQuery); }
151   static VerificationType category1_check()
152     { return VerificationType(Category1Query); }
153   static VerificationType category2_check()
154     { return VerificationType(Category2Query); }
155   static VerificationType category2_2nd_check()
156     { return VerificationType(Category2_2ndQuery); }
157 
158   // For reference types, store the actual Symbol
159   static VerificationType reference_type(Symbol* sh) {
160       assert(((uintptr_t)sh &amp; 0x3) == 0, &quot;Symbols must be aligned&quot;);
161       // If the above assert fails in the future because oop* isn&#39;t aligned,
162       // then this type encoding system will have to change to have a tag value
163       // to descriminate between oops and primitives.
164       return VerificationType((uintptr_t)sh);
165   }
166   static VerificationType uninitialized_type(u2 bci)
167     { return VerificationType(bci &lt;&lt; 1 * BitsPerByte | Uninitialized); }
168   static VerificationType uninitialized_this_type()
169     { return uninitialized_type(BciForThis); }
170 
171   // Create based on u1 read from classfile
172   static VerificationType from_tag(u1 tag);
173 
174   bool is_bogus() const     { return (_u._data == Bogus); }
175   bool is_null() const      { return (_u._data == Null); }
176   bool is_boolean() const   { return (_u._data == Boolean); }
177   bool is_byte() const      { return (_u._data == Byte); }
178   bool is_char() const      { return (_u._data == Char); }
179   bool is_short() const     { return (_u._data == Short); }
180   bool is_integer() const   { return (_u._data == Integer); }
181   bool is_long() const      { return (_u._data == Long); }
182   bool is_float() const     { return (_u._data == Float); }
183   bool is_double() const    { return (_u._data == Double); }
184   bool is_long2() const     { return (_u._data == Long_2nd); }
185   bool is_double2() const   { return (_u._data == Double_2nd); }
186   bool is_reference() const { return ((_u._data &amp; TypeMask) == Reference); }
187   bool is_category1() const {
188     // This should return true for all one-word types, which are category1
189     // primitives, and references (including uninitialized refs).  Though
190     // the &#39;query&#39; types should technically return &#39;false&#39; here, if we
191     // allow this to return true, we can perform the test using only
192     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical &#39;ands&#39;).
193     // Since noone should call this on a query type anyway, this is ok.
194     assert(!is_check(), &quot;Must not be a check type (wrong value returned)&quot;);
195     return ((_u._data &amp; Category1) != Primitive);
196     // should only return false if it&#39;s a primitive, and the category1 flag
197     // is not set.
198   }
199   bool is_category2() const { return ((_u._data &amp; Category2) == Category2); }
200   bool is_category2_2nd() const {
201     return ((_u._data &amp; Category2_2nd) == Category2_2nd);
202   }
203   bool is_reference_check() const { return _u._data == ReferenceQuery; }
204   bool is_category1_check() const { return _u._data == Category1Query; }
205   bool is_category2_check() const { return _u._data == Category2Query; }
206   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
207   bool is_check() const { return (_u._data &amp; TypeQuery) == TypeQuery; }
208 
209   bool is_x_array(char sig) const {
210     return is_null() || (is_array() &amp;&amp; (name()-&gt;char_at(1) == sig));
211   }
212   bool is_int_array() const { return is_x_array(&#39;I&#39;); }
213   bool is_byte_array() const { return is_x_array(&#39;B&#39;); }
214   bool is_bool_array() const { return is_x_array(&#39;Z&#39;); }
215   bool is_char_array() const { return is_x_array(&#39;C&#39;); }
216   bool is_short_array() const { return is_x_array(&#39;S&#39;); }
217   bool is_long_array() const { return is_x_array(&#39;J&#39;); }
218   bool is_float_array() const { return is_x_array(&#39;F&#39;); }
219   bool is_double_array() const { return is_x_array(&#39;D&#39;); }
220   bool is_object_array() const { return is_x_array(&#39;L&#39;); }
221   bool is_array_array() const { return is_x_array(&#39;[&#39;); }
222   bool is_reference_array() const
223     { return is_object_array() || is_array_array(); }
224   bool is_object() const
225     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 1 &amp;&amp;
226               name()-&gt;char_at(0) != &#39;[&#39;); }
227   bool is_array() const
228     { return (is_reference() &amp;&amp; !is_null() &amp;&amp; name()-&gt;utf8_length() &gt;= 2 &amp;&amp;
229               name()-&gt;char_at(0) == &#39;[&#39;); }
230   bool is_uninitialized() const
231     { return ((_u._data &amp; Uninitialized) == Uninitialized); }
232   bool is_uninitialized_this() const
233     { return is_uninitialized() &amp;&amp; bci() == BciForThis; }
234 
235   VerificationType to_category2_2nd() const {
236     assert(is_category2(), &quot;Must be a double word&quot;);
237     return VerificationType(is_long() ? Long_2nd : Double_2nd);
238   }
239 
240   u2 bci() const {
241     assert(is_uninitialized(), &quot;Must be uninitialized type&quot;);
242     return ((_u._data &amp; BciMask) &gt;&gt; 1 * BitsPerByte);
243   }
244 
245   Symbol* name() const {
246     assert(is_reference() &amp;&amp; !is_null(), &quot;Must be a non-null reference&quot;);
247     return _u._sym;
248   }
249 
250   bool equals(const VerificationType&amp; t) const {
251     return (_u._data == t._u._data ||
252       (is_reference() &amp;&amp; t.is_reference() &amp;&amp; !is_null() &amp;&amp; !t.is_null() &amp;&amp;
253        name() == t.name()));
254   }
255 
256   bool operator ==(const VerificationType&amp; t) const {
257     return equals(t);
258   }
259 
260   bool operator !=(const VerificationType&amp; t) const {
261     return !equals(t);
262   }
263 
264   // The whole point of this type system - check to see if one type
265   // is assignable to another.  Returns true if one can assign &#39;from&#39; to
266   // this.
267   bool is_assignable_from(
268       const VerificationType&amp; from, ClassVerifier* context,
269       bool from_field_is_protected, TRAPS) const {
270     if (equals(from) || is_bogus()) {
271       return true;
272     } else {
273       switch(_u._data) {
274         case Category1Query:
275           return from.is_category1();
276         case Category2Query:
277           return from.is_category2();
278         case Category2_2ndQuery:
279           return from.is_category2_2nd();
280         case ReferenceQuery:
281           return from.is_reference() || from.is_uninitialized();
282         case Boolean:
283         case Byte:
284         case Char:
285         case Short:
286           // An int can be assigned to boolean, byte, char or short values.
287           return from.is_integer();
288         default:
289           if (is_reference() &amp;&amp; from.is_reference()) {
290             return is_reference_assignable_from(from, context,
291                                                 from_field_is_protected,
292                                                 THREAD);
293           } else {
294             return false;
295           }
296       }
297     }
298   }
299 
300   // Check to see if one array component type is assignable to another.
301   // Same as is_assignable_from() except int primitives must be identical.
302   bool is_component_assignable_from(
303       const VerificationType&amp; from, ClassVerifier* context,
304       bool from_field_is_protected, TRAPS) const {
305     if (equals(from) || is_bogus()) {
306       return true;
307     } else {
308       switch(_u._data) {
309         case Boolean:
310         case Byte:
311         case Char:
312         case Short:
313           return false;
314         default:
315           return is_assignable_from(from, context, from_field_is_protected, THREAD);
316       }
317     }
318   }
319 
320   VerificationType get_component(ClassVerifier* context, TRAPS) const;
321 
322   int dimensions() const {
323     assert(is_array(), &quot;Must be an array&quot;);
324     int index = 0;
325     while (name()-&gt;char_at(index) == &#39;[&#39;) index++;
326     return index;
327   }
328 
329   void print_on(outputStream* st) const;
330 
331  private:
332 
333   bool is_reference_assignable_from(
334     const VerificationType&amp;, ClassVerifier*, bool from_field_is_protected,
335     TRAPS) const;
336 
337  public:
338   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
339                                               Symbol* from_name, bool from_field_is_protected,
340                                               bool from_is_array, bool from_is_object,
341                                               TRAPS);
342 };
343 
344 #endif // SHARE_CLASSFILE_VERIFICATIONTYPE_HPP
    </pre>
  </body>
</html>
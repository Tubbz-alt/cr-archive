<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classLoader.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADER_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADER_HPP
 27 
 28 #include &quot;jimage.hpp&quot;
<a name="1" id="anc1"></a>
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;runtime/perfData.hpp&quot;
 31 #include &quot;utilities/exceptions.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 // The VM class loader.
 35 #include &lt;sys/stat.h&gt;
 36 
 37 // Name of boot &quot;modules&quot; image
 38 #define  MODULES_IMAGE_NAME &quot;modules&quot;
 39 
 40 // Class path entry (directory or zip file)
 41 
 42 class JImageFile;
 43 class ClassFileStream;
 44 class PackageEntry;
 45 template &lt;typename T&gt; class GrowableArray;
 46 
 47 class ClassPathEntry : public CHeapObj&lt;mtClass&gt; {
 48 private:
 49   ClassPathEntry* volatile _next;
<a name="2" id="anc2"></a>

 50 public:
 51   ClassPathEntry* next() const;
 52   virtual ~ClassPathEntry() {}
 53   void set_next(ClassPathEntry* next);
<a name="3" id="anc3"></a><span class="line-modified"> 54   virtual bool is_modules_image() const = 0;</span>
<span class="line-modified"> 55   virtual bool is_jar_file() const = 0;</span>


 56   virtual const char* name() const = 0;
<a name="4" id="anc4"></a><span class="line-modified"> 57   virtual JImageFile* jimage() const = 0;</span>
<span class="line-modified"> 58   virtual void close_jimage() = 0;</span>
 59   // Constructor
 60   ClassPathEntry() : _next(NULL) {}
 61   // Attempt to locate file_name through this class path entry.
 62   // Returns a class file parsing stream if successfull.
 63   virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;
<a name="5" id="anc5"></a>



 64 };
 65 
 66 class ClassPathDirEntry: public ClassPathEntry {
 67  private:
 68   const char* _dir;           // Name of directory
 69  public:
<a name="6" id="anc6"></a><span class="line-removed"> 70   bool is_modules_image() const { return false; }</span>
<span class="line-removed"> 71   bool is_jar_file() const { return false;  }</span>
 72   const char* name() const { return _dir; }
<a name="7" id="anc7"></a><span class="line-modified"> 73   JImageFile* jimage() const { return NULL; }</span>
<span class="line-modified"> 74   void close_jimage() {}</span>
<span class="line-modified"> 75   ClassPathDirEntry(const char* dir);</span>
 76   virtual ~ClassPathDirEntry() {}
 77   ClassFileStream* open_stream(const char* name, TRAPS);
 78 };
 79 
<a name="8" id="anc8"></a><span class="line-removed"> 80 </span>
 81 // Type definitions for zip file and zip file entry
 82 typedef void* jzfile;
 83 typedef struct {
 84   char *name;                   /* entry name */
 85   jlong time;                   /* modification time */
 86   jlong size;                   /* size of uncompressed data */
 87   jlong csize;                  /* size of compressed data (zero if uncompressed) */
 88   jint crc;                     /* crc of uncompressed data */
 89   char *comment;                /* optional zip file comment */
 90   jbyte *extra;                 /* optional extra data */
 91   jlong pos;                    /* position of LOC header (if negative) or data */
 92 } jzentry;
 93 
 94 class ClassPathZipEntry: public ClassPathEntry {
 95  private:
 96   jzfile* _zip;              // The zip archive
 97   const char*   _zip_name;   // Name of zip archive
<a name="9" id="anc9"></a>
 98  public:
<a name="10" id="anc10"></a><span class="line-removed"> 99   bool is_modules_image() const { return false; }</span>
100   bool is_jar_file() const { return true;  }
<a name="11" id="anc11"></a>
101   const char* name() const { return _zip_name; }
<a name="12" id="anc12"></a><span class="line-modified">102   JImageFile* jimage() const { return NULL; }</span>
<span class="line-removed">103   void close_jimage() {}</span>
<span class="line-removed">104   ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append);</span>
105   virtual ~ClassPathZipEntry();
106   u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
107   ClassFileStream* open_stream(const char* name, TRAPS);
108   void contents_do(void f(const char* name, void* context), void* context);
109 };
110 
111 
112 // For java image files
113 class ClassPathImageEntry: public ClassPathEntry {
114 private:
115   JImageFile* _jimage;
116   const char* _name;
<a name="13" id="anc13"></a>
117 public:
118   bool is_modules_image() const;
<a name="14" id="anc14"></a><span class="line-removed">119   bool is_jar_file() const { return false; }</span>
120   bool is_open() const { return _jimage != NULL; }
121   const char* name() const { return _name == NULL ? &quot;&quot; : _name; }
122   JImageFile* jimage() const { return _jimage; }
123   void close_jimage();
124   ClassPathImageEntry(JImageFile* jimage, const char* name);
125   virtual ~ClassPathImageEntry();
126   ClassFileStream* open_stream(const char* name, TRAPS);
<a name="15" id="anc15"></a>
127 };
128 
129 // ModuleClassPathList contains a linked list of ClassPathEntry&#39;s
130 // that have been specified for a specific module.  Currently,
131 // the only way to specify a module/path pair is via the --patch-module
132 // command line option.
133 class ModuleClassPathList : public CHeapObj&lt;mtClass&gt; {
134 private:
135   Symbol* _module_name;
136   // First and last entries of class path entries for a specific module
137   ClassPathEntry* _module_first_entry;
138   ClassPathEntry* _module_last_entry;
139 public:
140   Symbol* module_name() const { return _module_name; }
141   ClassPathEntry* module_first_entry() const { return _module_first_entry; }
142   ModuleClassPathList(Symbol* module_name);
143   ~ModuleClassPathList();
144   void add_to_list(ClassPathEntry* new_entry);
145 };
146 
<a name="16" id="anc16"></a><span class="line-removed">147 class SharedPathsMiscInfo;</span>
<span class="line-removed">148 </span>
149 class ClassLoader: AllStatic {
150  public:
151   enum ClassLoaderType {
152     BOOT_LOADER = 1,      /* boot loader */
153     PLATFORM_LOADER  = 2, /* PlatformClassLoader */
154     APP_LOADER  = 3       /* AppClassLoader */
155   };
156  protected:
157 
158   // Performance counters
159   static PerfCounter* _perf_accumulated_time;
160   static PerfCounter* _perf_classes_inited;
161   static PerfCounter* _perf_class_init_time;
162   static PerfCounter* _perf_class_init_selftime;
163   static PerfCounter* _perf_classes_verified;
164   static PerfCounter* _perf_class_verify_time;
165   static PerfCounter* _perf_class_verify_selftime;
166   static PerfCounter* _perf_classes_linked;
167   static PerfCounter* _perf_class_link_time;
168   static PerfCounter* _perf_class_link_selftime;
169   static PerfCounter* _perf_class_parse_time;
170   static PerfCounter* _perf_class_parse_selftime;
171   static PerfCounter* _perf_sys_class_lookup_time;
172   static PerfCounter* _perf_shared_classload_time;
173   static PerfCounter* _perf_sys_classload_time;
174   static PerfCounter* _perf_app_classload_time;
175   static PerfCounter* _perf_app_classload_selftime;
176   static PerfCounter* _perf_app_classload_count;
177   static PerfCounter* _perf_define_appclasses;
178   static PerfCounter* _perf_define_appclass_time;
179   static PerfCounter* _perf_define_appclass_selftime;
180   static PerfCounter* _perf_app_classfile_bytes_read;
181   static PerfCounter* _perf_sys_classfile_bytes_read;
182 
183   static PerfCounter* _sync_systemLoaderLockContentionRate;
184   static PerfCounter* _sync_nonSystemLoaderLockContentionRate;
185   static PerfCounter* _sync_JVMFindLoadedClassLockFreeCounter;
186   static PerfCounter* _sync_JVMDefineClassLockFreeCounter;
187   static PerfCounter* _sync_JNIDefineClassLockFreeCounter;
188 
189   static PerfCounter* _unsafe_defineClassCallCounter;
190 
191   // The boot class path consists of 3 ordered pieces:
192   //  1. the module/path pairs specified to --patch-module
193   //    --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
194   //  2. the base piece
195   //    [jimage | build with exploded modules]
196   //  3. boot loader append path
197   //    [-Xbootclasspath/a]; [jvmti appended entries]
198   //
199   // The boot loader must obey this order when attempting
200   // to load a class.
201 
202   // 1. Contains the module/path pairs specified to --patch-module
203   static GrowableArray&lt;ModuleClassPathList*&gt;* _patch_mod_entries;
204 
205   // 2. the base piece
206   //    Contains the ClassPathEntry of the modular java runtime image.
207   //    If no java runtime image is present, this indicates a
208   //    build with exploded modules is being used instead.
209   static ClassPathEntry* _jrt_entry;
210   static GrowableArray&lt;ModuleClassPathList*&gt;* _exploded_entries;
211   enum { EXPLODED_ENTRY_SIZE = 80 }; // Initial number of exploded modules
212 
213   // 3. the boot loader&#39;s append path
214   //    [-Xbootclasspath/a]; [jvmti appended entries]
215   //    Note: boot loader append path does not support named modules.
216   static ClassPathEntry* _first_append_entry;
217   // Last entry in linked list of appended ClassPathEntry instances
218   static ClassPathEntry* _last_append_entry;
219 
220   // Info used by CDS
<a name="17" id="anc17"></a><span class="line-removed">221   CDS_ONLY(static SharedPathsMiscInfo * _shared_paths_misc_info;)</span>
<span class="line-removed">222 </span>
223   CDS_ONLY(static ClassPathEntry* _app_classpath_entries;)
224   CDS_ONLY(static ClassPathEntry* _last_app_classpath_entry;)
225   CDS_ONLY(static ClassPathEntry* _module_path_entries;)
226   CDS_ONLY(static ClassPathEntry* _last_module_path_entry;)
227   CDS_ONLY(static void setup_app_search_path(const char* class_path);)
228   CDS_ONLY(static void setup_module_search_path(const char* path, TRAPS);)
229   static void add_to_app_classpath_entries(const char* path,
230                                            ClassPathEntry* entry,
231                                            bool check_for_duplicates);
232   CDS_ONLY(static void add_to_module_path_entries(const char* path,
233                                            ClassPathEntry* entry);)
234  public:
235   CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})
236   CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})
237 
<a name="18" id="anc18"></a>

238  protected:
239   // Initialization:
240   //   - setup the boot loader&#39;s system class path
241   //   - setup the boot loader&#39;s patch mod entries, if present
242   //   - create the ModuleEntry for java.base
243   static void setup_bootstrap_search_path();
244   static void setup_boot_search_path(const char *class_path);
245   static void setup_patch_mod_entries();
246   static void create_javabase();
247 
<a name="19" id="anc19"></a>

248   static void load_zip_library();
249   static void load_jimage_library();
250 
251  public:
252   static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,
253                                                  bool throw_exception,
<a name="20" id="anc20"></a><span class="line-modified">254                                                  bool is_boot_append, TRAPS);</span>

255 
256   // If the package for the fully qualified class name is in the boot
257   // loader&#39;s package entry table then add_package() sets the classpath_index
258   // field so that get_system_package() will know to return a non-null value
259   // for the package&#39;s location.  And, so that the package will be added to
260   // the list of packages returned by get_system_packages().
261   // For packages whose classes are loaded from the boot loader class path, the
262   // classpath_index indicates which entry on the boot loader class path.
263   static bool add_package(const char *fullq_class_name, s2 classpath_index, TRAPS);
264 
265   // Canonicalizes path names, so strcmp will work properly. This is mainly
266   // to avoid confusing the zip library
267   static bool get_canonical_path(const char* orig, char* out, int len);
268   static const char* file_name_for_class_name(const char* class_name,
269                                               int class_name_len);
270   static PackageEntry* get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS);
271 
272  public:
<a name="21" id="anc21"></a><span class="line-removed">273   static jboolean decompress(void *in, u8 inSize, void *out, u8 outSize, char **pmsg);</span>
274   static int crc32(int crc, const char* buf, int len);
275   static bool update_class_path_entry_list(const char *path,
276                                            bool check_for_duplicates,
277                                            bool is_boot_append,
<a name="22" id="anc22"></a>
278                                            bool throw_exception=true);
279   CDS_ONLY(static void update_module_path_entry_list(const char *path, TRAPS);)
280   static void print_bootclasspath();
281 
282   // Timing
283   static PerfCounter* perf_accumulated_time()         { return _perf_accumulated_time; }
284   static PerfCounter* perf_classes_inited()           { return _perf_classes_inited; }
285   static PerfCounter* perf_class_init_time()          { return _perf_class_init_time; }
286   static PerfCounter* perf_class_init_selftime()      { return _perf_class_init_selftime; }
287   static PerfCounter* perf_classes_verified()         { return _perf_classes_verified; }
288   static PerfCounter* perf_class_verify_time()        { return _perf_class_verify_time; }
289   static PerfCounter* perf_class_verify_selftime()    { return _perf_class_verify_selftime; }
290   static PerfCounter* perf_classes_linked()           { return _perf_classes_linked; }
291   static PerfCounter* perf_class_link_time()          { return _perf_class_link_time; }
292   static PerfCounter* perf_class_link_selftime()      { return _perf_class_link_selftime; }
293   static PerfCounter* perf_class_parse_time()         { return _perf_class_parse_time; }
294   static PerfCounter* perf_class_parse_selftime()     { return _perf_class_parse_selftime; }
295   static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }
296   static PerfCounter* perf_shared_classload_time()    { return _perf_shared_classload_time; }
297   static PerfCounter* perf_sys_classload_time()       { return _perf_sys_classload_time; }
298   static PerfCounter* perf_app_classload_time()       { return _perf_app_classload_time; }
299   static PerfCounter* perf_app_classload_selftime()   { return _perf_app_classload_selftime; }
300   static PerfCounter* perf_app_classload_count()      { return _perf_app_classload_count; }
301   static PerfCounter* perf_define_appclasses()        { return _perf_define_appclasses; }
302   static PerfCounter* perf_define_appclass_time()     { return _perf_define_appclass_time; }
303   static PerfCounter* perf_define_appclass_selftime() { return _perf_define_appclass_selftime; }
304   static PerfCounter* perf_app_classfile_bytes_read() { return _perf_app_classfile_bytes_read; }
305   static PerfCounter* perf_sys_classfile_bytes_read() { return _perf_sys_classfile_bytes_read; }
306 
307   // Record how often system loader lock object is contended
308   static PerfCounter* sync_systemLoaderLockContentionRate() {
309     return _sync_systemLoaderLockContentionRate;
310   }
311 
312   // Record how often non system loader lock object is contended
313   static PerfCounter* sync_nonSystemLoaderLockContentionRate() {
314     return _sync_nonSystemLoaderLockContentionRate;
315   }
316 
317   // Record how many calls to JVM_FindLoadedClass w/o holding a lock
318   static PerfCounter* sync_JVMFindLoadedClassLockFreeCounter() {
319     return _sync_JVMFindLoadedClassLockFreeCounter;
320   }
321 
322   // Record how many calls to JVM_DefineClass w/o holding a lock
323   static PerfCounter* sync_JVMDefineClassLockFreeCounter() {
324     return _sync_JVMDefineClassLockFreeCounter;
325   }
326 
327   // Record how many calls to jni_DefineClass w/o holding a lock
328   static PerfCounter* sync_JNIDefineClassLockFreeCounter() {
329     return _sync_JNIDefineClassLockFreeCounter;
330   }
331 
332   // Record how many calls to Unsafe_DefineClass
333   static PerfCounter* unsafe_defineClassCallCounter() {
334     return _unsafe_defineClassCallCounter;
335   }
336 
337   // Modular java runtime image is present vs. a build with exploded modules
338   static bool has_jrt_entry() { return (_jrt_entry != NULL); }
339   static ClassPathEntry* get_jrt_entry() { return _jrt_entry; }
340   static void close_jrt_image();
341 
342   // Add a module&#39;s exploded directory to the boot loader&#39;s exploded module build list
343   static void add_to_exploded_build_list(Symbol* module_name, TRAPS);
344 
345   // Attempt load of individual class from either the patched or exploded modules build lists
346   static ClassFileStream* search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
347                                                 const char* const class_name,
348                                                 const char* const file_name, TRAPS);
349 
350   // Load individual .class file
351   static InstanceKlass* load_class(Symbol* class_name, bool search_append_only, TRAPS);
352 
353   // If the specified package has been loaded by the system, then returns
354   // the name of the directory or ZIP file that the package was loaded from.
355   // Returns null if the package was not loaded.
356   // Note: The specified name can either be the name of a class or package.
357   // If a package name is specified, then it must be &quot;/&quot;-separator and also
358   // end with a trailing &quot;/&quot;.
359   static oop get_system_package(const char* name, TRAPS);
360 
361   // Returns an array of Java strings representing all of the currently
362   // loaded system packages.
363   // Note: The package names returned are &quot;/&quot;-separated and end with a
364   // trailing &quot;/&quot;.
365   static objArrayOop get_system_packages(TRAPS);
366 
367   // Initialization
368   static void initialize();
369   static void classLoader_init2(TRAPS);
370   CDS_ONLY(static void initialize_shared_path();)
371   CDS_ONLY(static void initialize_module_path(TRAPS);)
372 
373   static int compute_Object_vtable();
374 
375   static ClassPathEntry* classpath_entry(int n);
376 
377   static bool is_in_patch_mod_entries(Symbol* module_name);
378 
379 #if INCLUDE_CDS
380   // Sharing dump and restore
381 
382   // Helper function used by CDS code to get the number of boot classpath
383   // entries during shared classpath setup time.
384   static int num_boot_classpath_entries();
385 
386   static ClassPathEntry* get_next_boot_classpath_entry(ClassPathEntry* e);
387 
388   // Helper function used by CDS code to get the number of app classpath
389   // entries during shared classpath setup time.
390   static int num_app_classpath_entries();
391 
392   // Helper function used by CDS code to get the number of module path
393   // entries during shared classpath setup time.
394   static int num_module_path_entries() {
<a name="23" id="anc23"></a><span class="line-modified">395     assert(DumpSharedSpaces, &quot;Should only be called at CDS dump time&quot;);</span>
396     int num_entries = 0;
397     ClassPathEntry* e= ClassLoader::_module_path_entries;
398     while (e != NULL) {
399       num_entries ++;
400       e = e-&gt;next();
401     }
402     return num_entries;
403   }
<a name="24" id="anc24"></a><span class="line-removed">404   static void  finalize_shared_paths_misc_info();</span>
<span class="line-removed">405   static int   get_shared_paths_misc_info_size();</span>
<span class="line-removed">406   static void* get_shared_paths_misc_info();</span>
<span class="line-removed">407   static bool  check_shared_paths_misc_info(void* info, int size);</span>
408   static void  exit_with_path_failure(const char* error, const char* message);
409   static char* skip_uri_protocol(char* source);
410   static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
411 #endif
<a name="25" id="anc25"></a>


412   static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,
413                                                 const char* file_name, jlong &amp;size);
414 
415   static void  trace_class_path(const char* msg, const char* name = NULL);
416 
417   // VM monitoring and management support
418   static jlong classloader_time_ms();
419   static jlong class_method_total_size();
420   static jlong class_init_count();
421   static jlong class_init_time_ms();
422   static jlong class_verify_time_ms();
423   static jlong class_link_count();
424   static jlong class_link_time_ms();
425 
426   // indicates if class path already contains a entry (exact match by name)
427   static bool contains_append_entry(const char* name);
428 
429   // adds a class path to the boot append entries
430   static void add_to_boot_append_entries(ClassPathEntry* new_entry);
431 
432   // creates a class path zip entry (returns NULL if JAR file cannot be opened)
433   static ClassPathZipEntry* create_class_path_zip_entry(const char *apath, bool is_boot_append);
434 
435   static bool string_ends_with(const char* str, const char* str_to_find);
436 
437   // obtain package name from a fully qualified class name
438   // *bad_class_name is set to true if there&#39;s a problem with parsing class_name, to
439   // distinguish from a class_name with no package name, as both cases have a NULL return value
440   static const char* package_from_name(const char* const class_name, bool* bad_class_name = NULL);
441 
<a name="26" id="anc26"></a><span class="line-removed">442   static bool is_modules_image(const char* name) { return string_ends_with(name, MODULES_IMAGE_NAME); }</span>
<span class="line-removed">443 </span>
444   // Debugging
445   static void verify()              PRODUCT_RETURN;
446 };
447 
448 // PerfClassTraceTime is used to measure time for class loading related events.
449 // This class tracks cumulative time and exclusive time for specific event types.
450 // During the execution of one event, other event types (e.g. class loading and
451 // resolution) as well as recursive calls of the same event type could happen.
452 // Only one elapsed timer (cumulative) and one thread-local self timer (exclusive)
453 // (i.e. only one event type) are active at a time even multiple PerfClassTraceTime
454 // instances have been created as multiple events are happening.
455 class PerfClassTraceTime {
456  public:
457   enum {
458     CLASS_LOAD   = 0,
459     PARSE_CLASS  = 1,
460     CLASS_LINK   = 2,
461     CLASS_VERIFY = 3,
462     CLASS_CLINIT = 4,
463     DEFINE_CLASS = 5,
464     EVENT_TYPE_COUNT = 6
465   };
466  protected:
467   // _t tracks time from initialization to destruction of this timer instance
468   // including time for all other event types, and recursive calls of this type.
469   // When a timer is called recursively, the elapsedTimer _t would not be used.
470   elapsedTimer     _t;
471   PerfLongCounter* _timep;
472   PerfLongCounter* _selftimep;
473   PerfLongCounter* _eventp;
474   // pointer to thread-local recursion counter and timer array
475   // The thread_local timers track cumulative time for specific event types
476   // exclusive of time for other event types, but including recursive calls
477   // of the same type.
478   int*             _recursion_counters;
479   elapsedTimer*    _timers;
480   int              _event_type;
481   int              _prev_active_event;
482 
483  public:
484 
485   inline PerfClassTraceTime(PerfLongCounter* timep,     /* counter incremented with inclusive time */
486                             PerfLongCounter* selftimep, /* counter incremented with exclusive time */
487                             PerfLongCounter* eventp,    /* event counter */
488                             int* recursion_counters,    /* thread-local recursion counter array */
489                             elapsedTimer* timers,       /* thread-local timer array */
490                             int type                    /* event type */ ) :
491       _timep(timep), _selftimep(selftimep), _eventp(eventp), _recursion_counters(recursion_counters), _timers(timers), _event_type(type) {
492     initialize();
493   }
494 
495   inline PerfClassTraceTime(PerfLongCounter* timep,     /* counter incremented with inclusive time */
496                             elapsedTimer* timers,       /* thread-local timer array */
497                             int type                    /* event type */ ) :
498       _timep(timep), _selftimep(NULL), _eventp(NULL), _recursion_counters(NULL), _timers(timers), _event_type(type) {
499     initialize();
500   }
501 
502   inline void suspend() { _t.stop(); _timers[_event_type].stop(); }
503   inline void resume()  { _t.start(); _timers[_event_type].start(); }
504 
505   ~PerfClassTraceTime();
506   void initialize();
507 };
508 
509 #endif // SHARE_CLASSFILE_CLASSLOADER_HPP
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
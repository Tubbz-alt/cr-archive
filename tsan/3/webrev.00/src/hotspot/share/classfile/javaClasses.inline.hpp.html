<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 26 #define SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 void java_lang_String::set_coder(oop string, jbyte coder) {
 34   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 35   string-&gt;byte_field_put(coder_offset, coder);
 36 }
 37 
 38 void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {
 39   assert(initialized, &quot;Must be initialized&quot;);
 40   string-&gt;obj_field_put_raw(value_offset, buffer);
 41 }
 42 
 43 void java_lang_String::set_value(oop string, typeArrayOop buffer) {
 44   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 45   string-&gt;obj_field_put(value_offset, (oop)buffer);
 46 }
 47 
 48 bool java_lang_String::hash_is_set(oop java_string) {
 49   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 50   return java_string-&gt;int_field(hash_offset) != 0 || java_string-&gt;bool_field(hashIsZero_offset) != 0;
 51 }
 52 
 53 // Accessors
 54 bool java_lang_String::value_equals(typeArrayOop str_value1, typeArrayOop str_value2) {
 55   return ((str_value1 == str_value2) ||
 56           (str_value1-&gt;length() == str_value2-&gt;length() &amp;&amp;
 57            (!memcmp(str_value1-&gt;base(T_BYTE),
 58                     str_value2-&gt;base(T_BYTE),
 59                     str_value2-&gt;length() * sizeof(jbyte)))));
 60 }
 61 
 62 typeArrayOop java_lang_String::value(oop java_string) {
 63   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 64   assert(is_instance(java_string), &quot;must be java_string&quot;);
 65   return (typeArrayOop) java_string-&gt;obj_field(value_offset);
 66 }
 67 
 68 typeArrayOop java_lang_String::value_no_keepalive(oop java_string) {
 69   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 70   assert(is_instance(java_string), &quot;must be java_string&quot;);
 71   return (typeArrayOop) java_string-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(value_offset);
 72 }
 73 
 74 bool java_lang_String::is_latin1(oop java_string) {
 75   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 76   assert(is_instance(java_string), &quot;must be java_string&quot;);
 77   jbyte coder = java_string-&gt;byte_field(coder_offset);
 78   assert(CompactStrings || coder == CODER_UTF16, &quot;Must be UTF16 without CompactStrings&quot;);
 79   return coder == CODER_LATIN1;
 80 }
 81 
 82 int java_lang_String::length(oop java_string, typeArrayOop value) {
 83   assert(initialized, &quot;Must be initialized&quot;);
 84   assert(is_instance(java_string), &quot;must be java_string&quot;);
 85   assert(value_equals(value, java_lang_String::value(java_string)),
 86          &quot;value must be equal to java_lang_String::value(java_string)&quot;);
 87   if (value == NULL) {
 88     return 0;
 89   }
 90   int arr_length = value-&gt;length();
 91   if (!is_latin1(java_string)) {
 92     assert((arr_length &amp; 1) == 0, &quot;should be even for UTF16 string&quot;);
 93     arr_length &gt;&gt;= 1; // convert number of bytes to number of elements
 94   }
 95   return arr_length;
 96 }
 97 
 98 int java_lang_String::length(oop java_string) {
 99   assert(initialized, &quot;Must be initialized&quot;);
100   assert(is_instance(java_string), &quot;must be java_string&quot;);
101   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
102   return length(java_string, value);
103 }
104 
105 bool java_lang_String::is_instance_inlined(oop obj) {
106   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::String_klass();
107 }
108 
109 // Accessors
110 oop java_lang_ref_Reference::referent(oop ref) {
111   return ref-&gt;obj_field(referent_offset);
112 }
113 
114 void java_lang_ref_Reference::set_referent(oop ref, oop value) {
115   ref-&gt;obj_field_put(referent_offset, value);
116 }
117 
118 void java_lang_ref_Reference::set_referent_raw(oop ref, oop value) {
119   ref-&gt;obj_field_put_raw(referent_offset, value);
120 }
121 
122 HeapWord* java_lang_ref_Reference::referent_addr_raw(oop ref) {
123   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(referent_offset);
124 }
125 
126 oop java_lang_ref_Reference::next(oop ref) {
127   return ref-&gt;obj_field(next_offset);
128 }
129 
130 void java_lang_ref_Reference::set_next(oop ref, oop value) {
131   ref-&gt;obj_field_put(next_offset, value);
132 }
133 
134 void java_lang_ref_Reference::set_next_raw(oop ref, oop value) {
135   ref-&gt;obj_field_put_raw(next_offset, value);
136 }
137 
138 HeapWord* java_lang_ref_Reference::next_addr_raw(oop ref) {
139   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(next_offset);
140 }
141 
142 oop java_lang_ref_Reference::discovered(oop ref) {
143   return ref-&gt;obj_field(discovered_offset);
144 }
145 
146 void java_lang_ref_Reference::set_discovered(oop ref, oop value) {
147   ref-&gt;obj_field_put(discovered_offset, value);
148 }
149 
150 void java_lang_ref_Reference::set_discovered_raw(oop ref, oop value) {
151   ref-&gt;obj_field_put_raw(discovered_offset, value);
152 }
153 
154 HeapWord* java_lang_ref_Reference::discovered_addr_raw(oop ref) {
155   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(discovered_offset);
156 }
157 
158 bool java_lang_ref_Reference::is_final(oop ref) {
159   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_FINAL;
160 }
161 
162 bool java_lang_ref_Reference::is_phantom(oop ref) {
163   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_PHANTOM;
164 }
165 
166 inline void java_lang_invoke_CallSite::set_target_volatile(oop site, oop target) {
167   site-&gt;obj_field_put_volatile(_target_offset, target);
168 }
169 
170 inline oop  java_lang_invoke_CallSite::target(oop site) {
171   return site-&gt;obj_field(_target_offset);
172 }
173 
174 inline void java_lang_invoke_CallSite::set_target(oop site, oop target) {
175   site-&gt;obj_field_put(_target_offset, target);
176 }
177 
178 inline bool java_lang_invoke_CallSite::is_instance(oop obj) {
179   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
180 }
181 
182 inline jboolean java_lang_invoke_ConstantCallSite::is_frozen(oop site) {
183   return site-&gt;bool_field(_is_frozen_offset);
184 }
185 
186 inline bool java_lang_invoke_ConstantCallSite::is_instance(oop obj) {
187   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
188 }
189 
190 inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {
191   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
192 }
193 
194 inline bool java_lang_invoke_MemberName::is_instance(oop obj) {
195   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MemberName_klass();
196 }
197 
198 inline bool java_lang_invoke_ResolvedMethodName::is_instance(oop obj) {
199   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::ResolvedMethodName_klass();
200 }
201 
202 inline bool java_lang_invoke_MethodType::is_instance(oop obj) {
203   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MethodType_klass();
204 }
205 
206 inline bool java_lang_invoke_MethodHandle::is_instance(oop obj) {
207   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
208 }
209 
210 inline bool java_lang_Class::is_instance(oop obj) {
211   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Class_klass();
212 }
213 
214 inline bool java_lang_Class::is_primitive(oop java_class) {
215   // should assert:
216   //assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
217   bool is_primitive = (java_class-&gt;metadata_field(_klass_offset) == NULL);
218 
219 #ifdef ASSERT
220   if (is_primitive) {
221     Klass* k = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
222     assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)-&gt;element_type()),
223         &quot;Should be either the T_VOID primitive or a java primitive&quot;);
224   }
225 #endif
226 
227   return is_primitive;
228 }
229 
230 inline int java_lang_Class::oop_size_raw(oop java_class) {
231   assert(_oop_size_offset != 0, &quot;must be set&quot;);
232   int size = java_class-&gt;int_field_raw(_oop_size_offset);
233   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
234   return size;
235 }
236 
237 inline bool java_lang_invoke_DirectMethodHandle::is_instance(oop obj) {
238   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
239 }
240 
241 inline bool java_lang_Module::is_instance(oop obj) {
242   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Module_klass();
243 }
244 
245 inline int Backtrace::merge_bci_and_version(int bci, int version) {
246   // only store u2 for version, checking for overflow.
247   if (version &gt; USHRT_MAX || version &lt; 0) version = USHRT_MAX;
248   assert((jushort)bci == bci, &quot;bci should be short&quot;);
249   return build_int_from_shorts(version, bci);
250 }
251 
252 inline int Backtrace::merge_mid_and_cpref(int mid, int cpref) {
253   // only store u2 for mid and cpref, checking for overflow.
254   assert((jushort)mid == mid, &quot;mid should be short&quot;);
255   assert((jushort)cpref == cpref, &quot;cpref should be short&quot;);
256   return build_int_from_shorts(cpref, mid);
257 }
258 
259 inline int Backtrace::bci_at(unsigned int merged) {
260   return extract_high_short_from_int(merged);
261 }
262 
263 inline int Backtrace::version_at(unsigned int merged) {
264   return extract_low_short_from_int(merged);
265 }
266 
267 inline int Backtrace::mid_at(unsigned int merged) {
268   return extract_high_short_from_int(merged);
269 }
270 
271 inline int Backtrace::cpref_at(unsigned int merged) {
272   return extract_low_short_from_int(merged);
273 }
274 
275 inline int Backtrace::get_line_number(Method* method, int bci) {
276   int line_number = 0;
277   if (method-&gt;is_native()) {
278     // Negative value different from -1 below, enabling Java code in
279     // class java.lang.StackTraceElement to distinguish &quot;native&quot; from
280     // &quot;no LineNumberTable&quot;.  JDK tests for -2.
281     line_number = -2;
282   } else {
283     // Returns -1 if no LineNumberTable, and otherwise actual line number
284     line_number = method-&gt;line_number_from_bci(bci);
285   }
286   return line_number;
287 }
288 
289 inline Symbol* Backtrace::get_source_file_name(InstanceKlass* holder, int version) {
290   // RedefineClasses() currently permits redefine operations to
291   // happen in parallel using a &quot;last one wins&quot; philosophy. That
292   // spec laxness allows the constant pool entry associated with
293   // the source_file_name_index for any older constant pool version
294   // to be unstable so we shouldn&#39;t try to use it.
295   if (holder-&gt;constants()-&gt;version() != version) {
296     return NULL;
297   } else {
298     return holder-&gt;source_file_name();
299   }
300 }
301 
302 #endif // SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
    </pre>
  </body>
</html>
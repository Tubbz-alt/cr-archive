<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/dictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/metaspaceClosure.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/safepointVerifiers.hpp&quot;
 38 #include &quot;utilities/hashtable.inline.hpp&quot;
 39 
 40 // Optimization: if any dictionary needs resizing, we set this flag,
 41 // so that we dont&#39;t have to walk all dictionaries to check if any actually
 42 // needs resizing, which is costly to do at Safepoint.
 43 bool Dictionary::_some_dictionary_needs_resizing = false;
 44 
 45 Dictionary::Dictionary(ClassLoaderData* loader_data, int table_size, bool resizable)
 46   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry)),
 47     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 48 };
 49 
 50 
 51 Dictionary::Dictionary(ClassLoaderData* loader_data,
 52                        int table_size, HashtableBucket&lt;mtClass&gt;* t,
 53                        int number_of_entries, bool resizable)
 54   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry), t, number_of_entries),
 55     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 56 };
 57 
 58 Dictionary::~Dictionary() {
 59   DictionaryEntry* probe = NULL;
 60   for (int index = 0; index &lt; table_size(); index++) {
 61     for (DictionaryEntry** p = bucket_addr(index); *p != NULL; ) {
 62       probe = *p;
 63       *p = probe-&gt;next();
 64       free_entry(probe);
 65     }
 66   }
 67   assert(number_of_entries() == 0, &quot;should have removed all entries&quot;);
 68   assert(new_entry_free_list() == NULL, &quot;entry present on Dictionary&#39;s free list&quot;);
 69 }
 70 
 71 DictionaryEntry* Dictionary::new_entry(unsigned int hash, InstanceKlass* klass) {
 72   DictionaryEntry* entry = (DictionaryEntry*)Hashtable&lt;InstanceKlass*, mtClass&gt;::allocate_new_entry(hash, klass);
 73   entry-&gt;set_pd_set(NULL);
 74   assert(klass-&gt;is_instance_klass(), &quot;Must be&quot;);
 75   return entry;
 76 }
 77 
 78 
 79 void Dictionary::free_entry(DictionaryEntry* entry) {
 80   // avoid recursion when deleting linked list
 81   // pd_set is accessed during a safepoint.
 82   // This doesn&#39;t require a lock because nothing is reading this
 83   // entry anymore.  The ClassLoader is dead.
 84   while (entry-&gt;pd_set() != NULL) {
 85     ProtectionDomainEntry* to_delete = entry-&gt;pd_set();
 86     entry-&gt;set_pd_set(to_delete-&gt;next());
 87     delete to_delete;
 88   }
 89   // Unlink from the Hashtable prior to freeing
 90   unlink_entry(entry);
 91   FREE_C_HEAP_ARRAY(char, entry);
 92 }
 93 
 94 const int _resize_load_trigger = 5;       // load factor that will trigger the resize
 95 const double _resize_factor    = 2.0;     // by how much we will resize using current number of entries
 96 const int _resize_max_size     = 40423;   // the max dictionary size allowed
 97 const int _primelist[] = {107, 1009, 2017, 4049, 5051, 10103, 20201, _resize_max_size};
 98 const int _prime_array_size = sizeof(_primelist)/sizeof(int);
 99 
100 // Calculate next &quot;good&quot; dictionary size based on requested count
101 static int calculate_dictionary_size(int requested) {
102   int newsize = _primelist[0];
103   int index = 0;
104   for (newsize = _primelist[index]; index &lt; (_prime_array_size - 1);
105        newsize = _primelist[++index]) {
106     if (requested &lt;= newsize) {
107       break;
108     }
109   }
110   return newsize;
111 }
112 
113 bool Dictionary::does_any_dictionary_needs_resizing() {
114   return Dictionary::_some_dictionary_needs_resizing;
115 }
116 
117 void Dictionary::check_if_needs_resize() {
118   if (_resizable == true) {
119     if (number_of_entries() &gt; (_resize_load_trigger*table_size())) {
120       _needs_resizing = true;
121       Dictionary::_some_dictionary_needs_resizing = true;
122     }
123   }
124 }
125 
126 bool Dictionary::resize_if_needed() {
127   int desired_size = 0;
128   if (_needs_resizing == true) {
129     desired_size = calculate_dictionary_size((int)(_resize_factor*number_of_entries()));
130     if (desired_size &gt;= _resize_max_size) {
131       desired_size = _resize_max_size;
132       // We have reached the limit, turn resizing off
133       _resizable = false;
134     }
135     if ((desired_size != 0) &amp;&amp; (desired_size != table_size())) {
136       if (!resize(desired_size)) {
137         // Something went wrong, turn resizing off
138         _resizable = false;
139       }
140     }
141   }
142 
143   _needs_resizing = false;
144   Dictionary::_some_dictionary_needs_resizing = false;
145 
146   return (desired_size != 0);
147 }
148 
149 bool DictionaryEntry::contains_protection_domain(oop protection_domain) const {
150   // Lock the pd_set list.  This lock cannot safepoint since the caller holds
151   // a Dictionary entry, which can be moved if the Dictionary is resized.
152   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
153 #ifdef ASSERT
154   if (protection_domain == instance_klass()-&gt;protection_domain()) {
155     // Ensure this doesn&#39;t show up in the pd_set (invariant)
156     bool in_pd_set = false;
157     for (ProtectionDomainEntry* current = pd_set();
158                                 current != NULL;
159                                 current = current-&gt;next()) {
160       if (current-&gt;object_no_keepalive() == protection_domain) {
161         in_pd_set = true;
162         break;
163       }
164     }
165     if (in_pd_set) {
166       assert(false, &quot;A klass&#39;s protection domain should not show up &quot;
167                     &quot;in its sys. dict. PD set&quot;);
168     }
169   }
170 #endif /* ASSERT */
171 
172   if (protection_domain == instance_klass()-&gt;protection_domain()) {
173     // Succeeds trivially
174     return true;
175   }
176 
177   for (ProtectionDomainEntry* current = pd_set();
178                               current != NULL;
179                               current = current-&gt;next()) {
180     if (current-&gt;object_no_keepalive() == protection_domain) return true;
181   }
182   return false;
183 }
184 
185 
186 void DictionaryEntry::add_protection_domain(Dictionary* dict, Handle protection_domain) {
187   assert_locked_or_safepoint(SystemDictionary_lock);
188   if (!contains_protection_domain(protection_domain())) {
189     ProtectionDomainCacheEntry* entry = SystemDictionary::cache_get(protection_domain);
190     // The pd_set in the dictionary entry is protected by a low level lock.
191     // With concurrent PD table cleanup, these links could be broken.
192     MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
193     ProtectionDomainEntry* new_head =
194                 new ProtectionDomainEntry(entry, pd_set());
195     set_pd_set(new_head);
196   }
197   LogTarget(Trace, protectiondomain) lt;
198   if (lt.is_enabled()) {
199     LogStream ls(lt);
200     print_count(&amp;ls);
201   }
202 }
203 
204 //   Just the classes from defining class loaders
205 void Dictionary::classes_do(void f(InstanceKlass*)) {
206   for (int index = 0; index &lt; table_size(); index++) {
207     for (DictionaryEntry* probe = bucket(index);
208                           probe != NULL;
209                           probe = probe-&gt;next()) {
210       InstanceKlass* k = probe-&gt;instance_klass();
211       if (loader_data() == k-&gt;class_loader_data()) {
212         f(k);
213       }
214     }
215   }
216 }
217 
218 // Added for initialize_itable_for_klass to handle exceptions
219 //   Just the classes from defining class loaders
220 void Dictionary::classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {
221   for (int index = 0; index &lt; table_size(); index++) {
222     for (DictionaryEntry* probe = bucket(index);
223                           probe != NULL;
224                           probe = probe-&gt;next()) {
225       InstanceKlass* k = probe-&gt;instance_klass();
226       if (loader_data() == k-&gt;class_loader_data()) {
227         f(k, CHECK);
228       }
229     }
230   }
231 }
232 
233 // All classes, and their class loaders, including initiating class loaders
234 void Dictionary::all_entries_do(KlassClosure* closure) {
235   for (int index = 0; index &lt; table_size(); index++) {
236     for (DictionaryEntry* probe = bucket(index);
237                           probe != NULL;
238                           probe = probe-&gt;next()) {
239       InstanceKlass* k = probe-&gt;instance_klass();
240       closure-&gt;do_klass(k);
241     }
242   }
243 }
244 
245 // Used to scan and relocate the classes during CDS archive dump.
246 void Dictionary::classes_do(MetaspaceClosure* it) {
247   Arguments::assert_is_dumping_archive();
248   for (int index = 0; index &lt; table_size(); index++) {
249     for (DictionaryEntry* probe = bucket(index);
250                           probe != NULL;
251                           probe = probe-&gt;next()) {
252       it-&gt;push(probe-&gt;klass_addr());
253     }
254   }
255 }
256 
257 
258 
259 // Add a loaded class to the dictionary.
260 // Readers of the SystemDictionary aren&#39;t always locked, so _buckets
261 // is volatile. The store of the next field in the constructor is
262 // also cast to volatile;  we do this to ensure store order is maintained
263 // by the compilers.
264 
265 void Dictionary::add_klass(unsigned int hash, Symbol* class_name,
266                            InstanceKlass* obj) {
267   assert_locked_or_safepoint(SystemDictionary_lock);
268   assert(obj != NULL, &quot;adding NULL obj&quot;);
269   assert(obj-&gt;name() == class_name, &quot;sanity check on name&quot;);
270 
271   DictionaryEntry* entry = new_entry(hash, obj);
272   int index = hash_to_index(hash);
273   add_entry(index, entry);
274   check_if_needs_resize();
275 }
276 
277 
278 // This routine does not lock the dictionary.
279 //
280 // Since readers don&#39;t hold a lock, we must make sure that system
281 // dictionary entries are only removed at a safepoint (when only one
282 // thread is running), and are added to in a safe way (all links must
283 // be updated in an MT-safe manner).
284 //
285 // Callers should be aware that an entry could be added just after
286 // _buckets[index] is read here, so the caller will not see the new entry.
287 DictionaryEntry* Dictionary::get_entry(int index, unsigned int hash,
288                                        Symbol* class_name) {
289   for (DictionaryEntry* entry = bucket(index);
290                         entry != NULL;
291                         entry = entry-&gt;next()) {
292     if (entry-&gt;hash() == hash &amp;&amp; entry-&gt;equals(class_name)) {
293       return entry;
294     }
295   }
296   return NULL;
297 }
298 
299 
300 InstanceKlass* Dictionary::find(unsigned int hash, Symbol* name,
301                                 Handle protection_domain) {
302   NoSafepointVerifier nsv;
303 
304   int index = hash_to_index(hash);
305   DictionaryEntry* entry = get_entry(index, hash, name);
306   if (entry != NULL &amp;&amp; entry-&gt;is_valid_protection_domain(protection_domain)) {
307     return entry-&gt;instance_klass();
308   } else {
309     return NULL;
310   }
311 }
312 
313 InstanceKlass* Dictionary::find_class(int index, unsigned int hash,
314                                       Symbol* name) {
315   assert_locked_or_safepoint(SystemDictionary_lock);
316   assert (index == index_for(name), &quot;incorrect index?&quot;);
317 
318   DictionaryEntry* entry = get_entry(index, hash, name);
319   return (entry != NULL) ? entry-&gt;instance_klass() : NULL;
320 }
321 
322 
323 void Dictionary::add_protection_domain(int index, unsigned int hash,
324                                        InstanceKlass* klass,
325                                        Handle protection_domain,
326                                        TRAPS) {
327   Symbol*  klass_name = klass-&gt;name();
328   DictionaryEntry* entry = get_entry(index, hash, klass_name);
329 
330   assert(entry != NULL,&quot;entry must be present, we just created it&quot;);
331   assert(protection_domain() != NULL,
332          &quot;real protection domain should be present&quot;);
333 
334   entry-&gt;add_protection_domain(this, protection_domain);
335 
336 #ifdef ASSERT
337   assert(loader_data() != ClassLoaderData::the_null_class_loader_data(), &quot;doesn&#39;t make sense&quot;);
338 #endif
339 
340   assert(entry-&gt;contains_protection_domain(protection_domain()),
341          &quot;now protection domain should be present&quot;);
342 }
343 
344 
345 bool Dictionary::is_valid_protection_domain(unsigned int hash,
346                                             Symbol* name,
347                                             Handle protection_domain) {
348   int index = hash_to_index(hash);
349   DictionaryEntry* entry = get_entry(index, hash, name);
350   return entry-&gt;is_valid_protection_domain(protection_domain);
351 }
352 
353 // During class loading we may have cached a protection domain that has
354 // since been unreferenced, so this entry should be cleared.
355 void Dictionary::clean_cached_protection_domains() {
356   assert_locked_or_safepoint(SystemDictionary_lock);
357 
358   if (loader_data()-&gt;is_the_null_class_loader_data()) {
359     // Classes in the boot loader are not loaded with protection domains
360     return;
361   }
362 
363   for (int index = 0; index &lt; table_size(); index++) {
364     for (DictionaryEntry* probe = bucket(index);
365                           probe != NULL;
366                           probe = probe-&gt;next()) {
367       Klass* e = probe-&gt;instance_klass();
368 
369       MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
370       ProtectionDomainEntry* current = probe-&gt;pd_set();
371       ProtectionDomainEntry* prev = NULL;
372       while (current != NULL) {
373         if (current-&gt;object_no_keepalive() == NULL) {
374           LogTarget(Debug, protectiondomain) lt;
375           if (lt.is_enabled()) {
376             ResourceMark rm;
377             // Print out trace information
378             LogStream ls(lt);
379             ls.print_cr(&quot;PD in set is not alive:&quot;);
380             ls.print(&quot;class loader: &quot;); loader_data()-&gt;class_loader()-&gt;print_value_on(&amp;ls);
381             ls.print(&quot; loading: &quot;); probe-&gt;instance_klass()-&gt;print_value_on(&amp;ls);
382             ls.cr();
383           }
384           if (probe-&gt;pd_set() == current) {
385             probe-&gt;set_pd_set(current-&gt;next());
386           } else {
387             assert(prev != NULL, &quot;should be set by alive entry&quot;);
388             prev-&gt;set_next(current-&gt;next());
389           }
390           ProtectionDomainEntry* to_delete = current;
391           current = current-&gt;next();
392           delete to_delete;
393         } else {
394           prev = current;
395           current = current-&gt;next();
396         }
397       }
398     }
399   }
400 }
401 
402 
403 SymbolPropertyTable::SymbolPropertyTable(int table_size)
404   : Hashtable&lt;Symbol*, mtSymbol&gt;(table_size, sizeof(SymbolPropertyEntry))
405 {
406 }
407 SymbolPropertyTable::SymbolPropertyTable(int table_size, HashtableBucket&lt;mtSymbol&gt;* t,
408                                          int number_of_entries)
409   : Hashtable&lt;Symbol*, mtSymbol&gt;(table_size, sizeof(SymbolPropertyEntry), t, number_of_entries)
410 {
411 }
412 
413 
414 SymbolPropertyEntry* SymbolPropertyTable::find_entry(int index, unsigned int hash,
415                                                      Symbol* sym,
416                                                      intptr_t sym_mode) {
417   assert(index == index_for(sym, sym_mode), &quot;incorrect index?&quot;);
418   for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
419     if (p-&gt;hash() == hash &amp;&amp; p-&gt;symbol() == sym &amp;&amp; p-&gt;symbol_mode() == sym_mode) {
420       return p;
421     }
422   }
423   return NULL;
424 }
425 
426 
427 SymbolPropertyEntry* SymbolPropertyTable::add_entry(int index, unsigned int hash,
428                                                     Symbol* sym, intptr_t sym_mode) {
429   assert_locked_or_safepoint(SystemDictionary_lock);
430   assert(index == index_for(sym, sym_mode), &quot;incorrect index?&quot;);
431   assert(find_entry(index, hash, sym, sym_mode) == NULL, &quot;no double entry&quot;);
432 
433   SymbolPropertyEntry* p = new_entry(hash, sym, sym_mode);
434   Hashtable&lt;Symbol*, mtSymbol&gt;::add_entry(index, p);
435   return p;
436 }
437 
438 void SymbolPropertyTable::oops_do(OopClosure* f) {
439   for (int index = 0; index &lt; table_size(); index++) {
440     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
441       if (p-&gt;method_type() != NULL) {
442         f-&gt;do_oop(p-&gt;method_type_addr());
443       }
444     }
445   }
446 }
447 
448 void SymbolPropertyTable::methods_do(void f(Method*)) {
449   for (int index = 0; index &lt; table_size(); index++) {
450     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
451       Method* prop = p-&gt;method();
452       if (prop != NULL) {
453         f((Method*)prop);
454       }
455     }
456   }
457 }
458 
459 void DictionaryEntry::verify_protection_domain_set() {
460   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
461   for (ProtectionDomainEntry* current = pd_set(); // accessed at a safepoint
462                               current != NULL;
463                               current = current-&gt;_next) {
464     guarantee(oopDesc::is_oop_or_null(current-&gt;_pd_cache-&gt;object_no_keepalive()), &quot;Invalid oop&quot;);
465   }
466 }
467 
468 void DictionaryEntry::print_count(outputStream *st) {
469   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
470   int count = 0;
471   for (ProtectionDomainEntry* current = pd_set();  // accessed inside SD lock
472                               current != NULL;
473                               current = current-&gt;_next) {
474     count++;
475   }
476   st-&gt;print_cr(&quot;pd set count = #%d&quot;, count);
477 }
478 
479 // ----------------------------------------------------------------------------
480 
481 void Dictionary::print_on(outputStream* st) const {
482   ResourceMark rm;
483 
484   assert(loader_data() != NULL, &quot;loader data should not be null&quot;);
485   st-&gt;print_cr(&quot;Java dictionary (table_size=%d, classes=%d, resizable=%s)&quot;,
486                table_size(), number_of_entries(), BOOL_TO_STR(_resizable));
487   st-&gt;print_cr(&quot;^ indicates that initiating loader is different from defining loader&quot;);
488 
489   for (int index = 0; index &lt; table_size(); index++) {
490     for (DictionaryEntry* probe = bucket(index);
491                           probe != NULL;
492                           probe = probe-&gt;next()) {
493       Klass* e = probe-&gt;instance_klass();
494       bool is_defining_class =
495          (loader_data() == e-&gt;class_loader_data());
496       st-&gt;print(&quot;%4d: %s%s&quot;, index, is_defining_class ? &quot; &quot; : &quot;^&quot;, e-&gt;external_name());
497       ClassLoaderData* cld = e-&gt;class_loader_data();
498       if (!loader_data()-&gt;is_the_null_class_loader_data()) {
499         // Class loader output for the dictionary for the null class loader data is
500         // redundant and obvious.
501         st-&gt;print(&quot;, &quot;);
502         cld-&gt;print_value_on(st);
503       }
504       st-&gt;cr();
505     }
506   }
507   tty-&gt;cr();
508 }
509 
510 void DictionaryEntry::verify() {
511   Klass* e = instance_klass();
512   guarantee(e-&gt;is_instance_klass(),
513                           &quot;Verify of dictionary failed&quot;);
514   e-&gt;verify();
515   verify_protection_domain_set();
516 }
517 
518 void Dictionary::verify() {
519   guarantee(number_of_entries() &gt;= 0, &quot;Verify of dictionary failed&quot;);
520 
521   ClassLoaderData* cld = loader_data();
522   // class loader must be present;  a null class loader is the
523   // boostrap loader
524   guarantee(cld != NULL ||
525             cld-&gt;class_loader() == NULL ||
526             cld-&gt;class_loader()-&gt;is_instance(),
527             &quot;checking type of class_loader&quot;);
528 
529   ResourceMark rm;
530   stringStream tempst;
531   tempst.print(&quot;System Dictionary for %s class loader&quot;, cld-&gt;loader_name_and_id());
532   verify_table&lt;DictionaryEntry&gt;(tempst.as_string());
533 }
    </pre>
  </body>
</html>
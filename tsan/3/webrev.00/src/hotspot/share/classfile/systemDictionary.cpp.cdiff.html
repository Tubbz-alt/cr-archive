<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbolTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,26 ***</span>
<span class="line-new-header">--- 38,29 ---</span>
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/placeholders.hpp&quot;
  #include &quot;classfile/protectionDomainCache.hpp&quot;
  #include &quot;classfile/resolutionErrors.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceRefKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,62 ***</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/typeArrayKlass.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
<span class="line-removed">- #include &quot;prims/resolvedMethodTable.hpp&quot;</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed">- #include &quot;runtime/fieldType.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;services/classLoadingService.hpp&quot;
  #include &quot;services/diagnosticCommand.hpp&quot;
  #include &quot;services/threadService.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #if INCLUDE_CDS
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #endif
<span class="line-removed">- #if INCLUDE_JVMCI</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  #if INCLUDE_JFR
  #include &quot;jfr/jfr.hpp&quot;
  #endif
  
  PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
  
<span class="line-removed">- int         SystemDictionary::_number_of_modifications = 0;</span>
  oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
  
  InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
                                                            =  { NULL /*, NULL...*/ };
  
  InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
  
  oop         SystemDictionary::_java_system_loader         =  NULL;
  oop         SystemDictionary::_java_platform_loader       =  NULL;
  
<span class="line-removed">- bool        SystemDictionary::_has_checkPackageAccess     =  false;</span>
<span class="line-removed">- </span>
  // Default ProtectionDomainCacheSize value
  
  const int defaultProtectionDomainCacheSize = 1009;
  
<span class="line-removed">- OopStorage* SystemDictionary::_vm_weak_oop_storage = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // ----------------------------------------------------------------------------
  // Java-level SystemLoader and PlatformLoader
  
  oop SystemDictionary::java_system_loader() {
    return _java_system_loader;
<span class="line-new-header">--- 69,50 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,11 ***</span>
  bool SystemDictionary::is_system_class_loader(oop class_loader) {
    if (class_loader == NULL) {
      return false;
    }
    return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified">!          oopDesc::equals(class_loader, _java_system_loader));</span>
  }
  
  // Returns true if the passed class loader is the platform class loader.
  bool SystemDictionary::is_platform_class_loader(oop class_loader) {
    if (class_loader == NULL) {
<span class="line-new-header">--- 171,11 ---</span>
  bool SystemDictionary::is_system_class_loader(oop class_loader) {
    if (class_loader == NULL) {
      return false;
    }
    return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified">!          class_loader == _java_system_loader);</span>
  }
  
  // Returns true if the passed class loader is the platform class loader.
  bool SystemDictionary::is_platform_class_loader(oop class_loader) {
    if (class_loader == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,11 ***</span>
  
  
  // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
  
  Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified">!   if (FieldType::is_array(class_name)) {</span>
      return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
    } else {
      return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
    }
  }
<span class="line-new-header">--- 237,11 ---</span>
  
  
  // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
  
  Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified">!   if (Signature::is_array(class_name)) {</span>
      return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
    } else {
      return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,16 ***</span>
  // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
  InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
                                                                         Handle class_loader,
                                                                         Handle protection_domain,
                                                                         TRAPS) {
<span class="line-modified">!   assert(class_name != NULL &amp;&amp; !FieldType::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified">!   if (FieldType::is_obj(class_name)) {</span>
      ResourceMark rm(THREAD);
      // Ignore wrapping L and ;.
      TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
<span class="line-modified">!                                    class_name-&gt;utf8_length() - 2, CHECK_NULL);</span>
      return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
    } else {
      return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
    }
  }
<span class="line-new-header">--- 249,16 ---</span>
  // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
  InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
                                                                         Handle class_loader,
                                                                         Handle protection_domain,
                                                                         TRAPS) {
<span class="line-modified">!   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified">!   if (Signature::has_envelope(class_name)) {</span>
      ResourceMark rm(THREAD);
      // Ignore wrapping L and ;.
      TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
<span class="line-modified">!                                                  class_name-&gt;utf8_length() - 2);</span>
      return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
    } else {
      return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,28 ***</span>
  
  Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
                                                       Handle class_loader,
                                                       Handle protection_domain,
                                                       TRAPS) {
<span class="line-modified">!   assert(FieldType::is_array(class_name), &quot;must be array&quot;);</span>
    Klass* k = NULL;
<span class="line-modified">!   FieldArrayInfo fd;</span>
<span class="line-modified">!   // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified">!   // of this call</span>
<span class="line-modified">!   BasicType t = FieldType::get_array_info(class_name, fd, CHECK_NULL);</span>
<span class="line-removed">-   if (t == T_OBJECT) {</span>
<span class="line-removed">-     // naked oop &quot;k&quot; is OK here -- we assign back into it</span>
<span class="line-removed">-     k = SystemDictionary::resolve_instance_class_or_null(fd.object_key(),</span>
                                                           class_loader,
                                                           protection_domain,
                                                           CHECK_NULL);
      if (k != NULL) {
<span class="line-modified">!       k = k-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
      }
    } else {
      k = Universe::typeArrayKlassObj(t);
<span class="line-modified">!     k = TypeArrayKlass::cast(k)-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
    }
    return k;
  }
  
  
<span class="line-new-header">--- 271,28 ---</span>
  
  Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
                                                       Handle class_loader,
                                                       Handle protection_domain,
                                                       TRAPS) {
<span class="line-modified">!   assert(Signature::is_array(class_name), &quot;must be array&quot;);</span>
<span class="line-added">+   ResourceMark rm(THREAD);</span>
<span class="line-added">+   SignatureStream ss(class_name, false);</span>
<span class="line-added">+   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
    Klass* k = NULL;
<span class="line-modified">!   BasicType t = ss.type();</span>
<span class="line-modified">!   if (ss.has_envelope()) {</span>
<span class="line-modified">!     Symbol* obj_class = ss.as_symbol();</span>
<span class="line-modified">!     k = SystemDictionary::resolve_instance_class_or_null(obj_class,</span>
                                                           class_loader,
                                                           protection_domain,
                                                           CHECK_NULL);
      if (k != NULL) {
<span class="line-modified">!       k = k-&gt;array_klass(ndims, CHECK_NULL);</span>
      }
    } else {
      k = Universe::typeArrayKlassObj(t);
<span class="line-modified">!     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);</span>
    }
    return k;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,11 ***</span>
                                                         Symbol* super_name,
                                                         Handle class_loader,
                                                         Handle protection_domain,
                                                         bool is_superclass,
                                                         TRAPS) {
<span class="line-modified">!   assert(!FieldType::is_array(super_name), &quot;invalid super class name&quot;);</span>
  #if INCLUDE_CDS
    if (DumpSharedSpaces) {
      // Special processing for handling UNREGISTERED shared classes.
      InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
          super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
<span class="line-new-header">--- 339,11 ---</span>
                                                         Symbol* super_name,
                                                         Handle class_loader,
                                                         Handle protection_domain,
                                                         bool is_superclass,
                                                         TRAPS) {
<span class="line-modified">!   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);</span>
  #if INCLUDE_CDS
    if (DumpSharedSpaces) {
      // Special processing for handling UNREGISTERED shared classes.
      InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
          super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,11 ***</span>
    int p_index = placeholders()-&gt;hash_to_index(p_hash);
    // can&#39;t throw error holding a lock
    bool child_already_loaded = false;
    bool throw_circularity_error = false;
    {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
      InstanceKlass* quicksuperk;
      // to support // loading: if child done loading, just return superclass
      // if super_name, &amp; class_loader don&#39;t match:
      // if initial define, SD update will give LinkageError
<span class="line-new-header">--- 375,11 ---</span>
    int p_index = placeholders()-&gt;hash_to_index(p_hash);
    // can&#39;t throw error holding a lock
    bool child_already_loaded = false;
    bool throw_circularity_error = false;
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
      InstanceKlass* quicksuperk;
      // to support // loading: if child done loading, just return superclass
      // if super_name, &amp; class_loader don&#39;t match:
      // if initial define, SD update will give LinkageError
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,11 ***</span>
      // so we don&#39;t throw an exception here.
      // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
      if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
          ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
           ((quicksuperk-&gt;name() == super_name) &amp;&amp;
<span class="line-modified">!             (oopDesc::equals(quicksuperk-&gt;class_loader(), class_loader())))) {</span>
             return quicksuperk;
      } else {
        PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
        if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
            throw_circularity_error = true;
<span class="line-new-header">--- 387,11 ---</span>
      // so we don&#39;t throw an exception here.
      // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
      if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
          ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
           ((quicksuperk-&gt;name() == super_name) &amp;&amp;
<span class="line-modified">!             (quicksuperk-&gt;class_loader() == class_loader()))) {</span>
             return quicksuperk;
      } else {
        PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
        if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
            throw_circularity_error = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,11 ***</span>
    // or error. GC used to walk the placeholder table as strong roots.
    // The instanceKlass is kept alive because the class loader is on the stack,
    // which keeps the loader_data alive, as well as all instanceKlasses in
    // the loader_data. parseClassFile adds the instanceKlass to loader_data.
    {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
      SystemDictionary_lock-&gt;notify_all();
    }
    if (HAS_PENDING_EXCEPTION || superk == NULL) {
      // can null superk
<span class="line-new-header">--- 421,11 ---</span>
    // or error. GC used to walk the placeholder table as strong roots.
    // The instanceKlass is kept alive because the class loader is on the stack,
    // which keeps the loader_data alive, as well as all instanceKlasses in
    // the loader_data. parseClassFile adds the instanceKlass to loader_data.
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
      SystemDictionary_lock-&gt;notify_all();
    }
    if (HAS_PENDING_EXCEPTION || superk == NULL) {
      // can null superk
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,17 ***</span>
  
  void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
                                                    Handle class_loader,
                                                    Handle protection_domain,
                                                    TRAPS) {
<span class="line-removed">-   if(!has_checkPackageAccess()) return;</span>
<span class="line-removed">- </span>
    // Now we have to call back to java to check if the initating class has access
    JavaValue result(T_VOID);
    LogTarget(Debug, protectiondomain) lt;
    if (lt.is_enabled()) {
<span class="line-modified">!     ResourceMark rm;</span>
      // Print out trace information
      LogStream ls(lt);
      ls.print_cr(&quot;Checking package access&quot;);
      if (class_loader() != NULL) {
        ls.print(&quot;class loader: &quot;);
<span class="line-new-header">--- 441,15 ---</span>
  
  void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
                                                    Handle class_loader,
                                                    Handle protection_domain,
                                                    TRAPS) {
    // Now we have to call back to java to check if the initating class has access
    JavaValue result(T_VOID);
    LogTarget(Debug, protectiondomain) lt;
    if (lt.is_enabled()) {
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      // Print out trace information
      LogStream ls(lt);
      ls.print_cr(&quot;Checking package access&quot;);
      if (class_loader() != NULL) {
        ls.print(&quot;class loader: &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,11 ***</span>
      Dictionary* dictionary = loader_data-&gt;dictionary();
  
      Symbol*  kn = klass-&gt;name();
      unsigned int d_hash = dictionary-&gt;compute_hash(kn);
  
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      int d_index = dictionary-&gt;hash_to_index(d_hash);
      dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
                                        protection_domain, THREAD);
    }
  }
<span class="line-new-header">--- 497,11 ---</span>
      Dictionary* dictionary = loader_data-&gt;dictionary();
  
      Symbol*  kn = klass-&gt;name();
      unsigned int d_hash = dictionary-&gt;compute_hash(kn);
  
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      int d_index = dictionary-&gt;hash_to_index(d_hash);
      dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
                                        protection_domain, THREAD);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,19 ***</span>
    assert_lock_strong(SystemDictionary_lock);
  
    bool calledholdinglock
        = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
    assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified">!   assert((!oopDesc::equals(lockObject(), _system_loader_lock_obj) &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>
    ObjectSynchronizer::notifyall(lockObject, THREAD);
  
    TSAN_ONLY(int tsan_rec = 0;)
    TSAN_RUNTIME_ONLY(
      tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());
      assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
    );
<span class="line-modified">!   intptr_t recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);</span>
    SystemDictionary_lock-&gt;wait();
    SystemDictionary_lock-&gt;unlock();
    ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));
    SystemDictionary_lock-&gt;lock();
<span class="line-new-header">--- 534,19 ---</span>
    assert_lock_strong(SystemDictionary_lock);
  
    bool calledholdinglock
        = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
    assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified">!   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>
    ObjectSynchronizer::notifyall(lockObject, THREAD);
  
    TSAN_ONLY(int tsan_rec = 0;)
    TSAN_RUNTIME_ONLY(
      tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());
      assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
    );
<span class="line-modified">!   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);</span>
    SystemDictionary_lock-&gt;wait();
    SystemDictionary_lock-&gt;unlock();
    ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));
    SystemDictionary_lock-&gt;lock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,21 ***</span>
                                                            CHECK_NULL);
  
    // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
    // Serial class loaders and bootstrap classloader do wait for superclass loads
   if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      // Check if classloading completed while we were loading superclass or waiting
      return find_class(d_hash, name, dictionary);
    }
  
    // must loop to both handle other placeholder updates
    // and spurious notifications
    bool super_load_in_progress = true;
    PlaceholderEntry* placeholder;
    while (super_load_in_progress) {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      // Check if classloading completed while we were loading superclass or waiting
      InstanceKlass* check = find_class(d_hash, name, dictionary);
      if (check != NULL) {
        // Klass is already loaded, so just return it
        return check;
<span class="line-new-header">--- 591,21 ---</span>
                                                            CHECK_NULL);
  
    // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
    // Serial class loaders and bootstrap classloader do wait for superclass loads
   if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      // Check if classloading completed while we were loading superclass or waiting
      return find_class(d_hash, name, dictionary);
    }
  
    // must loop to both handle other placeholder updates
    // and spurious notifications
    bool super_load_in_progress = true;
    PlaceholderEntry* placeholder;
    while (super_load_in_progress) {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      // Check if classloading completed while we were loading superclass or waiting
      InstanceKlass* check = find_class(d_hash, name, dictionary);
      if (check != NULL) {
        // Klass is already loaded, so just return it
        return check;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 669,12 ***</span>
  // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
  InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
                                                                  Handle class_loader,
                                                                  Handle protection_domain,
                                                                  TRAPS) {
<span class="line-modified">!   assert(name != NULL &amp;&amp; !FieldType::is_array(name) &amp;&amp;</span>
<span class="line-modified">!          !FieldType::is_obj(name), &quot;invalid class name&quot;);</span>
  
    EventClassLoad class_load_start_event;
  
    HandleMark hm(THREAD);
  
<span class="line-new-header">--- 658,12 ---</span>
  // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
  InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
                                                                  Handle class_loader,
                                                                  Handle protection_domain,
                                                                  TRAPS) {
<span class="line-modified">!   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;</span>
<span class="line-modified">!          !Signature::has_envelope(name), &quot;invalid class name&quot;);</span>
  
    EventClassLoad class_load_start_event;
  
    HandleMark hm(THREAD);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 729,11 ***</span>
    assert(THREAD-&gt;can_call_java(),
           &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
           name-&gt;as_C_string(),
           class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
    {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      InstanceKlass* check = find_class(d_hash, name, dictionary);
      if (check != NULL) {
        // InstanceKlass is already loaded, so just return it
        class_has_been_loaded = true;
        k = check;
<span class="line-new-header">--- 718,11 ---</span>
    assert(THREAD-&gt;can_call_java(),
           &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
           name-&gt;as_C_string(),
           class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      InstanceKlass* check = find_class(d_hash, name, dictionary);
      if (check != NULL) {
        // InstanceKlass is already loaded, so just return it
        class_has_been_loaded = true;
        k = check;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,11 ***</span>
      //    No performance benefit and no deadlock issues.
      // case 4. parallelCapable user level classloaders - without objectLocker
      //    Allow parallel classloading of a class/classloader pair
  
      {
<span class="line-modified">!       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
        if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
          PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
          if (oldprobe) {
            // only need check_seen_thread once, not on each loop
            // 6341374 java/lang/Instrument with -Xcomp
<span class="line-new-header">--- 778,11 ---</span>
      //    No performance benefit and no deadlock issues.
      // case 4. parallelCapable user level classloaders - without objectLocker
      //    Allow parallel classloading of a class/classloader pair
  
      {
<span class="line-modified">!       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
        if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
          PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
          if (oldprobe) {
            // only need check_seen_thread once, not on each loop
            // 6341374 java/lang/Instrument with -Xcomp
</pre>
<hr />
<pre>
<span class="line-old-header">*** 860,11 ***</span>
        k = load_instance_class(name, class_loader, THREAD);
  
        // If everything was OK (no exceptions, no null return value), and
        // class_loader is NOT the defining loader, do a little more bookkeeping.
        if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
<span class="line-modified">!         !oopDesc::equals(k-&gt;class_loader(), class_loader())) {</span>
  
          check_constraints(d_hash, k, class_loader, false, THREAD);
  
          // Need to check for a PENDING_EXCEPTION again; check_constraints
          // can throw but we may have to remove entry from the placeholder table below.
<span class="line-new-header">--- 849,11 ---</span>
        k = load_instance_class(name, class_loader, THREAD);
  
        // If everything was OK (no exceptions, no null return value), and
        // class_loader is NOT the defining loader, do a little more bookkeeping.
        if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
<span class="line-modified">!         k-&gt;class_loader() != class_loader()) {</span>
  
          check_constraints(d_hash, k, class_loader, false, THREAD);
  
          // Need to check for a PENDING_EXCEPTION again; check_constraints
          // can throw but we may have to remove entry from the placeholder table below.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 876,11 ***</span>
            // before references to the initiating class loader.
            loader_data-&gt;record_dependency(k);
  
            { // Grabbing the Compile_lock prevents systemDictionary updates
              // during compilations.
<span class="line-modified">!             MutexLocker mu(Compile_lock, THREAD);</span>
              update_dictionary(d_hash, p_index, p_hash,
                k, class_loader, THREAD);
            }
  
            if (JvmtiExport::should_post_class_load()) {
<span class="line-new-header">--- 865,11 ---</span>
            // before references to the initiating class loader.
            loader_data-&gt;record_dependency(k);
  
            { // Grabbing the Compile_lock prevents systemDictionary updates
              // during compilations.
<span class="line-modified">!             MutexLocker mu(THREAD, Compile_lock);</span>
              update_dictionary(d_hash, p_index, p_hash,
                k, class_loader, THREAD);
            }
  
            if (JvmtiExport::should_post_class_load()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,11 ***</span>
  
      if (load_instance_added == true) {
        // clean up placeholder entries for LOAD_INSTANCE success or error
        // This brackets the SystemDictionary updates for both defining
        // and initiating loaders
<span class="line-modified">!       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
        placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
        SystemDictionary_lock-&gt;notify_all();
      }
    }
  
<span class="line-new-header">--- 883,11 ---</span>
  
      if (load_instance_added == true) {
        // clean up placeholder entries for LOAD_INSTANCE success or error
        // This brackets the SystemDictionary updates for both defining
        // and initiating loaders
<span class="line-modified">!       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
        placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
        SystemDictionary_lock-&gt;notify_all();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 909,11 ***</span>
      post_class_load_event(&amp;class_load_start_event, k, loader_data);
    }
  #ifdef ASSERT
    {
      ClassLoaderData* loader_data = k-&gt;class_loader_data();
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      InstanceKlass* kk = find_class(name, loader_data);
      assert(kk == k, &quot;should be present in dictionary&quot;);
    }
  #endif
  
<span class="line-new-header">--- 898,11 ---</span>
      post_class_load_event(&amp;class_load_start_event, k, loader_data);
    }
  #ifdef ASSERT
    {
      ClassLoaderData* loader_data = k-&gt;class_loader_data();
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      InstanceKlass* kk = find_class(name, loader_data);
      assert(kk == k, &quot;should be present in dictionary&quot;);
    }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 975,23 ***</span>
                                                        Handle protection_domain,
                                                        TRAPS) {
    Klass* k = NULL;
    assert(class_name != NULL, &quot;class name must be non NULL&quot;);
  
<span class="line-modified">!   if (FieldType::is_array(class_name)) {</span>
      // The name refers to an array.  Parse the name.
      // dimension and object_key in FieldArrayInfo are assigned as a
      // side-effect of this call
<span class="line-modified">!     FieldArrayInfo fd;</span>
<span class="line-modified">!     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>
      if (t != T_OBJECT) {
        k = Universe::typeArrayKlassObj(t);
      } else {
<span class="line-modified">!       k = SystemDictionary::find(fd.object_key(), class_loader, protection_domain, THREAD);</span>
      }
      if (k != NULL) {
<span class="line-modified">!       k = k-&gt;array_klass_or_null(fd.dimension());</span>
      }
    } else {
      k = find(class_name, class_loader, protection_domain, THREAD);
    }
    return k;
<span class="line-new-header">--- 964,25 ---</span>
                                                        Handle protection_domain,
                                                        TRAPS) {
    Klass* k = NULL;
    assert(class_name != NULL, &quot;class name must be non NULL&quot;);
  
<span class="line-modified">!   if (Signature::is_array(class_name)) {</span>
      // The name refers to an array.  Parse the name.
      // dimension and object_key in FieldArrayInfo are assigned as a
      // side-effect of this call
<span class="line-modified">!     SignatureStream ss(class_name, false);</span>
<span class="line-modified">!     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added">+     BasicType t = ss.type();</span>
      if (t != T_OBJECT) {
        k = Universe::typeArrayKlassObj(t);
      } else {
<span class="line-modified">!       Symbol* obj_class = ss.as_symbol();</span>
<span class="line-added">+       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
      }
      if (k != NULL) {
<span class="line-modified">!       k = k-&gt;array_klass_or_null(ndims);</span>
      }
    } else {
      k = find(class_name, class_loader, protection_domain, THREAD);
    }
    return k;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1013,11 ***</span>
  
    ClassLoaderData* loader_data;
    if (unsafe_anonymous_host != NULL) {
      // Create a new CLD for an unsafe anonymous class, that uses the same class loader
      // as the unsafe_anonymous_host
<span class="line-modified">!     guarantee(oopDesc::equals(unsafe_anonymous_host-&gt;class_loader(), class_loader()), &quot;should be the same&quot;);</span>
      loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
    } else {
      loader_data = ClassLoaderData::class_loader_data(class_loader());
    }
  
<span class="line-new-header">--- 1004,11 ---</span>
  
    ClassLoaderData* loader_data;
    if (unsafe_anonymous_host != NULL) {
      // Create a new CLD for an unsafe anonymous class, that uses the same class loader
      // as the unsafe_anonymous_host
<span class="line-modified">!     guarantee(unsafe_anonymous_host-&gt;class_loader() == class_loader(), &quot;should be the same&quot;);</span>
      loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
    } else {
      loader_data = ClassLoaderData::class_loader_data(class_loader());
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1041,20 ***</span>
      // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
      // so that they can be unloaded when the mirror is no longer referenced.
      k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
  
      {
<span class="line-modified">!       MutexLocker mu_r(Compile_lock, THREAD);</span>
  
        // Add to class hierarchy, initialize vtables, and do possible
        // deoptimizations.
        add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
<span class="line-removed">- </span>
        // But, do not add to dictionary.
<span class="line-removed">- </span>
<span class="line-removed">-       // compiled code dependencies need to be validated anyway</span>
<span class="line-removed">-       notice_modification();</span>
      }
  
      // Rewrite and patch constant pool here.
      k-&gt;link_class(CHECK_NULL);
      if (cp_patches != NULL) {
<span class="line-new-header">--- 1032,16 ---</span>
      // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
      // so that they can be unloaded when the mirror is no longer referenced.
      k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
  
      {
<span class="line-modified">!       MutexLocker mu_r(THREAD, Compile_lock);</span>
  
        // Add to class hierarchy, initialize vtables, and do possible
        // deoptimizations.
        add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
        // But, do not add to dictionary.
      }
  
      // Rewrite and patch constant pool here.
      k-&gt;link_class(CHECK_NULL);
      if (cp_patches != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1163,11 ***</span>
      return NULL;
    }
  
    // Make sure we have an entry in the SystemDictionary on success
    debug_only( {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
  
      Klass* check = find_class(h_name, k-&gt;class_loader_data());
      assert(check == k, &quot;should be present in the dictionary&quot;);
    } );
  
<span class="line-new-header">--- 1150,11 ---</span>
      return NULL;
    }
  
    // Make sure we have an entry in the SystemDictionary on success
    debug_only( {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
  
      Klass* check = find_class(h_name, k-&gt;class_loader_data());
      assert(check == k, &quot;should be present in the dictionary&quot;);
    } );
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1195,11 ***</span>
  bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
                                                 InstanceKlass* ik,
                                                 Handle class_loader, TRAPS) {
    assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
           &quot;Cannot use sharing if java.base is patched&quot;);
<span class="line-modified">!   ResourceMark rm;</span>
    int path_index = ik-&gt;shared_classpath_index();
    ClassLoaderData* loader_data = class_loader_data(class_loader);
    if (path_index &lt; 0) {
      // path_index &lt; 0 indicates that the class is intended for a custom loader
      // and should not be loaded by boot/platform/app loaders
<span class="line-new-header">--- 1182,11 ---</span>
  bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
                                                 InstanceKlass* ik,
                                                 Handle class_loader, TRAPS) {
    assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
           &quot;Cannot use sharing if java.base is patched&quot;);
<span class="line-modified">!   ResourceMark rm(THREAD);</span>
    int path_index = ik-&gt;shared_classpath_index();
    ClassLoaderData* loader_data = class_loader_data(class_loader);
    if (path_index &lt; 0) {
      // path_index &lt; 0 indicates that the class is intended for a custom loader
      // and should not be loaded by boot/platform/app loaders
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1219,14 ***</span>
    }
    // Get the pkg_entry from the classloader
    TempNewSymbol pkg_name = NULL;
    PackageEntry* pkg_entry = NULL;
    ModuleEntry* mod_entry = NULL;
<span class="line-removed">-   const char* pkg_string = NULL;</span>
    pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);
    if (pkg_name != NULL) {
<span class="line-removed">-     pkg_string = pkg_name-&gt;as_C_string();</span>
      if (loader_data != NULL) {
        pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
      }
      if (pkg_entry != NULL) {
        mod_entry = pkg_entry-&gt;module();
<span class="line-new-header">--- 1206,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1259,11 ***</span>
      // 1. the class is from the unamed package
      // 2. or, the class is not from a module defined in the NULL classloader
      // 3. or, the class is from an unamed module
      if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
        // the class is from the -Xbootclasspath/a
<span class="line-modified">!       if (pkg_string == NULL ||</span>
            pkg_entry == NULL ||
            pkg_entry-&gt;in_unnamed_module()) {
          assert(mod_entry == NULL ||
                 mod_entry == loader_data-&gt;unnamed_module(),
                 &quot;the unnamed module is not defined in the classloader&quot;);
<span class="line-new-header">--- 1244,11 ---</span>
      // 1. the class is from the unamed package
      // 2. or, the class is not from a module defined in the NULL classloader
      // 3. or, the class is from an unamed module
      if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
        // the class is from the -Xbootclasspath/a
<span class="line-modified">!       if (pkg_name == NULL ||</span>
            pkg_entry == NULL ||
            pkg_entry-&gt;in_unnamed_module()) {
          assert(mod_entry == NULL ||
                 mod_entry == loader_data-&gt;unnamed_module(),
                 &quot;the unnamed module is not defined in the classloader&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1271,139 ***</span>
        }
      }
      return false;
    } else {
      bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
<span class="line-modified">!               ik, class_loader, pkg_string, pkg_name,</span>
<span class="line-removed">-               pkg_entry, mod_entry, CHECK_(false));</span>
      return res;
    }
  }
  
  InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
                                                     Handle class_loader,
                                                     Handle protection_domain,
                                                     const ClassFileStream *cfs,
                                                     TRAPS) {
  
<span class="line-modified">!   if (ik != NULL) {</span>
<span class="line-modified">!     Symbol* class_name = ik-&gt;name();</span>
  
<span class="line-modified">!     bool visible = is_shared_class_visible(</span>
<span class="line-modified">!                             class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-modified">!     if (!visible) {</span>
        return NULL;
      }
  
<span class="line-modified">!     // Resolve the superclass and interfaces. They must be the same</span>
<span class="line-modified">!     // as in dump time, because the layout of &lt;ik&gt; depends on</span>
<span class="line-modified">!     // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     // If unexpected superclass or interfaces are found, we cannot</span>
<span class="line-modified">!     // load &lt;ik&gt; from the shared archive.</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (ik-&gt;super() != NULL) {</span>
<span class="line-modified">!       Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-modified">!       Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-modified">!                                        class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-modified">!       if (s != ik-&gt;super()) {</span>
<span class="line-removed">-         // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-removed">-         // so we cannot use ik.</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();</span>
<span class="line-removed">-     int num_interfaces = interfaces-&gt;length();</span>
<span class="line-removed">-     for (int index = 0; index &lt; num_interfaces; index++) {</span>
<span class="line-removed">-       InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-removed">-       Symbol* name  = k-&gt;name();</span>
<span class="line-removed">-       Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-removed">-       if (k != i) {</span>
<span class="line-removed">-         // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-removed">-         // so we cannot use ik.</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">-       }</span>
      }
  
<span class="line-modified">!     InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(</span>
<span class="line-modified">!         ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);</span>
<span class="line-modified">!     if (new_ik != NULL) {</span>
<span class="line-modified">!       // The class is changed by CFLH. Return the new class. The shared class is</span>
<span class="line-modified">!       // not used.</span>
<span class="line-modified">!       return new_ik;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     // Adjust methods to recover missing data.  They need addresses for</span>
<span class="line-modified">!     // interpreter entry points and their default native method address</span>
<span class="line-modified">!     // must be reset.</span>
  
<span class="line-modified">!     // Updating methods must be done under a lock so multiple</span>
<span class="line-modified">!     // threads don&#39;t update these in parallel</span>
<span class="line-modified">!     //</span>
<span class="line-modified">!     // Shared classes are all currently loaded by either the bootstrap or</span>
<span class="line-modified">!     // internal parallel class loaders, so this will never cause a deadlock</span>
<span class="line-modified">!     // on a custom class loader lock.</span>
  
<span class="line-modified">!     ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       HandleMark hm(THREAD);</span>
<span class="line-modified">!       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);</span>
<span class="line-modified">!       check_loader_lock_contention(lockObject, THREAD);</span>
<span class="line-modified">!       ObjectLocker ol(lockObject, THREAD, true);</span>
<span class="line-modified">!       // prohibited package check assumes all classes loaded from archive call</span>
<span class="line-modified">!       // restore_unshareable_info which calls ik-&gt;set_package()</span>
<span class="line-modified">!       ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     ik-&gt;print_class_load_logging(loader_data, NULL, NULL);</span>
  
<span class="line-modified">!     // For boot loader, ensure that GetSystemPackage knows that a class in this</span>
<span class="line-modified">!     // package was loaded.</span>
<span class="line-modified">!     if (class_loader.is_null()) {</span>
<span class="line-modified">!       int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-modified">!       ResourceMark rm;</span>
<span class="line-modified">!       ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {</span>
<span class="line-modified">!       // Only dump the classes that can be stored into CDS archive</span>
<span class="line-modified">!       if (SystemDictionaryShared::is_sharing_possible(loader_data)) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());</span>
<span class="line-modified">!         classlist_file-&gt;flush();</span>
<span class="line-removed">-       }</span>
      }
  
<span class="line-modified">!     // notify a class loaded from shared object</span>
<span class="line-modified">!     ClassLoadingService::notify_class_loaded(ik, true /* shared class */);</span>
  
<span class="line-modified">!     ik-&gt;set_has_passed_fingerprint_check(false);</span>
<span class="line-modified">!     if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {</span>
<span class="line-modified">!       uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);</span>
<span class="line-modified">!       uint64_t cds_fp = ik-&gt;get_stored_fingerprint();</span>
<span class="line-modified">!       if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {</span>
<span class="line-modified">!         // This class matches with a class saved in an AOT library</span>
<span class="line-modified">!         ik-&gt;set_has_passed_fingerprint_check(true);</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         ResourceMark rm;</span>
          log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
        }
      }
    }
    return ik;
  }
  #endif // INCLUDE_CDS
  
  InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
  
    if (class_loader.is_null()) {
<span class="line-modified">!     ResourceMark rm;</span>
      PackageEntry* pkg_entry = NULL;
      bool search_only_bootloader_append = false;
      ClassLoaderData *loader_data = class_loader_data(class_loader);
  
      // Find the package in the boot loader&#39;s package entry table.
<span class="line-new-header">--- 1256,140 ---</span>
        }
      }
      return false;
    } else {
      bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
<span class="line-modified">!               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));</span>
      return res;
    }
  }
  
  InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
                                                     Handle class_loader,
                                                     Handle protection_domain,
                                                     const ClassFileStream *cfs,
                                                     TRAPS) {
<span class="line-added">+   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="line-added">+   Symbol* class_name = ik-&gt;name();</span>
  
<span class="line-modified">!   bool visible = is_shared_class_visible(</span>
<span class="line-modified">!                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-added">+   if (!visible) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // Resolve the superclass and interfaces. They must be the same</span>
<span class="line-modified">!   // as in dump time, because the layout of &lt;ik&gt; depends on</span>
<span class="line-modified">!   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // If unexpected superclass or interfaces are found, we cannot</span>
<span class="line-added">+   // load &lt;ik&gt; from the shared archive.</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (ik-&gt;super() != NULL) {</span>
<span class="line-added">+     Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-added">+     Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-added">+                                      class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">+     if (s != ik-&gt;super()) {</span>
<span class="line-added">+       // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-added">+       // so we cannot use ik.</span>
        return NULL;
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
      }
<span class="line-added">+   }</span>
  
<span class="line-modified">!   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();</span>
<span class="line-modified">!   int num_interfaces = interfaces-&gt;length();</span>
<span class="line-modified">!   for (int index = 0; index &lt; num_interfaces; index++) {</span>
<span class="line-modified">!     InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-modified">!     Symbol* name  = k-&gt;name();</span>
<span class="line-modified">!     Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-modified">!     if (k != i) {</span>
<span class="line-modified">!       // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-modified">!       // so we cannot use ik.</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
      }
<span class="line-added">+   }</span>
  
<span class="line-modified">!   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(</span>
<span class="line-modified">!       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);</span>
<span class="line-modified">!   if (new_ik != NULL) {</span>
<span class="line-modified">!     // The class is changed by CFLH. Return the new class. The shared class is</span>
<span class="line-modified">!     // not used.</span>
<span class="line-modified">!     return new_ik;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Adjust methods to recover missing data.  They need addresses for</span>
<span class="line-modified">!   // interpreter entry points and their default native method address</span>
<span class="line-modified">!   // must be reset.</span>
  
<span class="line-modified">!   // Updating methods must be done under a lock so multiple</span>
<span class="line-modified">!   // threads don&#39;t update these in parallel</span>
<span class="line-modified">!   //</span>
<span class="line-modified">!   // Shared classes are all currently loaded by either the bootstrap or</span>
<span class="line-modified">!   // internal parallel class loaders, so this will never cause a deadlock</span>
<span class="line-modified">!   // on a custom class loader lock.</span>
  
<span class="line-modified">!   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     HandleMark hm(THREAD);</span>
<span class="line-modified">!     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);</span>
<span class="line-modified">!     check_loader_lock_contention(lockObject, THREAD);</span>
<span class="line-modified">!     ObjectLocker ol(lockObject, THREAD, true);</span>
<span class="line-modified">!     // prohibited package check assumes all classes loaded from archive call</span>
<span class="line-modified">!     // restore_unshareable_info which calls ik-&gt;set_package()</span>
<span class="line-modified">!     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);</span>
  
<span class="line-modified">!   // For boot loader, ensure that GetSystemPackage knows that a class in this</span>
<span class="line-modified">!   // package was loaded.</span>
<span class="line-modified">!   if (class_loader.is_null()) {</span>
<span class="line-modified">!     int path_index = ik-&gt;shared_classpath_index();</span>
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
<span class="line-modified">!     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {</span>
<span class="line-modified">!     // Only dump the classes that can be stored into CDS archive</span>
<span class="line-modified">!     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {</span>
<span class="line-modified">!       ResourceMark rm(THREAD);</span>
<span class="line-modified">!       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());</span>
<span class="line-modified">!       classlist_file-&gt;flush();</span>
      }
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // notify a class loaded from shared object</span>
<span class="line-modified">!   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);</span>
  
<span class="line-modified">!   ik-&gt;set_has_passed_fingerprint_check(false);</span>
<span class="line-modified">!   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {</span>
<span class="line-modified">!     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);</span>
<span class="line-modified">!     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();</span>
<span class="line-modified">!     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {</span>
<span class="line-modified">!       // This class matches with a class saved in an AOT library</span>
<span class="line-modified">!       ik-&gt;set_has_passed_fingerprint_check(true);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       if (log_is_enabled(Info, class, fingerprint)) {</span>
<span class="line-added">+         ResourceMark rm(THREAD);</span>
          log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
        }
      }
    }
<span class="line-added">+ </span>
    return ik;
  }
  #endif // INCLUDE_CDS
  
  InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
  
    if (class_loader.is_null()) {
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      PackageEntry* pkg_entry = NULL;
      bool search_only_bootloader_append = false;
      ClassLoaderData *loader_data = class_loader_data(class_loader);
  
      // Find the package in the boot loader&#39;s package entry table.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1446,10 ***</span>
<span class="line-new-header">--- 1432,15 ---</span>
          // Class is either in the unnamed package, in a named package
          // within a module not defined to the boot loader or in a
          // a named package within the unnamed module.  In all cases,
          // limit visibility to search for the class only in the boot
          // loader&#39;s append path.
<span class="line-added">+         if (!ClassLoader::has_bootclasspath_append()) {</span>
<span class="line-added">+            // If there is no bootclasspath append entry, no need to continue</span>
<span class="line-added">+            // searching.</span>
<span class="line-added">+            return NULL;</span>
<span class="line-added">+         }</span>
          search_only_bootloader_append = true;
        }
      }
  
      // Prior to bootstrapping&#39;s module initialization, never load a class outside
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1579,11 ***</span>
    Symbol*  name_h = k-&gt;name();
    Dictionary* dictionary = loader_data-&gt;dictionary();
    unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
    check_constraints(d_hash, k, class_loader_h, true, CHECK);
  
<span class="line-modified">!   // Register class just loaded with class loader (placed in Vector)</span>
    // Note we do this before updating the dictionary, as this can
    // fail with an OutOfMemoryError (if it does, we will *not* put this
    // class in the dictionary and will not update the class hierarchy).
    // JVMTI FollowReferences needs to find the classes this way.
    if (k-&gt;class_loader() != NULL) {
<span class="line-new-header">--- 1570,11 ---</span>
    Symbol*  name_h = k-&gt;name();
    Dictionary* dictionary = loader_data-&gt;dictionary();
    unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
    check_constraints(d_hash, k, class_loader_h, true, CHECK);
  
<span class="line-modified">!   // Register class just loaded with class loader (placed in ArrayList)</span>
    // Note we do this before updating the dictionary, as this can
    // fail with an OutOfMemoryError (if it does, we will *not* put this
    // class in the dictionary and will not update the class hierarchy).
    // JVMTI FollowReferences needs to find the classes this way.
    if (k-&gt;class_loader() != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1597,11 ***</span>
    // Add the new class. We need recompile lock during update of CHA.
    {
      unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
      int p_index = placeholders()-&gt;hash_to_index(p_hash);
  
<span class="line-modified">!     MutexLocker mu_r(Compile_lock, THREAD);</span>
  
      // Add to class hierarchy, initialize vtables, and do possible
      // deoptimizations.
      add_to_hierarchy(k, CHECK); // No exception, but can block
  
<span class="line-new-header">--- 1588,11 ---</span>
    // Add the new class. We need recompile lock during update of CHA.
    {
      unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
      int p_index = placeholders()-&gt;hash_to_index(p_hash);
  
<span class="line-modified">!     MutexLocker mu_r(THREAD, Compile_lock);</span>
  
      // Add to class hierarchy, initialize vtables, and do possible
      // deoptimizations.
      add_to_hierarchy(k, CHECK); // No exception, but can block
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1654,11 ***</span>
    unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
    int p_index = placeholders()-&gt;hash_to_index(p_hash);
    PlaceholderEntry* probe;
  
    {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      // First check if class already defined
      if (is_parallelDefine(class_loader)) {
        InstanceKlass* check = find_class(d_hash, name_h, dictionary);
        if (check != NULL) {
          return check;
<span class="line-new-header">--- 1645,11 ---</span>
    unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
    int p_index = placeholders()-&gt;hash_to_index(p_hash);
    PlaceholderEntry* probe;
  
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      // First check if class already defined
      if (is_parallelDefine(class_loader)) {
        InstanceKlass* check = find_class(d_hash, name_h, dictionary);
        if (check != NULL) {
          return check;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1695,11 ***</span>
  
    Handle linkage_exception = Handle(); // null handle
  
    // definer must notify any waiting threads
    {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
      assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
      if (probe != NULL) {
        if (HAS_PENDING_EXCEPTION) {
          linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
<span class="line-new-header">--- 1686,11 ---</span>
  
    Handle linkage_exception = Handle(); // null handle
  
    // definer must notify any waiting threads
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
      assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
      if (probe != NULL) {
        if (HAS_PENDING_EXCEPTION) {
          linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1743,11 ***</span>
  
    if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
        == ObjectSynchronizer::owner_other) {
      // contention will likely happen, so increment the corresponding
      // contention counter.
<span class="line-modified">!     if (oopDesc::equals(loader_lock(), _system_loader_lock_obj)) {</span>
        ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
      } else {
        ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
      }
    }
<span class="line-new-header">--- 1734,11 ---</span>
  
    if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
        == ObjectSynchronizer::owner_other) {
      // contention will likely happen, so increment the corresponding
      // contention counter.
<span class="line-modified">!     if (loader_lock() == _system_loader_lock_obj) {</span>
        ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
      } else {
        ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1830,23 ***</span>
      GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
      // First, mark for unload all ClassLoaderData referencing a dead class loader.
      unloading_occurred = ClassLoaderDataGraph::do_unloading();
      if (unloading_occurred) {
<span class="line-modified">!       MutexLockerEx ml2(is_concurrent ? Module_lock : NULL);</span>
        JFR_ONLY(Jfr::on_unloading_classes();)
  
<span class="line-modified">!       MutexLockerEx ml1(is_concurrent ? SystemDictionary_lock : NULL);</span>
        ClassLoaderDataGraph::clean_module_and_package_info();
        constraints()-&gt;purge_loader_constraints();
        resolution_errors()-&gt;purge_resolution_errors();
      }
    }
  
    GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
<span class="line-removed">-   // Trigger cleaning the ResolvedMethodTable even if no unloading occurred.</span>
<span class="line-removed">-   ResolvedMethodTable::trigger_cleanup();</span>
  
    if (unloading_occurred) {
      SymbolTable::trigger_cleanup();
  
      // Oops referenced by the protection domain cache table may get unreachable independently
<span class="line-new-header">--- 1821,21 ---</span>
      GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
      // First, mark for unload all ClassLoaderData referencing a dead class loader.
      unloading_occurred = ClassLoaderDataGraph::do_unloading();
      if (unloading_occurred) {
<span class="line-modified">!       MutexLocker ml2(is_concurrent ? Module_lock : NULL);</span>
        JFR_ONLY(Jfr::on_unloading_classes();)
  
<span class="line-modified">!       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);</span>
        ClassLoaderDataGraph::clean_module_and_package_info();
        constraints()-&gt;purge_loader_constraints();
        resolution_errors()-&gt;purge_resolution_errors();
      }
    }
  
    GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
  
    if (unloading_occurred) {
      SymbolTable::trigger_cleanup();
  
      // Oops referenced by the protection domain cache table may get unreachable independently
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1858,18 ***</span>
    }
  
    return unloading_occurred;
  }
  
<span class="line-modified">! void SystemDictionary::oops_do(OopClosure* f) {</span>
    f-&gt;do_oop(&amp;_java_system_loader);
    f-&gt;do_oop(&amp;_java_platform_loader);
    f-&gt;do_oop(&amp;_system_loader_lock_obj);
    CDS_ONLY(SystemDictionaryShared::oops_do(f);)
  
    // Visit extra methods
    invoke_method_table()-&gt;oops_do(f);
  }
  
  // CDS: scan and relocate all classes referenced by _well_known_klasses[].
  void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
    for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
<span class="line-new-header">--- 1847,22 ---</span>
    }
  
    return unloading_occurred;
  }
  
<span class="line-modified">! void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {</span>
    f-&gt;do_oop(&amp;_java_system_loader);
    f-&gt;do_oop(&amp;_java_platform_loader);
    f-&gt;do_oop(&amp;_system_loader_lock_obj);
    CDS_ONLY(SystemDictionaryShared::oops_do(f);)
  
    // Visit extra methods
    invoke_method_table()-&gt;oops_do(f);
<span class="line-added">+ </span>
<span class="line-added">+   if (include_handles) {</span>
<span class="line-added">+     OopStorageSet::vm_global()-&gt;oops_do(f);</span>
<span class="line-added">+   }</span>
  }
  
  // CDS: scan and relocate all classes referenced by _well_known_klasses[].
  void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
    for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1889,11 ***</span>
  // Initialization
  
  void SystemDictionary::initialize(TRAPS) {
    // Allocate arrays
    _placeholders        = new PlaceholderTable(_placeholder_table_size);
<span class="line-removed">-   _number_of_modifications = 0;</span>
    _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
    _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
    _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
    _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
  
<span class="line-new-header">--- 1882,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1930,17 ***</span>
    assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
    int sid = wk_init_info[id - FIRST_WKID];
    Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
    InstanceKlass** klassp = &amp;_well_known_klasses[id];
  
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_JVMCI</span>
<span class="line-removed">-   if (id &gt;= FIRST_JVMCI_WKID) {</span>
<span class="line-removed">-     assert(EnableJVMCI, &quot;resolve JVMCI classes only when EnableJVMCI is true&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
    if ((*klassp) == NULL) {
      Klass* k = resolve_or_fail(symbol, true, CHECK_0);
      (*klassp) = InstanceKlass::cast(k);
    }
    return ((*klassp) != NULL);
<span class="line-new-header">--- 1922,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1994,10 ***</span>
<span class="line-new-header">--- 1979,14 ---</span>
  #endif
    {
      resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
    }
  
<span class="line-added">+   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   java_lang_Object::register_natives(CHECK);</span>
<span class="line-added">+ </span>
    // Calculate offsets for String and Class classes since they are loaded and
    // can be used after this point.
    java_lang_String::compute_offsets();
    java_lang_Class::compute_offsets();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2011,25 ***</span>
  
    // do a bunch more:
    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
  
    // Preload ref klasses and set reference types
<span class="line-modified">!   InstanceKlass::cast(WK_KLASS(Reference_klass))-&gt;set_reference_type(REF_OTHER);</span>
    InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
  
    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
<span class="line-modified">!   InstanceKlass::cast(WK_KLASS(SoftReference_klass))-&gt;set_reference_type(REF_SOFT);</span>
<span class="line-modified">!   InstanceKlass::cast(WK_KLASS(WeakReference_klass))-&gt;set_reference_type(REF_WEAK);</span>
<span class="line-modified">!   InstanceKlass::cast(WK_KLASS(FinalReference_klass))-&gt;set_reference_type(REF_FINAL);</span>
<span class="line-modified">!   InstanceKlass::cast(WK_KLASS(PhantomReference_klass))-&gt;set_reference_type(REF_PHANTOM);</span>
  
    // JSR 292 classes
    WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
    WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
    resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
    resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
<span class="line-modified">!   WKID last = NOT_JVMCI(WKID_LIMIT) JVMCI_ONLY(FIRST_JVMCI_WKID);</span>
    resolve_wk_klasses_until(last, scan, CHECK);
  
    _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
    _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
    _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
<span class="line-new-header">--- 2000,25 ---</span>
  
    // do a bunch more:
    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
  
    // Preload ref klasses and set reference types
<span class="line-modified">!   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);</span>
    InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
  
    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
<span class="line-modified">!   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);</span>
<span class="line-modified">!   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);</span>
<span class="line-modified">!   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);</span>
<span class="line-modified">!   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);</span>
  
    // JSR 292 classes
    WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
    WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
    resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
    resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
<span class="line-modified">!   WKID last = WKID_LIMIT;</span>
    resolve_wk_klasses_until(last, scan, CHECK);
  
    _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
    _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
    _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2039,15 ***</span>
    _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
    _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
    //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
    //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
  
<span class="line-removed">-   { // Compute whether we should use checkPackageAccess or NOT</span>
<span class="line-removed">-     Method* method = InstanceKlass::cast(ClassLoader_klass())-&gt;find_method(vmSymbols::checkPackageAccess_name(), vmSymbols::class_protectiondomain_signature());</span>
<span class="line-removed">-     _has_checkPackageAccess = (method != NULL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
  #ifdef ASSERT
    if (UseSharedSpaces) {
      assert(JvmtiExport::is_early_phase(),
             &quot;All well known classes must be resolved in JVMTI early phase&quot;);
      for (int i = FIRST_WKID; i &lt; last; i++) {
<span class="line-new-header">--- 2028,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2088,11 ***</span>
  
    {
      Symbol *name = k-&gt;name();
      ClassLoaderData *loader_data = class_loader_data(class_loader);
  
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
  
      InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
      if (check != NULL) {
        // If different InstanceKlass - duplicate class definition,
        // else - ok, class loaded by a different thread in parallel.
<span class="line-new-header">--- 2072,11 ---</span>
  
    {
      Symbol *name = k-&gt;name();
      ClassLoaderData *loader_data = class_loader_data(class_loader);
  
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
  
      InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
      if (check != NULL) {
        // If different InstanceKlass - duplicate class definition,
        // else - ok, class loaded by a different thread in parallel.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2153,39 ***</span>
    assert_locked_or_safepoint(Compile_lock);
    Symbol*  name  = k-&gt;name();
    ClassLoaderData *loader_data = class_loader_data(class_loader);
  
    {
<span class="line-modified">!     MutexLocker mu1(SystemDictionary_lock, THREAD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // See whether biased locking is enabled and if so set it for this</span>
<span class="line-removed">-     // klass.</span>
<span class="line-removed">-     // Note that this must be done past the last potential blocking</span>
<span class="line-removed">-     // point / safepoint. We enable biased locking lazily using a</span>
<span class="line-removed">-     // VM_Operation to iterate the SystemDictionary and installing the</span>
<span class="line-removed">-     // biasable mark word into each InstanceKlass&#39;s prototype header.</span>
<span class="line-removed">-     // To avoid race conditions where we accidentally miss enabling the</span>
<span class="line-removed">-     // optimization for one class in the process of being added to the</span>
<span class="line-removed">-     // dictionary, we must not safepoint after the test of</span>
<span class="line-removed">-     // BiasedLocking::enabled().</span>
<span class="line-removed">-     if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="line-removed">-       // Set biased locking bit for all loaded classes; it will be</span>
<span class="line-removed">-       // cleared if revocation occurs too often for this type</span>
<span class="line-removed">-       // NOTE that we must only do this when the class is initally</span>
<span class="line-removed">-       // defined, not each time it is referenced from a new class loader</span>
<span class="line-removed">-       if (oopDesc::equals(k-&gt;class_loader(), class_loader())) {</span>
<span class="line-removed">-         k-&gt;set_prototype_header(markOopDesc::biased_locking_prototype());</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
  
      // Make a new dictionary entry.
      Dictionary* dictionary = loader_data-&gt;dictionary();
      InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
      if (sd_check == NULL) {
        dictionary-&gt;add_klass(d_hash, name, k);
<span class="line-removed">- </span>
<span class="line-removed">-       notice_modification();</span>
      }
    #ifdef ASSERT
      sd_check = find_class(d_hash, name, dictionary);
      assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
      // Note: there may be a placeholder entry: for circularity testing
<span class="line-new-header">--- 2137,17 ---</span>
    assert_locked_or_safepoint(Compile_lock);
    Symbol*  name  = k-&gt;name();
    ClassLoaderData *loader_data = class_loader_data(class_loader);
  
    {
<span class="line-modified">!     MutexLocker mu1(THREAD, SystemDictionary_lock);</span>
  
      // Make a new dictionary entry.
      Dictionary* dictionary = loader_data-&gt;dictionary();
      InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
      if (sd_check == NULL) {
        dictionary-&gt;add_klass(d_hash, name, k);
      }
    #ifdef ASSERT
      sd_check = find_class(d_hash, name, dictionary);
      assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
      // Note: there may be a placeholder entry: for circularity testing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2211,27 ***</span>
      return klass;
  
    // Now look to see if it has been loaded elsewhere, and is subject to
    // a loader constraint that would require this loader to return the
    // klass that is already loaded.
<span class="line-modified">!   if (FieldType::is_array(class_name)) {</span>
      // For array classes, their Klass*s are not kept in the
      // constraint table. The element Klass*s are.
<span class="line-modified">!     FieldArrayInfo fd;</span>
<span class="line-modified">!     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>
      if (t != T_OBJECT) {
        klass = Universe::typeArrayKlassObj(t);
      } else {
<span class="line-modified">!       MutexLocker mu(SystemDictionary_lock, THREAD);</span>
<span class="line-modified">!       klass = constraints()-&gt;find_constrained_klass(fd.object_key(), class_loader);</span>
      }
      // If element class already loaded, allocate array klass
      if (klass != NULL) {
<span class="line-modified">!       klass = klass-&gt;array_klass_or_null(fd.dimension());</span>
      }
    } else {
<span class="line-modified">!     MutexLocker mu(SystemDictionary_lock, THREAD);</span>
      // Non-array classes are easy: simply check the constraint table.
      klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
    }
  
    return klass;
<span class="line-new-header">--- 2173,28 ---</span>
      return klass;
  
    // Now look to see if it has been loaded elsewhere, and is subject to
    // a loader constraint that would require this loader to return the
    // klass that is already loaded.
<span class="line-modified">!   if (Signature::is_array(class_name)) {</span>
      // For array classes, their Klass*s are not kept in the
      // constraint table. The element Klass*s are.
<span class="line-modified">!     SignatureStream ss(class_name, false);</span>
<span class="line-modified">!     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added">+     BasicType t = ss.type();</span>
      if (t != T_OBJECT) {
        klass = Universe::typeArrayKlassObj(t);
      } else {
<span class="line-modified">!       MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-modified">!       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);</span>
      }
      // If element class already loaded, allocate array klass
      if (klass != NULL) {
<span class="line-modified">!       klass = klass-&gt;array_klass_or_null(ndims);</span>
      }
    } else {
<span class="line-modified">!     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
      // Non-array classes are easy: simply check the constraint table.
      klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
    }
  
    return klass;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2244,50 ***</span>
                                               Thread* THREAD) {
    ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
    ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
  
    Symbol* constraint_name = NULL;
<span class="line-modified">!   // Needs to be in same scope as constraint_name in case a Symbol is created and</span>
<span class="line-modified">!   // assigned to constraint_name.</span>
<span class="line-removed">-   FieldArrayInfo fd;</span>
<span class="line-removed">-   if (!FieldType::is_array(class_name)) {</span>
      constraint_name = class_name;
    } else {
      // For array classes, their Klass*s are not kept in the
      // constraint table. The element classes are.
<span class="line-modified">!     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(false));</span>
<span class="line-modified">!     // primitive types always pass</span>
<span class="line-modified">!     if (t != T_OBJECT) {</span>
<span class="line-modified">!       return true;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       constraint_name = fd.object_key();</span>
      }
    }
  
    Dictionary* dictionary1 = loader_data1-&gt;dictionary();
    unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
  
    Dictionary* dictionary2 = loader_data2-&gt;dictionary();
    unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
  
    {
<span class="line-modified">!     MutexLocker mu_s(SystemDictionary_lock, THREAD);</span>
      InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
      InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">!     return constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">!                                     klass2, class_loader2);</span>
    }
  }
  
  // Add entry to resolution error table to record the error when the first
  // attempt to resolve a reference to a class has failed.
  void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
                                              Symbol* error, Symbol* message) {
    unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
    int index = resolution_errors()-&gt;hash_to_index(hash);
    {
<span class="line-modified">!     MutexLocker ml(SystemDictionary_lock, Thread::current());</span>
      resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
    }
  }
  
  // Delete a resolution error for RedefineClasses for a constant pool is going away
<span class="line-new-header">--- 2207,55 ---</span>
                                               Thread* THREAD) {
    ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
    ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
  
    Symbol* constraint_name = NULL;
<span class="line-modified">! </span>
<span class="line-modified">!   if (!Signature::is_array(class_name)) {</span>
      constraint_name = class_name;
    } else {
      // For array classes, their Klass*s are not kept in the
      // constraint table. The element classes are.
<span class="line-modified">!     SignatureStream ss(class_name, false);</span>
<span class="line-modified">!     ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-modified">!     if (!ss.has_envelope()) {</span>
<span class="line-modified">!       return true;     // primitive types always pass</span>
      }
<span class="line-added">+     constraint_name = ss.as_symbol();</span>
<span class="line-added">+     // Increment refcount to keep constraint_name alive after</span>
<span class="line-added">+     // SignatureStream is destructed. It will be decremented below</span>
<span class="line-added">+     // before returning.</span>
<span class="line-added">+     constraint_name-&gt;increment_refcount();</span>
    }
  
    Dictionary* dictionary1 = loader_data1-&gt;dictionary();
    unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
  
    Dictionary* dictionary2 = loader_data2-&gt;dictionary();
    unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
  
    {
<span class="line-modified">!     MutexLocker mu_s(THREAD, SystemDictionary_lock);</span>
      InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
      InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">!     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">!                                            klass2, class_loader2);</span>
<span class="line-added">+     if (Signature::is_array(class_name)) {</span>
<span class="line-added">+       constraint_name-&gt;decrement_refcount();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return result;</span>
    }
  }
  
  // Add entry to resolution error table to record the error when the first
  // attempt to resolve a reference to a class has failed.
  void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
                                              Symbol* error, Symbol* message) {
    unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
    int index = resolution_errors()-&gt;hash_to_index(hash);
    {
<span class="line-modified">!     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
      resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
    }
  }
  
  // Delete a resolution error for RedefineClasses for a constant pool is going away
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2299,11 ***</span>
  Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
                                                  Symbol** message) {
    unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
    int index = resolution_errors()-&gt;hash_to_index(hash);
    {
<span class="line-modified">!     MutexLocker ml(SystemDictionary_lock, Thread::current());</span>
      ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
      if (entry != NULL) {
        *message = entry-&gt;message();
        return entry-&gt;error();
      } else {
<span class="line-new-header">--- 2267,11 ---</span>
  Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
                                                  Symbol** message) {
    unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
    int index = resolution_errors()-&gt;hash_to_index(hash);
    {
<span class="line-modified">!     MutexLocker ml(Thread::current(), SystemDictionary_lock);</span>
      ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
      if (entry != NULL) {
        *message = entry-&gt;message();
        return entry-&gt;error();
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2365,31 ***</span>
  // Arrays are not added to the loader constraint table, their elements are.
  Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
                                                 Handle loader1, Handle loader2,
                                                 bool is_method, TRAPS)  {
    // Nothing to do if loaders are the same.
<span class="line-modified">!   if (oopDesc::equals(loader1(), loader2())) {</span>
      return NULL;
    }
  
<span class="line-modified">!   SignatureStream sig_strm(signature, is_method);</span>
<span class="line-modified">!   while (!sig_strm.is_done()) {</span>
<span class="line-modified">!     if (sig_strm.is_object()) {</span>
<span class="line-modified">!       Symbol* sig = sig_strm.as_symbol(CHECK_NULL);</span>
        if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
          return sig;
        }
      }
<span class="line-removed">-     sig_strm.next();</span>
    }
    return NULL;
  }
  
  
<span class="line-modified">! methodHandle SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,</span>
<span class="line-modified">!                                                             Symbol* signature,</span>
<span class="line-modified">!                                                             TRAPS) {</span>
    methodHandle empty;
    assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
           MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
           iid != vmIntrinsics::_invokeGeneric,
           &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
<span class="line-new-header">--- 2333,32 ---</span>
  // Arrays are not added to the loader constraint table, their elements are.
  Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
                                                 Handle loader1, Handle loader2,
                                                 bool is_method, TRAPS)  {
    // Nothing to do if loaders are the same.
<span class="line-modified">!   if (loader1() == loader2()) {</span>
      return NULL;
    }
  
<span class="line-modified">!   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {</span>
<span class="line-modified">!     if (ss.is_reference()) {</span>
<span class="line-modified">!       Symbol* sig = ss.as_symbol();</span>
<span class="line-modified">!       // Note: In the future, if template-like types can take</span>
<span class="line-added">+       // arguments, we will want to recognize them and dig out class</span>
<span class="line-added">+       // names hiding inside the argument lists.</span>
        if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
          return sig;
        }
      }
    }
    return NULL;
  }
  
  
<span class="line-modified">! Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,</span>
<span class="line-modified">!                                                        Symbol* signature,</span>
<span class="line-modified">!                                                        TRAPS) {</span>
    methodHandle empty;
    assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
           MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
           iid != vmIntrinsics::_invokeGeneric,
           &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2399,24 ***</span>
    SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
    methodHandle m;
    if (spe == NULL || spe-&gt;method() == NULL) {
      spe = NULL;
      // Must create lots of stuff here, but outside of the SystemDictionary lock.
<span class="line-modified">!     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_(empty));</span>
      if (!Arguments::is_interpreter_only()) {
        // Generate a compiled form of the MH intrinsic.
        AdapterHandlerLibrary::create_native_wrapper(m);
        // Check if have the compiled code.
        if (!m-&gt;has_compiled_code()) {
<span class="line-modified">!         THROW_MSG_(vmSymbols::java_lang_VirtualMachineError(),</span>
<span class="line-modified">!                    &quot;Out of space in CodeCache for method handle intrinsic&quot;, empty);</span>
        }
      }
      // Now grab the lock.  We might have to throw away the new method,
      // if a racing thread has managed to install one at the same time.
      {
<span class="line-modified">!       MutexLocker ml(SystemDictionary_lock, THREAD);</span>
        spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
        if (spe == NULL)
          spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
        if (spe-&gt;method() == NULL)
          spe-&gt;set_method(m());
<span class="line-new-header">--- 2368,24 ---</span>
    SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
    methodHandle m;
    if (spe == NULL || spe-&gt;method() == NULL) {
      spe = NULL;
      // Must create lots of stuff here, but outside of the SystemDictionary lock.
<span class="line-modified">!     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);</span>
      if (!Arguments::is_interpreter_only()) {
        // Generate a compiled form of the MH intrinsic.
        AdapterHandlerLibrary::create_native_wrapper(m);
        // Check if have the compiled code.
        if (!m-&gt;has_compiled_code()) {
<span class="line-modified">!         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),</span>
<span class="line-modified">!                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);</span>
        }
      }
      // Now grab the lock.  We might have to throw away the new method,
      // if a racing thread has managed to install one at the same time.
      {
<span class="line-modified">!       MutexLocker ml(THREAD, SystemDictionary_lock);</span>
        spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
        if (spe == NULL)
          spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
        if (spe-&gt;method() == NULL)
          spe-&gt;set_method(m());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2429,16 ***</span>
           &quot;MH intrinsic invariant&quot;);
    return spe-&gt;method();
  }
  
  // Helper for unpacking the return value from linkMethod and linkCallSite.
<span class="line-modified">! static methodHandle unpack_method_and_appendix(Handle mname,</span>
<span class="line-modified">!                                                Klass* accessing_klass,</span>
<span class="line-modified">!                                                objArrayHandle appendix_box,</span>
<span class="line-modified">!                                                Handle* appendix_result,</span>
<span class="line-modified">!                                                TRAPS) {</span>
<span class="line-removed">-   methodHandle empty;</span>
    if (mname.not_null()) {
      Method* m = java_lang_invoke_MemberName::vmtarget(mname());
      if (m != NULL) {
        oop appendix = appendix_box-&gt;obj_at(0);
        if (TraceMethodHandles) {
<span class="line-new-header">--- 2398,15 ---</span>
           &quot;MH intrinsic invariant&quot;);
    return spe-&gt;method();
  }
  
  // Helper for unpacking the return value from linkMethod and linkCallSite.
<span class="line-modified">! static Method* unpack_method_and_appendix(Handle mname,</span>
<span class="line-modified">!                                           Klass* accessing_klass,</span>
<span class="line-modified">!                                           objArrayHandle appendix_box,</span>
<span class="line-modified">!                                           Handle* appendix_result,</span>
<span class="line-modified">!                                           TRAPS) {</span>
    if (mname.not_null()) {
      Method* m = java_lang_invoke_MemberName::vmtarget(mname());
      if (m != NULL) {
        oop appendix = appendix_box-&gt;obj_at(0);
        if (TraceMethodHandles) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2452,39 ***</span>
        }
        (*appendix_result) = Handle(THREAD, appendix);
        // the target is stored in the cpCache and if a reference to this
        // MemberName is dropped we need a way to make sure the
        // class_loader containing this method is kept alive.
        ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
        this_key-&gt;record_dependency(m-&gt;method_holder());
<span class="line-modified">!       return methodHandle(THREAD, m);</span>
      }
    }
<span class="line-modified">!   THROW_MSG_(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;, empty);</span>
<span class="line-removed">-   return empty;</span>
  }
  
<span class="line-modified">! methodHandle SystemDictionary::find_method_handle_invoker(Klass* klass,</span>
<span class="line-modified">!                                                           Symbol* name,</span>
<span class="line-modified">!                                                           Symbol* signature,</span>
                                                            Klass* accessing_klass,
                                                            Handle *appendix_result,
                                                            TRAPS) {
<span class="line-removed">-   methodHandle empty;</span>
    assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
    Handle method_type =
<span class="line-modified">!     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_(empty));</span>
  
    int ref_kind = JVM_REF_invokeVirtual;
<span class="line-modified">!   oop name_oop = StringTable::intern(name, CHECK_(empty));</span>
    Handle name_str (THREAD, name_oop);
<span class="line-modified">!   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_(empty));</span>
    assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
  
    // This should not happen.  JDK code should take care of that.
    if (accessing_klass == NULL || method_type.is_null()) {
<span class="line-modified">!     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;, empty);</span>
    }
  
    // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
    JavaCallArguments args;
    args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
<span class="line-new-header">--- 2420,38 ---</span>
        }
        (*appendix_result) = Handle(THREAD, appendix);
        // the target is stored in the cpCache and if a reference to this
        // MemberName is dropped we need a way to make sure the
        // class_loader containing this method is kept alive.
<span class="line-added">+       methodHandle mh(THREAD, m); // record_dependency can safepoint.</span>
        ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
        this_key-&gt;record_dependency(m-&gt;method_holder());
<span class="line-modified">!       return mh();</span>
      }
    }
<span class="line-modified">!   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);</span>
  }
  
<span class="line-modified">! Method* SystemDictionary::find_method_handle_invoker(Klass* klass,</span>
<span class="line-modified">!                                                      Symbol* name,</span>
<span class="line-modified">!                                                      Symbol* signature,</span>
                                                            Klass* accessing_klass,
                                                            Handle *appendix_result,
                                                            TRAPS) {
    assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
    Handle method_type =
<span class="line-modified">!     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);</span>
  
    int ref_kind = JVM_REF_invokeVirtual;
<span class="line-modified">!   oop name_oop = StringTable::intern(name, CHECK_NULL);</span>
    Handle name_str (THREAD, name_oop);
<span class="line-modified">!   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);</span>
    assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
  
    // This should not happen.  JDK code should take care of that.
    if (accessing_klass == NULL || method_type.is_null()) {
<span class="line-modified">!     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);</span>
    }
  
    // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
    JavaCallArguments args;
    args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2496,11 ***</span>
    JavaValue result(T_OBJECT);
    JavaCalls::call_static(&amp;result,
                           SystemDictionary::MethodHandleNatives_klass(),
                           vmSymbols::linkMethod_name(),
                           vmSymbols::linkMethod_signature(),
<span class="line-modified">!                          &amp;args, CHECK_(empty));</span>
    Handle mname(THREAD, (oop) result.get_jobject());
    return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
  }
  
  // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
<span class="line-new-header">--- 2463,11 ---</span>
    JavaValue result(T_OBJECT);
    JavaCalls::call_static(&amp;result,
                           SystemDictionary::MethodHandleNatives_klass(),
                           vmSymbols::linkMethod_name(),
                           vmSymbols::linkMethod_signature(),
<span class="line-modified">!                          &amp;args, CHECK_NULL);</span>
    Handle mname(THREAD, (oop) result.get_jobject());
    return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
  }
  
  // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2520,18 ***</span>
    return klass-&gt;is_public() &amp;&amp;
           (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
            InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- // Return the Java mirror (java.lang.Class instance) for a single-character</span>
<span class="line-removed">- // descriptor.  This result, when available, is the same as produced by the</span>
<span class="line-removed">- // heavier API point of the same name that takes a Symbol.</span>
<span class="line-removed">- oop SystemDictionary::find_java_mirror_for_type(char signature_char) {</span>
<span class="line-removed">-   return java_lang_Class::primitive_mirror(char2type(signature_char));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Find or construct the Java mirror (java.lang.Class instance) for a
  // for the given field type signature, as interpreted relative to the
  // given class loader.  Handles primitives, void, references, arrays,
  // and all other reflectable types, except method types.
  // N.B.  Code in reflection should use this entry point.
<span class="line-new-header">--- 2487,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2544,36 ***</span>
    Handle empty;
  
    assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
           &quot;one or the other, or perhaps neither&quot;);
  
<span class="line-modified">!   Symbol* type = signature;</span>
  
    // What we have here must be a valid field descriptor,
    // and all valid field descriptors are supported.
    // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">!   if (type-&gt;utf8_length() == 1) {</span>
  
      // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">!     char ch = type-&gt;char_at(0);</span>
<span class="line-removed">-     assert(is_java_primitive(char2type(ch)) || ch == &#39;V&#39;, &quot;&quot;);</span>
<span class="line-removed">-     return Handle(THREAD, find_java_mirror_for_type(ch));</span>
  
<span class="line-modified">!   } else if (FieldType::is_obj(type) || FieldType::is_array(type)) {</span>
  
      // It&#39;s a reference type.
      if (accessing_klass != NULL) {
        class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
        protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
      }
      Klass* constant_type_klass;
      if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">!       constant_type_klass = resolve_or_null(type, class_loader, protection_domain,</span>
                                              CHECK_(empty));
      } else {
        bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">!       constant_type_klass = resolve_or_fail(type, class_loader, protection_domain,</span>
                                              throw_error, CHECK_(empty));
      }
      if (constant_type_klass == NULL) {
        return Handle();  // report failure this way
      }
<span class="line-new-header">--- 2503,34 ---</span>
    Handle empty;
  
    assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
           &quot;one or the other, or perhaps neither&quot;);
  
<span class="line-modified">!   SignatureStream ss(signature, false);</span>
  
    // What we have here must be a valid field descriptor,
    // and all valid field descriptors are supported.
    // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">!   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
  
      // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">!     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>
  
<span class="line-modified">!   } else if (ss.is_reference()) {</span>
  
      // It&#39;s a reference type.
      if (accessing_klass != NULL) {
        class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
        protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
      }
      Klass* constant_type_klass;
      if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">!       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
                                              CHECK_(empty));
      } else {
        bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">!       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
                                              throw_error, CHECK_(empty));
      }
      if (constant_type_klass == NULL) {
        return Handle();  // report failure this way
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2632,21 ***</span>
      oop mirror = NULL;
      if (can_be_cached) {
        // Use neutral class loader to lookup candidate classes to be placed in the cache.
        mirror = ss.as_java_mirror(Handle(), Handle(),
                                   SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">!       if (mirror == NULL || (ss.is_object() &amp;&amp; !is_always_visible_class(mirror))) {</span>
          // Fall back to accessing_klass context.
          can_be_cached = false;
        }
      }
      if (!can_be_cached) {
        // Resolve, throwing a real error if it doesn&#39;t work.
        mirror = ss.as_java_mirror(class_loader, protection_domain,
                                   SignatureStream::NCDFError, CHECK_(empty));
      }
<span class="line-modified">!     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol(THREAD)-&gt;as_C_string());</span>
      if (ss.at_return_type())
        rt = Handle(THREAD, mirror);
      else
        pts-&gt;obj_at_put(arg++, mirror);
  
<span class="line-new-header">--- 2589,21 ---</span>
      oop mirror = NULL;
      if (can_be_cached) {
        // Use neutral class loader to lookup candidate classes to be placed in the cache.
        mirror = ss.as_java_mirror(Handle(), Handle(),
                                   SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">!       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {</span>
          // Fall back to accessing_klass context.
          can_be_cached = false;
        }
      }
      if (!can_be_cached) {
        // Resolve, throwing a real error if it doesn&#39;t work.
        mirror = ss.as_java_mirror(class_loader, protection_domain,
                                   SignatureStream::NCDFError, CHECK_(empty));
      }
<span class="line-modified">!     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());</span>
      if (ss.at_return_type())
        rt = Handle(THREAD, mirror);
      else
        pts-&gt;obj_at_put(arg++, mirror);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2673,11 ***</span>
                           &amp;args, CHECK_(empty));
    Handle method_type(THREAD, (oop) result.get_jobject());
  
    if (can_be_cached) {
      // We can cache this MethodType inside the JVM.
<span class="line-modified">!     MutexLocker ml(SystemDictionary_lock, THREAD);</span>
      spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
      if (spe == NULL)
        spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
      if (spe-&gt;method_type() == NULL) {
        spe-&gt;set_method_type(method_type());
<span class="line-new-header">--- 2630,11 ---</span>
                           &amp;args, CHECK_(empty));
    Handle method_type(THREAD, (oop) result.get_jobject());
  
    if (can_be_cached) {
      // We can cache this MethodType inside the JVM.
<span class="line-modified">!     MutexLocker ml(THREAD, SystemDictionary_lock);</span>
      spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
      if (spe == NULL)
        spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
      if (spe-&gt;method_type() == NULL) {
        spe-&gt;set_method_type(method_type());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2758,110 ***</span>
                           vmSymbols::linkMethodHandleConstant_signature(),
                           &amp;args, CHECK_(empty));
    return Handle(THREAD, (oop) result.get_jobject());
  }
  
<span class="line-modified">! // Ask Java to compute a constant by invoking a BSM given a Dynamic_info CP entry</span>
<span class="line-modified">! Handle SystemDictionary::link_dynamic_constant(Klass* caller,</span>
<span class="line-modified">!                                                int condy_index,</span>
<span class="line-modified">!                                                Handle bootstrap_specifier,</span>
<span class="line-modified">!                                                Symbol* name,</span>
<span class="line-modified">!                                                Symbol* type,</span>
<span class="line-removed">-                                                TRAPS) {</span>
<span class="line-removed">-   Handle empty;</span>
<span class="line-removed">-   Handle bsm, info;</span>
<span class="line-removed">-   if (java_lang_invoke_MethodHandle::is_instance(bootstrap_specifier())) {</span>
<span class="line-removed">-     bsm = bootstrap_specifier;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(bootstrap_specifier-&gt;is_objArray(), &quot;&quot;);</span>
<span class="line-removed">-     objArrayOop args = (objArrayOop) bootstrap_specifier();</span>
<span class="line-removed">-     assert(args-&gt;length() == 2, &quot;&quot;);</span>
<span class="line-removed">-     bsm  = Handle(THREAD, args-&gt;obj_at(0));</span>
<span class="line-removed">-     info = Handle(THREAD, args-&gt;obj_at(1));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm()),</span>
<span class="line-removed">-             &quot;caller must supply a valid BSM&quot;);</span>
  
    // This should not happen.  JDK code should take care of that.
<span class="line-modified">!   if (caller == NULL) {</span>
<span class="line-modified">!     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad dynamic constant&quot;, empty);</span>
    }
  
<span class="line-modified">!   Handle constant_name = java_lang_String::create_from_symbol(name, CHECK_(empty));</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Resolve the constant type in the context of the caller class</span>
<span class="line-modified">!   Handle type_mirror = find_java_mirror_for_type(type, caller, SignatureStream::NCDFError,</span>
<span class="line-modified">!                                                  CHECK_(empty));</span>
  
<span class="line-modified">!   // call java.lang.invoke.MethodHandleNatives::linkConstantDyanmic(caller, condy_index, bsm, type, info)</span>
    JavaCallArguments args;
<span class="line-modified">!   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));</span>
<span class="line-modified">!   args.push_int(condy_index);</span>
<span class="line-modified">!   args.push_oop(bsm);</span>
<span class="line-modified">!   args.push_oop(constant_name);</span>
<span class="line-modified">!   args.push_oop(type_mirror);</span>
<span class="line-modified">!   args.push_oop(info);</span>
    JavaValue result(T_OBJECT);
    JavaCalls::call_static(&amp;result,
                           SystemDictionary::MethodHandleNatives_klass(),
<span class="line-modified">!                          vmSymbols::linkDynamicConstant_name(),</span>
<span class="line-modified">!                          vmSymbols::linkDynamicConstant_signature(),</span>
<span class="line-modified">!                          &amp;args, CHECK_(empty));</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return Handle(THREAD, (oop) result.get_jobject());</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Ask Java code to find or construct a java.lang.invoke.CallSite for the given</span>
<span class="line-modified">! // name and signature, as interpreted relative to the given class loader.</span>
<span class="line-modified">! methodHandle SystemDictionary::find_dynamic_call_site_invoker(Klass* caller,</span>
<span class="line-modified">!                                                               int indy_index,</span>
<span class="line-modified">!                                                               Handle bootstrap_specifier,</span>
<span class="line-modified">!                                                               Symbol* name,</span>
<span class="line-removed">-                                                               Symbol* type,</span>
<span class="line-removed">-                                                               Handle *appendix_result,</span>
<span class="line-removed">-                                                               TRAPS) {</span>
<span class="line-removed">-   methodHandle empty;</span>
<span class="line-removed">-   Handle bsm, info;</span>
<span class="line-removed">-   if (java_lang_invoke_MethodHandle::is_instance(bootstrap_specifier())) {</span>
<span class="line-removed">-     bsm = bootstrap_specifier;</span>
    } else {
<span class="line-modified">!     objArrayOop args = (objArrayOop) bootstrap_specifier();</span>
<span class="line-removed">-     assert(args-&gt;length() == 2, &quot;&quot;);</span>
<span class="line-removed">-     bsm  = Handle(THREAD, args-&gt;obj_at(0));</span>
<span class="line-removed">-     info = Handle(THREAD, args-&gt;obj_at(1));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   guarantee(java_lang_invoke_MethodHandle::is_instance(bsm()),</span>
<span class="line-removed">-             &quot;caller must supply a valid BSM&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Handle method_name = java_lang_String::create_from_symbol(name, CHECK_(empty));</span>
<span class="line-removed">-   Handle method_type = find_method_handle_type(type, caller, CHECK_(empty));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // This should not happen.  JDK code should take care of that.</span>
<span class="line-removed">-   if (caller == NULL || method_type.is_null()) {</span>
<span class="line-removed">-     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad invokedynamic&quot;, empty);</span>
    }
  
<span class="line-modified">!   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_(empty));</span>
<span class="line-modified">!   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // call java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)</span>
<span class="line-removed">-   JavaCallArguments args;</span>
<span class="line-removed">-   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));</span>
<span class="line-removed">-   args.push_int(indy_index);</span>
<span class="line-removed">-   args.push_oop(bsm);</span>
<span class="line-removed">-   args.push_oop(method_name);</span>
<span class="line-removed">-   args.push_oop(method_type);</span>
<span class="line-removed">-   args.push_oop(info);</span>
<span class="line-removed">-   args.push_oop(appendix_box);</span>
<span class="line-removed">-   JavaValue result(T_OBJECT);</span>
<span class="line-removed">-   JavaCalls::call_static(&amp;result,</span>
<span class="line-removed">-                          SystemDictionary::MethodHandleNatives_klass(),</span>
<span class="line-removed">-                          vmSymbols::linkCallSite_name(),</span>
<span class="line-removed">-                          vmSymbols::linkCallSite_signature(),</span>
<span class="line-removed">-                          &amp;args, CHECK_(empty));</span>
<span class="line-removed">-   Handle mname(THREAD, (oop) result.get_jobject());</span>
<span class="line-removed">-   return unpack_method_and_appendix(mname, caller, appendix_box, appendix_result, THREAD);</span>
  }
  
  // Protection domain cache table handling
  
  ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
<span class="line-new-header">--- 2715,66 ---</span>
                           vmSymbols::linkMethodHandleConstant_signature(),
                           &amp;args, CHECK_(empty));
    return Handle(THREAD, (oop) result.get_jobject());
  }
  
<span class="line-modified">! // Ask Java to run a bootstrap method, in order to create a dynamic call site</span>
<span class="line-modified">! // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry</span>
<span class="line-modified">! // with linkage results being stored back into the bootstrap specifier.</span>
<span class="line-modified">! void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {</span>
<span class="line-modified">!   // Resolve the bootstrap specifier, its name, type, and static arguments</span>
<span class="line-modified">!   bootstrap_specifier.resolve_bsm(CHECK);</span>
  
    // This should not happen.  JDK code should take care of that.
<span class="line-modified">!   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {</span>
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);</span>
    }
  
<span class="line-modified">!   bool is_indy = bootstrap_specifier.is_method_call();</span>
<span class="line-modified">!   objArrayHandle appendix_box;</span>
<span class="line-modified">!   if (is_indy) {</span>
<span class="line-modified">!     // Some method calls may require an appendix argument.  Arrange to receive it.</span>
<span class="line-modified">!     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);</span>
<span class="line-added">+     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)</span>
<span class="line-added">+   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)</span>
    JavaCallArguments args;
<span class="line-modified">!   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));</span>
<span class="line-modified">!   args.push_int(bootstrap_specifier.bss_index());</span>
<span class="line-modified">!   args.push_oop(bootstrap_specifier.bsm());</span>
<span class="line-modified">!   args.push_oop(bootstrap_specifier.name_arg());</span>
<span class="line-modified">!   args.push_oop(bootstrap_specifier.type_arg());</span>
<span class="line-modified">!   args.push_oop(bootstrap_specifier.arg_values());</span>
<span class="line-added">+   if (is_indy) {</span>
<span class="line-added">+     args.push_oop(appendix_box);</span>
<span class="line-added">+   }</span>
    JavaValue result(T_OBJECT);
    JavaCalls::call_static(&amp;result,
                           SystemDictionary::MethodHandleNatives_klass(),
<span class="line-modified">!                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),</span>
<span class="line-modified">!                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),</span>
<span class="line-modified">!                          &amp;args, CHECK);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Handle value(THREAD, (oop) result.get_jobject());</span>
<span class="line-modified">!   if (is_indy) {</span>
<span class="line-modified">!     Handle appendix;</span>
<span class="line-modified">!     Method* method = unpack_method_and_appendix(value,</span>
<span class="line-modified">!                                                 bootstrap_specifier.caller(),</span>
<span class="line-modified">!                                                 appendix_box,</span>
<span class="line-modified">!                                                 &amp;appendix, CHECK);</span>
<span class="line-modified">!     methodHandle mh(THREAD, method);</span>
<span class="line-modified">!     bootstrap_specifier.set_resolved_method(mh, appendix);</span>
    } else {
<span class="line-modified">!     bootstrap_specifier.set_resolved_value(value);</span>
    }
  
<span class="line-modified">!   // sanity check</span>
<span class="line-modified">!   assert(bootstrap_specifier.is_resolved() ||</span>
<span class="line-modified">!          (bootstrap_specifier.is_method_call() &amp;&amp;</span>
<span class="line-modified">!           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);</span>
  }
  
  // Protection domain cache table handling
  
  ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2886,10 ***</span>
<span class="line-new-header">--- 2799,12 ---</span>
  
    _pd_cache_table-&gt;print_on(st);
    st-&gt;cr();
  }
  
<span class="line-added">+ void SystemDictionary::print() { print_on(tty); }</span>
<span class="line-added">+ </span>
  void SystemDictionary::verify() {
    guarantee(constraints() != NULL,
              &quot;Verify of loader constraints failed&quot;);
    guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
              &quot;Verify of placeholders failed&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2912,17 ***</span>
    assert_locked_or_safepoint(SystemDictionary_lock);
    if (verbose) {
      print_on(st);
    } else {
      CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
<span class="line-modified">!     ClassLoaderDataGraph::print_dictionary_statistics(st);</span>
      placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
      constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
<span class="line-modified">!     _pd_cache_table-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);</span>
    }
  }
  
  // Utility for dumping dictionaries.
  SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
                                   DCmdWithParser(output, heap),
    _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
             &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
<span class="line-new-header">--- 2827,32 ---</span>
    assert_locked_or_safepoint(SystemDictionary_lock);
    if (verbose) {
      print_on(st);
    } else {
      CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
<span class="line-modified">!     ClassLoaderDataGraph::print_table_statistics(st);</span>
      placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
      constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
<span class="line-modified">!     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);</span>
    }
  }
  
<span class="line-added">+ TableStatistics SystemDictionary::placeholders_statistics() {</span>
<span class="line-added">+   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">+   return placeholders()-&gt;statistics_calculate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TableStatistics SystemDictionary::loader_constraints_statistics() {</span>
<span class="line-added">+   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">+   return constraints()-&gt;statistics_calculate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TableStatistics SystemDictionary::protection_domain_cache_statistics() {</span>
<span class="line-added">+   MutexLocker ml(SystemDictionary_lock);</span>
<span class="line-added">+   return pd_cache_table()-&gt;statistics_calculate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Utility for dumping dictionaries.
  SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
                                   DCmdWithParser(output, heap),
    _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
             &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2943,17 ***</span>
      return dcmd-&gt;_dcmdparser.num_arguments();
    } else {
      return 0;
    }
  }
<span class="line-removed">- </span>
<span class="line-removed">- void SystemDictionary::initialize_oop_storage() {</span>
<span class="line-removed">-   _vm_weak_oop_storage =</span>
<span class="line-removed">-     new OopStorage(&quot;VM Weak Oop Handles&quot;,</span>
<span class="line-removed">-                    VMWeakAlloc_lock,</span>
<span class="line-removed">-                    VMWeakActive_lock);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- OopStorage* SystemDictionary::vm_weak_oop_storage() {</span>
<span class="line-removed">-   assert(_vm_weak_oop_storage != NULL, &quot;Uninitialized&quot;);</span>
<span class="line-removed">-   return _vm_weak_oop_storage;</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 2873,5 ---</span>
</pre>
<center><a href="symbolTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
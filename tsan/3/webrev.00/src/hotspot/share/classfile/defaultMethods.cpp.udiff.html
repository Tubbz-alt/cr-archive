<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/defaultMethods.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compactHashtable.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/defaultMethods.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,11 @@</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/klass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -44,42 +45,10 @@</span>
  #include &quot;utilities/pair.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  
  typedef enum { QUALIFIED, DISQUALIFIED } QualifiedState;
  
<span class="udiff-line-removed">- // Because we use an iterative algorithm when iterating over the type</span>
<span class="udiff-line-removed">- // hierarchy, we can&#39;t use traditional scoped objects which automatically do</span>
<span class="udiff-line-removed">- // cleanup in the destructor when the scope is exited.  PseudoScope (and</span>
<span class="udiff-line-removed">- // PseudoScopeMark) provides a similar functionality, but for when you want a</span>
<span class="udiff-line-removed">- // scoped object in non-stack memory (such as in resource memory, as we do</span>
<span class="udiff-line-removed">- // here).  You&#39;ve just got to remember to call &#39;destroy()&#39; on the scope when</span>
<span class="udiff-line-removed">- // leaving it (and marks have to be explicitly added).</span>
<span class="udiff-line-removed">- class PseudoScopeMark : public ResourceObj {</span>
<span class="udiff-line-removed">-  public:</span>
<span class="udiff-line-removed">-   virtual void destroy() = 0;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- class PseudoScope : public ResourceObj {</span>
<span class="udiff-line-removed">-  private:</span>
<span class="udiff-line-removed">-   GrowableArray&lt;PseudoScopeMark*&gt; _marks;</span>
<span class="udiff-line-removed">-  public:</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static PseudoScope* cast(void* data) {</span>
<span class="udiff-line-removed">-     return static_cast&lt;PseudoScope*&gt;(data);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void add_mark(PseudoScopeMark* psm) {</span>
<span class="udiff-line-removed">-    _marks.append(psm);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void destroy() {</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; _marks.length(); ++i) {</span>
<span class="udiff-line-removed">-       _marks.at(i)-&gt;destroy();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  static void print_slot(outputStream* str, Symbol* name, Symbol* signature) {
    str-&gt;print(&quot;%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
  }
  
  static void print_method(outputStream* str, Method* mo, bool with_class=true) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,17 +74,17 @@</span>
   * encountered (visit()), The algorithm can cut-off further exploration of a
   * particular branch by returning &#39;false&#39; from a visit() call.
   *
   * The ALGO class, must provide a visit() method, which each of which will be
   * called once for each node in the inheritance tree during the iteration.  In
<span class="udiff-line-modified-removed">-  * addition, it can provide a memory block via new_node_data(InstanceKlass*),</span>
<span class="udiff-line-modified-removed">-  * which it can use for node-specific storage (and access via the</span>
<span class="udiff-line-modified-removed">-  * current_data() and data_at_depth(int) methods).</span>
<span class="udiff-line-modified-added">+  * addition, it can provide a memory block via new_node_data(), which it can</span>
<span class="udiff-line-modified-added">+  * use for node-specific storage (and access via the current_data() and</span>
<span class="udiff-line-modified-added">+  * data_at_depth(int) methods).</span>
   *
   * Bare minimum needed to be an ALGO class:
   * class Algo : public HierarchyVisitor&lt;Algo&gt; {
<span class="udiff-line-modified-removed">-  *   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
<span class="udiff-line-modified-added">+  *   void* new_node_data() { return NULL; }</span>
   *   void free_node_data(void* data) { return; }
   *   bool visit() { return true; }
   * };
   */
  template &lt;class ALGO&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,10 +100,16 @@</span>
  
      Node(InstanceKlass* cls, void* data, bool visit_super)
          : _class(cls), _super_was_visited(!visit_super),
            _interface_index(0), _algorithm_data(data) {}
  
<span class="udiff-line-added">+     void update(InstanceKlass* cls, void* data, bool visit_super) {</span>
<span class="udiff-line-added">+       _class = cls;</span>
<span class="udiff-line-added">+       _super_was_visited = !visit_super;</span>
<span class="udiff-line-added">+       _interface_index = 0;</span>
<span class="udiff-line-added">+       _algorithm_data = data;</span>
<span class="udiff-line-added">+     }</span>
      int number_of_interfaces() { return _class-&gt;local_interfaces()-&gt;length(); }
      int interface_index() { return _interface_index; }
      void set_super_visited() { _super_was_visited = true; }
      void increment_visited_interface() { ++_interface_index; }
      void set_all_interfaces_visited() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,32 +118,45 @@</span>
      bool has_visited_super() { return _super_was_visited; }
      bool has_visited_all_interfaces() {
        return interface_index() &gt;= number_of_interfaces();
      }
      InstanceKlass* interface_at(int index) {
<span class="udiff-line-modified-removed">-       return InstanceKlass::cast(_class-&gt;local_interfaces()-&gt;at(index));</span>
<span class="udiff-line-modified-added">+       return _class-&gt;local_interfaces()-&gt;at(index);</span>
      }
      InstanceKlass* next_super() { return _class-&gt;java_super(); }
      InstanceKlass* next_interface() {
        return interface_at(interface_index());
      }
    };
  
    bool _visited_Object;
<span class="udiff-line-added">+ </span>
    GrowableArray&lt;Node*&gt; _path;
<span class="udiff-line-added">+   GrowableArray&lt;Node*&gt; _free_nodes;</span>
  
    Node* current_top() const { return _path.top(); }
<span class="udiff-line-modified-removed">-   bool has_more_nodes() const { return !_path.is_empty(); }</span>
<span class="udiff-line-modified-removed">-   void push(InstanceKlass* cls, void* data) {</span>
<span class="udiff-line-modified-added">+   bool has_more_nodes() const { return _path.length() &gt; 0; }</span>
<span class="udiff-line-modified-added">+   void push(InstanceKlass* cls, ALGO* algo) {</span>
      assert(cls != NULL, &quot;Requires a valid instance class&quot;);
<span class="udiff-line-removed">-     Node* node = new Node(cls, data, has_super(cls));</span>
      if (cls == SystemDictionary::Object_klass()) {
        _visited_Object = true;
      }
<span class="udiff-line-added">+     void* data = algo-&gt;new_node_data();</span>
<span class="udiff-line-added">+     Node* node;</span>
<span class="udiff-line-added">+     if (_free_nodes.is_empty()) { // Add a new node</span>
<span class="udiff-line-added">+       node = new Node(cls, data, has_super(cls));</span>
<span class="udiff-line-added">+     } else { // Reuse existing node and data</span>
<span class="udiff-line-added">+       node = _free_nodes.pop();</span>
<span class="udiff-line-added">+       node-&gt;update(cls, data, has_super(cls));</span>
<span class="udiff-line-added">+     }</span>
      _path.push(node);
    }
<span class="udiff-line-modified-removed">-   void pop() { _path.pop(); }</span>
<span class="udiff-line-modified-added">+   void pop() {</span>
<span class="udiff-line-added">+     Node* node = _path.pop();</span>
<span class="udiff-line-added">+     // Make the node available for reuse</span>
<span class="udiff-line-added">+     _free_nodes.push(node);</span>
<span class="udiff-line-added">+   }</span>
  
    // Since the starting point can be an interface, we must ensure we catch
    // j.l.Object as the super once in those cases. The _visited_Object flag
    // only ensures we don&#39;t then repeatedly enqueue Object for each interface
    // in the class hierarchy.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,10 +168,15 @@</span>
      return (i &gt;= _path.length()) ? NULL : _path.at(_path.length() - i - 1);
    }
  
   protected:
  
<span class="udiff-line-added">+   // Resets the visitor</span>
<span class="udiff-line-added">+   void reset() {</span>
<span class="udiff-line-added">+     _visited_Object = false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Accessors available to the algorithm
    int current_depth() const { return _path.length() - 1; }
  
    InstanceKlass* class_at_depth(int i) {
      Node* n = node_at_depth(i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,18 +189,17 @@</span>
      return n == NULL ? NULL : n-&gt;_algorithm_data;
    }
    void* current_data() { return data_at_depth(0); }
  
   public:
<span class="udiff-line-added">+   HierarchyVisitor() : _visited_Object(false), _path() {}</span>
  
    void run(InstanceKlass* root) {
      ALGO* algo = static_cast&lt;ALGO*&gt;(this);
  
<span class="udiff-line-modified-removed">-     void* algo_data = algo-&gt;new_node_data(root);</span>
<span class="udiff-line-removed">-     push(root, algo_data);</span>
<span class="udiff-line-modified-added">+     push(root, algo);</span>
      bool top_needs_visit = true;
<span class="udiff-line-removed">- </span>
      do {
        Node* top = current_top();
        if (top_needs_visit) {
          if (algo-&gt;visit() == false) {
            // algorithm does not want to continue along this path.  Arrange
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,12 +221,11 @@</span>
          } else {
            next = top-&gt;next_interface();
            top-&gt;increment_visited_interface();
          }
          assert(next != NULL, &quot;Otherwise we shouldn&#39;t be here&quot;);
<span class="udiff-line-modified-removed">-         algo_data = algo-&gt;new_node_data(next);</span>
<span class="udiff-line-removed">-         push(next, algo_data);</span>
<span class="udiff-line-modified-added">+         push(next, algo);</span>
          top_needs_visit = true;
        }
      } while (has_more_nodes());
    }
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,11 +239,11 @@</span>
      streamIndentor si(_st, current_depth() * 2);
      _st-&gt;indent().print_cr(&quot;%s&quot;, cls-&gt;name()-&gt;as_C_string());
      return true;
    }
  
<span class="udiff-line-modified-removed">-   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
<span class="udiff-line-modified-added">+   void* new_node_data() { return NULL; }</span>
    void free_node_data(void* data) { return; }
  
    PrintHierarchy(outputStream* st = tty) : _st(st) {}
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -267,11 +258,11 @@</span>
   private:
    Thread* _thread;
    GrowableArray&lt;ConstantPool*&gt; _keep_alive;
  
   public:
<span class="udiff-line-modified-removed">-   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(20) {</span>
<span class="udiff-line-modified-added">+   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(6) {</span>
      assert(thread == Thread::current(), &quot;Must be current thread&quot;);
    }
  
    ~KeepAliveRegistrar() {
      for (int i = _keep_alive.length() - 1; i &gt;= 0; --i) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -296,11 +287,11 @@</span>
    KeepAliveRegistrar* _registrar;
  
   public:
    KeepAliveVisitor(KeepAliveRegistrar* registrar) : _registrar(registrar) {}
  
<span class="udiff-line-modified-removed">-   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
<span class="udiff-line-modified-added">+   void* new_node_data() { return NULL; }</span>
    void free_node_data(void* data) { return; }
  
    bool visit() {
      _registrar-&gt;register_class(current_class());
      return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -313,40 +304,45 @@</span>
  // hierarchy, they are tagged with a qualification state.  The qualification
  // state for an erased method is set to disqualified if there exists a path
  // from the root of hierarchy to the method that contains an interleaving
  // erased method defined in an interface.
  
<span class="udiff-line-added">+ class MethodState {</span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   Method* _method;</span>
<span class="udiff-line-added">+   QualifiedState _state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   MethodState() : _method(NULL), _state(DISQUALIFIED) {}</span>
<span class="udiff-line-added">+   MethodState(Method* method, QualifiedState state) : _method(method), _state(state) {}</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  class MethodFamily : public ResourceObj {
   private:
  
<span class="udiff-line-modified-removed">-   GrowableArray&lt;Pair&lt;Method*,QualifiedState&gt; &gt; _members;</span>
<span class="udiff-line-removed">-   ResourceHashtable&lt;Method*, int&gt; _member_index;</span>
<span class="udiff-line-modified-added">+   GrowableArray&lt;MethodState&gt; _members;</span>
  
    Method* _selected_target;  // Filled in later, if a unique target exists
    Symbol* _exception_message; // If no unique target is found
    Symbol* _exception_name;    // If no unique target is found
  
<span class="udiff-line-modified-removed">-   bool contains_method(Method* method) {</span>
<span class="udiff-line-modified-removed">-     int* lookup = _member_index.get(method);</span>
<span class="udiff-line-modified-removed">-     return lookup != NULL;</span>
<span class="udiff-line-modified-added">+   MethodState* find_method(Method* method) {</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="udiff-line-modified-added">+       if (_members.at(i)._method == method) {</span>
<span class="udiff-line-added">+         return &amp;_members.at(i);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return NULL;</span>
    }
  
    void add_method(Method* method, QualifiedState state) {
<span class="udiff-line-modified-removed">-     Pair&lt;Method*,QualifiedState&gt; entry(method, state);</span>
<span class="udiff-line-modified-removed">-     _member_index.put(method, _members.length());</span>
<span class="udiff-line-removed">-     _members.append(entry);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void disqualify_method(Method* method) {</span>
<span class="udiff-line-removed">-     int* index = _member_index.get(method);</span>
<span class="udiff-line-removed">-     guarantee(index != NULL &amp;&amp; *index &gt;= 0 &amp;&amp; *index &lt; _members.length(), &quot;bad index&quot;);</span>
<span class="udiff-line-removed">-     _members.at(*index).second = DISQUALIFIED;</span>
<span class="udiff-line-modified-added">+     MethodState method_state(method, state);</span>
<span class="udiff-line-modified-added">+     _members.append(method_state);</span>
    }
  
    Symbol* generate_no_defaults_message(TRAPS) const;
    Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;
<span class="udiff-line-modified-removed">-   Symbol* generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const;</span>
<span class="udiff-line-modified-added">+   Symbol* generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const;</span>
  
   public:
  
    MethodFamily()
        : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -355,27 +351,19 @@</span>
      if (_selected_target == NULL &amp;&amp; !m-&gt;is_overpass()) {
        _selected_target = m;
      }
    }
  
<span class="udiff-line-modified-removed">-   void record_qualified_method(Method* m) {</span>
<span class="udiff-line-modified-removed">-     // If the method already exists in the set as qualified, this operation is</span>
<span class="udiff-line-modified-removed">-     // redundant.  If it already exists as disqualified, then we leave it as</span>
<span class="udiff-line-modified-removed">-     // disqualfied.  Thus we only add to the set if it&#39;s not already in the</span>
<span class="udiff-line-modified-removed">-     // set.</span>
<span class="udiff-line-modified-removed">-     if (!contains_method(m)) {</span>
<span class="udiff-line-modified-removed">-       add_method(m, QUALIFIED);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void record_disqualified_method(Method* m) {</span>
<span class="udiff-line-removed">-     // If not in the set, add it as disqualified.  If it&#39;s already in the set,</span>
<span class="udiff-line-removed">-     // then set the state to disqualified no matter what the previous state was.</span>
<span class="udiff-line-removed">-     if (!contains_method(m)) {</span>
<span class="udiff-line-removed">-       add_method(m, DISQUALIFIED);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       disqualify_method(m);</span>
<span class="udiff-line-modified-added">+   void record_method(Method* m, QualifiedState state) {</span>
<span class="udiff-line-modified-added">+     // If not in the set, add it.  If it&#39;s already in the set, then leave it</span>
<span class="udiff-line-modified-added">+     // as is if state is qualified, or set it to disqualified if state is</span>
<span class="udiff-line-modified-added">+     // disqualified.</span>
<span class="udiff-line-modified-added">+     MethodState* method_state = find_method(m);</span>
<span class="udiff-line-modified-added">+     if (method_state == NULL) {</span>
<span class="udiff-line-modified-added">+       add_method(m, state);</span>
<span class="udiff-line-modified-added">+     } else if (state == DISQUALIFIED) {</span>
<span class="udiff-line-modified-added">+       method_state-&gt;_state = DISQUALIFIED;</span>
      }
    }
  
    bool has_target() const { return _selected_target != NULL; }
    bool throws_exception() { return _exception_message != NULL; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -383,34 +371,47 @@</span>
    Method* get_selected_target() { return _selected_target; }
    Symbol* get_exception_message() { return _exception_message; }
    Symbol* get_exception_name() { return _exception_name; }
  
    // Either sets the target or the exception error message
<span class="udiff-line-modified-removed">-   void determine_target(InstanceKlass* root, TRAPS) {</span>
<span class="udiff-line-modified-added">+   void determine_target_or_set_exception_message(InstanceKlass* root, TRAPS) {</span>
      if (has_target() || throws_exception()) {
        return;
      }
  
      // Qualified methods are maximally-specific methods
      // These include public, instance concrete (=default) and abstract methods
<span class="udiff-line-removed">-     GrowableArray&lt;Method*&gt; qualified_methods;</span>
      int num_defaults = 0;
      int default_index = -1;
<span class="udiff-line-modified-removed">-     int qualified_index = -1;</span>
<span class="udiff-line-modified-removed">-     for (int i = 0; i &lt; _members.length(); ++i) {</span>
<span class="udiff-line-modified-removed">-       Pair&lt;Method*,QualifiedState&gt; entry = _members.at(i);</span>
<span class="udiff-line-modified-removed">-       if (entry.second == QUALIFIED) {</span>
<span class="udiff-line-removed">-         qualified_methods.append(entry.first);</span>
<span class="udiff-line-removed">-         qualified_index++;</span>
<span class="udiff-line-removed">-         if (entry.first-&gt;is_default_method()) {</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="udiff-line-modified-added">+       MethodState &amp;member = _members.at(i);</span>
<span class="udiff-line-modified-added">+       if (member._state == QUALIFIED) {</span>
<span class="udiff-line-modified-added">+         if (member._method-&gt;is_default_method()) {</span>
            num_defaults++;
<span class="udiff-line-modified-removed">-           default_index = qualified_index;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+           default_index = i;</span>
          }
        }
      }
  
<span class="udiff-line-added">+     if (num_defaults == 1) {</span>
<span class="udiff-line-added">+       assert(_members.at(default_index)._state == QUALIFIED, &quot;&quot;);</span>
<span class="udiff-line-added">+       _selected_target = _members.at(default_index)._method;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       generate_and_set_exception_message(root, num_defaults, default_index, CHECK);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void generate_and_set_exception_message(InstanceKlass* root, int num_defaults, int default_index, TRAPS) {</span>
<span class="udiff-line-added">+     assert(num_defaults != 1, &quot;invariant - should&#39;ve been handled calling method&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GrowableArray&lt;Method*&gt; qualified_methods;</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="udiff-line-added">+       MethodState&amp; member = _members.at(i);</span>
<span class="udiff-line-added">+       if (member._state == QUALIFIED) {</span>
<span class="udiff-line-added">+         qualified_methods.push(member._method);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      if (num_defaults == 0) {
        // If the root klass has a static method with matching name and signature
        // then do not generate an overpass method because it will hide the
        // static method during resolution.
        if (qualified_methods.length() == 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,17 +419,12 @@</span>
        } else {
          assert(root != NULL, &quot;Null root class&quot;);
          _exception_message = generate_method_message(root-&gt;name(), qualified_methods.at(0), CHECK);
        }
        _exception_name = vmSymbols::java_lang_AbstractMethodError();
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // If only one qualified method is default, select that</span>
<span class="udiff-line-removed">-     } else if (num_defaults == 1) {</span>
<span class="udiff-line-removed">-         _selected_target = qualified_methods.at(default_index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     } else if (num_defaults &gt; 1) {</span>
<span class="udiff-line-removed">-       _exception_message = generate_conflicts_message(&amp;qualified_methods,CHECK);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       _exception_message = generate_conflicts_message(&amp;_members,CHECK);</span>
        _exception_name = vmSymbols::java_lang_IncompatibleClassChangeError();
        LogTarget(Debug, defaultmethods) lt;
        if (lt.is_enabled()) {
          LogStream ls(lt);
          _exception_message-&gt;print_value_on(&amp;ls);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,11 +452,11 @@</span>
      str-&gt;indent().print_cr(&quot;%s: %s&quot;, _exception_name-&gt;as_C_string(), _exception_message-&gt;as_C_string());
    }
  };
  
  Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {
<span class="udiff-line-modified-removed">-   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;, THREAD);</span>
<span class="udiff-line-modified-added">+   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;);</span>
  }
  
  Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {
    stringStream ss;
    ss.print(&quot;Method &quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,30 +465,30 @@</span>
    ss.write((const char*)klass_name-&gt;bytes(), klass_name-&gt;utf8_length());
    ss.print(&quot;.&quot;);
    ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());
    ss.write((const char*)signature-&gt;bytes(), signature-&gt;utf8_length());
    ss.print(&quot; is abstract&quot;);
<span class="udiff-line-modified-removed">-   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
<span class="udiff-line-modified-added">+   return SymbolTable::new_symbol(ss.base(), (int)ss.size());</span>
  }
  
<span class="udiff-line-modified-removed">- Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const {</span>
<span class="udiff-line-modified-added">+ Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const {</span>
    stringStream ss;
    ss.print(&quot;Conflicting default methods:&quot;);
    for (int i = 0; i &lt; methods-&gt;length(); ++i) {
<span class="udiff-line-modified-removed">-     Method* method = methods-&gt;at(i);</span>
<span class="udiff-line-modified-removed">-     Symbol* klass = method-&gt;klass_name();</span>
<span class="udiff-line-modified-removed">-     Symbol* name = method-&gt;name();</span>
<span class="udiff-line-modified-added">+     Method *method = methods-&gt;at(i)._method;</span>
<span class="udiff-line-modified-added">+     Symbol *klass = method-&gt;klass_name();</span>
<span class="udiff-line-modified-added">+     Symbol *name = method-&gt;name();</span>
      ss.print(&quot; &quot;);
<span class="udiff-line-modified-removed">-     ss.write((const char*)klass-&gt;bytes(), klass-&gt;utf8_length());</span>
<span class="udiff-line-modified-added">+     ss.write((const char*) klass-&gt;bytes(), klass-&gt;utf8_length());</span>
      ss.print(&quot;.&quot;);
<span class="udiff-line-modified-removed">-     ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());</span>
<span class="udiff-line-modified-added">+     ss.write((const char*) name-&gt;bytes(), name-&gt;utf8_length());</span>
    }
<span class="udiff-line-modified-removed">-   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
<span class="udiff-line-modified-added">+   return SymbolTable::new_symbol(ss.base(), (int)ss.size());</span>
  }
  
  
<span class="udiff-line-modified-removed">- class StateRestorer;</span>
<span class="udiff-line-modified-added">+ class StateRestorerScope;</span>
  
  // StatefulMethodFamily is a wrapper around a MethodFamily that maintains the
  // qualification state during hierarchy visitation, and applies that state
  // when adding members to the MethodFamily
  class StatefulMethodFamily : public ResourceObj {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -514,36 +510,76 @@</span>
  
    void set_target_if_empty(Method* m) { _method_family.set_target_if_empty(m); }
  
    MethodFamily* get_method_family() { return &amp;_method_family; }
  
<span class="udiff-line-modified-removed">-   StateRestorer* record_method_and_dq_further(Method* mo);</span>
<span class="udiff-line-modified-added">+   void record_method_and_dq_further(StateRestorerScope* scope, Method* mo);</span>
  };
  
<span class="udiff-line-modified-removed">- class StateRestorer : public PseudoScopeMark {</span>
<span class="udiff-line-modified-removed">-  private:</span>
<span class="udiff-line-modified-added">+ // Because we use an iterative algorithm when iterating over the type</span>
<span class="udiff-line-modified-added">+ // hierarchy, we can&#39;t use traditional scoped objects which automatically do</span>
<span class="udiff-line-added">+ // cleanup in the destructor when the scope is exited.  StateRestorerScope (and</span>
<span class="udiff-line-added">+ // StateRestorer) provides a similar functionality, but for when you want a</span>
<span class="udiff-line-added">+ // scoped object in non-stack memory (such as in resource memory, as we do</span>
<span class="udiff-line-added">+ // here).  You&#39;ve just got to remember to call &#39;restore_state()&#39; on the scope when</span>
<span class="udiff-line-added">+ // leaving it (and marks have to be explicitly added). The scope is reusable after</span>
<span class="udiff-line-added">+ // &#39;restore_state()&#39; has been called.</span>
<span class="udiff-line-added">+ class StateRestorer : public ResourceObj {</span>
<span class="udiff-line-added">+  public:</span>
    StatefulMethodFamily* _method;
    QualifiedState _state_to_restore;
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   StateRestorer(StatefulMethodFamily* dm, QualifiedState state)</span>
<span class="udiff-line-modified-removed">-       : _method(dm), _state_to_restore(state) {}</span>
<span class="udiff-line-removed">-   ~StateRestorer() { destroy(); }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   StateRestorer() : _method(NULL), _state_to_restore(DISQUALIFIED) {}</span>
<span class="udiff-line-modified-added">+ </span>
    void restore_state() { _method-&gt;set_qualification_state(_state_to_restore); }
<span class="udiff-line-removed">-   virtual void destroy() { restore_state(); }</span>
  };
  
<span class="udiff-line-modified-removed">- StateRestorer* StatefulMethodFamily::record_method_and_dq_further(Method* mo) {</span>
<span class="udiff-line-modified-removed">-   StateRestorer* mark = new StateRestorer(this, _qualification_state);</span>
<span class="udiff-line-modified-removed">-   if (_qualification_state == QUALIFIED) {</span>
<span class="udiff-line-modified-removed">-     _method_family.record_qualified_method(mo);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     _method_family.record_disqualified_method(mo);</span>
<span class="udiff-line-modified-added">+ class StateRestorerScope : public ResourceObj {</span>
<span class="udiff-line-modified-added">+  private:</span>
<span class="udiff-line-modified-added">+   GrowableArray&lt;StateRestorer*&gt;  _marks;</span>
<span class="udiff-line-modified-added">+   GrowableArray&lt;StateRestorer*&gt;* _free_list; // Shared between scopes</span>
<span class="udiff-line-modified-added">+  public:</span>
<span class="udiff-line-modified-added">+   StateRestorerScope(GrowableArray&lt;StateRestorer*&gt;* free_list) : _marks(), _free_list(free_list) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static StateRestorerScope* cast(void* data) {</span>
<span class="udiff-line-added">+     return static_cast&lt;StateRestorerScope*&gt;(data);</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void mark(StatefulMethodFamily* family, QualifiedState qualification_state) {</span>
<span class="udiff-line-added">+     StateRestorer* restorer;</span>
<span class="udiff-line-added">+     if (!_free_list-&gt;is_empty()) {</span>
<span class="udiff-line-added">+       restorer = _free_list-&gt;pop();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       restorer = new StateRestorer();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     restorer-&gt;_method = family;</span>
<span class="udiff-line-added">+     restorer-&gt;_state_to_restore = qualification_state;</span>
<span class="udiff-line-added">+     _marks.append(restorer);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   bool is_empty() {</span>
<span class="udiff-line-added">+     return _marks.is_empty();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void restore_state() {</span>
<span class="udiff-line-added">+     while(!_marks.is_empty()) {</span>
<span class="udiff-line-added">+       StateRestorer* restorer = _marks.pop();</span>
<span class="udiff-line-added">+       restorer-&gt;restore_state();</span>
<span class="udiff-line-added">+       _free_list-&gt;push(restorer);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void StatefulMethodFamily::record_method_and_dq_further(StateRestorerScope* scope, Method* mo) {</span>
<span class="udiff-line-added">+   scope-&gt;mark(this, _qualification_state);</span>
<span class="udiff-line-added">+   _method_family.record_method(mo, _qualification_state);</span>
<span class="udiff-line-added">+ </span>
    // Everything found &quot;above&quot;??? this method in the hierarchy walk is set to
    // disqualified
    set_qualification_state(DISQUALIFIED);
<span class="udiff-line-removed">-   return mark;</span>
  }
  
  // Represents a location corresponding to a vtable slot for methods that
  // neither the class nor any of it&#39;s ancestors provide an implementaion.
  // Default methods may be present to fill this slot.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -657,33 +693,51 @@</span>
    // Context data
    Symbol* _method_name;
    Symbol* _method_signature;
    StatefulMethodFamily*  _family;
    bool _cur_class_is_interface;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   // Free lists, used as an optimization</span>
<span class="udiff-line-added">+   GrowableArray&lt;StateRestorerScope*&gt; _free_scopes;</span>
<span class="udiff-line-added">+   GrowableArray&lt;StateRestorer*&gt; _free_restorers;</span>
   public:
<span class="udiff-line-modified-removed">-   FindMethodsByErasedSig(Symbol* name, Symbol* signature, bool is_interf) :</span>
<span class="udiff-line-modified-removed">-       _method_name(name), _method_signature(signature), _family(NULL),</span>
<span class="udiff-line-modified-removed">-       _cur_class_is_interface(is_interf) {}</span>
<span class="udiff-line-modified-added">+   FindMethodsByErasedSig() : _free_scopes(6), _free_restorers(6) {};</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   void prepare(Symbol* name, Symbol* signature, bool is_interf) {</span>
<span class="udiff-line-added">+     reset();</span>
<span class="udiff-line-added">+     _method_name = name;</span>
<span class="udiff-line-added">+     _method_signature = signature;</span>
<span class="udiff-line-added">+     _family = NULL;</span>
<span class="udiff-line-added">+     _cur_class_is_interface = is_interf;</span>
<span class="udiff-line-added">+   }</span>
  
    void get_discovered_family(MethodFamily** family) {
        if (_family != NULL) {
          *family = _family-&gt;get_method_family();
        } else {
          *family = NULL;
        }
    }
  
<span class="udiff-line-modified-removed">-   void* new_node_data(InstanceKlass* cls) { return new PseudoScope(); }</span>
<span class="udiff-line-modified-added">+   void* new_node_data() {</span>
<span class="udiff-line-added">+     if (!_free_scopes.is_empty()) {</span>
<span class="udiff-line-added">+       StateRestorerScope* free_scope = _free_scopes.pop();</span>
<span class="udiff-line-added">+       assert(free_scope-&gt;is_empty(), &quot;StateRestorerScope::_marks array not empty&quot;);</span>
<span class="udiff-line-added">+       return free_scope;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return new StateRestorerScope(&amp;_free_restorers);</span>
<span class="udiff-line-added">+   }</span>
    void free_node_data(void* node_data) {
<span class="udiff-line-modified-removed">-     PseudoScope::cast(node_data)-&gt;destroy();</span>
<span class="udiff-line-modified-added">+     StateRestorerScope* scope =  StateRestorerScope::cast(node_data);</span>
<span class="udiff-line-added">+     scope-&gt;restore_state();</span>
<span class="udiff-line-added">+     // Reuse scopes</span>
<span class="udiff-line-added">+     _free_scopes.push(scope);</span>
    }
  
    // Find all methods on this hierarchy that match this
    // method&#39;s erased (name, signature)
    bool visit() {
<span class="udiff-line-modified-removed">-     PseudoScope* scope = PseudoScope::cast(current_data());</span>
<span class="udiff-line-modified-added">+     StateRestorerScope* scope = StateRestorerScope::cast(current_data());</span>
      InstanceKlass* iklass = current_class();
  
      Method* m = iklass-&gt;find_method(_method_name, _method_signature);
      // Private interface methods are not candidates for default methods.
      // invokespecial to private interface methods doesn&#39;t use default method logic.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -699,12 +753,11 @@</span>
        if (_family == NULL) {
          _family = new StatefulMethodFamily();
        }
  
        if (iklass-&gt;is_interface()) {
<span class="udiff-line-modified-removed">-         StateRestorer* restorer = _family-&gt;record_method_and_dq_further(m);</span>
<span class="udiff-line-removed">-         scope-&gt;add_mark(restorer);</span>
<span class="udiff-line-modified-added">+         _family-&gt;record_method_and_dq_further(scope, m);</span>
        } else {
          // This is the rule that methods in classes &quot;win&quot; (bad word) over
          // methods in interfaces. This works because of single inheritance.
          // Private methods in classes do not &quot;win&quot;, they will be found
          // first on searching, but overriding for invokevirtual needs
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,20 +774,24 @@</span>
  
  static void create_defaults_and_exceptions(
      GrowableArray&lt;EmptyVtableSlot*&gt;* slots, InstanceKlass* klass, TRAPS);
  
  static void generate_erased_defaults(
<span class="udiff-line-modified-removed">-      InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {</span>
<span class="udiff-line-modified-added">+     FindMethodsByErasedSig* visitor,</span>
<span class="udiff-line-added">+     InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {</span>
  
<span class="udiff-line-added">+   // the visitor needs to be initialized or re-initialized before use</span>
<span class="udiff-line-added">+   // - this facilitates reusing the same visitor instance on multiple</span>
<span class="udiff-line-added">+   // generation passes as an optimization</span>
<span class="udiff-line-added">+   visitor-&gt;prepare(slot-&gt;name(), slot-&gt;signature(), is_intf);</span>
    // sets up a set of methods with the same exact erased signature
<span class="udiff-line-modified-removed">-   FindMethodsByErasedSig visitor(slot-&gt;name(), slot-&gt;signature(), is_intf);</span>
<span class="udiff-line-removed">-   visitor.run(klass);</span>
<span class="udiff-line-modified-added">+   visitor-&gt;run(klass);</span>
  
    MethodFamily* family;
<span class="udiff-line-modified-removed">-   visitor.get_discovered_family(&amp;family);</span>
<span class="udiff-line-modified-added">+   visitor-&gt;get_discovered_family(&amp;family);</span>
    if (family != NULL) {
<span class="udiff-line-modified-removed">-     family-&gt;determine_target(klass, CHECK);</span>
<span class="udiff-line-modified-added">+     family-&gt;determine_target_or_set_exception_message(klass, CHECK);</span>
      slot-&gt;bind_family(family);
    }
  }
  
  static void merge_in_new_methods(InstanceKlass* klass,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -785,21 +842,22 @@</span>
  
    GrowableArray&lt;EmptyVtableSlot*&gt; empty_slots;
    find_empty_vtable_slots(&amp;empty_slots, klass, mirandas, CHECK);
  
    if (empty_slots.length() &gt; 0) {
<span class="udiff-line-added">+     FindMethodsByErasedSig findMethodsByErasedSig;</span>
      for (int i = 0; i &lt; empty_slots.length(); ++i) {
        EmptyVtableSlot* slot = empty_slots.at(i);
        LogTarget(Debug, defaultmethods) lt;
        if (lt.is_enabled()) {
          LogStream ls(lt);
          streamIndentor si(&amp;ls, 2);
          ls.indent().print(&quot;Looking for default methods for slot &quot;);
          slot-&gt;print_on(&amp;ls);
          ls.cr();
        }
<span class="udiff-line-modified-removed">-       generate_erased_defaults(klass, slot, klass-&gt;is_interface(), CHECK);</span>
<span class="udiff-line-modified-added">+       generate_erased_defaults(&amp;findMethodsByErasedSig, klass, slot, klass-&gt;is_interface(), CHECK);</span>
      }
      log_debug(defaultmethods)(&quot;Creating defaults and overpasses...&quot;);
      create_defaults_and_exceptions(&amp;empty_slots, klass, CHECK);
    }
    log_debug(defaultmethods)(&quot;Default method processing complete&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -841,12 +899,11 @@</span>
                                 mt, CHECK_NULL);
  
    m-&gt;set_constants(NULL); // This will get filled in later
    m-&gt;set_name_index(cp-&gt;utf8(name));
    m-&gt;set_signature_index(cp-&gt;utf8(sig));
<span class="udiff-line-modified-removed">-   ResultTypeFinder rtf(sig);</span>
<span class="udiff-line-removed">-   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
<span class="udiff-line-modified-added">+   m-&gt;compute_from_signature(sig);</span>
    m-&gt;set_size_of_parameters(params);
    m-&gt;set_max_stack(max_stack);
    m-&gt;set_max_locals(params);
    m-&gt;constMethod()-&gt;set_stackmap_data(NULL);
    m-&gt;set_code(code_start);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,16 +952,16 @@</span>
  
    GrowableArray&lt;Method*&gt; overpasses;
    GrowableArray&lt;Method*&gt; defaults;
    BytecodeConstantPool bpool(klass-&gt;constants());
  
<span class="udiff-line-added">+   BytecodeBuffer* buffer = NULL; // Lazily create a reusable buffer</span>
    for (int i = 0; i &lt; slots-&gt;length(); ++i) {
      EmptyVtableSlot* slot = slots-&gt;at(i);
  
      if (slot-&gt;is_bound()) {
        MethodFamily* method = slot-&gt;get_binding();
<span class="udiff-line-removed">-       BytecodeBuffer buffer;</span>
  
        LogTarget(Debug, defaultmethods) lt;
        if (lt.is_enabled()) {
          ResourceMark rm(THREAD);
          LogStream ls(lt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -923,15 +980,20 @@</span>
          if (selected-&gt;method_holder()-&gt;is_interface()) {
            assert(!selected-&gt;is_private(), &quot;pushing private interface method as default&quot;);
            defaults.push(selected);
          }
        } else if (method-&gt;throws_exception()) {
<span class="udiff-line-modified-removed">-         int max_stack = assemble_method_error(&amp;bpool, &amp;buffer,</span>
<span class="udiff-line-modified-added">+         if (buffer == NULL) {</span>
<span class="udiff-line-added">+           buffer = new BytecodeBuffer();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           buffer-&gt;clear();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int max_stack = assemble_method_error(&amp;bpool, buffer,</span>
             method-&gt;get_exception_name(), method-&gt;get_exception_message(), CHECK);
          AccessFlags flags = accessFlags_from(
            JVM_ACC_PUBLIC | JVM_ACC_SYNTHETIC | JVM_ACC_BRIDGE);
<span class="udiff-line-modified-removed">-          Method* m = new_method(&amp;bpool, &amp;buffer, slot-&gt;name(), slot-&gt;signature(),</span>
<span class="udiff-line-modified-added">+         Method* m = new_method(&amp;bpool, buffer, slot-&gt;name(), slot-&gt;signature(),</span>
            flags, max_stack, slot-&gt;size_of_parameters(),
            ConstMethod::OVERPASS, CHECK);
          // We push to the methods list:
          // overpass methods which are exception throwing methods
          if (m != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1009,11 +1071,11 @@</span>
  
    Array&lt;Method*&gt;* merged_methods = MetadataFactory::new_array&lt;Method*&gt;(
        klass-&gt;class_loader_data(), new_size, NULL, CHECK);
  
    // original_ordering might be empty if this class has no methods of its own
<span class="udiff-line-modified-removed">-   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
<span class="udiff-line-modified-added">+   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
      merged_ordering = MetadataFactory::new_array&lt;int&gt;(
          klass-&gt;class_loader_data(), new_size, CHECK);
    }
    int method_order_index = klass-&gt;methods()-&gt;length();
  
</pre>
<center><a href="compactHashtable.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
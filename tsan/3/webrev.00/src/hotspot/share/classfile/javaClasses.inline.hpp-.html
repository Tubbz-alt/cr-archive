<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/javaClasses.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 26 #define SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;oops/oopsHierarchy.hpp&quot;
 32 
 33 void java_lang_String::set_coder(oop string, jbyte coder) {
 34   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 35   string-&gt;byte_field_put(coder_offset, coder);
 36 }
 37 
 38 void java_lang_String::set_value_raw(oop string, typeArrayOop buffer) {
 39   assert(initialized, &quot;Must be initialized&quot;);
 40   string-&gt;obj_field_put_raw(value_offset, buffer);
 41 }
 42 
 43 void java_lang_String::set_value(oop string, typeArrayOop buffer) {
 44   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 45   string-&gt;obj_field_put(value_offset, (oop)buffer);
 46 }
 47 
 48 void java_lang_String::set_hash(oop string, unsigned int hash) {
 49   assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 50   string-&gt;int_field_put(hash_offset, hash);
 51 }
 52 
 53 // Accessors
 54 bool java_lang_String::value_equals(typeArrayOop str_value1, typeArrayOop str_value2) {
 55   return (oopDesc::equals(str_value1, str_value2) ||
 56           (str_value1-&gt;length() == str_value2-&gt;length() &amp;&amp;
 57            (!memcmp(str_value1-&gt;base(T_BYTE),
 58                     str_value2-&gt;base(T_BYTE),
 59                     str_value2-&gt;length() * sizeof(jbyte)))));
 60 }
 61 
 62 typeArrayOop java_lang_String::value(oop java_string) {
 63   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 64   assert(is_instance(java_string), &quot;must be java_string&quot;);
 65   return (typeArrayOop) java_string-&gt;obj_field(value_offset);
 66 }
 67 
 68 typeArrayOop java_lang_String::value_no_keepalive(oop java_string) {
 69   assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 70   assert(is_instance(java_string), &quot;must be java_string&quot;);
 71   return (typeArrayOop) java_string-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(value_offset);
 72 }
 73 
 74 unsigned int java_lang_String::hash(oop java_string) {
 75   assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 76   assert(is_instance(java_string), &quot;must be java_string&quot;);
 77   return java_string-&gt;int_field(hash_offset);
 78 }
 79 
 80 bool java_lang_String::is_latin1(oop java_string) {
 81   assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 82   assert(is_instance(java_string), &quot;must be java_string&quot;);
 83   jbyte coder = java_string-&gt;byte_field(coder_offset);
 84   assert(CompactStrings || coder == CODER_UTF16, &quot;Must be UTF16 without CompactStrings&quot;);
 85   return coder == CODER_LATIN1;
 86 }
 87 
 88 int java_lang_String::length(oop java_string, typeArrayOop value) {
 89   assert(initialized, &quot;Must be initialized&quot;);
 90   assert(is_instance(java_string), &quot;must be java_string&quot;);
 91   assert(value_equals(value, java_lang_String::value(java_string)),
 92          &quot;value must be equal to java_lang_String::value(java_string)&quot;);
 93   if (value == NULL) {
 94     return 0;
 95   }
 96   int arr_length = value-&gt;length();
 97   if (!is_latin1(java_string)) {
 98     assert((arr_length &amp; 1) == 0, &quot;should be even for UTF16 string&quot;);
 99     arr_length &gt;&gt;= 1; // convert number of bytes to number of elements
100   }
101   return arr_length;
102 }
103 
104 int java_lang_String::length(oop java_string) {
105   assert(initialized, &quot;Must be initialized&quot;);
106   assert(is_instance(java_string), &quot;must be java_string&quot;);
107   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
108   return length(java_string, value);
109 }
110 
111 bool java_lang_String::is_instance_inlined(oop obj) {
112   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::String_klass();
113 }
114 
115 // Accessors
116 oop java_lang_ref_Reference::referent(oop ref) {
117   return ref-&gt;obj_field(referent_offset);
118 }
119 
120 void java_lang_ref_Reference::set_referent(oop ref, oop value) {
121   ref-&gt;obj_field_put(referent_offset, value);
122 }
123 
124 void java_lang_ref_Reference::set_referent_raw(oop ref, oop value) {
125   ref-&gt;obj_field_put_raw(referent_offset, value);
126 }
127 
128 HeapWord* java_lang_ref_Reference::referent_addr_raw(oop ref) {
129   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(referent_offset);
130 }
131 
132 oop java_lang_ref_Reference::next(oop ref) {
133   return ref-&gt;obj_field(next_offset);
134 }
135 
136 void java_lang_ref_Reference::set_next(oop ref, oop value) {
137   ref-&gt;obj_field_put(next_offset, value);
138 }
139 
140 void java_lang_ref_Reference::set_next_raw(oop ref, oop value) {
141   ref-&gt;obj_field_put_raw(next_offset, value);
142 }
143 
144 HeapWord* java_lang_ref_Reference::next_addr_raw(oop ref) {
145   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(next_offset);
146 }
147 
148 oop java_lang_ref_Reference::discovered(oop ref) {
149   return ref-&gt;obj_field(discovered_offset);
150 }
151 
152 void java_lang_ref_Reference::set_discovered(oop ref, oop value) {
153   ref-&gt;obj_field_put(discovered_offset, value);
154 }
155 
156 void java_lang_ref_Reference::set_discovered_raw(oop ref, oop value) {
157   ref-&gt;obj_field_put_raw(discovered_offset, value);
158 }
159 
160 HeapWord* java_lang_ref_Reference::discovered_addr_raw(oop ref) {
161   return ref-&gt;obj_field_addr_raw&lt;HeapWord&gt;(discovered_offset);
162 }
163 
164 bool java_lang_ref_Reference::is_final(oop ref) {
165   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_FINAL;
166 }
167 
168 bool java_lang_ref_Reference::is_phantom(oop ref) {
169   return InstanceKlass::cast(ref-&gt;klass())-&gt;reference_type() == REF_PHANTOM;
170 }
171 
172 inline void java_lang_invoke_CallSite::set_target_volatile(oop site, oop target) {
173   site-&gt;obj_field_put_volatile(_target_offset, target);
174 }
175 
176 inline oop  java_lang_invoke_CallSite::target(oop site) {
177   return site-&gt;obj_field(_target_offset);
178 }
179 
180 inline void java_lang_invoke_CallSite::set_target(oop site, oop target) {
181   site-&gt;obj_field_put(_target_offset, target);
182 }
183 
184 inline bool java_lang_invoke_CallSite::is_instance(oop obj) {
185   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
186 }
187 
188 inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {
189   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
190 }
191 
192 inline bool java_lang_invoke_MemberName::is_instance(oop obj) {
193   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MemberName_klass();
194 }
195 
196 inline bool java_lang_invoke_ResolvedMethodName::is_instance(oop obj) {
197   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::ResolvedMethodName_klass();
198 }
199 
200 inline bool java_lang_invoke_MethodType::is_instance(oop obj) {
201   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::MethodType_klass();
202 }
203 
204 inline bool java_lang_invoke_MethodHandle::is_instance(oop obj) {
205   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
206 }
207 
208 inline bool java_lang_Class::is_instance(oop obj) {
209   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Class_klass();
210 }
211 
212 inline bool java_lang_Class::is_primitive(oop java_class) {
213   // should assert:
214   //assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
215   bool is_primitive = (java_class-&gt;metadata_field(_klass_offset) == NULL);
216 
217 #ifdef ASSERT
218   if (is_primitive) {
219     Klass* k = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
220     assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)-&gt;element_type()),
221         &quot;Should be either the T_VOID primitive or a java primitive&quot;);
222   }
223 #endif
224 
225   return is_primitive;
226 }
227 
228 inline int java_lang_Class::oop_size_raw(oop java_class) {
229   assert(_oop_size_offset != 0, &quot;must be set&quot;);
230   int size = java_class-&gt;int_field_raw(_oop_size_offset);
231   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
232   return size;
233 }
234 
235 inline bool java_lang_invoke_DirectMethodHandle::is_instance(oop obj) {
236   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
237 }
238 
239 inline bool java_lang_Module::is_instance(oop obj) {
240   return obj != NULL &amp;&amp; obj-&gt;klass() == SystemDictionary::Module_klass();
241 }
242 
243 inline int Backtrace::merge_bci_and_version(int bci, int version) {
244   // only store u2 for version, checking for overflow.
245   if (version &gt; USHRT_MAX || version &lt; 0) version = USHRT_MAX;
246   assert((jushort)bci == bci, &quot;bci should be short&quot;);
247   return build_int_from_shorts(version, bci);
248 }
249 
250 inline int Backtrace::merge_mid_and_cpref(int mid, int cpref) {
251   // only store u2 for mid and cpref, checking for overflow.
252   assert((jushort)mid == mid, &quot;mid should be short&quot;);
253   assert((jushort)cpref == cpref, &quot;cpref should be short&quot;);
254   return build_int_from_shorts(cpref, mid);
255 }
256 
257 inline int Backtrace::bci_at(unsigned int merged) {
258   return extract_high_short_from_int(merged);
259 }
260 
261 inline int Backtrace::version_at(unsigned int merged) {
262   return extract_low_short_from_int(merged);
263 }
264 
265 inline int Backtrace::mid_at(unsigned int merged) {
266   return extract_high_short_from_int(merged);
267 }
268 
269 inline int Backtrace::cpref_at(unsigned int merged) {
270   return extract_low_short_from_int(merged);
271 }
272 
273 inline int Backtrace::get_line_number(const methodHandle&amp; method, int bci) {
274   int line_number = 0;
275   if (method-&gt;is_native()) {
276     // Negative value different from -1 below, enabling Java code in
277     // class java.lang.StackTraceElement to distinguish &quot;native&quot; from
278     // &quot;no LineNumberTable&quot;.  JDK tests for -2.
279     line_number = -2;
280   } else {
281     // Returns -1 if no LineNumberTable, and otherwise actual line number
282     line_number = method-&gt;line_number_from_bci(bci);
283     if (line_number == -1 &amp;&amp; ShowHiddenFrames) {
284       line_number = bci + 1000000;
285     }
286   }
287   return line_number;
288 }
289 
290 inline Symbol* Backtrace::get_source_file_name(InstanceKlass* holder, int version) {
291   // RedefineClasses() currently permits redefine operations to
292   // happen in parallel using a &quot;last one wins&quot; philosophy. That
293   // spec laxness allows the constant pool entry associated with
294   // the source_file_name_index for any older constant pool version
295   // to be unstable so we shouldn&#39;t try to use it.
296   if (holder-&gt;constants()-&gt;version() != version) {
297     return NULL;
298   } else {
299     return holder-&gt;source_file_name();
300   }
301 }
302 
303 #endif // SHARE_CLASSFILE_JAVACLASSES_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/defaultMethods.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compactHashtable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/defaultMethods.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/bytecodeAssembler.hpp&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logStream.hpp&quot;
  32 #include &quot;memory/allocation.hpp&quot;
  33 #include &quot;memory/metadataFactory.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;

  35 #include &quot;runtime/handles.inline.hpp&quot;
  36 #include &quot;runtime/signature.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;oops/instanceKlass.hpp&quot;
  39 #include &quot;oops/klass.hpp&quot;
  40 #include &quot;oops/method.hpp&quot;
  41 #include &quot;utilities/accessFlags.hpp&quot;
  42 #include &quot;utilities/exceptions.hpp&quot;
  43 #include &quot;utilities/ostream.hpp&quot;
  44 #include &quot;utilities/pair.hpp&quot;
  45 #include &quot;utilities/resourceHash.hpp&quot;
  46 
  47 typedef enum { QUALIFIED, DISQUALIFIED } QualifiedState;
  48 
<span class="line-removed">  49 // Because we use an iterative algorithm when iterating over the type</span>
<span class="line-removed">  50 // hierarchy, we can&#39;t use traditional scoped objects which automatically do</span>
<span class="line-removed">  51 // cleanup in the destructor when the scope is exited.  PseudoScope (and</span>
<span class="line-removed">  52 // PseudoScopeMark) provides a similar functionality, but for when you want a</span>
<span class="line-removed">  53 // scoped object in non-stack memory (such as in resource memory, as we do</span>
<span class="line-removed">  54 // here).  You&#39;ve just got to remember to call &#39;destroy()&#39; on the scope when</span>
<span class="line-removed">  55 // leaving it (and marks have to be explicitly added).</span>
<span class="line-removed">  56 class PseudoScopeMark : public ResourceObj {</span>
<span class="line-removed">  57  public:</span>
<span class="line-removed">  58   virtual void destroy() = 0;</span>
<span class="line-removed">  59 };</span>
<span class="line-removed">  60 </span>
<span class="line-removed">  61 class PseudoScope : public ResourceObj {</span>
<span class="line-removed">  62  private:</span>
<span class="line-removed">  63   GrowableArray&lt;PseudoScopeMark*&gt; _marks;</span>
<span class="line-removed">  64  public:</span>
<span class="line-removed">  65 </span>
<span class="line-removed">  66   static PseudoScope* cast(void* data) {</span>
<span class="line-removed">  67     return static_cast&lt;PseudoScope*&gt;(data);</span>
<span class="line-removed">  68   }</span>
<span class="line-removed">  69 </span>
<span class="line-removed">  70   void add_mark(PseudoScopeMark* psm) {</span>
<span class="line-removed">  71    _marks.append(psm);</span>
<span class="line-removed">  72   }</span>
<span class="line-removed">  73 </span>
<span class="line-removed">  74   void destroy() {</span>
<span class="line-removed">  75     for (int i = 0; i &lt; _marks.length(); ++i) {</span>
<span class="line-removed">  76       _marks.at(i)-&gt;destroy();</span>
<span class="line-removed">  77     }</span>
<span class="line-removed">  78   }</span>
<span class="line-removed">  79 };</span>
<span class="line-removed">  80 </span>
  81 static void print_slot(outputStream* str, Symbol* name, Symbol* signature) {
  82   str-&gt;print(&quot;%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
  83 }
  84 
  85 static void print_method(outputStream* str, Method* mo, bool with_class=true) {
  86   if (with_class) {
  87     str-&gt;print(&quot;%s.&quot;, mo-&gt;klass_name()-&gt;as_C_string());
  88   }
  89   print_slot(str, mo-&gt;name(), mo-&gt;signature());
  90 }
  91 
  92 /**
  93  * Perform a depth-first iteration over the class hierarchy, applying
  94  * algorithmic logic as it goes.
  95  *
  96  * This class is one half of the inheritance hierarchy analysis mechanism.
  97  * It is meant to be used in conjunction with another class, the algorithm,
  98  * which is indicated by the ALGO template parameter.  This class can be
  99  * paired with any algorithm class that provides the required methods.
 100  *
 101  * This class contains all the mechanics for iterating over the class hierarchy
 102  * starting at a particular root, without recursing (thus limiting stack growth
 103  * from this point).  It visits each superclass (if present) and superinterface
 104  * in a depth-first manner, with callbacks to the ALGO class as each class is
 105  * encountered (visit()), The algorithm can cut-off further exploration of a
 106  * particular branch by returning &#39;false&#39; from a visit() call.
 107  *
 108  * The ALGO class, must provide a visit() method, which each of which will be
 109  * called once for each node in the inheritance tree during the iteration.  In
<span class="line-modified"> 110  * addition, it can provide a memory block via new_node_data(InstanceKlass*),</span>
<span class="line-modified"> 111  * which it can use for node-specific storage (and access via the</span>
<span class="line-modified"> 112  * current_data() and data_at_depth(int) methods).</span>
 113  *
 114  * Bare minimum needed to be an ALGO class:
 115  * class Algo : public HierarchyVisitor&lt;Algo&gt; {
<span class="line-modified"> 116  *   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 117  *   void free_node_data(void* data) { return; }
 118  *   bool visit() { return true; }
 119  * };
 120  */
 121 template &lt;class ALGO&gt;
 122 class HierarchyVisitor : StackObj {
 123  private:
 124 
 125   class Node : public ResourceObj {
 126    public:
 127     InstanceKlass* _class;
 128     bool _super_was_visited;
 129     int _interface_index;
 130     void* _algorithm_data;
 131 
 132     Node(InstanceKlass* cls, void* data, bool visit_super)
 133         : _class(cls), _super_was_visited(!visit_super),
 134           _interface_index(0), _algorithm_data(data) {}
 135 






 136     int number_of_interfaces() { return _class-&gt;local_interfaces()-&gt;length(); }
 137     int interface_index() { return _interface_index; }
 138     void set_super_visited() { _super_was_visited = true; }
 139     void increment_visited_interface() { ++_interface_index; }
 140     void set_all_interfaces_visited() {
 141       _interface_index = number_of_interfaces();
 142     }
 143     bool has_visited_super() { return _super_was_visited; }
 144     bool has_visited_all_interfaces() {
 145       return interface_index() &gt;= number_of_interfaces();
 146     }
 147     InstanceKlass* interface_at(int index) {
<span class="line-modified"> 148       return InstanceKlass::cast(_class-&gt;local_interfaces()-&gt;at(index));</span>
 149     }
 150     InstanceKlass* next_super() { return _class-&gt;java_super(); }
 151     InstanceKlass* next_interface() {
 152       return interface_at(interface_index());
 153     }
 154   };
 155 
 156   bool _visited_Object;

 157   GrowableArray&lt;Node*&gt; _path;

 158 
 159   Node* current_top() const { return _path.top(); }
<span class="line-modified"> 160   bool has_more_nodes() const { return !_path.is_empty(); }</span>
<span class="line-modified"> 161   void push(InstanceKlass* cls, void* data) {</span>
 162     assert(cls != NULL, &quot;Requires a valid instance class&quot;);
<span class="line-removed"> 163     Node* node = new Node(cls, data, has_super(cls));</span>
 164     if (cls == SystemDictionary::Object_klass()) {
 165       _visited_Object = true;
 166     }








 167     _path.push(node);
 168   }
<span class="line-modified"> 169   void pop() { _path.pop(); }</span>




 170 
 171   // Since the starting point can be an interface, we must ensure we catch
 172   // j.l.Object as the super once in those cases. The _visited_Object flag
 173   // only ensures we don&#39;t then repeatedly enqueue Object for each interface
 174   // in the class hierarchy.
 175   bool has_super(InstanceKlass* cls) {
 176     return cls-&gt;super() != NULL &amp;&amp; (!_visited_Object || !cls-&gt;is_interface());
 177   }
 178 
 179   Node* node_at_depth(int i) const {
 180     return (i &gt;= _path.length()) ? NULL : _path.at(_path.length() - i - 1);
 181   }
 182 
 183  protected:
 184 





 185   // Accessors available to the algorithm
 186   int current_depth() const { return _path.length() - 1; }
 187 
 188   InstanceKlass* class_at_depth(int i) {
 189     Node* n = node_at_depth(i);
 190     return n == NULL ? NULL : n-&gt;_class;
 191   }
 192   InstanceKlass* current_class() { return class_at_depth(0); }
 193 
 194   void* data_at_depth(int i) {
 195     Node* n = node_at_depth(i);
 196     return n == NULL ? NULL : n-&gt;_algorithm_data;
 197   }
 198   void* current_data() { return data_at_depth(0); }
 199 
 200  public:

 201 
 202   void run(InstanceKlass* root) {
 203     ALGO* algo = static_cast&lt;ALGO*&gt;(this);
 204 
<span class="line-modified"> 205     void* algo_data = algo-&gt;new_node_data(root);</span>
<span class="line-removed"> 206     push(root, algo_data);</span>
 207     bool top_needs_visit = true;
<span class="line-removed"> 208 </span>
 209     do {
 210       Node* top = current_top();
 211       if (top_needs_visit) {
 212         if (algo-&gt;visit() == false) {
 213           // algorithm does not want to continue along this path.  Arrange
 214           // it so that this state is immediately popped off the stack
 215           top-&gt;set_super_visited();
 216           top-&gt;set_all_interfaces_visited();
 217         }
 218         top_needs_visit = false;
 219       }
 220 
 221       if (top-&gt;has_visited_super() &amp;&amp; top-&gt;has_visited_all_interfaces()) {
 222         algo-&gt;free_node_data(top-&gt;_algorithm_data);
 223         pop();
 224       } else {
 225         InstanceKlass* next = NULL;
 226         if (top-&gt;has_visited_super() == false) {
 227           next = top-&gt;next_super();
 228           top-&gt;set_super_visited();
 229         } else {
 230           next = top-&gt;next_interface();
 231           top-&gt;increment_visited_interface();
 232         }
 233         assert(next != NULL, &quot;Otherwise we shouldn&#39;t be here&quot;);
<span class="line-modified"> 234         algo_data = algo-&gt;new_node_data(next);</span>
<span class="line-removed"> 235         push(next, algo_data);</span>
 236         top_needs_visit = true;
 237       }
 238     } while (has_more_nodes());
 239   }
 240 };
 241 
 242 class PrintHierarchy : public HierarchyVisitor&lt;PrintHierarchy&gt; {
 243  private:
 244    outputStream* _st;
 245  public:
 246   bool visit() {
 247     InstanceKlass* cls = current_class();
 248     streamIndentor si(_st, current_depth() * 2);
 249     _st-&gt;indent().print_cr(&quot;%s&quot;, cls-&gt;name()-&gt;as_C_string());
 250     return true;
 251   }
 252 
<span class="line-modified"> 253   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 254   void free_node_data(void* data) { return; }
 255 
 256   PrintHierarchy(outputStream* st = tty) : _st(st) {}
 257 };
 258 
 259 // Used to register InstanceKlass objects and all related metadata structures
 260 // (Methods, ConstantPools) as &quot;in-use&quot; by the current thread so that they can&#39;t
 261 // be deallocated by class redefinition while we&#39;re using them.  The classes are
 262 // de-registered when this goes out of scope.
 263 //
 264 // Once a class is registered, we need not bother with methodHandles or
 265 // constantPoolHandles for it&#39;s associated metadata.
 266 class KeepAliveRegistrar : public StackObj {
 267  private:
 268   Thread* _thread;
 269   GrowableArray&lt;ConstantPool*&gt; _keep_alive;
 270 
 271  public:
<span class="line-modified"> 272   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(20) {</span>
 273     assert(thread == Thread::current(), &quot;Must be current thread&quot;);
 274   }
 275 
 276   ~KeepAliveRegistrar() {
 277     for (int i = _keep_alive.length() - 1; i &gt;= 0; --i) {
 278       ConstantPool* cp = _keep_alive.at(i);
 279       int idx = _thread-&gt;metadata_handles()-&gt;find_from_end(cp);
 280       assert(idx &gt; 0, &quot;Must be in the list&quot;);
 281       _thread-&gt;metadata_handles()-&gt;remove_at(idx);
 282     }
 283   }
 284 
 285   // Register a class as &#39;in-use&#39; by the thread.  It&#39;s fine to register a class
 286   // multiple times (though perhaps inefficient)
 287   void register_class(InstanceKlass* ik) {
 288     ConstantPool* cp = ik-&gt;constants();
 289     _keep_alive.push(cp);
 290     _thread-&gt;metadata_handles()-&gt;push(cp);
 291   }
 292 };
 293 
 294 class KeepAliveVisitor : public HierarchyVisitor&lt;KeepAliveVisitor&gt; {
 295  private:
 296   KeepAliveRegistrar* _registrar;
 297 
 298  public:
 299   KeepAliveVisitor(KeepAliveRegistrar* registrar) : _registrar(registrar) {}
 300 
<span class="line-modified"> 301   void* new_node_data(InstanceKlass* cls) { return NULL; }</span>
 302   void free_node_data(void* data) { return; }
 303 
 304   bool visit() {
 305     _registrar-&gt;register_class(current_class());
 306     return true;
 307   }
 308 };
 309 
 310 
 311 // A method family contains a set of all methods that implement a single
 312 // erased method. As members of the set are collected while walking over the
 313 // hierarchy, they are tagged with a qualification state.  The qualification
 314 // state for an erased method is set to disqualified if there exists a path
 315 // from the root of hierarchy to the method that contains an interleaving
 316 // erased method defined in an interface.
 317 









 318 class MethodFamily : public ResourceObj {
 319  private:
 320 
<span class="line-modified"> 321   GrowableArray&lt;Pair&lt;Method*,QualifiedState&gt; &gt; _members;</span>
<span class="line-removed"> 322   ResourceHashtable&lt;Method*, int&gt; _member_index;</span>
 323 
 324   Method* _selected_target;  // Filled in later, if a unique target exists
 325   Symbol* _exception_message; // If no unique target is found
 326   Symbol* _exception_name;    // If no unique target is found
 327 
<span class="line-modified"> 328   bool contains_method(Method* method) {</span>
<span class="line-modified"> 329     int* lookup = _member_index.get(method);</span>
<span class="line-modified"> 330     return lookup != NULL;</span>




 331   }
 332 
 333   void add_method(Method* method, QualifiedState state) {
<span class="line-modified"> 334     Pair&lt;Method*,QualifiedState&gt; entry(method, state);</span>
<span class="line-modified"> 335     _member_index.put(method, _members.length());</span>
<span class="line-removed"> 336     _members.append(entry);</span>
<span class="line-removed"> 337   }</span>
<span class="line-removed"> 338 </span>
<span class="line-removed"> 339   void disqualify_method(Method* method) {</span>
<span class="line-removed"> 340     int* index = _member_index.get(method);</span>
<span class="line-removed"> 341     guarantee(index != NULL &amp;&amp; *index &gt;= 0 &amp;&amp; *index &lt; _members.length(), &quot;bad index&quot;);</span>
<span class="line-removed"> 342     _members.at(*index).second = DISQUALIFIED;</span>
 343   }
 344 
 345   Symbol* generate_no_defaults_message(TRAPS) const;
 346   Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;
<span class="line-modified"> 347   Symbol* generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const;</span>
 348 
 349  public:
 350 
 351   MethodFamily()
 352       : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}
 353 
 354   void set_target_if_empty(Method* m) {
 355     if (_selected_target == NULL &amp;&amp; !m-&gt;is_overpass()) {
 356       _selected_target = m;
 357     }
 358   }
 359 
<span class="line-modified"> 360   void record_qualified_method(Method* m) {</span>
<span class="line-modified"> 361     // If the method already exists in the set as qualified, this operation is</span>
<span class="line-modified"> 362     // redundant.  If it already exists as disqualified, then we leave it as</span>
<span class="line-modified"> 363     // disqualfied.  Thus we only add to the set if it&#39;s not already in the</span>
<span class="line-modified"> 364     // set.</span>
<span class="line-modified"> 365     if (!contains_method(m)) {</span>
<span class="line-modified"> 366       add_method(m, QUALIFIED);</span>
<span class="line-modified"> 367     }</span>
<span class="line-modified"> 368   }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370   void record_disqualified_method(Method* m) {</span>
<span class="line-removed"> 371     // If not in the set, add it as disqualified.  If it&#39;s already in the set,</span>
<span class="line-removed"> 372     // then set the state to disqualified no matter what the previous state was.</span>
<span class="line-removed"> 373     if (!contains_method(m)) {</span>
<span class="line-removed"> 374       add_method(m, DISQUALIFIED);</span>
<span class="line-removed"> 375     } else {</span>
<span class="line-removed"> 376       disqualify_method(m);</span>
 377     }
 378   }
 379 
 380   bool has_target() const { return _selected_target != NULL; }
 381   bool throws_exception() { return _exception_message != NULL; }
 382 
 383   Method* get_selected_target() { return _selected_target; }
 384   Symbol* get_exception_message() { return _exception_message; }
 385   Symbol* get_exception_name() { return _exception_name; }
 386 
 387   // Either sets the target or the exception error message
<span class="line-modified"> 388   void determine_target(InstanceKlass* root, TRAPS) {</span>
 389     if (has_target() || throws_exception()) {
 390       return;
 391     }
 392 
 393     // Qualified methods are maximally-specific methods
 394     // These include public, instance concrete (=default) and abstract methods
<span class="line-removed"> 395     GrowableArray&lt;Method*&gt; qualified_methods;</span>
 396     int num_defaults = 0;
 397     int default_index = -1;
<span class="line-modified"> 398     int qualified_index = -1;</span>
<span class="line-modified"> 399     for (int i = 0; i &lt; _members.length(); ++i) {</span>
<span class="line-modified"> 400       Pair&lt;Method*,QualifiedState&gt; entry = _members.at(i);</span>
<span class="line-modified"> 401       if (entry.second == QUALIFIED) {</span>
<span class="line-removed"> 402         qualified_methods.append(entry.first);</span>
<span class="line-removed"> 403         qualified_index++;</span>
<span class="line-removed"> 404         if (entry.first-&gt;is_default_method()) {</span>
 405           num_defaults++;
<span class="line-modified"> 406           default_index = qualified_index;</span>
<span class="line-removed"> 407 </span>
 408         }
 409       }
 410     }
 411 


















 412     if (num_defaults == 0) {
 413       // If the root klass has a static method with matching name and signature
 414       // then do not generate an overpass method because it will hide the
 415       // static method during resolution.
 416       if (qualified_methods.length() == 0) {
 417         _exception_message = generate_no_defaults_message(CHECK);
 418       } else {
 419         assert(root != NULL, &quot;Null root class&quot;);
 420         _exception_message = generate_method_message(root-&gt;name(), qualified_methods.at(0), CHECK);
 421       }
 422       _exception_name = vmSymbols::java_lang_AbstractMethodError();
<span class="line-modified"> 423 </span>
<span class="line-modified"> 424     // If only one qualified method is default, select that</span>
<span class="line-removed"> 425     } else if (num_defaults == 1) {</span>
<span class="line-removed"> 426         _selected_target = qualified_methods.at(default_index);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428     } else if (num_defaults &gt; 1) {</span>
<span class="line-removed"> 429       _exception_message = generate_conflicts_message(&amp;qualified_methods,CHECK);</span>
 430       _exception_name = vmSymbols::java_lang_IncompatibleClassChangeError();
 431       LogTarget(Debug, defaultmethods) lt;
 432       if (lt.is_enabled()) {
 433         LogStream ls(lt);
 434         _exception_message-&gt;print_value_on(&amp;ls);
 435         ls.cr();
 436       }
 437     }
 438   }
 439 
 440   void print_selected(outputStream* str, int indent) const {
 441     assert(has_target(), &quot;Should be called otherwise&quot;);
 442     streamIndentor si(str, indent * 2);
 443     str-&gt;indent().print(&quot;Selected method: &quot;);
 444     print_method(str, _selected_target);
 445     Klass* method_holder = _selected_target-&gt;method_holder();
 446     if (!method_holder-&gt;is_interface()) {
 447       str-&gt;print(&quot; : in superclass&quot;);
 448     }
 449     str-&gt;cr();
 450   }
 451 
 452   void print_exception(outputStream* str, int indent) {
 453     assert(throws_exception(), &quot;Should be called otherwise&quot;);
 454     assert(_exception_name != NULL, &quot;exception_name should be set&quot;);
 455     streamIndentor si(str, indent * 2);
 456     str-&gt;indent().print_cr(&quot;%s: %s&quot;, _exception_name-&gt;as_C_string(), _exception_message-&gt;as_C_string());
 457   }
 458 };
 459 
 460 Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {
<span class="line-modified"> 461   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;, THREAD);</span>
 462 }
 463 
 464 Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {
 465   stringStream ss;
 466   ss.print(&quot;Method &quot;);
 467   Symbol* name = method-&gt;name();
 468   Symbol* signature = method-&gt;signature();
 469   ss.write((const char*)klass_name-&gt;bytes(), klass_name-&gt;utf8_length());
 470   ss.print(&quot;.&quot;);
 471   ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());
 472   ss.write((const char*)signature-&gt;bytes(), signature-&gt;utf8_length());
 473   ss.print(&quot; is abstract&quot;);
<span class="line-modified"> 474   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
 475 }
 476 
<span class="line-modified"> 477 Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;Method*&gt;* methods, TRAPS) const {</span>
 478   stringStream ss;
 479   ss.print(&quot;Conflicting default methods:&quot;);
 480   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
<span class="line-modified"> 481     Method* method = methods-&gt;at(i);</span>
<span class="line-modified"> 482     Symbol* klass = method-&gt;klass_name();</span>
<span class="line-modified"> 483     Symbol* name = method-&gt;name();</span>
 484     ss.print(&quot; &quot;);
<span class="line-modified"> 485     ss.write((const char*)klass-&gt;bytes(), klass-&gt;utf8_length());</span>
 486     ss.print(&quot;.&quot;);
<span class="line-modified"> 487     ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());</span>
 488   }
<span class="line-modified"> 489   return SymbolTable::new_symbol(ss.base(), (int)ss.size(), THREAD);</span>
 490 }
 491 
 492 
<span class="line-modified"> 493 class StateRestorer;</span>
 494 
 495 // StatefulMethodFamily is a wrapper around a MethodFamily that maintains the
 496 // qualification state during hierarchy visitation, and applies that state
 497 // when adding members to the MethodFamily
 498 class StatefulMethodFamily : public ResourceObj {
 499   friend class StateRestorer;
 500  private:
 501   QualifiedState _qualification_state;
 502 
 503   void set_qualification_state(QualifiedState state) {
 504     _qualification_state = state;
 505   }
 506 
 507  protected:
 508   MethodFamily _method_family;
 509 
 510  public:
 511   StatefulMethodFamily() {
 512    _qualification_state = QUALIFIED;
 513   }
 514 
 515   void set_target_if_empty(Method* m) { _method_family.set_target_if_empty(m); }
 516 
 517   MethodFamily* get_method_family() { return &amp;_method_family; }
 518 
<span class="line-modified"> 519   StateRestorer* record_method_and_dq_further(Method* mo);</span>
 520 };
 521 
<span class="line-modified"> 522 class StateRestorer : public PseudoScopeMark {</span>
<span class="line-modified"> 523  private:</span>








 524   StatefulMethodFamily* _method;
 525   QualifiedState _state_to_restore;
<span class="line-modified"> 526  public:</span>
<span class="line-modified"> 527   StateRestorer(StatefulMethodFamily* dm, QualifiedState state)</span>
<span class="line-modified"> 528       : _method(dm), _state_to_restore(state) {}</span>
<span class="line-removed"> 529   ~StateRestorer() { destroy(); }</span>
 530   void restore_state() { _method-&gt;set_qualification_state(_state_to_restore); }
<span class="line-removed"> 531   virtual void destroy() { restore_state(); }</span>
 532 };
 533 
<span class="line-modified"> 534 StateRestorer* StatefulMethodFamily::record_method_and_dq_further(Method* mo) {</span>
<span class="line-modified"> 535   StateRestorer* mark = new StateRestorer(this, _qualification_state);</span>
<span class="line-modified"> 536   if (_qualification_state == QUALIFIED) {</span>
<span class="line-modified"> 537     _method_family.record_qualified_method(mo);</span>
<span class="line-modified"> 538   } else {</span>
<span class="line-modified"> 539     _method_family.record_disqualified_method(mo);</span>



 540   }
































 541   // Everything found &quot;above&quot;??? this method in the hierarchy walk is set to
 542   // disqualified
 543   set_qualification_state(DISQUALIFIED);
<span class="line-removed"> 544   return mark;</span>
 545 }
 546 
 547 // Represents a location corresponding to a vtable slot for methods that
 548 // neither the class nor any of it&#39;s ancestors provide an implementaion.
 549 // Default methods may be present to fill this slot.
 550 class EmptyVtableSlot : public ResourceObj {
 551  private:
 552   Symbol* _name;
 553   Symbol* _signature;
 554   int _size_of_parameters;
 555   MethodFamily* _binding;
 556 
 557  public:
 558   EmptyVtableSlot(Method* method)
 559       : _name(method-&gt;name()), _signature(method-&gt;signature()),
 560         _size_of_parameters(method-&gt;size_of_parameters()), _binding(NULL) {}
 561 
 562   Symbol* name() const { return _name; }
 563   Symbol* signature() const { return _signature; }
 564   int size_of_parameters() const { return _size_of_parameters; }
</pre>
<hr />
<pre>
 642     ResourceMark rm;
 643     LogStream ls(lt);
 644     streamIndentor si(&amp;ls);
 645     for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 646       ls.indent();
 647       slots-&gt;at(i)-&gt;print_on(&amp;ls);
 648       ls.cr();
 649     }
 650   }
 651 }
 652 
 653 // Iterates over the superinterface type hierarchy looking for all methods
 654 // with a specific erased signature.
 655 class FindMethodsByErasedSig : public HierarchyVisitor&lt;FindMethodsByErasedSig&gt; {
 656  private:
 657   // Context data
 658   Symbol* _method_name;
 659   Symbol* _method_signature;
 660   StatefulMethodFamily*  _family;
 661   bool _cur_class_is_interface;
<span class="line-modified"> 662 </span>


 663  public:
<span class="line-modified"> 664   FindMethodsByErasedSig(Symbol* name, Symbol* signature, bool is_interf) :</span>
<span class="line-modified"> 665       _method_name(name), _method_signature(signature), _family(NULL),</span>
<span class="line-modified"> 666       _cur_class_is_interface(is_interf) {}</span>






 667 
 668   void get_discovered_family(MethodFamily** family) {
 669       if (_family != NULL) {
 670         *family = _family-&gt;get_method_family();
 671       } else {
 672         *family = NULL;
 673       }
 674   }
 675 
<span class="line-modified"> 676   void* new_node_data(InstanceKlass* cls) { return new PseudoScope(); }</span>







 677   void free_node_data(void* node_data) {
<span class="line-modified"> 678     PseudoScope::cast(node_data)-&gt;destroy();</span>



 679   }
 680 
 681   // Find all methods on this hierarchy that match this
 682   // method&#39;s erased (name, signature)
 683   bool visit() {
<span class="line-modified"> 684     PseudoScope* scope = PseudoScope::cast(current_data());</span>
 685     InstanceKlass* iklass = current_class();
 686 
 687     Method* m = iklass-&gt;find_method(_method_name, _method_signature);
 688     // Private interface methods are not candidates for default methods.
 689     // invokespecial to private interface methods doesn&#39;t use default method logic.
 690     // Private class methods are not candidates for default methods.
 691     // Private methods do not override default methods, so need to perform
 692     // default method inheritance without including private methods.
 693     // The overpasses are your supertypes&#39; errors, we do not include them.
 694     // Non-public methods in java.lang.Object are not candidates for default
 695     // methods.
 696     // Future: take access controls into account for superclass methods
 697     if (m != NULL &amp;&amp; !m-&gt;is_static() &amp;&amp; !m-&gt;is_overpass() &amp;&amp; !m-&gt;is_private() &amp;&amp;
 698      (!_cur_class_is_interface || !SystemDictionary::is_nonpublic_Object_method(m))) {
 699       if (_family == NULL) {
 700         _family = new StatefulMethodFamily();
 701       }
 702 
 703       if (iklass-&gt;is_interface()) {
<span class="line-modified"> 704         StateRestorer* restorer = _family-&gt;record_method_and_dq_further(m);</span>
<span class="line-removed"> 705         scope-&gt;add_mark(restorer);</span>
 706       } else {
 707         // This is the rule that methods in classes &quot;win&quot; (bad word) over
 708         // methods in interfaces. This works because of single inheritance.
 709         // Private methods in classes do not &quot;win&quot;, they will be found
 710         // first on searching, but overriding for invokevirtual needs
 711         // to find default method candidates for the same signature
 712         _family-&gt;set_target_if_empty(m);
 713       }
 714     }
 715     return true;
 716   }
 717 
 718 };
 719 
 720 
 721 
 722 static void create_defaults_and_exceptions(
 723     GrowableArray&lt;EmptyVtableSlot*&gt;* slots, InstanceKlass* klass, TRAPS);
 724 
 725 static void generate_erased_defaults(
<span class="line-modified"> 726      InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {</span>

 727 




 728   // sets up a set of methods with the same exact erased signature
<span class="line-modified"> 729   FindMethodsByErasedSig visitor(slot-&gt;name(), slot-&gt;signature(), is_intf);</span>
<span class="line-removed"> 730   visitor.run(klass);</span>
 731 
 732   MethodFamily* family;
<span class="line-modified"> 733   visitor.get_discovered_family(&amp;family);</span>
 734   if (family != NULL) {
<span class="line-modified"> 735     family-&gt;determine_target(klass, CHECK);</span>
 736     slot-&gt;bind_family(family);
 737   }
 738 }
 739 
 740 static void merge_in_new_methods(InstanceKlass* klass,
 741     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 742 static void create_default_methods( InstanceKlass* klass,
 743     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 744 
 745 // This is the guts of the default methods implementation.  This is called just
 746 // after the classfile has been parsed if some ancestor has default methods.
 747 //
 748 // First it finds any name/signature slots that need any implementation (either
 749 // because they are miranda or a superclass&#39;s implementation is an overpass
 750 // itself).  For each slot, iterate over the hierarchy, to see if they contain a
 751 // signature that matches the slot we are looking at.
 752 //
 753 // For each slot filled, we either record the default method candidate in the
 754 // klass default_methods list or, only to handle exception cases, we create an
 755 // overpass method that throws an exception and add it to the klass methods list.
</pre>
<hr />
<pre>
 770   constantPoolHandle cp(THREAD, klass-&gt;constants());
 771   KeepAliveRegistrar keepAlive(THREAD);
 772   KeepAliveVisitor loadKeepAlive(&amp;keepAlive);
 773   loadKeepAlive.run(klass);
 774 
 775   LogTarget(Debug, defaultmethods) lt;
 776   if (lt.is_enabled()) {
 777     ResourceMark rm;
 778     lt.print(&quot;%s %s requires default method processing&quot;,
 779              klass-&gt;is_interface() ? &quot;Interface&quot; : &quot;Class&quot;,
 780              klass-&gt;name()-&gt;as_klass_external_name());
 781     LogStream ls(lt);
 782     PrintHierarchy printer(&amp;ls);
 783     printer.run(klass);
 784   }
 785 
 786   GrowableArray&lt;EmptyVtableSlot*&gt; empty_slots;
 787   find_empty_vtable_slots(&amp;empty_slots, klass, mirandas, CHECK);
 788 
 789   if (empty_slots.length() &gt; 0) {

 790     for (int i = 0; i &lt; empty_slots.length(); ++i) {
 791       EmptyVtableSlot* slot = empty_slots.at(i);
 792       LogTarget(Debug, defaultmethods) lt;
 793       if (lt.is_enabled()) {
 794         LogStream ls(lt);
 795         streamIndentor si(&amp;ls, 2);
 796         ls.indent().print(&quot;Looking for default methods for slot &quot;);
 797         slot-&gt;print_on(&amp;ls);
 798         ls.cr();
 799       }
<span class="line-modified"> 800       generate_erased_defaults(klass, slot, klass-&gt;is_interface(), CHECK);</span>
 801     }
 802     log_debug(defaultmethods)(&quot;Creating defaults and overpasses...&quot;);
 803     create_defaults_and_exceptions(&amp;empty_slots, klass, CHECK);
 804   }
 805   log_debug(defaultmethods)(&quot;Default method processing complete&quot;);
 806 }
 807 
 808 static int assemble_method_error(
 809     BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message, TRAPS) {
 810 
 811   Symbol* init = vmSymbols::object_initializer_name();
 812   Symbol* sig = vmSymbols::string_void_signature();
 813 
 814   BytecodeAssembler assem(buffer, cp);
 815 
 816   assem._new(errorName);
 817   assem.dup();
 818   assem.load_string(message);
 819   assem.invokespecial(errorName, init, sig);
 820   assem.athrow();
</pre>
<hr />
<pre>
 826     BytecodeConstantPool* cp, BytecodeBuffer* bytecodes, Symbol* name,
 827     Symbol* sig, AccessFlags flags, int max_stack, int params,
 828     ConstMethod::MethodType mt, TRAPS) {
 829 
 830   address code_start = 0;
 831   int code_length = 0;
 832   InlineTableSizes sizes;
 833 
 834   if (bytecodes != NULL &amp;&amp; bytecodes-&gt;length() &gt; 0) {
 835     code_start = static_cast&lt;address&gt;(bytecodes-&gt;adr_at(0));
 836     code_length = bytecodes-&gt;length();
 837   }
 838 
 839   Method* m = Method::allocate(cp-&gt;pool_holder()-&gt;class_loader_data(),
 840                                code_length, flags, &amp;sizes,
 841                                mt, CHECK_NULL);
 842 
 843   m-&gt;set_constants(NULL); // This will get filled in later
 844   m-&gt;set_name_index(cp-&gt;utf8(name));
 845   m-&gt;set_signature_index(cp-&gt;utf8(sig));
<span class="line-modified"> 846   ResultTypeFinder rtf(sig);</span>
<span class="line-removed"> 847   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
 848   m-&gt;set_size_of_parameters(params);
 849   m-&gt;set_max_stack(max_stack);
 850   m-&gt;set_max_locals(params);
 851   m-&gt;constMethod()-&gt;set_stackmap_data(NULL);
 852   m-&gt;set_code(code_start);
 853 
 854   return m;
 855 }
 856 
 857 static void switchover_constant_pool(BytecodeConstantPool* bpool,
 858     InstanceKlass* klass, GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
 859 
 860   if (new_methods-&gt;length() &gt; 0) {
 861     ConstantPool* cp = bpool-&gt;create_constant_pool(CHECK);
 862     if (cp != klass-&gt;constants()) {
 863       // Copy resolved anonymous class into new constant pool.
 864       if (klass-&gt;is_unsafe_anonymous()) {
 865         cp-&gt;klass_at_put(klass-&gt;this_class_index(), klass);
 866       }
 867       klass-&gt;class_loader_data()-&gt;add_to_deallocate_list(klass-&gt;constants());
</pre>
<hr />
<pre>
 880 }
 881 
 882 // Create default_methods list for the current class.
 883 // With the VM only processing erased signatures, the VM only
 884 // creates an overpass in a conflict case or a case with no candidates.
 885 // This allows virtual methods to override the overpass, but ensures
 886 // that a local method search will find the exception rather than an abstract
 887 // or default method that is not a valid candidate.
 888 //
 889 // Note that if overpass method are ever created that are not exception
 890 // throwing methods then the loader constraint checking logic for vtable and
 891 // itable creation needs to be changed to check loader constraints for the
 892 // overpass methods that do not throw exceptions.
 893 static void create_defaults_and_exceptions(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 894     InstanceKlass* klass, TRAPS) {
 895 
 896   GrowableArray&lt;Method*&gt; overpasses;
 897   GrowableArray&lt;Method*&gt; defaults;
 898   BytecodeConstantPool bpool(klass-&gt;constants());
 899 

 900   for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 901     EmptyVtableSlot* slot = slots-&gt;at(i);
 902 
 903     if (slot-&gt;is_bound()) {
 904       MethodFamily* method = slot-&gt;get_binding();
<span class="line-removed"> 905       BytecodeBuffer buffer;</span>
 906 
 907       LogTarget(Debug, defaultmethods) lt;
 908       if (lt.is_enabled()) {
 909         ResourceMark rm(THREAD);
 910         LogStream ls(lt);
 911         ls.print(&quot;for slot: &quot;);
 912         slot-&gt;print_on(&amp;ls);
 913         ls.cr();
 914         if (method-&gt;has_target()) {
 915           method-&gt;print_selected(&amp;ls, 1);
 916         } else if (method-&gt;throws_exception()) {
 917           method-&gt;print_exception(&amp;ls, 1);
 918         }
 919       }
 920 
 921       if (method-&gt;has_target()) {
 922         Method* selected = method-&gt;get_selected_target();
 923         if (selected-&gt;method_holder()-&gt;is_interface()) {
 924           assert(!selected-&gt;is_private(), &quot;pushing private interface method as default&quot;);
 925           defaults.push(selected);
 926         }
 927       } else if (method-&gt;throws_exception()) {
<span class="line-modified"> 928         int max_stack = assemble_method_error(&amp;bpool, &amp;buffer,</span>





 929            method-&gt;get_exception_name(), method-&gt;get_exception_message(), CHECK);
 930         AccessFlags flags = accessFlags_from(
 931           JVM_ACC_PUBLIC | JVM_ACC_SYNTHETIC | JVM_ACC_BRIDGE);
<span class="line-modified"> 932          Method* m = new_method(&amp;bpool, &amp;buffer, slot-&gt;name(), slot-&gt;signature(),</span>
 933           flags, max_stack, slot-&gt;size_of_parameters(),
 934           ConstMethod::OVERPASS, CHECK);
 935         // We push to the methods list:
 936         // overpass methods which are exception throwing methods
 937         if (m != NULL) {
 938           overpasses.push(m);
 939         }
 940       }
 941     }
 942   }
 943 
 944 
 945   log_debug(defaultmethods)(&quot;Created %d overpass methods&quot;, overpasses.length());
 946   log_debug(defaultmethods)(&quot;Created %d default  methods&quot;, defaults.length());
 947 
 948   if (overpasses.length() &gt; 0) {
 949     switchover_constant_pool(&amp;bpool, klass, &amp;overpasses, CHECK);
 950     merge_in_new_methods(klass, &amp;overpasses, CHECK);
 951   }
 952   if (defaults.length() &gt; 0) {
</pre>
<hr />
<pre>
 994     prev = nv;
 995   }
 996 #endif
 997 }
 998 
 999 static void merge_in_new_methods(InstanceKlass* klass,
1000     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
1001 
1002   enum { ANNOTATIONS, PARAMETERS, DEFAULTS, NUM_ARRAYS };
1003 
1004   Array&lt;Method*&gt;* original_methods = klass-&gt;methods();
1005   Array&lt;int&gt;* original_ordering = klass-&gt;method_ordering();
1006   Array&lt;int&gt;* merged_ordering = Universe::the_empty_int_array();
1007 
1008   int new_size = klass-&gt;methods()-&gt;length() + new_methods-&gt;length();
1009 
1010   Array&lt;Method*&gt;* merged_methods = MetadataFactory::new_array&lt;Method*&gt;(
1011       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
1012 
1013   // original_ordering might be empty if this class has no methods of its own
<span class="line-modified">1014   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
1015     merged_ordering = MetadataFactory::new_array&lt;int&gt;(
1016         klass-&gt;class_loader_data(), new_size, CHECK);
1017   }
1018   int method_order_index = klass-&gt;methods()-&gt;length();
1019 
1020   sort_methods(new_methods);
1021 
1022   // Perform grand merge of existing methods and new methods
1023   int orig_idx = 0;
1024   int new_idx = 0;
1025 
1026   for (int i = 0; i &lt; new_size; ++i) {
1027     Method* orig_method = NULL;
1028     Method* new_method = NULL;
1029     if (orig_idx &lt; original_methods-&gt;length()) {
1030       orig_method = original_methods-&gt;at(orig_idx);
1031     }
1032     if (new_idx &lt; new_methods-&gt;length()) {
1033       new_method = new_methods-&gt;at(new_idx);
1034     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/bytecodeAssembler.hpp&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logStream.hpp&quot;
  32 #include &quot;memory/allocation.hpp&quot;
  33 #include &quot;memory/metadataFactory.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  35 #include &quot;memory/universe.hpp&quot;</span>
  36 #include &quot;runtime/handles.inline.hpp&quot;
  37 #include &quot;runtime/signature.hpp&quot;
  38 #include &quot;runtime/thread.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/klass.hpp&quot;
  41 #include &quot;oops/method.hpp&quot;
  42 #include &quot;utilities/accessFlags.hpp&quot;
  43 #include &quot;utilities/exceptions.hpp&quot;
  44 #include &quot;utilities/ostream.hpp&quot;
  45 #include &quot;utilities/pair.hpp&quot;
  46 #include &quot;utilities/resourceHash.hpp&quot;
  47 
  48 typedef enum { QUALIFIED, DISQUALIFIED } QualifiedState;
  49 
































  50 static void print_slot(outputStream* str, Symbol* name, Symbol* signature) {
  51   str-&gt;print(&quot;%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
  52 }
  53 
  54 static void print_method(outputStream* str, Method* mo, bool with_class=true) {
  55   if (with_class) {
  56     str-&gt;print(&quot;%s.&quot;, mo-&gt;klass_name()-&gt;as_C_string());
  57   }
  58   print_slot(str, mo-&gt;name(), mo-&gt;signature());
  59 }
  60 
  61 /**
  62  * Perform a depth-first iteration over the class hierarchy, applying
  63  * algorithmic logic as it goes.
  64  *
  65  * This class is one half of the inheritance hierarchy analysis mechanism.
  66  * It is meant to be used in conjunction with another class, the algorithm,
  67  * which is indicated by the ALGO template parameter.  This class can be
  68  * paired with any algorithm class that provides the required methods.
  69  *
  70  * This class contains all the mechanics for iterating over the class hierarchy
  71  * starting at a particular root, without recursing (thus limiting stack growth
  72  * from this point).  It visits each superclass (if present) and superinterface
  73  * in a depth-first manner, with callbacks to the ALGO class as each class is
  74  * encountered (visit()), The algorithm can cut-off further exploration of a
  75  * particular branch by returning &#39;false&#39; from a visit() call.
  76  *
  77  * The ALGO class, must provide a visit() method, which each of which will be
  78  * called once for each node in the inheritance tree during the iteration.  In
<span class="line-modified">  79  * addition, it can provide a memory block via new_node_data(), which it can</span>
<span class="line-modified">  80  * use for node-specific storage (and access via the current_data() and</span>
<span class="line-modified">  81  * data_at_depth(int) methods).</span>
  82  *
  83  * Bare minimum needed to be an ALGO class:
  84  * class Algo : public HierarchyVisitor&lt;Algo&gt; {
<span class="line-modified">  85  *   void* new_node_data() { return NULL; }</span>
  86  *   void free_node_data(void* data) { return; }
  87  *   bool visit() { return true; }
  88  * };
  89  */
  90 template &lt;class ALGO&gt;
  91 class HierarchyVisitor : StackObj {
  92  private:
  93 
  94   class Node : public ResourceObj {
  95    public:
  96     InstanceKlass* _class;
  97     bool _super_was_visited;
  98     int _interface_index;
  99     void* _algorithm_data;
 100 
 101     Node(InstanceKlass* cls, void* data, bool visit_super)
 102         : _class(cls), _super_was_visited(!visit_super),
 103           _interface_index(0), _algorithm_data(data) {}
 104 
<span class="line-added"> 105     void update(InstanceKlass* cls, void* data, bool visit_super) {</span>
<span class="line-added"> 106       _class = cls;</span>
<span class="line-added"> 107       _super_was_visited = !visit_super;</span>
<span class="line-added"> 108       _interface_index = 0;</span>
<span class="line-added"> 109       _algorithm_data = data;</span>
<span class="line-added"> 110     }</span>
 111     int number_of_interfaces() { return _class-&gt;local_interfaces()-&gt;length(); }
 112     int interface_index() { return _interface_index; }
 113     void set_super_visited() { _super_was_visited = true; }
 114     void increment_visited_interface() { ++_interface_index; }
 115     void set_all_interfaces_visited() {
 116       _interface_index = number_of_interfaces();
 117     }
 118     bool has_visited_super() { return _super_was_visited; }
 119     bool has_visited_all_interfaces() {
 120       return interface_index() &gt;= number_of_interfaces();
 121     }
 122     InstanceKlass* interface_at(int index) {
<span class="line-modified"> 123       return _class-&gt;local_interfaces()-&gt;at(index);</span>
 124     }
 125     InstanceKlass* next_super() { return _class-&gt;java_super(); }
 126     InstanceKlass* next_interface() {
 127       return interface_at(interface_index());
 128     }
 129   };
 130 
 131   bool _visited_Object;
<span class="line-added"> 132 </span>
 133   GrowableArray&lt;Node*&gt; _path;
<span class="line-added"> 134   GrowableArray&lt;Node*&gt; _free_nodes;</span>
 135 
 136   Node* current_top() const { return _path.top(); }
<span class="line-modified"> 137   bool has_more_nodes() const { return _path.length() &gt; 0; }</span>
<span class="line-modified"> 138   void push(InstanceKlass* cls, ALGO* algo) {</span>
 139     assert(cls != NULL, &quot;Requires a valid instance class&quot;);

 140     if (cls == SystemDictionary::Object_klass()) {
 141       _visited_Object = true;
 142     }
<span class="line-added"> 143     void* data = algo-&gt;new_node_data();</span>
<span class="line-added"> 144     Node* node;</span>
<span class="line-added"> 145     if (_free_nodes.is_empty()) { // Add a new node</span>
<span class="line-added"> 146       node = new Node(cls, data, has_super(cls));</span>
<span class="line-added"> 147     } else { // Reuse existing node and data</span>
<span class="line-added"> 148       node = _free_nodes.pop();</span>
<span class="line-added"> 149       node-&gt;update(cls, data, has_super(cls));</span>
<span class="line-added"> 150     }</span>
 151     _path.push(node);
 152   }
<span class="line-modified"> 153   void pop() {</span>
<span class="line-added"> 154     Node* node = _path.pop();</span>
<span class="line-added"> 155     // Make the node available for reuse</span>
<span class="line-added"> 156     _free_nodes.push(node);</span>
<span class="line-added"> 157   }</span>
 158 
 159   // Since the starting point can be an interface, we must ensure we catch
 160   // j.l.Object as the super once in those cases. The _visited_Object flag
 161   // only ensures we don&#39;t then repeatedly enqueue Object for each interface
 162   // in the class hierarchy.
 163   bool has_super(InstanceKlass* cls) {
 164     return cls-&gt;super() != NULL &amp;&amp; (!_visited_Object || !cls-&gt;is_interface());
 165   }
 166 
 167   Node* node_at_depth(int i) const {
 168     return (i &gt;= _path.length()) ? NULL : _path.at(_path.length() - i - 1);
 169   }
 170 
 171  protected:
 172 
<span class="line-added"> 173   // Resets the visitor</span>
<span class="line-added"> 174   void reset() {</span>
<span class="line-added"> 175     _visited_Object = false;</span>
<span class="line-added"> 176   }</span>
<span class="line-added"> 177 </span>
 178   // Accessors available to the algorithm
 179   int current_depth() const { return _path.length() - 1; }
 180 
 181   InstanceKlass* class_at_depth(int i) {
 182     Node* n = node_at_depth(i);
 183     return n == NULL ? NULL : n-&gt;_class;
 184   }
 185   InstanceKlass* current_class() { return class_at_depth(0); }
 186 
 187   void* data_at_depth(int i) {
 188     Node* n = node_at_depth(i);
 189     return n == NULL ? NULL : n-&gt;_algorithm_data;
 190   }
 191   void* current_data() { return data_at_depth(0); }
 192 
 193  public:
<span class="line-added"> 194   HierarchyVisitor() : _visited_Object(false), _path() {}</span>
 195 
 196   void run(InstanceKlass* root) {
 197     ALGO* algo = static_cast&lt;ALGO*&gt;(this);
 198 
<span class="line-modified"> 199     push(root, algo);</span>

 200     bool top_needs_visit = true;

 201     do {
 202       Node* top = current_top();
 203       if (top_needs_visit) {
 204         if (algo-&gt;visit() == false) {
 205           // algorithm does not want to continue along this path.  Arrange
 206           // it so that this state is immediately popped off the stack
 207           top-&gt;set_super_visited();
 208           top-&gt;set_all_interfaces_visited();
 209         }
 210         top_needs_visit = false;
 211       }
 212 
 213       if (top-&gt;has_visited_super() &amp;&amp; top-&gt;has_visited_all_interfaces()) {
 214         algo-&gt;free_node_data(top-&gt;_algorithm_data);
 215         pop();
 216       } else {
 217         InstanceKlass* next = NULL;
 218         if (top-&gt;has_visited_super() == false) {
 219           next = top-&gt;next_super();
 220           top-&gt;set_super_visited();
 221         } else {
 222           next = top-&gt;next_interface();
 223           top-&gt;increment_visited_interface();
 224         }
 225         assert(next != NULL, &quot;Otherwise we shouldn&#39;t be here&quot;);
<span class="line-modified"> 226         push(next, algo);</span>

 227         top_needs_visit = true;
 228       }
 229     } while (has_more_nodes());
 230   }
 231 };
 232 
 233 class PrintHierarchy : public HierarchyVisitor&lt;PrintHierarchy&gt; {
 234  private:
 235    outputStream* _st;
 236  public:
 237   bool visit() {
 238     InstanceKlass* cls = current_class();
 239     streamIndentor si(_st, current_depth() * 2);
 240     _st-&gt;indent().print_cr(&quot;%s&quot;, cls-&gt;name()-&gt;as_C_string());
 241     return true;
 242   }
 243 
<span class="line-modified"> 244   void* new_node_data() { return NULL; }</span>
 245   void free_node_data(void* data) { return; }
 246 
 247   PrintHierarchy(outputStream* st = tty) : _st(st) {}
 248 };
 249 
 250 // Used to register InstanceKlass objects and all related metadata structures
 251 // (Methods, ConstantPools) as &quot;in-use&quot; by the current thread so that they can&#39;t
 252 // be deallocated by class redefinition while we&#39;re using them.  The classes are
 253 // de-registered when this goes out of scope.
 254 //
 255 // Once a class is registered, we need not bother with methodHandles or
 256 // constantPoolHandles for it&#39;s associated metadata.
 257 class KeepAliveRegistrar : public StackObj {
 258  private:
 259   Thread* _thread;
 260   GrowableArray&lt;ConstantPool*&gt; _keep_alive;
 261 
 262  public:
<span class="line-modified"> 263   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(6) {</span>
 264     assert(thread == Thread::current(), &quot;Must be current thread&quot;);
 265   }
 266 
 267   ~KeepAliveRegistrar() {
 268     for (int i = _keep_alive.length() - 1; i &gt;= 0; --i) {
 269       ConstantPool* cp = _keep_alive.at(i);
 270       int idx = _thread-&gt;metadata_handles()-&gt;find_from_end(cp);
 271       assert(idx &gt; 0, &quot;Must be in the list&quot;);
 272       _thread-&gt;metadata_handles()-&gt;remove_at(idx);
 273     }
 274   }
 275 
 276   // Register a class as &#39;in-use&#39; by the thread.  It&#39;s fine to register a class
 277   // multiple times (though perhaps inefficient)
 278   void register_class(InstanceKlass* ik) {
 279     ConstantPool* cp = ik-&gt;constants();
 280     _keep_alive.push(cp);
 281     _thread-&gt;metadata_handles()-&gt;push(cp);
 282   }
 283 };
 284 
 285 class KeepAliveVisitor : public HierarchyVisitor&lt;KeepAliveVisitor&gt; {
 286  private:
 287   KeepAliveRegistrar* _registrar;
 288 
 289  public:
 290   KeepAliveVisitor(KeepAliveRegistrar* registrar) : _registrar(registrar) {}
 291 
<span class="line-modified"> 292   void* new_node_data() { return NULL; }</span>
 293   void free_node_data(void* data) { return; }
 294 
 295   bool visit() {
 296     _registrar-&gt;register_class(current_class());
 297     return true;
 298   }
 299 };
 300 
 301 
 302 // A method family contains a set of all methods that implement a single
 303 // erased method. As members of the set are collected while walking over the
 304 // hierarchy, they are tagged with a qualification state.  The qualification
 305 // state for an erased method is set to disqualified if there exists a path
 306 // from the root of hierarchy to the method that contains an interleaving
 307 // erased method defined in an interface.
 308 
<span class="line-added"> 309 class MethodState {</span>
<span class="line-added"> 310  public:</span>
<span class="line-added"> 311   Method* _method;</span>
<span class="line-added"> 312   QualifiedState _state;</span>
<span class="line-added"> 313 </span>
<span class="line-added"> 314   MethodState() : _method(NULL), _state(DISQUALIFIED) {}</span>
<span class="line-added"> 315   MethodState(Method* method, QualifiedState state) : _method(method), _state(state) {}</span>
<span class="line-added"> 316 };</span>
<span class="line-added"> 317 </span>
 318 class MethodFamily : public ResourceObj {
 319  private:
 320 
<span class="line-modified"> 321   GrowableArray&lt;MethodState&gt; _members;</span>

 322 
 323   Method* _selected_target;  // Filled in later, if a unique target exists
 324   Symbol* _exception_message; // If no unique target is found
 325   Symbol* _exception_name;    // If no unique target is found
 326 
<span class="line-modified"> 327   MethodState* find_method(Method* method) {</span>
<span class="line-modified"> 328     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="line-modified"> 329       if (_members.at(i)._method == method) {</span>
<span class="line-added"> 330         return &amp;_members.at(i);</span>
<span class="line-added"> 331       }</span>
<span class="line-added"> 332     }</span>
<span class="line-added"> 333     return NULL;</span>
 334   }
 335 
 336   void add_method(Method* method, QualifiedState state) {
<span class="line-modified"> 337     MethodState method_state(method, state);</span>
<span class="line-modified"> 338     _members.append(method_state);</span>







 339   }
 340 
 341   Symbol* generate_no_defaults_message(TRAPS) const;
 342   Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;
<span class="line-modified"> 343   Symbol* generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const;</span>
 344 
 345  public:
 346 
 347   MethodFamily()
 348       : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}
 349 
 350   void set_target_if_empty(Method* m) {
 351     if (_selected_target == NULL &amp;&amp; !m-&gt;is_overpass()) {
 352       _selected_target = m;
 353     }
 354   }
 355 
<span class="line-modified"> 356   void record_method(Method* m, QualifiedState state) {</span>
<span class="line-modified"> 357     // If not in the set, add it.  If it&#39;s already in the set, then leave it</span>
<span class="line-modified"> 358     // as is if state is qualified, or set it to disqualified if state is</span>
<span class="line-modified"> 359     // disqualified.</span>
<span class="line-modified"> 360     MethodState* method_state = find_method(m);</span>
<span class="line-modified"> 361     if (method_state == NULL) {</span>
<span class="line-modified"> 362       add_method(m, state);</span>
<span class="line-modified"> 363     } else if (state == DISQUALIFIED) {</span>
<span class="line-modified"> 364       method_state-&gt;_state = DISQUALIFIED;</span>








 365     }
 366   }
 367 
 368   bool has_target() const { return _selected_target != NULL; }
 369   bool throws_exception() { return _exception_message != NULL; }
 370 
 371   Method* get_selected_target() { return _selected_target; }
 372   Symbol* get_exception_message() { return _exception_message; }
 373   Symbol* get_exception_name() { return _exception_name; }
 374 
 375   // Either sets the target or the exception error message
<span class="line-modified"> 376   void determine_target_or_set_exception_message(InstanceKlass* root, TRAPS) {</span>
 377     if (has_target() || throws_exception()) {
 378       return;
 379     }
 380 
 381     // Qualified methods are maximally-specific methods
 382     // These include public, instance concrete (=default) and abstract methods

 383     int num_defaults = 0;
 384     int default_index = -1;
<span class="line-modified"> 385     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="line-modified"> 386       MethodState &amp;member = _members.at(i);</span>
<span class="line-modified"> 387       if (member._state == QUALIFIED) {</span>
<span class="line-modified"> 388         if (member._method-&gt;is_default_method()) {</span>



 389           num_defaults++;
<span class="line-modified"> 390           default_index = i;</span>

 391         }
 392       }
 393     }
 394 
<span class="line-added"> 395     if (num_defaults == 1) {</span>
<span class="line-added"> 396       assert(_members.at(default_index)._state == QUALIFIED, &quot;&quot;);</span>
<span class="line-added"> 397       _selected_target = _members.at(default_index)._method;</span>
<span class="line-added"> 398     } else {</span>
<span class="line-added"> 399       generate_and_set_exception_message(root, num_defaults, default_index, CHECK);</span>
<span class="line-added"> 400     }</span>
<span class="line-added"> 401   }</span>
<span class="line-added"> 402 </span>
<span class="line-added"> 403   void generate_and_set_exception_message(InstanceKlass* root, int num_defaults, int default_index, TRAPS) {</span>
<span class="line-added"> 404     assert(num_defaults != 1, &quot;invariant - should&#39;ve been handled calling method&quot;);</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406     GrowableArray&lt;Method*&gt; qualified_methods;</span>
<span class="line-added"> 407     for (int i = 0; i &lt; _members.length(); i++) {</span>
<span class="line-added"> 408       MethodState&amp; member = _members.at(i);</span>
<span class="line-added"> 409       if (member._state == QUALIFIED) {</span>
<span class="line-added"> 410         qualified_methods.push(member._method);</span>
<span class="line-added"> 411       }</span>
<span class="line-added"> 412     }</span>
 413     if (num_defaults == 0) {
 414       // If the root klass has a static method with matching name and signature
 415       // then do not generate an overpass method because it will hide the
 416       // static method during resolution.
 417       if (qualified_methods.length() == 0) {
 418         _exception_message = generate_no_defaults_message(CHECK);
 419       } else {
 420         assert(root != NULL, &quot;Null root class&quot;);
 421         _exception_message = generate_method_message(root-&gt;name(), qualified_methods.at(0), CHECK);
 422       }
 423       _exception_name = vmSymbols::java_lang_AbstractMethodError();
<span class="line-modified"> 424     } else {</span>
<span class="line-modified"> 425       _exception_message = generate_conflicts_message(&amp;_members,CHECK);</span>





 426       _exception_name = vmSymbols::java_lang_IncompatibleClassChangeError();
 427       LogTarget(Debug, defaultmethods) lt;
 428       if (lt.is_enabled()) {
 429         LogStream ls(lt);
 430         _exception_message-&gt;print_value_on(&amp;ls);
 431         ls.cr();
 432       }
 433     }
 434   }
 435 
 436   void print_selected(outputStream* str, int indent) const {
 437     assert(has_target(), &quot;Should be called otherwise&quot;);
 438     streamIndentor si(str, indent * 2);
 439     str-&gt;indent().print(&quot;Selected method: &quot;);
 440     print_method(str, _selected_target);
 441     Klass* method_holder = _selected_target-&gt;method_holder();
 442     if (!method_holder-&gt;is_interface()) {
 443       str-&gt;print(&quot; : in superclass&quot;);
 444     }
 445     str-&gt;cr();
 446   }
 447 
 448   void print_exception(outputStream* str, int indent) {
 449     assert(throws_exception(), &quot;Should be called otherwise&quot;);
 450     assert(_exception_name != NULL, &quot;exception_name should be set&quot;);
 451     streamIndentor si(str, indent * 2);
 452     str-&gt;indent().print_cr(&quot;%s: %s&quot;, _exception_name-&gt;as_C_string(), _exception_message-&gt;as_C_string());
 453   }
 454 };
 455 
 456 Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {
<span class="line-modified"> 457   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;);</span>
 458 }
 459 
 460 Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {
 461   stringStream ss;
 462   ss.print(&quot;Method &quot;);
 463   Symbol* name = method-&gt;name();
 464   Symbol* signature = method-&gt;signature();
 465   ss.write((const char*)klass_name-&gt;bytes(), klass_name-&gt;utf8_length());
 466   ss.print(&quot;.&quot;);
 467   ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());
 468   ss.write((const char*)signature-&gt;bytes(), signature-&gt;utf8_length());
 469   ss.print(&quot; is abstract&quot;);
<span class="line-modified"> 470   return SymbolTable::new_symbol(ss.base(), (int)ss.size());</span>
 471 }
 472 
<span class="line-modified"> 473 Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const {</span>
 474   stringStream ss;
 475   ss.print(&quot;Conflicting default methods:&quot;);
 476   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
<span class="line-modified"> 477     Method *method = methods-&gt;at(i)._method;</span>
<span class="line-modified"> 478     Symbol *klass = method-&gt;klass_name();</span>
<span class="line-modified"> 479     Symbol *name = method-&gt;name();</span>
 480     ss.print(&quot; &quot;);
<span class="line-modified"> 481     ss.write((const char*) klass-&gt;bytes(), klass-&gt;utf8_length());</span>
 482     ss.print(&quot;.&quot;);
<span class="line-modified"> 483     ss.write((const char*) name-&gt;bytes(), name-&gt;utf8_length());</span>
 484   }
<span class="line-modified"> 485   return SymbolTable::new_symbol(ss.base(), (int)ss.size());</span>
 486 }
 487 
 488 
<span class="line-modified"> 489 class StateRestorerScope;</span>
 490 
 491 // StatefulMethodFamily is a wrapper around a MethodFamily that maintains the
 492 // qualification state during hierarchy visitation, and applies that state
 493 // when adding members to the MethodFamily
 494 class StatefulMethodFamily : public ResourceObj {
 495   friend class StateRestorer;
 496  private:
 497   QualifiedState _qualification_state;
 498 
 499   void set_qualification_state(QualifiedState state) {
 500     _qualification_state = state;
 501   }
 502 
 503  protected:
 504   MethodFamily _method_family;
 505 
 506  public:
 507   StatefulMethodFamily() {
 508    _qualification_state = QUALIFIED;
 509   }
 510 
 511   void set_target_if_empty(Method* m) { _method_family.set_target_if_empty(m); }
 512 
 513   MethodFamily* get_method_family() { return &amp;_method_family; }
 514 
<span class="line-modified"> 515   void record_method_and_dq_further(StateRestorerScope* scope, Method* mo);</span>
 516 };
 517 
<span class="line-modified"> 518 // Because we use an iterative algorithm when iterating over the type</span>
<span class="line-modified"> 519 // hierarchy, we can&#39;t use traditional scoped objects which automatically do</span>
<span class="line-added"> 520 // cleanup in the destructor when the scope is exited.  StateRestorerScope (and</span>
<span class="line-added"> 521 // StateRestorer) provides a similar functionality, but for when you want a</span>
<span class="line-added"> 522 // scoped object in non-stack memory (such as in resource memory, as we do</span>
<span class="line-added"> 523 // here).  You&#39;ve just got to remember to call &#39;restore_state()&#39; on the scope when</span>
<span class="line-added"> 524 // leaving it (and marks have to be explicitly added). The scope is reusable after</span>
<span class="line-added"> 525 // &#39;restore_state()&#39; has been called.</span>
<span class="line-added"> 526 class StateRestorer : public ResourceObj {</span>
<span class="line-added"> 527  public:</span>
 528   StatefulMethodFamily* _method;
 529   QualifiedState _state_to_restore;
<span class="line-modified"> 530 </span>
<span class="line-modified"> 531   StateRestorer() : _method(NULL), _state_to_restore(DISQUALIFIED) {}</span>
<span class="line-modified"> 532 </span>

 533   void restore_state() { _method-&gt;set_qualification_state(_state_to_restore); }

 534 };
 535 
<span class="line-modified"> 536 class StateRestorerScope : public ResourceObj {</span>
<span class="line-modified"> 537  private:</span>
<span class="line-modified"> 538   GrowableArray&lt;StateRestorer*&gt;  _marks;</span>
<span class="line-modified"> 539   GrowableArray&lt;StateRestorer*&gt;* _free_list; // Shared between scopes</span>
<span class="line-modified"> 540  public:</span>
<span class="line-modified"> 541   StateRestorerScope(GrowableArray&lt;StateRestorer*&gt;* free_list) : _marks(), _free_list(free_list) {}</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543   static StateRestorerScope* cast(void* data) {</span>
<span class="line-added"> 544     return static_cast&lt;StateRestorerScope*&gt;(data);</span>
 545   }
<span class="line-added"> 546 </span>
<span class="line-added"> 547   void mark(StatefulMethodFamily* family, QualifiedState qualification_state) {</span>
<span class="line-added"> 548     StateRestorer* restorer;</span>
<span class="line-added"> 549     if (!_free_list-&gt;is_empty()) {</span>
<span class="line-added"> 550       restorer = _free_list-&gt;pop();</span>
<span class="line-added"> 551     } else {</span>
<span class="line-added"> 552       restorer = new StateRestorer();</span>
<span class="line-added"> 553     }</span>
<span class="line-added"> 554     restorer-&gt;_method = family;</span>
<span class="line-added"> 555     restorer-&gt;_state_to_restore = qualification_state;</span>
<span class="line-added"> 556     _marks.append(restorer);</span>
<span class="line-added"> 557   }</span>
<span class="line-added"> 558 </span>
<span class="line-added"> 559 #ifdef ASSERT</span>
<span class="line-added"> 560   bool is_empty() {</span>
<span class="line-added"> 561     return _marks.is_empty();</span>
<span class="line-added"> 562   }</span>
<span class="line-added"> 563 #endif</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565   void restore_state() {</span>
<span class="line-added"> 566     while(!_marks.is_empty()) {</span>
<span class="line-added"> 567       StateRestorer* restorer = _marks.pop();</span>
<span class="line-added"> 568       restorer-&gt;restore_state();</span>
<span class="line-added"> 569       _free_list-&gt;push(restorer);</span>
<span class="line-added"> 570     }</span>
<span class="line-added"> 571   }</span>
<span class="line-added"> 572 };</span>
<span class="line-added"> 573 </span>
<span class="line-added"> 574 void StatefulMethodFamily::record_method_and_dq_further(StateRestorerScope* scope, Method* mo) {</span>
<span class="line-added"> 575   scope-&gt;mark(this, _qualification_state);</span>
<span class="line-added"> 576   _method_family.record_method(mo, _qualification_state);</span>
<span class="line-added"> 577 </span>
 578   // Everything found &quot;above&quot;??? this method in the hierarchy walk is set to
 579   // disqualified
 580   set_qualification_state(DISQUALIFIED);

 581 }
 582 
 583 // Represents a location corresponding to a vtable slot for methods that
 584 // neither the class nor any of it&#39;s ancestors provide an implementaion.
 585 // Default methods may be present to fill this slot.
 586 class EmptyVtableSlot : public ResourceObj {
 587  private:
 588   Symbol* _name;
 589   Symbol* _signature;
 590   int _size_of_parameters;
 591   MethodFamily* _binding;
 592 
 593  public:
 594   EmptyVtableSlot(Method* method)
 595       : _name(method-&gt;name()), _signature(method-&gt;signature()),
 596         _size_of_parameters(method-&gt;size_of_parameters()), _binding(NULL) {}
 597 
 598   Symbol* name() const { return _name; }
 599   Symbol* signature() const { return _signature; }
 600   int size_of_parameters() const { return _size_of_parameters; }
</pre>
<hr />
<pre>
 678     ResourceMark rm;
 679     LogStream ls(lt);
 680     streamIndentor si(&amp;ls);
 681     for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 682       ls.indent();
 683       slots-&gt;at(i)-&gt;print_on(&amp;ls);
 684       ls.cr();
 685     }
 686   }
 687 }
 688 
 689 // Iterates over the superinterface type hierarchy looking for all methods
 690 // with a specific erased signature.
 691 class FindMethodsByErasedSig : public HierarchyVisitor&lt;FindMethodsByErasedSig&gt; {
 692  private:
 693   // Context data
 694   Symbol* _method_name;
 695   Symbol* _method_signature;
 696   StatefulMethodFamily*  _family;
 697   bool _cur_class_is_interface;
<span class="line-modified"> 698   // Free lists, used as an optimization</span>
<span class="line-added"> 699   GrowableArray&lt;StateRestorerScope*&gt; _free_scopes;</span>
<span class="line-added"> 700   GrowableArray&lt;StateRestorer*&gt; _free_restorers;</span>
 701  public:
<span class="line-modified"> 702   FindMethodsByErasedSig() : _free_scopes(6), _free_restorers(6) {};</span>
<span class="line-modified"> 703 </span>
<span class="line-modified"> 704   void prepare(Symbol* name, Symbol* signature, bool is_interf) {</span>
<span class="line-added"> 705     reset();</span>
<span class="line-added"> 706     _method_name = name;</span>
<span class="line-added"> 707     _method_signature = signature;</span>
<span class="line-added"> 708     _family = NULL;</span>
<span class="line-added"> 709     _cur_class_is_interface = is_interf;</span>
<span class="line-added"> 710   }</span>
 711 
 712   void get_discovered_family(MethodFamily** family) {
 713       if (_family != NULL) {
 714         *family = _family-&gt;get_method_family();
 715       } else {
 716         *family = NULL;
 717       }
 718   }
 719 
<span class="line-modified"> 720   void* new_node_data() {</span>
<span class="line-added"> 721     if (!_free_scopes.is_empty()) {</span>
<span class="line-added"> 722       StateRestorerScope* free_scope = _free_scopes.pop();</span>
<span class="line-added"> 723       assert(free_scope-&gt;is_empty(), &quot;StateRestorerScope::_marks array not empty&quot;);</span>
<span class="line-added"> 724       return free_scope;</span>
<span class="line-added"> 725     }</span>
<span class="line-added"> 726     return new StateRestorerScope(&amp;_free_restorers);</span>
<span class="line-added"> 727   }</span>
 728   void free_node_data(void* node_data) {
<span class="line-modified"> 729     StateRestorerScope* scope =  StateRestorerScope::cast(node_data);</span>
<span class="line-added"> 730     scope-&gt;restore_state();</span>
<span class="line-added"> 731     // Reuse scopes</span>
<span class="line-added"> 732     _free_scopes.push(scope);</span>
 733   }
 734 
 735   // Find all methods on this hierarchy that match this
 736   // method&#39;s erased (name, signature)
 737   bool visit() {
<span class="line-modified"> 738     StateRestorerScope* scope = StateRestorerScope::cast(current_data());</span>
 739     InstanceKlass* iklass = current_class();
 740 
 741     Method* m = iklass-&gt;find_method(_method_name, _method_signature);
 742     // Private interface methods are not candidates for default methods.
 743     // invokespecial to private interface methods doesn&#39;t use default method logic.
 744     // Private class methods are not candidates for default methods.
 745     // Private methods do not override default methods, so need to perform
 746     // default method inheritance without including private methods.
 747     // The overpasses are your supertypes&#39; errors, we do not include them.
 748     // Non-public methods in java.lang.Object are not candidates for default
 749     // methods.
 750     // Future: take access controls into account for superclass methods
 751     if (m != NULL &amp;&amp; !m-&gt;is_static() &amp;&amp; !m-&gt;is_overpass() &amp;&amp; !m-&gt;is_private() &amp;&amp;
 752      (!_cur_class_is_interface || !SystemDictionary::is_nonpublic_Object_method(m))) {
 753       if (_family == NULL) {
 754         _family = new StatefulMethodFamily();
 755       }
 756 
 757       if (iklass-&gt;is_interface()) {
<span class="line-modified"> 758         _family-&gt;record_method_and_dq_further(scope, m);</span>

 759       } else {
 760         // This is the rule that methods in classes &quot;win&quot; (bad word) over
 761         // methods in interfaces. This works because of single inheritance.
 762         // Private methods in classes do not &quot;win&quot;, they will be found
 763         // first on searching, but overriding for invokevirtual needs
 764         // to find default method candidates for the same signature
 765         _family-&gt;set_target_if_empty(m);
 766       }
 767     }
 768     return true;
 769   }
 770 
 771 };
 772 
 773 
 774 
 775 static void create_defaults_and_exceptions(
 776     GrowableArray&lt;EmptyVtableSlot*&gt;* slots, InstanceKlass* klass, TRAPS);
 777 
 778 static void generate_erased_defaults(
<span class="line-modified"> 779     FindMethodsByErasedSig* visitor,</span>
<span class="line-added"> 780     InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {</span>
 781 
<span class="line-added"> 782   // the visitor needs to be initialized or re-initialized before use</span>
<span class="line-added"> 783   // - this facilitates reusing the same visitor instance on multiple</span>
<span class="line-added"> 784   // generation passes as an optimization</span>
<span class="line-added"> 785   visitor-&gt;prepare(slot-&gt;name(), slot-&gt;signature(), is_intf);</span>
 786   // sets up a set of methods with the same exact erased signature
<span class="line-modified"> 787   visitor-&gt;run(klass);</span>

 788 
 789   MethodFamily* family;
<span class="line-modified"> 790   visitor-&gt;get_discovered_family(&amp;family);</span>
 791   if (family != NULL) {
<span class="line-modified"> 792     family-&gt;determine_target_or_set_exception_message(klass, CHECK);</span>
 793     slot-&gt;bind_family(family);
 794   }
 795 }
 796 
 797 static void merge_in_new_methods(InstanceKlass* klass,
 798     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 799 static void create_default_methods( InstanceKlass* klass,
 800     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 801 
 802 // This is the guts of the default methods implementation.  This is called just
 803 // after the classfile has been parsed if some ancestor has default methods.
 804 //
 805 // First it finds any name/signature slots that need any implementation (either
 806 // because they are miranda or a superclass&#39;s implementation is an overpass
 807 // itself).  For each slot, iterate over the hierarchy, to see if they contain a
 808 // signature that matches the slot we are looking at.
 809 //
 810 // For each slot filled, we either record the default method candidate in the
 811 // klass default_methods list or, only to handle exception cases, we create an
 812 // overpass method that throws an exception and add it to the klass methods list.
</pre>
<hr />
<pre>
 827   constantPoolHandle cp(THREAD, klass-&gt;constants());
 828   KeepAliveRegistrar keepAlive(THREAD);
 829   KeepAliveVisitor loadKeepAlive(&amp;keepAlive);
 830   loadKeepAlive.run(klass);
 831 
 832   LogTarget(Debug, defaultmethods) lt;
 833   if (lt.is_enabled()) {
 834     ResourceMark rm;
 835     lt.print(&quot;%s %s requires default method processing&quot;,
 836              klass-&gt;is_interface() ? &quot;Interface&quot; : &quot;Class&quot;,
 837              klass-&gt;name()-&gt;as_klass_external_name());
 838     LogStream ls(lt);
 839     PrintHierarchy printer(&amp;ls);
 840     printer.run(klass);
 841   }
 842 
 843   GrowableArray&lt;EmptyVtableSlot*&gt; empty_slots;
 844   find_empty_vtable_slots(&amp;empty_slots, klass, mirandas, CHECK);
 845 
 846   if (empty_slots.length() &gt; 0) {
<span class="line-added"> 847     FindMethodsByErasedSig findMethodsByErasedSig;</span>
 848     for (int i = 0; i &lt; empty_slots.length(); ++i) {
 849       EmptyVtableSlot* slot = empty_slots.at(i);
 850       LogTarget(Debug, defaultmethods) lt;
 851       if (lt.is_enabled()) {
 852         LogStream ls(lt);
 853         streamIndentor si(&amp;ls, 2);
 854         ls.indent().print(&quot;Looking for default methods for slot &quot;);
 855         slot-&gt;print_on(&amp;ls);
 856         ls.cr();
 857       }
<span class="line-modified"> 858       generate_erased_defaults(&amp;findMethodsByErasedSig, klass, slot, klass-&gt;is_interface(), CHECK);</span>
 859     }
 860     log_debug(defaultmethods)(&quot;Creating defaults and overpasses...&quot;);
 861     create_defaults_and_exceptions(&amp;empty_slots, klass, CHECK);
 862   }
 863   log_debug(defaultmethods)(&quot;Default method processing complete&quot;);
 864 }
 865 
 866 static int assemble_method_error(
 867     BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message, TRAPS) {
 868 
 869   Symbol* init = vmSymbols::object_initializer_name();
 870   Symbol* sig = vmSymbols::string_void_signature();
 871 
 872   BytecodeAssembler assem(buffer, cp);
 873 
 874   assem._new(errorName);
 875   assem.dup();
 876   assem.load_string(message);
 877   assem.invokespecial(errorName, init, sig);
 878   assem.athrow();
</pre>
<hr />
<pre>
 884     BytecodeConstantPool* cp, BytecodeBuffer* bytecodes, Symbol* name,
 885     Symbol* sig, AccessFlags flags, int max_stack, int params,
 886     ConstMethod::MethodType mt, TRAPS) {
 887 
 888   address code_start = 0;
 889   int code_length = 0;
 890   InlineTableSizes sizes;
 891 
 892   if (bytecodes != NULL &amp;&amp; bytecodes-&gt;length() &gt; 0) {
 893     code_start = static_cast&lt;address&gt;(bytecodes-&gt;adr_at(0));
 894     code_length = bytecodes-&gt;length();
 895   }
 896 
 897   Method* m = Method::allocate(cp-&gt;pool_holder()-&gt;class_loader_data(),
 898                                code_length, flags, &amp;sizes,
 899                                mt, CHECK_NULL);
 900 
 901   m-&gt;set_constants(NULL); // This will get filled in later
 902   m-&gt;set_name_index(cp-&gt;utf8(name));
 903   m-&gt;set_signature_index(cp-&gt;utf8(sig));
<span class="line-modified"> 904   m-&gt;compute_from_signature(sig);</span>

 905   m-&gt;set_size_of_parameters(params);
 906   m-&gt;set_max_stack(max_stack);
 907   m-&gt;set_max_locals(params);
 908   m-&gt;constMethod()-&gt;set_stackmap_data(NULL);
 909   m-&gt;set_code(code_start);
 910 
 911   return m;
 912 }
 913 
 914 static void switchover_constant_pool(BytecodeConstantPool* bpool,
 915     InstanceKlass* klass, GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
 916 
 917   if (new_methods-&gt;length() &gt; 0) {
 918     ConstantPool* cp = bpool-&gt;create_constant_pool(CHECK);
 919     if (cp != klass-&gt;constants()) {
 920       // Copy resolved anonymous class into new constant pool.
 921       if (klass-&gt;is_unsafe_anonymous()) {
 922         cp-&gt;klass_at_put(klass-&gt;this_class_index(), klass);
 923       }
 924       klass-&gt;class_loader_data()-&gt;add_to_deallocate_list(klass-&gt;constants());
</pre>
<hr />
<pre>
 937 }
 938 
 939 // Create default_methods list for the current class.
 940 // With the VM only processing erased signatures, the VM only
 941 // creates an overpass in a conflict case or a case with no candidates.
 942 // This allows virtual methods to override the overpass, but ensures
 943 // that a local method search will find the exception rather than an abstract
 944 // or default method that is not a valid candidate.
 945 //
 946 // Note that if overpass method are ever created that are not exception
 947 // throwing methods then the loader constraint checking logic for vtable and
 948 // itable creation needs to be changed to check loader constraints for the
 949 // overpass methods that do not throw exceptions.
 950 static void create_defaults_and_exceptions(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 951     InstanceKlass* klass, TRAPS) {
 952 
 953   GrowableArray&lt;Method*&gt; overpasses;
 954   GrowableArray&lt;Method*&gt; defaults;
 955   BytecodeConstantPool bpool(klass-&gt;constants());
 956 
<span class="line-added"> 957   BytecodeBuffer* buffer = NULL; // Lazily create a reusable buffer</span>
 958   for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 959     EmptyVtableSlot* slot = slots-&gt;at(i);
 960 
 961     if (slot-&gt;is_bound()) {
 962       MethodFamily* method = slot-&gt;get_binding();

 963 
 964       LogTarget(Debug, defaultmethods) lt;
 965       if (lt.is_enabled()) {
 966         ResourceMark rm(THREAD);
 967         LogStream ls(lt);
 968         ls.print(&quot;for slot: &quot;);
 969         slot-&gt;print_on(&amp;ls);
 970         ls.cr();
 971         if (method-&gt;has_target()) {
 972           method-&gt;print_selected(&amp;ls, 1);
 973         } else if (method-&gt;throws_exception()) {
 974           method-&gt;print_exception(&amp;ls, 1);
 975         }
 976       }
 977 
 978       if (method-&gt;has_target()) {
 979         Method* selected = method-&gt;get_selected_target();
 980         if (selected-&gt;method_holder()-&gt;is_interface()) {
 981           assert(!selected-&gt;is_private(), &quot;pushing private interface method as default&quot;);
 982           defaults.push(selected);
 983         }
 984       } else if (method-&gt;throws_exception()) {
<span class="line-modified"> 985         if (buffer == NULL) {</span>
<span class="line-added"> 986           buffer = new BytecodeBuffer();</span>
<span class="line-added"> 987         } else {</span>
<span class="line-added"> 988           buffer-&gt;clear();</span>
<span class="line-added"> 989         }</span>
<span class="line-added"> 990         int max_stack = assemble_method_error(&amp;bpool, buffer,</span>
 991            method-&gt;get_exception_name(), method-&gt;get_exception_message(), CHECK);
 992         AccessFlags flags = accessFlags_from(
 993           JVM_ACC_PUBLIC | JVM_ACC_SYNTHETIC | JVM_ACC_BRIDGE);
<span class="line-modified"> 994         Method* m = new_method(&amp;bpool, buffer, slot-&gt;name(), slot-&gt;signature(),</span>
 995           flags, max_stack, slot-&gt;size_of_parameters(),
 996           ConstMethod::OVERPASS, CHECK);
 997         // We push to the methods list:
 998         // overpass methods which are exception throwing methods
 999         if (m != NULL) {
1000           overpasses.push(m);
1001         }
1002       }
1003     }
1004   }
1005 
1006 
1007   log_debug(defaultmethods)(&quot;Created %d overpass methods&quot;, overpasses.length());
1008   log_debug(defaultmethods)(&quot;Created %d default  methods&quot;, defaults.length());
1009 
1010   if (overpasses.length() &gt; 0) {
1011     switchover_constant_pool(&amp;bpool, klass, &amp;overpasses, CHECK);
1012     merge_in_new_methods(klass, &amp;overpasses, CHECK);
1013   }
1014   if (defaults.length() &gt; 0) {
</pre>
<hr />
<pre>
1056     prev = nv;
1057   }
1058 #endif
1059 }
1060 
1061 static void merge_in_new_methods(InstanceKlass* klass,
1062     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
1063 
1064   enum { ANNOTATIONS, PARAMETERS, DEFAULTS, NUM_ARRAYS };
1065 
1066   Array&lt;Method*&gt;* original_methods = klass-&gt;methods();
1067   Array&lt;int&gt;* original_ordering = klass-&gt;method_ordering();
1068   Array&lt;int&gt;* merged_ordering = Universe::the_empty_int_array();
1069 
1070   int new_size = klass-&gt;methods()-&gt;length() + new_methods-&gt;length();
1071 
1072   Array&lt;Method*&gt;* merged_methods = MetadataFactory::new_array&lt;Method*&gt;(
1073       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
1074 
1075   // original_ordering might be empty if this class has no methods of its own
<span class="line-modified">1076   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
1077     merged_ordering = MetadataFactory::new_array&lt;int&gt;(
1078         klass-&gt;class_loader_data(), new_size, CHECK);
1079   }
1080   int method_order_index = klass-&gt;methods()-&gt;length();
1081 
1082   sort_methods(new_methods);
1083 
1084   // Perform grand merge of existing methods and new methods
1085   int orig_idx = 0;
1086   int new_idx = 0;
1087 
1088   for (int i = 0; i &lt; new_size; ++i) {
1089     Method* orig_method = NULL;
1090     Method* new_method = NULL;
1091     if (orig_idx &lt; original_methods-&gt;length()) {
1092       orig_method = original_methods-&gt;at(orig_idx);
1093     }
1094     if (new_idx &lt; new_methods-&gt;length()) {
1095       new_method = new_methods-&gt;at(new_idx);
1096     }
</pre>
</td>
</tr>
</table>
<center><a href="compactHashtable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
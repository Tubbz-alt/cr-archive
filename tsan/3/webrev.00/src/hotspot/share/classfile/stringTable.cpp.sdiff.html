<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/stringTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackMapTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/stringTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/altHashing.hpp&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;classfile/stringTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;</span>
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/filemap.hpp&quot;
 38 #include &quot;memory/heapShared.inline.hpp&quot;
 39 #include &quot;memory/resourceArea.hpp&quot;
 40 #include &quot;memory/universe.hpp&quot;
 41 #include &quot;oops/access.inline.hpp&quot;

 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 44 #include &quot;oops/weakHandle.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/safepointVerifiers.hpp&quot;
 49 #include &quot;runtime/timerTrace.hpp&quot;
 50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 51 #include &quot;services/diagnosticCommand.hpp&quot;
 52 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 53 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
 54 #include &quot;utilities/macros.hpp&quot;

 55 
 56 // We prefer short chains of avg 2
 57 const double PREF_AVG_LIST_LEN = 2.0;
 58 // 2^24 is max size
 59 const size_t END_SIZE = 24;
<span class="line-modified"> 60 // If a chain gets to 32 something might be wrong</span>
<span class="line-modified"> 61 const size_t REHASH_LEN = 32;</span>
 62 // If we have as many dead items as 50% of the number of bucket
 63 const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;
 64 
 65 #if INCLUDE_CDS_JAVA_HEAP
 66 inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {
 67   assert(sizeof(narrowOop) == sizeof(offset), &quot;must be&quot;);
 68   narrowOop v = (narrowOop)offset;
 69   return HeapShared::decode_from_archive(v);
 70 }
 71 
 72 static CompactHashtable&lt;
 73   const jchar*, oop,
 74   read_string_from_compact_hashtable,
 75   java_lang_String::equals
 76 &gt; _shared_table;
 77 #endif
 78 
 79 // --------------------------------------------------------------------------
<span class="line-removed"> 80 StringTable* StringTable::_the_table = NULL;</span>
<span class="line-removed"> 81 volatile bool StringTable::_alt_hash = false;</span>
 82 












 83 static juint murmur_seed = 0;
 84 
 85 uintx hash_string(const jchar* s, int len, bool useAlt) {
 86   return  useAlt ?
 87     AltHashing::murmur3_32(murmur_seed, s, len) :
 88     java_lang_String::hash_code(s, len);
 89 }
 90 
<span class="line-modified"> 91 class StringTableConfig : public StringTableHash::BaseConfig {</span>
 92  private:
 93  public:
<span class="line-modified"> 94   static uintx get_hash(WeakHandle&lt;vm_string_table_data&gt; const&amp; value,</span>
<span class="line-modified"> 95                         bool* is_dead) {</span>

 96     EXCEPTION_MARK;
 97     oop val_oop = value.peek();
 98     if (val_oop == NULL) {
 99       *is_dead = true;
100       return 0;
101     }
102     *is_dead = false;
103     ResourceMark rm(THREAD);
104     // All String oops are hashed as unicode
105     int length;
106     jchar* chars = java_lang_String::as_unicode_string(val_oop, length, THREAD);
107     if (chars != NULL) {
<span class="line-modified">108       return hash_string(chars, length, StringTable::_alt_hash);</span>
109     }
110     vm_exit_out_of_memory(length, OOM_MALLOC_ERROR, &quot;get hash from oop&quot;);
111     return 0;
112   }
113   // We use default allocation/deallocation but counted
<span class="line-modified">114   static void* allocate_node(size_t size,</span>
<span class="line-removed">115                              WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
116     StringTable::item_added();
<span class="line-modified">117     return StringTableHash::BaseConfig::allocate_node(size, value);</span>
118   }
<span class="line-modified">119   static void free_node(void* memory,</span>
<span class="line-removed">120                         WeakHandle&lt;vm_string_table_data&gt; const&amp; value) {</span>
121     value.release();
<span class="line-modified">122     StringTableHash::BaseConfig::free_node(memory, value);</span>
123     StringTable::item_removed();
124   }
125 };
126 
127 class StringTableLookupJchar : StackObj {
128  private:
129   Thread* _thread;
130   uintx _hash;
131   int _len;
132   const jchar* _str;
133   Handle _found;
134 
135  public:
136   StringTableLookupJchar(Thread* thread, uintx hash, const jchar* key, int len)
137     : _thread(thread), _hash(hash), _len(len), _str(key) {
138   }
139   uintx get_hash() const {
140     return _hash;
141   }
142   bool equals(WeakHandle&lt;vm_string_table_data&gt;* value, bool* is_dead) {
</pre>
<hr />
<pre>
177       // dead oop, mark this hash dead for cleaning
178       *is_dead = true;
179       return false;
180     }
181     bool equals = java_lang_String::equals(_find(), val_oop);
182     if (!equals) {
183       return false;
184     }
185     // Need to resolve weak handle and Handleize through possible safepoint.
186     _found = Handle(_thread, value-&gt;resolve());
187     return true;
188   }
189 };
190 
191 static size_t ceil_log2(size_t val) {
192   size_t ret;
193   for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; val; ++ret);
194   return ret;
195 }
196 
<span class="line-modified">197 StringTable::StringTable() : _local_table(NULL), _current_size(0), _has_work(0),</span>
<span class="line-removed">198   _needs_rehashing(false), _weak_handles(NULL), _items_count(0), _uncleaned_items_count(0) {</span>
<span class="line-removed">199   _weak_handles = new OopStorage(&quot;StringTable weak&quot;,</span>
<span class="line-removed">200                                  StringTableWeakAlloc_lock,</span>
<span class="line-removed">201                                  StringTableWeakActive_lock);</span>
202   size_t start_size_log_2 = ceil_log2(StringTableSize);
203   _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
204   log_trace(stringtable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
205                          _current_size, start_size_log_2);
206   _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
207 }
208 
<span class="line-removed">209 void StringTable::update_needs_rehash(bool rehash) {</span>
<span class="line-removed">210   if (rehash) {</span>
<span class="line-removed">211     _needs_rehashing = true;</span>
<span class="line-removed">212   }</span>
<span class="line-removed">213 }</span>
<span class="line-removed">214 </span>
215 size_t StringTable::item_added() {
<span class="line-modified">216   return Atomic::add((size_t)1, &amp;(the_table()-&gt;_items_count));</span>
217 }
218 
219 size_t StringTable::add_items_to_clean(size_t ndead) {
<span class="line-modified">220   size_t total = Atomic::add((size_t)ndead, &amp;(the_table()-&gt;_uncleaned_items_count));</span>
221   log_trace(stringtable)(
222      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,
<span class="line-modified">223      the_table()-&gt;_uncleaned_items_count, ndead, total);</span>
224   return total;
225 }
226 
227 void StringTable::item_removed() {
<span class="line-modified">228   Atomic::add((size_t)-1, &amp;(the_table()-&gt;_items_count));</span>
229 }
230 
<span class="line-modified">231 double StringTable::get_load_factor() const {</span>
232   return (double)_items_count/_current_size;
233 }
234 
<span class="line-modified">235 double StringTable::get_dead_factor() const {</span>
236   return (double)_uncleaned_items_count/_current_size;
237 }
238 
239 size_t StringTable::table_size() {
240   return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
241 }
242 
243 void StringTable::trigger_concurrent_work() {
<span class="line-modified">244   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">245   the_table()-&gt;_has_work = true;</span>
246   Service_lock-&gt;notify_all();
247 }
248 
249 // Probing
250 oop StringTable::lookup(Symbol* symbol) {
251   ResourceMark rm;
252   int length;
253   jchar* chars = symbol-&gt;as_unicode(length);
254   return lookup(chars, length);
255 }
256 
257 oop StringTable::lookup(const jchar* name, int len) {
258   unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">259   oop string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
260   if (string != NULL) {
261     return string;
262   }
<span class="line-modified">263   if (StringTable::_alt_hash) {</span>
264     hash = hash_string(name, len, true);
265   }
<span class="line-modified">266   return StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
267 }
268 
269 class StringTableGet : public StackObj {
270   Thread* _thread;
271   Handle  _return;
272  public:
273   StringTableGet(Thread* thread) : _thread(thread) {}
274   void operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
275     oop result = val-&gt;resolve();
276     assert(result != NULL, &quot;Result should be reachable&quot;);
277     _return = Handle(_thread, result);
278   }
279   oop get_res_oop() {
280     return _return();
281   }
282 };
283 
284 oop StringTable::do_lookup(const jchar* name, int len, uintx hash) {
285   Thread* thread = Thread::current();
286   StringTableLookupJchar lookup(thread, hash, name, len);
</pre>
<hr />
<pre>
310   jchar* chars = java_lang_String::as_unicode_string(string, length,
311                                                      CHECK_NULL);
312   oop result = intern(h_string, chars, length, CHECK_NULL);
313   return result;
314 }
315 
316 oop StringTable::intern(const char* utf8_string, TRAPS) {
317   if (utf8_string == NULL) return NULL;
318   ResourceMark rm(THREAD);
319   int length = UTF8::unicode_length(utf8_string);
320   jchar* chars = NEW_RESOURCE_ARRAY(jchar, length);
321   UTF8::convert_to_unicode(utf8_string, chars, length);
322   Handle string;
323   oop result = intern(string, chars, length, CHECK_NULL);
324   return result;
325 }
326 
327 oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
328   // shared table always uses java_lang_String::hash_code
329   unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">330   oop found_string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span>
331   if (found_string != NULL) {
332     return found_string;
333   }
<span class="line-modified">334   if (StringTable::_alt_hash) {</span>
335     hash = hash_string(name, len, true);
336   }
<span class="line-modified">337   found_string = StringTable::the_table()-&gt;do_lookup(name, len, hash);</span>
338   if (found_string != NULL) {
339     return found_string;
340   }
<span class="line-modified">341   return StringTable::the_table()-&gt;do_intern(string_or_null_h, name, len,</span>
<span class="line-removed">342                                              hash, CHECK_NULL);</span>
343 }
344 
345 oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,
346                            int len, uintx hash, TRAPS) {
347   HandleMark hm(THREAD);  // cleanup strings created
348   Handle string_h;
349 
350   if (!string_or_null_h.is_null()) {
351     string_h = string_or_null_h;
352   } else {
353     string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
354   }
355 
356   // Deduplicate the string before it is interned. Note that we should never
357   // deduplicate a string after it has been interned. Doing so will counteract
358   // compiler optimizations done on e.g. interned string literals.
359   Universe::heap()-&gt;deduplicate_string(string_h());
360 
361   assert(java_lang_String::equals(string_h(), name, len),
362          &quot;string must be properly initialized&quot;);
363   assert(len == java_lang_String::length(string_h()), &quot;Must be same length&quot;);
364 
365   StringTableLookupOop lookup(THREAD, hash, string_h);
366   StringTableGet stg(THREAD);
367 
368   bool rehash_warning;
369   do {
<span class="line-modified">370     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-removed">371       update_needs_rehash(rehash_warning);</span>
<span class="line-removed">372       return stg.get_res_oop();</span>
<span class="line-removed">373     }</span>
374     WeakHandle&lt;vm_string_table_data&gt; wh = WeakHandle&lt;vm_string_table_data&gt;::create(string_h);
375     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.
376     if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) {
377       update_needs_rehash(rehash_warning);
378       return wh.resolve();
379     }






380   } while(true);
381 }
382 
<span class="line-removed">383 void StringTable::oops_do(OopClosure* f) {</span>
<span class="line-removed">384   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">385   StringTable::the_table()-&gt;_weak_handles-&gt;oops_do(f);</span>
<span class="line-removed">386 }</span>
<span class="line-removed">387 </span>
<span class="line-removed">388 void StringTable::possibly_parallel_oops_do(</span>
<span class="line-removed">389    OopStorage::ParState&lt;false /* concurrent */, false /* const */&gt;*</span>
<span class="line-removed">390    _par_state_string, OopClosure* f)</span>
<span class="line-removed">391 {</span>
<span class="line-removed">392   assert(f != NULL, &quot;No closure&quot;);</span>
<span class="line-removed">393   _par_state_string-&gt;oops_do(f);</span>
<span class="line-removed">394 }</span>
<span class="line-removed">395 </span>
396 // Concurrent work
397 void StringTable::grow(JavaThread* jt) {
398   StringTableHash::GrowTask gt(_local_table);
399   if (!gt.prepare(jt)) {
400     return;
401   }
402   log_trace(stringtable)(&quot;Started to grow&quot;);
403   {
404     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, stringtable, perf));
405     while (gt.do_task(jt)) {
406       gt.pause(jt);
407       {
408         ThreadBlockInVM tbivm(jt);
409       }
410       gt.cont(jt);
411     }
412   }
413   gt.done(jt);
414   _current_size = table_size();
415   log_debug(stringtable)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);
</pre>
<hr />
<pre>
461 
462 void StringTable::check_concurrent_work() {
463   if (_has_work) {
464     return;
465   }
466 
467   double load_factor = StringTable::get_load_factor();
468   double dead_factor = StringTable::get_dead_factor();
469   // We should clean/resize if we have more dead than alive,
470   // more items than preferred load factor or
471   // more dead items than water mark.
472   if ((dead_factor &gt; load_factor) ||
473       (load_factor &gt; PREF_AVG_LIST_LEN) ||
474       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {
475     log_debug(stringtable)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,
476                            load_factor, dead_factor);
477     trigger_concurrent_work();
478   }
479 }
480 
<span class="line-modified">481 void StringTable::concurrent_work(JavaThread* jt) {</span>
482   _has_work = false;
483   double load_factor = get_load_factor();
484   log_debug(stringtable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
485   // We prefer growing, since that also removes dead items
486   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
487     grow(jt);
488   } else {
489     clean_dead_entries(jt);
490   }
491 }
492 
<span class="line-removed">493 void StringTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-removed">494   StringTable::the_table()-&gt;concurrent_work(jt);</span>
<span class="line-removed">495 }</span>
<span class="line-removed">496 </span>
497 // Rehash
498 bool StringTable::do_rehash() {
499   if (!_local_table-&gt;is_safepoint_safe()) {
500     return false;
501   }
502 
<span class="line-modified">503   // We use max size</span>
<span class="line-modified">504   StringTableHash* new_table = new StringTableHash(END_SIZE, END_SIZE, REHASH_LEN);</span>

505   // Use alt hash from now on
506   _alt_hash = true;
507   if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
508     _alt_hash = false;
509     delete new_table;
510     return false;
511   }
512 
513   // free old table
514   delete _local_table;
515   _local_table = new_table;
516 
517   return true;
518 }
519 
<span class="line-modified">520 void StringTable::try_rehash_table() {</span>
521   static bool rehashed = false;
522   log_debug(stringtable)(&quot;Table imbalanced, rehashing called.&quot;);
523 
524   // Grow instead of rehash.
525   if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
526       !_local_table-&gt;is_max_size_reached()) {
527     log_debug(stringtable)(&quot;Choosing growing over rehashing.&quot;);
528     trigger_concurrent_work();
529     _needs_rehashing = false;
530     return;
531   }
532   // Already rehashed.
533   if (rehashed) {
534     log_warning(stringtable)(&quot;Rehashing already done, still long lists.&quot;);
535     trigger_concurrent_work();
536     _needs_rehashing = false;
537     return;
538   }
539 
540   murmur_seed = AltHashing::compute_seed();
541   {
542     if (do_rehash()) {
543       rehashed = true;
544     } else {
545       log_info(stringtable)(&quot;Resizes in progress rehashing skipped.&quot;);
546     }
547   }
548   _needs_rehashing = false;
549 }
550 
<span class="line-removed">551 void StringTable::rehash_table() {</span>
<span class="line-removed">552   StringTable::the_table()-&gt;try_rehash_table();</span>
<span class="line-removed">553 }</span>
<span class="line-removed">554 </span>
555 // Statistics
556 static int literal_size(oop obj) {
557   // NOTE: this would over-count if (pre-JDK8)
558   // java_lang_Class::has_offset_field() is true and the String.value array is
559   // shared by several Strings. However, starting from JDK8, the String.value
560   // array is not shared anymore.
561   if (obj == NULL) {
562     return 0;
563   } else if (obj-&gt;klass() == SystemDictionary::String_klass()) {
564     return (obj-&gt;size() + java_lang_String::value(obj)-&gt;size()) * HeapWordSize;
565   } else {
566     return obj-&gt;size();
567   }
568 }
569 
570 struct SizeFunc : StackObj {
571   size_t operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
572     oop s = val-&gt;peek();
573     if (s == NULL) {
574       // Dead
575       return 0;
576     }
577     return literal_size(s);
578   };
579 };
580 







581 void StringTable::print_table_statistics(outputStream* st,
582                                          const char* table_name) {
583   SizeFunc sz;
584   _local_table-&gt;statistics_to(Thread::current(), sz, st, table_name);
585 }
586 
587 // Verification
588 class VerifyStrings : StackObj {
589  public:
590   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
591     oop s = val-&gt;peek();
592     if (s != NULL) {
593       assert(java_lang_String::length(s) &gt;= 0, &quot;Length on string must work.&quot;);
594     }
595     return true;
596   };
597 };
598 
599 // This verification is part of Universe::verify() and needs to be quick.
600 void StringTable::verify() {
601   Thread* thr = Thread::current();
602   VerifyStrings vs;
<span class="line-modified">603   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vs)) {</span>
604     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
605   }
606 }
607 
608 // Verification and comp
609 class VerifyCompStrings : StackObj {
610   GrowableArray&lt;oop&gt;* _oops;
611  public:
612   size_t _errors;
613   VerifyCompStrings(GrowableArray&lt;oop&gt;* oops) : _oops(oops), _errors(0) {}
614   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
615     oop s = val-&gt;resolve();
616     if (s == NULL) {
617       return true;
618     }
619     int len = _oops-&gt;length();
620     for (int i = 0; i &lt; len; i++) {
621       bool eq = java_lang_String::equals(s, _oops-&gt;at(i));
622       assert(!eq, &quot;Duplicate strings&quot;);
623       if (eq) {
624         _errors++;
625       }
626     }
627     _oops-&gt;push(s);
628     return true;
629   };
630 };
631 
632 size_t StringTable::verify_and_compare_entries() {
633   Thread* thr = Thread::current();
634   GrowableArray&lt;oop&gt;* oops =
635     new (ResourceObj::C_HEAP, mtInternal)
<span class="line-modified">636       GrowableArray&lt;oop&gt;((int)the_table()-&gt;_current_size, true);</span>
637 
638   VerifyCompStrings vcs(oops);
<span class="line-modified">639   if (!the_table()-&gt;_local_table-&gt;try_scan(thr, vcs)) {</span>
640     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
641   }
642   delete oops;
643   return vcs._errors;
644 }
645 
646 // Dumping
647 class PrintString : StackObj {
648   Thread* _thr;
649   outputStream* _st;
650  public:
651   PrintString(Thread* thr, outputStream* st) : _thr(thr), _st(st) {}
652   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
653     oop s = val-&gt;peek();
654     if (s == NULL) {
655       return true;
656     }
657     typeArrayOop value     = java_lang_String::value_no_keepalive(s);
658     int          length    = java_lang_String::length(s);
659     bool         is_latin1 = java_lang_String::is_latin1(s);
</pre>
<hr />
<pre>
666       char* utf8_string;
667 
668       if (!is_latin1) {
669         jchar* chars = value-&gt;char_at_addr(0);
670         utf8_string = UNICODE::as_utf8(chars, utf8_length);
671       } else {
672         jbyte* bytes = value-&gt;byte_at_addr(0);
673         utf8_string = UNICODE::as_utf8(bytes, utf8_length);
674       }
675 
676       _st-&gt;print(&quot;%d: &quot;, utf8_length);
677       HashtableTextDump::put_utf8(_st, utf8_string, utf8_length);
678     }
679     _st-&gt;cr();
680     return true;
681   };
682 };
683 
684 void StringTable::dump(outputStream* st, bool verbose) {
685   if (!verbose) {
<span class="line-modified">686     the_table()-&gt;print_table_statistics(st, &quot;StringTable&quot;);</span>
687   } else {
688     Thread* thr = Thread::current();
689     ResourceMark rm(thr);
690     st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
691     PrintString ps(thr, st);
<span class="line-modified">692     if (!the_table()-&gt;_local_table-&gt;try_scan(thr, ps)) {</span>
693       st-&gt;print_cr(&quot;dump unavailable at this moment&quot;);
694     }
695   }
696 }
697 
698 // Utility for dumping strings
699 StringtableDCmd::StringtableDCmd(outputStream* output, bool heap) :
700                                  DCmdWithParser(output, heap),
701   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each string in the table&quot;,
702            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
703   _dcmdparser.add_dcmd_option(&amp;_verbose);
704 }
705 
706 void StringtableDCmd::execute(DCmdSource source, TRAPS) {
707   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpStrings,
708                          _verbose.value());
709   VMThread::execute(&amp;dumper);
710 }
711 
712 int StringtableDCmd::num_arguments() {
</pre>
<hr />
<pre>
743   }
744   new_s = HeapShared::archive_heap_object(s, THREAD);
745   if (new_s == NULL) {
746     return NULL;
747   }
748 
749   // adjust the pointer to the &#39;value&#39; field in the new String oop
750   java_lang_String::set_value_raw(new_s, new_v);
751   return new_s;
752 }
753 
754 struct CopyToArchive : StackObj {
755   CompactHashtableWriter* _writer;
756   CopyToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
757   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
758     oop s = val-&gt;peek();
759     if (s == NULL) {
760       return true;
761     }
762     unsigned int hash = java_lang_String::hash_code(s);
<span class="line-removed">763     if (hash == 0) {</span>
<span class="line-removed">764       // We do not archive Strings with a 0 hashcode because ......</span>
<span class="line-removed">765       return true;</span>
<span class="line-removed">766     }</span>
<span class="line-removed">767 </span>
<span class="line-removed">768     java_lang_String::set_hash(s, hash);</span>
769     oop new_s = StringTable::create_archived_string(s, Thread::current());
770     if (new_s == NULL) {
771       return true;
772     }
773 
774     val-&gt;replace(new_s);
775     // add to the compact table
776     _writer-&gt;add(hash, CompressedOops::encode(new_s));
777     return true;
778   }
779 };
780 
781 void StringTable::copy_shared_string_table(CompactHashtableWriter* writer) {
782   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
783 
784   CopyToArchive copy(writer);
<span class="line-modified">785   StringTable::the_table()-&gt;_local_table-&gt;do_safepoint_scan(copy);</span>
786 }
787 
788 void StringTable::write_to_archive() {
789   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
790 
791   _shared_table.reset();
<span class="line-modified">792   int num_buckets = CompactHashtableWriter::default_num_buckets(</span>
<span class="line-removed">793       StringTable::the_table()-&gt;_items_count);</span>
<span class="line-removed">794   CompactHashtableWriter writer(num_buckets,</span>
<span class="line-removed">795                                 &amp;MetaspaceShared::stats()-&gt;string);</span>
796 
797   // Copy the interned strings into the &quot;string space&quot; within the java heap
798   copy_shared_string_table(&amp;writer);
799   writer.dump(&amp;_shared_table, &quot;string&quot;);
800 }
801 
802 void StringTable::serialize_shared_table_header(SerializeClosure* soc) {
803   _shared_table.serialize_header(soc);
804 
805   if (soc-&gt;writing()) {
806     // Sanity. Make sure we don&#39;t use the shared table at dump time
807     _shared_table.reset();
808   } else if (!HeapShared::closed_archive_heap_region_mapped()) {
809     _shared_table.reset();
810   }
811 }
812 
813 class SharedStringIterator {
814   OopClosure* _oop_closure;
815 public:
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/altHashing.hpp&quot;
 27 #include &quot;classfile/compactHashtable.hpp&quot;
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;classfile/stringTable.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/filemap.hpp&quot;
 38 #include &quot;memory/heapShared.inline.hpp&quot;
 39 #include &quot;memory/resourceArea.hpp&quot;
 40 #include &quot;memory/universe.hpp&quot;
 41 #include &quot;oops/access.inline.hpp&quot;
<span class="line-added"> 42 #include &quot;oops/compressedOops.hpp&quot;</span>
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
 45 #include &quot;oops/weakHandle.inline.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;runtime/mutexLocker.hpp&quot;
 49 #include &quot;runtime/safepointVerifiers.hpp&quot;
 50 #include &quot;runtime/timerTrace.hpp&quot;
 51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 52 #include &quot;services/diagnosticCommand.hpp&quot;
 53 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 54 #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
 55 #include &quot;utilities/macros.hpp&quot;
<span class="line-added"> 56 #include &quot;utilities/utf8.hpp&quot;</span>
 57 
 58 // We prefer short chains of avg 2
 59 const double PREF_AVG_LIST_LEN = 2.0;
 60 // 2^24 is max size
 61 const size_t END_SIZE = 24;
<span class="line-modified"> 62 // If a chain gets to 100 something might be wrong</span>
<span class="line-modified"> 63 const size_t REHASH_LEN = 100;</span>
 64 // If we have as many dead items as 50% of the number of bucket
 65 const double CLEAN_DEAD_HIGH_WATER_MARK = 0.5;
 66 
 67 #if INCLUDE_CDS_JAVA_HEAP
 68 inline oop read_string_from_compact_hashtable(address base_address, u4 offset) {
 69   assert(sizeof(narrowOop) == sizeof(offset), &quot;must be&quot;);
 70   narrowOop v = (narrowOop)offset;
 71   return HeapShared::decode_from_archive(v);
 72 }
 73 
 74 static CompactHashtable&lt;
 75   const jchar*, oop,
 76   read_string_from_compact_hashtable,
 77   java_lang_String::equals
 78 &gt; _shared_table;
 79 #endif
 80 
 81 // --------------------------------------------------------------------------


 82 
<span class="line-added"> 83 typedef ConcurrentHashTable&lt;StringTableConfig, mtSymbol&gt; StringTableHash;</span>
<span class="line-added"> 84 static StringTableHash* _local_table = NULL;</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86 volatile bool StringTable::_has_work = false;</span>
<span class="line-added"> 87 volatile bool StringTable::_needs_rehashing = false;</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 volatile size_t StringTable::_uncleaned_items_count = 0;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91 static size_t _current_size = 0;</span>
<span class="line-added"> 92 static volatile size_t _items_count = 0;</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94 volatile bool _alt_hash = false;</span>
 95 static juint murmur_seed = 0;
 96 
 97 uintx hash_string(const jchar* s, int len, bool useAlt) {
 98   return  useAlt ?
 99     AltHashing::murmur3_32(murmur_seed, s, len) :
100     java_lang_String::hash_code(s, len);
101 }
102 
<span class="line-modified">103 class StringTableConfig : public StackObj {</span>
104  private:
105  public:
<span class="line-modified">106   typedef WeakHandle&lt;vm_string_table_data&gt; Value;</span>
<span class="line-modified">107 </span>
<span class="line-added">108   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
109     EXCEPTION_MARK;
110     oop val_oop = value.peek();
111     if (val_oop == NULL) {
112       *is_dead = true;
113       return 0;
114     }
115     *is_dead = false;
116     ResourceMark rm(THREAD);
117     // All String oops are hashed as unicode
118     int length;
119     jchar* chars = java_lang_String::as_unicode_string(val_oop, length, THREAD);
120     if (chars != NULL) {
<span class="line-modified">121       return hash_string(chars, length, _alt_hash);</span>
122     }
123     vm_exit_out_of_memory(length, OOM_MALLOC_ERROR, &quot;get hash from oop&quot;);
124     return 0;
125   }
126   // We use default allocation/deallocation but counted
<span class="line-modified">127   static void* allocate_node(size_t size, Value const&amp; value) {</span>

128     StringTable::item_added();
<span class="line-modified">129     return AllocateHeap(size, mtSymbol);</span>
130   }
<span class="line-modified">131   static void free_node(void* memory, Value const&amp; value) {</span>

132     value.release();
<span class="line-modified">133     FreeHeap(memory);</span>
134     StringTable::item_removed();
135   }
136 };
137 
138 class StringTableLookupJchar : StackObj {
139  private:
140   Thread* _thread;
141   uintx _hash;
142   int _len;
143   const jchar* _str;
144   Handle _found;
145 
146  public:
147   StringTableLookupJchar(Thread* thread, uintx hash, const jchar* key, int len)
148     : _thread(thread), _hash(hash), _len(len), _str(key) {
149   }
150   uintx get_hash() const {
151     return _hash;
152   }
153   bool equals(WeakHandle&lt;vm_string_table_data&gt;* value, bool* is_dead) {
</pre>
<hr />
<pre>
188       // dead oop, mark this hash dead for cleaning
189       *is_dead = true;
190       return false;
191     }
192     bool equals = java_lang_String::equals(_find(), val_oop);
193     if (!equals) {
194       return false;
195     }
196     // Need to resolve weak handle and Handleize through possible safepoint.
197     _found = Handle(_thread, value-&gt;resolve());
198     return true;
199   }
200 };
201 
202 static size_t ceil_log2(size_t val) {
203   size_t ret;
204   for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; val; ++ret);
205   return ret;
206 }
207 
<span class="line-modified">208 void StringTable::create_table() {</span>




209   size_t start_size_log_2 = ceil_log2(StringTableSize);
210   _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
211   log_trace(stringtable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
212                          _current_size, start_size_log_2);
213   _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
214 }
215 






216 size_t StringTable::item_added() {
<span class="line-modified">217   return Atomic::add(&amp;_items_count, (size_t)1);</span>
218 }
219 
220 size_t StringTable::add_items_to_clean(size_t ndead) {
<span class="line-modified">221   size_t total = Atomic::add(&amp;_uncleaned_items_count, (size_t)ndead);</span>
222   log_trace(stringtable)(
223      &quot;Uncleaned items:&quot; SIZE_FORMAT &quot; added: &quot; SIZE_FORMAT &quot; total:&quot; SIZE_FORMAT,
<span class="line-modified">224      _uncleaned_items_count, ndead, total);</span>
225   return total;
226 }
227 
228 void StringTable::item_removed() {
<span class="line-modified">229   Atomic::add(&amp;_items_count, (size_t)-1);</span>
230 }
231 
<span class="line-modified">232 double StringTable::get_load_factor() {</span>
233   return (double)_items_count/_current_size;
234 }
235 
<span class="line-modified">236 double StringTable::get_dead_factor() {</span>
237   return (double)_uncleaned_items_count/_current_size;
238 }
239 
240 size_t StringTable::table_size() {
241   return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
242 }
243 
244 void StringTable::trigger_concurrent_work() {
<span class="line-modified">245   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">246   _has_work = true;</span>
247   Service_lock-&gt;notify_all();
248 }
249 
250 // Probing
251 oop StringTable::lookup(Symbol* symbol) {
252   ResourceMark rm;
253   int length;
254   jchar* chars = symbol-&gt;as_unicode(length);
255   return lookup(chars, length);
256 }
257 
258 oop StringTable::lookup(const jchar* name, int len) {
259   unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">260   oop string = lookup_shared(name, len, hash);</span>
261   if (string != NULL) {
262     return string;
263   }
<span class="line-modified">264   if (_alt_hash) {</span>
265     hash = hash_string(name, len, true);
266   }
<span class="line-modified">267   return do_lookup(name, len, hash);</span>
268 }
269 
270 class StringTableGet : public StackObj {
271   Thread* _thread;
272   Handle  _return;
273  public:
274   StringTableGet(Thread* thread) : _thread(thread) {}
275   void operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
276     oop result = val-&gt;resolve();
277     assert(result != NULL, &quot;Result should be reachable&quot;);
278     _return = Handle(_thread, result);
279   }
280   oop get_res_oop() {
281     return _return();
282   }
283 };
284 
285 oop StringTable::do_lookup(const jchar* name, int len, uintx hash) {
286   Thread* thread = Thread::current();
287   StringTableLookupJchar lookup(thread, hash, name, len);
</pre>
<hr />
<pre>
311   jchar* chars = java_lang_String::as_unicode_string(string, length,
312                                                      CHECK_NULL);
313   oop result = intern(h_string, chars, length, CHECK_NULL);
314   return result;
315 }
316 
317 oop StringTable::intern(const char* utf8_string, TRAPS) {
318   if (utf8_string == NULL) return NULL;
319   ResourceMark rm(THREAD);
320   int length = UTF8::unicode_length(utf8_string);
321   jchar* chars = NEW_RESOURCE_ARRAY(jchar, length);
322   UTF8::convert_to_unicode(utf8_string, chars, length);
323   Handle string;
324   oop result = intern(string, chars, length, CHECK_NULL);
325   return result;
326 }
327 
328 oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
329   // shared table always uses java_lang_String::hash_code
330   unsigned int hash = java_lang_String::hash_code(name, len);
<span class="line-modified">331   oop found_string = lookup_shared(name, len, hash);</span>
332   if (found_string != NULL) {
333     return found_string;
334   }
<span class="line-modified">335   if (_alt_hash) {</span>
336     hash = hash_string(name, len, true);
337   }
<span class="line-modified">338   found_string = do_lookup(name, len, hash);</span>
339   if (found_string != NULL) {
340     return found_string;
341   }
<span class="line-modified">342   return do_intern(string_or_null_h, name, len, hash, THREAD);</span>

343 }
344 
345 oop StringTable::do_intern(Handle string_or_null_h, const jchar* name,
346                            int len, uintx hash, TRAPS) {
347   HandleMark hm(THREAD);  // cleanup strings created
348   Handle string_h;
349 
350   if (!string_or_null_h.is_null()) {
351     string_h = string_or_null_h;
352   } else {
353     string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
354   }
355 
356   // Deduplicate the string before it is interned. Note that we should never
357   // deduplicate a string after it has been interned. Doing so will counteract
358   // compiler optimizations done on e.g. interned string literals.
359   Universe::heap()-&gt;deduplicate_string(string_h());
360 
361   assert(java_lang_String::equals(string_h(), name, len),
362          &quot;string must be properly initialized&quot;);
363   assert(len == java_lang_String::length(string_h()), &quot;Must be same length&quot;);
364 
365   StringTableLookupOop lookup(THREAD, hash, string_h);
366   StringTableGet stg(THREAD);
367 
368   bool rehash_warning;
369   do {
<span class="line-modified">370     // Callers have already looked up the String using the jchar* name, so just go to add.</span>



371     WeakHandle&lt;vm_string_table_data&gt; wh = WeakHandle&lt;vm_string_table_data&gt;::create(string_h);
372     // The hash table takes ownership of the WeakHandle, even if it&#39;s not inserted.
373     if (_local_table-&gt;insert(THREAD, lookup, wh, &amp;rehash_warning)) {
374       update_needs_rehash(rehash_warning);
375       return wh.resolve();
376     }
<span class="line-added">377     // In case another thread did a concurrent add, return value already in the table.</span>
<span class="line-added">378     // This could fail if the String got gc&#39;ed concurrently, so loop back until success.</span>
<span class="line-added">379     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-added">380       update_needs_rehash(rehash_warning);</span>
<span class="line-added">381       return stg.get_res_oop();</span>
<span class="line-added">382     }</span>
383   } while(true);
384 }
385 













386 // Concurrent work
387 void StringTable::grow(JavaThread* jt) {
388   StringTableHash::GrowTask gt(_local_table);
389   if (!gt.prepare(jt)) {
390     return;
391   }
392   log_trace(stringtable)(&quot;Started to grow&quot;);
393   {
394     TraceTime timer(&quot;Grow&quot;, TRACETIME_LOG(Debug, stringtable, perf));
395     while (gt.do_task(jt)) {
396       gt.pause(jt);
397       {
398         ThreadBlockInVM tbivm(jt);
399       }
400       gt.cont(jt);
401     }
402   }
403   gt.done(jt);
404   _current_size = table_size();
405   log_debug(stringtable)(&quot;Grown to size:&quot; SIZE_FORMAT, _current_size);
</pre>
<hr />
<pre>
451 
452 void StringTable::check_concurrent_work() {
453   if (_has_work) {
454     return;
455   }
456 
457   double load_factor = StringTable::get_load_factor();
458   double dead_factor = StringTable::get_dead_factor();
459   // We should clean/resize if we have more dead than alive,
460   // more items than preferred load factor or
461   // more dead items than water mark.
462   if ((dead_factor &gt; load_factor) ||
463       (load_factor &gt; PREF_AVG_LIST_LEN) ||
464       (dead_factor &gt; CLEAN_DEAD_HIGH_WATER_MARK)) {
465     log_debug(stringtable)(&quot;Concurrent work triggered, live factor: %g dead factor: %g&quot;,
466                            load_factor, dead_factor);
467     trigger_concurrent_work();
468   }
469 }
470 
<span class="line-modified">471 void StringTable::do_concurrent_work(JavaThread* jt) {</span>
472   _has_work = false;
473   double load_factor = get_load_factor();
474   log_debug(stringtable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
475   // We prefer growing, since that also removes dead items
476   if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
477     grow(jt);
478   } else {
479     clean_dead_entries(jt);
480   }
481 }
482 




483 // Rehash
484 bool StringTable::do_rehash() {
485   if (!_local_table-&gt;is_safepoint_safe()) {
486     return false;
487   }
488 
<span class="line-modified">489   // We use current size, not max size.</span>
<span class="line-modified">490   size_t new_size = _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="line-added">491   StringTableHash* new_table = new StringTableHash(new_size, END_SIZE, REHASH_LEN);</span>
492   // Use alt hash from now on
493   _alt_hash = true;
494   if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
495     _alt_hash = false;
496     delete new_table;
497     return false;
498   }
499 
500   // free old table
501   delete _local_table;
502   _local_table = new_table;
503 
504   return true;
505 }
506 
<span class="line-modified">507 void StringTable::rehash_table() {</span>
508   static bool rehashed = false;
509   log_debug(stringtable)(&quot;Table imbalanced, rehashing called.&quot;);
510 
511   // Grow instead of rehash.
512   if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
513       !_local_table-&gt;is_max_size_reached()) {
514     log_debug(stringtable)(&quot;Choosing growing over rehashing.&quot;);
515     trigger_concurrent_work();
516     _needs_rehashing = false;
517     return;
518   }
519   // Already rehashed.
520   if (rehashed) {
521     log_warning(stringtable)(&quot;Rehashing already done, still long lists.&quot;);
522     trigger_concurrent_work();
523     _needs_rehashing = false;
524     return;
525   }
526 
527   murmur_seed = AltHashing::compute_seed();
528   {
529     if (do_rehash()) {
530       rehashed = true;
531     } else {
532       log_info(stringtable)(&quot;Resizes in progress rehashing skipped.&quot;);
533     }
534   }
535   _needs_rehashing = false;
536 }
537 




538 // Statistics
539 static int literal_size(oop obj) {
540   // NOTE: this would over-count if (pre-JDK8)
541   // java_lang_Class::has_offset_field() is true and the String.value array is
542   // shared by several Strings. However, starting from JDK8, the String.value
543   // array is not shared anymore.
544   if (obj == NULL) {
545     return 0;
546   } else if (obj-&gt;klass() == SystemDictionary::String_klass()) {
547     return (obj-&gt;size() + java_lang_String::value(obj)-&gt;size()) * HeapWordSize;
548   } else {
549     return obj-&gt;size();
550   }
551 }
552 
553 struct SizeFunc : StackObj {
554   size_t operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
555     oop s = val-&gt;peek();
556     if (s == NULL) {
557       // Dead
558       return 0;
559     }
560     return literal_size(s);
561   };
562 };
563 
<span class="line-added">564 TableStatistics StringTable::get_table_statistics() {</span>
<span class="line-added">565   static TableStatistics ts;</span>
<span class="line-added">566   SizeFunc sz;</span>
<span class="line-added">567   ts = _local_table-&gt;statistics_get(Thread::current(), sz, ts);</span>
<span class="line-added">568   return ts;</span>
<span class="line-added">569 }</span>
<span class="line-added">570 </span>
571 void StringTable::print_table_statistics(outputStream* st,
572                                          const char* table_name) {
573   SizeFunc sz;
574   _local_table-&gt;statistics_to(Thread::current(), sz, st, table_name);
575 }
576 
577 // Verification
578 class VerifyStrings : StackObj {
579  public:
580   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
581     oop s = val-&gt;peek();
582     if (s != NULL) {
583       assert(java_lang_String::length(s) &gt;= 0, &quot;Length on string must work.&quot;);
584     }
585     return true;
586   };
587 };
588 
589 // This verification is part of Universe::verify() and needs to be quick.
590 void StringTable::verify() {
591   Thread* thr = Thread::current();
592   VerifyStrings vs;
<span class="line-modified">593   if (!_local_table-&gt;try_scan(thr, vs)) {</span>
594     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
595   }
596 }
597 
598 // Verification and comp
599 class VerifyCompStrings : StackObj {
600   GrowableArray&lt;oop&gt;* _oops;
601  public:
602   size_t _errors;
603   VerifyCompStrings(GrowableArray&lt;oop&gt;* oops) : _oops(oops), _errors(0) {}
604   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
605     oop s = val-&gt;resolve();
606     if (s == NULL) {
607       return true;
608     }
609     int len = _oops-&gt;length();
610     for (int i = 0; i &lt; len; i++) {
611       bool eq = java_lang_String::equals(s, _oops-&gt;at(i));
612       assert(!eq, &quot;Duplicate strings&quot;);
613       if (eq) {
614         _errors++;
615       }
616     }
617     _oops-&gt;push(s);
618     return true;
619   };
620 };
621 
622 size_t StringTable::verify_and_compare_entries() {
623   Thread* thr = Thread::current();
624   GrowableArray&lt;oop&gt;* oops =
625     new (ResourceObj::C_HEAP, mtInternal)
<span class="line-modified">626       GrowableArray&lt;oop&gt;((int)_current_size, true);</span>
627 
628   VerifyCompStrings vcs(oops);
<span class="line-modified">629   if (!_local_table-&gt;try_scan(thr, vcs)) {</span>
630     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);
631   }
632   delete oops;
633   return vcs._errors;
634 }
635 
636 // Dumping
637 class PrintString : StackObj {
638   Thread* _thr;
639   outputStream* _st;
640  public:
641   PrintString(Thread* thr, outputStream* st) : _thr(thr), _st(st) {}
642   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
643     oop s = val-&gt;peek();
644     if (s == NULL) {
645       return true;
646     }
647     typeArrayOop value     = java_lang_String::value_no_keepalive(s);
648     int          length    = java_lang_String::length(s);
649     bool         is_latin1 = java_lang_String::is_latin1(s);
</pre>
<hr />
<pre>
656       char* utf8_string;
657 
658       if (!is_latin1) {
659         jchar* chars = value-&gt;char_at_addr(0);
660         utf8_string = UNICODE::as_utf8(chars, utf8_length);
661       } else {
662         jbyte* bytes = value-&gt;byte_at_addr(0);
663         utf8_string = UNICODE::as_utf8(bytes, utf8_length);
664       }
665 
666       _st-&gt;print(&quot;%d: &quot;, utf8_length);
667       HashtableTextDump::put_utf8(_st, utf8_string, utf8_length);
668     }
669     _st-&gt;cr();
670     return true;
671   };
672 };
673 
674 void StringTable::dump(outputStream* st, bool verbose) {
675   if (!verbose) {
<span class="line-modified">676     print_table_statistics(st, &quot;StringTable&quot;);</span>
677   } else {
678     Thread* thr = Thread::current();
679     ResourceMark rm(thr);
680     st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
681     PrintString ps(thr, st);
<span class="line-modified">682     if (!_local_table-&gt;try_scan(thr, ps)) {</span>
683       st-&gt;print_cr(&quot;dump unavailable at this moment&quot;);
684     }
685   }
686 }
687 
688 // Utility for dumping strings
689 StringtableDCmd::StringtableDCmd(outputStream* output, bool heap) :
690                                  DCmdWithParser(output, heap),
691   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each string in the table&quot;,
692            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
693   _dcmdparser.add_dcmd_option(&amp;_verbose);
694 }
695 
696 void StringtableDCmd::execute(DCmdSource source, TRAPS) {
697   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpStrings,
698                          _verbose.value());
699   VMThread::execute(&amp;dumper);
700 }
701 
702 int StringtableDCmd::num_arguments() {
</pre>
<hr />
<pre>
733   }
734   new_s = HeapShared::archive_heap_object(s, THREAD);
735   if (new_s == NULL) {
736     return NULL;
737   }
738 
739   // adjust the pointer to the &#39;value&#39; field in the new String oop
740   java_lang_String::set_value_raw(new_s, new_v);
741   return new_s;
742 }
743 
744 struct CopyToArchive : StackObj {
745   CompactHashtableWriter* _writer;
746   CopyToArchive(CompactHashtableWriter* writer) : _writer(writer) {}
747   bool operator()(WeakHandle&lt;vm_string_table_data&gt;* val) {
748     oop s = val-&gt;peek();
749     if (s == NULL) {
750       return true;
751     }
752     unsigned int hash = java_lang_String::hash_code(s);






753     oop new_s = StringTable::create_archived_string(s, Thread::current());
754     if (new_s == NULL) {
755       return true;
756     }
757 
758     val-&gt;replace(new_s);
759     // add to the compact table
760     _writer-&gt;add(hash, CompressedOops::encode(new_s));
761     return true;
762   }
763 };
764 
765 void StringTable::copy_shared_string_table(CompactHashtableWriter* writer) {
766   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
767 
768   CopyToArchive copy(writer);
<span class="line-modified">769   _local_table-&gt;do_safepoint_scan(copy);</span>
770 }
771 
772 void StringTable::write_to_archive() {
773   assert(HeapShared::is_heap_object_archiving_allowed(), &quot;must be&quot;);
774 
775   _shared_table.reset();
<span class="line-modified">776   CompactHashtableWriter writer(_items_count, &amp;MetaspaceShared::stats()-&gt;string);</span>



777 
778   // Copy the interned strings into the &quot;string space&quot; within the java heap
779   copy_shared_string_table(&amp;writer);
780   writer.dump(&amp;_shared_table, &quot;string&quot;);
781 }
782 
783 void StringTable::serialize_shared_table_header(SerializeClosure* soc) {
784   _shared_table.serialize_header(soc);
785 
786   if (soc-&gt;writing()) {
787     // Sanity. Make sure we don&#39;t use the shared table at dump time
788     _shared_table.reset();
789   } else if (!HeapShared::closed_archive_heap_region_mapped()) {
790     _shared_table.reset();
791   }
792 }
793 
794 class SharedStringIterator {
795   OopClosure* _oop_closure;
796 public:
</pre>
</td>
</tr>
</table>
<center><a href="stackMapTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,15 ***</span>
<span class="line-new-header">--- 36,18 ---</span>
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #include &quot;classfile/verificationType.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;memory/archiveUtils.hpp&quot;</span>
  #include &quot;memory/filemap.hpp&quot;
  #include &quot;memory/metadataFactory.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;memory/dynamicArchive.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,13 ***</span>
  
  
  objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
<span class="line-modified">! DEBUG_ONLY(bool SystemDictionaryShared::_checked_excluded_classes = false;)</span>
  
  class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  public:
    struct DTConstraint {
      Symbol* _name;
      Symbol* _from_name;
      DTConstraint() : _name(NULL), _from_name(NULL) {}
<span class="line-new-header">--- 61,14 ---</span>
  
  
  objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
<span class="line-modified">! DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)</span>
  
  class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
<span class="line-added">+   bool                         _excluded;</span>
  public:
    struct DTConstraint {
      Symbol* _name;
      Symbol* _from_name;
      DTConstraint() : _name(NULL), _from_name(NULL) {}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,11 ***</span>
  
    InstanceKlass*               _klass;
    int                          _id;
    int                          _clsfile_size;
    int                          _clsfile_crc32;
<span class="line-removed">-   bool                         _excluded;</span>
    GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
    GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  
    DumpTimeSharedClassInfo() {
      _klass = NULL;
<span class="line-new-header">--- 77,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 115,19 ---</span>
          it-&gt;push(&amp;cons-&gt;_name);
          it-&gt;push(&amp;cons-&gt;_from_name);
        }
      }
    }
<span class="line-added">+ </span>
<span class="line-added">+   void set_excluded() {</span>
<span class="line-added">+     _excluded = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_excluded() {</span>
<span class="line-added">+     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null</span>
<span class="line-added">+     return _excluded || _klass == NULL;</span>
<span class="line-added">+   }</span>
  };
  
  class DumpTimeSharedClassTable: public ResourceHashtable&lt;
    InstanceKlass*,
    DumpTimeSharedClassInfo,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,12 ***</span>
    int _unregistered_count;
  public:
    DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
      DumpTimeSharedClassInfo* p = get(k);
      if (p == NULL) {
<span class="line-modified">!       assert(!SystemDictionaryShared::checked_excluded_classes(),</span>
<span class="line-modified">!              &quot;no new classes can be added after check_excluded_classes&quot;);</span>
        put(k, DumpTimeSharedClassInfo());
        p = get(k);
        assert(p != NULL, &quot;sanity&quot;);
        p-&gt;_klass = k;
      }
<span class="line-new-header">--- 140,12 ---</span>
    int _unregistered_count;
  public:
    DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
      DumpTimeSharedClassInfo* p = get(k);
      if (p == NULL) {
<span class="line-modified">!       assert(!SystemDictionaryShared::no_class_loading_should_happen(),</span>
<span class="line-modified">!              &quot;no new classes can be loaded while dumping archive&quot;);</span>
        put(k, DumpTimeSharedClassInfo());
        p = get(k);
        assert(p != NULL, &quot;sanity&quot;);
        p-&gt;_klass = k;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,20 ***</span>
    class CountClassByCategory : StackObj {
      DumpTimeSharedClassTable* _table;
    public:
      CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
      bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!       if (SystemDictionaryShared::is_builtin(k)) {</span>
<span class="line-modified">!         ++ _table-&gt;_builtin_count;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         ++ _table-&gt;_unregistered_count;</span>
        }
        return true; // keep on iterating
      }
    };
  
    void update_counts() {
      CountClassByCategory counter(this);
      iterate(&amp;counter);
    }
  
    int count_of(bool is_builtin) const {
<span class="line-new-header">--- 155,24 ---</span>
    class CountClassByCategory : StackObj {
      DumpTimeSharedClassTable* _table;
    public:
      CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
      bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!       if (!info.is_excluded()) {</span>
<span class="line-modified">!         if (info.is_builtin()) {</span>
<span class="line-modified">!           ++ _table-&gt;_builtin_count;</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+           ++ _table-&gt;_unregistered_count;</span>
<span class="line-added">+         }</span>
        }
        return true; // keep on iterating
      }
    };
  
    void update_counts() {
<span class="line-added">+     _builtin_count = 0;</span>
<span class="line-added">+     _unregistered_count = 0;</span>
      CountClassByCategory counter(this);
      iterate(&amp;counter);
    }
  
    int count_of(bool is_builtin) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,30 ***</span>
    char* verifier_constraint_flags() {
      assert(_num_constraints &gt; 0, &quot;sanity&quot;);
      return (char*)(address(this) + verifier_constraint_flags_offset());
    }
  
    void init(DumpTimeSharedClassInfo&amp; info) {
      _klass = info._klass;
<span class="line-removed">-     _num_constraints = info.num_constraints();</span>
      if (!SystemDictionaryShared::is_builtin(_klass)) {
        CrcInfo* c = crc();
        c-&gt;_clsfile_size = info._clsfile_size;
        c-&gt;_clsfile_crc32 = info._clsfile_crc32;
      }
      if (_num_constraints &gt; 0) {
        RTConstraint* constraints = verifier_constraints();
        char* flags = verifier_constraint_flags();
        int i;
        for (i = 0; i &lt; _num_constraints; i++) {
<span class="line-modified">!         constraints[i]._name      = MetaspaceShared::object_delta_u4(info._verifier_constraints-&gt;at(i)._name);</span>
<span class="line-modified">!         constraints[i]._from_name = MetaspaceShared::object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);</span>
        }
        for (i = 0; i &lt; _num_constraints; i++) {
          flags[i] = info._verifier_constraint_flags-&gt;at(i);
        }
      }
    }
  
    bool matches(int clsfile_size, int clsfile_crc32) const {
      return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
             crc()-&gt;_clsfile_crc32 == clsfile_crc32;
<span class="line-new-header">--- 263,41 ---</span>
    char* verifier_constraint_flags() {
      assert(_num_constraints &gt; 0, &quot;sanity&quot;);
      return (char*)(address(this) + verifier_constraint_flags_offset());
    }
  
<span class="line-added">+   static u4 object_delta_u4(Symbol* sym) {</span>
<span class="line-added">+     if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+       sym = DynamicArchive::original_to_target(sym);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return MetaspaceShared::object_delta_u4(sym);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void init(DumpTimeSharedClassInfo&amp; info) {
      _klass = info._klass;
      if (!SystemDictionaryShared::is_builtin(_klass)) {
        CrcInfo* c = crc();
        c-&gt;_clsfile_size = info._clsfile_size;
        c-&gt;_clsfile_crc32 = info._clsfile_crc32;
      }
<span class="line-added">+     _num_constraints = info.num_constraints();</span>
      if (_num_constraints &gt; 0) {
        RTConstraint* constraints = verifier_constraints();
        char* flags = verifier_constraint_flags();
        int i;
        for (i = 0; i &lt; _num_constraints; i++) {
<span class="line-modified">!         constraints[i]._name      = object_delta_u4(info._verifier_constraints-&gt;at(i)._name);</span>
<span class="line-modified">!         constraints[i]._from_name = object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);</span>
        }
        for (i = 0; i &lt; _num_constraints; i++) {
          flags[i] = info._verifier_constraint_flags-&gt;at(i);
        }
      }
<span class="line-added">+     if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+       _klass = DynamicArchive::original_to_target(info._klass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ArchivePtrMarker::mark_pointer(&amp;_klass);</span>
    }
  
    bool matches(int clsfile_size, int clsfile_crc32) const {
      return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
             crc()-&gt;_clsfile_crc32 == clsfile_crc32;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,11 ***</span>
  public:
    static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
      return *info_pointer_addr(klass);
    }
    static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
<span class="line-modified">!     *info_pointer_addr(klass) = record;</span>
    }
  
    // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
    static inline bool EQUALS(
         const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
<span class="line-new-header">--- 331,18 ---</span>
  public:
    static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
      return *info_pointer_addr(klass);
    }
    static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
<span class="line-modified">!     if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+       klass = DynamicArchive::original_to_buffer(klass);</span>
<span class="line-added">+       *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       *info_pointer_addr(klass) = record;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));</span>
    }
  
    // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
    static inline bool EQUALS(
         const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,12 ***</span>
<span class="line-new-header">--- 354,16 ---</span>
    Symbol*,
    const RunTimeSharedClassInfo*,
    RunTimeSharedClassInfo::EQUALS&gt; {};
  
  static DumpTimeSharedClassTable* _dumptime_table = NULL;
<span class="line-added">+ // SystemDictionaries in the base layer static archive</span>
  static RunTimeSharedDictionary _builtin_dictionary;
  static RunTimeSharedDictionary _unregistered_dictionary;
<span class="line-added">+ // SystemDictionaries in the top layer dynamic archive</span>
<span class="line-added">+ static RunTimeSharedDictionary _dynamic_builtin_dictionary;</span>
<span class="line-added">+ static RunTimeSharedDictionary _dynamic_unregistered_dictionary;</span>
  
  oop SystemDictionaryShared::shared_protection_domain(int index) {
    return _shared_protection_domains-&gt;obj_at(index);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,11 ***</span>
  //     boot/platform/app classloader, or must be in the unnamed module defined in the
  //     AppClassLoader.
  bool SystemDictionaryShared::is_shared_class_visible_for_classloader(
                                                       InstanceKlass* ik,
                                                       Handle class_loader,
<span class="line-removed">-                                                      const char* pkg_string,</span>
                                                       Symbol* pkg_name,
                                                       PackageEntry* pkg_entry,
                                                       ModuleEntry* mod_entry,
                                                       TRAPS) {
    assert(class_loader.not_null(), &quot;Class loader should not be NULL&quot;);
<span class="line-new-header">--- 659,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,11 ***</span>
          return true; // Module class from the runtime image
        }
      }
    } else if (SystemDictionary::is_system_class_loader(class_loader())) {
      assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);
<span class="line-modified">!     if (pkg_string == NULL) {</span>
        // The archived class is in the unnamed package. Currently, the boot image
        // does not contain any class in the unnamed package.
        assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);
        if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {
          assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);
<span class="line-new-header">--- 685,11 ---</span>
          return true; // Module class from the runtime image
        }
      }
    } else if (SystemDictionary::is_system_class_loader(class_loader())) {
      assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);
<span class="line-modified">!     if (pkg_name == NULL) {</span>
        // The archived class is in the unnamed package. Currently, the boot image
        // does not contain any class in the unnamed package.
        assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);
        if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {
          assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,10 ***</span>
<span class="line-new-header">--- 744,21 ---</span>
      return true;
    }
    return false;
  }
  
<span class="line-added">+ bool SystemDictionaryShared::has_platform_or_app_classes() {</span>
<span class="line-added">+   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (DynamicArchive::is_mapped() &amp;&amp;</span>
<span class="line-added">+       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // The following stack shows how this code is reached:
  //
  //   [0] SystemDictionaryShared::find_or_load_shared_class()
  //   [1] JVM_FindLoadedClass
  //   [2] java.lang.ClassLoader.findLoadedClass0()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 744,11 ***</span>
  
  InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
                   Symbol* name, Handle class_loader, TRAPS) {
    InstanceKlass* k = NULL;
    if (UseSharedSpaces) {
<span class="line-modified">!     if (!FileMapInfo::current_info()-&gt;header()-&gt;has_platform_or_app_classes()) {</span>
        return NULL;
      }
  
      if (SystemDictionary::is_system_class_loader(class_loader()) ||
          SystemDictionary::is_platform_class_loader(class_loader())) {
<span class="line-new-header">--- 792,11 ---</span>
  
  InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
                   Symbol* name, Handle class_loader, TRAPS) {
    InstanceKlass* k = NULL;
    if (UseSharedSpaces) {
<span class="line-modified">!     if (!has_platform_or_app_classes()) {</span>
        return NULL;
      }
  
      if (SystemDictionary::is_system_class_loader(class_loader()) ||
          SystemDictionary::is_platform_class_loader(class_loader())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 773,11 ***</span>
        Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
        check_loader_lock_contention(lockObject, THREAD);
        ObjectLocker ol(lockObject, THREAD, DoObjectLock);
  
        {
<span class="line-modified">!         MutexLocker mu(SystemDictionary_lock, THREAD);</span>
          InstanceKlass* check = find_class(d_hash, name, dictionary);
          if (check != NULL) {
            return check;
          }
        }
<span class="line-new-header">--- 821,11 ---</span>
        Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
        check_loader_lock_contention(lockObject, THREAD);
        ObjectLocker ol(lockObject, THREAD, DoObjectLock);
  
        {
<span class="line-modified">!         MutexLocker mu(THREAD, SystemDictionary_lock);</span>
          InstanceKlass* check = find_class(d_hash, name, dictionary);
          if (check != NULL) {
            return check;
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 859,17 ***</span>
        SystemDictionary::is_platform_class_loader(class_loader())) {
      // Do nothing for the BUILTIN loaders.
      return NULL;
    }
  
<span class="line-modified">!   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, class_name);</span>
    if (record == NULL) {
      return NULL;
    }
  
    int clsfile_size  = cfs-&gt;length();
    int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
    if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
      return NULL;
    }
  
    return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
<span class="line-new-header">--- 907,18 ---</span>
        SystemDictionary::is_platform_class_loader(class_loader())) {
      // Do nothing for the BUILTIN loaders.
      return NULL;
    }
  
<span class="line-modified">!   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, &amp;_dynamic_unregistered_dictionary, class_name);</span>
    if (record == NULL) {
      return NULL;
    }
  
    int clsfile_size  = cfs-&gt;length();
    int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
<span class="line-added">+ </span>
    if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
      return NULL;
    }
  
    return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,11 ***</span>
                     const ClassFileStream *cfs,
                     TRAPS) {
    ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
  
    {
<span class="line-modified">!     MutexLocker mu(SharedDictionary_lock, THREAD);</span>
      if (ik-&gt;class_loader_data() != NULL) {
        //    ik is already loaded (by this loader or by a different loader)
        // or ik is being loaded by a different thread (by this loader or by a different loader)
        return NULL;
      }
<span class="line-new-header">--- 933,11 ---</span>
                     const ClassFileStream *cfs,
                     TRAPS) {
    ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
  
    {
<span class="line-modified">!     MutexLocker mu(THREAD, SharedDictionary_lock);</span>
      if (ik-&gt;class_loader_data() != NULL) {
        //    ik is already loaded (by this loader or by a different loader)
        // or ik is being loaded by a different thread (by this loader or by a different loader)
        return NULL;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,11 ***</span>
      // We don&#39;t allow duplicated unregistered classes of the same name.
      return false;
    } else {
      bool isnew = _loaded_unregistered_classes.put(name, true);
      assert(isnew, &quot;sanity&quot;);
<span class="line-modified">!     MutexLocker mu_r(Compile_lock, THREAD); // add_to_hierarchy asserts this.</span>
      SystemDictionary::add_to_hierarchy(k, CHECK_0);
      return true;
    }
  }
  
<span class="line-new-header">--- 976,11 ---</span>
      // We don&#39;t allow duplicated unregistered classes of the same name.
      return false;
    } else {
      bool isnew = _loaded_unregistered_classes.put(name, true);
      assert(isnew, &quot;sanity&quot;);
<span class="line-modified">!     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.</span>
      SystemDictionary::add_to_hierarchy(k, CHECK_0);
      return true;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 968,18 ***</span>
      return NULL;
    }
  }
  
  DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
    if (_dumptime_table == NULL) {
      _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
    }
    return _dumptime_table-&gt;find_or_allocate_info_for(k);
  }
  
  void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;only when dumping&quot;);</span>
    assert(!is_builtin(k), &quot;must be unregistered class&quot;);
    DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
    info-&gt;_clsfile_size  = cfs-&gt;length();
    info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
  }
<span class="line-new-header">--- 1017,19 ---</span>
      return NULL;
    }
  }
  
  DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
<span class="line-added">+   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_dumptime_table == NULL) {
      _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
    }
    return _dumptime_table-&gt;find_or_allocate_info_for(k);
  }
  
  void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
    assert(!is_builtin(k), &quot;must be unregistered class&quot;);
    DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
    info-&gt;_clsfile_size  = cfs-&gt;length();
    info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 987,10 ***</span>
<span class="line-new-header">--- 1037,30 ---</span>
  void SystemDictionaryShared::init_dumptime_info(InstanceKlass* k) {
    (void)find_or_allocate_info_for(k);
  }
  
  void SystemDictionaryShared::remove_dumptime_info(InstanceKlass* k) {
<span class="line-added">+   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(k);</span>
<span class="line-added">+   if (p == NULL) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (p-&gt;_verifier_constraints != NULL) {</span>
<span class="line-added">+     for (int i = 0; i &lt; p-&gt;_verifier_constraints-&gt;length(); i++) {</span>
<span class="line-added">+       DumpTimeSharedClassInfo::DTConstraint constraint = p-&gt;_verifier_constraints-&gt;at(i);</span>
<span class="line-added">+       if (constraint._name != NULL ) {</span>
<span class="line-added">+         constraint._name-&gt;decrement_refcount();</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (constraint._from_name != NULL ) {</span>
<span class="line-added">+         constraint._from_name-&gt;decrement_refcount();</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(DTConstraint, p-&gt;_verifier_constraints);</span>
<span class="line-added">+     p-&gt;_verifier_constraints = NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(char, p-&gt;_verifier_constraint_flags);</span>
<span class="line-added">+   p-&gt;_verifier_constraint_flags = NULL;</span>
    _dumptime_table-&gt;remove(k);
  }
  
  bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {
    while (k) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1007,13 ***</span>
<span class="line-new-header">--- 1077,15 ---</span>
    log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
  }
  
  bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
    if (k-&gt;class_loader_data()-&gt;is_unsafe_anonymous()) {
<span class="line-added">+     warn_excluded(k, &quot;Unsafe anonymous class&quot;);</span>
      return true; // unsafe anonymous classes are not archived, skip
    }
    if (k-&gt;is_in_error_state()) {
<span class="line-added">+     warn_excluded(k, &quot;In error state&quot;);</span>
      return true;
    }
    if (k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
      // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
      // agent during dump time).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1033,20 ***</span>
      // There are only a small number of these classes, so it&#39;s not worthwhile to
      // support them and make CDS more complicated.
      warn_excluded(k, &quot;JFR event class&quot;);
      return true;
    }
    return false;
  }
  
  // k is a class before relocating by ArchiveCompactor
  void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
    ResourceMark rm;
    const char* name = k-&gt;name()-&gt;as_C_string();
    DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
    guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
<span class="line-modified">!   guarantee(!info-&gt;_excluded, &quot;Should not attempt to archive excluded class %s&quot;, name);</span>
    if (is_builtin(k)) {
      guarantee(k-&gt;loader_type() != 0,
                &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
    } else {
      guarantee(k-&gt;loader_type() == 0,
<span class="line-new-header">--- 1105,59 ---</span>
      // There are only a small number of these classes, so it&#39;s not worthwhile to
      // support them and make CDS more complicated.
      warn_excluded(k, &quot;JFR event class&quot;);
      return true;
    }
<span class="line-added">+   if (k-&gt;init_state() &lt; InstanceKlass::linked) {</span>
<span class="line-added">+     // In static dumping, we will attempt to link all classes. Those that fail to link will</span>
<span class="line-added">+     // be marked as in error state.</span>
<span class="line-added">+     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // TODO -- rethink how this can be handled.</span>
<span class="line-added">+     // We should try to link ik, however, we can&#39;t do it here because</span>
<span class="line-added">+     // 1. We are at VM exit</span>
<span class="line-added">+     // 2. linking a class may cause other classes to be loaded, which means</span>
<span class="line-added">+     //    a custom ClassLoader.loadClass() may be called, at a point where the</span>
<span class="line-added">+     //    class loader doesn&#39;t expect it.</span>
<span class="line-added">+     warn_excluded(k, &quot;Not linked&quot;);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {</span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,</span>
<span class="line-added">+                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">+   if (super != NULL &amp;&amp; should_be_excluded(super)) {</span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();</span>
<span class="line-added">+   int len = interfaces-&gt;length();</span>
<span class="line-added">+   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-added">+     InstanceKlass* intf = interfaces-&gt;at(i);</span>
<span class="line-added">+     if (should_be_excluded(intf)) {</span>
<span class="line-added">+       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    return false;
  }
  
  // k is a class before relocating by ArchiveCompactor
  void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
    ResourceMark rm;
    const char* name = k-&gt;name()-&gt;as_C_string();
    DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
<span class="line-added">+   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);</span>
    guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
<span class="line-modified">!   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);</span>
    if (is_builtin(k)) {
      guarantee(k-&gt;loader_type() != 0,
                &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
    } else {
      guarantee(k-&gt;loader_type() == 0,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1056,35 ***</span>
  
  class ExcludeDumpTimeSharedClasses : StackObj {
  public:
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
      if (SystemDictionaryShared::should_be_excluded(k)) {
<span class="line-modified">!       info._excluded = true;</span>
      }
      return true; // keep on iterating
    }
  };
  
  void SystemDictionaryShared::check_excluded_classes() {
    ExcludeDumpTimeSharedClasses excl;
    _dumptime_table-&gt;iterate(&amp;excl);
<span class="line-modified">!   DEBUG_ONLY(_checked_excluded_classes = true;)</span>
  }
  
  bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
<span class="line-modified">!   assert(_checked_excluded_classes, &quot;sanity&quot;);</span>
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;only when dumping&quot;);</span>
<span class="line-modified">!   return find_or_allocate_info_for(k)-&gt;_excluded;</span>
  }
  
  class IterateDumpTimeSharedClassTable : StackObj {
    MetaspaceClosure *_it;
  public:
    IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
  
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!     if (!info._excluded) {</span>
        info.metaspace_pointers_do(_it);
      }
      return true; // keep on iterating
    }
  };
<span class="line-new-header">--- 1167,35 ---</span>
  
  class ExcludeDumpTimeSharedClasses : StackObj {
  public:
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
      if (SystemDictionaryShared::should_be_excluded(k)) {
<span class="line-modified">!       info.set_excluded();</span>
      }
      return true; // keep on iterating
    }
  };
  
  void SystemDictionaryShared::check_excluded_classes() {
    ExcludeDumpTimeSharedClasses excl;
    _dumptime_table-&gt;iterate(&amp;excl);
<span class="line-modified">!   _dumptime_table-&gt;update_counts();</span>
  }
  
  bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
<span class="line-modified">!   assert(_no_class_loading_should_happen, &quot;sanity&quot;);</span>
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
<span class="line-modified">!   return find_or_allocate_info_for(k)-&gt;is_excluded();</span>
  }
  
  class IterateDumpTimeSharedClassTable : StackObj {
    MetaspaceClosure *_it;
  public:
    IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
  
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!     if (!info.is_excluded()) {</span>
        info.metaspace_pointers_do(_it);
      }
      return true; // keep on iterating
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1094,22 ***</span>
    _dumptime_table-&gt;iterate(&amp;iter);
  }
  
  bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
           Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;called at dump time only&quot;);</span>
    DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
    info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
                                      from_is_array, from_is_object);
<span class="line-modified">!   if (is_builtin(k)) {</span>
<span class="line-modified">!     // For builtin class loaders, we can try to complete the verification check at dump time,</span>
<span class="line-modified">!     // because we can resolve all the constraint classes.</span>
      return false;
    } else {
<span class="line-modified">!     // For non-builtin class loaders, we cannot complete the verification check at dump time,</span>
<span class="line-modified">!     // because at dump time we don&#39;t know how to resolve classes for such loaders.</span>
<span class="line-modified">!     return true;</span>
    }
  }
  
  void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
           Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
<span class="line-new-header">--- 1205,31 ---</span>
    _dumptime_table-&gt;iterate(&amp;iter);
  }
  
  bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
           Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
    DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
    info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
                                      from_is_array, from_is_object);
<span class="line-modified">! </span>
<span class="line-modified">!   if (DynamicDumpSharedSpaces) {</span>
<span class="line-modified">!     // For dynamic dumping, we can resolve all the constraint classes for all class loaders during</span>
<span class="line-added">+     // the initial run prior to creating the archive before vm exit. We will also perform verification</span>
<span class="line-added">+     // check when running with the archive.</span>
      return false;
    } else {
<span class="line-modified">!     if (is_builtin(k)) {</span>
<span class="line-modified">!       // For builtin class loaders, we can try to complete the verification check at dump time,</span>
<span class="line-modified">!       // because we can resolve all the constraint classes. We will also perform verification check</span>
<span class="line-added">+       // when running with the archive.</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // For non-builtin class loaders, we cannot complete the verification check at dump time,</span>
<span class="line-added">+       // because at dump time we don&#39;t know how to resolve classes for such loaders.</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
    }
  }
  
  void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
           Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1136,13 ***</span>
    c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
    vcflags_array-&gt;append(c);
  
    if (log_is_enabled(Trace, cds, verification)) {
      ResourceMark rm;
<span class="line-modified">!     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s&quot;,</span>
                                   k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
<span class="line-modified">!                                  name-&gt;as_klass_external_name());</span>
    }
  }
  
  void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
                                                              TRAPS) {
<span class="line-new-header">--- 1256,13 ---</span>
    c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
    vcflags_array-&gt;append(c);
  
    if (log_is_enabled(Trace, cds, verification)) {
      ResourceMark rm;
<span class="line-modified">!     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,</span>
                                   k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
<span class="line-modified">!                                  name-&gt;as_klass_external_name(), c);</span>
    }
  }
  
  void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
                                                              TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1154,10 ***</span>
<span class="line-new-header">--- 1274,17 ---</span>
      for (int i = 0; i &lt; length; i++) {
        Symbol* name      = record-&gt;get_constraint_name(i);
        Symbol* from_name = record-&gt;get_constraint_from_name(i);
        char c            = record-&gt;get_constraint_flag(i);
  
<span class="line-added">+       if (log_is_enabled(Trace, cds, verification)) {</span>
<span class="line-added">+         ResourceMark rm(THREAD);</span>
<span class="line-added">+         log_trace(cds, verification)(&quot;check_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,</span>
<span class="line-added">+                                      klass-&gt;external_name(), from_name-&gt;as_klass_external_name(),</span>
<span class="line-added">+                                      name-&gt;as_klass_external_name(), c);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
        bool from_field_is_protected = (c &amp; SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;
        bool from_is_array           = (c &amp; SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;
        bool from_is_object          = (c &amp; SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;
  
        bool ok = VerificationType::resolve_and_check_assignability(klass, name,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1175,68 ***</span>
        }
      }
    }
  }
  
  class CopySharedClassInfoToArchive : StackObj {
    CompactHashtableWriter* _writer;
    bool _is_builtin;
  public:
<span class="line-modified">!   CopySharedClassInfoToArchive(CompactHashtableWriter* writer, bool is_builtin)</span>
      : _writer(writer), _is_builtin(is_builtin) {}
  
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!     if (!info._excluded &amp;&amp; info.is_builtin() == _is_builtin) {</span>
        size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_constraints());
<span class="line-modified">!       RunTimeSharedClassInfo* record =</span>
<span class="line-modified">!         (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);</span>
        record-&gt;init(info);
  
<span class="line-modified">!       unsigned int hash = primitive_hash&lt;Symbol*&gt;(info._klass-&gt;name());</span>
<span class="line-modified">!       _writer-&gt;add(hash, MetaspaceShared::object_delta_u4(record));</span>
  
        // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
        RunTimeSharedClassInfo::set_for(info._klass, record);
      }
      return true; // keep on iterating
    }
  };
  
<span class="line-modified">! void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary, bool is_builtin) {</span>
    CompactHashtableStats stats;
    dictionary-&gt;reset();
<span class="line-modified">!   int num_buckets = CompactHashtableWriter::default_num_buckets(_dumptime_table-&gt;count_of(is_builtin));</span>
<span class="line-modified">!   CompactHashtableWriter writer(num_buckets, &amp;stats);</span>
<span class="line-removed">-   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin);</span>
    _dumptime_table-&gt;iterate(&amp;copy);
    writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
  }
  
<span class="line-modified">! void SystemDictionaryShared::write_to_archive() {</span>
<span class="line-modified">!   _dumptime_table-&gt;update_counts();</span>
<span class="line-modified">!   write_dictionary(&amp;_builtin_dictionary, true);</span>
<span class="line-modified">!   write_dictionary(&amp;_unregistered_dictionary, false);</span>
  }
  
<span class="line-modified">! void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc) {</span>
<span class="line-modified">!   _builtin_dictionary.serialize_header(soc);</span>
<span class="line-modified">!   _unregistered_dictionary.serialize_header(soc);</span>
  }
  
  const RunTimeSharedClassInfo*
<span class="line-modified">! SystemDictionaryShared::find_record(RunTimeSharedDictionary* dict, Symbol* name) {</span>
<span class="line-modified">!   if (UseSharedSpaces) {</span>
<span class="line-modified">!     unsigned int hash = primitive_hash&lt;Symbol*&gt;(name);</span>
<span class="line-removed">-     return dict-&gt;lookup(name, hash, 0);</span>
<span class="line-removed">-   } else {</span>
      return NULL;
    }
  }
  
  InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
<span class="line-modified">!   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, name);</span>
<span class="line-modified">!   if (record) {</span>
      return record-&gt;_klass;
    } else {
      return NULL;
    }
  }
<span class="line-new-header">--- 1302,141 ---</span>
        }
      }
    }
  }
  
<span class="line-added">+ class EstimateSizeForArchive : StackObj {</span>
<span class="line-added">+   size_t _shared_class_info_size;</span>
<span class="line-added">+   int _num_builtin_klasses;</span>
<span class="line-added">+   int _num_unregistered_klasses;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   EstimateSizeForArchive() {</span>
<span class="line-added">+     _shared_class_info_size = 0;</span>
<span class="line-added">+     _num_builtin_klasses = 0;</span>
<span class="line-added">+     _num_unregistered_klasses = 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {</span>
<span class="line-added">+     if (!info.is_excluded()) {</span>
<span class="line-added">+       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_constraints());</span>
<span class="line-added">+       _shared_class_info_size += align_up(byte_size, BytesPerWord);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true; // keep on iterating</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t total() {</span>
<span class="line-added">+     return _shared_class_info_size;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t SystemDictionaryShared::estimate_size_for_archive() {</span>
<span class="line-added">+   EstimateSizeForArchive est;</span>
<span class="line-added">+   _dumptime_table-&gt;iterate(&amp;est);</span>
<span class="line-added">+   return est.total() +</span>
<span class="line-added">+     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(true)) +</span>
<span class="line-added">+     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(false));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class CopySharedClassInfoToArchive : StackObj {
    CompactHashtableWriter* _writer;
    bool _is_builtin;
  public:
<span class="line-modified">!   CopySharedClassInfoToArchive(CompactHashtableWriter* writer,</span>
<span class="line-added">+                                bool is_builtin,</span>
<span class="line-added">+                                bool is_static_archive)</span>
      : _writer(writer), _is_builtin(is_builtin) {}
  
    bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
<span class="line-modified">!     if (!info.is_excluded() &amp;&amp; info.is_builtin() == _is_builtin) {</span>
        size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_constraints());
<span class="line-modified">!       RunTimeSharedClassInfo* record;</span>
<span class="line-modified">!       record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);</span>
        record-&gt;init(info);
  
<span class="line-modified">!       unsigned int hash;</span>
<span class="line-modified">!       Symbol* name = info._klass-&gt;name();</span>
<span class="line-added">+       if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+         name = DynamicArchive::original_to_target(name);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       hash = SystemDictionaryShared::hash_for_shared_dictionary(name);</span>
<span class="line-added">+       u4 delta;</span>
<span class="line-added">+       if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+         delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         delta = MetaspaceShared::object_delta_u4(record);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       _writer-&gt;add(hash, delta);</span>
<span class="line-added">+       if (log_is_enabled(Trace, cds, hashtables)) {</span>
<span class="line-added">+         ResourceMark rm;</span>
<span class="line-added">+         log_trace(cds,hashtables)(&quot;%s dictionary: %s&quot;, (_is_builtin ? &quot;builtin&quot; : &quot;unregistered&quot;), info._klass-&gt;external_name());</span>
<span class="line-added">+       }</span>
  
        // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
        RunTimeSharedClassInfo::set_for(info._klass, record);
      }
      return true; // keep on iterating
    }
  };
  
<span class="line-modified">! void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary,</span>
<span class="line-added">+                                               bool is_builtin,</span>
<span class="line-added">+                                               bool is_static_archive) {</span>
    CompactHashtableStats stats;
    dictionary-&gt;reset();
<span class="line-modified">!   CompactHashtableWriter writer(_dumptime_table-&gt;count_of(is_builtin), &amp;stats);</span>
<span class="line-modified">!   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin, is_static_archive);</span>
    _dumptime_table-&gt;iterate(&amp;copy);
    writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
  }
  
<span class="line-modified">! void SystemDictionaryShared::write_to_archive(bool is_static_archive) {</span>
<span class="line-modified">!   if (is_static_archive) {</span>
<span class="line-modified">!     write_dictionary(&amp;_builtin_dictionary, true);</span>
<span class="line-modified">!     write_dictionary(&amp;_unregistered_dictionary, false);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     write_dictionary(&amp;_dynamic_builtin_dictionary, true);</span>
<span class="line-added">+     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,</span>
<span class="line-modified">!                                                           bool is_static_archive) {</span>
<span class="line-modified">!   if (is_static_archive) {</span>
<span class="line-added">+     _builtin_dictionary.serialize_header(soc);</span>
<span class="line-added">+     _unregistered_dictionary.serialize_header(soc);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _dynamic_builtin_dictionary.serialize_header(soc);</span>
<span class="line-added">+     _dynamic_unregistered_dictionary.serialize_header(soc);</span>
<span class="line-added">+   }</span>
  }
  
  const RunTimeSharedClassInfo*
<span class="line-modified">! SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {</span>
<span class="line-modified">!   if (!UseSharedSpaces || !name-&gt;is_shared()) {</span>
<span class="line-modified">!     // The names of all shared classes must also be a shared Symbol.</span>
      return NULL;
    }
<span class="line-added">+ </span>
<span class="line-added">+   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);</span>
<span class="line-added">+   const RunTimeSharedClassInfo* record = NULL;</span>
<span class="line-added">+   if (!MetaspaceShared::is_shared_dynamic(name)) {</span>
<span class="line-added">+     // The names of all shared classes in the static dict must also be in the</span>
<span class="line-added">+     // static archive</span>
<span class="line-added">+     record = static_dict-&gt;lookup(name, hash, 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {</span>
<span class="line-added">+     record = dynamic_dict-&gt;lookup(name, hash, 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return record;</span>
  }
  
  InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
<span class="line-modified">!   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, &amp;_dynamic_builtin_dictionary, name);</span>
<span class="line-modified">!   if (record != NULL) {</span>
      return record-&gt;_klass;
    } else {
      return NULL;
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1263,14 ***</span>
<span class="line-new-header">--- 1463,33 ---</span>
    if (UseSharedSpaces) {
      st-&gt;print_cr(&quot;Shared Dictionary&quot;);
      SharedDictionaryPrinter p(st);
      _builtin_dictionary.iterate(&amp;p);
      _unregistered_dictionary.iterate(&amp;p);
<span class="line-added">+     if (DynamicArchive::is_mapped()) {</span>
<span class="line-added">+       _dynamic_builtin_dictionary.iterate(&amp;p);</span>
<span class="line-added">+       _unregistered_dictionary.iterate(&amp;p);</span>
<span class="line-added">+     }</span>
    }
  }
  
  void SystemDictionaryShared::print_table_statistics(outputStream* st) {
    if (UseSharedSpaces) {
      _builtin_dictionary.print_table_statistics(st, &quot;Builtin Shared Dictionary&quot;);
      _unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
<span class="line-added">+     if (DynamicArchive::is_mapped()) {</span>
<span class="line-added">+       _dynamic_builtin_dictionary.print_table_statistics(st, &quot;Dynamic Builtin Shared Dictionary&quot;);</span>
<span class="line-added">+       _dynamic_unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SystemDictionaryShared::empty_dumptime_table() {</span>
<span class="line-added">+   if (_dumptime_table == NULL) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _dumptime_table-&gt;update_counts();</span>
<span class="line-added">+   if (_dumptime_table-&gt;count_of(true) == 0 &amp;&amp; _dumptime_table-&gt;count_of(false) == 0){</span>
<span class="line-added">+     return true;</span>
    }
<span class="line-added">+   return false;</span>
  }
</pre>
<center><a href="systemDictionary.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
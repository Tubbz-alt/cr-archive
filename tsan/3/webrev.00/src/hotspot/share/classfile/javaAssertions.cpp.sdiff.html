<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaAssertions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaAssertions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62   int len = (int)strlen(name);
 63   char *name_copy = NEW_C_HEAP_ARRAY(char, len + 1, mtClass);
 64   strcpy(name_copy, name);
 65 
 66   // Figure out which list the new item should go on.  Names that end in &quot;...&quot;
 67   // go on the package tree list.
 68   OptionList** head = &amp;_classes;
 69   if (len &gt;= 3 &amp;&amp; strcmp(name_copy + len - 3, &quot;...&quot;) == 0) {
 70     // Delete the &quot;...&quot;.
 71     len -= 3;
 72     name_copy[len] = &#39;\0&#39;;
 73     head = &amp;_packages;
 74   }
 75 
 76   // Convert class/package names to internal format.  Will have to convert back
 77   // when copying to java in createJavaAssertionStatusDirectives, but that
 78   // should happen only once.  Alternative would require that
 79   // JVM_DesiredAssertionStatus pass the external_name() to
 80   // JavaAssertion::enabled(), but that is done once per loaded class.
 81   for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 82     if (name_copy[i] == &#39;.&#39;) name_copy[i] = &#39;/&#39;;</span>
 83   }
 84 
 85   if (TraceJavaAssertions) {
 86     tty-&gt;print_cr(&quot;JavaAssertions: adding %s %s=%d&quot;,
 87       head == &amp;_classes ? &quot;class&quot; : &quot;package&quot;,
 88       name_copy[0] != &#39;\0&#39; ? name_copy : &quot;&#39;default&#39;&quot;,
 89       enable);
 90   }
 91 
 92   // Prepend a new item to the list.  Items added later take precedence, so
 93   // prepending allows us to stop searching the list after the first match.
 94   *head = new OptionList(name_copy, enable, *head);
 95 }
 96 
 97 oop JavaAssertions::createAssertionStatusDirectives(TRAPS) {
 98   Symbol* asd_sym = vmSymbols::java_lang_AssertionStatusDirectives();
 99   Klass* k = SystemDictionary::resolve_or_fail(asd_sym, true, CHECK_NULL);
100   InstanceKlass* asd_klass = InstanceKlass::cast(k);
101   asd_klass-&gt;initialize(CHECK_NULL);
102   Handle h = asd_klass-&gt;allocate_instance_handle(CHECK_NULL);
</pre>
<hr />
<pre>
118   fillJavaArrays(_classes, len, classNames, classEnabled, CHECK_NULL);
119 
120   java_lang_AssertionStatusDirectives::set_packages(h(), pkgNames());
121   java_lang_AssertionStatusDirectives::set_packageEnabled(h(), pkgEnabled());
122   java_lang_AssertionStatusDirectives::set_classes(h(), classNames());
123   java_lang_AssertionStatusDirectives::set_classEnabled(h(), classEnabled());
124   java_lang_AssertionStatusDirectives::set_deflt(h(), userClassDefault());
125   return h();
126 }
127 
128 void JavaAssertions::fillJavaArrays(const OptionList* p, int len,
129 objArrayHandle names, typeArrayHandle enabled, TRAPS) {
130   // Fill in the parallel names and enabled (boolean) arrays.  Start at the end
131   // of the array and work backwards, so the order of items in the arrays
132   // matches the order on the command line (the list is in reverse order, since
133   // it was created by prepending successive items from the command line).
134   int index;
135   for (index = len - 1; p != 0; p = p-&gt;next(), --index) {
136     assert(index &gt;= 0, &quot;length does not match list&quot;);
137     Handle s = java_lang_String::create_from_str(p-&gt;name(), CHECK);
<span class="line-modified">138     s = java_lang_String::char_converter(s, &#39;/&#39;, &#39;.&#39;, CHECK);</span>
139     names-&gt;obj_at_put(index, s());
140     enabled-&gt;bool_at_put(index, p-&gt;enabled());
141   }
142   assert(index == -1, &quot;length does not match list&quot;);
143 }
144 
145 inline JavaAssertions::OptionList*
146 JavaAssertions::match_class(const char* classname) {
147   for (OptionList* p = _classes; p != 0; p = p-&gt;next()) {
148     if (strcmp(p-&gt;name(), classname) == 0) {
149       return p;
150     }
151   }
152   return 0;
153 }
154 
155 JavaAssertions::OptionList*
156 JavaAssertions::match_package(const char* classname) {
157   // Search the package list for any items that apply to classname.  Each
158   // sub-package in classname is checked, from most-specific to least, until one
159   // is found.
160   if (_packages == 0) return 0;
161 
162   // Find the length of the &quot;most-specific&quot; package in classname.  If classname
163   // does not include a package, length will be 0 which will match items for the
164   // default package (from options &quot;-ea:...&quot;  or &quot;-da:...&quot;).
165   size_t len = strlen(classname);
<span class="line-modified">166   for (/* empty */; len &gt; 0 &amp;&amp; classname[len] != &#39;/&#39;; --len) /* empty */;</span>
167 
168   do {
<span class="line-modified">169     assert(len == 0 || classname[len] == &#39;/&#39;, &quot;not a package name&quot;);</span>
170     for (OptionList* p = _packages; p != 0; p = p-&gt;next()) {
171       if (strncmp(p-&gt;name(), classname, len) == 0 &amp;&amp; p-&gt;name()[len] == &#39;\0&#39;) {
172         return p;
173       }
174     }
175 
176     // Find the length of the next package, taking care to avoid decrementing
177     // past 0 (len is unsigned).
<span class="line-modified">178     while (len &gt; 0 &amp;&amp; classname[--len] != &#39;/&#39;) /* empty */;</span>
179   } while (len &gt; 0);
180 
181   return 0;
182 }
183 
184 inline void JavaAssertions::trace(const char* name,
185 const char* typefound, const char* namefound, bool enabled) {
186   if (TraceJavaAssertions) {
187     tty-&gt;print_cr(&quot;JavaAssertions:  search for %s found %s %s=%d&quot;,
188       name, typefound, namefound[0] != &#39;\0&#39; ? namefound : &quot;&#39;default&#39;&quot;, enabled);
189   }
190 }
191 
192 bool JavaAssertions::enabled(const char* classname, bool systemClass) {
193   assert(classname != 0, &quot;must have a classname&quot;);
194 
195   // This will be slow if the number of assertion options on the command line is
196   // large--it traverses two lists, one of them multiple times.  Could use a
197   // single n-ary tree instead of lists if someone ever notices.
198 
</pre>
</td>
<td>
<hr />
<pre>
 62   int len = (int)strlen(name);
 63   char *name_copy = NEW_C_HEAP_ARRAY(char, len + 1, mtClass);
 64   strcpy(name_copy, name);
 65 
 66   // Figure out which list the new item should go on.  Names that end in &quot;...&quot;
 67   // go on the package tree list.
 68   OptionList** head = &amp;_classes;
 69   if (len &gt;= 3 &amp;&amp; strcmp(name_copy + len - 3, &quot;...&quot;) == 0) {
 70     // Delete the &quot;...&quot;.
 71     len -= 3;
 72     name_copy[len] = &#39;\0&#39;;
 73     head = &amp;_packages;
 74   }
 75 
 76   // Convert class/package names to internal format.  Will have to convert back
 77   // when copying to java in createJavaAssertionStatusDirectives, but that
 78   // should happen only once.  Alternative would require that
 79   // JVM_DesiredAssertionStatus pass the external_name() to
 80   // JavaAssertion::enabled(), but that is done once per loaded class.
 81   for (int i = 0; i &lt; len; ++i) {
<span class="line-modified"> 82     if (name_copy[i] == JVM_SIGNATURE_DOT) name_copy[i] = JVM_SIGNATURE_SLASH;</span>
 83   }
 84 
 85   if (TraceJavaAssertions) {
 86     tty-&gt;print_cr(&quot;JavaAssertions: adding %s %s=%d&quot;,
 87       head == &amp;_classes ? &quot;class&quot; : &quot;package&quot;,
 88       name_copy[0] != &#39;\0&#39; ? name_copy : &quot;&#39;default&#39;&quot;,
 89       enable);
 90   }
 91 
 92   // Prepend a new item to the list.  Items added later take precedence, so
 93   // prepending allows us to stop searching the list after the first match.
 94   *head = new OptionList(name_copy, enable, *head);
 95 }
 96 
 97 oop JavaAssertions::createAssertionStatusDirectives(TRAPS) {
 98   Symbol* asd_sym = vmSymbols::java_lang_AssertionStatusDirectives();
 99   Klass* k = SystemDictionary::resolve_or_fail(asd_sym, true, CHECK_NULL);
100   InstanceKlass* asd_klass = InstanceKlass::cast(k);
101   asd_klass-&gt;initialize(CHECK_NULL);
102   Handle h = asd_klass-&gt;allocate_instance_handle(CHECK_NULL);
</pre>
<hr />
<pre>
118   fillJavaArrays(_classes, len, classNames, classEnabled, CHECK_NULL);
119 
120   java_lang_AssertionStatusDirectives::set_packages(h(), pkgNames());
121   java_lang_AssertionStatusDirectives::set_packageEnabled(h(), pkgEnabled());
122   java_lang_AssertionStatusDirectives::set_classes(h(), classNames());
123   java_lang_AssertionStatusDirectives::set_classEnabled(h(), classEnabled());
124   java_lang_AssertionStatusDirectives::set_deflt(h(), userClassDefault());
125   return h();
126 }
127 
128 void JavaAssertions::fillJavaArrays(const OptionList* p, int len,
129 objArrayHandle names, typeArrayHandle enabled, TRAPS) {
130   // Fill in the parallel names and enabled (boolean) arrays.  Start at the end
131   // of the array and work backwards, so the order of items in the arrays
132   // matches the order on the command line (the list is in reverse order, since
133   // it was created by prepending successive items from the command line).
134   int index;
135   for (index = len - 1; p != 0; p = p-&gt;next(), --index) {
136     assert(index &gt;= 0, &quot;length does not match list&quot;);
137     Handle s = java_lang_String::create_from_str(p-&gt;name(), CHECK);
<span class="line-modified">138     s = java_lang_String::char_converter(s, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, CHECK);</span>
139     names-&gt;obj_at_put(index, s());
140     enabled-&gt;bool_at_put(index, p-&gt;enabled());
141   }
142   assert(index == -1, &quot;length does not match list&quot;);
143 }
144 
145 inline JavaAssertions::OptionList*
146 JavaAssertions::match_class(const char* classname) {
147   for (OptionList* p = _classes; p != 0; p = p-&gt;next()) {
148     if (strcmp(p-&gt;name(), classname) == 0) {
149       return p;
150     }
151   }
152   return 0;
153 }
154 
155 JavaAssertions::OptionList*
156 JavaAssertions::match_package(const char* classname) {
157   // Search the package list for any items that apply to classname.  Each
158   // sub-package in classname is checked, from most-specific to least, until one
159   // is found.
160   if (_packages == 0) return 0;
161 
162   // Find the length of the &quot;most-specific&quot; package in classname.  If classname
163   // does not include a package, length will be 0 which will match items for the
164   // default package (from options &quot;-ea:...&quot;  or &quot;-da:...&quot;).
165   size_t len = strlen(classname);
<span class="line-modified">166   for (/* empty */; len &gt; 0 &amp;&amp; classname[len] != JVM_SIGNATURE_SLASH; --len) /* empty */;</span>
167 
168   do {
<span class="line-modified">169     assert(len == 0 || classname[len] == JVM_SIGNATURE_SLASH, &quot;not a package name&quot;);</span>
170     for (OptionList* p = _packages; p != 0; p = p-&gt;next()) {
171       if (strncmp(p-&gt;name(), classname, len) == 0 &amp;&amp; p-&gt;name()[len] == &#39;\0&#39;) {
172         return p;
173       }
174     }
175 
176     // Find the length of the next package, taking care to avoid decrementing
177     // past 0 (len is unsigned).
<span class="line-modified">178     while (len &gt; 0 &amp;&amp; classname[--len] != JVM_SIGNATURE_SLASH) /* empty */;</span>
179   } while (len &gt; 0);
180 
181   return 0;
182 }
183 
184 inline void JavaAssertions::trace(const char* name,
185 const char* typefound, const char* namefound, bool enabled) {
186   if (TraceJavaAssertions) {
187     tty-&gt;print_cr(&quot;JavaAssertions:  search for %s found %s %s=%d&quot;,
188       name, typefound, namefound[0] != &#39;\0&#39; ? namefound : &quot;&#39;default&#39;&quot;, enabled);
189   }
190 }
191 
192 bool JavaAssertions::enabled(const char* classname, bool systemClass) {
193   assert(classname != 0, &quot;must have a classname&quot;);
194 
195   // This will be slow if the number of assertion options on the command line is
196   // large--it traverses two lists, one of them multiple times.  Could use a
197   // single n-ary tree instead of lists if someone ever notices.
198 
</pre>
</td>
</tr>
</table>
<center><a href="dictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
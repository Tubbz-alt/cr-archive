<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1  /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 50 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 51 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 52 #include &quot;classfile/dictionary.hpp&quot;
 53 #include &quot;classfile/javaClasses.hpp&quot;
 54 #include &quot;classfile/moduleEntry.hpp&quot;
 55 #include &quot;classfile/packageEntry.hpp&quot;
 56 #include &quot;classfile/symbolTable.hpp&quot;
 57 #include &quot;classfile/systemDictionary.hpp&quot;
 58 #include &quot;logging/log.hpp&quot;
 59 #include &quot;logging/logStream.hpp&quot;
 60 #include &quot;memory/allocation.inline.hpp&quot;
 61 #include &quot;memory/metadataFactory.hpp&quot;
 62 #include &quot;memory/resourceArea.hpp&quot;
 63 #include &quot;oops/access.inline.hpp&quot;
 64 #include &quot;oops/oop.inline.hpp&quot;
 65 #include &quot;oops/oopHandle.inline.hpp&quot;
 66 #include &quot;oops/weakHandle.inline.hpp&quot;
 67 #include &quot;runtime/atomic.hpp&quot;
 68 #include &quot;runtime/handles.inline.hpp&quot;
 69 #include &quot;runtime/mutex.hpp&quot;
<span class="line-removed"> 70 #include &quot;runtime/orderAccess.hpp&quot;</span>
 71 #include &quot;runtime/safepoint.hpp&quot;
 72 #include &quot;utilities/growableArray.hpp&quot;
 73 #include &quot;utilities/macros.hpp&quot;
 74 #include &quot;utilities/ostream.hpp&quot;
 75 
 76 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
 77 
 78 void ClassLoaderData::init_null_class_loader_data() {
 79   assert(_the_null_class_loader_data == NULL, &quot;cannot initialize twice&quot;);
 80   assert(ClassLoaderDataGraph::_head == NULL, &quot;cannot initialize twice&quot;);
 81 
 82   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
 83   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
 84   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), &quot;Must be&quot;);
 85 
 86   LogTarget(Trace, class, loader, data) lt;
 87   if (lt.is_enabled()) {
 88     ResourceMark rm;
 89     LogStream ls(lt);
 90     ls.print(&quot;create &quot;);
 91     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
 92     ls.cr();
 93   }
 94 }
 95 
 96 // Obtain and set the class loader&#39;s name within the ClassLoaderData so
 97 // it will be available for error messages, logging, JFR, etc.  The name
 98 // and klass are available after the class_loader oop is no longer alive,
 99 // during unloading.
100 void ClassLoaderData::initialize_name(Handle class_loader) {
101   Thread* THREAD = Thread::current();
102   ResourceMark rm(THREAD);
103 
104   // Obtain the class loader&#39;s name.  If the class loader&#39;s name was not
105   // explicitly set during construction, the CLD&#39;s _name field will be null.
106   oop cl_name = java_lang_ClassLoader::name(class_loader());
107   if (cl_name != NULL) {
108     const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
109 
110     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
<span class="line-modified">111       // Can&#39;t throw InternalError and SymbolTable doesn&#39;t throw OOM anymore.</span>
<span class="line-removed">112       _name = SymbolTable::new_symbol(cl_instance_name, CATCH);</span>
113     }
114   }
115 
116   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
117   // name was not explicitly set during construction, the class loader&#39;s name and id
118   // will be set to the qualified class name of the class loader along with its
119   // identity hash.
120   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
121   // leaving the _name_and_id field null, fall back to the external qualified class
122   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
123   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
124   const char* cl_instance_name_and_id =
125                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
126                                              java_lang_String::as_utf8_string(cl_name_and_id);
127   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
<span class="line-modified">128   // Can&#39;t throw InternalError and SymbolTable doesn&#39;t throw OOM anymore.</span>
<span class="line-removed">129   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id, CATCH);</span>
130 }
131 
132 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous) :
133   _metaspace(NULL),
<span class="line-modified">134   _metaspace_lock(new Mutex(Monitor::leaf+1, &quot;Metaspace allocation lock&quot;, true,</span>
<span class="line-modified">135                             Monitor::_safepoint_check_never)),</span>
136   _unloading(false), _is_unsafe_anonymous(is_unsafe_anonymous),
137   _modified_oops(true), _accumulated_modified_oops(false),
138   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
139   // it from being unloaded during parsing of the unsafe anonymous class.
140   // The null-class-loader should always be kept alive.
141   _keep_alive((is_unsafe_anonymous || h_class_loader.is_null()) ? 1 : 0),
142   _claim(0),
143   _handles(),
144   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
145   _jmethod_ids(NULL),
146   _deallocate_list(NULL),
147   _next(NULL),
148   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
149 
150   if (!h_class_loader.is_null()) {
151     _class_loader = _handles.add(h_class_loader());
152     _class_loader_klass = h_class_loader-&gt;klass();
153     initialize_name(h_class_loader);
154   }
155 
</pre>
<hr />
<pre>
172     _dictionary = create_dictionary();
173   }
174 
175   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
176 
177   JFR_ONLY(INIT_ID(this);)
178 }
179 
180 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
181   Chunk* c = _head;
182   while (c != NULL) {
183     Chunk* next = c-&gt;_next;
184     delete c;
185     c = next;
186   }
187 }
188 
189 oop* ClassLoaderData::ChunkedHandleList::add(oop o) {
190   if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
191     Chunk* next = new Chunk(_head);
<span class="line-modified">192     OrderAccess::release_store(&amp;_head, next);</span>
193   }
194   oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
195   NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
<span class="line-modified">196   OrderAccess::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);</span>
197   return handle;
198 }
199 
200 int ClassLoaderData::ChunkedHandleList::count() const {
201   int count = 0;
202   Chunk* chunk = _head;
203   while (chunk != NULL) {
204     count += chunk-&gt;_size;
205     chunk = chunk-&gt;_next;
206   }
207   return count;
208 }
209 
210 inline void ClassLoaderData::ChunkedHandleList::oops_do_chunk(OopClosure* f, Chunk* c, const juint size) {
211   for (juint i = 0; i &lt; size; i++) {
212     if (c-&gt;_data[i] != NULL) {
213       f-&gt;do_oop(&amp;c-&gt;_data[i]);
214     }
215   }
216 }
217 
218 void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
<span class="line-modified">219   Chunk* head = OrderAccess::load_acquire(&amp;_head);</span>
220   if (head != NULL) {
221     // Must be careful when reading size of head
<span class="line-modified">222     oops_do_chunk(f, head, OrderAccess::load_acquire(&amp;head-&gt;_size));</span>
223     for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
224       oops_do_chunk(f, c, c-&gt;_size);
225     }
226   }
227 }
228 
229 class VerifyContainsOopClosure : public OopClosure {
230   oop  _target;
231   bool _found;
232 
233  public:
234   VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
235 
236   void do_oop(oop* p) {
<span class="line-modified">237     if (p != NULL &amp;&amp; oopDesc::equals(NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p), _target)) {</span>
238       _found = true;
239     }
240   }
241 
242   void do_oop(narrowOop* p) {
243     // The ChunkedHandleList should not contain any narrowOop
244     ShouldNotReachHere();
245   }
246 
247   bool found() const {
248     return _found;
249   }
250 };
251 
252 bool ClassLoaderData::ChunkedHandleList::contains(oop p) {
253   VerifyContainsOopClosure cl(p);
254   oops_do(&amp;cl);
255   return cl.found();
256 }
257 
258 #ifndef PRODUCT
259 bool ClassLoaderData::ChunkedHandleList::owner_of(oop* oop_handle) {
260   Chunk* chunk = _head;
261   while (chunk != NULL) {
262     if (&amp;(chunk-&gt;_data[0]) &lt;= oop_handle &amp;&amp; oop_handle &lt; &amp;(chunk-&gt;_data[chunk-&gt;_size])) {
263       return true;
264     }
265     chunk = chunk-&gt;_next;
266   }
267   return false;
268 }
269 #endif // PRODUCT
270 













271 bool ClassLoaderData::try_claim(int claim) {
272   for (;;) {
273     int old_claim = Atomic::load(&amp;_claim);
274     if ((old_claim &amp; claim) == claim) {
275       return false;
276     }
277     int new_claim = old_claim | claim;
<span class="line-modified">278     if (Atomic::cmpxchg(new_claim, &amp;_claim, old_claim) == old_claim) {</span>
279       return true;
280     }
281   }
282 }
283 
284 // Unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
285 // while the class is being parsed, and if the class appears on the module fixup list.
286 // Due to the uniqueness that no other class shares the unsafe anonymous class&#39; name or
287 // ClassLoaderData, no other non-GC thread has knowledge of the unsafe anonymous class while
288 // it is being defined, therefore _keep_alive is not volatile or atomic.
289 void ClassLoaderData::inc_keep_alive() {
290   if (is_unsafe_anonymous()) {
<span class="line-modified">291     assert(_keep_alive &gt;= 0, &quot;Invalid keep alive increment count&quot;);</span>
292     _keep_alive++;
293   }
294 }
295 
296 void ClassLoaderData::dec_keep_alive() {
297   if (is_unsafe_anonymous()) {
298     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
299     _keep_alive--;
300   }
301 }
302 
303 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
304   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
305     return;
306   }
307 
308   // Only clear modified_oops after the ClassLoaderData is claimed.
309   if (clear_mod_oops) {
310     clear_modified_oops();
311   }
312 
313   _handles.oops_do(f);
314 }
315 
316 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
317   // Lock-free access requires load_acquire
<span class="line-modified">318   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
319     klass_closure-&gt;do_klass(k);
320     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
321   }
322 }
323 
324 void ClassLoaderData::classes_do(void f(Klass * const)) {
325   // Lock-free access requires load_acquire
<span class="line-modified">326   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
327     f(k);
328     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
329   }
330 }
331 
332 void ClassLoaderData::methods_do(void f(Method*)) {
333   // Lock-free access requires load_acquire
<span class="line-modified">334   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
335     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
336       InstanceKlass::cast(k)-&gt;methods_do(f);
337     }
338   }
339 }
340 
341 void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
342   // Lock-free access requires load_acquire
<span class="line-modified">343   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
344     // Do not filter ArrayKlass oops here...
345     if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
346 #ifdef ASSERT
347       oop m = k-&gt;java_mirror();
348       assert(m != NULL, &quot;NULL mirror&quot;);
349       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
350 #endif
351       klass_closure-&gt;do_klass(k);
352     }
353   }
354 }
355 
356 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
357   // Lock-free access requires load_acquire
<span class="line-modified">358   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
359     if (k-&gt;is_instance_klass()) {
360       f(InstanceKlass::cast(k));
361     }
362     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
363   }
364 }
365 
366 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
367   assert_locked_or_safepoint(Module_lock);
368   if (_unnamed_module != NULL) {
369     f(_unnamed_module);
370   }
371   if (_modules != NULL) {
372     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
373       for (ModuleEntry* entry = _modules-&gt;bucket(i);
374            entry != NULL;
375            entry = entry-&gt;next()) {
376         f(entry);
377       }
378     }
</pre>
<hr />
<pre>
405   if (to_cld-&gt;is_permanent_class_loader_data()) {
406     return;
407   }
408 
409   oop to;
410   if (to_cld-&gt;is_unsafe_anonymous()) {
411     // Just return if an unsafe anonymous class is attempting to record a dependency
412     // to itself.  (Note that every unsafe anonymous class has its own unique class
413     // loader data.)
414     if (to_cld == from_cld) {
415       return;
416     }
417     // Unsafe anonymous class dependencies are through the mirror.
418     to = k-&gt;java_mirror();
419   } else {
420     to = to_cld-&gt;class_loader();
421     oop from = from_cld-&gt;class_loader();
422 
423     // Just return if this dependency is to a class with the same or a parent
424     // class_loader.
<span class="line-modified">425     if (oopDesc::equals(from, to) || java_lang_ClassLoader::isAncestor(from, to)) {</span>
426       return; // this class loader is in the parent list, no need to add it.
427     }
428   }
429 
430   // It&#39;s a dependency we won&#39;t find through GC, add it.
431   if (!_handles.contains(to)) {
432     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
433     LogTarget(Trace, class, loader, data) lt;
434     if (lt.is_enabled()) {
435       ResourceMark rm;
436       LogStream ls(lt);
437       ls.print(&quot;adding dependency from &quot;);
438       print_value_on(&amp;ls);
439       ls.print(&quot; to &quot;);
440       to_cld-&gt;print_value_on(&amp;ls);
441       ls.cr();
442     }
443     Handle dependency(Thread::current(), to);
444     add_handle(dependency);
445     // Added a potentially young gen oop to the ClassLoaderData
446     record_modified_oops();
447   }
448 }
449 
450 void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
451   {
<span class="line-modified">452     MutexLockerEx ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
453     Klass* old_value = _klasses;
454     k-&gt;set_next_link(old_value);
455     // Link the new item into the list, making sure the linked class is stable
456     // since the list can be walked without a lock
<span class="line-modified">457     OrderAccess::release_store(&amp;_klasses, k);</span>
458     if (k-&gt;is_array_klass()) {
459       ClassLoaderDataGraph::inc_array_classes(1);
460     } else {
461       ClassLoaderDataGraph::inc_instance_classes(1);
462     }
463   }
464 
465   if (publicize) {
466     LogTarget(Trace, class, loader, data) lt;
467     if (lt.is_enabled()) {
468       ResourceMark rm;
469       LogStream ls(lt);
470       ls.print(&quot;Adding k: &quot; PTR_FORMAT &quot; %s to &quot;, p2i(k), k-&gt;external_name());
471       print_value_on(&amp;ls);
472       ls.cr();
473     }
474   }
475 }
476 
477 void ClassLoaderData::initialize_holder(Handle loader_or_mirror) {
</pre>
<hr />
<pre>
524     print_value_on(&amp;ls);
525     ls.cr();
526   }
527 
528   // Some items on the _deallocate_list need to free their C heap structures
529   // if they are not already on the _klasses list.
530   free_deallocate_list_C_heap_structures();
531 
532   // Clean up class dependencies and tell serviceability tools
533   // these classes are unloading.  Must be called
534   // after erroneous classes are released.
535   classes_do(InstanceKlass::unload_class);
536 
537   // Clean up global class iterator for compiler
538   ClassLoaderDataGraph::adjust_saved_class(this);
539 }
540 
541 ModuleEntryTable* ClassLoaderData::modules() {
542   // Lazily create the module entry table at first request.
543   // Lock-free access requires load_acquire.
<span class="line-modified">544   ModuleEntryTable* modules = OrderAccess::load_acquire(&amp;_modules);</span>
545   if (modules == NULL) {
546     MutexLocker m1(Module_lock);
547     // Check if _modules got allocated while we were waiting for this lock.
548     if ((modules = _modules) == NULL) {
549       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
550 
551       {
<span class="line-modified">552         MutexLockerEx m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
553         // Ensure _modules is stable, since it is examined without a lock
<span class="line-modified">554         OrderAccess::release_store(&amp;_modules, modules);</span>
555       }
556     }
557   }
558   return modules;
559 }
560 
561 const int _boot_loader_dictionary_size    = 1009;
562 const int _default_loader_dictionary_size = 107;
563 
564 Dictionary* ClassLoaderData::create_dictionary() {
565   assert(!is_unsafe_anonymous(), &quot;unsafe anonymous class loader data do not have a dictionary&quot;);
566   int size;
567   bool resizable = false;
568   if (_the_null_class_loader_data == NULL) {
569     size = _boot_loader_dictionary_size;
570     resizable = true;
571   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
572     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
573   } else if (is_system_class_loader_data()) {
574     size = _boot_loader_dictionary_size;
</pre>
<hr />
<pre>
724 // even if its class loader is one of these loaders.
725 bool ClassLoaderData::is_builtin_class_loader_data() const {
726   return (is_boot_class_loader_data() ||
727           SystemDictionary::is_system_class_loader(class_loader()) ||
728           SystemDictionary::is_platform_class_loader(class_loader()));
729 }
730 
731 // Returns true if this class loader data is a class loader data
732 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
733 // class loaders and not the CLD for an unsafe anonymous class.
734 bool ClassLoaderData::is_permanent_class_loader_data() const {
735   return is_builtin_class_loader_data() &amp;&amp; !is_unsafe_anonymous();
736 }
737 
738 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
739   // If the metaspace has not been allocated, create a new one.  Might want
740   // to create smaller arena for Reflection class loaders also.
741   // The reason for the delayed allocation is because some class loaders are
742   // simply for delegating with no metadata of their own.
743   // Lock-free access requires load_acquire.
<span class="line-modified">744   ClassLoaderMetaspace* metaspace = OrderAccess::load_acquire(&amp;_metaspace);</span>
745   if (metaspace == NULL) {
<span class="line-modified">746     MutexLockerEx ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);</span>
747     // Check if _metaspace got allocated while we were waiting for this lock.
748     if ((metaspace = _metaspace) == NULL) {
749       if (this == the_null_class_loader_data()) {
750         assert (class_loader() == NULL, &quot;Must be&quot;);
751         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
752       } else if (is_unsafe_anonymous()) {
753         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::UnsafeAnonymousMetaspaceType);
754       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
755         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
756       } else {
757         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
758       }
759       // Ensure _metaspace is stable, since it is examined without a lock
<span class="line-modified">760       OrderAccess::release_store(&amp;_metaspace, metaspace);</span>
761     }
762   }
763   return metaspace;
764 }
765 
766 OopHandle ClassLoaderData::add_handle(Handle h) {
<span class="line-modified">767   MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
768   record_modified_oops();
769   return OopHandle(_handles.add(h()));
770 }
771 
772 void ClassLoaderData::remove_handle(OopHandle h) {
773   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
774   oop* ptr = h.ptr_raw();
775   if (ptr != NULL) {
776     assert(_handles.owner_of(ptr), &quot;Got unexpected handle &quot; PTR_FORMAT, p2i(ptr));
777     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
778   }
779 }
780 
781 void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
<span class="line-modified">782   MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
783   if (dest.resolve() != NULL) {
784     return;
785   } else {
786     dest = _handles.add(h());
787   }
788 }
789 
790 // Add this metadata pointer to be freed when it&#39;s safe.  This is only during
791 // a safepoint which checks if handles point to this metadata field.
792 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
793   // Metadata in shared region isn&#39;t deleted.
794   if (!m-&gt;is_shared()) {
<span class="line-modified">795     MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
796     if (_deallocate_list == NULL) {
797       _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, true);
798     }
799     _deallocate_list-&gt;append_if_missing(m);
800     log_debug(class, loader, data)(&quot;deallocate added for %s&quot;, m-&gt;print_value_string());
801     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
802   }
803 }
804 
805 // Deallocate free metadata on the free list.  How useful the PermGen was!
806 void ClassLoaderData::free_deallocate_list() {
807   // This must be called at a safepoint because it depends on metadata walking at
808   // safepoint cleanup time.
809   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
810   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
811   if (_deallocate_list == NULL) {
812     return;
813   }
814   // Go backwards because this removes entries that are freed.
815   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
898     return _name_and_id-&gt;as_C_string();
899   } else {
900     // May be called in a race before _name_and_id is initialized.
901     return _class_loader_klass-&gt;external_name();
902   }
903 }
904 
905 void ClassLoaderData::print_value_on(outputStream* out) const {
906   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
907     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
908     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
909   } else {
910     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
911     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
912   }
913   if (is_unsafe_anonymous()) {
914     out-&gt;print(&quot; unsafe anonymous&quot;);
915   }
916 }
917 


918 #ifndef PRODUCT
919 void ClassLoaderData::print_on(outputStream* out) const {
920   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
921               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
922   if (is_unsafe_anonymous()) out-&gt;print(&quot; unsafe anonymous&quot;);
923   if (claimed()) out-&gt;print(&quot; claimed&quot;);
924   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
925   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
926 
927   if (_jmethod_ids != NULL) {
928     Method::print_jmethod_ids(this, out);
929   }
930   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
931   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
932   out-&gt;print_cr(&quot;}&quot;);
933 }
934 #endif // PRODUCT
935 


936 void ClassLoaderData::verify() {
937   assert_locked_or_safepoint(_metaspace_lock);
938   oop cl = class_loader();
939 
940   guarantee(this == class_loader_data(cl) || is_unsafe_anonymous(), &quot;Must be the same&quot;);
941   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || is_unsafe_anonymous(), &quot;must be&quot;);
942 
943   // Verify the integrity of the allocated space.
944   if (metaspace_or_null() != NULL) {
945     metaspace_or_null()-&gt;verify();
946   }
947 
948   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
949     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
950     k-&gt;verify();
951     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
952   }
953 }
954 
955 bool ClassLoaderData::contains_klass(Klass* klass) {
956   // Lock-free access requires load_acquire
<span class="line-modified">957   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
958     if (k == klass) return true;
959   }
960   return false;
961 }
</pre>
</td>
<td>
<hr />
<pre>
  1  /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 50 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 51 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
 52 #include &quot;classfile/dictionary.hpp&quot;
 53 #include &quot;classfile/javaClasses.hpp&quot;
 54 #include &quot;classfile/moduleEntry.hpp&quot;
 55 #include &quot;classfile/packageEntry.hpp&quot;
 56 #include &quot;classfile/symbolTable.hpp&quot;
 57 #include &quot;classfile/systemDictionary.hpp&quot;
 58 #include &quot;logging/log.hpp&quot;
 59 #include &quot;logging/logStream.hpp&quot;
 60 #include &quot;memory/allocation.inline.hpp&quot;
 61 #include &quot;memory/metadataFactory.hpp&quot;
 62 #include &quot;memory/resourceArea.hpp&quot;
 63 #include &quot;oops/access.inline.hpp&quot;
 64 #include &quot;oops/oop.inline.hpp&quot;
 65 #include &quot;oops/oopHandle.inline.hpp&quot;
 66 #include &quot;oops/weakHandle.inline.hpp&quot;
 67 #include &quot;runtime/atomic.hpp&quot;
 68 #include &quot;runtime/handles.inline.hpp&quot;
 69 #include &quot;runtime/mutex.hpp&quot;

 70 #include &quot;runtime/safepoint.hpp&quot;
 71 #include &quot;utilities/growableArray.hpp&quot;
 72 #include &quot;utilities/macros.hpp&quot;
 73 #include &quot;utilities/ostream.hpp&quot;
 74 
 75 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
 76 
 77 void ClassLoaderData::init_null_class_loader_data() {
 78   assert(_the_null_class_loader_data == NULL, &quot;cannot initialize twice&quot;);
 79   assert(ClassLoaderDataGraph::_head == NULL, &quot;cannot initialize twice&quot;);
 80 
 81   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
 82   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
 83   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), &quot;Must be&quot;);
 84 
 85   LogTarget(Trace, class, loader, data) lt;
 86   if (lt.is_enabled()) {
 87     ResourceMark rm;
 88     LogStream ls(lt);
 89     ls.print(&quot;create &quot;);
 90     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
 91     ls.cr();
 92   }
 93 }
 94 
 95 // Obtain and set the class loader&#39;s name within the ClassLoaderData so
 96 // it will be available for error messages, logging, JFR, etc.  The name
 97 // and klass are available after the class_loader oop is no longer alive,
 98 // during unloading.
 99 void ClassLoaderData::initialize_name(Handle class_loader) {
100   Thread* THREAD = Thread::current();
101   ResourceMark rm(THREAD);
102 
103   // Obtain the class loader&#39;s name.  If the class loader&#39;s name was not
104   // explicitly set during construction, the CLD&#39;s _name field will be null.
105   oop cl_name = java_lang_ClassLoader::name(class_loader());
106   if (cl_name != NULL) {
107     const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
108 
109     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
<span class="line-modified">110       _name = SymbolTable::new_symbol(cl_instance_name);</span>

111     }
112   }
113 
114   // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
115   // name was not explicitly set during construction, the class loader&#39;s name and id
116   // will be set to the qualified class name of the class loader along with its
117   // identity hash.
118   // If for some reason the ClassLoader&#39;s constructor has not been run, instead of
119   // leaving the _name_and_id field null, fall back to the external qualified class
120   // name.  Thus CLD&#39;s _name_and_id field should never have a null value.
121   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
122   const char* cl_instance_name_and_id =
123                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
124                                              java_lang_String::as_utf8_string(cl_name_and_id);
125   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
<span class="line-modified">126   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);</span>

127 }
128 
129 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous) :
130   _metaspace(NULL),
<span class="line-modified">131   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,</span>
<span class="line-modified">132                             Mutex::_safepoint_check_never)),</span>
133   _unloading(false), _is_unsafe_anonymous(is_unsafe_anonymous),
134   _modified_oops(true), _accumulated_modified_oops(false),
135   // An unsafe anonymous class loader data doesn&#39;t have anything to keep
136   // it from being unloaded during parsing of the unsafe anonymous class.
137   // The null-class-loader should always be kept alive.
138   _keep_alive((is_unsafe_anonymous || h_class_loader.is_null()) ? 1 : 0),
139   _claim(0),
140   _handles(),
141   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
142   _jmethod_ids(NULL),
143   _deallocate_list(NULL),
144   _next(NULL),
145   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
146 
147   if (!h_class_loader.is_null()) {
148     _class_loader = _handles.add(h_class_loader());
149     _class_loader_klass = h_class_loader-&gt;klass();
150     initialize_name(h_class_loader);
151   }
152 
</pre>
<hr />
<pre>
169     _dictionary = create_dictionary();
170   }
171 
172   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
173 
174   JFR_ONLY(INIT_ID(this);)
175 }
176 
177 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
178   Chunk* c = _head;
179   while (c != NULL) {
180     Chunk* next = c-&gt;_next;
181     delete c;
182     c = next;
183   }
184 }
185 
186 oop* ClassLoaderData::ChunkedHandleList::add(oop o) {
187   if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
188     Chunk* next = new Chunk(_head);
<span class="line-modified">189     Atomic::release_store(&amp;_head, next);</span>
190   }
191   oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
192   NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
<span class="line-modified">193   Atomic::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);</span>
194   return handle;
195 }
196 
197 int ClassLoaderData::ChunkedHandleList::count() const {
198   int count = 0;
199   Chunk* chunk = _head;
200   while (chunk != NULL) {
201     count += chunk-&gt;_size;
202     chunk = chunk-&gt;_next;
203   }
204   return count;
205 }
206 
207 inline void ClassLoaderData::ChunkedHandleList::oops_do_chunk(OopClosure* f, Chunk* c, const juint size) {
208   for (juint i = 0; i &lt; size; i++) {
209     if (c-&gt;_data[i] != NULL) {
210       f-&gt;do_oop(&amp;c-&gt;_data[i]);
211     }
212   }
213 }
214 
215 void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
<span class="line-modified">216   Chunk* head = Atomic::load_acquire(&amp;_head);</span>
217   if (head != NULL) {
218     // Must be careful when reading size of head
<span class="line-modified">219     oops_do_chunk(f, head, Atomic::load_acquire(&amp;head-&gt;_size));</span>
220     for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
221       oops_do_chunk(f, c, c-&gt;_size);
222     }
223   }
224 }
225 
226 class VerifyContainsOopClosure : public OopClosure {
227   oop  _target;
228   bool _found;
229 
230  public:
231   VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
232 
233   void do_oop(oop* p) {
<span class="line-modified">234     if (p != NULL &amp;&amp; NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p) == _target) {</span>
235       _found = true;
236     }
237   }
238 
239   void do_oop(narrowOop* p) {
240     // The ChunkedHandleList should not contain any narrowOop
241     ShouldNotReachHere();
242   }
243 
244   bool found() const {
245     return _found;
246   }
247 };
248 
249 bool ClassLoaderData::ChunkedHandleList::contains(oop p) {
250   VerifyContainsOopClosure cl(p);
251   oops_do(&amp;cl);
252   return cl.found();
253 }
254 
255 #ifndef PRODUCT
256 bool ClassLoaderData::ChunkedHandleList::owner_of(oop* oop_handle) {
257   Chunk* chunk = _head;
258   while (chunk != NULL) {
259     if (&amp;(chunk-&gt;_data[0]) &lt;= oop_handle &amp;&amp; oop_handle &lt; &amp;(chunk-&gt;_data[chunk-&gt;_size])) {
260       return true;
261     }
262     chunk = chunk-&gt;_next;
263   }
264   return false;
265 }
266 #endif // PRODUCT
267 
<span class="line-added">268 void ClassLoaderData::clear_claim(int claim) {</span>
<span class="line-added">269   for (;;) {</span>
<span class="line-added">270     int old_claim = Atomic::load(&amp;_claim);</span>
<span class="line-added">271     if ((old_claim &amp; claim) == 0) {</span>
<span class="line-added">272       return;</span>
<span class="line-added">273     }</span>
<span class="line-added">274     int new_claim = old_claim &amp; ~claim;</span>
<span class="line-added">275     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {</span>
<span class="line-added">276       return;</span>
<span class="line-added">277     }</span>
<span class="line-added">278   }</span>
<span class="line-added">279 }</span>
<span class="line-added">280 </span>
281 bool ClassLoaderData::try_claim(int claim) {
282   for (;;) {
283     int old_claim = Atomic::load(&amp;_claim);
284     if ((old_claim &amp; claim) == claim) {
285       return false;
286     }
287     int new_claim = old_claim | claim;
<span class="line-modified">288     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {</span>
289       return true;
290     }
291   }
292 }
293 
294 // Unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
295 // while the class is being parsed, and if the class appears on the module fixup list.
296 // Due to the uniqueness that no other class shares the unsafe anonymous class&#39; name or
297 // ClassLoaderData, no other non-GC thread has knowledge of the unsafe anonymous class while
298 // it is being defined, therefore _keep_alive is not volatile or atomic.
299 void ClassLoaderData::inc_keep_alive() {
300   if (is_unsafe_anonymous()) {
<span class="line-modified">301     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);</span>
302     _keep_alive++;
303   }
304 }
305 
306 void ClassLoaderData::dec_keep_alive() {
307   if (is_unsafe_anonymous()) {
308     assert(_keep_alive &gt; 0, &quot;Invalid keep alive decrement count&quot;);
309     _keep_alive--;
310   }
311 }
312 
313 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
314   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
315     return;
316   }
317 
318   // Only clear modified_oops after the ClassLoaderData is claimed.
319   if (clear_mod_oops) {
320     clear_modified_oops();
321   }
322 
323   _handles.oops_do(f);
324 }
325 
326 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
327   // Lock-free access requires load_acquire
<span class="line-modified">328   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
329     klass_closure-&gt;do_klass(k);
330     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
331   }
332 }
333 
334 void ClassLoaderData::classes_do(void f(Klass * const)) {
335   // Lock-free access requires load_acquire
<span class="line-modified">336   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
337     f(k);
338     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
339   }
340 }
341 
342 void ClassLoaderData::methods_do(void f(Method*)) {
343   // Lock-free access requires load_acquire
<span class="line-modified">344   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
345     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
346       InstanceKlass::cast(k)-&gt;methods_do(f);
347     }
348   }
349 }
350 
351 void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
352   // Lock-free access requires load_acquire
<span class="line-modified">353   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
354     // Do not filter ArrayKlass oops here...
355     if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
356 #ifdef ASSERT
357       oop m = k-&gt;java_mirror();
358       assert(m != NULL, &quot;NULL mirror&quot;);
359       assert(m-&gt;is_a(SystemDictionary::Class_klass()), &quot;invalid mirror&quot;);
360 #endif
361       klass_closure-&gt;do_klass(k);
362     }
363   }
364 }
365 
366 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
367   // Lock-free access requires load_acquire
<span class="line-modified">368   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
369     if (k-&gt;is_instance_klass()) {
370       f(InstanceKlass::cast(k));
371     }
372     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
373   }
374 }
375 
376 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
377   assert_locked_or_safepoint(Module_lock);
378   if (_unnamed_module != NULL) {
379     f(_unnamed_module);
380   }
381   if (_modules != NULL) {
382     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
383       for (ModuleEntry* entry = _modules-&gt;bucket(i);
384            entry != NULL;
385            entry = entry-&gt;next()) {
386         f(entry);
387       }
388     }
</pre>
<hr />
<pre>
415   if (to_cld-&gt;is_permanent_class_loader_data()) {
416     return;
417   }
418 
419   oop to;
420   if (to_cld-&gt;is_unsafe_anonymous()) {
421     // Just return if an unsafe anonymous class is attempting to record a dependency
422     // to itself.  (Note that every unsafe anonymous class has its own unique class
423     // loader data.)
424     if (to_cld == from_cld) {
425       return;
426     }
427     // Unsafe anonymous class dependencies are through the mirror.
428     to = k-&gt;java_mirror();
429   } else {
430     to = to_cld-&gt;class_loader();
431     oop from = from_cld-&gt;class_loader();
432 
433     // Just return if this dependency is to a class with the same or a parent
434     // class_loader.
<span class="line-modified">435     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {</span>
436       return; // this class loader is in the parent list, no need to add it.
437     }
438   }
439 
440   // It&#39;s a dependency we won&#39;t find through GC, add it.
441   if (!_handles.contains(to)) {
442     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
443     LogTarget(Trace, class, loader, data) lt;
444     if (lt.is_enabled()) {
445       ResourceMark rm;
446       LogStream ls(lt);
447       ls.print(&quot;adding dependency from &quot;);
448       print_value_on(&amp;ls);
449       ls.print(&quot; to &quot;);
450       to_cld-&gt;print_value_on(&amp;ls);
451       ls.cr();
452     }
453     Handle dependency(Thread::current(), to);
454     add_handle(dependency);
455     // Added a potentially young gen oop to the ClassLoaderData
456     record_modified_oops();
457   }
458 }
459 
460 void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
461   {
<span class="line-modified">462     MutexLocker ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
463     Klass* old_value = _klasses;
464     k-&gt;set_next_link(old_value);
465     // Link the new item into the list, making sure the linked class is stable
466     // since the list can be walked without a lock
<span class="line-modified">467     Atomic::release_store(&amp;_klasses, k);</span>
468     if (k-&gt;is_array_klass()) {
469       ClassLoaderDataGraph::inc_array_classes(1);
470     } else {
471       ClassLoaderDataGraph::inc_instance_classes(1);
472     }
473   }
474 
475   if (publicize) {
476     LogTarget(Trace, class, loader, data) lt;
477     if (lt.is_enabled()) {
478       ResourceMark rm;
479       LogStream ls(lt);
480       ls.print(&quot;Adding k: &quot; PTR_FORMAT &quot; %s to &quot;, p2i(k), k-&gt;external_name());
481       print_value_on(&amp;ls);
482       ls.cr();
483     }
484   }
485 }
486 
487 void ClassLoaderData::initialize_holder(Handle loader_or_mirror) {
</pre>
<hr />
<pre>
534     print_value_on(&amp;ls);
535     ls.cr();
536   }
537 
538   // Some items on the _deallocate_list need to free their C heap structures
539   // if they are not already on the _klasses list.
540   free_deallocate_list_C_heap_structures();
541 
542   // Clean up class dependencies and tell serviceability tools
543   // these classes are unloading.  Must be called
544   // after erroneous classes are released.
545   classes_do(InstanceKlass::unload_class);
546 
547   // Clean up global class iterator for compiler
548   ClassLoaderDataGraph::adjust_saved_class(this);
549 }
550 
551 ModuleEntryTable* ClassLoaderData::modules() {
552   // Lazily create the module entry table at first request.
553   // Lock-free access requires load_acquire.
<span class="line-modified">554   ModuleEntryTable* modules = Atomic::load_acquire(&amp;_modules);</span>
555   if (modules == NULL) {
556     MutexLocker m1(Module_lock);
557     // Check if _modules got allocated while we were waiting for this lock.
558     if ((modules = _modules) == NULL) {
559       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
560 
561       {
<span class="line-modified">562         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
563         // Ensure _modules is stable, since it is examined without a lock
<span class="line-modified">564         Atomic::release_store(&amp;_modules, modules);</span>
565       }
566     }
567   }
568   return modules;
569 }
570 
571 const int _boot_loader_dictionary_size    = 1009;
572 const int _default_loader_dictionary_size = 107;
573 
574 Dictionary* ClassLoaderData::create_dictionary() {
575   assert(!is_unsafe_anonymous(), &quot;unsafe anonymous class loader data do not have a dictionary&quot;);
576   int size;
577   bool resizable = false;
578   if (_the_null_class_loader_data == NULL) {
579     size = _boot_loader_dictionary_size;
580     resizable = true;
581   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
582     size = 1;  // there&#39;s only one class in relection class loader and no initiated classes
583   } else if (is_system_class_loader_data()) {
584     size = _boot_loader_dictionary_size;
</pre>
<hr />
<pre>
734 // even if its class loader is one of these loaders.
735 bool ClassLoaderData::is_builtin_class_loader_data() const {
736   return (is_boot_class_loader_data() ||
737           SystemDictionary::is_system_class_loader(class_loader()) ||
738           SystemDictionary::is_platform_class_loader(class_loader()));
739 }
740 
741 // Returns true if this class loader data is a class loader data
742 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
743 // class loaders and not the CLD for an unsafe anonymous class.
744 bool ClassLoaderData::is_permanent_class_loader_data() const {
745   return is_builtin_class_loader_data() &amp;&amp; !is_unsafe_anonymous();
746 }
747 
748 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
749   // If the metaspace has not been allocated, create a new one.  Might want
750   // to create smaller arena for Reflection class loaders also.
751   // The reason for the delayed allocation is because some class loaders are
752   // simply for delegating with no metadata of their own.
753   // Lock-free access requires load_acquire.
<span class="line-modified">754   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);</span>
755   if (metaspace == NULL) {
<span class="line-modified">756     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);</span>
757     // Check if _metaspace got allocated while we were waiting for this lock.
758     if ((metaspace = _metaspace) == NULL) {
759       if (this == the_null_class_loader_data()) {
760         assert (class_loader() == NULL, &quot;Must be&quot;);
761         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
762       } else if (is_unsafe_anonymous()) {
763         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::UnsafeAnonymousMetaspaceType);
764       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
765         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
766       } else {
767         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
768       }
769       // Ensure _metaspace is stable, since it is examined without a lock
<span class="line-modified">770       Atomic::release_store(&amp;_metaspace, metaspace);</span>
771     }
772   }
773   return metaspace;
774 }
775 
776 OopHandle ClassLoaderData::add_handle(Handle h) {
<span class="line-modified">777   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
778   record_modified_oops();
779   return OopHandle(_handles.add(h()));
780 }
781 
782 void ClassLoaderData::remove_handle(OopHandle h) {
783   assert(!is_unloading(), &quot;Do not remove a handle for a CLD that is unloading&quot;);
784   oop* ptr = h.ptr_raw();
785   if (ptr != NULL) {
786     assert(_handles.owner_of(ptr), &quot;Got unexpected handle &quot; PTR_FORMAT, p2i(ptr));
787     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
788   }
789 }
790 
791 void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
<span class="line-modified">792   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
793   if (dest.resolve() != NULL) {
794     return;
795   } else {
796     dest = _handles.add(h());
797   }
798 }
799 
800 // Add this metadata pointer to be freed when it&#39;s safe.  This is only during
801 // a safepoint which checks if handles point to this metadata field.
802 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
803   // Metadata in shared region isn&#39;t deleted.
804   if (!m-&gt;is_shared()) {
<span class="line-modified">805     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
806     if (_deallocate_list == NULL) {
807       _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, true);
808     }
809     _deallocate_list-&gt;append_if_missing(m);
810     log_debug(class, loader, data)(&quot;deallocate added for %s&quot;, m-&gt;print_value_string());
811     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
812   }
813 }
814 
815 // Deallocate free metadata on the free list.  How useful the PermGen was!
816 void ClassLoaderData::free_deallocate_list() {
817   // This must be called at a safepoint because it depends on metadata walking at
818   // safepoint cleanup time.
819   assert(SafepointSynchronize::is_at_safepoint(), &quot;only called at safepoint&quot;);
820   assert(!is_unloading(), &quot;only called for ClassLoaderData that are not unloading&quot;);
821   if (_deallocate_list == NULL) {
822     return;
823   }
824   // Go backwards because this removes entries that are freed.
825   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
908     return _name_and_id-&gt;as_C_string();
909   } else {
910     // May be called in a race before _name_and_id is initialized.
911     return _class_loader_klass-&gt;external_name();
912   }
913 }
914 
915 void ClassLoaderData::print_value_on(outputStream* out) const {
916   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
917     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; for instance &quot;, p2i(this));
918     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
919   } else {
920     // loader data: 0xsomeaddr of &#39;bootstrap&#39;
921     out-&gt;print(&quot;loader data: &quot; INTPTR_FORMAT &quot; of %s&quot;, p2i(this), loader_name_and_id());
922   }
923   if (is_unsafe_anonymous()) {
924     out-&gt;print(&quot; unsafe anonymous&quot;);
925   }
926 }
927 
<span class="line-added">928 void ClassLoaderData::print_value() const { print_value_on(tty); }</span>
<span class="line-added">929 </span>
930 #ifndef PRODUCT
931 void ClassLoaderData::print_on(outputStream* out) const {
932   out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
933               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
934   if (is_unsafe_anonymous()) out-&gt;print(&quot; unsafe anonymous&quot;);
935   if (claimed()) out-&gt;print(&quot; claimed&quot;);
936   if (is_unloading()) out-&gt;print(&quot; unloading&quot;);
937   out-&gt;print(&quot; metaspace: &quot; INTPTR_FORMAT, p2i(metaspace_or_null()));
938 
939   if (_jmethod_ids != NULL) {
940     Method::print_jmethod_ids(this, out);
941   }
942   out-&gt;print(&quot; handles count %d&quot;, _handles.count());
943   out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
944   out-&gt;print_cr(&quot;}&quot;);
945 }
946 #endif // PRODUCT
947 
<span class="line-added">948 void ClassLoaderData::print() const { print_on(tty); }</span>
<span class="line-added">949 </span>
950 void ClassLoaderData::verify() {
951   assert_locked_or_safepoint(_metaspace_lock);
952   oop cl = class_loader();
953 
954   guarantee(this == class_loader_data(cl) || is_unsafe_anonymous(), &quot;Must be the same&quot;);
955   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || is_unsafe_anonymous(), &quot;must be&quot;);
956 
957   // Verify the integrity of the allocated space.
958   if (metaspace_or_null() != NULL) {
959     metaspace_or_null()-&gt;verify();
960   }
961 
962   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
963     guarantee(k-&gt;class_loader_data() == this, &quot;Must be the same&quot;);
964     k-&gt;verify();
965     assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
966   }
967 }
968 
969 bool ClassLoaderData::contains_klass(Klass* klass) {
970   // Lock-free access requires load_acquire
<span class="line-modified">971   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
972     if (k == klass) return true;
973   }
974   return false;
975 }
</pre>
</td>
</tr>
</table>
<center><a href="classLoader.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
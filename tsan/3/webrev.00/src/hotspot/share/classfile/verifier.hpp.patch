diff a/src/hotspot/share/classfile/verifier.hpp b/src/hotspot/share/classfile/verifier.hpp
--- a/src/hotspot/share/classfile/verifier.hpp
+++ b/src/hotspot/share/classfile/verifier.hpp
@@ -29,10 +29,11 @@
 #include "oops/klass.hpp"
 #include "oops/method.hpp"
 #include "runtime/handles.hpp"
 #include "utilities/exceptions.hpp"
 #include "utilities/growableArray.hpp"
+#include "utilities/resourceHash.hpp"
 
 // The verifier class
 class Verifier : AllStatic {
  public:
   enum {
@@ -244,10 +245,37 @@
   void bytecode_details(outputStream* ss, const Method* method) const;
   void handler_details(outputStream* ss, const Method* method) const;
   void stackmap_details(outputStream* ss, const Method* method) const;
 };
 
+class sig_as_verification_types : public ResourceObj {
+ private:
+  int _num_args;  // Number of arguments, not including return type.
+  GrowableArray<VerificationType>* _sig_verif_types;
+
+ public:
+
+  sig_as_verification_types(GrowableArray<VerificationType>* sig_verif_types) :
+    _num_args(0), _sig_verif_types(sig_verif_types) {
+  }
+
+  int num_args() const { return _num_args; }
+  void set_num_args(int num_args) { _num_args = num_args; }
+
+  GrowableArray<VerificationType>* sig_verif_types() { return _sig_verif_types; }
+  void set_sig_verif_types(GrowableArray<VerificationType>* sig_verif_types) {
+    _sig_verif_types = sig_verif_types;
+  }
+
+};
+
+// This hashtable is indexed by the Utf8 constant pool indexes pointed to
+// by constant pool (Interface)Method_refs' NameAndType signature entries.
+typedef ResourceHashtable<int, sig_as_verification_types*,
+                          primitive_hash<int>, primitive_equals<int>, 1007>
+                          method_signatures_table_type;
+
 // A new instance of this class is created for each class being verified
 class ClassVerifier : public StackObj {
  private:
   Thread* _thread;
 
@@ -255,10 +283,12 @@
   GrowableArray<Symbol*>* _symbols;  // keep a list of symbols created
 
   Symbol* _exception_type;
   char* _message;
 
+  method_signatures_table_type* _method_signatures_table;
+
   ErrorContext _error_context;  // contains information about an error
 
   void verify_method(const methodHandle& method, TRAPS);
   char* generate_code_data(const methodHandle& m, u4 code_length, TRAPS);
   void verify_exception_handler_table(u4 code_length, char* code_data,
@@ -381,10 +411,17 @@
   // Verifies the class.  If a verify or class file format error occurs,
   // the '_exception_name' symbols will set to the exception name and
   // the message_buffer will be filled in with the exception message.
   void verify_class(TRAPS);
 
+  // Translates method signature entries into verificationTypes and saves them
+  // in the growable array.
+  void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types, TRAPS);
+
+  // Initializes a sig_as_verification_types entry and puts it in the hash table.
+  void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index, TRAPS);
+
   // Return status modes
   Symbol* result() const { return _exception_type; }
   bool has_error() const { return result() != NULL; }
   char* exception_message() {
     stringStream ss;
@@ -398,23 +435,31 @@
   void verify_error(ErrorContext ctx, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);
   void class_format_error(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);
 
   Klass* load_class(Symbol* name, TRAPS);
 
+  method_signatures_table_type* method_signatures_table() const {
+    return _method_signatures_table;
+  }
+
+  void set_method_signatures_table(method_signatures_table_type* method_signatures_table) {
+    _method_signatures_table = method_signatures_table;
+  }
+
   int change_sig_to_verificationType(
-    SignatureStream* sig_type, VerificationType* inference_type, TRAPS);
+    SignatureStream* sig_type, VerificationType* inference_type);
 
   VerificationType cp_index_to_type(int index, const constantPoolHandle& cp, TRAPS) {
     return VerificationType::reference_type(cp->klass_name_at(index));
   }
 
   // Keep a list of temporary symbols created during verification because
   // their reference counts need to be decremented when the verifier object
   // goes out of scope.  Since these symbols escape the scope in which they're
   // created, we can't use a TempNewSymbol.
-  Symbol* create_temporary_symbol(const Symbol* s, int begin, int end, TRAPS);
-  Symbol* create_temporary_symbol(const char *s, int length, TRAPS);
+  Symbol* create_temporary_symbol(const Symbol* s, int begin, int end);
+  Symbol* create_temporary_symbol(const char *s, int length);
   Symbol* create_temporary_symbol(Symbol* s) {
     if (s == _previous_symbol) {
       return s;
     }
     if (!s->is_permanent()) {
@@ -426,22 +471,22 @@
     }
     _previous_symbol = s;
     return s;
   }
 
-  TypeOrigin ref_ctx(const char* str, TRAPS);
+  TypeOrigin ref_ctx(const char* str);
 
 };
 
 inline int ClassVerifier::change_sig_to_verificationType(
-    SignatureStream* sig_type, VerificationType* inference_type, TRAPS) {
+    SignatureStream* sig_type, VerificationType* inference_type) {
   BasicType bt = sig_type->type();
   switch (bt) {
     case T_OBJECT:
     case T_ARRAY:
       {
-        Symbol* name = sig_type->as_symbol(CHECK_0);
+        Symbol* name = sig_type->as_symbol();
         // Create another symbol to save as signature stream unreferences this symbol.
         Symbol* name_copy = create_temporary_symbol(name);
         assert(name_copy == name, "symbols don't match");
         *inference_type =
           VerificationType::reference_type(name_copy);

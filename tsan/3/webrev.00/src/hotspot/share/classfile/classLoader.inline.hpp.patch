diff a/src/hotspot/share/classfile/classLoader.inline.hpp b/src/hotspot/share/classfile/classLoader.inline.hpp
--- a/src/hotspot/share/classfile/classLoader.inline.hpp
+++ b/src/hotspot/share/classfile/classLoader.inline.hpp
@@ -24,18 +24,18 @@
 
 #ifndef SHARE_CLASSFILE_CLASSLOADER_INLINE_HPP
 #define SHARE_CLASSFILE_CLASSLOADER_INLINE_HPP
 
 #include "classfile/classLoader.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 
 // Next entry in class path
-inline ClassPathEntry* ClassPathEntry::next() const { return OrderAccess::load_acquire(&_next); }
+inline ClassPathEntry* ClassPathEntry::next() const { return Atomic::load_acquire(&_next); }
 
 inline void ClassPathEntry::set_next(ClassPathEntry* next) {
   // may have unlocked readers, so ensure visibility.
-  OrderAccess::release_store(&_next, next);
+  Atomic::release_store(&_next, next);
 }
 
 inline ClassPathEntry* ClassLoader::classpath_entry(int n) {
   assert(n >= 0, "sanity");
   if (n == 0) {
@@ -60,11 +60,11 @@
 
 // Helper function used by CDS code to get the number of boot classpath
 // entries during shared classpath setup time.
 
 inline int ClassLoader::num_boot_classpath_entries() {
-  assert(DumpSharedSpaces, "Should only be called at CDS dump time");
+  Arguments::assert_is_dumping_archive();
   assert(has_jrt_entry(), "must have a java runtime image");
   int num_entries = 1; // count the runtime image
   ClassPathEntry* e = ClassLoader::_first_append_entry;
   while (e != NULL) {
     num_entries ++;
@@ -82,11 +82,11 @@
 }
 
 // Helper function used by CDS code to get the number of app classpath
 // entries during shared classpath setup time.
 inline int ClassLoader::num_app_classpath_entries() {
-  assert(DumpSharedSpaces, "Should only be called at CDS dump time");
+  Arguments::assert_is_dumping_archive();
   int num_entries = 0;
   ClassPathEntry* e= ClassLoader::_app_classpath_entries;
   while (e != NULL) {
     num_entries ++;
     e = e->next();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/compactHashtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compactHashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="defaultMethods.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/compactHashtable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83     unsigned int _hash;
 84     u4 _value;
 85 
 86   public:
 87     Entry() {}
 88     Entry(unsigned int hash, u4 val) : _hash(hash), _value(val) {}
 89 
 90     u4 value() {
 91       return _value;
 92     }
 93     unsigned int hash() {
 94       return _hash;
 95     }
 96 
 97     bool operator==(const CompactHashtableWriter::Entry&amp; other) {
 98       return (_value == other._value &amp;&amp; _hash == other._hash);
 99     }
100   }; // class CompactHashtableWriter::Entry
101 
102 private:
<span class="line-modified">103   int _num_entries;</span>
104   int _num_buckets;
105   int _num_empty_buckets;
106   int _num_value_only_buckets;
107   int _num_other_buckets;
108   GrowableArray&lt;Entry&gt;** _buckets;
109   CompactHashtableStats* _stats;
110   Array&lt;u4&gt;* _compact_buckets;
111   Array&lt;u4&gt;* _compact_entries;
112 
113 public:
114   // This is called at dump-time only
<span class="line-modified">115   CompactHashtableWriter(int num_buckets, CompactHashtableStats* stats);</span>
116   ~CompactHashtableWriter();
117 
118   void add(unsigned int hash, u4 value);
119 
120 private:
121   void allocate_table();
122   void dump_table(NumberSeq* summary);
<span class="line-modified">123 </span>
<span class="line-removed">124 public:</span>
<span class="line-removed">125   void dump(SimpleCompactHashtable *cht, const char* table_name);</span>
<span class="line-removed">126 </span>
<span class="line-removed">127   static int default_num_buckets(size_t num_entries) {</span>
<span class="line-removed">128     return default_num_buckets((int)num_entries);</span>
<span class="line-removed">129   }</span>
<span class="line-removed">130   static int default_num_buckets(int num_entries) {</span>
131     int num_buckets = num_entries / SharedSymbolTableBucketSize;
132     // calculation of num_buckets can result in zero buckets, we need at least one
133     return (num_buckets &lt; 1) ? 1 : num_buckets;
134   }





135 };
136 #endif // INCLUDE_CDS
137 
138 #define REGULAR_BUCKET_TYPE       0
139 #define VALUE_ONLY_BUCKET_TYPE    1
140 #define TABLEEND_BUCKET_TYPE      3
141 #define BUCKET_OFFSET_MASK        0x3FFFFFFF
142 #define BUCKET_OFFSET(info)       ((info) &amp; BUCKET_OFFSET_MASK)
143 #define BUCKET_TYPE_SHIFT         30
144 #define BUCKET_TYPE(info)         (((info) &amp; ~BUCKET_OFFSET_MASK) &gt;&gt; BUCKET_TYPE_SHIFT)
145 #define BUCKET_INFO(offset, type) (((type) &lt;&lt; BUCKET_TYPE_SHIFT) | ((offset) &amp; BUCKET_OFFSET_MASK))
146 
147 /////////////////////////////////////////////////////////////////////////////
148 //
149 // CompactHashtable is used to store the CDS archive&#39;s symbol/string tables.
150 //
151 // Because these tables are read-only (no entries can be added/deleted) at run-time
152 // and tend to have large number of entries, we try to minimize the footprint
153 // cost per entry.
154 //
</pre>
<hr />
<pre>
197   u4  _bucket_count;
198   u4  _entry_count;
199   u4* _buckets;
200   u4* _entries;
201 
202 public:
203   SimpleCompactHashtable() {
204     _entry_count = 0;
205     _bucket_count = 0;
206     _buckets = 0;
207     _entries = 0;
208   }
209 
210   void reset() {
211     _bucket_count = 0;
212     _entry_count = 0;
213     _buckets = 0;
214     _entries = 0;
215   }
216 
<span class="line-modified">217   void init(address base_address, u4 entry_count, u4 bucket_count, u4* buckets, u4* entries) {</span>
<span class="line-removed">218     _base_address = base_address;</span>
<span class="line-removed">219     _bucket_count = bucket_count;</span>
<span class="line-removed">220     _entry_count = entry_count;</span>
<span class="line-removed">221     _buckets = buckets;</span>
<span class="line-removed">222     _entries = entries;</span>
<span class="line-removed">223   }</span>
224 
225   // Read/Write the table&#39;s header from/to the CDS archive
226   void serialize_header(SerializeClosure* soc) NOT_CDS_RETURN;
227 
228   inline bool empty() {
229     return (_entry_count == 0);
230   }


231 };
232 
233 template &lt;
234   typename K,
235   typename V,
236   V (*DECODE)(address base_address, u4 offset),
237   bool (*EQUALS)(V value, K key, int len)
238   &gt;
239 class CompactHashtable : public SimpleCompactHashtable {
240   friend class VMStructs;
241 
242   V decode(u4 offset) const {
243     return DECODE(_base_address, offset);
244   }
245 
246 public:
247   // Lookup a value V from the compact table using key K
248   inline V lookup(K key, unsigned int hash, int len) const {
249     if (_entry_count &gt; 0) {
250       int index = hash % _bucket_count;
</pre>
</td>
<td>
<hr />
<pre>
 83     unsigned int _hash;
 84     u4 _value;
 85 
 86   public:
 87     Entry() {}
 88     Entry(unsigned int hash, u4 val) : _hash(hash), _value(val) {}
 89 
 90     u4 value() {
 91       return _value;
 92     }
 93     unsigned int hash() {
 94       return _hash;
 95     }
 96 
 97     bool operator==(const CompactHashtableWriter::Entry&amp; other) {
 98       return (_value == other._value &amp;&amp; _hash == other._hash);
 99     }
100   }; // class CompactHashtableWriter::Entry
101 
102 private:
<span class="line-modified">103   int _num_entries_written;</span>
104   int _num_buckets;
105   int _num_empty_buckets;
106   int _num_value_only_buckets;
107   int _num_other_buckets;
108   GrowableArray&lt;Entry&gt;** _buckets;
109   CompactHashtableStats* _stats;
110   Array&lt;u4&gt;* _compact_buckets;
111   Array&lt;u4&gt;* _compact_entries;
112 
113 public:
114   // This is called at dump-time only
<span class="line-modified">115   CompactHashtableWriter(int num_entries, CompactHashtableStats* stats);</span>
116   ~CompactHashtableWriter();
117 
118   void add(unsigned int hash, u4 value);
119 
120 private:
121   void allocate_table();
122   void dump_table(NumberSeq* summary);
<span class="line-modified">123   static int calculate_num_buckets(int num_entries) {</span>







124     int num_buckets = num_entries / SharedSymbolTableBucketSize;
125     // calculation of num_buckets can result in zero buckets, we need at least one
126     return (num_buckets &lt; 1) ? 1 : num_buckets;
127   }
<span class="line-added">128 </span>
<span class="line-added">129 public:</span>
<span class="line-added">130   void dump(SimpleCompactHashtable *cht, const char* table_name);</span>
<span class="line-added">131 </span>
<span class="line-added">132   static size_t estimate_size(int num_entries);</span>
133 };
134 #endif // INCLUDE_CDS
135 
136 #define REGULAR_BUCKET_TYPE       0
137 #define VALUE_ONLY_BUCKET_TYPE    1
138 #define TABLEEND_BUCKET_TYPE      3
139 #define BUCKET_OFFSET_MASK        0x3FFFFFFF
140 #define BUCKET_OFFSET(info)       ((info) &amp; BUCKET_OFFSET_MASK)
141 #define BUCKET_TYPE_SHIFT         30
142 #define BUCKET_TYPE(info)         (((info) &amp; ~BUCKET_OFFSET_MASK) &gt;&gt; BUCKET_TYPE_SHIFT)
143 #define BUCKET_INFO(offset, type) (((type) &lt;&lt; BUCKET_TYPE_SHIFT) | ((offset) &amp; BUCKET_OFFSET_MASK))
144 
145 /////////////////////////////////////////////////////////////////////////////
146 //
147 // CompactHashtable is used to store the CDS archive&#39;s symbol/string tables.
148 //
149 // Because these tables are read-only (no entries can be added/deleted) at run-time
150 // and tend to have large number of entries, we try to minimize the footprint
151 // cost per entry.
152 //
</pre>
<hr />
<pre>
195   u4  _bucket_count;
196   u4  _entry_count;
197   u4* _buckets;
198   u4* _entries;
199 
200 public:
201   SimpleCompactHashtable() {
202     _entry_count = 0;
203     _bucket_count = 0;
204     _buckets = 0;
205     _entries = 0;
206   }
207 
208   void reset() {
209     _bucket_count = 0;
210     _entry_count = 0;
211     _buckets = 0;
212     _entries = 0;
213   }
214 
<span class="line-modified">215   void init(address base_address, u4 entry_count, u4 bucket_count, u4* buckets, u4* entries);</span>






216 
217   // Read/Write the table&#39;s header from/to the CDS archive
218   void serialize_header(SerializeClosure* soc) NOT_CDS_RETURN;
219 
220   inline bool empty() {
221     return (_entry_count == 0);
222   }
<span class="line-added">223 </span>
<span class="line-added">224   static size_t calculate_header_size();</span>
225 };
226 
227 template &lt;
228   typename K,
229   typename V,
230   V (*DECODE)(address base_address, u4 offset),
231   bool (*EQUALS)(V value, K key, int len)
232   &gt;
233 class CompactHashtable : public SimpleCompactHashtable {
234   friend class VMStructs;
235 
236   V decode(u4 offset) const {
237     return DECODE(_base_address, offset);
238   }
239 
240 public:
241   // Lookup a value V from the compact table using key K
242   inline V lookup(K key, unsigned int hash, int len) const {
243     if (_entry_count &gt; 0) {
244       int index = hash % _bucket_count;
</pre>
</td>
</tr>
</table>
<center><a href="compactHashtable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="defaultMethods.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
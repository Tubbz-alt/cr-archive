<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoader.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADER_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADER_HPP
 27 
 28 #include &quot;jimage.hpp&quot;

 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;runtime/perfData.hpp&quot;
 31 #include &quot;utilities/exceptions.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 // The VM class loader.
 35 #include &lt;sys/stat.h&gt;
 36 
 37 // Name of boot &quot;modules&quot; image
 38 #define  MODULES_IMAGE_NAME &quot;modules&quot;
 39 
 40 // Class path entry (directory or zip file)
 41 
 42 class JImageFile;
 43 class ClassFileStream;
 44 class PackageEntry;
 45 template &lt;typename T&gt; class GrowableArray;
 46 
 47 class ClassPathEntry : public CHeapObj&lt;mtClass&gt; {
 48 private:
 49   ClassPathEntry* volatile _next;


 50 public:
 51   ClassPathEntry* next() const;
 52   virtual ~ClassPathEntry() {}
 53   void set_next(ClassPathEntry* next);
<span class="line-modified"> 54   virtual bool is_modules_image() const = 0;</span>
<span class="line-modified"> 55   virtual bool is_jar_file() const = 0;</span>


 56   virtual const char* name() const = 0;
<span class="line-modified"> 57   virtual JImageFile* jimage() const = 0;</span>
<span class="line-modified"> 58   virtual void close_jimage() = 0;</span>
 59   // Constructor
 60   ClassPathEntry() : _next(NULL) {}
 61   // Attempt to locate file_name through this class path entry.
 62   // Returns a class file parsing stream if successfull.
 63   virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;




 64 };
 65 
 66 class ClassPathDirEntry: public ClassPathEntry {
 67  private:
 68   const char* _dir;           // Name of directory
 69  public:
<span class="line-removed"> 70   bool is_modules_image() const { return false; }</span>
<span class="line-removed"> 71   bool is_jar_file() const { return false;  }</span>
 72   const char* name() const { return _dir; }
<span class="line-modified"> 73   JImageFile* jimage() const { return NULL; }</span>
<span class="line-modified"> 74   void close_jimage() {}</span>
<span class="line-modified"> 75   ClassPathDirEntry(const char* dir);</span>
 76   virtual ~ClassPathDirEntry() {}
 77   ClassFileStream* open_stream(const char* name, TRAPS);
 78 };
 79 
<span class="line-removed"> 80 </span>
 81 // Type definitions for zip file and zip file entry
 82 typedef void* jzfile;
 83 typedef struct {
 84   char *name;                   /* entry name */
 85   jlong time;                   /* modification time */
 86   jlong size;                   /* size of uncompressed data */
 87   jlong csize;                  /* size of compressed data (zero if uncompressed) */
 88   jint crc;                     /* crc of uncompressed data */
 89   char *comment;                /* optional zip file comment */
 90   jbyte *extra;                 /* optional extra data */
 91   jlong pos;                    /* position of LOC header (if negative) or data */
 92 } jzentry;
 93 
 94 class ClassPathZipEntry: public ClassPathEntry {
 95  private:
 96   jzfile* _zip;              // The zip archive
 97   const char*   _zip_name;   // Name of zip archive

 98  public:
<span class="line-removed"> 99   bool is_modules_image() const { return false; }</span>
100   bool is_jar_file() const { return true;  }

101   const char* name() const { return _zip_name; }
<span class="line-modified">102   JImageFile* jimage() const { return NULL; }</span>
<span class="line-removed">103   void close_jimage() {}</span>
<span class="line-removed">104   ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append);</span>
105   virtual ~ClassPathZipEntry();
106   u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
107   ClassFileStream* open_stream(const char* name, TRAPS);
108   void contents_do(void f(const char* name, void* context), void* context);
109 };
110 
111 
112 // For java image files
113 class ClassPathImageEntry: public ClassPathEntry {
114 private:
115   JImageFile* _jimage;
116   const char* _name;

117 public:
118   bool is_modules_image() const;
<span class="line-removed">119   bool is_jar_file() const { return false; }</span>
120   bool is_open() const { return _jimage != NULL; }
121   const char* name() const { return _name == NULL ? &quot;&quot; : _name; }
122   JImageFile* jimage() const { return _jimage; }
123   void close_jimage();
124   ClassPathImageEntry(JImageFile* jimage, const char* name);
125   virtual ~ClassPathImageEntry();
126   ClassFileStream* open_stream(const char* name, TRAPS);

127 };
128 
129 // ModuleClassPathList contains a linked list of ClassPathEntry&#39;s
130 // that have been specified for a specific module.  Currently,
131 // the only way to specify a module/path pair is via the --patch-module
132 // command line option.
133 class ModuleClassPathList : public CHeapObj&lt;mtClass&gt; {
134 private:
135   Symbol* _module_name;
136   // First and last entries of class path entries for a specific module
137   ClassPathEntry* _module_first_entry;
138   ClassPathEntry* _module_last_entry;
139 public:
140   Symbol* module_name() const { return _module_name; }
141   ClassPathEntry* module_first_entry() const { return _module_first_entry; }
142   ModuleClassPathList(Symbol* module_name);
143   ~ModuleClassPathList();
144   void add_to_list(ClassPathEntry* new_entry);
145 };
146 
<span class="line-removed">147 class SharedPathsMiscInfo;</span>
<span class="line-removed">148 </span>
149 class ClassLoader: AllStatic {
150  public:
151   enum ClassLoaderType {
152     BOOT_LOADER = 1,      /* boot loader */
153     PLATFORM_LOADER  = 2, /* PlatformClassLoader */
154     APP_LOADER  = 3       /* AppClassLoader */
155   };
156  protected:
157 
158   // Performance counters
159   static PerfCounter* _perf_accumulated_time;
160   static PerfCounter* _perf_classes_inited;
161   static PerfCounter* _perf_class_init_time;
162   static PerfCounter* _perf_class_init_selftime;
163   static PerfCounter* _perf_classes_verified;
164   static PerfCounter* _perf_class_verify_time;
165   static PerfCounter* _perf_class_verify_selftime;
166   static PerfCounter* _perf_classes_linked;
167   static PerfCounter* _perf_class_link_time;
168   static PerfCounter* _perf_class_link_selftime;
</pre>
<hr />
<pre>
201 
202   // 1. Contains the module/path pairs specified to --patch-module
203   static GrowableArray&lt;ModuleClassPathList*&gt;* _patch_mod_entries;
204 
205   // 2. the base piece
206   //    Contains the ClassPathEntry of the modular java runtime image.
207   //    If no java runtime image is present, this indicates a
208   //    build with exploded modules is being used instead.
209   static ClassPathEntry* _jrt_entry;
210   static GrowableArray&lt;ModuleClassPathList*&gt;* _exploded_entries;
211   enum { EXPLODED_ENTRY_SIZE = 80 }; // Initial number of exploded modules
212 
213   // 3. the boot loader&#39;s append path
214   //    [-Xbootclasspath/a]; [jvmti appended entries]
215   //    Note: boot loader append path does not support named modules.
216   static ClassPathEntry* _first_append_entry;
217   // Last entry in linked list of appended ClassPathEntry instances
218   static ClassPathEntry* _last_append_entry;
219 
220   // Info used by CDS
<span class="line-removed">221   CDS_ONLY(static SharedPathsMiscInfo * _shared_paths_misc_info;)</span>
<span class="line-removed">222 </span>
223   CDS_ONLY(static ClassPathEntry* _app_classpath_entries;)
224   CDS_ONLY(static ClassPathEntry* _last_app_classpath_entry;)
225   CDS_ONLY(static ClassPathEntry* _module_path_entries;)
226   CDS_ONLY(static ClassPathEntry* _last_module_path_entry;)
227   CDS_ONLY(static void setup_app_search_path(const char* class_path);)
228   CDS_ONLY(static void setup_module_search_path(const char* path, TRAPS);)
229   static void add_to_app_classpath_entries(const char* path,
230                                            ClassPathEntry* entry,
231                                            bool check_for_duplicates);
232   CDS_ONLY(static void add_to_module_path_entries(const char* path,
233                                            ClassPathEntry* entry);)
234  public:
235   CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})
236   CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})
237 


238  protected:
239   // Initialization:
240   //   - setup the boot loader&#39;s system class path
241   //   - setup the boot loader&#39;s patch mod entries, if present
242   //   - create the ModuleEntry for java.base
243   static void setup_bootstrap_search_path();
244   static void setup_boot_search_path(const char *class_path);
245   static void setup_patch_mod_entries();
246   static void create_javabase();
247 


248   static void load_zip_library();
249   static void load_jimage_library();
250 
251  public:
252   static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,
253                                                  bool throw_exception,
<span class="line-modified">254                                                  bool is_boot_append, TRAPS);</span>

255 
256   // If the package for the fully qualified class name is in the boot
257   // loader&#39;s package entry table then add_package() sets the classpath_index
258   // field so that get_system_package() will know to return a non-null value
259   // for the package&#39;s location.  And, so that the package will be added to
260   // the list of packages returned by get_system_packages().
261   // For packages whose classes are loaded from the boot loader class path, the
262   // classpath_index indicates which entry on the boot loader class path.
263   static bool add_package(const char *fullq_class_name, s2 classpath_index, TRAPS);
264 
265   // Canonicalizes path names, so strcmp will work properly. This is mainly
266   // to avoid confusing the zip library
267   static bool get_canonical_path(const char* orig, char* out, int len);
268   static const char* file_name_for_class_name(const char* class_name,
269                                               int class_name_len);
270   static PackageEntry* get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS);
271 
272  public:
<span class="line-removed">273   static jboolean decompress(void *in, u8 inSize, void *out, u8 outSize, char **pmsg);</span>
274   static int crc32(int crc, const char* buf, int len);
275   static bool update_class_path_entry_list(const char *path,
276                                            bool check_for_duplicates,
277                                            bool is_boot_append,

278                                            bool throw_exception=true);
279   CDS_ONLY(static void update_module_path_entry_list(const char *path, TRAPS);)
280   static void print_bootclasspath();
281 
282   // Timing
283   static PerfCounter* perf_accumulated_time()         { return _perf_accumulated_time; }
284   static PerfCounter* perf_classes_inited()           { return _perf_classes_inited; }
285   static PerfCounter* perf_class_init_time()          { return _perf_class_init_time; }
286   static PerfCounter* perf_class_init_selftime()      { return _perf_class_init_selftime; }
287   static PerfCounter* perf_classes_verified()         { return _perf_classes_verified; }
288   static PerfCounter* perf_class_verify_time()        { return _perf_class_verify_time; }
289   static PerfCounter* perf_class_verify_selftime()    { return _perf_class_verify_selftime; }
290   static PerfCounter* perf_classes_linked()           { return _perf_classes_linked; }
291   static PerfCounter* perf_class_link_time()          { return _perf_class_link_time; }
292   static PerfCounter* perf_class_link_selftime()      { return _perf_class_link_selftime; }
293   static PerfCounter* perf_class_parse_time()         { return _perf_class_parse_time; }
294   static PerfCounter* perf_class_parse_selftime()     { return _perf_class_parse_selftime; }
295   static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }
296   static PerfCounter* perf_shared_classload_time()    { return _perf_shared_classload_time; }
297   static PerfCounter* perf_sys_classload_time()       { return _perf_sys_classload_time; }
</pre>
<hr />
<pre>
375   static ClassPathEntry* classpath_entry(int n);
376 
377   static bool is_in_patch_mod_entries(Symbol* module_name);
378 
379 #if INCLUDE_CDS
380   // Sharing dump and restore
381 
382   // Helper function used by CDS code to get the number of boot classpath
383   // entries during shared classpath setup time.
384   static int num_boot_classpath_entries();
385 
386   static ClassPathEntry* get_next_boot_classpath_entry(ClassPathEntry* e);
387 
388   // Helper function used by CDS code to get the number of app classpath
389   // entries during shared classpath setup time.
390   static int num_app_classpath_entries();
391 
392   // Helper function used by CDS code to get the number of module path
393   // entries during shared classpath setup time.
394   static int num_module_path_entries() {
<span class="line-modified">395     assert(DumpSharedSpaces, &quot;Should only be called at CDS dump time&quot;);</span>
396     int num_entries = 0;
397     ClassPathEntry* e= ClassLoader::_module_path_entries;
398     while (e != NULL) {
399       num_entries ++;
400       e = e-&gt;next();
401     }
402     return num_entries;
403   }
<span class="line-removed">404   static void  finalize_shared_paths_misc_info();</span>
<span class="line-removed">405   static int   get_shared_paths_misc_info_size();</span>
<span class="line-removed">406   static void* get_shared_paths_misc_info();</span>
<span class="line-removed">407   static bool  check_shared_paths_misc_info(void* info, int size);</span>
408   static void  exit_with_path_failure(const char* error, const char* message);
409   static char* skip_uri_protocol(char* source);
410   static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
411 #endif



412   static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,
413                                                 const char* file_name, jlong &amp;size);
414 
415   static void  trace_class_path(const char* msg, const char* name = NULL);
416 
417   // VM monitoring and management support
418   static jlong classloader_time_ms();
419   static jlong class_method_total_size();
420   static jlong class_init_count();
421   static jlong class_init_time_ms();
422   static jlong class_verify_time_ms();
423   static jlong class_link_count();
424   static jlong class_link_time_ms();
425 
426   // indicates if class path already contains a entry (exact match by name)
427   static bool contains_append_entry(const char* name);
428 
429   // adds a class path to the boot append entries
430   static void add_to_boot_append_entries(ClassPathEntry* new_entry);
431 
432   // creates a class path zip entry (returns NULL if JAR file cannot be opened)
433   static ClassPathZipEntry* create_class_path_zip_entry(const char *apath, bool is_boot_append);
434 
435   static bool string_ends_with(const char* str, const char* str_to_find);
436 
437   // obtain package name from a fully qualified class name
438   // *bad_class_name is set to true if there&#39;s a problem with parsing class_name, to
439   // distinguish from a class_name with no package name, as both cases have a NULL return value
440   static const char* package_from_name(const char* const class_name, bool* bad_class_name = NULL);
441 
<span class="line-removed">442   static bool is_modules_image(const char* name) { return string_ends_with(name, MODULES_IMAGE_NAME); }</span>
<span class="line-removed">443 </span>
444   // Debugging
445   static void verify()              PRODUCT_RETURN;
446 };
447 
448 // PerfClassTraceTime is used to measure time for class loading related events.
449 // This class tracks cumulative time and exclusive time for specific event types.
450 // During the execution of one event, other event types (e.g. class loading and
451 // resolution) as well as recursive calls of the same event type could happen.
452 // Only one elapsed timer (cumulative) and one thread-local self timer (exclusive)
453 // (i.e. only one event type) are active at a time even multiple PerfClassTraceTime
454 // instances have been created as multiple events are happening.
455 class PerfClassTraceTime {
456  public:
457   enum {
458     CLASS_LOAD   = 0,
459     PARSE_CLASS  = 1,
460     CLASS_LINK   = 2,
461     CLASS_VERIFY = 3,
462     CLASS_CLINIT = 4,
463     DEFINE_CLASS = 5,
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSLOADER_HPP
 26 #define SHARE_CLASSFILE_CLASSLOADER_HPP
 27 
 28 #include &quot;jimage.hpp&quot;
<span class="line-added"> 29 #include &quot;runtime/arguments.hpp&quot;</span>
 30 #include &quot;runtime/handles.hpp&quot;
 31 #include &quot;runtime/perfData.hpp&quot;
 32 #include &quot;utilities/exceptions.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 // The VM class loader.
 36 #include &lt;sys/stat.h&gt;
 37 
 38 // Name of boot &quot;modules&quot; image
 39 #define  MODULES_IMAGE_NAME &quot;modules&quot;
 40 
 41 // Class path entry (directory or zip file)
 42 
 43 class JImageFile;
 44 class ClassFileStream;
 45 class PackageEntry;
 46 template &lt;typename T&gt; class GrowableArray;
 47 
 48 class ClassPathEntry : public CHeapObj&lt;mtClass&gt; {
 49 private:
 50   ClassPathEntry* volatile _next;
<span class="line-added"> 51 protected:</span>
<span class="line-added"> 52   const char* copy_path(const char*path);</span>
 53 public:
 54   ClassPathEntry* next() const;
 55   virtual ~ClassPathEntry() {}
 56   void set_next(ClassPathEntry* next);
<span class="line-modified"> 57   virtual bool is_modules_image() const { return false; }</span>
<span class="line-modified"> 58   virtual bool is_jar_file() const { return false; }</span>
<span class="line-added"> 59   // Is this entry created from the &quot;Class-path&quot; attribute from a JAR Manifest?</span>
<span class="line-added"> 60   virtual bool from_class_path_attr() const { return false; }</span>
 61   virtual const char* name() const = 0;
<span class="line-modified"> 62   virtual JImageFile* jimage() const { return NULL; }</span>
<span class="line-modified"> 63   virtual void close_jimage() {}</span>
 64   // Constructor
 65   ClassPathEntry() : _next(NULL) {}
 66   // Attempt to locate file_name through this class path entry.
 67   // Returns a class file parsing stream if successfull.
 68   virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;
<span class="line-added"> 69   // Open the stream for a specific class loader</span>
<span class="line-added"> 70   virtual ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {</span>
<span class="line-added"> 71     return open_stream(name, THREAD);</span>
<span class="line-added"> 72   }</span>
 73 };
 74 
 75 class ClassPathDirEntry: public ClassPathEntry {
 76  private:
 77   const char* _dir;           // Name of directory
 78  public:


 79   const char* name() const { return _dir; }
<span class="line-modified"> 80   ClassPathDirEntry(const char* dir) {</span>
<span class="line-modified"> 81     _dir = copy_path(dir);</span>
<span class="line-modified"> 82   }</span>
 83   virtual ~ClassPathDirEntry() {}
 84   ClassFileStream* open_stream(const char* name, TRAPS);
 85 };
 86 

 87 // Type definitions for zip file and zip file entry
 88 typedef void* jzfile;
 89 typedef struct {
 90   char *name;                   /* entry name */
 91   jlong time;                   /* modification time */
 92   jlong size;                   /* size of uncompressed data */
 93   jlong csize;                  /* size of compressed data (zero if uncompressed) */
 94   jint crc;                     /* crc of uncompressed data */
 95   char *comment;                /* optional zip file comment */
 96   jbyte *extra;                 /* optional extra data */
 97   jlong pos;                    /* position of LOC header (if negative) or data */
 98 } jzentry;
 99 
100 class ClassPathZipEntry: public ClassPathEntry {
101  private:
102   jzfile* _zip;              // The zip archive
103   const char*   _zip_name;   // Name of zip archive
<span class="line-added">104   bool _from_class_path_attr; // From the &quot;Class-path&quot; attribute of a jar file</span>
105  public:

106   bool is_jar_file() const { return true;  }
<span class="line-added">107   bool from_class_path_attr() const { return _from_class_path_attr; }</span>
108   const char* name() const { return _zip_name; }
<span class="line-modified">109   ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append, bool from_class_path_attr);</span>


110   virtual ~ClassPathZipEntry();
111   u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
112   ClassFileStream* open_stream(const char* name, TRAPS);
113   void contents_do(void f(const char* name, void* context), void* context);
114 };
115 
116 
117 // For java image files
118 class ClassPathImageEntry: public ClassPathEntry {
119 private:
120   JImageFile* _jimage;
121   const char* _name;
<span class="line-added">122   DEBUG_ONLY(static ClassPathImageEntry* _singleton;)</span>
123 public:
124   bool is_modules_image() const;

125   bool is_open() const { return _jimage != NULL; }
126   const char* name() const { return _name == NULL ? &quot;&quot; : _name; }
127   JImageFile* jimage() const { return _jimage; }
128   void close_jimage();
129   ClassPathImageEntry(JImageFile* jimage, const char* name);
130   virtual ~ClassPathImageEntry();
131   ClassFileStream* open_stream(const char* name, TRAPS);
<span class="line-added">132   ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS);</span>
133 };
134 
135 // ModuleClassPathList contains a linked list of ClassPathEntry&#39;s
136 // that have been specified for a specific module.  Currently,
137 // the only way to specify a module/path pair is via the --patch-module
138 // command line option.
139 class ModuleClassPathList : public CHeapObj&lt;mtClass&gt; {
140 private:
141   Symbol* _module_name;
142   // First and last entries of class path entries for a specific module
143   ClassPathEntry* _module_first_entry;
144   ClassPathEntry* _module_last_entry;
145 public:
146   Symbol* module_name() const { return _module_name; }
147   ClassPathEntry* module_first_entry() const { return _module_first_entry; }
148   ModuleClassPathList(Symbol* module_name);
149   ~ModuleClassPathList();
150   void add_to_list(ClassPathEntry* new_entry);
151 };
152 


153 class ClassLoader: AllStatic {
154  public:
155   enum ClassLoaderType {
156     BOOT_LOADER = 1,      /* boot loader */
157     PLATFORM_LOADER  = 2, /* PlatformClassLoader */
158     APP_LOADER  = 3       /* AppClassLoader */
159   };
160  protected:
161 
162   // Performance counters
163   static PerfCounter* _perf_accumulated_time;
164   static PerfCounter* _perf_classes_inited;
165   static PerfCounter* _perf_class_init_time;
166   static PerfCounter* _perf_class_init_selftime;
167   static PerfCounter* _perf_classes_verified;
168   static PerfCounter* _perf_class_verify_time;
169   static PerfCounter* _perf_class_verify_selftime;
170   static PerfCounter* _perf_classes_linked;
171   static PerfCounter* _perf_class_link_time;
172   static PerfCounter* _perf_class_link_selftime;
</pre>
<hr />
<pre>
205 
206   // 1. Contains the module/path pairs specified to --patch-module
207   static GrowableArray&lt;ModuleClassPathList*&gt;* _patch_mod_entries;
208 
209   // 2. the base piece
210   //    Contains the ClassPathEntry of the modular java runtime image.
211   //    If no java runtime image is present, this indicates a
212   //    build with exploded modules is being used instead.
213   static ClassPathEntry* _jrt_entry;
214   static GrowableArray&lt;ModuleClassPathList*&gt;* _exploded_entries;
215   enum { EXPLODED_ENTRY_SIZE = 80 }; // Initial number of exploded modules
216 
217   // 3. the boot loader&#39;s append path
218   //    [-Xbootclasspath/a]; [jvmti appended entries]
219   //    Note: boot loader append path does not support named modules.
220   static ClassPathEntry* _first_append_entry;
221   // Last entry in linked list of appended ClassPathEntry instances
222   static ClassPathEntry* _last_append_entry;
223 
224   // Info used by CDS


225   CDS_ONLY(static ClassPathEntry* _app_classpath_entries;)
226   CDS_ONLY(static ClassPathEntry* _last_app_classpath_entry;)
227   CDS_ONLY(static ClassPathEntry* _module_path_entries;)
228   CDS_ONLY(static ClassPathEntry* _last_module_path_entry;)
229   CDS_ONLY(static void setup_app_search_path(const char* class_path);)
230   CDS_ONLY(static void setup_module_search_path(const char* path, TRAPS);)
231   static void add_to_app_classpath_entries(const char* path,
232                                            ClassPathEntry* entry,
233                                            bool check_for_duplicates);
234   CDS_ONLY(static void add_to_module_path_entries(const char* path,
235                                            ClassPathEntry* entry);)
236  public:
237   CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})
238   CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})
239 
<span class="line-added">240   static bool has_bootclasspath_append() { return _first_append_entry != NULL; }</span>
<span class="line-added">241 </span>
242  protected:
243   // Initialization:
244   //   - setup the boot loader&#39;s system class path
245   //   - setup the boot loader&#39;s patch mod entries, if present
246   //   - create the ModuleEntry for java.base
247   static void setup_bootstrap_search_path();
248   static void setup_boot_search_path(const char *class_path);
249   static void setup_patch_mod_entries();
250   static void create_javabase();
251 
<span class="line-added">252   static void* dll_lookup(void* lib, const char* name, const char* path);</span>
<span class="line-added">253   static void load_java_library();</span>
254   static void load_zip_library();
255   static void load_jimage_library();
256 
257  public:
258   static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,
259                                                  bool throw_exception,
<span class="line-modified">260                                                  bool is_boot_append,</span>
<span class="line-added">261                                                  bool from_class_path_attr, TRAPS);</span>
262 
263   // If the package for the fully qualified class name is in the boot
264   // loader&#39;s package entry table then add_package() sets the classpath_index
265   // field so that get_system_package() will know to return a non-null value
266   // for the package&#39;s location.  And, so that the package will be added to
267   // the list of packages returned by get_system_packages().
268   // For packages whose classes are loaded from the boot loader class path, the
269   // classpath_index indicates which entry on the boot loader class path.
270   static bool add_package(const char *fullq_class_name, s2 classpath_index, TRAPS);
271 
272   // Canonicalizes path names, so strcmp will work properly. This is mainly
273   // to avoid confusing the zip library
274   static bool get_canonical_path(const char* orig, char* out, int len);
275   static const char* file_name_for_class_name(const char* class_name,
276                                               int class_name_len);
277   static PackageEntry* get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS);
278 
279  public:

280   static int crc32(int crc, const char* buf, int len);
281   static bool update_class_path_entry_list(const char *path,
282                                            bool check_for_duplicates,
283                                            bool is_boot_append,
<span class="line-added">284                                            bool from_class_path_attr,</span>
285                                            bool throw_exception=true);
286   CDS_ONLY(static void update_module_path_entry_list(const char *path, TRAPS);)
287   static void print_bootclasspath();
288 
289   // Timing
290   static PerfCounter* perf_accumulated_time()         { return _perf_accumulated_time; }
291   static PerfCounter* perf_classes_inited()           { return _perf_classes_inited; }
292   static PerfCounter* perf_class_init_time()          { return _perf_class_init_time; }
293   static PerfCounter* perf_class_init_selftime()      { return _perf_class_init_selftime; }
294   static PerfCounter* perf_classes_verified()         { return _perf_classes_verified; }
295   static PerfCounter* perf_class_verify_time()        { return _perf_class_verify_time; }
296   static PerfCounter* perf_class_verify_selftime()    { return _perf_class_verify_selftime; }
297   static PerfCounter* perf_classes_linked()           { return _perf_classes_linked; }
298   static PerfCounter* perf_class_link_time()          { return _perf_class_link_time; }
299   static PerfCounter* perf_class_link_selftime()      { return _perf_class_link_selftime; }
300   static PerfCounter* perf_class_parse_time()         { return _perf_class_parse_time; }
301   static PerfCounter* perf_class_parse_selftime()     { return _perf_class_parse_selftime; }
302   static PerfCounter* perf_sys_class_lookup_time()    { return _perf_sys_class_lookup_time; }
303   static PerfCounter* perf_shared_classload_time()    { return _perf_shared_classload_time; }
304   static PerfCounter* perf_sys_classload_time()       { return _perf_sys_classload_time; }
</pre>
<hr />
<pre>
382   static ClassPathEntry* classpath_entry(int n);
383 
384   static bool is_in_patch_mod_entries(Symbol* module_name);
385 
386 #if INCLUDE_CDS
387   // Sharing dump and restore
388 
389   // Helper function used by CDS code to get the number of boot classpath
390   // entries during shared classpath setup time.
391   static int num_boot_classpath_entries();
392 
393   static ClassPathEntry* get_next_boot_classpath_entry(ClassPathEntry* e);
394 
395   // Helper function used by CDS code to get the number of app classpath
396   // entries during shared classpath setup time.
397   static int num_app_classpath_entries();
398 
399   // Helper function used by CDS code to get the number of module path
400   // entries during shared classpath setup time.
401   static int num_module_path_entries() {
<span class="line-modified">402     Arguments::assert_is_dumping_archive();</span>
403     int num_entries = 0;
404     ClassPathEntry* e= ClassLoader::_module_path_entries;
405     while (e != NULL) {
406       num_entries ++;
407       e = e-&gt;next();
408     }
409     return num_entries;
410   }




411   static void  exit_with_path_failure(const char* error, const char* message);
412   static char* skip_uri_protocol(char* source);
413   static void  record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS);
414 #endif
<span class="line-added">415 </span>
<span class="line-added">416   static char* lookup_vm_options();</span>
<span class="line-added">417 </span>
418   static JImageLocationRef jimage_find_resource(JImageFile* jf, const char* module_name,
419                                                 const char* file_name, jlong &amp;size);
420 
421   static void  trace_class_path(const char* msg, const char* name = NULL);
422 
423   // VM monitoring and management support
424   static jlong classloader_time_ms();
425   static jlong class_method_total_size();
426   static jlong class_init_count();
427   static jlong class_init_time_ms();
428   static jlong class_verify_time_ms();
429   static jlong class_link_count();
430   static jlong class_link_time_ms();
431 
432   // indicates if class path already contains a entry (exact match by name)
433   static bool contains_append_entry(const char* name);
434 
435   // adds a class path to the boot append entries
436   static void add_to_boot_append_entries(ClassPathEntry* new_entry);
437 
438   // creates a class path zip entry (returns NULL if JAR file cannot be opened)
439   static ClassPathZipEntry* create_class_path_zip_entry(const char *apath, bool is_boot_append);
440 
441   static bool string_ends_with(const char* str, const char* str_to_find);
442 
443   // obtain package name from a fully qualified class name
444   // *bad_class_name is set to true if there&#39;s a problem with parsing class_name, to
445   // distinguish from a class_name with no package name, as both cases have a NULL return value
446   static const char* package_from_name(const char* const class_name, bool* bad_class_name = NULL);
447 


448   // Debugging
449   static void verify()              PRODUCT_RETURN;
450 };
451 
452 // PerfClassTraceTime is used to measure time for class loading related events.
453 // This class tracks cumulative time and exclusive time for specific event types.
454 // During the execution of one event, other event types (e.g. class loading and
455 // resolution) as well as recursive calls of the same event type could happen.
456 // Only one elapsed timer (cumulative) and one thread-local self timer (exclusive)
457 // (i.e. only one event type) are active at a time even multiple PerfClassTraceTime
458 // instances have been created as multiple events are happening.
459 class PerfClassTraceTime {
460  public:
461   enum {
462     CLASS_LOAD   = 0,
463     PARSE_CLASS  = 1,
464     CLASS_LINK   = 2,
465     CLASS_VERIFY = 3,
466     CLASS_CLINIT = 4,
467     DEFINE_CLASS = 5,
</pre>
</td>
</tr>
</table>
<center><a href="classLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
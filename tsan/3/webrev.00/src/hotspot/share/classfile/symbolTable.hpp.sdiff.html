<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/symbolTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/symbolTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYMBOLTABLE_HPP
 26 #define SHARE_CLASSFILE_SYMBOLTABLE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
<span class="line-modified"> 31 #include &quot;utilities/concurrentHashTable.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;utilities/hashtable.hpp&quot;</span>
 33 
 34 class JavaThread;
 35 
 36 // TempNewSymbol acts as a handle class in a handle/body idiom and is
 37 // responsible for proper resource management of the body (which is a Symbol*).
 38 // The body is resource managed by a reference counting scheme.
 39 // TempNewSymbol can therefore be used to properly hold a newly created or referenced
 40 // Symbol* temporarily in scope.
 41 //
 42 // Routines in SymbolTable will initialize the reference count of a Symbol* before
 43 // it becomes &quot;managed&quot; by TempNewSymbol instances. As a handle class, TempNewSymbol
 44 // needs to maintain proper reference counting in context of copy semantics.
 45 //
<span class="line-modified"> 46 // In SymbolTable, new_symbol() and lookup() will create a Symbol* if not already in the</span>
 47 // symbol table and add to the symbol&#39;s reference count.
 48 // probe() and lookup_only() will increment the refcount if symbol is found.
 49 class TempNewSymbol : public StackObj {
 50   Symbol* _temp;
 51 
 52 public:
 53   TempNewSymbol() : _temp(NULL) {}
 54 
 55   // Conversion from a Symbol* to a TempNewSymbol.
 56   // Does not increment the current reference count.
 57   TempNewSymbol(Symbol *s) : _temp(s) {}
 58 
 59   // Copy constructor increments reference count.
 60   TempNewSymbol(const TempNewSymbol&amp; rhs) : _temp(rhs._temp) {
 61     if (_temp != NULL) {
 62       _temp-&gt;increment_refcount();
 63     }
 64   }
 65 
 66   // Assignment operator uses a c++ trick called copy and swap idiom.
</pre>
<hr />
<pre>
 73     _temp = tmp;
 74   }
 75 
 76   // Decrement reference counter so it can go away if it&#39;s unused
 77   ~TempNewSymbol() {
 78     if (_temp != NULL) {
 79       _temp-&gt;decrement_refcount();
 80     }
 81   }
 82 
 83   // Symbol* conversion operators
 84   Symbol* operator -&gt; () const                   { return _temp; }
 85   bool    operator == (Symbol* o) const          { return _temp == o; }
 86   operator Symbol*()                             { return _temp; }
 87 };
 88 
 89 class CompactHashtableWriter;
 90 class SerializeClosure;
 91 
 92 class SymbolTableConfig;
<span class="line-removed"> 93 typedef ConcurrentHashTable&lt;Symbol*,</span>
<span class="line-removed"> 94                               SymbolTableConfig, mtSymbol&gt; SymbolTableHash;</span>
<span class="line-removed"> 95 </span>
 96 class SymbolTableCreateEntry;
 97 
<span class="line-modified"> 98 class SymbolTable : public CHeapObj&lt;mtSymbol&gt; {</span>



 99   friend class VMStructs;
100   friend class Symbol;
101   friend class ClassFileParser;
102   friend class SymbolTableConfig;
103   friend class SymbolTableCreateEntry;
104 
<span class="line-modified">105 private:</span>
<span class="line-modified">106   static void delete_symbol(Symbol* sym);</span>
<span class="line-removed">107   void grow(JavaThread* jt);</span>
<span class="line-removed">108   void clean_dead_entries(JavaThread* jt);</span>
<span class="line-removed">109 </span>
<span class="line-removed">110   // The symbol table</span>
<span class="line-removed">111   static SymbolTable* _the_table;</span>
<span class="line-removed">112   static volatile bool _lookup_shared_first;</span>
<span class="line-removed">113   static volatile bool _alt_hash;</span>
<span class="line-removed">114 </span>
<span class="line-removed">115   // For statistics</span>
<span class="line-removed">116   volatile size_t _symbols_removed;</span>
<span class="line-removed">117   volatile size_t _symbols_counted;</span>
118 
<span class="line-removed">119   SymbolTableHash* _local_table;</span>
<span class="line-removed">120   size_t _current_size;</span>
<span class="line-removed">121   volatile bool _has_work;</span>
122   // Set if one bucket is out of balance due to hash algorithm deficiency
<span class="line-modified">123   volatile bool _needs_rehashing;</span>
124 
<span class="line-modified">125   volatile size_t _items_count;</span>
<span class="line-modified">126   volatile bool   _has_items_to_clean;</span>

127 
<span class="line-modified">128   double get_load_factor() const;</span>
129 
<span class="line-modified">130   void check_concurrent_work();</span>
131 
132   static void item_added();
133   static void item_removed();
134 
135   // For cleaning
<span class="line-modified">136   void reset_has_items_to_clean();</span>
<span class="line-modified">137   void mark_has_items_to_clean();</span>
<span class="line-modified">138   bool has_items_to_clean() const;</span>
139 
<span class="line-modified">140   SymbolTable();</span>


141 
<span class="line-modified">142   Symbol* allocate_symbol(const char* name, int len, bool c_heap, TRAPS); // Assumes no characters larger than 0x7F</span>
<span class="line-modified">143   Symbol* do_lookup(const char* name, int len, uintx hash);</span>
<span class="line-modified">144   Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool heap, TRAPS);</span>
145 
146   // Adding elements
147   static void new_symbols(ClassLoaderData* loader_data,
148                           const constantPoolHandle&amp; cp, int names_count,
149                           const char** name, int* lengths,
<span class="line-modified">150                           int* cp_indices, unsigned int* hashValues,</span>
<span class="line-removed">151                           TRAPS);</span>
152 
<span class="line-modified">153   static Symbol* lookup_shared(const char* name, int len, unsigned int hash);</span>
<span class="line-modified">154   Symbol* lookup_dynamic(const char* name, int len, unsigned int hash);</span>
<span class="line-modified">155   Symbol* lookup_common(const char* name, int len, unsigned int hash);</span>
156 
157   // Arena for permanent symbols (null class loader) that are never unloaded
158   static Arena*  _arena;
159   static Arena* arena() { return _arena; }  // called for statistics
160 
<span class="line-modified">161   static void initialize_symbols(int arena_alloc_size = 0);</span>
162 
<span class="line-modified">163   void concurrent_work(JavaThread* jt);</span>
<span class="line-modified">164   void print_table_statistics(outputStream* st, const char* table_name);</span>
<span class="line-removed">165 </span>
<span class="line-removed">166   void try_rehash_table();</span>
<span class="line-removed">167   bool do_rehash();</span>
<span class="line-removed">168   inline void update_needs_rehash(bool rehash);</span>
169 
170 public:
171   // The symbol table
<span class="line-modified">172   static SymbolTable* the_table() { return _the_table; }</span>
<span class="line-modified">173   size_t table_size();</span>
174 
175   enum {
176     symbol_alloc_batch_size = 8,
177     // Pick initial size based on java -version size measurements
178     symbol_alloc_arena_size = 360*K // TODO (revisit)
179   };
180 
<span class="line-modified">181   static void create_table() {</span>
<span class="line-removed">182     assert(_the_table == NULL, &quot;One symbol table allowed.&quot;);</span>
<span class="line-removed">183     _the_table = new SymbolTable();</span>
<span class="line-removed">184     initialize_symbols(symbol_alloc_arena_size);</span>
<span class="line-removed">185   }</span>
186 
187   static void do_concurrent_work(JavaThread* jt);
<span class="line-modified">188   static bool has_work() { return the_table()-&gt;_has_work; }</span>
189   static void trigger_cleanup();
190 
191   // Probing
<span class="line-removed">192   static Symbol* lookup(const char* name, int len, TRAPS);</span>
<span class="line-removed">193   // lookup only, won&#39;t add. Also calculate hash.</span>
<span class="line-removed">194   static Symbol* lookup_only(const char* name, int len, unsigned int&amp; hash);</span>
<span class="line-removed">195   // adds new symbol if not found</span>
<span class="line-removed">196   static Symbol* lookup(const Symbol* sym, int begin, int end, TRAPS);</span>
<span class="line-removed">197   // jchar (UTF16) version of lookups</span>
<span class="line-removed">198   static Symbol* lookup_unicode(const jchar* name, int len, TRAPS);</span>
<span class="line-removed">199   static Symbol* lookup_only_unicode(const jchar* name, int len, unsigned int&amp; hash);</span>
200   // Needed for preloading classes in signatures when compiling.
201   // Returns the symbol is already present in symbol table, otherwise
202   // NULL.  NO ALLOCATION IS GUARANTEED!
203   static Symbol* probe(const char* name, int len) {
204     unsigned int ignore_hash;
205     return lookup_only(name, len, ignore_hash);
206   }
207   static Symbol* probe_unicode(const jchar* name, int len) {
208     unsigned int ignore_hash;
209     return lookup_only_unicode(name, len, ignore_hash);
210   }
211 
<span class="line-modified">212   // Symbol creation</span>
<span class="line-modified">213   static Symbol* new_symbol(const char* utf8_buffer, int length, TRAPS) {</span>
<span class="line-modified">214     assert(utf8_buffer != NULL, &quot;just checking&quot;);</span>
<span class="line-modified">215     return lookup(utf8_buffer, length, THREAD);</span>
<span class="line-modified">216   }</span>
<span class="line-modified">217   static Symbol* new_symbol(const char* name, TRAPS) {</span>
<span class="line-modified">218     return new_symbol(name, (int)strlen(name), THREAD);</span>
<span class="line-modified">219   }</span>
<span class="line-removed">220   static Symbol* new_symbol(const Symbol* sym, int begin, int end, TRAPS) {</span>
<span class="line-removed">221     assert(begin &lt;= end &amp;&amp; end &lt;= sym-&gt;utf8_length(), &quot;just checking&quot;);</span>
<span class="line-removed">222     return lookup(sym, begin, end, THREAD);</span>
223   }

224   // Create a symbol in the arena for symbols that are not deleted
<span class="line-modified">225   static Symbol* new_permanent_symbol(const char* name, TRAPS);</span>
226 
227   // Rehash the string table if it gets out of balance
228   static void rehash_table();
<span class="line-modified">229   static bool needs_rehashing()</span>
<span class="line-modified">230     { return SymbolTable::the_table()-&gt;_needs_rehashing; }</span>




231 
232   // Heap dumper and CDS
233   static void symbols_do(SymbolClosure *cl);
234 
235   // Sharing
236 private:
237   static void copy_shared_symbol_table(CompactHashtableWriter* ch_table);
238 public:
<span class="line-modified">239   static void write_to_archive() NOT_CDS_RETURN;</span>
<span class="line-modified">240   static void serialize_shared_table_header(SerializeClosure* soc) NOT_CDS_RETURN;</span>


241   static void metaspace_pointers_do(MetaspaceClosure* it);
242 
243   // Jcmd
244   static void dump(outputStream* st, bool verbose=false);
245   // Debugging
246   static void verify();
<span class="line-removed">247   static void read(const char* filename, TRAPS);</span>
248 
249   // Histogram
250   static void print_histogram() PRODUCT_RETURN;
251 };
252 
253 #endif // SHARE_CLASSFILE_SYMBOLTABLE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYMBOLTABLE_HPP
 26 #define SHARE_CLASSFILE_SYMBOLTABLE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
<span class="line-modified"> 31 #include &quot;utilities/tableStatistics.hpp&quot;</span>

 32 
 33 class JavaThread;
 34 
 35 // TempNewSymbol acts as a handle class in a handle/body idiom and is
 36 // responsible for proper resource management of the body (which is a Symbol*).
 37 // The body is resource managed by a reference counting scheme.
 38 // TempNewSymbol can therefore be used to properly hold a newly created or referenced
 39 // Symbol* temporarily in scope.
 40 //
 41 // Routines in SymbolTable will initialize the reference count of a Symbol* before
 42 // it becomes &quot;managed&quot; by TempNewSymbol instances. As a handle class, TempNewSymbol
 43 // needs to maintain proper reference counting in context of copy semantics.
 44 //
<span class="line-modified"> 45 // In SymbolTable, new_symbol() will create a Symbol* if not already in the</span>
 46 // symbol table and add to the symbol&#39;s reference count.
 47 // probe() and lookup_only() will increment the refcount if symbol is found.
 48 class TempNewSymbol : public StackObj {
 49   Symbol* _temp;
 50 
 51 public:
 52   TempNewSymbol() : _temp(NULL) {}
 53 
 54   // Conversion from a Symbol* to a TempNewSymbol.
 55   // Does not increment the current reference count.
 56   TempNewSymbol(Symbol *s) : _temp(s) {}
 57 
 58   // Copy constructor increments reference count.
 59   TempNewSymbol(const TempNewSymbol&amp; rhs) : _temp(rhs._temp) {
 60     if (_temp != NULL) {
 61       _temp-&gt;increment_refcount();
 62     }
 63   }
 64 
 65   // Assignment operator uses a c++ trick called copy and swap idiom.
</pre>
<hr />
<pre>
 72     _temp = tmp;
 73   }
 74 
 75   // Decrement reference counter so it can go away if it&#39;s unused
 76   ~TempNewSymbol() {
 77     if (_temp != NULL) {
 78       _temp-&gt;decrement_refcount();
 79     }
 80   }
 81 
 82   // Symbol* conversion operators
 83   Symbol* operator -&gt; () const                   { return _temp; }
 84   bool    operator == (Symbol* o) const          { return _temp == o; }
 85   operator Symbol*()                             { return _temp; }
 86 };
 87 
 88 class CompactHashtableWriter;
 89 class SerializeClosure;
 90 
 91 class SymbolTableConfig;



 92 class SymbolTableCreateEntry;
 93 
<span class="line-modified"> 94 class constantPoolHandle;</span>
<span class="line-added"> 95 class SymbolClosure;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 class SymbolTable : public AllStatic {</span>
 98   friend class VMStructs;
 99   friend class Symbol;
100   friend class ClassFileParser;
101   friend class SymbolTableConfig;
102   friend class SymbolTableCreateEntry;
103 
<span class="line-modified">104  private:</span>
<span class="line-modified">105   static volatile bool _has_work;</span>











106 



107   // Set if one bucket is out of balance due to hash algorithm deficiency
<span class="line-modified">108   static volatile bool _needs_rehashing;</span>
109 
<span class="line-modified">110   static void delete_symbol(Symbol* sym);</span>
<span class="line-modified">111   static void grow(JavaThread* jt);</span>
<span class="line-added">112   static void clean_dead_entries(JavaThread* jt);</span>
113 
<span class="line-modified">114   static double get_load_factor();</span>
115 
<span class="line-modified">116   static void check_concurrent_work();</span>
117 
118   static void item_added();
119   static void item_removed();
120 
121   // For cleaning
<span class="line-modified">122   static void reset_has_items_to_clean();</span>
<span class="line-modified">123   static void mark_has_items_to_clean();</span>
<span class="line-modified">124   static bool has_items_to_clean();</span>
125 
<span class="line-modified">126   static Symbol* allocate_symbol(const char* name, int len, bool c_heap); // Assumes no characters larger than 0x7F</span>
<span class="line-added">127   static Symbol* do_lookup(const char* name, int len, uintx hash);</span>
<span class="line-added">128   static Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool heap);</span>
129 
<span class="line-modified">130   // lookup only, won&#39;t add. Also calculate hash. Used by the ClassfileParser.</span>
<span class="line-modified">131   static Symbol* lookup_only(const char* name, int len, unsigned int&amp; hash);</span>
<span class="line-modified">132   static Symbol* lookup_only_unicode(const jchar* name, int len, unsigned int&amp; hash);</span>
133 
134   // Adding elements
135   static void new_symbols(ClassLoaderData* loader_data,
136                           const constantPoolHandle&amp; cp, int names_count,
137                           const char** name, int* lengths,
<span class="line-modified">138                           int* cp_indices, unsigned int* hashValues);</span>

139 
<span class="line-modified">140   static Symbol* lookup_shared(const char* name, int len, unsigned int hash) NOT_CDS_RETURN_(NULL);</span>
<span class="line-modified">141   static Symbol* lookup_dynamic(const char* name, int len, unsigned int hash);</span>
<span class="line-modified">142   static Symbol* lookup_common(const char* name, int len, unsigned int hash);</span>
143 
144   // Arena for permanent symbols (null class loader) that are never unloaded
145   static Arena*  _arena;
146   static Arena* arena() { return _arena; }  // called for statistics
147 
<span class="line-modified">148   static void print_table_statistics(outputStream* st, const char* table_name);</span>
149 
<span class="line-modified">150   static void try_rehash_table();</span>
<span class="line-modified">151   static bool do_rehash();</span>




152 
153 public:
154   // The symbol table
<span class="line-modified">155   static size_t table_size();</span>
<span class="line-modified">156   static TableStatistics get_table_statistics();</span>
157 
158   enum {
159     symbol_alloc_batch_size = 8,
160     // Pick initial size based on java -version size measurements
161     symbol_alloc_arena_size = 360*K // TODO (revisit)
162   };
163 
<span class="line-modified">164   static void create_table();</span>




165 
166   static void do_concurrent_work(JavaThread* jt);
<span class="line-modified">167   static bool has_work() { return _has_work; }</span>
168   static void trigger_cleanup();
169 
170   // Probing








171   // Needed for preloading classes in signatures when compiling.
172   // Returns the symbol is already present in symbol table, otherwise
173   // NULL.  NO ALLOCATION IS GUARANTEED!
174   static Symbol* probe(const char* name, int len) {
175     unsigned int ignore_hash;
176     return lookup_only(name, len, ignore_hash);
177   }
178   static Symbol* probe_unicode(const jchar* name, int len) {
179     unsigned int ignore_hash;
180     return lookup_only_unicode(name, len, ignore_hash);
181   }
182 
<span class="line-modified">183   // Symbol lookup and create if not found.</span>
<span class="line-modified">184   // jchar (UTF16) version of lookup</span>
<span class="line-modified">185   static Symbol* new_symbol(const jchar* name, int len);</span>
<span class="line-modified">186   // char (UTF8) versions</span>
<span class="line-modified">187   static Symbol* new_symbol(const Symbol* sym, int begin, int end);</span>
<span class="line-modified">188   static Symbol* new_symbol(const char* utf8_buffer, int length);</span>
<span class="line-modified">189   static Symbol* new_symbol(const char* name) {</span>
<span class="line-modified">190     return new_symbol(name, (int)strlen(name));</span>



191   }
<span class="line-added">192 </span>
193   // Create a symbol in the arena for symbols that are not deleted
<span class="line-modified">194   static Symbol* new_permanent_symbol(const char* name);</span>
195 
196   // Rehash the string table if it gets out of balance
197   static void rehash_table();
<span class="line-modified">198   static bool needs_rehashing() { return _needs_rehashing; }</span>
<span class="line-modified">199   static inline void update_needs_rehash(bool rehash) {</span>
<span class="line-added">200     if (rehash) {</span>
<span class="line-added">201       _needs_rehashing = true;</span>
<span class="line-added">202     }</span>
<span class="line-added">203   }</span>
204 
205   // Heap dumper and CDS
206   static void symbols_do(SymbolClosure *cl);
207 
208   // Sharing
209 private:
210   static void copy_shared_symbol_table(CompactHashtableWriter* ch_table);
211 public:
<span class="line-modified">212   static size_t estimate_size_for_archive() NOT_CDS_RETURN_(0);</span>
<span class="line-modified">213   static void write_to_archive(bool is_static_archive = true) NOT_CDS_RETURN;</span>
<span class="line-added">214   static void serialize_shared_table_header(SerializeClosure* soc,</span>
<span class="line-added">215                                             bool is_static_archive = true) NOT_CDS_RETURN;</span>
216   static void metaspace_pointers_do(MetaspaceClosure* it);
217 
218   // Jcmd
219   static void dump(outputStream* st, bool verbose=false);
220   // Debugging
221   static void verify();

222 
223   // Histogram
224   static void print_histogram() PRODUCT_RETURN;
225 };
226 
227 #endif // SHARE_CLASSFILE_SYMBOLTABLE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/classLoaderDataGraph.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderDataGraph.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,15 +46,30 @@</span>
  
  volatile size_t ClassLoaderDataGraph::_num_array_classes = 0;
  volatile size_t ClassLoaderDataGraph::_num_instance_classes = 0;
  
  void ClassLoaderDataGraph::clear_claimed_marks() {
<span class="udiff-line-modified-removed">-   for (ClassLoaderData* cld = _head; cld != NULL; cld = cld-&gt;next()) {</span>
<span class="udiff-line-modified-added">+   // The claimed marks of the CLDs in the ClassLoaderDataGraph are cleared</span>
<span class="udiff-line-added">+   // outside a safepoint and without locking the ClassLoaderDataGraph_lock.</span>
<span class="udiff-line-added">+   // This is required to avoid a deadlock between concurrent GC threads and safepointing.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // We need to make sure that the CLD contents are fully visible to the</span>
<span class="udiff-line-added">+   // reader thread. This is accomplished by acquire/release of the _head,</span>
<span class="udiff-line-added">+   // and is sufficient.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // Any ClassLoaderData added after or during walking the list are prepended to</span>
<span class="udiff-line-added">+   // _head. Their claim mark need not be handled here.</span>
<span class="udiff-line-added">+   for (ClassLoaderData* cld = Atomic::load_acquire(&amp;_head); cld != NULL; cld = cld-&gt;next()) {</span>
      cld-&gt;clear_claim();
    }
  }
  
<span class="udiff-line-added">+ void ClassLoaderDataGraph::clear_claimed_marks(int claim) {</span>
<span class="udiff-line-added">+  for (ClassLoaderData* cld = Atomic::load_acquire(&amp;_head); cld != NULL; cld = cld-&gt;next()) {</span>
<span class="udiff-line-added">+     cld-&gt;clear_claim(claim);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  // Class iterator used by the compiler.  It gets some number of classes at
  // a safepoint to decay invocation counters on the methods.
  class ClassLoaderDataGraphKlassIteratorStatic {
    ClassLoaderData* _current_loader_data;
    Klass*           _current_class_entry;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,21 +176,18 @@</span>
    // on the stack or in the code cache, so we only have to repeat the full walk if
    // they were found at that time.
    // TODO: have redefinition clean old methods out of the code cache.  They still exist in some places.
    bool walk_all_metadata = InstanceKlass::has_previous_versions_and_reset();
  
<span class="udiff-line-modified-removed">-   MetadataOnStackMark md_on_stack(walk_all_metadata);</span>
<span class="udiff-line-modified-added">+   MetadataOnStackMark md_on_stack(walk_all_metadata, /*redefinition_walk*/false);</span>
    clean_deallocate_lists(walk_all_metadata);
  }
  
  // GC root of class loader data created.
<span class="udiff-line-modified-removed">- ClassLoaderData* ClassLoaderDataGraph::_head = NULL;</span>
<span class="udiff-line-modified-added">+ ClassLoaderData* volatile ClassLoaderDataGraph::_head = NULL;</span>
  ClassLoaderData* ClassLoaderDataGraph::_unloading = NULL;
<span class="udiff-line-removed">- ClassLoaderData* ClassLoaderDataGraph::_saved_unloading = NULL;</span>
<span class="udiff-line-removed">- ClassLoaderData* ClassLoaderDataGraph::_saved_head = NULL;</span>
  
<span class="udiff-line-removed">- bool ClassLoaderDataGraph::_should_purge = false;</span>
  bool ClassLoaderDataGraph::_should_clean_deallocate_lists = false;
  bool ClassLoaderDataGraph::_safepoint_cleanup_needed = false;
  bool ClassLoaderDataGraph::_metaspace_oom = false;
  
  // Add a new class loader data node to the list.  Assign the newly created
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -202,11 +214,11 @@</span>
  
    cld = new ClassLoaderData(loader, is_unsafe_anonymous);
  
    // First install the new CLD to the Graph.
    cld-&gt;set_next(_head);
<span class="udiff-line-modified-removed">-   _head = cld;</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(&amp;_head, cld);</span>
  
    // Next associate with the class_loader.
    if (!is_unsafe_anonymous) {
      // Use OrderAccess, since readers need to get the loader_data only after
      // it&#39;s added to the Graph
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -231,13 +243,11 @@</span>
    return loader_data;
  }
  
  void ClassLoaderDataGraph::cld_unloading_do(CLDClosure* cl) {
    assert_locked_or_safepoint_weak(ClassLoaderDataGraph_lock);
<span class="udiff-line-modified-removed">-   // Only walk the head until any clds not purged from prior unloading</span>
<span class="udiff-line-removed">-   // (CMS doesn&#39;t purge right away).</span>
<span class="udiff-line-removed">-   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
<span class="udiff-line-modified-added">+   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>
      assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
      cl-&gt;do_cld(cld);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -267,21 +277,31 @@</span>
    } else {
      cld_do(cl);
    }
  }
  
<span class="udiff-line-modified-removed">- // Closure for locking and iterating through classes.</span>
<span class="udiff-line-modified-removed">- LockedClassesDo::LockedClassesDo(classes_do_func_t f) : _function(f) {</span>
<span class="udiff-line-modified-removed">-   ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="udiff-line-modified-added">+ // Closure for locking and iterating through classes. Only lock outside of safepoint.</span>
<span class="udiff-line-modified-added">+ LockedClassesDo::LockedClassesDo(classes_do_func_t f) : _function(f),</span>
<span class="udiff-line-modified-added">+   _do_lock(!SafepointSynchronize::is_at_safepoint()) {</span>
<span class="udiff-line-added">+   if (_do_lock) {</span>
<span class="udiff-line-added">+     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-modified-removed">- LockedClassesDo::LockedClassesDo() : _function(NULL) {</span>
<span class="udiff-line-modified-added">+ LockedClassesDo::LockedClassesDo() : _function(NULL),</span>
<span class="udiff-line-added">+   _do_lock(!SafepointSynchronize::is_at_safepoint()) {</span>
    // callers provide their own do_klass
<span class="udiff-line-modified-removed">-   ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="udiff-line-modified-added">+   if (_do_lock) {</span>
<span class="udiff-line-added">+     ClassLoaderDataGraph_lock-&gt;lock();</span>
<span class="udiff-line-added">+   }</span>
  }
  
<span class="udiff-line-modified-removed">- LockedClassesDo::~LockedClassesDo() { ClassLoaderDataGraph_lock-&gt;unlock(); }</span>
<span class="udiff-line-modified-added">+ LockedClassesDo::~LockedClassesDo() {</span>
<span class="udiff-line-added">+   if (_do_lock) {</span>
<span class="udiff-line-added">+     ClassLoaderDataGraph_lock-&gt;unlock();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  
  // Iterating over the CLDG needs to be locked because
  // unloading can remove entries concurrently soon.
  class ClassLoaderDataGraphIterator : public StackObj {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,12 +311,11 @@</span>
    Thread*          _thread;
    NoSafepointVerifier _nsv; // No safepoints allowed in this scope
                              // unless verifying at a safepoint.
  
  public:
<span class="udiff-line-modified-removed">-   ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head),</span>
<span class="udiff-line-removed">-      _nsv(true, !SafepointSynchronize::is_at_safepoint()) {</span>
<span class="udiff-line-modified-added">+   ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head) {</span>
      _thread = Thread::current();
      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
    }
  
    ClassLoaderData* get_next() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,13 +373,11 @@</span>
    }
  }
  
  void ClassLoaderDataGraph::modules_unloading_do(void f(ModuleEntry*)) {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="udiff-line-modified-removed">-   // Only walk the head until any clds not purged from prior unloading</span>
<span class="udiff-line-removed">-   // (CMS doesn&#39;t purge right away).</span>
<span class="udiff-line-removed">-   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
<span class="udiff-line-modified-added">+   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>
      assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
      cld-&gt;modules_do(f);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -372,13 +389,11 @@</span>
    }
  }
  
  void ClassLoaderDataGraph::packages_unloading_do(void f(PackageEntry*)) {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="udiff-line-modified-removed">-   // Only walk the head until any clds not purged from prior unloading</span>
<span class="udiff-line-removed">-   // (CMS doesn&#39;t purge right away).</span>
<span class="udiff-line-removed">-   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
<span class="udiff-line-modified-added">+   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>
      assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
      cld-&gt;packages_do(f);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -397,13 +412,11 @@</span>
  }
  
  
  void ClassLoaderDataGraph::classes_unloading_do(void f(Klass* const)) {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
<span class="udiff-line-modified-removed">-   // Only walk the head until any clds not purged from prior unloading</span>
<span class="udiff-line-removed">-   // (CMS doesn&#39;t purge right away).</span>
<span class="udiff-line-removed">-   for (ClassLoaderData* cld = _unloading; cld != _saved_unloading; cld = cld-&gt;next()) {</span>
<span class="udiff-line-modified-added">+   for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld-&gt;next()) {</span>
      assert(cld-&gt;is_unloading(), &quot;invariant&quot;);
      cld-&gt;classes_do(f);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,45 +453,19 @@</span>
      cld-&gt;dictionary()-&gt;print_on(st);
      st-&gt;cr();
    }
  }
  
<span class="udiff-line-modified-removed">- void ClassLoaderDataGraph::print_dictionary_statistics(outputStream* st) {</span>
<span class="udiff-line-modified-added">+ void ClassLoaderDataGraph::print_table_statistics(outputStream* st) {</span>
    FOR_ALL_DICTIONARY(cld) {
      ResourceMark rm;
      stringStream tempst;
      tempst.print(&quot;System Dictionary for %s class loader&quot;, cld-&gt;loader_name_and_id());
      cld-&gt;dictionary()-&gt;print_table_statistics(st, tempst.as_string());
    }
  }
  
<span class="udiff-line-removed">- GrowableArray&lt;ClassLoaderData*&gt;* ClassLoaderDataGraph::new_clds() {</span>
<span class="udiff-line-removed">-   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);</span>
<span class="udiff-line-removed">-   assert(_head == NULL || _saved_head != NULL, &quot;remember_new_clds(true) not called?&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   GrowableArray&lt;ClassLoaderData*&gt;* array = new GrowableArray&lt;ClassLoaderData*&gt;();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The CLDs in [_head, _saved_head] were all added during last call to remember_new_clds(true);</span>
<span class="udiff-line-removed">-   ClassLoaderData* curr = _head;</span>
<span class="udiff-line-removed">-   while (curr != _saved_head) {</span>
<span class="udiff-line-removed">-     if (!curr-&gt;claimed()) {</span>
<span class="udiff-line-removed">-       array-&gt;push(curr);</span>
<span class="udiff-line-removed">-       LogTarget(Debug, class, loader, data) lt;</span>
<span class="udiff-line-removed">-       if (lt.is_enabled()) {</span>
<span class="udiff-line-removed">-         LogStream ls(lt);</span>
<span class="udiff-line-removed">-         ls.print(&quot;found new CLD: &quot;);</span>
<span class="udiff-line-removed">-         curr-&gt;print_value_on(&amp;ls);</span>
<span class="udiff-line-removed">-         ls.cr();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     curr = curr-&gt;_next;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return array;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  #ifndef PRODUCT
  bool ClassLoaderDataGraph::contains_loader_data(ClassLoaderData* loader_data) {
    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
    for (ClassLoaderData* data = _head; data != NULL; data = data-&gt;next()) {
      if (loader_data == data) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,14 +504,10 @@</span>
    ClassLoaderData* prev = NULL;
    bool seen_dead_loader = false;
    uint loaders_processed = 0;
    uint loaders_removed = 0;
  
<span class="udiff-line-removed">-   // Save previous _unloading pointer for CMS which may add to unloading list before</span>
<span class="udiff-line-removed">-   // purging and we don&#39;t want to rewalk the previously unloaded class loader data.</span>
<span class="udiff-line-removed">-   _saved_unloading = _unloading;</span>
<span class="udiff-line-removed">- </span>
    data = _head;
    while (data != NULL) {
      if (data-&gt;is_alive()) {
        prev = data;
        data = data-&gt;next();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,18 +576,17 @@</span>
      set_metaspace_oom(false);
    }
    DependencyContext::purge_dependency_contexts();
  }
  
<span class="udiff-line-modified-removed">- int ClassLoaderDataGraph::resize_if_needed() {</span>
<span class="udiff-line-modified-added">+ int ClassLoaderDataGraph::resize_dictionaries() {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint!&quot;);
    int resized = 0;
<span class="udiff-line-modified-removed">-   if (Dictionary::does_any_dictionary_needs_resizing()) {</span>
<span class="udiff-line-modified-removed">-     FOR_ALL_DICTIONARY(cld) {</span>
<span class="udiff-line-modified-removed">-       if (cld-&gt;dictionary()-&gt;resize_if_needed()) {</span>
<span class="udiff-line-modified-removed">-         resized++;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+   assert (Dictionary::does_any_dictionary_needs_resizing(), &quot;some dictionary should need resizing&quot;);</span>
<span class="udiff-line-modified-added">+   FOR_ALL_DICTIONARY(cld) {</span>
<span class="udiff-line-modified-added">+     if (cld-&gt;dictionary()-&gt;resize_if_needed()) {</span>
<span class="udiff-line-modified-added">+       resized++;</span>
      }
    }
    return resized;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,11 +632,11 @@</span>
    Klass* head = _next_klass;
  
    while (head != NULL) {
      Klass* next = next_klass_in_cldg(head);
  
<span class="udiff-line-modified-removed">-     Klass* old_head = Atomic::cmpxchg(next, &amp;_next_klass, head);</span>
<span class="udiff-line-modified-added">+     Klass* old_head = Atomic::cmpxchg(&amp;_next_klass, head, next);</span>
  
      if (old_head == head) {
        return head; // Won the CAS.
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -704,5 +686,7 @@</span>
    while (ClassLoaderData* cld = iter.get_next()) {
      cld-&gt;print_on(out);
    }
  }
  #endif // PRODUCT
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ClassLoaderDataGraph::print() { print_on(tty); }</span>
</pre>
<center><a href="classLoaderData.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecodeAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;

  33 #include &quot;classfile/javaClasses.inline.hpp&quot;
  34 #include &quot;classfile/moduleEntry.hpp&quot;

  35 #include &quot;classfile/symbolTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #if INCLUDE_TSAN
  38 #include &quot;classfile/tsanIgnoreList.hpp&quot;
  39 #endif // INCLUDE_TSAN
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
<span class="line-modified">  52 #include &quot;oops/fieldStreams.hpp&quot;</span>
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;

  60 #include &quot;oops/symbol.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;

  64 #include &quot;runtime/handles.inline.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/perfData.hpp&quot;
  68 #include &quot;runtime/reflection.hpp&quot;
  69 #include &quot;runtime/safepointVerifiers.hpp&quot;
  70 #include &quot;runtime/signature.hpp&quot;
  71 #include &quot;runtime/timer.hpp&quot;
  72 #include &quot;services/classLoadingService.hpp&quot;
  73 #include &quot;services/threadService.hpp&quot;
  74 #include &quot;utilities/align.hpp&quot;
  75 #include &quot;utilities/bitMap.inline.hpp&quot;
  76 #include &quot;utilities/copy.hpp&quot;
  77 #include &quot;utilities/exceptions.hpp&quot;
  78 #include &quot;utilities/globalDefinitions.hpp&quot;
  79 #include &quot;utilities/growableArray.hpp&quot;
  80 #include &quot;utilities/macros.hpp&quot;
  81 #include &quot;utilities/ostream.hpp&quot;
  82 #include &quot;utilities/resourceHash.hpp&quot;


  83 #if INCLUDE_CDS
  84 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  85 #endif
  86 #if INCLUDE_JFR
  87 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  88 #endif
  89 
  90 // We generally try to create the oops directly when parsing, rather than
  91 // allocating temporary data structures and copying the bytes twice. A
  92 // temporary area is only needed when parsing utf8 entries in the constant
  93 // pool and when parsing line number tables.
  94 
  95 // We add assert in debug mode when class format is not checked.
  96 
  97 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
  98 #define JAVA_MIN_SUPPORTED_VERSION        45
  99 #define JAVA_PREVIEW_MINOR_VERSION        65535
 100 
 101 // Used for two backward compatibility reasons:
 102 // - to check for new additions to the class file format in JDK1.5
</pre>
<hr />
<pre>
 108 // - also used as the max version when running in jdk6
 109 #define JAVA_6_VERSION                    50
 110 
 111 // Used for backward compatibility reasons:
 112 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 113 #define JAVA_7_VERSION                    51
 114 
 115 // Extension method support.
 116 #define JAVA_8_VERSION                    52
 117 
 118 #define JAVA_9_VERSION                    53
 119 
 120 #define JAVA_10_VERSION                   54
 121 
 122 #define JAVA_11_VERSION                   55
 123 
 124 #define JAVA_12_VERSION                   56
 125 
 126 #define JAVA_13_VERSION                   57
 127 




 128 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
<span class="line-modified"> 129   assert((bad_constant == 19 || bad_constant == 20) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,</span>

 130          &quot;Unexpected bad constant pool entry&quot;);
 131   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 132 }
 133 
 134 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 135                                                   ConstantPool* cp,
 136                                                   const int length,
 137                                                   TRAPS) {
 138   assert(stream != NULL, &quot;invariant&quot;);
 139   assert(cp != NULL, &quot;invariant&quot;);
 140 
 141   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 142   // this function (_current can be allocated in a register, with scalar
 143   // replacement of aggregates). The _current pointer is copied back to
 144   // stream() when this function returns. DON&#39;T call another method within
 145   // this method that uses stream().
 146   const ClassFileStream cfs1 = *stream;
 147   const ClassFileStream* const cfs = &amp;cfs1;
 148 
 149   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
</pre>
<hr />
<pre>
 298         const u1* utf8_buffer = cfs-&gt;current();
 299         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 300         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 301         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 302         cfs-&gt;skip_u1_fast(utf8_length);
 303 
 304         // Before storing the symbol, make sure it&#39;s legal
 305         if (_need_verify) {
 306           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 307         }
 308 
 309         if (has_cp_patch_at(index)) {
 310           Handle patch = clear_cp_patch_at(index);
 311           guarantee_property(java_lang_String::is_instance(patch()),
 312                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 313                              index,
 314                              CHECK);
 315           const char* const str = java_lang_String::as_utf8_string(patch());
 316           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 317           utf8_buffer = (const u1*) str;
<span class="line-modified"> 318           utf8_length = (int) strlen(str);</span>
 319         }
 320 
 321         unsigned int hash;
 322         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 323                                                         utf8_length,
 324                                                         hash);
 325         if (result == NULL) {
 326           names[names_count] = (const char*)utf8_buffer;
 327           lengths[names_count] = utf8_length;
 328           indices[names_count] = index;
 329           hashValues[names_count++] = hash;
 330           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 331             SymbolTable::new_symbols(_loader_data,
<span class="line-modified"> 332                                      cp,</span>
 333                                      names_count,
 334                                      names,
 335                                      lengths,
 336                                      indices,
<span class="line-modified"> 337                                      hashValues,</span>
<span class="line-removed"> 338                                      CHECK);</span>
 339             names_count = 0;
 340           }
 341         } else {
 342           cp-&gt;symbol_at_put(index, result);
 343         }
 344         break;
 345       }
<span class="line-modified"> 346       case 19:</span>
<span class="line-modified"> 347       case 20: {</span>
 348         // Record that an error occurred in these two cases but keep parsing so
 349         // that ACC_Module can be checked for in the access_flags.  Need to
 350         // throw NoClassDefFoundError in that case.
 351         if (_major_version &gt;= JAVA_9_VERSION) {
 352           cfs-&gt;guarantee_more(3, CHECK);
 353           cfs-&gt;get_u2_fast();
 354           set_class_bad_constant_seen(tag);
 355           break;
 356         }
 357       }
 358       default: {
 359         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 360                               tag,
 361                               CHECK);
 362         break;
 363       }
 364     } // end of switch(tag)
 365   } // end of for
 366 
 367   // Allocate the remaining symbols
 368   if (names_count &gt; 0) {
 369     SymbolTable::new_symbols(_loader_data,
<span class="line-modified"> 370                              cp,</span>
 371                              names_count,
 372                              names,
 373                              lengths,
 374                              indices,
<span class="line-modified"> 375                              hashValues,</span>
<span class="line-removed"> 376                              CHECK);</span>
 377   }
 378 
 379   // Copy _current pointer of local copy back to stream.
 380   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 381   stream-&gt;set_current(cfs1.current());
 382 
 383 }
 384 
 385 static inline bool valid_cp_range(int index, int length) {
 386   return (index &gt; 0 &amp;&amp; index &lt; length);
 387 }
 388 
 389 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 390   assert(cp != NULL, &quot;invariant&quot;);
 391   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 392     return cp-&gt;symbol_at(index);
 393   }
 394   return NULL;
 395 }
 396 
</pre>
<hr />
<pre>
 644     switch (tag) {
 645       case JVM_CONSTANT_UnresolvedClass: {
 646         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 647         // check the name, even if _cp_patches will overwrite it
 648         verify_legal_class_name(class_name, CHECK);
 649         break;
 650       }
 651       case JVM_CONSTANT_NameAndType: {
 652         if (_need_verify) {
 653           const int sig_index = cp-&gt;signature_ref_index_at(index);
 654           const int name_index = cp-&gt;name_ref_index_at(index);
 655           const Symbol* const name = cp-&gt;symbol_at(name_index);
 656           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 657           guarantee_property(sig-&gt;utf8_length() != 0,
 658             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 659             sig_index, CHECK);
 660           guarantee_property(name-&gt;utf8_length() != 0,
 661             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 662             name_index, CHECK);
 663 
<span class="line-modified"> 664           if (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
 665             // Format check method name and signature
 666             verify_legal_method_name(name, CHECK);
 667             verify_legal_method_signature(name, sig, CHECK);
 668           } else {
 669             // Format check field name and signature
 670             verify_legal_field_name(name, CHECK);
 671             verify_legal_field_signature(name, sig, CHECK);
 672           }
 673         }
 674         break;
 675       }
 676       case JVM_CONSTANT_Dynamic: {
 677         const int name_and_type_ref_index =
 678           cp-&gt;name_and_type_ref_index_at(index);
 679         // already verified to be utf8
 680         const int name_ref_index =
 681           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 682         // already verified to be utf8
 683         const int signature_ref_index =
 684           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 685         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 686         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 687         if (_need_verify) {
 688           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
<span class="line-modified"> 689           // Need only to be sure signature is non-zero length and the right type.</span>
<span class="line-modified"> 690           if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed"> 691               signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
 692             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 693           }
 694         }
 695         break;
 696       }
 697       case JVM_CONSTANT_InvokeDynamic:
 698       case JVM_CONSTANT_Fieldref:
 699       case JVM_CONSTANT_Methodref:
 700       case JVM_CONSTANT_InterfaceMethodref: {
 701         const int name_and_type_ref_index =
 702           cp-&gt;name_and_type_ref_index_at(index);
 703         // already verified to be utf8
 704         const int name_ref_index =
 705           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 706         // already verified to be utf8
 707         const int signature_ref_index =
 708           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 709         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 710         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 711         if (tag == JVM_CONSTANT_Fieldref) {
 712           if (_need_verify) {
 713             // Field name and signature are verified above, when iterating NameAndType_info.
 714             // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified"> 715             if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed"> 716                 signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
 717               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 718             }
 719           }
 720         } else {
 721           if (_need_verify) {
 722             // Method name and signature are verified above, when iterating NameAndType_info.
 723             // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified"> 724             if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed"> 725                 signature-&gt;char_at(0) != JVM_SIGNATURE_FUNC) {</span>
 726               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 727             }
 728           }
 729           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 730           const unsigned int name_len = name-&gt;utf8_length();
 731           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 732               name_len != 0 &amp;&amp;
<span class="line-modified"> 733               name-&gt;char_at(0) == &#39;&lt;&#39; &amp;&amp;</span>
 734               name != vmSymbols::object_initializer_name()) {
 735             classfile_parse_error(
 736               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 737               name_ref_index, CHECK);
 738           }
 739         }
 740         break;
 741       }
 742       case JVM_CONSTANT_MethodHandle: {
 743         const int ref_index = cp-&gt;method_handle_index_at(index);
 744         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 745         switch (ref_kind) {
 746           case JVM_REF_invokeVirtual:
 747           case JVM_REF_invokeStatic:
 748           case JVM_REF_invokeSpecial:
 749           case JVM_REF_newInvokeSpecial: {
 750             const int name_and_type_ref_index =
 751               cp-&gt;name_and_type_ref_index_at(ref_index);
 752             const int name_ref_index =
 753               cp-&gt;name_ref_index_at(name_and_type_ref_index);
</pre>
<hr />
<pre>
 805                                           TRAPS) {
 806   assert(cp != NULL, &quot;invariant&quot;);
 807 
 808   BasicType patch_type = T_VOID;
 809 
 810   switch (cp-&gt;tag_at(index).value()) {
 811 
 812     case JVM_CONSTANT_UnresolvedClass: {
 813       // Patching a class means pre-resolving it.
 814       // The name in the constant pool is ignored.
 815       if (java_lang_Class::is_instance(patch())) {
 816         guarantee_property(!java_lang_Class::is_primitive(patch()),
 817                            &quot;Illegal class patch at %d in class file %s&quot;,
 818                            index, CHECK);
 819         Klass* k = java_lang_Class::as_Klass(patch());
 820         patch_class(cp, index, k, k-&gt;name());
 821       } else {
 822         guarantee_property(java_lang_String::is_instance(patch()),
 823                            &quot;Illegal class patch at %d in class file %s&quot;,
 824                            index, CHECK);
<span class="line-modified"> 825         Symbol* const name = java_lang_String::as_symbol(patch(), CHECK);</span>
 826         patch_class(cp, index, NULL, name);
 827       }
 828       break;
 829     }
 830 
 831     case JVM_CONSTANT_String: {
 832       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 833       // references to be created first.
 834       return;
 835     }
 836     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 837     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 838     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 839     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 840     patch_prim:
 841     {
 842       jvalue value;
 843       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 844       guarantee_property(value_type == patch_type,
 845                          &quot;Illegal primitive patch at %d in class file %s&quot;,
</pre>
<hr />
<pre>
1681 
1682     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1683     field-&gt;initialize(access_flags.as_short(),
1684                       name_index,
1685                       signature_index,
1686                       constantvalue_index);
1687     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1688 
1689     // Remember how many oops we encountered and compute allocation type
1690     const FieldAllocationType atype = fac-&gt;update(is_static, type);
1691     field-&gt;set_allocation_type(atype);
1692 
1693     TSAN_RUNTIME_ONLY(
1694       if (ThreadSanitizerIgnoreFile != NULL &amp;&amp;
1695           TsanIgnoreList::match(_class_name, name, type)) {
1696         parsed_annotations.set_tsan_ignore(true);
1697       }
1698     );
1699 
1700     // After field is initialized with type, we can augment it with aux info
<span class="line-modified">1701     if (parsed_annotations.has_any_annotations())</span>
1702       parsed_annotations.apply_to(field);




1703   }
1704 
1705   int index = length;
1706   if (num_injected != 0) {
1707     for (int n = 0; n &lt; num_injected; n++) {
1708       // Check for duplicates
1709       if (injected[n].may_be_java) {
1710         const Symbol* const name      = injected[n].name();
1711         const Symbol* const signature = injected[n].signature();
1712         bool duplicate = false;
1713         for (int i = 0; i &lt; length; i++) {
1714           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1715           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1716               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1717             // Symbol is desclared in Java so skip this one
1718             duplicate = true;
1719             break;
1720           }
1721         }
1722         if (duplicate) {
1723           // These will be removed from the field array at the end
1724           continue;
1725         }
1726       }
1727 
1728       // Injected field
1729       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1730       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1731                         injected[n].name_index,
1732                         injected[n].signature_index,
1733                         0);
1734 
<span class="line-modified">1735       const BasicType type = FieldType::basic_type(injected[n].signature());</span>
1736 
1737       // Remember how many oops we encountered and compute allocation type
1738       const FieldAllocationType atype = fac-&gt;update(false, type);
1739       field-&gt;set_allocation_type(atype);
1740       index++;
1741     }
1742   }
1743 
1744   assert(NULL == _fields, &quot;invariant&quot;);
1745 
1746   _fields =
1747     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1748                                    index * FieldInfo::field_slots + num_generic_signature,
1749                                    CHECK);
1750   // Sometimes injected fields already exist in the Java source so
1751   // the fields array could be too long.  In that case the
1752   // fields array is trimed. Also unused slots that were reserved
1753   // for generic signature indexes are discarded.
1754   {
1755     int i = 0;
</pre>
<hr />
<pre>
2456       valid_symbol_at(method_attribute_name_index),
2457       &quot;Invalid method attribute name index %u in class file %s&quot;,
2458       method_attribute_name_index, CHECK_NULL);
2459 
2460     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2461     if (method_attribute_name == vmSymbols::tag_code()) {
2462       // Parse Code attribute
2463       if (_need_verify) {
2464         guarantee_property(
2465             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2466                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2467                          CHECK_NULL);
2468       }
2469       if (parsed_code_attribute) {
2470         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2471                               CHECK_NULL);
2472       }
2473       parsed_code_attribute = true;
2474 
2475       // Stack size, locals size, and code size
<span class="line-modified">2476       if (_major_version == 45 &amp;&amp; _minor_version &lt;= 2) {</span>
<span class="line-modified">2477         cfs-&gt;guarantee_more(4, CHECK_NULL);</span>
<span class="line-modified">2478         max_stack = cfs-&gt;get_u1_fast();</span>
<span class="line-modified">2479         max_locals = cfs-&gt;get_u1_fast();</span>
<span class="line-removed">2480         code_length = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">2481       } else {</span>
<span class="line-removed">2482         cfs-&gt;guarantee_more(8, CHECK_NULL);</span>
<span class="line-removed">2483         max_stack = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">2484         max_locals = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">2485         code_length = cfs-&gt;get_u4_fast();</span>
<span class="line-removed">2486       }</span>
2487       if (_need_verify) {
2488         guarantee_property(args_size &lt;= max_locals,
2489                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2490                            CHECK_NULL);
2491         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2492                            &quot;Invalid method Code length %u in class file %s&quot;,
2493                            code_length, CHECK_NULL);
2494       }
2495       // Code pointer
2496       code_start = cfs-&gt;current();
2497       assert(code_start != NULL, &quot;null code start&quot;);
2498       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2499       cfs-&gt;skip_u1_fast(code_length);
2500 
2501       // Exception handler table
2502       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2503       exception_table_length = cfs-&gt;get_u2_fast();
2504       if (exception_table_length &gt; 0) {
2505         exception_table_start = parse_exception_table(cfs,
2506                                                       code_length,
2507                                                       exception_table_length,
2508                                                       CHECK_NULL);
2509       }
2510 
2511       // Parse additional attributes in code attribute
2512       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2513       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2514 
2515       unsigned int calculated_attribute_length = 0;
2516 
<span class="line-modified">2517       if (_major_version &gt; 45 || (_major_version == 45 &amp;&amp; _minor_version &gt; 2)) {</span>
<span class="line-modified">2518         calculated_attribute_length =</span>
<span class="line-removed">2519             sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);</span>
<span class="line-removed">2520       } else {</span>
<span class="line-removed">2521         // max_stack, locals and length are smaller in pre-version 45.2 classes</span>
<span class="line-removed">2522         calculated_attribute_length = sizeof(u1) + sizeof(u1) + sizeof(u2);</span>
<span class="line-removed">2523       }</span>
2524       calculated_attribute_length +=
2525         code_length +
2526         sizeof(exception_table_length) +
2527         sizeof(code_attributes_count) +
2528         exception_table_length *
2529             ( sizeof(u2) +   // start_pc
2530               sizeof(u2) +   // end_pc
2531               sizeof(u2) +   // handler_pc
2532               sizeof(u2) );  // catch_type_index
2533 
2534       while (code_attributes_count--) {
2535         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2536         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2537         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2538         calculated_attribute_length += code_attribute_length +
2539                                        sizeof(code_attribute_name_index) +
2540                                        sizeof(code_attribute_length);
2541         check_property(valid_symbol_at(code_attribute_name_index),
2542                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2543                        code_attribute_name_index,
</pre>
<hr />
<pre>
2813       runtime_visible_parameter_annotations_length +
2814            runtime_invisible_parameter_annotations_length,
2815       runtime_visible_type_annotations_length +
2816            runtime_invisible_type_annotations_length,
2817       annotation_default_length,
2818       0);
2819 
2820   Method* const m = Method::allocate(_loader_data,
2821                                      code_length,
2822                                      access_flags,
2823                                      &amp;sizes,
2824                                      ConstMethod::NORMAL,
2825                                      CHECK_NULL);
2826 
2827   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2828 
2829   // Fill in information from fixed part (access_flags already set)
2830   m-&gt;set_constants(_cp);
2831   m-&gt;set_name_index(name_index);
2832   m-&gt;set_signature_index(signature_index);
<span class="line-modified">2833 </span>
<span class="line-modified">2834   ResultTypeFinder rtf(cp-&gt;symbol_at(signature_index));</span>
<span class="line-removed">2835   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
<span class="line-removed">2836 </span>
<span class="line-removed">2837   if (args_size &gt;= 0) {</span>
<span class="line-removed">2838     m-&gt;set_size_of_parameters(args_size);</span>
<span class="line-removed">2839   } else {</span>
<span class="line-removed">2840     m-&gt;compute_size_of_parameters(THREAD);</span>
<span class="line-removed">2841   }</span>
<span class="line-removed">2842 #ifdef ASSERT</span>
<span class="line-removed">2843   if (args_size &gt;= 0) {</span>
<span class="line-removed">2844     m-&gt;compute_size_of_parameters(THREAD);</span>
<span class="line-removed">2845     assert(args_size == m-&gt;size_of_parameters(), &quot;&quot;);</span>
<span class="line-removed">2846   }</span>
<span class="line-removed">2847 #endif</span>
2848 
2849   // Fill in code attribute information
2850   m-&gt;set_max_stack(max_stack);
2851   m-&gt;set_max_locals(max_locals);
2852   if (stackmap_data != NULL) {
2853     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2854                                          (u1*)stackmap_data,
2855                                          stackmap_data_length,
2856                                          CHECK_NULL);
2857   }
2858 
2859   // Copy byte codes
2860   m-&gt;set_code((u1*)code_start);
2861 
2862   // Copy line number table
2863   if (linenumber_table != NULL) {
2864     memcpy(m-&gt;compressed_linenumber_table(),
2865            linenumber_table-&gt;buffer(),
2866            linenumber_table_length);
2867   }
</pre>
<hr />
<pre>
2890     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2891                                                 m-&gt;checked_exceptions_start(),
2892                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2893                                                 sizeof(u2));
2894   }
2895 
2896   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2897   if (total_lvt_length &gt; 0) {
2898     promoted_flags-&gt;set_has_localvariable_table();
2899     copy_localvariable_table(m-&gt;constMethod(),
2900                              lvt_cnt,
2901                              localvariable_table_length,
2902                              localvariable_table_start,
2903                              lvtt_cnt,
2904                              localvariable_type_table_length,
2905                              localvariable_type_table_start,
2906                              CHECK_NULL);
2907   }
2908 
2909   if (parsed_annotations.has_any_annotations())
<span class="line-modified">2910     parsed_annotations.apply_to(m);</span>
2911 
2912   // Copy annotations
2913   copy_method_annotations(m-&gt;constMethod(),
2914                           runtime_visible_annotations,
2915                           runtime_visible_annotations_length,
2916                           runtime_invisible_annotations,
2917                           runtime_invisible_annotations_length,
2918                           runtime_visible_parameter_annotations,
2919                           runtime_visible_parameter_annotations_length,
2920                           runtime_invisible_parameter_annotations,
2921                           runtime_invisible_parameter_annotations_length,
2922                           runtime_visible_type_annotations,
2923                           runtime_visible_type_annotations_length,
2924                           runtime_invisible_type_annotations,
2925                           runtime_invisible_type_annotations_length,
2926                           annotation_default,
2927                           annotation_default_length,
2928                           CHECK_NULL);
2929 
2930   if (name == vmSymbols::finalize_method_name() &amp;&amp;
</pre>
<hr />
<pre>
3012             dup = true;
3013             break;
3014           }
3015         }
3016       }
3017       if (dup) {
3018         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
3019                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
3020       }
3021     }
3022   }
3023 }
3024 
3025 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
3026   const int length = methods-&gt;length();
3027   // If JVMTI original method ordering or sharing is enabled we have to
3028   // remember the original class file ordering.
3029   // We temporarily use the vtable_index field in the Method* to store the
3030   // class file index, so we can read in after calling qsort.
3031   // Put the method ordering in the shared archive.
<span class="line-modified">3032   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
3033     for (int index = 0; index &lt; length; index++) {
3034       Method* const m = methods-&gt;at(index);
3035       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3036       m-&gt;set_vtable_index(index);
3037     }
3038   }
3039   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3040   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3041   Method::sort_methods(methods);
3042 
3043   intArray* method_ordering = NULL;
3044   // If JVMTI original method ordering or sharing is enabled construct int
3045   // array remembering the original ordering
<span class="line-modified">3046   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
3047     method_ordering = new intArray(length, length, -1);
3048     for (int index = 0; index &lt; length; index++) {
3049       Method* const m = methods-&gt;at(index);
3050       const int old_index = m-&gt;vtable_index();
3051       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3052       method_ordering-&gt;at_put(index, old_index);
3053       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3054     }
3055   }
3056   return method_ordering;
3057 }
3058 
3059 // Parse generic_signature attribute for methods and fields
3060 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3061                                                       TRAPS) {
3062   assert(cfs != NULL, &quot;invariant&quot;);
3063 
3064   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3065   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3066   check_property(
</pre>
<hr />
<pre>
3231   _nest_members = nest_members;
3232 
3233   int index = 0;
3234   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3235   for (int n = 0; n &lt; length; n++) {
3236     const u2 class_info_index = cfs-&gt;get_u2_fast();
3237     check_property(
3238       valid_klass_reference_at(class_info_index),
3239       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3240       class_info_index, CHECK_0);
3241     nest_members-&gt;at_put(index++, class_info_index);
3242   }
3243   assert(index == size, &quot;wrong size&quot;);
3244 
3245   // Restore buffer&#39;s current position.
3246   cfs-&gt;set_current(current_mark);
3247 
3248   return length;
3249 }
3250 







































































































































































3251 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3252   set_class_synthetic_flag(true);
3253 }
3254 
3255 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3256   assert(cfs != NULL, &quot;invariant&quot;);
3257 
3258   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3259   check_property(
3260     valid_symbol_at(signature_index),
3261     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3262     signature_index, CHECK);
3263   set_class_generic_signature_index(signature_index);
3264 }
3265 
3266 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3267                                                                   ConstantPool* cp,
3268                                                                   u4 attribute_byte_length,
3269                                                                   TRAPS) {
3270   assert(cfs != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
3328     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3329     operands-&gt;at_put(operand_fill_index++, argument_count);
3330 
3331     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3332     for (int j = 0; j &lt; argument_count; j++) {
3333       const u2 argument_index = cfs-&gt;get_u2_fast();
3334       check_property(
3335         valid_cp_range(argument_index, cp_size) &amp;&amp;
3336         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3337         &quot;argument_index %u has bad constant type in class file %s&quot;,
3338         argument_index,
3339         CHECK);
3340       operands-&gt;at_put(operand_fill_index++, argument_index);
3341     }
3342   }
3343   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3344                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3345                      CHECK);
3346 }
3347 






3348 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3349                                                  ConstantPool* cp,
3350                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3351                                                  TRAPS) {
3352   assert(cfs != NULL, &quot;invariant&quot;);
3353   assert(cp != NULL, &quot;invariant&quot;);
3354   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3355 
3356   // Set inner classes attribute to default sentinel
3357   _inner_classes = Universe::the_empty_short_array();
3358   // Set nest members attribute to default sentinel
3359   _nest_members = Universe::the_empty_short_array();
3360   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3361   u2 attributes_count = cfs-&gt;get_u2_fast();
3362   bool parsed_sourcefile_attribute = false;
3363   bool parsed_innerclasses_attribute = false;
3364   bool parsed_nest_members_attribute = false;
3365   bool parsed_nest_host_attribute = false;

3366   bool parsed_enclosingmethod_attribute = false;
3367   bool parsed_bootstrap_methods_attribute = false;
3368   const u1* runtime_visible_annotations = NULL;
3369   int runtime_visible_annotations_length = 0;
3370   const u1* runtime_invisible_annotations = NULL;
3371   int runtime_invisible_annotations_length = 0;
3372   const u1* runtime_visible_type_annotations = NULL;
3373   int runtime_visible_type_annotations_length = 0;
3374   const u1* runtime_invisible_type_annotations = NULL;
3375   int runtime_invisible_type_annotations_length = 0;
3376   bool runtime_invisible_type_annotations_exists = false;
3377   bool runtime_invisible_annotations_exists = false;
3378   bool parsed_source_debug_ext_annotations_exist = false;
3379   const u1* inner_classes_attribute_start = NULL;
3380   u4  inner_classes_attribute_length = 0;
3381   u2  enclosing_method_class_index = 0;
3382   u2  enclosing_method_method_index = 0;
3383   const u1* nest_members_attribute_start = NULL;
3384   u4  nest_members_attribute_length = 0;


3385 
3386   // Iterate over attributes
3387   while (attributes_count--) {
3388     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3389     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3390     const u4 attribute_length = cfs-&gt;get_u4_fast();
3391     check_property(
3392       valid_symbol_at(attribute_name_index),
3393       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3394       attribute_name_index, CHECK);
3395     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3396     if (tag == vmSymbols::tag_source_file()) {
3397       // Check for SourceFile tag
3398       if (_need_verify) {
3399         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3400       }
3401       if (parsed_sourcefile_attribute) {
3402         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3403       } else {
3404         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3547           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3548         } else if (tag == vmSymbols::tag_nest_host()) {
3549           if (parsed_nest_host_attribute) {
3550             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3551           } else {
3552             parsed_nest_host_attribute = true;
3553           }
3554           if (parsed_nest_members_attribute) {
3555             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3556           }
3557           if (_need_verify) {
3558             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3559           }
3560           cfs-&gt;guarantee_more(2, CHECK);
3561           u2 class_info_index = cfs-&gt;get_u2_fast();
3562           check_property(
3563                          valid_klass_reference_at(class_info_index),
3564                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3565                          class_info_index, CHECK);
3566           _nest_host = class_info_index;





































3567         } else {
3568           // Unknown attribute
3569           cfs-&gt;skip_u1(attribute_length, CHECK);
3570         }
3571       } else {
3572         // Unknown attribute
3573         cfs-&gt;skip_u1(attribute_length, CHECK);
3574       }
3575     } else {
3576       // Unknown attribute
3577       cfs-&gt;skip_u1(attribute_length, CHECK);
3578     }
3579   }
<span class="line-modified">3580   _annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-modified">3581                                       runtime_visible_annotations_length,</span>
<span class="line-modified">3582                                       runtime_invisible_annotations,</span>
<span class="line-modified">3583                                       runtime_invisible_annotations_length,</span>
<span class="line-modified">3584                                       CHECK);</span>
<span class="line-modified">3585   _type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-modified">3586                                            runtime_visible_type_annotations_length,</span>
<span class="line-modified">3587                                            runtime_invisible_type_annotations,</span>
<span class="line-modified">3588                                            runtime_invisible_type_annotations_length,</span>
<span class="line-modified">3589                                            CHECK);</span>
3590 
3591   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3592     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3593                             cfs,
3594                             inner_classes_attribute_start,
3595                             parsed_innerclasses_attribute,
3596                             enclosing_method_class_index,
3597                             enclosing_method_method_index,
3598                             CHECK);
3599     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3600       guarantee_property(
3601         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3602         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3603     }
3604   }
3605 
3606   if (parsed_nest_members_attribute) {
3607     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3608                             cfs,
3609                             nest_members_attribute_start,
3610                             CHECK);
3611     if (_need_verify) {
3612       guarantee_property(
3613         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3614         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3615     }
3616   }
3617 













3618   if (_max_bootstrap_specifier_index &gt;= 0) {
3619     guarantee_property(parsed_bootstrap_methods_attribute,
3620                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3621   }
3622 }
3623 
3624 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3625   assert(k != NULL, &quot;invariant&quot;);
3626 
3627   if (_synthetic_flag)
3628     k-&gt;set_is_synthetic();
3629   if (_sourcefile_index != 0) {
3630     k-&gt;set_source_file_name_index(_sourcefile_index);
3631   }
3632   if (_generic_signature_index != 0) {
3633     k-&gt;set_generic_signature_index(_generic_signature_index);
3634   }
3635   if (_sde_buffer != NULL) {
3636     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3637   }
3638 }
3639 
3640 // Create the Annotations object that will
3641 // hold the annotations array for the Klass.
3642 void ClassFileParser::create_combined_annotations(TRAPS) {
<span class="line-modified">3643     if (_annotations == NULL &amp;&amp;</span>
<span class="line-modified">3644         _type_annotations == NULL &amp;&amp;</span>
3645         _fields_annotations == NULL &amp;&amp;
3646         _fields_type_annotations == NULL) {
3647       // Don&#39;t create the Annotations object unnecessarily.
3648       return;
3649     }
3650 
3651     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
<span class="line-modified">3652     annotations-&gt;set_class_annotations(_annotations);</span>
<span class="line-modified">3653     annotations-&gt;set_class_type_annotations(_type_annotations);</span>
3654     annotations-&gt;set_fields_annotations(_fields_annotations);
3655     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3656 
3657     // This is the Annotations object that will be
3658     // assigned to InstanceKlass being constructed.
3659     _combined_annotations = annotations;
3660 
3661     // The annotations arrays below has been transfered the
3662     // _combined_annotations so these fields can now be cleared.
<span class="line-modified">3663     _annotations             = NULL;</span>
<span class="line-modified">3664     _type_annotations        = NULL;</span>
3665     _fields_annotations      = NULL;
3666     _fields_type_annotations = NULL;
3667 }
3668 
3669 // Transfer ownership of metadata allocated to the InstanceKlass.
3670 void ClassFileParser::apply_parsed_class_metadata(
3671                                             InstanceKlass* this_klass,
<span class="line-modified">3672                                             int java_fields_count, TRAPS) {</span>

3673   assert(this_klass != NULL, &quot;invariant&quot;);
3674 
3675   _cp-&gt;set_pool_holder(this_klass);
3676   this_klass-&gt;set_constants(_cp);
3677   this_klass-&gt;set_fields(_fields, java_fields_count);
3678   this_klass-&gt;set_methods(_methods);
3679   this_klass-&gt;set_inner_classes(_inner_classes);
3680   this_klass-&gt;set_nest_members(_nest_members);
3681   this_klass-&gt;set_nest_host_index(_nest_host);
3682   this_klass-&gt;set_local_interfaces(_local_interfaces);
3683   this_klass-&gt;set_annotations(_combined_annotations);

3684   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3685   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3686   // its _super. If an OOM occurs while loading the current klass, its _super field
3687   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3688   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3689   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3690 
3691   // Clear out these fields so they don&#39;t get deallocated by the destructor
3692   clear_class_metadata();
3693 }
3694 
3695 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3696                                                        int runtime_visible_annotations_length,
3697                                                        const u1* const runtime_invisible_annotations,
3698                                                        int runtime_invisible_annotations_length,
3699                                                        TRAPS) {
3700   AnnotationArray* annotations = NULL;
3701   if (runtime_visible_annotations != NULL ||
3702       runtime_invisible_annotations != NULL) {
3703     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
</pre>
<hr />
<pre>
3737                    super_class_index,
3738                    CHECK_NULL);
3739     // The class name should be legal because it is checked when parsing constant pool.
3740     // However, make sure it is not an array type.
3741     bool is_array = false;
3742     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3743       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3744       if (need_verify)
3745         is_array = super_klass-&gt;is_array_klass();
3746     } else if (need_verify) {
3747       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3748     }
3749     if (need_verify) {
3750       guarantee_property(!is_array,
3751                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
3752     }
3753   }
3754   return super_klass;
3755 }
3756 
<span class="line-removed">3757 static unsigned int compute_oop_map_count(const InstanceKlass* super,</span>
<span class="line-removed">3758                                           unsigned int nonstatic_oop_map_count,</span>
<span class="line-removed">3759                                           int first_nonstatic_oop_offset) {</span>
<span class="line-removed">3760 </span>
<span class="line-removed">3761   unsigned int map_count =</span>
<span class="line-removed">3762     NULL == super ? 0 : super-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">3763   if (nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-removed">3764     // We have oops to add to map</span>
<span class="line-removed">3765     if (map_count == 0) {</span>
<span class="line-removed">3766       map_count = nonstatic_oop_map_count;</span>
<span class="line-removed">3767     }</span>
<span class="line-removed">3768     else {</span>
<span class="line-removed">3769       // Check whether we should add a new map block or whether the last one can</span>
<span class="line-removed">3770       // be extended</span>
<span class="line-removed">3771       const OopMapBlock* const first_map = super-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">3772       const OopMapBlock* const last_map = first_map + map_count - 1;</span>
<span class="line-removed">3773 </span>
<span class="line-removed">3774       const int next_offset = last_map-&gt;offset() + last_map-&gt;count() * heapOopSize;</span>
<span class="line-removed">3775       if (next_offset == first_nonstatic_oop_offset) {</span>
<span class="line-removed">3776         // There is no gap bettwen superklass&#39;s last oop field and first</span>
<span class="line-removed">3777         // local oop field, merge maps.</span>
<span class="line-removed">3778         nonstatic_oop_map_count -= 1;</span>
<span class="line-removed">3779       }</span>
<span class="line-removed">3780       else {</span>
<span class="line-removed">3781         // Superklass didn&#39;t end with a oop field, add extra maps</span>
<span class="line-removed">3782         assert(next_offset &lt; first_nonstatic_oop_offset, &quot;just checking&quot;);</span>
<span class="line-removed">3783       }</span>
<span class="line-removed">3784       map_count += nonstatic_oop_map_count;</span>
<span class="line-removed">3785     }</span>
<span class="line-removed">3786   }</span>
<span class="line-removed">3787   return map_count;</span>
<span class="line-removed">3788 }</span>
<span class="line-removed">3789 </span>
3790 #ifndef PRODUCT
3791 static void print_field_layout(const Symbol* name,
3792                                Array&lt;u2&gt;* fields,
<span class="line-modified">3793                                const constantPoolHandle&amp; cp,</span>
3794                                int instance_size,
3795                                int instance_fields_start,
3796                                int instance_fields_end,
3797                                int static_fields_end) {
3798 
3799   assert(name != NULL, &quot;invariant&quot;);
3800 
3801   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
3802   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
3803   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3804     if (!fs.access_flags().is_static()) {
3805       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3806         fs.offset(),
3807         fs.name()-&gt;as_klass_external_name(),
3808         fs.signature()-&gt;as_klass_external_name());
3809     }
3810   }
3811   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
3812   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
3813   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
3814   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3815     if (fs.access_flags().is_static()) {
3816       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3817         fs.offset(),
3818         fs.name()-&gt;as_klass_external_name(),
3819         fs.signature()-&gt;as_klass_external_name());
3820     }
3821   }
3822   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
3823   tty-&gt;print(&quot;\n&quot;);
3824 }
3825 #endif
3826 
<span class="line-modified">3827 // Values needed for oopmap and InstanceKlass creation</span>
<span class="line-modified">3828 class ClassFileParser::FieldLayoutInfo : public ResourceObj {</span>
<span class="line-modified">3829  public:</span>
<span class="line-modified">3830   int*          nonstatic_oop_offsets;</span>
<span class="line-modified">3831   unsigned int* nonstatic_oop_counts;</span>
<span class="line-modified">3832   unsigned int  nonstatic_oop_map_count;</span>
<span class="line-modified">3833   unsigned int  total_oop_map_count;</span>
<span class="line-modified">3834   int           instance_size;</span>
<span class="line-modified">3835   int           nonstatic_field_size;</span>
<span class="line-modified">3836   int           static_field_size;</span>
<span class="line-modified">3837   bool          has_nonstatic_fields;</span>
<span class="line-modified">3838 };</span>







































































































3839 
3840 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
3841 void ClassFileParser::layout_fields(ConstantPool* cp,
3842                                     const FieldAllocationCount* fac,
3843                                     const ClassAnnotationCollector* parsed_annotations,
3844                                     FieldLayoutInfo* info,
3845                                     TRAPS) {
3846 
3847   assert(cp != NULL, &quot;invariant&quot;);
3848 
3849   // Field size and offset computation
3850   int nonstatic_field_size = _super_klass == NULL ? 0 :
3851                                _super_klass-&gt;nonstatic_field_size();
3852 
3853   // Count the contended fields by type.
3854   //
3855   // We ignore static fields, because @Contended is not supported for them.
3856   // The layout code below will also ignore the static fields.
3857   int nonstatic_contended_count = 0;
3858   FieldAllocationCount fac_contended;
</pre>
<hr />
<pre>
3905   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
3906 
3907   // Total non-static fields count, including every contended field
3908   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
3909                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
3910                                         fac-&gt;count[NONSTATIC_OOP];
3911 
3912   const bool super_has_nonstatic_fields =
3913           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
3914   const bool has_nonstatic_fields =
3915     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
3916 
3917 
3918   // Prepare list of oops for oop map generation.
3919   //
3920   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
3921   // regions. offset[i] is the start of the i-th region, which then has
3922   // count[i] oops following. Before we know how many regions are required,
3923   // we pessimistically allocate the maps to fit all the oops into the
3924   // distinct regions.
<span class="line-removed">3925   //</span>
<span class="line-removed">3926   // TODO: We add +1 to always allocate non-zero resource arrays; we need</span>
<span class="line-removed">3927   // to figure out if we still need to do this.</span>
<span class="line-removed">3928   unsigned int nonstatic_oop_map_count = 0;</span>
<span class="line-removed">3929   unsigned int max_nonstatic_oop_maps  = fac-&gt;count[NONSTATIC_OOP] + 1;</span>
3930 
<span class="line-modified">3931   int* nonstatic_oop_offsets = NEW_RESOURCE_ARRAY_IN_THREAD(</span>
<span class="line-modified">3932             THREAD, int, max_nonstatic_oop_maps);</span>
<span class="line-modified">3933   unsigned int* const nonstatic_oop_counts  = NEW_RESOURCE_ARRAY_IN_THREAD(</span>
<span class="line-modified">3934             THREAD, unsigned int, max_nonstatic_oop_maps);</span>




3935 
3936   int first_nonstatic_oop_offset = 0; // will be set for first oop field
3937 
<span class="line-modified">3938   bool compact_fields   = CompactFields;</span>
<span class="line-modified">3939   int allocation_style = FieldsAllocationStyle;</span>
<span class="line-removed">3940   if( allocation_style &lt; 0 || allocation_style &gt; 2 ) { // Out of range?</span>
<span class="line-removed">3941     assert(false, &quot;0 &lt;= FieldsAllocationStyle &lt;= 2&quot;);</span>
<span class="line-removed">3942     allocation_style = 1; // Optimistic</span>
<span class="line-removed">3943   }</span>
3944 
3945   // The next classes have predefined hard-coded fields offsets
3946   // (see in JavaClasses::compute_hard_coded_offsets()).
3947   // Use default fields allocation order for them.
<span class="line-modified">3948   if( (allocation_style != 0 || compact_fields ) &amp;&amp; _loader_data-&gt;class_loader() == NULL &amp;&amp;</span>
<span class="line-modified">3949       (_class_name == vmSymbols::java_lang_AssertionStatusDirectives() ||</span>
<span class="line-removed">3950        _class_name == vmSymbols::java_lang_Class() ||</span>
<span class="line-removed">3951        _class_name == vmSymbols::java_lang_ClassLoader() ||</span>
<span class="line-removed">3952        _class_name == vmSymbols::java_lang_ref_Reference() ||</span>
<span class="line-removed">3953        _class_name == vmSymbols::java_lang_ref_SoftReference() ||</span>
<span class="line-removed">3954        _class_name == vmSymbols::java_lang_StackTraceElement() ||</span>
<span class="line-removed">3955        _class_name == vmSymbols::java_lang_String() ||</span>
<span class="line-removed">3956        _class_name == vmSymbols::java_lang_Throwable() ||</span>
3957        _class_name == vmSymbols::java_lang_Boolean() ||
3958        _class_name == vmSymbols::java_lang_Character() ||
3959        _class_name == vmSymbols::java_lang_Float() ||
3960        _class_name == vmSymbols::java_lang_Double() ||
3961        _class_name == vmSymbols::java_lang_Byte() ||
3962        _class_name == vmSymbols::java_lang_Short() ||
3963        _class_name == vmSymbols::java_lang_Integer() ||
3964        _class_name == vmSymbols::java_lang_Long())) {
<span class="line-modified">3965     allocation_style = 0;     // Allocate oops first</span>
3966     compact_fields   = false; // Don&#39;t compact fields
3967   }
3968 
3969   int next_nonstatic_oop_offset = 0;
3970   int next_nonstatic_double_offset = 0;
3971 
3972   // Rearrange fields for a given allocation style
<span class="line-modified">3973   if( allocation_style == 0 ) {</span>
3974     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
3975     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
3976     next_nonstatic_double_offset = next_nonstatic_oop_offset +
3977                                     (nonstatic_oop_count * heapOopSize);
<span class="line-modified">3978   } else if( allocation_style == 1 ) {</span>
3979     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
3980     next_nonstatic_double_offset = next_nonstatic_field_offset;
<span class="line-removed">3981   } else if( allocation_style == 2 ) {</span>
<span class="line-removed">3982     // Fields allocation: oops fields in super and sub classes are together.</span>
<span class="line-removed">3983     if( nonstatic_field_size &gt; 0 &amp;&amp; _super_klass != NULL &amp;&amp;</span>
<span class="line-removed">3984         _super_klass-&gt;nonstatic_oop_map_size() &gt; 0 ) {</span>
<span class="line-removed">3985       const unsigned int map_count = _super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">3986       const OopMapBlock* const first_map = _super_klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">3987       const OopMapBlock* const last_map = first_map + map_count - 1;</span>
<span class="line-removed">3988       const int next_offset = last_map-&gt;offset() + (last_map-&gt;count() * heapOopSize);</span>
<span class="line-removed">3989       if (next_offset == next_nonstatic_field_offset) {</span>
<span class="line-removed">3990         allocation_style = 0;   // allocate oops first</span>
<span class="line-removed">3991         next_nonstatic_oop_offset    = next_nonstatic_field_offset;</span>
<span class="line-removed">3992         next_nonstatic_double_offset = next_nonstatic_oop_offset +</span>
<span class="line-removed">3993                                        (nonstatic_oop_count * heapOopSize);</span>
<span class="line-removed">3994       }</span>
<span class="line-removed">3995     }</span>
<span class="line-removed">3996     if( allocation_style == 2 ) {</span>
<span class="line-removed">3997       allocation_style = 1;     // allocate oops last</span>
<span class="line-removed">3998       next_nonstatic_double_offset = next_nonstatic_field_offset;</span>
<span class="line-removed">3999     }</span>
<span class="line-removed">4000   } else {</span>
<span class="line-removed">4001     ShouldNotReachHere();</span>
4002   }
4003 
4004   int nonstatic_oop_space_count   = 0;
4005   int nonstatic_word_space_count  = 0;
4006   int nonstatic_short_space_count = 0;
4007   int nonstatic_byte_space_count  = 0;
4008   int nonstatic_oop_space_offset = 0;
4009   int nonstatic_word_space_offset = 0;
4010   int nonstatic_short_space_offset = 0;
4011   int nonstatic_byte_space_offset = 0;
4012 
4013   // Try to squeeze some of the fields into the gaps due to
4014   // long/double alignment.
4015   if (nonstatic_double_count &gt; 0) {
4016     int offset = next_nonstatic_double_offset;
4017     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4018     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4019       // Allocate available fields into the gap before double field.
4020       int length = next_nonstatic_double_offset - offset;
4021       assert(length == BytesPerInt, &quot;&quot;);
</pre>
<hr />
<pre>
4025         nonstatic_word_space_count = 1; // Only one will fit
4026         length -= BytesPerInt;
4027         offset += BytesPerInt;
4028       }
4029       nonstatic_short_space_offset = offset;
4030       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4031         nonstatic_short_count       -= 1;
4032         nonstatic_short_space_count += 1;
4033         length -= BytesPerShort;
4034         offset += BytesPerShort;
4035       }
4036       nonstatic_byte_space_offset = offset;
4037       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4038         nonstatic_byte_count       -= 1;
4039         nonstatic_byte_space_count += 1;
4040         length -= 1;
4041       }
4042       // Allocate oop field in the gap if there are no other fields for that.
4043       nonstatic_oop_space_offset = offset;
4044       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
<span class="line-modified">4045           allocation_style != 0) { // when oop fields not first</span>
4046         nonstatic_oop_count      -= 1;
4047         nonstatic_oop_space_count = 1; // Only one will fit
4048         length -= heapOopSize;
4049         offset += heapOopSize;
4050       }
4051     }
4052   }
4053 
4054   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4055                                      (nonstatic_double_count * BytesPerLong);
4056   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4057                                       (nonstatic_word_count * BytesPerInt);
4058   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4059                                      (nonstatic_short_count * BytesPerShort);
4060   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4061                                        nonstatic_byte_count;
4062 
4063   // let oops jump before padding with this allocation style
<span class="line-modified">4064   if( allocation_style == 1 ) {</span>
4065     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4066     if( nonstatic_oop_count &gt; 0 ) {
4067       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4068     }
4069     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4070   }
4071 
4072   // Iterate over fields again and compute correct offsets.
4073   // The field allocation type was temporarily stored in the offset slot.
4074   // oop fields are located before non-oop fields (static and non-static).
4075   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4076 
4077     // skip already laid out fields
4078     if (fs.is_offset_set()) continue;
4079 
4080     // contended instance fields are handled below
4081     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4082 
4083     int real_offset = 0;
4084     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
</pre>
<hr />
<pre>
4097         real_offset = next_static_short_offset;
4098         next_static_short_offset += BytesPerShort;
4099         break;
4100       case STATIC_WORD:
4101         real_offset = next_static_word_offset;
4102         next_static_word_offset += BytesPerInt;
4103         break;
4104       case STATIC_DOUBLE:
4105         real_offset = next_static_double_offset;
4106         next_static_double_offset += BytesPerLong;
4107         break;
4108       case NONSTATIC_OOP:
4109         if( nonstatic_oop_space_count &gt; 0 ) {
4110           real_offset = nonstatic_oop_space_offset;
4111           nonstatic_oop_space_offset += heapOopSize;
4112           nonstatic_oop_space_count  -= 1;
4113         } else {
4114           real_offset = next_nonstatic_oop_offset;
4115           next_nonstatic_oop_offset += heapOopSize;
4116         }
<span class="line-modified">4117 </span>
<span class="line-removed">4118         // Record this oop in the oop maps</span>
<span class="line-removed">4119         if( nonstatic_oop_map_count &gt; 0 &amp;&amp;</span>
<span class="line-removed">4120             nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==</span>
<span class="line-removed">4121             real_offset -</span>
<span class="line-removed">4122             int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *</span>
<span class="line-removed">4123             heapOopSize ) {</span>
<span class="line-removed">4124           // This oop is adjacent to the previous one, add to current oop map</span>
<span class="line-removed">4125           assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">4126           nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;</span>
<span class="line-removed">4127         } else {</span>
<span class="line-removed">4128           // This oop is not adjacent to the previous one, create new oop map</span>
<span class="line-removed">4129           assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">4130           nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;</span>
<span class="line-removed">4131           nonstatic_oop_counts [nonstatic_oop_map_count] = 1;</span>
<span class="line-removed">4132           nonstatic_oop_map_count += 1;</span>
<span class="line-removed">4133           if( first_nonstatic_oop_offset == 0 ) { // Undefined</span>
<span class="line-removed">4134             first_nonstatic_oop_offset = real_offset;</span>
<span class="line-removed">4135           }</span>
<span class="line-removed">4136         }</span>
4137         break;
4138       case NONSTATIC_BYTE:
4139         if( nonstatic_byte_space_count &gt; 0 ) {
4140           real_offset = nonstatic_byte_space_offset;
4141           nonstatic_byte_space_offset += 1;
4142           nonstatic_byte_space_count  -= 1;
4143         } else {
4144           real_offset = next_nonstatic_byte_offset;
4145           next_nonstatic_byte_offset += 1;
4146         }
4147         break;
4148       case NONSTATIC_SHORT:
4149         if( nonstatic_short_space_count &gt; 0 ) {
4150           real_offset = nonstatic_short_space_offset;
4151           nonstatic_short_space_offset += BytesPerShort;
4152           nonstatic_short_space_count  -= 1;
4153         } else {
4154           real_offset = next_nonstatic_short_offset;
4155           next_nonstatic_short_offset += BytesPerShort;
4156         }
</pre>
<hr />
<pre>
4229             real_offset = next_nonstatic_padded_offset;
4230             next_nonstatic_padded_offset += BytesPerShort;
4231             break;
4232 
4233           case NONSTATIC_WORD:
4234             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4235             real_offset = next_nonstatic_padded_offset;
4236             next_nonstatic_padded_offset += BytesPerInt;
4237             break;
4238 
4239           case NONSTATIC_DOUBLE:
4240             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4241             real_offset = next_nonstatic_padded_offset;
4242             next_nonstatic_padded_offset += BytesPerLong;
4243             break;
4244 
4245           case NONSTATIC_OOP:
4246             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4247             real_offset = next_nonstatic_padded_offset;
4248             next_nonstatic_padded_offset += heapOopSize;
<span class="line-modified">4249 </span>
<span class="line-removed">4250             // Record this oop in the oop maps</span>
<span class="line-removed">4251             if( nonstatic_oop_map_count &gt; 0 &amp;&amp;</span>
<span class="line-removed">4252                 nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==</span>
<span class="line-removed">4253                 real_offset -</span>
<span class="line-removed">4254                 int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *</span>
<span class="line-removed">4255                 heapOopSize ) {</span>
<span class="line-removed">4256               // This oop is adjacent to the previous one, add to current oop map</span>
<span class="line-removed">4257               assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">4258               nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;</span>
<span class="line-removed">4259             } else {</span>
<span class="line-removed">4260               // This oop is not adjacent to the previous one, create new oop map</span>
<span class="line-removed">4261               assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">4262               nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;</span>
<span class="line-removed">4263               nonstatic_oop_counts [nonstatic_oop_map_count] = 1;</span>
<span class="line-removed">4264               nonstatic_oop_map_count += 1;</span>
<span class="line-removed">4265               if( first_nonstatic_oop_offset == 0 ) { // Undefined</span>
<span class="line-removed">4266                 first_nonstatic_oop_offset = real_offset;</span>
<span class="line-removed">4267               }</span>
<span class="line-removed">4268             }</span>
4269             break;
4270 
4271           default:
4272             ShouldNotReachHere();
4273         }
4274 
4275         if (fs.contended_group() == 0) {
4276           // Contended group defines the equivalence class over the fields:
4277           // the fields within the same contended group are not inter-padded.
4278           // The only exception is default group, which does not incur the
4279           // equivalence, and so requires intra-padding.
4280           next_nonstatic_padded_offset += ContendedPaddingWidth;
4281         }
4282 
4283         fs.set_offset(real_offset);
4284       } // for
4285 
4286       // Start laying out the next group.
4287       // Note that this will effectively pad the last group in the back;
4288       // this is expected to alleviate memory contention effects for
</pre>
<hr />
<pre>
4312   int static_field_size         = (static_fields_end -
4313                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4314   nonstatic_field_size          = nonstatic_field_size +
4315                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4316 
4317   int instance_size             = align_object_size(instance_end / wordSize);
4318 
4319   assert(instance_size == align_object_size(align_up(
4320          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
4321           wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4322 
4323   // Invariant: nonstatic_field end/start should only change if there are
4324   // nonstatic fields in the class, or if the class is contended. We compare
4325   // against the non-aligned value, so that end alignment will not fail the
4326   // assert without actually having the fields.
4327   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4328          is_contended_class ||
4329          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4330 
4331   // Number of non-static oop map blocks allocated at end of klass.
<span class="line-modified">4332   const unsigned int total_oop_map_count =</span>
<span class="line-removed">4333     compute_oop_map_count(_super_klass, nonstatic_oop_map_count,</span>
<span class="line-removed">4334                           first_nonstatic_oop_offset);</span>
4335 
4336 #ifndef PRODUCT
4337   if (PrintFieldLayout) {
4338     print_field_layout(_class_name,
4339           _fields,
4340           cp,
4341           instance_size,
4342           nonstatic_fields_start,
4343           nonstatic_fields_end,
4344           static_fields_end);
4345   }
4346 
4347 #endif
4348   // Pass back information needed for InstanceKlass creation
<span class="line-modified">4349   info-&gt;nonstatic_oop_offsets = nonstatic_oop_offsets;</span>
<span class="line-modified">4350   info-&gt;nonstatic_oop_counts = nonstatic_oop_counts;</span>
<span class="line-modified">4351   info-&gt;nonstatic_oop_map_count = nonstatic_oop_map_count;</span>
<span class="line-modified">4352   info-&gt;total_oop_map_count = total_oop_map_count;</span>
<span class="line-modified">4353   info-&gt;instance_size = instance_size;</span>
<span class="line-removed">4354   info-&gt;static_field_size = static_field_size;</span>
<span class="line-removed">4355   info-&gt;nonstatic_field_size = nonstatic_field_size;</span>
<span class="line-removed">4356   info-&gt;has_nonstatic_fields = has_nonstatic_fields;</span>
<span class="line-removed">4357 }</span>
<span class="line-removed">4358 </span>
<span class="line-removed">4359 static void fill_oop_maps(const InstanceKlass* k,</span>
<span class="line-removed">4360                           unsigned int nonstatic_oop_map_count,</span>
<span class="line-removed">4361                           const int* nonstatic_oop_offsets,</span>
<span class="line-removed">4362                           const unsigned int* nonstatic_oop_counts) {</span>
<span class="line-removed">4363 </span>
<span class="line-removed">4364   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">4365 </span>
<span class="line-removed">4366   OopMapBlock* this_oop_map = k-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">4367   const InstanceKlass* const super = k-&gt;superklass();</span>
<span class="line-removed">4368   const unsigned int super_count = super ? super-&gt;nonstatic_oop_map_count() : 0;</span>
<span class="line-removed">4369   if (super_count &gt; 0) {</span>
<span class="line-removed">4370     // Copy maps from superklass</span>
<span class="line-removed">4371     OopMapBlock* super_oop_map = super-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">4372     for (unsigned int i = 0; i &lt; super_count; ++i) {</span>
<span class="line-removed">4373       *this_oop_map++ = *super_oop_map++;</span>
<span class="line-removed">4374     }</span>
<span class="line-removed">4375   }</span>
<span class="line-removed">4376 </span>
<span class="line-removed">4377   if (nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-removed">4378     if (super_count + nonstatic_oop_map_count &gt; k-&gt;nonstatic_oop_map_count()) {</span>
<span class="line-removed">4379       // The counts differ because there is no gap between superklass&#39;s last oop</span>
<span class="line-removed">4380       // field and the first local oop field.  Extend the last oop map copied</span>
<span class="line-removed">4381       // from the superklass instead of creating new one.</span>
<span class="line-removed">4382       nonstatic_oop_map_count--;</span>
<span class="line-removed">4383       nonstatic_oop_offsets++;</span>
<span class="line-removed">4384       this_oop_map--;</span>
<span class="line-removed">4385       this_oop_map-&gt;set_count(this_oop_map-&gt;count() + *nonstatic_oop_counts++);</span>
<span class="line-removed">4386       this_oop_map++;</span>
<span class="line-removed">4387     }</span>
<span class="line-removed">4388 </span>
<span class="line-removed">4389     // Add new map blocks, fill them</span>
<span class="line-removed">4390     while (nonstatic_oop_map_count-- &gt; 0) {</span>
<span class="line-removed">4391       this_oop_map-&gt;set_offset(*nonstatic_oop_offsets++);</span>
<span class="line-removed">4392       this_oop_map-&gt;set_count(*nonstatic_oop_counts++);</span>
<span class="line-removed">4393       this_oop_map++;</span>
<span class="line-removed">4394     }</span>
<span class="line-removed">4395     assert(k-&gt;start_of_nonstatic_oop_maps() + k-&gt;nonstatic_oop_map_count() ==</span>
<span class="line-removed">4396            this_oop_map, &quot;sanity&quot;);</span>
<span class="line-removed">4397   }</span>
4398 }
4399 
<span class="line-removed">4400 </span>
4401 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4402   assert(ik != NULL, &quot;invariant&quot;);
4403 
4404   const Klass* const super = ik-&gt;super();
4405 
4406   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4407   // in which case we don&#39;t have to register objects as finalizable
4408   if (!_has_empty_finalizer) {
4409     if (_has_finalizer ||
4410         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4411       ik-&gt;set_has_finalizer();
4412     }
4413   }
4414 
4415 #ifdef ASSERT
4416   bool f = false;
4417   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4418                                            vmSymbols::void_method_signature());
4419   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4420       f = true;
</pre>
<hr />
<pre>
4534     // Finally add local interfaces
4535     append_interfaces(result, local_ifs);
4536 
4537     // length will be less than the max_transitive_size if duplicates were removed
4538     const int length = result-&gt;length();
4539     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4540     Array&lt;InstanceKlass*&gt;* const new_result =
4541       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4542     for (int i = 0; i &lt; length; i++) {
4543       InstanceKlass* const e = result-&gt;at(i);
4544       assert(e != NULL, &quot;just checking&quot;);
4545       new_result-&gt;at_put(i, e);
4546     }
4547     return new_result;
4548   }
4549 }
4550 
4551 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4552   assert(this_klass != NULL, &quot;invariant&quot;);
4553   const Klass* const super = this_klass-&gt;super();

4554   if (super != NULL) {
4555 
4556     // If the loader is not the boot loader then throw an exception if its
4557     // superclass is in package jdk.internal.reflect and its loader is not a
4558     // special reflection class loader
4559     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4560       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
4561       PackageEntry* super_package = super-&gt;package();
4562       if (super_package != NULL &amp;&amp;
4563           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4564           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4565         ResourceMark rm(THREAD);
4566         Exceptions::fthrow(
4567           THREAD_AND_LOCATION,
4568           vmSymbols::java_lang_IllegalAccessError(),
4569           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4570           this_klass-&gt;external_name(),
4571           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4572           super-&gt;external_name());
4573         return;
</pre>
<hr />
<pre>
4735   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
4736   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
4737   if (is_module) {
4738     ResourceMark rm(THREAD);
4739     Exceptions::fthrow(
4740       THREAD_AND_LOCATION,
4741       vmSymbols::java_lang_NoClassDefFoundError(),
4742       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4743       _class_name-&gt;as_C_string());
4744     return;
4745   }
4746 
4747   if (!_need_verify) { return; }
4748 
4749   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4750   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4751   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4752   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4753   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4754   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
<span class="line-modified">4755   const bool major_gte_15  = _major_version &gt;= JAVA_1_5_VERSION;</span>

4756 
4757   if ((is_abstract &amp;&amp; is_final) ||
4758       (is_interface &amp;&amp; !is_abstract) ||
<span class="line-modified">4759       (is_interface &amp;&amp; major_gte_15 &amp;&amp; (is_super || is_enum)) ||</span>
<span class="line-modified">4760       (!is_interface &amp;&amp; major_gte_15 &amp;&amp; is_annotation)) {</span>
4761     ResourceMark rm(THREAD);
4762     Exceptions::fthrow(
4763       THREAD_AND_LOCATION,
4764       vmSymbols::java_lang_ClassFormatError(),
4765       &quot;Illegal class modifiers in class %s: 0x%X&quot;,
4766       _class_name-&gt;as_C_string(), flags
4767     );
4768     return;
4769   }
4770 }
4771 
4772 static bool has_illegal_visibility(jint flags) {
4773   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4774   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4775   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4776 
4777   return ((is_public &amp;&amp; is_protected) ||
4778           (is_public &amp;&amp; is_private) ||
4779           (is_protected &amp;&amp; is_private));
4780 }
4781 
4782 // A legal major_version.minor_version must be one of the following:
4783 //
<span class="line-modified">4784 //   Major_version = 45, any minor_version.</span>
<span class="line-modified">4785 //   Major_version &gt;= 46 and major_version &lt;= current_major_version and minor_version = 0.</span>
<span class="line-modified">4786 //   Major_version = current_major_version and minor_version = 65535 and --enable-preview is present.</span>
4787 //
4788 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){

4789   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
<span class="line-modified">4790   if (major != JAVA_MIN_SUPPORTED_VERSION) { // All 45.* are ok including 45.65535</span>
<span class="line-modified">4791     if (minor == JAVA_PREVIEW_MINOR_VERSION) {</span>
<span class="line-modified">4792       if (major != max_version) {</span>
<span class="line-modified">4793         ResourceMark rm(THREAD);</span>
<span class="line-modified">4794         Exceptions::fthrow(</span>
<span class="line-modified">4795           THREAD_AND_LOCATION,</span>
<span class="line-modified">4796           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4797           &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;</span>
<span class="line-removed">4798           &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,</span>
<span class="line-removed">4799           class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);</span>
<span class="line-removed">4800         return;</span>
<span class="line-removed">4801       }</span>
4802 
<span class="line-modified">4803       if (!Arguments::enable_preview()) {</span>
<span class="line-modified">4804         ResourceMark rm(THREAD);</span>
<span class="line-modified">4805         Exceptions::fthrow(</span>
<span class="line-modified">4806           THREAD_AND_LOCATION,</span>
<span class="line-modified">4807           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4808           &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,</span>
<span class="line-modified">4809           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">4810         return;</span>
<span class="line-modified">4811       }</span>
4812 
<span class="line-modified">4813     } else { // minor != JAVA_PREVIEW_MINOR_VERSION</span>
<span class="line-modified">4814       if (major &gt; max_version) {</span>
<span class="line-modified">4815         ResourceMark rm(THREAD);</span>
<span class="line-modified">4816         Exceptions::fthrow(</span>
<span class="line-modified">4817           THREAD_AND_LOCATION,</span>
<span class="line-modified">4818           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4819           &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;</span>
<span class="line-modified">4820           &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,</span>
<span class="line-modified">4821           class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-modified">4822       } else if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {</span>
<span class="line-modified">4823         ResourceMark rm(THREAD);</span>
<span class="line-modified">4824         Exceptions::fthrow(</span>
<span class="line-modified">4825           THREAD_AND_LOCATION,</span>
<span class="line-modified">4826           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4827           &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,</span>
<span class="line-modified">4828           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">4829       } else if (minor != 0) {</span>
<span class="line-modified">4830         ResourceMark rm(THREAD);</span>
<span class="line-modified">4831         Exceptions::fthrow(</span>
<span class="line-modified">4832           THREAD_AND_LOCATION,</span>
<span class="line-modified">4833           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4834           &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,</span>
<span class="line-removed">4835           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-removed">4836       }</span>
4837     }







4838   }
4839 }
4840 
4841 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4842                                                    bool is_interface,
4843                                                    TRAPS) const {
4844   if (!_need_verify) { return; }
4845 
4846   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4847   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4848   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4849   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4850   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4851   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4852   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4853   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
<span class="line-modified">4854   const bool major_gte_15 = _major_version &gt;= JAVA_1_5_VERSION;</span>
4855 
4856   bool is_illegal = false;
4857 
4858   if (is_interface) {
4859     if (!is_public || !is_static || !is_final || is_private ||
4860         is_protected || is_volatile || is_transient ||
<span class="line-modified">4861         (major_gte_15 &amp;&amp; is_enum)) {</span>
4862       is_illegal = true;
4863     }
4864   } else { // not interface
4865     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
4866       is_illegal = true;
4867     }
4868   }
4869 
4870   if (is_illegal) {
4871     ResourceMark rm(THREAD);
4872     Exceptions::fthrow(
4873       THREAD_AND_LOCATION,
4874       vmSymbols::java_lang_ClassFormatError(),
4875       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
4876       _class_name-&gt;as_C_string(), flags);
4877     return;
4878   }
4879 }
4880 
4881 void ClassFileParser::verify_legal_method_modifiers(jint flags,
4882                                                     bool is_interface,
4883                                                     const Symbol* name,
4884                                                     TRAPS) const {
4885   if (!_need_verify) { return; }
4886 
4887   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
4888   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
4889   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
4890   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
4891   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
4892   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
4893   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
4894   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
4895   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
4896   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
<span class="line-modified">4897   const bool major_gte_15    = _major_version &gt;= JAVA_1_5_VERSION;</span>
4898   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
4899   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
4900 
4901   bool is_illegal = false;
4902 
4903   if (is_interface) {
4904     if (major_gte_8) {
4905       // Class file version is JAVA_8_VERSION or later Methods of
4906       // interfaces may set any of the flags except ACC_PROTECTED,
4907       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
4908       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
4909       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
4910           (is_native || is_protected || is_final || is_synchronized) ||
4911           // If a specific method of a class or interface has its
4912           // ACC_ABSTRACT flag set, it must not have any of its
4913           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
4914           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
4915           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
4916           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
4917           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
4918         is_illegal = true;
4919       }
<span class="line-modified">4920     } else if (major_gte_15) {</span>
4921       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
4922       if (!is_public || is_private || is_protected || is_static || is_final ||
4923           is_synchronized || is_native || !is_abstract || is_strict) {
4924         is_illegal = true;
4925       }
4926     } else {
4927       // Class file version is pre-JAVA_1_5_VERSION
4928       if (!is_public || is_static || is_final || is_native || !is_abstract) {
4929         is_illegal = true;
4930       }
4931     }
4932   } else { // not interface
4933     if (has_illegal_visibility(flags)) {
4934       is_illegal = true;
4935     } else {
4936       if (is_initializer) {
4937         if (is_static || is_final || is_synchronized || is_native ||
<span class="line-modified">4938             is_abstract || (major_gte_15 &amp;&amp; is_bridge)) {</span>
4939           is_illegal = true;
4940         }
4941       } else { // not initializer
4942         if (is_abstract) {
4943           if ((is_final || is_native || is_private || is_static ||
<span class="line-modified">4944               (major_gte_15 &amp;&amp; (is_synchronized || is_strict)))) {</span>
4945             is_illegal = true;
4946           }
4947         }
4948       }
4949     }
4950   }
4951 
4952   if (is_illegal) {
4953     ResourceMark rm(THREAD);
4954     Exceptions::fthrow(
4955       THREAD_AND_LOCATION,
4956       vmSymbols::java_lang_ClassFormatError(),
4957       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,
4958       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);
4959     return;
4960   }
4961 }
4962 
4963 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
4964                                         int length,
4965                                         TRAPS) const {
4966   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
4967   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
4968     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
4969   }
4970 }
4971 
4972 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
4973 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
4974 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
4975 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
4976 // method.  Because these names have been checked as special cases before
4977 // calling this method in verify_legal_method_name.
4978 //
4979 // This method is also called from the modular system APIs in modules.cpp
4980 // to verify the validity of module and package names.
4981 bool ClassFileParser::verify_unqualified_name(const char* name,
4982                                               unsigned int length,
4983                                               int type) {

4984   for (const char* p = name; p != name + length; p++) {
4985     switch(*p) {
<span class="line-modified">4986       case &#39;.&#39;:</span>
<span class="line-modified">4987       case &#39;;&#39;:</span>
<span class="line-modified">4988       case &#39;[&#39;:</span>
4989         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
4990         return false;
<span class="line-modified">4991       case &#39;/&#39;:</span>
4992         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
4993         // unqualified name must not be empty
4994         if (type == ClassFileParser::LegalClass) {
<span class="line-modified">4995           if (p == name || p+1 &gt;= name+length || *(p+1) == &#39;/&#39;) {</span>

4996             return false;
4997           }
4998         } else {
4999           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5000         }
5001         break;
<span class="line-modified">5002       case &#39;&lt;&#39;:</span>
<span class="line-modified">5003       case &#39;&gt;&#39;:</span>
5004         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5005         if (type == ClassFileParser::LegalMethod) {
5006           return false;
5007         }
5008     }
5009   }
5010   return true;
5011 }
5012 
5013 // Take pointer to a UTF8 byte string (not NUL-terminated).
5014 // Skip over the longest part of the string that could
5015 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5016 // Return a pointer to just past the fieldname.
5017 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5018 // being true, we saw consecutive slashes (meaning we were looking for a
5019 // qualified path but found something that was badly-formed).
5020 static const char* skip_over_field_name(const char* const name,
5021                                         bool slash_ok,
5022                                         unsigned int length) {
5023   const char* p;
5024   jboolean last_is_slash = false;
5025   jboolean not_first_ch = false;
5026 
5027   for (p = name; p != name + length; not_first_ch = true) {
5028     const char* old_p = p;
5029     jchar ch = *p;
5030     if (ch &lt; 128) {
5031       p++;
5032       // quick check for ascii
5033       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5034         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5035         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5036         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5037         last_is_slash = false;
5038         continue;
5039       }
<span class="line-modified">5040       if (slash_ok &amp;&amp; ch == &#39;/&#39;) {</span>
5041         if (last_is_slash) {
5042           return NULL;  // Don&#39;t permit consecutive slashes
5043         }
5044         last_is_slash = true;
5045         continue;
5046       }
5047     }
5048     else {
5049       jint unicode_ch;
5050       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5051       p = tmp_p;
5052       last_is_slash = false;
5053       // Check if ch is Java identifier start or is Java identifier part
5054       // 4672820: call java.lang.Character methods directly without generating separate tables.
5055       EXCEPTION_MARK;
5056       // return value
5057       JavaValue result(T_BOOLEAN);
5058       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5059       JavaCallArguments args;
5060       args.push_int(unicode_ch);
</pre>
<hr />
<pre>
5100                                                        TRAPS) const {
5101   unsigned int array_dim = 0;
5102   while (length &gt; 0) {
5103     switch (signature[0]) {
5104     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5105     case JVM_SIGNATURE_BOOLEAN:
5106     case JVM_SIGNATURE_BYTE:
5107     case JVM_SIGNATURE_CHAR:
5108     case JVM_SIGNATURE_SHORT:
5109     case JVM_SIGNATURE_INT:
5110     case JVM_SIGNATURE_FLOAT:
5111     case JVM_SIGNATURE_LONG:
5112     case JVM_SIGNATURE_DOUBLE:
5113       return signature + 1;
5114     case JVM_SIGNATURE_CLASS: {
5115       if (_major_version &lt; JAVA_1_5_VERSION) {
5116         // Skip over the class name if one is there
5117         const char* const p = skip_over_field_name(signature + 1, true, --length);
5118 
5119         // The next character better be a semicolon
<span class="line-modified">5120         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == &#39;;&#39;) {</span>
5121           return p + 1;
5122         }
5123       }
5124       else {
5125         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
5126         signature++;
<span class="line-modified">5127         const char* c = (const char*) memchr(signature, &#39;;&#39;, length - 1);</span>
5128         // Format check signature
5129         if (c != NULL) {
5130           int newlen = c - (char*) signature;
5131           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5132           if (!legal) {
<span class="line-modified">5133             classfile_parse_error(&quot;Class name contains illegal character &quot;</span>
5134                                   &quot;in descriptor in class file %s&quot;,
5135                                   CHECK_0);
5136             return NULL;
5137           }
5138           return signature + newlen + 1;
5139         }
5140       }
5141       return NULL;
5142     }
5143     case JVM_SIGNATURE_ARRAY:
5144       array_dim++;
5145       if (array_dim &gt; 255) {
5146         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5147         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);
5148       }
5149       // The rest of what&#39;s there better be a legal signature
5150       signature++;
5151       length--;
5152       void_ok = false;
5153       break;
</pre>
<hr />
<pre>
5156     }
5157   }
5158   return NULL;
5159 }
5160 
5161 // Checks if name is a legal class name.
5162 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5163   if (!_need_verify || _relax_verify) { return; }
5164 
5165   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5166   char* bytes = (char*)name-&gt;bytes();
5167   unsigned int length = name-&gt;utf8_length();
5168   bool legal = false;
5169 
5170   if (length &gt; 0) {
5171     const char* p;
5172     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5173       p = skip_over_field_signature(bytes, false, length, CHECK);
5174       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5175     } else if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">5176       if (bytes[0] != &#39;&lt;&#39;) {</span>
5177         p = skip_over_field_name(bytes, true, length);
5178         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5179       }
5180     } else {
5181       // 4900761: relax the constraints based on JSR202 spec
5182       // Class names may be drawn from the entire Unicode character set.
5183       // Identifiers between &#39;/&#39; must be unqualified names.
5184       // The utf8 string has been verified when parsing cpool entries.
5185       legal = verify_unqualified_name(bytes, length, LegalClass);
5186     }
5187   }
5188   if (!legal) {
5189     ResourceMark rm(THREAD);
5190     assert(_class_name != NULL, &quot;invariant&quot;);
5191     Exceptions::fthrow(
5192       THREAD_AND_LOCATION,
5193       vmSymbols::java_lang_ClassFormatError(),
5194       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5195       _class_name-&gt;as_C_string()
5196     );
5197     return;
5198   }
5199 }
5200 
5201 // Checks if name is a legal field name.
5202 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5203   if (!_need_verify || _relax_verify) { return; }
5204 
5205   char* bytes = (char*)name-&gt;bytes();
5206   unsigned int length = name-&gt;utf8_length();
5207   bool legal = false;
5208 
5209   if (length &gt; 0) {
5210     if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">5211       if (bytes[0] != &#39;&lt;&#39;) {</span>
5212         const char* p = skip_over_field_name(bytes, false, length);
5213         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5214       }
5215     } else {
5216       // 4881221: relax the constraints based on JSR202 spec
5217       legal = verify_unqualified_name(bytes, length, LegalField);
5218     }
5219   }
5220 
5221   if (!legal) {
5222     ResourceMark rm(THREAD);
5223     assert(_class_name != NULL, &quot;invariant&quot;);
5224     Exceptions::fthrow(
5225       THREAD_AND_LOCATION,
5226       vmSymbols::java_lang_ClassFormatError(),
5227       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5228       _class_name-&gt;as_C_string()
5229     );
5230     return;
5231   }
5232 }
5233 
5234 // Checks if name is a legal method name.
5235 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5236   if (!_need_verify || _relax_verify) { return; }
5237 
5238   assert(name != NULL, &quot;method name is null&quot;);
5239   char* bytes = (char*)name-&gt;bytes();
5240   unsigned int length = name-&gt;utf8_length();
5241   bool legal = false;
5242 
5243   if (length &gt; 0) {
<span class="line-modified">5244     if (bytes[0] == &#39;&lt;&#39;) {</span>
5245       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5246         legal = true;
5247       }
5248     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5249       const char* p;
5250       p = skip_over_field_name(bytes, false, length);
5251       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5252     } else {
5253       // 4881221: relax the constraints based on JSR202 spec
5254       legal = verify_unqualified_name(bytes, length, LegalMethod);
5255     }
5256   }
5257 
5258   if (!legal) {
5259     ResourceMark rm(THREAD);
5260     assert(_class_name != NULL, &quot;invariant&quot;);
5261     Exceptions::fthrow(
5262       THREAD_AND_LOCATION,
5263       vmSymbols::java_lang_ClassFormatError(),
5264       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
</pre>
<hr />
<pre>
5308   unsigned int length = signature-&gt;utf8_length();
5309   const char* nextp;
5310 
5311   // The first character must be a &#39;(&#39;
5312   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5313     length--;
5314     // Skip over legal field signatures
5315     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5316     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5317       args_size++;
5318       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5319         args_size++;
5320       }
5321       length -= nextp - p;
5322       p = nextp;
5323       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5324     }
5325     // The first non-signature thing better be a &#39;)&#39;
5326     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5327       length--;
<span class="line-modified">5328       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == &#39;&lt;&#39;) {</span>
5329         // All internal methods must return void
5330         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5331           return args_size;
5332         }
5333       } else {
5334         // Now we better just have a return value
5335         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5336         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5337           return args_size;
5338         }
5339       }
5340     }
5341   }
5342   // Report error
5343   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5344   return 0;
5345 }
5346 
5347 int ClassFileParser::static_field_size() const {
5348   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5349   return _field_info-&gt;static_field_size;</span>
5350 }
5351 
5352 int ClassFileParser::total_oop_map_count() const {
5353   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5354   return _field_info-&gt;total_oop_map_count;</span>
5355 }
5356 
5357 jint ClassFileParser::layout_size() const {
5358   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5359   return _field_info-&gt;instance_size;</span>
5360 }
5361 
5362 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5363                                          const Array&lt;Method*&gt;* methods) {
5364   assert(ik != NULL, &quot;invariant&quot;);
5365   assert(methods != NULL, &quot;invariant&quot;);
5366 
5367   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5368   // (We used to do this lazily, but now we query it in Rewriter,
5369   // which is eagerly done for every method, so we might as well do it now,
5370   // when everything is fresh in memory.)
5371   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5372 
5373   if (klass_id != vmSymbols::NO_SID) {
5374     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5375       Method* method = methods-&gt;at(j);
5376       method-&gt;init_intrinsic_id();
5377 
5378       if (CheckIntrinsics) {
5379         // Check if an intrinsic is defined for method &#39;method&#39;,
</pre>
<hr />
<pre>
5483 
5484   return ik;
5485 }
5486 
5487 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5488   assert(ik != NULL, &quot;invariant&quot;);
5489 
5490   // Set name and CLD before adding to CLD
5491   ik-&gt;set_class_loader_data(_loader_data);
5492   ik-&gt;set_name(_class_name);
5493 
5494   // Add all classes to our internal class loader list here,
5495   // including classes in the bootstrap (NULL) class loader.
5496   const bool publicize = !is_internal();
5497 
5498   _loader_data-&gt;add_class(ik, publicize);
5499 
5500   set_klass_to_deallocate(ik);
5501 
5502   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5503   assert(ik-&gt;static_field_size() == _field_info-&gt;static_field_size, &quot;sanity&quot;);</span>
<span class="line-modified">5504   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;total_oop_map_count,</span>
<span class="line-modified">5505     &quot;sanity&quot;);</span>
5506 
5507   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
<span class="line-modified">5508   assert(ik-&gt;size_helper() == _field_info-&gt;instance_size, &quot;sanity&quot;);</span>
5509 
5510   // Fill in information already parsed
5511   ik-&gt;set_should_verify_class(_need_verify);
5512 
5513   // Not yet: supers are done below to support the new subtype-checking fields
<span class="line-modified">5514   ik-&gt;set_nonstatic_field_size(_field_info-&gt;nonstatic_field_size);</span>
<span class="line-modified">5515   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;has_nonstatic_fields);</span>
5516   assert(_fac != NULL, &quot;invariant&quot;);
5517   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5518 
5519   // this transfers ownership of a lot of arrays from
5520   // the parser onto the InstanceKlass*
5521   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5522 
5523   // note that is not safe to use the fields in the parser from this point on
5524   assert(NULL == _cp, &quot;invariant&quot;);
5525   assert(NULL == _fields, &quot;invariant&quot;);
5526   assert(NULL == _methods, &quot;invariant&quot;);
5527   assert(NULL == _inner_classes, &quot;invariant&quot;);
5528   assert(NULL == _nest_members, &quot;invariant&quot;);
5529   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5530   assert(NULL == _combined_annotations, &quot;invariant&quot;);

5531 
5532   if (_has_final_method) {
5533     ik-&gt;set_has_final_method();
5534   }
5535 
5536   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5537   // The InstanceKlass::_methods_jmethod_ids cache
5538   // is managed on the assumption that the initial cache
5539   // size is equal to the number of methods in the class. If
5540   // that changes, then InstanceKlass::idnum_can_increment()
5541   // has to be changed accordingly.
5542   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5543 
5544   ik-&gt;set_this_class_index(_this_class_index);
5545 
5546   if (is_unsafe_anonymous()) {
5547     // _this_class_index is a CONSTANT_Class entry that refers to this
5548     // anonymous class itself. If this class needs to refer to its own methods or
5549     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5550     // _this_class_index. However, because this class is anonymous (it&#39;s
</pre>
<hr />
<pre>
5585 
5586   // Miranda methods
5587   if ((_num_miranda_methods &gt; 0) ||
5588       // if this class introduced new miranda methods or
5589       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5590         // super class exists and this class inherited miranda methods
5591      ) {
5592        ik-&gt;set_has_miranda_methods(); // then set a flag
5593   }
5594 
5595   // Fill in information needed to compute superclasses.
5596   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5597   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5598   _transitive_interfaces = NULL;
5599 
5600   // Initialize itable offset tables
5601   klassItable::setup_itable_offset_table(ik);
5602 
5603   // Compute transitive closure of interfaces this class implements
5604   // Do final class setup
<span class="line-modified">5605   fill_oop_maps(ik,</span>
<span class="line-modified">5606                 _field_info-&gt;nonstatic_oop_map_count,</span>
<span class="line-modified">5607                 _field_info-&gt;nonstatic_oop_offsets,</span>
<span class="line-modified">5608                 _field_info-&gt;nonstatic_oop_counts);</span>





5609 
5610   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5611   set_precomputed_flags(ik);
5612 
5613   // check if this class can access its super class
5614   check_super_class_access(ik, CHECK);
5615 
5616   // check if this class can access its superinterfaces
5617   check_super_interface_access(ik, CHECK);
5618 
5619   // check if this class overrides any final method
5620   check_final_method_override(ik, CHECK);
5621 
5622   // reject static interface methods prior to Java 8
5623   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5624     check_illegal_static_method(ik, CHECK);
5625   }
5626 
5627   // Obtain this_klass&#39; module entry
5628   ModuleEntry* module_entry = ik-&gt;module();
</pre>
<hr />
<pre>
5668       // Make sure each method has a jmethodID.
5669       // This allows us to avoid allocating jmethodIDs during program execution.
5670       jmethodID id = ik-&gt;methods()-&gt;at(index)-&gt;jmethod_id();
5671 #ifdef ASSERT
5672       u8 id_u8 = reinterpret_cast&lt;u8&gt;(id);
5673       assert((id_u8 &amp; right_n_bits(3)) == 0, &quot;jmethodID is not aligned&quot;);
5674       assert((id_u8 &amp; left_n_bits(17)) == 0, &quot;jmethodID is not aligned&quot;);
5675 #endif
5676     }
5677   }
5678 #endif // INCLUDE_TSAN
5679 
5680   if (!is_internal()) {
5681     if (log_is_enabled(Info, class, load)) {
5682       ResourceMark rm;
5683       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5684       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5685     }
5686 
5687     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
<span class="line-modified">5688         ik-&gt;major_version() != JAVA_MIN_SUPPORTED_VERSION &amp;&amp;</span>
5689         log_is_enabled(Info, class, preview)) {
5690       ResourceMark rm;
5691       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
<span class="line-modified">5692                                ik-&gt;external_name(), ik-&gt;major_version());</span>
5693     }
5694 
5695     if (log_is_enabled(Debug, class, resolve))  {
5696       ResourceMark rm;
5697       // print out the superclass.
5698       const char * from = ik-&gt;external_name();
5699       if (ik-&gt;java_super() != NULL) {
5700         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5701                    from,
5702                    ik-&gt;java_super()-&gt;external_name());
5703       }
5704       // print out each of the interface classes referred to by this class.
5705       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5706       if (local_interfaces != NULL) {
5707         const int length = local_interfaces-&gt;length();
5708         for (int i = 0; i &lt; length; i++) {
5709           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5710           const char * to = k-&gt;external_name();
5711           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5712         }
</pre>
<hr />
<pre>
5727   debug_only(ik-&gt;verify();)
5728 }
5729 
5730 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5731   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5732   _class_name-&gt;decrement_refcount();
5733 
5734   _class_name = new_class_name;
5735   // Increment the refcount of the new name.
5736   // Now the ClassFileParser owns this name and will decrement in
5737   // the destructor.
5738   _class_name-&gt;increment_refcount();
5739 }
5740 
5741 
5742 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5743 // package by prepending its host class&#39;s package name to its class name and setting
5744 // its _class_name field.
5745 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5746   ResourceMark rm(THREAD);
<span class="line-modified">5747   assert(strrchr(_class_name-&gt;as_C_string(), &#39;/&#39;) == NULL,</span>
5748          &quot;Unsafe anonymous class should not be in a package&quot;);
5749   const char* host_pkg_name =
5750     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
5751 
5752   if (host_pkg_name != NULL) {
5753     int host_pkg_len = (int)strlen(host_pkg_name);
5754     int class_name_len = _class_name-&gt;utf8_length();
5755     int symbol_len = host_pkg_len + 1 + class_name_len;
5756     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
5757     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
5758                          host_pkg_name, class_name_len, _class_name-&gt;base());
5759     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
5760 
5761     // Decrement old _class_name to avoid leaking.
5762     _class_name-&gt;decrement_refcount();
5763 
5764     // Create a symbol and update the anonymous class name.
5765     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
5766     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
5767     // when the class is unloaded.
<span class="line-modified">5768     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len, CHECK);</span>
5769   }
5770 }
5771 
5772 // If the host class and the anonymous class are in the same package then do
5773 // nothing.  If the anonymous class is in the unnamed package then move it to its
5774 // host&#39;s package.  If the classes are in different packages then throw an IAE
5775 // exception.
5776 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
5777   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
5778 
5779   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
<span class="line-modified">5780                                                _class_name-&gt;utf8_length(), &#39;/&#39;);</span>
5781   if (anon_last_slash == NULL) {  // Unnamed package
5782     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
5783   } else {
5784     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
5785       ResourceMark rm(THREAD);
5786       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
5787         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
5788         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
5789     }
5790   }
5791 }
5792 
5793 static bool relax_format_check_for(ClassLoaderData* loader_data) {
5794   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
5795                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
5796   bool need_verify =
5797     // verifyAll
5798     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
5799     // verifyRemote
5800     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
</pre>
<hr />
<pre>
5809                                  GrowableArray&lt;Handle&gt;* cp_patches,
5810                                  Publicity pub_level,
5811                                  TRAPS) :
5812   _stream(stream),
5813   _requested_name(name),
5814   _class_name(NULL),
5815   _loader_data(loader_data),
5816   _unsafe_anonymous_host(unsafe_anonymous_host),
5817   _cp_patches(cp_patches),
5818   _num_patched_klasses(0),
5819   _max_num_patched_klasses(0),
5820   _orig_cp_size(0),
5821   _first_patched_klass_resolved_index(0),
5822   _super_klass(),
5823   _cp(NULL),
5824   _fields(NULL),
5825   _methods(NULL),
5826   _inner_classes(NULL),
5827   _nest_members(NULL),
5828   _nest_host(0),

5829   _local_interfaces(NULL),
5830   _transitive_interfaces(NULL),
5831   _combined_annotations(NULL),
<span class="line-modified">5832   _annotations(NULL),</span>
<span class="line-modified">5833   _type_annotations(NULL),</span>
5834   _fields_annotations(NULL),
5835   _fields_type_annotations(NULL),
5836   _klass(NULL),
5837   _klass_to_deallocate(NULL),
5838   _parsed_annotations(NULL),
5839   _fac(NULL),
5840   _field_info(NULL),
5841   _method_ordering(NULL),
5842   _all_mirandas(NULL),
5843   _vtable_size(0),
5844   _itable_size(0),
5845   _num_miranda_methods(0),
5846   _rt(REF_NONE),
5847   _protection_domain(protection_domain),
5848   _access_flags(),
5849   _pub_level(pub_level),
5850   _bad_constant_seen(0),
5851   _synthetic_flag(false),
5852   _sde_length(false),
5853   _sde_buffer(NULL),
5854   _sourcefile_index(0),
5855   _generic_signature_index(0),
5856   _major_version(0),
5857   _minor_version(0),
5858   _this_class_index(0),
5859   _super_class_index(0),
5860   _itfs_len(0),
5861   _java_fields_count(0),
5862   _need_verify(false),
5863   _relax_verify(false),
5864   _has_nonstatic_concrete_methods(false),
5865   _declares_nonstatic_concrete_methods(false),
5866   _has_final_method(false),

5867   _has_finalizer(false),
5868   _has_empty_finalizer(false),
5869   _has_vanilla_constructor(false),
5870   _max_bootstrap_specifier_index(-1) {
5871 
5872   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
5873   _class_name-&gt;increment_refcount();
5874 
5875   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
5876   assert(_loader_data != NULL, &quot;invariant&quot;);
5877   assert(stream != NULL, &quot;invariant&quot;);
5878   assert(_stream != NULL, &quot;invariant&quot;);
5879   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
5880   assert(_class_name != NULL, &quot;invariant&quot;);
5881   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
5882 
5883   // Figure out whether we can skip format checking (matching classic VM behavior)
5884   if (DumpSharedSpaces) {
5885     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
5886     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
5917 
5918   // Check if verification needs to be relaxed for this class file
5919   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
5920   _relax_verify = relax_format_check_for(_loader_data);
5921 
5922   parse_stream(stream, CHECK);
5923 
5924   post_process_parsed_stream(stream, _cp, CHECK);
5925 }
5926 
5927 void ClassFileParser::clear_class_metadata() {
5928   // metadata created before the instance klass is created.  Must be
5929   // deallocated if classfile parsing returns an error.
5930   _cp = NULL;
5931   _fields = NULL;
5932   _methods = NULL;
5933   _inner_classes = NULL;
5934   _nest_members = NULL;
5935   _local_interfaces = NULL;
5936   _combined_annotations = NULL;
<span class="line-modified">5937   _annotations = _type_annotations = NULL;</span>
5938   _fields_annotations = _fields_type_annotations = NULL;

5939 }
5940 
5941 // Destructor to clean up
5942 ClassFileParser::~ClassFileParser() {
5943   _class_name-&gt;decrement_refcount();
5944 
5945   if (_cp != NULL) {
5946     MetadataFactory::free_metadata(_loader_data, _cp);
5947   }
5948   if (_fields != NULL) {
5949     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
5950   }
5951 
5952   if (_methods != NULL) {
5953     // Free methods
5954     InstanceKlass::deallocate_methods(_loader_data, _methods);
5955   }
5956 
5957   // beware of the Universe::empty_blah_array!!
5958   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
5959     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
5960   }
5961 
5962   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
5963     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
5964   }
5965 




5966   // Free interfaces
5967   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
5968                                        _local_interfaces, _transitive_interfaces);
5969 
5970   if (_combined_annotations != NULL) {
5971     // After all annotations arrays have been created, they are installed into the
5972     // Annotations object that will be assigned to the InstanceKlass being created.
5973 
5974     // Deallocate the Annotations object and the installed annotations arrays.
5975     _combined_annotations-&gt;deallocate_contents(_loader_data);
5976 
5977     // If the _combined_annotations pointer is non-NULL,
5978     // then the other annotations fields should have been cleared.
<span class="line-modified">5979     assert(_annotations             == NULL, &quot;Should have been cleared&quot;);</span>
<span class="line-modified">5980     assert(_type_annotations        == NULL, &quot;Should have been cleared&quot;);</span>
5981     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
5982     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
5983   } else {
5984     // If the annotations arrays were not installed into the Annotations object,
5985     // then they have to be deallocated explicitly.
<span class="line-modified">5986     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _annotations);</span>
<span class="line-modified">5987     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _type_annotations);</span>
5988     Annotations::free_contents(_loader_data, _fields_annotations);
5989     Annotations::free_contents(_loader_data, _fields_type_annotations);
5990   }
5991 
5992   clear_class_metadata();
5993   _transitive_interfaces = NULL;
5994 
5995   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
5996   // to the deallocate list so that the klass is removed from the CLD::_klasses list
5997   // at a safepoint.
5998   if (_klass_to_deallocate != NULL) {
5999     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6000   }
6001 }
6002 
6003 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6004                                    TRAPS) {
6005 
6006   assert(stream != NULL, &quot;invariant&quot;);
6007   assert(_class_name != NULL, &quot;invariant&quot;);
6008 
6009   // BEGIN STREAM PARSING
6010   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6011   // Magic value
6012   const u4 magic = stream-&gt;get_u4_fast();
6013   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6014                      &quot;Incompatible magic value %u in class file %s&quot;,
6015                      magic, CHECK);
6016 
6017   // Version numbers
6018   _minor_version = stream-&gt;get_u2_fast();
6019   _major_version = stream-&gt;get_u2_fast();
6020 
<span class="line-modified">6021   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_1_5_VERSION) {</span>
6022     ResourceMark rm;
<span class="line-modified">6023     warning(&quot;Pre JDK 1.5 class not supported by CDS: %u.%u %s&quot;,</span>
6024             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6025     Exceptions::fthrow(
6026       THREAD_AND_LOCATION,
6027       vmSymbols::java_lang_UnsupportedClassVersionError(),
6028       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6029       _major_version,
6030       _minor_version);
6031   }
6032 
6033   // Check version numbers - we check this even with verifier off
6034   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6035 
6036   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6037   u2 cp_size = stream-&gt;get_u2_fast();
6038 
6039   guarantee_property(
6040     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6041     cp_size, CHECK);
6042 
6043   _orig_cp_size = cp_size;
</pre>
<hr />
<pre>
6142       }
6143       ls.cr();
6144     }
6145 
6146 #if INCLUDE_CDS
6147     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6148       if (!ClassLoader::has_jrt_entry()) {
6149         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6150         DumpLoadedClassList = NULL;
6151       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6152                  _unsafe_anonymous_host == NULL) {
6153         // Only dump the classes that can be stored into CDS archive.
6154         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6155         oop class_loader = _loader_data-&gt;class_loader();
6156         ResourceMark rm(THREAD);
6157         bool skip = false;
6158         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6159           // For the boot and platform class loaders, skip classes that are not found in the
6160           // java runtime image, such as those found in the --patch-module entries.
6161           // These classes can&#39;t be loaded from the archive during runtime.
<span class="line-modified">6162           if (!ClassLoader::is_modules_image(stream-&gt;source()) &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {</span>
6163             skip = true;
6164           }
6165 
6166           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6167             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6168             // as they can be loaded from the archive during runtime.
6169             skip = false;
6170           }
6171         }
6172         if (skip) {
6173           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6174             _class_name-&gt;as_C_string(), stream-&gt;source());
6175         } else {
6176           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6177           classlist_file-&gt;flush();
6178         }
6179       }
6180     }
6181 #endif
6182   }
</pre>
<hr />
<pre>
6319   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6320                                                     &amp;_num_miranda_methods,
6321                                                     _all_mirandas,
6322                                                     _super_klass,
6323                                                     _methods,
6324                                                     _access_flags,
6325                                                     _major_version,
6326                                                     loader,
6327                                                     _class_name,
6328                                                     _local_interfaces,
6329                                                     CHECK);
6330 
6331   // Size of Java itable (in words)
6332   _itable_size = _access_flags.is_interface() ? 0 :
6333     klassItable::compute_itable_size(_transitive_interfaces);
6334 
6335   assert(_fac != NULL, &quot;invariant&quot;);
6336   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6337 
6338   _field_info = new FieldLayoutInfo();
<span class="line-modified">6339   layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>






6340 
6341   // Compute reference typ
6342   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6343 
6344 }
6345 
6346 void ClassFileParser::set_klass(InstanceKlass* klass) {
6347 
6348 #ifdef ASSERT
6349   if (klass != NULL) {
6350     assert(NULL == _klass, &quot;leaking?&quot;);
6351   }
6352 #endif
6353 
6354   _klass = klass;
6355 }
6356 
6357 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6358 
6359 #ifdef ASSERT
</pre>
<hr />
<pre>
6365   _klass_to_deallocate = klass;
6366 }
6367 
6368 // Caller responsible for ResourceMark
6369 // clone stream with rewound position
6370 const ClassFileStream* ClassFileParser::clone_stream() const {
6371   assert(_stream != NULL, &quot;invariant&quot;);
6372 
6373   return _stream-&gt;clone();
6374 }
6375 // ----------------------------------------------------------------------------
6376 // debugging
6377 
6378 #ifdef ASSERT
6379 
6380 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6381 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6382   if (class_name != NULL) {
6383     ResourceMark rm;
6384     char* name = class_name-&gt;as_C_string();
<span class="line-modified">6385     return strchr(name, &#39;.&#39;) == NULL;</span>
6386   } else {
6387     return true;
6388   }
6389 }
6390 
6391 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
<span class="line-added">  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;</span>
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">  36 #include &quot;classfile/packageEntry.hpp&quot;</span>
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #if INCLUDE_TSAN
  40 #include &quot;classfile/tsanIgnoreList.hpp&quot;
  41 #endif // INCLUDE_TSAN
  42 #include &quot;classfile/verificationType.hpp&quot;
  43 #include &quot;classfile/verifier.hpp&quot;
  44 #include &quot;classfile/vmSymbols.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logStream.hpp&quot;
  47 #include &quot;memory/allocation.hpp&quot;
  48 #include &quot;memory/metadataFactory.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/annotations.hpp&quot;
  53 #include &quot;oops/constantPool.inline.hpp&quot;
<span class="line-modified">  54 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  55 #include &quot;oops/instanceKlass.hpp&quot;
  56 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  57 #include &quot;oops/klass.inline.hpp&quot;
  58 #include &quot;oops/klassVtable.hpp&quot;
  59 #include &quot;oops/metadata.hpp&quot;
  60 #include &quot;oops/method.inline.hpp&quot;
  61 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  62 #include &quot;oops/recordComponent.hpp&quot;</span>
  63 #include &quot;oops/symbol.hpp&quot;
  64 #include &quot;prims/jvmtiExport.hpp&quot;
  65 #include &quot;prims/jvmtiThreadState.hpp&quot;
  66 #include &quot;runtime/arguments.hpp&quot;
<span class="line-added">  67 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/javaCalls.hpp&quot;
  70 #include &quot;runtime/os.hpp&quot;
  71 #include &quot;runtime/perfData.hpp&quot;
  72 #include &quot;runtime/reflection.hpp&quot;
  73 #include &quot;runtime/safepointVerifiers.hpp&quot;
  74 #include &quot;runtime/signature.hpp&quot;
  75 #include &quot;runtime/timer.hpp&quot;
  76 #include &quot;services/classLoadingService.hpp&quot;
  77 #include &quot;services/threadService.hpp&quot;
  78 #include &quot;utilities/align.hpp&quot;
  79 #include &quot;utilities/bitMap.inline.hpp&quot;
  80 #include &quot;utilities/copy.hpp&quot;
  81 #include &quot;utilities/exceptions.hpp&quot;
  82 #include &quot;utilities/globalDefinitions.hpp&quot;
  83 #include &quot;utilities/growableArray.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/ostream.hpp&quot;
  86 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  87 #include &quot;utilities/utf8.hpp&quot;</span>
<span class="line-added">  88 </span>
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
 107 // Used for two backward compatibility reasons:
 108 // - to check for new additions to the class file format in JDK1.5
</pre>
<hr />
<pre>
 114 // - also used as the max version when running in jdk6
 115 #define JAVA_6_VERSION                    50
 116 
 117 // Used for backward compatibility reasons:
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
<span class="line-added"> 134 #define JAVA_14_VERSION                   58</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136 #define JAVA_15_VERSION                   59</span>
<span class="line-added"> 137 </span>
 138 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
<span class="line-modified"> 139   assert((bad_constant == JVM_CONSTANT_Module ||</span>
<span class="line-added"> 140           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,</span>
 141          &quot;Unexpected bad constant pool entry&quot;);
 142   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 143 }
 144 
 145 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 146                                                   ConstantPool* cp,
 147                                                   const int length,
 148                                                   TRAPS) {
 149   assert(stream != NULL, &quot;invariant&quot;);
 150   assert(cp != NULL, &quot;invariant&quot;);
 151 
 152   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 153   // this function (_current can be allocated in a register, with scalar
 154   // replacement of aggregates). The _current pointer is copied back to
 155   // stream() when this function returns. DON&#39;T call another method within
 156   // this method that uses stream().
 157   const ClassFileStream cfs1 = *stream;
 158   const ClassFileStream* const cfs = &amp;cfs1;
 159 
 160   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
</pre>
<hr />
<pre>
 309         const u1* utf8_buffer = cfs-&gt;current();
 310         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 311         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 312         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 313         cfs-&gt;skip_u1_fast(utf8_length);
 314 
 315         // Before storing the symbol, make sure it&#39;s legal
 316         if (_need_verify) {
 317           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 318         }
 319 
 320         if (has_cp_patch_at(index)) {
 321           Handle patch = clear_cp_patch_at(index);
 322           guarantee_property(java_lang_String::is_instance(patch()),
 323                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 324                              index,
 325                              CHECK);
 326           const char* const str = java_lang_String::as_utf8_string(patch());
 327           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 328           utf8_buffer = (const u1*) str;
<span class="line-modified"> 329           utf8_length = (u2) strlen(str);</span>
 330         }
 331 
 332         unsigned int hash;
 333         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 334                                                         utf8_length,
 335                                                         hash);
 336         if (result == NULL) {
 337           names[names_count] = (const char*)utf8_buffer;
 338           lengths[names_count] = utf8_length;
 339           indices[names_count] = index;
 340           hashValues[names_count++] = hash;
 341           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 342             SymbolTable::new_symbols(_loader_data,
<span class="line-modified"> 343                                      constantPoolHandle(THREAD, cp),</span>
 344                                      names_count,
 345                                      names,
 346                                      lengths,
 347                                      indices,
<span class="line-modified"> 348                                      hashValues);</span>

 349             names_count = 0;
 350           }
 351         } else {
 352           cp-&gt;symbol_at_put(index, result);
 353         }
 354         break;
 355       }
<span class="line-modified"> 356       case JVM_CONSTANT_Module:</span>
<span class="line-modified"> 357       case JVM_CONSTANT_Package: {</span>
 358         // Record that an error occurred in these two cases but keep parsing so
 359         // that ACC_Module can be checked for in the access_flags.  Need to
 360         // throw NoClassDefFoundError in that case.
 361         if (_major_version &gt;= JAVA_9_VERSION) {
 362           cfs-&gt;guarantee_more(3, CHECK);
 363           cfs-&gt;get_u2_fast();
 364           set_class_bad_constant_seen(tag);
 365           break;
 366         }
 367       }
 368       default: {
 369         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 370                               tag,
 371                               CHECK);
 372         break;
 373       }
 374     } // end of switch(tag)
 375   } // end of for
 376 
 377   // Allocate the remaining symbols
 378   if (names_count &gt; 0) {
 379     SymbolTable::new_symbols(_loader_data,
<span class="line-modified"> 380                              constantPoolHandle(THREAD, cp),</span>
 381                              names_count,
 382                              names,
 383                              lengths,
 384                              indices,
<span class="line-modified"> 385                              hashValues);</span>

 386   }
 387 
 388   // Copy _current pointer of local copy back to stream.
 389   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 390   stream-&gt;set_current(cfs1.current());
 391 
 392 }
 393 
 394 static inline bool valid_cp_range(int index, int length) {
 395   return (index &gt; 0 &amp;&amp; index &lt; length);
 396 }
 397 
 398 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 399   assert(cp != NULL, &quot;invariant&quot;);
 400   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 401     return cp-&gt;symbol_at(index);
 402   }
 403   return NULL;
 404 }
 405 
</pre>
<hr />
<pre>
 653     switch (tag) {
 654       case JVM_CONSTANT_UnresolvedClass: {
 655         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 656         // check the name, even if _cp_patches will overwrite it
 657         verify_legal_class_name(class_name, CHECK);
 658         break;
 659       }
 660       case JVM_CONSTANT_NameAndType: {
 661         if (_need_verify) {
 662           const int sig_index = cp-&gt;signature_ref_index_at(index);
 663           const int name_index = cp-&gt;name_ref_index_at(index);
 664           const Symbol* const name = cp-&gt;symbol_at(name_index);
 665           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 666           guarantee_property(sig-&gt;utf8_length() != 0,
 667             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 668             sig_index, CHECK);
 669           guarantee_property(name-&gt;utf8_length() != 0,
 670             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 671             name_index, CHECK);
 672 
<span class="line-modified"> 673           if (Signature::is_method(sig)) {</span>
 674             // Format check method name and signature
 675             verify_legal_method_name(name, CHECK);
 676             verify_legal_method_signature(name, sig, CHECK);
 677           } else {
 678             // Format check field name and signature
 679             verify_legal_field_name(name, CHECK);
 680             verify_legal_field_signature(name, sig, CHECK);
 681           }
 682         }
 683         break;
 684       }
 685       case JVM_CONSTANT_Dynamic: {
 686         const int name_and_type_ref_index =
 687           cp-&gt;name_and_type_ref_index_at(index);
 688         // already verified to be utf8
 689         const int name_ref_index =
 690           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 691         // already verified to be utf8
 692         const int signature_ref_index =
 693           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 694         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 695         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 696         if (_need_verify) {
 697           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
<span class="line-modified"> 698           // Need only to be sure signature is the right type.</span>
<span class="line-modified"> 699           if (Signature::is_method(signature)) {</span>

 700             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 701           }
 702         }
 703         break;
 704       }
 705       case JVM_CONSTANT_InvokeDynamic:
 706       case JVM_CONSTANT_Fieldref:
 707       case JVM_CONSTANT_Methodref:
 708       case JVM_CONSTANT_InterfaceMethodref: {
 709         const int name_and_type_ref_index =
 710           cp-&gt;name_and_type_ref_index_at(index);
 711         // already verified to be utf8
 712         const int name_ref_index =
 713           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 714         // already verified to be utf8
 715         const int signature_ref_index =
 716           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 717         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 718         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 719         if (tag == JVM_CONSTANT_Fieldref) {
 720           if (_need_verify) {
 721             // Field name and signature are verified above, when iterating NameAndType_info.
 722             // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified"> 723             if (Signature::is_method(signature)) {</span>

 724               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 725             }
 726           }
 727         } else {
 728           if (_need_verify) {
 729             // Method name and signature are verified above, when iterating NameAndType_info.
 730             // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified"> 731             if (!Signature::is_method(signature)) {</span>

 732               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 733             }
 734           }
 735           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 736           const unsigned int name_len = name-&gt;utf8_length();
 737           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 738               name_len != 0 &amp;&amp;
<span class="line-modified"> 739               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;</span>
 740               name != vmSymbols::object_initializer_name()) {
 741             classfile_parse_error(
 742               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 743               name_ref_index, CHECK);
 744           }
 745         }
 746         break;
 747       }
 748       case JVM_CONSTANT_MethodHandle: {
 749         const int ref_index = cp-&gt;method_handle_index_at(index);
 750         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 751         switch (ref_kind) {
 752           case JVM_REF_invokeVirtual:
 753           case JVM_REF_invokeStatic:
 754           case JVM_REF_invokeSpecial:
 755           case JVM_REF_newInvokeSpecial: {
 756             const int name_and_type_ref_index =
 757               cp-&gt;name_and_type_ref_index_at(ref_index);
 758             const int name_ref_index =
 759               cp-&gt;name_ref_index_at(name_and_type_ref_index);
</pre>
<hr />
<pre>
 811                                           TRAPS) {
 812   assert(cp != NULL, &quot;invariant&quot;);
 813 
 814   BasicType patch_type = T_VOID;
 815 
 816   switch (cp-&gt;tag_at(index).value()) {
 817 
 818     case JVM_CONSTANT_UnresolvedClass: {
 819       // Patching a class means pre-resolving it.
 820       // The name in the constant pool is ignored.
 821       if (java_lang_Class::is_instance(patch())) {
 822         guarantee_property(!java_lang_Class::is_primitive(patch()),
 823                            &quot;Illegal class patch at %d in class file %s&quot;,
 824                            index, CHECK);
 825         Klass* k = java_lang_Class::as_Klass(patch());
 826         patch_class(cp, index, k, k-&gt;name());
 827       } else {
 828         guarantee_property(java_lang_String::is_instance(patch()),
 829                            &quot;Illegal class patch at %d in class file %s&quot;,
 830                            index, CHECK);
<span class="line-modified"> 831         Symbol* const name = java_lang_String::as_symbol(patch());</span>
 832         patch_class(cp, index, NULL, name);
 833       }
 834       break;
 835     }
 836 
 837     case JVM_CONSTANT_String: {
 838       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 839       // references to be created first.
 840       return;
 841     }
 842     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 843     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 844     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 845     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 846     patch_prim:
 847     {
 848       jvalue value;
 849       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 850       guarantee_property(value_type == patch_type,
 851                          &quot;Illegal primitive patch at %d in class file %s&quot;,
</pre>
<hr />
<pre>
1687 
1688     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1689     field-&gt;initialize(access_flags.as_short(),
1690                       name_index,
1691                       signature_index,
1692                       constantvalue_index);
1693     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1694 
1695     // Remember how many oops we encountered and compute allocation type
1696     const FieldAllocationType atype = fac-&gt;update(is_static, type);
1697     field-&gt;set_allocation_type(atype);
1698 
1699     TSAN_RUNTIME_ONLY(
1700       if (ThreadSanitizerIgnoreFile != NULL &amp;&amp;
1701           TsanIgnoreList::match(_class_name, name, type)) {
1702         parsed_annotations.set_tsan_ignore(true);
1703       }
1704     );
1705 
1706     // After field is initialized with type, we can augment it with aux info
<span class="line-modified">1707     if (parsed_annotations.has_any_annotations()) {</span>
1708       parsed_annotations.apply_to(field);
<span class="line-added">1709       if (field-&gt;is_contended()) {</span>
<span class="line-added">1710         _has_contended_fields = true;</span>
<span class="line-added">1711       }</span>
<span class="line-added">1712     }</span>
1713   }
1714 
1715   int index = length;
1716   if (num_injected != 0) {
1717     for (int n = 0; n &lt; num_injected; n++) {
1718       // Check for duplicates
1719       if (injected[n].may_be_java) {
1720         const Symbol* const name      = injected[n].name();
1721         const Symbol* const signature = injected[n].signature();
1722         bool duplicate = false;
1723         for (int i = 0; i &lt; length; i++) {
1724           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1725           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1726               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1727             // Symbol is desclared in Java so skip this one
1728             duplicate = true;
1729             break;
1730           }
1731         }
1732         if (duplicate) {
1733           // These will be removed from the field array at the end
1734           continue;
1735         }
1736       }
1737 
1738       // Injected field
1739       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1740       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1741                         injected[n].name_index,
1742                         injected[n].signature_index,
1743                         0);
1744 
<span class="line-modified">1745       const BasicType type = Signature::basic_type(injected[n].signature());</span>
1746 
1747       // Remember how many oops we encountered and compute allocation type
1748       const FieldAllocationType atype = fac-&gt;update(false, type);
1749       field-&gt;set_allocation_type(atype);
1750       index++;
1751     }
1752   }
1753 
1754   assert(NULL == _fields, &quot;invariant&quot;);
1755 
1756   _fields =
1757     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1758                                    index * FieldInfo::field_slots + num_generic_signature,
1759                                    CHECK);
1760   // Sometimes injected fields already exist in the Java source so
1761   // the fields array could be too long.  In that case the
1762   // fields array is trimed. Also unused slots that were reserved
1763   // for generic signature indexes are discarded.
1764   {
1765     int i = 0;
</pre>
<hr />
<pre>
2466       valid_symbol_at(method_attribute_name_index),
2467       &quot;Invalid method attribute name index %u in class file %s&quot;,
2468       method_attribute_name_index, CHECK_NULL);
2469 
2470     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2471     if (method_attribute_name == vmSymbols::tag_code()) {
2472       // Parse Code attribute
2473       if (_need_verify) {
2474         guarantee_property(
2475             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2476                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2477                          CHECK_NULL);
2478       }
2479       if (parsed_code_attribute) {
2480         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2481                               CHECK_NULL);
2482       }
2483       parsed_code_attribute = true;
2484 
2485       // Stack size, locals size, and code size
<span class="line-modified">2486       cfs-&gt;guarantee_more(8, CHECK_NULL);</span>
<span class="line-modified">2487       max_stack = cfs-&gt;get_u2_fast();</span>
<span class="line-modified">2488       max_locals = cfs-&gt;get_u2_fast();</span>
<span class="line-modified">2489       code_length = cfs-&gt;get_u4_fast();</span>







2490       if (_need_verify) {
2491         guarantee_property(args_size &lt;= max_locals,
2492                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2493                            CHECK_NULL);
2494         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2495                            &quot;Invalid method Code length %u in class file %s&quot;,
2496                            code_length, CHECK_NULL);
2497       }
2498       // Code pointer
2499       code_start = cfs-&gt;current();
2500       assert(code_start != NULL, &quot;null code start&quot;);
2501       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2502       cfs-&gt;skip_u1_fast(code_length);
2503 
2504       // Exception handler table
2505       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2506       exception_table_length = cfs-&gt;get_u2_fast();
2507       if (exception_table_length &gt; 0) {
2508         exception_table_start = parse_exception_table(cfs,
2509                                                       code_length,
2510                                                       exception_table_length,
2511                                                       CHECK_NULL);
2512       }
2513 
2514       // Parse additional attributes in code attribute
2515       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2516       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2517 
2518       unsigned int calculated_attribute_length = 0;
2519 
<span class="line-modified">2520       calculated_attribute_length =</span>
<span class="line-modified">2521           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);</span>





2522       calculated_attribute_length +=
2523         code_length +
2524         sizeof(exception_table_length) +
2525         sizeof(code_attributes_count) +
2526         exception_table_length *
2527             ( sizeof(u2) +   // start_pc
2528               sizeof(u2) +   // end_pc
2529               sizeof(u2) +   // handler_pc
2530               sizeof(u2) );  // catch_type_index
2531 
2532       while (code_attributes_count--) {
2533         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2534         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2535         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2536         calculated_attribute_length += code_attribute_length +
2537                                        sizeof(code_attribute_name_index) +
2538                                        sizeof(code_attribute_length);
2539         check_property(valid_symbol_at(code_attribute_name_index),
2540                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2541                        code_attribute_name_index,
</pre>
<hr />
<pre>
2811       runtime_visible_parameter_annotations_length +
2812            runtime_invisible_parameter_annotations_length,
2813       runtime_visible_type_annotations_length +
2814            runtime_invisible_type_annotations_length,
2815       annotation_default_length,
2816       0);
2817 
2818   Method* const m = Method::allocate(_loader_data,
2819                                      code_length,
2820                                      access_flags,
2821                                      &amp;sizes,
2822                                      ConstMethod::NORMAL,
2823                                      CHECK_NULL);
2824 
2825   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2826 
2827   // Fill in information from fixed part (access_flags already set)
2828   m-&gt;set_constants(_cp);
2829   m-&gt;set_name_index(name_index);
2830   m-&gt;set_signature_index(signature_index);
<span class="line-modified">2831   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));</span>
<span class="line-modified">2832   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);</span>













2833 
2834   // Fill in code attribute information
2835   m-&gt;set_max_stack(max_stack);
2836   m-&gt;set_max_locals(max_locals);
2837   if (stackmap_data != NULL) {
2838     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2839                                          (u1*)stackmap_data,
2840                                          stackmap_data_length,
2841                                          CHECK_NULL);
2842   }
2843 
2844   // Copy byte codes
2845   m-&gt;set_code((u1*)code_start);
2846 
2847   // Copy line number table
2848   if (linenumber_table != NULL) {
2849     memcpy(m-&gt;compressed_linenumber_table(),
2850            linenumber_table-&gt;buffer(),
2851            linenumber_table_length);
2852   }
</pre>
<hr />
<pre>
2875     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2876                                                 m-&gt;checked_exceptions_start(),
2877                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2878                                                 sizeof(u2));
2879   }
2880 
2881   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2882   if (total_lvt_length &gt; 0) {
2883     promoted_flags-&gt;set_has_localvariable_table();
2884     copy_localvariable_table(m-&gt;constMethod(),
2885                              lvt_cnt,
2886                              localvariable_table_length,
2887                              localvariable_table_start,
2888                              lvtt_cnt,
2889                              localvariable_type_table_length,
2890                              localvariable_type_table_start,
2891                              CHECK_NULL);
2892   }
2893 
2894   if (parsed_annotations.has_any_annotations())
<span class="line-modified">2895     parsed_annotations.apply_to(methodHandle(THREAD, m));</span>
2896 
2897   // Copy annotations
2898   copy_method_annotations(m-&gt;constMethod(),
2899                           runtime_visible_annotations,
2900                           runtime_visible_annotations_length,
2901                           runtime_invisible_annotations,
2902                           runtime_invisible_annotations_length,
2903                           runtime_visible_parameter_annotations,
2904                           runtime_visible_parameter_annotations_length,
2905                           runtime_invisible_parameter_annotations,
2906                           runtime_invisible_parameter_annotations_length,
2907                           runtime_visible_type_annotations,
2908                           runtime_visible_type_annotations_length,
2909                           runtime_invisible_type_annotations,
2910                           runtime_invisible_type_annotations_length,
2911                           annotation_default,
2912                           annotation_default_length,
2913                           CHECK_NULL);
2914 
2915   if (name == vmSymbols::finalize_method_name() &amp;&amp;
</pre>
<hr />
<pre>
2997             dup = true;
2998             break;
2999           }
3000         }
3001       }
3002       if (dup) {
3003         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
3004                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
3005       }
3006     }
3007   }
3008 }
3009 
3010 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
3011   const int length = methods-&gt;length();
3012   // If JVMTI original method ordering or sharing is enabled we have to
3013   // remember the original class file ordering.
3014   // We temporarily use the vtable_index field in the Method* to store the
3015   // class file index, so we can read in after calling qsort.
3016   // Put the method ordering in the shared archive.
<span class="line-modified">3017   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
3018     for (int index = 0; index &lt; length; index++) {
3019       Method* const m = methods-&gt;at(index);
3020       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3021       m-&gt;set_vtable_index(index);
3022     }
3023   }
3024   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3025   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3026   Method::sort_methods(methods);
3027 
3028   intArray* method_ordering = NULL;
3029   // If JVMTI original method ordering or sharing is enabled construct int
3030   // array remembering the original ordering
<span class="line-modified">3031   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
3032     method_ordering = new intArray(length, length, -1);
3033     for (int index = 0; index &lt; length; index++) {
3034       Method* const m = methods-&gt;at(index);
3035       const int old_index = m-&gt;vtable_index();
3036       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3037       method_ordering-&gt;at_put(index, old_index);
3038       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3039     }
3040   }
3041   return method_ordering;
3042 }
3043 
3044 // Parse generic_signature attribute for methods and fields
3045 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3046                                                       TRAPS) {
3047   assert(cfs != NULL, &quot;invariant&quot;);
3048 
3049   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3050   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3051   check_property(
</pre>
<hr />
<pre>
3216   _nest_members = nest_members;
3217 
3218   int index = 0;
3219   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3220   for (int n = 0; n &lt; length; n++) {
3221     const u2 class_info_index = cfs-&gt;get_u2_fast();
3222     check_property(
3223       valid_klass_reference_at(class_info_index),
3224       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3225       class_info_index, CHECK_0);
3226     nest_members-&gt;at_put(index++, class_info_index);
3227   }
3228   assert(index == size, &quot;wrong size&quot;);
3229 
3230   // Restore buffer&#39;s current position.
3231   cfs-&gt;set_current(current_mark);
3232 
3233   return length;
3234 }
3235 
<span class="line-added">3236 //  Record {</span>
<span class="line-added">3237 //    u2 attribute_name_index;</span>
<span class="line-added">3238 //    u4 attribute_length;</span>
<span class="line-added">3239 //    u2 components_count;</span>
<span class="line-added">3240 //    component_info components[components_count];</span>
<span class="line-added">3241 //  }</span>
<span class="line-added">3242 //  component_info {</span>
<span class="line-added">3243 //    u2 name_index;</span>
<span class="line-added">3244 //    u2 descriptor_index</span>
<span class="line-added">3245 //    u2 attributes_count;</span>
<span class="line-added">3246 //    attribute_info_attributes[attributes_count];</span>
<span class="line-added">3247 //  }</span>
<span class="line-added">3248 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,</span>
<span class="line-added">3249                                                      const ConstantPool* cp,</span>
<span class="line-added">3250                                                      const u1* const record_attribute_start,</span>
<span class="line-added">3251                                                      TRAPS) {</span>
<span class="line-added">3252   const u1* const current_mark = cfs-&gt;current();</span>
<span class="line-added">3253   int components_count = 0;</span>
<span class="line-added">3254   unsigned int calculate_attr_size = 0;</span>
<span class="line-added">3255   if (record_attribute_start != NULL) {</span>
<span class="line-added">3256     cfs-&gt;set_current(record_attribute_start);</span>
<span class="line-added">3257     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components</span>
<span class="line-added">3258     components_count = (int)cfs-&gt;get_u2_fast();</span>
<span class="line-added">3259     calculate_attr_size = 2;</span>
<span class="line-added">3260   }</span>
<span class="line-added">3261 </span>
<span class="line-added">3262   Array&lt;RecordComponent*&gt;* const record_components =</span>
<span class="line-added">3263     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);</span>
<span class="line-added">3264   _record_components = record_components;</span>
<span class="line-added">3265 </span>
<span class="line-added">3266   for (int x = 0; x &lt; components_count; x++) {</span>
<span class="line-added">3267     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count</span>
<span class="line-added">3268 </span>
<span class="line-added">3269     const u2 name_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3270     check_property(valid_symbol_at(name_index),</span>
<span class="line-added">3271       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,</span>
<span class="line-added">3272       name_index, CHECK_0);</span>
<span class="line-added">3273     const Symbol* const name = cp-&gt;symbol_at(name_index);</span>
<span class="line-added">3274     verify_legal_field_name(name, CHECK_0);</span>
<span class="line-added">3275 </span>
<span class="line-added">3276     const u2 descriptor_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3277     check_property(valid_symbol_at(descriptor_index),</span>
<span class="line-added">3278       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,</span>
<span class="line-added">3279       descriptor_index, CHECK_0);</span>
<span class="line-added">3280     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);</span>
<span class="line-added">3281     verify_legal_field_signature(name, descr, CHECK_0);</span>
<span class="line-added">3282 </span>
<span class="line-added">3283     const u2 attributes_count = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3284     calculate_attr_size += 6;</span>
<span class="line-added">3285     u2 generic_sig_index = 0;</span>
<span class="line-added">3286     const u1* runtime_visible_annotations = NULL;</span>
<span class="line-added">3287     int runtime_visible_annotations_length = 0;</span>
<span class="line-added">3288     const u1* runtime_invisible_annotations = NULL;</span>
<span class="line-added">3289     int runtime_invisible_annotations_length = 0;</span>
<span class="line-added">3290     bool runtime_invisible_annotations_exists = false;</span>
<span class="line-added">3291     const u1* runtime_visible_type_annotations = NULL;</span>
<span class="line-added">3292     int runtime_visible_type_annotations_length = 0;</span>
<span class="line-added">3293     const u1* runtime_invisible_type_annotations = NULL;</span>
<span class="line-added">3294     int runtime_invisible_type_annotations_length = 0;</span>
<span class="line-added">3295     bool runtime_invisible_type_annotations_exists = false;</span>
<span class="line-added">3296 </span>
<span class="line-added">3297     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,</span>
<span class="line-added">3298     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.</span>
<span class="line-added">3299     for (int y = 0; y &lt; attributes_count; y++) {</span>
<span class="line-added">3300       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length</span>
<span class="line-added">3301       const u2 attribute_name_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3302       const u4 attribute_length = cfs-&gt;get_u4_fast();</span>
<span class="line-added">3303       calculate_attr_size += 6;</span>
<span class="line-added">3304       check_property(</span>
<span class="line-added">3305         valid_symbol_at(attribute_name_index),</span>
<span class="line-added">3306         &quot;Invalid Record attribute name index %u in class file %s&quot;,</span>
<span class="line-added">3307         attribute_name_index, CHECK_0);</span>
<span class="line-added">3308 </span>
<span class="line-added">3309       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);</span>
<span class="line-added">3310       if (attribute_name == vmSymbols::tag_signature()) {</span>
<span class="line-added">3311         if (generic_sig_index != 0) {</span>
<span class="line-added">3312           classfile_parse_error(</span>
<span class="line-added">3313             &quot;Multiple Signature attributes for Record component in class file %s&quot;,</span>
<span class="line-added">3314             CHECK_0);</span>
<span class="line-added">3315         }</span>
<span class="line-added">3316         if (attribute_length != 2) {</span>
<span class="line-added">3317           classfile_parse_error(</span>
<span class="line-added">3318             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,</span>
<span class="line-added">3319             attribute_length, CHECK_0);</span>
<span class="line-added">3320         }</span>
<span class="line-added">3321         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);</span>
<span class="line-added">3322 </span>
<span class="line-added">3323       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {</span>
<span class="line-added">3324         if (runtime_visible_annotations != NULL) {</span>
<span class="line-added">3325           classfile_parse_error(</span>
<span class="line-added">3326             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3327         }</span>
<span class="line-added">3328         runtime_visible_annotations_length = attribute_length;</span>
<span class="line-added">3329         runtime_visible_annotations = cfs-&gt;current();</span>
<span class="line-added">3330 </span>
<span class="line-added">3331         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);</span>
<span class="line-added">3332         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);</span>
<span class="line-added">3333         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);</span>
<span class="line-added">3334 </span>
<span class="line-added">3335       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {</span>
<span class="line-added">3336         if (runtime_invisible_annotations_exists) {</span>
<span class="line-added">3337           classfile_parse_error(</span>
<span class="line-added">3338             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3339         }</span>
<span class="line-added">3340         runtime_invisible_annotations_exists = true;</span>
<span class="line-added">3341         if (PreserveAllAnnotations) {</span>
<span class="line-added">3342           runtime_invisible_annotations_length = attribute_length;</span>
<span class="line-added">3343           runtime_invisible_annotations = cfs-&gt;current();</span>
<span class="line-added">3344           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);</span>
<span class="line-added">3345         }</span>
<span class="line-added">3346         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">3347 </span>
<span class="line-added">3348       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {</span>
<span class="line-added">3349         if (runtime_visible_type_annotations != NULL) {</span>
<span class="line-added">3350           classfile_parse_error(</span>
<span class="line-added">3351             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3352         }</span>
<span class="line-added">3353         runtime_visible_type_annotations_length = attribute_length;</span>
<span class="line-added">3354         runtime_visible_type_annotations = cfs-&gt;current();</span>
<span class="line-added">3355 </span>
<span class="line-added">3356         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);</span>
<span class="line-added">3357         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);</span>
<span class="line-added">3358         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);</span>
<span class="line-added">3359 </span>
<span class="line-added">3360       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {</span>
<span class="line-added">3361         if (runtime_invisible_type_annotations_exists) {</span>
<span class="line-added">3362           classfile_parse_error(</span>
<span class="line-added">3363             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3364         }</span>
<span class="line-added">3365         runtime_invisible_type_annotations_exists = true;</span>
<span class="line-added">3366         if (PreserveAllAnnotations) {</span>
<span class="line-added">3367           runtime_invisible_type_annotations_length = attribute_length;</span>
<span class="line-added">3368           runtime_invisible_type_annotations = cfs-&gt;current();</span>
<span class="line-added">3369           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);</span>
<span class="line-added">3370         }</span>
<span class="line-added">3371         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">3372 </span>
<span class="line-added">3373       } else {</span>
<span class="line-added">3374         // Skip unknown attributes</span>
<span class="line-added">3375         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">3376       }</span>
<span class="line-added">3377       calculate_attr_size += attribute_length;</span>
<span class="line-added">3378     } // End of attributes For loop</span>
<span class="line-added">3379 </span>
<span class="line-added">3380     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-added">3381                                                         runtime_visible_annotations_length,</span>
<span class="line-added">3382                                                         runtime_invisible_annotations,</span>
<span class="line-added">3383                                                         runtime_invisible_annotations_length,</span>
<span class="line-added">3384                                                         CHECK_0);</span>
<span class="line-added">3385     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-added">3386                                                              runtime_visible_type_annotations_length,</span>
<span class="line-added">3387                                                              runtime_invisible_type_annotations,</span>
<span class="line-added">3388                                                              runtime_invisible_type_annotations_length,</span>
<span class="line-added">3389                                                              CHECK_0);</span>
<span class="line-added">3390 </span>
<span class="line-added">3391     RecordComponent* record_component =</span>
<span class="line-added">3392       RecordComponent::allocate(_loader_data, name_index, descriptor_index,</span>
<span class="line-added">3393                                 attributes_count, generic_sig_index,</span>
<span class="line-added">3394                                 annotations, type_annotations, CHECK_0);</span>
<span class="line-added">3395     record_components-&gt;at_put(x, record_component);</span>
<span class="line-added">3396   }  // End of component processing loop</span>
<span class="line-added">3397 </span>
<span class="line-added">3398   // Restore buffer&#39;s current position.</span>
<span class="line-added">3399   cfs-&gt;set_current(current_mark);</span>
<span class="line-added">3400   return calculate_attr_size;</span>
<span class="line-added">3401 }</span>
<span class="line-added">3402 </span>
3403 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3404   set_class_synthetic_flag(true);
3405 }
3406 
3407 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3408   assert(cfs != NULL, &quot;invariant&quot;);
3409 
3410   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3411   check_property(
3412     valid_symbol_at(signature_index),
3413     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3414     signature_index, CHECK);
3415   set_class_generic_signature_index(signature_index);
3416 }
3417 
3418 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3419                                                                   ConstantPool* cp,
3420                                                                   u4 attribute_byte_length,
3421                                                                   TRAPS) {
3422   assert(cfs != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
3480     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3481     operands-&gt;at_put(operand_fill_index++, argument_count);
3482 
3483     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3484     for (int j = 0; j &lt; argument_count; j++) {
3485       const u2 argument_index = cfs-&gt;get_u2_fast();
3486       check_property(
3487         valid_cp_range(argument_index, cp_size) &amp;&amp;
3488         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3489         &quot;argument_index %u has bad constant type in class file %s&quot;,
3490         argument_index,
3491         CHECK);
3492       operands-&gt;at_put(operand_fill_index++, argument_index);
3493     }
3494   }
3495   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3496                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3497                      CHECK);
3498 }
3499 
<span class="line-added">3500 bool ClassFileParser::supports_records() {</span>
<span class="line-added">3501   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
<span class="line-added">3502     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-added">3503     Arguments::enable_preview();</span>
<span class="line-added">3504 }</span>
<span class="line-added">3505 </span>
3506 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3507                                                  ConstantPool* cp,
3508                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3509                                                  TRAPS) {
3510   assert(cfs != NULL, &quot;invariant&quot;);
3511   assert(cp != NULL, &quot;invariant&quot;);
3512   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3513 
3514   // Set inner classes attribute to default sentinel
3515   _inner_classes = Universe::the_empty_short_array();
3516   // Set nest members attribute to default sentinel
3517   _nest_members = Universe::the_empty_short_array();
3518   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3519   u2 attributes_count = cfs-&gt;get_u2_fast();
3520   bool parsed_sourcefile_attribute = false;
3521   bool parsed_innerclasses_attribute = false;
3522   bool parsed_nest_members_attribute = false;
3523   bool parsed_nest_host_attribute = false;
<span class="line-added">3524   bool parsed_record_attribute = false;</span>
3525   bool parsed_enclosingmethod_attribute = false;
3526   bool parsed_bootstrap_methods_attribute = false;
3527   const u1* runtime_visible_annotations = NULL;
3528   int runtime_visible_annotations_length = 0;
3529   const u1* runtime_invisible_annotations = NULL;
3530   int runtime_invisible_annotations_length = 0;
3531   const u1* runtime_visible_type_annotations = NULL;
3532   int runtime_visible_type_annotations_length = 0;
3533   const u1* runtime_invisible_type_annotations = NULL;
3534   int runtime_invisible_type_annotations_length = 0;
3535   bool runtime_invisible_type_annotations_exists = false;
3536   bool runtime_invisible_annotations_exists = false;
3537   bool parsed_source_debug_ext_annotations_exist = false;
3538   const u1* inner_classes_attribute_start = NULL;
3539   u4  inner_classes_attribute_length = 0;
3540   u2  enclosing_method_class_index = 0;
3541   u2  enclosing_method_method_index = 0;
3542   const u1* nest_members_attribute_start = NULL;
3543   u4  nest_members_attribute_length = 0;
<span class="line-added">3544   const u1* record_attribute_start = NULL;</span>
<span class="line-added">3545   u4  record_attribute_length = 0;</span>
3546 
3547   // Iterate over attributes
3548   while (attributes_count--) {
3549     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3550     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3551     const u4 attribute_length = cfs-&gt;get_u4_fast();
3552     check_property(
3553       valid_symbol_at(attribute_name_index),
3554       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3555       attribute_name_index, CHECK);
3556     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3557     if (tag == vmSymbols::tag_source_file()) {
3558       // Check for SourceFile tag
3559       if (_need_verify) {
3560         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3561       }
3562       if (parsed_sourcefile_attribute) {
3563         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3564       } else {
3565         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3708           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3709         } else if (tag == vmSymbols::tag_nest_host()) {
3710           if (parsed_nest_host_attribute) {
3711             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3712           } else {
3713             parsed_nest_host_attribute = true;
3714           }
3715           if (parsed_nest_members_attribute) {
3716             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3717           }
3718           if (_need_verify) {
3719             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3720           }
3721           cfs-&gt;guarantee_more(2, CHECK);
3722           u2 class_info_index = cfs-&gt;get_u2_fast();
3723           check_property(
3724                          valid_klass_reference_at(class_info_index),
3725                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3726                          class_info_index, CHECK);
3727           _nest_host = class_info_index;
<span class="line-added">3728         } else if (_major_version &gt;= JAVA_14_VERSION) {</span>
<span class="line-added">3729           if (tag == vmSymbols::tag_record()) {</span>
<span class="line-added">3730             // Skip over Record attribute if not supported or if super class is</span>
<span class="line-added">3731             // not java.lang.Record.</span>
<span class="line-added">3732             if (supports_records() &amp;&amp;</span>
<span class="line-added">3733                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {</span>
<span class="line-added">3734               if (parsed_record_attribute) {</span>
<span class="line-added">3735                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);</span>
<span class="line-added">3736               }</span>
<span class="line-added">3737               // Check that class is final and not abstract.</span>
<span class="line-added">3738               if (!_access_flags.is_final() || _access_flags.is_abstract()) {</span>
<span class="line-added">3739                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);</span>
<span class="line-added">3740               }</span>
<span class="line-added">3741               parsed_record_attribute = true;</span>
<span class="line-added">3742               record_attribute_start = cfs-&gt;current();</span>
<span class="line-added">3743               record_attribute_length = attribute_length;</span>
<span class="line-added">3744             } else if (log_is_enabled(Info, class, record)) {</span>
<span class="line-added">3745               // Log why the Record attribute was ignored.  Note that if the</span>
<span class="line-added">3746               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and</span>
<span class="line-added">3747               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError</span>
<span class="line-added">3748               // exception would have been thrown.</span>
<span class="line-added">3749               ResourceMark rm(THREAD);</span>
<span class="line-added">3750               if (supports_records()) {</span>
<span class="line-added">3751                 log_info(class, record)(</span>
<span class="line-added">3752                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,</span>
<span class="line-added">3753                   _class_name-&gt;as_C_string());</span>
<span class="line-added">3754               } else {</span>
<span class="line-added">3755                 log_info(class, record)(</span>
<span class="line-added">3756                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,</span>
<span class="line-added">3757                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-added">3758               }</span>
<span class="line-added">3759             }</span>
<span class="line-added">3760             cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3761           } else {</span>
<span class="line-added">3762             // Unknown attribute</span>
<span class="line-added">3763             cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3764           }</span>
3765         } else {
3766           // Unknown attribute
3767           cfs-&gt;skip_u1(attribute_length, CHECK);
3768         }
3769       } else {
3770         // Unknown attribute
3771         cfs-&gt;skip_u1(attribute_length, CHECK);
3772       }
3773     } else {
3774       // Unknown attribute
3775       cfs-&gt;skip_u1(attribute_length, CHECK);
3776     }
3777   }
<span class="line-modified">3778   _class_annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-modified">3779                                             runtime_visible_annotations_length,</span>
<span class="line-modified">3780                                             runtime_invisible_annotations,</span>
<span class="line-modified">3781                                             runtime_invisible_annotations_length,</span>
<span class="line-modified">3782                                             CHECK);</span>
<span class="line-modified">3783   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-modified">3784                                                  runtime_visible_type_annotations_length,</span>
<span class="line-modified">3785                                                  runtime_invisible_type_annotations,</span>
<span class="line-modified">3786                                                  runtime_invisible_type_annotations_length,</span>
<span class="line-modified">3787                                                  CHECK);</span>
3788 
3789   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3790     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3791                             cfs,
3792                             inner_classes_attribute_start,
3793                             parsed_innerclasses_attribute,
3794                             enclosing_method_class_index,
3795                             enclosing_method_method_index,
3796                             CHECK);
3797     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3798       guarantee_property(
3799         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3800         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3801     }
3802   }
3803 
3804   if (parsed_nest_members_attribute) {
3805     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3806                             cfs,
3807                             nest_members_attribute_start,
3808                             CHECK);
3809     if (_need_verify) {
3810       guarantee_property(
3811         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3812         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3813     }
3814   }
3815 
<span class="line-added">3816   if (parsed_record_attribute) {</span>
<span class="line-added">3817     const unsigned int calculated_attr_length = parse_classfile_record_attribute(</span>
<span class="line-added">3818                             cfs,</span>
<span class="line-added">3819                             cp,</span>
<span class="line-added">3820                             record_attribute_start,</span>
<span class="line-added">3821                             CHECK);</span>
<span class="line-added">3822     if (_need_verify) {</span>
<span class="line-added">3823       guarantee_property(record_attribute_length == calculated_attr_length,</span>
<span class="line-added">3824                          &quot;Record attribute has wrong length in class file %s&quot;,</span>
<span class="line-added">3825                          CHECK);</span>
<span class="line-added">3826     }</span>
<span class="line-added">3827   }</span>
<span class="line-added">3828 </span>
3829   if (_max_bootstrap_specifier_index &gt;= 0) {
3830     guarantee_property(parsed_bootstrap_methods_attribute,
3831                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3832   }
3833 }
3834 
3835 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3836   assert(k != NULL, &quot;invariant&quot;);
3837 
3838   if (_synthetic_flag)
3839     k-&gt;set_is_synthetic();
3840   if (_sourcefile_index != 0) {
3841     k-&gt;set_source_file_name_index(_sourcefile_index);
3842   }
3843   if (_generic_signature_index != 0) {
3844     k-&gt;set_generic_signature_index(_generic_signature_index);
3845   }
3846   if (_sde_buffer != NULL) {
3847     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3848   }
3849 }
3850 
3851 // Create the Annotations object that will
3852 // hold the annotations array for the Klass.
3853 void ClassFileParser::create_combined_annotations(TRAPS) {
<span class="line-modified">3854     if (_class_annotations == NULL &amp;&amp;</span>
<span class="line-modified">3855         _class_type_annotations == NULL &amp;&amp;</span>
3856         _fields_annotations == NULL &amp;&amp;
3857         _fields_type_annotations == NULL) {
3858       // Don&#39;t create the Annotations object unnecessarily.
3859       return;
3860     }
3861 
3862     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
<span class="line-modified">3863     annotations-&gt;set_class_annotations(_class_annotations);</span>
<span class="line-modified">3864     annotations-&gt;set_class_type_annotations(_class_type_annotations);</span>
3865     annotations-&gt;set_fields_annotations(_fields_annotations);
3866     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3867 
3868     // This is the Annotations object that will be
3869     // assigned to InstanceKlass being constructed.
3870     _combined_annotations = annotations;
3871 
3872     // The annotations arrays below has been transfered the
3873     // _combined_annotations so these fields can now be cleared.
<span class="line-modified">3874     _class_annotations       = NULL;</span>
<span class="line-modified">3875     _class_type_annotations  = NULL;</span>
3876     _fields_annotations      = NULL;
3877     _fields_type_annotations = NULL;
3878 }
3879 
3880 // Transfer ownership of metadata allocated to the InstanceKlass.
3881 void ClassFileParser::apply_parsed_class_metadata(
3882                                             InstanceKlass* this_klass,
<span class="line-modified">3883                                             int java_fields_count,</span>
<span class="line-added">3884                                             TRAPS) {</span>
3885   assert(this_klass != NULL, &quot;invariant&quot;);
3886 
3887   _cp-&gt;set_pool_holder(this_klass);
3888   this_klass-&gt;set_constants(_cp);
3889   this_klass-&gt;set_fields(_fields, java_fields_count);
3890   this_klass-&gt;set_methods(_methods);
3891   this_klass-&gt;set_inner_classes(_inner_classes);
3892   this_klass-&gt;set_nest_members(_nest_members);
3893   this_klass-&gt;set_nest_host_index(_nest_host);
3894   this_klass-&gt;set_local_interfaces(_local_interfaces);
3895   this_klass-&gt;set_annotations(_combined_annotations);
<span class="line-added">3896   this_klass-&gt;set_record_components(_record_components);</span>
3897   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3898   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3899   // its _super. If an OOM occurs while loading the current klass, its _super field
3900   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3901   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3902   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3903 
3904   // Clear out these fields so they don&#39;t get deallocated by the destructor
3905   clear_class_metadata();
3906 }
3907 
3908 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3909                                                        int runtime_visible_annotations_length,
3910                                                        const u1* const runtime_invisible_annotations,
3911                                                        int runtime_invisible_annotations_length,
3912                                                        TRAPS) {
3913   AnnotationArray* annotations = NULL;
3914   if (runtime_visible_annotations != NULL ||
3915       runtime_invisible_annotations != NULL) {
3916     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
</pre>
<hr />
<pre>
3950                    super_class_index,
3951                    CHECK_NULL);
3952     // The class name should be legal because it is checked when parsing constant pool.
3953     // However, make sure it is not an array type.
3954     bool is_array = false;
3955     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3956       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3957       if (need_verify)
3958         is_array = super_klass-&gt;is_array_klass();
3959     } else if (need_verify) {
3960       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3961     }
3962     if (need_verify) {
3963       guarantee_property(!is_array,
3964                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
3965     }
3966   }
3967   return super_klass;
3968 }
3969 

































3970 #ifndef PRODUCT
3971 static void print_field_layout(const Symbol* name,
3972                                Array&lt;u2&gt;* fields,
<span class="line-modified">3973                                ConstantPool* cp,</span>
3974                                int instance_size,
3975                                int instance_fields_start,
3976                                int instance_fields_end,
3977                                int static_fields_end) {
3978 
3979   assert(name != NULL, &quot;invariant&quot;);
3980 
3981   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
3982   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
3983   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3984     if (!fs.access_flags().is_static()) {
3985       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3986         fs.offset(),
3987         fs.name()-&gt;as_klass_external_name(),
3988         fs.signature()-&gt;as_klass_external_name());
3989     }
3990   }
3991   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
3992   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
3993   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
3994   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3995     if (fs.access_flags().is_static()) {
3996       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3997         fs.offset(),
3998         fs.name()-&gt;as_klass_external_name(),
3999         fs.signature()-&gt;as_klass_external_name());
4000     }
4001   }
4002   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4003   tty-&gt;print(&quot;\n&quot;);
4004 }
4005 #endif
4006 
<span class="line-modified">4007 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {</span>
<span class="line-modified">4008   _max_nonstatic_oop_maps = max_blocks;</span>
<span class="line-modified">4009   _nonstatic_oop_map_count = 0;</span>
<span class="line-modified">4010   if (max_blocks == 0) {</span>
<span class="line-modified">4011     _nonstatic_oop_maps = NULL;</span>
<span class="line-modified">4012   } else {</span>
<span class="line-modified">4013     _nonstatic_oop_maps =</span>
<span class="line-modified">4014         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);</span>
<span class="line-modified">4015     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);</span>
<span class="line-modified">4016   }</span>
<span class="line-modified">4017 }</span>
<span class="line-modified">4018 </span>
<span class="line-added">4019 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {</span>
<span class="line-added">4020   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);</span>
<span class="line-added">4021   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);</span>
<span class="line-added">4022 }</span>
<span class="line-added">4023 </span>
<span class="line-added">4024 // addition of super oop maps</span>
<span class="line-added">4025 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {</span>
<span class="line-added">4026   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;</span>
<span class="line-added">4027          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);</span>
<span class="line-added">4028 </span>
<span class="line-added">4029   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);</span>
<span class="line-added">4030   _nonstatic_oop_map_count += nof_blocks;</span>
<span class="line-added">4031 }</span>
<span class="line-added">4032 </span>
<span class="line-added">4033 // collection of oops</span>
<span class="line-added">4034 void OopMapBlocksBuilder::add(int offset, int count) {</span>
<span class="line-added">4035   if (_nonstatic_oop_map_count == 0) {</span>
<span class="line-added">4036     _nonstatic_oop_map_count++;</span>
<span class="line-added">4037   }</span>
<span class="line-added">4038   OopMapBlock* nonstatic_oop_map = last_oop_map();</span>
<span class="line-added">4039   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up</span>
<span class="line-added">4040     nonstatic_oop_map-&gt;set_offset(offset);</span>
<span class="line-added">4041     nonstatic_oop_map-&gt;set_count(count);</span>
<span class="line-added">4042   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add</span>
<span class="line-added">4043     nonstatic_oop_map-&gt;increment_count(count);</span>
<span class="line-added">4044   } else { // Need a new one...</span>
<span class="line-added">4045     _nonstatic_oop_map_count++;</span>
<span class="line-added">4046     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-added">4047     nonstatic_oop_map = last_oop_map();</span>
<span class="line-added">4048     nonstatic_oop_map-&gt;set_offset(offset);</span>
<span class="line-added">4049     nonstatic_oop_map-&gt;set_count(count);</span>
<span class="line-added">4050   }</span>
<span class="line-added">4051 }</span>
<span class="line-added">4052 </span>
<span class="line-added">4053 // general purpose copy, e.g. into allocated instanceKlass</span>
<span class="line-added">4054 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {</span>
<span class="line-added">4055   if (_nonstatic_oop_map_count != 0) {</span>
<span class="line-added">4056     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);</span>
<span class="line-added">4057   }</span>
<span class="line-added">4058 }</span>
<span class="line-added">4059 </span>
<span class="line-added">4060 // Sort and compact adjacent blocks</span>
<span class="line-added">4061 void OopMapBlocksBuilder::compact() {</span>
<span class="line-added">4062   if (_nonstatic_oop_map_count &lt;= 1) {</span>
<span class="line-added">4063     return;</span>
<span class="line-added">4064   }</span>
<span class="line-added">4065   /*</span>
<span class="line-added">4066    * Since field layout sneeks in oops before values, we will be able to condense</span>
<span class="line-added">4067    * blocks. There is potential to compact between super, own refs and values</span>
<span class="line-added">4068    * containing refs.</span>
<span class="line-added">4069    *</span>
<span class="line-added">4070    * Currently compaction is slightly limited due to values being 8 byte aligned.</span>
<span class="line-added">4071    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose</span>
<span class="line-added">4072    * and maybe it doesn&#39;t need to be.</span>
<span class="line-added">4073    */</span>
<span class="line-added">4074   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),</span>
<span class="line-added">4075         (_sort_Fn)OopMapBlock::compare_offset);</span>
<span class="line-added">4076   if (_nonstatic_oop_map_count &lt; 2) {</span>
<span class="line-added">4077     return;</span>
<span class="line-added">4078   }</span>
<span class="line-added">4079 </span>
<span class="line-added">4080   // Make a temp copy, and iterate through and copy back into the original</span>
<span class="line-added">4081   ResourceMark rm;</span>
<span class="line-added">4082   OopMapBlock* oop_maps_copy =</span>
<span class="line-added">4083       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);</span>
<span class="line-added">4084   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;</span>
<span class="line-added">4085   copy(oop_maps_copy);</span>
<span class="line-added">4086   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;</span>
<span class="line-added">4087   unsigned int new_count = 1;</span>
<span class="line-added">4088   oop_maps_copy++;</span>
<span class="line-added">4089   while(oop_maps_copy &lt; oop_maps_copy_end) {</span>
<span class="line-added">4090     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);</span>
<span class="line-added">4091     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {</span>
<span class="line-added">4092       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());</span>
<span class="line-added">4093     } else {</span>
<span class="line-added">4094       nonstatic_oop_map++;</span>
<span class="line-added">4095       new_count++;</span>
<span class="line-added">4096       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());</span>
<span class="line-added">4097       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());</span>
<span class="line-added">4098     }</span>
<span class="line-added">4099     oop_maps_copy++;</span>
<span class="line-added">4100   }</span>
<span class="line-added">4101   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);</span>
<span class="line-added">4102   _nonstatic_oop_map_count = new_count;</span>
<span class="line-added">4103 }</span>
<span class="line-added">4104 </span>
<span class="line-added">4105 void OopMapBlocksBuilder::print_on(outputStream* st) const {</span>
<span class="line-added">4106   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);</span>
<span class="line-added">4107   if (_nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-added">4108     OopMapBlock* map = _nonstatic_oop_maps;</span>
<span class="line-added">4109     OopMapBlock* last_map = last_oop_map();</span>
<span class="line-added">4110     assert(map &lt;= last_map, &quot;Last less than first&quot;);</span>
<span class="line-added">4111     while (map &lt;= last_map) {</span>
<span class="line-added">4112       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),</span>
<span class="line-added">4113                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());</span>
<span class="line-added">4114       map++;</span>
<span class="line-added">4115     }</span>
<span class="line-added">4116   }</span>
<span class="line-added">4117 }</span>
<span class="line-added">4118 </span>
<span class="line-added">4119 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {</span>
<span class="line-added">4120   print_on(st);</span>
<span class="line-added">4121 }</span>
4122 
4123 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4124 void ClassFileParser::layout_fields(ConstantPool* cp,
4125                                     const FieldAllocationCount* fac,
4126                                     const ClassAnnotationCollector* parsed_annotations,
4127                                     FieldLayoutInfo* info,
4128                                     TRAPS) {
4129 
4130   assert(cp != NULL, &quot;invariant&quot;);
4131 
4132   // Field size and offset computation
4133   int nonstatic_field_size = _super_klass == NULL ? 0 :
4134                                _super_klass-&gt;nonstatic_field_size();
4135 
4136   // Count the contended fields by type.
4137   //
4138   // We ignore static fields, because @Contended is not supported for them.
4139   // The layout code below will also ignore the static fields.
4140   int nonstatic_contended_count = 0;
4141   FieldAllocationCount fac_contended;
</pre>
<hr />
<pre>
4188   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4189 
4190   // Total non-static fields count, including every contended field
4191   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4192                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4193                                         fac-&gt;count[NONSTATIC_OOP];
4194 
4195   const bool super_has_nonstatic_fields =
4196           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4197   const bool has_nonstatic_fields =
4198     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4199 
4200 
4201   // Prepare list of oops for oop map generation.
4202   //
4203   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4204   // regions. offset[i] is the start of the i-th region, which then has
4205   // count[i] oops following. Before we know how many regions are required,
4206   // we pessimistically allocate the maps to fit all the oops into the
4207   // distinct regions.





4208 
<span class="line-modified">4209   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-modified">4210   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>
<span class="line-modified">4211 </span>
<span class="line-modified">4212   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);</span>
<span class="line-added">4213   if (super_oop_map_count &gt; 0) {</span>
<span class="line-added">4214     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),</span>
<span class="line-added">4215                                                     _super_klass-&gt;nonstatic_oop_map_count());</span>
<span class="line-added">4216   }</span>
4217 
4218   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4219 
<span class="line-modified">4220   bool compact_fields  = true;</span>
<span class="line-modified">4221   bool allocate_oops_first = false;</span>




4222 
4223   // The next classes have predefined hard-coded fields offsets
4224   // (see in JavaClasses::compute_hard_coded_offsets()).
4225   // Use default fields allocation order for them.
<span class="line-modified">4226   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;</span>
<span class="line-modified">4227       (_class_name == vmSymbols::java_lang_ref_Reference() ||</span>







4228        _class_name == vmSymbols::java_lang_Boolean() ||
4229        _class_name == vmSymbols::java_lang_Character() ||
4230        _class_name == vmSymbols::java_lang_Float() ||
4231        _class_name == vmSymbols::java_lang_Double() ||
4232        _class_name == vmSymbols::java_lang_Byte() ||
4233        _class_name == vmSymbols::java_lang_Short() ||
4234        _class_name == vmSymbols::java_lang_Integer() ||
4235        _class_name == vmSymbols::java_lang_Long())) {
<span class="line-modified">4236     allocate_oops_first = true;     // Allocate oops first</span>
4237     compact_fields   = false; // Don&#39;t compact fields
4238   }
4239 
4240   int next_nonstatic_oop_offset = 0;
4241   int next_nonstatic_double_offset = 0;
4242 
4243   // Rearrange fields for a given allocation style
<span class="line-modified">4244   if (allocate_oops_first) {</span>
4245     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4246     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4247     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4248                                     (nonstatic_oop_count * heapOopSize);
<span class="line-modified">4249   } else {</span>
4250     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4251     next_nonstatic_double_offset = next_nonstatic_field_offset;





















4252   }
4253 
4254   int nonstatic_oop_space_count   = 0;
4255   int nonstatic_word_space_count  = 0;
4256   int nonstatic_short_space_count = 0;
4257   int nonstatic_byte_space_count  = 0;
4258   int nonstatic_oop_space_offset = 0;
4259   int nonstatic_word_space_offset = 0;
4260   int nonstatic_short_space_offset = 0;
4261   int nonstatic_byte_space_offset = 0;
4262 
4263   // Try to squeeze some of the fields into the gaps due to
4264   // long/double alignment.
4265   if (nonstatic_double_count &gt; 0) {
4266     int offset = next_nonstatic_double_offset;
4267     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4268     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4269       // Allocate available fields into the gap before double field.
4270       int length = next_nonstatic_double_offset - offset;
4271       assert(length == BytesPerInt, &quot;&quot;);
</pre>
<hr />
<pre>
4275         nonstatic_word_space_count = 1; // Only one will fit
4276         length -= BytesPerInt;
4277         offset += BytesPerInt;
4278       }
4279       nonstatic_short_space_offset = offset;
4280       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4281         nonstatic_short_count       -= 1;
4282         nonstatic_short_space_count += 1;
4283         length -= BytesPerShort;
4284         offset += BytesPerShort;
4285       }
4286       nonstatic_byte_space_offset = offset;
4287       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4288         nonstatic_byte_count       -= 1;
4289         nonstatic_byte_space_count += 1;
4290         length -= 1;
4291       }
4292       // Allocate oop field in the gap if there are no other fields for that.
4293       nonstatic_oop_space_offset = offset;
4294       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
<span class="line-modified">4295           !allocate_oops_first) { // when oop fields not first</span>
4296         nonstatic_oop_count      -= 1;
4297         nonstatic_oop_space_count = 1; // Only one will fit
4298         length -= heapOopSize;
4299         offset += heapOopSize;
4300       }
4301     }
4302   }
4303 
4304   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4305                                      (nonstatic_double_count * BytesPerLong);
4306   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4307                                       (nonstatic_word_count * BytesPerInt);
4308   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4309                                      (nonstatic_short_count * BytesPerShort);
4310   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4311                                        nonstatic_byte_count;
4312 
4313   // let oops jump before padding with this allocation style
<span class="line-modified">4314   if (!allocate_oops_first) {</span>
4315     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4316     if( nonstatic_oop_count &gt; 0 ) {
4317       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4318     }
4319     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4320   }
4321 
4322   // Iterate over fields again and compute correct offsets.
4323   // The field allocation type was temporarily stored in the offset slot.
4324   // oop fields are located before non-oop fields (static and non-static).
4325   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4326 
4327     // skip already laid out fields
4328     if (fs.is_offset_set()) continue;
4329 
4330     // contended instance fields are handled below
4331     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4332 
4333     int real_offset = 0;
4334     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
</pre>
<hr />
<pre>
4347         real_offset = next_static_short_offset;
4348         next_static_short_offset += BytesPerShort;
4349         break;
4350       case STATIC_WORD:
4351         real_offset = next_static_word_offset;
4352         next_static_word_offset += BytesPerInt;
4353         break;
4354       case STATIC_DOUBLE:
4355         real_offset = next_static_double_offset;
4356         next_static_double_offset += BytesPerLong;
4357         break;
4358       case NONSTATIC_OOP:
4359         if( nonstatic_oop_space_count &gt; 0 ) {
4360           real_offset = nonstatic_oop_space_offset;
4361           nonstatic_oop_space_offset += heapOopSize;
4362           nonstatic_oop_space_count  -= 1;
4363         } else {
4364           real_offset = next_nonstatic_oop_offset;
4365           next_nonstatic_oop_offset += heapOopSize;
4366         }
<span class="line-modified">4367         nonstatic_oop_maps-&gt;add(real_offset, 1);</span>



















4368         break;
4369       case NONSTATIC_BYTE:
4370         if( nonstatic_byte_space_count &gt; 0 ) {
4371           real_offset = nonstatic_byte_space_offset;
4372           nonstatic_byte_space_offset += 1;
4373           nonstatic_byte_space_count  -= 1;
4374         } else {
4375           real_offset = next_nonstatic_byte_offset;
4376           next_nonstatic_byte_offset += 1;
4377         }
4378         break;
4379       case NONSTATIC_SHORT:
4380         if( nonstatic_short_space_count &gt; 0 ) {
4381           real_offset = nonstatic_short_space_offset;
4382           nonstatic_short_space_offset += BytesPerShort;
4383           nonstatic_short_space_count  -= 1;
4384         } else {
4385           real_offset = next_nonstatic_short_offset;
4386           next_nonstatic_short_offset += BytesPerShort;
4387         }
</pre>
<hr />
<pre>
4460             real_offset = next_nonstatic_padded_offset;
4461             next_nonstatic_padded_offset += BytesPerShort;
4462             break;
4463 
4464           case NONSTATIC_WORD:
4465             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4466             real_offset = next_nonstatic_padded_offset;
4467             next_nonstatic_padded_offset += BytesPerInt;
4468             break;
4469 
4470           case NONSTATIC_DOUBLE:
4471             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4472             real_offset = next_nonstatic_padded_offset;
4473             next_nonstatic_padded_offset += BytesPerLong;
4474             break;
4475 
4476           case NONSTATIC_OOP:
4477             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4478             real_offset = next_nonstatic_padded_offset;
4479             next_nonstatic_padded_offset += heapOopSize;
<span class="line-modified">4480             nonstatic_oop_maps-&gt;add(real_offset, 1);</span>



















4481             break;
4482 
4483           default:
4484             ShouldNotReachHere();
4485         }
4486 
4487         if (fs.contended_group() == 0) {
4488           // Contended group defines the equivalence class over the fields:
4489           // the fields within the same contended group are not inter-padded.
4490           // The only exception is default group, which does not incur the
4491           // equivalence, and so requires intra-padding.
4492           next_nonstatic_padded_offset += ContendedPaddingWidth;
4493         }
4494 
4495         fs.set_offset(real_offset);
4496       } // for
4497 
4498       // Start laying out the next group.
4499       // Note that this will effectively pad the last group in the back;
4500       // this is expected to alleviate memory contention effects for
</pre>
<hr />
<pre>
4524   int static_field_size         = (static_fields_end -
4525                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4526   nonstatic_field_size          = nonstatic_field_size +
4527                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4528 
4529   int instance_size             = align_object_size(instance_end / wordSize);
4530 
4531   assert(instance_size == align_object_size(align_up(
4532          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
4533           wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4534 
4535   // Invariant: nonstatic_field end/start should only change if there are
4536   // nonstatic fields in the class, or if the class is contended. We compare
4537   // against the non-aligned value, so that end alignment will not fail the
4538   // assert without actually having the fields.
4539   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4540          is_contended_class ||
4541          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4542 
4543   // Number of non-static oop map blocks allocated at end of klass.
<span class="line-modified">4544   nonstatic_oop_maps-&gt;compact();</span>


4545 
4546 #ifndef PRODUCT
4547   if (PrintFieldLayout) {
4548     print_field_layout(_class_name,
4549           _fields,
4550           cp,
4551           instance_size,
4552           nonstatic_fields_start,
4553           nonstatic_fields_end,
4554           static_fields_end);
4555   }
4556 
4557 #endif
4558   // Pass back information needed for InstanceKlass creation
<span class="line-modified">4559   info-&gt;oop_map_blocks = nonstatic_oop_maps;</span>
<span class="line-modified">4560   info-&gt;_instance_size = instance_size;</span>
<span class="line-modified">4561   info-&gt;_static_field_size = static_field_size;</span>
<span class="line-modified">4562   info-&gt;_nonstatic_field_size = nonstatic_field_size;</span>
<span class="line-modified">4563   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;</span>












































4564 }
4565 

4566 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4567   assert(ik != NULL, &quot;invariant&quot;);
4568 
4569   const Klass* const super = ik-&gt;super();
4570 
4571   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4572   // in which case we don&#39;t have to register objects as finalizable
4573   if (!_has_empty_finalizer) {
4574     if (_has_finalizer ||
4575         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4576       ik-&gt;set_has_finalizer();
4577     }
4578   }
4579 
4580 #ifdef ASSERT
4581   bool f = false;
4582   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4583                                            vmSymbols::void_method_signature());
4584   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4585       f = true;
</pre>
<hr />
<pre>
4699     // Finally add local interfaces
4700     append_interfaces(result, local_ifs);
4701 
4702     // length will be less than the max_transitive_size if duplicates were removed
4703     const int length = result-&gt;length();
4704     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4705     Array&lt;InstanceKlass*&gt;* const new_result =
4706       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4707     for (int i = 0; i &lt; length; i++) {
4708       InstanceKlass* const e = result-&gt;at(i);
4709       assert(e != NULL, &quot;just checking&quot;);
4710       new_result-&gt;at_put(i, e);
4711     }
4712     return new_result;
4713   }
4714 }
4715 
4716 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4717   assert(this_klass != NULL, &quot;invariant&quot;);
4718   const Klass* const super = this_klass-&gt;super();
<span class="line-added">4719 </span>
4720   if (super != NULL) {
4721 
4722     // If the loader is not the boot loader then throw an exception if its
4723     // superclass is in package jdk.internal.reflect and its loader is not a
4724     // special reflection class loader
4725     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4726       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
4727       PackageEntry* super_package = super-&gt;package();
4728       if (super_package != NULL &amp;&amp;
4729           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4730           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4731         ResourceMark rm(THREAD);
4732         Exceptions::fthrow(
4733           THREAD_AND_LOCATION,
4734           vmSymbols::java_lang_IllegalAccessError(),
4735           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4736           this_klass-&gt;external_name(),
4737           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4738           super-&gt;external_name());
4739         return;
</pre>
<hr />
<pre>
4901   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
4902   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
4903   if (is_module) {
4904     ResourceMark rm(THREAD);
4905     Exceptions::fthrow(
4906       THREAD_AND_LOCATION,
4907       vmSymbols::java_lang_NoClassDefFoundError(),
4908       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4909       _class_name-&gt;as_C_string());
4910     return;
4911   }
4912 
4913   if (!_need_verify) { return; }
4914 
4915   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4916   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4917   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4918   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4919   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4920   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
<span class="line-modified">4921   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;</span>
<span class="line-added">4922   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;</span>
4923 
4924   if ((is_abstract &amp;&amp; is_final) ||
4925       (is_interface &amp;&amp; !is_abstract) ||
<span class="line-modified">4926       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||</span>
<span class="line-modified">4927       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>
4928     ResourceMark rm(THREAD);
4929     Exceptions::fthrow(
4930       THREAD_AND_LOCATION,
4931       vmSymbols::java_lang_ClassFormatError(),
4932       &quot;Illegal class modifiers in class %s: 0x%X&quot;,
4933       _class_name-&gt;as_C_string(), flags
4934     );
4935     return;
4936   }
4937 }
4938 
4939 static bool has_illegal_visibility(jint flags) {
4940   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4941   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4942   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4943 
4944   return ((is_public &amp;&amp; is_protected) ||
4945           (is_public &amp;&amp; is_private) ||
4946           (is_protected &amp;&amp; is_private));
4947 }
4948 
4949 // A legal major_version.minor_version must be one of the following:
4950 //
<span class="line-modified">4951 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.</span>
<span class="line-modified">4952 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.</span>
<span class="line-modified">4953 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.</span>
4954 //
4955 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
<span class="line-added">4956   ResourceMark rm(THREAD);</span>
4957   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
<span class="line-modified">4958   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {</span>
<span class="line-modified">4959     Exceptions::fthrow(</span>
<span class="line-modified">4960       THREAD_AND_LOCATION,</span>
<span class="line-modified">4961       vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4962       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,</span>
<span class="line-modified">4963       class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">4964     return;</span>
<span class="line-modified">4965   }</span>




4966 
<span class="line-modified">4967   if (major &gt; max_version) {</span>
<span class="line-modified">4968     Exceptions::fthrow(</span>
<span class="line-modified">4969       THREAD_AND_LOCATION,</span>
<span class="line-modified">4970       vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4971       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;</span>
<span class="line-modified">4972       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,</span>
<span class="line-modified">4973       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-modified">4974     return;</span>
<span class="line-modified">4975   }</span>
4976 
<span class="line-modified">4977   if (major &lt; JAVA_12_VERSION || minor == 0) {</span>
<span class="line-modified">4978     return;</span>
<span class="line-modified">4979   }</span>
<span class="line-modified">4980 </span>
<span class="line-modified">4981   if (minor == JAVA_PREVIEW_MINOR_VERSION) {</span>
<span class="line-modified">4982     if (major != max_version) {</span>
<span class="line-modified">4983       Exceptions::fthrow(</span>
<span class="line-modified">4984         THREAD_AND_LOCATION,</span>
<span class="line-modified">4985         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4986         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;</span>
<span class="line-modified">4987         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,</span>
<span class="line-modified">4988         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);</span>
<span class="line-modified">4989       return;</span>
<span class="line-modified">4990     }</span>
<span class="line-modified">4991 </span>
<span class="line-modified">4992     if (!Arguments::enable_preview()) {</span>
<span class="line-modified">4993       Exceptions::fthrow(</span>
<span class="line-modified">4994         THREAD_AND_LOCATION,</span>
<span class="line-modified">4995         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">4996         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,</span>
<span class="line-modified">4997         class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">4998       return;</span>


4999     }
<span class="line-added">5000 </span>
<span class="line-added">5001   } else { // minor != JAVA_PREVIEW_MINOR_VERSION</span>
<span class="line-added">5002     Exceptions::fthrow(</span>
<span class="line-added">5003         THREAD_AND_LOCATION,</span>
<span class="line-added">5004         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-added">5005         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,</span>
<span class="line-added">5006         class_name-&gt;as_C_string(), major, minor);</span>
5007   }
5008 }
5009 
5010 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5011                                                    bool is_interface,
5012                                                    TRAPS) const {
5013   if (!_need_verify) { return; }
5014 
5015   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5016   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5017   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5018   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5019   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5020   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5021   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5022   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
<span class="line-modified">5023   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;</span>
5024 
5025   bool is_illegal = false;
5026 
5027   if (is_interface) {
5028     if (!is_public || !is_static || !is_final || is_private ||
5029         is_protected || is_volatile || is_transient ||
<span class="line-modified">5030         (major_gte_1_5 &amp;&amp; is_enum)) {</span>
5031       is_illegal = true;
5032     }
5033   } else { // not interface
5034     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5035       is_illegal = true;
5036     }
5037   }
5038 
5039   if (is_illegal) {
5040     ResourceMark rm(THREAD);
5041     Exceptions::fthrow(
5042       THREAD_AND_LOCATION,
5043       vmSymbols::java_lang_ClassFormatError(),
5044       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5045       _class_name-&gt;as_C_string(), flags);
5046     return;
5047   }
5048 }
5049 
5050 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5051                                                     bool is_interface,
5052                                                     const Symbol* name,
5053                                                     TRAPS) const {
5054   if (!_need_verify) { return; }
5055 
5056   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5057   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5058   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5059   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5060   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5061   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5062   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5063   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5064   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5065   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
<span class="line-modified">5066   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;</span>
5067   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5068   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5069 
5070   bool is_illegal = false;
5071 
5072   if (is_interface) {
5073     if (major_gte_8) {
5074       // Class file version is JAVA_8_VERSION or later Methods of
5075       // interfaces may set any of the flags except ACC_PROTECTED,
5076       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5077       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5078       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5079           (is_native || is_protected || is_final || is_synchronized) ||
5080           // If a specific method of a class or interface has its
5081           // ACC_ABSTRACT flag set, it must not have any of its
5082           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5083           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5084           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5085           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5086           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5087         is_illegal = true;
5088       }
<span class="line-modified">5089     } else if (major_gte_1_5) {</span>
5090       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5091       if (!is_public || is_private || is_protected || is_static || is_final ||
5092           is_synchronized || is_native || !is_abstract || is_strict) {
5093         is_illegal = true;
5094       }
5095     } else {
5096       // Class file version is pre-JAVA_1_5_VERSION
5097       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5098         is_illegal = true;
5099       }
5100     }
5101   } else { // not interface
5102     if (has_illegal_visibility(flags)) {
5103       is_illegal = true;
5104     } else {
5105       if (is_initializer) {
5106         if (is_static || is_final || is_synchronized || is_native ||
<span class="line-modified">5107             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {</span>
5108           is_illegal = true;
5109         }
5110       } else { // not initializer
5111         if (is_abstract) {
5112           if ((is_final || is_native || is_private || is_static ||
<span class="line-modified">5113               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
5114             is_illegal = true;
5115           }
5116         }
5117       }
5118     }
5119   }
5120 
5121   if (is_illegal) {
5122     ResourceMark rm(THREAD);
5123     Exceptions::fthrow(
5124       THREAD_AND_LOCATION,
5125       vmSymbols::java_lang_ClassFormatError(),
5126       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,
5127       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);
5128     return;
5129   }
5130 }
5131 
5132 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5133                                         int length,
5134                                         TRAPS) const {
5135   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5136   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5137     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5138   }
5139 }
5140 
5141 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5142 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5143 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5144 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5145 // method.  Because these names have been checked as special cases before
5146 // calling this method in verify_legal_method_name.
5147 //
5148 // This method is also called from the modular system APIs in modules.cpp
5149 // to verify the validity of module and package names.
5150 bool ClassFileParser::verify_unqualified_name(const char* name,
5151                                               unsigned int length,
5152                                               int type) {
<span class="line-added">5153   if (length == 0) return false;  // Must have at least one char.</span>
5154   for (const char* p = name; p != name + length; p++) {
5155     switch(*p) {
<span class="line-modified">5156       case JVM_SIGNATURE_DOT:</span>
<span class="line-modified">5157       case JVM_SIGNATURE_ENDCLASS:</span>
<span class="line-modified">5158       case JVM_SIGNATURE_ARRAY:</span>
5159         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5160         return false;
<span class="line-modified">5161       case JVM_SIGNATURE_SLASH:</span>
5162         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5163         // unqualified name must not be empty
5164         if (type == ClassFileParser::LegalClass) {
<span class="line-modified">5165           if (p == name || p+1 &gt;= name+length ||</span>
<span class="line-added">5166               *(p+1) == JVM_SIGNATURE_SLASH) {</span>
5167             return false;
5168           }
5169         } else {
5170           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5171         }
5172         break;
<span class="line-modified">5173       case JVM_SIGNATURE_SPECIAL:</span>
<span class="line-modified">5174       case JVM_SIGNATURE_ENDSPECIAL:</span>
5175         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5176         if (type == ClassFileParser::LegalMethod) {
5177           return false;
5178         }
5179     }
5180   }
5181   return true;
5182 }
5183 
5184 // Take pointer to a UTF8 byte string (not NUL-terminated).
5185 // Skip over the longest part of the string that could
5186 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5187 // Return a pointer to just past the fieldname.
5188 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5189 // being true, we saw consecutive slashes (meaning we were looking for a
5190 // qualified path but found something that was badly-formed).
5191 static const char* skip_over_field_name(const char* const name,
5192                                         bool slash_ok,
5193                                         unsigned int length) {
5194   const char* p;
5195   jboolean last_is_slash = false;
5196   jboolean not_first_ch = false;
5197 
5198   for (p = name; p != name + length; not_first_ch = true) {
5199     const char* old_p = p;
5200     jchar ch = *p;
5201     if (ch &lt; 128) {
5202       p++;
5203       // quick check for ascii
5204       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5205         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5206         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5207         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5208         last_is_slash = false;
5209         continue;
5210       }
<span class="line-modified">5211       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {</span>
5212         if (last_is_slash) {
5213           return NULL;  // Don&#39;t permit consecutive slashes
5214         }
5215         last_is_slash = true;
5216         continue;
5217       }
5218     }
5219     else {
5220       jint unicode_ch;
5221       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5222       p = tmp_p;
5223       last_is_slash = false;
5224       // Check if ch is Java identifier start or is Java identifier part
5225       // 4672820: call java.lang.Character methods directly without generating separate tables.
5226       EXCEPTION_MARK;
5227       // return value
5228       JavaValue result(T_BOOLEAN);
5229       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5230       JavaCallArguments args;
5231       args.push_int(unicode_ch);
</pre>
<hr />
<pre>
5271                                                        TRAPS) const {
5272   unsigned int array_dim = 0;
5273   while (length &gt; 0) {
5274     switch (signature[0]) {
5275     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5276     case JVM_SIGNATURE_BOOLEAN:
5277     case JVM_SIGNATURE_BYTE:
5278     case JVM_SIGNATURE_CHAR:
5279     case JVM_SIGNATURE_SHORT:
5280     case JVM_SIGNATURE_INT:
5281     case JVM_SIGNATURE_FLOAT:
5282     case JVM_SIGNATURE_LONG:
5283     case JVM_SIGNATURE_DOUBLE:
5284       return signature + 1;
5285     case JVM_SIGNATURE_CLASS: {
5286       if (_major_version &lt; JAVA_1_5_VERSION) {
5287         // Skip over the class name if one is there
5288         const char* const p = skip_over_field_name(signature + 1, true, --length);
5289 
5290         // The next character better be a semicolon
<span class="line-modified">5291         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {</span>
5292           return p + 1;
5293         }
5294       }
5295       else {
5296         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
5297         signature++;
<span class="line-modified">5298         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);</span>
5299         // Format check signature
5300         if (c != NULL) {
5301           int newlen = c - (char*) signature;
5302           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5303           if (!legal) {
<span class="line-modified">5304             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;</span>
5305                                   &quot;in descriptor in class file %s&quot;,
5306                                   CHECK_0);
5307             return NULL;
5308           }
5309           return signature + newlen + 1;
5310         }
5311       }
5312       return NULL;
5313     }
5314     case JVM_SIGNATURE_ARRAY:
5315       array_dim++;
5316       if (array_dim &gt; 255) {
5317         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5318         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);
5319       }
5320       // The rest of what&#39;s there better be a legal signature
5321       signature++;
5322       length--;
5323       void_ok = false;
5324       break;
</pre>
<hr />
<pre>
5327     }
5328   }
5329   return NULL;
5330 }
5331 
5332 // Checks if name is a legal class name.
5333 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5334   if (!_need_verify || _relax_verify) { return; }
5335 
5336   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5337   char* bytes = (char*)name-&gt;bytes();
5338   unsigned int length = name-&gt;utf8_length();
5339   bool legal = false;
5340 
5341   if (length &gt; 0) {
5342     const char* p;
5343     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5344       p = skip_over_field_signature(bytes, false, length, CHECK);
5345       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5346     } else if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">5347       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {</span>
5348         p = skip_over_field_name(bytes, true, length);
5349         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5350       }
5351     } else {
5352       // 4900761: relax the constraints based on JSR202 spec
5353       // Class names may be drawn from the entire Unicode character set.
5354       // Identifiers between &#39;/&#39; must be unqualified names.
5355       // The utf8 string has been verified when parsing cpool entries.
5356       legal = verify_unqualified_name(bytes, length, LegalClass);
5357     }
5358   }
5359   if (!legal) {
5360     ResourceMark rm(THREAD);
5361     assert(_class_name != NULL, &quot;invariant&quot;);
5362     Exceptions::fthrow(
5363       THREAD_AND_LOCATION,
5364       vmSymbols::java_lang_ClassFormatError(),
5365       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5366       _class_name-&gt;as_C_string()
5367     );
5368     return;
5369   }
5370 }
5371 
5372 // Checks if name is a legal field name.
5373 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5374   if (!_need_verify || _relax_verify) { return; }
5375 
5376   char* bytes = (char*)name-&gt;bytes();
5377   unsigned int length = name-&gt;utf8_length();
5378   bool legal = false;
5379 
5380   if (length &gt; 0) {
5381     if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">5382       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {</span>
5383         const char* p = skip_over_field_name(bytes, false, length);
5384         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5385       }
5386     } else {
5387       // 4881221: relax the constraints based on JSR202 spec
5388       legal = verify_unqualified_name(bytes, length, LegalField);
5389     }
5390   }
5391 
5392   if (!legal) {
5393     ResourceMark rm(THREAD);
5394     assert(_class_name != NULL, &quot;invariant&quot;);
5395     Exceptions::fthrow(
5396       THREAD_AND_LOCATION,
5397       vmSymbols::java_lang_ClassFormatError(),
5398       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5399       _class_name-&gt;as_C_string()
5400     );
5401     return;
5402   }
5403 }
5404 
5405 // Checks if name is a legal method name.
5406 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5407   if (!_need_verify || _relax_verify) { return; }
5408 
5409   assert(name != NULL, &quot;method name is null&quot;);
5410   char* bytes = (char*)name-&gt;bytes();
5411   unsigned int length = name-&gt;utf8_length();
5412   bool legal = false;
5413 
5414   if (length &gt; 0) {
<span class="line-modified">5415     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {</span>
5416       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5417         legal = true;
5418       }
5419     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5420       const char* p;
5421       p = skip_over_field_name(bytes, false, length);
5422       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5423     } else {
5424       // 4881221: relax the constraints based on JSR202 spec
5425       legal = verify_unqualified_name(bytes, length, LegalMethod);
5426     }
5427   }
5428 
5429   if (!legal) {
5430     ResourceMark rm(THREAD);
5431     assert(_class_name != NULL, &quot;invariant&quot;);
5432     Exceptions::fthrow(
5433       THREAD_AND_LOCATION,
5434       vmSymbols::java_lang_ClassFormatError(),
5435       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
</pre>
<hr />
<pre>
5479   unsigned int length = signature-&gt;utf8_length();
5480   const char* nextp;
5481 
5482   // The first character must be a &#39;(&#39;
5483   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5484     length--;
5485     // Skip over legal field signatures
5486     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5487     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5488       args_size++;
5489       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5490         args_size++;
5491       }
5492       length -= nextp - p;
5493       p = nextp;
5494       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5495     }
5496     // The first non-signature thing better be a &#39;)&#39;
5497     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5498       length--;
<span class="line-modified">5499       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {</span>
5500         // All internal methods must return void
5501         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5502           return args_size;
5503         }
5504       } else {
5505         // Now we better just have a return value
5506         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5507         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5508           return args_size;
5509         }
5510       }
5511     }
5512   }
5513   // Report error
5514   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5515   return 0;
5516 }
5517 
5518 int ClassFileParser::static_field_size() const {
5519   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5520   return _field_info-&gt;_static_field_size;</span>
5521 }
5522 
5523 int ClassFileParser::total_oop_map_count() const {
5524   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5525   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;</span>
5526 }
5527 
5528 jint ClassFileParser::layout_size() const {
5529   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5530   return _field_info-&gt;_instance_size;</span>
5531 }
5532 
5533 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5534                                          const Array&lt;Method*&gt;* methods) {
5535   assert(ik != NULL, &quot;invariant&quot;);
5536   assert(methods != NULL, &quot;invariant&quot;);
5537 
5538   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5539   // (We used to do this lazily, but now we query it in Rewriter,
5540   // which is eagerly done for every method, so we might as well do it now,
5541   // when everything is fresh in memory.)
5542   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5543 
5544   if (klass_id != vmSymbols::NO_SID) {
5545     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5546       Method* method = methods-&gt;at(j);
5547       method-&gt;init_intrinsic_id();
5548 
5549       if (CheckIntrinsics) {
5550         // Check if an intrinsic is defined for method &#39;method&#39;,
</pre>
<hr />
<pre>
5654 
5655   return ik;
5656 }
5657 
5658 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5659   assert(ik != NULL, &quot;invariant&quot;);
5660 
5661   // Set name and CLD before adding to CLD
5662   ik-&gt;set_class_loader_data(_loader_data);
5663   ik-&gt;set_name(_class_name);
5664 
5665   // Add all classes to our internal class loader list here,
5666   // including classes in the bootstrap (NULL) class loader.
5667   const bool publicize = !is_internal();
5668 
5669   _loader_data-&gt;add_class(ik, publicize);
5670 
5671   set_klass_to_deallocate(ik);
5672 
5673   assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">5674   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);</span>
<span class="line-modified">5675   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,</span>
<span class="line-modified">5676          &quot;sanity&quot;);</span>
5677 
5678   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
<span class="line-modified">5679   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);</span>
5680 
5681   // Fill in information already parsed
5682   ik-&gt;set_should_verify_class(_need_verify);
5683 
5684   // Not yet: supers are done below to support the new subtype-checking fields
<span class="line-modified">5685   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);</span>
<span class="line-modified">5686   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);</span>
5687   assert(_fac != NULL, &quot;invariant&quot;);
5688   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5689 
5690   // this transfers ownership of a lot of arrays from
5691   // the parser onto the InstanceKlass*
5692   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5693 
5694   // note that is not safe to use the fields in the parser from this point on
5695   assert(NULL == _cp, &quot;invariant&quot;);
5696   assert(NULL == _fields, &quot;invariant&quot;);
5697   assert(NULL == _methods, &quot;invariant&quot;);
5698   assert(NULL == _inner_classes, &quot;invariant&quot;);
5699   assert(NULL == _nest_members, &quot;invariant&quot;);
5700   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5701   assert(NULL == _combined_annotations, &quot;invariant&quot;);
<span class="line-added">5702   assert(NULL == _record_components, &quot;invariant&quot;);</span>
5703 
5704   if (_has_final_method) {
5705     ik-&gt;set_has_final_method();
5706   }
5707 
5708   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5709   // The InstanceKlass::_methods_jmethod_ids cache
5710   // is managed on the assumption that the initial cache
5711   // size is equal to the number of methods in the class. If
5712   // that changes, then InstanceKlass::idnum_can_increment()
5713   // has to be changed accordingly.
5714   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5715 
5716   ik-&gt;set_this_class_index(_this_class_index);
5717 
5718   if (is_unsafe_anonymous()) {
5719     // _this_class_index is a CONSTANT_Class entry that refers to this
5720     // anonymous class itself. If this class needs to refer to its own methods or
5721     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5722     // _this_class_index. However, because this class is anonymous (it&#39;s
</pre>
<hr />
<pre>
5757 
5758   // Miranda methods
5759   if ((_num_miranda_methods &gt; 0) ||
5760       // if this class introduced new miranda methods or
5761       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5762         // super class exists and this class inherited miranda methods
5763      ) {
5764        ik-&gt;set_has_miranda_methods(); // then set a flag
5765   }
5766 
5767   // Fill in information needed to compute superclasses.
5768   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5769   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5770   _transitive_interfaces = NULL;
5771 
5772   // Initialize itable offset tables
5773   klassItable::setup_itable_offset_table(ik);
5774 
5775   // Compute transitive closure of interfaces this class implements
5776   // Do final class setup
<span class="line-modified">5777   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;</span>
<span class="line-modified">5778   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-modified">5779     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());</span>
<span class="line-modified">5780   }</span>
<span class="line-added">5781 </span>
<span class="line-added">5782   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||</span>
<span class="line-added">5783       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {</span>
<span class="line-added">5784     ik-&gt;set_has_contended_annotations(true);</span>
<span class="line-added">5785   }</span>
5786 
5787   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5788   set_precomputed_flags(ik);
5789 
5790   // check if this class can access its super class
5791   check_super_class_access(ik, CHECK);
5792 
5793   // check if this class can access its superinterfaces
5794   check_super_interface_access(ik, CHECK);
5795 
5796   // check if this class overrides any final method
5797   check_final_method_override(ik, CHECK);
5798 
5799   // reject static interface methods prior to Java 8
5800   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5801     check_illegal_static_method(ik, CHECK);
5802   }
5803 
5804   // Obtain this_klass&#39; module entry
5805   ModuleEntry* module_entry = ik-&gt;module();
</pre>
<hr />
<pre>
5845       // Make sure each method has a jmethodID.
5846       // This allows us to avoid allocating jmethodIDs during program execution.
5847       jmethodID id = ik-&gt;methods()-&gt;at(index)-&gt;jmethod_id();
5848 #ifdef ASSERT
5849       u8 id_u8 = reinterpret_cast&lt;u8&gt;(id);
5850       assert((id_u8 &amp; right_n_bits(3)) == 0, &quot;jmethodID is not aligned&quot;);
5851       assert((id_u8 &amp; left_n_bits(17)) == 0, &quot;jmethodID is not aligned&quot;);
5852 #endif
5853     }
5854   }
5855 #endif // INCLUDE_TSAN
5856 
5857   if (!is_internal()) {
5858     if (log_is_enabled(Info, class, load)) {
5859       ResourceMark rm;
5860       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5861       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5862     }
5863 
5864     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
<span class="line-modified">5865         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
5866         log_is_enabled(Info, class, preview)) {
5867       ResourceMark rm;
5868       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
<span class="line-modified">5869                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);</span>
5870     }
5871 
5872     if (log_is_enabled(Debug, class, resolve))  {
5873       ResourceMark rm;
5874       // print out the superclass.
5875       const char * from = ik-&gt;external_name();
5876       if (ik-&gt;java_super() != NULL) {
5877         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5878                    from,
5879                    ik-&gt;java_super()-&gt;external_name());
5880       }
5881       // print out each of the interface classes referred to by this class.
5882       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5883       if (local_interfaces != NULL) {
5884         const int length = local_interfaces-&gt;length();
5885         for (int i = 0; i &lt; length; i++) {
5886           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5887           const char * to = k-&gt;external_name();
5888           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5889         }
</pre>
<hr />
<pre>
5904   debug_only(ik-&gt;verify();)
5905 }
5906 
5907 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5908   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5909   _class_name-&gt;decrement_refcount();
5910 
5911   _class_name = new_class_name;
5912   // Increment the refcount of the new name.
5913   // Now the ClassFileParser owns this name and will decrement in
5914   // the destructor.
5915   _class_name-&gt;increment_refcount();
5916 }
5917 
5918 
5919 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5920 // package by prepending its host class&#39;s package name to its class name and setting
5921 // its _class_name field.
5922 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5923   ResourceMark rm(THREAD);
<span class="line-modified">5924   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,</span>
5925          &quot;Unsafe anonymous class should not be in a package&quot;);
5926   const char* host_pkg_name =
5927     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
5928 
5929   if (host_pkg_name != NULL) {
5930     int host_pkg_len = (int)strlen(host_pkg_name);
5931     int class_name_len = _class_name-&gt;utf8_length();
5932     int symbol_len = host_pkg_len + 1 + class_name_len;
5933     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
5934     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
5935                          host_pkg_name, class_name_len, _class_name-&gt;base());
5936     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
5937 
5938     // Decrement old _class_name to avoid leaking.
5939     _class_name-&gt;decrement_refcount();
5940 
5941     // Create a symbol and update the anonymous class name.
5942     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
5943     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
5944     // when the class is unloaded.
<span class="line-modified">5945     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);</span>
5946   }
5947 }
5948 
5949 // If the host class and the anonymous class are in the same package then do
5950 // nothing.  If the anonymous class is in the unnamed package then move it to its
5951 // host&#39;s package.  If the classes are in different packages then throw an IAE
5952 // exception.
5953 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
5954   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
5955 
5956   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
<span class="line-modified">5957                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);</span>
5958   if (anon_last_slash == NULL) {  // Unnamed package
5959     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
5960   } else {
5961     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
5962       ResourceMark rm(THREAD);
5963       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
5964         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
5965         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
5966     }
5967   }
5968 }
5969 
5970 static bool relax_format_check_for(ClassLoaderData* loader_data) {
5971   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
5972                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
5973   bool need_verify =
5974     // verifyAll
5975     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
5976     // verifyRemote
5977     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
</pre>
<hr />
<pre>
5986                                  GrowableArray&lt;Handle&gt;* cp_patches,
5987                                  Publicity pub_level,
5988                                  TRAPS) :
5989   _stream(stream),
5990   _requested_name(name),
5991   _class_name(NULL),
5992   _loader_data(loader_data),
5993   _unsafe_anonymous_host(unsafe_anonymous_host),
5994   _cp_patches(cp_patches),
5995   _num_patched_klasses(0),
5996   _max_num_patched_klasses(0),
5997   _orig_cp_size(0),
5998   _first_patched_klass_resolved_index(0),
5999   _super_klass(),
6000   _cp(NULL),
6001   _fields(NULL),
6002   _methods(NULL),
6003   _inner_classes(NULL),
6004   _nest_members(NULL),
6005   _nest_host(0),
<span class="line-added">6006   _record_components(NULL),</span>
6007   _local_interfaces(NULL),
6008   _transitive_interfaces(NULL),
6009   _combined_annotations(NULL),
<span class="line-modified">6010   _class_annotations(NULL),</span>
<span class="line-modified">6011   _class_type_annotations(NULL),</span>
6012   _fields_annotations(NULL),
6013   _fields_type_annotations(NULL),
6014   _klass(NULL),
6015   _klass_to_deallocate(NULL),
6016   _parsed_annotations(NULL),
6017   _fac(NULL),
6018   _field_info(NULL),
6019   _method_ordering(NULL),
6020   _all_mirandas(NULL),
6021   _vtable_size(0),
6022   _itable_size(0),
6023   _num_miranda_methods(0),
6024   _rt(REF_NONE),
6025   _protection_domain(protection_domain),
6026   _access_flags(),
6027   _pub_level(pub_level),
6028   _bad_constant_seen(0),
6029   _synthetic_flag(false),
6030   _sde_length(false),
6031   _sde_buffer(NULL),
6032   _sourcefile_index(0),
6033   _generic_signature_index(0),
6034   _major_version(0),
6035   _minor_version(0),
6036   _this_class_index(0),
6037   _super_class_index(0),
6038   _itfs_len(0),
6039   _java_fields_count(0),
6040   _need_verify(false),
6041   _relax_verify(false),
6042   _has_nonstatic_concrete_methods(false),
6043   _declares_nonstatic_concrete_methods(false),
6044   _has_final_method(false),
<span class="line-added">6045   _has_contended_fields(false),</span>
6046   _has_finalizer(false),
6047   _has_empty_finalizer(false),
6048   _has_vanilla_constructor(false),
6049   _max_bootstrap_specifier_index(-1) {
6050 
6051   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6052   _class_name-&gt;increment_refcount();
6053 
6054   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6055   assert(_loader_data != NULL, &quot;invariant&quot;);
6056   assert(stream != NULL, &quot;invariant&quot;);
6057   assert(_stream != NULL, &quot;invariant&quot;);
6058   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6059   assert(_class_name != NULL, &quot;invariant&quot;);
6060   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6061 
6062   // Figure out whether we can skip format checking (matching classic VM behavior)
6063   if (DumpSharedSpaces) {
6064     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6065     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6096 
6097   // Check if verification needs to be relaxed for this class file
6098   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6099   _relax_verify = relax_format_check_for(_loader_data);
6100 
6101   parse_stream(stream, CHECK);
6102 
6103   post_process_parsed_stream(stream, _cp, CHECK);
6104 }
6105 
6106 void ClassFileParser::clear_class_metadata() {
6107   // metadata created before the instance klass is created.  Must be
6108   // deallocated if classfile parsing returns an error.
6109   _cp = NULL;
6110   _fields = NULL;
6111   _methods = NULL;
6112   _inner_classes = NULL;
6113   _nest_members = NULL;
6114   _local_interfaces = NULL;
6115   _combined_annotations = NULL;
<span class="line-modified">6116   _class_annotations = _class_type_annotations = NULL;</span>
6117   _fields_annotations = _fields_type_annotations = NULL;
<span class="line-added">6118   _record_components = NULL;</span>
6119 }
6120 
6121 // Destructor to clean up
6122 ClassFileParser::~ClassFileParser() {
6123   _class_name-&gt;decrement_refcount();
6124 
6125   if (_cp != NULL) {
6126     MetadataFactory::free_metadata(_loader_data, _cp);
6127   }
6128   if (_fields != NULL) {
6129     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6130   }
6131 
6132   if (_methods != NULL) {
6133     // Free methods
6134     InstanceKlass::deallocate_methods(_loader_data, _methods);
6135   }
6136 
6137   // beware of the Universe::empty_blah_array!!
6138   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6139     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6140   }
6141 
6142   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6143     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6144   }
6145 
<span class="line-added">6146   if (_record_components != NULL) {</span>
<span class="line-added">6147     InstanceKlass::deallocate_record_components(_loader_data, _record_components);</span>
<span class="line-added">6148   }</span>
<span class="line-added">6149 </span>
6150   // Free interfaces
6151   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6152                                        _local_interfaces, _transitive_interfaces);
6153 
6154   if (_combined_annotations != NULL) {
6155     // After all annotations arrays have been created, they are installed into the
6156     // Annotations object that will be assigned to the InstanceKlass being created.
6157 
6158     // Deallocate the Annotations object and the installed annotations arrays.
6159     _combined_annotations-&gt;deallocate_contents(_loader_data);
6160 
6161     // If the _combined_annotations pointer is non-NULL,
6162     // then the other annotations fields should have been cleared.
<span class="line-modified">6163     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);</span>
<span class="line-modified">6164     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);</span>
6165     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6166     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6167   } else {
6168     // If the annotations arrays were not installed into the Annotations object,
6169     // then they have to be deallocated explicitly.
<span class="line-modified">6170     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);</span>
<span class="line-modified">6171     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);</span>
6172     Annotations::free_contents(_loader_data, _fields_annotations);
6173     Annotations::free_contents(_loader_data, _fields_type_annotations);
6174   }
6175 
6176   clear_class_metadata();
6177   _transitive_interfaces = NULL;
6178 
6179   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6180   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6181   // at a safepoint.
6182   if (_klass_to_deallocate != NULL) {
6183     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6184   }
6185 }
6186 
6187 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6188                                    TRAPS) {
6189 
6190   assert(stream != NULL, &quot;invariant&quot;);
6191   assert(_class_name != NULL, &quot;invariant&quot;);
6192 
6193   // BEGIN STREAM PARSING
6194   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6195   // Magic value
6196   const u4 magic = stream-&gt;get_u4_fast();
6197   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6198                      &quot;Incompatible magic value %u in class file %s&quot;,
6199                      magic, CHECK);
6200 
6201   // Version numbers
6202   _minor_version = stream-&gt;get_u2_fast();
6203   _major_version = stream-&gt;get_u2_fast();
6204 
<span class="line-modified">6205   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {</span>
6206     ResourceMark rm;
<span class="line-modified">6207     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,</span>
6208             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6209     Exceptions::fthrow(
6210       THREAD_AND_LOCATION,
6211       vmSymbols::java_lang_UnsupportedClassVersionError(),
6212       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6213       _major_version,
6214       _minor_version);
6215   }
6216 
6217   // Check version numbers - we check this even with verifier off
6218   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6219 
6220   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6221   u2 cp_size = stream-&gt;get_u2_fast();
6222 
6223   guarantee_property(
6224     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6225     cp_size, CHECK);
6226 
6227   _orig_cp_size = cp_size;
</pre>
<hr />
<pre>
6326       }
6327       ls.cr();
6328     }
6329 
6330 #if INCLUDE_CDS
6331     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6332       if (!ClassLoader::has_jrt_entry()) {
6333         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6334         DumpLoadedClassList = NULL;
6335       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6336                  _unsafe_anonymous_host == NULL) {
6337         // Only dump the classes that can be stored into CDS archive.
6338         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6339         oop class_loader = _loader_data-&gt;class_loader();
6340         ResourceMark rm(THREAD);
6341         bool skip = false;
6342         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6343           // For the boot and platform class loaders, skip classes that are not found in the
6344           // java runtime image, such as those found in the --patch-module entries.
6345           // These classes can&#39;t be loaded from the archive during runtime.
<span class="line-modified">6346           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {</span>
6347             skip = true;
6348           }
6349 
6350           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6351             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6352             // as they can be loaded from the archive during runtime.
6353             skip = false;
6354           }
6355         }
6356         if (skip) {
6357           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6358             _class_name-&gt;as_C_string(), stream-&gt;source());
6359         } else {
6360           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6361           classlist_file-&gt;flush();
6362         }
6363       }
6364     }
6365 #endif
6366   }
</pre>
<hr />
<pre>
6503   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6504                                                     &amp;_num_miranda_methods,
6505                                                     _all_mirandas,
6506                                                     _super_klass,
6507                                                     _methods,
6508                                                     _access_flags,
6509                                                     _major_version,
6510                                                     loader,
6511                                                     _class_name,
6512                                                     _local_interfaces,
6513                                                     CHECK);
6514 
6515   // Size of Java itable (in words)
6516   _itable_size = _access_flags.is_interface() ? 0 :
6517     klassItable::compute_itable_size(_transitive_interfaces);
6518 
6519   assert(_fac != NULL, &quot;invariant&quot;);
6520   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6521 
6522   _field_info = new FieldLayoutInfo();
<span class="line-modified">6523   if (UseNewFieldLayout) {</span>
<span class="line-added">6524     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="line-added">6525                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-added">6526     lb.build_layout();</span>
<span class="line-added">6527   } else {</span>
<span class="line-added">6528     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>
<span class="line-added">6529   }</span>
6530 
6531   // Compute reference typ
6532   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6533 
6534 }
6535 
6536 void ClassFileParser::set_klass(InstanceKlass* klass) {
6537 
6538 #ifdef ASSERT
6539   if (klass != NULL) {
6540     assert(NULL == _klass, &quot;leaking?&quot;);
6541   }
6542 #endif
6543 
6544   _klass = klass;
6545 }
6546 
6547 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6548 
6549 #ifdef ASSERT
</pre>
<hr />
<pre>
6555   _klass_to_deallocate = klass;
6556 }
6557 
6558 // Caller responsible for ResourceMark
6559 // clone stream with rewound position
6560 const ClassFileStream* ClassFileParser::clone_stream() const {
6561   assert(_stream != NULL, &quot;invariant&quot;);
6562 
6563   return _stream-&gt;clone();
6564 }
6565 // ----------------------------------------------------------------------------
6566 // debugging
6567 
6568 #ifdef ASSERT
6569 
6570 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6571 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6572   if (class_name != NULL) {
6573     ResourceMark rm;
6574     char* name = class_name-&gt;as_C_string();
<span class="line-modified">6575     return strchr(name, JVM_SIGNATURE_DOT) == NULL;</span>
6576   } else {
6577     return true;
6578   }
6579 }
6580 
6581 #endif
</pre>
</td>
</tr>
</table>
<center><a href="bytecodeAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
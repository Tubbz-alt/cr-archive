<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytecodeAssembler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,12 ***</span>
<span class="line-new-header">--- 28,14 ---</span>
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/defaultMethods.hpp&quot;
  #include &quot;classfile/dictionary.hpp&quot;
<span class="line-added">+ #include &quot;classfile/fieldLayoutBuilder.hpp&quot;</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">+ #include &quot;classfile/packageEntry.hpp&quot;</span>
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #if INCLUDE_TSAN
  #include &quot;classfile/tsanIgnoreList.hpp&quot;
  #endif // INCLUDE_TSAN
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,22 ***</span>
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/annotations.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/klassVtable.hpp&quot;
  #include &quot;oops/metadata.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;runtime/reflection.hpp&quot;
<span class="line-new-header">--- 49,24 ---</span>
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/annotations.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/klassVtable.hpp&quot;
  #include &quot;oops/metadata.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/recordComponent.hpp&quot;</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
<span class="line-added">+ #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  #include &quot;runtime/reflection.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,10 ***</span>
<span class="line-new-header">--- 82,12 ---</span>
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
<span class="line-added">+ </span>
  #if INCLUDE_CDS
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #endif
  #if INCLUDE_JFR
  #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,12 ***</span>
  
  #define JAVA_12_VERSION                   56
  
  #define JAVA_13_VERSION                   57
  
  void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
<span class="line-modified">!   assert((bad_constant == 19 || bad_constant == 20) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,</span>
           &quot;Unexpected bad constant pool entry&quot;);
    if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
  }
  
  void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
<span class="line-new-header">--- 129,17 ---</span>
  
  #define JAVA_12_VERSION                   56
  
  #define JAVA_13_VERSION                   57
  
<span class="line-added">+ #define JAVA_14_VERSION                   58</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define JAVA_15_VERSION                   59</span>
<span class="line-added">+ </span>
  void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
<span class="line-modified">!   assert((bad_constant == JVM_CONSTANT_Module ||</span>
<span class="line-added">+           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,</span>
           &quot;Unexpected bad constant pool entry&quot;);
    if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
  }
  
  void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,11 ***</span>
                               index,
                               CHECK);
            const char* const str = java_lang_String::as_utf8_string(patch());
            // (could use java_lang_String::as_symbol instead, but might as well batch them)
            utf8_buffer = (const u1*) str;
<span class="line-modified">!           utf8_length = (int) strlen(str);</span>
          }
  
          unsigned int hash;
          Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
                                                          utf8_length,
<span class="line-new-header">--- 324,11 ---</span>
                               index,
                               CHECK);
            const char* const str = java_lang_String::as_utf8_string(patch());
            // (could use java_lang_String::as_symbol instead, but might as well batch them)
            utf8_buffer = (const u1*) str;
<span class="line-modified">!           utf8_length = (u2) strlen(str);</span>
          }
  
          unsigned int hash;
          Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
                                                          utf8_length,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,26 ***</span>
            lengths[names_count] = utf8_length;
            indices[names_count] = index;
            hashValues[names_count++] = hash;
            if (names_count == SymbolTable::symbol_alloc_batch_size) {
              SymbolTable::new_symbols(_loader_data,
<span class="line-modified">!                                      cp,</span>
                                       names_count,
                                       names,
                                       lengths,
                                       indices,
<span class="line-modified">!                                      hashValues,</span>
<span class="line-removed">-                                      CHECK);</span>
              names_count = 0;
            }
          } else {
            cp-&gt;symbol_at_put(index, result);
          }
          break;
        }
<span class="line-modified">!       case 19:</span>
<span class="line-modified">!       case 20: {</span>
          // Record that an error occurred in these two cases but keep parsing so
          // that ACC_Module can be checked for in the access_flags.  Need to
          // throw NoClassDefFoundError in that case.
          if (_major_version &gt;= JAVA_9_VERSION) {
            cfs-&gt;guarantee_more(3, CHECK);
<span class="line-new-header">--- 338,25 ---</span>
            lengths[names_count] = utf8_length;
            indices[names_count] = index;
            hashValues[names_count++] = hash;
            if (names_count == SymbolTable::symbol_alloc_batch_size) {
              SymbolTable::new_symbols(_loader_data,
<span class="line-modified">!                                      constantPoolHandle(THREAD, cp),</span>
                                       names_count,
                                       names,
                                       lengths,
                                       indices,
<span class="line-modified">!                                      hashValues);</span>
              names_count = 0;
            }
          } else {
            cp-&gt;symbol_at_put(index, result);
          }
          break;
        }
<span class="line-modified">!       case JVM_CONSTANT_Module:</span>
<span class="line-modified">!       case JVM_CONSTANT_Package: {</span>
          // Record that an error occurred in these two cases but keep parsing so
          // that ACC_Module can be checked for in the access_flags.  Need to
          // throw NoClassDefFoundError in that case.
          if (_major_version &gt;= JAVA_9_VERSION) {
            cfs-&gt;guarantee_more(3, CHECK);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,17 ***</span>
    } // end of for
  
    // Allocate the remaining symbols
    if (names_count &gt; 0) {
      SymbolTable::new_symbols(_loader_data,
<span class="line-modified">!                              cp,</span>
                               names_count,
                               names,
                               lengths,
                               indices,
<span class="line-modified">!                              hashValues,</span>
<span class="line-removed">-                              CHECK);</span>
    }
  
    // Copy _current pointer of local copy back to stream.
    assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
    stream-&gt;set_current(cfs1.current());
<span class="line-new-header">--- 375,16 ---</span>
    } // end of for
  
    // Allocate the remaining symbols
    if (names_count &gt; 0) {
      SymbolTable::new_symbols(_loader_data,
<span class="line-modified">!                              constantPoolHandle(THREAD, cp),</span>
                               names_count,
                               names,
                               lengths,
                               indices,
<span class="line-modified">!                              hashValues);</span>
    }
  
    // Copy _current pointer of local copy back to stream.
    assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
    stream-&gt;set_current(cfs1.current());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,11 ***</span>
              sig_index, CHECK);
            guarantee_property(name-&gt;utf8_length() != 0,
              &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
              name_index, CHECK);
  
<span class="line-modified">!           if (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
              // Format check method name and signature
              verify_legal_method_name(name, CHECK);
              verify_legal_method_signature(name, sig, CHECK);
            } else {
              // Format check field name and signature
<span class="line-new-header">--- 668,11 ---</span>
              sig_index, CHECK);
            guarantee_property(name-&gt;utf8_length() != 0,
              &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
              name_index, CHECK);
  
<span class="line-modified">!           if (Signature::is_method(sig)) {</span>
              // Format check method name and signature
              verify_legal_method_name(name, CHECK);
              verify_legal_method_signature(name, sig, CHECK);
            } else {
              // Format check field name and signature
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,13 ***</span>
            cp-&gt;signature_ref_index_at(name_and_type_ref_index);
          const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
          const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
          if (_need_verify) {
            // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
<span class="line-modified">!           // Need only to be sure signature is non-zero length and the right type.</span>
<span class="line-modified">!           if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed">-               signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
              throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
            }
          }
          break;
        }
<span class="line-new-header">--- 693,12 ---</span>
            cp-&gt;signature_ref_index_at(name_and_type_ref_index);
          const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
          const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
          if (_need_verify) {
            // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
<span class="line-modified">!           // Need only to be sure signature is the right type.</span>
<span class="line-modified">!           if (Signature::is_method(signature)) {</span>
              throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
            }
          }
          break;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 710,29 ***</span>
          const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
          if (tag == JVM_CONSTANT_Fieldref) {
            if (_need_verify) {
              // Field name and signature are verified above, when iterating NameAndType_info.
              // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified">!             if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed">-                 signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {</span>
                throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
              }
            }
          } else {
            if (_need_verify) {
              // Method name and signature are verified above, when iterating NameAndType_info.
              // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified">!             if (signature-&gt;utf8_length() == 0 ||</span>
<span class="line-removed">-                 signature-&gt;char_at(0) != JVM_SIGNATURE_FUNC) {</span>
                throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
              }
            }
            // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
            const unsigned int name_len = name-&gt;utf8_length();
            if (tag == JVM_CONSTANT_Methodref &amp;&amp;
                name_len != 0 &amp;&amp;
<span class="line-modified">!               name-&gt;char_at(0) == &#39;&lt;&#39; &amp;&amp;</span>
                name != vmSymbols::object_initializer_name()) {
              classfile_parse_error(
                &quot;Bad method name at constant pool index %u in class file %s&quot;,
                name_ref_index, CHECK);
            }
<span class="line-new-header">--- 718,27 ---</span>
          const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
          if (tag == JVM_CONSTANT_Fieldref) {
            if (_need_verify) {
              // Field name and signature are verified above, when iterating NameAndType_info.
              // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified">!             if (Signature::is_method(signature)) {</span>
                throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
              }
            }
          } else {
            if (_need_verify) {
              // Method name and signature are verified above, when iterating NameAndType_info.
              // Need only to be sure signature is non-zero length and the right type.
<span class="line-modified">!             if (!Signature::is_method(signature)) {</span>
                throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
              }
            }
            // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
            const unsigned int name_len = name-&gt;utf8_length();
            if (tag == JVM_CONSTANT_Methodref &amp;&amp;
                name_len != 0 &amp;&amp;
<span class="line-modified">!               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;</span>
                name != vmSymbols::object_initializer_name()) {
              classfile_parse_error(
                &quot;Bad method name at constant pool index %u in class file %s&quot;,
                name_ref_index, CHECK);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,11 ***</span>
          patch_class(cp, index, k, k-&gt;name());
        } else {
          guarantee_property(java_lang_String::is_instance(patch()),
                             &quot;Illegal class patch at %d in class file %s&quot;,
                             index, CHECK);
<span class="line-modified">!         Symbol* const name = java_lang_String::as_symbol(patch(), CHECK);</span>
          patch_class(cp, index, NULL, name);
        }
        break;
      }
  
<span class="line-new-header">--- 826,11 ---</span>
          patch_class(cp, index, k, k-&gt;name());
        } else {
          guarantee_property(java_lang_String::is_instance(patch()),
                             &quot;Illegal class patch at %d in class file %s&quot;,
                             index, CHECK);
<span class="line-modified">!         Symbol* const name = java_lang_String::as_symbol(patch());</span>
          patch_class(cp, index, NULL, name);
        }
        break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1696,12 ***</span>
          parsed_annotations.set_tsan_ignore(true);
        }
      );
  
      // After field is initialized with type, we can augment it with aux info
<span class="line-modified">!     if (parsed_annotations.has_any_annotations())</span>
        parsed_annotations.apply_to(field);
    }
  
    int index = length;
    if (num_injected != 0) {
      for (int n = 0; n &lt; num_injected; n++) {
<span class="line-new-header">--- 1702,16 ---</span>
          parsed_annotations.set_tsan_ignore(true);
        }
      );
  
      // After field is initialized with type, we can augment it with aux info
<span class="line-modified">!     if (parsed_annotations.has_any_annotations()) {</span>
        parsed_annotations.apply_to(field);
<span class="line-added">+       if (field-&gt;is_contended()) {</span>
<span class="line-added">+         _has_contended_fields = true;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    }
  
    int index = length;
    if (num_injected != 0) {
      for (int n = 0; n &lt; num_injected; n++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1730,11 ***</span>
        field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
                          injected[n].name_index,
                          injected[n].signature_index,
                          0);
  
<span class="line-modified">!       const BasicType type = FieldType::basic_type(injected[n].signature());</span>
  
        // Remember how many oops we encountered and compute allocation type
        const FieldAllocationType atype = fac-&gt;update(false, type);
        field-&gt;set_allocation_type(atype);
        index++;
<span class="line-new-header">--- 1740,11 ---</span>
        field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
                          injected[n].name_index,
                          injected[n].signature_index,
                          0);
  
<span class="line-modified">!       const BasicType type = Signature::basic_type(injected[n].signature());</span>
  
        // Remember how many oops we encountered and compute allocation type
        const FieldAllocationType atype = fac-&gt;update(false, type);
        field-&gt;set_allocation_type(atype);
        index++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2471,21 ***</span>
                                CHECK_NULL);
        }
        parsed_code_attribute = true;
  
        // Stack size, locals size, and code size
<span class="line-modified">!       if (_major_version == 45 &amp;&amp; _minor_version &lt;= 2) {</span>
<span class="line-modified">!         cfs-&gt;guarantee_more(4, CHECK_NULL);</span>
<span class="line-modified">!         max_stack = cfs-&gt;get_u1_fast();</span>
<span class="line-modified">!         max_locals = cfs-&gt;get_u1_fast();</span>
<span class="line-removed">-         code_length = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         cfs-&gt;guarantee_more(8, CHECK_NULL);</span>
<span class="line-removed">-         max_stack = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">-         max_locals = cfs-&gt;get_u2_fast();</span>
<span class="line-removed">-         code_length = cfs-&gt;get_u4_fast();</span>
<span class="line-removed">-       }</span>
        if (_need_verify) {
          guarantee_property(args_size &lt;= max_locals,
                             &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
                             CHECK_NULL);
          guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
<span class="line-new-header">--- 2481,14 ---</span>
                                CHECK_NULL);
        }
        parsed_code_attribute = true;
  
        // Stack size, locals size, and code size
<span class="line-modified">!       cfs-&gt;guarantee_more(8, CHECK_NULL);</span>
<span class="line-modified">!       max_stack = cfs-&gt;get_u2_fast();</span>
<span class="line-modified">!       max_locals = cfs-&gt;get_u2_fast();</span>
<span class="line-modified">!       code_length = cfs-&gt;get_u4_fast();</span>
        if (_need_verify) {
          guarantee_property(args_size &lt;= max_locals,
                             &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
                             CHECK_NULL);
          guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2512,17 ***</span>
        cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
        u2 code_attributes_count = cfs-&gt;get_u2_fast();
  
        unsigned int calculated_attribute_length = 0;
  
<span class="line-modified">!       if (_major_version &gt; 45 || (_major_version == 45 &amp;&amp; _minor_version &gt; 2)) {</span>
<span class="line-modified">!         calculated_attribute_length =</span>
<span class="line-removed">-             sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         // max_stack, locals and length are smaller in pre-version 45.2 classes</span>
<span class="line-removed">-         calculated_attribute_length = sizeof(u1) + sizeof(u1) + sizeof(u2);</span>
<span class="line-removed">-       }</span>
        calculated_attribute_length +=
          code_length +
          sizeof(exception_table_length) +
          sizeof(code_attributes_count) +
          exception_table_length *
<span class="line-new-header">--- 2515,12 ---</span>
        cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
        u2 code_attributes_count = cfs-&gt;get_u2_fast();
  
        unsigned int calculated_attribute_length = 0;
  
<span class="line-modified">!       calculated_attribute_length =</span>
<span class="line-modified">!           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);</span>
        calculated_attribute_length +=
          code_length +
          sizeof(exception_table_length) +
          sizeof(code_attributes_count) +
          exception_table_length *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,25 ***</span>
  
    // Fill in information from fixed part (access_flags already set)
    m-&gt;set_constants(_cp);
    m-&gt;set_name_index(name_index);
    m-&gt;set_signature_index(signature_index);
<span class="line-modified">! </span>
<span class="line-modified">!   ResultTypeFinder rtf(cp-&gt;symbol_at(signature_index));</span>
<span class="line-removed">-   m-&gt;constMethod()-&gt;set_result_type(rtf.type());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (args_size &gt;= 0) {</span>
<span class="line-removed">-     m-&gt;set_size_of_parameters(args_size);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     m-&gt;compute_size_of_parameters(THREAD);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   if (args_size &gt;= 0) {</span>
<span class="line-removed">-     m-&gt;compute_size_of_parameters(THREAD);</span>
<span class="line-removed">-     assert(args_size == m-&gt;size_of_parameters(), &quot;&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
  
    // Fill in code attribute information
    m-&gt;set_max_stack(max_stack);
    m-&gt;set_max_locals(max_locals);
    if (stackmap_data != NULL) {
<span class="line-new-header">--- 2826,12 ---</span>
  
    // Fill in information from fixed part (access_flags already set)
    m-&gt;set_constants(_cp);
    m-&gt;set_name_index(name_index);
    m-&gt;set_signature_index(signature_index);
<span class="line-modified">!   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));</span>
<span class="line-modified">!   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);</span>
  
    // Fill in code attribute information
    m-&gt;set_max_stack(max_stack);
    m-&gt;set_max_locals(max_locals);
    if (stackmap_data != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2905,11 ***</span>
                               localvariable_type_table_start,
                               CHECK_NULL);
    }
  
    if (parsed_annotations.has_any_annotations())
<span class="line-modified">!     parsed_annotations.apply_to(m);</span>
  
    // Copy annotations
    copy_method_annotations(m-&gt;constMethod(),
                            runtime_visible_annotations,
                            runtime_visible_annotations_length,
<span class="line-new-header">--- 2890,11 ---</span>
                               localvariable_type_table_start,
                               CHECK_NULL);
    }
  
    if (parsed_annotations.has_any_annotations())
<span class="line-modified">!     parsed_annotations.apply_to(methodHandle(THREAD, m));</span>
  
    // Copy annotations
    copy_method_annotations(m-&gt;constMethod(),
                            runtime_visible_annotations,
                            runtime_visible_annotations_length,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3027,11 ***</span>
    // If JVMTI original method ordering or sharing is enabled we have to
    // remember the original class file ordering.
    // We temporarily use the vtable_index field in the Method* to store the
    // class file index, so we can read in after calling qsort.
    // Put the method ordering in the shared archive.
<span class="line-modified">!   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
      for (int index = 0; index &lt; length; index++) {
        Method* const m = methods-&gt;at(index);
        assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
        m-&gt;set_vtable_index(index);
      }
<span class="line-new-header">--- 3012,11 ---</span>
    // If JVMTI original method ordering or sharing is enabled we have to
    // remember the original class file ordering.
    // We temporarily use the vtable_index field in the Method* to store the
    // class file index, so we can read in after calling qsort.
    // Put the method ordering in the shared archive.
<span class="line-modified">!   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
      for (int index = 0; index &lt; length; index++) {
        Method* const m = methods-&gt;at(index);
        assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
        m-&gt;set_vtable_index(index);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3041,11 ***</span>
    Method::sort_methods(methods);
  
    intArray* method_ordering = NULL;
    // If JVMTI original method ordering or sharing is enabled construct int
    // array remembering the original ordering
<span class="line-modified">!   if (JvmtiExport::can_maintain_original_method_order() || DumpSharedSpaces) {</span>
      method_ordering = new intArray(length, length, -1);
      for (int index = 0; index &lt; length; index++) {
        Method* const m = methods-&gt;at(index);
        const int old_index = m-&gt;vtable_index();
        assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
<span class="line-new-header">--- 3026,11 ---</span>
    Method::sort_methods(methods);
  
    intArray* method_ordering = NULL;
    // If JVMTI original method ordering or sharing is enabled construct int
    // array remembering the original ordering
<span class="line-modified">!   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {</span>
      method_ordering = new intArray(length, length, -1);
      for (int index = 0; index &lt; length; index++) {
        Method* const m = methods-&gt;at(index);
        const int old_index = m-&gt;vtable_index();
        assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3246,10 ***</span>
<span class="line-new-header">--- 3231,177 ---</span>
    cfs-&gt;set_current(current_mark);
  
    return length;
  }
  
<span class="line-added">+ //  Record {</span>
<span class="line-added">+ //    u2 attribute_name_index;</span>
<span class="line-added">+ //    u4 attribute_length;</span>
<span class="line-added">+ //    u2 components_count;</span>
<span class="line-added">+ //    component_info components[components_count];</span>
<span class="line-added">+ //  }</span>
<span class="line-added">+ //  component_info {</span>
<span class="line-added">+ //    u2 name_index;</span>
<span class="line-added">+ //    u2 descriptor_index</span>
<span class="line-added">+ //    u2 attributes_count;</span>
<span class="line-added">+ //    attribute_info_attributes[attributes_count];</span>
<span class="line-added">+ //  }</span>
<span class="line-added">+ u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,</span>
<span class="line-added">+                                                      const ConstantPool* cp,</span>
<span class="line-added">+                                                      const u1* const record_attribute_start,</span>
<span class="line-added">+                                                      TRAPS) {</span>
<span class="line-added">+   const u1* const current_mark = cfs-&gt;current();</span>
<span class="line-added">+   int components_count = 0;</span>
<span class="line-added">+   unsigned int calculate_attr_size = 0;</span>
<span class="line-added">+   if (record_attribute_start != NULL) {</span>
<span class="line-added">+     cfs-&gt;set_current(record_attribute_start);</span>
<span class="line-added">+     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components</span>
<span class="line-added">+     components_count = (int)cfs-&gt;get_u2_fast();</span>
<span class="line-added">+     calculate_attr_size = 2;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Array&lt;RecordComponent*&gt;* const record_components =</span>
<span class="line-added">+     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);</span>
<span class="line-added">+   _record_components = record_components;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (int x = 0; x &lt; components_count; x++) {</span>
<span class="line-added">+     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count</span>
<span class="line-added">+ </span>
<span class="line-added">+     const u2 name_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">+     check_property(valid_symbol_at(name_index),</span>
<span class="line-added">+       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,</span>
<span class="line-added">+       name_index, CHECK_0);</span>
<span class="line-added">+     const Symbol* const name = cp-&gt;symbol_at(name_index);</span>
<span class="line-added">+     verify_legal_field_name(name, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const u2 descriptor_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">+     check_property(valid_symbol_at(descriptor_index),</span>
<span class="line-added">+       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,</span>
<span class="line-added">+       descriptor_index, CHECK_0);</span>
<span class="line-added">+     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);</span>
<span class="line-added">+     verify_legal_field_signature(name, descr, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const u2 attributes_count = cfs-&gt;get_u2_fast();</span>
<span class="line-added">+     calculate_attr_size += 6;</span>
<span class="line-added">+     u2 generic_sig_index = 0;</span>
<span class="line-added">+     const u1* runtime_visible_annotations = NULL;</span>
<span class="line-added">+     int runtime_visible_annotations_length = 0;</span>
<span class="line-added">+     const u1* runtime_invisible_annotations = NULL;</span>
<span class="line-added">+     int runtime_invisible_annotations_length = 0;</span>
<span class="line-added">+     bool runtime_invisible_annotations_exists = false;</span>
<span class="line-added">+     const u1* runtime_visible_type_annotations = NULL;</span>
<span class="line-added">+     int runtime_visible_type_annotations_length = 0;</span>
<span class="line-added">+     const u1* runtime_invisible_type_annotations = NULL;</span>
<span class="line-added">+     int runtime_invisible_type_annotations_length = 0;</span>
<span class="line-added">+     bool runtime_invisible_type_annotations_exists = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,</span>
<span class="line-added">+     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.</span>
<span class="line-added">+     for (int y = 0; y &lt; attributes_count; y++) {</span>
<span class="line-added">+       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length</span>
<span class="line-added">+       const u2 attribute_name_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">+       const u4 attribute_length = cfs-&gt;get_u4_fast();</span>
<span class="line-added">+       calculate_attr_size += 6;</span>
<span class="line-added">+       check_property(</span>
<span class="line-added">+         valid_symbol_at(attribute_name_index),</span>
<span class="line-added">+         &quot;Invalid Record attribute name index %u in class file %s&quot;,</span>
<span class="line-added">+         attribute_name_index, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);</span>
<span class="line-added">+       if (attribute_name == vmSymbols::tag_signature()) {</span>
<span class="line-added">+         if (generic_sig_index != 0) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Multiple Signature attributes for Record component in class file %s&quot;,</span>
<span class="line-added">+             CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (attribute_length != 2) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,</span>
<span class="line-added">+             attribute_length, CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {</span>
<span class="line-added">+         if (runtime_visible_annotations != NULL) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         runtime_visible_annotations_length = attribute_length;</span>
<span class="line-added">+         runtime_visible_annotations = cfs-&gt;current();</span>
<span class="line-added">+ </span>
<span class="line-added">+         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);</span>
<span class="line-added">+         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);</span>
<span class="line-added">+         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {</span>
<span class="line-added">+         if (runtime_invisible_annotations_exists) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         runtime_invisible_annotations_exists = true;</span>
<span class="line-added">+         if (PreserveAllAnnotations) {</span>
<span class="line-added">+           runtime_invisible_annotations_length = attribute_length;</span>
<span class="line-added">+           runtime_invisible_annotations = cfs-&gt;current();</span>
<span class="line-added">+           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {</span>
<span class="line-added">+         if (runtime_visible_type_annotations != NULL) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         runtime_visible_type_annotations_length = attribute_length;</span>
<span class="line-added">+         runtime_visible_type_annotations = cfs-&gt;current();</span>
<span class="line-added">+ </span>
<span class="line-added">+         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);</span>
<span class="line-added">+         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);</span>
<span class="line-added">+         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {</span>
<span class="line-added">+         if (runtime_invisible_type_annotations_exists) {</span>
<span class="line-added">+           classfile_parse_error(</span>
<span class="line-added">+             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         runtime_invisible_type_annotations_exists = true;</span>
<span class="line-added">+         if (PreserveAllAnnotations) {</span>
<span class="line-added">+           runtime_invisible_type_annotations_length = attribute_length;</span>
<span class="line-added">+           runtime_invisible_type_annotations = cfs-&gt;current();</span>
<span class="line-added">+           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         // Skip unknown attributes</span>
<span class="line-added">+         cfs-&gt;skip_u1(attribute_length, CHECK_0);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       calculate_attr_size += attribute_length;</span>
<span class="line-added">+     } // End of attributes For loop</span>
<span class="line-added">+ </span>
<span class="line-added">+     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-added">+                                                         runtime_visible_annotations_length,</span>
<span class="line-added">+                                                         runtime_invisible_annotations,</span>
<span class="line-added">+                                                         runtime_invisible_annotations_length,</span>
<span class="line-added">+                                                         CHECK_0);</span>
<span class="line-added">+     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-added">+                                                              runtime_visible_type_annotations_length,</span>
<span class="line-added">+                                                              runtime_invisible_type_annotations,</span>
<span class="line-added">+                                                              runtime_invisible_type_annotations_length,</span>
<span class="line-added">+                                                              CHECK_0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     RecordComponent* record_component =</span>
<span class="line-added">+       RecordComponent::allocate(_loader_data, name_index, descriptor_index,</span>
<span class="line-added">+                                 attributes_count, generic_sig_index,</span>
<span class="line-added">+                                 annotations, type_annotations, CHECK_0);</span>
<span class="line-added">+     record_components-&gt;at_put(x, record_component);</span>
<span class="line-added">+   }  // End of component processing loop</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Restore buffer&#39;s current position.</span>
<span class="line-added">+   cfs-&gt;set_current(current_mark);</span>
<span class="line-added">+   return calculate_attr_size;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
    set_class_synthetic_flag(true);
  }
  
  void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3343,10 ***</span>
<span class="line-new-header">--- 3495,16 ---</span>
    guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
                       &quot;Bad length on BootstrapMethods in class file %s&quot;,
                       CHECK);
  }
  
<span class="line-added">+ bool ClassFileParser::supports_records() {</span>
<span class="line-added">+   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
<span class="line-added">+     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-added">+     Arguments::enable_preview();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
                                                   ConstantPool* cp,
                   ClassFileParser::ClassAnnotationCollector* parsed_annotations,
                                                   TRAPS) {
    assert(cfs != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3361,10 ***</span>
<span class="line-new-header">--- 3519,11 ---</span>
    u2 attributes_count = cfs-&gt;get_u2_fast();
    bool parsed_sourcefile_attribute = false;
    bool parsed_innerclasses_attribute = false;
    bool parsed_nest_members_attribute = false;
    bool parsed_nest_host_attribute = false;
<span class="line-added">+   bool parsed_record_attribute = false;</span>
    bool parsed_enclosingmethod_attribute = false;
    bool parsed_bootstrap_methods_attribute = false;
    const u1* runtime_visible_annotations = NULL;
    int runtime_visible_annotations_length = 0;
    const u1* runtime_invisible_annotations = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3380,10 ***</span>
<span class="line-new-header">--- 3539,12 ---</span>
    u4  inner_classes_attribute_length = 0;
    u2  enclosing_method_class_index = 0;
    u2  enclosing_method_method_index = 0;
    const u1* nest_members_attribute_start = NULL;
    u4  nest_members_attribute_length = 0;
<span class="line-added">+   const u1* record_attribute_start = NULL;</span>
<span class="line-added">+   u4  record_attribute_length = 0;</span>
  
    // Iterate over attributes
    while (attributes_count--) {
      cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
      const u2 attribute_name_index = cfs-&gt;get_u2_fast();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3562,10 ***</span>
<span class="line-new-header">--- 3723,47 ---</span>
            check_property(
                           valid_klass_reference_at(class_info_index),
                           &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
                           class_info_index, CHECK);
            _nest_host = class_info_index;
<span class="line-added">+         } else if (_major_version &gt;= JAVA_14_VERSION) {</span>
<span class="line-added">+           if (tag == vmSymbols::tag_record()) {</span>
<span class="line-added">+             // Skip over Record attribute if not supported or if super class is</span>
<span class="line-added">+             // not java.lang.Record.</span>
<span class="line-added">+             if (supports_records() &amp;&amp;</span>
<span class="line-added">+                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {</span>
<span class="line-added">+               if (parsed_record_attribute) {</span>
<span class="line-added">+                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);</span>
<span class="line-added">+               }</span>
<span class="line-added">+               // Check that class is final and not abstract.</span>
<span class="line-added">+               if (!_access_flags.is_final() || _access_flags.is_abstract()) {</span>
<span class="line-added">+                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);</span>
<span class="line-added">+               }</span>
<span class="line-added">+               parsed_record_attribute = true;</span>
<span class="line-added">+               record_attribute_start = cfs-&gt;current();</span>
<span class="line-added">+               record_attribute_length = attribute_length;</span>
<span class="line-added">+             } else if (log_is_enabled(Info, class, record)) {</span>
<span class="line-added">+               // Log why the Record attribute was ignored.  Note that if the</span>
<span class="line-added">+               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and</span>
<span class="line-added">+               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError</span>
<span class="line-added">+               // exception would have been thrown.</span>
<span class="line-added">+               ResourceMark rm(THREAD);</span>
<span class="line-added">+               if (supports_records()) {</span>
<span class="line-added">+                 log_info(class, record)(</span>
<span class="line-added">+                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,</span>
<span class="line-added">+                   _class_name-&gt;as_C_string());</span>
<span class="line-added">+               } else {</span>
<span class="line-added">+                 log_info(class, record)(</span>
<span class="line-added">+                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,</span>
<span class="line-added">+                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-added">+               }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             // Unknown attribute</span>
<span class="line-added">+             cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">+           }</span>
          } else {
            // Unknown attribute
            cfs-&gt;skip_u1(attribute_length, CHECK);
          }
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3575,20 ***</span>
      } else {
        // Unknown attribute
        cfs-&gt;skip_u1(attribute_length, CHECK);
      }
    }
<span class="line-modified">!   _annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-modified">!                                       runtime_visible_annotations_length,</span>
<span class="line-modified">!                                       runtime_invisible_annotations,</span>
<span class="line-modified">!                                       runtime_invisible_annotations_length,</span>
<span class="line-modified">!                                       CHECK);</span>
<span class="line-modified">!   _type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-modified">!                                            runtime_visible_type_annotations_length,</span>
<span class="line-modified">!                                            runtime_invisible_type_annotations,</span>
<span class="line-modified">!                                            runtime_invisible_type_annotations_length,</span>
<span class="line-modified">!                                            CHECK);</span>
  
    if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
      const u2 num_of_classes = parse_classfile_inner_classes_attribute(
                              cfs,
                              inner_classes_attribute_start,
<span class="line-new-header">--- 3773,20 ---</span>
      } else {
        // Unknown attribute
        cfs-&gt;skip_u1(attribute_length, CHECK);
      }
    }
<span class="line-modified">!   _class_annotations = assemble_annotations(runtime_visible_annotations,</span>
<span class="line-modified">!                                             runtime_visible_annotations_length,</span>
<span class="line-modified">!                                             runtime_invisible_annotations,</span>
<span class="line-modified">!                                             runtime_invisible_annotations_length,</span>
<span class="line-modified">!                                             CHECK);</span>
<span class="line-modified">!   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,</span>
<span class="line-modified">!                                                  runtime_visible_type_annotations_length,</span>
<span class="line-modified">!                                                  runtime_invisible_type_annotations,</span>
<span class="line-modified">!                                                  runtime_invisible_type_annotations_length,</span>
<span class="line-modified">!                                                  CHECK);</span>
  
    if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
      const u2 num_of_classes = parse_classfile_inner_classes_attribute(
                              cfs,
                              inner_classes_attribute_start,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3613,10 ***</span>
<span class="line-new-header">--- 3811,23 ---</span>
          nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
          &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
      }
    }
  
<span class="line-added">+   if (parsed_record_attribute) {</span>
<span class="line-added">+     const unsigned int calculated_attr_length = parse_classfile_record_attribute(</span>
<span class="line-added">+                             cfs,</span>
<span class="line-added">+                             cp,</span>
<span class="line-added">+                             record_attribute_start,</span>
<span class="line-added">+                             CHECK);</span>
<span class="line-added">+     if (_need_verify) {</span>
<span class="line-added">+       guarantee_property(record_attribute_length == calculated_attr_length,</span>
<span class="line-added">+                          &quot;Record attribute has wrong length in class file %s&quot;,</span>
<span class="line-added">+                          CHECK);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (_max_bootstrap_specifier_index &gt;= 0) {
      guarantee_property(parsed_bootstrap_methods_attribute,
                         &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3638,40 ***</span>
  }
  
  // Create the Annotations object that will
  // hold the annotations array for the Klass.
  void ClassFileParser::create_combined_annotations(TRAPS) {
<span class="line-modified">!     if (_annotations == NULL &amp;&amp;</span>
<span class="line-modified">!         _type_annotations == NULL &amp;&amp;</span>
          _fields_annotations == NULL &amp;&amp;
          _fields_type_annotations == NULL) {
        // Don&#39;t create the Annotations object unnecessarily.
        return;
      }
  
      Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
<span class="line-modified">!     annotations-&gt;set_class_annotations(_annotations);</span>
<span class="line-modified">!     annotations-&gt;set_class_type_annotations(_type_annotations);</span>
      annotations-&gt;set_fields_annotations(_fields_annotations);
      annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
  
      // This is the Annotations object that will be
      // assigned to InstanceKlass being constructed.
      _combined_annotations = annotations;
  
      // The annotations arrays below has been transfered the
      // _combined_annotations so these fields can now be cleared.
<span class="line-modified">!     _annotations             = NULL;</span>
<span class="line-modified">!     _type_annotations        = NULL;</span>
      _fields_annotations      = NULL;
      _fields_type_annotations = NULL;
  }
  
  // Transfer ownership of metadata allocated to the InstanceKlass.
  void ClassFileParser::apply_parsed_class_metadata(
                                              InstanceKlass* this_klass,
<span class="line-modified">!                                             int java_fields_count, TRAPS) {</span>
    assert(this_klass != NULL, &quot;invariant&quot;);
  
    _cp-&gt;set_pool_holder(this_klass);
    this_klass-&gt;set_constants(_cp);
    this_klass-&gt;set_fields(_fields, java_fields_count);
<span class="line-new-header">--- 3849,41 ---</span>
  }
  
  // Create the Annotations object that will
  // hold the annotations array for the Klass.
  void ClassFileParser::create_combined_annotations(TRAPS) {
<span class="line-modified">!     if (_class_annotations == NULL &amp;&amp;</span>
<span class="line-modified">!         _class_type_annotations == NULL &amp;&amp;</span>
          _fields_annotations == NULL &amp;&amp;
          _fields_type_annotations == NULL) {
        // Don&#39;t create the Annotations object unnecessarily.
        return;
      }
  
      Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
<span class="line-modified">!     annotations-&gt;set_class_annotations(_class_annotations);</span>
<span class="line-modified">!     annotations-&gt;set_class_type_annotations(_class_type_annotations);</span>
      annotations-&gt;set_fields_annotations(_fields_annotations);
      annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
  
      // This is the Annotations object that will be
      // assigned to InstanceKlass being constructed.
      _combined_annotations = annotations;
  
      // The annotations arrays below has been transfered the
      // _combined_annotations so these fields can now be cleared.
<span class="line-modified">!     _class_annotations       = NULL;</span>
<span class="line-modified">!     _class_type_annotations  = NULL;</span>
      _fields_annotations      = NULL;
      _fields_type_annotations = NULL;
  }
  
  // Transfer ownership of metadata allocated to the InstanceKlass.
  void ClassFileParser::apply_parsed_class_metadata(
                                              InstanceKlass* this_klass,
<span class="line-modified">!                                             int java_fields_count,</span>
<span class="line-added">+                                             TRAPS) {</span>
    assert(this_klass != NULL, &quot;invariant&quot;);
  
    _cp-&gt;set_pool_holder(this_klass);
    this_klass-&gt;set_constants(_cp);
    this_klass-&gt;set_fields(_fields, java_fields_count);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3679,10 ***</span>
<span class="line-new-header">--- 3891,11 ---</span>
    this_klass-&gt;set_inner_classes(_inner_classes);
    this_klass-&gt;set_nest_members(_nest_members);
    this_klass-&gt;set_nest_host_index(_nest_host);
    this_klass-&gt;set_local_interfaces(_local_interfaces);
    this_klass-&gt;set_annotations(_combined_annotations);
<span class="line-added">+   this_klass-&gt;set_record_components(_record_components);</span>
    // Delay the setting of _transitive_interfaces until after initialize_supers() in
    // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
    // its _super. If an OOM occurs while loading the current klass, its _super field
    // may not have been set. When GC tries to free the klass, the _transitive_interfaces
    // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3752,47 ***</span>
      }
    }
    return super_klass;
  }
  
<span class="line-removed">- static unsigned int compute_oop_map_count(const InstanceKlass* super,</span>
<span class="line-removed">-                                           unsigned int nonstatic_oop_map_count,</span>
<span class="line-removed">-                                           int first_nonstatic_oop_offset) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   unsigned int map_count =</span>
<span class="line-removed">-     NULL == super ? 0 : super-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">-   if (nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-removed">-     // We have oops to add to map</span>
<span class="line-removed">-     if (map_count == 0) {</span>
<span class="line-removed">-       map_count = nonstatic_oop_map_count;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-       // Check whether we should add a new map block or whether the last one can</span>
<span class="line-removed">-       // be extended</span>
<span class="line-removed">-       const OopMapBlock* const first_map = super-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">-       const OopMapBlock* const last_map = first_map + map_count - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       const int next_offset = last_map-&gt;offset() + last_map-&gt;count() * heapOopSize;</span>
<span class="line-removed">-       if (next_offset == first_nonstatic_oop_offset) {</span>
<span class="line-removed">-         // There is no gap bettwen superklass&#39;s last oop field and first</span>
<span class="line-removed">-         // local oop field, merge maps.</span>
<span class="line-removed">-         nonstatic_oop_map_count -= 1;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       else {</span>
<span class="line-removed">-         // Superklass didn&#39;t end with a oop field, add extra maps</span>
<span class="line-removed">-         assert(next_offset &lt; first_nonstatic_oop_offset, &quot;just checking&quot;);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       map_count += nonstatic_oop_map_count;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return map_count;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #ifndef PRODUCT
  static void print_field_layout(const Symbol* name,
                                 Array&lt;u2&gt;* fields,
<span class="line-modified">!                                const constantPoolHandle&amp; cp,</span>
                                 int instance_size,
                                 int instance_fields_start,
                                 int instance_fields_end,
                                 int static_fields_end) {
  
<span class="line-new-header">--- 3965,14 ---</span>
      }
    }
    return super_klass;
  }
  
  #ifndef PRODUCT
  static void print_field_layout(const Symbol* name,
                                 Array&lt;u2&gt;* fields,
<span class="line-modified">!                                ConstantPool* cp,</span>
                                 int instance_size,
                                 int instance_fields_start,
                                 int instance_fields_end,
                                 int static_fields_end) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3822,22 ***</span>
    tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
    tty-&gt;print(&quot;\n&quot;);
  }
  #endif
  
<span class="line-modified">! // Values needed for oopmap and InstanceKlass creation</span>
<span class="line-modified">! class ClassFileParser::FieldLayoutInfo : public ResourceObj {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   int*          nonstatic_oop_offsets;</span>
<span class="line-modified">!   unsigned int* nonstatic_oop_counts;</span>
<span class="line-modified">!   unsigned int  nonstatic_oop_map_count;</span>
<span class="line-modified">!   unsigned int  total_oop_map_count;</span>
<span class="line-modified">!   int           instance_size;</span>
<span class="line-modified">!   int           nonstatic_field_size;</span>
<span class="line-modified">!   int           static_field_size;</span>
<span class="line-modified">!   bool          has_nonstatic_fields;</span>
<span class="line-modified">! };</span>
  
  // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
  void ClassFileParser::layout_fields(ConstantPool* cp,
                                      const FieldAllocationCount* fac,
                                      const ClassAnnotationCollector* parsed_annotations,
<span class="line-new-header">--- 4002,125 ---</span>
    tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
    tty-&gt;print(&quot;\n&quot;);
  }
  #endif
  
<span class="line-modified">! OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {</span>
<span class="line-modified">!   _max_nonstatic_oop_maps = max_blocks;</span>
<span class="line-modified">!   _nonstatic_oop_map_count = 0;</span>
<span class="line-modified">!   if (max_blocks == 0) {</span>
<span class="line-modified">!     _nonstatic_oop_maps = NULL;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     _nonstatic_oop_maps =</span>
<span class="line-modified">!         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);</span>
<span class="line-modified">!     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {</span>
<span class="line-added">+   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);</span>
<span class="line-added">+   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // addition of super oop maps</span>
<span class="line-added">+ void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {</span>
<span class="line-added">+   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;</span>
<span class="line-added">+          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);</span>
<span class="line-added">+   _nonstatic_oop_map_count += nof_blocks;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // collection of oops</span>
<span class="line-added">+ void OopMapBlocksBuilder::add(int offset, int count) {</span>
<span class="line-added">+   if (_nonstatic_oop_map_count == 0) {</span>
<span class="line-added">+     _nonstatic_oop_map_count++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   OopMapBlock* nonstatic_oop_map = last_oop_map();</span>
<span class="line-added">+   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up</span>
<span class="line-added">+     nonstatic_oop_map-&gt;set_offset(offset);</span>
<span class="line-added">+     nonstatic_oop_map-&gt;set_count(count);</span>
<span class="line-added">+   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add</span>
<span class="line-added">+     nonstatic_oop_map-&gt;increment_count(count);</span>
<span class="line-added">+   } else { // Need a new one...</span>
<span class="line-added">+     _nonstatic_oop_map_count++;</span>
<span class="line-added">+     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-added">+     nonstatic_oop_map = last_oop_map();</span>
<span class="line-added">+     nonstatic_oop_map-&gt;set_offset(offset);</span>
<span class="line-added">+     nonstatic_oop_map-&gt;set_count(count);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // general purpose copy, e.g. into allocated instanceKlass</span>
<span class="line-added">+ void OopMapBlocksBuilder::copy(OopMapBlock* dst) {</span>
<span class="line-added">+   if (_nonstatic_oop_map_count != 0) {</span>
<span class="line-added">+     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Sort and compact adjacent blocks</span>
<span class="line-added">+ void OopMapBlocksBuilder::compact() {</span>
<span class="line-added">+   if (_nonstatic_oop_map_count &lt;= 1) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * Since field layout sneeks in oops before values, we will be able to condense</span>
<span class="line-added">+    * blocks. There is potential to compact between super, own refs and values</span>
<span class="line-added">+    * containing refs.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * Currently compaction is slightly limited due to values being 8 byte aligned.</span>
<span class="line-added">+    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose</span>
<span class="line-added">+    * and maybe it doesn&#39;t need to be.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),</span>
<span class="line-added">+         (_sort_Fn)OopMapBlock::compare_offset);</span>
<span class="line-added">+   if (_nonstatic_oop_map_count &lt; 2) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Make a temp copy, and iterate through and copy back into the original</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   OopMapBlock* oop_maps_copy =</span>
<span class="line-added">+       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);</span>
<span class="line-added">+   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;</span>
<span class="line-added">+   copy(oop_maps_copy);</span>
<span class="line-added">+   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;</span>
<span class="line-added">+   unsigned int new_count = 1;</span>
<span class="line-added">+   oop_maps_copy++;</span>
<span class="line-added">+   while(oop_maps_copy &lt; oop_maps_copy_end) {</span>
<span class="line-added">+     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);</span>
<span class="line-added">+     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {</span>
<span class="line-added">+       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       nonstatic_oop_map++;</span>
<span class="line-added">+       new_count++;</span>
<span class="line-added">+       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());</span>
<span class="line-added">+       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     oop_maps_copy++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);</span>
<span class="line-added">+   _nonstatic_oop_map_count = new_count;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OopMapBlocksBuilder::print_on(outputStream* st) const {</span>
<span class="line-added">+   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);</span>
<span class="line-added">+   if (_nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-added">+     OopMapBlock* map = _nonstatic_oop_maps;</span>
<span class="line-added">+     OopMapBlock* last_map = last_oop_map();</span>
<span class="line-added">+     assert(map &lt;= last_map, &quot;Last less than first&quot;);</span>
<span class="line-added">+     while (map &lt;= last_map) {</span>
<span class="line-added">+       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),</span>
<span class="line-added">+                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());</span>
<span class="line-added">+       map++;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OopMapBlocksBuilder::print_value_on(outputStream* st) const {</span>
<span class="line-added">+   print_on(st);</span>
<span class="line-added">+ }</span>
  
  // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
  void ClassFileParser::layout_fields(ConstantPool* cp,
                                      const FieldAllocationCount* fac,
                                      const ClassAnnotationCollector* parsed_annotations,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3920,87 ***</span>
    // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
    // regions. offset[i] is the start of the i-th region, which then has
    // count[i] oops following. Before we know how many regions are required,
    // we pessimistically allocate the maps to fit all the oops into the
    // distinct regions.
<span class="line-removed">-   //</span>
<span class="line-removed">-   // TODO: We add +1 to always allocate non-zero resource arrays; we need</span>
<span class="line-removed">-   // to figure out if we still need to do this.</span>
<span class="line-removed">-   unsigned int nonstatic_oop_map_count = 0;</span>
<span class="line-removed">-   unsigned int max_nonstatic_oop_maps  = fac-&gt;count[NONSTATIC_OOP] + 1;</span>
  
<span class="line-modified">!   int* nonstatic_oop_offsets = NEW_RESOURCE_ARRAY_IN_THREAD(</span>
<span class="line-modified">!             THREAD, int, max_nonstatic_oop_maps);</span>
<span class="line-modified">!   unsigned int* const nonstatic_oop_counts  = NEW_RESOURCE_ARRAY_IN_THREAD(</span>
<span class="line-modified">!             THREAD, unsigned int, max_nonstatic_oop_maps);</span>
  
    int first_nonstatic_oop_offset = 0; // will be set for first oop field
  
<span class="line-modified">!   bool compact_fields   = CompactFields;</span>
<span class="line-modified">!   int allocation_style = FieldsAllocationStyle;</span>
<span class="line-removed">-   if( allocation_style &lt; 0 || allocation_style &gt; 2 ) { // Out of range?</span>
<span class="line-removed">-     assert(false, &quot;0 &lt;= FieldsAllocationStyle &lt;= 2&quot;);</span>
<span class="line-removed">-     allocation_style = 1; // Optimistic</span>
<span class="line-removed">-   }</span>
  
    // The next classes have predefined hard-coded fields offsets
    // (see in JavaClasses::compute_hard_coded_offsets()).
    // Use default fields allocation order for them.
<span class="line-modified">!   if( (allocation_style != 0 || compact_fields ) &amp;&amp; _loader_data-&gt;class_loader() == NULL &amp;&amp;</span>
<span class="line-modified">!       (_class_name == vmSymbols::java_lang_AssertionStatusDirectives() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_Class() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_ClassLoader() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_ref_Reference() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_ref_SoftReference() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_StackTraceElement() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_String() ||</span>
<span class="line-removed">-        _class_name == vmSymbols::java_lang_Throwable() ||</span>
         _class_name == vmSymbols::java_lang_Boolean() ||
         _class_name == vmSymbols::java_lang_Character() ||
         _class_name == vmSymbols::java_lang_Float() ||
         _class_name == vmSymbols::java_lang_Double() ||
         _class_name == vmSymbols::java_lang_Byte() ||
         _class_name == vmSymbols::java_lang_Short() ||
         _class_name == vmSymbols::java_lang_Integer() ||
         _class_name == vmSymbols::java_lang_Long())) {
<span class="line-modified">!     allocation_style = 0;     // Allocate oops first</span>
      compact_fields   = false; // Don&#39;t compact fields
    }
  
    int next_nonstatic_oop_offset = 0;
    int next_nonstatic_double_offset = 0;
  
    // Rearrange fields for a given allocation style
<span class="line-modified">!   if( allocation_style == 0 ) {</span>
      // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
      next_nonstatic_oop_offset    = next_nonstatic_field_offset;
      next_nonstatic_double_offset = next_nonstatic_oop_offset +
                                      (nonstatic_oop_count * heapOopSize);
<span class="line-modified">!   } else if( allocation_style == 1 ) {</span>
      // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
      next_nonstatic_double_offset = next_nonstatic_field_offset;
<span class="line-removed">-   } else if( allocation_style == 2 ) {</span>
<span class="line-removed">-     // Fields allocation: oops fields in super and sub classes are together.</span>
<span class="line-removed">-     if( nonstatic_field_size &gt; 0 &amp;&amp; _super_klass != NULL &amp;&amp;</span>
<span class="line-removed">-         _super_klass-&gt;nonstatic_oop_map_size() &gt; 0 ) {</span>
<span class="line-removed">-       const unsigned int map_count = _super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-removed">-       const OopMapBlock* const first_map = _super_klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">-       const OopMapBlock* const last_map = first_map + map_count - 1;</span>
<span class="line-removed">-       const int next_offset = last_map-&gt;offset() + (last_map-&gt;count() * heapOopSize);</span>
<span class="line-removed">-       if (next_offset == next_nonstatic_field_offset) {</span>
<span class="line-removed">-         allocation_style = 0;   // allocate oops first</span>
<span class="line-removed">-         next_nonstatic_oop_offset    = next_nonstatic_field_offset;</span>
<span class="line-removed">-         next_nonstatic_double_offset = next_nonstatic_oop_offset +</span>
<span class="line-removed">-                                        (nonstatic_oop_count * heapOopSize);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if( allocation_style == 2 ) {</span>
<span class="line-removed">-       allocation_style = 1;     // allocate oops last</span>
<span class="line-removed">-       next_nonstatic_double_offset = next_nonstatic_field_offset;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     ShouldNotReachHere();</span>
    }
  
    int nonstatic_oop_space_count   = 0;
    int nonstatic_word_space_count  = 0;
    int nonstatic_short_space_count = 0;
<span class="line-new-header">--- 4203,54 ---</span>
    // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
    // regions. offset[i] is the start of the i-th region, which then has
    // count[i] oops following. Before we know how many regions are required,
    // we pessimistically allocate the maps to fit all the oops into the
    // distinct regions.
  
<span class="line-modified">!   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-modified">!   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>
<span class="line-modified">! </span>
<span class="line-modified">!   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);</span>
<span class="line-added">+   if (super_oop_map_count &gt; 0) {</span>
<span class="line-added">+     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),</span>
<span class="line-added">+                                                     _super_klass-&gt;nonstatic_oop_map_count());</span>
<span class="line-added">+   }</span>
  
    int first_nonstatic_oop_offset = 0; // will be set for first oop field
  
<span class="line-modified">!   bool compact_fields  = true;</span>
<span class="line-modified">!   bool allocate_oops_first = false;</span>
  
    // The next classes have predefined hard-coded fields offsets
    // (see in JavaClasses::compute_hard_coded_offsets()).
    // Use default fields allocation order for them.
<span class="line-modified">!   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;</span>
<span class="line-modified">!       (_class_name == vmSymbols::java_lang_ref_Reference() ||</span>
         _class_name == vmSymbols::java_lang_Boolean() ||
         _class_name == vmSymbols::java_lang_Character() ||
         _class_name == vmSymbols::java_lang_Float() ||
         _class_name == vmSymbols::java_lang_Double() ||
         _class_name == vmSymbols::java_lang_Byte() ||
         _class_name == vmSymbols::java_lang_Short() ||
         _class_name == vmSymbols::java_lang_Integer() ||
         _class_name == vmSymbols::java_lang_Long())) {
<span class="line-modified">!     allocate_oops_first = true;     // Allocate oops first</span>
      compact_fields   = false; // Don&#39;t compact fields
    }
  
    int next_nonstatic_oop_offset = 0;
    int next_nonstatic_double_offset = 0;
  
    // Rearrange fields for a given allocation style
<span class="line-modified">!   if (allocate_oops_first) {</span>
      // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
      next_nonstatic_oop_offset    = next_nonstatic_field_offset;
      next_nonstatic_double_offset = next_nonstatic_oop_offset +
                                      (nonstatic_oop_count * heapOopSize);
<span class="line-modified">!   } else {</span>
      // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
      next_nonstatic_double_offset = next_nonstatic_field_offset;
    }
  
    int nonstatic_oop_space_count   = 0;
    int nonstatic_word_space_count  = 0;
    int nonstatic_short_space_count = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4040,11 ***</span>
          length -= 1;
        }
        // Allocate oop field in the gap if there are no other fields for that.
        nonstatic_oop_space_offset = offset;
        if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
<span class="line-modified">!           allocation_style != 0) { // when oop fields not first</span>
          nonstatic_oop_count      -= 1;
          nonstatic_oop_space_count = 1; // Only one will fit
          length -= heapOopSize;
          offset += heapOopSize;
        }
<span class="line-new-header">--- 4290,11 ---</span>
          length -= 1;
        }
        // Allocate oop field in the gap if there are no other fields for that.
        nonstatic_oop_space_offset = offset;
        if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
<span class="line-modified">!           !allocate_oops_first) { // when oop fields not first</span>
          nonstatic_oop_count      -= 1;
          nonstatic_oop_space_count = 1; // Only one will fit
          length -= heapOopSize;
          offset += heapOopSize;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4059,11 ***</span>
                                       (nonstatic_short_count * BytesPerShort);
    int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
                                         nonstatic_byte_count;
  
    // let oops jump before padding with this allocation style
<span class="line-modified">!   if( allocation_style == 1 ) {</span>
      next_nonstatic_oop_offset = next_nonstatic_padded_offset;
      if( nonstatic_oop_count &gt; 0 ) {
        next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
      }
      next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
<span class="line-new-header">--- 4309,11 ---</span>
                                       (nonstatic_short_count * BytesPerShort);
    int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
                                         nonstatic_byte_count;
  
    // let oops jump before padding with this allocation style
<span class="line-modified">!   if (!allocate_oops_first) {</span>
      next_nonstatic_oop_offset = next_nonstatic_padded_offset;
      if( nonstatic_oop_count &gt; 0 ) {
        next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
      }
      next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4112,30 ***</span>
            nonstatic_oop_space_count  -= 1;
          } else {
            real_offset = next_nonstatic_oop_offset;
            next_nonstatic_oop_offset += heapOopSize;
          }
<span class="line-modified">! </span>
<span class="line-removed">-         // Record this oop in the oop maps</span>
<span class="line-removed">-         if( nonstatic_oop_map_count &gt; 0 &amp;&amp;</span>
<span class="line-removed">-             nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==</span>
<span class="line-removed">-             real_offset -</span>
<span class="line-removed">-             int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *</span>
<span class="line-removed">-             heapOopSize ) {</span>
<span class="line-removed">-           // This oop is adjacent to the previous one, add to current oop map</span>
<span class="line-removed">-           assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">-           nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           // This oop is not adjacent to the previous one, create new oop map</span>
<span class="line-removed">-           assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">-           nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;</span>
<span class="line-removed">-           nonstatic_oop_counts [nonstatic_oop_map_count] = 1;</span>
<span class="line-removed">-           nonstatic_oop_map_count += 1;</span>
<span class="line-removed">-           if( first_nonstatic_oop_offset == 0 ) { // Undefined</span>
<span class="line-removed">-             first_nonstatic_oop_offset = real_offset;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
          break;
        case NONSTATIC_BYTE:
          if( nonstatic_byte_space_count &gt; 0 ) {
            real_offset = nonstatic_byte_space_offset;
            nonstatic_byte_space_offset += 1;
<span class="line-new-header">--- 4362,11 ---</span>
            nonstatic_oop_space_count  -= 1;
          } else {
            real_offset = next_nonstatic_oop_offset;
            next_nonstatic_oop_offset += heapOopSize;
          }
<span class="line-modified">!         nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
          break;
        case NONSTATIC_BYTE:
          if( nonstatic_byte_space_count &gt; 0 ) {
            real_offset = nonstatic_byte_space_offset;
            nonstatic_byte_space_offset += 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4244,30 ***</span>
  
            case NONSTATIC_OOP:
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += heapOopSize;
<span class="line-modified">! </span>
<span class="line-removed">-             // Record this oop in the oop maps</span>
<span class="line-removed">-             if( nonstatic_oop_map_count &gt; 0 &amp;&amp;</span>
<span class="line-removed">-                 nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==</span>
<span class="line-removed">-                 real_offset -</span>
<span class="line-removed">-                 int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *</span>
<span class="line-removed">-                 heapOopSize ) {</span>
<span class="line-removed">-               // This oop is adjacent to the previous one, add to current oop map</span>
<span class="line-removed">-               assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">-               nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-               // This oop is not adjacent to the previous one, create new oop map</span>
<span class="line-removed">-               assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);</span>
<span class="line-removed">-               nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;</span>
<span class="line-removed">-               nonstatic_oop_counts [nonstatic_oop_map_count] = 1;</span>
<span class="line-removed">-               nonstatic_oop_map_count += 1;</span>
<span class="line-removed">-               if( first_nonstatic_oop_offset == 0 ) { // Undefined</span>
<span class="line-removed">-                 first_nonstatic_oop_offset = real_offset;</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
              break;
  
            default:
              ShouldNotReachHere();
          }
<span class="line-new-header">--- 4475,11 ---</span>
  
            case NONSTATIC_OOP:
              next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
              real_offset = next_nonstatic_padded_offset;
              next_nonstatic_padded_offset += heapOopSize;
<span class="line-modified">!             nonstatic_oop_maps-&gt;add(real_offset, 1);</span>
              break;
  
            default:
              ShouldNotReachHere();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4327,13 ***</span>
    assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
           is_contended_class ||
           (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
  
    // Number of non-static oop map blocks allocated at end of klass.
<span class="line-modified">!   const unsigned int total_oop_map_count =</span>
<span class="line-removed">-     compute_oop_map_count(_super_klass, nonstatic_oop_map_count,</span>
<span class="line-removed">-                           first_nonstatic_oop_offset);</span>
  
  #ifndef PRODUCT
    if (PrintFieldLayout) {
      print_field_layout(_class_name,
            _fields,
<span class="line-new-header">--- 4539,11 ---</span>
    assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
           is_contended_class ||
           (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
  
    // Number of non-static oop map blocks allocated at end of klass.
<span class="line-modified">!   nonstatic_oop_maps-&gt;compact();</span>
  
  #ifndef PRODUCT
    if (PrintFieldLayout) {
      print_field_layout(_class_name,
            _fields,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4344,62 ***</span>
            static_fields_end);
    }
  
  #endif
    // Pass back information needed for InstanceKlass creation
<span class="line-modified">!   info-&gt;nonstatic_oop_offsets = nonstatic_oop_offsets;</span>
<span class="line-modified">!   info-&gt;nonstatic_oop_counts = nonstatic_oop_counts;</span>
<span class="line-modified">!   info-&gt;nonstatic_oop_map_count = nonstatic_oop_map_count;</span>
<span class="line-modified">!   info-&gt;total_oop_map_count = total_oop_map_count;</span>
<span class="line-modified">!   info-&gt;instance_size = instance_size;</span>
<span class="line-removed">-   info-&gt;static_field_size = static_field_size;</span>
<span class="line-removed">-   info-&gt;nonstatic_field_size = nonstatic_field_size;</span>
<span class="line-removed">-   info-&gt;has_nonstatic_fields = has_nonstatic_fields;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void fill_oop_maps(const InstanceKlass* k,</span>
<span class="line-removed">-                           unsigned int nonstatic_oop_map_count,</span>
<span class="line-removed">-                           const int* nonstatic_oop_offsets,</span>
<span class="line-removed">-                           const unsigned int* nonstatic_oop_counts) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(k != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OopMapBlock* this_oop_map = k-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">-   const InstanceKlass* const super = k-&gt;superklass();</span>
<span class="line-removed">-   const unsigned int super_count = super ? super-&gt;nonstatic_oop_map_count() : 0;</span>
<span class="line-removed">-   if (super_count &gt; 0) {</span>
<span class="line-removed">-     // Copy maps from superklass</span>
<span class="line-removed">-     OopMapBlock* super_oop_map = super-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; super_count; ++i) {</span>
<span class="line-removed">-       *this_oop_map++ = *super_oop_map++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-removed">-     if (super_count + nonstatic_oop_map_count &gt; k-&gt;nonstatic_oop_map_count()) {</span>
<span class="line-removed">-       // The counts differ because there is no gap between superklass&#39;s last oop</span>
<span class="line-removed">-       // field and the first local oop field.  Extend the last oop map copied</span>
<span class="line-removed">-       // from the superklass instead of creating new one.</span>
<span class="line-removed">-       nonstatic_oop_map_count--;</span>
<span class="line-removed">-       nonstatic_oop_offsets++;</span>
<span class="line-removed">-       this_oop_map--;</span>
<span class="line-removed">-       this_oop_map-&gt;set_count(this_oop_map-&gt;count() + *nonstatic_oop_counts++);</span>
<span class="line-removed">-       this_oop_map++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Add new map blocks, fill them</span>
<span class="line-removed">-     while (nonstatic_oop_map_count-- &gt; 0) {</span>
<span class="line-removed">-       this_oop_map-&gt;set_offset(*nonstatic_oop_offsets++);</span>
<span class="line-removed">-       this_oop_map-&gt;set_count(*nonstatic_oop_counts++);</span>
<span class="line-removed">-       this_oop_map++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(k-&gt;start_of_nonstatic_oop_maps() + k-&gt;nonstatic_oop_map_count() ==</span>
<span class="line-removed">-            this_oop_map, &quot;sanity&quot;);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- </span>
  void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
    assert(ik != NULL, &quot;invariant&quot;);
  
    const Klass* const super = ik-&gt;super();
  
<span class="line-new-header">--- 4554,17 ---</span>
            static_fields_end);
    }
  
  #endif
    // Pass back information needed for InstanceKlass creation
<span class="line-modified">!   info-&gt;oop_map_blocks = nonstatic_oop_maps;</span>
<span class="line-modified">!   info-&gt;_instance_size = instance_size;</span>
<span class="line-modified">!   info-&gt;_static_field_size = static_field_size;</span>
<span class="line-modified">!   info-&gt;_nonstatic_field_size = nonstatic_field_size;</span>
<span class="line-modified">!   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;</span>
  }
  
  void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
    assert(ik != NULL, &quot;invariant&quot;);
  
    const Klass* const super = ik-&gt;super();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4549,10 ***</span>
<span class="line-new-header">--- 4714,11 ---</span>
  }
  
  static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
    assert(this_klass != NULL, &quot;invariant&quot;);
    const Klass* const super = this_klass-&gt;super();
<span class="line-added">+ </span>
    if (super != NULL) {
  
      // If the loader is not the boot loader then throw an exception if its
      // superclass is in package jdk.internal.reflect and its loader is not a
      // special reflection class loader
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4750,16 ***</span>
    const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
    const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
    const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
    const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
    const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
<span class="line-modified">!   const bool major_gte_15  = _major_version &gt;= JAVA_1_5_VERSION;</span>
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
<span class="line-modified">!       (is_interface &amp;&amp; major_gte_15 &amp;&amp; (is_super || is_enum)) ||</span>
<span class="line-modified">!       (!is_interface &amp;&amp; major_gte_15 &amp;&amp; is_annotation)) {</span>
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Illegal class modifiers in class %s: 0x%X&quot;,
<span class="line-new-header">--- 4916,17 ---</span>
    const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
    const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
    const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
    const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
    const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
<span class="line-modified">!   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;</span>
<span class="line-added">+   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;</span>
  
    if ((is_abstract &amp;&amp; is_final) ||
        (is_interface &amp;&amp; !is_abstract) ||
<span class="line-modified">!       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||</span>
<span class="line-modified">!       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>
      ResourceMark rm(THREAD);
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_ClassFormatError(),
        &quot;Illegal class modifiers in class %s: 0x%X&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4779,64 ***</span>
            (is_protected &amp;&amp; is_private));
  }
  
  // A legal major_version.minor_version must be one of the following:
  //
<span class="line-modified">! //   Major_version = 45, any minor_version.</span>
<span class="line-modified">! //   Major_version &gt;= 46 and major_version &lt;= current_major_version and minor_version = 0.</span>
<span class="line-modified">! //   Major_version = current_major_version and minor_version = 65535 and --enable-preview is present.</span>
  //
  static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
    const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
<span class="line-modified">!   if (major != JAVA_MIN_SUPPORTED_VERSION) { // All 45.* are ok including 45.65535</span>
<span class="line-modified">!     if (minor == JAVA_PREVIEW_MINOR_VERSION) {</span>
<span class="line-modified">!       if (major != max_version) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         Exceptions::fthrow(</span>
<span class="line-modified">!           THREAD_AND_LOCATION,</span>
<span class="line-modified">!           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!           &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;</span>
<span class="line-removed">-           &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,</span>
<span class="line-removed">-           class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       if (!Arguments::enable_preview()) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         Exceptions::fthrow(</span>
<span class="line-modified">!           THREAD_AND_LOCATION,</span>
<span class="line-modified">!           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!           &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,</span>
<span class="line-modified">!           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!     } else { // minor != JAVA_PREVIEW_MINOR_VERSION</span>
<span class="line-modified">!       if (major &gt; max_version) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         Exceptions::fthrow(</span>
<span class="line-modified">!           THREAD_AND_LOCATION,</span>
<span class="line-modified">!           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!           &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;</span>
<span class="line-modified">!           &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,</span>
<span class="line-modified">!           class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-modified">!       } else if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         Exceptions::fthrow(</span>
<span class="line-modified">!           THREAD_AND_LOCATION,</span>
<span class="line-modified">!           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!           &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,</span>
<span class="line-modified">!           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">!       } else if (minor != 0) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         Exceptions::fthrow(</span>
<span class="line-modified">!           THREAD_AND_LOCATION,</span>
<span class="line-modified">!           vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!           &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,</span>
<span class="line-removed">-           class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-removed">-       }</span>
      }
    }
  }
  
  void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                     bool is_interface,
<span class="line-new-header">--- 4946,66 ---</span>
            (is_protected &amp;&amp; is_private));
  }
  
  // A legal major_version.minor_version must be one of the following:
  //
<span class="line-modified">! //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.</span>
<span class="line-modified">! //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.</span>
<span class="line-modified">! //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.</span>
  //
  static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
<span class="line-added">+   ResourceMark rm(THREAD);</span>
    const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
<span class="line-modified">!   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {</span>
<span class="line-modified">!     Exceptions::fthrow(</span>
<span class="line-modified">!       THREAD_AND_LOCATION,</span>
<span class="line-modified">!       vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,</span>
<span class="line-modified">!       class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (major &gt; max_version) {</span>
<span class="line-modified">!     Exceptions::fthrow(</span>
<span class="line-modified">!       THREAD_AND_LOCATION,</span>
<span class="line-modified">!       vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;</span>
<span class="line-modified">!       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,</span>
<span class="line-modified">!       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (major &lt; JAVA_12_VERSION || minor == 0) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (minor == JAVA_PREVIEW_MINOR_VERSION) {</span>
<span class="line-modified">!     if (major != max_version) {</span>
<span class="line-modified">!       Exceptions::fthrow(</span>
<span class="line-modified">!         THREAD_AND_LOCATION,</span>
<span class="line-modified">!         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;</span>
<span class="line-modified">!         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,</span>
<span class="line-modified">!         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!Arguments::enable_preview()) {</span>
<span class="line-modified">!       Exceptions::fthrow(</span>
<span class="line-modified">!         THREAD_AND_LOCATION,</span>
<span class="line-modified">!         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-modified">!         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,</span>
<span class="line-modified">!         class_name-&gt;as_C_string(), major, minor);</span>
<span class="line-modified">!       return;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+   } else { // minor != JAVA_PREVIEW_MINOR_VERSION</span>
<span class="line-added">+     Exceptions::fthrow(</span>
<span class="line-added">+         THREAD_AND_LOCATION,</span>
<span class="line-added">+         vmSymbols::java_lang_UnsupportedClassVersionError(),</span>
<span class="line-added">+         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,</span>
<span class="line-added">+         class_name-&gt;as_C_string(), major, minor);</span>
    }
  }
  
  void ClassFileParser::verify_legal_field_modifiers(jint flags,
                                                     bool is_interface,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4849,18 ***</span>
    const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
    const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
    const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
    const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
    const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
<span class="line-modified">!   const bool major_gte_15 = _major_version &gt;= JAVA_1_5_VERSION;</span>
  
    bool is_illegal = false;
  
    if (is_interface) {
      if (!is_public || !is_static || !is_final || is_private ||
          is_protected || is_volatile || is_transient ||
<span class="line-modified">!         (major_gte_15 &amp;&amp; is_enum)) {</span>
        is_illegal = true;
      }
    } else { // not interface
      if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
        is_illegal = true;
<span class="line-new-header">--- 5018,18 ---</span>
    const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
    const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
    const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
    const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
    const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
<span class="line-modified">!   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;</span>
  
    bool is_illegal = false;
  
    if (is_interface) {
      if (!is_public || !is_static || !is_final || is_private ||
          is_protected || is_volatile || is_transient ||
<span class="line-modified">!         (major_gte_1_5 &amp;&amp; is_enum)) {</span>
        is_illegal = true;
      }
    } else { // not interface
      if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
        is_illegal = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4892,11 ***</span>
    const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
    const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
    const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
    const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
    const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
<span class="line-modified">!   const bool major_gte_15    = _major_version &gt;= JAVA_1_5_VERSION;</span>
    const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
    const bool is_initializer  = (name == vmSymbols::object_initializer_name());
  
    bool is_illegal = false;
  
<span class="line-new-header">--- 5061,11 ---</span>
    const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
    const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
    const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
    const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
    const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
<span class="line-modified">!   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;</span>
    const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
    const bool is_initializer  = (name == vmSymbols::object_initializer_name());
  
    bool is_illegal = false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4915,11 ***</span>
            // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
            // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
            (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
          is_illegal = true;
        }
<span class="line-modified">!     } else if (major_gte_15) {</span>
        // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
        if (!is_public || is_private || is_protected || is_static || is_final ||
            is_synchronized || is_native || !is_abstract || is_strict) {
          is_illegal = true;
        }
<span class="line-new-header">--- 5084,11 ---</span>
            // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
            // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
            (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
          is_illegal = true;
        }
<span class="line-modified">!     } else if (major_gte_1_5) {</span>
        // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
        if (!is_public || is_private || is_protected || is_static || is_final ||
            is_synchronized || is_native || !is_abstract || is_strict) {
          is_illegal = true;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4933,17 ***</span>
      if (has_illegal_visibility(flags)) {
        is_illegal = true;
      } else {
        if (is_initializer) {
          if (is_static || is_final || is_synchronized || is_native ||
<span class="line-modified">!             is_abstract || (major_gte_15 &amp;&amp; is_bridge)) {</span>
            is_illegal = true;
          }
        } else { // not initializer
          if (is_abstract) {
            if ((is_final || is_native || is_private || is_static ||
<span class="line-modified">!               (major_gte_15 &amp;&amp; (is_synchronized || is_strict)))) {</span>
              is_illegal = true;
            }
          }
        }
      }
<span class="line-new-header">--- 5102,17 ---</span>
      if (has_illegal_visibility(flags)) {
        is_illegal = true;
      } else {
        if (is_initializer) {
          if (is_static || is_final || is_synchronized || is_native ||
<span class="line-modified">!             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {</span>
            is_illegal = true;
          }
        } else { // not initializer
          if (is_abstract) {
            if ((is_final || is_native || is_private || is_static ||
<span class="line-modified">!               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
              is_illegal = true;
            }
          }
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4979,30 ***</span>
  // This method is also called from the modular system APIs in modules.cpp
  // to verify the validity of module and package names.
  bool ClassFileParser::verify_unqualified_name(const char* name,
                                                unsigned int length,
                                                int type) {
    for (const char* p = name; p != name + length; p++) {
      switch(*p) {
<span class="line-modified">!       case &#39;.&#39;:</span>
<span class="line-modified">!       case &#39;;&#39;:</span>
<span class="line-modified">!       case &#39;[&#39;:</span>
          // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
          return false;
<span class="line-modified">!       case &#39;/&#39;:</span>
          // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
          // unqualified name must not be empty
          if (type == ClassFileParser::LegalClass) {
<span class="line-modified">!           if (p == name || p+1 &gt;= name+length || *(p+1) == &#39;/&#39;) {</span>
              return false;
            }
          } else {
            return false;   // do not permit &#39;/&#39; unless it&#39;s class name
          }
          break;
<span class="line-modified">!       case &#39;&lt;&#39;:</span>
<span class="line-modified">!       case &#39;&gt;&#39;:</span>
          // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
          if (type == ClassFileParser::LegalMethod) {
            return false;
          }
      }
<span class="line-new-header">--- 5148,32 ---</span>
  // This method is also called from the modular system APIs in modules.cpp
  // to verify the validity of module and package names.
  bool ClassFileParser::verify_unqualified_name(const char* name,
                                                unsigned int length,
                                                int type) {
<span class="line-added">+   if (length == 0) return false;  // Must have at least one char.</span>
    for (const char* p = name; p != name + length; p++) {
      switch(*p) {
<span class="line-modified">!       case JVM_SIGNATURE_DOT:</span>
<span class="line-modified">!       case JVM_SIGNATURE_ENDCLASS:</span>
<span class="line-modified">!       case JVM_SIGNATURE_ARRAY:</span>
          // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
          return false;
<span class="line-modified">!       case JVM_SIGNATURE_SLASH:</span>
          // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
          // unqualified name must not be empty
          if (type == ClassFileParser::LegalClass) {
<span class="line-modified">!           if (p == name || p+1 &gt;= name+length ||</span>
<span class="line-added">+               *(p+1) == JVM_SIGNATURE_SLASH) {</span>
              return false;
            }
          } else {
            return false;   // do not permit &#39;/&#39; unless it&#39;s class name
          }
          break;
<span class="line-modified">!       case JVM_SIGNATURE_SPECIAL:</span>
<span class="line-modified">!       case JVM_SIGNATURE_ENDSPECIAL:</span>
          // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
          if (type == ClassFileParser::LegalMethod) {
            return false;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5035,11 ***</span>
          (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
          (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
          last_is_slash = false;
          continue;
        }
<span class="line-modified">!       if (slash_ok &amp;&amp; ch == &#39;/&#39;) {</span>
          if (last_is_slash) {
            return NULL;  // Don&#39;t permit consecutive slashes
          }
          last_is_slash = true;
          continue;
<span class="line-new-header">--- 5206,11 ---</span>
          (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
          (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
          last_is_slash = false;
          continue;
        }
<span class="line-modified">!       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {</span>
          if (last_is_slash) {
            return NULL;  // Don&#39;t permit consecutive slashes
          }
          last_is_slash = true;
          continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5115,24 ***</span>
        if (_major_version &lt; JAVA_1_5_VERSION) {
          // Skip over the class name if one is there
          const char* const p = skip_over_field_name(signature + 1, true, --length);
  
          // The next character better be a semicolon
<span class="line-modified">!         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == &#39;;&#39;) {</span>
            return p + 1;
          }
        }
        else {
          // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
          signature++;
<span class="line-modified">!         const char* c = (const char*) memchr(signature, &#39;;&#39;, length - 1);</span>
          // Format check signature
          if (c != NULL) {
            int newlen = c - (char*) signature;
            bool legal = verify_unqualified_name(signature, newlen, LegalClass);
            if (!legal) {
<span class="line-modified">!             classfile_parse_error(&quot;Class name contains illegal character &quot;</span>
                                    &quot;in descriptor in class file %s&quot;,
                                    CHECK_0);
              return NULL;
            }
            return signature + newlen + 1;
<span class="line-new-header">--- 5286,24 ---</span>
        if (_major_version &lt; JAVA_1_5_VERSION) {
          // Skip over the class name if one is there
          const char* const p = skip_over_field_name(signature + 1, true, --length);
  
          // The next character better be a semicolon
<span class="line-modified">!         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {</span>
            return p + 1;
          }
        }
        else {
          // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
          signature++;
<span class="line-modified">!         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);</span>
          // Format check signature
          if (c != NULL) {
            int newlen = c - (char*) signature;
            bool legal = verify_unqualified_name(signature, newlen, LegalClass);
            if (!legal) {
<span class="line-modified">!             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;</span>
                                    &quot;in descriptor in class file %s&quot;,
                                    CHECK_0);
              return NULL;
            }
            return signature + newlen + 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5171,11 ***</span>
      const char* p;
      if (bytes[0] == JVM_SIGNATURE_ARRAY) {
        p = skip_over_field_signature(bytes, false, length, CHECK);
        legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
      } else if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">!       if (bytes[0] != &#39;&lt;&#39;) {</span>
          p = skip_over_field_name(bytes, true, length);
          legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
        }
      } else {
        // 4900761: relax the constraints based on JSR202 spec
<span class="line-new-header">--- 5342,11 ---</span>
      const char* p;
      if (bytes[0] == JVM_SIGNATURE_ARRAY) {
        p = skip_over_field_signature(bytes, false, length, CHECK);
        legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
      } else if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">!       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {</span>
          p = skip_over_field_name(bytes, true, length);
          legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
        }
      } else {
        // 4900761: relax the constraints based on JSR202 spec
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5206,11 ***</span>
    unsigned int length = name-&gt;utf8_length();
    bool legal = false;
  
    if (length &gt; 0) {
      if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">!       if (bytes[0] != &#39;&lt;&#39;) {</span>
          const char* p = skip_over_field_name(bytes, false, length);
          legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
        }
      } else {
        // 4881221: relax the constraints based on JSR202 spec
<span class="line-new-header">--- 5377,11 ---</span>
    unsigned int length = name-&gt;utf8_length();
    bool legal = false;
  
    if (length &gt; 0) {
      if (_major_version &lt; JAVA_1_5_VERSION) {
<span class="line-modified">!       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {</span>
          const char* p = skip_over_field_name(bytes, false, length);
          legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
        }
      } else {
        // 4881221: relax the constraints based on JSR202 spec
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5239,11 ***</span>
    char* bytes = (char*)name-&gt;bytes();
    unsigned int length = name-&gt;utf8_length();
    bool legal = false;
  
    if (length &gt; 0) {
<span class="line-modified">!     if (bytes[0] == &#39;&lt;&#39;) {</span>
        if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
          legal = true;
        }
      } else if (_major_version &lt; JAVA_1_5_VERSION) {
        const char* p;
<span class="line-new-header">--- 5410,11 ---</span>
    char* bytes = (char*)name-&gt;bytes();
    unsigned int length = name-&gt;utf8_length();
    bool legal = false;
  
    if (length &gt; 0) {
<span class="line-modified">!     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {</span>
        if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
          legal = true;
        }
      } else if (_major_version &lt; JAVA_1_5_VERSION) {
        const char* p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5323,11 ***</span>
        nextp = skip_over_field_signature(p, false, length, CHECK_0);
      }
      // The first non-signature thing better be a &#39;)&#39;
      if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
        length--;
<span class="line-modified">!       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == &#39;&lt;&#39;) {</span>
          // All internal methods must return void
          if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
            return args_size;
          }
        } else {
<span class="line-new-header">--- 5494,11 ---</span>
        nextp = skip_over_field_signature(p, false, length, CHECK_0);
      }
      // The first non-signature thing better be a &#39;)&#39;
      if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
        length--;
<span class="line-modified">!       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {</span>
          // All internal methods must return void
          if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
            return args_size;
          }
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5344,21 ***</span>
    return 0;
  }
  
  int ClassFileParser::static_field_size() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;static_field_size;</span>
  }
  
  int ClassFileParser::total_oop_map_count() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;total_oop_map_count;</span>
  }
  
  jint ClassFileParser::layout_size() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;instance_size;</span>
  }
  
  static void check_methods_for_intrinsics(const InstanceKlass* ik,
                                           const Array&lt;Method*&gt;* methods) {
    assert(ik != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 5515,21 ---</span>
    return 0;
  }
  
  int ClassFileParser::static_field_size() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;_static_field_size;</span>
  }
  
  int ClassFileParser::total_oop_map_count() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;</span>
  }
  
  jint ClassFileParser::layout_size() const {
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   return _field_info-&gt;_instance_size;</span>
  }
  
  static void check_methods_for_intrinsics(const InstanceKlass* ik,
                                           const Array&lt;Method*&gt;* methods) {
    assert(ik != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5498,23 ***</span>
    _loader_data-&gt;add_class(ik, publicize);
  
    set_klass_to_deallocate(ik);
  
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(ik-&gt;static_field_size() == _field_info-&gt;static_field_size, &quot;sanity&quot;);</span>
<span class="line-modified">!   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;total_oop_map_count,</span>
<span class="line-modified">!     &quot;sanity&quot;);</span>
  
    assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
<span class="line-modified">!   assert(ik-&gt;size_helper() == _field_info-&gt;instance_size, &quot;sanity&quot;);</span>
  
    // Fill in information already parsed
    ik-&gt;set_should_verify_class(_need_verify);
  
    // Not yet: supers are done below to support the new subtype-checking fields
<span class="line-modified">!   ik-&gt;set_nonstatic_field_size(_field_info-&gt;nonstatic_field_size);</span>
<span class="line-modified">!   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;has_nonstatic_fields);</span>
    assert(_fac != NULL, &quot;invariant&quot;);
    ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
  
    // this transfers ownership of a lot of arrays from
    // the parser onto the InstanceKlass*
<span class="line-new-header">--- 5669,23 ---</span>
    _loader_data-&gt;add_class(ik, publicize);
  
    set_klass_to_deallocate(ik);
  
    assert(_field_info != NULL, &quot;invariant&quot;);
<span class="line-modified">!   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);</span>
<span class="line-modified">!   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,</span>
<span class="line-modified">!          &quot;sanity&quot;);</span>
  
    assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
<span class="line-modified">!   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);</span>
  
    // Fill in information already parsed
    ik-&gt;set_should_verify_class(_need_verify);
  
    // Not yet: supers are done below to support the new subtype-checking fields
<span class="line-modified">!   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);</span>
<span class="line-modified">!   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);</span>
    assert(_fac != NULL, &quot;invariant&quot;);
    ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
  
    // this transfers ownership of a lot of arrays from
    // the parser onto the InstanceKlass*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5526,10 ***</span>
<span class="line-new-header">--- 5697,11 ---</span>
    assert(NULL == _methods, &quot;invariant&quot;);
    assert(NULL == _inner_classes, &quot;invariant&quot;);
    assert(NULL == _nest_members, &quot;invariant&quot;);
    assert(NULL == _local_interfaces, &quot;invariant&quot;);
    assert(NULL == _combined_annotations, &quot;invariant&quot;);
<span class="line-added">+   assert(NULL == _record_components, &quot;invariant&quot;);</span>
  
    if (_has_final_method) {
      ik-&gt;set_has_final_method();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5600,14 ***</span>
    // Initialize itable offset tables
    klassItable::setup_itable_offset_table(ik);
  
    // Compute transitive closure of interfaces this class implements
    // Do final class setup
<span class="line-modified">!   fill_oop_maps(ik,</span>
<span class="line-modified">!                 _field_info-&gt;nonstatic_oop_map_count,</span>
<span class="line-modified">!                 _field_info-&gt;nonstatic_oop_offsets,</span>
<span class="line-modified">!                 _field_info-&gt;nonstatic_oop_counts);</span>
  
    // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
    set_precomputed_flags(ik);
  
    // check if this class can access its super class
<span class="line-new-header">--- 5772,19 ---</span>
    // Initialize itable offset tables
    klassItable::setup_itable_offset_table(ik);
  
    // Compute transitive closure of interfaces this class implements
    // Do final class setup
<span class="line-modified">!   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;</span>
<span class="line-modified">!   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {</span>
<span class="line-modified">!     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||</span>
<span class="line-added">+       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {</span>
<span class="line-added">+     ik-&gt;set_has_contended_annotations(true);</span>
<span class="line-added">+   }</span>
  
    // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
    set_precomputed_flags(ik);
  
    // check if this class can access its super class
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5683,15 ***</span>
        const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
        ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
      }
  
      if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
<span class="line-modified">!         ik-&gt;major_version() != JAVA_MIN_SUPPORTED_VERSION &amp;&amp;</span>
          log_is_enabled(Info, class, preview)) {
        ResourceMark rm;
        log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
<span class="line-modified">!                                ik-&gt;external_name(), ik-&gt;major_version());</span>
      }
  
      if (log_is_enabled(Debug, class, resolve))  {
        ResourceMark rm;
        // print out the superclass.
<span class="line-new-header">--- 5860,15 ---</span>
        const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
        ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
      }
  
      if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
<span class="line-modified">!         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
          log_is_enabled(Info, class, preview)) {
        ResourceMark rm;
        log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
<span class="line-modified">!                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);</span>
      }
  
      if (log_is_enabled(Debug, class, resolve))  {
        ResourceMark rm;
        // print out the superclass.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5742,11 ***</span>
  // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
  // package by prepending its host class&#39;s package name to its class name and setting
  // its _class_name field.
  void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
    ResourceMark rm(THREAD);
<span class="line-modified">!   assert(strrchr(_class_name-&gt;as_C_string(), &#39;/&#39;) == NULL,</span>
           &quot;Unsafe anonymous class should not be in a package&quot;);
    const char* host_pkg_name =
      ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
  
    if (host_pkg_name != NULL) {
<span class="line-new-header">--- 5919,11 ---</span>
  // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
  // package by prepending its host class&#39;s package name to its class name and setting
  // its _class_name field.
  void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
    ResourceMark rm(THREAD);
<span class="line-modified">!   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,</span>
           &quot;Unsafe anonymous class should not be in a package&quot;);
    const char* host_pkg_name =
      ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
  
    if (host_pkg_name != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5763,11 ***</span>
  
      // Create a symbol and update the anonymous class name.
      // The new class name is created with a refcount of one. When installed into the InstanceKlass,
      // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
      // when the class is unloaded.
<span class="line-modified">!     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len, CHECK);</span>
    }
  }
  
  // If the host class and the anonymous class are in the same package then do
  // nothing.  If the anonymous class is in the unnamed package then move it to its
<span class="line-new-header">--- 5940,11 ---</span>
  
      // Create a symbol and update the anonymous class name.
      // The new class name is created with a refcount of one. When installed into the InstanceKlass,
      // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
      // when the class is unloaded.
<span class="line-modified">!     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);</span>
    }
  }
  
  // If the host class and the anonymous class are in the same package then do
  // nothing.  If the anonymous class is in the unnamed package then move it to its
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5775,11 ***</span>
  // exception.
  void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
    assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
  
    const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
<span class="line-modified">!                                                _class_name-&gt;utf8_length(), &#39;/&#39;);</span>
    if (anon_last_slash == NULL) {  // Unnamed package
      prepend_host_package_name(_unsafe_anonymous_host, CHECK);
    } else {
      if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
        ResourceMark rm(THREAD);
<span class="line-new-header">--- 5952,11 ---</span>
  // exception.
  void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
    assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
  
    const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
<span class="line-modified">!                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);</span>
    if (anon_last_slash == NULL) {  // Unnamed package
      prepend_host_package_name(_unsafe_anonymous_host, CHECK);
    } else {
      if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
        ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5824,15 ***</span>
    _fields(NULL),
    _methods(NULL),
    _inner_classes(NULL),
    _nest_members(NULL),
    _nest_host(0),
    _local_interfaces(NULL),
    _transitive_interfaces(NULL),
    _combined_annotations(NULL),
<span class="line-modified">!   _annotations(NULL),</span>
<span class="line-modified">!   _type_annotations(NULL),</span>
    _fields_annotations(NULL),
    _fields_type_annotations(NULL),
    _klass(NULL),
    _klass_to_deallocate(NULL),
    _parsed_annotations(NULL),
<span class="line-new-header">--- 6001,16 ---</span>
    _fields(NULL),
    _methods(NULL),
    _inner_classes(NULL),
    _nest_members(NULL),
    _nest_host(0),
<span class="line-added">+   _record_components(NULL),</span>
    _local_interfaces(NULL),
    _transitive_interfaces(NULL),
    _combined_annotations(NULL),
<span class="line-modified">!   _class_annotations(NULL),</span>
<span class="line-modified">!   _class_type_annotations(NULL),</span>
    _fields_annotations(NULL),
    _fields_type_annotations(NULL),
    _klass(NULL),
    _klass_to_deallocate(NULL),
    _parsed_annotations(NULL),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5862,10 ***</span>
<span class="line-new-header">--- 6040,11 ---</span>
    _need_verify(false),
    _relax_verify(false),
    _has_nonstatic_concrete_methods(false),
    _declares_nonstatic_concrete_methods(false),
    _has_final_method(false),
<span class="line-added">+   _has_contended_fields(false),</span>
    _has_finalizer(false),
    _has_empty_finalizer(false),
    _has_vanilla_constructor(false),
    _max_bootstrap_specifier_index(-1) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5932,12 ***</span>
    _methods = NULL;
    _inner_classes = NULL;
    _nest_members = NULL;
    _local_interfaces = NULL;
    _combined_annotations = NULL;
<span class="line-modified">!   _annotations = _type_annotations = NULL;</span>
    _fields_annotations = _fields_type_annotations = NULL;
  }
  
  // Destructor to clean up
  ClassFileParser::~ClassFileParser() {
    _class_name-&gt;decrement_refcount();
<span class="line-new-header">--- 6111,13 ---</span>
    _methods = NULL;
    _inner_classes = NULL;
    _nest_members = NULL;
    _local_interfaces = NULL;
    _combined_annotations = NULL;
<span class="line-modified">!   _class_annotations = _class_type_annotations = NULL;</span>
    _fields_annotations = _fields_type_annotations = NULL;
<span class="line-added">+   _record_components = NULL;</span>
  }
  
  // Destructor to clean up
  ClassFileParser::~ClassFileParser() {
    _class_name-&gt;decrement_refcount();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5961,10 ***</span>
<span class="line-new-header">--- 6141,14 ---</span>
  
    if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
      MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
    }
  
<span class="line-added">+   if (_record_components != NULL) {</span>
<span class="line-added">+     InstanceKlass::deallocate_record_components(_loader_data, _record_components);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Free interfaces
    InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
                                         _local_interfaces, _transitive_interfaces);
  
    if (_combined_annotations != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5974,19 ***</span>
      // Deallocate the Annotations object and the installed annotations arrays.
      _combined_annotations-&gt;deallocate_contents(_loader_data);
  
      // If the _combined_annotations pointer is non-NULL,
      // then the other annotations fields should have been cleared.
<span class="line-modified">!     assert(_annotations             == NULL, &quot;Should have been cleared&quot;);</span>
<span class="line-modified">!     assert(_type_annotations        == NULL, &quot;Should have been cleared&quot;);</span>
      assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
      assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
    } else {
      // If the annotations arrays were not installed into the Annotations object,
      // then they have to be deallocated explicitly.
<span class="line-modified">!     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _annotations);</span>
<span class="line-modified">!     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _type_annotations);</span>
      Annotations::free_contents(_loader_data, _fields_annotations);
      Annotations::free_contents(_loader_data, _fields_type_annotations);
    }
  
    clear_class_metadata();
<span class="line-new-header">--- 6158,19 ---</span>
      // Deallocate the Annotations object and the installed annotations arrays.
      _combined_annotations-&gt;deallocate_contents(_loader_data);
  
      // If the _combined_annotations pointer is non-NULL,
      // then the other annotations fields should have been cleared.
<span class="line-modified">!     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);</span>
<span class="line-modified">!     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);</span>
      assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
      assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
    } else {
      // If the annotations arrays were not installed into the Annotations object,
      // then they have to be deallocated explicitly.
<span class="line-modified">!     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);</span>
<span class="line-modified">!     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);</span>
      Annotations::free_contents(_loader_data, _fields_annotations);
      Annotations::free_contents(_loader_data, _fields_type_annotations);
    }
  
    clear_class_metadata();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6016,13 ***</span>
  
    // Version numbers
    _minor_version = stream-&gt;get_u2_fast();
    _major_version = stream-&gt;get_u2_fast();
  
<span class="line-modified">!   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_1_5_VERSION) {</span>
      ResourceMark rm;
<span class="line-modified">!     warning(&quot;Pre JDK 1.5 class not supported by CDS: %u.%u %s&quot;,</span>
              _major_version,  _minor_version, _class_name-&gt;as_C_string());
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_UnsupportedClassVersionError(),
        &quot;Unsupported major.minor version for dump time %u.%u&quot;,
<span class="line-new-header">--- 6200,13 ---</span>
  
    // Version numbers
    _minor_version = stream-&gt;get_u2_fast();
    _major_version = stream-&gt;get_u2_fast();
  
<span class="line-modified">!   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {</span>
      ResourceMark rm;
<span class="line-modified">!     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,</span>
              _major_version,  _minor_version, _class_name-&gt;as_C_string());
      Exceptions::fthrow(
        THREAD_AND_LOCATION,
        vmSymbols::java_lang_UnsupportedClassVersionError(),
        &quot;Unsupported major.minor version for dump time %u.%u&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6157,11 ***</span>
          bool skip = false;
          if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
            // For the boot and platform class loaders, skip classes that are not found in the
            // java runtime image, such as those found in the --patch-module entries.
            // These classes can&#39;t be loaded from the archive during runtime.
<span class="line-modified">!           if (!ClassLoader::is_modules_image(stream-&gt;source()) &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {</span>
              skip = true;
            }
  
            if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
              // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
<span class="line-new-header">--- 6341,11 ---</span>
          bool skip = false;
          if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
            // For the boot and platform class loaders, skip classes that are not found in the
            // java runtime image, such as those found in the --patch-module entries.
            // These classes can&#39;t be loaded from the archive during runtime.
<span class="line-modified">!           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {</span>
              skip = true;
            }
  
            if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
              // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6334,11 ***</span>
  
    assert(_fac != NULL, &quot;invariant&quot;);
    assert(_parsed_annotations != NULL, &quot;invariant&quot;);
  
    _field_info = new FieldLayoutInfo();
<span class="line-modified">!   layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>
  
    // Compute reference typ
    _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
  
  }
<span class="line-new-header">--- 6518,17 ---</span>
  
    assert(_fac != NULL, &quot;invariant&quot;);
    assert(_parsed_annotations != NULL, &quot;invariant&quot;);
  
    _field_info = new FieldLayoutInfo();
<span class="line-modified">!   if (UseNewFieldLayout) {</span>
<span class="line-added">+     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,</span>
<span class="line-added">+                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-added">+     lb.build_layout();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);</span>
<span class="line-added">+   }</span>
  
    // Compute reference typ
    _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
  
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6380,11 ***</span>
  // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
  bool ClassFileParser::is_internal_format(Symbol* class_name) {
    if (class_name != NULL) {
      ResourceMark rm;
      char* name = class_name-&gt;as_C_string();
<span class="line-modified">!     return strchr(name, &#39;.&#39;) == NULL;</span>
    } else {
      return true;
    }
  }
  
<span class="line-new-header">--- 6570,11 ---</span>
  // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
  bool ClassFileParser::is_internal_format(Symbol* class_name) {
    if (class_name != NULL) {
      ResourceMark rm;
      char* name = class_name-&gt;as_C_string();
<span class="line-modified">!     return strchr(name, JVM_SIGNATURE_DOT) == NULL;</span>
    } else {
      return true;
    }
  }
  
</pre>
<center><a href="bytecodeAssembler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/verifier.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_VERIFIER_HPP
 26 #define SHARE_CLASSFILE_VERIFIER_HPP
 27 
 28 #include &quot;classfile/verificationType.hpp&quot;
 29 #include &quot;oops/klass.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/handles.hpp&quot;
 32 #include &quot;utilities/exceptions.hpp&quot;
 33 #include &quot;utilities/growableArray.hpp&quot;
 34 
 35 // The verifier class
 36 class Verifier : AllStatic {
 37  public:
 38   enum {
 39     STACKMAP_ATTRIBUTE_MAJOR_VERSION    = 50,
 40     INVOKEDYNAMIC_MAJOR_VERSION         = 51,
 41     NO_RELAX_ACCESS_CTRL_CHECK_VERSION  = 52,
 42     DYNAMICCONSTANT_MAJOR_VERSION       = 55
 43   };
 44 
 45   // Verify the bytecodes for a class.
 46   static bool verify(InstanceKlass* klass, bool should_verify_class, TRAPS);
 47 
 48   static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS);
 49 
 50   // Return false if the class is loaded by the bootstrap loader,
 51   // or if defineClass was called requesting skipping verification
 52   // -Xverify:all overrides this value
 53   static bool should_verify_for(oop class_loader, bool should_verify_class);
 54 
 55   // Relax certain access checks to enable some broken 1.1 apps to run on 1.2.
 56   static bool relax_access_for(oop class_loader);
 57 
 58   // Print output for class+resolve
 59   static void trace_class_resolution(Klass* resolve_class, InstanceKlass* verify_class);
 60 
 61  private:
 62   static bool is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class);
 63   static Symbol* inference_verify(
 64     InstanceKlass* klass, char* msg, size_t msg_len, TRAPS);
 65 };
 66 
 67 class RawBytecodeStream;
 68 class StackMapFrame;
 69 class StackMapTable;
 70 
 71 // Summary of verifier&#39;s memory usage:
 72 // StackMapTable is stack allocated.
 73 // StackMapFrame are resource allocated. There is only one ResourceMark
 74 // for each class verification, which is created at the top level.
 75 // There is one mutable StackMapFrame (current_frame) which is updated
 76 // by abstract bytecode interpretation. frame_in_exception_handler() returns
 77 // a frame that has a mutable one-item stack (ready for pushing the
 78 // catch type exception object). All the other StackMapFrame&#39;s
 79 // are immutable (including their locals and stack arrays) after
 80 // their constructions.
 81 // locals/stack arrays in StackMapFrame are resource allocated.
 82 // locals/stack arrays can be shared between StackMapFrame&#39;s, except
 83 // the mutable StackMapFrame (current_frame).
 84 
 85 // These macros are used similarly to CHECK macros but also check
 86 // the status of the verifier and return if that has an error.
 87 #define CHECK_VERIFY(verifier) \
 88   CHECK); if ((verifier)-&gt;has_error()) return; ((void)0
 89 #define CHECK_VERIFY_(verifier, result) \
 90   CHECK_(result)); if ((verifier)-&gt;has_error()) return (result); ((void)0
 91 
 92 class TypeOrigin {
 93  private:
 94   typedef enum {
 95     CF_LOCALS,  // Comes from the current frame locals
 96     CF_STACK,   // Comes from the current frame expression stack
 97     SM_LOCALS,  // Comes from stackmap locals
 98     SM_STACK,   // Comes from stackmap expression stack
 99     CONST_POOL, // Comes from the constant pool
100     SIG,        // Comes from method signature
101     IMPLICIT,   // Comes implicitly from code or context
102     BAD_INDEX,  // No type, but the index is bad
103     FRAME_ONLY, // No type, context just contains the frame
104     NONE
105   } Origin;
106 
107   Origin _origin;
108   u2 _index;              // local, stack, or constant pool index
109   StackMapFrame* _frame;  // source frame if CF or SM
110   VerificationType _type; // The actual type
111 
112   TypeOrigin(
113       Origin origin, u2 index, StackMapFrame* frame, VerificationType type)
114       : _origin(origin), _index(index), _frame(frame), _type(type) {}
115 
116  public:
117   TypeOrigin() : _origin(NONE), _index(0), _frame(NULL) {}
118 
119   static TypeOrigin null();
120   static TypeOrigin local(u2 index, StackMapFrame* frame);
121   static TypeOrigin stack(u2 index, StackMapFrame* frame);
122   static TypeOrigin sm_local(u2 index, StackMapFrame* frame);
123   static TypeOrigin sm_stack(u2 index, StackMapFrame* frame);
124   static TypeOrigin cp(u2 index, VerificationType vt);
125   static TypeOrigin signature(VerificationType vt);
126   static TypeOrigin bad_index(u2 index);
127   static TypeOrigin implicit(VerificationType t);
128   static TypeOrigin frame(StackMapFrame* frame);
129 
130   void reset_frame();
131   void details(outputStream* ss) const;
132   void print_frame(outputStream* ss) const;
133   const StackMapFrame* frame() const { return _frame; }
134   bool is_valid() const { return _origin != NONE; }
135   u2 index() const { return _index; }
136 
137 #ifdef ASSERT
138   void print_on(outputStream* str) const;
139 #endif
140 };
141 
142 class ErrorContext {
143  private:
144   typedef enum {
145     INVALID_BYTECODE,     // There was a problem with the bytecode
146     WRONG_TYPE,           // Type value was not as expected
147     FLAGS_MISMATCH,       // Frame flags are not assignable
148     BAD_CP_INDEX,         // Invalid constant pool index
149     BAD_LOCAL_INDEX,      // Invalid local index
150     LOCALS_SIZE_MISMATCH, // Frames have differing local counts
151     STACK_SIZE_MISMATCH,  // Frames have different stack sizes
152     STACK_OVERFLOW,       // Attempt to push onto a full expression stack
153     STACK_UNDERFLOW,      // Attempt to pop and empty expression stack
154     MISSING_STACKMAP,     // No stackmap for this location and there should be
155     BAD_STACKMAP,         // Format error in stackmap
156     NO_FAULT,             // No error
157     UNKNOWN
158   } FaultType;
159 
160   int _bci;
161   FaultType _fault;
162   TypeOrigin _type;
163   TypeOrigin _expected;
164 
165   ErrorContext(int bci, FaultType fault) :
166       _bci(bci), _fault(fault)  {}
167   ErrorContext(int bci, FaultType fault, TypeOrigin type) :
168       _bci(bci), _fault(fault), _type(type)  {}
169   ErrorContext(int bci, FaultType fault, TypeOrigin type, TypeOrigin exp) :
170       _bci(bci), _fault(fault), _type(type), _expected(exp)  {}
171 
172  public:
173   ErrorContext() : _bci(-1), _fault(NO_FAULT) {}
174 
175   static ErrorContext bad_code(u2 bci) {
176     return ErrorContext(bci, INVALID_BYTECODE);
177   }
178   static ErrorContext bad_type(u2 bci, TypeOrigin type) {
179     return ErrorContext(bci, WRONG_TYPE, type);
180   }
181   static ErrorContext bad_type(u2 bci, TypeOrigin type, TypeOrigin exp) {
182     return ErrorContext(bci, WRONG_TYPE, type, exp);
183   }
184   static ErrorContext bad_flags(u2 bci, StackMapFrame* frame) {
185     return ErrorContext(bci, FLAGS_MISMATCH, TypeOrigin::frame(frame));
186   }
187   static ErrorContext bad_flags(u2 bci, StackMapFrame* cur, StackMapFrame* sm) {
188     return ErrorContext(bci, FLAGS_MISMATCH,
189                         TypeOrigin::frame(cur), TypeOrigin::frame(sm));
190   }
191   static ErrorContext bad_cp_index(u2 bci, u2 index) {
192     return ErrorContext(bci, BAD_CP_INDEX, TypeOrigin::bad_index(index));
193   }
194   static ErrorContext bad_local_index(u2 bci, u2 index) {
195     return ErrorContext(bci, BAD_LOCAL_INDEX, TypeOrigin::bad_index(index));
196   }
197   static ErrorContext locals_size_mismatch(
198       u2 bci, StackMapFrame* frame0, StackMapFrame* frame1) {
199     return ErrorContext(bci, LOCALS_SIZE_MISMATCH,
200         TypeOrigin::frame(frame0), TypeOrigin::frame(frame1));
201   }
202   static ErrorContext stack_size_mismatch(
203       u2 bci, StackMapFrame* frame0, StackMapFrame* frame1) {
204     return ErrorContext(bci, STACK_SIZE_MISMATCH,
205         TypeOrigin::frame(frame0), TypeOrigin::frame(frame1));
206   }
207   static ErrorContext stack_overflow(u2 bci, StackMapFrame* frame) {
208     return ErrorContext(bci, STACK_OVERFLOW, TypeOrigin::frame(frame));
209   }
210   static ErrorContext stack_underflow(u2 bci, StackMapFrame* frame) {
211     return ErrorContext(bci, STACK_UNDERFLOW, TypeOrigin::frame(frame));
212   }
213   static ErrorContext missing_stackmap(u2 bci) {
214     return ErrorContext(bci, MISSING_STACKMAP);
215   }
216   static ErrorContext bad_stackmap(int index, StackMapFrame* frame) {
217     return ErrorContext(0, BAD_STACKMAP, TypeOrigin::frame(frame));
218   }
219 
220   bool is_valid() const { return _fault != NO_FAULT; }
221   int bci() const { return _bci; }
222 
223   void reset_frames() {
224     _type.reset_frame();
225     _expected.reset_frame();
226   }
227 
228   void details(outputStream* ss, const Method* method) const;
229 
230 #ifdef ASSERT
231   void print_on(outputStream* str) const {
232     str-&gt;print(&quot;error_context(%d, %d,&quot;, _bci, _fault);
233     _type.print_on(str);
234     str-&gt;print(&quot;,&quot;);
235     _expected.print_on(str);
236     str-&gt;print(&quot;)&quot;);
237   }
238 #endif
239 
240  private:
241   void location_details(outputStream* ss, const Method* method) const;
242   void reason_details(outputStream* ss) const;
243   void frame_details(outputStream* ss) const;
244   void bytecode_details(outputStream* ss, const Method* method) const;
245   void handler_details(outputStream* ss, const Method* method) const;
246   void stackmap_details(outputStream* ss, const Method* method) const;
247 };
248 
249 // A new instance of this class is created for each class being verified
250 class ClassVerifier : public StackObj {
251  private:
252   Thread* _thread;
253 
254   Symbol* _previous_symbol;          // cache of the previously looked up symbol
255   GrowableArray&lt;Symbol*&gt;* _symbols;  // keep a list of symbols created
256 
257   Symbol* _exception_type;
258   char* _message;
259 
260   ErrorContext _error_context;  // contains information about an error
261 
262   void verify_method(const methodHandle&amp; method, TRAPS);
263   char* generate_code_data(const methodHandle&amp; m, u4 code_length, TRAPS);
264   void verify_exception_handler_table(u4 code_length, char* code_data,
265                                       int&amp; min, int&amp; max, TRAPS);
266   void verify_local_variable_table(u4 code_length, char* code_data, TRAPS);
267 
268   VerificationType cp_ref_index_to_type(
269       int index, const constantPoolHandle&amp; cp, TRAPS) {
270     return cp_index_to_type(cp-&gt;klass_ref_index_at(index), cp, THREAD);
271   }
272 
273   bool is_protected_access(
274     InstanceKlass* this_class, Klass* target_class,
275     Symbol* field_name, Symbol* field_sig, bool is_method);
276 
277   void verify_cp_index(u2 bci, const constantPoolHandle&amp; cp, int index, TRAPS);
278   void verify_cp_type(u2 bci, int index, const constantPoolHandle&amp; cp,
279       unsigned int types, TRAPS);
280   void verify_cp_class_type(u2 bci, int index, const constantPoolHandle&amp; cp, TRAPS);
281 
282   u2 verify_stackmap_table(
283     u2 stackmap_index, u2 bci, StackMapFrame* current_frame,
284     StackMapTable* stackmap_table, bool no_control_flow, TRAPS);
285 
286   void verify_exception_handler_targets(
287     u2 bci, bool this_uninit, StackMapFrame* current_frame,
288     StackMapTable* stackmap_table, TRAPS);
289 
290   void verify_ldc(
291     int opcode, u2 index, StackMapFrame *current_frame,
292     const constantPoolHandle&amp; cp, u2 bci, TRAPS);
293 
294   void verify_switch(
295     RawBytecodeStream* bcs, u4 code_length, char* code_data,
296     StackMapFrame* current_frame, StackMapTable* stackmap_table, TRAPS);
297 
298   void verify_field_instructions(
299     RawBytecodeStream* bcs, StackMapFrame* current_frame,
300     const constantPoolHandle&amp; cp, bool allow_arrays, TRAPS);
301 
302   void verify_invoke_init(
303     RawBytecodeStream* bcs, u2 ref_index, VerificationType ref_class_type,
304     StackMapFrame* current_frame, u4 code_length, bool in_try_block,
305     bool* this_uninit, const constantPoolHandle&amp; cp, StackMapTable* stackmap_table,
306     TRAPS);
307 
308   // Used by ends_in_athrow() to push all handlers that contain bci onto the
309   // handler_stack, if the handler has not already been pushed on the stack.
310   void push_handlers(ExceptionTable* exhandlers,
311                      GrowableArray&lt;u4&gt;* handler_list,
312                      GrowableArray&lt;u4&gt;* handler_stack,
313                      u4 bci);
314 
315   // Returns true if all paths starting with start_bc_offset end in athrow
316   // bytecode or loop.
317   bool ends_in_athrow(u4 start_bc_offset);
318 
319   void verify_invoke_instructions(
320     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
321     bool in_try_block, bool* this_uninit, VerificationType return_type,
322     const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS);
323 
324   VerificationType get_newarray_type(u2 index, u2 bci, TRAPS);
325   void verify_anewarray(u2 bci, u2 index, const constantPoolHandle&amp; cp,
326       StackMapFrame* current_frame, TRAPS);
327   void verify_return_value(
328       VerificationType return_type, VerificationType type, u2 offset,
329       StackMapFrame* current_frame, TRAPS);
330 
331   void verify_iload (u2 index, StackMapFrame* current_frame, TRAPS);
332   void verify_lload (u2 index, StackMapFrame* current_frame, TRAPS);
333   void verify_fload (u2 index, StackMapFrame* current_frame, TRAPS);
334   void verify_dload (u2 index, StackMapFrame* current_frame, TRAPS);
335   void verify_aload (u2 index, StackMapFrame* current_frame, TRAPS);
336   void verify_istore(u2 index, StackMapFrame* current_frame, TRAPS);
337   void verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS);
338   void verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS);
339   void verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS);
340   void verify_astore(u2 index, StackMapFrame* current_frame, TRAPS);
341   void verify_iinc  (u2 index, StackMapFrame* current_frame, TRAPS);
342 
343   bool name_in_supers(Symbol* ref_name, InstanceKlass* current);
344 
345   VerificationType object_type() const;
346 
347   InstanceKlass*      _klass;  // the class being verified
348   methodHandle        _method; // current method being verified
349   VerificationType    _this_type; // the verification type of the current class
350 
351   // Some recursive calls from the verifier to the name resolver
352   // can cause the current class to be re-verified and rewritten.
353   // If this happens, the original verification should not continue,
354   // because constant pool indexes will have changed.
355   // The rewriter is preceded by the verifier.  If the verifier throws
356   // an error, rewriting is prevented.  Also, rewriting always precedes
357   // bytecode execution or compilation.  Thus, is_rewritten implies
358   // that a class has been verified and prepared for execution.
359   bool was_recursively_verified() { return _klass-&gt;is_rewritten(); }
360 
361   bool is_same_or_direct_interface(InstanceKlass* klass,
362     VerificationType klass_type, VerificationType ref_class_type);
363 
364  public:
365   enum {
366     BYTECODE_OFFSET = 1,
367     NEW_OFFSET = 2
368   };
369 
370   // constructor
371   ClassVerifier(InstanceKlass* klass, TRAPS);
372 
373   // destructor
374   ~ClassVerifier();
375 
376   Thread* thread()             { return _thread; }
377   const methodHandle&amp; method() { return _method; }
378   InstanceKlass* current_class() const { return _klass; }
379   VerificationType current_type() const { return _this_type; }
380 
381   // Verifies the class.  If a verify or class file format error occurs,
382   // the &#39;_exception_name&#39; symbols will set to the exception name and
383   // the message_buffer will be filled in with the exception message.
384   void verify_class(TRAPS);
385 
386   // Return status modes
387   Symbol* result() const { return _exception_type; }
388   bool has_error() const { return result() != NULL; }
389   char* exception_message() {
390     stringStream ss;
391     ss.print(&quot;%s&quot;, _message);
392     _error_context.details(&amp;ss, _method());
393     return ss.as_string();
394   }
395 
396   // Called when verify or class format errors are encountered.
397   // May throw an exception based upon the mode.
398   void verify_error(ErrorContext ctx, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);
399   void class_format_error(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);
400 
401   Klass* load_class(Symbol* name, TRAPS);
402 
403   int change_sig_to_verificationType(
404     SignatureStream* sig_type, VerificationType* inference_type, TRAPS);
405 
406   VerificationType cp_index_to_type(int index, const constantPoolHandle&amp; cp, TRAPS) {
407     return VerificationType::reference_type(cp-&gt;klass_name_at(index));
408   }
409 
410   // Keep a list of temporary symbols created during verification because
411   // their reference counts need to be decremented when the verifier object
412   // goes out of scope.  Since these symbols escape the scope in which they&#39;re
413   // created, we can&#39;t use a TempNewSymbol.
414   Symbol* create_temporary_symbol(const Symbol* s, int begin, int end, TRAPS);
415   Symbol* create_temporary_symbol(const char *s, int length, TRAPS);
416   Symbol* create_temporary_symbol(Symbol* s) {
417     if (s == _previous_symbol) {
418       return s;
419     }
420     if (!s-&gt;is_permanent()) {
421       s-&gt;increment_refcount();
422       if (_symbols == NULL) {
423         _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
424       }
425       _symbols-&gt;push(s);
426     }
427     _previous_symbol = s;
428     return s;
429   }
430 
431   TypeOrigin ref_ctx(const char* str, TRAPS);
432 
433 };
434 
435 inline int ClassVerifier::change_sig_to_verificationType(
436     SignatureStream* sig_type, VerificationType* inference_type, TRAPS) {
437   BasicType bt = sig_type-&gt;type();
438   switch (bt) {
439     case T_OBJECT:
440     case T_ARRAY:
441       {
442         Symbol* name = sig_type-&gt;as_symbol(CHECK_0);
443         // Create another symbol to save as signature stream unreferences this symbol.
444         Symbol* name_copy = create_temporary_symbol(name);
445         assert(name_copy == name, &quot;symbols don&#39;t match&quot;);
446         *inference_type =
447           VerificationType::reference_type(name_copy);
448         return 1;
449       }
450     case T_LONG:
451       *inference_type = VerificationType::long_type();
452       *++inference_type = VerificationType::long2_type();
453       return 2;
454     case T_DOUBLE:
455       *inference_type = VerificationType::double_type();
456       *++inference_type = VerificationType::double2_type();
457       return 2;
458     case T_INT:
459     case T_BOOLEAN:
460     case T_BYTE:
461     case T_CHAR:
462     case T_SHORT:
463       *inference_type = VerificationType::integer_type();
464       return 1;
465     case T_FLOAT:
466       *inference_type = VerificationType::float_type();
467       return 1;
468     default:
469       ShouldNotReachHere();
470       return 1;
471   }
472 }
473 
474 #endif // SHARE_CLASSFILE_VERIFIER_HPP
    </pre>
  </body>
</html>
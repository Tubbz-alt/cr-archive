<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaAssertions.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;classfile/altHashing.hpp&quot;
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/debugInfo.hpp&quot;
  #include &quot;code/dependencyContext.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,34 ***</span>
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vframe.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  #if INCLUDE_JVMCI
  #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  #endif
  
  #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
<span class="line-new-header">--- 40,38 ---</span>
  #include &quot;memory/heapShared.inline.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
<span class="line-added">+ #include &quot;oops/recordComponent.hpp&quot;</span>
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/resolvedMethodTable.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/init.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vframe.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/vm_version.hpp&quot;</span>
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  #if INCLUDE_JVMCI
  #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  #endif
  
  #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,10 ***</span>
<span class="line-new-header">--- 87,25 ---</span>
  
  InjectedField JavaClasses::_injected_fields[] = {
    ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  };
  
<span class="line-added">+ // Register native methods of Object</span>
<span class="line-added">+ void java_lang_Object::register_natives(TRAPS) {</span>
<span class="line-added">+   InstanceKlass* obj = SystemDictionary::Object_klass();</span>
<span class="line-added">+   Method::register_native(obj, vmSymbols::hashCode_name(),</span>
<span class="line-added">+                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);</span>
<span class="line-added">+   Method::register_native(obj, vmSymbols::wait_name(),</span>
<span class="line-added">+                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);</span>
<span class="line-added">+   Method::register_native(obj, vmSymbols::notify_name(),</span>
<span class="line-added">+                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);</span>
<span class="line-added">+   Method::register_native(obj, vmSymbols::notifyAll_name(),</span>
<span class="line-added">+                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);</span>
<span class="line-added">+   Method::register_native(obj, vmSymbols::clone_name(),</span>
<span class="line-added">+                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int JavaClasses::compute_injected_offset(InjectedFieldID id) {
    return _injected_fields[id].compute_offset();
  }
  
  InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,10 ***</span>
<span class="line-new-header">--- 177,11 ---</span>
    compute_offset(dest_offset, ik, name, signature_symbol, is_static);
  }
  
  int java_lang_String::value_offset  = 0;
  int java_lang_String::hash_offset   = 0;
<span class="line-added">+ int java_lang_String::hashIsZero_offset = 0;</span>
  int java_lang_String::coder_offset  = 0;
  
  bool java_lang_String::initialized  = false;
  
  bool java_lang_String::is_instance(oop obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
    compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
  
  #define STRING_FIELDS_DO(macro) \
    macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
    macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
<span class="line-modified">!   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false)</span>
  
  void java_lang_String::compute_offsets() {
    if (initialized) {
      return;
    }
<span class="line-new-header">--- 197,12 ---</span>
    compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
  
  #define STRING_FIELDS_DO(macro) \
    macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
    macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
<span class="line-modified">!   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-added">+   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
  
  void java_lang_String::compute_offsets() {
    if (initialized) {
      return;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,11 ***</span>
  }
  
  #if INCLUDE_CDS
  void java_lang_String::serialize_offsets(SerializeClosure* f) {
    STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified">!   f-&gt;do_u4((u4*)&amp;initialized);</span>
  }
  #endif
  
  class CompactStringsFixup : public FieldClosure {
  private:
<span class="line-new-header">--- 214,11 ---</span>
  }
  
  #if INCLUDE_CDS
  void java_lang_String::serialize_offsets(SerializeClosure* f) {
    STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified">!   f-&gt;do_bool(&amp;initialized);</span>
  }
  #endif
  
  class CompactStringsFixup : public FieldClosure {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,11 ***</span>
    }
  };
  
  void java_lang_String::set_compact_strings(bool value) {
    CompactStringsFixup fix(value);
<span class="line-modified">!   InstanceKlass::cast(SystemDictionary::String_klass())-&gt;do_local_static_fields(&amp;fix);</span>
  }
  
  Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
    assert(initialized, &quot;Must be initialized&quot;);
    assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
<span class="line-new-header">--- 237,11 ---</span>
    }
  };
  
  void java_lang_String::set_compact_strings(bool value) {
    CompactStringsFixup fix(value);
<span class="line-modified">!   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);</span>
  }
  
  Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
    assert(initialized, &quot;Must be initialized&quot;);
    assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,29 ***</span>
  
  // Converts a C string to a Java String based on current encoding
  Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
    assert(str != NULL, &quot;bad arguments&quot;);
  
<span class="line-modified">!   typedef jstring (*to_java_string_fn_t)(JNIEnv*, const char *);</span>
    static to_java_string_fn_t _to_java_string_fn = NULL;
  
    if (_to_java_string_fn == NULL) {
      void *lib_handle = os::native_java_library();
<span class="line-modified">!     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;NewStringPlatform&quot;));</span>
      if (_to_java_string_fn == NULL) {
<span class="line-modified">!       fatal(&quot;NewStringPlatform missing&quot;);</span>
      }
    }
  
    jstring js = NULL;
<span class="line-modified">!   { JavaThread* thread = (JavaThread*)THREAD;</span>
<span class="line-modified">!     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>
      HandleMark hm(thread);
      ThreadToNativeFromVM ttn(thread);
      js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
    }
<span class="line-modified">!   return Handle(THREAD, JNIHandles::resolve(js));</span>
  }
  
  // Converts a Java String to a native C string that can be used for
  // native OS calls.
  char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
<span class="line-new-header">--- 387,39 ---</span>
  
  // Converts a C string to a Java String based on current encoding
  Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
    assert(str != NULL, &quot;bad arguments&quot;);
  
<span class="line-modified">!   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);</span>
    static to_java_string_fn_t _to_java_string_fn = NULL;
  
    if (_to_java_string_fn == NULL) {
      void *lib_handle = os::native_java_library();
<span class="line-modified">!     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));</span>
<span class="line-added">+ #if defined(_WIN32) &amp;&amp; !defined(_WIN64)</span>
<span class="line-added">+     if (_to_java_string_fn == NULL) {</span>
<span class="line-added">+       // On 32 bit Windows, also try __stdcall decorated name</span>
<span class="line-added">+       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
      if (_to_java_string_fn == NULL) {
<span class="line-modified">!       fatal(&quot;JNU_NewStringPlatform missing&quot;);</span>
      }
    }
  
    jstring js = NULL;
<span class="line-modified">!   {</span>
<span class="line-modified">!     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);</span>
<span class="line-added">+     JavaThread* thread = (JavaThread*)THREAD;</span>
      HandleMark hm(thread);
      ThreadToNativeFromVM ttn(thread);
      js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
    }
<span class="line-modified">! </span>
<span class="line-added">+   Handle native_platform_string(THREAD, JNIHandles::resolve(js));</span>
<span class="line-added">+   JNIHandles::destroy_local(js);  // destroy local JNIHandle.</span>
<span class="line-added">+   return native_platform_string;</span>
  }
  
  // Converts a Java String to a native C string that can be used for
  // native OS calls.
  char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,22 ***</span>
    }
    return result;
  }
  
  unsigned int java_lang_String::hash_code(oop java_string) {
<span class="line-modified">!   typeArrayOop value  = java_lang_String::value(java_string);</span>
<span class="line-modified">!   int          length = java_lang_String::length(java_string, value);</span>
<span class="line-modified">!   // Zero length string will hash to zero with String.hashCode() function.</span>
<span class="line-modified">!   if (length == 0) return 0;</span>
  
<span class="line-modified">!   bool      is_latin1 = java_lang_String::is_latin1(java_string);</span>
  
<span class="line-modified">!   if (is_latin1) {</span>
<span class="line-modified">!     return java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);</span>
    } else {
<span class="line-modified">!     return java_lang_String::hash_code(value-&gt;char_at_addr(0), length);</span>
    }
  }
  
  char* java_lang_String::as_quoted_ascii(oop java_string) {
    typeArrayOop value  = java_lang_String::value(java_string);
    int          length = java_lang_String::length(java_string, value);
<span class="line-new-header">--- 536,42 ---</span>
    }
    return result;
  }
  
  unsigned int java_lang_String::hash_code(oop java_string) {
<span class="line-modified">!   // The hash and hashIsZero fields are subject to a benign data race,</span>
<span class="line-modified">!   // making it crucial to ensure that any observable result of the</span>
<span class="line-modified">!   // calculation in this method stays correct under any possible read of</span>
<span class="line-modified">!   // these fields. Necessary restrictions to allow this to be correct</span>
<span class="line-added">+   // without explicit memory fences or similar concurrency primitives is</span>
<span class="line-added">+   // that we can ever only write to one of these two fields for a given</span>
<span class="line-added">+   // String instance, and that the computation is idempotent and derived</span>
<span class="line-added">+   // from immutable state</span>
<span class="line-added">+   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
<span class="line-added">+   if (java_lang_String::hash_is_set(java_string)) {</span>
<span class="line-added">+     return java_string-&gt;int_field(hash_offset);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   typeArrayOop value = java_lang_String::value(java_string);</span>
<span class="line-added">+   int         length = java_lang_String::length(java_string, value);</span>
<span class="line-added">+   bool     is_latin1 = java_lang_String::is_latin1(java_string);</span>
  
<span class="line-modified">!   unsigned int hash = 0;</span>
<span class="line-modified">!   if (length &gt; 0) {</span>
<span class="line-added">+     if (is_latin1) {</span>
<span class="line-added">+       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (hash != 0) {</span>
<span class="line-added">+     java_string-&gt;int_field_put(hash_offset, hash);</span>
    } else {
<span class="line-modified">!     java_string-&gt;bool_field_put(hashIsZero_offset, true);</span>
    }
<span class="line-added">+   return hash;</span>
  }
  
  char* java_lang_String::as_quoted_ascii(oop java_string) {
    typeArrayOop value  = java_lang_String::value(java_string);
    int          length = java_lang_String::length(java_string, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,23 ***</span>
    assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
    assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
    return result;
  }
  
<span class="line-modified">! Symbol* java_lang_String::as_symbol(oop java_string, TRAPS) {</span>
    typeArrayOop value  = java_lang_String::value(java_string);
    int          length = java_lang_String::length(java_string, value);
    bool      is_latin1 = java_lang_String::is_latin1(java_string);
    if (!is_latin1) {
      jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
<span class="line-modified">!     Symbol* sym = SymbolTable::lookup_unicode(base, length, THREAD);</span>
      return sym;
    } else {
      ResourceMark rm;
      jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
      const char* base = UNICODE::as_utf8(position, length);
<span class="line-modified">!     Symbol* sym = SymbolTable::lookup(base, length, THREAD);</span>
      return sym;
    }
  }
  
  Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
<span class="line-new-header">--- 595,23 ---</span>
    assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
    assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
    return result;
  }
  
<span class="line-modified">! Symbol* java_lang_String::as_symbol(oop java_string) {</span>
    typeArrayOop value  = java_lang_String::value(java_string);
    int          length = java_lang_String::length(java_string, value);
    bool      is_latin1 = java_lang_String::is_latin1(java_string);
    if (!is_latin1) {
      jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
<span class="line-modified">!     Symbol* sym = SymbolTable::new_symbol(base, length);</span>
      return sym;
    } else {
      ResourceMark rm;
      jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
      const char* base = UNICODE::as_utf8(position, length);
<span class="line-modified">!     Symbol* sym = SymbolTable::new_symbol(base, length);</span>
      return sym;
    }
  }
  
  Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,11 ***</span>
      // for java.base is known. But note that since we captured the NULL module another
      // thread may have completed that initialization.
  
      bool javabase_was_defined = false;
      {
<span class="line-modified">!       MutexLocker m1(Module_lock, THREAD);</span>
        // Keep list of classes needing java.base module fixup
        if (!ModuleEntryTable::javabase_defined()) {
          assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
          k-&gt;class_loader_data()-&gt;inc_keep_alive();
          assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
<span class="line-new-header">--- 880,11 ---</span>
      // for java.base is known. But note that since we captured the NULL module another
      // thread may have completed that initialization.
  
      bool javabase_was_defined = false;
      {
<span class="line-modified">!       MutexLocker m1(THREAD, Module_lock);</span>
        // Keep list of classes needing java.base module fixup
        if (!ModuleEntryTable::javabase_defined()) {
          assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
          k-&gt;class_loader_data()-&gt;inc_keep_alive();
          assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,11 ***</span>
        set_module(mirror(), javabase_handle());
      }
    } else {
      assert(Universe::is_module_initialized() ||
             (ModuleEntryTable::javabase_defined() &amp;&amp;
<span class="line-modified">!             (oopDesc::equals(module(), ModuleEntryTable::javabase_moduleEntry()-&gt;module()))),</span>
             &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
      set_module(mirror(), module());
    }
  }
  
<span class="line-new-header">--- 903,11 ---</span>
        set_module(mirror(), javabase_handle());
      }
    } else {
      assert(Universe::is_module_initialized() ||
             (ModuleEntryTable::javabase_defined() &amp;&amp;
<span class="line-modified">!             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),</span>
             &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
      set_module(mirror(), module());
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,11 ***</span>
          return;
        }
      }
  
      // set the classLoader field in the java_lang_Class instance
<span class="line-modified">!     assert(oopDesc::equals(class_loader(), k-&gt;class_loader()), &quot;should be same&quot;);</span>
      set_class_loader(mirror(), class_loader());
  
      // Setup indirection from klass-&gt;mirror
      // after any exceptions can happen during allocations.
      k-&gt;set_java_mirror(mirror);
<span class="line-new-header">--- 980,11 ---</span>
          return;
        }
      }
  
      // set the classLoader field in the java_lang_Class instance
<span class="line-modified">!     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);</span>
      set_class_loader(mirror(), class_loader());
  
      // Setup indirection from klass-&gt;mirror
      // after any exceptions can happen during allocations.
      k-&gt;set_java_mirror(mirror);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,11 ***</span>
        oop archived_m = HeapShared::archive_heap_object(m, THREAD);
        assert(archived_m != NULL, &quot;sanity&quot;);
        Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
        assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
        if (ak != NULL) {
<span class="line-modified">!         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak);</span>
          archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
        }
  
        // Clear the fields. Just to be safe
        Klass *k = m-&gt;klass();
<span class="line-new-header">--- 1076,11 ---</span>
        oop archived_m = HeapShared::archive_heap_object(m, THREAD);
        assert(archived_m != NULL, &quot;sanity&quot;);
        Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
        assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
        if (ak != NULL) {
<span class="line-modified">!         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);</span>
          archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
        }
  
        // Clear the fields. Just to be safe
        Klass *k = m-&gt;klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,29 ***</span>
    set_module(archived_mirror, NULL);
  
    // The archived mirror&#39;s field at _klass_offset is still pointing to the original
    // klass. Updated the field in the archived mirror to point to the relocated
    // klass in the archive.
<span class="line-modified">!   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror));</span>
    log_debug(cds, heap, mirror)(
      &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
      p2i(as_Klass(mirror)), p2i(reloc_k));
    archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
  
    // The field at _array_klass_offset is pointing to the original one dimension
    // higher array klass if exists. Relocate the pointer.
    Klass *arr = array_klass_acquire(mirror);
    if (arr != NULL) {
<span class="line-modified">!     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr);</span>
      log_debug(cds, heap, mirror)(
        &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
        p2i(arr), p2i(reloc_arr));
      archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
    }
    return archived_mirror;
  }
  
  // Returns true if the mirror is updated, false if no archived mirror
  // data is present. After the archived mirror object is restored, the
  // shared klass&#39; _has_raw_archived_mirror flag is cleared.
  bool java_lang_Class::restore_archived_mirror(Klass *k,
                                                Handle class_loader, Handle module,
<span class="line-new-header">--- 1221,56 ---</span>
    set_module(archived_mirror, NULL);
  
    // The archived mirror&#39;s field at _klass_offset is still pointing to the original
    // klass. Updated the field in the archived mirror to point to the relocated
    // klass in the archive.
<span class="line-modified">!   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);</span>
    log_debug(cds, heap, mirror)(
      &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
      p2i(as_Klass(mirror)), p2i(reloc_k));
    archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
  
    // The field at _array_klass_offset is pointing to the original one dimension
    // higher array klass if exists. Relocate the pointer.
    Klass *arr = array_klass_acquire(mirror);
    if (arr != NULL) {
<span class="line-modified">!     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);</span>
      log_debug(cds, heap, mirror)(
        &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
        p2i(arr), p2i(reloc_arr));
      archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
    }
    return archived_mirror;
  }
  
<span class="line-added">+ void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {</span>
<span class="line-added">+   if (MetaspaceShared::relocation_delta() != 0) {</span>
<span class="line-added">+     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-added">+     if (ak != NULL) {</span>
<span class="line-added">+       archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-added">+           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {</span>
<span class="line-added">+   if (MetaspaceShared::relocation_delta() != 0) {</span>
<span class="line-added">+     Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));</span>
<span class="line-added">+     archived_mirror-&gt;metadata_field_put(_klass_offset,</span>
<span class="line-added">+         (Klass*)(address(k) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));</span>
<span class="line-added">+     if (ak != NULL) {</span>
<span class="line-added">+       archived_mirror-&gt;metadata_field_put(_array_klass_offset,</span>
<span class="line-added">+           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // Returns true if the mirror is updated, false if no archived mirror
  // data is present. After the archived mirror object is restored, the
  // shared klass&#39; _has_raw_archived_mirror flag is cleared.
  bool java_lang_Class::restore_archived_mirror(Klass *k,
                                                Handle class_loader, Handle module,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1203,19 ***</span>
      fixup_mirror_list()-&gt;push(k);
      return true;
    }
  
    oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
<span class="line-removed">- </span>
    if (m == NULL) {
      return false;
    }
  
<span class="line-removed">-   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));</span>
<span class="line-removed">- </span>
    // mirror is archived, restore
    assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
    Handle mirror(THREAD, m);
  
    if (!k-&gt;is_array_klass()) {
      // - local static final fields with initial values were initialized at dump time
  
<span class="line-new-header">--- 1282,19 ---</span>
      fixup_mirror_list()-&gt;push(k);
      return true;
    }
  
    oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
    if (m == NULL) {
      return false;
    }
  
    // mirror is archived, restore
<span class="line-added">+   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));</span>
    assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
<span class="line-added">+   update_archived_mirror_native_pointers(m);</span>
<span class="line-added">+   assert(as_Klass(m) == k, &quot;must be&quot;);</span>
    Handle mirror(THREAD, m);
  
    if (!k-&gt;is_array_klass()) {
      // - local static final fields with initial values were initialized at dump time
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,13 ***</span>
    k-&gt;set_java_mirror(mirror);
    k-&gt;clear_has_raw_archived_mirror();
  
    set_mirror_module_field(k, mirror, module, THREAD);
  
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   log_trace(cds, heap, mirror)(</span>
<span class="line-modified">!     &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));</span>
  
    return true;
  }
  #endif // INCLUDE_CDS_JAVA_HEAP
  
<span class="line-new-header">--- 1315,15 ---</span>
    k-&gt;set_java_mirror(mirror);
    k-&gt;clear_has_raw_archived_mirror();
  
    set_mirror_module_field(k, mirror, module, THREAD);
  
<span class="line-modified">!   if (log_is_enabled(Trace, cds, heap, mirror)) {</span>
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
<span class="line-modified">!     log_trace(cds, heap, mirror)(</span>
<span class="line-added">+         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));</span>
<span class="line-added">+   }</span>
  
    return true;
  }
  #endif // INCLUDE_CDS_JAVA_HEAP
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1324,14 ***</span>
    java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
  }
  
  
  void java_lang_Class::set_class_loader(oop java_class, oop loader) {
<span class="line-modified">!   // jdk7 runs Queens in bootstrapping and jdk8-9 has no coordinated pushes yet.</span>
<span class="line-modified">!   if (_class_loader_offset != 0) {</span>
<span class="line-removed">-     java_class-&gt;obj_field_put(_class_loader_offset, loader);</span>
<span class="line-removed">-   }</span>
  }
  
  oop java_lang_Class::class_loader(oop java_class) {
    assert(_class_loader_offset != 0, &quot;must be set&quot;);
    return java_class-&gt;obj_field(_class_loader_offset);
<span class="line-new-header">--- 1405,12 ---</span>
    java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
  }
  
  
  void java_lang_Class::set_class_loader(oop java_class, oop loader) {
<span class="line-modified">!   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">!   java_class-&gt;obj_field_put(_class_loader_offset, loader);</span>
  }
  
  oop java_lang_Class::class_loader(oop java_class) {
    assert(_class_loader_offset != 0, &quot;must be set&quot;);
    return java_class-&gt;obj_field(_class_loader_offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1425,11 ***</span>
    if (is_instance)  st-&gt;print(&quot;L&quot;);
    st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
    if (is_instance)  st-&gt;print(&quot;;&quot;);
  }
  
<span class="line-modified">! Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found, TRAPS) {</span>
    assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
    Symbol* name;
    if (is_primitive(java_class)) {
      name = vmSymbols::type_signature(primitive_type(java_class));
      // Because this can create a new symbol, the caller has to decrement
<span class="line-new-header">--- 1504,11 ---</span>
    if (is_instance)  st-&gt;print(&quot;L&quot;);
    st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
    if (is_instance)  st-&gt;print(&quot;;&quot;);
  }
  
<span class="line-modified">! Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {</span>
    assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
    Symbol* name;
    if (is_primitive(java_class)) {
      name = vmSymbols::type_signature(primitive_type(java_class));
      // Because this can create a new symbol, the caller has to decrement
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1446,11 ***</span>
        const char* sigstr = k-&gt;signature_name();
        int         siglen = (int) strlen(sigstr);
        if (!intern_if_not_found) {
          name = SymbolTable::probe(sigstr, siglen);
        } else {
<span class="line-modified">!         name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
        }
      }
    }
    return name;
  }
<span class="line-new-header">--- 1525,11 ---</span>
        const char* sigstr = k-&gt;signature_name();
        int         siglen = (int) strlen(sigstr);
        if (!intern_if_not_found) {
          name = SymbolTable::probe(sigstr, siglen);
        } else {
<span class="line-modified">!         name = SymbolTable::new_symbol(sigstr, siglen);</span>
        }
      }
    }
    return name;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1491,13 ***</span>
    BasicType type = T_VOID;
    if (ak != NULL) {
      // Note: create_basic_type_mirror above initializes ak to a non-null value.
      type = ArrayKlass::cast(ak)-&gt;element_type();
    } else {
<span class="line-modified">!     assert(oopDesc::equals(java_class, Universe::void_mirror()), &quot;only valid non-array primitive&quot;);</span>
    }
<span class="line-modified">!   assert(oopDesc::equals(Universe::java_mirror(type), java_class), &quot;must be consistent&quot;);</span>
    return type;
  }
  
  BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
    assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
<span class="line-new-header">--- 1570,13 ---</span>
    BasicType type = T_VOID;
    if (ak != NULL) {
      // Note: create_basic_type_mirror above initializes ak to a non-null value.
      type = ArrayKlass::cast(ak)-&gt;element_type();
    } else {
<span class="line-modified">!     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);</span>
    }
<span class="line-modified">!   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);</span>
    return type;
  }
  
  BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
    assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1522,11 ***</span>
  
  bool java_lang_Class::offsets_computed = false;
  int  java_lang_Class::classRedefinedCount_offset = -1;
  
  #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">!   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false) ; \</span>
    macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
    macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
    macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
    macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
  
<span class="line-new-header">--- 1601,11 ---</span>
  
  bool java_lang_Class::offsets_computed = false;
  int  java_lang_Class::classRedefinedCount_offset = -1;
  
  #define CLASS_FIELDS_DO(macro) \
<span class="line-modified">!   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
    macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
    macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
    macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
    macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1548,34 ***</span>
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
  
  #if INCLUDE_CDS
  void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">!   f-&gt;do_u4((u4*)&amp;offsets_computed);</span>
    f-&gt;do_u4((u4*)&amp;_init_lock_offset);
  
    CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">!   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">-     // If we don&#39;t have an offset for it then just return -1 as a marker.</span>
<span class="line-removed">-     return -1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
  }
  
  void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">!   if (classRedefinedCount_offset == -1) {</span>
<span class="line-removed">-     // If we don&#39;t have an offset for it then nothing to set.</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
  }
  
  
  // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
<span class="line-new-header">--- 1627,26 ---</span>
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
  }
  
  #if INCLUDE_CDS
  void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">!   f-&gt;do_bool(&amp;offsets_computed);</span>
    f-&gt;do_u4((u4*)&amp;_init_lock_offset);
  
    CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  
    CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
  int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">!   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
    return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
  }
  
  void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">!   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
    the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
  }
  
  
  // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1590,32 ***</span>
  int java_lang_Thread::_group_offset = 0;
  int java_lang_Thread::_contextClassLoader_offset = 0;
  int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
  int java_lang_Thread::_priority_offset = 0;
  int java_lang_Thread::_eetop_offset = 0;
  int java_lang_Thread::_daemon_offset = 0;
  int java_lang_Thread::_stillborn_offset = 0;
  int java_lang_Thread::_stackSize_offset = 0;
  int java_lang_Thread::_tid_offset = 0;
  int java_lang_Thread::_thread_status_offset = 0;
  int java_lang_Thread::_park_blocker_offset = 0;
<span class="line-removed">- int java_lang_Thread::_park_event_offset = 0 ;</span>
  
  #define THREAD_FIELDS_DO(macro) \
    macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
    macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
    macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
    macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
    macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
    macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
    macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
    macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
    macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
    macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
    macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
<span class="line-modified">!   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false); \</span>
<span class="line-removed">-   macro(_park_event_offset,    k, &quot;nativeParkEventPointer&quot;, long_signature, false)</span>
  
  void java_lang_Thread::compute_offsets() {
    assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
  
    InstanceKlass* k = SystemDictionary::Thread_klass();
<span class="line-new-header">--- 1661,32 ---</span>
  int java_lang_Thread::_group_offset = 0;
  int java_lang_Thread::_contextClassLoader_offset = 0;
  int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
  int java_lang_Thread::_priority_offset = 0;
  int java_lang_Thread::_eetop_offset = 0;
<span class="line-added">+ int java_lang_Thread::_interrupted_offset = 0;</span>
  int java_lang_Thread::_daemon_offset = 0;
  int java_lang_Thread::_stillborn_offset = 0;
  int java_lang_Thread::_stackSize_offset = 0;
  int java_lang_Thread::_tid_offset = 0;
  int java_lang_Thread::_thread_status_offset = 0;
  int java_lang_Thread::_park_blocker_offset = 0;
  
  #define THREAD_FIELDS_DO(macro) \
    macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
    macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
    macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
    macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
    macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
    macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
    macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
<span class="line-added">+   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \</span>
    macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
    macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
    macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
    macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
<span class="line-modified">!   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)</span>
  
  void java_lang_Thread::compute_offsets() {
    assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
  
    InstanceKlass* k = SystemDictionary::Thread_klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1635,10 ***</span>
<span class="line-new-header">--- 1706,28 ---</span>
  
  void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
    java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
  }
  
<span class="line-added">+ bool java_lang_Thread::interrupted(oop java_thread) {</span>
<span class="line-added">+   // Make sure the caller can safely access oops.</span>
<span class="line-added">+   assert(Thread::current()-&gt;is_VM_thread() ||</span>
<span class="line-added">+          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;</span>
<span class="line-added">+           JavaThread::current()-&gt;thread_state() != _thread_in_native),</span>
<span class="line-added">+          &quot;Unsafe access to oop&quot;);</span>
<span class="line-added">+   return java_thread-&gt;bool_field_volatile(_interrupted_offset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Thread::set_interrupted(oop java_thread, bool val) {</span>
<span class="line-added">+   // Make sure the caller can safely access oops.</span>
<span class="line-added">+   assert(Thread::current()-&gt;is_VM_thread() ||</span>
<span class="line-added">+          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;</span>
<span class="line-added">+           JavaThread::current()-&gt;thread_state() != _thread_in_native),</span>
<span class="line-added">+          &quot;Unsafe access to oop&quot;);</span>
<span class="line-added">+   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  
  oop java_lang_Thread::name(oop java_thread) {
    return java_thread-&gt;obj_field(_name_offset);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1697,89 ***</span>
    return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
  }
  
  
  jlong java_lang_Thread::stackSize(oop java_thread) {
<span class="line-modified">!   if (_stackSize_offset &gt; 0) {</span>
<span class="line-removed">-     return java_thread-&gt;long_field(_stackSize_offset);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
  }
  
  // Write the thread status value to threadStatus field in java.lang.Thread java class.
  void java_lang_Thread::set_thread_status(oop java_thread,
                                           java_lang_Thread::ThreadStatus status) {
<span class="line-modified">!   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">-   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">-     java_thread-&gt;int_field_put(_thread_status_offset, status);</span>
<span class="line-removed">-   }</span>
  }
  
  // Read thread status value from threadStatus field in java.lang.Thread java class.
  java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
    // Make sure the caller is operating on behalf of the VM or is
    // running VM code (state == _thread_in_vm).
    assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
           JavaThread::current()-&gt;thread_state() == _thread_in_vm,
           &quot;Java Thread is not running in vm&quot;);
<span class="line-modified">!   // The threadStatus is only present starting in 1.5</span>
<span class="line-removed">-   if (_thread_status_offset &gt; 0) {</span>
<span class="line-removed">-     return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // All we can easily figure out is if it is alive, but that is</span>
<span class="line-removed">-     // enough info for a valid unknown status.</span>
<span class="line-removed">-     // These aren&#39;t restricted to valid set ThreadStatus values, so</span>
<span class="line-removed">-     // use JVMTI values and cast.</span>
<span class="line-removed">-     JavaThread* thr = java_lang_Thread::thread(java_thread);</span>
<span class="line-removed">-     if (thr == NULL) {</span>
<span class="line-removed">-       // the thread hasn&#39;t run yet or is in the process of exiting</span>
<span class="line-removed">-       return NEW;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return (java_lang_Thread::ThreadStatus)JVMTI_THREAD_STATE_ALIVE;</span>
<span class="line-removed">-   }</span>
  }
  
  
  jlong java_lang_Thread::thread_id(oop java_thread) {
<span class="line-modified">!   // The thread ID field is only present starting in 1.5</span>
<span class="line-removed">-   if (_tid_offset &gt; 0) {</span>
<span class="line-removed">-     return java_thread-&gt;long_field(_tid_offset);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">-   }</span>
  }
  
  oop java_lang_Thread::park_blocker(oop java_thread) {
<span class="line-modified">!   assert(JDK_Version::current().supports_thread_park_blocker() &amp;&amp;</span>
<span class="line-removed">-          _park_blocker_offset != 0, &quot;Must support parkBlocker field&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (_park_blocker_offset &gt; 0) {</span>
<span class="line-removed">-     return java_thread-&gt;obj_field(_park_blocker_offset);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- jlong java_lang_Thread::park_event(oop java_thread) {</span>
<span class="line-removed">-   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">-     return java_thread-&gt;long_field(_park_event_offset);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return 0;</span>
  }
  
<span class="line-removed">- bool java_lang_Thread::set_park_event(oop java_thread, jlong ptr) {</span>
<span class="line-removed">-   if (_park_event_offset &gt; 0) {</span>
<span class="line-removed">-     java_thread-&gt;long_field_put(_park_event_offset, ptr);</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  const char* java_lang_Thread::thread_status_name(oop java_thread) {
<span class="line-removed">-   assert(_thread_status_offset != 0, &quot;Must have thread status&quot;);</span>
    ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
    switch (status) {
      case NEW                      : return &quot;NEW&quot;;
      case RUNNABLE                 : return &quot;RUNNABLE&quot;;
      case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
<span class="line-new-header">--- 1786,39 ---</span>
    return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
  }
  
  
  jlong java_lang_Thread::stackSize(oop java_thread) {
<span class="line-modified">!   return java_thread-&gt;long_field(_stackSize_offset);</span>
  }
  
  // Write the thread status value to threadStatus field in java.lang.Thread java class.
  void java_lang_Thread::set_thread_status(oop java_thread,
                                           java_lang_Thread::ThreadStatus status) {
<span class="line-modified">!   java_thread-&gt;int_field_put(_thread_status_offset, status);</span>
  }
  
  // Read thread status value from threadStatus field in java.lang.Thread java class.
  java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
    // Make sure the caller is operating on behalf of the VM or is
    // running VM code (state == _thread_in_vm).
    assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
           JavaThread::current()-&gt;thread_state() == _thread_in_vm,
           &quot;Java Thread is not running in vm&quot;);
<span class="line-modified">!   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);</span>
  }
  
  
  jlong java_lang_Thread::thread_id(oop java_thread) {
<span class="line-modified">!   return java_thread-&gt;long_field(_tid_offset);</span>
  }
  
  oop java_lang_Thread::park_blocker(oop java_thread) {
<span class="line-modified">!   return java_thread-&gt;obj_field(_park_blocker_offset);</span>
  }
  
  const char* java_lang_Thread::thread_status_name(oop java_thread) {
    ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
    switch (status) {
      case NEW                      : return &quot;NEW&quot;;
      case RUNNABLE                 : return &quot;RUNNABLE&quot;;
      case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1929,11 ***</span>
  // Return Symbol for detailed_message or NULL
  Symbol* java_lang_Throwable::detail_message(oop throwable) {
    PRESERVE_EXCEPTION_MARK;  // Keep original exception
    oop detailed_message = java_lang_Throwable::message(throwable);
    if (detailed_message != NULL) {
<span class="line-modified">!     return java_lang_String::as_symbol(detailed_message, THREAD);</span>
    }
    return NULL;
  }
  
  void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-new-header">--- 1968,11 ---</span>
  // Return Symbol for detailed_message or NULL
  Symbol* java_lang_Throwable::detail_message(oop throwable) {
    PRESERVE_EXCEPTION_MARK;  // Keep original exception
    oop detailed_message = java_lang_Throwable::message(throwable);
    if (detailed_message != NULL) {
<span class="line-modified">!     return java_lang_String::as_symbol(detailed_message);</span>
    }
    return NULL;
  }
  
  void java_lang_Throwable::set_message(oop throwable, oop value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,32 ***</span>
  static inline bool version_matches(Method* method, int version) {
    assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
    return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
  }
  
<span class="line-removed">- </span>
  // This class provides a simple wrapper over the internal structure of
  // exception backtrace to insulate users of the backtrace from needing
  // to know what it looks like.
  class BacktraceBuilder: public StackObj {
   friend class BacktraceIterator;
   private:
    Handle          _backtrace;
    objArrayOop     _head;
    typeArrayOop    _methods;
    typeArrayOop    _bcis;
    objArrayOop     _mirrors;
<span class="line-modified">!   typeArrayOop    _names; // needed to insulate method name against redefinition</span>
    int             _index;
    NoSafepointVerifier _nsv;
  
    enum {
      trace_methods_offset = java_lang_Throwable::trace_methods_offset,
      trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
      trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
      trace_names_offset   = java_lang_Throwable::trace_names_offset,
      trace_next_offset    = java_lang_Throwable::trace_next_offset,
      trace_size           = java_lang_Throwable::trace_size,
      trace_chunk_size     = java_lang_Throwable::trace_chunk_size
    };
  
    // get info out of chunks
<span class="line-new-header">--- 2006,38 ---</span>
  static inline bool version_matches(Method* method, int version) {
    assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
    return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
  }
  
  // This class provides a simple wrapper over the internal structure of
  // exception backtrace to insulate users of the backtrace from needing
  // to know what it looks like.
<span class="line-added">+ // The code of this class is not GC safe. Allocations can only happen</span>
<span class="line-added">+ // in expand().</span>
  class BacktraceBuilder: public StackObj {
   friend class BacktraceIterator;
   private:
    Handle          _backtrace;
    objArrayOop     _head;
    typeArrayOop    _methods;
    typeArrayOop    _bcis;
    objArrayOop     _mirrors;
<span class="line-modified">!   typeArrayOop    _names; // Needed to insulate method name against redefinition.</span>
<span class="line-added">+   // This is set to a java.lang.Boolean(true) if the top frame</span>
<span class="line-added">+   // of the backtrace is omitted because it shall be hidden.</span>
<span class="line-added">+   // Else it is null.</span>
<span class="line-added">+   oop             _has_hidden_top_frame;</span>
    int             _index;
    NoSafepointVerifier _nsv;
  
    enum {
      trace_methods_offset = java_lang_Throwable::trace_methods_offset,
      trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
      trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
      trace_names_offset   = java_lang_Throwable::trace_names_offset,
      trace_next_offset    = java_lang_Throwable::trace_next_offset,
<span class="line-added">+     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,</span>
      trace_size           = java_lang_Throwable::trace_size,
      trace_chunk_size     = java_lang_Throwable::trace_chunk_size
    };
  
    // get info out of chunks
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2014,25 ***</span>
    static typeArrayOop get_names(objArrayHandle chunk) {
      typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
      assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
      return names;
    }
  
   public:
  
    // constructor for new backtrace
<span class="line-modified">!   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL) {</span>
      expand(CHECK);
      _backtrace = Handle(THREAD, _head);
      _index = 0;
    }
  
    BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
      _methods = get_methods(backtrace);
      _bcis = get_bcis(backtrace);
      _mirrors = get_mirrors(backtrace);
      _names = get_names(backtrace);
      assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
             _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
             _mirrors-&gt;length() == _names-&gt;length(),
             &quot;method and source information arrays should match&quot;);
  
<span class="line-new-header">--- 2059,30 ---</span>
    static typeArrayOop get_names(objArrayHandle chunk) {
      typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
      assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
      return names;
    }
<span class="line-added">+   static oop get_has_hidden_top_frame(objArrayHandle chunk) {</span>
<span class="line-added">+     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);</span>
<span class="line-added">+     return hidden;</span>
<span class="line-added">+   }</span>
  
   public:
  
    // constructor for new backtrace
<span class="line-modified">!   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(NULL) {</span>
      expand(CHECK);
      _backtrace = Handle(THREAD, _head);
      _index = 0;
    }
  
    BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
      _methods = get_methods(backtrace);
      _bcis = get_bcis(backtrace);
      _mirrors = get_mirrors(backtrace);
      _names = get_names(backtrace);
<span class="line-added">+     _has_hidden_top_frame = get_has_hidden_top_frame(backtrace);</span>
      assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
             _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
             _mirrors-&gt;length() == _names-&gt;length(),
             &quot;method and source information arrays should match&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2066,10 ***</span>
<span class="line-new-header">--- 2116,11 ---</span>
      }
      new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
      new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
      new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
      new_head-&gt;obj_at_put(trace_names_offset, new_names());
<span class="line-added">+     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);</span>
  
      _head    = new_head();
      _methods = new_methods();
      _bcis = new_bcis();
      _mirrors = new_mirrors();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,10 ***</span>
<span class="line-new-header">--- 2157,24 ---</span>
      assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
      _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
      _index++;
    }
  
<span class="line-added">+   void set_has_hidden_top_frame(TRAPS) {</span>
<span class="line-added">+     if (_has_hidden_top_frame == NULL) {</span>
<span class="line-added">+       // It would be nice to add java/lang/Boolean::TRUE here</span>
<span class="line-added">+       // to indicate that this backtrace has a hidden top frame.</span>
<span class="line-added">+       // But this code is used before TRUE is allocated.</span>
<span class="line-added">+       // Therefor let&#39;s just use an arbitrary legal oop</span>
<span class="line-added">+       // available right here. We only test for != null</span>
<span class="line-added">+       // anyways. _methods is a short[].</span>
<span class="line-added">+       assert(_methods != NULL, &quot;we need a legal oop&quot;);</span>
<span class="line-added">+       _has_hidden_top_frame = _methods;</span>
<span class="line-added">+       _head-&gt;obj_at_put(trace_hidden_offset, _has_hidden_top_frame);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  };
  
  struct BacktraceElement : public StackObj {
    int _method_id;
    int _bci;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2241,11 ***</span>
    }
  
    st-&gt;print_cr(&quot;%s&quot;, buf);
  }
  
<span class="line-modified">! void java_lang_Throwable::print_stack_element(outputStream *st, const methodHandle&amp; method, int bci) {</span>
    Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
    int method_id = method-&gt;orig_method_idnum();
    int version = method-&gt;constants()-&gt;version();
    print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
  }
<span class="line-new-header">--- 2306,11 ---</span>
    }
  
    st-&gt;print_cr(&quot;%s&quot;, buf);
  }
  
<span class="line-modified">! void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {</span>
    Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
    int method_id = method-&gt;orig_method_idnum();
    int version = method-&gt;constants()-&gt;version();
    print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2347,11 ***</span>
    // See bug 6333838 for  more details.
    // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
    // trace as utilizing vframe.
  #ifdef ASSERT
    vframeStream st(thread);
<span class="line-removed">-   methodHandle st_method(THREAD, st.method());</span>
  #endif
    int total_count = 0;
    RegisterMap map(thread, false);
    int decode_offset = 0;
    CompiledMethod* nm = NULL;
<span class="line-new-header">--- 2412,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2397,18 ***</span>
            continue;
          }
        }
      }
  #ifdef ASSERT
<span class="line-modified">!     assert(st_method() == method &amp;&amp; st.bci() == bci,</span>
             &quot;Wrong stack trace&quot;);
      st.next();
<span class="line-removed">-     // vframeStream::method isn&#39;t GC-safe so store off a copy</span>
<span class="line-removed">-     // of the Method* in case we GC.</span>
<span class="line-removed">-     if (!st.at_end()) {</span>
<span class="line-removed">-       st_method = st.method();</span>
<span class="line-removed">-     }</span>
  #endif
  
      // the format of the stacktrace will be:
      // - 1 or more fillInStackTrace frames for the exception class (skipped)
      // - 0 or more &lt;init&gt; methods for the exception class (skipped)
<span class="line-new-header">--- 2461,13 ---</span>
            continue;
          }
        }
      }
  #ifdef ASSERT
<span class="line-modified">!     assert(st.method() == method &amp;&amp; st.bci() == bci,</span>
             &quot;Wrong stack trace&quot;);
      st.next();
  #endif
  
      // the format of the stacktrace will be:
      // - 1 or more fillInStackTrace frames for the exception class (skipped)
      // - 0 or more &lt;init&gt; methods for the exception class (skipped)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2435,11 ***</span>
          // there are none or we&#39;ve seen them all - either way stop checking
          skip_throwableInit_check = true;
        }
      }
      if (method-&gt;is_hidden()) {
<span class="line-modified">!       if (skip_hidden)  continue;</span>
      }
      bt.push(method, bci, CHECK);
      total_count++;
    }
  
<span class="line-new-header">--- 2494,17 ---</span>
          // there are none or we&#39;ve seen them all - either way stop checking
          skip_throwableInit_check = true;
        }
      }
      if (method-&gt;is_hidden()) {
<span class="line-modified">!       if (skip_hidden) {</span>
<span class="line-added">+         if (total_count == 0) {</span>
<span class="line-added">+           // The top frame will be hidden from the stack trace.</span>
<span class="line-added">+           bt.set_has_hidden_top_frame(CHECK);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
      }
      bt.push(method, bci, CHECK);
      total_count++;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2552,10 ***</span>
<span class="line-new-header">--- 2617,41 ---</span>
                                           bte._bci,
                                           bte._name, CHECK);
    }
  }
  
<span class="line-added">+ bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {</span>
<span class="line-added">+   Thread* THREAD = Thread::current();</span>
<span class="line-added">+   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));</span>
<span class="line-added">+   BacktraceIterator iter(result, THREAD);</span>
<span class="line-added">+   // No backtrace available.</span>
<span class="line-added">+   if (!iter.repeat()) return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If the exception happened in a frame that has been hidden, i.e.,</span>
<span class="line-added">+   // omitted from the back trace, we can not compute the message.</span>
<span class="line-added">+   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);</span>
<span class="line-added">+   if (hidden != NULL) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Get first backtrace element.</span>
<span class="line-added">+   BacktraceElement bte = iter.next(THREAD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));</span>
<span class="line-added">+   assert(holder != NULL, &quot;first element should be non-null&quot;);</span>
<span class="line-added">+   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Original version is no longer available.</span>
<span class="line-added">+   if (m == NULL || !version_matches(m, bte._version)) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   *method = m;</span>
<span class="line-added">+   *bci = bte._bci;</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
    // Allocate java.lang.StackTraceElement instance
    InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
    assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
    if (k-&gt;should_be_initialized()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2611,38 ***</span>
    if (method() == NULL || !version_matches(method(), version)) {
      // The method was redefined, accurate line number information isn&#39;t available
      java_lang_StackTraceElement::set_fileName(element(), NULL);
      java_lang_StackTraceElement::set_lineNumber(element(), -1);
    } else {
<span class="line-modified">!     // Fill in source file name and line number.</span>
<span class="line-modified">!     Symbol* source = Backtrace::get_source_file_name(holder, version);</span>
<span class="line-modified">!     oop source_file = java_lang_Class::source_file(java_class());</span>
<span class="line-modified">!     if (source != NULL) {</span>
<span class="line-removed">-       // Class was not redefined. We can trust its cache if set,</span>
<span class="line-removed">-       // else we have to initialize it.</span>
<span class="line-removed">-       if (source_file == NULL) {</span>
<span class="line-removed">-         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">-         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       // Class was redefined. Dump the cache if it was set.</span>
<span class="line-removed">-       if (source_file != NULL) {</span>
<span class="line-removed">-         source_file = NULL;</span>
<span class="line-removed">-         java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (ShowHiddenFrames) {</span>
<span class="line-removed">-         source = vmSymbols::unknown_class_name();</span>
<span class="line-removed">-         source_file = StringTable::intern(source, CHECK);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     java_lang_StackTraceElement::set_fileName(element(), source_file);</span>
  
<span class="line-modified">!     int line_number = Backtrace::get_line_number(method, bci);</span>
      java_lang_StackTraceElement::set_lineNumber(element(), line_number);
    }
  }
  
  Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
    HandleMark hm(THREAD);
    Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
    Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
    // we should expand MemberName::name when Throwable uses StackTrace
<span class="line-new-header">--- 2707,65 ---</span>
    if (method() == NULL || !version_matches(method(), version)) {
      // The method was redefined, accurate line number information isn&#39;t available
      java_lang_StackTraceElement::set_fileName(element(), NULL);
      java_lang_StackTraceElement::set_lineNumber(element(), -1);
    } else {
<span class="line-modified">!     Symbol* source;</span>
<span class="line-modified">!     oop source_file;</span>
<span class="line-modified">!     int line_number;</span>
<span class="line-modified">!     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);</span>
  
<span class="line-modified">!     java_lang_StackTraceElement::set_fileName(element(), source_file);</span>
      java_lang_StackTraceElement::set_lineNumber(element(), line_number);
    }
  }
  
<span class="line-added">+ void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,</span>
<span class="line-added">+                                                        InstanceKlass* holder,</span>
<span class="line-added">+                                                        int version,</span>
<span class="line-added">+                                                        const methodHandle&amp; method,</span>
<span class="line-added">+                                                        int bci,</span>
<span class="line-added">+                                                        Symbol*&amp; source,</span>
<span class="line-added">+                                                        oop&amp; source_file,</span>
<span class="line-added">+                                                        int&amp; line_number, TRAPS) {</span>
<span class="line-added">+   // Fill in source file name and line number.</span>
<span class="line-added">+   source = Backtrace::get_source_file_name(holder, version);</span>
<span class="line-added">+   source_file = java_lang_Class::source_file(java_class());</span>
<span class="line-added">+   if (source != NULL) {</span>
<span class="line-added">+     // Class was not redefined. We can trust its cache if set,</span>
<span class="line-added">+     // else we have to initialize it.</span>
<span class="line-added">+     if (source_file == NULL) {</span>
<span class="line-added">+       source_file = StringTable::intern(source, CHECK);</span>
<span class="line-added">+       java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Class was redefined. Dump the cache if it was set.</span>
<span class="line-added">+     if (source_file != NULL) {</span>
<span class="line-added">+       source_file = NULL;</span>
<span class="line-added">+       java_lang_Class::set_source_file(java_class(), source_file);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   line_number = Backtrace::get_line_number(method(), bci);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,</span>
<span class="line-added">+                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {</span>
<span class="line-added">+   ResourceMark rm(THREAD);</span>
<span class="line-added">+   HandleMark hm(THREAD);</span>
<span class="line-added">+ </span>
<span class="line-added">+   filename = NULL;</span>
<span class="line-added">+   line_number = -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop source_file;</span>
<span class="line-added">+   int version = method-&gt;constants()-&gt;version();</span>
<span class="line-added">+   InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-added">+   Handle java_class(THREAD, holder-&gt;java_mirror());</span>
<span class="line-added">+   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI</span>
<span class="line-added">+ </span>
  Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
    HandleMark hm(THREAD);
    Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
    Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
    // we should expand MemberName::name when Throwable uses StackTrace
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,18 ***</span>
    Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
    InstanceKlass* holder = InstanceKlass::cast(clazz);
    Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
  
    short version = stackFrame-&gt;short_field(_version_offset);
<span class="line-modified">!   short bci = stackFrame-&gt;short_field(_bci_offset);</span>
    Symbol* name = method-&gt;name();
<span class="line-modified">!   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, method, version, bci, name, CHECK);</span>
  }
  
  #define STACKFRAMEINFO_FIELDS_DO(macro) \
    macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
<span class="line-modified">!   macro(_bci_offset,            k, &quot;bci&quot;,         short_signature,  false)</span>
  
  void java_lang_StackFrameInfo::compute_offsets() {
    InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
    STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
    STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
<span class="line-new-header">--- 2795,19 ---</span>
    Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
    InstanceKlass* holder = InstanceKlass::cast(clazz);
    Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
  
    short version = stackFrame-&gt;short_field(_version_offset);
<span class="line-modified">!   int bci = stackFrame-&gt;int_field(_bci_offset);</span>
    Symbol* name = method-&gt;name();
<span class="line-modified">!   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),</span>
<span class="line-added">+                                        version, bci, name, CHECK);</span>
  }
  
  #define STACKFRAMEINFO_FIELDS_DO(macro) \
    macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
<span class="line-modified">!   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
  
  void java_lang_StackFrameInfo::compute_offsets() {
    InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
    STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
    STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3019,10 ***</span>
<span class="line-new-header">--- 3143,68 ---</span>
  void java_lang_reflect_Field::set_annotations(oop field, oop value) {
    assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
    field-&gt;obj_field_put(annotations_offset, value);
  }
  
<span class="line-added">+ oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {</span>
<span class="line-added">+   // Allocate java.lang.reflect.RecordComponent instance</span>
<span class="line-added">+   HandleMark hm(THREAD);</span>
<span class="line-added">+   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();</span>
<span class="line-added">+   assert(ik != NULL, &quot;must be loaded&quot;);</span>
<span class="line-added">+   ik-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Handle decl_class(THREAD, holder-&gt;java_mirror());</span>
<span class="line-added">+   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());</span>
<span class="line-added">+ </span>
<span class="line-added">+   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8</span>
<span class="line-added">+   oop component_name = StringTable::intern(name, CHECK_NULL);</span>
<span class="line-added">+   java_lang_reflect_RecordComponent::set_name(element(), component_name);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());</span>
<span class="line-added">+   Handle component_type_h =</span>
<span class="line-added">+     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);</span>
<span class="line-added">+   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());</span>
<span class="line-added">+ </span>
<span class="line-added">+   Method* accessor_method = NULL;</span>
<span class="line-added">+   {</span>
<span class="line-added">+     // Prepend &quot;()&quot; to type to create the full method signature.</span>
<span class="line-added">+     ResourceMark rm(THREAD);</span>
<span class="line-added">+     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char</span>
<span class="line-added">+     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);</span>
<span class="line-added">+     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());</span>
<span class="line-added">+     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);</span>
<span class="line-added">+     accessor_method = holder-&gt;find_instance_method(name, full_sig);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (accessor_method != NULL) {</span>
<span class="line-added">+     methodHandle method(THREAD, accessor_method);</span>
<span class="line-added">+     oop m = Reflection::new_method(method, false, CHECK_NULL);</span>
<span class="line-added">+     java_lang_reflect_RecordComponent::set_accessor(element(), m);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int sig_index = component-&gt;generic_signature_index();</span>
<span class="line-added">+   if (sig_index &gt; 0) {</span>
<span class="line-added">+     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8</span>
<span class="line-added">+     oop component_sig = StringTable::intern(sig, CHECK_NULL);</span>
<span class="line-added">+     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     java_lang_reflect_RecordComponent::set_signature(element(), NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);</span>
<span class="line-added">+   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);</span>
<span class="line-added">+ </span>
<span class="line-added">+   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);</span>
<span class="line-added">+   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return element();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #define CONSTANTPOOL_FIELDS_DO(macro) \
    macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
  
  void reflect_ConstantPool::compute_offsets() {
    InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3618,27 ***</span>
  void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
    assert(is_instance(resolved_method), &quot;wrong type&quot;);
    resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
  }
  
  oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
    // lookup ResolvedMethod oop in the table, or create a new one and intern it
<span class="line-modified">!   oop resolved_method = ResolvedMethodTable::find_method(m());</span>
<span class="line-modified">!   if (resolved_method == NULL) {</span>
<span class="line-modified">!     InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();</span>
<span class="line-removed">-     if (!k-&gt;is_initialized()) {</span>
<span class="line-removed">-       k-&gt;initialize(CHECK_NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-removed">-     new_resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m());</span>
<span class="line-removed">-     // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have</span>
<span class="line-removed">-     // distinct loaders) to ensure the metadata is kept alive.</span>
<span class="line-removed">-     // This mirror may be different than the one in clazz field.</span>
<span class="line-removed">-     new_resolved_method-&gt;obj_field_put(_vmholder_offset, m-&gt;method_holder()-&gt;java_mirror());</span>
<span class="line-removed">-     resolved_method = ResolvedMethodTable::add_method(m, Handle(THREAD, new_resolved_method));</span>
    }
<span class="line-modified">!   return resolved_method;</span>
  }
  
  oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
    assert(is_instance(lform), &quot;wrong type&quot;);
    return lform-&gt;obj_field(_vmentry_offset);
<span class="line-new-header">--- 3800,52 ---</span>
  void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
    assert(is_instance(resolved_method), &quot;wrong type&quot;);
    resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
  }
  
<span class="line-added">+ void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {</span>
<span class="line-added">+   assert(is_instance(resolved_method), &quot;wrong type&quot;);</span>
<span class="line-added">+   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
<span class="line-added">+   const Method* method = m();</span>
<span class="line-added">+ </span>
    // lookup ResolvedMethod oop in the table, or create a new one and intern it
<span class="line-modified">!   oop resolved_method = ResolvedMethodTable::find_method(method);</span>
<span class="line-modified">!   if (resolved_method != NULL) {</span>
<span class="line-modified">!     return resolved_method;</span>
    }
<span class="line-modified">! </span>
<span class="line-added">+   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();</span>
<span class="line-added">+   if (!k-&gt;is_initialized()) {</span>
<span class="line-added">+     k-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   NoSafepointVerifier nsv;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (method-&gt;is_old()) {</span>
<span class="line-added">+     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :</span>
<span class="line-added">+                                       method-&gt;get_new_method();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-added">+ </span>
<span class="line-added">+   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));</span>
<span class="line-added">+   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have</span>
<span class="line-added">+   // distinct loaders) to ensure the metadata is kept alive.</span>
<span class="line-added">+   // This mirror may be different than the one in clazz field.</span>
<span class="line-added">+   set_vmholder(new_resolved_method, holder-&gt;java_mirror());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Set flag in class to indicate this InstanceKlass has entries in the table</span>
<span class="line-added">+   // to avoid walking table during redefinition if none of the redefined classes</span>
<span class="line-added">+   // have any membernames in the table.</span>
<span class="line-added">+   holder-&gt;set_has_resolved_methods();</span>
<span class="line-added">+ </span>
<span class="line-added">+   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));</span>
  }
  
  oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
    assert(is_instance(lform), &quot;wrong type&quot;);
    return lform-&gt;obj_field(_vmentry_offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3673,34 ***</span>
    }
    st-&gt;print(&quot;)&quot;);
    java_lang_Class::print_signature(rtype(mt), st);
  }
  
<span class="line-modified">! Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found, TRAPS) {</span>
    ResourceMark rm;
    stringStream buffer(128);
    print_signature(mt, &amp;buffer);
    const char* sigstr =       buffer.base();
    int         siglen = (int) buffer.size();
    Symbol *name;
    if (!intern_if_not_found) {
      name = SymbolTable::probe(sigstr, siglen);
    } else {
<span class="line-modified">!     name = SymbolTable::new_symbol(sigstr, siglen, THREAD);</span>
    }
    return name;
  }
  
  bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
<span class="line-modified">!   if (oopDesc::equals(mt1, mt2))</span>
      return true;
<span class="line-modified">!   if (!oopDesc::equals(rtype(mt1), rtype(mt2)))</span>
      return false;
    if (ptype_count(mt1) != ptype_count(mt2))
      return false;
    for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
<span class="line-modified">!     if (!oopDesc::equals(ptype(mt1, i), ptype(mt2, i)))</span>
        return false;
    }
    return true;
  }
  
<span class="line-new-header">--- 3880,34 ---</span>
    }
    st-&gt;print(&quot;)&quot;);
    java_lang_Class::print_signature(rtype(mt), st);
  }
  
<span class="line-modified">! Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {</span>
    ResourceMark rm;
    stringStream buffer(128);
    print_signature(mt, &amp;buffer);
    const char* sigstr =       buffer.base();
    int         siglen = (int) buffer.size();
    Symbol *name;
    if (!intern_if_not_found) {
      name = SymbolTable::probe(sigstr, siglen);
    } else {
<span class="line-modified">!     name = SymbolTable::new_symbol(sigstr, siglen);</span>
    }
    return name;
  }
  
  bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
<span class="line-modified">!   if (mt1 == mt2)</span>
      return true;
<span class="line-modified">!   if (rtype(mt1) != rtype(mt2))</span>
      return false;
    if (ptype_count(mt1) != ptype_count(mt2))
      return false;
    for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
<span class="line-modified">!     if (ptype(mt1, i) != ptype(mt2, i))</span>
        return false;
    }
    return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3764,10 ***</span>
<span class="line-new-header">--- 3971,28 ---</span>
  
    oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
    return dep_oop;
  }
  
<span class="line-added">+ // Support for java_lang_invoke_ConstantCallSite</span>
<span class="line-added">+ </span>
<span class="line-added">+ int java_lang_invoke_ConstantCallSite::_is_frozen_offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CONSTANTCALLSITE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_invoke_ConstantCallSite::compute_offsets() {</span>
<span class="line-added">+   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();</span>
<span class="line-added">+   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
  
  int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
  int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3815,22 ***</span>
  }
  #endif
  
  oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
    assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
    // Ensure klass is initialized
    SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);
    // Allocate result
    oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);
    // Fill in values
    result-&gt;obj_field_put(_context_offset, context());
    result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
    result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
<span class="line-modified">!   // whitelist AccessControlContexts created by the JVM if present</span>
<span class="line-modified">!   if (_isAuthorized_offset != -1) {</span>
<span class="line-removed">-     result-&gt;bool_field_put(_isAuthorized_offset, true);</span>
<span class="line-removed">-   }</span>
    return result;
  }
  
  
  // Support for java_lang_ClassLoader
<span class="line-new-header">--- 4040,21 ---</span>
  }
  #endif
  
  oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
    assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-added">+   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);</span>
    // Ensure klass is initialized
    SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);
    // Allocate result
    oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);
    // Fill in values
    result-&gt;obj_field_put(_context_offset, context());
    result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
    result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
<span class="line-modified">!   // whitelist AccessControlContexts created by the JVM</span>
<span class="line-modified">!   result-&gt;bool_field_put(_isAuthorized_offset, true);</span>
    return result;
  }
  
  
  // Support for java_lang_ClassLoader
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3841,21 ***</span>
  int  java_lang_ClassLoader::name_offset = -1;
  int  java_lang_ClassLoader::nameAndId_offset = -1;
  int  java_lang_ClassLoader::unnamedModule_offset = -1;
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
<span class="line-modified">!   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
  }
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
<span class="line-modified">!   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
  }
  
  void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
<span class="line-modified">!   assert(loader != NULL &amp;&amp; oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
  }
  
  #define CLASSLOADER_FIELDS_DO(macro) \
    macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
<span class="line-new-header">--- 4065,24 ---</span>
  int  java_lang_ClassLoader::name_offset = -1;
  int  java_lang_ClassLoader::nameAndId_offset = -1;
  int  java_lang_ClassLoader::unnamedModule_offset = -1;
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
<span class="line-modified">!   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
  }
  
  ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
<span class="line-modified">!   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
  }
  
  void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
<span class="line-modified">!   assert(loader != NULL, &quot;loader must not be NULL&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);</span>
    HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
  }
  
  #define CLASSLOADER_FIELDS_DO(macro) \
    macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3910,11 ***</span>
    oop acl = loader;
    debug_only(jint loop_count = 0);
    // This loop taken verbatim from ClassLoader.java:
    do {
      acl = parent(acl);
<span class="line-modified">!     if (oopDesc::equals(cl, acl)) {</span>
        return true;
      }
      assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
    } while (acl != NULL);
    return false;
<span class="line-new-header">--- 4137,11 ---</span>
    oop acl = loader;
    debug_only(jint loop_count = 0);
    // This loop taken verbatim from ClassLoader.java:
    do {
      acl = parent(acl);
<span class="line-modified">!     if (cl == acl) {</span>
        return true;
      }
      assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
    } while (acl != NULL);
    return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3927,24 ***</span>
  
  // For class loader classes, parallelCapable defined
  // based on non-null field
  // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
  bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">!   if (parallelCapable_offset == -1) {</span>
<span class="line-removed">-      // Default for backward compatibility is false</span>
<span class="line-removed">-      return false;</span>
<span class="line-removed">-   }</span>
    return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
  }
  
  bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
    // Fix for 4474172; see evaluation for more details
    loader = non_reflection_class_loader(loader);
  
    oop cl = SystemDictionary::java_system_loader();
    while(cl != NULL) {
<span class="line-modified">!     if (oopDesc::equals(cl, loader)) return true;</span>
      cl = parent(cl);
    }
    return false;
  }
  
<span class="line-new-header">--- 4154,21 ---</span>
  
  // For class loader classes, parallelCapable defined
  // based on non-null field
  // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
  bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">!   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);</span>
    return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
  }
  
  bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
    // Fix for 4474172; see evaluation for more details
    loader = non_reflection_class_loader(loader);
  
    oop cl = SystemDictionary::java_system_loader();
    while(cl != NULL) {
<span class="line-modified">!     if (cl == loader) return true;</span>
      cl = parent(cl);
    }
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3996,10 ***</span>
<span class="line-new-header">--- 4220,56 ---</span>
  
  int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
  int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
  int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
  
<span class="line-added">+ // Support for jdk_internal_misc_UnsafeConstants</span>
<span class="line-added">+ //</span>
<span class="line-added">+ class UnsafeConstantsFixup : public FieldClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   int _address_size;</span>
<span class="line-added">+   int _page_size;</span>
<span class="line-added">+   bool _big_endian;</span>
<span class="line-added">+   bool _use_unaligned_access;</span>
<span class="line-added">+   int _data_cache_line_flush_size;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   UnsafeConstantsFixup() {</span>
<span class="line-added">+     // round up values for all static final fields</span>
<span class="line-added">+     _address_size = sizeof(void*);</span>
<span class="line-added">+     _page_size = os::vm_page_size();</span>
<span class="line-added">+     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);</span>
<span class="line-added">+     _use_unaligned_access = UseUnalignedAccesses;</span>
<span class="line-added">+     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void do_field(fieldDescriptor* fd) {</span>
<span class="line-added">+     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();</span>
<span class="line-added">+     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);</span>
<span class="line-added">+     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);</span>
<span class="line-added">+     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);</span>
<span class="line-added">+     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);</span>
<span class="line-added">+     if (fd-&gt;name() == vmSymbols::address_size_name()) {</span>
<span class="line-added">+       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);</span>
<span class="line-added">+     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {</span>
<span class="line-added">+       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);</span>
<span class="line-added">+     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {</span>
<span class="line-added">+       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);</span>
<span class="line-added">+     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {</span>
<span class="line-added">+       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);</span>
<span class="line-added">+     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {</span>
<span class="line-added">+       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(false, &quot;unexpected UnsafeConstants field&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {</span>
<span class="line-added">+   UnsafeConstantsFixup fixup;</span>
<span class="line-added">+   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int java_lang_Class::_klass_offset;
  int java_lang_Class::_array_klass_offset;
  int java_lang_Class::_oop_size_offset;
  int java_lang_Class::_static_oop_field_count_offset;
  int java_lang_Class::_class_loader_offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4083,10 ***</span>
<span class="line-new-header">--- 4353,25 ---</span>
  int java_lang_AssertionStatusDirectives::deflt_offset;
  int java_nio_Buffer::_limit_offset;
  int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
  int reflect_ConstantPool::_oop_offset;
  int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
<span class="line-added">+ int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-added">+ int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-added">+ int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::clazz_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::name_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::type_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::accessor_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::signature_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::annotations_offset;</span>
<span class="line-added">+ int java_lang_reflect_RecordComponent::typeAnnotations_offset;</span>
<span class="line-added">+ </span>
  
  
  #define STACKTRACEELEMENT_FIELDS_DO(macro) \
    macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
    macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4144,10 ***</span>
<span class="line-new-header">--- 4429,11 ---</span>
  void java_lang_StackFrameInfo::set_version(oop element, short value) {
    element-&gt;short_field_put(_version_offset, value);
  }
  
  void java_lang_StackFrameInfo::set_bci(oop element, int value) {
<span class="line-added">+   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
    element-&gt;int_field_put(_bci_offset, value);
  }
  
  void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
    element-&gt;obj_field_put(_monitors_offset, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4242,14 ***</span>
<span class="line-new-header">--- 4528,249 ---</span>
  void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
    AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
  }
  #endif
  
<span class="line-added">+ #define INTEGER_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Integer_IntegerCache::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Integer_IntegerCache();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef INTEGER_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jint java_lang_Integer::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.i;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define LONG_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Long_LongCache::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Long_LongCache();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef LONG_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jlong java_lang_Long::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.j;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CHARACTER_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Character_CharacterCache::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Character_CharacterCache();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef CHARACTER_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jchar java_lang_Character::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.c;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define SHORT_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Short_ShortCache::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Short_ShortCache();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef SHORT_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jshort java_lang_Short::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.s;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define BYTE_CACHE_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return objArrayOop(base-&gt;obj_field(_static_cache_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Byte_ByteCache::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Byte_ByteCache();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef BYTE_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jbyte java_lang_Byte::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.b;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #define BOOLEAN_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \</span>
<span class="line-added">+   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_Boolean::compute_offsets(InstanceKlass *k) {</span>
<span class="line-added">+   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);</span>
<span class="line-added">+   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return base-&gt;obj_field(_static_TRUE_offset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {</span>
<span class="line-added">+   oop base = ik-&gt;static_field_base_raw();</span>
<span class="line-added">+   return base-&gt;obj_field(_static_FALSE_offset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Symbol* java_lang_Boolean::symbol() {</span>
<span class="line-added">+   return vmSymbols::java_lang_Boolean();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #undef BOOLEAN_CACHE_FIELDS_DO</span>
<span class="line-added">+ </span>
<span class="line-added">+ jboolean java_lang_Boolean::value(oop obj) {</span>
<span class="line-added">+    jvalue v;</span>
<span class="line-added">+    java_lang_boxing_object::get_value(obj, &amp;v);</span>
<span class="line-added">+    return v.z;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static int member_offset(int hardcoded_offset) {
    return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
  }
  
<span class="line-added">+ #define RECORDCOMPONENT_FIELDS_DO(macro) \</span>
<span class="line-added">+   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-added">+   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-added">+   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-added">+   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-added">+   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-added">+   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-added">+   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Support for java_lang_reflect_RecordComponent</span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::compute_offsets() {</span>
<span class="line-added">+   InstanceKlass* k = SystemDictionary::RecordComponent_klass();</span>
<span class="line-added">+   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_CDS</span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">+   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(clazz_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(name_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(type_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(accessor_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(signature_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(annotations_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {</span>
<span class="line-added">+   element-&gt;obj_field_put(typeAnnotations_offset, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Compute hard-coded offsets
  // Invoked before SystemDictionary::initialize, so pre-loaded classes
  // are not available to determine the offset_of_static_fields.
  void JavaClasses::compute_hard_coded_offsets() {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4281,37 ***</span>
  
    // We have already called the compute_offsets() of the
    // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
    // earlier inside SystemDictionary::resolve_well_known_classes()
    BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
<span class="line-removed">- </span>
<span class="line-removed">-   // generated interpreter code wants to know about the offsets we just computed:</span>
<span class="line-removed">-   AbstractAssembler::update_delayed_values();</span>
  }
  
  #if INCLUDE_CDS
  #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
  
  void JavaClasses::serialize_offsets(SerializeClosure* soc) {
    BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
  }
  #endif
  
  
  #ifndef PRODUCT
  
  // These functions exist to assert the validity of hard-coded field offsets to guard
  // against changes in the class files
  
  bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
    EXCEPTION_MARK;
    fieldDescriptor fd;
<span class="line-modified">!   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name, CATCH);</span>
    Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
    InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!   TempNewSymbol f_name = SymbolTable::new_symbol(field_name, CATCH);</span>
<span class="line-modified">!   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig, CATCH);</span>
    if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
      tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
      return false;
    }
    if (fd.is_static()) {
<span class="line-new-header">--- 4802,56 ---</span>
  
    // We have already called the compute_offsets() of the
    // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
    // earlier inside SystemDictionary::resolve_well_known_classes()
    BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
  }
  
  #if INCLUDE_CDS
  #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
  
  void JavaClasses::serialize_offsets(SerializeClosure* soc) {
    BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
  }
  #endif
  
<span class="line-added">+ #if INCLUDE_CDS_JAVA_HEAP</span>
<span class="line-added">+ bool JavaClasses::is_supported_for_archiving(oop obj) {</span>
<span class="line-added">+   Klass* klass = obj-&gt;klass();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.</span>
<span class="line-added">+       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed</span>
<span class="line-added">+       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in</span>
<span class="line-added">+       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes</span>
<span class="line-added">+       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.</span>
<span class="line-added">+       // So for now we cannot not support these classes for archiving.</span>
<span class="line-added">+       //</span>
<span class="line-added">+       // These objects typically are not referenced by static fields, but rather by resolved</span>
<span class="line-added">+       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.</span>
<span class="line-added">+       klass == SystemDictionary::ResolvedMethodName_klass() ||</span>
<span class="line-added">+       klass == SystemDictionary::MemberName_klass() ||</span>
<span class="line-added">+       klass == SystemDictionary::Context_klass()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
  
  #ifndef PRODUCT
  
  // These functions exist to assert the validity of hard-coded field offsets to guard
  // against changes in the class files
  
  bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
    EXCEPTION_MARK;
    fieldDescriptor fd;
<span class="line-modified">!   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);</span>
    Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
    InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);</span>
<span class="line-modified">!   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);</span>
    if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
      tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
      return false;
    }
    if (fd.is_static()) {
</pre>
<center><a href="javaAssertions.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
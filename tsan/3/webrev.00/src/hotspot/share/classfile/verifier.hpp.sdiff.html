<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_VERIFIER_HPP
 26 #define SHARE_CLASSFILE_VERIFIER_HPP
 27 
 28 #include &quot;classfile/verificationType.hpp&quot;
 29 #include &quot;oops/klass.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/handles.hpp&quot;
 32 #include &quot;utilities/exceptions.hpp&quot;
 33 #include &quot;utilities/growableArray.hpp&quot;

 34 
 35 // The verifier class
 36 class Verifier : AllStatic {
 37  public:
 38   enum {
 39     STACKMAP_ATTRIBUTE_MAJOR_VERSION    = 50,
 40     INVOKEDYNAMIC_MAJOR_VERSION         = 51,
 41     NO_RELAX_ACCESS_CTRL_CHECK_VERSION  = 52,
 42     DYNAMICCONSTANT_MAJOR_VERSION       = 55
 43   };
 44 
 45   // Verify the bytecodes for a class.
 46   static bool verify(InstanceKlass* klass, bool should_verify_class, TRAPS);
 47 
 48   static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS);
 49 
 50   // Return false if the class is loaded by the bootstrap loader,
 51   // or if defineClass was called requesting skipping verification
 52   // -Xverify:all overrides this value
 53   static bool should_verify_for(oop class_loader, bool should_verify_class);
</pre>
<hr />
<pre>
229 
230 #ifdef ASSERT
231   void print_on(outputStream* str) const {
232     str-&gt;print(&quot;error_context(%d, %d,&quot;, _bci, _fault);
233     _type.print_on(str);
234     str-&gt;print(&quot;,&quot;);
235     _expected.print_on(str);
236     str-&gt;print(&quot;)&quot;);
237   }
238 #endif
239 
240  private:
241   void location_details(outputStream* ss, const Method* method) const;
242   void reason_details(outputStream* ss) const;
243   void frame_details(outputStream* ss) const;
244   void bytecode_details(outputStream* ss, const Method* method) const;
245   void handler_details(outputStream* ss, const Method* method) const;
246   void stackmap_details(outputStream* ss, const Method* method) const;
247 };
248 



























249 // A new instance of this class is created for each class being verified
250 class ClassVerifier : public StackObj {
251  private:
252   Thread* _thread;
253 
254   Symbol* _previous_symbol;          // cache of the previously looked up symbol
255   GrowableArray&lt;Symbol*&gt;* _symbols;  // keep a list of symbols created
256 
257   Symbol* _exception_type;
258   char* _message;
259 


260   ErrorContext _error_context;  // contains information about an error
261 
262   void verify_method(const methodHandle&amp; method, TRAPS);
263   char* generate_code_data(const methodHandle&amp; m, u4 code_length, TRAPS);
264   void verify_exception_handler_table(u4 code_length, char* code_data,
265                                       int&amp; min, int&amp; max, TRAPS);
266   void verify_local_variable_table(u4 code_length, char* code_data, TRAPS);
267 
268   VerificationType cp_ref_index_to_type(
269       int index, const constantPoolHandle&amp; cp, TRAPS) {
270     return cp_index_to_type(cp-&gt;klass_ref_index_at(index), cp, THREAD);
271   }
272 
273   bool is_protected_access(
274     InstanceKlass* this_class, Klass* target_class,
275     Symbol* field_name, Symbol* field_sig, bool is_method);
276 
277   void verify_cp_index(u2 bci, const constantPoolHandle&amp; cp, int index, TRAPS);
278   void verify_cp_type(u2 bci, int index, const constantPoolHandle&amp; cp,
279       unsigned int types, TRAPS);
</pre>
<hr />
<pre>
366     BYTECODE_OFFSET = 1,
367     NEW_OFFSET = 2
368   };
369 
370   // constructor
371   ClassVerifier(InstanceKlass* klass, TRAPS);
372 
373   // destructor
374   ~ClassVerifier();
375 
376   Thread* thread()             { return _thread; }
377   const methodHandle&amp; method() { return _method; }
378   InstanceKlass* current_class() const { return _klass; }
379   VerificationType current_type() const { return _this_type; }
380 
381   // Verifies the class.  If a verify or class file format error occurs,
382   // the &#39;_exception_name&#39; symbols will set to the exception name and
383   // the message_buffer will be filled in with the exception message.
384   void verify_class(TRAPS);
385 







386   // Return status modes
387   Symbol* result() const { return _exception_type; }
388   bool has_error() const { return result() != NULL; }
389   char* exception_message() {
390     stringStream ss;
391     ss.print(&quot;%s&quot;, _message);
392     _error_context.details(&amp;ss, _method());
393     return ss.as_string();
394   }
395 
396   // Called when verify or class format errors are encountered.
397   // May throw an exception based upon the mode.
398   void verify_error(ErrorContext ctx, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);
399   void class_format_error(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);
400 
401   Klass* load_class(Symbol* name, TRAPS);
402 








403   int change_sig_to_verificationType(
<span class="line-modified">404     SignatureStream* sig_type, VerificationType* inference_type, TRAPS);</span>
405 
406   VerificationType cp_index_to_type(int index, const constantPoolHandle&amp; cp, TRAPS) {
407     return VerificationType::reference_type(cp-&gt;klass_name_at(index));
408   }
409 
410   // Keep a list of temporary symbols created during verification because
411   // their reference counts need to be decremented when the verifier object
412   // goes out of scope.  Since these symbols escape the scope in which they&#39;re
413   // created, we can&#39;t use a TempNewSymbol.
<span class="line-modified">414   Symbol* create_temporary_symbol(const Symbol* s, int begin, int end, TRAPS);</span>
<span class="line-modified">415   Symbol* create_temporary_symbol(const char *s, int length, TRAPS);</span>
416   Symbol* create_temporary_symbol(Symbol* s) {
417     if (s == _previous_symbol) {
418       return s;
419     }
420     if (!s-&gt;is_permanent()) {
421       s-&gt;increment_refcount();
422       if (_symbols == NULL) {
423         _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
424       }
425       _symbols-&gt;push(s);
426     }
427     _previous_symbol = s;
428     return s;
429   }
430 
<span class="line-modified">431   TypeOrigin ref_ctx(const char* str, TRAPS);</span>
432 
433 };
434 
435 inline int ClassVerifier::change_sig_to_verificationType(
<span class="line-modified">436     SignatureStream* sig_type, VerificationType* inference_type, TRAPS) {</span>
437   BasicType bt = sig_type-&gt;type();
438   switch (bt) {
439     case T_OBJECT:
440     case T_ARRAY:
441       {
<span class="line-modified">442         Symbol* name = sig_type-&gt;as_symbol(CHECK_0);</span>
443         // Create another symbol to save as signature stream unreferences this symbol.
444         Symbol* name_copy = create_temporary_symbol(name);
445         assert(name_copy == name, &quot;symbols don&#39;t match&quot;);
446         *inference_type =
447           VerificationType::reference_type(name_copy);
448         return 1;
449       }
450     case T_LONG:
451       *inference_type = VerificationType::long_type();
452       *++inference_type = VerificationType::long2_type();
453       return 2;
454     case T_DOUBLE:
455       *inference_type = VerificationType::double_type();
456       *++inference_type = VerificationType::double2_type();
457       return 2;
458     case T_INT:
459     case T_BOOLEAN:
460     case T_BYTE:
461     case T_CHAR:
462     case T_SHORT:
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_VERIFIER_HPP
 26 #define SHARE_CLASSFILE_VERIFIER_HPP
 27 
 28 #include &quot;classfile/verificationType.hpp&quot;
 29 #include &quot;oops/klass.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/handles.hpp&quot;
 32 #include &quot;utilities/exceptions.hpp&quot;
 33 #include &quot;utilities/growableArray.hpp&quot;
<span class="line-added"> 34 #include &quot;utilities/resourceHash.hpp&quot;</span>
 35 
 36 // The verifier class
 37 class Verifier : AllStatic {
 38  public:
 39   enum {
 40     STACKMAP_ATTRIBUTE_MAJOR_VERSION    = 50,
 41     INVOKEDYNAMIC_MAJOR_VERSION         = 51,
 42     NO_RELAX_ACCESS_CTRL_CHECK_VERSION  = 52,
 43     DYNAMICCONSTANT_MAJOR_VERSION       = 55
 44   };
 45 
 46   // Verify the bytecodes for a class.
 47   static bool verify(InstanceKlass* klass, bool should_verify_class, TRAPS);
 48 
 49   static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS);
 50 
 51   // Return false if the class is loaded by the bootstrap loader,
 52   // or if defineClass was called requesting skipping verification
 53   // -Xverify:all overrides this value
 54   static bool should_verify_for(oop class_loader, bool should_verify_class);
</pre>
<hr />
<pre>
230 
231 #ifdef ASSERT
232   void print_on(outputStream* str) const {
233     str-&gt;print(&quot;error_context(%d, %d,&quot;, _bci, _fault);
234     _type.print_on(str);
235     str-&gt;print(&quot;,&quot;);
236     _expected.print_on(str);
237     str-&gt;print(&quot;)&quot;);
238   }
239 #endif
240 
241  private:
242   void location_details(outputStream* ss, const Method* method) const;
243   void reason_details(outputStream* ss) const;
244   void frame_details(outputStream* ss) const;
245   void bytecode_details(outputStream* ss, const Method* method) const;
246   void handler_details(outputStream* ss, const Method* method) const;
247   void stackmap_details(outputStream* ss, const Method* method) const;
248 };
249 
<span class="line-added">250 class sig_as_verification_types : public ResourceObj {</span>
<span class="line-added">251  private:</span>
<span class="line-added">252   int _num_args;  // Number of arguments, not including return type.</span>
<span class="line-added">253   GrowableArray&lt;VerificationType&gt;* _sig_verif_types;</span>
<span class="line-added">254 </span>
<span class="line-added">255  public:</span>
<span class="line-added">256 </span>
<span class="line-added">257   sig_as_verification_types(GrowableArray&lt;VerificationType&gt;* sig_verif_types) :</span>
<span class="line-added">258     _num_args(0), _sig_verif_types(sig_verif_types) {</span>
<span class="line-added">259   }</span>
<span class="line-added">260 </span>
<span class="line-added">261   int num_args() const { return _num_args; }</span>
<span class="line-added">262   void set_num_args(int num_args) { _num_args = num_args; }</span>
<span class="line-added">263 </span>
<span class="line-added">264   GrowableArray&lt;VerificationType&gt;* sig_verif_types() { return _sig_verif_types; }</span>
<span class="line-added">265   void set_sig_verif_types(GrowableArray&lt;VerificationType&gt;* sig_verif_types) {</span>
<span class="line-added">266     _sig_verif_types = sig_verif_types;</span>
<span class="line-added">267   }</span>
<span class="line-added">268 </span>
<span class="line-added">269 };</span>
<span class="line-added">270 </span>
<span class="line-added">271 // This hashtable is indexed by the Utf8 constant pool indexes pointed to</span>
<span class="line-added">272 // by constant pool (Interface)Method_refs&#39; NameAndType signature entries.</span>
<span class="line-added">273 typedef ResourceHashtable&lt;int, sig_as_verification_types*,</span>
<span class="line-added">274                           primitive_hash&lt;int&gt;, primitive_equals&lt;int&gt;, 1007&gt;</span>
<span class="line-added">275                           method_signatures_table_type;</span>
<span class="line-added">276 </span>
277 // A new instance of this class is created for each class being verified
278 class ClassVerifier : public StackObj {
279  private:
280   Thread* _thread;
281 
282   Symbol* _previous_symbol;          // cache of the previously looked up symbol
283   GrowableArray&lt;Symbol*&gt;* _symbols;  // keep a list of symbols created
284 
285   Symbol* _exception_type;
286   char* _message;
287 
<span class="line-added">288   method_signatures_table_type* _method_signatures_table;</span>
<span class="line-added">289 </span>
290   ErrorContext _error_context;  // contains information about an error
291 
292   void verify_method(const methodHandle&amp; method, TRAPS);
293   char* generate_code_data(const methodHandle&amp; m, u4 code_length, TRAPS);
294   void verify_exception_handler_table(u4 code_length, char* code_data,
295                                       int&amp; min, int&amp; max, TRAPS);
296   void verify_local_variable_table(u4 code_length, char* code_data, TRAPS);
297 
298   VerificationType cp_ref_index_to_type(
299       int index, const constantPoolHandle&amp; cp, TRAPS) {
300     return cp_index_to_type(cp-&gt;klass_ref_index_at(index), cp, THREAD);
301   }
302 
303   bool is_protected_access(
304     InstanceKlass* this_class, Klass* target_class,
305     Symbol* field_name, Symbol* field_sig, bool is_method);
306 
307   void verify_cp_index(u2 bci, const constantPoolHandle&amp; cp, int index, TRAPS);
308   void verify_cp_type(u2 bci, int index, const constantPoolHandle&amp; cp,
309       unsigned int types, TRAPS);
</pre>
<hr />
<pre>
396     BYTECODE_OFFSET = 1,
397     NEW_OFFSET = 2
398   };
399 
400   // constructor
401   ClassVerifier(InstanceKlass* klass, TRAPS);
402 
403   // destructor
404   ~ClassVerifier();
405 
406   Thread* thread()             { return _thread; }
407   const methodHandle&amp; method() { return _method; }
408   InstanceKlass* current_class() const { return _klass; }
409   VerificationType current_type() const { return _this_type; }
410 
411   // Verifies the class.  If a verify or class file format error occurs,
412   // the &#39;_exception_name&#39; symbols will set to the exception name and
413   // the message_buffer will be filled in with the exception message.
414   void verify_class(TRAPS);
415 
<span class="line-added">416   // Translates method signature entries into verificationTypes and saves them</span>
<span class="line-added">417   // in the growable array.</span>
<span class="line-added">418   void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types, TRAPS);</span>
<span class="line-added">419 </span>
<span class="line-added">420   // Initializes a sig_as_verification_types entry and puts it in the hash table.</span>
<span class="line-added">421   void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index, TRAPS);</span>
<span class="line-added">422 </span>
423   // Return status modes
424   Symbol* result() const { return _exception_type; }
425   bool has_error() const { return result() != NULL; }
426   char* exception_message() {
427     stringStream ss;
428     ss.print(&quot;%s&quot;, _message);
429     _error_context.details(&amp;ss, _method());
430     return ss.as_string();
431   }
432 
433   // Called when verify or class format errors are encountered.
434   // May throw an exception based upon the mode.
435   void verify_error(ErrorContext ctx, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);
436   void class_format_error(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);
437 
438   Klass* load_class(Symbol* name, TRAPS);
439 
<span class="line-added">440   method_signatures_table_type* method_signatures_table() const {</span>
<span class="line-added">441     return _method_signatures_table;</span>
<span class="line-added">442   }</span>
<span class="line-added">443 </span>
<span class="line-added">444   void set_method_signatures_table(method_signatures_table_type* method_signatures_table) {</span>
<span class="line-added">445     _method_signatures_table = method_signatures_table;</span>
<span class="line-added">446   }</span>
<span class="line-added">447 </span>
448   int change_sig_to_verificationType(
<span class="line-modified">449     SignatureStream* sig_type, VerificationType* inference_type);</span>
450 
451   VerificationType cp_index_to_type(int index, const constantPoolHandle&amp; cp, TRAPS) {
452     return VerificationType::reference_type(cp-&gt;klass_name_at(index));
453   }
454 
455   // Keep a list of temporary symbols created during verification because
456   // their reference counts need to be decremented when the verifier object
457   // goes out of scope.  Since these symbols escape the scope in which they&#39;re
458   // created, we can&#39;t use a TempNewSymbol.
<span class="line-modified">459   Symbol* create_temporary_symbol(const Symbol* s, int begin, int end);</span>
<span class="line-modified">460   Symbol* create_temporary_symbol(const char *s, int length);</span>
461   Symbol* create_temporary_symbol(Symbol* s) {
462     if (s == _previous_symbol) {
463       return s;
464     }
465     if (!s-&gt;is_permanent()) {
466       s-&gt;increment_refcount();
467       if (_symbols == NULL) {
468         _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
469       }
470       _symbols-&gt;push(s);
471     }
472     _previous_symbol = s;
473     return s;
474   }
475 
<span class="line-modified">476   TypeOrigin ref_ctx(const char* str);</span>
477 
478 };
479 
480 inline int ClassVerifier::change_sig_to_verificationType(
<span class="line-modified">481     SignatureStream* sig_type, VerificationType* inference_type) {</span>
482   BasicType bt = sig_type-&gt;type();
483   switch (bt) {
484     case T_OBJECT:
485     case T_ARRAY:
486       {
<span class="line-modified">487         Symbol* name = sig_type-&gt;as_symbol();</span>
488         // Create another symbol to save as signature stream unreferences this symbol.
489         Symbol* name_copy = create_temporary_symbol(name);
490         assert(name_copy == name, &quot;symbols don&#39;t match&quot;);
491         *inference_type =
492           VerificationType::reference_type(name_copy);
493         return 1;
494       }
495     case T_LONG:
496       *inference_type = VerificationType::long_type();
497       *++inference_type = VerificationType::long2_type();
498       return 2;
499     case T_DOUBLE:
500       *inference_type = VerificationType::double_type();
501       *++inference_type = VerificationType::double2_type();
502       return 2;
503     case T_INT:
504     case T_BOOLEAN:
505     case T_BYTE:
506     case T_CHAR:
507     case T_SHORT:
</pre>
</td>
</tr>
</table>
<center><a href="verifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/modules.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="moduleEntry.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="packageEntry.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/modules.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2 * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 *
  5 * This code is free software; you can redistribute it and/or modify it
  6 * under the terms of the GNU General Public License version 2 only, as
  7 * published by the Free Software Foundation.
  8 *
  9 * This code is distributed in the hope that it will be useful, but WITHOUT
 10 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 * version 2 for more details (a copy is included in the LICENSE file that
 13 * accompanied this code).
 14 *
 15 * You should have received a copy of the GNU General Public License version
 16 * 2 along with this work; if not, write to the Free Software Foundation,
 17 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 *
 19 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 * or visit www.oracle.com if you need additional information or have any
 21 * questions.
 22 *
</pre>
<hr />
<pre>
 94 
 95 static PackageEntryTable* get_package_entry_table(Handle h_loader) {
 96   // This code can be called during start-up, before the classLoader&#39;s classLoader data got
 97   // created.  So, call register_loader() to make sure the classLoader data gets created.
 98   ClassLoaderData *loader_cld = SystemDictionary::register_loader(h_loader);
 99   return loader_cld-&gt;packages();
100 }
101 
102 static ModuleEntry* get_module_entry(jobject module, TRAPS) {
103   oop m = JNIHandles::resolve(module);
104   if (!java_lang_Module::is_instance(m)) {
105     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
106                    &quot;module is not an instance of type java.lang.Module&quot;);
107   }
108   return java_lang_Module::module_entry(m);
109 }
110 
111 static PackageEntry* get_package_entry(ModuleEntry* module_entry, const char* package_name, TRAPS) {
112   ResourceMark rm(THREAD);
113   if (package_name == NULL) return NULL;
<span class="line-modified">114   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name, CHECK_NULL);</span>
115   PackageEntryTable* package_entry_table = module_entry-&gt;loader_data()-&gt;packages();
116   assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
117   return package_entry_table-&gt;lookup_only(pkg_symbol);
118 }
119 
120 static PackageEntry* get_package_entry_by_name(Symbol* package,
121                                                Handle h_loader,
122                                                TRAPS) {
123   if (package != NULL) {
124     ResourceMark rm(THREAD);
125     if (Modules::verify_package_name(package-&gt;as_C_string())) {
126       PackageEntryTable* const package_entry_table =
127         get_package_entry_table(h_loader);
128       assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
129       return package_entry_table-&gt;lookup_only(package);
130     }
131   }
132   return NULL;
133 }
134 
135 bool Modules::is_package_defined(Symbol* package, Handle h_loader, TRAPS) {
136   PackageEntry* res = get_package_entry_by_name(package, h_loader, CHECK_false);
137   return res != NULL;
138 }
139 
140 static void define_javabase_module(jobject module, jstring version,
141                                    jstring location, const char* const* packages,
142                                    jsize num_packages, TRAPS) {
143   ResourceMark rm(THREAD);
144 
145   Handle module_handle(THREAD, JNIHandles::resolve(module));
146 
147   // Obtain java.base&#39;s module version
148   const char* module_version = get_module_version(version);
149   TempNewSymbol version_symbol;
150   if (module_version != NULL) {
<span class="line-modified">151     version_symbol = SymbolTable::new_symbol(module_version, CHECK);</span>
152   } else {
153     version_symbol = NULL;
154   }
155 
156   // Obtain java.base&#39;s location
157   const char* module_location = NULL;
158   TempNewSymbol location_symbol = NULL;
159   if (location != NULL) {
160     module_location =
161       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
162     if (module_location != NULL) {
<span class="line-modified">163       location_symbol = SymbolTable::new_symbol(module_location, CHECK);</span>
164     }
165   }
166 
167 
168   // Check that the packages are syntactically ok.
169   GrowableArray&lt;Symbol*&gt;* pkg_list = new GrowableArray&lt;Symbol*&gt;(num_packages);
170   for (int x = 0; x &lt; num_packages; x++) {
171     const char *package_name = packages[x];
172     if (!Modules::verify_package_name(package_name)) {
173       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
174                 err_msg(&quot;Invalid package name: %s for module: &quot; JAVA_BASE_NAME, package_name));
175     }
<span class="line-modified">176     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);</span>
177     pkg_list-&gt;append(pkg_symbol);
178   }
179 
180   // Validate java_base&#39;s loader is the boot loader.
181   oop loader = java_lang_Module::loader(module_handle());
182   if (loader != NULL) {
183     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
184               &quot;Class loader must be the boot class loader&quot;);
185   }
186   Handle h_loader(THREAD, loader);
187 
188   // Ensure the boot loader&#39;s PackageEntryTable has been created
189   PackageEntryTable* package_table = get_package_entry_table(h_loader);
190   assert(pkg_list-&gt;length() == 0 || package_table != NULL, &quot;Bad package_table&quot;);
191 
192   // Ensure java.base&#39;s ModuleEntry has been created
193   assert(ModuleEntryTable::javabase_moduleEntry() != NULL, &quot;No ModuleEntry for &quot; JAVA_BASE_NAME);
194 
195   bool duplicate_javabase = false;
196   {
<span class="line-modified">197     MutexLocker m1(Module_lock, THREAD);</span>
198 
199     if (ModuleEntryTable::javabase_defined()) {
200       duplicate_javabase = true;
201     } else {
202 
203       // Verify that all java.base packages created during bootstrapping are in
204       // pkg_list.  If any are not in pkg_list, than a non-java.base class was
205       // loaded erroneously pre java.base module definition.
206       package_table-&gt;verify_javabase_packages(pkg_list);
207 
208       // loop through and add any new packages for java.base
209       for (int x = 0; x &lt; pkg_list-&gt;length(); x++) {
210         // Some of java.base&#39;s packages were added early in bootstrapping, ignore duplicates.
211         package_table-&gt;locked_create_entry_if_not_exist(pkg_list-&gt;at(x),
212                                                         ModuleEntryTable::javabase_moduleEntry());
213         assert(package_table-&gt;locked_lookup_only(pkg_list-&gt;at(x)) != NULL,
214                &quot;Unable to create a &quot; JAVA_BASE_NAME &quot; package entry&quot;);
215         // Unable to have a GrowableArray of TempNewSymbol.  Must decrement the refcount of
216         // the Symbol* that was created above for each package. The refcount was incremented
217         // by SymbolTable::new_symbol and as well by the PackageEntry creation.
</pre>
<hr />
<pre>
289               &quot;module is not an instance of type java.lang.Module&quot;);
290   }
291 
292   char* module_name = get_module_name(module_handle(), CHECK);
293   if (module_name == NULL) {
294     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
295               &quot;Module name cannot be null&quot;);
296   }
297 
298   // Special handling of java.base definition
299   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
300     assert(is_open == JNI_FALSE, &quot;java.base module cannot be open&quot;);
301     define_javabase_module(module, version, location, packages, num_packages, CHECK);
302     return;
303   }
304 
305   const char* module_version = get_module_version(version);
306 
307   oop loader = java_lang_Module::loader(module_handle());
308   // Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.
<span class="line-modified">309   if (!oopDesc::equals(loader, java_lang_ClassLoader::non_reflection_class_loader(loader))) {</span>
310     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
311               &quot;Class loader is an invalid delegating class loader&quot;);
312   }
313   Handle h_loader = Handle(THREAD, loader);
314   // define_module can be called during start-up, before the class loader&#39;s ClassLoaderData
315   // has been created.  SystemDictionary::register_loader ensures creation, if needed.
316   ClassLoaderData* loader_data = SystemDictionary::register_loader(h_loader);
317   assert(loader_data != NULL, &quot;class loader data shouldn&#39;t be null&quot;);
318 
319   // Check that the list of packages has no duplicates and that the
320   // packages are syntactically ok.
321   GrowableArray&lt;Symbol*&gt;* pkg_list = new GrowableArray&lt;Symbol*&gt;(num_packages);
322   for (int x = 0; x &lt; num_packages; x++) {
323     const char* package_name = packages[x];
324     if (!verify_package_name(package_name)) {
325       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
326                 err_msg(&quot;Invalid package name: %s for module: %s&quot;,
327                         package_name, module_name));
328     }
329 
330     // Only modules defined to either the boot or platform class loader, can define a &quot;java/&quot; package.
331     if (!h_loader.is_null() &amp;&amp;
332         !SystemDictionary::is_platform_class_loader(h_loader()) &amp;&amp;
333         (strncmp(package_name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp;
<span class="line-modified">334           (package_name[JAVAPKG_LEN] == &#39;/&#39; || package_name[JAVAPKG_LEN] == &#39;\0&#39;))) {</span>
335       const char* class_loader_name = loader_data-&gt;loader_name_and_id();
336       size_t pkg_len = strlen(package_name);
337       char* pkg_name = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, pkg_len + 1);
338       strncpy(pkg_name, package_name, pkg_len + 1);
339       StringUtils::replace_no_expand(pkg_name, &quot;/&quot;, &quot;.&quot;);
340       const char* msg_text1 = &quot;Class loader (instance of): &quot;;
341       const char* msg_text2 = &quot; tried to define prohibited package name: &quot;;
342       size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + pkg_len + 1;
343       char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);
344       jio_snprintf(message, len, &quot;%s%s%s%s&quot;, msg_text1, class_loader_name, msg_text2, pkg_name);
345       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), message);
346     }
347 
<span class="line-modified">348     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name, CHECK);</span>
349     pkg_list-&gt;append(pkg_symbol);
350   }
351 
352   ModuleEntryTable* module_table = get_module_entry_table(h_loader);
353   assert(module_table != NULL, &quot;module entry table shouldn&#39;t be null&quot;);
354 
355   // Create symbol* entry for module name.
<span class="line-modified">356   TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name, CHECK);</span>
357 
358   bool dupl_modules = false;
359 
360   // Create symbol* entry for module version.
361   TempNewSymbol version_symbol;
362   if (module_version != NULL) {
<span class="line-modified">363     version_symbol = SymbolTable::new_symbol(module_version, CHECK);</span>
364   } else {
365     version_symbol = NULL;
366   }
367 
368   // Create symbol* entry for module location.
369   const char* module_location = NULL;
370   TempNewSymbol location_symbol = NULL;
371   if (location != NULL) {
372     module_location =
373       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
374     if (module_location != NULL) {
<span class="line-modified">375       location_symbol = SymbolTable::new_symbol(module_location, CHECK);</span>
376     }
377   }
378 
379   PackageEntryTable* package_table = NULL;
380   PackageEntry* existing_pkg = NULL;
381   {
<span class="line-modified">382     MutexLocker ml(Module_lock, THREAD);</span>
383 
384     if (num_packages &gt; 0) {
385       package_table = get_package_entry_table(h_loader);
386       assert(package_table != NULL, &quot;Missing package_table&quot;);
387 
388       // Check that none of the packages exist in the class loader&#39;s package table.
389       for (int x = 0; x &lt; pkg_list-&gt;length(); x++) {
390         existing_pkg = package_table-&gt;locked_lookup_only(pkg_list-&gt;at(x));
391         if (existing_pkg != NULL) {
392           // This could be because the module was already defined.  If so,
393           // report that error instead of the package error.
394           if (module_table-&gt;lookup_only(module_symbol) != NULL) {
395             dupl_modules = true;
396           }
397           break;
398         }
399       }
400     }  // if (num_packages &gt; 0)...
401 
402     // Add the module and its packages.
</pre>
<hr />
<pre>
640     if (klass != NULL) {
641       ls.print_cr(&quot; for class %s&quot;, klass-&gt;external_name());
642     } else {
643       ls.print_cr(&quot; for primitive class&quot;);
644     }
645   }
646 
647   return JNIHandles::make_local(THREAD, module);
648 }
649 
650 jobject Modules::get_named_module(Handle h_loader, const char* package_name, TRAPS) {
651   assert(ModuleEntryTable::javabase_defined(),
652          &quot;Attempt to call get_named_module before &quot; JAVA_BASE_NAME &quot; is defined&quot;);
653   assert(h_loader.is_null() || java_lang_ClassLoader::is_subclass(h_loader-&gt;klass()),
654          &quot;Class loader is not a subclass of java.lang.ClassLoader&quot;);
655   assert(package_name != NULL, &quot;the package_name should not be NULL&quot;);
656 
657   if (strlen(package_name) == 0) {
658     return NULL;
659   }
<span class="line-modified">660   TempNewSymbol package_sym = SymbolTable::new_symbol(package_name, CHECK_NULL);</span>
661   const PackageEntry* const pkg_entry =
662     get_package_entry_by_name(package_sym, h_loader, THREAD);
663   const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
664 
665   if (module_entry != NULL &amp;&amp; module_entry-&gt;module() != NULL &amp;&amp; module_entry-&gt;is_named()) {
666     return JNIHandles::make_local(THREAD, module_entry-&gt;module());
667   }
668   return NULL;
669 }
670 
671 
672 // This method is called by JFR and by the above method.
673 jobject Modules::get_module(Symbol* package_name, Handle h_loader, TRAPS) {
674   const PackageEntry* const pkg_entry =
675     get_package_entry_by_name(package_name, h_loader, THREAD);
676   const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
677 
678   if (module_entry != NULL &amp;&amp;
679       module_entry-&gt;module() != NULL) {
680     return JNIHandles::make_local(THREAD, module_entry-&gt;module());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2 * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 *
  5 * This code is free software; you can redistribute it and/or modify it
  6 * under the terms of the GNU General Public License version 2 only, as
  7 * published by the Free Software Foundation.
  8 *
  9 * This code is distributed in the hope that it will be useful, but WITHOUT
 10 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 * version 2 for more details (a copy is included in the LICENSE file that
 13 * accompanied this code).
 14 *
 15 * You should have received a copy of the GNU General Public License version
 16 * 2 along with this work; if not, write to the Free Software Foundation,
 17 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 *
 19 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 * or visit www.oracle.com if you need additional information or have any
 21 * questions.
 22 *
</pre>
<hr />
<pre>
 94 
 95 static PackageEntryTable* get_package_entry_table(Handle h_loader) {
 96   // This code can be called during start-up, before the classLoader&#39;s classLoader data got
 97   // created.  So, call register_loader() to make sure the classLoader data gets created.
 98   ClassLoaderData *loader_cld = SystemDictionary::register_loader(h_loader);
 99   return loader_cld-&gt;packages();
100 }
101 
102 static ModuleEntry* get_module_entry(jobject module, TRAPS) {
103   oop m = JNIHandles::resolve(module);
104   if (!java_lang_Module::is_instance(m)) {
105     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),
106                    &quot;module is not an instance of type java.lang.Module&quot;);
107   }
108   return java_lang_Module::module_entry(m);
109 }
110 
111 static PackageEntry* get_package_entry(ModuleEntry* module_entry, const char* package_name, TRAPS) {
112   ResourceMark rm(THREAD);
113   if (package_name == NULL) return NULL;
<span class="line-modified">114   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(package_name);</span>
115   PackageEntryTable* package_entry_table = module_entry-&gt;loader_data()-&gt;packages();
116   assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
117   return package_entry_table-&gt;lookup_only(pkg_symbol);
118 }
119 
120 static PackageEntry* get_package_entry_by_name(Symbol* package,
121                                                Handle h_loader,
122                                                TRAPS) {
123   if (package != NULL) {
124     ResourceMark rm(THREAD);
125     if (Modules::verify_package_name(package-&gt;as_C_string())) {
126       PackageEntryTable* const package_entry_table =
127         get_package_entry_table(h_loader);
128       assert(package_entry_table != NULL, &quot;Unexpected null package entry table&quot;);
129       return package_entry_table-&gt;lookup_only(package);
130     }
131   }
132   return NULL;
133 }
134 
135 bool Modules::is_package_defined(Symbol* package, Handle h_loader, TRAPS) {
136   PackageEntry* res = get_package_entry_by_name(package, h_loader, CHECK_false);
137   return res != NULL;
138 }
139 
140 static void define_javabase_module(jobject module, jstring version,
141                                    jstring location, const char* const* packages,
142                                    jsize num_packages, TRAPS) {
143   ResourceMark rm(THREAD);
144 
145   Handle module_handle(THREAD, JNIHandles::resolve(module));
146 
147   // Obtain java.base&#39;s module version
148   const char* module_version = get_module_version(version);
149   TempNewSymbol version_symbol;
150   if (module_version != NULL) {
<span class="line-modified">151     version_symbol = SymbolTable::new_symbol(module_version);</span>
152   } else {
153     version_symbol = NULL;
154   }
155 
156   // Obtain java.base&#39;s location
157   const char* module_location = NULL;
158   TempNewSymbol location_symbol = NULL;
159   if (location != NULL) {
160     module_location =
161       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
162     if (module_location != NULL) {
<span class="line-modified">163       location_symbol = SymbolTable::new_symbol(module_location);</span>
164     }
165   }
166 
167 
168   // Check that the packages are syntactically ok.
169   GrowableArray&lt;Symbol*&gt;* pkg_list = new GrowableArray&lt;Symbol*&gt;(num_packages);
170   for (int x = 0; x &lt; num_packages; x++) {
171     const char *package_name = packages[x];
172     if (!Modules::verify_package_name(package_name)) {
173       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
174                 err_msg(&quot;Invalid package name: %s for module: &quot; JAVA_BASE_NAME, package_name));
175     }
<span class="line-modified">176     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);</span>
177     pkg_list-&gt;append(pkg_symbol);
178   }
179 
180   // Validate java_base&#39;s loader is the boot loader.
181   oop loader = java_lang_Module::loader(module_handle());
182   if (loader != NULL) {
183     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
184               &quot;Class loader must be the boot class loader&quot;);
185   }
186   Handle h_loader(THREAD, loader);
187 
188   // Ensure the boot loader&#39;s PackageEntryTable has been created
189   PackageEntryTable* package_table = get_package_entry_table(h_loader);
190   assert(pkg_list-&gt;length() == 0 || package_table != NULL, &quot;Bad package_table&quot;);
191 
192   // Ensure java.base&#39;s ModuleEntry has been created
193   assert(ModuleEntryTable::javabase_moduleEntry() != NULL, &quot;No ModuleEntry for &quot; JAVA_BASE_NAME);
194 
195   bool duplicate_javabase = false;
196   {
<span class="line-modified">197     MutexLocker m1(THREAD, Module_lock);</span>
198 
199     if (ModuleEntryTable::javabase_defined()) {
200       duplicate_javabase = true;
201     } else {
202 
203       // Verify that all java.base packages created during bootstrapping are in
204       // pkg_list.  If any are not in pkg_list, than a non-java.base class was
205       // loaded erroneously pre java.base module definition.
206       package_table-&gt;verify_javabase_packages(pkg_list);
207 
208       // loop through and add any new packages for java.base
209       for (int x = 0; x &lt; pkg_list-&gt;length(); x++) {
210         // Some of java.base&#39;s packages were added early in bootstrapping, ignore duplicates.
211         package_table-&gt;locked_create_entry_if_not_exist(pkg_list-&gt;at(x),
212                                                         ModuleEntryTable::javabase_moduleEntry());
213         assert(package_table-&gt;locked_lookup_only(pkg_list-&gt;at(x)) != NULL,
214                &quot;Unable to create a &quot; JAVA_BASE_NAME &quot; package entry&quot;);
215         // Unable to have a GrowableArray of TempNewSymbol.  Must decrement the refcount of
216         // the Symbol* that was created above for each package. The refcount was incremented
217         // by SymbolTable::new_symbol and as well by the PackageEntry creation.
</pre>
<hr />
<pre>
289               &quot;module is not an instance of type java.lang.Module&quot;);
290   }
291 
292   char* module_name = get_module_name(module_handle(), CHECK);
293   if (module_name == NULL) {
294     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
295               &quot;Module name cannot be null&quot;);
296   }
297 
298   // Special handling of java.base definition
299   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
300     assert(is_open == JNI_FALSE, &quot;java.base module cannot be open&quot;);
301     define_javabase_module(module, version, location, packages, num_packages, CHECK);
302     return;
303   }
304 
305   const char* module_version = get_module_version(version);
306 
307   oop loader = java_lang_Module::loader(module_handle());
308   // Make sure loader is not the jdk.internal.reflect.DelegatingClassLoader.
<span class="line-modified">309   if (loader != java_lang_ClassLoader::non_reflection_class_loader(loader)) {</span>
310     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
311               &quot;Class loader is an invalid delegating class loader&quot;);
312   }
313   Handle h_loader = Handle(THREAD, loader);
314   // define_module can be called during start-up, before the class loader&#39;s ClassLoaderData
315   // has been created.  SystemDictionary::register_loader ensures creation, if needed.
316   ClassLoaderData* loader_data = SystemDictionary::register_loader(h_loader);
317   assert(loader_data != NULL, &quot;class loader data shouldn&#39;t be null&quot;);
318 
319   // Check that the list of packages has no duplicates and that the
320   // packages are syntactically ok.
321   GrowableArray&lt;Symbol*&gt;* pkg_list = new GrowableArray&lt;Symbol*&gt;(num_packages);
322   for (int x = 0; x &lt; num_packages; x++) {
323     const char* package_name = packages[x];
324     if (!verify_package_name(package_name)) {
325       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
326                 err_msg(&quot;Invalid package name: %s for module: %s&quot;,
327                         package_name, module_name));
328     }
329 
330     // Only modules defined to either the boot or platform class loader, can define a &quot;java/&quot; package.
331     if (!h_loader.is_null() &amp;&amp;
332         !SystemDictionary::is_platform_class_loader(h_loader()) &amp;&amp;
333         (strncmp(package_name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp;
<span class="line-modified">334           (package_name[JAVAPKG_LEN] == JVM_SIGNATURE_SLASH || package_name[JAVAPKG_LEN] == &#39;\0&#39;))) {</span>
335       const char* class_loader_name = loader_data-&gt;loader_name_and_id();
336       size_t pkg_len = strlen(package_name);
337       char* pkg_name = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, pkg_len + 1);
338       strncpy(pkg_name, package_name, pkg_len + 1);
339       StringUtils::replace_no_expand(pkg_name, &quot;/&quot;, &quot;.&quot;);
340       const char* msg_text1 = &quot;Class loader (instance of): &quot;;
341       const char* msg_text2 = &quot; tried to define prohibited package name: &quot;;
342       size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + pkg_len + 1;
343       char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);
344       jio_snprintf(message, len, &quot;%s%s%s%s&quot;, msg_text1, class_loader_name, msg_text2, pkg_name);
345       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), message);
346     }
347 
<span class="line-modified">348     Symbol* pkg_symbol = SymbolTable::new_symbol(package_name);</span>
349     pkg_list-&gt;append(pkg_symbol);
350   }
351 
352   ModuleEntryTable* module_table = get_module_entry_table(h_loader);
353   assert(module_table != NULL, &quot;module entry table shouldn&#39;t be null&quot;);
354 
355   // Create symbol* entry for module name.
<span class="line-modified">356   TempNewSymbol module_symbol = SymbolTable::new_symbol(module_name);</span>
357 
358   bool dupl_modules = false;
359 
360   // Create symbol* entry for module version.
361   TempNewSymbol version_symbol;
362   if (module_version != NULL) {
<span class="line-modified">363     version_symbol = SymbolTable::new_symbol(module_version);</span>
364   } else {
365     version_symbol = NULL;
366   }
367 
368   // Create symbol* entry for module location.
369   const char* module_location = NULL;
370   TempNewSymbol location_symbol = NULL;
371   if (location != NULL) {
372     module_location =
373       java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(location));
374     if (module_location != NULL) {
<span class="line-modified">375       location_symbol = SymbolTable::new_symbol(module_location);</span>
376     }
377   }
378 
379   PackageEntryTable* package_table = NULL;
380   PackageEntry* existing_pkg = NULL;
381   {
<span class="line-modified">382     MutexLocker ml(THREAD, Module_lock);</span>
383 
384     if (num_packages &gt; 0) {
385       package_table = get_package_entry_table(h_loader);
386       assert(package_table != NULL, &quot;Missing package_table&quot;);
387 
388       // Check that none of the packages exist in the class loader&#39;s package table.
389       for (int x = 0; x &lt; pkg_list-&gt;length(); x++) {
390         existing_pkg = package_table-&gt;locked_lookup_only(pkg_list-&gt;at(x));
391         if (existing_pkg != NULL) {
392           // This could be because the module was already defined.  If so,
393           // report that error instead of the package error.
394           if (module_table-&gt;lookup_only(module_symbol) != NULL) {
395             dupl_modules = true;
396           }
397           break;
398         }
399       }
400     }  // if (num_packages &gt; 0)...
401 
402     // Add the module and its packages.
</pre>
<hr />
<pre>
640     if (klass != NULL) {
641       ls.print_cr(&quot; for class %s&quot;, klass-&gt;external_name());
642     } else {
643       ls.print_cr(&quot; for primitive class&quot;);
644     }
645   }
646 
647   return JNIHandles::make_local(THREAD, module);
648 }
649 
650 jobject Modules::get_named_module(Handle h_loader, const char* package_name, TRAPS) {
651   assert(ModuleEntryTable::javabase_defined(),
652          &quot;Attempt to call get_named_module before &quot; JAVA_BASE_NAME &quot; is defined&quot;);
653   assert(h_loader.is_null() || java_lang_ClassLoader::is_subclass(h_loader-&gt;klass()),
654          &quot;Class loader is not a subclass of java.lang.ClassLoader&quot;);
655   assert(package_name != NULL, &quot;the package_name should not be NULL&quot;);
656 
657   if (strlen(package_name) == 0) {
658     return NULL;
659   }
<span class="line-modified">660   TempNewSymbol package_sym = SymbolTable::new_symbol(package_name);</span>
661   const PackageEntry* const pkg_entry =
662     get_package_entry_by_name(package_sym, h_loader, THREAD);
663   const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
664 
665   if (module_entry != NULL &amp;&amp; module_entry-&gt;module() != NULL &amp;&amp; module_entry-&gt;is_named()) {
666     return JNIHandles::make_local(THREAD, module_entry-&gt;module());
667   }
668   return NULL;
669 }
670 
671 
672 // This method is called by JFR and by the above method.
673 jobject Modules::get_module(Symbol* package_name, Handle h_loader, TRAPS) {
674   const PackageEntry* const pkg_entry =
675     get_package_entry_by_name(package_name, h_loader, THREAD);
676   const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry-&gt;module() : NULL);
677 
678   if (module_entry != NULL &amp;&amp;
679       module_entry-&gt;module() != NULL) {
680     return JNIHandles::make_local(THREAD, module_entry-&gt;module());
</pre>
</td>
</tr>
</table>
<center><a href="moduleEntry.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="packageEntry.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
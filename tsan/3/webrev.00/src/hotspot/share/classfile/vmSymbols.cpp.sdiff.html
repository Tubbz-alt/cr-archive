<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/vmSymbols.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verifier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/vmSymbols.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;

  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;compiler/compilerDirectives.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/oopFactory.hpp&quot;
  31 #include &quot;memory/metaspaceClosure.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;utilities/xmlstream.hpp&quot;
  35 
  36 
  37 Symbol* vmSymbols::_symbols[vmSymbols::SID_LIMIT];
  38 
  39 Symbol* vmSymbols::_type_signatures[T_VOID+1] = { NULL /*, NULL...*/ };
  40 
  41 inline int compare_symbol(const Symbol* a, const Symbol* b) {
  42   if (a == b)  return 0;
  43   // follow the natural address order:
  44   return (address)a &gt; (address)b ? +1 : -1;
  45 }
  46 
</pre>
<hr />
<pre>
  66     if (skiplen == 0)  return &quot;&lt;unknown&gt;&quot;;  // overflow
  67     string += skiplen+1;
  68   }
  69   return string;
  70 }
  71 #endif //ASSERT
  72 
  73 // Put all the VM symbol strings in one place.
  74 // Makes for a more compact libjvm.
  75 #define VM_SYMBOL_BODY(name, string) string &quot;\0&quot;
  76 static const char* vm_symbol_bodies = VM_SYMBOLS_DO(VM_SYMBOL_BODY, VM_ALIAS_IGNORE);
  77 
  78 void vmSymbols::initialize(TRAPS) {
  79   assert((int)SID_LIMIT &lt;= (1&lt;&lt;log2_SID_LIMIT), &quot;must fit in this bitfield&quot;);
  80   assert((int)SID_LIMIT*5 &gt; (1&lt;&lt;log2_SID_LIMIT), &quot;make the bitfield smaller, please&quot;);
  81   assert(vmIntrinsics::FLAG_LIMIT &lt;= (1 &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT), &quot;must fit in this bitfield&quot;);
  82 
  83   if (!UseSharedSpaces) {
  84     const char* string = &amp;vm_symbol_bodies[0];
  85     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
<span class="line-modified">  86       Symbol* sym = SymbolTable::new_permanent_symbol(string, CHECK);</span>
  87       _symbols[index] = sym;
  88       string += strlen(string); // skip string body
  89       string += 1;              // skip trailing null
  90     }
  91 
  92     _type_signatures[T_BYTE]    = byte_signature();
  93     _type_signatures[T_CHAR]    = char_signature();
  94     _type_signatures[T_DOUBLE]  = double_signature();
  95     _type_signatures[T_FLOAT]   = float_signature();
  96     _type_signatures[T_INT]     = int_signature();
  97     _type_signatures[T_LONG]    = long_signature();
  98     _type_signatures[T_SHORT]   = short_signature();
  99     _type_signatures[T_BOOLEAN] = bool_signature();
 100     _type_signatures[T_VOID]    = void_signature();
<span class="line-removed"> 101     // no single signatures for T_OBJECT or T_ARRAY</span>
 102 #ifdef ASSERT
 103     for (int i = (int)T_BOOLEAN; i &lt; (int)T_VOID+1; i++) {
 104       Symbol* s = _type_signatures[i];
 105       if (s == NULL)  continue;
<span class="line-modified"> 106       BasicType st = signature_type(s);</span>
<span class="line-modified"> 107       assert(st == i, &quot;&quot;);</span>

 108     }
 109 #endif
 110   }
 111 
 112 #ifdef ASSERT
 113   // Check for duplicates:
 114   for (int i1 = (int)FIRST_SID; i1 &lt; (int)SID_LIMIT; i1++) {
 115     Symbol* sym = symbol_at((SID)i1);
 116     for (int i2 = (int)FIRST_SID; i2 &lt; i1; i2++) {
 117       if (symbol_at((SID)i2) == sym) {
 118         tty-&gt;print(&quot;*** Duplicate VM symbol SIDs %s(%d) and %s(%d): \&quot;&quot;,
 119                    vm_symbol_enum_name((SID)i2), i2,
 120                    vm_symbol_enum_name((SID)i1), i1);
 121         sym-&gt;print_symbol_on(tty);
 122         tty-&gt;print_cr(&quot;\&quot;&quot;);
 123       }
 124     }
 125   }
 126 #endif //ASSERT
 127 
 128   // Create an index for find_id:
 129   {
 130     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 131       vm_symbol_index[index] = (SID)index;
 132     }
 133     int num_sids = SID_LIMIT-FIRST_SID;
 134     qsort(&amp;vm_symbol_index[FIRST_SID], num_sids, sizeof(vm_symbol_index[0]),
 135           compare_vmsymbol_sid);
 136   }
 137 
 138 #ifdef ASSERT
 139   {
 140     // Spot-check correspondence between strings, symbols, and enums:
 141     assert(_symbols[NO_SID] == NULL, &quot;must be&quot;);
 142     const char* str = &quot;java/lang/Object&quot;;
<span class="line-modified"> 143     TempNewSymbol jlo = SymbolTable::new_permanent_symbol(str, CHECK);</span>
 144     assert(strncmp(str, (char*)jlo-&gt;base(), jlo-&gt;utf8_length()) == 0, &quot;&quot;);
 145     assert(jlo == java_lang_Object(), &quot;&quot;);
 146     SID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);
 147     assert(find_sid(jlo) == sid, &quot;&quot;);
 148     assert(symbol_at(sid) == jlo, &quot;&quot;);
 149 
 150     // Make sure find_sid produces the right answer in each case.
 151     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 152       Symbol* sym = symbol_at((SID)index);
 153       sid = find_sid(sym);
 154       assert(sid == (SID)index, &quot;symbol index works&quot;);
 155       // Note:  If there are duplicates, this assert will fail.
 156       // A &quot;Duplicate VM symbol&quot; message will have already been printed.
 157     }
 158 
 159     // The string &quot;format&quot; happens (at the moment) not to be a vmSymbol,
 160     // though it is a method name in java.lang.String.
 161     str = &quot;format&quot;;
<span class="line-modified"> 162     TempNewSymbol fmt = SymbolTable::new_permanent_symbol(str, CHECK);</span>
 163     sid = find_sid(fmt);
 164     assert(sid == NO_SID, &quot;symbol index works (negative test)&quot;);
 165   }
 166 #endif
 167 }
 168 
 169 
 170 #ifndef PRODUCT
 171 const char* vmSymbols::name_for(vmSymbols::SID sid) {
 172   if (sid == NO_SID)
 173     return &quot;NO_SID&quot;;
 174   const char* string = &amp;vm_symbol_bodies[0];
 175   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 176     if (index == (int)sid)
 177       return string;
 178     string += strlen(string); // skip string body
 179     string += 1;              // skip trailing null
 180   }
 181   return &quot;BAD_SID&quot;;
 182 }
</pre>
<hr />
<pre>
 191   for (int i = 0; i &lt; T_VOID+1; i++) {
 192     f-&gt;do_symbol(&amp;_type_signatures[i]);
 193   }
 194 }
 195 
 196 void vmSymbols::metaspace_pointers_do(MetaspaceClosure *it) {
 197   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 198     it-&gt;push(&amp;_symbols[index]);
 199   }
 200   for (int i = 0; i &lt; T_VOID+1; i++) {
 201     it-&gt;push(&amp;_type_signatures[i]);
 202   }
 203 }
 204 
 205 void vmSymbols::serialize(SerializeClosure* soc) {
 206   soc-&gt;do_region((u_char*)&amp;_symbols[FIRST_SID],
 207                  (SID_LIMIT - FIRST_SID) * sizeof(_symbols[0]));
 208   soc-&gt;do_region((u_char*)_type_signatures, sizeof(_type_signatures));
 209 }
 210 
<span class="line-removed"> 211 </span>
<span class="line-removed"> 212 BasicType vmSymbols::signature_type(const Symbol* s) {</span>
<span class="line-removed"> 213   assert(s != NULL, &quot;checking&quot;);</span>
<span class="line-removed"> 214   if (s-&gt;utf8_length() == 1) {</span>
<span class="line-removed"> 215     BasicType result = char2type(s-&gt;char_at(0));</span>
<span class="line-removed"> 216     if (is_java_primitive(result) || result == T_VOID) {</span>
<span class="line-removed"> 217       assert(s == _type_signatures[result], &quot;&quot;);</span>
<span class="line-removed"> 218       return result;</span>
<span class="line-removed"> 219     }</span>
<span class="line-removed"> 220   }</span>
<span class="line-removed"> 221   return T_OBJECT;</span>
<span class="line-removed"> 222 }</span>
<span class="line-removed"> 223 </span>
<span class="line-removed"> 224 </span>
 225 static int mid_hint = (int)vmSymbols::FIRST_SID+1;
 226 
 227 #ifndef PRODUCT
 228 static int find_sid_calls, find_sid_probes;
 229 // (Typical counts are calls=7000 and probes=17000.)
 230 #endif
 231 
 232 vmSymbols::SID vmSymbols::find_sid(const Symbol* symbol) {
 233   // Handle the majority of misses by a bounds check.
 234   // Then, use a binary search over the index.
 235   // Expected trip count is less than log2_SID_LIMIT, about eight.
 236   // This is slow but acceptable, given that calls are not
 237   // dynamically common.  (Method*::intrinsic_id has a cache.)
 238   NOT_PRODUCT(find_sid_calls++);
 239   int min = (int)FIRST_SID, max = (int)SID_LIMIT - 1;
 240   SID sid = NO_SID, sid1;
 241   int cmp1;
 242   sid1 = vm_symbol_index[min];
 243   cmp1 = compare_symbol(symbol, symbol_at(sid1));
 244   if (cmp1 &lt;= 0) {              // before the first
</pre>
<hr />
<pre>
 346 
 347   return vmIntrinsics::_none;
 348 }
 349 
 350 bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {
 351   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 352   switch(id) {
 353 #ifdef JFR_HAVE_INTRINSICS
 354   case vmIntrinsics::_counterTime:
 355 #endif
 356   case vmIntrinsics::_currentTimeMillis:
 357   case vmIntrinsics::_nanoTime:
 358   case vmIntrinsics::_floatToRawIntBits:
 359   case vmIntrinsics::_intBitsToFloat:
 360   case vmIntrinsics::_doubleToRawLongBits:
 361   case vmIntrinsics::_longBitsToDouble:
 362   case vmIntrinsics::_getClass:
 363   case vmIntrinsics::_isInstance:
 364   case vmIntrinsics::_currentThread:
 365   case vmIntrinsics::_dabs:



 366   case vmIntrinsics::_dsqrt:
 367   case vmIntrinsics::_dsin:
 368   case vmIntrinsics::_dcos:
 369   case vmIntrinsics::_dtan:
 370   case vmIntrinsics::_dlog:
 371   case vmIntrinsics::_dlog10:
 372   case vmIntrinsics::_dexp:
 373   case vmIntrinsics::_dpow:
 374   case vmIntrinsics::_checkIndex:
 375   case vmIntrinsics::_Reference_get:
 376   case vmIntrinsics::_updateCRC32:
 377   case vmIntrinsics::_updateBytesCRC32:
 378   case vmIntrinsics::_updateByteBufferCRC32:
 379   case vmIntrinsics::_vectorizedMismatch:
 380   case vmIntrinsics::_fmaD:
 381   case vmIntrinsics::_fmaF:
 382   case vmIntrinsics::_isDigit:
 383   case vmIntrinsics::_isLowerCase:
 384   case vmIntrinsics::_isUpperCase:
 385   case vmIntrinsics::_isWhitespace:
</pre>
<hr />
<pre>
 387   default:
 388     return false;
 389   }
 390 }
 391 
 392 bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {
 393   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 394   switch(id) {
 395 #ifdef JFR_HAVE_INTRINSICS
 396   case vmIntrinsics::_counterTime:
 397   case vmIntrinsics::_getClassId:
 398 #endif
 399   case vmIntrinsics::_currentTimeMillis:
 400   case vmIntrinsics::_nanoTime:
 401   case vmIntrinsics::_floatToRawIntBits:
 402   case vmIntrinsics::_intBitsToFloat:
 403   case vmIntrinsics::_doubleToRawLongBits:
 404   case vmIntrinsics::_longBitsToDouble:
 405   case vmIntrinsics::_currentThread:
 406   case vmIntrinsics::_dabs:



 407   case vmIntrinsics::_dsqrt:
 408   case vmIntrinsics::_dsin:
 409   case vmIntrinsics::_dcos:
 410   case vmIntrinsics::_dtan:
 411   case vmIntrinsics::_dlog:
 412   case vmIntrinsics::_dlog10:
 413   case vmIntrinsics::_dexp:
 414   case vmIntrinsics::_dpow:
 415   case vmIntrinsics::_updateCRC32:
 416   case vmIntrinsics::_updateBytesCRC32:
 417   case vmIntrinsics::_updateByteBufferCRC32:
 418   case vmIntrinsics::_vectorizedMismatch:
 419   case vmIntrinsics::_fmaD:
 420   case vmIntrinsics::_fmaF:
 421     return false;
 422   default:
 423     return true;
 424   }
 425 }
 426 
</pre>
<hr />
<pre>
 439   }
 440 }
 441 
 442 bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {
 443   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 444   switch(id) {
 445   case vmIntrinsics::_hashCode:
 446   case vmIntrinsics::_clone:
 447     return true;
 448     break;
 449   default:
 450     return false;
 451   }
 452 }
 453 
 454 int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {
 455   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 456   switch (id) {
 457   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 458   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:


 459   case vmIntrinsics::_counterMode_AESCrypt:
 460     return 1;
 461   case vmIntrinsics::_digestBase_implCompressMB:
 462     return 3;
 463   default:
 464     return 0;
 465   }
 466 }
 467 
 468 bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {
 469   return !vmIntrinsics::is_intrinsic_disabled(id) &amp;&amp;
 470     !vmIntrinsics::is_disabled_by_flags(id);
 471 }
 472 
 473 bool vmIntrinsics::is_intrinsic_disabled(vmIntrinsics::ID id) {
 474   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 475 
 476   // Canonicalize DisableIntrinsic to contain only &#39;,&#39; as a separator.
 477   // Note, DirectiveSet may not be created at this point yet since this code
 478   // is called from initial stub geenration code.
</pre>
<hr />
<pre>
 542     default:
 543       return true;
 544     }
 545   }
 546 
 547   switch (id) {
 548   case vmIntrinsics::_isInstance:
 549   case vmIntrinsics::_isAssignableFrom:
 550   case vmIntrinsics::_getModifiers:
 551   case vmIntrinsics::_isInterface:
 552   case vmIntrinsics::_isArray:
 553   case vmIntrinsics::_isPrimitive:
 554   case vmIntrinsics::_getSuperclass:
 555   case vmIntrinsics::_Class_cast:
 556   case vmIntrinsics::_getLength:
 557   case vmIntrinsics::_newArray:
 558   case vmIntrinsics::_getClass:
 559     if (!InlineClassNatives) return true;
 560     break;
 561   case vmIntrinsics::_currentThread:
<span class="line-removed"> 562   case vmIntrinsics::_isInterrupted:</span>
 563     if (!InlineThreadNatives) return true;
 564     break;
 565   case vmIntrinsics::_floatToRawIntBits:
 566   case vmIntrinsics::_intBitsToFloat:
 567   case vmIntrinsics::_doubleToRawLongBits:
 568   case vmIntrinsics::_longBitsToDouble:



 569   case vmIntrinsics::_dabs:



 570   case vmIntrinsics::_dsqrt:
 571   case vmIntrinsics::_dsin:
 572   case vmIntrinsics::_dcos:
 573   case vmIntrinsics::_dtan:
 574   case vmIntrinsics::_dlog:
 575   case vmIntrinsics::_dexp:
 576   case vmIntrinsics::_dpow:
 577   case vmIntrinsics::_dlog10:
 578   case vmIntrinsics::_datan2:
 579   case vmIntrinsics::_min:
 580   case vmIntrinsics::_max:
 581   case vmIntrinsics::_floatToIntBits:
 582   case vmIntrinsics::_doubleToLongBits:
 583   case vmIntrinsics::_maxF:
 584   case vmIntrinsics::_minF:
 585   case vmIntrinsics::_maxD:
 586   case vmIntrinsics::_minD:
 587     if (!InlineMathNatives) return true;
 588     break;
 589   case vmIntrinsics::_fmaD:
</pre>
<hr />
<pre>
 709   case vmIntrinsics::_getIntUnaligned:
 710   case vmIntrinsics::_getLongUnaligned:
 711   case vmIntrinsics::_putShortUnaligned:
 712   case vmIntrinsics::_putCharUnaligned:
 713   case vmIntrinsics::_putIntUnaligned:
 714   case vmIntrinsics::_putLongUnaligned:
 715   case vmIntrinsics::_allocateInstance:
 716     if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;
 717     break;
 718   case vmIntrinsics::_hashCode:
 719     if (!InlineObjectHash) return true;
 720     break;
 721   case vmIntrinsics::_aescrypt_encryptBlock:
 722   case vmIntrinsics::_aescrypt_decryptBlock:
 723     if (!UseAESIntrinsics) return true;
 724     break;
 725   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 726   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 727     if (!UseAESIntrinsics) return true;
 728     break;




 729   case vmIntrinsics::_counterMode_AESCrypt:
 730     if (!UseAESCTRIntrinsics) return true;
 731     break;
 732   case vmIntrinsics::_sha_implCompress:
 733     if (!UseSHA1Intrinsics) return true;
 734     break;
 735   case vmIntrinsics::_sha2_implCompress:
 736     if (!UseSHA256Intrinsics) return true;
 737     break;
 738   case vmIntrinsics::_sha5_implCompress:
 739     if (!UseSHA512Intrinsics) return true;
 740     break;
 741   case vmIntrinsics::_digestBase_implCompressMB:
 742     if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;
 743     break;
 744   case vmIntrinsics::_ghash_processBlocks:
 745     if (!UseGHASHIntrinsics) return true;
 746     break;
 747   case vmIntrinsics::_base64_encodeBlock:
 748     if (!UseBASE64Intrinsics) return true;
</pre>
<hr />
<pre>
 751   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 752     if (!UseCRC32CIntrinsics) return true;
 753     break;
 754   case vmIntrinsics::_vectorizedMismatch:
 755     if (!UseVectorizedMismatchIntrinsic) return true;
 756     break;
 757   case vmIntrinsics::_updateBytesAdler32:
 758   case vmIntrinsics::_updateByteBufferAdler32:
 759     if (!UseAdler32Intrinsics) return true;
 760     break;
 761   case vmIntrinsics::_copyMemory:
 762     if (!InlineArrayCopy || !InlineUnsafeOps) return true;
 763     break;
 764 #ifdef COMPILER1
 765   case vmIntrinsics::_checkIndex:
 766     if (!InlineNIOCheckIndex) return true;
 767     break;
 768 #endif // COMPILER1
 769 #ifdef COMPILER2
 770   case vmIntrinsics::_clone:
<span class="line-removed"> 771 #if INCLUDE_ZGC</span>
<span class="line-removed"> 772     if (UseZGC) return true;</span>
<span class="line-removed"> 773 #endif</span>
 774   case vmIntrinsics::_copyOf:
 775   case vmIntrinsics::_copyOfRange:
 776     // These intrinsics use both the objectcopy and the arraycopy
 777     // intrinsic mechanism.
 778     if (!InlineObjectCopy || !InlineArrayCopy) return true;
 779     break;
 780   case vmIntrinsics::_compareToL:
 781   case vmIntrinsics::_compareToU:
 782   case vmIntrinsics::_compareToLU:
 783   case vmIntrinsics::_compareToUL:
 784     if (!SpecialStringCompareTo) return true;
 785     break;
 786   case vmIntrinsics::_indexOfL:
 787   case vmIntrinsics::_indexOfU:
 788   case vmIntrinsics::_indexOfUL:
 789   case vmIntrinsics::_indexOfIL:
 790   case vmIntrinsics::_indexOfIU:
 791   case vmIntrinsics::_indexOfIUL:
 792   case vmIntrinsics::_indexOfU_char:
 793     if (!SpecialStringIndexOf) return true;
</pre>
<hr />
<pre>
 805     if (!SpecialEncodeISOArray) return true;
 806     break;
 807   case vmIntrinsics::_getCallerClass:
 808     if (!InlineReflectionGetCallerClass) return true;
 809     break;
 810   case vmIntrinsics::_multiplyToLen:
 811     if (!UseMultiplyToLenIntrinsic) return true;
 812     break;
 813   case vmIntrinsics::_squareToLen:
 814     if (!UseSquareToLenIntrinsic) return true;
 815     break;
 816   case vmIntrinsics::_mulAdd:
 817     if (!UseMulAddIntrinsic) return true;
 818     break;
 819   case vmIntrinsics::_montgomeryMultiply:
 820     if (!UseMontgomeryMultiplyIntrinsic) return true;
 821     break;
 822   case vmIntrinsics::_montgomerySquare:
 823     if (!UseMontgomerySquareIntrinsic) return true;
 824     break;



 825   case vmIntrinsics::_addExactI:
 826   case vmIntrinsics::_addExactL:
 827   case vmIntrinsics::_decrementExactI:
 828   case vmIntrinsics::_decrementExactL:
 829   case vmIntrinsics::_incrementExactI:
 830   case vmIntrinsics::_incrementExactL:
 831   case vmIntrinsics::_multiplyExactI:
 832   case vmIntrinsics::_multiplyExactL:
 833   case vmIntrinsics::_negateExactI:
 834   case vmIntrinsics::_negateExactL:
 835   case vmIntrinsics::_subtractExactI:
 836   case vmIntrinsics::_subtractExactL:
 837     if (!UseMathExactIntrinsics || !InlineMathNatives) return true;
 838     break;
 839   case vmIntrinsics::_isDigit:
 840   case vmIntrinsics::_isLowerCase:
 841   case vmIntrinsics::_isUpperCase:
 842   case vmIntrinsics::_isWhitespace:
 843     if (!UseCharacterCompareIntrinsics) return true;
 844     break;
</pre>
<hr />
<pre>
 934 
 935 #undef VM_INTRINSIC_CASE
 936 }
 937 
 938 
 939 const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {
 940   const char* str = name_at(id);
 941 #ifndef PRODUCT
 942   const char* kname = vmSymbols::name_for(class_for(id));
 943   const char* mname = vmSymbols::name_for(name_for(id));
 944   const char* sname = vmSymbols::name_for(signature_for(id));
 945   const char* fname = &quot;&quot;;
 946   switch (flags_for(id)) {
 947   case F_Y:  fname = &quot;synchronized &quot;;  break;
 948   case F_RN: fname = &quot;native &quot;;        break;
 949   case F_SN: fname = &quot;native static &quot;; break;
 950   case F_S:  fname = &quot;static &quot;;        break;
 951   case F_RNY:fname = &quot;native synchronized &quot;; break;
 952   default:   break;
 953   }
<span class="line-modified"> 954   const char* kptr = strrchr(kname, &#39;/&#39;);</span>
 955   if (kptr != NULL)  kname = kptr + 1;
 956   int len = jio_snprintf(buf, buflen, &quot;%s: %s%s.%s%s&quot;,
 957                          str, fname, kname, mname, sname);
 958   if (len &lt; buflen)
 959     str = buf;
 960 #endif //PRODUCT
 961   return str;
 962 }
 963 
 964 
 965 // These are to get information about intrinsics.
 966 
 967 #define ID4(x, y, z, f) ((ID3(x, y, z) &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))
 968 
 969 static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {
 970 #define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \
 971   ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),
 972 
 973   0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,
 974                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
</pre>
<hr />
<pre>
1037   ID declared_id = match_method_with_klass(m, mk);
1038 
1039   if (declared_id == actual_id)  return; // success
1040 
1041   if (declared_id == _none &amp;&amp; actual_id != _none &amp;&amp; mk == vmSymbols::java_lang_StrictMath()) {
1042     // Here are a few special cases in StrictMath not declared in vmSymbols.hpp.
1043     switch (actual_id) {
1044     case _min:
1045     case _max:
1046     case _dsqrt:
1047       declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());
1048       if (declared_id == actual_id)  return; // acceptable alias
1049       break;
1050     default:
1051         break;
1052     }
1053   }
1054 
1055   const char* declared_name = name_at(declared_id);
1056   const char* actual_name   = name_at(actual_id);
<span class="line-removed">1057   methodHandle mh = m;</span>
1058   m = NULL;
1059   ttyLocker ttyl;
1060   if (xtty != NULL) {
1061     xtty-&gt;begin_elem(&quot;intrinsic_misdeclared actual=&#39;%s&#39; declared=&#39;%s&#39;&quot;,
1062                      actual_name, declared_name);
<span class="line-modified">1063     xtty-&gt;method(mh);</span>
1064     xtty-&gt;end_elem(&quot;%s&quot;, &quot;&quot;);
1065   }
1066   if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
1067     tty-&gt;print_cr(&quot;*** misidentified method; %s(%d) should be %s(%d):&quot;,
1068                   declared_name, declared_id, actual_name, actual_id);
<span class="line-modified">1069     mh()-&gt;print_short_name(tty);</span>
1070     tty-&gt;cr();
1071   }
1072 }
1073 #endif //PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
<span class="line-added">  27 #include &quot;classfile/symbolTable.hpp&quot;</span>
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/oopFactory.hpp&quot;
  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;runtime/handles.inline.hpp&quot;
  35 #include &quot;utilities/xmlstream.hpp&quot;
  36 
  37 
  38 Symbol* vmSymbols::_symbols[vmSymbols::SID_LIMIT];
  39 
  40 Symbol* vmSymbols::_type_signatures[T_VOID+1] = { NULL /*, NULL...*/ };
  41 
  42 inline int compare_symbol(const Symbol* a, const Symbol* b) {
  43   if (a == b)  return 0;
  44   // follow the natural address order:
  45   return (address)a &gt; (address)b ? +1 : -1;
  46 }
  47 
</pre>
<hr />
<pre>
  67     if (skiplen == 0)  return &quot;&lt;unknown&gt;&quot;;  // overflow
  68     string += skiplen+1;
  69   }
  70   return string;
  71 }
  72 #endif //ASSERT
  73 
  74 // Put all the VM symbol strings in one place.
  75 // Makes for a more compact libjvm.
  76 #define VM_SYMBOL_BODY(name, string) string &quot;\0&quot;
  77 static const char* vm_symbol_bodies = VM_SYMBOLS_DO(VM_SYMBOL_BODY, VM_ALIAS_IGNORE);
  78 
  79 void vmSymbols::initialize(TRAPS) {
  80   assert((int)SID_LIMIT &lt;= (1&lt;&lt;log2_SID_LIMIT), &quot;must fit in this bitfield&quot;);
  81   assert((int)SID_LIMIT*5 &gt; (1&lt;&lt;log2_SID_LIMIT), &quot;make the bitfield smaller, please&quot;);
  82   assert(vmIntrinsics::FLAG_LIMIT &lt;= (1 &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT), &quot;must fit in this bitfield&quot;);
  83 
  84   if (!UseSharedSpaces) {
  85     const char* string = &amp;vm_symbol_bodies[0];
  86     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
<span class="line-modified">  87       Symbol* sym = SymbolTable::new_permanent_symbol(string);</span>
  88       _symbols[index] = sym;
  89       string += strlen(string); // skip string body
  90       string += 1;              // skip trailing null
  91     }
  92 
  93     _type_signatures[T_BYTE]    = byte_signature();
  94     _type_signatures[T_CHAR]    = char_signature();
  95     _type_signatures[T_DOUBLE]  = double_signature();
  96     _type_signatures[T_FLOAT]   = float_signature();
  97     _type_signatures[T_INT]     = int_signature();
  98     _type_signatures[T_LONG]    = long_signature();
  99     _type_signatures[T_SHORT]   = short_signature();
 100     _type_signatures[T_BOOLEAN] = bool_signature();
 101     _type_signatures[T_VOID]    = void_signature();

 102 #ifdef ASSERT
 103     for (int i = (int)T_BOOLEAN; i &lt; (int)T_VOID+1; i++) {
 104       Symbol* s = _type_signatures[i];
 105       if (s == NULL)  continue;
<span class="line-modified"> 106       SignatureStream ss(s, false);</span>
<span class="line-modified"> 107       assert(ss.type() == i, &quot;matching signature&quot;);</span>
<span class="line-added"> 108       assert(!ss.is_reference(), &quot;no single-char signature for T_OBJECT, etc.&quot;);</span>
 109     }
 110 #endif
 111   }
 112 
 113 #ifdef ASSERT
 114   // Check for duplicates:
 115   for (int i1 = (int)FIRST_SID; i1 &lt; (int)SID_LIMIT; i1++) {
 116     Symbol* sym = symbol_at((SID)i1);
 117     for (int i2 = (int)FIRST_SID; i2 &lt; i1; i2++) {
 118       if (symbol_at((SID)i2) == sym) {
 119         tty-&gt;print(&quot;*** Duplicate VM symbol SIDs %s(%d) and %s(%d): \&quot;&quot;,
 120                    vm_symbol_enum_name((SID)i2), i2,
 121                    vm_symbol_enum_name((SID)i1), i1);
 122         sym-&gt;print_symbol_on(tty);
 123         tty-&gt;print_cr(&quot;\&quot;&quot;);
 124       }
 125     }
 126   }
 127 #endif //ASSERT
 128 
 129   // Create an index for find_id:
 130   {
 131     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 132       vm_symbol_index[index] = (SID)index;
 133     }
 134     int num_sids = SID_LIMIT-FIRST_SID;
 135     qsort(&amp;vm_symbol_index[FIRST_SID], num_sids, sizeof(vm_symbol_index[0]),
 136           compare_vmsymbol_sid);
 137   }
 138 
 139 #ifdef ASSERT
 140   {
 141     // Spot-check correspondence between strings, symbols, and enums:
 142     assert(_symbols[NO_SID] == NULL, &quot;must be&quot;);
 143     const char* str = &quot;java/lang/Object&quot;;
<span class="line-modified"> 144     TempNewSymbol jlo = SymbolTable::new_permanent_symbol(str);</span>
 145     assert(strncmp(str, (char*)jlo-&gt;base(), jlo-&gt;utf8_length()) == 0, &quot;&quot;);
 146     assert(jlo == java_lang_Object(), &quot;&quot;);
 147     SID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);
 148     assert(find_sid(jlo) == sid, &quot;&quot;);
 149     assert(symbol_at(sid) == jlo, &quot;&quot;);
 150 
 151     // Make sure find_sid produces the right answer in each case.
 152     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 153       Symbol* sym = symbol_at((SID)index);
 154       sid = find_sid(sym);
 155       assert(sid == (SID)index, &quot;symbol index works&quot;);
 156       // Note:  If there are duplicates, this assert will fail.
 157       // A &quot;Duplicate VM symbol&quot; message will have already been printed.
 158     }
 159 
 160     // The string &quot;format&quot; happens (at the moment) not to be a vmSymbol,
 161     // though it is a method name in java.lang.String.
 162     str = &quot;format&quot;;
<span class="line-modified"> 163     TempNewSymbol fmt = SymbolTable::new_permanent_symbol(str);</span>
 164     sid = find_sid(fmt);
 165     assert(sid == NO_SID, &quot;symbol index works (negative test)&quot;);
 166   }
 167 #endif
 168 }
 169 
 170 
 171 #ifndef PRODUCT
 172 const char* vmSymbols::name_for(vmSymbols::SID sid) {
 173   if (sid == NO_SID)
 174     return &quot;NO_SID&quot;;
 175   const char* string = &amp;vm_symbol_bodies[0];
 176   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 177     if (index == (int)sid)
 178       return string;
 179     string += strlen(string); // skip string body
 180     string += 1;              // skip trailing null
 181   }
 182   return &quot;BAD_SID&quot;;
 183 }
</pre>
<hr />
<pre>
 192   for (int i = 0; i &lt; T_VOID+1; i++) {
 193     f-&gt;do_symbol(&amp;_type_signatures[i]);
 194   }
 195 }
 196 
 197 void vmSymbols::metaspace_pointers_do(MetaspaceClosure *it) {
 198   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 199     it-&gt;push(&amp;_symbols[index]);
 200   }
 201   for (int i = 0; i &lt; T_VOID+1; i++) {
 202     it-&gt;push(&amp;_type_signatures[i]);
 203   }
 204 }
 205 
 206 void vmSymbols::serialize(SerializeClosure* soc) {
 207   soc-&gt;do_region((u_char*)&amp;_symbols[FIRST_SID],
 208                  (SID_LIMIT - FIRST_SID) * sizeof(_symbols[0]));
 209   soc-&gt;do_region((u_char*)_type_signatures, sizeof(_type_signatures));
 210 }
 211 














 212 static int mid_hint = (int)vmSymbols::FIRST_SID+1;
 213 
 214 #ifndef PRODUCT
 215 static int find_sid_calls, find_sid_probes;
 216 // (Typical counts are calls=7000 and probes=17000.)
 217 #endif
 218 
 219 vmSymbols::SID vmSymbols::find_sid(const Symbol* symbol) {
 220   // Handle the majority of misses by a bounds check.
 221   // Then, use a binary search over the index.
 222   // Expected trip count is less than log2_SID_LIMIT, about eight.
 223   // This is slow but acceptable, given that calls are not
 224   // dynamically common.  (Method*::intrinsic_id has a cache.)
 225   NOT_PRODUCT(find_sid_calls++);
 226   int min = (int)FIRST_SID, max = (int)SID_LIMIT - 1;
 227   SID sid = NO_SID, sid1;
 228   int cmp1;
 229   sid1 = vm_symbol_index[min];
 230   cmp1 = compare_symbol(symbol, symbol_at(sid1));
 231   if (cmp1 &lt;= 0) {              // before the first
</pre>
<hr />
<pre>
 333 
 334   return vmIntrinsics::_none;
 335 }
 336 
 337 bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {
 338   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 339   switch(id) {
 340 #ifdef JFR_HAVE_INTRINSICS
 341   case vmIntrinsics::_counterTime:
 342 #endif
 343   case vmIntrinsics::_currentTimeMillis:
 344   case vmIntrinsics::_nanoTime:
 345   case vmIntrinsics::_floatToRawIntBits:
 346   case vmIntrinsics::_intBitsToFloat:
 347   case vmIntrinsics::_doubleToRawLongBits:
 348   case vmIntrinsics::_longBitsToDouble:
 349   case vmIntrinsics::_getClass:
 350   case vmIntrinsics::_isInstance:
 351   case vmIntrinsics::_currentThread:
 352   case vmIntrinsics::_dabs:
<span class="line-added"> 353   case vmIntrinsics::_fabs:</span>
<span class="line-added"> 354   case vmIntrinsics::_iabs:</span>
<span class="line-added"> 355   case vmIntrinsics::_labs:</span>
 356   case vmIntrinsics::_dsqrt:
 357   case vmIntrinsics::_dsin:
 358   case vmIntrinsics::_dcos:
 359   case vmIntrinsics::_dtan:
 360   case vmIntrinsics::_dlog:
 361   case vmIntrinsics::_dlog10:
 362   case vmIntrinsics::_dexp:
 363   case vmIntrinsics::_dpow:
 364   case vmIntrinsics::_checkIndex:
 365   case vmIntrinsics::_Reference_get:
 366   case vmIntrinsics::_updateCRC32:
 367   case vmIntrinsics::_updateBytesCRC32:
 368   case vmIntrinsics::_updateByteBufferCRC32:
 369   case vmIntrinsics::_vectorizedMismatch:
 370   case vmIntrinsics::_fmaD:
 371   case vmIntrinsics::_fmaF:
 372   case vmIntrinsics::_isDigit:
 373   case vmIntrinsics::_isLowerCase:
 374   case vmIntrinsics::_isUpperCase:
 375   case vmIntrinsics::_isWhitespace:
</pre>
<hr />
<pre>
 377   default:
 378     return false;
 379   }
 380 }
 381 
 382 bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {
 383   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 384   switch(id) {
 385 #ifdef JFR_HAVE_INTRINSICS
 386   case vmIntrinsics::_counterTime:
 387   case vmIntrinsics::_getClassId:
 388 #endif
 389   case vmIntrinsics::_currentTimeMillis:
 390   case vmIntrinsics::_nanoTime:
 391   case vmIntrinsics::_floatToRawIntBits:
 392   case vmIntrinsics::_intBitsToFloat:
 393   case vmIntrinsics::_doubleToRawLongBits:
 394   case vmIntrinsics::_longBitsToDouble:
 395   case vmIntrinsics::_currentThread:
 396   case vmIntrinsics::_dabs:
<span class="line-added"> 397   case vmIntrinsics::_fabs:</span>
<span class="line-added"> 398   case vmIntrinsics::_iabs:</span>
<span class="line-added"> 399   case vmIntrinsics::_labs:</span>
 400   case vmIntrinsics::_dsqrt:
 401   case vmIntrinsics::_dsin:
 402   case vmIntrinsics::_dcos:
 403   case vmIntrinsics::_dtan:
 404   case vmIntrinsics::_dlog:
 405   case vmIntrinsics::_dlog10:
 406   case vmIntrinsics::_dexp:
 407   case vmIntrinsics::_dpow:
 408   case vmIntrinsics::_updateCRC32:
 409   case vmIntrinsics::_updateBytesCRC32:
 410   case vmIntrinsics::_updateByteBufferCRC32:
 411   case vmIntrinsics::_vectorizedMismatch:
 412   case vmIntrinsics::_fmaD:
 413   case vmIntrinsics::_fmaF:
 414     return false;
 415   default:
 416     return true;
 417   }
 418 }
 419 
</pre>
<hr />
<pre>
 432   }
 433 }
 434 
 435 bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {
 436   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 437   switch(id) {
 438   case vmIntrinsics::_hashCode:
 439   case vmIntrinsics::_clone:
 440     return true;
 441     break;
 442   default:
 443     return false;
 444   }
 445 }
 446 
 447 int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {
 448   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 449   switch (id) {
 450   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 451   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
<span class="line-added"> 452   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="line-added"> 453   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
 454   case vmIntrinsics::_counterMode_AESCrypt:
 455     return 1;
 456   case vmIntrinsics::_digestBase_implCompressMB:
 457     return 3;
 458   default:
 459     return 0;
 460   }
 461 }
 462 
 463 bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {
 464   return !vmIntrinsics::is_intrinsic_disabled(id) &amp;&amp;
 465     !vmIntrinsics::is_disabled_by_flags(id);
 466 }
 467 
 468 bool vmIntrinsics::is_intrinsic_disabled(vmIntrinsics::ID id) {
 469   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 470 
 471   // Canonicalize DisableIntrinsic to contain only &#39;,&#39; as a separator.
 472   // Note, DirectiveSet may not be created at this point yet since this code
 473   // is called from initial stub geenration code.
</pre>
<hr />
<pre>
 537     default:
 538       return true;
 539     }
 540   }
 541 
 542   switch (id) {
 543   case vmIntrinsics::_isInstance:
 544   case vmIntrinsics::_isAssignableFrom:
 545   case vmIntrinsics::_getModifiers:
 546   case vmIntrinsics::_isInterface:
 547   case vmIntrinsics::_isArray:
 548   case vmIntrinsics::_isPrimitive:
 549   case vmIntrinsics::_getSuperclass:
 550   case vmIntrinsics::_Class_cast:
 551   case vmIntrinsics::_getLength:
 552   case vmIntrinsics::_newArray:
 553   case vmIntrinsics::_getClass:
 554     if (!InlineClassNatives) return true;
 555     break;
 556   case vmIntrinsics::_currentThread:

 557     if (!InlineThreadNatives) return true;
 558     break;
 559   case vmIntrinsics::_floatToRawIntBits:
 560   case vmIntrinsics::_intBitsToFloat:
 561   case vmIntrinsics::_doubleToRawLongBits:
 562   case vmIntrinsics::_longBitsToDouble:
<span class="line-added"> 563   case vmIntrinsics::_ceil:</span>
<span class="line-added"> 564   case vmIntrinsics::_floor:</span>
<span class="line-added"> 565   case vmIntrinsics::_rint:</span>
 566   case vmIntrinsics::_dabs:
<span class="line-added"> 567   case vmIntrinsics::_fabs:</span>
<span class="line-added"> 568   case vmIntrinsics::_iabs:</span>
<span class="line-added"> 569   case vmIntrinsics::_labs:</span>
 570   case vmIntrinsics::_dsqrt:
 571   case vmIntrinsics::_dsin:
 572   case vmIntrinsics::_dcos:
 573   case vmIntrinsics::_dtan:
 574   case vmIntrinsics::_dlog:
 575   case vmIntrinsics::_dexp:
 576   case vmIntrinsics::_dpow:
 577   case vmIntrinsics::_dlog10:
 578   case vmIntrinsics::_datan2:
 579   case vmIntrinsics::_min:
 580   case vmIntrinsics::_max:
 581   case vmIntrinsics::_floatToIntBits:
 582   case vmIntrinsics::_doubleToLongBits:
 583   case vmIntrinsics::_maxF:
 584   case vmIntrinsics::_minF:
 585   case vmIntrinsics::_maxD:
 586   case vmIntrinsics::_minD:
 587     if (!InlineMathNatives) return true;
 588     break;
 589   case vmIntrinsics::_fmaD:
</pre>
<hr />
<pre>
 709   case vmIntrinsics::_getIntUnaligned:
 710   case vmIntrinsics::_getLongUnaligned:
 711   case vmIntrinsics::_putShortUnaligned:
 712   case vmIntrinsics::_putCharUnaligned:
 713   case vmIntrinsics::_putIntUnaligned:
 714   case vmIntrinsics::_putLongUnaligned:
 715   case vmIntrinsics::_allocateInstance:
 716     if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;
 717     break;
 718   case vmIntrinsics::_hashCode:
 719     if (!InlineObjectHash) return true;
 720     break;
 721   case vmIntrinsics::_aescrypt_encryptBlock:
 722   case vmIntrinsics::_aescrypt_decryptBlock:
 723     if (!UseAESIntrinsics) return true;
 724     break;
 725   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 726   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 727     if (!UseAESIntrinsics) return true;
 728     break;
<span class="line-added"> 729   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="line-added"> 730   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="line-added"> 731     if (!UseAESIntrinsics) return true;</span>
<span class="line-added"> 732     break;</span>
 733   case vmIntrinsics::_counterMode_AESCrypt:
 734     if (!UseAESCTRIntrinsics) return true;
 735     break;
 736   case vmIntrinsics::_sha_implCompress:
 737     if (!UseSHA1Intrinsics) return true;
 738     break;
 739   case vmIntrinsics::_sha2_implCompress:
 740     if (!UseSHA256Intrinsics) return true;
 741     break;
 742   case vmIntrinsics::_sha5_implCompress:
 743     if (!UseSHA512Intrinsics) return true;
 744     break;
 745   case vmIntrinsics::_digestBase_implCompressMB:
 746     if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;
 747     break;
 748   case vmIntrinsics::_ghash_processBlocks:
 749     if (!UseGHASHIntrinsics) return true;
 750     break;
 751   case vmIntrinsics::_base64_encodeBlock:
 752     if (!UseBASE64Intrinsics) return true;
</pre>
<hr />
<pre>
 755   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 756     if (!UseCRC32CIntrinsics) return true;
 757     break;
 758   case vmIntrinsics::_vectorizedMismatch:
 759     if (!UseVectorizedMismatchIntrinsic) return true;
 760     break;
 761   case vmIntrinsics::_updateBytesAdler32:
 762   case vmIntrinsics::_updateByteBufferAdler32:
 763     if (!UseAdler32Intrinsics) return true;
 764     break;
 765   case vmIntrinsics::_copyMemory:
 766     if (!InlineArrayCopy || !InlineUnsafeOps) return true;
 767     break;
 768 #ifdef COMPILER1
 769   case vmIntrinsics::_checkIndex:
 770     if (!InlineNIOCheckIndex) return true;
 771     break;
 772 #endif // COMPILER1
 773 #ifdef COMPILER2
 774   case vmIntrinsics::_clone:



 775   case vmIntrinsics::_copyOf:
 776   case vmIntrinsics::_copyOfRange:
 777     // These intrinsics use both the objectcopy and the arraycopy
 778     // intrinsic mechanism.
 779     if (!InlineObjectCopy || !InlineArrayCopy) return true;
 780     break;
 781   case vmIntrinsics::_compareToL:
 782   case vmIntrinsics::_compareToU:
 783   case vmIntrinsics::_compareToLU:
 784   case vmIntrinsics::_compareToUL:
 785     if (!SpecialStringCompareTo) return true;
 786     break;
 787   case vmIntrinsics::_indexOfL:
 788   case vmIntrinsics::_indexOfU:
 789   case vmIntrinsics::_indexOfUL:
 790   case vmIntrinsics::_indexOfIL:
 791   case vmIntrinsics::_indexOfIU:
 792   case vmIntrinsics::_indexOfIUL:
 793   case vmIntrinsics::_indexOfU_char:
 794     if (!SpecialStringIndexOf) return true;
</pre>
<hr />
<pre>
 806     if (!SpecialEncodeISOArray) return true;
 807     break;
 808   case vmIntrinsics::_getCallerClass:
 809     if (!InlineReflectionGetCallerClass) return true;
 810     break;
 811   case vmIntrinsics::_multiplyToLen:
 812     if (!UseMultiplyToLenIntrinsic) return true;
 813     break;
 814   case vmIntrinsics::_squareToLen:
 815     if (!UseSquareToLenIntrinsic) return true;
 816     break;
 817   case vmIntrinsics::_mulAdd:
 818     if (!UseMulAddIntrinsic) return true;
 819     break;
 820   case vmIntrinsics::_montgomeryMultiply:
 821     if (!UseMontgomeryMultiplyIntrinsic) return true;
 822     break;
 823   case vmIntrinsics::_montgomerySquare:
 824     if (!UseMontgomerySquareIntrinsic) return true;
 825     break;
<span class="line-added"> 826   case vmIntrinsics::_bigIntegerRightShiftWorker:</span>
<span class="line-added"> 827   case vmIntrinsics::_bigIntegerLeftShiftWorker:</span>
<span class="line-added"> 828     break;</span>
 829   case vmIntrinsics::_addExactI:
 830   case vmIntrinsics::_addExactL:
 831   case vmIntrinsics::_decrementExactI:
 832   case vmIntrinsics::_decrementExactL:
 833   case vmIntrinsics::_incrementExactI:
 834   case vmIntrinsics::_incrementExactL:
 835   case vmIntrinsics::_multiplyExactI:
 836   case vmIntrinsics::_multiplyExactL:
 837   case vmIntrinsics::_negateExactI:
 838   case vmIntrinsics::_negateExactL:
 839   case vmIntrinsics::_subtractExactI:
 840   case vmIntrinsics::_subtractExactL:
 841     if (!UseMathExactIntrinsics || !InlineMathNatives) return true;
 842     break;
 843   case vmIntrinsics::_isDigit:
 844   case vmIntrinsics::_isLowerCase:
 845   case vmIntrinsics::_isUpperCase:
 846   case vmIntrinsics::_isWhitespace:
 847     if (!UseCharacterCompareIntrinsics) return true;
 848     break;
</pre>
<hr />
<pre>
 938 
 939 #undef VM_INTRINSIC_CASE
 940 }
 941 
 942 
 943 const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {
 944   const char* str = name_at(id);
 945 #ifndef PRODUCT
 946   const char* kname = vmSymbols::name_for(class_for(id));
 947   const char* mname = vmSymbols::name_for(name_for(id));
 948   const char* sname = vmSymbols::name_for(signature_for(id));
 949   const char* fname = &quot;&quot;;
 950   switch (flags_for(id)) {
 951   case F_Y:  fname = &quot;synchronized &quot;;  break;
 952   case F_RN: fname = &quot;native &quot;;        break;
 953   case F_SN: fname = &quot;native static &quot;; break;
 954   case F_S:  fname = &quot;static &quot;;        break;
 955   case F_RNY:fname = &quot;native synchronized &quot;; break;
 956   default:   break;
 957   }
<span class="line-modified"> 958   const char* kptr = strrchr(kname, JVM_SIGNATURE_SLASH);</span>
 959   if (kptr != NULL)  kname = kptr + 1;
 960   int len = jio_snprintf(buf, buflen, &quot;%s: %s%s.%s%s&quot;,
 961                          str, fname, kname, mname, sname);
 962   if (len &lt; buflen)
 963     str = buf;
 964 #endif //PRODUCT
 965   return str;
 966 }
 967 
 968 
 969 // These are to get information about intrinsics.
 970 
 971 #define ID4(x, y, z, f) ((ID3(x, y, z) &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))
 972 
 973 static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {
 974 #define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \
 975   ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),
 976 
 977   0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,
 978                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
</pre>
<hr />
<pre>
1041   ID declared_id = match_method_with_klass(m, mk);
1042 
1043   if (declared_id == actual_id)  return; // success
1044 
1045   if (declared_id == _none &amp;&amp; actual_id != _none &amp;&amp; mk == vmSymbols::java_lang_StrictMath()) {
1046     // Here are a few special cases in StrictMath not declared in vmSymbols.hpp.
1047     switch (actual_id) {
1048     case _min:
1049     case _max:
1050     case _dsqrt:
1051       declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());
1052       if (declared_id == actual_id)  return; // acceptable alias
1053       break;
1054     default:
1055         break;
1056     }
1057   }
1058 
1059   const char* declared_name = name_at(declared_id);
1060   const char* actual_name   = name_at(actual_id);

1061   m = NULL;
1062   ttyLocker ttyl;
1063   if (xtty != NULL) {
1064     xtty-&gt;begin_elem(&quot;intrinsic_misdeclared actual=&#39;%s&#39; declared=&#39;%s&#39;&quot;,
1065                      actual_name, declared_name);
<span class="line-modified">1066     xtty-&gt;method(m);</span>
1067     xtty-&gt;end_elem(&quot;%s&quot;, &quot;&quot;);
1068   }
1069   if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
1070     tty-&gt;print_cr(&quot;*** misidentified method; %s(%d) should be %s(%d):&quot;,
1071                   declared_name, declared_id, actual_name, actual_id);
<span class="line-modified">1072     m-&gt;print_short_name(tty);</span>
1073     tty-&gt;cr();
1074   }
1075 }
1076 #endif //PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="verifier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
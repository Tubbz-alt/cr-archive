<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,33 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/stackMapTable.hpp&quot;
  #include &quot;classfile/stackMapFrame.hpp&quot;
  #include &quot;classfile/stackMapTableFormat.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.hpp&quot;
  #include &quot;runtime/fieldDescriptor.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;services/threadService.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
<span class="line-new-header">--- 23,35 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
<span class="line-added">+ #include &quot;classfile/classLoader.hpp&quot;</span>
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/stackMapTable.hpp&quot;
  #include &quot;classfile/stackMapFrame.hpp&quot;
  #include &quot;classfile/stackMapTableFormat.hpp&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;interpreter/bytecodes.hpp&quot;
  #include &quot;interpreter/bytecodeStream.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/typeArrayOop.hpp&quot;
  #include &quot;runtime/fieldDescriptor.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;services/threadService.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,33 ***</span>
  #define NOFAILOVER_MAJOR_VERSION                       51
  #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
  #define MAX_ARRAY_DIMENSIONS 255
  
<span class="line-modified">! // Access to external entry for VerifyClassCodes - old byte code verifier</span>
  
  extern &quot;C&quot; {
<span class="line-modified">!   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint);</span>
<span class="line-removed">-   typedef jboolean (*verify_byte_codes_fn_new_t)(JNIEnv *, jclass, char *, jint, jint);</span>
  }
  
<span class="line-modified">! static void* volatile _verify_byte_codes_fn = NULL;</span>
  
<span class="line-modified">! static volatile jint _is_new_verify_byte_codes_fn = (jint) true;</span>
  
<span class="line-modified">! static void* verify_byte_codes_fn() {</span>
<span class="line-modified">!   if (OrderAccess::load_acquire(&amp;_verify_byte_codes_fn) == NULL) {</span>
<span class="line-modified">!     void *lib_handle = os::native_java_library();</span>
<span class="line-modified">!     void *func = os::dll_lookup(lib_handle, &quot;VerifyClassCodesForMajorVersion&quot;);</span>
<span class="line-modified">!     OrderAccess::release_store(&amp;_verify_byte_codes_fn, func);</span>
<span class="line-modified">!     if (func == NULL) {</span>
<span class="line-modified">!       _is_new_verify_byte_codes_fn = false;</span>
<span class="line-modified">!       func = os::dll_lookup(lib_handle, &quot;VerifyClassCodes&quot;);</span>
<span class="line-modified">!       OrderAccess::release_store(&amp;_verify_byte_codes_fn, func);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return (void*)_verify_byte_codes_fn;</span>
  }
  
  
  // Methods in Verifier
  
<span class="line-new-header">--- 60,43 ---</span>
  #define NOFAILOVER_MAJOR_VERSION                       51
  #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
  #define MAX_ARRAY_DIMENSIONS 255
  
<span class="line-modified">! // Access to external entry for VerifyClassForMajorVersion - old byte code verifier</span>
  
  extern &quot;C&quot; {
<span class="line-modified">!   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);</span>
  }
  
<span class="line-modified">! static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;</span>
  
<span class="line-modified">! static verify_byte_codes_fn_t verify_byte_codes_fn() {</span>
  
<span class="line-modified">!   if (_verify_byte_codes_fn != NULL)</span>
<span class="line-modified">!     return _verify_byte_codes_fn;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   MutexLocker locker(Verify_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (_verify_byte_codes_fn != NULL)</span>
<span class="line-modified">!     return _verify_byte_codes_fn;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Load verify dll</span>
<span class="line-modified">!   char buffer[JVM_MAXPATHLEN];</span>
<span class="line-modified">!   char ebuf[1024];</span>
<span class="line-modified">!   if (!os::dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(), &quot;verify&quot;))</span>
<span class="line-added">+     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">+ </span>
<span class="line-added">+   void *lib_handle = os::dll_load(buffer, ebuf, sizeof(ebuf));</span>
<span class="line-added">+   if (lib_handle == NULL)</span>
<span class="line-added">+     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">+ </span>
<span class="line-added">+   void *fn = os::dll_lookup(lib_handle, &quot;VerifyClassForMajorVersion&quot;);</span>
<span class="line-added">+   if (fn == NULL)</span>
<span class="line-added">+     return NULL; // Caller will throw VerifyError</span>
<span class="line-added">+ </span>
<span class="line-added">+   return _verify_byte_codes_fn = CAST_TO_FN_PTR(verify_byte_codes_fn_t, fn);</span>
  }
  
  
  // Methods in Verifier
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,26 ***</span>
                             jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
                             jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
                             PerfClassTraceTime::CLASS_VERIFY);
  
    // If the class should be verified, first see if we can use the split
<span class="line-modified">!   // verifier.  If not, or if verification fails and FailOverToOldVerifier</span>
<span class="line-modified">!   // is set, then call the inference verifier.</span>
    Symbol* exception_name = NULL;
    const size_t message_buffer_len = klass-&gt;name()-&gt;utf8_length() + 1024;
    char* message_buffer = NULL;
    char* exception_message = NULL;
  
<span class="line-removed">-   bool can_failover = FailOverToOldVerifier &amp;&amp;</span>
<span class="line-removed">-      klass-&gt;major_version() &lt; NOFAILOVER_MAJOR_VERSION;</span>
<span class="line-removed">- </span>
    log_info(class, init)(&quot;Start class verification for: %s&quot;, klass-&gt;external_name());
    if (klass-&gt;major_version() &gt;= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
      ClassVerifier split_verifier(klass, THREAD);
      split_verifier.verify_class(THREAD);
      exception_name = split_verifier.result();
<span class="line-modified">!     if (can_failover &amp;&amp; !HAS_PENDING_EXCEPTION &amp;&amp;</span>
          (exception_name == vmSymbols::java_lang_VerifyError() ||
           exception_name == vmSymbols::java_lang_ClassFormatError())) {
        log_info(verification)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
        log_info(class, init)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
        message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
<span class="line-new-header">--- 172,32 ---</span>
                             jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
                             jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
                             PerfClassTraceTime::CLASS_VERIFY);
  
    // If the class should be verified, first see if we can use the split
<span class="line-modified">!   // verifier.  If not, or if verification fails and can failover, then</span>
<span class="line-modified">!   // call the inference verifier.</span>
    Symbol* exception_name = NULL;
    const size_t message_buffer_len = klass-&gt;name()-&gt;utf8_length() + 1024;
    char* message_buffer = NULL;
    char* exception_message = NULL;
  
    log_info(class, init)(&quot;Start class verification for: %s&quot;, klass-&gt;external_name());
    if (klass-&gt;major_version() &gt;= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
      ClassVerifier split_verifier(klass, THREAD);
      split_verifier.verify_class(THREAD);
      exception_name = split_verifier.result();
<span class="line-modified">! </span>
<span class="line-added">+     // If DumpSharedSpaces is set then don&#39;t fall back to the old verifier on</span>
<span class="line-added">+     // verification failure. If a class fails verification with the split verifier,</span>
<span class="line-added">+     // it might fail the CDS runtime verifier constraint check. In that case, we</span>
<span class="line-added">+     // don&#39;t want to share the class. We only archive classes that pass the split</span>
<span class="line-added">+     // verifier.</span>
<span class="line-added">+     bool can_failover = !DumpSharedSpaces &amp;&amp;</span>
<span class="line-added">+       klass-&gt;major_version() &lt; NOFAILOVER_MAJOR_VERSION;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (can_failover &amp;&amp; !HAS_PENDING_EXCEPTION &amp;&amp;  // Split verifier doesn&#39;t set PENDING_EXCEPTION for failure</span>
          (exception_name == vmSymbols::java_lang_VerifyError() ||
           exception_name == vmSymbols::java_lang_ClassFormatError())) {
        log_info(verification)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
        log_info(class, init)(&quot;Fail over class verification to old verifier for: %s&quot;, klass-&gt;external_name());
        message_buffer = NEW_RESOURCE_ARRAY(char, message_buffer_len);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,11 ***</span>
  Symbol* Verifier::inference_verify(
      InstanceKlass* klass, char* message, size_t message_len, TRAPS) {
    JavaThread* thread = (JavaThread*)THREAD;
    JNIEnv *env = thread-&gt;jni_environment();
  
<span class="line-modified">!   void* verify_func = verify_byte_codes_fn();</span>
  
    if (verify_func == NULL) {
      jio_snprintf(message, message_len, &quot;Could not link verifier&quot;);
      return vmSymbols::java_lang_VerifyError();
    }
<span class="line-new-header">--- 289,11 ---</span>
  Symbol* Verifier::inference_verify(
      InstanceKlass* klass, char* message, size_t message_len, TRAPS) {
    JavaThread* thread = (JavaThread*)THREAD;
    JNIEnv *env = thread-&gt;jni_environment();
  
<span class="line-modified">!   verify_byte_codes_fn_t verify_func = verify_byte_codes_fn();</span>
  
    if (verify_func == NULL) {
      jio_snprintf(message, message_len, &quot;Could not link verifier&quot;);
      return vmSymbols::java_lang_VerifyError();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,20 ***</span>
      HandleMark hm(thread);
      ThreadToNativeFromVM ttn(thread);
      // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
      // code knows that we have left the VM
  
<span class="line-modified">!     if (_is_new_verify_byte_codes_fn) {</span>
<span class="line-removed">-       verify_byte_codes_fn_new_t func =</span>
<span class="line-removed">-         CAST_TO_FN_PTR(verify_byte_codes_fn_new_t, verify_func);</span>
<span class="line-removed">-       result = (*func)(env, cls, message, (int)message_len,</span>
<span class="line-removed">-           klass-&gt;major_version());</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       verify_byte_codes_fn_t func =</span>
<span class="line-removed">-         CAST_TO_FN_PTR(verify_byte_codes_fn_t, verify_func);</span>
<span class="line-removed">-       result = (*func)(env, cls, message, (int)message_len);</span>
<span class="line-removed">-     }</span>
    }
  
    JNIHandles::destroy_local(cls);
  
    // These numbers are chosen so that VerifyClassCodes interface doesn&#39;t need
<span class="line-new-header">--- 308,11 ---</span>
      HandleMark hm(thread);
      ThreadToNativeFromVM ttn(thread);
      // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
      // code knows that we have left the VM
  
<span class="line-modified">!     result = (*verify_func)(env, cls, message, (int)message_len, klass-&gt;major_version());</span>
    }
  
    JNIHandles::destroy_local(cls);
  
    // These numbers are chosen so that VerifyClassCodes interface doesn&#39;t need
</pre>
<hr />
<pre>
<span class="line-old-header">*** 572,11 ***</span>
  // Methods in ClassVerifier
  
  ClassVerifier::ClassVerifier(
      InstanceKlass* klass, TRAPS)
      : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
<span class="line-modified">!       _message(NULL), _klass(klass) {</span>
    _this_type = VerificationType::reference_type(klass-&gt;name());
  }
  
  ClassVerifier::~ClassVerifier() {
    // Decrement the reference count for any symbols created.
<span class="line-new-header">--- 581,11 ---</span>
  // Methods in ClassVerifier
  
  ClassVerifier::ClassVerifier(
      InstanceKlass* klass, TRAPS)
      : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
<span class="line-modified">!       _message(NULL), _method_signatures_table(NULL), _klass(klass) {</span>
    _this_type = VerificationType::reference_type(klass-&gt;name());
  }
  
  ClassVerifier::~ClassVerifier() {
    // Decrement the reference count for any symbols created.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,19 ***</span>
  
  VerificationType ClassVerifier::object_type() const {
    return VerificationType::reference_type(vmSymbols::java_lang_Object());
  }
  
<span class="line-modified">! TypeOrigin ClassVerifier::ref_ctx(const char* sig, TRAPS) {</span>
    VerificationType vt = VerificationType::reference_type(
<span class="line-modified">!       create_temporary_symbol(sig, (int)strlen(sig), THREAD));</span>
    return TypeOrigin::implicit(vt);
  }
  
  void ClassVerifier::verify_class(TRAPS) {
    log_info(verification)(&quot;Verifying class %s with new format&quot;, _klass-&gt;external_name());
  
    Array&lt;Method*&gt;* methods = _klass-&gt;methods();
    int num_methods = methods-&gt;length();
  
    for (int index = 0; index &lt; num_methods; index++) {
      // Check for recursive re-verification before each method.
<span class="line-new-header">--- 599,26 ---</span>
  
  VerificationType ClassVerifier::object_type() const {
    return VerificationType::reference_type(vmSymbols::java_lang_Object());
  }
  
<span class="line-modified">! TypeOrigin ClassVerifier::ref_ctx(const char* sig) {</span>
    VerificationType vt = VerificationType::reference_type(
<span class="line-modified">!                          create_temporary_symbol(sig, (int)strlen(sig)));</span>
    return TypeOrigin::implicit(vt);
  }
  
  void ClassVerifier::verify_class(TRAPS) {
    log_info(verification)(&quot;Verifying class %s with new format&quot;, _klass-&gt;external_name());
  
<span class="line-added">+   // Either verifying both local and remote classes or just remote classes.</span>
<span class="line-added">+   assert(BytecodeVerificationRemote, &quot;Should not be here&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Create hash table containing method signatures.</span>
<span class="line-added">+   method_signatures_table_type method_signatures_table;</span>
<span class="line-added">+   set_method_signatures_table(&amp;method_signatures_table);</span>
<span class="line-added">+ </span>
    Array&lt;Method*&gt;* methods = _klass-&gt;methods();
    int num_methods = methods-&gt;length();
  
    for (int index = 0; index &lt; num_methods; index++) {
      // Check for recursive re-verification before each method.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,10 ***</span>
<span class="line-new-header">--- 639,59 ---</span>
      log_info(class, init)(&quot;Recursive verification detected for: %s&quot;,
                          _klass-&gt;external_name());
    }
  }
  
<span class="line-added">+ // Translate the signature entries into verification types and save them in</span>
<span class="line-added">+ // the growable array.  Also, save the count of arguments.</span>
<span class="line-added">+ void ClassVerifier::translate_signature(Symbol* const method_sig,</span>
<span class="line-added">+                                         sig_as_verification_types* sig_verif_types,</span>
<span class="line-added">+                                         TRAPS) {</span>
<span class="line-added">+   SignatureStream sig_stream(method_sig);</span>
<span class="line-added">+   VerificationType sig_type[2];</span>
<span class="line-added">+   int sig_i = 0;</span>
<span class="line-added">+   GrowableArray&lt;VerificationType&gt;* verif_types = sig_verif_types-&gt;sig_verif_types();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Translate the signature arguments into verification types.</span>
<span class="line-added">+   while (!sig_stream.at_return_type()) {</span>
<span class="line-added">+     int n = change_sig_to_verificationType(&amp;sig_stream, sig_type);</span>
<span class="line-added">+     assert(n &lt;= 2, &quot;Unexpected signature type&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Store verification type(s).  Longs and Doubles each have two verificationTypes.</span>
<span class="line-added">+     for (int x = 0; x &lt; n; x++) {</span>
<span class="line-added">+       verif_types-&gt;push(sig_type[x]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     sig_i += n;</span>
<span class="line-added">+     sig_stream.next();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Set final arg count, not including the return type.  The final arg count will</span>
<span class="line-added">+   // be compared with sig_verify_types&#39; length to see if there is a return type.</span>
<span class="line-added">+   sig_verif_types-&gt;set_num_args(sig_i);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Store verification type(s) for the return type, if there is one.</span>
<span class="line-added">+   if (sig_stream.type() != T_VOID) {</span>
<span class="line-added">+     int n = change_sig_to_verificationType(&amp;sig_stream, sig_type);</span>
<span class="line-added">+     assert(n &lt;= 2, &quot;Unexpected signature return type&quot;);</span>
<span class="line-added">+     for (int y = 0; y &lt; n; y++) {</span>
<span class="line-added">+       verif_types-&gt;push(sig_type[y]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ClassVerifier::create_method_sig_entry(sig_as_verification_types* sig_verif_types,</span>
<span class="line-added">+                                             int sig_index, TRAPS) {</span>
<span class="line-added">+   // Translate the signature into verification types.</span>
<span class="line-added">+   ConstantPool* cp = _klass-&gt;constants();</span>
<span class="line-added">+   Symbol* const method_sig = cp-&gt;symbol_at(sig_index);</span>
<span class="line-added">+   translate_signature(method_sig, sig_verif_types, CHECK_VERIFY(this));</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Add the list of this signature&#39;s verification types to the table.</span>
<span class="line-added">+   bool is_unique = method_signatures_table()-&gt;put(sig_index, sig_verif_types);</span>
<span class="line-added">+   assert(is_unique, &quot;Duplicate entries in method_signature_table&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ClassVerifier::verify_method(const methodHandle&amp; m, TRAPS) {
    HandleMark hm(THREAD);
    _method = m;   // initialize _method
    log_info(verification)(&quot;Verifying method %s&quot;, m-&gt;name_and_sig_as_C_string());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
    StackMapStream stream(stackmap_data);
    StackMapReader reader(this, &amp;stream, code_data, code_length, THREAD);
    StackMapTable stackmap_table(&amp;reader, &amp;current_frame, max_locals, max_stack,
                                 code_data, code_length, CHECK_VERIFY(this));
  
<span class="line-modified">!   LogTarget(Info, verification) lt;</span>
    if (lt.is_enabled()) {
      ResourceMark rm(THREAD);
      LogStream ls(lt);
      stackmap_table.print_on(&amp;ls);
    }
<span class="line-new-header">--- 737,11 ---</span>
    StackMapStream stream(stackmap_data);
    StackMapReader reader(this, &amp;stream, code_data, code_length, THREAD);
    StackMapTable stackmap_table(&amp;reader, &amp;current_frame, max_locals, max_stack,
                                 code_data, code_length, CHECK_VERIFY(this));
  
<span class="line-modified">!   LogTarget(Debug, verification) lt;</span>
    if (lt.is_enabled()) {
      ResourceMark rm(THREAD);
      LogStream ls(lt);
      stackmap_table.print_on(&amp;ls);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 716,11 ***</span>
        u2 index;
        int target;
        VerificationType type, type2;
        VerificationType atype;
  
<span class="line-modified">!       LogTarget(Info, verification) lt;</span>
        if (lt.is_enabled()) {
          ResourceMark rm(THREAD);
          LogStream ls(lt);
          current_frame.print_on(&amp;ls);
          lt.print(&quot;offset = %d,  opcode = %s&quot;, bci,
<span class="line-new-header">--- 781,11 ---</span>
        u2 index;
        int target;
        VerificationType type, type2;
        VerificationType atype;
  
<span class="line-modified">!       LogTarget(Debug, verification) lt;</span>
        if (lt.is_enabled()) {
          ResourceMark rm(THREAD);
          LogStream ls(lt);
          current_frame.print_on(&amp;ls);
          lt.print(&quot;offset = %d,  opcode = %s&quot;, bci,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_int_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;, THREAD)),</span>
                  bad_type_msg, &quot;iaload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
<span class="line-new-header">--- 929,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_int_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;)),</span>
                  bad_type_msg, &quot;iaload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 892,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_char_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;, THREAD)),</span>
                  bad_type_msg, &quot;caload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
<span class="line-new-header">--- 957,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_char_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;)),</span>
                  bad_type_msg, &quot;caload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_short_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;, THREAD)),</span>
                  bad_type_msg, &quot;saload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
<span class="line-new-header">--- 971,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_short_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;)),</span>
                  bad_type_msg, &quot;saload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 920,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_long_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;, THREAD)),</span>
                  bad_type_msg, &quot;laload&quot;);
              return;
            }
            current_frame.push_stack_2(
              VerificationType::long_type(),
<span class="line-new-header">--- 985,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_long_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;)),</span>
                  bad_type_msg, &quot;laload&quot;);
              return;
            }
            current_frame.push_stack_2(
              VerificationType::long_type(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_float_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;, THREAD)),</span>
                  bad_type_msg, &quot;faload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::float_type(), CHECK_VERIFY(this));
<span class="line-new-header">--- 1000,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_float_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;)),</span>
                  bad_type_msg, &quot;faload&quot;);
              return;
            }
            current_frame.push_stack(
              VerificationType::float_type(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 949,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_double_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;, THREAD)),</span>
                  bad_type_msg, &quot;daload&quot;);
              return;
            }
            current_frame.push_stack_2(
              VerificationType::double_type(),
<span class="line-new-header">--- 1014,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_double_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),</span>
                  bad_type_msg, &quot;daload&quot;);
              return;
            }
            current_frame.push_stack_2(
              VerificationType::double_type(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_int_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;, THREAD)),</span>
                  bad_type_msg, &quot;iastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_bastore :
<span class="line-new-header">--- 1103,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_int_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[I&quot;)),</span>
                  bad_type_msg, &quot;iastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_bastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_char_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;, THREAD)),</span>
                  bad_type_msg, &quot;castore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_sastore :
<span class="line-new-header">--- 1131,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_char_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[C&quot;)),</span>
                  bad_type_msg, &quot;castore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_sastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_short_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;, THREAD)),</span>
                  bad_type_msg, &quot;sastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_lastore :
<span class="line-new-header">--- 1145,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_short_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[S&quot;)),</span>
                  bad_type_msg, &quot;sastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_lastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1095,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_long_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;, THREAD)),</span>
                  bad_type_msg, &quot;lastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_fastore :
<span class="line-new-header">--- 1160,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_long_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[J&quot;)),</span>
                  bad_type_msg, &quot;lastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_fastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1109,11 ***</span>
              (VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_float_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;, THREAD)),</span>
                  bad_type_msg, &quot;fastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_dastore :
<span class="line-new-header">--- 1174,11 ---</span>
              (VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_float_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[F&quot;)),</span>
                  bad_type_msg, &quot;fastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_dastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1124,11 ***</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_double_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;, THREAD)),</span>
                  bad_type_msg, &quot;dastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_aastore :
<span class="line-new-header">--- 1189,11 ---</span>
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            if (!atype.is_double_array()) {
              verify_error(ErrorContext::bad_type(bci,
<span class="line-modified">!                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),</span>
                  bad_type_msg, &quot;dastore&quot;);
              return;
            }
            no_control_flow = false; break;
          case Bytecodes::_aastore :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2001,11 ***</span>
    va_list va;
    va_start(va, msg);
    ss.vprint(msg, va);
    va_end(va);
    if (!_method.is_null()) {
<span class="line-modified">!     ss.print(&quot; in method %s&quot;, _method-&gt;name_and_sig_as_C_string());</span>
    }
    _message = ss.as_string();
  }
  
  Klass* ClassVerifier::load_class(Symbol* name, TRAPS) {
<span class="line-new-header">--- 2066,13 ---</span>
    va_list va;
    va_start(va, msg);
    ss.vprint(msg, va);
    va_end(va);
    if (!_method.is_null()) {
<span class="line-modified">!     ss.print(&quot; in method &#39;&quot;);</span>
<span class="line-added">+     _method-&gt;print_external_name(&amp;ss);</span>
<span class="line-added">+     ss.print(&quot;&#39;&quot;);</span>
    }
    _message = ss.as_string();
  }
  
  Klass* ClassVerifier::load_class(Symbol* name, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2120,12 ***</span>
      assert(sizeof(VerificationType) == sizeof(uintptr_t),
            &quot;buffer type must match VerificationType size&quot;);
      uintptr_t constant_type_buffer[2];
      VerificationType* v_constant_type = (VerificationType*)constant_type_buffer;
      SignatureStream sig_stream(constant_type, false);
<span class="line-modified">!     int n = change_sig_to_verificationType(</span>
<span class="line-removed">-       &amp;sig_stream, v_constant_type, CHECK_VERIFY(this));</span>
      int opcode_n = (opcode == Bytecodes::_ldc2_w ? 2 : 1);
      if (n != opcode_n) {
        // wrong kind of ldc; reverify against updated type mask
        types &amp;= ~(1 &lt;&lt; JVM_CONSTANT_Dynamic);
        verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
<span class="line-new-header">--- 2187,11 ---</span>
      assert(sizeof(VerificationType) == sizeof(uintptr_t),
            &quot;buffer type must match VerificationType size&quot;);
      uintptr_t constant_type_buffer[2];
      VerificationType* v_constant_type = (VerificationType*)constant_type_buffer;
      SignatureStream sig_stream(constant_type, false);
<span class="line-modified">!     int n = change_sig_to_verificationType(&amp;sig_stream, v_constant_type);</span>
      int opcode_n = (opcode == Bytecodes::_ldc2_w ? 2 : 1);
      if (n != opcode_n) {
        // wrong kind of ldc; reverify against updated type mask
        types &amp;= ~(1 &lt;&lt; JVM_CONSTANT_Dynamic);
        verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2262,12 ***</span>
    // stack allocating it.  Plus it would run constructors.  This shows up
    // in performance profiles.
  
    SignatureStream sig_stream(field_sig, false);
    VerificationType stack_object_type;
<span class="line-modified">!   int n = change_sig_to_verificationType(</span>
<span class="line-removed">-     &amp;sig_stream, field_type, CHECK_VERIFY(this));</span>
    u2 bci = bcs-&gt;bci();
    bool is_assignable;
    switch (bcs-&gt;raw_code()) {
      case Bytecodes::_getstatic: {
        for (int i = 0; i &lt; n; i++) {
<span class="line-new-header">--- 2328,11 ---</span>
    // stack allocating it.  Plus it would run constructors.  This shows up
    // in performance profiles.
  
    SignatureStream sig_stream(field_sig, false);
    VerificationType stack_object_type;
<span class="line-modified">!   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);</span>
    u2 bci = bcs-&gt;bci();
    bool is_assignable;
    switch (bcs-&gt;raw_code()) {
      case Bytecodes::_getstatic: {
        for (int i = 0; i &lt; n; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2581,13 ***</span>
          if (bci &gt;= start_pc &amp;&amp; bci &lt; end_pc) {
            if (!ends_in_athrow(exhandlers.handler_pc(i))) {
              verify_error(ErrorContext::bad_code(bci),
                &quot;Bad &lt;init&gt; method call from after the start of a try block&quot;);
              return;
<span class="line-modified">!           } else if (log_is_enabled(Info, verification)) {</span>
              ResourceMark rm(THREAD);
<span class="line-modified">!             log_info(verification)(&quot;Survived call to ends_in_athrow(): %s&quot;,</span>
                                            current_class()-&gt;name()-&gt;as_C_string());
            }
          }
        }
  
<span class="line-new-header">--- 2646,13 ---</span>
          if (bci &gt;= start_pc &amp;&amp; bci &lt; end_pc) {
            if (!ends_in_athrow(exhandlers.handler_pc(i))) {
              verify_error(ErrorContext::bad_code(bci),
                &quot;Bad &lt;init&gt; method call from after the start of a try block&quot;);
              return;
<span class="line-modified">!           } else if (log_is_enabled(Debug, verification)) {</span>
              ResourceMark rm(THREAD);
<span class="line-modified">!             log_debug(verification)(&quot;Survived call to ends_in_athrow(): %s&quot;,</span>
                                            current_class()-&gt;name()-&gt;as_C_string());
            }
          }
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2732,48 ***</span>
      }
    } else {
      ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
    }
  
<span class="line-removed">-   // For a small signature length, we just allocate 128 bytes instead</span>
<span class="line-removed">-   // of parsing the signature once to find its size.</span>
<span class="line-removed">-   // -3 is for &#39;(&#39;, &#39;)&#39; and return descriptor; multiply by 2 is for</span>
<span class="line-removed">-   // longs/doubles to be consertive.</span>
    assert(sizeof(VerificationType) == sizeof(uintptr_t),
          &quot;buffer type must match VerificationType size&quot;);
<span class="line-removed">-   uintptr_t on_stack_sig_types_buffer[128];</span>
<span class="line-removed">-   // If we make a VerificationType[128] array directly, the compiler calls</span>
<span class="line-removed">-   // to the c-runtime library to do the allocation instead of just</span>
<span class="line-removed">-   // stack allocating it.  Plus it would run constructors.  This shows up</span>
<span class="line-removed">-   // in performance profiles.</span>
  
<span class="line-modified">!   VerificationType* sig_types;</span>
<span class="line-modified">!   int size = (method_sig-&gt;utf8_length() - 3) * 2;</span>
<span class="line-removed">-   if (size &gt; 128) {</span>
<span class="line-removed">-     // Long and double occupies two slots here.</span>
<span class="line-removed">-     ArgumentSizeComputer size_it(method_sig);</span>
<span class="line-removed">-     size = size_it.size();</span>
<span class="line-removed">-     sig_types = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, VerificationType, size);</span>
<span class="line-removed">-   } else{</span>
<span class="line-removed">-     sig_types = (VerificationType*)on_stack_sig_types_buffer;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   SignatureStream sig_stream(method_sig);</span>
<span class="line-removed">-   int sig_i = 0;</span>
<span class="line-removed">-   while (!sig_stream.at_return_type()) {</span>
<span class="line-removed">-     sig_i += change_sig_to_verificationType(</span>
<span class="line-removed">-       &amp;sig_stream, &amp;sig_types[sig_i], CHECK_VERIFY(this));</span>
<span class="line-removed">-     sig_stream.next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   int nargs = sig_i;</span>
  
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     ArgumentSizeComputer size_it(method_sig);</span>
<span class="line-modified">!     assert(nargs == size_it.size(), &quot;Argument sizes do not match&quot;);</span>
<span class="line-modified">!     assert(nargs &lt;= (method_sig-&gt;utf8_length() - 3) * 2, &quot;estimate of max size isn&#39;t conservative enough&quot;);</span>
    }
<span class="line-modified">! #endif</span>
  
    // Check instruction operands
    u2 bci = bcs-&gt;bci();
    if (opcode == Bytecodes::_invokeinterface) {
      address bcp = bcs-&gt;bcp();
<span class="line-new-header">--- 2797,32 ---</span>
      }
    } else {
      ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
    }
  
    assert(sizeof(VerificationType) == sizeof(uintptr_t),
          &quot;buffer type must match VerificationType size&quot;);
  
<span class="line-modified">!   // Get the UTF8 index for this signature.</span>
<span class="line-modified">!   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));</span>
  
<span class="line-modified">!   // Get the signature&#39;s verification types.</span>
<span class="line-modified">!   sig_as_verification_types* mth_sig_verif_types;</span>
<span class="line-modified">!   sig_as_verification_types** mth_sig_verif_types_ptr = method_signatures_table()-&gt;get(sig_index);</span>
<span class="line-modified">!   if (mth_sig_verif_types_ptr != NULL) {</span>
<span class="line-modified">!     // Found the entry for the signature&#39;s verification types in the hash table.</span>
<span class="line-added">+     mth_sig_verif_types = *mth_sig_verif_types_ptr;</span>
<span class="line-added">+     assert(mth_sig_verif_types != NULL, &quot;Unexpected NULL sig_as_verification_types value&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Not found, add the entry to the table.</span>
<span class="line-added">+     GrowableArray&lt;VerificationType&gt;* verif_types = new GrowableArray&lt;VerificationType&gt;(10);</span>
<span class="line-added">+     mth_sig_verif_types = new sig_as_verification_types(verif_types);</span>
<span class="line-added">+     create_method_sig_entry(mth_sig_verif_types, sig_index, CHECK_VERIFY(this));</span>
    }
<span class="line-modified">! </span>
<span class="line-added">+   // Get the number of arguments for this signature.</span>
<span class="line-added">+   int nargs = mth_sig_verif_types-&gt;num_args();</span>
  
    // Check instruction operands
    u2 bci = bcs-&gt;bci();
    if (opcode == Bytecodes::_invokeinterface) {
      address bcp = bcs-&gt;bcp();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2800,11 ***</span>
            &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
        return;
      }
    }
  
<span class="line-modified">!   if (method_name-&gt;char_at(0) == &#39;&lt;&#39;) {</span>
      // Make sure &lt;init&gt; can only be invoked by invokespecial
      if (opcode != Bytecodes::_invokespecial ||
          method_name != vmSymbols::object_initializer_name()) {
        verify_error(ErrorContext::bad_code(bci),
            &quot;Illegal call to internal method&quot;);
<span class="line-new-header">--- 2849,11 ---</span>
            &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
        return;
      }
    }
  
<span class="line-modified">!   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {</span>
      // Make sure &lt;init&gt; can only be invoked by invokespecial
      if (opcode != Bytecodes::_invokespecial ||
          method_name != vmSymbols::object_initializer_name()) {
        verify_error(ErrorContext::bad_code(bci),
            &quot;Illegal call to internal method&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2842,14 ***</span>
            &quot;interface method reference is in an indirect superinterface.&quot;);
        return;
      }
  
    }
    // Match method descriptor with operand stack
<span class="line-modified">!   for (int i = nargs - 1; i &gt;= 0; i--) {  // Run backwards</span>
<span class="line-modified">!     current_frame-&gt;pop_stack(sig_types[i], CHECK_VERIFY(this));</span>
    }
    // Check objectref on operand stack
    if (opcode != Bytecodes::_invokestatic &amp;&amp;
        opcode != Bytecodes::_invokedynamic) {
      if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
        verify_invoke_init(bcs, index, ref_class_type, current_frame,
<span class="line-new-header">--- 2891,20 ---</span>
            &quot;interface method reference is in an indirect superinterface.&quot;);
        return;
      }
  
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Get the verification types for the method&#39;s arguments.</span>
<span class="line-added">+   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();</span>
<span class="line-added">+   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);</span>
    // Match method descriptor with operand stack
<span class="line-modified">!   // The arguments are on the stack in descending order.</span>
<span class="line-modified">!   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards</span>
<span class="line-added">+     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));</span>
    }
<span class="line-added">+ </span>
    // Check objectref on operand stack
    if (opcode != Bytecodes::_invokestatic &amp;&amp;
        opcode != Bytecodes::_invokedynamic) {
      if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
        verify_invoke_init(bcs, index, ref_class_type, current_frame,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2917,24 ***</span>
          current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
        }
      }
    }
    // Push the result type.
<span class="line-modified">!   if (sig_stream.type() != T_VOID) {</span>
      if (method_name == vmSymbols::object_initializer_name()) {
        // &lt;init&gt; method must have a void return type
        /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have
         * void return */
        verify_error(ErrorContext::bad_code(bci),
            &quot;Return type must be void in &lt;init&gt; method&quot;);
        return;
      }
<span class="line-modified">!     VerificationType return_type[2];</span>
<span class="line-modified">!     int n = change_sig_to_verificationType(</span>
<span class="line-modified">!       &amp;sig_stream, return_type, CHECK_VERIFY(this));</span>
<span class="line-modified">!     for (int i = 0; i &lt; n; i++) {</span>
<span class="line-modified">!       current_frame-&gt;push_stack(return_type[i], CHECK_VERIFY(this)); // push types backwards</span>
      }
    }
  }
  
  VerificationType ClassVerifier::get_newarray_type(
<span class="line-new-header">--- 2972,27 ---</span>
          current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
        }
      }
    }
    // Push the result type.
<span class="line-modified">!   int sig_verif_types_len = sig_verif_types-&gt;length();</span>
<span class="line-added">+   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type</span>
      if (method_name == vmSymbols::object_initializer_name()) {
        // &lt;init&gt; method must have a void return type
        /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have
         * void return */
        verify_error(ErrorContext::bad_code(bci),
            &quot;Return type must be void in &lt;init&gt; method&quot;);
        return;
      }
<span class="line-modified">! </span>
<span class="line-modified">!     assert(sig_verif_types_len &lt;= nargs + 2,</span>
<span class="line-modified">!            &quot;Signature verification types array return type is bogus&quot;);</span>
<span class="line-modified">!     for (int i = nargs; i &lt; sig_verif_types_len; i++) {</span>
<span class="line-modified">!       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||</span>
<span class="line-added">+              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);</span>
<span class="line-added">+       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));</span>
      }
    }
  }
  
  VerificationType ClassVerifier::get_newarray_type(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2946,12 ***</span>
      verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
      return VerificationType::bogus_type();
    }
  
    // from_bt[index] contains the array signature which has a length of 2
<span class="line-modified">!   Symbol* sig = create_temporary_symbol(</span>
<span class="line-removed">-     from_bt[index], 2, CHECK_(VerificationType::bogus_type()));</span>
    return VerificationType::reference_type(sig);
  }
  
  void ClassVerifier::verify_anewarray(
      u2 bci, u2 index, const constantPoolHandle&amp; cp,
<span class="line-new-header">--- 3004,11 ---</span>
      verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
      return VerificationType::bogus_type();
    }
  
    // from_bt[index] contains the array signature which has a length of 2
<span class="line-modified">!   Symbol* sig = create_temporary_symbol(from_bt[index], 2);</span>
    return VerificationType::reference_type(sig);
  }
  
  void ClassVerifier::verify_anewarray(
      u2 bci, u2 index, const constantPoolHandle&amp; cp,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2968,29 ***</span>
    if (component_type.is_array()) {     // it&#39;s an array
      const char* component_name = component_type.name()-&gt;as_utf8();
      // Check for more than MAX_ARRAY_DIMENSIONS
      length = (int)strlen(component_name);
      if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
<span class="line-modified">!         component_name[MAX_ARRAY_DIMENSIONS - 1] == &#39;[&#39;) {</span>
        verify_error(ErrorContext::bad_code(bci),
          &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
      }
      // add one dimension to component
      length++;
      arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">!     int n = os::snprintf(arr_sig_str, length + 1, &quot;[%s&quot;, component_name);</span>
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    } else {         // it&#39;s an object or interface
      const char* component_name = component_type.name()-&gt;as_utf8();
      // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.
      length = (int)strlen(component_name) + 3;
      arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">!     int n = os::snprintf(arr_sig_str, length + 1, &quot;[L%s;&quot;, component_name);</span>
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    }
<span class="line-modified">!   Symbol* arr_sig = create_temporary_symbol(</span>
<span class="line-removed">-     arr_sig_str, length, CHECK_VERIFY(this));</span>
    VerificationType new_array_type = VerificationType::reference_type(arr_sig);
    current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
<span class="line-new-header">--- 3025,30 ---</span>
    if (component_type.is_array()) {     // it&#39;s an array
      const char* component_name = component_type.name()-&gt;as_utf8();
      // Check for more than MAX_ARRAY_DIMENSIONS
      length = (int)strlen(component_name);
      if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
<span class="line-modified">!         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {</span>
        verify_error(ErrorContext::bad_code(bci),
          &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
      }
      // add one dimension to component
      length++;
      arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">!     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,</span>
<span class="line-added">+                          JVM_SIGNATURE_ARRAY, component_name);</span>
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    } else {         // it&#39;s an object or interface
      const char* component_name = component_type.name()-&gt;as_utf8();
      // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.
      length = (int)strlen(component_name) + 3;
      arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
<span class="line-modified">!     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,</span>
<span class="line-added">+                          JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);</span>
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    }
<span class="line-modified">!   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);</span>
    VerificationType new_array_type = VerificationType::reference_type(arr_sig);
    current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3094,22 ***</span>
  
  // The verifier creates symbols which are substrings of Symbols.
  // These are stored in the verifier until the end of verification so that
  // they can be reference counted.
  Symbol* ClassVerifier::create_temporary_symbol(const Symbol *s, int begin,
<span class="line-modified">!                                                int end, TRAPS) {</span>
    const char* name = (const char*)s-&gt;base() + begin;
    int length = end - begin;
<span class="line-modified">!   return create_temporary_symbol(name, length, CHECK_NULL);</span>
  }
  
<span class="line-modified">! Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length, TRAPS) {</span>
    // Quick deduplication check
    if (_previous_symbol != NULL &amp;&amp; _previous_symbol-&gt;equals(name, length)) {
      return _previous_symbol;
    }
<span class="line-modified">!   Symbol* sym = SymbolTable::new_symbol(name, length, CHECK_NULL);</span>
    if (!sym-&gt;is_permanent()) {
      if (_symbols == NULL) {
        _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
      }
      _symbols-&gt;push(sym);
<span class="line-new-header">--- 3152,22 ---</span>
  
  // The verifier creates symbols which are substrings of Symbols.
  // These are stored in the verifier until the end of verification so that
  // they can be reference counted.
  Symbol* ClassVerifier::create_temporary_symbol(const Symbol *s, int begin,
<span class="line-modified">!                                                int end) {</span>
    const char* name = (const char*)s-&gt;base() + begin;
    int length = end - begin;
<span class="line-modified">!   return create_temporary_symbol(name, length);</span>
  }
  
<span class="line-modified">! Symbol* ClassVerifier::create_temporary_symbol(const char *name, int length) {</span>
    // Quick deduplication check
    if (_previous_symbol != NULL &amp;&amp; _previous_symbol-&gt;equals(name, length)) {
      return _previous_symbol;
    }
<span class="line-modified">!   Symbol* sym = SymbolTable::new_symbol(name, length);</span>
    if (!sym-&gt;is_permanent()) {
      if (_symbols == NULL) {
        _symbols = new GrowableArray&lt;Symbol*&gt;(50, 0, NULL);
      }
      _symbols-&gt;push(sym);
</pre>
<center><a href="verificationType.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classLoaderExt.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classFileParser.hpp&quot;
 27 #include &quot;classfile/classFileStream.hpp&quot;
 28 #include &quot;classfile/classLoader.inline.hpp&quot;
 29 #include &quot;classfile/classLoaderExt.hpp&quot;
 30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 31 #include &quot;classfile/klassFactory.hpp&quot;
 32 #include &quot;classfile/modules.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 33 #include &quot;classfile/sharedPathsMiscInfo.hpp&quot;</span>
 34 #include &quot;classfile/systemDictionaryShared.hpp&quot;
 35 #include &quot;classfile/vmSymbols.hpp&quot;
<a name="2" id="anc2"></a>
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/filemap.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/instanceKlass.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;oops/symbol.hpp&quot;
 42 #include &quot;runtime/arguments.hpp&quot;
 43 #include &quot;runtime/handles.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/os.hpp&quot;
 47 #include &quot;services/threadService.hpp&quot;
 48 #include &quot;utilities/stringUtils.hpp&quot;
 49 
 50 jshort ClassLoaderExt::_app_class_paths_start_index = ClassLoaderExt::max_classpath_index;
 51 jshort ClassLoaderExt::_app_module_paths_start_index = ClassLoaderExt::max_classpath_index;
 52 jshort ClassLoaderExt::_max_used_path_index = 0;
 53 bool ClassLoaderExt::_has_app_classes = false;
 54 bool ClassLoaderExt::_has_platform_classes = false;
 55 
 56 void ClassLoaderExt::append_boot_classpath(ClassPathEntry* new_entry) {
 57   if (UseSharedSpaces) {
 58     warning(&quot;Sharing is only supported for boot loader classes because bootstrap classpath has been appended&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 59     FileMapInfo::current_info()-&gt;header()-&gt;set_has_platform_or_app_classes(false);</span>
 60   }
 61   ClassLoader::add_to_boot_append_entries(new_entry);
 62 }
 63 
 64 void ClassLoaderExt::setup_app_search_path() {
<a name="4" id="anc4"></a><span class="line-modified"> 65   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);</span>
 66   _app_class_paths_start_index = ClassLoader::num_boot_classpath_entries();
 67   char* app_class_path = os::strdup(Arguments::get_appclasspath());
 68 
 69   if (strcmp(app_class_path, &quot;.&quot;) == 0) {
 70     // This doesn&#39;t make any sense, even for AppCDS, so let&#39;s skip it. We
 71     // don&#39;t want to throw an error here because -cp &quot;.&quot; is usually assigned
 72     // by the launcher when classpath is not specified.
 73     trace_class_path(&quot;app loader class path (skipped)=&quot;, app_class_path);
 74   } else {
 75     trace_class_path(&quot;app loader class path=&quot;, app_class_path);
<a name="5" id="anc5"></a><span class="line-removed"> 76     shared_paths_misc_info()-&gt;add_app_classpath(app_class_path);</span>
 77     ClassLoader::setup_app_search_path(app_class_path);
 78   }
 79 }
 80 
 81 void ClassLoaderExt::process_module_table(ModuleEntryTable* met, TRAPS) {
 82   ResourceMark rm(THREAD);
 83   for (int i = 0; i &lt; met-&gt;table_size(); i++) {
 84     for (ModuleEntry* m = met-&gt;bucket(i); m != NULL;) {
 85       char* path = m-&gt;location()-&gt;as_C_string();
 86       if (strncmp(path, &quot;file:&quot;, 5) == 0) {
 87         path = ClassLoader::skip_uri_protocol(path);
 88         ClassLoader::setup_module_search_path(path, THREAD);
 89       }
 90       m = m-&gt;next();
 91     }
 92   }
 93 }
 94 void ClassLoaderExt::setup_module_paths(TRAPS) {
<a name="6" id="anc6"></a><span class="line-modified"> 95   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);</span>
 96   _app_module_paths_start_index = ClassLoader::num_boot_classpath_entries() +
 97                               ClassLoader::num_app_classpath_entries();
 98   Handle system_class_loader (THREAD, SystemDictionary::java_system_loader());
 99   ModuleEntryTable* met = Modules::get_module_entry_table(system_class_loader);
100   process_module_table(met, THREAD);
101 }
102 
103 char* ClassLoaderExt::read_manifest(ClassPathEntry* entry, jint *manifest_size, bool clean_text, TRAPS) {
104   const char* name = &quot;META-INF/MANIFEST.MF&quot;;
105   char* manifest;
106   jint size;
107 
108   assert(entry-&gt;is_jar_file(), &quot;must be&quot;);
109   manifest = (char*) ((ClassPathZipEntry*)entry )-&gt;open_entry(name, &amp;size, true, CHECK_NULL);
110 
111   if (manifest == NULL) { // No Manifest
112     *manifest_size = 0;
113     return NULL;
114   }
115 
116 
117   if (clean_text) {
118     // See http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#JAR%20Manifest
119     // (1): replace all CR/LF and CR with LF
120     StringUtils::replace_no_expand(manifest, &quot;\r\n&quot;, &quot;\n&quot;);
121 
122     // (2) remove all new-line continuation (remove all &quot;\n &quot; substrings)
123     StringUtils::replace_no_expand(manifest, &quot;\n &quot;, &quot;&quot;);
124   }
125 
126   *manifest_size = (jint)strlen(manifest);
127   return manifest;
128 }
129 
130 char* ClassLoaderExt::get_class_path_attr(const char* jar_path, char* manifest, jint manifest_size) {
131   const char* tag = &quot;Class-Path: &quot;;
132   const int tag_len = (int)strlen(tag);
133   char* found = NULL;
134   char* line_start = manifest;
135   char* end = manifest + manifest_size;
136 
137   assert(*end == 0, &quot;must be nul-terminated&quot;);
138 
139   while (line_start &lt; end) {
140     char* line_end = strchr(line_start, &#39;\n&#39;);
141     if (line_end == NULL) {
142       // JAR spec require the manifest file to be terminated by a new line.
143       break;
144     }
145     if (strncmp(tag, line_start, tag_len) == 0) {
146       if (found != NULL) {
147         // Same behavior as jdk/src/share/classes/java/util/jar/Attributes.java
148         // If duplicated entries are found, the last one is used.
<a name="7" id="anc7"></a><span class="line-modified">149         tty-&gt;print_cr(&quot;Warning: Duplicate name in Manifest: %s.\n&quot;</span>
150                       &quot;Ensure that the manifest does not have duplicate entries, and\n&quot;
151                       &quot;that blank lines separate individual sections in both your\n&quot;
152                       &quot;manifest and in the META-INF/MANIFEST.MF entry in the jar file:\n%s\n&quot;, tag, jar_path);
153       }
154       found = line_start + tag_len;
155       assert(found &lt;= line_end, &quot;sanity&quot;);
156       *line_end = &#39;\0&#39;;
157     }
158     line_start = line_end + 1;
159   }
160   return found;
161 }
162 
163 void ClassLoaderExt::process_jar_manifest(ClassPathEntry* entry,
164                                           bool check_for_duplicates) {
165   Thread* THREAD = Thread::current();
166   ResourceMark rm(THREAD);
167   jint manifest_size;
168   char* manifest = read_manifest(entry, &amp;manifest_size, CHECK);
169 
170   if (manifest == NULL) {
171     return;
172   }
173 
174   if (strstr(manifest, &quot;Extension-List:&quot;) != NULL) {
175     vm_exit_during_cds_dumping(err_msg(&quot;-Xshare:dump does not support Extension-List in JAR manifest: %s&quot;, entry-&gt;name()));
176   }
177 
178   char* cp_attr = get_class_path_attr(entry-&gt;name(), manifest, manifest_size);
179 
180   if (cp_attr != NULL &amp;&amp; strlen(cp_attr) &gt; 0) {
181     trace_class_path(&quot;found Class-Path: &quot;, cp_attr);
182 
183     char sep = os::file_separator()[0];
184     const char* dir_name = entry-&gt;name();
185     const char* dir_tail = strrchr(dir_name, sep);
186     int dir_len;
187     if (dir_tail == NULL) {
188       dir_len = 0;
189     } else {
190       dir_len = dir_tail - dir_name + 1;
191     }
192 
193     // Split the cp_attr by spaces, and add each file
194     char* file_start = cp_attr;
195     char* end = file_start + strlen(file_start);
196 
197     while (file_start &lt; end) {
198       char* file_end = strchr(file_start, &#39; &#39;);
199       if (file_end != NULL) {
200         *file_end = 0;
201         file_end += 1;
202       } else {
203         file_end = end;
204       }
205 
206       size_t name_len = strlen(file_start);
207       if (name_len &gt; 0) {
208         ResourceMark rm(THREAD);
209         size_t libname_len = dir_len + name_len;
210         char* libname = NEW_RESOURCE_ARRAY(char, libname_len + 1);
211         int n = os::snprintf(libname, libname_len + 1, &quot;%.*s%s&quot;, dir_len, dir_name, file_start);
212         assert((size_t)n == libname_len, &quot;Unexpected number of characters in string&quot;);
<a name="8" id="anc8"></a><span class="line-modified">213         trace_class_path(&quot;library = &quot;, libname);</span>
<span class="line-modified">214         ClassLoader::update_class_path_entry_list(libname, true, false);</span>




215       }
216 
217       file_start = file_end;
218     }
219   }
220 }
221 
222 void ClassLoaderExt::setup_search_paths() {
<a name="9" id="anc9"></a><span class="line-removed">223   shared_paths_misc_info()-&gt;record_app_offset();</span>
224   ClassLoaderExt::setup_app_search_path();
225 }
226 
227 void ClassLoaderExt::record_result(const s2 classpath_index,
228                                    InstanceKlass* result,
229                                    TRAPS) {
<a name="10" id="anc10"></a><span class="line-modified">230   assert(DumpSharedSpaces, &quot;Sanity&quot;);</span>
231 
232   // We need to remember where the class comes from during dumping.
233   oop loader = result-&gt;class_loader();
234   s2 classloader_type = ClassLoader::BOOT_LOADER;
235   if (SystemDictionary::is_system_class_loader(loader)) {
236     classloader_type = ClassLoader::APP_LOADER;
237     ClassLoaderExt::set_has_app_classes();
238   } else if (SystemDictionary::is_platform_class_loader(loader)) {
239     classloader_type = ClassLoader::PLATFORM_LOADER;
240     ClassLoaderExt::set_has_platform_classes();
241   }
242   if (classpath_index &gt; ClassLoaderExt::max_used_path_index()) {
243     ClassLoaderExt::set_max_used_path_index(classpath_index);
244   }
245   result-&gt;set_shared_classpath_index(classpath_index);
246   result-&gt;set_class_loader_type(classloader_type);
247 }
248 
<a name="11" id="anc11"></a><span class="line-removed">249 void ClassLoaderExt::finalize_shared_paths_misc_info() {</span>
<span class="line-removed">250   if (!_has_app_classes) {</span>
<span class="line-removed">251     shared_paths_misc_info()-&gt;pop_app();</span>
<span class="line-removed">252   }</span>
<span class="line-removed">253 }</span>
<span class="line-removed">254 </span>
255 // Load the class of the given name from the location given by path. The path is specified by
256 // the &quot;source:&quot; in the class list file (see classListParser.cpp), and can be a directory or
257 // a JAR file.
258 InstanceKlass* ClassLoaderExt::load_class(Symbol* name, const char* path, TRAPS) {
259   assert(name != NULL, &quot;invariant&quot;);
260   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);
261   ResourceMark rm(THREAD);
262   const char* class_name = name-&gt;as_C_string();
263 
264   const char* file_name = file_name_for_class_name(class_name,
265                                                    name-&gt;utf8_length());
266   assert(file_name != NULL, &quot;invariant&quot;);
267 
268   // Lookup stream for parsing .class file
269   ClassFileStream* stream = NULL;
270   ClassPathEntry* e = find_classpath_entry_from_cache(path, CHECK_NULL);
271   if (e == NULL) {
272     return NULL;
273   }
274   {
275     PerfClassTraceTime vmtimer(perf_sys_class_lookup_time(),
276                                ((JavaThread*) THREAD)-&gt;get_thread_stat()-&gt;perf_timers_addr(),
277                                PerfClassTraceTime::CLASS_LOAD);
278     stream = e-&gt;open_stream(file_name, CHECK_NULL);
279   }
280 
281   if (NULL == stream) {
<a name="12" id="anc12"></a><span class="line-modified">282     tty-&gt;print_cr(&quot;Preload Warning: Cannot find %s&quot;, class_name);</span>
283     return NULL;
284   }
285 
286   assert(stream != NULL, &quot;invariant&quot;);
287   stream-&gt;set_verify(true);
288 
289   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
290   Handle protection_domain;
291 
292   InstanceKlass* result = KlassFactory::create_from_stream(stream,
293                                                            name,
294                                                            loader_data,
295                                                            protection_domain,
296                                                            NULL, // unsafe_anonymous_host
297                                                            NULL, // cp_patches
298                                                            THREAD);
299 
300   if (HAS_PENDING_EXCEPTION) {
<a name="13" id="anc13"></a><span class="line-modified">301     tty-&gt;print_cr(&quot;Preload Error: Failed to load %s&quot;, class_name);</span>
302     return NULL;
303   }
<a name="14" id="anc14"></a><span class="line-removed">304   result-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);</span>
<span class="line-removed">305   SystemDictionaryShared::set_shared_class_misc_info(result, stream);</span>
306   return result;
307 }
308 
309 struct CachedClassPathEntry {
310   const char* _path;
311   ClassPathEntry* _entry;
312 };
313 
314 static GrowableArray&lt;CachedClassPathEntry&gt;* cached_path_entries = NULL;
315 
316 ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(const char* path, TRAPS) {
317   // This is called from dump time so it&#39;s single threaded and there&#39;s no need for a lock.
318   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);
319   if (cached_path_entries == NULL) {
320     cached_path_entries = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;CachedClassPathEntry&gt;(20, /*c heap*/ true);
321   }
322   CachedClassPathEntry ccpe;
323   for (int i=0; i&lt;cached_path_entries-&gt;length(); i++) {
324     ccpe = cached_path_entries-&gt;at(i);
325     if (strcmp(ccpe._path, path) == 0) {
326       if (i != 0) {
327         // Put recent entries at the beginning to speed up searches.
328         cached_path_entries-&gt;remove_at(i);
329         cached_path_entries-&gt;insert_before(0, ccpe);
330       }
331       return ccpe._entry;
332     }
333   }
334 
335   struct stat st;
336   if (os::stat(path, &amp;st) != 0) {
337     // File or directory not found
338     return NULL;
339   }
340   ClassPathEntry* new_entry = NULL;
341 
<a name="15" id="anc15"></a><span class="line-modified">342   new_entry = create_class_path_entry(path, &amp;st, false, false, CHECK_NULL);</span>
343   if (new_entry == NULL) {
344     return NULL;
345   }
346   ccpe._path = strdup(path);
347   ccpe._entry = new_entry;
348   cached_path_entries-&gt;insert_before(0, ccpe);
349   return new_entry;
350 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/symbolTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbolTable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/symbolTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,29 ***</span>
  #include &quot;classfile/altHashing.hpp&quot;
  #include &quot;classfile/compactHashtable.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/timerTrace.hpp&quot;
  #include &quot;services/diagnosticCommand.hpp&quot;
  #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
  
  // We used to not resize at all, so let&#39;s be conservative
  // and not set it too short before we decide to resize,
  // to match previous startup behavior
  const double PREF_AVG_LIST_LEN = 8.0;
<span class="line-modified">! // 2^17 (131,072) is max size, which is about 6.5 times as large</span>
<span class="line-modified">! // as the previous table size (used to be 20,011),</span>
<span class="line-removed">- // which never resized</span>
<span class="line-removed">- const size_t END_SIZE = 17;</span>
  // If a chain gets to 100 something might be wrong
  const size_t REHASH_LEN = 100;
  
  const size_t ON_STACK_BUFFER_LENGTH = 128;
  
<span class="line-new-header">--- 26,29 ---</span>
  #include &quot;classfile/altHashing.hpp&quot;
  #include &quot;classfile/compactHashtable.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">+ #include &quot;memory/dynamicArchive.hpp&quot;</span>
  #include &quot;memory/metaspaceClosure.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/timerTrace.hpp&quot;
  #include &quot;services/diagnosticCommand.hpp&quot;
  #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
  #include &quot;utilities/concurrentHashTableTasks.inline.hpp&quot;
<span class="line-added">+ #include &quot;utilities/utf8.hpp&quot;</span>
  
  // We used to not resize at all, so let&#39;s be conservative
  // and not set it too short before we decide to resize,
  // to match previous startup behavior
  const double PREF_AVG_LIST_LEN = 8.0;
<span class="line-modified">! // 2^24 is max size, like StringTable.</span>
<span class="line-modified">! const size_t END_SIZE = 24;</span>
  // If a chain gets to 100 something might be wrong
  const size_t REHASH_LEN = 100;
  
  const size_t ON_STACK_BUFFER_LENGTH = 128;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,14 ***</span>
  static OffsetCompactHashtable&lt;
    const char*, Symbol*,
    symbol_equals_compact_hashtable_entry
  &gt; _shared_table;
  
  // --------------------------------------------------------------------------
<span class="line-modified">! SymbolTable* SymbolTable::_the_table = NULL;</span>
<span class="line-modified">! volatile bool SymbolTable::_alt_hash = false;</span>
<span class="line-modified">! volatile bool SymbolTable::_lookup_shared_first = false;</span>
  // Static arena for symbols that are not deallocated
  Arena* SymbolTable::_arena = NULL;
  
  static juint murmur_seed = 0;
  
<span class="line-new-header">--- 66,35 ---</span>
  static OffsetCompactHashtable&lt;
    const char*, Symbol*,
    symbol_equals_compact_hashtable_entry
  &gt; _shared_table;
  
<span class="line-added">+ static OffsetCompactHashtable&lt;</span>
<span class="line-added">+   const char*, Symbol*,</span>
<span class="line-added">+   symbol_equals_compact_hashtable_entry</span>
<span class="line-added">+ &gt; _dynamic_shared_table;</span>
<span class="line-added">+ </span>
  // --------------------------------------------------------------------------
<span class="line-modified">! </span>
<span class="line-modified">! typedef ConcurrentHashTable&lt;SymbolTableConfig, mtSymbol&gt; SymbolTableHash;</span>
<span class="line-modified">! static SymbolTableHash* _local_table = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ volatile bool SymbolTable::_has_work = 0;</span>
<span class="line-added">+ volatile bool SymbolTable::_needs_rehashing = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ // For statistics</span>
<span class="line-added">+ static size_t _symbols_removed = 0;</span>
<span class="line-added">+ static size_t _symbols_counted = 0;</span>
<span class="line-added">+ static size_t _current_size = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static volatile size_t _items_count = 0;</span>
<span class="line-added">+ static volatile bool   _has_items_to_clean = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static volatile bool _alt_hash = false;</span>
<span class="line-added">+ static volatile bool _lookup_shared_first = false;</span>
<span class="line-added">+ </span>
  // Static arena for symbols that are not deallocated
  Arena* SymbolTable::_arena = NULL;
  
  static juint murmur_seed = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,31 ***</span>
    return useAlt ?
    AltHashing::murmur3_32(murmur_seed, (const jbyte*)s, len) :
    java_lang_String::hash_code((const jbyte*)s, len);
  }
  
  static uintx hash_shared_symbol(const char* s, int len) {
    return java_lang_String::hash_code((const jbyte*)s, len);
  }
  
<span class="line-modified">! class SymbolTableConfig : public SymbolTableHash::BaseConfig {</span>
  private:
  public:
<span class="line-modified">!   static uintx get_hash(Symbol* const&amp; value, bool* is_dead) {</span>
      *is_dead = (value-&gt;refcount() == 0);
      if (*is_dead) {
        return 0;
      } else {
<span class="line-modified">!       return hash_symbol((const char*)value-&gt;bytes(), value-&gt;utf8_length(), SymbolTable::_alt_hash);</span>
      }
    }
    // We use default allocation/deallocation but counted
<span class="line-modified">!   static void* allocate_node(size_t size, Symbol* const&amp; value) {</span>
      SymbolTable::item_added();
<span class="line-modified">!     return SymbolTableHash::BaseConfig::allocate_node(size, value);</span>
    }
<span class="line-modified">!   static void free_node(void* memory, Symbol* const&amp; value) {</span>
      // We get here because #1 some threads lost a race to insert a newly created Symbol
      // or #2 we&#39;re cleaning up unused symbol.
      // If #1, then the symbol can be either permanent (refcount==PERM_REFCOUNT),
      // or regular newly created one (refcount==1)
      // If #2, then the symbol is dead (refcount==0)
<span class="line-new-header">--- 110,35 ---</span>
    return useAlt ?
    AltHashing::murmur3_32(murmur_seed, (const jbyte*)s, len) :
    java_lang_String::hash_code((const jbyte*)s, len);
  }
  
<span class="line-added">+ #if INCLUDE_CDS</span>
  static uintx hash_shared_symbol(const char* s, int len) {
    return java_lang_String::hash_code((const jbyte*)s, len);
  }
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! class SymbolTableConfig : public AllStatic {</span>
  private:
  public:
<span class="line-modified">!   typedef Symbol* Value;  // value of the Node in the hashtable</span>
<span class="line-added">+ </span>
<span class="line-added">+   static uintx get_hash(Value const&amp; value, bool* is_dead) {</span>
      *is_dead = (value-&gt;refcount() == 0);
      if (*is_dead) {
        return 0;
      } else {
<span class="line-modified">!       return hash_symbol((const char*)value-&gt;bytes(), value-&gt;utf8_length(), _alt_hash);</span>
      }
    }
    // We use default allocation/deallocation but counted
<span class="line-modified">!   static void* allocate_node(size_t size, Value const&amp; value) {</span>
      SymbolTable::item_added();
<span class="line-modified">!     return AllocateHeap(size, mtSymbol);</span>
    }
<span class="line-modified">!   static void free_node(void* memory, Value const&amp; value) {</span>
      // We get here because #1 some threads lost a race to insert a newly created Symbol
      // or #2 we&#39;re cleaning up unused symbol.
      // If #1, then the symbol can be either permanent (refcount==PERM_REFCOUNT),
      // or regular newly created one (refcount==1)
      // If #2, then the symbol is dead (refcount==0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,36 ***</span>
      if (value-&gt;refcount() == 1) {
        value-&gt;decrement_refcount();
        assert(value-&gt;refcount() == 0, &quot;expected dead symbol&quot;);
      }
      SymbolTable::delete_symbol(value);
<span class="line-modified">!     SymbolTableHash::BaseConfig::free_node(memory, value);</span>
      SymbolTable::item_removed();
    }
  };
  
  static size_t ceil_log2(size_t value) {
    size_t ret;
    for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; value; ++ret);
    return ret;
  }
  
<span class="line-modified">! SymbolTable::SymbolTable() :</span>
<span class="line-removed">-   _symbols_removed(0), _symbols_counted(0), _local_table(NULL),</span>
<span class="line-removed">-   _current_size(0), _has_work(0), _needs_rehashing(false),</span>
<span class="line-removed">-   _items_count(0), _has_items_to_clean(false) {</span>
<span class="line-removed">- </span>
    size_t start_size_log_2 = ceil_log2(SymbolTableSize);
    _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
    log_trace(symboltable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
                           _current_size, start_size_log_2);
    _local_table = new SymbolTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
  }
  
  void SymbolTable::delete_symbol(Symbol* sym) {
    if (sym-&gt;refcount() == PERM_REFCOUNT) {
<span class="line-modified">!     MutexLockerEx ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena</span>
      // Deleting permanent symbol should not occur very often (insert race condition),
      // so log it.
      log_trace_symboltable_helper(sym, &quot;Freeing permanent symbol&quot;);
      if (!arena()-&gt;Afree(sym, sym-&gt;size())) {
        log_trace_symboltable_helper(sym, &quot;Leaked permanent symbol&quot;);
<span class="line-new-header">--- 147,39 ---</span>
      if (value-&gt;refcount() == 1) {
        value-&gt;decrement_refcount();
        assert(value-&gt;refcount() == 0, &quot;expected dead symbol&quot;);
      }
      SymbolTable::delete_symbol(value);
<span class="line-modified">!     FreeHeap(memory);</span>
      SymbolTable::item_removed();
    }
  };
  
  static size_t ceil_log2(size_t value) {
    size_t ret;
    for (ret = 1; ((size_t)1 &lt;&lt; ret) &lt; value; ++ret);
    return ret;
  }
  
<span class="line-modified">! void SymbolTable::create_table ()  {</span>
    size_t start_size_log_2 = ceil_log2(SymbolTableSize);
    _current_size = ((size_t)1) &lt;&lt; start_size_log_2;
    log_trace(symboltable)(&quot;Start size: &quot; SIZE_FORMAT &quot; (&quot; SIZE_FORMAT &quot;)&quot;,
                           _current_size, start_size_log_2);
    _local_table = new SymbolTableHash(start_size_log_2, END_SIZE, REHASH_LEN);
<span class="line-added">+ </span>
<span class="line-added">+   // Initialize the arena for global symbols, size passed in depends on CDS.</span>
<span class="line-added">+   if (symbol_alloc_arena_size == 0) {</span>
<span class="line-added">+     _arena = new (mtSymbol) Arena(mtSymbol);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);</span>
<span class="line-added">+   }</span>
  }
  
  void SymbolTable::delete_symbol(Symbol* sym) {
    if (sym-&gt;refcount() == PERM_REFCOUNT) {
<span class="line-modified">!     MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena</span>
      // Deleting permanent symbol should not occur very often (insert race condition),
      // so log it.
      log_trace_symboltable_helper(sym, &quot;Freeing permanent symbol&quot;);
      if (!arena()-&gt;Afree(sym, sym-&gt;size())) {
        log_trace_symboltable_helper(sym, &quot;Leaked permanent symbol&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,71 ***</span>
    } else {
      delete sym;
    }
  }
  
<span class="line-modified">! void SymbolTable::update_needs_rehash(bool rehash) {</span>
<span class="line-modified">!   if (rehash) {</span>
<span class="line-modified">!     _needs_rehashing = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void SymbolTable::reset_has_items_to_clean() { Atomic::store(false, &amp;_has_items_to_clean); }</span>
<span class="line-removed">- void SymbolTable::mark_has_items_to_clean()  { Atomic::store(true, &amp;_has_items_to_clean); }</span>
<span class="line-removed">- bool SymbolTable::has_items_to_clean() const { return Atomic::load(&amp;_has_items_to_clean); }</span>
  
  void SymbolTable::item_added() {
<span class="line-modified">!   Atomic::inc(&amp;(SymbolTable::the_table()-&gt;_items_count));</span>
  }
  
  void SymbolTable::item_removed() {
<span class="line-modified">!   Atomic::inc(&amp;(SymbolTable::the_table()-&gt;_symbols_removed));</span>
<span class="line-modified">!   Atomic::dec(&amp;(SymbolTable::the_table()-&gt;_items_count));</span>
  }
  
<span class="line-modified">! double SymbolTable::get_load_factor() const {</span>
    return (double)_items_count/_current_size;
  }
  
  size_t SymbolTable::table_size() {
    return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
  }
  
  void SymbolTable::trigger_cleanup() {
<span class="line-modified">!   MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   SymbolTable::the_table()-&gt;_has_work = true;</span>
    Service_lock-&gt;notify_all();
  }
  
<span class="line-modified">! Symbol* SymbolTable::allocate_symbol(const char* name, int len, bool c_heap, TRAPS) {</span>
    assert (len &lt;= Symbol::max_length(), &quot;should be checked by caller&quot;);
  
    Symbol* sym;
<span class="line-modified">!   if (DumpSharedSpaces) {</span>
      c_heap = false;
    }
    if (c_heap) {
      // refcount starts as 1
<span class="line-modified">!     sym = new (len, THREAD) Symbol((const u1*)name, len, 1);</span>
      assert(sym != NULL, &quot;new should call vm_exit_out_of_memory if C_HEAP is exhausted&quot;);
    } else {
      // Allocate to global arena
<span class="line-modified">!     MutexLockerEx ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena</span>
<span class="line-modified">!     sym = new (len, arena(), THREAD) Symbol((const u1*)name, len, PERM_REFCOUNT);</span>
    }
    return sym;
  }
  
<span class="line-removed">- void SymbolTable::initialize_symbols(int arena_alloc_size) {</span>
<span class="line-removed">-   // Initialize the arena for global symbols, size passed in depends on CDS.</span>
<span class="line-removed">-   if (arena_alloc_size == 0) {</span>
<span class="line-removed">-     _arena = new (mtSymbol) Arena(mtSymbol);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _arena = new (mtSymbol) Arena(mtSymbol, arena_alloc_size);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  class SymbolsDo : StackObj {
    SymbolClosure *_cl;
  public:
    SymbolsDo(SymbolClosure *cl) : _cl(cl) {}
    bool operator()(Symbol** value) {
<span class="line-new-header">--- 187,56 ---</span>
    } else {
      delete sym;
    }
  }
  
<span class="line-modified">! void SymbolTable::reset_has_items_to_clean() { Atomic::store(&amp;_has_items_to_clean, false); }</span>
<span class="line-modified">! void SymbolTable::mark_has_items_to_clean()  { Atomic::store(&amp;_has_items_to_clean, true); }</span>
<span class="line-modified">! bool SymbolTable::has_items_to_clean()       { return Atomic::load(&amp;_has_items_to_clean); }</span>
  
  void SymbolTable::item_added() {
<span class="line-modified">!   Atomic::inc(&amp;_items_count);</span>
  }
  
  void SymbolTable::item_removed() {
<span class="line-modified">!   Atomic::inc(&amp;(_symbols_removed));</span>
<span class="line-modified">!   Atomic::dec(&amp;_items_count);</span>
  }
  
<span class="line-modified">! double SymbolTable::get_load_factor() {</span>
    return (double)_items_count/_current_size;
  }
  
  size_t SymbolTable::table_size() {
    return ((size_t)1) &lt;&lt; _local_table-&gt;get_size_log2(Thread::current());
  }
  
  void SymbolTable::trigger_cleanup() {
<span class="line-modified">!   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   _has_work = true;</span>
    Service_lock-&gt;notify_all();
  }
  
<span class="line-modified">! Symbol* SymbolTable::allocate_symbol(const char* name, int len, bool c_heap) {</span>
    assert (len &lt;= Symbol::max_length(), &quot;should be checked by caller&quot;);
  
    Symbol* sym;
<span class="line-modified">!   if (Arguments::is_dumping_archive()) {</span>
      c_heap = false;
    }
    if (c_heap) {
      // refcount starts as 1
<span class="line-modified">!     sym = new (len) Symbol((const u1*)name, len, 1);</span>
      assert(sym != NULL, &quot;new should call vm_exit_out_of_memory if C_HEAP is exhausted&quot;);
    } else {
      // Allocate to global arena
<span class="line-modified">!     MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); // Protect arena</span>
<span class="line-modified">!     sym = new (len, arena()) Symbol((const u1*)name, len, PERM_REFCOUNT);</span>
    }
    return sym;
  }
  
  class SymbolsDo : StackObj {
    SymbolClosure *_cl;
  public:
    SymbolsDo(SymbolClosure *cl) : _cl(cl) {}
    bool operator()(Symbol** value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,15 ***</span>
  // Call function for all symbols in the symbol table.
  void SymbolTable::symbols_do(SymbolClosure *cl) {
    // all symbols from shared table
    SharedSymbolIterator iter(cl);
    _shared_table.iterate(&amp;iter);
  
    // all symbols from the dynamic table
    SymbolsDo sd(cl);
<span class="line-modified">!   if (!SymbolTable::the_table()-&gt;_local_table-&gt;try_scan(Thread::current(), sd)) {</span>
<span class="line-modified">!     log_info(stringtable)(&quot;symbols_do unavailable at this moment&quot;);</span>
    }
  }
  
  class MetaspacePointersDo : StackObj {
    MetaspaceClosure *_it;
<span class="line-new-header">--- 259,16 ---</span>
  // Call function for all symbols in the symbol table.
  void SymbolTable::symbols_do(SymbolClosure *cl) {
    // all symbols from shared table
    SharedSymbolIterator iter(cl);
    _shared_table.iterate(&amp;iter);
<span class="line-added">+   _dynamic_shared_table.iterate(&amp;iter);</span>
  
    // all symbols from the dynamic table
    SymbolsDo sd(cl);
<span class="line-modified">!   if (!_local_table-&gt;try_scan(Thread::current(), sd)) {</span>
<span class="line-modified">!     log_info(symboltable)(&quot;symbols_do unavailable at this moment&quot;);</span>
    }
  }
  
  class MetaspacePointersDo : StackObj {
    MetaspaceClosure *_it;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,35 ***</span>
      return true;
    };
  };
  
  void SymbolTable::metaspace_pointers_do(MetaspaceClosure* it) {
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;called only during dump time&quot;);</span>
    MetaspacePointersDo mpd(it);
<span class="line-modified">!   SymbolTable::the_table()-&gt;_local_table-&gt;do_safepoint_scan(mpd);</span>
  }
  
  Symbol* SymbolTable::lookup_dynamic(const char* name,
                                      int len, unsigned int hash) {
<span class="line-modified">!   Symbol* sym = SymbolTable::the_table()-&gt;do_lookup(name, len, hash);</span>
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;refcount must not be zero&quot;);
    return sym;
  }
  
  Symbol* SymbolTable::lookup_shared(const char* name,
                                     int len, unsigned int hash) {
    if (!_shared_table.empty()) {
<span class="line-modified">!     if (SymbolTable::_alt_hash) {</span>
        // hash_code parameter may use alternate hashing algorithm but the shared table
        // always uses the same original hash code.
        hash = hash_shared_symbol(name, len);
      }
<span class="line-modified">!     return _shared_table.lookup(name, hash, len);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     return NULL;</span>
    }
  }
  
  Symbol* SymbolTable::lookup_common(const char* name,
                              int len, unsigned int hash) {
    Symbol* sym;
    if (_lookup_shared_first) {
<span class="line-new-header">--- 281,40 ---</span>
      return true;
    };
  };
  
  void SymbolTable::metaspace_pointers_do(MetaspaceClosure* it) {
<span class="line-modified">!   Arguments::assert_is_dumping_archive();</span>
    MetaspacePointersDo mpd(it);
<span class="line-modified">!   _local_table-&gt;do_safepoint_scan(mpd);</span>
  }
  
  Symbol* SymbolTable::lookup_dynamic(const char* name,
                                      int len, unsigned int hash) {
<span class="line-modified">!   Symbol* sym = do_lookup(name, len, hash);</span>
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;refcount must not be zero&quot;);
    return sym;
  }
  
<span class="line-added">+ #if INCLUDE_CDS</span>
  Symbol* SymbolTable::lookup_shared(const char* name,
                                     int len, unsigned int hash) {
<span class="line-added">+   Symbol* sym = NULL;</span>
    if (!_shared_table.empty()) {
<span class="line-modified">!     if (_alt_hash) {</span>
        // hash_code parameter may use alternate hashing algorithm but the shared table
        // always uses the same original hash code.
        hash = hash_shared_symbol(name, len);
      }
<span class="line-modified">!     sym = _shared_table.lookup(name, hash, len);</span>
<span class="line-modified">!     if (sym == NULL &amp;&amp; DynamicArchive::is_mapped()) {</span>
<span class="line-modified">!       sym = _dynamic_shared_table.lookup(name, hash, len);</span>
<span class="line-added">+     }</span>
    }
<span class="line-added">+   return sym;</span>
  }
<span class="line-added">+ #endif</span>
  
  Symbol* SymbolTable::lookup_common(const char* name,
                              int len, unsigned int hash) {
    Symbol* sym;
    if (_lookup_shared_first) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,29 ***</span>
      }
    }
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::lookup(const char* name, int len, TRAPS) {</span>
<span class="line-modified">!   unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);</span>
<span class="line-modified">!   Symbol* sym = SymbolTable::the_table()-&gt;lookup_common(name, len, hash);</span>
    if (sym == NULL) {
<span class="line-modified">!     sym = SymbolTable::the_table()-&gt;do_add_if_needed(name, len, hash, true, CHECK_NULL);</span>
    }
    assert(sym-&gt;refcount() != 0, &quot;lookup should have incremented the count&quot;);
    assert(sym-&gt;equals(name, len), &quot;symbol must be properly initialized&quot;);
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::lookup(const Symbol* sym, int begin, int end, TRAPS) {</span>
    assert(sym-&gt;refcount() != 0, &quot;require a valid symbol&quot;);
    const char* name = (const char*)sym-&gt;base() + begin;
    int len = end - begin;
<span class="line-modified">!   unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);</span>
<span class="line-modified">!   Symbol* found = SymbolTable::the_table()-&gt;lookup_common(name, len, hash);</span>
    if (found == NULL) {
<span class="line-modified">!     found = SymbolTable::the_table()-&gt;do_add_if_needed(name, len, hash, true, THREAD);</span>
    }
    return found;
  }
  
  class SymbolTableLookup : StackObj {
<span class="line-new-header">--- 333,30 ---</span>
      }
    }
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::new_symbol(const char* name, int len) {</span>
<span class="line-modified">!   unsigned int hash = hash_symbol(name, len, _alt_hash);</span>
<span class="line-modified">!   Symbol* sym = lookup_common(name, len, hash);</span>
    if (sym == NULL) {
<span class="line-modified">!     sym = do_add_if_needed(name, len, hash, true);</span>
    }
    assert(sym-&gt;refcount() != 0, &quot;lookup should have incremented the count&quot;);
    assert(sym-&gt;equals(name, len), &quot;symbol must be properly initialized&quot;);
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::new_symbol(const Symbol* sym, int begin, int end) {</span>
<span class="line-added">+   assert(begin &lt;= end &amp;&amp; end &lt;= sym-&gt;utf8_length(), &quot;just checking&quot;);</span>
    assert(sym-&gt;refcount() != 0, &quot;require a valid symbol&quot;);
    const char* name = (const char*)sym-&gt;base() + begin;
    int len = end - begin;
<span class="line-modified">!   unsigned int hash = hash_symbol(name, len, _alt_hash);</span>
<span class="line-modified">!   Symbol* found = lookup_common(name, len, hash);</span>
    if (found == NULL) {
<span class="line-modified">!     found = do_add_if_needed(name, len, hash, true);</span>
    }
    return found;
  }
  
  class SymbolTableLookup : StackObj {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,12 ***</span>
    Thread* _thread;
    uintx _hash;
    int _len;
    const char* _str;
  public:
<span class="line-modified">!   SymbolTableLookup(Thread* thread, const char* key, int len, uintx hash)</span>
<span class="line-modified">!   : _thread(thread), _hash(hash), _len(len), _str(key) {}</span>
    uintx get_hash() const {
      return _hash;
    }
    bool equals(Symbol** value, bool* is_dead) {
      assert(value != NULL, &quot;expected valid value&quot;);
<span class="line-new-header">--- 364,12 ---</span>
    Thread* _thread;
    uintx _hash;
    int _len;
    const char* _str;
  public:
<span class="line-modified">!   SymbolTableLookup(const char* key, int len, uintx hash)</span>
<span class="line-modified">!   : _hash(hash), _len(len), _str(key) {}</span>
    uintx get_hash() const {
      return _hash;
    }
    bool equals(Symbol** value, bool* is_dead) {
      assert(value != NULL, &quot;expected valid value&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,45 ***</span>
    }
  };
  
  Symbol* SymbolTable::do_lookup(const char* name, int len, uintx hash) {
    Thread* thread = Thread::current();
<span class="line-modified">!   SymbolTableLookup lookup(thread, name, len, hash);</span>
    SymbolTableGet stg;
    bool rehash_warning = false;
    _local_table-&gt;get(thread, lookup, stg, &amp;rehash_warning);
    update_needs_rehash(rehash_warning);
    Symbol* sym = stg.get_res_sym();
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);
    return sym;
  }
  
  Symbol* SymbolTable::lookup_only(const char* name, int len, unsigned int&amp; hash) {
<span class="line-modified">!   hash = hash_symbol(name, len, SymbolTable::_alt_hash);</span>
<span class="line-modified">!   return SymbolTable::the_table()-&gt;lookup_common(name, len, hash);</span>
  }
  
  // Suggestion: Push unicode-based lookup all the way into the hashing
  // and probing logic, so there is no need for convert_to_utf8 until
  // an actual new Symbol* is created.
<span class="line-modified">! Symbol* SymbolTable::lookup_unicode(const jchar* name, int utf16_length, TRAPS) {</span>
    int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
    char stack_buf[ON_STACK_BUFFER_LENGTH];
    if (utf8_length &lt; (int) sizeof(stack_buf)) {
      char* chars = stack_buf;
      UNICODE::convert_to_utf8(name, utf16_length, chars);
<span class="line-modified">!     return lookup(chars, utf8_length, THREAD);</span>
    } else {
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
      char* chars = NEW_RESOURCE_ARRAY(char, utf8_length + 1);
      UNICODE::convert_to_utf8(name, utf16_length, chars);
<span class="line-modified">!     return lookup(chars, utf8_length, THREAD);</span>
    }
  }
  
  Symbol* SymbolTable::lookup_only_unicode(const jchar* name, int utf16_length,
<span class="line-modified">!                                            unsigned int&amp; hash) {</span>
    int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
    char stack_buf[ON_STACK_BUFFER_LENGTH];
    if (utf8_length &lt; (int) sizeof(stack_buf)) {
      char* chars = stack_buf;
      UNICODE::convert_to_utf8(name, utf16_length, chars);
<span class="line-new-header">--- 405,45 ---</span>
    }
  };
  
  Symbol* SymbolTable::do_lookup(const char* name, int len, uintx hash) {
    Thread* thread = Thread::current();
<span class="line-modified">!   SymbolTableLookup lookup(name, len, hash);</span>
    SymbolTableGet stg;
    bool rehash_warning = false;
    _local_table-&gt;get(thread, lookup, stg, &amp;rehash_warning);
    update_needs_rehash(rehash_warning);
    Symbol* sym = stg.get_res_sym();
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);
    return sym;
  }
  
  Symbol* SymbolTable::lookup_only(const char* name, int len, unsigned int&amp; hash) {
<span class="line-modified">!   hash = hash_symbol(name, len, _alt_hash);</span>
<span class="line-modified">!   return lookup_common(name, len, hash);</span>
  }
  
  // Suggestion: Push unicode-based lookup all the way into the hashing
  // and probing logic, so there is no need for convert_to_utf8 until
  // an actual new Symbol* is created.
<span class="line-modified">! Symbol* SymbolTable::new_symbol(const jchar* name, int utf16_length) {</span>
    int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
    char stack_buf[ON_STACK_BUFFER_LENGTH];
    if (utf8_length &lt; (int) sizeof(stack_buf)) {
      char* chars = stack_buf;
      UNICODE::convert_to_utf8(name, utf16_length, chars);
<span class="line-modified">!     return new_symbol(chars, utf8_length);</span>
    } else {
<span class="line-modified">!     ResourceMark rm;</span>
      char* chars = NEW_RESOURCE_ARRAY(char, utf8_length + 1);
      UNICODE::convert_to_utf8(name, utf16_length, chars);
<span class="line-modified">!     return new_symbol(chars, utf8_length);</span>
    }
  }
  
  Symbol* SymbolTable::lookup_only_unicode(const jchar* name, int utf16_length,
<span class="line-modified">!                                          unsigned int&amp; hash) {</span>
    int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);
    char stack_buf[ON_STACK_BUFFER_LENGTH];
    if (utf8_length &lt; (int) sizeof(stack_buf)) {
      char* chars = stack_buf;
      UNICODE::convert_to_utf8(name, utf16_length, chars);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,37 ***</span>
    }
  }
  
  void SymbolTable::new_symbols(ClassLoaderData* loader_data, const constantPoolHandle&amp; cp,
                                int names_count, const char** names, int* lengths,
<span class="line-modified">!                               int* cp_indices, unsigned int* hashValues, TRAPS) {</span>
    bool c_heap = !loader_data-&gt;is_the_null_class_loader_data();
    for (int i = 0; i &lt; names_count; i++) {
      const char *name = names[i];
      int len = lengths[i];
      unsigned int hash = hashValues[i];
<span class="line-modified">!     assert(SymbolTable::the_table()-&gt;lookup_shared(name, len, hash) == NULL, &quot;must have checked already&quot;);</span>
<span class="line-modified">!     Symbol* sym = SymbolTable::the_table()-&gt;do_add_if_needed(name, len, hash, c_heap, CHECK);</span>
      assert(sym-&gt;refcount() != 0, &quot;lookup should have incremented the count&quot;);
      cp-&gt;symbol_at_put(cp_indices[i], sym);
    }
  }
  
<span class="line-modified">! Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool heap, TRAPS) {</span>
<span class="line-modified">!   SymbolTableLookup lookup(THREAD, name, len, hash);</span>
    SymbolTableGet stg;
    bool clean_hint = false;
    bool rehash_warning = false;
    Symbol* sym = NULL;
  
    do {
<span class="line-modified">!     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-modified">!       sym = stg.get_res_sym();</span>
        break;
      }
<span class="line-modified">!     sym = SymbolTable::the_table()-&gt;allocate_symbol(name, len, heap, THREAD);</span>
<span class="line-modified">!     if (_local_table-&gt;insert(THREAD, lookup, sym, &amp;rehash_warning, &amp;clean_hint)) {</span>
        break;
      }
    } while(true);
  
    update_needs_rehash(rehash_warning);
<span class="line-new-header">--- 456,41 ---</span>
    }
  }
  
  void SymbolTable::new_symbols(ClassLoaderData* loader_data, const constantPoolHandle&amp; cp,
                                int names_count, const char** names, int* lengths,
<span class="line-modified">!                               int* cp_indices, unsigned int* hashValues) {</span>
    bool c_heap = !loader_data-&gt;is_the_null_class_loader_data();
    for (int i = 0; i &lt; names_count; i++) {
      const char *name = names[i];
      int len = lengths[i];
      unsigned int hash = hashValues[i];
<span class="line-modified">!     assert(lookup_shared(name, len, hash) == NULL, &quot;must have checked already&quot;);</span>
<span class="line-modified">!     Symbol* sym = do_add_if_needed(name, len, hash, c_heap);</span>
      assert(sym-&gt;refcount() != 0, &quot;lookup should have incremented the count&quot;);
      cp-&gt;symbol_at_put(cp_indices[i], sym);
    }
  }
  
<span class="line-modified">! Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool heap) {</span>
<span class="line-modified">!   SymbolTableLookup lookup(name, len, hash);</span>
    SymbolTableGet stg;
    bool clean_hint = false;
    bool rehash_warning = false;
    Symbol* sym = NULL;
<span class="line-added">+   Thread* THREAD = Thread::current();</span>
  
    do {
<span class="line-modified">!     // Callers have looked up the symbol once, insert the symbol.</span>
<span class="line-modified">!     sym = allocate_symbol(name, len, heap);</span>
<span class="line-added">+     if (_local_table-&gt;insert(THREAD, lookup, sym, &amp;rehash_warning, &amp;clean_hint)) {</span>
        break;
      }
<span class="line-modified">!     // In case another thread did a concurrent add, return value already in the table.</span>
<span class="line-modified">!     // This could fail if the symbol got deleted concurrently, so loop back until success.</span>
<span class="line-added">+     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {</span>
<span class="line-added">+       sym = stg.get_res_sym();</span>
        break;
      }
    } while(true);
  
    update_needs_rehash(rehash_warning);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,16 ***</span>
  
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::new_permanent_symbol(const char* name, TRAPS) {</span>
    unsigned int hash = 0;
    int len = (int)strlen(name);
    Symbol* sym = SymbolTable::lookup_only(name, len, hash);
    if (sym == NULL) {
<span class="line-modified">!     sym = SymbolTable::the_table()-&gt;do_add_if_needed(name, len, hash, false, CHECK_NULL);</span>
    }
    if (!sym-&gt;is_permanent()) {
      sym-&gt;make_permanent();
      log_trace_symboltable_helper(sym, &quot;Asked for a permanent symbol, but got a regular one&quot;);
    }
<span class="line-new-header">--- 502,16 ---</span>
  
    assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);
    return sym;
  }
  
<span class="line-modified">! Symbol* SymbolTable::new_permanent_symbol(const char* name) {</span>
    unsigned int hash = 0;
    int len = (int)strlen(name);
    Symbol* sym = SymbolTable::lookup_only(name, len, hash);
    if (sym == NULL) {
<span class="line-modified">!     sym = do_add_if_needed(name, len, hash, false);</span>
    }
    if (!sym-&gt;is_permanent()) {
      sym-&gt;make_permanent();
      log_trace_symboltable_helper(sym, &quot;Asked for a permanent symbol, but got a regular one&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,10 ***</span>
<span class="line-new-header">--- 524,17 ---</span>
      assert(*value != NULL, &quot;value should point to a symbol&quot;);
      return (*value)-&gt;size() * HeapWordSize;
    };
  };
  
<span class="line-added">+ TableStatistics SymbolTable::get_table_statistics() {</span>
<span class="line-added">+   static TableStatistics ts;</span>
<span class="line-added">+   SizeFunc sz;</span>
<span class="line-added">+   ts = _local_table-&gt;statistics_get(Thread::current(), sz, ts);</span>
<span class="line-added">+   return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void SymbolTable::print_table_statistics(outputStream* st,
                                           const char* table_name) {
    SizeFunc sz;
    _local_table-&gt;statistics_to(Thread::current(), sz, st, table_name);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,12 ***</span>
  };
  
  void SymbolTable::verify() {
    Thread* thr = Thread::current();
    VerifySymbols vs;
<span class="line-modified">!   if (!SymbolTable::the_table()-&gt;_local_table-&gt;try_scan(thr, vs)) {</span>
<span class="line-modified">!     log_info(stringtable)(&quot;verify unavailable at this moment&quot;);</span>
    }
  }
  
  // Dumping
  class DumpSymbol : StackObj {
<span class="line-new-header">--- 553,12 ---</span>
  };
  
  void SymbolTable::verify() {
    Thread* thr = Thread::current();
    VerifySymbols vs;
<span class="line-modified">!   if (!_local_table-&gt;try_scan(thr, vs)) {</span>
<span class="line-modified">!     log_info(symboltable)(&quot;verify unavailable at this moment&quot;);</span>
    }
  }
  
  // Dumping
  class DumpSymbol : StackObj {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,17 ***</span>
    };
  };
  
  void SymbolTable::dump(outputStream* st, bool verbose) {
    if (!verbose) {
<span class="line-modified">!     SymbolTable::the_table()-&gt;print_table_statistics(st, &quot;SymbolTable&quot;);</span>
    } else {
      Thread* thr = Thread::current();
      ResourceMark rm(thr);
      st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
      DumpSymbol ds(thr, st);
<span class="line-modified">!     if (!SymbolTable::the_table()-&gt;_local_table-&gt;try_scan(thr, ds)) {</span>
        log_info(symboltable)(&quot;dump unavailable at this moment&quot;);
      }
    }
  }
  
<span class="line-new-header">--- 579,17 ---</span>
    };
  };
  
  void SymbolTable::dump(outputStream* st, bool verbose) {
    if (!verbose) {
<span class="line-modified">!     print_table_statistics(st, &quot;SymbolTable&quot;);</span>
    } else {
      Thread* thr = Thread::current();
      ResourceMark rm(thr);
      st-&gt;print_cr(&quot;VERSION: 1.1&quot;);
      DumpSymbol ds(thr, st);
<span class="line-modified">!     if (!_local_table-&gt;try_scan(thr, ds)) {</span>
        log_info(symboltable)(&quot;dump unavailable at this moment&quot;);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,44 ***</span>
      assert(*value != NULL, &quot;value should point to a symbol&quot;);
      Symbol* sym = *value;
      unsigned int fixed_hash = hash_shared_symbol((const char*)sym-&gt;bytes(), sym-&gt;utf8_length());
      assert(fixed_hash == hash_symbol((const char*)sym-&gt;bytes(), sym-&gt;utf8_length(), false),
             &quot;must not rehash during dumping&quot;);
      _writer-&gt;add(fixed_hash, MetaspaceShared::object_delta_u4(sym));
      return true;
    }
  };
  
  void SymbolTable::copy_shared_symbol_table(CompactHashtableWriter* writer) {
    CopyToArchive copy(writer);
<span class="line-modified">!   SymbolTable::the_table()-&gt;_local_table-&gt;do_safepoint_scan(copy);</span>
  }
  
<span class="line-modified">! void SymbolTable::write_to_archive() {</span>
<span class="line-modified">!   _shared_table.reset();</span>
  
<span class="line-modified">!   int num_buckets = CompactHashtableWriter::default_num_buckets(</span>
<span class="line-modified">!       SymbolTable::the_table()-&gt;_items_count);</span>
<span class="line-removed">-   CompactHashtableWriter writer(num_buckets,</span>
                                  &amp;MetaspaceShared::stats()-&gt;symbol);
    copy_shared_symbol_table(&amp;writer);
<span class="line-modified">!   writer.dump(&amp;_shared_table, &quot;symbol&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Verify table is correct</span>
<span class="line-modified">!   Symbol* sym = vmSymbols::java_lang_Object();</span>
<span class="line-modified">!   const char* name = (const char*)sym-&gt;bytes();</span>
<span class="line-modified">!   int len = sym-&gt;utf8_length();</span>
<span class="line-modified">!   unsigned int hash = hash_symbol(name, len, SymbolTable::_alt_hash);</span>
<span class="line-modified">!   assert(sym == _shared_table.lookup(name, hash, len), &quot;sanity&quot;);</span>
  }
  
<span class="line-modified">! void SymbolTable::serialize_shared_table_header(SerializeClosure* soc) {</span>
<span class="line-modified">!   _shared_table.serialize_header(soc);</span>
<span class="line-modified">! </span>
    if (soc-&gt;writing()) {
      // Sanity. Make sure we don&#39;t use the shared table at dump time
<span class="line-modified">!     _shared_table.reset();</span>
    }
  }
  #endif //INCLUDE_CDS
  
  // Concurrent work
<span class="line-new-header">--- 602,59 ---</span>
      assert(*value != NULL, &quot;value should point to a symbol&quot;);
      Symbol* sym = *value;
      unsigned int fixed_hash = hash_shared_symbol((const char*)sym-&gt;bytes(), sym-&gt;utf8_length());
      assert(fixed_hash == hash_symbol((const char*)sym-&gt;bytes(), sym-&gt;utf8_length(), false),
             &quot;must not rehash during dumping&quot;);
<span class="line-added">+     if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+       sym = DynamicArchive::original_to_target(sym);</span>
<span class="line-added">+     }</span>
      _writer-&gt;add(fixed_hash, MetaspaceShared::object_delta_u4(sym));
      return true;
    }
  };
  
  void SymbolTable::copy_shared_symbol_table(CompactHashtableWriter* writer) {
    CopyToArchive copy(writer);
<span class="line-modified">!   _local_table-&gt;do_safepoint_scan(copy);</span>
  }
  
<span class="line-modified">! size_t SymbolTable::estimate_size_for_archive() {</span>
<span class="line-modified">!   return CompactHashtableWriter::estimate_size(int(_items_count));</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void SymbolTable::write_to_archive(bool is_static_archive) {</span>
<span class="line-modified">!   CompactHashtableWriter writer(int(_items_count),</span>
                                  &amp;MetaspaceShared::stats()-&gt;symbol);
    copy_shared_symbol_table(&amp;writer);
<span class="line-modified">!   if (is_static_archive) {</span>
<span class="line-modified">!     _shared_table.reset();</span>
<span class="line-modified">!     writer.dump(&amp;_shared_table, &quot;symbol&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Verify table is correct</span>
<span class="line-modified">!     Symbol* sym = vmSymbols::java_lang_Object();</span>
<span class="line-modified">!     const char* name = (const char*)sym-&gt;bytes();</span>
<span class="line-modified">!     int len = sym-&gt;utf8_length();</span>
<span class="line-added">+     unsigned int hash = hash_symbol(name, len, _alt_hash);</span>
<span class="line-added">+     assert(sym == _shared_table.lookup(name, hash, len), &quot;sanity&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _dynamic_shared_table.reset();</span>
<span class="line-added">+     writer.dump(&amp;_dynamic_shared_table, &quot;symbol&quot;);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void SymbolTable::serialize_shared_table_header(SerializeClosure* soc,</span>
<span class="line-modified">!                                                 bool is_static_archive) {</span>
<span class="line-modified">!   OffsetCompactHashtable&lt;const char*, Symbol*, symbol_equals_compact_hashtable_entry&gt; * table;</span>
<span class="line-added">+   if (is_static_archive) {</span>
<span class="line-added">+     table = &amp;_shared_table;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     table = &amp;_dynamic_shared_table;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   table-&gt;serialize_header(soc);</span>
    if (soc-&gt;writing()) {
      // Sanity. Make sure we don&#39;t use the shared table at dump time
<span class="line-modified">!     table-&gt;reset();</span>
    }
  }
  #endif //INCLUDE_CDS
  
  // Concurrent work
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,15 ***</span>
        {
          ThreadBlockInVM tbivm(jt);
        }
        bdt.cont(jt);
      }
<span class="line-modified">!     SymbolTable::the_table()-&gt;reset_has_items_to_clean();</span>
      bdt.done(jt);
    }
  
<span class="line-modified">!   Atomic::add(stdc._processed, &amp;_symbols_counted);</span>
  
    log_debug(symboltable)(&quot;Cleaned &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT,
                           stdd._deleted, stdc._processed);
  }
  
<span class="line-new-header">--- 718,15 ---</span>
        {
          ThreadBlockInVM tbivm(jt);
        }
        bdt.cont(jt);
      }
<span class="line-modified">!     reset_has_items_to_clean();</span>
      bdt.done(jt);
    }
  
<span class="line-modified">!   Atomic::add(&amp;_symbols_counted, stdc._processed);</span>
  
    log_debug(symboltable)(&quot;Cleaned &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT,
                           stdd._deleted, stdc._processed);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,11 ***</span>
                             get_load_factor(), has_items_to_clean() ? &quot;true&quot; : &quot;false&quot;);
      trigger_cleanup();
    }
  }
  
<span class="line-modified">! void SymbolTable::concurrent_work(JavaThread* jt) {</span>
    double load_factor = get_load_factor();
    log_debug(symboltable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
    // We prefer growing, since that also removes dead items
    if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
      grow(jt);
<span class="line-new-header">--- 742,11 ---</span>
                             get_load_factor(), has_items_to_clean() ? &quot;true&quot; : &quot;false&quot;);
      trigger_cleanup();
    }
  }
  
<span class="line-modified">! void SymbolTable::do_concurrent_work(JavaThread* jt) {</span>
    double load_factor = get_load_factor();
    log_debug(symboltable, perf)(&quot;Concurrent work, live factor: %g&quot;, load_factor);
    // We prefer growing, since that also removes dead items
    if (load_factor &gt; PREF_AVG_LIST_LEN &amp;&amp; !_local_table-&gt;is_max_size_reached()) {
      grow(jt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 708,22 ***</span>
      clean_dead_entries(jt);
    }
    _has_work = false;
  }
  
<span class="line-removed">- void SymbolTable::do_concurrent_work(JavaThread* jt) {</span>
<span class="line-removed">-   SymbolTable::the_table()-&gt;concurrent_work(jt);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Rehash
  bool SymbolTable::do_rehash() {
    if (!_local_table-&gt;is_safepoint_safe()) {
      return false;
    }
  
<span class="line-modified">!   // We use max size</span>
<span class="line-modified">!   SymbolTableHash* new_table = new SymbolTableHash(END_SIZE, END_SIZE, REHASH_LEN);</span>
    // Use alt hash from now on
    _alt_hash = true;
    if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
      _alt_hash = false;
      delete new_table;
<span class="line-new-header">--- 754,19 ---</span>
      clean_dead_entries(jt);
    }
    _has_work = false;
  }
  
  // Rehash
  bool SymbolTable::do_rehash() {
    if (!_local_table-&gt;is_safepoint_safe()) {
      return false;
    }
  
<span class="line-modified">!   // We use current size</span>
<span class="line-modified">!   size_t new_size = _local_table-&gt;get_size_log2(Thread::current());</span>
<span class="line-added">+   SymbolTableHash* new_table = new SymbolTableHash(new_size, END_SIZE, REHASH_LEN);</span>
    // Use alt hash from now on
    _alt_hash = true;
    if (!_local_table-&gt;try_move_nodes_to(Thread::current(), new_table)) {
      _alt_hash = false;
      delete new_table;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
    _local_table = new_table;
  
    return true;
  }
  
<span class="line-modified">! void SymbolTable::try_rehash_table() {</span>
    static bool rehashed = false;
    log_debug(symboltable)(&quot;Table imbalanced, rehashing called.&quot;);
  
    // Grow instead of rehash.
    if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
<span class="line-new-header">--- 778,11 ---</span>
    _local_table = new_table;
  
    return true;
  }
  
<span class="line-modified">! void SymbolTable::rehash_table() {</span>
    static bool rehashed = false;
    log_debug(symboltable)(&quot;Table imbalanced, rehashing called.&quot;);
  
    // Grow instead of rehash.
    if (get_load_factor() &gt; PREF_AVG_LIST_LEN &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,14 ***</span>
    }
  
    _needs_rehashing = false;
  }
  
<span class="line-removed">- void SymbolTable::rehash_table() {</span>
<span class="line-removed">-   SymbolTable::the_table()-&gt;try_rehash_table();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //---------------------------------------------------------------------------
  // Non-product code
  
  #ifndef PRODUCT
  
<span class="line-new-header">--- 810,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 818,22 ***</span>
      return true;
    };
  };
  
  void SymbolTable::print_histogram() {
<span class="line-removed">-   SymbolTable* st = SymbolTable::the_table();</span>
    HistogramIterator hi;
<span class="line-modified">!   st-&gt;_local_table-&gt;do_scan(Thread::current(), hi);</span>
    tty-&gt;print_cr(&quot;Symbol Table Histogram:&quot;);
    tty-&gt;print_cr(&quot;  Total number of symbols  &quot; SIZE_FORMAT_W(7), hi.total_count);
    tty-&gt;print_cr(&quot;  Total size in memory     &quot; SIZE_FORMAT_W(7) &quot;K&quot;,
            (hi.total_size * wordSize) / 1024);
<span class="line-modified">!   tty-&gt;print_cr(&quot;  Total counted            &quot; SIZE_FORMAT_W(7), st-&gt;_symbols_counted);</span>
<span class="line-modified">!   tty-&gt;print_cr(&quot;  Total removed            &quot; SIZE_FORMAT_W(7), st-&gt;_symbols_removed);</span>
<span class="line-modified">!   if (SymbolTable::the_table()-&gt;_symbols_counted &gt; 0) {</span>
      tty-&gt;print_cr(&quot;  Percent removed          %3.2f&quot;,
<span class="line-modified">!           ((float)st-&gt;_symbols_removed / st-&gt;_symbols_counted) * 100);</span>
    }
    tty-&gt;print_cr(&quot;  Reference counts         &quot; SIZE_FORMAT_W(7), Symbol::_total_count);
    tty-&gt;print_cr(&quot;  Symbol arena used        &quot; SIZE_FORMAT_W(7) &quot;K&quot;, arena()-&gt;used() / 1024);
    tty-&gt;print_cr(&quot;  Symbol arena size        &quot; SIZE_FORMAT_W(7) &quot;K&quot;, arena()-&gt;size_in_bytes() / 1024);
    tty-&gt;print_cr(&quot;  Total symbol length      &quot; SIZE_FORMAT_W(7), hi.total_length);
<span class="line-new-header">--- 857,21 ---</span>
      return true;
    };
  };
  
  void SymbolTable::print_histogram() {
    HistogramIterator hi;
<span class="line-modified">!   _local_table-&gt;do_scan(Thread::current(), hi);</span>
    tty-&gt;print_cr(&quot;Symbol Table Histogram:&quot;);
    tty-&gt;print_cr(&quot;  Total number of symbols  &quot; SIZE_FORMAT_W(7), hi.total_count);
    tty-&gt;print_cr(&quot;  Total size in memory     &quot; SIZE_FORMAT_W(7) &quot;K&quot;,
            (hi.total_size * wordSize) / 1024);
<span class="line-modified">!   tty-&gt;print_cr(&quot;  Total counted            &quot; SIZE_FORMAT_W(7), _symbols_counted);</span>
<span class="line-modified">!   tty-&gt;print_cr(&quot;  Total removed            &quot; SIZE_FORMAT_W(7), _symbols_removed);</span>
<span class="line-modified">!   if (_symbols_counted &gt; 0) {</span>
      tty-&gt;print_cr(&quot;  Percent removed          %3.2f&quot;,
<span class="line-modified">!           ((float)_symbols_removed / _symbols_counted) * 100);</span>
    }
    tty-&gt;print_cr(&quot;  Reference counts         &quot; SIZE_FORMAT_W(7), Symbol::_total_count);
    tty-&gt;print_cr(&quot;  Symbol arena used        &quot; SIZE_FORMAT_W(7) &quot;K&quot;, arena()-&gt;used() / 1024);
    tty-&gt;print_cr(&quot;  Symbol arena size        &quot; SIZE_FORMAT_W(7) &quot;K&quot;, arena()-&gt;size_in_bytes() / 1024);
    tty-&gt;print_cr(&quot;  Total symbol length      &quot; SIZE_FORMAT_W(7), hi.total_length);
</pre>
<center><a href="stringTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbolTable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
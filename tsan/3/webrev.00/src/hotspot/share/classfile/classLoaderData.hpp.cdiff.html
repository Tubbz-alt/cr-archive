<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classLoaderData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/memRegion.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;oops/oopHandle.hpp&quot;
  #include &quot;oops/weakHandle.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #if INCLUDE_JFR
  #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
  
    // Remembered sets support for the oops in the class loader data.
    bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
    bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
  
<span class="line-modified">!   s2 _keep_alive;          // if this CLD is kept alive.</span>
                             // Used for unsafe anonymous classes and the boot class
                             // loader. _keep_alive does not need to be volatile or
                             // atomic since there is one unique CLD per unsafe anonymous class.
  
    volatile int _claim; // non-zero if claimed, for example during GC traces.
<span class="line-new-header">--- 122,11 ---</span>
  
    // Remembered sets support for the oops in the class loader data.
    bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
    bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
  
<span class="line-modified">!   int _keep_alive;         // if this CLD is kept alive.</span>
                             // Used for unsafe anonymous classes and the boot class
                             // loader. _keep_alive does not need to be volatile or
                             // atomic since there is one unique CLD per unsafe anonymous class.
  
    volatile int _claim; // non-zero if claimed, for example during GC traces.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
    Symbol* _name;
    Symbol* _name_and_id;
    JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
  
    void set_next(ClassLoaderData* next) { _next = next; }
<span class="line-modified">!   ClassLoaderData* next() const        { return _next; }</span>
  
    ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous);
    ~ClassLoaderData();
  
    // The CLD are not placed in the Heap, so the Card Table or
<span class="line-new-header">--- 158,11 ---</span>
    Symbol* _name;
    Symbol* _name_and_id;
    JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
  
    void set_next(ClassLoaderData* next) { _next = next; }
<span class="line-modified">!   ClassLoaderData* next() const        { return Atomic::load(&amp;_next); }</span>
  
    ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous);
    ~ClassLoaderData();
  
    // The CLD are not placed in the Heap, so the Card Table or
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,20 ***</span>
   public:
    // GC interface.
  
    // The &quot;claim&quot; is typically used to check if oops_do needs to be applied on
    // the CLD or not. Most GCs only perform strong marking during the marking phase.
<span class="line-modified">!   enum {</span>
<span class="line-modified">!     _claim_none        = 0,</span>
<span class="line-modified">!     _claim_finalizable = 2,</span>
<span class="line-modified">!     _claim_strong      = 3</span>
    };
    void clear_claim() { _claim = 0; }
    bool claimed() const { return _claim != 0; }
    bool try_claim(int claim);
<span class="line-removed">-   int get_claim() const { return _claim; }</span>
<span class="line-removed">-   void set_claim(int claim) { _claim = claim; }</span>
  
    // Computes if the CLD is alive or not. This is safe to call in concurrent
    // contexts.
    bool is_alive() const;
  
<span class="line-new-header">--- 204,21 ---</span>
   public:
    // GC interface.
  
    // The &quot;claim&quot; is typically used to check if oops_do needs to be applied on
    // the CLD or not. Most GCs only perform strong marking during the marking phase.
<span class="line-modified">!   enum Claim {</span>
<span class="line-modified">!     _claim_none         = 0,</span>
<span class="line-modified">!     _claim_finalizable  = 2,</span>
<span class="line-modified">!     _claim_strong       = 3,</span>
<span class="line-added">+     _claim_other        = 4</span>
    };
    void clear_claim() { _claim = 0; }
<span class="line-added">+   void clear_claim(int claim);</span>
    bool claimed() const { return _claim != 0; }
<span class="line-added">+   bool claimed(int claim) const { return (_claim &amp; claim) == claim; }</span>
    bool try_claim(int claim);
  
    // Computes if the CLD is alive or not. This is safe to call in concurrent
    // contexts.
    bool is_alive() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,13 ***</span>
    Klass* klasses() { return _klasses; }
  
    JNIMethodBlock* jmethod_ids() const              { return _jmethod_ids; }
    void set_jmethod_ids(JNIMethodBlock* new_block)  { _jmethod_ids = new_block; }
  
<span class="line-modified">!   void print()                                     { print_on(tty); }</span>
    void print_on(outputStream* out) const PRODUCT_RETURN;
<span class="line-modified">!   void print_value()                               { print_value_on(tty); }</span>
    void print_value_on(outputStream* out) const;
    void verify();
  
    OopHandle add_handle(Handle h);
    void remove_handle(OopHandle h);
<span class="line-new-header">--- 282,13 ---</span>
    Klass* klasses() { return _klasses; }
  
    JNIMethodBlock* jmethod_ids() const              { return _jmethod_ids; }
    void set_jmethod_ids(JNIMethodBlock* new_block)  { _jmethod_ids = new_block; }
  
<span class="line-modified">!   void print() const;</span>
    void print_on(outputStream* out) const PRODUCT_RETURN;
<span class="line-modified">!   void print_value() const;</span>
    void print_value_on(outputStream* out) const;
    void verify();
  
    OopHandle add_handle(Handle h);
    void remove_handle(OopHandle h);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,10 ***</span>
<span class="line-new-header">--- 300,14 ---</span>
    PackageEntryTable* packages() { return _packages; }
    ModuleEntry* unnamed_module() { return _unnamed_module; }
    ModuleEntryTable* modules();
    bool modules_defined() { return (_modules != NULL); }
  
<span class="line-added">+   // Offsets</span>
<span class="line-added">+   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }</span>
<span class="line-added">+   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }</span>
<span class="line-added">+ </span>
    // Loaded class dictionary
    Dictionary* dictionary() const { return _dictionary; }
  
    void add_to_deallocate_list(Metadata* m);
  
</pre>
<center><a href="classLoaderData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/classfile/compactHashtable.hpp b/src/hotspot/share/classfile/compactHashtable.hpp
--- a/src/hotspot/share/classfile/compactHashtable.hpp
+++ b/src/hotspot/share/classfile/compactHashtable.hpp
@@ -98,11 +98,11 @@
       return (_value == other._value && _hash == other._hash);
     }
   }; // class CompactHashtableWriter::Entry
 
 private:
-  int _num_entries;
+  int _num_entries_written;
   int _num_buckets;
   int _num_empty_buckets;
   int _num_value_only_buckets;
   int _num_other_buckets;
   GrowableArray<Entry>** _buckets;
@@ -110,30 +110,28 @@
   Array<u4>* _compact_buckets;
   Array<u4>* _compact_entries;
 
 public:
   // This is called at dump-time only
-  CompactHashtableWriter(int num_buckets, CompactHashtableStats* stats);
+  CompactHashtableWriter(int num_entries, CompactHashtableStats* stats);
   ~CompactHashtableWriter();
 
   void add(unsigned int hash, u4 value);
 
 private:
   void allocate_table();
   void dump_table(NumberSeq* summary);
-
-public:
-  void dump(SimpleCompactHashtable *cht, const char* table_name);
-
-  static int default_num_buckets(size_t num_entries) {
-    return default_num_buckets((int)num_entries);
-  }
-  static int default_num_buckets(int num_entries) {
+  static int calculate_num_buckets(int num_entries) {
     int num_buckets = num_entries / SharedSymbolTableBucketSize;
     // calculation of num_buckets can result in zero buckets, we need at least one
     return (num_buckets < 1) ? 1 : num_buckets;
   }
+
+public:
+  void dump(SimpleCompactHashtable *cht, const char* table_name);
+
+  static size_t estimate_size(int num_entries);
 };
 #endif // INCLUDE_CDS
 
 #define REGULAR_BUCKET_TYPE       0
 #define VALUE_ONLY_BUCKET_TYPE    1
@@ -212,24 +210,20 @@
     _entry_count = 0;
     _buckets = 0;
     _entries = 0;
   }
 
-  void init(address base_address, u4 entry_count, u4 bucket_count, u4* buckets, u4* entries) {
-    _base_address = base_address;
-    _bucket_count = bucket_count;
-    _entry_count = entry_count;
-    _buckets = buckets;
-    _entries = entries;
-  }
+  void init(address base_address, u4 entry_count, u4 bucket_count, u4* buckets, u4* entries);
 
   // Read/Write the table's header from/to the CDS archive
   void serialize_header(SerializeClosure* soc) NOT_CDS_RETURN;
 
   inline bool empty() {
     return (_entry_count == 0);
   }
+
+  static size_t calculate_header_size();
 };
 
 template <
   typename K,
   typename V,

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="tsanIgnoreList.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
 27 
 28 #include &quot;oops/klass.hpp&quot;
 29 #include &quot;classfile/dictionary.hpp&quot;

 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/filemap.hpp&quot;
 32 
 33 
 34 /*===============================================================================
 35 
 36     Handling of the classes in the AppCDS archive
 37 
 38     To ensure safety and to simplify the implementation, archived classes are
 39     &quot;segregated&quot; into 2 types. The following rules describe how they
 40     are stored and looked up.
 41 
 42 [1] Category of archived classes
 43 
 44     There are 2 disjoint groups of classes stored in the AppCDS archive:
 45 
 46     BUILTIN:              These classes may be defined ONLY by the BOOT/PLATFORM/APP
 47                           loaders.
 48 
 49     UNREGISTERED:         These classes may be defined ONLY by a ClassLoader
</pre>
<hr />
<pre>
 91 
 92     (a) BUILTIN loaders:
 93 
 94         search _builtin_dictionary
 95 
 96     (b) UNREGISTERED loaders:
 97 
 98         search _unregistered_dictionary for an entry that matches the
 99         (name, clsfile_len, clsfile_crc32).
100 
101 ===============================================================================*/
102 #define UNREGISTERED_INDEX -9999
103 
104 class ClassFileStream;
105 class DumpTimeSharedClassInfo;
106 class DumpTimeSharedClassTable;
107 class RunTimeSharedClassInfo;
108 class RunTimeSharedDictionary;
109 
110 class SystemDictionaryShared: public SystemDictionary {

111 public:
112   enum {
113     FROM_FIELD_IS_PROTECTED = 1 &lt;&lt; 0,
114     FROM_IS_ARRAY           = 1 &lt;&lt; 1,
115     FROM_IS_OBJECT          = 1 &lt;&lt; 2
116   };
117 
118 private:
119   // These _shared_xxxs arrays are used to initialize the java.lang.Package and
120   // java.security.ProtectionDomain objects associated with each shared class.
121   //
122   // See SystemDictionaryShared::init_security_info for more info.
123   static objArrayOop _shared_protection_domains;
124   static objArrayOop _shared_jar_urls;
125   static objArrayOop _shared_jar_manifests;
126 
127   static InstanceKlass* load_shared_class_for_builtin_loader(
128                                                Symbol* class_name,
129                                                Handle class_loader,
130                                                TRAPS);
</pre>
<hr />
<pre>
193     atomic_set_array_index(_shared_protection_domains, index, pd);
194   }
195   static void allocate_shared_protection_domain_array(int size, TRAPS);
196   static oop shared_jar_url(int index);
197   static void atomic_set_shared_jar_url(int index, oop url) {
198     atomic_set_array_index(_shared_jar_urls, index, url);
199   }
200   static void allocate_shared_jar_url_array(int size, TRAPS);
201   static oop shared_jar_manifest(int index);
202   static void atomic_set_shared_jar_manifest(int index, oop man) {
203     atomic_set_array_index(_shared_jar_manifests, index, man);
204   }
205   static void allocate_shared_jar_manifest_array(int size, TRAPS);
206   static InstanceKlass* acquire_class_for_current_thread(
207                                  InstanceKlass *ik,
208                                  Handle class_loader,
209                                  Handle protection_domain,
210                                  const ClassFileStream* cfs,
211                                  TRAPS);
212   static DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k);
<span class="line-modified">213   static void write_dictionary(RunTimeSharedDictionary* dictionary, bool is_builtin);</span>


214   static bool is_jfr_event_class(InstanceKlass *k);
215   static void warn_excluded(InstanceKlass* k, const char* reason);

216 
<span class="line-modified">217   DEBUG_ONLY(static bool _checked_excluded_classes;)</span>
218 public:
219   static InstanceKlass* find_builtin_class(Symbol* class_name);
220 
<span class="line-modified">221   static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* dict, Symbol* name);</span>




222 
223   // Called by PLATFORM/APP loader only
224   static InstanceKlass* find_or_load_shared_class(Symbol* class_name,
225                                                Handle class_loader,
226                                                TRAPS);
227 
228 
229   static void allocate_shared_data_arrays(int size, TRAPS);
230   static void oops_do(OopClosure* f);
231 
232   // Check if sharing is supported for the class loader.
233   static bool is_sharing_possible(ClassLoaderData* loader_data);
234   static bool is_shared_class_visible_for_classloader(InstanceKlass* ik,
235                                                       Handle class_loader,
<span class="line-removed">236                                                       const char* pkg_string,</span>
237                                                       Symbol* pkg_name,
238                                                       PackageEntry* pkg_entry,
239                                                       ModuleEntry* mod_entry,
240                                                       TRAPS);
241   static PackageEntry* get_package_entry(Symbol* pkg,
242                                          ClassLoaderData *loader_data) {
243     if (loader_data != NULL) {
244       PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
245       return pkgEntryTable-&gt;lookup_only(pkg);
246     }
247     return NULL;
248   }
249 
250   static bool add_unregistered_class(InstanceKlass* k, TRAPS);
251   static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,
252                                                 Symbol* class_name,
253                                                 Handle class_loader,
254                                                 Handle protection_domain,
255                                                 bool is_superclass,
256                                                 TRAPS);
</pre>
<hr />
<pre>
270                                            Handle protection_domain,
271                                            const ClassFileStream* st,
272                                            TRAPS);
273   // &quot;verification_constraints&quot; are a set of checks performed by
274   // VerificationType::is_reference_assignable_from when verifying a shared class during
275   // dump time.
276   //
277   // With AppCDS, it is possible to override archived classes by calling
278   // ClassLoader.defineClass() directly. SystemDictionary::load_shared_class() already
279   // ensures that you cannot load a shared class if its super type(s) are changed. However,
280   // we need an additional check to ensure that the verification_constraints did not change
281   // between dump time and runtime.
282   static bool add_verification_constraint(InstanceKlass* k, Symbol* name,
283                   Symbol* from_name, bool from_field_is_protected,
284                   bool from_is_array, bool from_is_object) NOT_CDS_RETURN_(false);
285   static void check_verification_constraints(InstanceKlass* klass,
286                                              TRAPS) NOT_CDS_RETURN;
287   static bool is_builtin(InstanceKlass* k) {
288     return (k-&gt;shared_classpath_index() != UNREGISTERED_INDEX);
289   }
<span class="line-removed">290   static bool should_be_excluded(InstanceKlass* k);</span>
291   static void check_excluded_classes();
292   static void validate_before_archiving(InstanceKlass* k);
293   static bool is_excluded_class(InstanceKlass* k);
294   static void dumptime_classes_do(class MetaspaceClosure* it);
<span class="line-modified">295   static void write_to_archive();</span>
<span class="line-modified">296   static void serialize_dictionary_headers(class SerializeClosure* soc);</span>


297   static void print() { return print_on(tty); }
298   static void print_on(outputStream* st) NOT_CDS_RETURN;
299   static void print_table_statistics(outputStream* st) NOT_CDS_RETURN;

300 
<span class="line-modified">301   DEBUG_ONLY(static bool checked_excluded_classes() {return _checked_excluded_classes;})</span>




















302 };
303 
304 #endif // SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
 27 
 28 #include &quot;oops/klass.hpp&quot;
 29 #include &quot;classfile/dictionary.hpp&quot;
<span class="line-added"> 30 #include &quot;classfile/packageEntry.hpp&quot;</span>
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;memory/filemap.hpp&quot;
 33 
 34 
 35 /*===============================================================================
 36 
 37     Handling of the classes in the AppCDS archive
 38 
 39     To ensure safety and to simplify the implementation, archived classes are
 40     &quot;segregated&quot; into 2 types. The following rules describe how they
 41     are stored and looked up.
 42 
 43 [1] Category of archived classes
 44 
 45     There are 2 disjoint groups of classes stored in the AppCDS archive:
 46 
 47     BUILTIN:              These classes may be defined ONLY by the BOOT/PLATFORM/APP
 48                           loaders.
 49 
 50     UNREGISTERED:         These classes may be defined ONLY by a ClassLoader
</pre>
<hr />
<pre>
 92 
 93     (a) BUILTIN loaders:
 94 
 95         search _builtin_dictionary
 96 
 97     (b) UNREGISTERED loaders:
 98 
 99         search _unregistered_dictionary for an entry that matches the
100         (name, clsfile_len, clsfile_crc32).
101 
102 ===============================================================================*/
103 #define UNREGISTERED_INDEX -9999
104 
105 class ClassFileStream;
106 class DumpTimeSharedClassInfo;
107 class DumpTimeSharedClassTable;
108 class RunTimeSharedClassInfo;
109 class RunTimeSharedDictionary;
110 
111 class SystemDictionaryShared: public SystemDictionary {
<span class="line-added">112   friend class ExcludeDumpTimeSharedClasses;</span>
113 public:
114   enum {
115     FROM_FIELD_IS_PROTECTED = 1 &lt;&lt; 0,
116     FROM_IS_ARRAY           = 1 &lt;&lt; 1,
117     FROM_IS_OBJECT          = 1 &lt;&lt; 2
118   };
119 
120 private:
121   // These _shared_xxxs arrays are used to initialize the java.lang.Package and
122   // java.security.ProtectionDomain objects associated with each shared class.
123   //
124   // See SystemDictionaryShared::init_security_info for more info.
125   static objArrayOop _shared_protection_domains;
126   static objArrayOop _shared_jar_urls;
127   static objArrayOop _shared_jar_manifests;
128 
129   static InstanceKlass* load_shared_class_for_builtin_loader(
130                                                Symbol* class_name,
131                                                Handle class_loader,
132                                                TRAPS);
</pre>
<hr />
<pre>
195     atomic_set_array_index(_shared_protection_domains, index, pd);
196   }
197   static void allocate_shared_protection_domain_array(int size, TRAPS);
198   static oop shared_jar_url(int index);
199   static void atomic_set_shared_jar_url(int index, oop url) {
200     atomic_set_array_index(_shared_jar_urls, index, url);
201   }
202   static void allocate_shared_jar_url_array(int size, TRAPS);
203   static oop shared_jar_manifest(int index);
204   static void atomic_set_shared_jar_manifest(int index, oop man) {
205     atomic_set_array_index(_shared_jar_manifests, index, man);
206   }
207   static void allocate_shared_jar_manifest_array(int size, TRAPS);
208   static InstanceKlass* acquire_class_for_current_thread(
209                                  InstanceKlass *ik,
210                                  Handle class_loader,
211                                  Handle protection_domain,
212                                  const ClassFileStream* cfs,
213                                  TRAPS);
214   static DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k);
<span class="line-modified">215   static void write_dictionary(RunTimeSharedDictionary* dictionary,</span>
<span class="line-added">216                                bool is_builtin,</span>
<span class="line-added">217                                bool is_static_archive = true);</span>
218   static bool is_jfr_event_class(InstanceKlass *k);
219   static void warn_excluded(InstanceKlass* k, const char* reason);
<span class="line-added">220   static bool should_be_excluded(InstanceKlass* k);</span>
221 
<span class="line-modified">222   DEBUG_ONLY(static bool _no_class_loading_should_happen;)</span>
223 public:
224   static InstanceKlass* find_builtin_class(Symbol* class_name);
225 
<span class="line-modified">226   static const RunTimeSharedClassInfo* find_record(RunTimeSharedDictionary* static_dict,</span>
<span class="line-added">227                                                    RunTimeSharedDictionary* dynamic_dict,</span>
<span class="line-added">228                                                    Symbol* name);</span>
<span class="line-added">229 </span>
<span class="line-added">230   static bool has_platform_or_app_classes();</span>
231 
232   // Called by PLATFORM/APP loader only
233   static InstanceKlass* find_or_load_shared_class(Symbol* class_name,
234                                                Handle class_loader,
235                                                TRAPS);
236 
237 
238   static void allocate_shared_data_arrays(int size, TRAPS);
239   static void oops_do(OopClosure* f);
240 
241   // Check if sharing is supported for the class loader.
242   static bool is_sharing_possible(ClassLoaderData* loader_data);
243   static bool is_shared_class_visible_for_classloader(InstanceKlass* ik,
244                                                       Handle class_loader,

245                                                       Symbol* pkg_name,
246                                                       PackageEntry* pkg_entry,
247                                                       ModuleEntry* mod_entry,
248                                                       TRAPS);
249   static PackageEntry* get_package_entry(Symbol* pkg,
250                                          ClassLoaderData *loader_data) {
251     if (loader_data != NULL) {
252       PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
253       return pkgEntryTable-&gt;lookup_only(pkg);
254     }
255     return NULL;
256   }
257 
258   static bool add_unregistered_class(InstanceKlass* k, TRAPS);
259   static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* child_name,
260                                                 Symbol* class_name,
261                                                 Handle class_loader,
262                                                 Handle protection_domain,
263                                                 bool is_superclass,
264                                                 TRAPS);
</pre>
<hr />
<pre>
278                                            Handle protection_domain,
279                                            const ClassFileStream* st,
280                                            TRAPS);
281   // &quot;verification_constraints&quot; are a set of checks performed by
282   // VerificationType::is_reference_assignable_from when verifying a shared class during
283   // dump time.
284   //
285   // With AppCDS, it is possible to override archived classes by calling
286   // ClassLoader.defineClass() directly. SystemDictionary::load_shared_class() already
287   // ensures that you cannot load a shared class if its super type(s) are changed. However,
288   // we need an additional check to ensure that the verification_constraints did not change
289   // between dump time and runtime.
290   static bool add_verification_constraint(InstanceKlass* k, Symbol* name,
291                   Symbol* from_name, bool from_field_is_protected,
292                   bool from_is_array, bool from_is_object) NOT_CDS_RETURN_(false);
293   static void check_verification_constraints(InstanceKlass* klass,
294                                              TRAPS) NOT_CDS_RETURN;
295   static bool is_builtin(InstanceKlass* k) {
296     return (k-&gt;shared_classpath_index() != UNREGISTERED_INDEX);
297   }

298   static void check_excluded_classes();
299   static void validate_before_archiving(InstanceKlass* k);
300   static bool is_excluded_class(InstanceKlass* k);
301   static void dumptime_classes_do(class MetaspaceClosure* it);
<span class="line-modified">302   static size_t estimate_size_for_archive();</span>
<span class="line-modified">303   static void write_to_archive(bool is_static_archive = true);</span>
<span class="line-added">304   static void serialize_dictionary_headers(class SerializeClosure* soc,</span>
<span class="line-added">305                                            bool is_static_archive = true);</span>
306   static void print() { return print_on(tty); }
307   static void print_on(outputStream* st) NOT_CDS_RETURN;
308   static void print_table_statistics(outputStream* st) NOT_CDS_RETURN;
<span class="line-added">309   static bool empty_dumptime_table() NOT_CDS_RETURN_(true);</span>
310 
<span class="line-modified">311   DEBUG_ONLY(static bool no_class_loading_should_happen() {return _no_class_loading_should_happen;})</span>
<span class="line-added">312 </span>
<span class="line-added">313 #ifdef ASSERT</span>
<span class="line-added">314   class NoClassLoadingMark: public StackObj {</span>
<span class="line-added">315   public:</span>
<span class="line-added">316     NoClassLoadingMark() {</span>
<span class="line-added">317       assert(!_no_class_loading_should_happen, &quot;must not be nested&quot;);</span>
<span class="line-added">318       _no_class_loading_should_happen = true;</span>
<span class="line-added">319     }</span>
<span class="line-added">320     ~NoClassLoadingMark() {</span>
<span class="line-added">321       _no_class_loading_should_happen = false;</span>
<span class="line-added">322     }</span>
<span class="line-added">323   };</span>
<span class="line-added">324 #endif</span>
<span class="line-added">325 </span>
<span class="line-added">326   template &lt;typename T&gt;</span>
<span class="line-added">327   static unsigned int hash_for_shared_dictionary(T* ptr) {</span>
<span class="line-added">328     assert(ptr &gt; (T*)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="line-added">329     address p = address(ptr) - SharedBaseAddress;</span>
<span class="line-added">330     return primitive_hash&lt;address&gt;(p);</span>
<span class="line-added">331   }</span>
332 };
333 
334 #endif // SHARE_CLASSFILE_SYSTEMDICTIONARYSHARED_HPP
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="tsanIgnoreList.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
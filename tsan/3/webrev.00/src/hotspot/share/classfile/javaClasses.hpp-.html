<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 #include &quot;utilities/utf8.hpp&quot;
  33 
  34 // Interface for manipulating the basic Java classes.
  35 //
  36 // All dependencies on layout of actual Java classes should be kept here.
  37 // If the layout of any of the classes above changes the offsets must be adjusted.
  38 //
  39 // For most classes we hardwire the offsets for performance reasons. In certain
  40 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  41 // startup since the layout here differs between JDK1.2 and JDK1.3.
  42 //
  43 // Note that fields (static and non-static) are arranged with oops before non-oops
  44 // on a per class basis. The offsets below have to reflect this ordering.
  45 //
  46 // When editing the layouts please update the check_offset verification code
  47 // correspondingly. The names in the enums must be identical to the actual field
  48 // names in order for the verification code to work.
  49 
  50 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  51   f(java_lang_Class) \
  52   f(java_lang_String) \
  53   //end
  54 
  55 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  56   f(java_lang_System) \
  57   f(java_lang_ClassLoader) \
  58   f(java_lang_Throwable) \
  59   f(java_lang_Thread) \
  60   f(java_lang_ThreadGroup) \
  61   f(java_lang_AssertionStatusDirectives) \
  62   f(java_lang_ref_SoftReference) \
  63   f(java_lang_invoke_MethodHandle) \
  64   f(java_lang_invoke_DirectMethodHandle) \
  65   f(java_lang_invoke_MemberName) \
  66   f(java_lang_invoke_ResolvedMethodName) \
  67   f(java_lang_invoke_LambdaForm) \
  68   f(java_lang_invoke_MethodType) \
  69   f(java_lang_invoke_CallSite) \
  70   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  71   f(java_security_AccessControlContext) \
  72   f(java_lang_reflect_AccessibleObject) \
  73   f(java_lang_reflect_Method) \
  74   f(java_lang_reflect_Constructor) \
  75   f(java_lang_reflect_Field) \
  76   f(java_nio_Buffer) \
  77   f(reflect_ConstantPool) \
  78   f(reflect_UnsafeStaticFieldAccessorImpl) \
  79   f(java_lang_reflect_Parameter) \
  80   f(java_lang_Module) \
  81   f(java_lang_StackTraceElement) \
  82   f(java_lang_StackFrameInfo) \
  83   f(java_lang_LiveStackFrameInfo) \
  84   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  85   //end
  86 
  87 #define BASIC_JAVA_CLASSES_DO(f) \
  88         BASIC_JAVA_CLASSES_DO_PART1(f) \
  89         BASIC_JAVA_CLASSES_DO_PART2(f)
  90 
  91 // Interface to java.lang.String objects
  92 
  93 class java_lang_String : AllStatic {
  94  private:
  95   static int value_offset;
  96   static int hash_offset;
  97   static int coder_offset;
  98 
  99   static bool initialized;
 100 
 101   static Handle basic_create(int length, bool byte_arr, TRAPS);
 102 
 103   static inline void set_coder(oop string, jbyte coder);
 104 
 105  public:
 106 
 107   // Coders
 108   enum Coder {
 109     CODER_LATIN1 =  0,
 110     CODER_UTF16  =  1
 111   };
 112 
 113   static void compute_offsets();
 114   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 115 
 116   // Instance creation
 117   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 118   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 119   static Handle create_from_str(const char* utf8_str, TRAPS);
 120   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 121   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 122   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 123   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 124 
 125   static void set_compact_strings(bool value);
 126 
 127   static int value_offset_in_bytes()  {
 128     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 129     return value_offset;
 130   }
 131   static int hash_offset_in_bytes()   {
 132     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 133     return hash_offset;
 134   }
 135   static int coder_offset_in_bytes()   {
 136     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 137     return coder_offset;
 138   }
 139 
 140   static inline void set_value_raw(oop string, typeArrayOop buffer);
 141   static inline void set_value(oop string, typeArrayOop buffer);
 142   static inline void set_hash(oop string, unsigned int hash);
 143 
 144   // Accessors
 145   static inline typeArrayOop value(oop java_string);
 146   static inline typeArrayOop value_no_keepalive(oop java_string);
 147   static inline unsigned int hash(oop java_string);
 148   static inline bool is_latin1(oop java_string);
 149   static inline int length(oop java_string);
 150   static inline int length(oop java_string, typeArrayOop string_value);
 151   static int utf8_length(oop java_string);
 152   static int utf8_length(oop java_string, typeArrayOop string_value);
 153 
 154   // String converters
 155   static char*  as_utf8_string(oop java_string);
 156   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 157   static char*  as_utf8_string(oop java_string, int start, int len);
 158   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 159   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 160   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 161   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 162   // produce an ascii string with all other values quoted using \u####
 163   static char*  as_quoted_ascii(oop java_string);
 164 
 165   // Compute the hash value for a java.lang.String object which would
 166   // contain the characters passed in.
 167   //
 168   // As the hash value used by the String object itself, in
 169   // String.hashCode().  This value is normally calculated in Java code
 170   // in the String.hashCode method(), but is precomputed for String
 171   // objects in the shared archive file.
 172   // hash P(31) from Kernighan &amp; Ritchie
 173   //
 174   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 175   static unsigned int hash_code(const jchar* s, int len) {
 176     unsigned int h = 0;
 177     while (len-- &gt; 0) {
 178       h = 31*h + (unsigned int) *s;
 179       s++;
 180     }
 181     return h;
 182   }
 183 
 184   static unsigned int hash_code(const jbyte* s, int len) {
 185     unsigned int h = 0;
 186     while (len-- &gt; 0) {
 187       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 188       s++;
 189     }
 190     return h;
 191   }
 192 
 193   static unsigned int hash_code(oop java_string);
 194 
 195   static bool equals(oop java_string, const jchar* chars, int len);
 196   static bool equals(oop str1, oop str2);
 197   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 198 
 199   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 200   static Handle externalize_classname(Handle java_string, TRAPS) { return char_converter(java_string, &#39;/&#39;, &#39;.&#39;, THREAD); }
 201   static Handle internalize_classname(Handle java_string, TRAPS) { return char_converter(java_string, &#39;.&#39;, &#39;/&#39;, THREAD); }
 202 
 203   // Conversion
 204   static Symbol* as_symbol(oop java_string, TRAPS);
 205   static Symbol* as_symbol_or_null(oop java_string);
 206 
 207   // Testers
 208   static bool is_instance(oop obj);
 209   static inline bool is_instance_inlined(oop obj);
 210 
 211   // Debugging
 212   static void print(oop java_string, outputStream* st);
 213   friend class JavaClasses;
 214   friend class StringTable;
 215 };
 216 
 217 
 218 // Interface to java.lang.Class objects
 219 
 220 #define CLASS_INJECTED_FIELDS(macro)                                       \
 221   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 222   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 223   macro(java_lang_Class, oop_size,               int_signature,     false) \
 224   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 225   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 226   macro(java_lang_Class, signers,                object_signature,  false) \
 227   macro(java_lang_Class, source_file,            object_signature,  false) \
 228 
 229 class java_lang_Class : AllStatic {
 230   friend class VMStructs;
 231   friend class JVMCIVMStructs;
 232 
 233  private:
 234   // The fake offsets are added by the class loader when java.lang.Class is loaded
 235 
 236   static int _klass_offset;
 237   static int _array_klass_offset;
 238 
 239   static int _oop_size_offset;
 240   static int _static_oop_field_count_offset;
 241 
 242   static int _protection_domain_offset;
 243   static int _init_lock_offset;
 244   static int _signers_offset;
 245   static int _class_loader_offset;
 246   static int _module_offset;
 247   static int _component_mirror_offset;
 248   static int _name_offset;
 249   static int _source_file_offset;
 250 
 251   static bool offsets_computed;
 252   static int classRedefinedCount_offset;
 253 
 254   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 255   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 256 
 257   static void set_init_lock(oop java_class, oop init_lock);
 258   static void set_protection_domain(oop java_class, oop protection_domain);
 259   static void set_class_loader(oop java_class, oop class_loader);
 260   static void set_component_mirror(oop java_class, oop comp_mirror);
 261   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
 262   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 263  public:
 264   static void allocate_fixup_lists();
 265   static void compute_offsets();
 266 
 267   // Instance creation
 268   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 269                             Handle protection_domain, TRAPS);
 270   static void fixup_mirror(Klass* k, TRAPS);
 271   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 272 
 273   // Archiving
 274   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 275   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 276   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 277   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 278                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 279   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 280                                       Handle protection_domain,
 281                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 282 
 283   static void fixup_module_field(Klass* k, Handle module);
 284 
 285   // Conversion
 286   static Klass* as_Klass(oop java_class);
 287   static Klass* as_Klass_raw(oop java_class);
 288   static void set_klass(oop java_class, Klass* klass);
 289   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 290   static Symbol* as_signature(oop java_class, bool intern_if_not_found, TRAPS);
 291   static void print_signature(oop java_class, outputStream *st);
 292   static const char* as_external_name(oop java_class);
 293   // Testing
 294   static bool is_instance(oop obj);
 295 
 296   static bool is_primitive(oop java_class);
 297   static BasicType primitive_type(oop java_class);
 298   static oop primitive_mirror(BasicType t);
 299   // JVM_NewArray support
 300   static Klass* array_klass_acquire(oop java_class);
 301   static void release_set_array_klass(oop java_class, Klass* klass);
 302   // compiler support for class operations
 303   static int klass_offset_in_bytes()                { return _klass_offset; }
 304   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 305   // Support for classRedefinedCount field
 306   static int classRedefinedCount(oop the_class_mirror);
 307   static void set_classRedefinedCount(oop the_class_mirror, int value);
 308 
 309   // Support for embedded per-class oops
 310   static oop  protection_domain(oop java_class);
 311   static oop  init_lock(oop java_class);
 312 #if INCLUDE_TSAN
 313   static oop* init_lock_addr(oop java_class);
 314   static const int* init_lock_offset_addr() { return &amp;_init_lock_offset; }
 315 #endif  // INCLUDE_TSAN
 316   static oop  component_mirror(oop java_class);
 317   static objArrayOop  signers(oop java_class);
 318   static void set_signers(oop java_class, objArrayOop signers);
 319 
 320   static oop class_loader(oop java_class);
 321   static void set_module(oop java_class, oop module);
 322   static oop module(oop java_class);
 323 
 324   static oop name(Handle java_class, TRAPS);
 325 
 326   static oop source_file(oop java_class);
 327   static void set_source_file(oop java_class, oop source_file);
 328 
 329   static int oop_size(oop java_class);
 330   static int oop_size_raw(oop java_class);
 331   static void set_oop_size(HeapWord* java_class, int size);
 332   static int static_oop_field_count(oop java_class);
 333   static int static_oop_field_count_raw(oop java_class);
 334   static void set_static_oop_field_count(oop java_class, int size);
 335 
 336   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 337     return _fixup_mirror_list;
 338   }
 339   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 340     _fixup_mirror_list = v;
 341   }
 342 
 343   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 344     return _fixup_module_field_list;
 345   }
 346   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 347     _fixup_module_field_list = v;
 348   }
 349 
 350   // Debugging
 351   friend class JavaClasses;
 352   friend class InstanceKlass;   // verification code accesses offsets
 353   friend class ClassFileParser; // access to number_of_fake_fields
 354 };
 355 
 356 // Interface to java.lang.Thread objects
 357 
 358 class java_lang_Thread : AllStatic {
 359  private:
 360   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 361   // so we compute the offsets at startup rather than hard-wiring them.
 362   static int _name_offset;
 363   static int _group_offset;
 364   static int _contextClassLoader_offset;
 365   static int _inheritedAccessControlContext_offset;
 366   static int _priority_offset;
 367   static int _eetop_offset;
 368   static int _daemon_offset;
 369   static int _stillborn_offset;
 370   static int _stackSize_offset;
 371   static int _tid_offset;
 372   static int _thread_status_offset;
 373   static int _park_blocker_offset;
 374   static int _park_event_offset ;
 375 
 376   static void compute_offsets();
 377 
 378  public:
 379   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 380 
 381   // Instance creation
 382   static oop create();
 383   // Returns the JavaThread associated with the thread obj
 384   static JavaThread* thread(oop java_thread);
 385   // Set JavaThread for instance
 386   static void set_thread(oop java_thread, JavaThread* thread);
 387   // Name
 388   static oop name(oop java_thread);
 389   static void set_name(oop java_thread, oop name);
 390   // Priority
 391   static ThreadPriority priority(oop java_thread);
 392   static void set_priority(oop java_thread, ThreadPriority priority);
 393   // Thread group
 394   static oop  threadGroup(oop java_thread);
 395   // Stillborn
 396   static bool is_stillborn(oop java_thread);
 397   static void set_stillborn(oop java_thread);
 398   // Alive (NOTE: this is not really a field, but provides the correct
 399   // definition without doing a Java call)
 400   static bool is_alive(oop java_thread);
 401   // Daemon
 402   static bool is_daemon(oop java_thread);
 403   static void set_daemon(oop java_thread);
 404   // Context ClassLoader
 405   static oop context_class_loader(oop java_thread);
 406   // Control context
 407   static oop inherited_access_control_context(oop java_thread);
 408   // Stack size hint
 409   static jlong stackSize(oop java_thread);
 410   // Thread ID
 411   static jlong thread_id(oop java_thread);
 412 
 413   // Blocker object responsible for thread parking
 414   static oop park_blocker(oop java_thread);
 415 
 416   // Pointer to type-stable park handler, encoded as jlong.
 417   // Should be set when apparently null
 418   // For details, see unsafe.cpp Unsafe_Unpark
 419   static jlong park_event(oop java_thread);
 420   static bool set_park_event(oop java_thread, jlong ptr);
 421 
 422   // Java Thread Status for JVMTI and M&amp;M use.
 423   // This thread status info is saved in threadStatus field of
 424   // java.lang.Thread java class.
 425   enum ThreadStatus {
 426     NEW                      = 0,
 427     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 428                                JVMTI_THREAD_STATE_RUNNABLE,
 429     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 430                                JVMTI_THREAD_STATE_WAITING +
 431                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 432                                JVMTI_THREAD_STATE_SLEEPING,
 433     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 434                                JVMTI_THREAD_STATE_WAITING +
 435                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 436                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 437     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 438                                JVMTI_THREAD_STATE_WAITING +
 439                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 440                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 441     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 442                                JVMTI_THREAD_STATE_WAITING +
 443                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 444                                JVMTI_THREAD_STATE_PARKED,
 445     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 446                                JVMTI_THREAD_STATE_WAITING +
 447                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 448                                JVMTI_THREAD_STATE_PARKED,
 449     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 450                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 451     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 452   };
 453   // Write thread status info to threadStatus field of java.lang.Thread.
 454   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 455   // Read thread status info from threadStatus field of java.lang.Thread.
 456   static ThreadStatus get_thread_status(oop java_thread_oop);
 457 
 458   static const char*  thread_status_name(oop java_thread_oop);
 459 
 460   // Debugging
 461   friend class JavaClasses;
 462 };
 463 
 464 // Interface to java.lang.ThreadGroup objects
 465 
 466 class java_lang_ThreadGroup : AllStatic {
 467  private:
 468   static int _parent_offset;
 469   static int _name_offset;
 470   static int _threads_offset;
 471   static int _groups_offset;
 472   static int _maxPriority_offset;
 473   static int _destroyed_offset;
 474   static int _daemon_offset;
 475   static int _nthreads_offset;
 476   static int _ngroups_offset;
 477 
 478   static void compute_offsets();
 479 
 480  public:
 481   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 482 
 483   // parent ThreadGroup
 484   static oop  parent(oop java_thread_group);
 485   // name
 486   static const char* name(oop java_thread_group);
 487   // (&quot;name as oop&quot; accessor is not necessary)
 488   // Number of threads in group
 489   static int nthreads(oop java_thread_group);
 490   // threads
 491   static objArrayOop threads(oop java_thread_group);
 492   // Number of threads in group
 493   static int ngroups(oop java_thread_group);
 494   // groups
 495   static objArrayOop groups(oop java_thread_group);
 496   // maxPriority in group
 497   static ThreadPriority maxPriority(oop java_thread_group);
 498   // Destroyed
 499   static bool is_destroyed(oop java_thread_group);
 500   // Daemon
 501   static bool is_daemon(oop java_thread_group);
 502   // Debugging
 503   friend class JavaClasses;
 504 };
 505 
 506 
 507 
 508 // Interface to java.lang.Throwable objects
 509 
 510 class java_lang_Throwable: AllStatic {
 511   friend class BacktraceBuilder;
 512   friend class BacktraceIterator;
 513 
 514  private:
 515   // Offsets
 516   enum {
 517     hc_backtrace_offset     =  0,
 518     hc_detailMessage_offset =  1,
 519     hc_cause_offset         =  2,  // New since 1.4
 520     hc_stackTrace_offset    =  3   // New since 1.4
 521   };
 522   // Trace constants
 523   enum {
 524     trace_methods_offset = 0,
 525     trace_bcis_offset    = 1,
 526     trace_mirrors_offset = 2,
 527     trace_names_offset   = 3,
 528     trace_next_offset    = 4,
 529     trace_size           = 5,
 530     trace_chunk_size     = 32
 531   };
 532 
 533   static int backtrace_offset;
 534   static int detailMessage_offset;
 535   static int stackTrace_offset;
 536   static int depth_offset;
 537   static int static_unassigned_stacktrace_offset;
 538 
 539   // StackTrace (programmatic access, new since 1.4)
 540   static void clear_stacktrace(oop throwable);
 541   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 542   static void set_stacktrace(oop throwable, oop st_element_array);
 543   static oop unassigned_stacktrace();
 544 
 545  public:
 546   // Backtrace
 547   static oop backtrace(oop throwable);
 548   static void set_backtrace(oop throwable, oop value);
 549   static int depth(oop throwable);
 550   static void set_depth(oop throwable, int value);
 551   // Needed by JVMTI to filter out this internal field.
 552   static int get_backtrace_offset() { return backtrace_offset;}
 553   static int get_detailMessage_offset() { return detailMessage_offset;}
 554   // Message
 555   static oop message(oop throwable);
 556   static void set_message(oop throwable, oop value);
 557   static Symbol* detail_message(oop throwable);
 558   static void print_stack_element(outputStream *st, const methodHandle&amp; method, int bci);
 559   static void print_stack_usage(Handle stream);
 560 
 561   static void compute_offsets();
 562   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 563 
 564   // Allocate space for backtrace (created but stack trace not filled in)
 565   static void allocate_backtrace(Handle throwable, TRAPS);
 566   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 567   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 568   // Fill in current stack trace, can cause GC
 569   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 570   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 571   // Programmatic access to stack trace
 572   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 573   // Printing
 574   static void print(oop throwable, outputStream* st);
 575   static void print_stack_trace(Handle throwable, outputStream* st);
 576   static void java_printStackTrace(Handle throwable, TRAPS);
 577   // Debugging
 578   friend class JavaClasses;
 579 };
 580 
 581 
 582 // Interface to java.lang.reflect.AccessibleObject objects
 583 
 584 class java_lang_reflect_AccessibleObject: AllStatic {
 585  private:
 586   // Note that to reduce dependencies on the JDK we compute these
 587   // offsets at run-time.
 588   static int override_offset;
 589 
 590   static void compute_offsets();
 591 
 592  public:
 593   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 594 
 595   // Accessors
 596   static jboolean override(oop reflect);
 597   static void set_override(oop reflect, jboolean value);
 598 
 599   // Debugging
 600   friend class JavaClasses;
 601 };
 602 
 603 
 604 // Interface to java.lang.reflect.Method objects
 605 
 606 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 607  private:
 608   // Note that to reduce dependencies on the JDK we compute these
 609   // offsets at run-time.
 610   static int clazz_offset;
 611   static int name_offset;
 612   static int returnType_offset;
 613   static int parameterTypes_offset;
 614   static int exceptionTypes_offset;
 615   static int slot_offset;
 616   static int modifiers_offset;
 617   static int signature_offset;
 618   static int annotations_offset;
 619   static int parameter_annotations_offset;
 620   static int annotation_default_offset;
 621 
 622   static void compute_offsets();
 623  public:
 624   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 625 
 626   // Allocation
 627   static Handle create(TRAPS);
 628 
 629   // Accessors
 630   static oop clazz(oop reflect);
 631   static void set_clazz(oop reflect, oop value);
 632 
 633   static void set_name(oop method, oop value);
 634 
 635   static oop return_type(oop method);
 636   static void set_return_type(oop method, oop value);
 637 
 638   static oop parameter_types(oop method);
 639   static void set_parameter_types(oop method, oop value);
 640 
 641   static int slot(oop reflect);
 642   static void set_slot(oop reflect, int value);
 643 
 644   static void set_exception_types(oop method, oop value);
 645   static void set_modifiers(oop method, int value);
 646   static void set_signature(oop method, oop value);
 647   static void set_annotations(oop method, oop value);
 648   static void set_parameter_annotations(oop method, oop value);
 649   static void set_annotation_default(oop method, oop value);
 650 
 651   // Debugging
 652   friend class JavaClasses;
 653 };
 654 
 655 
 656 // Interface to java.lang.reflect.Constructor objects
 657 
 658 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 659  private:
 660   // Note that to reduce dependencies on the JDK we compute these
 661   // offsets at run-time.
 662   static int clazz_offset;
 663   static int parameterTypes_offset;
 664   static int exceptionTypes_offset;
 665   static int slot_offset;
 666   static int modifiers_offset;
 667   static int signature_offset;
 668   static int annotations_offset;
 669   static int parameter_annotations_offset;
 670 
 671   static void compute_offsets();
 672  public:
 673   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 674 
 675   // Allocation
 676   static Handle create(TRAPS);
 677 
 678   // Accessors
 679   static oop clazz(oop reflect);
 680   static void set_clazz(oop reflect, oop value);
 681 
 682   static oop parameter_types(oop constructor);
 683   static void set_parameter_types(oop constructor, oop value);
 684 
 685   static int slot(oop reflect);
 686   static void set_slot(oop reflect, int value);
 687 
 688   static void set_exception_types(oop constructor, oop value);
 689   static void set_modifiers(oop constructor, int value);
 690   static void set_signature(oop constructor, oop value);
 691   static void set_annotations(oop constructor, oop value);
 692   static void set_parameter_annotations(oop method, oop value);
 693 
 694   // Debugging
 695   friend class JavaClasses;
 696 };
 697 
 698 
 699 // Interface to java.lang.reflect.Field objects
 700 
 701 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 702  private:
 703   // Note that to reduce dependencies on the JDK we compute these
 704   // offsets at run-time.
 705   static int clazz_offset;
 706   static int name_offset;
 707   static int type_offset;
 708   static int slot_offset;
 709   static int modifiers_offset;
 710   static int signature_offset;
 711   static int annotations_offset;
 712 
 713   static void compute_offsets();
 714 
 715  public:
 716   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 717 
 718   // Allocation
 719   static Handle create(TRAPS);
 720 
 721   // Accessors
 722   static oop clazz(oop reflect);
 723   static void set_clazz(oop reflect, oop value);
 724 
 725   static oop name(oop field);
 726   static void set_name(oop field, oop value);
 727 
 728   static oop type(oop field);
 729   static void set_type(oop field, oop value);
 730 
 731   static int slot(oop reflect);
 732   static void set_slot(oop reflect, int value);
 733 
 734   static int modifiers(oop field);
 735   static void set_modifiers(oop field, int value);
 736 
 737   static void set_signature(oop constructor, oop value);
 738   static void set_annotations(oop constructor, oop value);
 739   static void set_parameter_annotations(oop method, oop value);
 740   static void set_annotation_default(oop method, oop value);
 741 
 742   // Debugging
 743   friend class JavaClasses;
 744 };
 745 
 746 class java_lang_reflect_Parameter {
 747  private:
 748   // Note that to reduce dependencies on the JDK we compute these
 749   // offsets at run-time.
 750   static int name_offset;
 751   static int modifiers_offset;
 752   static int index_offset;
 753   static int executable_offset;
 754 
 755   static void compute_offsets();
 756 
 757  public:
 758   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 759 
 760   // Allocation
 761   static Handle create(TRAPS);
 762 
 763   // Accessors
 764   static oop name(oop field);
 765   static void set_name(oop field, oop value);
 766 
 767   static int index(oop reflect);
 768   static void set_index(oop reflect, int value);
 769 
 770   static int modifiers(oop reflect);
 771   static void set_modifiers(oop reflect, int value);
 772 
 773   static oop executable(oop constructor);
 774   static void set_executable(oop constructor, oop value);
 775 
 776   friend class JavaClasses;
 777 };
 778 
 779 #define MODULE_INJECTED_FIELDS(macro)                            \
 780   macro(java_lang_Module, module_entry, intptr_signature, false)
 781 
 782 class java_lang_Module {
 783   private:
 784     static int loader_offset;
 785     static int name_offset;
 786     static int _module_entry_offset;
 787     static void compute_offsets();
 788 
 789   public:
 790     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 791 
 792     // Allocation
 793     static Handle create(Handle loader, Handle module_name, TRAPS);
 794 
 795     // Testers
 796     static bool is_instance(oop obj);
 797 
 798     // Accessors
 799     static oop loader(oop module);
 800     static void set_loader(oop module, oop value);
 801 
 802     static oop name(oop module);
 803     static void set_name(oop module, oop value);
 804 
 805     static ModuleEntry* module_entry(oop module);
 806     static void set_module_entry(oop module, ModuleEntry* module_entry);
 807 
 808   friend class JavaClasses;
 809 };
 810 
 811 // Interface to jdk.internal.reflect.ConstantPool objects
 812 class reflect_ConstantPool {
 813  private:
 814   // Note that to reduce dependencies on the JDK we compute these
 815   // offsets at run-time.
 816   static int _oop_offset;
 817 
 818   static void compute_offsets();
 819 
 820  public:
 821   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 822 
 823   // Allocation
 824   static Handle create(TRAPS);
 825 
 826   // Accessors
 827   static void set_cp(oop reflect, ConstantPool* value);
 828   static int oop_offset() {
 829     return _oop_offset;
 830   }
 831 
 832   static ConstantPool* get_cp(oop reflect);
 833 
 834   // Debugging
 835   friend class JavaClasses;
 836 };
 837 
 838 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 839 class reflect_UnsafeStaticFieldAccessorImpl {
 840  private:
 841   static int _base_offset;
 842   static void compute_offsets();
 843 
 844  public:
 845   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 846 
 847   static int base_offset() {
 848     return _base_offset;
 849   }
 850 
 851   // Debugging
 852   friend class JavaClasses;
 853 };
 854 
 855 // Interface to java.lang primitive type boxing objects:
 856 //  - java.lang.Boolean
 857 //  - java.lang.Character
 858 //  - java.lang.Float
 859 //  - java.lang.Double
 860 //  - java.lang.Byte
 861 //  - java.lang.Short
 862 //  - java.lang.Integer
 863 //  - java.lang.Long
 864 
 865 // This could be separated out into 8 individual classes.
 866 
 867 class java_lang_boxing_object: AllStatic {
 868  private:
 869   enum {
 870    hc_value_offset = 0
 871   };
 872   static int value_offset;
 873   static int long_value_offset;
 874 
 875   static oop initialize_and_allocate(BasicType type, TRAPS);
 876  public:
 877   // Allocation. Returns a boxed value, or NULL for invalid type.
 878   static oop create(BasicType type, jvalue* value, TRAPS);
 879   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 880   static BasicType get_value(oop box, jvalue* value);
 881   static BasicType set_value(oop box, jvalue* value);
 882   static BasicType basic_type(oop box);
 883   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 884   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 885   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 886   static void print(BasicType type, jvalue* value, outputStream* st);
 887 
 888   static int value_offset_in_bytes(BasicType type) {
 889     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 890                                                     value_offset;
 891   }
 892 
 893   // Debugging
 894   friend class JavaClasses;
 895 };
 896 
 897 
 898 
 899 // Interface to java.lang.ref.Reference objects
 900 
 901 class java_lang_ref_Reference: AllStatic {
 902  public:
 903   enum {
 904    hc_referent_offset   = 0,
 905    hc_queue_offset      = 1,
 906    hc_next_offset       = 2,
 907    hc_discovered_offset = 3  // Is not last, see SoftRefs.
 908   };
 909 
 910   static int referent_offset;
 911   static int queue_offset;
 912   static int next_offset;
 913   static int discovered_offset;
 914 
 915   // Accessors
 916   static inline oop referent(oop ref);
 917   static inline void set_referent(oop ref, oop value);
 918   static inline void set_referent_raw(oop ref, oop value);
 919   static inline HeapWord* referent_addr_raw(oop ref);
 920   static inline oop next(oop ref);
 921   static inline void set_next(oop ref, oop value);
 922   static inline void set_next_raw(oop ref, oop value);
 923   static inline HeapWord* next_addr_raw(oop ref);
 924   static inline oop discovered(oop ref);
 925   static inline void set_discovered(oop ref, oop value);
 926   static inline void set_discovered_raw(oop ref, oop value);
 927   static inline HeapWord* discovered_addr_raw(oop ref);
 928   static inline oop queue(oop ref);
 929   static inline void set_queue(oop ref, oop value);
 930   static bool is_referent_field(oop obj, ptrdiff_t offset);
 931   static inline bool is_final(oop ref);
 932   static inline bool is_phantom(oop ref);
 933 };
 934 
 935 
 936 // Interface to java.lang.ref.SoftReference objects
 937 
 938 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 939  public:
 940   static int timestamp_offset;
 941   static int static_clock_offset;
 942 
 943   // Accessors
 944   static jlong timestamp(oop ref);
 945 
 946   // Accessors for statics
 947   static jlong clock();
 948   static void set_clock(jlong value);
 949 
 950   static void compute_offsets();
 951   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 952 };
 953 
 954 // Interface to java.lang.invoke.MethodHandle objects
 955 
 956 class MethodHandleEntry;
 957 
 958 class java_lang_invoke_MethodHandle: AllStatic {
 959   friend class JavaClasses;
 960 
 961  private:
 962   static int _type_offset;               // the MethodType of this MH
 963   static int _form_offset;               // the LambdaForm of this MH
 964 
 965   static void compute_offsets();
 966 
 967  public:
 968   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 969 
 970   // Accessors
 971   static oop            type(oop mh);
 972   static void       set_type(oop mh, oop mtype);
 973 
 974   static oop            form(oop mh);
 975   static void       set_form(oop mh, oop lform);
 976 
 977   // Testers
 978   static bool is_subclass(Klass* klass) {
 979     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 980   }
 981   static bool is_instance(oop obj);
 982 
 983   // Accessors for code generation:
 984   static int type_offset_in_bytes()             { return _type_offset; }
 985   static int form_offset_in_bytes()             { return _form_offset; }
 986 };
 987 
 988 // Interface to java.lang.invoke.DirectMethodHandle objects
 989 
 990 class java_lang_invoke_DirectMethodHandle: AllStatic {
 991   friend class JavaClasses;
 992 
 993  private:
 994   static int _member_offset;               // the MemberName of this DMH
 995 
 996   static void compute_offsets();
 997 
 998  public:
 999   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1000 
1001   // Accessors
1002   static oop  member(oop mh);
1003 
1004   // Testers
1005   static bool is_subclass(Klass* klass) {
1006     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1007   }
1008   static bool is_instance(oop obj);
1009 
1010   // Accessors for code generation:
1011   static int member_offset_in_bytes()           { return _member_offset; }
1012 };
1013 
1014 // Interface to java.lang.invoke.LambdaForm objects
1015 // (These are a private interface for managing adapter code generation.)
1016 
1017 class java_lang_invoke_LambdaForm: AllStatic {
1018   friend class JavaClasses;
1019 
1020  private:
1021   static int _vmentry_offset;  // type is MemberName
1022 
1023   static void compute_offsets();
1024 
1025  public:
1026   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1027 
1028   // Accessors
1029   static oop            vmentry(oop lform);
1030   static void       set_vmentry(oop lform, oop invoker);
1031 
1032   // Testers
1033   static bool is_subclass(Klass* klass) {
1034     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1035       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1036   }
1037   static bool is_instance(oop obj);
1038 
1039   // Accessors for code generation:
1040   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }
1041 };
1042 
1043 
1044 // Interface to java.lang.invoke.MemberName objects
1045 // (These are a private interface for Java code to query the class hierarchy.)
1046 
1047 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1048   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1049   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1050 
1051 class java_lang_invoke_ResolvedMethodName : AllStatic {
1052   friend class JavaClasses;
1053 
1054   static int _vmtarget_offset;
1055   static int _vmholder_offset;
1056 
1057   static void compute_offsets();
1058  public:
1059   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1060 
1061   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1062 
1063   static Method* vmtarget(oop resolved_method);
1064   static void set_vmtarget(oop resolved_method, Method* method);
1065 
1066   // find or create resolved member name
1067   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1068 
1069   static bool is_instance(oop resolved_method);
1070 };
1071 
1072 
1073 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1074   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1075 
1076 
1077 class java_lang_invoke_MemberName: AllStatic {
1078   friend class JavaClasses;
1079 
1080  private:
1081   // From java.lang.invoke.MemberName:
1082   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1083   //    private String     name;        // may be null if not yet materialized
1084   //    private Object     type;        // may be null if not yet materialized
1085   //    private int        flags;       // modifier bits; see reflect.Modifier
1086   //    private ResolvedMethodName method;    // holds VM-specific target value
1087   //    private intptr_t   vmindex;     // member index within class or interface
1088   static int _clazz_offset;
1089   static int _name_offset;
1090   static int _type_offset;
1091   static int _flags_offset;
1092   static int _method_offset;
1093   static int _vmindex_offset;
1094 
1095   static void compute_offsets();
1096 
1097  public:
1098   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1099   // Accessors
1100   static oop            clazz(oop mname);
1101   static void       set_clazz(oop mname, oop clazz);
1102 
1103   static oop            type(oop mname);
1104   static void       set_type(oop mname, oop type);
1105 
1106   static oop            name(oop mname);
1107   static void       set_name(oop mname, oop name);
1108 
1109   static int            flags(oop mname);
1110   static void       set_flags(oop mname, int flags);
1111 
1112   // Link through ResolvedMethodName field to get Method*
1113   static Method*        vmtarget(oop mname);
1114   static void       set_method(oop mname, oop method);
1115 
1116   static intptr_t       vmindex(oop mname);
1117   static void       set_vmindex(oop mname, intptr_t index);
1118 
1119   // Testers
1120   static bool is_subclass(Klass* klass) {
1121     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1122   }
1123   static bool is_instance(oop obj);
1124 
1125   static bool is_method(oop obj);
1126 
1127   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1128   enum {
1129     MN_IS_METHOD            = 0x00010000, // method (not constructor)
1130     MN_IS_CONSTRUCTOR       = 0x00020000, // constructor
1131     MN_IS_FIELD             = 0x00040000, // field
1132     MN_IS_TYPE              = 0x00080000, // nested type
1133     MN_CALLER_SENSITIVE     = 0x00100000, // @CallerSensitive annotation detected
1134     MN_REFERENCE_KIND_SHIFT = 24, // refKind
1135     MN_REFERENCE_KIND_MASK  = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1136     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1137     MN_SEARCH_SUPERCLASSES  = 0x00100000, // walk super classes
1138     MN_SEARCH_INTERFACES    = 0x00200000  // walk implemented interfaces
1139   };
1140 
1141   // Accessors for code generation:
1142   static int clazz_offset_in_bytes()            { return _clazz_offset; }
1143   static int type_offset_in_bytes()             { return _type_offset; }
1144   static int name_offset_in_bytes()             { return _name_offset; }
1145   static int flags_offset_in_bytes()            { return _flags_offset; }
1146   static int method_offset_in_bytes()           { return _method_offset; }
1147   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }
1148 };
1149 
1150 
1151 // Interface to java.lang.invoke.MethodType objects
1152 
1153 class java_lang_invoke_MethodType: AllStatic {
1154   friend class JavaClasses;
1155 
1156  private:
1157   static int _rtype_offset;
1158   static int _ptypes_offset;
1159 
1160   static void compute_offsets();
1161 
1162  public:
1163   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1164   // Accessors
1165   static oop            rtype(oop mt);
1166   static objArrayOop    ptypes(oop mt);
1167 
1168   static oop            ptype(oop mt, int index);
1169   static int            ptype_count(oop mt);
1170 
1171   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1172   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1173 
1174   static Symbol*        as_signature(oop mt, bool intern_if_not_found, TRAPS);
1175   static void           print_signature(oop mt, outputStream* st);
1176 
1177   static bool is_instance(oop obj);
1178 
1179   static bool equals(oop mt1, oop mt2);
1180 
1181   // Accessors for code generation:
1182   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1183   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1184 };
1185 
1186 
1187 // Interface to java.lang.invoke.CallSite objects
1188 
1189 class java_lang_invoke_CallSite: AllStatic {
1190   friend class JavaClasses;
1191 
1192 private:
1193   static int _target_offset;
1194   static int _context_offset;
1195 
1196   static void compute_offsets();
1197 
1198 public:
1199   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1200   // Accessors
1201   static oop              target(          oop site);
1202   static void         set_target(          oop site, oop target);
1203   static void         set_target_volatile( oop site, oop target);
1204 
1205   static oop context_no_keepalive(oop site);
1206 
1207   // Testers
1208   static bool is_subclass(Klass* klass) {
1209     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1210   }
1211   static bool is_instance(oop obj);
1212 
1213   // Accessors for code generation:
1214   static int target_offset_in_bytes()           { return _target_offset; }
1215 };
1216 
1217 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1218 
1219 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1220   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1221   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1222 
1223 class DependencyContext;
1224 
1225 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1226   friend class JavaClasses;
1227 
1228 private:
1229   static int _vmdependencies_offset;
1230   static int _last_cleanup_offset;
1231 
1232   static void compute_offsets();
1233 
1234 public:
1235   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1236   // Accessors
1237   static DependencyContext vmdependencies(oop context);
1238 
1239   // Testers
1240   static bool is_subclass(Klass* klass) {
1241     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1242   }
1243   static bool is_instance(oop obj);
1244 };
1245 
1246 // Interface to java.security.AccessControlContext objects
1247 
1248 class java_security_AccessControlContext: AllStatic {
1249  private:
1250   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1251   // so we compute the offsets at startup rather than hard-wiring them.
1252   static int _context_offset;
1253   static int _privilegedContext_offset;
1254   static int _isPrivileged_offset;
1255   static int _isAuthorized_offset;
1256 
1257   static void compute_offsets();
1258  public:
1259   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1260   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1261 
1262   // Debugging/initialization
1263   friend class JavaClasses;
1264 };
1265 
1266 
1267 // Interface to java.lang.ClassLoader objects
1268 
1269 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1270   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1271 
1272 class java_lang_ClassLoader : AllStatic {
1273  private:
1274   static int _loader_data_offset;
1275   static bool offsets_computed;
1276   static int parent_offset;
1277   static int parallelCapable_offset;
1278   static int name_offset;
1279   static int nameAndId_offset;
1280   static int unnamedModule_offset;
1281 
1282  public:
1283   static void compute_offsets();
1284   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1285 
1286   static ClassLoaderData* loader_data_acquire(oop loader);
1287   static ClassLoaderData* loader_data_raw(oop loader);
1288   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1289 
1290   static oop parent(oop loader);
1291   static oop name(oop loader);
1292   static oop nameAndId(oop loader);
1293   static bool isAncestor(oop loader, oop cl);
1294 
1295   // Support for parallelCapable field
1296   static bool parallelCapable(oop the_class_mirror);
1297 
1298   static bool is_trusted_loader(oop loader);
1299 
1300   // Return true if this is one of the class loaders associated with
1301   // the generated bytecodes for reflection.
1302   static bool is_reflection_class_loader(oop loader);
1303 
1304   // Fix for 4474172
1305   static oop  non_reflection_class_loader(oop loader);
1306 
1307   // Testers
1308   static bool is_subclass(Klass* klass) {
1309     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1310   }
1311   static bool is_instance(oop obj);
1312 
1313   static oop unnamedModule(oop loader);
1314 
1315   // Debugging
1316   friend class JavaClasses;
1317   friend class ClassFileParser; // access to number_of_fake_fields
1318 };
1319 
1320 
1321 // Interface to java.lang.System objects
1322 
1323 class java_lang_System : AllStatic {
1324  private:
1325   static int  static_in_offset;
1326   static int static_out_offset;
1327   static int static_err_offset;
1328   static int static_security_offset;
1329 
1330  public:
1331   static int  in_offset_in_bytes();
1332   static int out_offset_in_bytes();
1333   static int err_offset_in_bytes();
1334 
1335   static void compute_offsets();
1336   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1337 
1338   // Debugging
1339   friend class JavaClasses;
1340 };
1341 
1342 
1343 // Interface to java.lang.StackTraceElement objects
1344 
1345 class java_lang_StackTraceElement: AllStatic {
1346  private:
1347   static int declaringClassObject_offset;
1348   static int classLoaderName_offset;
1349   static int moduleName_offset;
1350   static int moduleVersion_offset;
1351   static int declaringClass_offset;
1352   static int methodName_offset;
1353   static int fileName_offset;
1354   static int lineNumber_offset;
1355 
1356   // Setters
1357   static void set_classLoaderName(oop element, oop value);
1358   static void set_moduleName(oop element, oop value);
1359   static void set_moduleVersion(oop element, oop value);
1360   static void set_declaringClass(oop element, oop value);
1361   static void set_methodName(oop element, oop value);
1362   static void set_fileName(oop element, oop value);
1363   static void set_lineNumber(oop element, int value);
1364   static void set_declaringClassObject(oop element, oop value);
1365 
1366  public:
1367   // Create an instance of StackTraceElement
1368   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1369 
1370   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1371                       int version, int bci, Symbol* name, TRAPS);
1372 
1373   static void compute_offsets();
1374   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1375 
1376   // Debugging
1377   friend class JavaClasses;
1378 };
1379 
1380 
1381 class Backtrace: AllStatic {
1382  public:
1383   // Helper backtrace functions to store bci|version together.
1384   static int merge_bci_and_version(int bci, int version);
1385   static int merge_mid_and_cpref(int mid, int cpref);
1386   static int bci_at(unsigned int merged);
1387   static int version_at(unsigned int merged);
1388   static int mid_at(unsigned int merged);
1389   static int cpref_at(unsigned int merged);
1390   static int get_line_number(const methodHandle&amp; method, int bci);
1391   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1392 
1393   // Debugging
1394   friend class JavaClasses;
1395 };
1396 
1397 // Interface to java.lang.StackFrameInfo objects
1398 
1399 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1400   macro(java_lang_StackFrameInfo, version, short_signature, false)
1401 
1402 class java_lang_StackFrameInfo: AllStatic {
1403 private:
1404   static int _memberName_offset;
1405   static int _bci_offset;
1406   static int _version_offset;
1407 
1408   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1409 
1410 public:
1411   // Setters
1412   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1413   static void set_bci(oop info, int value);
1414 
1415   static void set_version(oop info, short value);
1416 
1417   static void compute_offsets();
1418   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1419 
1420   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1421 
1422   // Debugging
1423   friend class JavaClasses;
1424 };
1425 
1426 class java_lang_LiveStackFrameInfo: AllStatic {
1427  private:
1428   static int _monitors_offset;
1429   static int _locals_offset;
1430   static int _operands_offset;
1431   static int _mode_offset;
1432 
1433  public:
1434   static void set_monitors(oop info, oop value);
1435   static void set_locals(oop info, oop value);
1436   static void set_operands(oop info, oop value);
1437   static void set_mode(oop info, int value);
1438 
1439   static void compute_offsets();
1440   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1441 
1442   // Debugging
1443   friend class JavaClasses;
1444 };
1445 
1446 // Interface to java.lang.AssertionStatusDirectives objects
1447 
1448 class java_lang_AssertionStatusDirectives: AllStatic {
1449  private:
1450   static int classes_offset;
1451   static int classEnabled_offset;
1452   static int packages_offset;
1453   static int packageEnabled_offset;
1454   static int deflt_offset;
1455 
1456  public:
1457   // Setters
1458   static void set_classes(oop obj, oop val);
1459   static void set_classEnabled(oop obj, oop val);
1460   static void set_packages(oop obj, oop val);
1461   static void set_packageEnabled(oop obj, oop val);
1462   static void set_deflt(oop obj, bool val);
1463 
1464   static void compute_offsets();
1465   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1466 
1467   // Debugging
1468   friend class JavaClasses;
1469 };
1470 
1471 
1472 class java_nio_Buffer: AllStatic {
1473  private:
1474   static int _limit_offset;
1475 
1476  public:
1477   static int  limit_offset();
1478   static void compute_offsets();
1479   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1480 };
1481 
1482 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1483  private:
1484   static int  _owner_offset;
1485  public:
1486   static void compute_offsets();
1487   static oop  get_owner_threadObj(oop obj);
1488   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1489 };
1490 
1491 // Use to declare fields that need to be injected into Java classes
1492 // for the JVM to use.  The name_index and signature_index are
1493 // declared in vmSymbols.  The may_be_java flag is used to declare
1494 // fields that might already exist in Java but should be injected if
1495 // they don&#39;t.  Otherwise the field is unconditionally injected and
1496 // the JVM uses the injected one.  This is to ensure that name
1497 // collisions don&#39;t occur.  In general may_be_java should be false
1498 // unless there&#39;s a good reason.
1499 
1500 class InjectedField {
1501  public:
1502   const SystemDictionary::WKID klass_id;
1503   const vmSymbols::SID name_index;
1504   const vmSymbols::SID signature_index;
1505   const bool           may_be_java;
1506 
1507 
1508   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1509   Symbol* name() const      { return lookup_symbol(name_index); }
1510   Symbol* signature() const { return lookup_symbol(signature_index); }
1511 
1512   int compute_offset();
1513 
1514   // Find the Symbol for this index
1515   static Symbol* lookup_symbol(int symbol_index) {
1516     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1517   }
1518 };
1519 
1520 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1521   klass##_##name##_enum,
1522 
1523 #define ALL_INJECTED_FIELDS(macro)          \
1524   CLASS_INJECTED_FIELDS(macro)              \
1525   CLASSLOADER_INJECTED_FIELDS(macro)        \
1526   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1527   MEMBERNAME_INJECTED_FIELDS(macro)         \
1528   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1529   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1530   MODULE_INJECTED_FIELDS(macro)
1531 
1532 // Interface to hard-coded offset checking
1533 
1534 class JavaClasses : AllStatic {
1535  private:
1536 
1537   static InjectedField _injected_fields[];
1538 
1539   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1540  public:
1541   enum InjectedFieldID {
1542     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1543     MAX_enum
1544   };
1545 
1546   static int compute_injected_offset(InjectedFieldID id);
1547 
1548   static void compute_hard_coded_offsets();
1549   static void compute_offsets();
1550   static void check_offsets() PRODUCT_RETURN;
1551   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1552   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1553 };
1554 
1555 #undef DECLARE_INJECTED_FIELD_ENUM
1556 
1557 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
    </pre>
  </body>
</html>
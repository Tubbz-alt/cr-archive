<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/classLoaderData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoader.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
   /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,11 +65,10 @@</span>
  #include &quot;oops/oopHandle.inline.hpp&quot;
  #include &quot;oops/weakHandle.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,12 +105,11 @@</span>
    oop cl_name = java_lang_ClassLoader::name(class_loader());
    if (cl_name != NULL) {
      const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
  
      if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != &#39;\0&#39;) {
<span class="udiff-line-modified-removed">-       // Can&#39;t throw InternalError and SymbolTable doesn&#39;t throw OOM anymore.</span>
<span class="udiff-line-removed">-       _name = SymbolTable::new_symbol(cl_instance_name, CATCH);</span>
<span class="udiff-line-modified-added">+       _name = SymbolTable::new_symbol(cl_instance_name);</span>
      }
    }
  
    // Obtain the class loader&#39;s name and identity hash.  If the class loader&#39;s
    // name was not explicitly set during construction, the class loader&#39;s name and id
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,18 +121,17 @@</span>
    oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
    const char* cl_instance_name_and_id =
                    (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
                                               java_lang_String::as_utf8_string(cl_name_and_id);
    assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != &#39;\0&#39;, &quot;class loader has no name and id&quot;);
<span class="udiff-line-modified-removed">-   // Can&#39;t throw InternalError and SymbolTable doesn&#39;t throw OOM anymore.</span>
<span class="udiff-line-removed">-   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id, CATCH);</span>
<span class="udiff-line-modified-added">+   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);</span>
  }
  
  ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous) :
    _metaspace(NULL),
<span class="udiff-line-modified-removed">-   _metaspace_lock(new Mutex(Monitor::leaf+1, &quot;Metaspace allocation lock&quot;, true,</span>
<span class="udiff-line-modified-removed">-                             Monitor::_safepoint_check_never)),</span>
<span class="udiff-line-modified-added">+   _metaspace_lock(new Mutex(Mutex::leaf+1, &quot;Metaspace allocation lock&quot;, true,</span>
<span class="udiff-line-modified-added">+                             Mutex::_safepoint_check_never)),</span>
    _unloading(false), _is_unsafe_anonymous(is_unsafe_anonymous),
    _modified_oops(true), _accumulated_modified_oops(false),
    // An unsafe anonymous class loader data doesn&#39;t have anything to keep
    // it from being unloaded during parsing of the unsafe anonymous class.
    // The null-class-loader should always be kept alive.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,15 +184,15 @@</span>
  }
  
  oop* ClassLoaderData::ChunkedHandleList::add(oop o) {
    if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
      Chunk* next = new Chunk(_head);
<span class="udiff-line-modified-removed">-     OrderAccess::release_store(&amp;_head, next);</span>
<span class="udiff-line-modified-added">+     Atomic::release_store(&amp;_head, next);</span>
    }
    oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
    NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);</span>
<span class="udiff-line-modified-added">+   Atomic::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);</span>
    return handle;
  }
  
  int ClassLoaderData::ChunkedHandleList::count() const {
    int count = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,14 +211,14 @@</span>
      }
    }
  }
  
  void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
<span class="udiff-line-modified-removed">-   Chunk* head = OrderAccess::load_acquire(&amp;_head);</span>
<span class="udiff-line-modified-added">+   Chunk* head = Atomic::load_acquire(&amp;_head);</span>
    if (head != NULL) {
      // Must be careful when reading size of head
<span class="udiff-line-modified-removed">-     oops_do_chunk(f, head, OrderAccess::load_acquire(&amp;head-&gt;_size));</span>
<span class="udiff-line-modified-added">+     oops_do_chunk(f, head, Atomic::load_acquire(&amp;head-&gt;_size));</span>
      for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
        oops_do_chunk(f, c, c-&gt;_size);
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -232,11 +229,11 @@</span>
  
   public:
    VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
  
    void do_oop(oop* p) {
<span class="udiff-line-modified-removed">-     if (p != NULL &amp;&amp; oopDesc::equals(NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p), _target)) {</span>
<span class="udiff-line-modified-added">+     if (p != NULL &amp;&amp; NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p) == _target) {</span>
        _found = true;
      }
    }
  
    void do_oop(narrowOop* p) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -266,18 +263,31 @@</span>
    }
    return false;
  }
  #endif // PRODUCT
  
<span class="udiff-line-added">+ void ClassLoaderData::clear_claim(int claim) {</span>
<span class="udiff-line-added">+   for (;;) {</span>
<span class="udiff-line-added">+     int old_claim = Atomic::load(&amp;_claim);</span>
<span class="udiff-line-added">+     if ((old_claim &amp; claim) == 0) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int new_claim = old_claim &amp; ~claim;</span>
<span class="udiff-line-added">+     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool ClassLoaderData::try_claim(int claim) {
    for (;;) {
      int old_claim = Atomic::load(&amp;_claim);
      if ((old_claim &amp; claim) == claim) {
        return false;
      }
      int new_claim = old_claim | claim;
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(new_claim, &amp;_claim, old_claim) == old_claim) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {</span>
        return true;
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,11 +296,11 @@</span>
  // Due to the uniqueness that no other class shares the unsafe anonymous class&#39; name or
  // ClassLoaderData, no other non-GC thread has knowledge of the unsafe anonymous class while
  // it is being defined, therefore _keep_alive is not volatile or atomic.
  void ClassLoaderData::inc_keep_alive() {
    if (is_unsafe_anonymous()) {
<span class="udiff-line-modified-removed">-     assert(_keep_alive &gt;= 0, &quot;Invalid keep alive increment count&quot;);</span>
<span class="udiff-line-modified-added">+     assert(_keep_alive &gt; 0, &quot;Invalid keep alive increment count&quot;);</span>
      _keep_alive++;
    }
  }
  
  void ClassLoaderData::dec_keep_alive() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -313,36 +323,36 @@</span>
    _handles.oops_do(f);
  }
  
  void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      klass_closure-&gt;do_klass(k);
      assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
    }
  }
  
  void ClassLoaderData::classes_do(void f(Klass * const)) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      f(k);
      assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
    }
  }
  
  void ClassLoaderData::methods_do(void f(Method*)) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
        InstanceKlass::cast(k)-&gt;methods_do(f);
      }
    }
  }
  
  void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      // Do not filter ArrayKlass oops here...
      if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
  #ifdef ASSERT
        oop m = k-&gt;java_mirror();
        assert(m != NULL, &quot;NULL mirror&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -353,11 +363,11 @@</span>
    }
  }
  
  void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      if (k-&gt;is_instance_klass()) {
        f(InstanceKlass::cast(k));
      }
      assert(k != k-&gt;next_link(), &quot;no loops!&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,11 +430,11 @@</span>
      to = to_cld-&gt;class_loader();
      oop from = from_cld-&gt;class_loader();
  
      // Just return if this dependency is to a class with the same or a parent
      // class_loader.
<span class="udiff-line-modified-removed">-     if (oopDesc::equals(from, to) || java_lang_ClassLoader::isAncestor(from, to)) {</span>
<span class="udiff-line-modified-added">+     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {</span>
        return; // this class loader is in the parent list, no need to add it.
      }
    }
  
    // It&#39;s a dependency we won&#39;t find through GC, add it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,16 +457,16 @@</span>
    }
  }
  
  void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
      Klass* old_value = _klasses;
      k-&gt;set_next_link(old_value);
      // Link the new item into the list, making sure the linked class is stable
      // since the list can be walked without a lock
<span class="udiff-line-modified-removed">-     OrderAccess::release_store(&amp;_klasses, k);</span>
<span class="udiff-line-modified-added">+     Atomic::release_store(&amp;_klasses, k);</span>
      if (k-&gt;is_array_klass()) {
        ClassLoaderDataGraph::inc_array_classes(1);
      } else {
        ClassLoaderDataGraph::inc_instance_classes(1);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -539,21 +549,21 @@</span>
  }
  
  ModuleEntryTable* ClassLoaderData::modules() {
    // Lazily create the module entry table at first request.
    // Lock-free access requires load_acquire.
<span class="udiff-line-modified-removed">-   ModuleEntryTable* modules = OrderAccess::load_acquire(&amp;_modules);</span>
<span class="udiff-line-modified-added">+   ModuleEntryTable* modules = Atomic::load_acquire(&amp;_modules);</span>
    if (modules == NULL) {
      MutexLocker m1(Module_lock);
      // Check if _modules got allocated while we were waiting for this lock.
      if ((modules = _modules) == NULL) {
        modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
  
        {
<span class="udiff-line-modified-removed">-         MutexLockerEx m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);</span>
          // Ensure _modules is stable, since it is examined without a lock
<span class="udiff-line-modified-removed">-         OrderAccess::release_store(&amp;_modules, modules);</span>
<span class="udiff-line-modified-added">+         Atomic::release_store(&amp;_modules, modules);</span>
        }
      }
    }
    return modules;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,13 +749,13 @@</span>
    // If the metaspace has not been allocated, create a new one.  Might want
    // to create smaller arena for Reflection class loaders also.
    // The reason for the delayed allocation is because some class loaders are
    // simply for delegating with no metadata of their own.
    // Lock-free access requires load_acquire.
<span class="udiff-line-modified-removed">-   ClassLoaderMetaspace* metaspace = OrderAccess::load_acquire(&amp;_metaspace);</span>
<span class="udiff-line-modified-added">+   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);</span>
    if (metaspace == NULL) {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);</span>
      // Check if _metaspace got allocated while we were waiting for this lock.
      if ((metaspace = _metaspace) == NULL) {
        if (this == the_null_class_loader_data()) {
          assert (class_loader() == NULL, &quot;Must be&quot;);
          metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,18 +765,18 @@</span>
          metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
        } else {
          metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
        }
        // Ensure _metaspace is stable, since it is examined without a lock
<span class="udiff-line-modified-removed">-       OrderAccess::release_store(&amp;_metaspace, metaspace);</span>
<span class="udiff-line-modified-added">+       Atomic::release_store(&amp;_metaspace, metaspace);</span>
      }
    }
    return metaspace;
  }
  
  OopHandle ClassLoaderData::add_handle(Handle h) {
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
    record_modified_oops();
    return OopHandle(_handles.add(h()));
  }
  
  void ClassLoaderData::remove_handle(OopHandle h) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -777,11 +787,11 @@</span>
      NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
    }
  }
  
  void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
    if (dest.resolve() != NULL) {
      return;
    } else {
      dest = _handles.add(h());
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -790,11 +800,11 @@</span>
  // Add this metadata pointer to be freed when it&#39;s safe.  This is only during
  // a safepoint which checks if handles point to this metadata field.
  void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
    // Metadata in shared region isn&#39;t deleted.
    if (!m-&gt;is_shared()) {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);</span>
      if (_deallocate_list == NULL) {
        _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, true);
      }
      _deallocate_list-&gt;append_if_missing(m);
      log_debug(class, loader, data)(&quot;deallocate added for %s&quot;, m-&gt;print_value_string());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -913,10 +923,12 @@</span>
    if (is_unsafe_anonymous()) {
      out-&gt;print(&quot; unsafe anonymous&quot;);
    }
  }
  
<span class="udiff-line-added">+ void ClassLoaderData::print_value() const { print_value_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  #ifndef PRODUCT
  void ClassLoaderData::print_on(outputStream* out) const {
    out-&gt;print(&quot;ClassLoaderData CLD: &quot; PTR_FORMAT &quot;, loader: &quot; PTR_FORMAT &quot;, loader_klass: %s {&quot;,
                p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
    if (is_unsafe_anonymous()) out-&gt;print(&quot; unsafe anonymous&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -931,10 +943,12 @@</span>
    out-&gt;print(&quot; dependencies %d&quot;, _dependency_count);
    out-&gt;print_cr(&quot;}&quot;);
  }
  #endif // PRODUCT
  
<span class="udiff-line-added">+ void ClassLoaderData::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  void ClassLoaderData::verify() {
    assert_locked_or_safepoint(_metaspace_lock);
    oop cl = class_loader();
  
    guarantee(this == class_loader_data(cl) || is_unsafe_anonymous(), &quot;Must be the same&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -952,10 +966,10 @@</span>
    }
  }
  
  bool ClassLoaderData::contains_klass(Klass* klass) {
    // Lock-free access requires load_acquire
<span class="udiff-line-modified-removed">-   for (Klass* k = OrderAccess::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
<span class="udiff-line-modified-added">+   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {</span>
      if (k == klass) return true;
    }
    return false;
  }
</pre>
<center><a href="classLoader.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
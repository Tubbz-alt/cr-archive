<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/stringTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbolTable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/stringTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,120 ***</span>
   */
  
  #ifndef SHARE_CLASSFILE_STRINGTABLE_HPP
  #define SHARE_CLASSFILE_STRINGTABLE_HPP
  
<span class="line-removed">- #include &quot;gc/shared/oopStorage.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/oopStorageParState.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;oops/oop.hpp&quot;
  #include &quot;oops/weakHandle.hpp&quot;
<span class="line-modified">! #include &quot;utilities/concurrentHashTable.hpp&quot;</span>
  
  class CompactHashtableWriter;
  class SerializeClosure;
  
  class StringTable;
  class StringTableConfig;
<span class="line-removed">- typedef ConcurrentHashTable&lt;WeakHandle&lt;vm_string_table_data&gt;,</span>
<span class="line-removed">-                             StringTableConfig, mtSymbol&gt; StringTableHash;</span>
<span class="line-removed">- </span>
  class StringTableCreateEntry;
  
  class StringTable : public CHeapObj&lt;mtSymbol&gt;{
    friend class VMStructs;
    friend class Symbol;
    friend class StringTableConfig;
    friend class StringTableCreateEntry;
  
<span class="line-modified">! private:</span>
<span class="line-modified">!   void grow(JavaThread* jt);</span>
<span class="line-removed">-   void clean_dead_entries(JavaThread* jt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The string table</span>
<span class="line-removed">-   static StringTable* _the_table;</span>
<span class="line-removed">-   static volatile bool _alt_hash;</span>
  
<span class="line-removed">- private:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   StringTableHash* _local_table;</span>
<span class="line-removed">-   size_t _current_size;</span>
<span class="line-removed">-   volatile bool _has_work;</span>
    // Set if one bucket is out of balance due to hash algorithm deficiency
<span class="line-modified">!   volatile bool _needs_rehashing;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   OopStorage* _weak_handles;</span>
  
<span class="line-modified">!   volatile size_t _items_count;</span>
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
<span class="line-removed">-   volatile size_t _uncleaned_items_count;</span>
<span class="line-removed">-   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
  
<span class="line-modified">!   double get_load_factor() const;</span>
<span class="line-modified">!   double get_dead_factor() const;</span>
  
<span class="line-modified">!   void check_concurrent_work();</span>
<span class="line-modified">!   void trigger_concurrent_work();</span>
  
    static size_t item_added();
    static void item_removed();
<span class="line-modified">!   size_t add_items_to_clean(size_t ndead);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   StringTable();</span>
  
    static oop intern(Handle string_or_null_h, const jchar* name, int len, TRAPS);
<span class="line-modified">!   oop do_intern(Handle string_or_null, const jchar* name, int len, uintx hash, TRAPS);</span>
<span class="line-modified">!   oop do_lookup(const jchar* name, int len, uintx hash);</span>
  
<span class="line-modified">!   void concurrent_work(JavaThread* jt);</span>
<span class="line-removed">-   void print_table_statistics(outputStream* st, const char* table_name);</span>
  
<span class="line-modified">!   void try_rehash_table();</span>
<span class="line-removed">-   bool do_rehash();</span>
<span class="line-removed">-   inline void update_needs_rehash(bool rehash);</span>
  
   public:
<span class="line-modified">!   // The string table</span>
<span class="line-modified">!   static StringTable* the_table() { return _the_table; }</span>
<span class="line-removed">-   size_t table_size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static OopStorage* weak_storage() { return the_table()-&gt;_weak_handles; }</span>
  
<span class="line-modified">!   static void create_table() {</span>
<span class="line-removed">-     assert(_the_table == NULL, &quot;One string table allowed.&quot;);</span>
<span class="line-removed">-     _the_table = new StringTable();</span>
<span class="line-removed">-   }</span>
  
    static void do_concurrent_work(JavaThread* jt);
<span class="line-modified">!   static bool has_work() { return the_table()-&gt;_has_work; }</span>
  
    // GC support
  
    // Must be called before a parallel walk where strings might die.
<span class="line-modified">!   static void reset_dead_counter() {</span>
<span class="line-modified">!     the_table()-&gt;_uncleaned_items_count = 0;</span>
<span class="line-removed">-   }</span>
    // After the parallel walk this method must be called to trigger
    // cleaning. Note it might trigger a resize instead.
<span class="line-modified">!   static void finish_dead_counter() {</span>
<span class="line-removed">-     the_table()-&gt;check_concurrent_work();</span>
<span class="line-removed">-   }</span>
  
    // If GC uses ParState directly it should add the number of cleared
    // strings to this method.
<span class="line-modified">!   static void inc_dead_counter(size_t ndead) {</span>
<span class="line-removed">-     the_table()-&gt;add_items_to_clean(ndead);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Serially invoke &quot;f-&gt;do_oop&quot; on the locations of all oops in the table.</span>
<span class="line-removed">-   static void oops_do(OopClosure* f);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Possibly parallel versions of the above</span>
<span class="line-removed">-   static void possibly_parallel_oops_do(</span>
<span class="line-removed">-      OopStorage::ParState&lt;false /* concurrent */, false /* const*/&gt;* par_state_string,</span>
<span class="line-removed">-      OopClosure* f);</span>
  
    // Probing
    static oop lookup(Symbol* symbol);
    static oop lookup(const jchar* chars, int length);
  
<span class="line-new-header">--- 23,78 ---</span>
   */
  
  #ifndef SHARE_CLASSFILE_STRINGTABLE_HPP
  #define SHARE_CLASSFILE_STRINGTABLE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
  #include &quot;oops/oop.hpp&quot;
  #include &quot;oops/weakHandle.hpp&quot;
<span class="line-modified">! #include &quot;utilities/tableStatistics.hpp&quot;</span>
  
  class CompactHashtableWriter;
<span class="line-added">+ class JavaThread;</span>
  class SerializeClosure;
  
  class StringTable;
  class StringTableConfig;
  class StringTableCreateEntry;
  
  class StringTable : public CHeapObj&lt;mtSymbol&gt;{
    friend class VMStructs;
    friend class Symbol;
    friend class StringTableConfig;
    friend class StringTableCreateEntry;
  
<span class="line-modified">!   static volatile bool _has_work;</span>
<span class="line-modified">!   static volatile size_t _uncleaned_items_count;</span>
  
    // Set if one bucket is out of balance due to hash algorithm deficiency
<span class="line-modified">!   static volatile bool _needs_rehashing;</span>
  
<span class="line-modified">!   static void grow(JavaThread* jt);</span>
<span class="line-modified">!   static void clean_dead_entries(JavaThread* jt);</span>
  
<span class="line-modified">!   static double get_load_factor();</span>
<span class="line-modified">!   static double get_dead_factor();</span>
  
<span class="line-modified">!   static void check_concurrent_work();</span>
<span class="line-modified">!   static void trigger_concurrent_work();</span>
  
    static size_t item_added();
    static void item_removed();
<span class="line-modified">!   static size_t add_items_to_clean(size_t ndead);</span>
  
    static oop intern(Handle string_or_null_h, const jchar* name, int len, TRAPS);
<span class="line-modified">!   static oop do_intern(Handle string_or_null, const jchar* name, int len, uintx hash, TRAPS);</span>
<span class="line-modified">!   static oop do_lookup(const jchar* name, int len, uintx hash);</span>
  
<span class="line-modified">!   static void print_table_statistics(outputStream* st, const char* table_name);</span>
  
<span class="line-modified">!   static bool do_rehash();</span>
  
   public:
<span class="line-modified">!   static size_t table_size();</span>
<span class="line-modified">!   static TableStatistics get_table_statistics();</span>
  
<span class="line-modified">!   static void create_table();</span>
  
    static void do_concurrent_work(JavaThread* jt);
<span class="line-modified">!   static bool has_work() { return _has_work; }</span>
  
    // GC support
  
    // Must be called before a parallel walk where strings might die.
<span class="line-modified">!   static void reset_dead_counter() { _uncleaned_items_count = 0; }</span>
<span class="line-modified">! </span>
    // After the parallel walk this method must be called to trigger
    // cleaning. Note it might trigger a resize instead.
<span class="line-modified">!   static void finish_dead_counter() { check_concurrent_work(); }</span>
  
    // If GC uses ParState directly it should add the number of cleared
    // strings to this method.
<span class="line-modified">!   static void inc_dead_counter(size_t ndead) { add_items_to_clean(ndead); }</span>
  
    // Probing
    static oop lookup(Symbol* symbol);
    static oop lookup(const jchar* chars, int length);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,16 ***</span>
    static oop intern(oop string, TRAPS);
    static oop intern(const char *utf8_string, TRAPS);
  
    // Rehash the string table if it gets out of balance
    static void rehash_table();
<span class="line-modified">!   static bool needs_rehashing()</span>
<span class="line-modified">!     { return StringTable::the_table()-&gt;_needs_rehashing; }</span>
  
    // Sharing
   private:
<span class="line-modified">!   oop lookup_shared(const jchar* name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(NULL);</span>
    static void copy_shared_string_table(CompactHashtableWriter* ch_table) NOT_CDS_JAVA_HEAP_RETURN;
   public:
    static oop create_archived_string(oop s, Thread* THREAD) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
    static void shared_oops_do(OopClosure* f) NOT_CDS_JAVA_HEAP_RETURN;
    static void write_to_archive() NOT_CDS_JAVA_HEAP_RETURN;
<span class="line-new-header">--- 103,20 ---</span>
    static oop intern(oop string, TRAPS);
    static oop intern(const char *utf8_string, TRAPS);
  
    // Rehash the string table if it gets out of balance
    static void rehash_table();
<span class="line-modified">!   static bool needs_rehashing() { return _needs_rehashing; }</span>
<span class="line-modified">!   static inline void update_needs_rehash(bool rehash) {</span>
<span class="line-added">+     if (rehash) {</span>
<span class="line-added">+       _needs_rehashing = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
    // Sharing
   private:
<span class="line-modified">!   static oop lookup_shared(const jchar* name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(NULL);</span>
    static void copy_shared_string_table(CompactHashtableWriter* ch_table) NOT_CDS_JAVA_HEAP_RETURN;
   public:
    static oop create_archived_string(oop s, Thread* THREAD) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
    static void shared_oops_do(OopClosure* f) NOT_CDS_JAVA_HEAP_RETURN;
    static void write_to_archive() NOT_CDS_JAVA_HEAP_RETURN;
</pre>
<center><a href="stringTable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="symbolTable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
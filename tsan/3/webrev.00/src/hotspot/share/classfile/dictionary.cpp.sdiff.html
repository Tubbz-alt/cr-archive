<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/dictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="defaultMethods.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/dictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/metaspaceClosure.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed"> 36 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed"> 37 #include &quot;runtime/orderAccess.hpp&quot;</span>
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/safepointVerifiers.hpp&quot;
 40 #include &quot;utilities/hashtable.inline.hpp&quot;
 41 
 42 // Optimization: if any dictionary needs resizing, we set this flag,
 43 // so that we dont&#39;t have to walk all dictionaries to check if any actually
 44 // needs resizing, which is costly to do at Safepoint.
 45 bool Dictionary::_some_dictionary_needs_resizing = false;
 46 
 47 Dictionary::Dictionary(ClassLoaderData* loader_data, int table_size, bool resizable)
 48   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry)),
 49     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 50 };
 51 
 52 
 53 Dictionary::Dictionary(ClassLoaderData* loader_data,
 54                        int table_size, HashtableBucket&lt;mtClass&gt;* t,
 55                        int number_of_entries, bool resizable)
 56   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry), t, number_of_entries),
 57     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
</pre>
<hr />
<pre>
134       // We have reached the limit, turn resizing off
135       _resizable = false;
136     }
137     if ((desired_size != 0) &amp;&amp; (desired_size != table_size())) {
138       if (!resize(desired_size)) {
139         // Something went wrong, turn resizing off
140         _resizable = false;
141       }
142     }
143   }
144 
145   _needs_resizing = false;
146   Dictionary::_some_dictionary_needs_resizing = false;
147 
148   return (desired_size != 0);
149 }
150 
151 bool DictionaryEntry::contains_protection_domain(oop protection_domain) const {
152   // Lock the pd_set list.  This lock cannot safepoint since the caller holds
153   // a Dictionary entry, which can be moved if the Dictionary is resized.
<span class="line-modified">154   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
155 #ifdef ASSERT
<span class="line-modified">156   if (oopDesc::equals(protection_domain, instance_klass()-&gt;protection_domain())) {</span>
157     // Ensure this doesn&#39;t show up in the pd_set (invariant)
158     bool in_pd_set = false;
159     for (ProtectionDomainEntry* current = pd_set();
160                                 current != NULL;
161                                 current = current-&gt;next()) {
<span class="line-modified">162       if (oopDesc::equals(current-&gt;object_no_keepalive(), protection_domain)) {</span>
163         in_pd_set = true;
164         break;
165       }
166     }
167     if (in_pd_set) {
168       assert(false, &quot;A klass&#39;s protection domain should not show up &quot;
169                     &quot;in its sys. dict. PD set&quot;);
170     }
171   }
172 #endif /* ASSERT */
173 
<span class="line-modified">174   if (oopDesc::equals(protection_domain, instance_klass()-&gt;protection_domain())) {</span>
175     // Succeeds trivially
176     return true;
177   }
178 
179   for (ProtectionDomainEntry* current = pd_set();
180                               current != NULL;
181                               current = current-&gt;next()) {
<span class="line-modified">182     if (oopDesc::equals(current-&gt;object_no_keepalive(), protection_domain)) return true;</span>
183   }
184   return false;
185 }
186 
187 
188 void DictionaryEntry::add_protection_domain(Dictionary* dict, Handle protection_domain) {
189   assert_locked_or_safepoint(SystemDictionary_lock);
190   if (!contains_protection_domain(protection_domain())) {
191     ProtectionDomainCacheEntry* entry = SystemDictionary::cache_get(protection_domain);
192     // The pd_set in the dictionary entry is protected by a low level lock.
193     // With concurrent PD table cleanup, these links could be broken.
<span class="line-modified">194     MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
195     ProtectionDomainEntry* new_head =
196                 new ProtectionDomainEntry(entry, pd_set());
197     set_pd_set(new_head);
198   }
199   LogTarget(Trace, protectiondomain) lt;
200   if (lt.is_enabled()) {
201     LogStream ls(lt);
202     print_count(&amp;ls);
203   }
204 }
205 
206 //   Just the classes from defining class loaders
207 void Dictionary::classes_do(void f(InstanceKlass*)) {
208   for (int index = 0; index &lt; table_size(); index++) {
209     for (DictionaryEntry* probe = bucket(index);
210                           probe != NULL;
211                           probe = probe-&gt;next()) {
212       InstanceKlass* k = probe-&gt;instance_klass();
213       if (loader_data() == k-&gt;class_loader_data()) {
214         f(k);
</pre>
<hr />
<pre>
229         f(k, CHECK);
230       }
231     }
232   }
233 }
234 
235 // All classes, and their class loaders, including initiating class loaders
236 void Dictionary::all_entries_do(KlassClosure* closure) {
237   for (int index = 0; index &lt; table_size(); index++) {
238     for (DictionaryEntry* probe = bucket(index);
239                           probe != NULL;
240                           probe = probe-&gt;next()) {
241       InstanceKlass* k = probe-&gt;instance_klass();
242       closure-&gt;do_klass(k);
243     }
244   }
245 }
246 
247 // Used to scan and relocate the classes during CDS archive dump.
248 void Dictionary::classes_do(MetaspaceClosure* it) {
<span class="line-modified">249   assert(DumpSharedSpaces, &quot;dump-time only&quot;);</span>
250   for (int index = 0; index &lt; table_size(); index++) {
251     for (DictionaryEntry* probe = bucket(index);
252                           probe != NULL;
253                           probe = probe-&gt;next()) {
254       it-&gt;push(probe-&gt;klass_addr());
255     }
256   }
257 }
258 
259 
260 
261 // Add a loaded class to the dictionary.
262 // Readers of the SystemDictionary aren&#39;t always locked, so _buckets
263 // is volatile. The store of the next field in the constructor is
264 // also cast to volatile;  we do this to ensure store order is maintained
265 // by the compilers.
266 
267 void Dictionary::add_klass(unsigned int hash, Symbol* class_name,
268                            InstanceKlass* obj) {
269   assert_locked_or_safepoint(SystemDictionary_lock);
</pre>
<hr />
<pre>
295       return entry;
296     }
297   }
298   return NULL;
299 }
300 
301 
302 InstanceKlass* Dictionary::find(unsigned int hash, Symbol* name,
303                                 Handle protection_domain) {
304   NoSafepointVerifier nsv;
305 
306   int index = hash_to_index(hash);
307   DictionaryEntry* entry = get_entry(index, hash, name);
308   if (entry != NULL &amp;&amp; entry-&gt;is_valid_protection_domain(protection_domain)) {
309     return entry-&gt;instance_klass();
310   } else {
311     return NULL;
312   }
313 }
314 
<span class="line-removed">315 </span>
316 InstanceKlass* Dictionary::find_class(int index, unsigned int hash,
317                                       Symbol* name) {
318   assert_locked_or_safepoint(SystemDictionary_lock);
319   assert (index == index_for(name), &quot;incorrect index?&quot;);
320 
321   DictionaryEntry* entry = get_entry(index, hash, name);
322   return (entry != NULL) ? entry-&gt;instance_klass() : NULL;
323 }
324 
325 
326 void Dictionary::add_protection_domain(int index, unsigned int hash,
327                                        InstanceKlass* klass,
328                                        Handle protection_domain,
329                                        TRAPS) {
330   Symbol*  klass_name = klass-&gt;name();
331   DictionaryEntry* entry = get_entry(index, hash, klass_name);
332 
333   assert(entry != NULL,&quot;entry must be present, we just created it&quot;);
334   assert(protection_domain() != NULL,
335          &quot;real protection domain should be present&quot;);
</pre>
<hr />
<pre>
352   DictionaryEntry* entry = get_entry(index, hash, name);
353   return entry-&gt;is_valid_protection_domain(protection_domain);
354 }
355 
356 // During class loading we may have cached a protection domain that has
357 // since been unreferenced, so this entry should be cleared.
358 void Dictionary::clean_cached_protection_domains() {
359   assert_locked_or_safepoint(SystemDictionary_lock);
360 
361   if (loader_data()-&gt;is_the_null_class_loader_data()) {
362     // Classes in the boot loader are not loaded with protection domains
363     return;
364   }
365 
366   for (int index = 0; index &lt; table_size(); index++) {
367     for (DictionaryEntry* probe = bucket(index);
368                           probe != NULL;
369                           probe = probe-&gt;next()) {
370       Klass* e = probe-&gt;instance_klass();
371 
<span class="line-modified">372       MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
373       ProtectionDomainEntry* current = probe-&gt;pd_set();
374       ProtectionDomainEntry* prev = NULL;
375       while (current != NULL) {
376         if (current-&gt;object_no_keepalive() == NULL) {
377           LogTarget(Debug, protectiondomain) lt;
378           if (lt.is_enabled()) {
379             ResourceMark rm;
380             // Print out trace information
381             LogStream ls(lt);
382             ls.print_cr(&quot;PD in set is not alive:&quot;);
383             ls.print(&quot;class loader: &quot;); loader_data()-&gt;class_loader()-&gt;print_value_on(&amp;ls);
384             ls.print(&quot; loading: &quot;); probe-&gt;instance_klass()-&gt;print_value_on(&amp;ls);
385             ls.cr();
386           }
387           if (probe-&gt;pd_set() == current) {
388             probe-&gt;set_pd_set(current-&gt;next());
389           } else {
390             assert(prev != NULL, &quot;should be set by alive entry&quot;);
391             prev-&gt;set_next(current-&gt;next());
392           }
</pre>
<hr />
<pre>
443     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
444       if (p-&gt;method_type() != NULL) {
445         f-&gt;do_oop(p-&gt;method_type_addr());
446       }
447     }
448   }
449 }
450 
451 void SymbolPropertyTable::methods_do(void f(Method*)) {
452   for (int index = 0; index &lt; table_size(); index++) {
453     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
454       Method* prop = p-&gt;method();
455       if (prop != NULL) {
456         f((Method*)prop);
457       }
458     }
459   }
460 }
461 
462 void DictionaryEntry::verify_protection_domain_set() {
<span class="line-modified">463   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
464   for (ProtectionDomainEntry* current = pd_set(); // accessed at a safepoint
465                               current != NULL;
466                               current = current-&gt;_next) {
467     guarantee(oopDesc::is_oop_or_null(current-&gt;_pd_cache-&gt;object_no_keepalive()), &quot;Invalid oop&quot;);
468   }
469 }
470 
471 void DictionaryEntry::print_count(outputStream *st) {
<span class="line-modified">472   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
473   int count = 0;
474   for (ProtectionDomainEntry* current = pd_set();  // accessed inside SD lock
475                               current != NULL;
476                               current = current-&gt;_next) {
477     count++;
478   }
479   st-&gt;print_cr(&quot;pd set count = #%d&quot;, count);
480 }
481 
482 // ----------------------------------------------------------------------------
483 
484 void Dictionary::print_on(outputStream* st) const {
485   ResourceMark rm;
486 
487   assert(loader_data() != NULL, &quot;loader data should not be null&quot;);
488   st-&gt;print_cr(&quot;Java dictionary (table_size=%d, classes=%d, resizable=%s)&quot;,
489                table_size(), number_of_entries(), BOOL_TO_STR(_resizable));
490   st-&gt;print_cr(&quot;^ indicates that initiating loader is different from defining loader&quot;);
491 
492   for (int index = 0; index &lt; table_size(); index++) {
</pre>
</td>
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/metaspaceClosure.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;


 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/safepointVerifiers.hpp&quot;
 38 #include &quot;utilities/hashtable.inline.hpp&quot;
 39 
 40 // Optimization: if any dictionary needs resizing, we set this flag,
 41 // so that we dont&#39;t have to walk all dictionaries to check if any actually
 42 // needs resizing, which is costly to do at Safepoint.
 43 bool Dictionary::_some_dictionary_needs_resizing = false;
 44 
 45 Dictionary::Dictionary(ClassLoaderData* loader_data, int table_size, bool resizable)
 46   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry)),
 47     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 48 };
 49 
 50 
 51 Dictionary::Dictionary(ClassLoaderData* loader_data,
 52                        int table_size, HashtableBucket&lt;mtClass&gt;* t,
 53                        int number_of_entries, bool resizable)
 54   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry), t, number_of_entries),
 55     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
</pre>
<hr />
<pre>
132       // We have reached the limit, turn resizing off
133       _resizable = false;
134     }
135     if ((desired_size != 0) &amp;&amp; (desired_size != table_size())) {
136       if (!resize(desired_size)) {
137         // Something went wrong, turn resizing off
138         _resizable = false;
139       }
140     }
141   }
142 
143   _needs_resizing = false;
144   Dictionary::_some_dictionary_needs_resizing = false;
145 
146   return (desired_size != 0);
147 }
148 
149 bool DictionaryEntry::contains_protection_domain(oop protection_domain) const {
150   // Lock the pd_set list.  This lock cannot safepoint since the caller holds
151   // a Dictionary entry, which can be moved if the Dictionary is resized.
<span class="line-modified">152   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
153 #ifdef ASSERT
<span class="line-modified">154   if (protection_domain == instance_klass()-&gt;protection_domain()) {</span>
155     // Ensure this doesn&#39;t show up in the pd_set (invariant)
156     bool in_pd_set = false;
157     for (ProtectionDomainEntry* current = pd_set();
158                                 current != NULL;
159                                 current = current-&gt;next()) {
<span class="line-modified">160       if (current-&gt;object_no_keepalive() == protection_domain) {</span>
161         in_pd_set = true;
162         break;
163       }
164     }
165     if (in_pd_set) {
166       assert(false, &quot;A klass&#39;s protection domain should not show up &quot;
167                     &quot;in its sys. dict. PD set&quot;);
168     }
169   }
170 #endif /* ASSERT */
171 
<span class="line-modified">172   if (protection_domain == instance_klass()-&gt;protection_domain()) {</span>
173     // Succeeds trivially
174     return true;
175   }
176 
177   for (ProtectionDomainEntry* current = pd_set();
178                               current != NULL;
179                               current = current-&gt;next()) {
<span class="line-modified">180     if (current-&gt;object_no_keepalive() == protection_domain) return true;</span>
181   }
182   return false;
183 }
184 
185 
186 void DictionaryEntry::add_protection_domain(Dictionary* dict, Handle protection_domain) {
187   assert_locked_or_safepoint(SystemDictionary_lock);
188   if (!contains_protection_domain(protection_domain())) {
189     ProtectionDomainCacheEntry* entry = SystemDictionary::cache_get(protection_domain);
190     // The pd_set in the dictionary entry is protected by a low level lock.
191     // With concurrent PD table cleanup, these links could be broken.
<span class="line-modified">192     MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
193     ProtectionDomainEntry* new_head =
194                 new ProtectionDomainEntry(entry, pd_set());
195     set_pd_set(new_head);
196   }
197   LogTarget(Trace, protectiondomain) lt;
198   if (lt.is_enabled()) {
199     LogStream ls(lt);
200     print_count(&amp;ls);
201   }
202 }
203 
204 //   Just the classes from defining class loaders
205 void Dictionary::classes_do(void f(InstanceKlass*)) {
206   for (int index = 0; index &lt; table_size(); index++) {
207     for (DictionaryEntry* probe = bucket(index);
208                           probe != NULL;
209                           probe = probe-&gt;next()) {
210       InstanceKlass* k = probe-&gt;instance_klass();
211       if (loader_data() == k-&gt;class_loader_data()) {
212         f(k);
</pre>
<hr />
<pre>
227         f(k, CHECK);
228       }
229     }
230   }
231 }
232 
233 // All classes, and their class loaders, including initiating class loaders
234 void Dictionary::all_entries_do(KlassClosure* closure) {
235   for (int index = 0; index &lt; table_size(); index++) {
236     for (DictionaryEntry* probe = bucket(index);
237                           probe != NULL;
238                           probe = probe-&gt;next()) {
239       InstanceKlass* k = probe-&gt;instance_klass();
240       closure-&gt;do_klass(k);
241     }
242   }
243 }
244 
245 // Used to scan and relocate the classes during CDS archive dump.
246 void Dictionary::classes_do(MetaspaceClosure* it) {
<span class="line-modified">247   Arguments::assert_is_dumping_archive();</span>
248   for (int index = 0; index &lt; table_size(); index++) {
249     for (DictionaryEntry* probe = bucket(index);
250                           probe != NULL;
251                           probe = probe-&gt;next()) {
252       it-&gt;push(probe-&gt;klass_addr());
253     }
254   }
255 }
256 
257 
258 
259 // Add a loaded class to the dictionary.
260 // Readers of the SystemDictionary aren&#39;t always locked, so _buckets
261 // is volatile. The store of the next field in the constructor is
262 // also cast to volatile;  we do this to ensure store order is maintained
263 // by the compilers.
264 
265 void Dictionary::add_klass(unsigned int hash, Symbol* class_name,
266                            InstanceKlass* obj) {
267   assert_locked_or_safepoint(SystemDictionary_lock);
</pre>
<hr />
<pre>
293       return entry;
294     }
295   }
296   return NULL;
297 }
298 
299 
300 InstanceKlass* Dictionary::find(unsigned int hash, Symbol* name,
301                                 Handle protection_domain) {
302   NoSafepointVerifier nsv;
303 
304   int index = hash_to_index(hash);
305   DictionaryEntry* entry = get_entry(index, hash, name);
306   if (entry != NULL &amp;&amp; entry-&gt;is_valid_protection_domain(protection_domain)) {
307     return entry-&gt;instance_klass();
308   } else {
309     return NULL;
310   }
311 }
312 

313 InstanceKlass* Dictionary::find_class(int index, unsigned int hash,
314                                       Symbol* name) {
315   assert_locked_or_safepoint(SystemDictionary_lock);
316   assert (index == index_for(name), &quot;incorrect index?&quot;);
317 
318   DictionaryEntry* entry = get_entry(index, hash, name);
319   return (entry != NULL) ? entry-&gt;instance_klass() : NULL;
320 }
321 
322 
323 void Dictionary::add_protection_domain(int index, unsigned int hash,
324                                        InstanceKlass* klass,
325                                        Handle protection_domain,
326                                        TRAPS) {
327   Symbol*  klass_name = klass-&gt;name();
328   DictionaryEntry* entry = get_entry(index, hash, klass_name);
329 
330   assert(entry != NULL,&quot;entry must be present, we just created it&quot;);
331   assert(protection_domain() != NULL,
332          &quot;real protection domain should be present&quot;);
</pre>
<hr />
<pre>
349   DictionaryEntry* entry = get_entry(index, hash, name);
350   return entry-&gt;is_valid_protection_domain(protection_domain);
351 }
352 
353 // During class loading we may have cached a protection domain that has
354 // since been unreferenced, so this entry should be cleared.
355 void Dictionary::clean_cached_protection_domains() {
356   assert_locked_or_safepoint(SystemDictionary_lock);
357 
358   if (loader_data()-&gt;is_the_null_class_loader_data()) {
359     // Classes in the boot loader are not loaded with protection domains
360     return;
361   }
362 
363   for (int index = 0; index &lt; table_size(); index++) {
364     for (DictionaryEntry* probe = bucket(index);
365                           probe != NULL;
366                           probe = probe-&gt;next()) {
367       Klass* e = probe-&gt;instance_klass();
368 
<span class="line-modified">369       MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
370       ProtectionDomainEntry* current = probe-&gt;pd_set();
371       ProtectionDomainEntry* prev = NULL;
372       while (current != NULL) {
373         if (current-&gt;object_no_keepalive() == NULL) {
374           LogTarget(Debug, protectiondomain) lt;
375           if (lt.is_enabled()) {
376             ResourceMark rm;
377             // Print out trace information
378             LogStream ls(lt);
379             ls.print_cr(&quot;PD in set is not alive:&quot;);
380             ls.print(&quot;class loader: &quot;); loader_data()-&gt;class_loader()-&gt;print_value_on(&amp;ls);
381             ls.print(&quot; loading: &quot;); probe-&gt;instance_klass()-&gt;print_value_on(&amp;ls);
382             ls.cr();
383           }
384           if (probe-&gt;pd_set() == current) {
385             probe-&gt;set_pd_set(current-&gt;next());
386           } else {
387             assert(prev != NULL, &quot;should be set by alive entry&quot;);
388             prev-&gt;set_next(current-&gt;next());
389           }
</pre>
<hr />
<pre>
440     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
441       if (p-&gt;method_type() != NULL) {
442         f-&gt;do_oop(p-&gt;method_type_addr());
443       }
444     }
445   }
446 }
447 
448 void SymbolPropertyTable::methods_do(void f(Method*)) {
449   for (int index = 0; index &lt; table_size(); index++) {
450     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
451       Method* prop = p-&gt;method();
452       if (prop != NULL) {
453         f((Method*)prop);
454       }
455     }
456   }
457 }
458 
459 void DictionaryEntry::verify_protection_domain_set() {
<span class="line-modified">460   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
461   for (ProtectionDomainEntry* current = pd_set(); // accessed at a safepoint
462                               current != NULL;
463                               current = current-&gt;_next) {
464     guarantee(oopDesc::is_oop_or_null(current-&gt;_pd_cache-&gt;object_no_keepalive()), &quot;Invalid oop&quot;);
465   }
466 }
467 
468 void DictionaryEntry::print_count(outputStream *st) {
<span class="line-modified">469   MutexLocker ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);</span>
470   int count = 0;
471   for (ProtectionDomainEntry* current = pd_set();  // accessed inside SD lock
472                               current != NULL;
473                               current = current-&gt;_next) {
474     count++;
475   }
476   st-&gt;print_cr(&quot;pd set count = #%d&quot;, count);
477 }
478 
479 // ----------------------------------------------------------------------------
480 
481 void Dictionary::print_on(outputStream* st) const {
482   ResourceMark rm;
483 
484   assert(loader_data() != NULL, &quot;loader data should not be null&quot;);
485   st-&gt;print_cr(&quot;Java dictionary (table_size=%d, classes=%d, resizable=%s)&quot;,
486                table_size(), number_of_entries(), BOOL_TO_STR(_resizable));
487   st-&gt;print_cr(&quot;^ indicates that initiating loader is different from defining loader&quot;);
488 
489   for (int index = 0; index &lt; table_size(); index++) {
</pre>
</td>
</tr>
</table>
<center><a href="defaultMethods.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="dictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
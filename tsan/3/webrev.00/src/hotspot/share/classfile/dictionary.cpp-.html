<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/dictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/metaspaceClosure.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/atomic.hpp&quot;
 37 #include &quot;runtime/orderAccess.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/safepointVerifiers.hpp&quot;
 40 #include &quot;utilities/hashtable.inline.hpp&quot;
 41 
 42 // Optimization: if any dictionary needs resizing, we set this flag,
 43 // so that we dont&#39;t have to walk all dictionaries to check if any actually
 44 // needs resizing, which is costly to do at Safepoint.
 45 bool Dictionary::_some_dictionary_needs_resizing = false;
 46 
 47 Dictionary::Dictionary(ClassLoaderData* loader_data, int table_size, bool resizable)
 48   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry)),
 49     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 50 };
 51 
 52 
 53 Dictionary::Dictionary(ClassLoaderData* loader_data,
 54                        int table_size, HashtableBucket&lt;mtClass&gt;* t,
 55                        int number_of_entries, bool resizable)
 56   : Hashtable&lt;InstanceKlass*, mtClass&gt;(table_size, (int)sizeof(DictionaryEntry), t, number_of_entries),
 57     _resizable(resizable), _needs_resizing(false), _loader_data(loader_data) {
 58 };
 59 
 60 Dictionary::~Dictionary() {
 61   DictionaryEntry* probe = NULL;
 62   for (int index = 0; index &lt; table_size(); index++) {
 63     for (DictionaryEntry** p = bucket_addr(index); *p != NULL; ) {
 64       probe = *p;
 65       *p = probe-&gt;next();
 66       free_entry(probe);
 67     }
 68   }
 69   assert(number_of_entries() == 0, &quot;should have removed all entries&quot;);
 70   assert(new_entry_free_list() == NULL, &quot;entry present on Dictionary&#39;s free list&quot;);
 71 }
 72 
 73 DictionaryEntry* Dictionary::new_entry(unsigned int hash, InstanceKlass* klass) {
 74   DictionaryEntry* entry = (DictionaryEntry*)Hashtable&lt;InstanceKlass*, mtClass&gt;::allocate_new_entry(hash, klass);
 75   entry-&gt;set_pd_set(NULL);
 76   assert(klass-&gt;is_instance_klass(), &quot;Must be&quot;);
 77   return entry;
 78 }
 79 
 80 
 81 void Dictionary::free_entry(DictionaryEntry* entry) {
 82   // avoid recursion when deleting linked list
 83   // pd_set is accessed during a safepoint.
 84   // This doesn&#39;t require a lock because nothing is reading this
 85   // entry anymore.  The ClassLoader is dead.
 86   while (entry-&gt;pd_set() != NULL) {
 87     ProtectionDomainEntry* to_delete = entry-&gt;pd_set();
 88     entry-&gt;set_pd_set(to_delete-&gt;next());
 89     delete to_delete;
 90   }
 91   // Unlink from the Hashtable prior to freeing
 92   unlink_entry(entry);
 93   FREE_C_HEAP_ARRAY(char, entry);
 94 }
 95 
 96 const int _resize_load_trigger = 5;       // load factor that will trigger the resize
 97 const double _resize_factor    = 2.0;     // by how much we will resize using current number of entries
 98 const int _resize_max_size     = 40423;   // the max dictionary size allowed
 99 const int _primelist[] = {107, 1009, 2017, 4049, 5051, 10103, 20201, _resize_max_size};
100 const int _prime_array_size = sizeof(_primelist)/sizeof(int);
101 
102 // Calculate next &quot;good&quot; dictionary size based on requested count
103 static int calculate_dictionary_size(int requested) {
104   int newsize = _primelist[0];
105   int index = 0;
106   for (newsize = _primelist[index]; index &lt; (_prime_array_size - 1);
107        newsize = _primelist[++index]) {
108     if (requested &lt;= newsize) {
109       break;
110     }
111   }
112   return newsize;
113 }
114 
115 bool Dictionary::does_any_dictionary_needs_resizing() {
116   return Dictionary::_some_dictionary_needs_resizing;
117 }
118 
119 void Dictionary::check_if_needs_resize() {
120   if (_resizable == true) {
121     if (number_of_entries() &gt; (_resize_load_trigger*table_size())) {
122       _needs_resizing = true;
123       Dictionary::_some_dictionary_needs_resizing = true;
124     }
125   }
126 }
127 
128 bool Dictionary::resize_if_needed() {
129   int desired_size = 0;
130   if (_needs_resizing == true) {
131     desired_size = calculate_dictionary_size((int)(_resize_factor*number_of_entries()));
132     if (desired_size &gt;= _resize_max_size) {
133       desired_size = _resize_max_size;
134       // We have reached the limit, turn resizing off
135       _resizable = false;
136     }
137     if ((desired_size != 0) &amp;&amp; (desired_size != table_size())) {
138       if (!resize(desired_size)) {
139         // Something went wrong, turn resizing off
140         _resizable = false;
141       }
142     }
143   }
144 
145   _needs_resizing = false;
146   Dictionary::_some_dictionary_needs_resizing = false;
147 
148   return (desired_size != 0);
149 }
150 
151 bool DictionaryEntry::contains_protection_domain(oop protection_domain) const {
152   // Lock the pd_set list.  This lock cannot safepoint since the caller holds
153   // a Dictionary entry, which can be moved if the Dictionary is resized.
154   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
155 #ifdef ASSERT
156   if (oopDesc::equals(protection_domain, instance_klass()-&gt;protection_domain())) {
157     // Ensure this doesn&#39;t show up in the pd_set (invariant)
158     bool in_pd_set = false;
159     for (ProtectionDomainEntry* current = pd_set();
160                                 current != NULL;
161                                 current = current-&gt;next()) {
162       if (oopDesc::equals(current-&gt;object_no_keepalive(), protection_domain)) {
163         in_pd_set = true;
164         break;
165       }
166     }
167     if (in_pd_set) {
168       assert(false, &quot;A klass&#39;s protection domain should not show up &quot;
169                     &quot;in its sys. dict. PD set&quot;);
170     }
171   }
172 #endif /* ASSERT */
173 
174   if (oopDesc::equals(protection_domain, instance_klass()-&gt;protection_domain())) {
175     // Succeeds trivially
176     return true;
177   }
178 
179   for (ProtectionDomainEntry* current = pd_set();
180                               current != NULL;
181                               current = current-&gt;next()) {
182     if (oopDesc::equals(current-&gt;object_no_keepalive(), protection_domain)) return true;
183   }
184   return false;
185 }
186 
187 
188 void DictionaryEntry::add_protection_domain(Dictionary* dict, Handle protection_domain) {
189   assert_locked_or_safepoint(SystemDictionary_lock);
190   if (!contains_protection_domain(protection_domain())) {
191     ProtectionDomainCacheEntry* entry = SystemDictionary::cache_get(protection_domain);
192     // The pd_set in the dictionary entry is protected by a low level lock.
193     // With concurrent PD table cleanup, these links could be broken.
194     MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
195     ProtectionDomainEntry* new_head =
196                 new ProtectionDomainEntry(entry, pd_set());
197     set_pd_set(new_head);
198   }
199   LogTarget(Trace, protectiondomain) lt;
200   if (lt.is_enabled()) {
201     LogStream ls(lt);
202     print_count(&amp;ls);
203   }
204 }
205 
206 //   Just the classes from defining class loaders
207 void Dictionary::classes_do(void f(InstanceKlass*)) {
208   for (int index = 0; index &lt; table_size(); index++) {
209     for (DictionaryEntry* probe = bucket(index);
210                           probe != NULL;
211                           probe = probe-&gt;next()) {
212       InstanceKlass* k = probe-&gt;instance_klass();
213       if (loader_data() == k-&gt;class_loader_data()) {
214         f(k);
215       }
216     }
217   }
218 }
219 
220 // Added for initialize_itable_for_klass to handle exceptions
221 //   Just the classes from defining class loaders
222 void Dictionary::classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {
223   for (int index = 0; index &lt; table_size(); index++) {
224     for (DictionaryEntry* probe = bucket(index);
225                           probe != NULL;
226                           probe = probe-&gt;next()) {
227       InstanceKlass* k = probe-&gt;instance_klass();
228       if (loader_data() == k-&gt;class_loader_data()) {
229         f(k, CHECK);
230       }
231     }
232   }
233 }
234 
235 // All classes, and their class loaders, including initiating class loaders
236 void Dictionary::all_entries_do(KlassClosure* closure) {
237   for (int index = 0; index &lt; table_size(); index++) {
238     for (DictionaryEntry* probe = bucket(index);
239                           probe != NULL;
240                           probe = probe-&gt;next()) {
241       InstanceKlass* k = probe-&gt;instance_klass();
242       closure-&gt;do_klass(k);
243     }
244   }
245 }
246 
247 // Used to scan and relocate the classes during CDS archive dump.
248 void Dictionary::classes_do(MetaspaceClosure* it) {
249   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
250   for (int index = 0; index &lt; table_size(); index++) {
251     for (DictionaryEntry* probe = bucket(index);
252                           probe != NULL;
253                           probe = probe-&gt;next()) {
254       it-&gt;push(probe-&gt;klass_addr());
255     }
256   }
257 }
258 
259 
260 
261 // Add a loaded class to the dictionary.
262 // Readers of the SystemDictionary aren&#39;t always locked, so _buckets
263 // is volatile. The store of the next field in the constructor is
264 // also cast to volatile;  we do this to ensure store order is maintained
265 // by the compilers.
266 
267 void Dictionary::add_klass(unsigned int hash, Symbol* class_name,
268                            InstanceKlass* obj) {
269   assert_locked_or_safepoint(SystemDictionary_lock);
270   assert(obj != NULL, &quot;adding NULL obj&quot;);
271   assert(obj-&gt;name() == class_name, &quot;sanity check on name&quot;);
272 
273   DictionaryEntry* entry = new_entry(hash, obj);
274   int index = hash_to_index(hash);
275   add_entry(index, entry);
276   check_if_needs_resize();
277 }
278 
279 
280 // This routine does not lock the dictionary.
281 //
282 // Since readers don&#39;t hold a lock, we must make sure that system
283 // dictionary entries are only removed at a safepoint (when only one
284 // thread is running), and are added to in a safe way (all links must
285 // be updated in an MT-safe manner).
286 //
287 // Callers should be aware that an entry could be added just after
288 // _buckets[index] is read here, so the caller will not see the new entry.
289 DictionaryEntry* Dictionary::get_entry(int index, unsigned int hash,
290                                        Symbol* class_name) {
291   for (DictionaryEntry* entry = bucket(index);
292                         entry != NULL;
293                         entry = entry-&gt;next()) {
294     if (entry-&gt;hash() == hash &amp;&amp; entry-&gt;equals(class_name)) {
295       return entry;
296     }
297   }
298   return NULL;
299 }
300 
301 
302 InstanceKlass* Dictionary::find(unsigned int hash, Symbol* name,
303                                 Handle protection_domain) {
304   NoSafepointVerifier nsv;
305 
306   int index = hash_to_index(hash);
307   DictionaryEntry* entry = get_entry(index, hash, name);
308   if (entry != NULL &amp;&amp; entry-&gt;is_valid_protection_domain(protection_domain)) {
309     return entry-&gt;instance_klass();
310   } else {
311     return NULL;
312   }
313 }
314 
315 
316 InstanceKlass* Dictionary::find_class(int index, unsigned int hash,
317                                       Symbol* name) {
318   assert_locked_or_safepoint(SystemDictionary_lock);
319   assert (index == index_for(name), &quot;incorrect index?&quot;);
320 
321   DictionaryEntry* entry = get_entry(index, hash, name);
322   return (entry != NULL) ? entry-&gt;instance_klass() : NULL;
323 }
324 
325 
326 void Dictionary::add_protection_domain(int index, unsigned int hash,
327                                        InstanceKlass* klass,
328                                        Handle protection_domain,
329                                        TRAPS) {
330   Symbol*  klass_name = klass-&gt;name();
331   DictionaryEntry* entry = get_entry(index, hash, klass_name);
332 
333   assert(entry != NULL,&quot;entry must be present, we just created it&quot;);
334   assert(protection_domain() != NULL,
335          &quot;real protection domain should be present&quot;);
336 
337   entry-&gt;add_protection_domain(this, protection_domain);
338 
339 #ifdef ASSERT
340   assert(loader_data() != ClassLoaderData::the_null_class_loader_data(), &quot;doesn&#39;t make sense&quot;);
341 #endif
342 
343   assert(entry-&gt;contains_protection_domain(protection_domain()),
344          &quot;now protection domain should be present&quot;);
345 }
346 
347 
348 bool Dictionary::is_valid_protection_domain(unsigned int hash,
349                                             Symbol* name,
350                                             Handle protection_domain) {
351   int index = hash_to_index(hash);
352   DictionaryEntry* entry = get_entry(index, hash, name);
353   return entry-&gt;is_valid_protection_domain(protection_domain);
354 }
355 
356 // During class loading we may have cached a protection domain that has
357 // since been unreferenced, so this entry should be cleared.
358 void Dictionary::clean_cached_protection_domains() {
359   assert_locked_or_safepoint(SystemDictionary_lock);
360 
361   if (loader_data()-&gt;is_the_null_class_loader_data()) {
362     // Classes in the boot loader are not loaded with protection domains
363     return;
364   }
365 
366   for (int index = 0; index &lt; table_size(); index++) {
367     for (DictionaryEntry* probe = bucket(index);
368                           probe != NULL;
369                           probe = probe-&gt;next()) {
370       Klass* e = probe-&gt;instance_klass();
371 
372       MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
373       ProtectionDomainEntry* current = probe-&gt;pd_set();
374       ProtectionDomainEntry* prev = NULL;
375       while (current != NULL) {
376         if (current-&gt;object_no_keepalive() == NULL) {
377           LogTarget(Debug, protectiondomain) lt;
378           if (lt.is_enabled()) {
379             ResourceMark rm;
380             // Print out trace information
381             LogStream ls(lt);
382             ls.print_cr(&quot;PD in set is not alive:&quot;);
383             ls.print(&quot;class loader: &quot;); loader_data()-&gt;class_loader()-&gt;print_value_on(&amp;ls);
384             ls.print(&quot; loading: &quot;); probe-&gt;instance_klass()-&gt;print_value_on(&amp;ls);
385             ls.cr();
386           }
387           if (probe-&gt;pd_set() == current) {
388             probe-&gt;set_pd_set(current-&gt;next());
389           } else {
390             assert(prev != NULL, &quot;should be set by alive entry&quot;);
391             prev-&gt;set_next(current-&gt;next());
392           }
393           ProtectionDomainEntry* to_delete = current;
394           current = current-&gt;next();
395           delete to_delete;
396         } else {
397           prev = current;
398           current = current-&gt;next();
399         }
400       }
401     }
402   }
403 }
404 
405 
406 SymbolPropertyTable::SymbolPropertyTable(int table_size)
407   : Hashtable&lt;Symbol*, mtSymbol&gt;(table_size, sizeof(SymbolPropertyEntry))
408 {
409 }
410 SymbolPropertyTable::SymbolPropertyTable(int table_size, HashtableBucket&lt;mtSymbol&gt;* t,
411                                          int number_of_entries)
412   : Hashtable&lt;Symbol*, mtSymbol&gt;(table_size, sizeof(SymbolPropertyEntry), t, number_of_entries)
413 {
414 }
415 
416 
417 SymbolPropertyEntry* SymbolPropertyTable::find_entry(int index, unsigned int hash,
418                                                      Symbol* sym,
419                                                      intptr_t sym_mode) {
420   assert(index == index_for(sym, sym_mode), &quot;incorrect index?&quot;);
421   for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
422     if (p-&gt;hash() == hash &amp;&amp; p-&gt;symbol() == sym &amp;&amp; p-&gt;symbol_mode() == sym_mode) {
423       return p;
424     }
425   }
426   return NULL;
427 }
428 
429 
430 SymbolPropertyEntry* SymbolPropertyTable::add_entry(int index, unsigned int hash,
431                                                     Symbol* sym, intptr_t sym_mode) {
432   assert_locked_or_safepoint(SystemDictionary_lock);
433   assert(index == index_for(sym, sym_mode), &quot;incorrect index?&quot;);
434   assert(find_entry(index, hash, sym, sym_mode) == NULL, &quot;no double entry&quot;);
435 
436   SymbolPropertyEntry* p = new_entry(hash, sym, sym_mode);
437   Hashtable&lt;Symbol*, mtSymbol&gt;::add_entry(index, p);
438   return p;
439 }
440 
441 void SymbolPropertyTable::oops_do(OopClosure* f) {
442   for (int index = 0; index &lt; table_size(); index++) {
443     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
444       if (p-&gt;method_type() != NULL) {
445         f-&gt;do_oop(p-&gt;method_type_addr());
446       }
447     }
448   }
449 }
450 
451 void SymbolPropertyTable::methods_do(void f(Method*)) {
452   for (int index = 0; index &lt; table_size(); index++) {
453     for (SymbolPropertyEntry* p = bucket(index); p != NULL; p = p-&gt;next()) {
454       Method* prop = p-&gt;method();
455       if (prop != NULL) {
456         f((Method*)prop);
457       }
458     }
459   }
460 }
461 
462 void DictionaryEntry::verify_protection_domain_set() {
463   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
464   for (ProtectionDomainEntry* current = pd_set(); // accessed at a safepoint
465                               current != NULL;
466                               current = current-&gt;_next) {
467     guarantee(oopDesc::is_oop_or_null(current-&gt;_pd_cache-&gt;object_no_keepalive()), &quot;Invalid oop&quot;);
468   }
469 }
470 
471 void DictionaryEntry::print_count(outputStream *st) {
472   MutexLockerEx ml(ProtectionDomainSet_lock, Mutex::_no_safepoint_check_flag);
473   int count = 0;
474   for (ProtectionDomainEntry* current = pd_set();  // accessed inside SD lock
475                               current != NULL;
476                               current = current-&gt;_next) {
477     count++;
478   }
479   st-&gt;print_cr(&quot;pd set count = #%d&quot;, count);
480 }
481 
482 // ----------------------------------------------------------------------------
483 
484 void Dictionary::print_on(outputStream* st) const {
485   ResourceMark rm;
486 
487   assert(loader_data() != NULL, &quot;loader data should not be null&quot;);
488   st-&gt;print_cr(&quot;Java dictionary (table_size=%d, classes=%d, resizable=%s)&quot;,
489                table_size(), number_of_entries(), BOOL_TO_STR(_resizable));
490   st-&gt;print_cr(&quot;^ indicates that initiating loader is different from defining loader&quot;);
491 
492   for (int index = 0; index &lt; table_size(); index++) {
493     for (DictionaryEntry* probe = bucket(index);
494                           probe != NULL;
495                           probe = probe-&gt;next()) {
496       Klass* e = probe-&gt;instance_klass();
497       bool is_defining_class =
498          (loader_data() == e-&gt;class_loader_data());
499       st-&gt;print(&quot;%4d: %s%s&quot;, index, is_defining_class ? &quot; &quot; : &quot;^&quot;, e-&gt;external_name());
500       ClassLoaderData* cld = e-&gt;class_loader_data();
501       if (!loader_data()-&gt;is_the_null_class_loader_data()) {
502         // Class loader output for the dictionary for the null class loader data is
503         // redundant and obvious.
504         st-&gt;print(&quot;, &quot;);
505         cld-&gt;print_value_on(st);
506       }
507       st-&gt;cr();
508     }
509   }
510   tty-&gt;cr();
511 }
512 
513 void DictionaryEntry::verify() {
514   Klass* e = instance_klass();
515   guarantee(e-&gt;is_instance_klass(),
516                           &quot;Verify of dictionary failed&quot;);
517   e-&gt;verify();
518   verify_protection_domain_set();
519 }
520 
521 void Dictionary::verify() {
522   guarantee(number_of_entries() &gt;= 0, &quot;Verify of dictionary failed&quot;);
523 
524   ClassLoaderData* cld = loader_data();
525   // class loader must be present;  a null class loader is the
526   // boostrap loader
527   guarantee(cld != NULL ||
528             cld-&gt;class_loader() == NULL ||
529             cld-&gt;class_loader()-&gt;is_instance(),
530             &quot;checking type of class_loader&quot;);
531 
532   ResourceMark rm;
533   stringStream tempst;
534   tempst.print(&quot;System Dictionary for %s class loader&quot;, cld-&gt;loader_name_and_id());
535   verify_table&lt;DictionaryEntry&gt;(tempst.as_string());
536 }
    </pre>
  </body>
</html>
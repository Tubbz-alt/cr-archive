<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/moduleEntry.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metadataOnStackMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="modules.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/moduleEntry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jni.h&quot;

 27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;classfile/moduleEntry.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;

 32 #include &quot;oops/oopHandle.inline.hpp&quot;
 33 #include &quot;oops/symbol.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/safepoint.hpp&quot;
 36 #include &quot;utilities/events.hpp&quot;
 37 #include &quot;utilities/growableArray.hpp&quot;
 38 #include &quot;utilities/hashtable.inline.hpp&quot;
 39 #include &quot;utilities/ostream.hpp&quot;
 40 
 41 ModuleEntry* ModuleEntryTable::_javabase_module = NULL;
 42 
 43 oop ModuleEntry::module() const { return _module.resolve(); }
 44 
 45 void ModuleEntry::set_location(Symbol* location) {
 46   if (_location != NULL) {
 47     // _location symbol&#39;s refcounts are managed by ModuleEntry,
 48     // must decrement the old one before updating.
 49     _location-&gt;decrement_refcount();
 50   }
 51 
</pre>
<hr />
<pre>
265 
266   // Store pointer to the ModuleEntry in the unnamed module&#39;s java.lang.Module object.
267   java_lang_Module::set_module_entry(module, unnamed_module);
268 
269   return unnamed_module;
270 }
271 
272 ModuleEntry* ModuleEntry::create_boot_unnamed_module(ClassLoaderData* cld) {
273   // For the boot loader, the java.lang.Module for the unnamed module
274   // is not known until a call to JVM_SetBootLoaderUnnamedModule is made. At
275   // this point initially create the ModuleEntry for the unnamed module.
276   ModuleEntry* unnamed_module = new_unnamed_module_entry(Handle(), cld);
277   assert(unnamed_module != NULL, &quot;boot loader unnamed module should not be null&quot;);
278   return unnamed_module;
279 }
280 
281 // When creating an unnamed module, this is called without holding the Module_lock.
282 // This is okay because the unnamed module gets created before the ClassLoaderData
283 // is available to other threads.
284 ModuleEntry* ModuleEntry::new_unnamed_module_entry(Handle module_handle, ClassLoaderData* cld) {
<span class="line-modified">285   ModuleEntry* entry = (ModuleEntry*) NEW_C_HEAP_ARRAY(char, sizeof(ModuleEntry), mtModule);</span>
286 
287   // Initialize everything BasicHashtable would
288   entry-&gt;set_next(NULL);
289   entry-&gt;set_hash(0);
290   entry-&gt;set_literal(NULL);
291 
292   // Initialize fields specific to a ModuleEntry
293   entry-&gt;init();
294 
295   // Unnamed modules can read all other unnamed modules.
296   entry-&gt;set_can_read_all_unnamed();
297 
298   if (!module_handle.is_null()) {
299     entry-&gt;set_module(cld-&gt;add_handle(module_handle));
300   }
301 
302   entry-&gt;set_loader_data(cld);
303   entry-&gt;_is_open = true;
304 
305   JFR_ONLY(INIT_ID(entry);)
306 
307   return entry;
308 }
309 
310 void ModuleEntry::delete_unnamed_module() {
311   // Do not need unlink_entry() since the unnamed module is not in the hashtable
<span class="line-modified">312   FREE_C_HEAP_ARRAY(char, this);</span>
313 }
314 
315 ModuleEntryTable::ModuleEntryTable(int table_size)
316   : Hashtable&lt;Symbol*, mtModule&gt;(table_size, sizeof(ModuleEntry))
317 {
318 }
319 
320 ModuleEntryTable::~ModuleEntryTable() {
321   // Walk through all buckets and all entries in each bucket,
322   // freeing each entry.
323   for (int i = 0; i &lt; table_size(); ++i) {
324     for (ModuleEntry* m = bucket(i); m != NULL;) {
325       ModuleEntry* to_remove = m;
326       // read next before freeing.
327       m = m-&gt;next();
328 
329       ResourceMark rm;
330       if (to_remove-&gt;name() != NULL) {
331         log_info(module, unload)(&quot;unloading module %s&quot;, to_remove-&gt;name()-&gt;as_C_string());
332       }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jni.h&quot;
<span class="line-added"> 27 #include &quot;classfile/classLoader.hpp&quot;</span>
 28 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;classfile/moduleEntry.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;oops/oopHandle.inline.hpp&quot;
 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/safepoint.hpp&quot;
 38 #include &quot;utilities/events.hpp&quot;
 39 #include &quot;utilities/growableArray.hpp&quot;
 40 #include &quot;utilities/hashtable.inline.hpp&quot;
 41 #include &quot;utilities/ostream.hpp&quot;
 42 
 43 ModuleEntry* ModuleEntryTable::_javabase_module = NULL;
 44 
 45 oop ModuleEntry::module() const { return _module.resolve(); }
 46 
 47 void ModuleEntry::set_location(Symbol* location) {
 48   if (_location != NULL) {
 49     // _location symbol&#39;s refcounts are managed by ModuleEntry,
 50     // must decrement the old one before updating.
 51     _location-&gt;decrement_refcount();
 52   }
 53 
</pre>
<hr />
<pre>
267 
268   // Store pointer to the ModuleEntry in the unnamed module&#39;s java.lang.Module object.
269   java_lang_Module::set_module_entry(module, unnamed_module);
270 
271   return unnamed_module;
272 }
273 
274 ModuleEntry* ModuleEntry::create_boot_unnamed_module(ClassLoaderData* cld) {
275   // For the boot loader, the java.lang.Module for the unnamed module
276   // is not known until a call to JVM_SetBootLoaderUnnamedModule is made. At
277   // this point initially create the ModuleEntry for the unnamed module.
278   ModuleEntry* unnamed_module = new_unnamed_module_entry(Handle(), cld);
279   assert(unnamed_module != NULL, &quot;boot loader unnamed module should not be null&quot;);
280   return unnamed_module;
281 }
282 
283 // When creating an unnamed module, this is called without holding the Module_lock.
284 // This is okay because the unnamed module gets created before the ClassLoaderData
285 // is available to other threads.
286 ModuleEntry* ModuleEntry::new_unnamed_module_entry(Handle module_handle, ClassLoaderData* cld) {
<span class="line-modified">287   ModuleEntry* entry = NEW_C_HEAP_OBJ(ModuleEntry, mtModule);</span>
288 
289   // Initialize everything BasicHashtable would
290   entry-&gt;set_next(NULL);
291   entry-&gt;set_hash(0);
292   entry-&gt;set_literal(NULL);
293 
294   // Initialize fields specific to a ModuleEntry
295   entry-&gt;init();
296 
297   // Unnamed modules can read all other unnamed modules.
298   entry-&gt;set_can_read_all_unnamed();
299 
300   if (!module_handle.is_null()) {
301     entry-&gt;set_module(cld-&gt;add_handle(module_handle));
302   }
303 
304   entry-&gt;set_loader_data(cld);
305   entry-&gt;_is_open = true;
306 
307   JFR_ONLY(INIT_ID(entry);)
308 
309   return entry;
310 }
311 
312 void ModuleEntry::delete_unnamed_module() {
313   // Do not need unlink_entry() since the unnamed module is not in the hashtable
<span class="line-modified">314   FREE_C_HEAP_OBJ(this);</span>
315 }
316 
317 ModuleEntryTable::ModuleEntryTable(int table_size)
318   : Hashtable&lt;Symbol*, mtModule&gt;(table_size, sizeof(ModuleEntry))
319 {
320 }
321 
322 ModuleEntryTable::~ModuleEntryTable() {
323   // Walk through all buckets and all entries in each bucket,
324   // freeing each entry.
325   for (int i = 0; i &lt; table_size(); ++i) {
326     for (ModuleEntry* m = bucket(i); m != NULL;) {
327       ModuleEntry* to_remove = m;
328       // read next before freeing.
329       m = m-&gt;next();
330 
331       ResourceMark rm;
332       if (to_remove-&gt;name() != NULL) {
333         log_info(module, unload)(&quot;unloading module %s&quot;, to_remove-&gt;name()-&gt;as_C_string());
334       }
</pre>
</td>
</tr>
</table>
<center><a href="metadataOnStackMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="modules.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 26 #define SHARE_CLASSFILE_CLASSFILEPARSER_HPP
 27 
 28 #include &quot;memory/referenceType.hpp&quot;
 29 #include &quot;oops/annotations.hpp&quot;
 30 #include &quot;oops/constantPool.hpp&quot;
 31 #include &quot;oops/typeArrayOop.hpp&quot;
 32 #include &quot;utilities/accessFlags.hpp&quot;
 33 
 34 class Annotations;
 35 template &lt;typename T&gt;
 36 class Array;
 37 class ClassFileStream;
 38 class ClassLoaderData;
 39 class CompressedLineNumberWriteStream;
 40 class ConstMethod;
 41 class FieldInfo;
 42 template &lt;typename T&gt;
 43 class GrowableArray;
 44 class InstanceKlass;
 45 class Symbol;
 46 class TempNewSymbol;
 47 
 48 // Parser for for .class files
 49 //
 50 // The bytes describing the class file structure is read from a Stream object
 51 
 52 class ClassFileParser {
 53 
 54  class ClassAnnotationCollector;
 55  class FieldAllocationCount;
 56  class FieldAnnotationCollector;
 57  class FieldLayoutInfo;
 58 
 59  public:
 60   // The ClassFileParser has an associated &quot;publicity&quot; level
 61   // It is used to control which subsystems (if any)
 62   // will observe the parsing (logging, events, tracing).
 63   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 64   // a &quot;public&quot; parsing attempt.
 65   //
 66   // &quot;INTERNAL&quot; level should be entirely private to the
 67   // caller - this allows for internal reuse of ClassFileParser
 68   //
 69   enum Publicity {
 70     INTERNAL,
 71     BROADCAST
 72   };
 73 
 74   enum { LegalClass, LegalField, LegalMethod }; // used to verify unqualified names
 75 
 76  private:
 77   // Potentially unaligned pointer to various 16-bit entries in the class file
 78   typedef void unsafe_u2;
 79 
 80   const ClassFileStream* _stream; // Actual input stream
 81   const Symbol* _requested_name;
 82   Symbol* _class_name;
 83   mutable ClassLoaderData* _loader_data;
 84   const InstanceKlass* _unsafe_anonymous_host;
 85   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
 86   int _num_patched_klasses;
 87   int _max_num_patched_klasses;
 88   int _orig_cp_size;
 89   int _first_patched_klass_resolved_index;
 90 
 91   // Metadata created before the instance klass is created.  Must be deallocated
 92   // if not transferred to the InstanceKlass upon successful class loading
 93   // in which case these pointers have been set to NULL.
 94   const InstanceKlass* _super_klass;
 95   ConstantPool* _cp;
 96   Array&lt;u2&gt;* _fields;
 97   Array&lt;Method*&gt;* _methods;
 98   Array&lt;u2&gt;* _inner_classes;
 99   Array&lt;u2&gt;* _nest_members;
100   u2 _nest_host;
101   Array&lt;InstanceKlass*&gt;* _local_interfaces;
102   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
103   Annotations* _combined_annotations;
104   AnnotationArray* _annotations;
105   AnnotationArray* _type_annotations;
106   Array&lt;AnnotationArray*&gt;* _fields_annotations;
107   Array&lt;AnnotationArray*&gt;* _fields_type_annotations;
108   InstanceKlass* _klass;  // InstanceKlass* once created.
109   InstanceKlass* _klass_to_deallocate; // an InstanceKlass* to be destroyed
110 
111   ClassAnnotationCollector* _parsed_annotations;
112   FieldAllocationCount* _fac;
113   FieldLayoutInfo* _field_info;
114   const intArray* _method_ordering;
115   GrowableArray&lt;Method*&gt;* _all_mirandas;
116 
117   enum { fixed_buffer_size = 128 };
118   u_char _linenumbertable_buffer[fixed_buffer_size];
119 
120   // Size of Java vtable (in words)
121   int _vtable_size;
122   int _itable_size;
123 
124   int _num_miranda_methods;
125 
126   ReferenceType _rt;
127   Handle _protection_domain;
128   AccessFlags _access_flags;
129 
130   // for tracing and notifications
131   Publicity _pub_level;
132 
133   // Used to keep track of whether a constant pool item 19 or 20 is found.  These
134   // correspond to CONSTANT_Module and CONSTANT_Package tags and are not allowed
135   // in regular class files.  For class file version &gt;= 53, a CFE cannot be thrown
136   // immediately when these are seen because a NCDFE must be thrown if the class&#39;s
137   // access_flags have ACC_MODULE set.  But, the access_flags haven&#39;t been looked
138   // at yet.  So, the bad constant pool item is cached here.  A value of zero
139   // means that no constant pool item 19 or 20 was found.
140   short _bad_constant_seen;
141 
142   // class attributes parsed before the instance klass is created:
143   bool _synthetic_flag;
144   int _sde_length;
145   const char* _sde_buffer;
146   u2 _sourcefile_index;
147   u2 _generic_signature_index;
148 
149   u2 _major_version;
150   u2 _minor_version;
151   u2 _this_class_index;
152   u2 _super_class_index;
153   u2 _itfs_len;
154   u2 _java_fields_count;
155 
156   bool _need_verify;
157   bool _relax_verify;
158 
159   bool _has_nonstatic_concrete_methods;
160   bool _declares_nonstatic_concrete_methods;
161   bool _has_final_method;
162 
163   // precomputed flags
164   bool _has_finalizer;
165   bool _has_empty_finalizer;
166   bool _has_vanilla_constructor;
167   int _max_bootstrap_specifier_index;  // detects BSS values
168 
169   void parse_stream(const ClassFileStream* const stream, TRAPS);
170 
171   void post_process_parsed_stream(const ClassFileStream* const stream,
172                                   ConstantPool* cp,
173                                   TRAPS);
174 
175   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
176   void fix_unsafe_anonymous_class_name(TRAPS);
177 
178   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
179   void set_klass(InstanceKlass* instance);
180 
181   void set_class_bad_constant_seen(short bad_constant);
182   short class_bad_constant_seen() { return  _bad_constant_seen; }
183   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
184   void set_class_sourcefile_index(u2 x)        { _sourcefile_index = x; }
185   void set_class_generic_signature_index(u2 x) { _generic_signature_index = x; }
186   void set_class_sde_buffer(const char* x, int len)  { _sde_buffer = x; _sde_length = len; }
187 
188   void create_combined_annotations(TRAPS);
189   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
190   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
191   void clear_class_metadata();
192 
193   // Constant pool parsing
194   void parse_constant_pool_entries(const ClassFileStream* const stream,
195                                    ConstantPool* cp,
196                                    const int length,
197                                    TRAPS);
198 
199   void parse_constant_pool(const ClassFileStream* const cfs,
200                            ConstantPool* const cp,
201                            const int length,
202                            TRAPS);
203 
204   // Interface parsing
205   void parse_interfaces(const ClassFileStream* const stream,
206                         const int itfs_len,
207                         ConstantPool* const cp,
208                         bool* has_nonstatic_concrete_methods,
209                         TRAPS);
210 
211   const InstanceKlass* parse_super_class(ConstantPool* const cp,
212                                          const int super_class_index,
213                                          const bool need_verify,
214                                          TRAPS);
215 
216   // Field parsing
217   void parse_field_attributes(const ClassFileStream* const cfs,
218                               u2 attributes_count,
219                               bool is_static,
220                               u2 signature_index,
221                               u2* const constantvalue_index_addr,
222                               bool* const is_synthetic_addr,
223                               u2* const generic_signature_index_addr,
224                               FieldAnnotationCollector* parsed_annotations,
225                               TRAPS);
226 
227   void parse_fields(const ClassFileStream* const cfs,
228                     bool is_interface,
229                     FieldAllocationCount* const fac,
230                     ConstantPool* cp,
231                     const int cp_size,
232                     u2* const java_fields_count_ptr,
233                     TRAPS);
234 
235   // Method parsing
236   Method* parse_method(const ClassFileStream* const cfs,
237                        bool is_interface,
238                        const ConstantPool* cp,
239                        AccessFlags* const promoted_flags,
240                        TRAPS);
241 
242   void parse_methods(const ClassFileStream* const cfs,
243                      bool is_interface,
244                      AccessFlags* const promoted_flags,
245                      bool* const has_final_method,
246                      bool* const declares_nonstatic_concrete_methods,
247                      TRAPS);
248 
249   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
250                                          u4 code_length,
251                                          u4 exception_table_length,
252                                          TRAPS);
253 
254   void parse_linenumber_table(u4 code_attribute_length,
255                               u4 code_length,
256                               CompressedLineNumberWriteStream**const write_stream,
257                               TRAPS);
258 
259   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
260                                              u4 code_length,
261                                              u2 max_locals,
262                                              u4 code_attribute_length,
263                                              u2* const localvariable_table_length,
264                                              bool isLVTT,
265                                              TRAPS);
266 
267   const unsafe_u2* parse_checked_exceptions(const ClassFileStream* const cfs,
268                                             u2* const checked_exceptions_length,
269                                             u4 method_attribute_length,
270                                             TRAPS);
271 
272   // Classfile attribute parsing
273   u2 parse_generic_signature_attribute(const ClassFileStream* const cfs, TRAPS);
274   void parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs, TRAPS);
275   void parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
276                                                         int length,
277                                                         TRAPS);
278 
279   u2   parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
280                                                const u1* const inner_classes_attribute_start,
281                                                bool parsed_enclosingmethod_attribute,
282                                                u2 enclosing_method_class_index,
283                                                u2 enclosing_method_method_index,
284                                                TRAPS);
285 
286   u2 parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
287                                             const u1* const nest_members_attribute_start,
288                                             TRAPS);
289 
290   void parse_classfile_attributes(const ClassFileStream* const cfs,
291                                   ConstantPool* cp,
292                                   ClassAnnotationCollector* parsed_annotations,
293                                   TRAPS);
294 
295   void parse_classfile_synthetic_attribute(TRAPS);
296   void parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS);
297   void parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
298                                                    ConstantPool* cp,
299                                                    u4 attribute_length,
300                                                    TRAPS);
301 
302   // Annotations handling
303   AnnotationArray* assemble_annotations(const u1* const runtime_visible_annotations,
304                                         int runtime_visible_annotations_length,
305                                         const u1* const runtime_invisible_annotations,
306                                         int runtime_invisible_annotations_length,
307                                         TRAPS);
308 
309   void set_precomputed_flags(InstanceKlass* k);
310 
311   // Format checker methods
312   void classfile_parse_error(const char* msg, TRAPS) const;
313   void classfile_parse_error(const char* msg, int index, TRAPS) const;
314   void classfile_parse_error(const char* msg, const char *name, TRAPS) const;
315   void classfile_parse_error(const char* msg,
316                              int index,
317                              const char *name,
318                              TRAPS) const;
319   void classfile_parse_error(const char* msg,
320                              const char* name,
321                              const char* signature,
322                              TRAPS) const;
323 
324   inline void guarantee_property(bool b, const char* msg, TRAPS) const {
325     if (!b) { classfile_parse_error(msg, CHECK); }
326   }
327 
328   void report_assert_property_failure(const char* msg, TRAPS) const PRODUCT_RETURN;
329   void report_assert_property_failure(const char* msg, int index, TRAPS) const PRODUCT_RETURN;
330 
331   inline void assert_property(bool b, const char* msg, TRAPS) const {
332 #ifdef ASSERT
333     if (!b) {
334       report_assert_property_failure(msg, THREAD);
335     }
336 #endif
337   }
338 
339   inline void assert_property(bool b, const char* msg, int index, TRAPS) const {
340 #ifdef ASSERT
341     if (!b) {
342       report_assert_property_failure(msg, index, THREAD);
343     }
344 #endif
345   }
346 
347   inline void check_property(bool property,
348                              const char* msg,
349                              int index,
350                              TRAPS) const {
351     if (_need_verify) {
352       guarantee_property(property, msg, index, CHECK);
353     } else {
354       assert_property(property, msg, index, CHECK);
355     }
356   }
357 
358   inline void check_property(bool property, const char* msg, TRAPS) const {
359     if (_need_verify) {
360       guarantee_property(property, msg, CHECK);
361     } else {
362       assert_property(property, msg, CHECK);
363     }
364   }
365 
366   inline void guarantee_property(bool b,
367                                  const char* msg,
368                                  int index,
369                                  TRAPS) const {
370     if (!b) { classfile_parse_error(msg, index, CHECK); }
371   }
372 
373   inline void guarantee_property(bool b,
374                                  const char* msg,
375                                  const char *name,
376                                  TRAPS) const {
377     if (!b) { classfile_parse_error(msg, name, CHECK); }
378   }
379 
380   inline void guarantee_property(bool b,
381                                  const char* msg,
382                                  int index,
383                                  const char *name,
384                                  TRAPS) const {
385     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
386   }
387 
388   void throwIllegalSignature(const char* type,
389                              const Symbol* name,
390                              const Symbol* sig,
391                              TRAPS) const;
392 
393   void verify_constantvalue(const ConstantPool* const cp,
394                             int constantvalue_index,
395                             int signature_index,
396                             TRAPS) const;
397 
398   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
399   void verify_legal_class_name(const Symbol* name, TRAPS) const;
400   void verify_legal_field_name(const Symbol* name, TRAPS) const;
401   void verify_legal_method_name(const Symbol* name, TRAPS) const;
402 
403   void verify_legal_field_signature(const Symbol* fieldname,
404                                     const Symbol* signature,
405                                     TRAPS) const;
406   int  verify_legal_method_signature(const Symbol* methodname,
407                                      const Symbol* signature,
408                                      TRAPS) const;
409 
410   void verify_legal_class_modifiers(jint flags, TRAPS) const;
411   void verify_legal_field_modifiers(jint flags, bool is_interface, TRAPS) const;
412   void verify_legal_method_modifiers(jint flags,
413                                      bool is_interface,
414                                      const Symbol* name,
415                                      TRAPS) const;
416 
417   const char* skip_over_field_signature(const char* signature,
418                                         bool void_ok,
419                                         unsigned int length,
420                                         TRAPS) const;
421 
422   bool has_cp_patch_at(int index) const {
423     assert(index &gt;= 0, &quot;oob&quot;);
424     return (_cp_patches != NULL
425             &amp;&amp; index &lt; _cp_patches-&gt;length()
426             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
427   }
428 
429   Handle cp_patch_at(int index) const {
430     assert(has_cp_patch_at(index), &quot;oob&quot;);
431     return _cp_patches-&gt;at(index);
432   }
433 
434   Handle clear_cp_patch_at(int index);
435 
436   void patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name);
437   void patch_constant_pool(ConstantPool* cp,
438                            int index,
439                            Handle patch,
440                            TRAPS);
441 
442   // Wrapper for constantTag.is_klass_[or_]reference.
443   // In older versions of the VM, Klass*s cannot sneak into early phases of
444   // constant pool construction, but in later versions they can.
445   // %%% Let&#39;s phase out the old is_klass_reference.
446   bool valid_klass_reference_at(int index) const {
447     return _cp-&gt;is_within_bounds(index) &amp;&amp;
448              _cp-&gt;tag_at(index).is_klass_or_reference();
449   }
450 
451   // Checks that the cpool index is in range and is a utf8
452   bool valid_symbol_at(int cpool_index) const {
453     return _cp-&gt;is_within_bounds(cpool_index) &amp;&amp;
454              _cp-&gt;tag_at(cpool_index).is_utf8();
455   }
456 
457   void copy_localvariable_table(const ConstMethod* cm,
458                                 int lvt_cnt,
459                                 u2* const localvariable_table_length,
460                                 const unsafe_u2** const localvariable_table_start,
461                                 int lvtt_cnt,
462                                 u2* const localvariable_type_table_length,
463                                 const unsafe_u2** const localvariable_type_table_start,
464                                 TRAPS);
465 
466   void copy_method_annotations(ConstMethod* cm,
467                                const u1* runtime_visible_annotations,
468                                int runtime_visible_annotations_length,
469                                const u1* runtime_invisible_annotations,
470                                int runtime_invisible_annotations_length,
471                                const u1* runtime_visible_parameter_annotations,
472                                int runtime_visible_parameter_annotations_length,
473                                const u1* runtime_invisible_parameter_annotations,
474                                int runtime_invisible_parameter_annotations_length,
475                                const u1* runtime_visible_type_annotations,
476                                int runtime_visible_type_annotations_length,
477                                const u1* runtime_invisible_type_annotations,
478                                int runtime_invisible_type_annotations_length,
479                                const u1* annotation_default,
480                                int annotation_default_length,
481                                TRAPS);
482 
483   // lays out fields in class and returns the total oopmap count
484   void layout_fields(ConstantPool* cp,
485                      const FieldAllocationCount* fac,
486                      const ClassAnnotationCollector* parsed_annotations,
487                      FieldLayoutInfo* info,
488                      TRAPS);
489 
490    void update_class_name(Symbol* new_name);
491 
492  public:
493   ClassFileParser(ClassFileStream* stream,
494                   Symbol* name,
495                   ClassLoaderData* loader_data,
496                   Handle protection_domain,
497                   const InstanceKlass* unsafe_anonymous_host,
498                   GrowableArray&lt;Handle&gt;* cp_patches,
499                   Publicity pub_level,
500                   TRAPS);
501 
502   ~ClassFileParser();
503 
504   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
505 
506   const ClassFileStream* clone_stream() const;
507 
508   void set_klass_to_deallocate(InstanceKlass* klass);
509 
510   int static_field_size() const;
511   int total_oop_map_count() const;
512   jint layout_size() const;
513 
514   int vtable_size() const { return _vtable_size; }
515   int itable_size() const { return _itable_size; }
516 
517   u2 this_class_index() const { return _this_class_index; }
518 
519   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
520   bool is_interface() const { return _access_flags.is_interface(); }
521 
522   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
523   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
524   ClassLoaderData* loader_data() const { return _loader_data; }
525   const Symbol* class_name() const { return _class_name; }
526   const InstanceKlass* super_klass() const { return _super_klass; }
527 
528   ReferenceType reference_type() const { return _rt; }
529   AccessFlags access_flags() const { return _access_flags; }
530 
531   bool is_internal() const { return INTERNAL == _pub_level; }
532 
533   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
534 
535 #ifdef ASSERT
536   static bool is_internal_format(Symbol* class_name);
537 #endif
538 
539 };
540 
541 #endif // SHARE_CLASSFILE_CLASSFILEPARSER_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/bytecodeAssembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="altHashing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/bytecodeAssembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37   if (probe == NULL) {
 38     index = _entries.length();
 39     _entries.append(bcpe);
 40     _indices.put(bcpe, index);
 41   } else {
 42     index = *probe;
 43   }
 44   return index + _orig-&gt;length();
 45 }
 46 
 47 ConstantPool* BytecodeConstantPool::create_constant_pool(TRAPS) const {
 48   if (_entries.length() == 0) {
 49     return _orig;
 50   }
 51 
 52   ConstantPool* cp = ConstantPool::allocate(
 53       _orig-&gt;pool_holder()-&gt;class_loader_data(),
 54       _orig-&gt;length() + _entries.length(), CHECK_NULL);
 55 
 56   cp-&gt;set_pool_holder(_orig-&gt;pool_holder());
<span class="line-modified"> 57   _orig-&gt;copy_cp_to(1, _orig-&gt;length() - 1, cp, 1, CHECK_NULL);</span>

 58 
 59   // Preserve dynamic constant information from the original pool
 60   if (_orig-&gt;has_dynamic_constant()) {
 61     cp-&gt;set_has_dynamic_constant();
 62   }
 63 
 64   for (int i = 0; i &lt; _entries.length(); ++i) {
 65     BytecodeCPEntry entry = _entries.at(i);
 66     int idx = i + _orig-&gt;length();
 67     switch (entry._tag) {
 68       case BytecodeCPEntry::UTF8:
 69         entry._u.utf8-&gt;increment_refcount();
 70         cp-&gt;symbol_at_put(idx, entry._u.utf8);
 71         break;
 72       case BytecodeCPEntry::KLASS:
 73         cp-&gt;klass_index_at_put(
 74             idx, entry._u.klass);
 75         break;
 76       case BytecodeCPEntry::STRING:
 77         cp-&gt;unresolved_string_at_put(
</pre>
<hr />
<pre>
170 }
171 
172 void BytecodeAssembler::dload(u4 index) {
173   xload(index, Bytecodes::_dload_0, Bytecodes::_dload);
174 }
175 
176 void BytecodeAssembler::aload(u4 index) {
177   xload(index, Bytecodes::_aload_0, Bytecodes::_aload);
178 }
179 
180 void BytecodeAssembler::load(BasicType bt, u4 index) {
181   switch (bt) {
182     case T_BOOLEAN:
183     case T_CHAR:
184     case T_BYTE:
185     case T_SHORT:
186     case T_INT:     iload(index); break;
187     case T_FLOAT:   fload(index); break;
188     case T_DOUBLE:  dload(index); break;
189     case T_LONG:    lload(index); break;
<span class="line-removed">190     case T_OBJECT:</span>
<span class="line-removed">191     case T_ARRAY:   aload(index); break;</span>
192     default:




193       ShouldNotReachHere();
194   }
195 }
196 
197 void BytecodeAssembler::checkcast(Symbol* sym) {
198   u2 cpool_index = _cp-&gt;klass(sym);
199   _code-&gt;append(Bytecodes::_checkcast);
200   append(cpool_index);
201 }
202 
203 void BytecodeAssembler::invokespecial(Method* method) {
204   invokespecial(method-&gt;klass_name(), method-&gt;name(), method-&gt;signature());
205 }
206 
207 void BytecodeAssembler::invokespecial(Symbol* klss, Symbol* name, Symbol* sig) {
208   u2 methodref_index = _cp-&gt;methodref(klss, name, sig);
209   _code-&gt;append(Bytecodes::_invokespecial);
210   append(methodref_index);
211 }
212 
</pre>
<hr />
<pre>
237 }
238 
239 void BytecodeAssembler::areturn() {
240   _code-&gt;append(Bytecodes::_areturn);
241 }
242 
243 void BytecodeAssembler::_return() {
244   _code-&gt;append(Bytecodes::_return);
245 }
246 
247 void BytecodeAssembler::_return(BasicType bt) {
248   switch (bt) {
249     case T_BOOLEAN:
250     case T_CHAR:
251     case T_BYTE:
252     case T_SHORT:
253     case T_INT:     ireturn(); break;
254     case T_FLOAT:   freturn(); break;
255     case T_DOUBLE:  dreturn(); break;
256     case T_LONG:    lreturn(); break;
<span class="line-removed">257     case T_OBJECT:</span>
<span class="line-removed">258     case T_ARRAY:   areturn(); break;</span>
259     case T_VOID:    _return(); break;
260     default:




261       ShouldNotReachHere();
262   }
263 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37   if (probe == NULL) {
 38     index = _entries.length();
 39     _entries.append(bcpe);
 40     _indices.put(bcpe, index);
 41   } else {
 42     index = *probe;
 43   }
 44   return index + _orig-&gt;length();
 45 }
 46 
 47 ConstantPool* BytecodeConstantPool::create_constant_pool(TRAPS) const {
 48   if (_entries.length() == 0) {
 49     return _orig;
 50   }
 51 
 52   ConstantPool* cp = ConstantPool::allocate(
 53       _orig-&gt;pool_holder()-&gt;class_loader_data(),
 54       _orig-&gt;length() + _entries.length(), CHECK_NULL);
 55 
 56   cp-&gt;set_pool_holder(_orig-&gt;pool_holder());
<span class="line-modified"> 57   constantPoolHandle cp_h(THREAD, cp);</span>
<span class="line-added"> 58   _orig-&gt;copy_cp_to(1, _orig-&gt;length() - 1, cp_h, 1, CHECK_NULL);</span>
 59 
 60   // Preserve dynamic constant information from the original pool
 61   if (_orig-&gt;has_dynamic_constant()) {
 62     cp-&gt;set_has_dynamic_constant();
 63   }
 64 
 65   for (int i = 0; i &lt; _entries.length(); ++i) {
 66     BytecodeCPEntry entry = _entries.at(i);
 67     int idx = i + _orig-&gt;length();
 68     switch (entry._tag) {
 69       case BytecodeCPEntry::UTF8:
 70         entry._u.utf8-&gt;increment_refcount();
 71         cp-&gt;symbol_at_put(idx, entry._u.utf8);
 72         break;
 73       case BytecodeCPEntry::KLASS:
 74         cp-&gt;klass_index_at_put(
 75             idx, entry._u.klass);
 76         break;
 77       case BytecodeCPEntry::STRING:
 78         cp-&gt;unresolved_string_at_put(
</pre>
<hr />
<pre>
171 }
172 
173 void BytecodeAssembler::dload(u4 index) {
174   xload(index, Bytecodes::_dload_0, Bytecodes::_dload);
175 }
176 
177 void BytecodeAssembler::aload(u4 index) {
178   xload(index, Bytecodes::_aload_0, Bytecodes::_aload);
179 }
180 
181 void BytecodeAssembler::load(BasicType bt, u4 index) {
182   switch (bt) {
183     case T_BOOLEAN:
184     case T_CHAR:
185     case T_BYTE:
186     case T_SHORT:
187     case T_INT:     iload(index); break;
188     case T_FLOAT:   fload(index); break;
189     case T_DOUBLE:  dload(index); break;
190     case T_LONG:    lload(index); break;


191     default:
<span class="line-added">192       if (is_reference_type(bt)) {</span>
<span class="line-added">193                     aload(index);</span>
<span class="line-added">194                     break;</span>
<span class="line-added">195       }</span>
196       ShouldNotReachHere();
197   }
198 }
199 
200 void BytecodeAssembler::checkcast(Symbol* sym) {
201   u2 cpool_index = _cp-&gt;klass(sym);
202   _code-&gt;append(Bytecodes::_checkcast);
203   append(cpool_index);
204 }
205 
206 void BytecodeAssembler::invokespecial(Method* method) {
207   invokespecial(method-&gt;klass_name(), method-&gt;name(), method-&gt;signature());
208 }
209 
210 void BytecodeAssembler::invokespecial(Symbol* klss, Symbol* name, Symbol* sig) {
211   u2 methodref_index = _cp-&gt;methodref(klss, name, sig);
212   _code-&gt;append(Bytecodes::_invokespecial);
213   append(methodref_index);
214 }
215 
</pre>
<hr />
<pre>
240 }
241 
242 void BytecodeAssembler::areturn() {
243   _code-&gt;append(Bytecodes::_areturn);
244 }
245 
246 void BytecodeAssembler::_return() {
247   _code-&gt;append(Bytecodes::_return);
248 }
249 
250 void BytecodeAssembler::_return(BasicType bt) {
251   switch (bt) {
252     case T_BOOLEAN:
253     case T_CHAR:
254     case T_BYTE:
255     case T_SHORT:
256     case T_INT:     ireturn(); break;
257     case T_FLOAT:   freturn(); break;
258     case T_DOUBLE:  dreturn(); break;
259     case T_LONG:    lreturn(); break;


260     case T_VOID:    _return(); break;
261     default:
<span class="line-added">262       if (is_reference_type(bt)) {</span>
<span class="line-added">263                     areturn();</span>
<span class="line-added">264                     break;</span>
<span class="line-added">265       }</span>
266       ShouldNotReachHere();
267   }
268 }
</pre>
</td>
</tr>
</table>
<center><a href="altHashing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
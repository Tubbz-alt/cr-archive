<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/stackMapFrame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stackMapFrame.hpp&quot;
 27 #include &quot;classfile/verifier.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 
 34 StackMapFrame::StackMapFrame(u2 max_locals, u2 max_stack, ClassVerifier* v) :
 35                       _offset(0), _locals_size(0), _stack_size(0),
 36                       _stack_mark(0), _max_locals(max_locals),
 37                       _max_stack(max_stack), _flags(0), _verifier(v) {
 38   Thread* thr = v-&gt;thread();
 39   _locals = NEW_RESOURCE_ARRAY_IN_THREAD(thr, VerificationType, max_locals);
 40   _stack = NEW_RESOURCE_ARRAY_IN_THREAD(thr, VerificationType, max_stack);
 41   int32_t i;
 42   for(i = 0; i &lt; max_locals; i++) {
 43     _locals[i] = VerificationType::bogus_type();
 44   }
 45   for(i = 0; i &lt; max_stack; i++) {
 46     _stack[i] = VerificationType::bogus_type();
 47   }
 48 }
 49 
 50 StackMapFrame* StackMapFrame::frame_in_exception_handler(u1 flags) {
 51   Thread* thr = _verifier-&gt;thread();
 52   VerificationType* stack = NEW_RESOURCE_ARRAY_IN_THREAD(thr, VerificationType, 1);
 53   StackMapFrame* frame = new StackMapFrame(_offset, flags, _locals_size, 0, _max_locals, _max_stack, _locals, stack, _verifier);
 54   return frame;
 55 }
 56 
 57 void StackMapFrame::initialize_object(
 58     VerificationType old_object, VerificationType new_object) {
 59   int32_t i;
 60   for (i = 0; i &lt; _max_locals; i++) {
 61     if (_locals[i].equals(old_object)) {
 62       _locals[i] = new_object;
 63     }
 64   }
 65   for (i = 0; i &lt; _stack_size; i++) {
 66     if (_stack[i].equals(old_object)) {
 67       _stack[i] = new_object;
 68     }
 69   }
 70   if (old_object == VerificationType::uninitialized_this_type()) {
 71     // &quot;this&quot; has been initialized - reset flags
 72     _flags = 0;
 73   }
 74 }
 75 
 76 VerificationType StackMapFrame::set_locals_from_arg(
 77     const methodHandle&amp; m, VerificationType thisKlass, TRAPS) {
 78   SignatureStream ss(m-&gt;signature());
 79   int init_local_num = 0;
 80   if (!m-&gt;is_static()) {
 81     init_local_num++;
 82     // add one extra argument for instance method
 83     if (m-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
 84        thisKlass.name() != vmSymbols::java_lang_Object()) {
 85       _locals[0] = VerificationType::uninitialized_this_type();
 86       _flags |= FLAG_THIS_UNINIT;
 87     } else {
 88       _locals[0] = thisKlass;
 89     }
 90   }
 91 
 92   // local num may be greater than size of parameters because long/double occupies two slots
 93   while(!ss.at_return_type()) {
 94     init_local_num += _verifier-&gt;change_sig_to_verificationType(
<a name="1" id="anc1"></a><span class="line-modified"> 95       &amp;ss, &amp;_locals[init_local_num],</span>
<span class="line-removed"> 96       CHECK_VERIFY_(verifier(), VerificationType::bogus_type()));</span>
 97     ss.next();
 98   }
 99   _locals_size = init_local_num;
100 
101   switch (ss.type()) {
102     case T_OBJECT:
103     case T_ARRAY:
104     {
<a name="2" id="anc2"></a><span class="line-modified">105       Symbol* sig = ss.as_symbol(CHECK_(VerificationType::bogus_type()));</span>
106       if (!sig-&gt;is_permanent()) {
107         // Create another symbol to save as signature stream unreferences
108         // this symbol.
109         Symbol *sig_copy =
<a name="3" id="anc3"></a><span class="line-modified">110           verifier()-&gt;create_temporary_symbol(sig, 0, sig-&gt;utf8_length(),</span>
<span class="line-removed">111         CHECK_(VerificationType::bogus_type()));</span>
112         assert(sig_copy == sig, &quot;symbols don&#39;t match&quot;);
113         sig = sig_copy;
114       }
115       return VerificationType::reference_type(sig);
116     }
117     case T_INT:     return VerificationType::integer_type();
118     case T_BYTE:    return VerificationType::byte_type();
119     case T_CHAR:    return VerificationType::char_type();
120     case T_SHORT:   return VerificationType::short_type();
121     case T_BOOLEAN: return VerificationType::boolean_type();
122     case T_FLOAT:   return VerificationType::float_type();
123     case T_DOUBLE:  return VerificationType::double_type();
124     case T_LONG:    return VerificationType::long_type();
125     case T_VOID:    return VerificationType::bogus_type();
126     default:
127       ShouldNotReachHere();
128   }
129   return VerificationType::bogus_type();
130 }
131 
132 void StackMapFrame::copy_locals(const StackMapFrame* src) {
133   int32_t len = src-&gt;locals_size() &lt; _locals_size ?
134     src-&gt;locals_size() : _locals_size;
135   for (int32_t i = 0; i &lt; len; i++) {
136     _locals[i] = src-&gt;locals()[i];
137   }
138 }
139 
140 void StackMapFrame::copy_stack(const StackMapFrame* src) {
141   int32_t len = src-&gt;stack_size() &lt; _stack_size ?
142     src-&gt;stack_size() : _stack_size;
143   for (int32_t i = 0; i &lt; len; i++) {
144     _stack[i] = src-&gt;stack()[i];
145   }
146 }
147 
148 // Returns the location of the first mismatch, or &#39;len&#39; if there are no
149 // mismatches
150 int StackMapFrame::is_assignable_to(
151     VerificationType* from, VerificationType* to, int32_t len, TRAPS) const {
152   int32_t i = 0;
153   for (i = 0; i &lt; len; i++) {
154     if (!to[i].is_assignable_from(from[i], verifier(), false, THREAD)) {
155       break;
156     }
157   }
158   return i;
159 }
160 
161 bool StackMapFrame::is_assignable_to(
162     const StackMapFrame* target, ErrorContext* ctx, TRAPS) const {
163   if (_max_locals != target-&gt;max_locals()) {
164     *ctx = ErrorContext::locals_size_mismatch(
165         _offset, (StackMapFrame*)this, (StackMapFrame*)target);
166     return false;
167   }
168   if (_stack_size != target-&gt;stack_size()) {
169     *ctx = ErrorContext::stack_size_mismatch(
170         _offset, (StackMapFrame*)this, (StackMapFrame*)target);
171     return false;
172   }
173   // Only need to compare type elements up to target-&gt;locals() or target-&gt;stack().
174   // The remaining type elements in this state can be ignored because they are
175   // assignable to bogus type.
176   int mismatch_loc;
177   mismatch_loc = is_assignable_to(
178     _locals, target-&gt;locals(), target-&gt;locals_size(), THREAD);
179   if (mismatch_loc != target-&gt;locals_size()) {
180     *ctx = ErrorContext::bad_type(target-&gt;offset(),
181         TypeOrigin::local(mismatch_loc, (StackMapFrame*)this),
182         TypeOrigin::sm_local(mismatch_loc, (StackMapFrame*)target));
183     return false;
184   }
185   mismatch_loc = is_assignable_to(_stack, target-&gt;stack(), _stack_size, THREAD);
186   if (mismatch_loc != _stack_size) {
187     *ctx = ErrorContext::bad_type(target-&gt;offset(),
188         TypeOrigin::stack(mismatch_loc, (StackMapFrame*)this),
189         TypeOrigin::sm_stack(mismatch_loc, (StackMapFrame*)target));
190     return false;
191   }
192 
193   if ((_flags | target-&gt;flags()) == target-&gt;flags()) {
194     return true;
195   } else {
196     *ctx = ErrorContext::bad_flags(target-&gt;offset(),
197         (StackMapFrame*)this, (StackMapFrame*)target);
198     return false;
199   }
200 }
201 
202 VerificationType StackMapFrame::pop_stack_ex(VerificationType type, TRAPS) {
203   if (_stack_size &lt;= 0) {
204     verifier()-&gt;verify_error(
205         ErrorContext::stack_underflow(_offset, this),
206         &quot;Operand stack underflow&quot;);
207     return VerificationType::bogus_type();
208   }
209   VerificationType top = _stack[--_stack_size];
210   bool subtype = type.is_assignable_from(
211     top, verifier(), false, CHECK_(VerificationType::bogus_type()));
212   if (!subtype) {
213     verifier()-&gt;verify_error(
214         ErrorContext::bad_type(_offset, stack_top_ctx(),
215             TypeOrigin::implicit(type)),
216         &quot;Bad type on operand stack&quot;);
217     return VerificationType::bogus_type();
218   }
219   return top;
220 }
221 
222 VerificationType StackMapFrame::get_local(
223     int32_t index, VerificationType type, TRAPS) {
224   if (index &gt;= _max_locals) {
225     verifier()-&gt;verify_error(
226         ErrorContext::bad_local_index(_offset, index),
227         &quot;Local variable table overflow&quot;);
228     return VerificationType::bogus_type();
229   }
230   bool subtype = type.is_assignable_from(_locals[index],
231     verifier(), false, CHECK_(VerificationType::bogus_type()));
232   if (!subtype) {
233     verifier()-&gt;verify_error(
234         ErrorContext::bad_type(_offset,
235           TypeOrigin::local(index, this),
236           TypeOrigin::implicit(type)),
237         &quot;Bad local variable type&quot;);
238     return VerificationType::bogus_type();
239   }
240   if(index &gt;= _locals_size) { _locals_size = index + 1; }
241   return _locals[index];
242 }
243 
244 void StackMapFrame::get_local_2(
245     int32_t index, VerificationType type1, VerificationType type2, TRAPS) {
246   assert(type1.is_long() || type1.is_double(), &quot;must be long/double&quot;);
247   assert(type2.is_long2() || type2.is_double2(), &quot;must be long/double_2&quot;);
248   if (index &gt;= _locals_size - 1) {
249     verifier()-&gt;verify_error(
250         ErrorContext::bad_local_index(_offset, index),
251         &quot;get long/double overflows locals&quot;);
252     return;
253   }
254   bool subtype = type1.is_assignable_from(_locals[index], verifier(), false, CHECK);
255   if (!subtype) {
256     verifier()-&gt;verify_error(
257         ErrorContext::bad_type(_offset,
258             TypeOrigin::local(index, this), TypeOrigin::implicit(type1)),
259         &quot;Bad local variable type&quot;);
260   } else {
261     subtype = type2.is_assignable_from(_locals[index + 1], verifier(), false, CHECK);
262     if (!subtype) {
263       /* Unreachable? All local store routines convert a split long or double
264        * into a TOP during the store.  So we should never end up seeing an
265        * orphaned half.  */
266       verifier()-&gt;verify_error(
267           ErrorContext::bad_type(_offset,
268               TypeOrigin::local(index + 1, this), TypeOrigin::implicit(type2)),
269           &quot;Bad local variable type&quot;);
270     }
271   }
272 }
273 
274 void StackMapFrame::set_local(int32_t index, VerificationType type, TRAPS) {
275   assert(!type.is_check(), &quot;Must be a real type&quot;);
276   if (index &gt;= _max_locals) {
277     verifier()-&gt;verify_error(
278         ErrorContext::bad_local_index(_offset, index),
279         &quot;Local variable table overflow&quot;);
280     return;
281   }
282   // If type at index is double or long, set the next location to be unusable
283   if (_locals[index].is_double() || _locals[index].is_long()) {
284     assert((index + 1) &lt; _locals_size, &quot;Local variable table overflow&quot;);
285     _locals[index + 1] = VerificationType::bogus_type();
286   }
287   // If type at index is double_2 or long_2, set the previous location to be unusable
288   if (_locals[index].is_double2() || _locals[index].is_long2()) {
289     assert(index &gt;= 1, &quot;Local variable table underflow&quot;);
290     _locals[index - 1] = VerificationType::bogus_type();
291   }
292   _locals[index] = type;
293   if (index &gt;= _locals_size) {
294 #ifdef ASSERT
295     for (int i=_locals_size; i&lt;index; i++) {
296       assert(_locals[i] == VerificationType::bogus_type(),
297              &quot;holes must be bogus type&quot;);
298     }
299 #endif
300     _locals_size = index + 1;
301   }
302 }
303 
304 void StackMapFrame::set_local_2(
305     int32_t index, VerificationType type1, VerificationType type2, TRAPS) {
306   assert(type1.is_long() || type1.is_double(), &quot;must be long/double&quot;);
307   assert(type2.is_long2() || type2.is_double2(), &quot;must be long/double_2&quot;);
308   if (index &gt;= _max_locals - 1) {
309     verifier()-&gt;verify_error(
310         ErrorContext::bad_local_index(_offset, index),
311         &quot;Local variable table overflow&quot;);
312     return;
313   }
314   // If type at index+1 is double or long, set the next location to be unusable
315   if (_locals[index+1].is_double() || _locals[index+1].is_long()) {
316     assert((index + 2) &lt; _locals_size, &quot;Local variable table overflow&quot;);
317     _locals[index + 2] = VerificationType::bogus_type();
318   }
319   // If type at index is double_2 or long_2, set the previous location to be unusable
320   if (_locals[index].is_double2() || _locals[index].is_long2()) {
321     assert(index &gt;= 1, &quot;Local variable table underflow&quot;);
322     _locals[index - 1] = VerificationType::bogus_type();
323   }
324   _locals[index] = type1;
325   _locals[index+1] = type2;
326   if (index &gt;= _locals_size - 1) {
327 #ifdef ASSERT
328     for (int i=_locals_size; i&lt;index; i++) {
329       assert(_locals[i] == VerificationType::bogus_type(),
330              &quot;holes must be bogus type&quot;);
331     }
332 #endif
333     _locals_size = index + 2;
334   }
335 }
336 
337 TypeOrigin StackMapFrame::stack_top_ctx() {
338   return TypeOrigin::stack(_stack_size, this);
339 }
340 
341 void StackMapFrame::print_on(outputStream* str) const {
342   str-&gt;indent().print_cr(&quot;bci: @%d&quot;, _offset);
343   str-&gt;indent().print_cr(&quot;flags: {%s }&quot;,
344       flag_this_uninit() ? &quot; flagThisUninit&quot; : &quot;&quot;);
345   str-&gt;indent().print(&quot;locals: {&quot;);
346   for (int32_t i = 0; i &lt; _locals_size; ++i) {
347     str-&gt;print(&quot; &quot;);
348     _locals[i].print_on(str);
349     if (i != _locals_size - 1) {
350       str-&gt;print(&quot;,&quot;);
351     }
352   }
353   str-&gt;print_cr(&quot; }&quot;);
354   str-&gt;indent().print(&quot;stack: {&quot;);
355   for (int32_t j = 0; j &lt; _stack_size; ++j) {
356     str-&gt;print(&quot; &quot;);
357     _stack[j].print_on(str);
358     if (j != _stack_size - 1) {
359       str-&gt;print(&quot;,&quot;);
360     }
361   }
362   str-&gt;print_cr(&quot; }&quot;);
363 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
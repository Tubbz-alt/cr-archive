<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/indexSet.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ifnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/indexSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 109,10 ***</span>
<span class="line-new-header">--- 109,13 ---</span>
  // corresponding to element.
  
  IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
    BitBlock *block = alloc_block();
    uint bi = get_block_index(element);
<span class="line-added">+   if (bi &gt;= _current_block_limit) {</span>
<span class="line-added">+     _current_block_limit = bi + 1;</span>
<span class="line-added">+   }</span>
    _blocks[bi] = block;
    return block;
  }
  
  //---------------------------- IndexSet::free_block() -------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,11 ***</span>
    assert(i &lt; _max_blocks, &quot;block index too large&quot;);
    BitBlock *block = _blocks[i];
    assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
    block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
    Compile::current()-&gt;set_indexSet_free_block_list(block);
<span class="line-modified">!   set_block(i,&amp;_empty_block);</span>
  }
  
  //------------------------------lrg_union--------------------------------------
  // Compute the union of all elements of one and two which interfere with
  // the RegMask mask.  If the degree of the union becomes exceeds
<span class="line-new-header">--- 126,11 ---</span>
    assert(i &lt; _max_blocks, &quot;block index too large&quot;);
    BitBlock *block = _blocks[i];
    assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
    block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
    Compile::current()-&gt;set_indexSet_free_block_list(block);
<span class="line-modified">!   set_block(i, &amp;_empty_block);</span>
  }
  
  //------------------------------lrg_union--------------------------------------
  // Compute the union of all elements of one and two which interfere with
  // the RegMask mask.  If the degree of the union becomes exceeds
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,42 ***</span>
    // Used to compute degree of register-only interferences.  Infinite-stack
    // neighbors do not alter colorability, as they can always color to some
    // other color.  (A variant of the Briggs assertion)
    uint reg_degree = 0;
  
<span class="line-modified">!   uint element;</span>
    // Load up the combined interference set with the neighbors of one
<span class="line-modified">!   IndexSetIterator elements(one);</span>
<span class="line-modified">!   while ((element = elements.next()) != 0) {</span>
<span class="line-modified">!     LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-modified">!     if (mask.overlap(lrg.mask())) {</span>
<span class="line-modified">!       insert(element);</span>
<span class="line-modified">!       if( !lrg.mask().is_AllStack() ) {</span>
<span class="line-modified">!         reg_degree += lrg1.compute_degree(lrg);</span>
<span class="line-modified">!         if( reg_degree &gt;= fail_degree ) return reg_degree;</span>
<span class="line-modified">!       } else {</span>
<span class="line-removed">-         // !!!!! Danger!  No update to reg_degree despite having a neighbor.</span>
<span class="line-removed">-         // A variant of the Briggs assertion.</span>
<span class="line-removed">-         // Not needed if I simplify during coalesce, ala George/Appel.</span>
<span class="line-removed">-         assert( lrg.lo_degree(), &quot;&quot; );</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Add neighbors of two as well</span>
<span class="line-removed">-   IndexSetIterator elements2(two);</span>
<span class="line-removed">-   while ((element = elements2.next()) != 0) {</span>
<span class="line-removed">-     LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-removed">-     if (mask.overlap(lrg.mask())) {</span>
<span class="line-removed">-       if (insert(element)) {</span>
<span class="line-removed">-         if( !lrg.mask().is_AllStack() ) {</span>
<span class="line-removed">-           reg_degree += lrg2.compute_degree(lrg);</span>
<span class="line-removed">-           if( reg_degree &gt;= fail_degree ) return reg_degree;</span>
          } else {
            // !!!!! Danger!  No update to reg_degree despite having a neighbor.
            // A variant of the Briggs assertion.
            // Not needed if I simplify during coalesce, ala George/Appel.
<span class="line-modified">!           assert( lrg.lo_degree(), &quot;&quot; );</span>
          }
        }
      }
    }
  
<span class="line-new-header">--- 169,47 ---</span>
    // Used to compute degree of register-only interferences.  Infinite-stack
    // neighbors do not alter colorability, as they can always color to some
    // other color.  (A variant of the Briggs assertion)
    uint reg_degree = 0;
  
<span class="line-modified">!   uint element = 0;</span>
    // Load up the combined interference set with the neighbors of one
<span class="line-modified">!   if (!one-&gt;is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator elements(one);</span>
<span class="line-modified">!     while ((element = elements.next()) != 0) {</span>
<span class="line-modified">!       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-modified">!       if (mask.overlap(lrg.mask())) {</span>
<span class="line-modified">!         insert(element);</span>
<span class="line-modified">!         if (!lrg.mask().is_AllStack()) {</span>
<span class="line-modified">!           reg_degree += lrg1.compute_degree(lrg);</span>
<span class="line-modified">!           if (reg_degree &gt;= fail_degree) return reg_degree;</span>
          } else {
            // !!!!! Danger!  No update to reg_degree despite having a neighbor.
            // A variant of the Briggs assertion.
            // Not needed if I simplify during coalesce, ala George/Appel.
<span class="line-modified">!           assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // Add neighbors of two as well</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!two-&gt;is_empty()) {</span>
<span class="line-added">+     IndexSetIterator elements2(two);</span>
<span class="line-added">+     while ((element = elements2.next()) != 0) {</span>
<span class="line-added">+       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-added">+       if (mask.overlap(lrg.mask())) {</span>
<span class="line-added">+         if (insert(element)) {</span>
<span class="line-added">+           if (!lrg.mask().is_AllStack()) {</span>
<span class="line-added">+             reg_degree += lrg2.compute_degree(lrg);</span>
<span class="line-added">+             if (reg_degree &gt;= fail_degree) return reg_degree;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             // !!!!! Danger!  No update to reg_degree despite having a neighbor.</span>
<span class="line-added">+             // A variant of the Briggs assertion.</span>
<span class="line-added">+             // Not needed if I simplify during coalesce, ala George/Appel.</span>
<span class="line-added">+             assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">+           }</span>
          }
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,10 ***</span>
<span class="line-new-header">--- 225,11 ---</span>
    set-&gt;check_watch(&quot;copied&quot;, _serial_number);
    check_watch(&quot;initialized by copy&quot;, set-&gt;_serial_number);
    _max_elements = set-&gt;_max_elements;
  #endif
    _count = set-&gt;_count;
<span class="line-added">+   _current_block_limit = set-&gt;_current_block_limit;</span>
    _max_blocks = set-&gt;_max_blocks;
    if (_max_blocks &lt;= preallocated_block_list_size) {
      _blocks = _preallocated_block_list;
    } else {
      _blocks =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,10 ***</span>
<span class="line-new-header">--- 255,11 ---</span>
    _serial_number = _serial_count++;
    check_watch(&quot;initialized&quot;, max_elements);
    _max_elements = max_elements;
  #endif
    _count = 0;
<span class="line-added">+   _current_block_limit = 0;</span>
    _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
  
    if (_max_blocks &lt;= preallocated_block_list_size) {
      _blocks = _preallocated_block_list;
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,10 ***</span>
<span class="line-new-header">--- 280,11 ---</span>
    _serial_number = _serial_count++;
    check_watch(&quot;initialized2&quot;, max_elements);
    _max_elements = max_elements;
  #endif // ASSERT
    _count = 0;
<span class="line-added">+   _current_block_limit = 0;</span>
    _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
  
    if (_max_blocks &lt;= preallocated_block_list_size) {
      _blocks = _preallocated_block_list;
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,18 ***</span>
    assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
    check_watch(&quot;swap&quot;, set-&gt;_serial_number);
    set-&gt;check_watch(&quot;swap&quot;, _serial_number);
  #endif
  
<span class="line-modified">!   for (uint i = 0; i &lt; _max_blocks; i++) {</span>
      BitBlock *temp = _blocks[i];
      set_block(i, set-&gt;_blocks[i]);
      set-&gt;set_block(i, temp);
    }
    uint temp = _count;
    _count = set-&gt;_count;
    set-&gt;_count = temp;
  }
  
  //---------------------------- IndexSet::dump() -----------------------------
  // Print this set.  Used for debugging.
  
<span class="line-new-header">--- 303,24 ---</span>
    assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
    check_watch(&quot;swap&quot;, set-&gt;_serial_number);
    set-&gt;check_watch(&quot;swap&quot;, _serial_number);
  #endif
  
<span class="line-modified">!   uint max = MAX2(_current_block_limit, set-&gt;_current_block_limit);</span>
<span class="line-added">+   for (uint i = 0; i &lt; max; i++) {</span>
      BitBlock *temp = _blocks[i];
      set_block(i, set-&gt;_blocks[i]);
      set-&gt;set_block(i, temp);
    }
    uint temp = _count;
    _count = set-&gt;_count;
    set-&gt;_count = temp;
<span class="line-added">+ </span>
<span class="line-added">+   temp = _current_block_limit;</span>
<span class="line-added">+   _current_block_limit = set-&gt;_current_block_limit;</span>
<span class="line-added">+   set-&gt;_current_block_limit = temp;</span>
<span class="line-added">+ </span>
  }
  
  //---------------------------- IndexSet::dump() -----------------------------
  // Print this set.  Used for debugging.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,82 ***</span>
  
  //---------------------------- IndexSetIterator() -----------------------------
  // Create an iterator for a set.  If empty blocks are detected when iterating
  // over the set, these blocks are replaced.
  
<span class="line-removed">- IndexSetIterator::IndexSetIterator(IndexSet *set) {</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   if (CollectIndexSetStatistics) {</span>
<span class="line-removed">-     set-&gt;tally_iteration_statistics();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   if (set-&gt;is_empty()) {</span>
<span class="line-removed">-     _current = 0;</span>
<span class="line-removed">-     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">-     _next_block = 1;</span>
<span class="line-removed">-     _max_blocks = 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We don&#39;t need the following values when we iterate over an empty set.</span>
<span class="line-removed">-     // The commented out code is left here to document that the omission</span>
<span class="line-removed">-     // is intentional.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     //_value = 0;</span>
<span class="line-removed">-     //_words = NULL;</span>
<span class="line-removed">-     //_blocks = NULL;</span>
<span class="line-removed">-     //_set = NULL;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _current = 0;</span>
<span class="line-removed">-     _value = 0;</span>
<span class="line-removed">-     _next_block = 0;</span>
<span class="line-removed">-     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     _max_blocks = set-&gt;_max_blocks;</span>
<span class="line-removed">-     _words = NULL;</span>
<span class="line-removed">-     _blocks = set-&gt;_blocks;</span>
<span class="line-removed">-     _set = set;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //---------------------------- IndexSetIterator(const) -----------------------------</span>
<span class="line-removed">- // Iterate over a constant IndexSet.</span>
<span class="line-removed">- </span>
<span class="line-removed">- IndexSetIterator::IndexSetIterator(const IndexSet *set) {</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   if (CollectIndexSetStatistics) {</span>
<span class="line-removed">-     set-&gt;tally_iteration_statistics();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // We don&#39;t call check_watch from here to avoid bad recursion.</span>
<span class="line-removed">-   //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   if (set-&gt;is_empty()) {</span>
<span class="line-removed">-     _current = 0;</span>
<span class="line-removed">-     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">-     _next_block = 1;</span>
<span class="line-removed">-     _max_blocks = 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We don&#39;t need the following values when we iterate over an empty set.</span>
<span class="line-removed">-     // The commented out code is left here to document that the omission</span>
<span class="line-removed">-     // is intentional.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     //_value = 0;</span>
<span class="line-removed">-     //_words = NULL;</span>
<span class="line-removed">-     //_blocks = NULL;</span>
<span class="line-removed">-     //_set = NULL;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _current = 0;</span>
<span class="line-removed">-     _value = 0;</span>
<span class="line-removed">-     _next_block = 0;</span>
<span class="line-removed">-     _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     _max_blocks = set-&gt;_max_blocks;</span>
<span class="line-removed">-     _words = NULL;</span>
<span class="line-removed">-     _blocks = set-&gt;_blocks;</span>
<span class="line-removed">-     _set = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //---------------------------- List16Iterator::advance_and_next() -----------------------------
  // Advance to the next non-empty word in the set being iterated over.  Return the next element
  // if there is one.  If we are done, return 0.  This method is called from the next() method
  // when it gets done with a word.
  
<span class="line-new-header">--- 398,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,14 ***</span>
    for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
      if (_words[wi] != 0) {
        // Found a non-empty word.
        _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
        _current = _words[wi];
<span class="line-modified">! </span>
<span class="line-modified">!       _next_word = wi+1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       return next();</span>
      }
    }
  
    // We ran out of words in the current block.  Advance to next non-empty block.
    for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
<span class="line-new-header">--- 410,12 ---</span>
    for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
      if (_words[wi] != 0) {
        // Found a non-empty word.
        _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
        _current = _words[wi];
<span class="line-modified">!       _next_word = wi + 1;</span>
<span class="line-modified">!       return next_value();</span>
      }
    }
  
    // We ran out of words in the current block.  Advance to next non-empty block.
    for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,12 ***</span>
            _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
            _current = _words[wi];
  
            _next_block = bi+1;
            _next_word = wi+1;
<span class="line-modified">! </span>
<span class="line-removed">-           return next();</span>
          }
        }
  
        // All of the words in the block were empty.  Replace
        // the block with the empty block.
<span class="line-new-header">--- 429,11 ---</span>
            _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
            _current = _words[wi];
  
            _next_block = bi+1;
            _next_word = wi+1;
<span class="line-modified">!           return next_value();</span>
          }
        }
  
        // All of the words in the block were empty.  Replace
        // the block with the empty block.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,13 ***</span>
          _set-&gt;free_block(bi);
        }
      }
    }
  
<span class="line-removed">-   // These assignments make redundant calls to next on a finished iterator</span>
<span class="line-removed">-   // faster.  Probably not necessary.</span>
<span class="line-removed">-   _next_block = _max_blocks;</span>
<span class="line-removed">-   _next_word = IndexSet::words_per_block;</span>
<span class="line-removed">- </span>
    // No more words.
    return 0;
  }
<span class="line-new-header">--- 441,8 ---</span>
</pre>
<center><a href="ifnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
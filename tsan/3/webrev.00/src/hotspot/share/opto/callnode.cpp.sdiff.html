<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="callnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  28 #include &quot;compiler/oopMap.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;opto/callGenerator.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/locknode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/parse.hpp&quot;
  41 #include &quot;opto/regalloc.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;

  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 //=============================================================================
  51 uint StartNode::size_of() const { return sizeof(*this); }
<span class="line-modified">  52 uint StartNode::cmp( const Node &amp;n ) const</span>
  53 { return _domain == ((StartNode&amp;)n)._domain; }
  54 const Type *StartNode::bottom_type() const { return _domain; }
  55 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  56 #ifndef PRODUCT
  57 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  58 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  59 #endif
  60 
  61 //------------------------------Ideal------------------------------------------
  62 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  63   return remove_dead_region(phase, can_reshape) ? this : NULL;
  64 }
  65 
  66 //------------------------------calling_convention-----------------------------
  67 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  68   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  69 }
  70 
  71 //------------------------------Registers--------------------------------------
  72 const RegMask &amp;StartNode::in_RegMask(uint) const {
</pre>
<hr />
<pre>
 649     ciMethod* method = jvms-&gt;method();
 650 
 651     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 652                                                                  temps + callee_parameters,
 653                                                                  extra_args,
 654                                                                  locks,
 655                                                                  callee_parameters,
 656                                                                  callee_locals,
 657                                                                  is_top_frame);
 658     size += frame_size;
 659 
 660     callee_parameters = method-&gt;size_of_parameters();
 661     callee_locals = method-&gt;max_locals();
 662     extra_args = 0;
 663     jvms = jvms-&gt;caller();
 664   }
 665   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 666 }
 667 
 668 //=============================================================================
<span class="line-modified"> 669 uint CallNode::cmp( const Node &amp;n ) const</span>
 670 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 671 #ifndef PRODUCT
 672 void CallNode::dump_req(outputStream *st) const {
 673   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 674   uint i;                       // Exit value of loop
 675   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 676     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 677     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 678     else st-&gt;print(&quot;_ &quot;);
 679   }
 680   st-&gt;print(&quot;)&quot;);
 681 }
 682 
 683 void CallNode::dump_spec(outputStream *st) const {
 684   st-&gt;print(&quot; &quot;);
 685   if (tf() != NULL)  tf()-&gt;dump_on(st);
 686   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 687   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 688 }
 689 #endif
</pre>
<hr />
<pre>
 945     } else {
 946       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 947       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 948         phase-&gt;C-&gt;prepend_late_inline(cg);
 949         set_generator(NULL);
 950       }
 951     }
 952   }
 953   return SafePointNode::Ideal(phase, can_reshape);
 954 }
 955 
 956 bool CallNode::is_call_to_arraycopystub() const {
 957   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 958     return true;
 959   }
 960   return false;
 961 }
 962 
 963 //=============================================================================
 964 uint CallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified"> 965 uint CallJavaNode::cmp( const Node &amp;n ) const {</span>
 966   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
 967   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
 968          _override_symbolic_info == call._override_symbolic_info;
 969 }
 970 #ifdef ASSERT
 971 bool CallJavaNode::validate_symbolic_info() const {
 972   if (method() == NULL) {
 973     return true; // call into runtime or uncommon trap
 974   }
 975   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
 976   ciMethod* callee = method();
 977   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
 978     assert(override_symbolic_info(), &quot;should be set&quot;);
 979   }
 980   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
 981   return true;
 982 }
 983 #endif
 984 
 985 #ifndef PRODUCT
 986 void CallJavaNode::dump_spec(outputStream *st) const {
 987   if( _method ) _method-&gt;print_short_name(st);
 988   CallNode::dump_spec(st);
 989 }
 990 
 991 void CallJavaNode::dump_compact_spec(outputStream* st) const {
 992   if (_method) {
 993     _method-&gt;print_short_name(st);
 994   } else {
 995     st-&gt;print(&quot;&lt;?&gt;&quot;);
 996   }
 997 }
 998 #endif
 999 
1000 //=============================================================================
1001 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1002 uint CallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
1003   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1004   return CallJavaNode::cmp(call);
1005 }
1006 
1007 //----------------------------uncommon_trap_request----------------------------
1008 // If this is an uncommon trap, return the request code, else zero.
1009 int CallStaticJavaNode::uncommon_trap_request() const {
1010   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1011     return extract_uncommon_trap_request(this);
1012   }
1013   return 0;
1014 }
1015 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1016 #ifndef PRODUCT
1017   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1018         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1019         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1020         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1021     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1022     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
</pre>
<hr />
<pre>
1039                                                      trap_req));
1040     }
1041     st-&gt;print(&quot; &quot;);
1042   }
1043   CallJavaNode::dump_spec(st);
1044 }
1045 
1046 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1047   if (_method) {
1048     _method-&gt;print_short_name(st);
1049   } else if (_name) {
1050     st-&gt;print(&quot;%s&quot;, _name);
1051   } else {
1052     st-&gt;print(&quot;&lt;?&gt;&quot;);
1053   }
1054 }
1055 #endif
1056 
1057 //=============================================================================
1058 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1059 uint CallDynamicJavaNode::cmp( const Node &amp;n ) const {</span>
1060   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1061   return CallJavaNode::cmp(call);
1062 }
1063 #ifndef PRODUCT
1064 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1065   st-&gt;print(&quot;# Dynamic &quot;);
1066   CallJavaNode::dump_spec(st);
1067 }
1068 #endif
1069 
1070 //=============================================================================
1071 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1072 uint CallRuntimeNode::cmp( const Node &amp;n ) const {</span>
1073   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1074   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1075 }
1076 #ifndef PRODUCT
1077 void CallRuntimeNode::dump_spec(outputStream *st) const {
1078   st-&gt;print(&quot;# &quot;);
1079   st-&gt;print(&quot;%s&quot;, _name);
1080   CallNode::dump_spec(st);
1081 }
1082 #endif
1083 
1084 //------------------------------calling_convention-----------------------------
1085 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1086   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1087 }
1088 
1089 //=============================================================================
1090 //------------------------------calling_convention-----------------------------
1091 
1092 
</pre>
<hr />
<pre>
1101 
1102 //=============================================================================
1103 
1104 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1105   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1106   int loc = jvms-&gt;locoff() + idx;
1107   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1108     // If current local idx is top then local idx - 1 could
1109     // be a long/double that needs to be killed since top could
1110     // represent the 2nd half ofthe long/double.
1111     uint ideal = in(loc -1)-&gt;ideal_reg();
1112     if (ideal == Op_RegD || ideal == Op_RegL) {
1113       // set other (low index) half to top
1114       set_req(loc - 1, in(loc));
1115     }
1116   }
1117   set_req(loc, c);
1118 }
1119 
1120 uint SafePointNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1121 uint SafePointNode::cmp( const Node &amp;n ) const {</span>
1122   return (&amp;n == this);          // Always fail except on self
1123 }
1124 
1125 //-------------------------set_next_exception----------------------------------
1126 void SafePointNode::set_next_exception(SafePointNode* n) {
1127   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1128   if (len() == req()) {
1129     if (n != NULL)  add_prec(n);
1130   } else {
1131     set_prec(req(), n);
1132   }
1133 }
1134 
1135 
1136 //----------------------------next_exception-----------------------------------
1137 SafePointNode* SafePointNode::next_exception() const {
1138   if (len() == req()) {
1139     return NULL;
1140   } else {
1141     Node* n = in(req());
</pre>
<hr />
<pre>
1297 //==============  SafePointScalarObjectNode  ==============
1298 
1299 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1300 #ifdef ASSERT
1301                                                      AllocateNode* alloc,
1302 #endif
1303                                                      uint first_index,
1304                                                      uint n_fields) :
1305   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1306   _first_index(first_index),
1307   _n_fields(n_fields)
1308 #ifdef ASSERT
1309   , _alloc(alloc)
1310 #endif
1311 {
1312   init_class_id(Class_SafePointScalarObject);
1313 }
1314 
1315 // Do not allow value-numbering for SafePointScalarObject node.
1316 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
<span class="line-modified">1317 uint SafePointScalarObjectNode::cmp( const Node &amp;n ) const {</span>
1318   return (&amp;n == this); // Always fail except on self
1319 }
1320 
1321 uint SafePointScalarObjectNode::ideal_reg() const {
1322   return 0; // No matching to machine instruction
1323 }
1324 
1325 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1326   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1327 }
1328 
1329 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1330   return RegMask::Empty;
1331 }
1332 
1333 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1334   return 0;
1335 }
1336 
1337 SafePointScalarObjectNode*
</pre>
<hr />
<pre>
1380   init_req( ALength            , topnode);
1381   C-&gt;add_macro_node(this);
1382 }
1383 
1384 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1385 {
1386   assert(initializer != NULL &amp;&amp;
1387          initializer-&gt;is_initializer() &amp;&amp;
1388          !initializer-&gt;is_static(),
1389              &quot;unexpected initializer method&quot;);
1390   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1391   if (analyzer == NULL) {
1392     return;
1393   }
1394 
1395   // Allocation node is first parameter in its initializer
1396   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1397     _is_allocation_MemBar_redundant = true;
1398   }
1399 }












1400 
1401 //=============================================================================
1402 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1403   if (remove_dead_region(phase, can_reshape))  return this;
1404   // Don&#39;t bother trying to transform a dead node
1405   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1406 
1407   const Type* type = phase-&gt;type(Ideal_length());
1408   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1409     if (can_reshape) {
1410       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1411       // Unreachable fall through path (negative array length),
1412       // the allocation can only throw so disconnect it.
1413       Node* proj = proj_out_or_null(TypeFunc::Control);
1414       Node* catchproj = NULL;
1415       if (proj != NULL) {
1416         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1417           Node *cn = proj-&gt;fast_out(i);
1418           if (cn-&gt;is_Catch()) {
1419             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1420             break;
1421           }
1422         }
1423       }
1424       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1425           (catchproj-&gt;outcnt() &gt; 1 ||
1426            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1427         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1428         Node* nproj = catchproj-&gt;clone();
1429         igvn-&gt;register_new_node_with_optimizer(nproj);
1430 
1431         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1432         frame = phase-&gt;transform(frame);
1433         // Halt &amp; Catch Fire
<span class="line-modified">1434         Node *halt = new HaltNode( nproj, frame );</span>
1435         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1436         phase-&gt;transform(halt);
1437 
1438         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1439         return this;
1440       }
1441     } else {
1442       // Can&#39;t correct it during regular GVN so register for IGVN
1443       phase-&gt;C-&gt;record_for_igvn(this);
1444     }
1445   }
1446   return NULL;
1447 }
1448 
1449 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1450 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1451 // a CastII is appropriate, return NULL.
1452 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1453   Node *length = in(AllocateNode::ALength);
1454   assert(length != NULL, &quot;length is not null&quot;);
</pre>
<hr />
<pre>
2067     }
2068     if (!t_oop-&gt;isa_aryptr()) {
2069       return true;
2070     }
2071 
2072     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2073     if (elem == Type::BOTTOM) {
2074       // An array but we don&#39;t know what elements are
2075       return true;
2076     }
2077 
2078     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2079     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2080     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2081 
2082     return dest_alias == t_oop_alias;
2083   }
2084 
2085   return true;
2086 }
<span class="line-removed">2087 </span>
</pre>
</td>
<td>
<hr />
<pre>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  28 #include &quot;compiler/oopMap.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;opto/callGenerator.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/locknode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/parse.hpp&quot;
  41 #include &quot;opto/regalloc.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
<span class="line-added">  45 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  46 
  47 // Portions of code courtesy of Clifford Click
  48 
  49 // Optimization - Graph Style
  50 
  51 //=============================================================================
  52 uint StartNode::size_of() const { return sizeof(*this); }
<span class="line-modified">  53 bool StartNode::cmp( const Node &amp;n ) const</span>
  54 { return _domain == ((StartNode&amp;)n)._domain; }
  55 const Type *StartNode::bottom_type() const { return _domain; }
  56 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  57 #ifndef PRODUCT
  58 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  59 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  60 #endif
  61 
  62 //------------------------------Ideal------------------------------------------
  63 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  64   return remove_dead_region(phase, can_reshape) ? this : NULL;
  65 }
  66 
  67 //------------------------------calling_convention-----------------------------
  68 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  69   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  70 }
  71 
  72 //------------------------------Registers--------------------------------------
  73 const RegMask &amp;StartNode::in_RegMask(uint) const {
</pre>
<hr />
<pre>
 650     ciMethod* method = jvms-&gt;method();
 651 
 652     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 653                                                                  temps + callee_parameters,
 654                                                                  extra_args,
 655                                                                  locks,
 656                                                                  callee_parameters,
 657                                                                  callee_locals,
 658                                                                  is_top_frame);
 659     size += frame_size;
 660 
 661     callee_parameters = method-&gt;size_of_parameters();
 662     callee_locals = method-&gt;max_locals();
 663     extra_args = 0;
 664     jvms = jvms-&gt;caller();
 665   }
 666   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 667 }
 668 
 669 //=============================================================================
<span class="line-modified"> 670 bool CallNode::cmp( const Node &amp;n ) const</span>
 671 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 672 #ifndef PRODUCT
 673 void CallNode::dump_req(outputStream *st) const {
 674   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 675   uint i;                       // Exit value of loop
 676   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 677     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 678     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 679     else st-&gt;print(&quot;_ &quot;);
 680   }
 681   st-&gt;print(&quot;)&quot;);
 682 }
 683 
 684 void CallNode::dump_spec(outputStream *st) const {
 685   st-&gt;print(&quot; &quot;);
 686   if (tf() != NULL)  tf()-&gt;dump_on(st);
 687   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 688   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 689 }
 690 #endif
</pre>
<hr />
<pre>
 946     } else {
 947       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 948       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 949         phase-&gt;C-&gt;prepend_late_inline(cg);
 950         set_generator(NULL);
 951       }
 952     }
 953   }
 954   return SafePointNode::Ideal(phase, can_reshape);
 955 }
 956 
 957 bool CallNode::is_call_to_arraycopystub() const {
 958   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 959     return true;
 960   }
 961   return false;
 962 }
 963 
 964 //=============================================================================
 965 uint CallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified"> 966 bool CallJavaNode::cmp( const Node &amp;n ) const {</span>
 967   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
 968   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
 969          _override_symbolic_info == call._override_symbolic_info;
 970 }
 971 #ifdef ASSERT
 972 bool CallJavaNode::validate_symbolic_info() const {
 973   if (method() == NULL) {
 974     return true; // call into runtime or uncommon trap
 975   }
 976   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
 977   ciMethod* callee = method();
 978   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
 979     assert(override_symbolic_info(), &quot;should be set&quot;);
 980   }
 981   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
 982   return true;
 983 }
 984 #endif
 985 
 986 #ifndef PRODUCT
 987 void CallJavaNode::dump_spec(outputStream *st) const {
 988   if( _method ) _method-&gt;print_short_name(st);
 989   CallNode::dump_spec(st);
 990 }
 991 
 992 void CallJavaNode::dump_compact_spec(outputStream* st) const {
 993   if (_method) {
 994     _method-&gt;print_short_name(st);
 995   } else {
 996     st-&gt;print(&quot;&lt;?&gt;&quot;);
 997   }
 998 }
 999 #endif
1000 
1001 //=============================================================================
1002 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1003 bool CallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
1004   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1005   return CallJavaNode::cmp(call);
1006 }
1007 
1008 //----------------------------uncommon_trap_request----------------------------
1009 // If this is an uncommon trap, return the request code, else zero.
1010 int CallStaticJavaNode::uncommon_trap_request() const {
1011   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1012     return extract_uncommon_trap_request(this);
1013   }
1014   return 0;
1015 }
1016 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1017 #ifndef PRODUCT
1018   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1019         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1020         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1021         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1022     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1023     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
</pre>
<hr />
<pre>
1040                                                      trap_req));
1041     }
1042     st-&gt;print(&quot; &quot;);
1043   }
1044   CallJavaNode::dump_spec(st);
1045 }
1046 
1047 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1048   if (_method) {
1049     _method-&gt;print_short_name(st);
1050   } else if (_name) {
1051     st-&gt;print(&quot;%s&quot;, _name);
1052   } else {
1053     st-&gt;print(&quot;&lt;?&gt;&quot;);
1054   }
1055 }
1056 #endif
1057 
1058 //=============================================================================
1059 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1060 bool CallDynamicJavaNode::cmp( const Node &amp;n ) const {</span>
1061   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1062   return CallJavaNode::cmp(call);
1063 }
1064 #ifndef PRODUCT
1065 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1066   st-&gt;print(&quot;# Dynamic &quot;);
1067   CallJavaNode::dump_spec(st);
1068 }
1069 #endif
1070 
1071 //=============================================================================
1072 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1073 bool CallRuntimeNode::cmp( const Node &amp;n ) const {</span>
1074   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1075   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1076 }
1077 #ifndef PRODUCT
1078 void CallRuntimeNode::dump_spec(outputStream *st) const {
1079   st-&gt;print(&quot;# &quot;);
1080   st-&gt;print(&quot;%s&quot;, _name);
1081   CallNode::dump_spec(st);
1082 }
1083 #endif
1084 
1085 //------------------------------calling_convention-----------------------------
1086 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1087   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1088 }
1089 
1090 //=============================================================================
1091 //------------------------------calling_convention-----------------------------
1092 
1093 
</pre>
<hr />
<pre>
1102 
1103 //=============================================================================
1104 
1105 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1106   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1107   int loc = jvms-&gt;locoff() + idx;
1108   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1109     // If current local idx is top then local idx - 1 could
1110     // be a long/double that needs to be killed since top could
1111     // represent the 2nd half ofthe long/double.
1112     uint ideal = in(loc -1)-&gt;ideal_reg();
1113     if (ideal == Op_RegD || ideal == Op_RegL) {
1114       // set other (low index) half to top
1115       set_req(loc - 1, in(loc));
1116     }
1117   }
1118   set_req(loc, c);
1119 }
1120 
1121 uint SafePointNode::size_of() const { return sizeof(*this); }
<span class="line-modified">1122 bool SafePointNode::cmp( const Node &amp;n ) const {</span>
1123   return (&amp;n == this);          // Always fail except on self
1124 }
1125 
1126 //-------------------------set_next_exception----------------------------------
1127 void SafePointNode::set_next_exception(SafePointNode* n) {
1128   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1129   if (len() == req()) {
1130     if (n != NULL)  add_prec(n);
1131   } else {
1132     set_prec(req(), n);
1133   }
1134 }
1135 
1136 
1137 //----------------------------next_exception-----------------------------------
1138 SafePointNode* SafePointNode::next_exception() const {
1139   if (len() == req()) {
1140     return NULL;
1141   } else {
1142     Node* n = in(req());
</pre>
<hr />
<pre>
1298 //==============  SafePointScalarObjectNode  ==============
1299 
1300 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1301 #ifdef ASSERT
1302                                                      AllocateNode* alloc,
1303 #endif
1304                                                      uint first_index,
1305                                                      uint n_fields) :
1306   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1307   _first_index(first_index),
1308   _n_fields(n_fields)
1309 #ifdef ASSERT
1310   , _alloc(alloc)
1311 #endif
1312 {
1313   init_class_id(Class_SafePointScalarObject);
1314 }
1315 
1316 // Do not allow value-numbering for SafePointScalarObject node.
1317 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
<span class="line-modified">1318 bool SafePointScalarObjectNode::cmp( const Node &amp;n ) const {</span>
1319   return (&amp;n == this); // Always fail except on self
1320 }
1321 
1322 uint SafePointScalarObjectNode::ideal_reg() const {
1323   return 0; // No matching to machine instruction
1324 }
1325 
1326 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1327   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1328 }
1329 
1330 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1331   return RegMask::Empty;
1332 }
1333 
1334 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1335   return 0;
1336 }
1337 
1338 SafePointScalarObjectNode*
</pre>
<hr />
<pre>
1381   init_req( ALength            , topnode);
1382   C-&gt;add_macro_node(this);
1383 }
1384 
1385 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1386 {
1387   assert(initializer != NULL &amp;&amp;
1388          initializer-&gt;is_initializer() &amp;&amp;
1389          !initializer-&gt;is_static(),
1390              &quot;unexpected initializer method&quot;);
1391   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1392   if (analyzer == NULL) {
1393     return;
1394   }
1395 
1396   // Allocation node is first parameter in its initializer
1397   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1398     _is_allocation_MemBar_redundant = true;
1399   }
1400 }
<span class="line-added">1401 Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {</span>
<span class="line-added">1402   Node* mark_node = NULL;</span>
<span class="line-added">1403   // For now only enable fast locking for non-array types</span>
<span class="line-added">1404   if (UseBiasedLocking &amp;&amp; Opcode() == Op_Allocate) {</span>
<span class="line-added">1405     Node* klass_node = in(AllocateNode::KlassNode);</span>
<span class="line-added">1406     Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));</span>
<span class="line-added">1407     mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);</span>
<span class="line-added">1408   } else {</span>
<span class="line-added">1409     mark_node = phase-&gt;MakeConX(markWord::prototype().value());</span>
<span class="line-added">1410   }</span>
<span class="line-added">1411   return mark_node;</span>
<span class="line-added">1412 }</span>
1413 
1414 //=============================================================================
1415 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1416   if (remove_dead_region(phase, can_reshape))  return this;
1417   // Don&#39;t bother trying to transform a dead node
1418   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1419 
1420   const Type* type = phase-&gt;type(Ideal_length());
1421   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1422     if (can_reshape) {
1423       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1424       // Unreachable fall through path (negative array length),
1425       // the allocation can only throw so disconnect it.
1426       Node* proj = proj_out_or_null(TypeFunc::Control);
1427       Node* catchproj = NULL;
1428       if (proj != NULL) {
1429         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1430           Node *cn = proj-&gt;fast_out(i);
1431           if (cn-&gt;is_Catch()) {
1432             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1433             break;
1434           }
1435         }
1436       }
1437       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1438           (catchproj-&gt;outcnt() &gt; 1 ||
1439            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1440         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1441         Node* nproj = catchproj-&gt;clone();
1442         igvn-&gt;register_new_node_with_optimizer(nproj);
1443 
1444         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1445         frame = phase-&gt;transform(frame);
1446         // Halt &amp; Catch Fire
<span class="line-modified">1447         Node* halt = new HaltNode(nproj, frame, &quot;unexpected negative array length&quot;);</span>
1448         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1449         phase-&gt;transform(halt);
1450 
1451         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1452         return this;
1453       }
1454     } else {
1455       // Can&#39;t correct it during regular GVN so register for IGVN
1456       phase-&gt;C-&gt;record_for_igvn(this);
1457     }
1458   }
1459   return NULL;
1460 }
1461 
1462 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1463 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1464 // a CastII is appropriate, return NULL.
1465 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1466   Node *length = in(AllocateNode::ALength);
1467   assert(length != NULL, &quot;length is not null&quot;);
</pre>
<hr />
<pre>
2080     }
2081     if (!t_oop-&gt;isa_aryptr()) {
2082       return true;
2083     }
2084 
2085     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2086     if (elem == Type::BOTTOM) {
2087       // An array but we don&#39;t know what elements are
2088       return true;
2089     }
2090 
2091     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2092     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2093     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2094 
2095     return dest_alias == t_oop_alias;
2096   }
2097 
2098   return true;
2099 }

</pre>
</td>
</tr>
</table>
<center><a href="callGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="callnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
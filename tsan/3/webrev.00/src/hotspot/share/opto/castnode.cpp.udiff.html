<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/castnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/castnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -61,10 +61,18 @@</span>
        if( t1 == Type::TOP )  assert(ft == Type::TOP, &quot;special case #1&quot;);
        const Type* rt = t1-&gt;join_speculative(_type);
        if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);
        break;
      }
<span class="udiff-line-added">+     case Op_CastLL:</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       const Type* t1 = phase-&gt;type(in(1));</span>
<span class="udiff-line-added">+       if (t1 == Type::TOP)   assert(ft == Type::TOP, &quot;special case #1&quot;);</span>
<span class="udiff-line-added">+       const Type* rt = t1-&gt;join_speculative(_type);</span>
<span class="udiff-line-added">+       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
      case Op_CastPP:
      if (phase-&gt;type(in(1)) == TypePtr::NULL_PTR &amp;&amp;
          _type-&gt;isa_ptr() &amp;&amp; _type-&gt;is_ptr()-&gt;_ptr == TypePtr::NotNull)
      assert(ft == Type::TOP, &quot;special case #3&quot;);
      break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79,11 +87,11 @@</span>
  // control copies
  Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {
    return (in(0) &amp;&amp; remove_dead_region(phase, can_reshape)) ? this : NULL;
  }
  
<span class="udiff-line-modified-removed">- uint ConstraintCastNode::cmp(const Node &amp;n) const {</span>
<span class="udiff-line-modified-added">+ bool ConstraintCastNode::cmp(const Node &amp;n) const {</span>
    return TypeNode::cmp(n) &amp;&amp; ((ConstraintCastNode&amp;)n)._carry_dependency == _carry_dependency;
  }
  
  uint ConstraintCastNode::size_of() const {
    return sizeof(*this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -94,10 +102,15 @@</span>
    case Op_CastII: {
      Node* cast = new CastIINode(n, t, carry_dependency);
      cast-&gt;set_req(0, c);
      return cast;
    }
<span class="udiff-line-added">+   case Op_CastLL: {</span>
<span class="udiff-line-added">+     Node* cast = new CastLLNode(n, t, carry_dependency);</span>
<span class="udiff-line-added">+     cast-&gt;set_req(0, c);</span>
<span class="udiff-line-added">+     return cast;</span>
<span class="udiff-line-added">+   }</span>
    case Op_CastPP: {
      Node* cast = new CastPPNode(n, t, carry_dependency);
      cast-&gt;set_req(0, c);
      return cast;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -260,11 +273,11 @@</span>
      }
    }
    return NULL;
  }
  
<span class="udiff-line-modified-removed">- uint CastIINode::cmp(const Node &amp;n) const {</span>
<span class="udiff-line-modified-added">+ bool CastIINode::cmp(const Node &amp;n) const {</span>
    return ConstraintCastNode::cmp(n) &amp;&amp; ((CastIINode&amp;)n)._range_check_dependency == _range_check_dependency;
  }
  
  uint CastIINode::size_of() const {
    return sizeof(*this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,10 +290,49 @@</span>
      st-&gt;print(&quot; range check dependency&quot;);
    }
  }
  #endif
  
<span class="udiff-line-added">+ Node* CastLLNode::Ideal(PhaseGVN* phase, bool can_reshape) {</span>
<span class="udiff-line-added">+   Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);</span>
<span class="udiff-line-added">+   if (progress != NULL) {</span>
<span class="udiff-line-added">+     return progress;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Same as in CastIINode::Ideal but for TypeLong instead of TypeInt</span>
<span class="udiff-line-added">+   if (can_reshape &amp;&amp; !phase-&gt;C-&gt;major_progress()) {</span>
<span class="udiff-line-added">+     const TypeLong* this_type = this-&gt;type()-&gt;is_long();</span>
<span class="udiff-line-added">+     const TypeLong* in_type = phase-&gt;type(in(1))-&gt;isa_long();</span>
<span class="udiff-line-added">+     if (in_type != NULL &amp;&amp; this_type != NULL &amp;&amp;</span>
<span class="udiff-line-added">+         (in_type-&gt;_lo != this_type-&gt;_lo ||</span>
<span class="udiff-line-added">+          in_type-&gt;_hi != this_type-&gt;_hi)) {</span>
<span class="udiff-line-added">+       jlong lo1 = this_type-&gt;_lo;</span>
<span class="udiff-line-added">+       jlong hi1 = this_type-&gt;_hi;</span>
<span class="udiff-line-added">+       int w1  = this_type-&gt;_widen;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (lo1 &gt;= 0) {</span>
<span class="udiff-line-added">+         // Keep a range assertion of &gt;=0.</span>
<span class="udiff-line-added">+         lo1 = 0;         hi1 = max_jlong;</span>
<span class="udiff-line-added">+       } else if (hi1 &lt; 0) {</span>
<span class="udiff-line-added">+         // Keep a range assertion of &lt;0.</span>
<span class="udiff-line-added">+         lo1 = min_jlong; hi1 = -1;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         lo1 = min_jlong; hi1 = max_jlong;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       const TypeLong* wtype = TypeLong::make(MAX2(in_type-&gt;_lo, lo1),</span>
<span class="udiff-line-added">+                                              MIN2(in_type-&gt;_hi, hi1),</span>
<span class="udiff-line-added">+                                              MAX2((int)in_type-&gt;_widen, w1));</span>
<span class="udiff-line-added">+       if (wtype != type()) {</span>
<span class="udiff-line-added">+         set_type(wtype);</span>
<span class="udiff-line-added">+         return this;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  //=============================================================================
  //------------------------------Identity---------------------------------------
  // If input is already higher or equal to cast type, then this is an identity.
  Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
    Node* dom = dominating_cast(phase, phase);
</pre>
<center><a href="callnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/indexSet.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="indexSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="lcm.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/indexSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -188,10 +188,13 @@</span>
    //-------------------------- Members ------------------------------------------
  
    // The number of elements in the set
    uint      _count;
  
<span class="udiff-line-added">+   // The current upper limit of blocks that has been allocated and might be in use</span>
<span class="udiff-line-added">+   uint      _current_block_limit;</span>
<span class="udiff-line-added">+ </span>
    // Our top level array of bitvector segments
    BitBlock **_blocks;
  
    BitBlock  *_preallocated_block_list[preallocated_block_list_size];
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,24 +212,14 @@</span>
   public:
    //-------------------------- Free list operations ------------------------------
    // Individual IndexSets can be placed on a free list.  This is done in PhaseLive.
  
    IndexSet *next() {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto ) {</span>
<span class="udiff-line-removed">-       check_watch(&quot;removed from free list?&quot;, ((_next == NULL) ? 0 : _next-&gt;_serial_number));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
      return _next;
    }
  
    void set_next(IndexSet *next) {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto ) {</span>
<span class="udiff-line-removed">-       check_watch(&quot;put on free list?&quot;, ((next == NULL) ? 0 : next-&gt;_serial_number));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
      _next = next;
    }
  
   private:
    //-------------------------- Utility methods -----------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -237,14 +230,10 @@</span>
      return _blocks[get_block_index(element)];
    }
  
    // Set a block in the top level array
    void set_block(uint index, BitBlock *block) {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto )</span>
<span class="udiff-line-removed">-       check_watch(&quot;set block&quot;, index);</span>
<span class="udiff-line-removed">- #endif</span>
      _blocks[index] = block;
    }
  
    // Get a BitBlock from the free list
    BitBlock *alloc_block();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -257,21 +246,18 @@</span>
  
   public:
    //-------------------------- Primitive set operations --------------------------
  
    void clear() {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto )</span>
<span class="udiff-line-removed">-       check_watch(&quot;clear&quot;);</span>
<span class="udiff-line-removed">- #endif</span>
      _count = 0;
<span class="udiff-line-modified-removed">-     for (uint i = 0; i &lt; _max_blocks; i++) {</span>
<span class="udiff-line-modified-added">+     for (uint i = 0; i &lt; _current_block_limit; i++) {</span>
        BitBlock *block = _blocks[i];
        if (block != &amp;_empty_block) {
          free_block(i);
        }
      }
<span class="udiff-line-added">+     _current_block_limit = 0;</span>
    }
  
    uint count() const { return _count; }
  
    bool is_empty() const { return _count == 0; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,14 +265,10 @@</span>
    bool member(uint element) const {
      return get_block_containing(element)-&gt;member(element);
    }
  
    bool insert(uint element) {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto )</span>
<span class="udiff-line-removed">-       check_watch(&quot;insert&quot;, element);</span>
<span class="udiff-line-removed">- #endif</span>
      if (element == 0) {
        return 0;
      }
      BitBlock *block = get_block_containing(element);
      if (block == &amp;_empty_block) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,15 +280,10 @@</span>
      }
      return !present;
    }
  
    bool remove(uint element) {
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if( VerifyOpto )</span>
<span class="udiff-line-removed">-       check_watch(&quot;remove&quot;, element);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
      BitBlock *block = get_block_containing(element);
      bool present = block-&gt;remove(element);
      if (present) {
        _count--;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,22 +382,22 @@</span>
    uint                  _value;
  
    // The index of the next word we will inspect
    uint                  _next_word;
  
<span class="udiff-line-removed">-   // A pointer to the contents of the current block</span>
<span class="udiff-line-removed">-   uint32_t             *_words;</span>
<span class="udiff-line-removed">- </span>
    // The index of the next block we will inspect
    uint                  _next_block;
  
<span class="udiff-line-removed">-   // A pointer to the blocks in our set</span>
<span class="udiff-line-removed">-   IndexSet::BitBlock **_blocks;</span>
<span class="udiff-line-removed">- </span>
    // The number of blocks in the set
    uint                  _max_blocks;
  
<span class="udiff-line-added">+   // A pointer to the contents of the current block</span>
<span class="udiff-line-added">+   uint32_t             *_words;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // A pointer to the blocks in our set</span>
<span class="udiff-line-added">+   IndexSet::BitBlock **_blocks;</span>
<span class="udiff-line-added">+ </span>
    // If the iterator was created from a non-const set, we replace
    // non-canonical empty blocks with the _empty_block pointer.  If
    // _set is NULL, we do no replacement.
    IndexSet            *_set;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -430,24 +407,66 @@</span>
  
   public:
  
    // If an iterator is built from a constant set then empty blocks
    // are not canonicalized.
<span class="udiff-line-modified-removed">-   IndexSetIterator(IndexSet *set);</span>
<span class="udiff-line-modified-removed">-   IndexSetIterator(const IndexSet *set);</span>
<span class="udiff-line-modified-added">+   IndexSetIterator(IndexSet *set) :</span>
<span class="udiff-line-modified-added">+     _current(0),</span>
<span class="udiff-line-added">+     _value(0),</span>
<span class="udiff-line-added">+     _next_word(IndexSet::words_per_block),</span>
<span class="udiff-line-added">+     _next_block(0),</span>
<span class="udiff-line-added">+     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="udiff-line-added">+     _words(NULL),</span>
<span class="udiff-line-added">+     _blocks(set-&gt;_blocks),</span>
<span class="udiff-line-added">+     _set(set) {</span>
<span class="udiff-line-added">+   #ifdef ASSERT</span>
<span class="udiff-line-added">+     if (CollectIndexSetStatistics) {</span>
<span class="udiff-line-added">+       set-&gt;tally_iteration_statistics();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());</span>
<span class="udiff-line-added">+   #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   IndexSetIterator(const IndexSet *set) :</span>
<span class="udiff-line-added">+     _current(0),</span>
<span class="udiff-line-added">+     _value(0),</span>
<span class="udiff-line-added">+     _next_word(IndexSet::words_per_block),</span>
<span class="udiff-line-added">+     _next_block(0),</span>
<span class="udiff-line-added">+     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="udiff-line-added">+     _words(NULL),</span>
<span class="udiff-line-added">+     _blocks(set-&gt;_blocks),</span>
<span class="udiff-line-added">+     _set(NULL)</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+   #ifdef ASSERT</span>
<span class="udiff-line-added">+     if (CollectIndexSetStatistics) {</span>
<span class="udiff-line-added">+       set-&gt;tally_iteration_statistics();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // We don&#39;t call check_watch from here to avoid bad recursion.</span>
<span class="udiff-line-added">+     //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());</span>
<span class="udiff-line-added">+   #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Return the next element of the set.</span>
<span class="udiff-line-added">+   uint next_value() {</span>
<span class="udiff-line-added">+     uint current = _current;</span>
<span class="udiff-line-added">+     assert(current != 0, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+     uint advance = count_trailing_zeros(current);</span>
<span class="udiff-line-added">+     assert(((current &gt;&gt; advance) &amp; 0x1) == 1, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+     _current = (current &gt;&gt; advance) - 1;</span>
<span class="udiff-line-added">+     _value += advance;</span>
<span class="udiff-line-added">+     return _value;</span>
<span class="udiff-line-added">+   }</span>
  
    // Return the next element of the set.  Return 0 when done.
    uint next() {
<span class="udiff-line-modified-removed">-     uint current = _current;</span>
<span class="udiff-line-modified-removed">-     if (current != 0) {</span>
<span class="udiff-line-modified-removed">-       uint advance = count_trailing_zeros(current);</span>
<span class="udiff-line-removed">-       assert(((current &gt;&gt; advance) &amp; 0x1) == 1, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-       _current = (current &gt;&gt; advance) - 1;</span>
<span class="udiff-line-removed">-       _value += advance;</span>
<span class="udiff-line-removed">-       return _value;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-modified-added">+     if (_current != 0) {</span>
<span class="udiff-line-modified-added">+       return next_value();</span>
<span class="udiff-line-modified-added">+     } else if (_next_word &lt; IndexSet::words_per_block || _next_block &lt; _max_blocks) {</span>
        return advance_and_next();
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return 0;</span>
      }
    }
<span class="udiff-line-added">+ </span>
  };
  
  #endif // SHARE_OPTO_INDEXSET_HPP
</pre>
<center><a href="indexSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="lcm.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="opaquenode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29,10 +29,12 @@</span>
  #include &quot;code/debugInfo.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/compilerDirectives.hpp&quot;
  #include &quot;compiler/oopMap.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;opto/ad.hpp&quot;
  #include &quot;opto/callnode.hpp&quot;
  #include &quot;opto/cfgnode.hpp&quot;
  #include &quot;opto/locknode.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,10 +44,11 @@</span>
  #include &quot;opto/regalloc.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
  #include &quot;opto/type.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/xmlstream.hpp&quot;
  
  #ifndef PRODUCT
  #define DEBUG_ARG(x) , x
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -112,39 +115,37 @@</span>
          _cfg-&gt;map_node_to_block(epilog, block);
        }
      }
    }
  
<span class="udiff-line-added">+   // Keeper of sizing aspects</span>
<span class="udiff-line-added">+   BufferSizingData buf_sizes = BufferSizingData();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Initialize code buffer</span>
<span class="udiff-line-added">+   estimate_buffer_size(buf_sizes._const);</span>
<span class="udiff-line-added">+   if (failing()) return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Pre-compute the length of blocks and replace</span>
<span class="udiff-line-added">+   // long branches with short if machine supports it.</span>
<span class="udiff-line-added">+   // Must be done before ScheduleAndBundle due to SPARC delay slots</span>
    uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);
    blk_starts[0] = 0;
<span class="udiff-line-added">+   shorten_branches(blk_starts, buf_sizes);</span>
  
<span class="udiff-line-modified-removed">-   // Initialize code buffer and process short branches.</span>
<span class="udiff-line-modified-removed">-   CodeBuffer* cb = init_buffer(blk_starts);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (cb == NULL || failing()) {</span>
<span class="udiff-line-modified-added">+   ScheduleAndBundle();</span>
<span class="udiff-line-modified-added">+   if (failing()) {</span>
      return;
    }
  
<span class="udiff-line-modified-removed">-   ScheduleAndBundle();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">-   if (trace_opto_output()) {</span>
<span class="udiff-line-removed">-     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);</span>
<span class="udiff-line-removed">-     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="udiff-line-removed">-       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);</span>
<span class="udiff-line-removed">-       Block* block = _cfg-&gt;get_block(i);</span>
<span class="udiff-line-removed">-       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="udiff-line-removed">-         Node* n = block-&gt;get_node(j);</span>
<span class="udiff-line-removed">-         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
<span class="udiff-line-removed">-         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);</span>
<span class="udiff-line-removed">-         n-&gt;dump();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   // Late barrier analysis must be done after schedule and bundle</span>
<span class="udiff-line-modified-added">+   // Otherwise liveness based spilling will fail</span>
<span class="udiff-line-modified-added">+   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-modified-added">+   bs-&gt;late_barrier_analysis();</span>
  
<span class="udiff-line-modified-removed">-   if (failing()) {</span>
<span class="udiff-line-modified-added">+   // Complete sizing of codebuffer</span>
<span class="udiff-line-added">+   CodeBuffer* cb = init_buffer(buf_sizes);</span>
<span class="udiff-line-added">+   if (cb == NULL || failing()) {</span>
      return;
    }
  
    BuildOopMaps();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,11 +222,11 @@</span>
    } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
  }
  
  // The architecture description provides short branch variants for some long
  // branch instructions. Replace eligible long branches with short branches.
<span class="udiff-line-modified-removed">- void Compile::shorten_branches(uint* blk_starts, int&amp; code_size, int&amp; reloc_size, int&amp; stub_size) {</span>
<span class="udiff-line-modified-added">+ void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
    // Compute size of each block, method size, and relocation information size
    uint nblocks  = _cfg-&gt;number_of_blocks();
  
    uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
    uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,15 +240,15 @@</span>
    DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
  
    bool has_short_branch_candidate = false;
  
    // Initialize the sizes to 0
<span class="udiff-line-modified-removed">-   code_size  = 0;          // Size in bytes of generated code</span>
<span class="udiff-line-modified-removed">-   stub_size  = 0;          // Size in bytes of all stub entries</span>
<span class="udiff-line-modified-added">+   int code_size  = 0;          // Size in bytes of generated code</span>
<span class="udiff-line-modified-added">+   int stub_size  = 0;          // Size in bytes of all stub entries</span>
    // Size in bytes of all relocation entries, including those in local stubs.
    // Start with 2-bytes of reloc info for the unvalidated entry point
<span class="udiff-line-modified-removed">-   reloc_size = 1;          // Number of relocation entries</span>
<span class="udiff-line-modified-added">+   int reloc_size = 1;          // Number of relocation entries</span>
  
    // Make three passes.  The first computes pessimistic blk_starts,
    // relative jmp_offset and reloc_size information.  The second performs
    // short branch substitution using the pessimistic sizing.  The
    // third inserts nops where needed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -477,10 +478,14 @@</span>
    // Adjust reloc_size to number of record of relocation info
    // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
    // a relocation index.
    // The CodeBuffer will expand the locs array if this estimate is too low.
    reloc_size *= 10 / sizeof(relocInfo);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   buf_sizes._reloc = reloc_size;</span>
<span class="udiff-line-added">+   buf_sizes._code  = code_size;</span>
<span class="udiff-line-added">+   buf_sizes._stub  = stub_size;</span>
  }
  
  //------------------------------FillLocArray-----------------------------------
  // Create a bit of debug info and append it to the array.  The mapping is from
  // Java local or expression stack to constant, register or stack-slot.  For
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -488,12 +493,12 @@</span>
  // entry has been taken care of and caller should skip it).
  static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
    // This should never have accepted Bad before
    assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
    return (OptoReg::is_reg(regnum))
<span class="udiff-line-modified-removed">-     ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )</span>
<span class="udiff-line-modified-removed">-     : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));</span>
<span class="udiff-line-modified-added">+          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )</span>
<span class="udiff-line-modified-added">+          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));</span>
  }
  
  
  ObjectValue*
  Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -608,68 +613,68 @@</span>
        array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
        array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
      }
  #endif //_LP64
      else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
<span class="udiff-line-modified-removed">-                OptoReg::is_reg(regnum) ) {</span>
<span class="udiff-line-modified-added">+              OptoReg::is_reg(regnum) ) {</span>
        array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()
<span class="udiff-line-modified-removed">-                                    ? Location::float_in_dbl : Location::normal ));</span>
<span class="udiff-line-modified-added">+                                                       ? Location::float_in_dbl : Location::normal ));</span>
      } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
        array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long
<span class="udiff-line-modified-removed">-                                    ? Location::int_in_long : Location::normal ));</span>
<span class="udiff-line-modified-added">+                                                       ? Location::int_in_long : Location::normal ));</span>
      } else if( t-&gt;base() == Type::NarrowOop ) {
        array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));
      } else {
        array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));
      }
      return;
    }
  
    // No register.  It must be constant data.
    switch (t-&gt;base()) {
<span class="udiff-line-modified-removed">-   case Type::Half:              // Second half of a double</span>
<span class="udiff-line-modified-removed">-     ShouldNotReachHere();       // Caller should skip 2nd halves</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   case Type::AnyPtr:</span>
<span class="udiff-line-removed">-     array-&gt;append(new ConstantOopWriteValue(NULL));</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   case Type::AryPtr:</span>
<span class="udiff-line-removed">-   case Type::InstPtr:          // fall through</span>
<span class="udiff-line-removed">-     array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   case Type::NarrowOop:</span>
<span class="udiff-line-removed">-     if (t == TypeNarrowOop::NULL_PTR) {</span>
<span class="udiff-line-modified-added">+     case Type::Half:              // Second half of a double</span>
<span class="udiff-line-modified-added">+       ShouldNotReachHere();       // Caller should skip 2nd halves</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case Type::AnyPtr:</span>
        array-&gt;append(new ConstantOopWriteValue(NULL));
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-modified-removed">-       array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   case Type::Int:</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   case Type::RawPtr:</span>
<span class="udiff-line-modified-removed">-     // A return address (T_ADDRESS).</span>
<span class="udiff-line-modified-removed">-     assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case Type::AryPtr:</span>
<span class="udiff-line-modified-added">+     case Type::InstPtr:          // fall through</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case Type::NarrowOop:</span>
<span class="udiff-line-modified-added">+       if (t == TypeNarrowOop::NULL_PTR) {</span>
<span class="udiff-line-modified-added">+         array-&gt;append(new ConstantOopWriteValue(NULL));</span>
<span class="udiff-line-modified-added">+       } else {</span>
<span class="udiff-line-modified-added">+         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case Type::Int:</span>
<span class="udiff-line-added">+       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case Type::RawPtr:</span>
<span class="udiff-line-added">+       // A return address (T_ADDRESS).</span>
<span class="udiff-line-added">+       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     // Must be restored to the full-width 64-bit stack slot.</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));</span>
<span class="udiff-line-modified-added">+       // Must be restored to the full-width 64-bit stack slot.</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));</span>
  #else
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));</span>
  #endif
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   case Type::FloatCon: {</span>
<span class="udiff-line-modified-removed">-     float f = t-&gt;is_float_constant()-&gt;getf();</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantIntValue(jint_cast(f)));</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   case Type::DoubleCon: {</span>
<span class="udiff-line-modified-removed">-     jdouble d = t-&gt;is_double_constant()-&gt;getd();</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     case Type::FloatCon: {</span>
<span class="udiff-line-modified-added">+       float f = t-&gt;is_float_constant()-&gt;getf();</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantIntValue(jint_cast(f)));</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     case Type::DoubleCon: {</span>
<span class="udiff-line-modified-added">+       jdouble d = t-&gt;is_double_constant()-&gt;getd();</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantDoubleValue(d));</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantDoubleValue(d));</span>
  #else
<span class="udiff-line-modified-removed">-     // Repack the double as two jints.</span>
<span class="udiff-line-modified-added">+       // Repack the double as two jints.</span>
      // The convention the interpreter uses is that the second local
      // holds the first raw word of the native double representation.
      // This is actually reasonable, since locals and stack arrays
      // grow downwards in all implementations.
      // (If, on some machine, the interpreter&#39;s Java locals or stack
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -677,19 +682,19 @@</span>
      jlong_accessor acc;
      acc.long_value = jlong_cast(d);
      array-&gt;append(new ConstantIntValue(acc.words[1]));
      array-&gt;append(new ConstantIntValue(acc.words[0]));
  #endif
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   case Type::Long: {</span>
<span class="udiff-line-modified-removed">-     jlong d = t-&gt;is_long()-&gt;get_con();</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     case Type::Long: {</span>
<span class="udiff-line-modified-added">+       jlong d = t-&gt;is_long()-&gt;get_con();</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new ConstantLongValue(d));</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new ConstantLongValue(d));</span>
  #else
<span class="udiff-line-modified-removed">-     // Repack the long as two jints.</span>
<span class="udiff-line-modified-added">+       // Repack the long as two jints.</span>
      // The convention the interpreter uses is that the second local
      // holds the first raw word of the native double representation.
      // This is actually reasonable, since locals and stack arrays
      // grow downwards in all implementations.
      // (If, on some machine, the interpreter&#39;s Java locals or stack
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -697,18 +702,18 @@</span>
      jlong_accessor acc;
      acc.long_value = d;
      array-&gt;append(new ConstantIntValue(acc.words[1]));
      array-&gt;append(new ConstantIntValue(acc.words[0]));
  #endif
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   case Type::Top:               // Add an illegal value here</span>
<span class="udiff-line-modified-removed">-     array-&gt;append(new LocationValue(Location()));</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-removed">-   default:</span>
<span class="udiff-line-modified-removed">-     ShouldNotReachHere();</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     case Type::Top:               // Add an illegal value here</span>
<span class="udiff-line-modified-added">+       array-&gt;append(new LocationValue(Location()));</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     default:</span>
<span class="udiff-line-modified-added">+       ShouldNotReachHere();</span>
<span class="udiff-line-modified-added">+       break;</span>
    }
  }
  
  // Determine if this node starts a bundle
  bool Compile::starts_bundle(const Node *n) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -869,62 +874,62 @@</span>
  
  
  
  // A simplified version of Process_OopMap_Node, to handle non-safepoints.
  class NonSafepointEmitter {
<span class="udiff-line-modified-removed">-   Compile*  C;</span>
<span class="udiff-line-modified-removed">-   JVMState* _pending_jvms;</span>
<span class="udiff-line-modified-removed">-   int       _pending_offset;</span>
<span class="udiff-line-modified-added">+     Compile*  C;</span>
<span class="udiff-line-modified-added">+     JVMState* _pending_jvms;</span>
<span class="udiff-line-modified-added">+     int       _pending_offset;</span>
  
<span class="udiff-line-modified-removed">-   void emit_non_safepoint();</span>
<span class="udiff-line-modified-added">+     void emit_non_safepoint();</span>
  
   public:
<span class="udiff-line-modified-removed">-   NonSafepointEmitter(Compile* compile) {</span>
<span class="udiff-line-modified-removed">-     this-&gt;C = compile;</span>
<span class="udiff-line-modified-removed">-     _pending_jvms = NULL;</span>
<span class="udiff-line-modified-removed">-     _pending_offset = 0;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+     NonSafepointEmitter(Compile* compile) {</span>
<span class="udiff-line-modified-added">+       this-&gt;C = compile;</span>
<span class="udiff-line-modified-added">+       _pending_jvms = NULL;</span>
<span class="udiff-line-modified-added">+       _pending_offset = 0;</span>
<span class="udiff-line-modified-added">+     }</span>
  
<span class="udiff-line-modified-removed">-   void observe_instruction(Node* n, int pc_offset) {</span>
<span class="udiff-line-modified-removed">-     if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;</span>
<span class="udiff-line-modified-added">+     void observe_instruction(Node* n, int pc_offset) {</span>
<span class="udiff-line-modified-added">+       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;</span>
  
<span class="udiff-line-modified-removed">-     Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);</span>
<span class="udiff-line-modified-removed">-     if (nn == NULL || nn-&gt;jvms() == NULL)  return;</span>
<span class="udiff-line-removed">-     if (_pending_jvms != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-         _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {</span>
<span class="udiff-line-removed">-       // Repeated JVMS?  Stretch it up here.</span>
<span class="udiff-line-removed">-       _pending_offset = pc_offset;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-modified-added">+       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);</span>
<span class="udiff-line-modified-added">+       if (nn == NULL || nn-&gt;jvms() == NULL)  return;</span>
        if (_pending_jvms != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-           _pending_offset &lt; pc_offset) {</span>
<span class="udiff-line-modified-removed">-         emit_non_safepoint();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       _pending_jvms = NULL;</span>
<span class="udiff-line-removed">-       if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {</span>
<span class="udiff-line-removed">-         // This is the only way _pending_jvms can become non-NULL:</span>
<span class="udiff-line-removed">-         _pending_jvms = nn-&gt;jvms();</span>
<span class="udiff-line-modified-added">+           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {</span>
<span class="udiff-line-modified-added">+         // Repeated JVMS?  Stretch it up here.</span>
          _pending_offset = pc_offset;
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         if (_pending_jvms != NULL &amp;&amp;</span>
<span class="udiff-line-added">+             _pending_offset &lt; pc_offset) {</span>
<span class="udiff-line-added">+           emit_non_safepoint();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         _pending_jvms = NULL;</span>
<span class="udiff-line-added">+         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {</span>
<span class="udiff-line-added">+           // This is the only way _pending_jvms can become non-NULL:</span>
<span class="udiff-line-added">+           _pending_jvms = nn-&gt;jvms();</span>
<span class="udiff-line-added">+           _pending_offset = pc_offset;</span>
<span class="udiff-line-added">+         }</span>
        }
      }
<span class="udiff-line-removed">-   }</span>
  
<span class="udiff-line-modified-removed">-   // Stay out of the way of real safepoints:</span>
<span class="udiff-line-modified-removed">-   void observe_safepoint(JVMState* jvms, int pc_offset) {</span>
<span class="udiff-line-modified-removed">-     if (_pending_jvms != NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         _pending_offset &lt; pc_offset) {</span>
<span class="udiff-line-modified-removed">-       emit_non_safepoint();</span>
<span class="udiff-line-modified-added">+     // Stay out of the way of real safepoints:</span>
<span class="udiff-line-modified-added">+     void observe_safepoint(JVMState* jvms, int pc_offset) {</span>
<span class="udiff-line-modified-added">+       if (_pending_jvms != NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           _pending_offset &lt; pc_offset) {</span>
<span class="udiff-line-modified-added">+         emit_non_safepoint();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _pending_jvms = NULL;</span>
      }
<span class="udiff-line-removed">-     _pending_jvms = NULL;</span>
<span class="udiff-line-removed">-   }</span>
  
<span class="udiff-line-modified-removed">-   void flush_at_end() {</span>
<span class="udiff-line-modified-removed">-     if (_pending_jvms != NULL) {</span>
<span class="udiff-line-modified-removed">-       emit_non_safepoint();</span>
<span class="udiff-line-modified-added">+     void flush_at_end() {</span>
<span class="udiff-line-modified-added">+       if (_pending_jvms != NULL) {</span>
<span class="udiff-line-modified-added">+         emit_non_safepoint();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _pending_jvms = NULL;</span>
      }
<span class="udiff-line-removed">-     _pending_jvms = NULL;</span>
<span class="udiff-line-removed">-   }</span>
  };
  
  void NonSafepointEmitter::emit_non_safepoint() {
    JVMState* youngest_jvms = _pending_jvms;
    int       pc_offset     = _pending_offset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -950,19 +955,15 @@</span>
    // Mark the end of the scope set.
    debug_info-&gt;end_non_safepoint(pc_offset);
  }
  
  //------------------------------init_buffer------------------------------------
<span class="udiff-line-modified-removed">- CodeBuffer* Compile::init_buffer(uint* blk_starts) {</span>
<span class="udiff-line-modified-added">+ void Compile::estimate_buffer_size(int&amp; const_req) {</span>
  
    // Set the initially allocated size
<span class="udiff-line-modified-removed">-   int  code_req   = initial_code_capacity;</span>
<span class="udiff-line-removed">-   int  locs_req   = initial_locs_capacity;</span>
<span class="udiff-line-removed">-   int  stub_req   = initial_stub_capacity;</span>
<span class="udiff-line-removed">-   int  const_req  = initial_const_capacity;</span>
<span class="udiff-line-modified-added">+   const_req = initial_const_capacity;</span>
  
<span class="udiff-line-removed">-   int  pad_req    = NativeCall::instruction_size;</span>
    // The extra spacing after the code is necessary on some platforms.
    // Sometimes we need to patch in a jump after the last instruction,
    // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
  
    // Compute the byte offset where we can store the deopt pc.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -970,11 +971,11 @@</span>
      _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
    }
  
    // Compute prolog code size
    _method_size = 0;
<span class="udiff-line-modified-removed">-   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP)+_regalloc-&gt;_framesize;</span>
<span class="udiff-line-modified-added">+   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
  #if defined(IA64) &amp;&amp; !defined(AIX)
    if (save_argument_registers()) {
      // 4815101: this is a stub with implicit and unknown precision fp args.
      // The usual spill mechanism can only generate stfd&#39;s in this case, which
      // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1019,15 +1020,22 @@</span>
    }
  
    // Initialize the space for the BufferBlob used to find and verify
    // instruction size in MachNode::emit_size()
    init_scratch_buffer_blob(const_req);
<span class="udiff-line-modified-removed">-   if (failing())  return NULL; // Out of memory</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   // Pre-compute the length of blocks and replace</span>
<span class="udiff-line-modified-removed">-   // long branches with short if machine supports it.</span>
<span class="udiff-line-modified-removed">-   shorten_branches(blk_starts, code_req, locs_req, stub_req);</span>
<span class="udiff-line-modified-added">+ CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   int stub_req  = buf_sizes._stub;</span>
<span class="udiff-line-added">+   int code_req  = buf_sizes._code;</span>
<span class="udiff-line-added">+   int const_req = buf_sizes._const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int pad_req   = NativeCall::instruction_size;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-added">+   stub_req += bs-&gt;estimate_stub_size();</span>
  
    // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
    // class HandlerImpl is platform-specific and defined in the *.ad files.
    int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
    int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1036,22 +1044,22 @@</span>
  
    if (StressCodeBuffers)
      code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
  
    int total_req =
<span class="udiff-line-modified-removed">-     const_req +</span>
<span class="udiff-line-modified-removed">-     code_req +</span>
<span class="udiff-line-modified-removed">-     pad_req +</span>
<span class="udiff-line-modified-removed">-     stub_req +</span>
<span class="udiff-line-modified-removed">-     exception_handler_req +</span>
<span class="udiff-line-modified-removed">-     deopt_handler_req;               // deopt handler</span>
<span class="udiff-line-modified-added">+           const_req +</span>
<span class="udiff-line-modified-added">+           code_req +</span>
<span class="udiff-line-modified-added">+           pad_req +</span>
<span class="udiff-line-modified-added">+           stub_req +</span>
<span class="udiff-line-modified-added">+           exception_handler_req +</span>
<span class="udiff-line-modified-added">+           deopt_handler_req;               // deopt handler</span>
  
    if (has_method_handle_invokes())
      total_req += deopt_handler_req;  // deopt MH handler
  
    CodeBuffer* cb = code_buffer();
<span class="udiff-line-modified-removed">-   cb-&gt;initialize(total_req, locs_req);</span>
<span class="udiff-line-modified-added">+   cb-&gt;initialize(total_req, buf_sizes._reloc);</span>
  
    // Have we run out of code space?
    if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
      C-&gt;record_failure(&quot;CodeCache is full&quot;);
      return NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1104,16 +1112,21 @@</span>
    uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
    uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
  #endif
  
    // Create an array of unused labels, one for each basic block, if printing is enabled
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
    int *node_offsets      = NULL;
    uint node_offset_limit = unique();
  
<span class="udiff-line-modified-removed">-   if (print_assembly())</span>
<span class="udiff-line-modified-removed">-     node_offsets         = NEW_RESOURCE_ARRAY(int, node_offset_limit);</span>
<span class="udiff-line-modified-added">+   if (print_assembly()) {</span>
<span class="udiff-line-modified-added">+     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (node_offsets != NULL) {</span>
<span class="udiff-line-added">+     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.</span>
<span class="udiff-line-added">+     memset(node_offsets, 0, node_offset_limit*sizeof(int));</span>
<span class="udiff-line-added">+   }</span>
  #endif
  
    NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily
  
    // Emit the constant table.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1261,28 +1274,28 @@</span>
            non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
                                             current_offset);
            Process_OopMap_Node(mach, current_offset);
          } // End if safepoint
  
<span class="udiff-line-modified-removed">-         // If this is a null check, then add the start of the previous instruction to the list</span>
<span class="udiff-line-modified-added">+           // If this is a null check, then add the start of the previous instruction to the list</span>
          else if( mach-&gt;is_MachNullCheck() ) {
            inct_starts[inct_cnt++] = previous_offset;
          }
  
<span class="udiff-line-modified-removed">-         // If this is a branch, then fill in the label with the target BB&#39;s label</span>
<span class="udiff-line-modified-added">+           // If this is a branch, then fill in the label with the target BB&#39;s label</span>
          else if (mach-&gt;is_MachBranch()) {
            // This requires the TRUE branch target be in succs[0]
            uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
  
            // Try to replace long branch if delay slot is not used,
            // it is mostly for back branches since forward branch&#39;s
            // distance is not updated yet.
            bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
                                      node_bundling(n)-&gt;use_unconditional_delay();
            if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
<span class="udiff-line-modified-removed">-            assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);</span>
<span class="udiff-line-modified-removed">-            int br_size = n-&gt;size(_regalloc);</span>
<span class="udiff-line-modified-added">+             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);</span>
<span class="udiff-line-modified-added">+             int br_size = n-&gt;size(_regalloc);</span>
              int offset = blk_starts[block_num] - current_offset;
              if (block_num &gt;= i) {
                // Current and following block&#39;s offset are not
                // finalized yet, adjust distance by the difference
                // between calculated and final offsets of current block.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1336,11 +1349,11 @@</span>
                }
              }
            }
          }
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-         // Check that oop-store precedes the card-mark</span>
<span class="udiff-line-modified-added">+           // Check that oop-store precedes the card-mark</span>
          else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
            uint storeCM_idx = j;
            int count = 0;
            for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
              Node *oop_store = mach-&gt;in(prec);  // Precedence edge
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1379,13 +1392,14 @@</span>
          C-&gt;record_failure(&quot;CodeCache is full&quot;);
          return;
        }
  
        // Save the offset for the listing
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">-       if (node_offsets &amp;&amp; n-&gt;_idx &lt; node_offset_limit)</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-modified-added">+       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {</span>
          node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
<span class="udiff-line-added">+       }</span>
  #endif
  
        // &quot;Normal&quot; instruction case
        DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
        n-&gt;emit(*cb, _regalloc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1428,13 +1442,14 @@</span>
  
          // Back up 1 instruction
          cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
  
          // Save the offset for the listing
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">-         if (node_offsets &amp;&amp; delay_slot-&gt;_idx &lt; node_offset_limit)</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-modified-added">+         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {</span>
            node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
<span class="udiff-line-added">+         }</span>
  #endif
  
          // Support a SafePoint in the delay slot
          if (delay_slot-&gt;is_MachSafePoint()) {
            MachNode *mach = delay_slot-&gt;as_Mach();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1505,10 +1520,14 @@</span>
        }
      }
    }
  #endif
  
<span class="udiff-line-added">+   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-added">+   bs-&gt;emit_stubs(*cb);</span>
<span class="udiff-line-added">+   if (failing())  return;</span>
<span class="udiff-line-added">+ </span>
  #ifndef PRODUCT
    // Information on the size of the method, without the extraneous code
    Scheduling::increment_method_size(cb-&gt;insts_size());
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1539,11 +1558,18 @@</span>
    if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
      C-&gt;record_failure(&quot;CodeCache is full&quot;);
      return;
    }
  
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-added">+   if (print_assembly()) {</span>
<span class="udiff-line-added">+     tty-&gt;cr();</span>
<span class="udiff-line-added">+     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
    // Dump the assembly code, including basic-block numbers
    if (print_assembly()) {
      ttyLocker ttyl;  // keep the following output all in one block
      if (!VMThread::should_terminate()) {  // test this under the tty lock
        // This output goes directly to the tty, not the compiler log.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1553,26 +1579,29 @@</span>
          xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),
                     is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
                     &quot;&quot;);
        }
        if (method() != NULL) {
<span class="udiff-line-added">+         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
          method()-&gt;print_metadata();
        } else if (stub_name() != NULL) {
<span class="udiff-line-modified-removed">-         tty-&gt;print_cr(&quot;Generating RuntimeStub - %s&quot;, stub_name());</span>
<span class="udiff-line-modified-added">+         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
        }
<span class="udiff-line-added">+       tty-&gt;cr();</span>
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
        dump_asm(node_offsets, node_offset_limit);
<span class="udiff-line-added">+       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
        if (xtty != NULL) {
          // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
          // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
          // thread safe
          ttyLocker ttyl2;
          xtty-&gt;tail(&quot;opto_assembly&quot;);
        }
      }
    }
  #endif
<span class="udiff-line-removed">- </span>
  }
  
  void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
    _inc_table.set_size(cnt);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1669,24 +1698,24 @@</span>
  #endif
  
  // Initializer for class Scheduling
  
  Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
<span class="udiff-line-modified-removed">-   : _arena(arena),</span>
<span class="udiff-line-modified-removed">-     _cfg(compile.cfg()),</span>
<span class="udiff-line-modified-removed">-     _regalloc(compile.regalloc()),</span>
<span class="udiff-line-modified-removed">-     _scheduled(arena),</span>
<span class="udiff-line-modified-removed">-     _available(arena),</span>
<span class="udiff-line-modified-removed">-     _reg_node(arena),</span>
<span class="udiff-line-modified-removed">-     _pinch_free_list(arena),</span>
<span class="udiff-line-modified-removed">-     _next_node(NULL),</span>
<span class="udiff-line-modified-removed">-     _bundle_instr_count(0),</span>
<span class="udiff-line-modified-removed">-     _bundle_cycle_number(0),</span>
<span class="udiff-line-modified-removed">-     _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])</span>
<span class="udiff-line-modified-added">+         : _arena(arena),</span>
<span class="udiff-line-modified-added">+           _cfg(compile.cfg()),</span>
<span class="udiff-line-modified-added">+           _regalloc(compile.regalloc()),</span>
<span class="udiff-line-modified-added">+           _scheduled(arena),</span>
<span class="udiff-line-modified-added">+           _available(arena),</span>
<span class="udiff-line-modified-added">+           _reg_node(arena),</span>
<span class="udiff-line-modified-added">+           _pinch_free_list(arena),</span>
<span class="udiff-line-modified-added">+           _next_node(NULL),</span>
<span class="udiff-line-modified-added">+           _bundle_instr_count(0),</span>
<span class="udiff-line-modified-added">+           _bundle_cycle_number(0),</span>
<span class="udiff-line-modified-added">+           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])</span>
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-   , _branches(0)</span>
<span class="udiff-line-modified-removed">-   , _unconditional_delays(0)</span>
<span class="udiff-line-modified-added">+         , _branches(0)</span>
<span class="udiff-line-modified-added">+         , _unconditional_delays(0)</span>
  #endif
  {
    // Create a MachNopNode
    _nop = new MachNopNode();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1763,12 +1792,12 @@</span>
    // Clear the bundling information
    _bundle_instr_count = 0;
    _bundle_use.reset();
  
    memcpy(_bundle_use_elements,
<span class="udiff-line-modified-removed">-     Pipeline_Use::elaborated_elements,</span>
<span class="udiff-line-modified-removed">-     sizeof(Pipeline_Use::elaborated_elements));</span>
<span class="udiff-line-modified-added">+          Pipeline_Use::elaborated_elements,</span>
<span class="udiff-line-modified-added">+          sizeof(Pipeline_Use::elaborated_elements));</span>
  }
  
  // Perform instruction scheduling and bundling over the sequence of
  // instructions in backwards order.
  void Compile::ScheduleAndBundle() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1791,10 +1820,26 @@</span>
    Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);
  
    // Walk backwards over each basic block, computing the needed alignment
    // Walk over all the basic blocks
    scheduling.DoScheduling();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+   if (trace_opto_output()) {</span>
<span class="udiff-line-added">+     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="udiff-line-added">+       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);</span>
<span class="udiff-line-added">+       Block* block = _cfg-&gt;get_block(i);</span>
<span class="udiff-line-added">+       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="udiff-line-added">+         Node* n = block-&gt;get_node(j);</span>
<span class="udiff-line-added">+         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
<span class="udiff-line-added">+         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);</span>
<span class="udiff-line-added">+         n-&gt;dump();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  // Compute the latency of all the instructions.  This is fairly simple,
  // because we already have a legal ordering.  Walk over the instructions
  // from first to last, and compute the latency of the instruction based
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1859,11 +1904,11 @@</span>
    // If the node cannot be scheduled this cycle, skip it
    if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
  #ifndef PRODUCT
      if (_cfg-&gt;C-&gt;trace_opto_output())
        tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
<span class="udiff-line-modified-removed">-         n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);</span>
<span class="udiff-line-modified-added">+                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);</span>
  #endif
      return (false);
    }
  
    const Pipeline *node_pipeline = n-&gt;pipeline();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1876,11 +1921,11 @@</span>
  
    if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
  #ifndef PRODUCT
      if (_cfg-&gt;C-&gt;trace_opto_output())
        tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
<span class="udiff-line-modified-removed">-         n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);</span>
<span class="udiff-line-modified-added">+                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);</span>
  #endif
      return (false);
    }
  
    // Don&#39;t allow non-machine nodes to be handled this way
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2084,16 +2129,16 @@</span>
          const Pipeline *avail_pipeline = d-&gt;pipeline();
  
          // Don&#39;t allow safepoints in the branch shadow, that will
          // cause a number of difficulties
          if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
<span class="udiff-line-modified-removed">-             !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             Pipeline::instr_has_unit_size() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             NodeFitsInBundle(d) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             !node_bundling(d)-&gt;used_in_delay()) {</span>
<span class="udiff-line-modified-added">+              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;</span>
<span class="udiff-line-modified-added">+              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;</span>
<span class="udiff-line-modified-added">+              Pipeline::instr_has_unit_size() &amp;&amp;</span>
<span class="udiff-line-modified-added">+              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;</span>
<span class="udiff-line-modified-added">+              NodeFitsInBundle(d) &amp;&amp;</span>
<span class="udiff-line-modified-added">+              !node_bundling(d)-&gt;used_in_delay()) {</span>
  
            if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
              // A node that fits in the delay slot was found, so we need to
              // set the appropriate bits in the bundle pipeline information so
              // that it correctly indicates resource usage.  Later, when we
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2134,17 +2179,17 @@</span>
  
      // See if the instruction in the delay slot requires a
      // step of the bundles
      if (!NodeFitsInBundle(n)) {
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-         if (_cfg-&gt;C-&gt;trace_opto_output())</span>
<span class="udiff-line-modified-removed">-           tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);</span>
<span class="udiff-line-modified-added">+       if (_cfg-&gt;C-&gt;trace_opto_output())</span>
<span class="udiff-line-modified-added">+         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);</span>
  #endif
<span class="udiff-line-modified-removed">-         // Update the state information</span>
<span class="udiff-line-modified-removed">-         _bundle_instr_count = 0;</span>
<span class="udiff-line-modified-removed">-         _bundle_cycle_number += 1;</span>
<span class="udiff-line-modified-removed">-         _bundle_use.step(1);</span>
<span class="udiff-line-modified-added">+       // Update the state information</span>
<span class="udiff-line-modified-added">+       _bundle_instr_count = 0;</span>
<span class="udiff-line-modified-added">+       _bundle_cycle_number += 1;</span>
<span class="udiff-line-modified-added">+       _bundle_use.step(1);</span>
      }
    }
  
    // Get the number of instructions
    uint instruction_count = node_pipeline-&gt;instructionCount();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2186,12 +2231,12 @@</span>
  
        else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
  #ifndef PRODUCT
          if (_cfg-&gt;C-&gt;trace_opto_output())
            tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
<span class="udiff-line-modified-removed">-             instruction_count + _bundle_instr_count,</span>
<span class="udiff-line-modified-removed">-             Pipeline::_max_instrs_per_cycle);</span>
<span class="udiff-line-modified-added">+                      instruction_count + _bundle_instr_count,</span>
<span class="udiff-line-modified-added">+                      Pipeline::_max_instrs_per_cycle);</span>
  #endif
          step(1);
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2393,16 +2438,13 @@</span>
             last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
        last = bb-&gt;get_node(--_bb_end);
      }
      assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
      if( last-&gt;is_Catch() ||
<span class="udiff-line-modified-removed">-        // Exclude unreachable path case when Halt node is in a separate block.</span>
<span class="udiff-line-modified-removed">-        (_bb_end &gt; 1 &amp;&amp; last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {</span>
<span class="udiff-line-modified-removed">-       // There must be a prior call.  Skip it.</span>
<span class="udiff-line-removed">-       while( !bb-&gt;get_node(--_bb_end)-&gt;is_MachCall() ) {</span>
<span class="udiff-line-removed">-         assert( bb-&gt;get_node(_bb_end)-&gt;is_MachProj(), &quot;skipping projections after expected call&quot; );</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {</span>
<span class="udiff-line-modified-added">+       // There might be a prior call.  Skip it.</span>
<span class="udiff-line-modified-added">+       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());</span>
      } else if( last-&gt;is_MachNullCheck() ) {
        // Backup so the last null-checked memory instruction is
        // outside the schedulable range. Skip over the nullcheck,
        // projection, and the memory nodes.
        Node *mem = last-&gt;in(1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2466,11 +2508,11 @@</span>
          }
        }
      }
  #endif
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   verify_good_schedule(bb,&quot;after block local scheduling&quot;);</span>
<span class="udiff-line-modified-added">+     verify_good_schedule(bb,&quot;after block local scheduling&quot;);</span>
  #endif
    }
  
  #ifndef PRODUCT
    if (_cfg-&gt;C-&gt;trace_opto_output())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2814,35 +2856,35 @@</span>
  // wired into the graph because the register is never
  // used or def&#39;ed in the block.
  //
  void Scheduling::garbage_collect_pinch_nodes() {
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-     if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-     int trace_cnt = 0;</span>
<span class="udiff-line-modified-removed">-     for (uint k = 0; k &lt; _reg_node.Size(); k++) {</span>
<span class="udiff-line-modified-removed">-       Node* pinch = _reg_node[k];</span>
<span class="udiff-line-modified-removed">-       if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           // no predecence input edges</span>
<span class="udiff-line-modified-removed">-           (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {</span>
<span class="udiff-line-modified-removed">-         cleanup_pinch(pinch);</span>
<span class="udiff-line-modified-removed">-         _pinch_free_list.push(pinch);</span>
<span class="udiff-line-modified-removed">-         _reg_node.map(k, NULL);</span>
<span class="udiff-line-modified-added">+   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);</span>
<span class="udiff-line-modified-added">+ #endif</span>
<span class="udiff-line-modified-added">+   int trace_cnt = 0;</span>
<span class="udiff-line-modified-added">+   for (uint k = 0; k &lt; _reg_node.Size(); k++) {</span>
<span class="udiff-line-modified-added">+     Node* pinch = _reg_node[k];</span>
<span class="udiff-line-modified-added">+     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;</span>
<span class="udiff-line-modified-added">+         // no predecence input edges</span>
<span class="udiff-line-modified-added">+         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {</span>
<span class="udiff-line-modified-added">+       cleanup_pinch(pinch);</span>
<span class="udiff-line-modified-added">+       _pinch_free_list.push(pinch);</span>
<span class="udiff-line-modified-added">+       _reg_node.map(k, NULL);</span>
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-         if (_cfg-&gt;C-&gt;trace_opto_output()) {</span>
<span class="udiff-line-modified-removed">-           trace_cnt++;</span>
<span class="udiff-line-modified-removed">-           if (trace_cnt &gt; 40) {</span>
<span class="udiff-line-modified-removed">-             tty-&gt;print(&quot;\n&quot;);</span>
<span class="udiff-line-modified-removed">-             trace_cnt = 0;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);</span>
<span class="udiff-line-modified-added">+       if (_cfg-&gt;C-&gt;trace_opto_output()) {</span>
<span class="udiff-line-modified-added">+         trace_cnt++;</span>
<span class="udiff-line-modified-added">+         if (trace_cnt &gt; 40) {</span>
<span class="udiff-line-modified-added">+           tty-&gt;print(&quot;\n&quot;);</span>
<span class="udiff-line-modified-added">+           trace_cnt = 0;</span>
          }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);</span>
        }
<span class="udiff-line-added">+ #endif</span>
      }
<span class="udiff-line-added">+   }</span>
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-     if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);</span>
<span class="udiff-line-modified-added">+   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);</span>
  #endif
  }
  
  // Clean up a pinch node for reuse.
  void Scheduling::cleanup_pinch( Node *pinch ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2875,23 +2917,23 @@</span>
  
  // Print Scheduling Statistics
  void Scheduling::print_statistics() {
    // Print the size added by nops for bundling
    tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
<span class="udiff-line-modified-removed">-     _total_nop_size, _total_method_size);</span>
<span class="udiff-line-modified-added">+              _total_nop_size, _total_method_size);</span>
    if (_total_method_size &gt; 0)
      tty-&gt;print(&quot;, for %.2f%%&quot;,
<span class="udiff-line-modified-removed">-       ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);</span>
<span class="udiff-line-modified-added">+                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);</span>
    tty-&gt;print(&quot;\n&quot;);
  
    // Print the number of branch shadows filled
    if (Pipeline::_branch_has_delay_slot) {
      tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
<span class="udiff-line-modified-removed">-       _total_branches, _total_unconditional_delays);</span>
<span class="udiff-line-modified-added">+                _total_branches, _total_unconditional_delays);</span>
      if (_total_branches &gt; 0)
        tty-&gt;print(&quot;, for %.2f%%&quot;,
<span class="udiff-line-modified-removed">-         ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);</span>
<span class="udiff-line-modified-added">+                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);</span>
      tty-&gt;print(&quot;\n&quot;);
    }
  
    uint total_instructions = 0, total_bundles = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2901,8 +2943,8 @@</span>
      total_bundles      += bundle_count;
    }
  
    if (total_bundles &gt; 0)
      tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
<span class="udiff-line-modified-removed">-       ((double)total_instructions) / ((double)total_bundles));</span>
<span class="udiff-line-modified-added">+                ((double)total_instructions) / ((double)total_bundles));</span>
  }
  #endif
</pre>
<center><a href="opaquenode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
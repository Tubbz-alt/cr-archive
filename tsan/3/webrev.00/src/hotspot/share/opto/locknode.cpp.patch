diff a/src/hotspot/share/opto/locknode.cpp b/src/hotspot/share/opto/locknode.cpp
--- a/src/hotspot/share/opto/locknode.cpp
+++ b/src/hotspot/share/opto/locknode.cpp
@@ -53,11 +53,11 @@
     return NO_HASH; // Each locked region has own BoxLock node
   return Node::hash() + _slot + (_is_eliminated ? Compile::current()->fixed_slots() : 0);
 }
 
 //------------------------------cmp--------------------------------------------
-uint BoxLockNode::cmp( const Node &n ) const {
+bool BoxLockNode::cmp( const Node &n ) const {
   if (EliminateNestedLocks)
     return (&n == this); // Always fail except on self
   const BoxLockNode &bn = (const BoxLockNode &)n;
   return bn._slot == _slot && bn._is_eliminated == _is_eliminated;
 }
@@ -137,20 +137,20 @@
 uint FastLockNode::hash() const { return NO_HASH; }
 
 uint FastLockNode::size_of() const { return sizeof(*this); }
 
 //------------------------------cmp--------------------------------------------
-uint FastLockNode::cmp( const Node &n ) const {
+bool FastLockNode::cmp( const Node &n ) const {
   return (&n == this);                // Always fail except on self
 }
 
 //=============================================================================
 //-----------------------------hash--------------------------------------------
 uint FastUnlockNode::hash() const { return NO_HASH; }
 
 //------------------------------cmp--------------------------------------------
-uint FastUnlockNode::cmp( const Node &n ) const {
+bool FastUnlockNode::cmp( const Node &n ) const {
   return (&n == this);                // Always fail except on self
 }
 
 //
 // Create a counter which counts the number of times this lock is acquired

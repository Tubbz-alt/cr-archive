<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/barrierSet.hpp&quot;
  28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/movenode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/subnode.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 
  42 // Portions of code courtesy of Clifford Click
  43 
  44 // Optimization - Graph Style
  45 
  46 #include &quot;math.h&quot;
  47 
  48 //=============================================================================
  49 //------------------------------Identity---------------------------------------
  50 // If right input is a constant 0, return the left input.
  51 Node* SubNode::Identity(PhaseGVN* phase) {
  52   assert(in(1) != this, &quot;Must already have called Value&quot;);
  53   assert(in(2) != this, &quot;Must already have called Value&quot;);
  54 
  55   // Remove double negation
  56   const Type *zero = add_id();
  57   if( phase-&gt;type( in(1) )-&gt;higher_equal( zero ) &amp;&amp;
  58       in(2)-&gt;Opcode() == Opcode() &amp;&amp;
  59       phase-&gt;type( in(2)-&gt;in(1) )-&gt;higher_equal( zero ) ) {
  60     return in(2)-&gt;in(2);
  61   }
  62 
  63   // Convert &quot;(X+Y) - Y&quot; into X and &quot;(X+Y) - X&quot; into Y
  64   if( in(1)-&gt;Opcode() == Op_AddI ) {
  65     if( phase-&gt;eqv(in(1)-&gt;in(2),in(2)) )
  66       return in(1)-&gt;in(1);
  67     if (phase-&gt;eqv(in(1)-&gt;in(1),in(2)))
  68       return in(1)-&gt;in(2);
  69 
  70     // Also catch: &quot;(X + Opaque2(Y)) - Y&quot;.  In this case, &#39;Y&#39; is a loop-varying
  71     // trip counter and X is likely to be loop-invariant (that&#39;s how O2 Nodes
  72     // are originally used, although the optimizer sometimes jiggers things).
  73     // This folding through an O2 removes a loop-exit use of a loop-varying
  74     // value and generally lowers register pressure in and around the loop.
  75     if( in(1)-&gt;in(2)-&gt;Opcode() == Op_Opaque2 &amp;&amp;
  76         phase-&gt;eqv(in(1)-&gt;in(2)-&gt;in(1),in(2)) )
  77       return in(1)-&gt;in(1);
  78   }
  79 
  80   return ( phase-&gt;type( in(2) )-&gt;higher_equal( zero ) ) ? in(1) : this;
  81 }
  82 
  83 //------------------------------Value------------------------------------------
  84 // A subtract node differences it&#39;s two inputs.
  85 const Type* SubNode::Value_common(PhaseTransform *phase) const {
  86   const Node* in1 = in(1);
  87   const Node* in2 = in(2);
  88   // Either input is TOP ==&gt; the result is TOP
  89   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
  90   if( t1 == Type::TOP ) return Type::TOP;
  91   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
  92   if( t2 == Type::TOP ) return Type::TOP;
  93 
  94   // Not correct for SubFnode and AddFNode (must check for infinity)
  95   // Equal?  Subtract is zero
  96   if (in1-&gt;eqv_uncast(in2))  return add_id();
  97 
  98   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
  99   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 100     return bottom_type();
 101 
 102   return NULL;
 103 }
 104 
 105 const Type* SubNode::Value(PhaseGVN* phase) const {
 106   const Type* t = Value_common(phase);
 107   if (t != NULL) {
 108     return t;
 109   }
 110   const Type* t1 = phase-&gt;type(in(1));
 111   const Type* t2 = phase-&gt;type(in(2));
 112   return sub(t1,t2);            // Local flavor of type subtraction
 113 
 114 }
 115 
 116 //=============================================================================
<a name="1" id="anc1"></a><span class="line-removed"> 117 </span>
 118 //------------------------------Helper function--------------------------------
<a name="2" id="anc2"></a><span class="line-modified"> 119 static bool ok_to_convert(Node* inc, Node* iv) {</span>
<span class="line-modified"> 120     // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment, because the</span>
<span class="line-modified"> 121     // &quot;-&quot; is loop invariant and collapsing extends the live-range of &quot;x&quot;</span>
<span class="line-modified"> 122     // to overlap with the &quot;+&quot;, forcing another register to be used in</span>
<span class="line-modified"> 123     // the loop.</span>
<span class="line-modified"> 124     // This test will be clearer with &#39;&amp;&amp;&#39; (apply DeMorgan&#39;s rule)</span>
<span class="line-modified"> 125     // but I like the early cutouts that happen here.</span>
<span class="line-modified"> 126     const PhiNode *phi;</span>
<span class="line-modified"> 127     if( ( !inc-&gt;in(1)-&gt;is_Phi() ||</span>
<span class="line-modified"> 128           !(phi=inc-&gt;in(1)-&gt;as_Phi()) ||</span>
<span class="line-modified"> 129           phi-&gt;is_copy() ||</span>
<span class="line-modified"> 130           !phi-&gt;region()-&gt;is_CountedLoop() ||</span>
<span class="line-modified"> 131           inc != phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr() )</span>
<span class="line-modified"> 132        &amp;&amp;</span>
<span class="line-removed"> 133         // Do not collapse (x+c0)-iv if &quot;iv&quot; is a loop induction variable,</span>
<span class="line-removed"> 134         // because &quot;x&quot; maybe invariant.</span>
<span class="line-removed"> 135         ( !iv-&gt;is_loop_iv() )</span>
<span class="line-removed"> 136       ) {</span>
<span class="line-removed"> 137       return true;</span>
<span class="line-removed"> 138     } else {</span>
<span class="line-removed"> 139       return false;</span>
<span class="line-removed"> 140     }</span>
 141 }
<a name="3" id="anc3"></a>














 142 //------------------------------Ideal------------------------------------------
 143 Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
 144   Node *in1 = in(1);
 145   Node *in2 = in(2);
 146   uint op1 = in1-&gt;Opcode();
 147   uint op2 = in2-&gt;Opcode();
 148 
 149 #ifdef ASSERT
 150   // Check for dead loop
 151   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 152       ( ( op1 == Op_AddI || op1 == Op_SubI ) &amp;&amp;
 153         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 154           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1 ) ) ) )
 155     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 156 #endif
 157 
 158   const Type *t2 = phase-&gt;type( in2 );
 159   if( t2 == Type::TOP ) return NULL;
 160   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 161   if( t2-&gt;base() == Type::Int ){        // Might be bottom or top...
 162     const TypeInt *i = t2-&gt;is_int();
 163     if( i-&gt;is_con() )
 164       return new AddINode(in1, phase-&gt;intcon(-i-&gt;get_con()));
 165   }
 166 
 167   // Convert &quot;(x+c0) - y&quot; into (x-y) + c0&quot;
 168   // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment or
 169   // if &quot;y&quot; is a loop induction variable.
 170   if( op1 == Op_AddI &amp;&amp; ok_to_convert(in1, in2) ) {
 171     const Type *tadd = phase-&gt;type( in1-&gt;in(2) );
 172     if( tadd-&gt;singleton() &amp;&amp; tadd != Type::TOP ) {
 173       Node *sub2 = phase-&gt;transform( new SubINode( in1-&gt;in(1), in2 ));
 174       return new AddINode( sub2, in1-&gt;in(2) );
 175     }
 176   }
 177 
 178 
 179   // Convert &quot;x - (y+c0)&quot; into &quot;(x-y) - c0&quot;
 180   // Need the same check as in above optimization but reversed.
 181   if (op2 == Op_AddI &amp;&amp; ok_to_convert(in2, in1)) {
 182     Node* in21 = in2-&gt;in(1);
 183     Node* in22 = in2-&gt;in(2);
 184     const TypeInt* tcon = phase-&gt;type(in22)-&gt;isa_int();
 185     if (tcon != NULL &amp;&amp; tcon-&gt;is_con()) {
 186       Node* sub2 = phase-&gt;transform( new SubINode(in1, in21) );
 187       Node* neg_c0 = phase-&gt;intcon(- tcon-&gt;get_con());
 188       return new AddINode(sub2, neg_c0);
 189     }
 190   }
 191 
 192   const Type *t1 = phase-&gt;type( in1 );
 193   if( t1 == Type::TOP ) return NULL;
 194 
 195 #ifdef ASSERT
 196   // Check for dead loop
 197   if( ( op2 == Op_AddI || op2 == Op_SubI ) &amp;&amp;
 198       ( phase-&gt;eqv( in2-&gt;in(1), this ) || phase-&gt;eqv( in2-&gt;in(2), this ) ||
 199         phase-&gt;eqv( in2-&gt;in(1), in2  ) || phase-&gt;eqv( in2-&gt;in(2), in2  ) ) )
 200     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 201 #endif
 202 
 203   // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 204   if( op2 == Op_AddI &amp;&amp;
 205       phase-&gt;eqv( in1, in2-&gt;in(1) ) )
 206     return new SubINode( phase-&gt;intcon(0),in2-&gt;in(2));
 207   // Convert &quot;(x-y) - x&quot; into &quot;-y&quot;
 208   if( op1 == Op_SubI &amp;&amp;
 209       phase-&gt;eqv( in1-&gt;in(1), in2 ) )
 210     return new SubINode( phase-&gt;intcon(0),in1-&gt;in(2));
 211   // Convert &quot;x - (y+x)&quot; into &quot;-y&quot;
 212   if( op2 == Op_AddI &amp;&amp;
 213       phase-&gt;eqv( in1, in2-&gt;in(2) ) )
 214     return new SubINode( phase-&gt;intcon(0),in2-&gt;in(1));
 215 
 216   // Convert &quot;0 - (x-y)&quot; into &quot;y-x&quot;
 217   if( t1 == TypeInt::ZERO &amp;&amp; op2 == Op_SubI )
 218     return new SubINode( in2-&gt;in(2), in2-&gt;in(1) );
 219 
 220   // Convert &quot;0 - (x+con)&quot; into &quot;-con-x&quot;
 221   jint con;
 222   if( t1 == TypeInt::ZERO &amp;&amp; op2 == Op_AddI &amp;&amp;
 223       (con = in2-&gt;in(2)-&gt;find_int_con(0)) != 0 )
 224     return new SubINode( phase-&gt;intcon(-con), in2-&gt;in(1) );
 225 
 226   // Convert &quot;(X+A) - (X+B)&quot; into &quot;A - B&quot;
 227   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(1) )
 228     return new SubINode( in1-&gt;in(2), in2-&gt;in(2) );
 229 
 230   // Convert &quot;(A+X) - (B+X)&quot; into &quot;A - B&quot;
 231   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) )
 232     return new SubINode( in1-&gt;in(1), in2-&gt;in(1) );
 233 
 234   // Convert &quot;(A+X) - (X+B)&quot; into &quot;A - B&quot;
 235   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) )
 236     return new SubINode( in1-&gt;in(1), in2-&gt;in(2) );
 237 
 238   // Convert &quot;(X+A) - (B+X)&quot; into &quot;A - B&quot;
 239   if( op1 == Op_AddI &amp;&amp; op2 == Op_AddI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(2) )
 240     return new SubINode( in1-&gt;in(2), in2-&gt;in(1) );
 241 
 242   // Convert &quot;A-(B-C)&quot; into (A+C)-B&quot;, since add is commutative and generally
 243   // nicer to optimize than subtract.
 244   if( op2 == Op_SubI &amp;&amp; in2-&gt;outcnt() == 1) {
 245     Node *add1 = phase-&gt;transform( new AddINode( in1, in2-&gt;in(2) ) );
 246     return new SubINode( add1, in2-&gt;in(1) );
 247   }
 248 
 249   return NULL;
 250 }
 251 
 252 //------------------------------sub--------------------------------------------
 253 // A subtract node differences it&#39;s two inputs.
 254 const Type *SubINode::sub( const Type *t1, const Type *t2 ) const {
 255   const TypeInt *r0 = t1-&gt;is_int(); // Handy access
 256   const TypeInt *r1 = t2-&gt;is_int();
 257   int32_t lo = java_subtract(r0-&gt;_lo, r1-&gt;_hi);
 258   int32_t hi = java_subtract(r0-&gt;_hi, r1-&gt;_lo);
 259 
 260   // We next check for 32-bit overflow.
 261   // If that happens, we just assume all integers are possible.
 262   if( (((r0-&gt;_lo ^ r1-&gt;_hi) &gt;= 0) ||    // lo ends have same signs OR
 263        ((r0-&gt;_lo ^      lo) &gt;= 0)) &amp;&amp;   // lo results have same signs AND
 264       (((r0-&gt;_hi ^ r1-&gt;_lo) &gt;= 0) ||    // hi ends have same signs OR
 265        ((r0-&gt;_hi ^      hi) &gt;= 0)) )    // hi results have same signs
 266     return TypeInt::make(lo,hi,MAX2(r0-&gt;_widen,r1-&gt;_widen));
 267   else                          // Overflow; assume all integers
 268     return TypeInt::INT;
 269 }
 270 
 271 //=============================================================================
 272 //------------------------------Ideal------------------------------------------
 273 Node *SubLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 274   Node *in1 = in(1);
 275   Node *in2 = in(2);
 276   uint op1 = in1-&gt;Opcode();
 277   uint op2 = in2-&gt;Opcode();
 278 
 279 #ifdef ASSERT
 280   // Check for dead loop
 281   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 282       ( ( op1 == Op_AddL || op1 == Op_SubL ) &amp;&amp;
 283         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 284           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1  ) ) ) )
 285     assert(false, &quot;dead loop in SubLNode::Ideal&quot;);
 286 #endif
 287 
 288   if( phase-&gt;type( in2 ) == Type::TOP ) return NULL;
 289   const TypeLong *i = phase-&gt;type( in2 )-&gt;isa_long();
 290   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 291   if( i &amp;&amp;                      // Might be bottom or top...
 292       i-&gt;is_con() )
 293     return new AddLNode(in1, phase-&gt;longcon(-i-&gt;get_con()));
 294 
 295   // Convert &quot;(x+c0) - y&quot; into (x-y) + c0&quot;
 296   // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment or
 297   // if &quot;y&quot; is a loop induction variable.
 298   if( op1 == Op_AddL &amp;&amp; ok_to_convert(in1, in2) ) {
 299     Node *in11 = in1-&gt;in(1);
 300     const Type *tadd = phase-&gt;type( in1-&gt;in(2) );
 301     if( tadd-&gt;singleton() &amp;&amp; tadd != Type::TOP ) {
 302       Node *sub2 = phase-&gt;transform( new SubLNode( in11, in2 ));
 303       return new AddLNode( sub2, in1-&gt;in(2) );
 304     }
 305   }
 306 
 307   // Convert &quot;x - (y+c0)&quot; into &quot;(x-y) - c0&quot;
 308   // Need the same check as in above optimization but reversed.
 309   if (op2 == Op_AddL &amp;&amp; ok_to_convert(in2, in1)) {
 310     Node* in21 = in2-&gt;in(1);
 311     Node* in22 = in2-&gt;in(2);
 312     const TypeLong* tcon = phase-&gt;type(in22)-&gt;isa_long();
 313     if (tcon != NULL &amp;&amp; tcon-&gt;is_con()) {
 314       Node* sub2 = phase-&gt;transform( new SubLNode(in1, in21) );
 315       Node* neg_c0 = phase-&gt;longcon(- tcon-&gt;get_con());
 316       return new AddLNode(sub2, neg_c0);
 317     }
 318   }
 319 
 320   const Type *t1 = phase-&gt;type( in1 );
 321   if( t1 == Type::TOP ) return NULL;
 322 
 323 #ifdef ASSERT
 324   // Check for dead loop
 325   if( ( op2 == Op_AddL || op2 == Op_SubL ) &amp;&amp;
 326       ( phase-&gt;eqv( in2-&gt;in(1), this ) || phase-&gt;eqv( in2-&gt;in(2), this ) ||
 327         phase-&gt;eqv( in2-&gt;in(1), in2  ) || phase-&gt;eqv( in2-&gt;in(2), in2  ) ) )
 328     assert(false, &quot;dead loop in SubLNode::Ideal&quot;);
 329 #endif
 330 
 331   // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 332   if( op2 == Op_AddL &amp;&amp;
 333       phase-&gt;eqv( in1, in2-&gt;in(1) ) )
 334     return new SubLNode( phase-&gt;makecon(TypeLong::ZERO), in2-&gt;in(2));
 335   // Convert &quot;x - (y+x)&quot; into &quot;-y&quot;
 336   if( op2 == Op_AddL &amp;&amp;
 337       phase-&gt;eqv( in1, in2-&gt;in(2) ) )
 338     return new SubLNode( phase-&gt;makecon(TypeLong::ZERO),in2-&gt;in(1));
 339 
 340   // Convert &quot;0 - (x-y)&quot; into &quot;y-x&quot;
 341   if( phase-&gt;type( in1 ) == TypeLong::ZERO &amp;&amp; op2 == Op_SubL )
 342     return new SubLNode( in2-&gt;in(2), in2-&gt;in(1) );
 343 
 344   // Convert &quot;(X+A) - (X+B)&quot; into &quot;A - B&quot;
 345   if( op1 == Op_AddL &amp;&amp; op2 == Op_AddL &amp;&amp; in1-&gt;in(1) == in2-&gt;in(1) )
 346     return new SubLNode( in1-&gt;in(2), in2-&gt;in(2) );
 347 
 348   // Convert &quot;(A+X) - (B+X)&quot; into &quot;A - B&quot;
 349   if( op1 == Op_AddL &amp;&amp; op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) )
 350     return new SubLNode( in1-&gt;in(1), in2-&gt;in(1) );
 351 
 352   // Convert &quot;A-(B-C)&quot; into (A+C)-B&quot;
 353   if( op2 == Op_SubL &amp;&amp; in2-&gt;outcnt() == 1) {
 354     Node *add1 = phase-&gt;transform( new AddLNode( in1, in2-&gt;in(2) ) );
 355     return new SubLNode( add1, in2-&gt;in(1) );
 356   }
 357 
 358   return NULL;
 359 }
 360 
 361 //------------------------------sub--------------------------------------------
 362 // A subtract node differences it&#39;s two inputs.
 363 const Type *SubLNode::sub( const Type *t1, const Type *t2 ) const {
 364   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 365   const TypeLong *r1 = t2-&gt;is_long();
 366   jlong lo = java_subtract(r0-&gt;_lo, r1-&gt;_hi);
 367   jlong hi = java_subtract(r0-&gt;_hi, r1-&gt;_lo);
 368 
 369   // We next check for 32-bit overflow.
 370   // If that happens, we just assume all integers are possible.
 371   if( (((r0-&gt;_lo ^ r1-&gt;_hi) &gt;= 0) ||    // lo ends have same signs OR
 372        ((r0-&gt;_lo ^      lo) &gt;= 0)) &amp;&amp;   // lo results have same signs AND
 373       (((r0-&gt;_hi ^ r1-&gt;_lo) &gt;= 0) ||    // hi ends have same signs OR
 374        ((r0-&gt;_hi ^      hi) &gt;= 0)) )    // hi results have same signs
 375     return TypeLong::make(lo,hi,MAX2(r0-&gt;_widen,r1-&gt;_widen));
 376   else                          // Overflow; assume all integers
 377     return TypeLong::LONG;
 378 }
 379 
 380 //=============================================================================
 381 //------------------------------Value------------------------------------------
 382 // A subtract node differences its two inputs.
 383 const Type* SubFPNode::Value(PhaseGVN* phase) const {
 384   const Node* in1 = in(1);
 385   const Node* in2 = in(2);
 386   // Either input is TOP ==&gt; the result is TOP
 387   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
 388   if( t1 == Type::TOP ) return Type::TOP;
 389   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
 390   if( t2 == Type::TOP ) return Type::TOP;
 391 
 392   // if both operands are infinity of same sign, the result is NaN; do
 393   // not replace with zero
 394   if( (t1-&gt;is_finite() &amp;&amp; t2-&gt;is_finite()) ) {
 395     if( phase-&gt;eqv(in1, in2) ) return add_id();
 396   }
 397 
 398   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 399   const Type *bot = bottom_type();
 400   if( (t1 == bot) || (t2 == bot) ||
 401       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 402     return bot;
 403 
 404   return sub(t1,t2);            // Local flavor of type subtraction
 405 }
 406 
 407 
 408 //=============================================================================
 409 //------------------------------Ideal------------------------------------------
 410 Node *SubFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 411   const Type *t2 = phase-&gt;type( in(2) );
 412   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 413   if( t2-&gt;base() == Type::FloatCon ) {  // Might be bottom or top...
 414     // return new (phase-&gt;C, 3) AddFNode(in(1), phase-&gt;makecon( TypeF::make(-t2-&gt;getf()) ) );
 415   }
 416 
 417   // Not associative because of boundary conditions (infinity)
 418   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 419     // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 420     if( in(2)-&gt;is_Add() &amp;&amp;
 421         phase-&gt;eqv(in(1),in(2)-&gt;in(1) ) )
 422       return new SubFNode( phase-&gt;makecon(TypeF::ZERO),in(2)-&gt;in(2));
 423   }
 424 
 425   // Cannot replace 0.0-X with -X because a &#39;fsub&#39; bytecode computes
 426   // 0.0-0.0 as +0.0, while a &#39;fneg&#39; bytecode computes -0.0.
 427   //if( phase-&gt;type(in(1)) == TypeF::ZERO )
 428   //return new (phase-&gt;C, 2) NegFNode(in(2));
 429 
 430   return NULL;
 431 }
 432 
 433 //------------------------------sub--------------------------------------------
 434 // A subtract node differences its two inputs.
 435 const Type *SubFNode::sub( const Type *t1, const Type *t2 ) const {
 436   // no folding if one of operands is infinity or NaN, do not do constant folding
 437   if( g_isfinite(t1-&gt;getf()) &amp;&amp; g_isfinite(t2-&gt;getf()) ) {
 438     return TypeF::make( t1-&gt;getf() - t2-&gt;getf() );
 439   }
 440   else if( g_isnan(t1-&gt;getf()) ) {
 441     return t1;
 442   }
 443   else if( g_isnan(t2-&gt;getf()) ) {
 444     return t2;
 445   }
 446   else {
 447     return Type::FLOAT;
 448   }
 449 }
 450 
 451 //=============================================================================
 452 //------------------------------Ideal------------------------------------------
 453 Node *SubDNode::Ideal(PhaseGVN *phase, bool can_reshape){
 454   const Type *t2 = phase-&gt;type( in(2) );
 455   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 456   if( t2-&gt;base() == Type::DoubleCon ) { // Might be bottom or top...
 457     // return new (phase-&gt;C, 3) AddDNode(in(1), phase-&gt;makecon( TypeD::make(-t2-&gt;getd()) ) );
 458   }
 459 
 460   // Not associative because of boundary conditions (infinity)
 461   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 462     // Convert &quot;x - (x+y)&quot; into &quot;-y&quot;
 463     if( in(2)-&gt;is_Add() &amp;&amp;
 464         phase-&gt;eqv(in(1),in(2)-&gt;in(1) ) )
 465       return new SubDNode( phase-&gt;makecon(TypeD::ZERO),in(2)-&gt;in(2));
 466   }
 467 
 468   // Cannot replace 0.0-X with -X because a &#39;dsub&#39; bytecode computes
 469   // 0.0-0.0 as +0.0, while a &#39;dneg&#39; bytecode computes -0.0.
 470   //if( phase-&gt;type(in(1)) == TypeD::ZERO )
 471   //return new (phase-&gt;C, 2) NegDNode(in(2));
 472 
 473   return NULL;
 474 }
 475 
 476 //------------------------------sub--------------------------------------------
 477 // A subtract node differences its two inputs.
 478 const Type *SubDNode::sub( const Type *t1, const Type *t2 ) const {
 479   // no folding if one of operands is infinity or NaN, do not do constant folding
 480   if( g_isfinite(t1-&gt;getd()) &amp;&amp; g_isfinite(t2-&gt;getd()) ) {
 481     return TypeD::make( t1-&gt;getd() - t2-&gt;getd() );
 482   }
 483   else if( g_isnan(t1-&gt;getd()) ) {
 484     return t1;
 485   }
 486   else if( g_isnan(t2-&gt;getd()) ) {
 487     return t2;
 488   }
 489   else {
 490     return Type::DOUBLE;
 491   }
 492 }
 493 
 494 //=============================================================================
 495 //------------------------------Idealize---------------------------------------
 496 // Unlike SubNodes, compare must still flatten return value to the
 497 // range -1, 0, 1.
 498 // And optimizations like those for (X + Y) - X fail if overflow happens.
 499 Node* CmpNode::Identity(PhaseGVN* phase) {
 500   return this;
 501 }
 502 
 503 #ifndef PRODUCT
 504 //----------------------------related------------------------------------------
 505 // Related nodes of comparison nodes include all data inputs (until hitting a
 506 // control boundary) as well as all outputs until and including control nodes
 507 // as well as their projections. In compact mode, data inputs till depth 1 and
 508 // all outputs till depth 1 are considered.
 509 void CmpNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 510   if (compact) {
 511     this-&gt;collect_nodes(in_rel, 1, false, true);
 512     this-&gt;collect_nodes(out_rel, -1, false, false);
 513   } else {
 514     this-&gt;collect_nodes_in_all_data(in_rel, false);
 515     this-&gt;collect_nodes_out_all_ctrl_boundary(out_rel);
 516     // Now, find all control nodes in out_rel, and include their projections
 517     // and projection targets (if any) in the result.
 518     GrowableArray&lt;Node*&gt; proj(Compile::current()-&gt;unique());
 519     for (GrowableArrayIterator&lt;Node*&gt; it = out_rel-&gt;begin(); it != out_rel-&gt;end(); ++it) {
 520       Node* n = *it;
 521       if (n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Proj()) {
 522         // Assume projections and projection targets are found at levels 1 and 2.
 523         n-&gt;collect_nodes(&amp;proj, -2, false, false);
 524         for (GrowableArrayIterator&lt;Node*&gt; p = proj.begin(); p != proj.end(); ++p) {
 525           out_rel-&gt;append_if_missing(*p);
 526         }
 527         proj.clear();
 528       }
 529     }
 530   }
 531 }
 532 #endif
 533 
 534 //=============================================================================
 535 //------------------------------cmp--------------------------------------------
 536 // Simplify a CmpI (compare 2 integers) node, based on local information.
 537 // If both inputs are constants, compare them.
 538 const Type *CmpINode::sub( const Type *t1, const Type *t2 ) const {
 539   const TypeInt *r0 = t1-&gt;is_int(); // Handy access
 540   const TypeInt *r1 = t2-&gt;is_int();
 541 
 542   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 543     return TypeInt::CC_LT;
 544   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 545     return TypeInt::CC_GT;
 546 
 547   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 548     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 549     return TypeInt::CC_EQ;      // Equal results.
 550   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 551     return TypeInt::CC_LE;
 552   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 553     return TypeInt::CC_GE;
 554   return TypeInt::CC;           // else use worst case results
 555 }
 556 
 557 // Simplify a CmpU (compare 2 integers) node, based on local information.
 558 // If both inputs are constants, compare them.
 559 const Type *CmpUNode::sub( const Type *t1, const Type *t2 ) const {
 560   assert(!t1-&gt;isa_ptr(), &quot;obsolete usage of CmpU&quot;);
 561 
 562   // comparing two unsigned ints
 563   const TypeInt *r0 = t1-&gt;is_int();   // Handy access
 564   const TypeInt *r1 = t2-&gt;is_int();
 565 
 566   // Current installed version
 567   // Compare ranges for non-overlap
 568   juint lo0 = r0-&gt;_lo;
 569   juint hi0 = r0-&gt;_hi;
 570   juint lo1 = r1-&gt;_lo;
 571   juint hi1 = r1-&gt;_hi;
 572 
 573   // If either one has both negative and positive values,
 574   // it therefore contains both 0 and -1, and since [0..-1] is the
 575   // full unsigned range, the type must act as an unsigned bottom.
 576   bool bot0 = ((jint)(lo0 ^ hi0) &lt; 0);
 577   bool bot1 = ((jint)(lo1 ^ hi1) &lt; 0);
 578 
 579   if (bot0 || bot1) {
 580     // All unsigned values are LE -1 and GE 0.
 581     if (lo0 == 0 &amp;&amp; hi0 == 0) {
 582       return TypeInt::CC_LE;            //   0 &lt;= bot
 583     } else if ((jint)lo0 == -1 &amp;&amp; (jint)hi0 == -1) {
 584       return TypeInt::CC_GE;            // -1 &gt;= bot
 585     } else if (lo1 == 0 &amp;&amp; hi1 == 0) {
 586       return TypeInt::CC_GE;            // bot &gt;= 0
 587     } else if ((jint)lo1 == -1 &amp;&amp; (jint)hi1 == -1) {
 588       return TypeInt::CC_LE;            // bot &lt;= -1
 589     }
 590   } else {
 591     // We can use ranges of the form [lo..hi] if signs are the same.
 592     assert(lo0 &lt;= hi0 &amp;&amp; lo1 &lt;= hi1, &quot;unsigned ranges are valid&quot;);
 593     // results are reversed, &#39;-&#39; &gt; &#39;+&#39; for unsigned compare
 594     if (hi0 &lt; lo1) {
 595       return TypeInt::CC_LT;            // smaller
 596     } else if (lo0 &gt; hi1) {
 597       return TypeInt::CC_GT;            // greater
 598     } else if (hi0 == lo1 &amp;&amp; lo0 == hi1) {
 599       return TypeInt::CC_EQ;            // Equal results
 600     } else if (lo0 &gt;= hi1) {
 601       return TypeInt::CC_GE;
 602     } else if (hi0 &lt;= lo1) {
 603       // Check for special case in Hashtable::get.  (See below.)
 604       if ((jint)lo0 &gt;= 0 &amp;&amp; (jint)lo1 &gt;= 0 &amp;&amp; is_index_range_check())
 605         return TypeInt::CC_LT;
 606       return TypeInt::CC_LE;
 607     }
 608   }
 609   // Check for special case in Hashtable::get - the hash index is
 610   // mod&#39;ed to the table size so the following range check is useless.
 611   // Check for: (X Mod Y) CmpU Y, where the mod result and Y both have
 612   // to be positive.
 613   // (This is a gross hack, since the sub method never
 614   // looks at the structure of the node in any other case.)
 615   if ((jint)lo0 &gt;= 0 &amp;&amp; (jint)lo1 &gt;= 0 &amp;&amp; is_index_range_check())
 616     return TypeInt::CC_LT;
 617   return TypeInt::CC;                   // else use worst case results
 618 }
 619 
 620 const Type* CmpUNode::Value(PhaseGVN* phase) const {
 621   const Type* t = SubNode::Value_common(phase);
 622   if (t != NULL) {
 623     return t;
 624   }
 625   const Node* in1 = in(1);
 626   const Node* in2 = in(2);
 627   const Type* t1 = phase-&gt;type(in1);
 628   const Type* t2 = phase-&gt;type(in2);
 629   assert(t1-&gt;isa_int(), &quot;CmpU has only Int type inputs&quot;);
 630   if (t2 == TypeInt::INT) { // Compare to bottom?
 631     return bottom_type();
 632   }
 633   uint in1_op = in1-&gt;Opcode();
 634   if (in1_op == Op_AddI || in1_op == Op_SubI) {
 635     // The problem rise when result of AddI(SubI) may overflow
 636     // signed integer value. Let say the input type is
 637     // [256, maxint] then +128 will create 2 ranges due to
 638     // overflow: [minint, minint+127] and [384, maxint].
 639     // But C2 type system keep only 1 type range and as result
 640     // it use general [minint, maxint] for this case which we
 641     // can&#39;t optimize.
 642     //
 643     // Make 2 separate type ranges based on types of AddI(SubI) inputs
 644     // and compare results of their compare. If results are the same
 645     // CmpU node can be optimized.
 646     const Node* in11 = in1-&gt;in(1);
 647     const Node* in12 = in1-&gt;in(2);
 648     const Type* t11 = (in11 == in1) ? Type::TOP : phase-&gt;type(in11);
 649     const Type* t12 = (in12 == in1) ? Type::TOP : phase-&gt;type(in12);
 650     // Skip cases when input types are top or bottom.
 651     if ((t11 != Type::TOP) &amp;&amp; (t11 != TypeInt::INT) &amp;&amp;
 652         (t12 != Type::TOP) &amp;&amp; (t12 != TypeInt::INT)) {
 653       const TypeInt *r0 = t11-&gt;is_int();
 654       const TypeInt *r1 = t12-&gt;is_int();
 655       jlong lo_r0 = r0-&gt;_lo;
 656       jlong hi_r0 = r0-&gt;_hi;
 657       jlong lo_r1 = r1-&gt;_lo;
 658       jlong hi_r1 = r1-&gt;_hi;
 659       if (in1_op == Op_SubI) {
 660         jlong tmp = hi_r1;
 661         hi_r1 = -lo_r1;
 662         lo_r1 = -tmp;
 663         // Note, for substructing [minint,x] type range
 664         // long arithmetic provides correct overflow answer.
 665         // The confusion come from the fact that in 32-bit
 666         // -minint == minint but in 64-bit -minint == maxint+1.
 667       }
 668       jlong lo_long = lo_r0 + lo_r1;
 669       jlong hi_long = hi_r0 + hi_r1;
 670       int lo_tr1 = min_jint;
 671       int hi_tr1 = (int)hi_long;
 672       int lo_tr2 = (int)lo_long;
 673       int hi_tr2 = max_jint;
 674       bool underflow = lo_long != (jlong)lo_tr2;
 675       bool overflow  = hi_long != (jlong)hi_tr1;
 676       // Use sub(t1, t2) when there is no overflow (one type range)
 677       // or when both overflow and underflow (too complex).
 678       if ((underflow != overflow) &amp;&amp; (hi_tr1 &lt; lo_tr2)) {
 679         // Overflow only on one boundary, compare 2 separate type ranges.
 680         int w = MAX2(r0-&gt;_widen, r1-&gt;_widen); // _widen does not matter here
 681         const TypeInt* tr1 = TypeInt::make(lo_tr1, hi_tr1, w);
 682         const TypeInt* tr2 = TypeInt::make(lo_tr2, hi_tr2, w);
 683         const Type* cmp1 = sub(tr1, t2);
 684         const Type* cmp2 = sub(tr2, t2);
 685         if (cmp1 == cmp2) {
 686           return cmp1; // Hit!
 687         }
 688       }
 689     }
 690   }
 691 
 692   return sub(t1, t2);            // Local flavor of type subtraction
 693 }
 694 
 695 bool CmpUNode::is_index_range_check() const {
 696   // Check for the &quot;(X ModI Y) CmpU Y&quot; shape
 697   return (in(1)-&gt;Opcode() == Op_ModI &amp;&amp;
 698           in(1)-&gt;in(2)-&gt;eqv_uncast(in(2)));
 699 }
 700 
 701 //------------------------------Idealize---------------------------------------
 702 Node *CmpINode::Ideal( PhaseGVN *phase, bool can_reshape ) {
 703   if (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) {
 704     switch (in(1)-&gt;Opcode()) {
 705     case Op_CmpL3:              // Collapse a CmpL3/CmpI into a CmpL
 706       return new CmpLNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 707     case Op_CmpF3:              // Collapse a CmpF3/CmpI into a CmpF
 708       return new CmpFNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 709     case Op_CmpD3:              // Collapse a CmpD3/CmpI into a CmpD
 710       return new CmpDNode(in(1)-&gt;in(1),in(1)-&gt;in(2));
 711     //case Op_SubI:
 712       // If (x - y) cannot overflow, then ((x - y) &lt;?&gt; 0)
 713       // can be turned into (x &lt;?&gt; y).
 714       // This is handled (with more general cases) by Ideal_sub_algebra.
 715     }
 716   }
 717   return NULL;                  // No change
 718 }
 719 
 720 
 721 //=============================================================================
 722 // Simplify a CmpL (compare 2 longs ) node, based on local information.
 723 // If both inputs are constants, compare them.
 724 const Type *CmpLNode::sub( const Type *t1, const Type *t2 ) const {
 725   const TypeLong *r0 = t1-&gt;is_long(); // Handy access
 726   const TypeLong *r1 = t2-&gt;is_long();
 727 
 728   if( r0-&gt;_hi &lt; r1-&gt;_lo )       // Range is always low?
 729     return TypeInt::CC_LT;
 730   else if( r0-&gt;_lo &gt; r1-&gt;_hi )  // Range is always high?
 731     return TypeInt::CC_GT;
 732 
 733   else if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() ) { // comparing constants?
 734     assert(r0-&gt;get_con() == r1-&gt;get_con(), &quot;must be equal&quot;);
 735     return TypeInt::CC_EQ;      // Equal results.
 736   } else if( r0-&gt;_hi == r1-&gt;_lo ) // Range is never high?
 737     return TypeInt::CC_LE;
 738   else if( r0-&gt;_lo == r1-&gt;_hi ) // Range is never low?
 739     return TypeInt::CC_GE;
 740   return TypeInt::CC;           // else use worst case results
 741 }
 742 
 743 
 744 // Simplify a CmpUL (compare 2 unsigned longs) node, based on local information.
 745 // If both inputs are constants, compare them.
 746 const Type* CmpULNode::sub(const Type* t1, const Type* t2) const {
 747   assert(!t1-&gt;isa_ptr(), &quot;obsolete usage of CmpUL&quot;);
 748 
 749   // comparing two unsigned longs
 750   const TypeLong* r0 = t1-&gt;is_long();   // Handy access
 751   const TypeLong* r1 = t2-&gt;is_long();
 752 
 753   // Current installed version
 754   // Compare ranges for non-overlap
 755   julong lo0 = r0-&gt;_lo;
 756   julong hi0 = r0-&gt;_hi;
 757   julong lo1 = r1-&gt;_lo;
 758   julong hi1 = r1-&gt;_hi;
 759 
 760   // If either one has both negative and positive values,
 761   // it therefore contains both 0 and -1, and since [0..-1] is the
 762   // full unsigned range, the type must act as an unsigned bottom.
 763   bool bot0 = ((jlong)(lo0 ^ hi0) &lt; 0);
 764   bool bot1 = ((jlong)(lo1 ^ hi1) &lt; 0);
 765 
 766   if (bot0 || bot1) {
 767     // All unsigned values are LE -1 and GE 0.
 768     if (lo0 == 0 &amp;&amp; hi0 == 0) {
 769       return TypeInt::CC_LE;            //   0 &lt;= bot
 770     } else if ((jlong)lo0 == -1 &amp;&amp; (jlong)hi0 == -1) {
 771       return TypeInt::CC_GE;            // -1 &gt;= bot
 772     } else if (lo1 == 0 &amp;&amp; hi1 == 0) {
 773       return TypeInt::CC_GE;            // bot &gt;= 0
 774     } else if ((jlong)lo1 == -1 &amp;&amp; (jlong)hi1 == -1) {
 775       return TypeInt::CC_LE;            // bot &lt;= -1
 776     }
 777   } else {
 778     // We can use ranges of the form [lo..hi] if signs are the same.
 779     assert(lo0 &lt;= hi0 &amp;&amp; lo1 &lt;= hi1, &quot;unsigned ranges are valid&quot;);
 780     // results are reversed, &#39;-&#39; &gt; &#39;+&#39; for unsigned compare
 781     if (hi0 &lt; lo1) {
 782       return TypeInt::CC_LT;            // smaller
 783     } else if (lo0 &gt; hi1) {
 784       return TypeInt::CC_GT;            // greater
 785     } else if (hi0 == lo1 &amp;&amp; lo0 == hi1) {
 786       return TypeInt::CC_EQ;            // Equal results
 787     } else if (lo0 &gt;= hi1) {
 788       return TypeInt::CC_GE;
 789     } else if (hi0 &lt;= lo1) {
 790       return TypeInt::CC_LE;
 791     }
 792   }
 793 
 794   return TypeInt::CC;                   // else use worst case results
 795 }
 796 
 797 //=============================================================================
 798 //------------------------------sub--------------------------------------------
 799 // Simplify an CmpP (compare 2 pointers) node, based on local information.
 800 // If both inputs are constants, compare them.
 801 const Type *CmpPNode::sub( const Type *t1, const Type *t2 ) const {
 802   const TypePtr *r0 = t1-&gt;is_ptr(); // Handy access
 803   const TypePtr *r1 = t2-&gt;is_ptr();
 804 
 805   // Undefined inputs makes for an undefined result
 806   if( TypePtr::above_centerline(r0-&gt;_ptr) ||
 807       TypePtr::above_centerline(r1-&gt;_ptr) )
 808     return Type::TOP;
 809 
 810   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {
 811     // Equal pointer constants (klasses, nulls, etc.)
 812     return TypeInt::CC_EQ;
 813   }
 814 
 815   // See if it is 2 unrelated classes.
<a name="4" id="anc4"></a><span class="line-modified"> 816   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-modified"> 817   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-modified"> 818   if (p0 &amp;&amp; p1) {</span>


 819     Node* in1 = in(1)-&gt;uncast();
 820     Node* in2 = in(2)-&gt;uncast();
 821     AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
 822     AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
 823     if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
 824       return TypeInt::CC_GT;  // different pointers
 825     }
<a name="5" id="anc5"></a><span class="line-modified"> 826     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-modified"> 827     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-modified"> 828     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-modified"> 829     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-modified"> 830     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
























 831     if (klass0 &amp;&amp; klass1 &amp;&amp;
<a name="6" id="anc6"></a><span class="line-removed"> 832         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
 833         klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
 834         klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
 835         (!klass0-&gt;is_obj_array_klass() ||
 836          !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
 837         (!klass1-&gt;is_obj_array_klass() ||
 838          !klass1-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface())) {
 839       bool unrelated_classes = false;
 840       // See if neither subclasses the other, or if the class on top
 841       // is precise.  In either of these cases, the compare is known
 842       // to fail if at least one of the pointers is provably not null.
 843       if (klass0-&gt;equals(klass1)) {  // if types are unequal but klasses are equal
 844         // Do nothing; we know nothing for imprecise types
 845       } else if (klass0-&gt;is_subtype_of(klass1)) {
 846         // If klass1&#39;s type is PRECISE, then classes are unrelated.
 847         unrelated_classes = xklass1;
 848       } else if (klass1-&gt;is_subtype_of(klass0)) {
 849         // If klass0&#39;s type is PRECISE, then classes are unrelated.
 850         unrelated_classes = xklass0;
 851       } else {                  // Neither subtypes the other
 852         unrelated_classes = true;
 853       }
 854       if (unrelated_classes) {
 855         // The oops classes are known to be unrelated. If the joined PTRs of
 856         // two oops is not Null and not Bottom, then we are sure that one
 857         // of the two oops is non-null, and the comparison will always fail.
 858         TypePtr::PTR jp = r0-&gt;join_ptr(r1-&gt;_ptr);
 859         if (jp != TypePtr::Null &amp;&amp; jp != TypePtr::BotPTR) {
 860           return TypeInt::CC_GT;
 861         }
 862       }
 863     }
 864   }
 865 
 866   // Known constants can be compared exactly
 867   // Null can be distinguished from any NotNull pointers
 868   // Unknown inputs makes an unknown result
 869   if( r0-&gt;singleton() ) {
 870     intptr_t bits0 = r0-&gt;get_con();
 871     if( r1-&gt;singleton() )
 872       return bits0 == r1-&gt;get_con() ? TypeInt::CC_EQ : TypeInt::CC_GT;
 873     return ( r1-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits0==0 ) ? TypeInt::CC_GT : TypeInt::CC;
 874   } else if( r1-&gt;singleton() ) {
 875     intptr_t bits1 = r1-&gt;get_con();
 876     return ( r0-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits1==0 ) ? TypeInt::CC_GT : TypeInt::CC;
 877   } else
 878     return TypeInt::CC;
 879 }
 880 
 881 static inline Node* isa_java_mirror_load(PhaseGVN* phase, Node* n) {
 882   // Return the klass node for (indirect load from OopHandle)
 883   //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
 884   //   or NULL if not matching.
 885   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 886     n = bs-&gt;step_over_gc_barrier(n);
 887 
 888   if (n-&gt;Opcode() != Op_LoadP) return NULL;
 889 
 890   const TypeInstPtr* tp = phase-&gt;type(n)-&gt;isa_instptr();
 891   if (!tp || tp-&gt;klass() != phase-&gt;C-&gt;env()-&gt;Class_klass()) return NULL;
 892 
 893   Node* adr = n-&gt;in(MemNode::Address);
 894   // First load from OopHandle: ((OopHandle)mirror)-&gt;resolve(); may need barrier.
 895   if (adr-&gt;Opcode() != Op_LoadP || !phase-&gt;type(adr)-&gt;isa_rawptr()) return NULL;
 896   adr = adr-&gt;in(MemNode::Address);
 897 
 898   intptr_t off = 0;
 899   Node* k = AddPNode::Ideal_base_and_offset(adr, phase, off);
 900   if (k == NULL)  return NULL;
 901   const TypeKlassPtr* tkp = phase-&gt;type(k)-&gt;isa_klassptr();
 902   if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return NULL;
 903 
 904   // We&#39;ve found the klass node of a Java mirror load.
 905   return k;
 906 }
 907 
 908 static inline Node* isa_const_java_mirror(PhaseGVN* phase, Node* n) {
 909   // for ConP(Foo.class) return ConP(Foo.klass)
 910   // otherwise return NULL
 911   if (!n-&gt;is_Con()) return NULL;
 912 
 913   const TypeInstPtr* tp = phase-&gt;type(n)-&gt;isa_instptr();
 914   if (!tp) return NULL;
 915 
 916   ciType* mirror_type = tp-&gt;java_mirror_type();
 917   // TypeInstPtr::java_mirror_type() returns non-NULL for compile-
 918   // time Class constants only.
 919   if (!mirror_type) return NULL;
 920 
 921   // x.getClass() == int.class can never be true (for all primitive types)
 922   // Return a ConP(NULL) node for this case.
 923   if (mirror_type-&gt;is_classless()) {
 924     return phase-&gt;makecon(TypePtr::NULL_PTR);
 925   }
 926 
 927   // return the ConP(Foo.klass)
 928   assert(mirror_type-&gt;is_klass(), &quot;mirror_type should represent a Klass*&quot;);
 929   return phase-&gt;makecon(TypeKlassPtr::make(mirror_type-&gt;as_klass()));
 930 }
 931 
 932 //------------------------------Ideal------------------------------------------
 933 // Normalize comparisons between Java mirror loads to compare the klass instead.
 934 //
 935 // Also check for the case of comparing an unknown klass loaded from the primary
 936 // super-type array vs a known klass with no subtypes.  This amounts to
 937 // checking to see an unknown klass subtypes a known klass with no subtypes;
 938 // this only happens on an exact match.  We can shorten this test by 1 load.
 939 Node *CmpPNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
 940   // Normalize comparisons between Java mirrors into comparisons of the low-
 941   // level klass, where a dependent load could be shortened.
 942   //
 943   // The new pattern has a nice effect of matching the same pattern used in the
 944   // fast path of instanceof/checkcast/Class.isInstance(), which allows
 945   // redundant exact type check be optimized away by GVN.
 946   // For example, in
 947   //   if (x.getClass() == Foo.class) {
 948   //     Foo foo = (Foo) x;
 949   //     // ... use a ...
 950   //   }
 951   // a CmpPNode could be shared between if_acmpne and checkcast
 952   {
 953     Node* k1 = isa_java_mirror_load(phase, in(1));
 954     Node* k2 = isa_java_mirror_load(phase, in(2));
 955     Node* conk2 = isa_const_java_mirror(phase, in(2));
 956 
 957     if (k1 &amp;&amp; (k2 || conk2)) {
 958       Node* lhs = k1;
 959       Node* rhs = (k2 != NULL) ? k2 : conk2;
 960       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
 961       if (igvn != NULL) {
 962         set_req_X(1, lhs, igvn);
 963         set_req_X(2, rhs, igvn);
 964       } else {
 965         set_req(1, lhs);
 966         set_req(2, rhs);
 967       }
 968       return this;
 969     }
 970   }
 971 
 972   // Constant pointer on right?
 973   const TypeKlassPtr* t2 = phase-&gt;type(in(2))-&gt;isa_klassptr();
 974   if (t2 == NULL || !t2-&gt;klass_is_exact())
 975     return NULL;
 976   // Get the constant klass we are comparing to.
 977   ciKlass* superklass = t2-&gt;klass();
 978 
 979   // Now check for LoadKlass on left.
 980   Node* ldk1 = in(1);
 981   if (ldk1-&gt;is_DecodeNKlass()) {
 982     ldk1 = ldk1-&gt;in(1);
 983     if (ldk1-&gt;Opcode() != Op_LoadNKlass )
 984       return NULL;
 985   } else if (ldk1-&gt;Opcode() != Op_LoadKlass )
 986     return NULL;
 987   // Take apart the address of the LoadKlass:
 988   Node* adr1 = ldk1-&gt;in(MemNode::Address);
 989   intptr_t con2 = 0;
 990   Node* ldk2 = AddPNode::Ideal_base_and_offset(adr1, phase, con2);
 991   if (ldk2 == NULL)
 992     return NULL;
 993   if (con2 == oopDesc::klass_offset_in_bytes()) {
 994     // We are inspecting an object&#39;s concrete class.
 995     // Short-circuit the check if the query is abstract.
 996     if (superklass-&gt;is_interface() ||
 997         superklass-&gt;is_abstract()) {
 998       // Make it come out always false:
 999       this-&gt;set_req(2, phase-&gt;makecon(TypePtr::NULL_PTR));
1000       return this;
1001     }
1002   }
1003 
1004   // Check for a LoadKlass from primary supertype array.
1005   // Any nested loadklass from loadklass+con must be from the p.s. array.
1006   if (ldk2-&gt;is_DecodeNKlass()) {
1007     // Keep ldk2 as DecodeN since it could be used in CmpP below.
1008     if (ldk2-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass )
1009       return NULL;
1010   } else if (ldk2-&gt;Opcode() != Op_LoadKlass)
1011     return NULL;
1012 
1013   // Verify that we understand the situation
1014   if (con2 != (intptr_t) superklass-&gt;super_check_offset())
1015     return NULL;                // Might be element-klass loading from array klass
1016 
1017   // If &#39;superklass&#39; has no subklasses and is not an interface, then we are
1018   // assured that the only input which will pass the type check is
1019   // &#39;superklass&#39; itself.
1020   //
1021   // We could be more liberal here, and allow the optimization on interfaces
1022   // which have a single implementor.  This would require us to increase the
1023   // expressiveness of the add_dependency() mechanism.
1024   // %%% Do this after we fix TypeOopPtr:  Deps are expressive enough now.
1025 
1026   // Object arrays must have their base element have no subtypes
1027   while (superklass-&gt;is_obj_array_klass()) {
1028     ciType* elem = superklass-&gt;as_obj_array_klass()-&gt;element_type();
1029     superklass = elem-&gt;as_klass();
1030   }
1031   if (superklass-&gt;is_instance_klass()) {
1032     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1033     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1034     // Add a dependency if there is a chance that a subclass will be added later.
1035     if (!ik-&gt;is_final()) {
1036       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
1037     }
1038   }
1039 
1040   // Bypass the dependent load, and compare directly
1041   this-&gt;set_req(1,ldk2);
1042 
1043   return this;
1044 }
1045 
1046 //=============================================================================
1047 //------------------------------sub--------------------------------------------
1048 // Simplify an CmpN (compare 2 pointers) node, based on local information.
1049 // If both inputs are constants, compare them.
1050 const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
<a name="7" id="anc7"></a><span class="line-modified">1051   const TypePtr *r0 = t1-&gt;make_ptr(); // Handy access</span>
<span class="line-modified">1052   const TypePtr *r1 = t2-&gt;make_ptr();</span>
<span class="line-removed">1053 </span>
<span class="line-removed">1054   // Undefined inputs makes for an undefined result</span>
<span class="line-removed">1055   if ((r0 == NULL) || (r1 == NULL) ||</span>
<span class="line-removed">1056       TypePtr::above_centerline(r0-&gt;_ptr) ||</span>
<span class="line-removed">1057       TypePtr::above_centerline(r1-&gt;_ptr)) {</span>
<span class="line-removed">1058     return Type::TOP;</span>
<span class="line-removed">1059   }</span>
<span class="line-removed">1060   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {</span>
<span class="line-removed">1061     // Equal pointer constants (klasses, nulls, etc.)</span>
<span class="line-removed">1062     return TypeInt::CC_EQ;</span>
<span class="line-removed">1063   }</span>
<span class="line-removed">1064 </span>
<span class="line-removed">1065   // See if it is 2 unrelated classes.</span>
<span class="line-removed">1066   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-removed">1067   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-removed">1068   if (p0 &amp;&amp; p1) {</span>
<span class="line-removed">1069     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-removed">1070     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-removed">1071     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-removed">1072     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-removed">1073     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
<span class="line-removed">1074     if (klass0 &amp;&amp; klass1 &amp;&amp;</span>
<span class="line-removed">1075         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
<span class="line-removed">1076         !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces</span>
<span class="line-removed">1077         !klass1-&gt;is_interface()) {</span>
<span class="line-removed">1078       bool unrelated_classes = false;</span>
<span class="line-removed">1079       // See if neither subclasses the other, or if the class on top</span>
<span class="line-removed">1080       // is precise.  In either of these cases, the compare is known</span>
<span class="line-removed">1081       // to fail if at least one of the pointers is provably not null.</span>
<span class="line-removed">1082       if (klass0-&gt;equals(klass1)) { // if types are unequal but klasses are equal</span>
<span class="line-removed">1083         // Do nothing; we know nothing for imprecise types</span>
<span class="line-removed">1084       } else if (klass0-&gt;is_subtype_of(klass1)) {</span>
<span class="line-removed">1085         // If klass1&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">1086         unrelated_classes = xklass1;</span>
<span class="line-removed">1087       } else if (klass1-&gt;is_subtype_of(klass0)) {</span>
<span class="line-removed">1088         // If klass0&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">1089         unrelated_classes = xklass0;</span>
<span class="line-removed">1090       } else {                  // Neither subtypes the other</span>
<span class="line-removed">1091         unrelated_classes = true;</span>
<span class="line-removed">1092       }</span>
<span class="line-removed">1093       if (unrelated_classes) {</span>
<span class="line-removed">1094         // The oops classes are known to be unrelated. If the joined PTRs of</span>
<span class="line-removed">1095         // two oops is not Null and not Bottom, then we are sure that one</span>
<span class="line-removed">1096         // of the two oops is non-null, and the comparison will always fail.</span>
<span class="line-removed">1097         TypePtr::PTR jp = r0-&gt;join_ptr(r1-&gt;_ptr);</span>
<span class="line-removed">1098         if (jp != TypePtr::Null &amp;&amp; jp != TypePtr::BotPTR) {</span>
<span class="line-removed">1099           return TypeInt::CC_GT;</span>
<span class="line-removed">1100         }</span>
<span class="line-removed">1101       }</span>
<span class="line-removed">1102     }</span>
<span class="line-removed">1103   }</span>
<span class="line-removed">1104 </span>
<span class="line-removed">1105   // Known constants can be compared exactly</span>
<span class="line-removed">1106   // Null can be distinguished from any NotNull pointers</span>
<span class="line-removed">1107   // Unknown inputs makes an unknown result</span>
<span class="line-removed">1108   if( r0-&gt;singleton() ) {</span>
<span class="line-removed">1109     intptr_t bits0 = r0-&gt;get_con();</span>
<span class="line-removed">1110     if( r1-&gt;singleton() )</span>
<span class="line-removed">1111       return bits0 == r1-&gt;get_con() ? TypeInt::CC_EQ : TypeInt::CC_GT;</span>
<span class="line-removed">1112     return ( r1-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits0==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">1113   } else if( r1-&gt;singleton() ) {</span>
<span class="line-removed">1114     intptr_t bits1 = r1-&gt;get_con();</span>
<span class="line-removed">1115     return ( r0-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits1==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">1116   } else</span>
<span class="line-removed">1117     return TypeInt::CC;</span>
1118 }
1119 
1120 //------------------------------Ideal------------------------------------------
1121 Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
1122   return NULL;
1123 }
1124 
1125 //=============================================================================
1126 //------------------------------Value------------------------------------------
1127 // Simplify an CmpF (compare 2 floats ) node, based on local information.
1128 // If both inputs are constants, compare them.
1129 const Type* CmpFNode::Value(PhaseGVN* phase) const {
1130   const Node* in1 = in(1);
1131   const Node* in2 = in(2);
1132   // Either input is TOP ==&gt; the result is TOP
1133   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1134   if( t1 == Type::TOP ) return Type::TOP;
1135   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1136   if( t2 == Type::TOP ) return Type::TOP;
1137 
1138   // Not constants?  Don&#39;t know squat - even if they are the same
1139   // value!  If they are NaN&#39;s they compare to LT instead of EQ.
1140   const TypeF *tf1 = t1-&gt;isa_float_constant();
1141   const TypeF *tf2 = t2-&gt;isa_float_constant();
1142   if( !tf1 || !tf2 ) return TypeInt::CC;
1143 
1144   // This implements the Java bytecode fcmpl, so unordered returns -1.
1145   if( tf1-&gt;is_nan() || tf2-&gt;is_nan() )
1146     return TypeInt::CC_LT;
1147 
1148   if( tf1-&gt;_f &lt; tf2-&gt;_f ) return TypeInt::CC_LT;
1149   if( tf1-&gt;_f &gt; tf2-&gt;_f ) return TypeInt::CC_GT;
1150   assert( tf1-&gt;_f == tf2-&gt;_f, &quot;do not understand FP behavior&quot; );
1151   return TypeInt::CC_EQ;
1152 }
1153 
1154 
1155 //=============================================================================
1156 //------------------------------Value------------------------------------------
1157 // Simplify an CmpD (compare 2 doubles ) node, based on local information.
1158 // If both inputs are constants, compare them.
1159 const Type* CmpDNode::Value(PhaseGVN* phase) const {
1160   const Node* in1 = in(1);
1161   const Node* in2 = in(2);
1162   // Either input is TOP ==&gt; the result is TOP
1163   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1164   if( t1 == Type::TOP ) return Type::TOP;
1165   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1166   if( t2 == Type::TOP ) return Type::TOP;
1167 
1168   // Not constants?  Don&#39;t know squat - even if they are the same
1169   // value!  If they are NaN&#39;s they compare to LT instead of EQ.
1170   const TypeD *td1 = t1-&gt;isa_double_constant();
1171   const TypeD *td2 = t2-&gt;isa_double_constant();
1172   if( !td1 || !td2 ) return TypeInt::CC;
1173 
1174   // This implements the Java bytecode dcmpl, so unordered returns -1.
1175   if( td1-&gt;is_nan() || td2-&gt;is_nan() )
1176     return TypeInt::CC_LT;
1177 
1178   if( td1-&gt;_d &lt; td2-&gt;_d ) return TypeInt::CC_LT;
1179   if( td1-&gt;_d &gt; td2-&gt;_d ) return TypeInt::CC_GT;
1180   assert( td1-&gt;_d == td2-&gt;_d, &quot;do not understand FP behavior&quot; );
1181   return TypeInt::CC_EQ;
1182 }
1183 
1184 //------------------------------Ideal------------------------------------------
1185 Node *CmpDNode::Ideal(PhaseGVN *phase, bool can_reshape){
1186   // Check if we can change this to a CmpF and remove a ConvD2F operation.
1187   // Change  (CMPD (F2D (float)) (ConD value))
1188   // To      (CMPF      (float)  (ConF value))
1189   // Valid when &#39;value&#39; does not lose precision as a float.
1190   // Benefits: eliminates conversion, does not require 24-bit mode
1191 
1192   // NaNs prevent commuting operands.  This transform works regardless of the
1193   // order of ConD and ConvF2D inputs by preserving the original order.
1194   int idx_f2d = 1;              // ConvF2D on left side?
1195   if( in(idx_f2d)-&gt;Opcode() != Op_ConvF2D )
1196     idx_f2d = 2;                // No, swap to check for reversed args
1197   int idx_con = 3-idx_f2d;      // Check for the constant on other input
1198 
1199   if( ConvertCmpD2CmpF &amp;&amp;
1200       in(idx_f2d)-&gt;Opcode() == Op_ConvF2D &amp;&amp;
1201       in(idx_con)-&gt;Opcode() == Op_ConD ) {
1202     const TypeD *t2 = in(idx_con)-&gt;bottom_type()-&gt;is_double_constant();
1203     double t2_value_as_double = t2-&gt;_d;
1204     float  t2_value_as_float  = (float)t2_value_as_double;
1205     if( t2_value_as_double == (double)t2_value_as_float ) {
1206       // Test value can be represented as a float
1207       // Eliminate the conversion to double and create new comparison
1208       Node *new_in1 = in(idx_f2d)-&gt;in(1);
1209       Node *new_in2 = phase-&gt;makecon( TypeF::make(t2_value_as_float) );
1210       if( idx_f2d != 1 ) {      // Must flip args to match original order
1211         Node *tmp = new_in1;
1212         new_in1 = new_in2;
1213         new_in2 = tmp;
1214       }
1215       CmpFNode *new_cmp = (Opcode() == Op_CmpD3)
1216         ? new CmpF3Node( new_in1, new_in2 )
1217         : new CmpFNode ( new_in1, new_in2 ) ;
1218       return new_cmp;           // Changed to CmpFNode
1219     }
1220     // Testing value required the precision of a double
1221   }
1222   return NULL;                  // No change
1223 }
1224 
1225 
1226 //=============================================================================
1227 //------------------------------cc2logical-------------------------------------
1228 // Convert a condition code type to a logical type
1229 const Type *BoolTest::cc2logical( const Type *CC ) const {
1230   if( CC == Type::TOP ) return Type::TOP;
1231   if( CC-&gt;base() != Type::Int ) return TypeInt::BOOL; // Bottom or worse
1232   const TypeInt *ti = CC-&gt;is_int();
1233   if( ti-&gt;is_con() ) {          // Only 1 kind of condition codes set?
1234     // Match low order 2 bits
1235     int tmp = ((ti-&gt;get_con()&amp;3) == (_test&amp;3)) ? 1 : 0;
1236     if( _test &amp; 4 ) tmp = 1-tmp;     // Optionally complement result
1237     return TypeInt::make(tmp);       // Boolean result
1238   }
1239 
1240   if( CC == TypeInt::CC_GE ) {
1241     if( _test == ge ) return TypeInt::ONE;
1242     if( _test == lt ) return TypeInt::ZERO;
1243   }
1244   if( CC == TypeInt::CC_LE ) {
1245     if( _test == le ) return TypeInt::ONE;
1246     if( _test == gt ) return TypeInt::ZERO;
1247   }
1248 
1249   return TypeInt::BOOL;
1250 }
1251 
1252 //------------------------------dump_spec-------------------------------------
1253 // Print special per-node info
1254 void BoolTest::dump_on(outputStream *st) const {
1255   const char *msg[] = {&quot;eq&quot;,&quot;gt&quot;,&quot;of&quot;,&quot;lt&quot;,&quot;ne&quot;,&quot;le&quot;,&quot;nof&quot;,&quot;ge&quot;};
1256   st-&gt;print(&quot;%s&quot;, msg[_test]);
1257 }
1258 
1259 // Returns the logical AND of two tests (or &#39;never&#39; if both tests can never be true).
1260 // For example, a test for &#39;le&#39; followed by a test for &#39;lt&#39; is equivalent with &#39;lt&#39;.
1261 BoolTest::mask BoolTest::merge(BoolTest other) const {
1262   const mask res[illegal+1][illegal+1] = {
1263     // eq,      gt,      of,      lt,      ne,      le,      nof,     ge,      never,   illegal
1264       {eq,      never,   illegal, never,   never,   eq,      illegal, eq,      never,   illegal},  // eq
1265       {never,   gt,      illegal, never,   gt,      never,   illegal, gt,      never,   illegal},  // gt
1266       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // of
1267       {never,   never,   illegal, lt,      lt,      lt,      illegal, never,   never,   illegal},  // lt
1268       {never,   gt,      illegal, lt,      ne,      lt,      illegal, gt,      never,   illegal},  // ne
1269       {eq,      never,   illegal, lt,      lt,      le,      illegal, eq,      never,   illegal},  // le
1270       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // nof
1271       {eq,      gt,      illegal, never,   gt,      eq,      illegal, ge,      never,   illegal},  // ge
1272       {never,   never,   never,   never,   never,   never,   never,   never,   never,   illegal},  // never
1273       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal}}; // illegal
1274   return res[_test][other._test];
1275 }
1276 
1277 //=============================================================================
1278 uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
1279 uint BoolNode::size_of() const { return sizeof(BoolNode); }
1280 
1281 //------------------------------operator==-------------------------------------
<a name="8" id="anc8"></a><span class="line-modified">1282 uint BoolNode::cmp( const Node &amp;n ) const {</span>
1283   const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
1284   return (_test._test == b-&gt;_test._test);
1285 }
1286 
1287 //-------------------------------make_predicate--------------------------------
1288 Node* BoolNode::make_predicate(Node* test_value, PhaseGVN* phase) {
1289   if (test_value-&gt;is_Con())   return test_value;
1290   if (test_value-&gt;is_Bool())  return test_value;
1291   if (test_value-&gt;is_CMove() &amp;&amp;
1292       test_value-&gt;in(CMoveNode::Condition)-&gt;is_Bool()) {
1293     BoolNode*   bol   = test_value-&gt;in(CMoveNode::Condition)-&gt;as_Bool();
1294     const Type* ftype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfFalse));
1295     const Type* ttype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfTrue));
1296     if (ftype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ttype)) {
1297       return bol;
1298     } else if (ttype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ftype)) {
1299       return phase-&gt;transform( bol-&gt;negate(phase) );
1300     }
1301     // Else fall through.  The CMove gets in the way of the test.
1302     // It should be the case that make_predicate(bol-&gt;as_int_value()) == bol.
1303   }
1304   Node* cmp = new CmpINode(test_value, phase-&gt;intcon(0));
1305   cmp = phase-&gt;transform(cmp);
1306   Node* bol = new BoolNode(cmp, BoolTest::ne);
1307   return phase-&gt;transform(bol);
1308 }
1309 
1310 //--------------------------------as_int_value---------------------------------
1311 Node* BoolNode::as_int_value(PhaseGVN* phase) {
1312   // Inverse to make_predicate.  The CMove probably boils down to a Conv2B.
1313   Node* cmov = CMoveNode::make(NULL, this,
1314                                phase-&gt;intcon(0), phase-&gt;intcon(1),
1315                                TypeInt::BOOL);
1316   return phase-&gt;transform(cmov);
1317 }
1318 
1319 //----------------------------------negate-------------------------------------
1320 BoolNode* BoolNode::negate(PhaseGVN* phase) {
1321   return new BoolNode(in(1), _test.negate());
1322 }
1323 
1324 // Change &quot;bool eq/ne (cmp (add/sub A B) C)&quot; into false/true if add/sub
1325 // overflows and we can prove that C is not in the two resulting ranges.
1326 // This optimization is similar to the one performed by CmpUNode::Value().
1327 Node* BoolNode::fold_cmpI(PhaseGVN* phase, SubNode* cmp, Node* cmp1, int cmp_op,
1328                           int cmp1_op, const TypeInt* cmp2_type) {
1329   // Only optimize eq/ne integer comparison of add/sub
1330   if((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1331      (cmp_op == Op_CmpI) &amp;&amp; (cmp1_op == Op_AddI || cmp1_op == Op_SubI)) {
1332     // Skip cases were inputs of add/sub are not integers or of bottom type
1333     const TypeInt* r0 = phase-&gt;type(cmp1-&gt;in(1))-&gt;isa_int();
1334     const TypeInt* r1 = phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_int();
1335     if ((r0 != NULL) &amp;&amp; (r0 != TypeInt::INT) &amp;&amp;
1336         (r1 != NULL) &amp;&amp; (r1 != TypeInt::INT) &amp;&amp;
1337         (cmp2_type != TypeInt::INT)) {
1338       // Compute exact (long) type range of add/sub result
1339       jlong lo_long = r0-&gt;_lo;
1340       jlong hi_long = r0-&gt;_hi;
1341       if (cmp1_op == Op_AddI) {
1342         lo_long += r1-&gt;_lo;
1343         hi_long += r1-&gt;_hi;
1344       } else {
1345         lo_long -= r1-&gt;_hi;
1346         hi_long -= r1-&gt;_lo;
1347       }
1348       // Check for over-/underflow by casting to integer
1349       int lo_int = (int)lo_long;
1350       int hi_int = (int)hi_long;
1351       bool underflow = lo_long != (jlong)lo_int;
1352       bool overflow  = hi_long != (jlong)hi_int;
1353       if ((underflow != overflow) &amp;&amp; (hi_int &lt; lo_int)) {
1354         // Overflow on one boundary, compute resulting type ranges:
1355         // tr1 [MIN_INT, hi_int] and tr2 [lo_int, MAX_INT]
1356         int w = MAX2(r0-&gt;_widen, r1-&gt;_widen); // _widen does not matter here
1357         const TypeInt* tr1 = TypeInt::make(min_jint, hi_int, w);
1358         const TypeInt* tr2 = TypeInt::make(lo_int, max_jint, w);
1359         // Compare second input of cmp to both type ranges
1360         const Type* sub_tr1 = cmp-&gt;sub(tr1, cmp2_type);
1361         const Type* sub_tr2 = cmp-&gt;sub(tr2, cmp2_type);
1362         if (sub_tr1 == TypeInt::CC_LT &amp;&amp; sub_tr2 == TypeInt::CC_GT) {
1363           // The result of the add/sub will never equal cmp2. Replace BoolNode
1364           // by false (0) if it tests for equality and by true (1) otherwise.
1365           return ConINode::make((_test._test == BoolTest::eq) ? 0 : 1);
1366         }
1367       }
1368     }
1369   }
1370   return NULL;
1371 }
1372 
1373 static bool is_counted_loop_cmp(Node *cmp) {
1374   Node *n = cmp-&gt;in(1)-&gt;in(1);
1375   return n != NULL &amp;&amp;
1376          n-&gt;is_Phi() &amp;&amp;
1377          n-&gt;in(0) != NULL &amp;&amp;
1378          n-&gt;in(0)-&gt;is_CountedLoop() &amp;&amp;
1379          n-&gt;in(0)-&gt;as_CountedLoop()-&gt;phi() == n;
1380 }
1381 
1382 //------------------------------Ideal------------------------------------------
1383 Node *BoolNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1384   // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
1385   // This moves the constant to the right.  Helps value-numbering.
1386   Node *cmp = in(1);
1387   if( !cmp-&gt;is_Sub() ) return NULL;
1388   int cop = cmp-&gt;Opcode();
<a name="9" id="anc9"></a><span class="line-modified">1389   if( cop == Op_FastLock || cop == Op_FastUnlock) return NULL;</span>
1390   Node *cmp1 = cmp-&gt;in(1);
1391   Node *cmp2 = cmp-&gt;in(2);
1392   if( !cmp1 ) return NULL;
1393 
1394   if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
1395     return NULL;
1396   }
1397 
1398   // Constant on left?
1399   Node *con = cmp1;
1400   uint op2 = cmp2-&gt;Opcode();
1401   // Move constants to the right of compare&#39;s to canonicalize.
1402   // Do not muck with Opaque1 nodes, as this indicates a loop
1403   // guard that cannot change shape.
1404   if( con-&gt;is_Con() &amp;&amp; !cmp2-&gt;is_Con() &amp;&amp; op2 != Op_Opaque1 &amp;&amp;
1405       // Because of NaN&#39;s, CmpD and CmpF are not commutative
1406       cop != Op_CmpD &amp;&amp; cop != Op_CmpF &amp;&amp;
1407       // Protect against swapping inputs to a compare when it is used by a
1408       // counted loop exit, which requires maintaining the loop-limit as in(2)
1409       !is_counted_loop_exit_test() ) {
1410     // Ok, commute the constant to the right of the cmp node.
1411     // Clone the Node, getting a new Node of the same class
1412     cmp = cmp-&gt;clone();
1413     // Swap inputs to the clone
1414     cmp-&gt;swap_edges(1, 2);
1415     cmp = phase-&gt;transform( cmp );
1416     return new BoolNode( cmp, _test.commute() );
1417   }
1418 
1419   // Change &quot;bool eq/ne (cmp (xor X 1) 0)&quot; into &quot;bool ne/eq (cmp X 0)&quot;.
1420   // The XOR-1 is an idiom used to flip the sense of a bool.  We flip the
1421   // test instead.
1422   int cmp1_op = cmp1-&gt;Opcode();
1423   const TypeInt* cmp2_type = phase-&gt;type(cmp2)-&gt;isa_int();
1424   if (cmp2_type == NULL)  return NULL;
1425   Node* j_xor = cmp1;
1426   if( cmp2_type == TypeInt::ZERO &amp;&amp;
1427       cmp1_op == Op_XorI &amp;&amp;
1428       j_xor-&gt;in(1) != j_xor &amp;&amp;          // An xor of itself is dead
1429       phase-&gt;type( j_xor-&gt;in(1) ) == TypeInt::BOOL &amp;&amp;
1430       phase-&gt;type( j_xor-&gt;in(2) ) == TypeInt::ONE &amp;&amp;
1431       (_test._test == BoolTest::eq ||
1432        _test._test == BoolTest::ne) ) {
1433     Node *ncmp = phase-&gt;transform(new CmpINode(j_xor-&gt;in(1),cmp2));
1434     return new BoolNode( ncmp, _test.negate() );
1435   }
1436 
1437   // Change ((x &amp; m) u&lt;= m) or ((m &amp; x) u&lt;= m) to always true
1438   // Same with ((x &amp; m) u&lt; m+1) and ((m &amp; x) u&lt; m+1)
1439   if (cop == Op_CmpU &amp;&amp;
1440       cmp1_op == Op_AndI) {
1441     Node* bound = NULL;
1442     if (_test._test == BoolTest::le) {
1443       bound = cmp2;
1444     } else if (_test._test == BoolTest::lt &amp;&amp;
1445                cmp2-&gt;Opcode() == Op_AddI &amp;&amp;
1446                cmp2-&gt;in(2)-&gt;find_int_con(0) == 1) {
1447       bound = cmp2-&gt;in(1);
1448     }
1449     if (cmp1-&gt;in(2) == bound || cmp1-&gt;in(1) == bound) {
1450       return ConINode::make(1);
1451     }
1452   }
1453 
1454   // Change ((x &amp; (m - 1)) u&lt; m) into (m &gt; 0)
1455   // This is the off-by-one variant of the above
1456   if (cop == Op_CmpU &amp;&amp;
1457       _test._test == BoolTest::lt &amp;&amp;
1458       cmp1_op == Op_AndI) {
1459     Node* l = cmp1-&gt;in(1);
1460     Node* r = cmp1-&gt;in(2);
1461     for (int repeat = 0; repeat &lt; 2; repeat++) {
1462       bool match = r-&gt;Opcode() == Op_AddI &amp;&amp; r-&gt;in(2)-&gt;find_int_con(0) == -1 &amp;&amp;
1463                    r-&gt;in(1) == cmp2;
1464       if (match) {
1465         // arraylength known to be non-negative, so a (arraylength != 0) is sufficient,
1466         // but to be compatible with the array range check pattern, use (arraylength u&gt; 0)
1467         Node* ncmp = cmp2-&gt;Opcode() == Op_LoadRange
1468                      ? phase-&gt;transform(new CmpUNode(cmp2, phase-&gt;intcon(0)))
1469                      : phase-&gt;transform(new CmpINode(cmp2, phase-&gt;intcon(0)));
1470         return new BoolNode(ncmp, BoolTest::gt);
1471       } else {
1472         // commute and try again
1473         l = cmp1-&gt;in(2);
1474         r = cmp1-&gt;in(1);
1475       }
1476     }
1477   }
1478 
1479   // Change x u&lt; 1 or x u&lt;= 0 to x == 0
1480   if (cop == Op_CmpU &amp;&amp;
1481       cmp1_op != Op_LoadRange &amp;&amp;
1482       ((_test._test == BoolTest::lt &amp;&amp;
1483         cmp2-&gt;find_int_con(-1) == 1) ||
1484        (_test._test == BoolTest::le &amp;&amp;
1485         cmp2-&gt;find_int_con(-1) == 0))) {
1486     Node* ncmp = phase-&gt;transform(new CmpINode(cmp1, phase-&gt;intcon(0)));
1487     return new BoolNode(ncmp, BoolTest::eq);
1488   }
1489 
1490   // Change (arraylength &lt;= 0) or (arraylength == 0)
1491   //   into (arraylength u&lt;= 0)
1492   // Also change (arraylength != 0) into (arraylength u&gt; 0)
1493   // The latter version matches the code pattern generated for
1494   // array range checks, which will more likely be optimized later.
1495   if (cop == Op_CmpI &amp;&amp;
1496       cmp1_op == Op_LoadRange &amp;&amp;
1497       cmp2-&gt;find_int_con(-1) == 0) {
1498     if (_test._test == BoolTest::le || _test._test == BoolTest::eq) {
1499       Node* ncmp = phase-&gt;transform(new CmpUNode(cmp1, cmp2));
1500       return new BoolNode(ncmp, BoolTest::le);
1501     } else if (_test._test == BoolTest::ne) {
1502       Node* ncmp = phase-&gt;transform(new CmpUNode(cmp1, cmp2));
1503       return new BoolNode(ncmp, BoolTest::gt);
1504     }
1505   }
1506 
1507   // Change &quot;bool eq/ne (cmp (Conv2B X) 0)&quot; into &quot;bool eq/ne (cmp X 0)&quot;.
1508   // This is a standard idiom for branching on a boolean value.
1509   Node *c2b = cmp1;
1510   if( cmp2_type == TypeInt::ZERO &amp;&amp;
1511       cmp1_op == Op_Conv2B &amp;&amp;
1512       (_test._test == BoolTest::eq ||
1513        _test._test == BoolTest::ne) ) {
1514     Node *ncmp = phase-&gt;transform(phase-&gt;type(c2b-&gt;in(1))-&gt;isa_int()
1515        ? (Node*)new CmpINode(c2b-&gt;in(1),cmp2)
1516        : (Node*)new CmpPNode(c2b-&gt;in(1),phase-&gt;makecon(TypePtr::NULL_PTR))
1517     );
1518     return new BoolNode( ncmp, _test._test );
1519   }
1520 
1521   // Comparing a SubI against a zero is equal to comparing the SubI
1522   // arguments directly.  This only works for eq and ne comparisons
1523   // due to possible integer overflow.
1524   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1525         (cop == Op_CmpI) &amp;&amp;
1526         (cmp1_op == Op_SubI) &amp;&amp;
1527         ( cmp2_type == TypeInt::ZERO ) ) {
1528     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(1),cmp1-&gt;in(2)));
1529     return new BoolNode( ncmp, _test._test );
1530   }
1531 
1532   // Same as above but with and AddI of a constant
1533   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1534       cop == Op_CmpI &amp;&amp;
1535       cmp1_op == Op_AddI &amp;&amp;
1536       cmp1-&gt;in(2) != NULL &amp;&amp;
1537       phase-&gt;type(cmp1-&gt;in(2))-&gt;isa_int() &amp;&amp;
1538       phase-&gt;type(cmp1-&gt;in(2))-&gt;is_int()-&gt;is_con() &amp;&amp;
1539       cmp2_type == TypeInt::ZERO &amp;&amp;
1540       !is_counted_loop_cmp(cmp) // modifying the exit test of a counted loop messes the counted loop shape
1541       ) {
1542     const TypeInt* cmp1_in2 = phase-&gt;type(cmp1-&gt;in(2))-&gt;is_int();
1543     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(1),phase-&gt;intcon(-cmp1_in2-&gt;_hi)));
1544     return new BoolNode( ncmp, _test._test );
1545   }
1546 
1547   // Change &quot;bool eq/ne (cmp (phi (X -X) 0))&quot; into &quot;bool eq/ne (cmp X 0)&quot;
1548   // since zero check of conditional negation of an integer is equal to
1549   // zero check of the integer directly.
1550   if ((_test._test == BoolTest::eq || _test._test == BoolTest::ne) &amp;&amp;
1551       (cop == Op_CmpI) &amp;&amp;
1552       (cmp2_type == TypeInt::ZERO) &amp;&amp;
1553       (cmp1_op == Op_Phi)) {
1554     // There should be a diamond phi with true path at index 1 or 2
1555     PhiNode *phi = cmp1-&gt;as_Phi();
1556     int idx_true = phi-&gt;is_diamond_phi();
1557     if (idx_true != 0) {
1558       // True input is in(idx_true) while false input is in(3 - idx_true)
1559       Node *tin = phi-&gt;in(idx_true);
1560       Node *fin = phi-&gt;in(3 - idx_true);
1561       if ((tin-&gt;Opcode() == Op_SubI) &amp;&amp;
1562           (phase-&gt;type(tin-&gt;in(1)) == TypeInt::ZERO) &amp;&amp;
1563           (tin-&gt;in(2) == fin)) {
1564         // Found conditional negation at true path, create a new CmpINode without that
1565         Node *ncmp = phase-&gt;transform(new CmpINode(fin, cmp2));
1566         return new BoolNode(ncmp, _test._test);
1567       }
1568       if ((fin-&gt;Opcode() == Op_SubI) &amp;&amp;
1569           (phase-&gt;type(fin-&gt;in(1)) == TypeInt::ZERO) &amp;&amp;
1570           (fin-&gt;in(2) == tin)) {
1571         // Found conditional negation at false path, create a new CmpINode without that
1572         Node *ncmp = phase-&gt;transform(new CmpINode(tin, cmp2));
1573         return new BoolNode(ncmp, _test._test);
1574       }
1575     }
1576   }
1577 
1578   // Change (-A vs 0) into (A vs 0) by commuting the test.  Disallow in the
1579   // most general case because negating 0x80000000 does nothing.  Needed for
1580   // the CmpF3/SubI/CmpI idiom.
1581   if( cop == Op_CmpI &amp;&amp;
1582       cmp1_op == Op_SubI &amp;&amp;
1583       cmp2_type == TypeInt::ZERO &amp;&amp;
1584       phase-&gt;type( cmp1-&gt;in(1) ) == TypeInt::ZERO &amp;&amp;
1585       phase-&gt;type( cmp1-&gt;in(2) )-&gt;higher_equal(TypeInt::SYMINT) ) {
1586     Node *ncmp = phase-&gt;transform( new CmpINode(cmp1-&gt;in(2),cmp2));
1587     return new BoolNode( ncmp, _test.commute() );
1588   }
1589 
1590   // Try to optimize signed integer comparison
1591   return fold_cmpI(phase, cmp-&gt;as_Sub(), cmp1, cop, cmp1_op, cmp2_type);
1592 
1593   //  The transformation below is not valid for either signed or unsigned
1594   //  comparisons due to wraparound concerns at MAX_VALUE and MIN_VALUE.
1595   //  This transformation can be resurrected when we are able to
1596   //  make inferences about the range of values being subtracted from
1597   //  (or added to) relative to the wraparound point.
1598   //
1599   //    // Remove +/-1&#39;s if possible.
1600   //    // &quot;X &lt;= Y-1&quot; becomes &quot;X &lt;  Y&quot;
1601   //    // &quot;X+1 &lt;= Y&quot; becomes &quot;X &lt;  Y&quot;
1602   //    // &quot;X &lt;  Y+1&quot; becomes &quot;X &lt;= Y&quot;
1603   //    // &quot;X-1 &lt;  Y&quot; becomes &quot;X &lt;= Y&quot;
1604   //    // Do not this to compares off of the counted-loop-end.  These guys are
1605   //    // checking the trip counter and they want to use the post-incremented
1606   //    // counter.  If they use the PRE-incremented counter, then the counter has
1607   //    // to be incremented in a private block on a loop backedge.
1608   //    if( du &amp;&amp; du-&gt;cnt(this) &amp;&amp; du-&gt;out(this)[0]-&gt;Opcode() == Op_CountedLoopEnd )
1609   //      return NULL;
1610   //  #ifndef PRODUCT
1611   //    // Do not do this in a wash GVN pass during verification.
1612   //    // Gets triggered by too many simple optimizations to be bothered with
1613   //    // re-trying it again and again.
1614   //    if( !phase-&gt;allow_progress() ) return NULL;
1615   //  #endif
1616   //    // Not valid for unsigned compare because of corner cases in involving zero.
1617   //    // For example, replacing &quot;X-1 &lt;u Y&quot; with &quot;X &lt;=u Y&quot; fails to throw an
1618   //    // exception in case X is 0 (because 0-1 turns into 4billion unsigned but
1619   //    // &quot;0 &lt;=u Y&quot; is always true).
1620   //    if( cmp-&gt;Opcode() == Op_CmpU ) return NULL;
1621   //    int cmp2_op = cmp2-&gt;Opcode();
1622   //    if( _test._test == BoolTest::le ) {
1623   //      if( cmp1_op == Op_AddI &amp;&amp;
1624   //          phase-&gt;type( cmp1-&gt;in(2) ) == TypeInt::ONE )
1625   //        return clone_cmp( cmp, cmp1-&gt;in(1), cmp2, phase, BoolTest::lt );
1626   //      else if( cmp2_op == Op_AddI &amp;&amp;
1627   //         phase-&gt;type( cmp2-&gt;in(2) ) == TypeInt::MINUS_1 )
1628   //        return clone_cmp( cmp, cmp1, cmp2-&gt;in(1), phase, BoolTest::lt );
1629   //    } else if( _test._test == BoolTest::lt ) {
1630   //      if( cmp1_op == Op_AddI &amp;&amp;
1631   //          phase-&gt;type( cmp1-&gt;in(2) ) == TypeInt::MINUS_1 )
1632   //        return clone_cmp( cmp, cmp1-&gt;in(1), cmp2, phase, BoolTest::le );
1633   //      else if( cmp2_op == Op_AddI &amp;&amp;
1634   //         phase-&gt;type( cmp2-&gt;in(2) ) == TypeInt::ONE )
1635   //        return clone_cmp( cmp, cmp1, cmp2-&gt;in(1), phase, BoolTest::le );
1636   //    }
1637 }
1638 
1639 //------------------------------Value------------------------------------------
1640 // Simplify a Bool (convert condition codes to boolean (1 or 0)) node,
1641 // based on local information.   If the input is constant, do it.
1642 const Type* BoolNode::Value(PhaseGVN* phase) const {
1643   return _test.cc2logical( phase-&gt;type( in(1) ) );
1644 }
1645 
1646 #ifndef PRODUCT
1647 //------------------------------dump_spec--------------------------------------
1648 // Dump special per-node info
1649 void BoolNode::dump_spec(outputStream *st) const {
1650   st-&gt;print(&quot;[&quot;);
1651   _test.dump_on(st);
1652   st-&gt;print(&quot;]&quot;);
1653 }
1654 
1655 //-------------------------------related---------------------------------------
1656 // A BoolNode&#39;s related nodes are all of its data inputs, and all of its
1657 // outputs until control nodes are hit, which are included. In compact
1658 // representation, inputs till level 3 and immediate outputs are included.
1659 void BoolNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1660   if (compact) {
1661     this-&gt;collect_nodes(in_rel, 3, false, true);
1662     this-&gt;collect_nodes(out_rel, -1, false, false);
1663   } else {
1664     this-&gt;collect_nodes_in_all_data(in_rel, false);
1665     this-&gt;collect_nodes_out_all_ctrl_boundary(out_rel);
1666   }
1667 }
1668 #endif
1669 
1670 //----------------------is_counted_loop_exit_test------------------------------
1671 // Returns true if node is used by a counted loop node.
1672 bool BoolNode::is_counted_loop_exit_test() {
1673   for( DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++ ) {
1674     Node* use = fast_out(i);
1675     if (use-&gt;is_CountedLoopEnd()) {
1676       return true;
1677     }
1678   }
1679   return false;
1680 }
1681 
1682 //=============================================================================
1683 //------------------------------Value------------------------------------------
1684 // Compute sqrt
1685 const Type* SqrtDNode::Value(PhaseGVN* phase) const {
1686   const Type *t1 = phase-&gt;type( in(1) );
1687   if( t1 == Type::TOP ) return Type::TOP;
1688   if( t1-&gt;base() != Type::DoubleCon ) return Type::DOUBLE;
1689   double d = t1-&gt;getd();
1690   if( d &lt; 0.0 ) return Type::DOUBLE;
1691   return TypeD::make( sqrt( d ) );
1692 }
1693 
1694 const Type* SqrtFNode::Value(PhaseGVN* phase) const {
1695   const Type *t1 = phase-&gt;type( in(1) );
1696   if( t1 == Type::TOP ) return Type::TOP;
1697   if( t1-&gt;base() != Type::FloatCon ) return Type::FLOAT;
1698   float f = t1-&gt;getf();
1699   if( f &lt; 0.0f ) return Type::FLOAT;
1700   return TypeF::make( (float)sqrt( (double)f ) );
1701 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/subnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  97 
  98   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
  99   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 100     return bottom_type();
 101 
 102   return NULL;
 103 }
 104 
 105 const Type* SubNode::Value(PhaseGVN* phase) const {
 106   const Type* t = Value_common(phase);
 107   if (t != NULL) {
 108     return t;
 109   }
 110   const Type* t1 = phase-&gt;type(in(1));
 111   const Type* t2 = phase-&gt;type(in(2));
 112   return sub(t1,t2);            // Local flavor of type subtraction
 113 
 114 }
 115 
 116 //=============================================================================
<span class="line-removed"> 117 </span>
 118 //------------------------------Helper function--------------------------------
<span class="line-modified"> 119 static bool ok_to_convert(Node* inc, Node* iv) {</span>
<span class="line-modified"> 120     // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment, because the</span>
<span class="line-modified"> 121     // &quot;-&quot; is loop invariant and collapsing extends the live-range of &quot;x&quot;</span>
<span class="line-modified"> 122     // to overlap with the &quot;+&quot;, forcing another register to be used in</span>
<span class="line-modified"> 123     // the loop.</span>
<span class="line-modified"> 124     // This test will be clearer with &#39;&amp;&amp;&#39; (apply DeMorgan&#39;s rule)</span>
<span class="line-modified"> 125     // but I like the early cutouts that happen here.</span>
<span class="line-modified"> 126     const PhiNode *phi;</span>
<span class="line-modified"> 127     if( ( !inc-&gt;in(1)-&gt;is_Phi() ||</span>
<span class="line-modified"> 128           !(phi=inc-&gt;in(1)-&gt;as_Phi()) ||</span>
<span class="line-modified"> 129           phi-&gt;is_copy() ||</span>
<span class="line-modified"> 130           !phi-&gt;region()-&gt;is_CountedLoop() ||</span>
<span class="line-modified"> 131           inc != phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr() )</span>
<span class="line-modified"> 132        &amp;&amp;</span>
<span class="line-removed"> 133         // Do not collapse (x+c0)-iv if &quot;iv&quot; is a loop induction variable,</span>
<span class="line-removed"> 134         // because &quot;x&quot; maybe invariant.</span>
<span class="line-removed"> 135         ( !iv-&gt;is_loop_iv() )</span>
<span class="line-removed"> 136       ) {</span>
<span class="line-removed"> 137       return true;</span>
<span class="line-removed"> 138     } else {</span>
<span class="line-removed"> 139       return false;</span>
<span class="line-removed"> 140     }</span>
 141 }















 142 //------------------------------Ideal------------------------------------------
 143 Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
 144   Node *in1 = in(1);
 145   Node *in2 = in(2);
 146   uint op1 = in1-&gt;Opcode();
 147   uint op2 = in2-&gt;Opcode();
 148 
 149 #ifdef ASSERT
 150   // Check for dead loop
 151   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 152       ( ( op1 == Op_AddI || op1 == Op_SubI ) &amp;&amp;
 153         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 154           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1 ) ) ) )
 155     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 156 #endif
 157 
 158   const Type *t2 = phase-&gt;type( in2 );
 159   if( t2 == Type::TOP ) return NULL;
 160   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 161   if( t2-&gt;base() == Type::Int ){        // Might be bottom or top...
</pre>
<hr />
<pre>
 796 
 797 //=============================================================================
 798 //------------------------------sub--------------------------------------------
 799 // Simplify an CmpP (compare 2 pointers) node, based on local information.
 800 // If both inputs are constants, compare them.
 801 const Type *CmpPNode::sub( const Type *t1, const Type *t2 ) const {
 802   const TypePtr *r0 = t1-&gt;is_ptr(); // Handy access
 803   const TypePtr *r1 = t2-&gt;is_ptr();
 804 
 805   // Undefined inputs makes for an undefined result
 806   if( TypePtr::above_centerline(r0-&gt;_ptr) ||
 807       TypePtr::above_centerline(r1-&gt;_ptr) )
 808     return Type::TOP;
 809 
 810   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {
 811     // Equal pointer constants (klasses, nulls, etc.)
 812     return TypeInt::CC_EQ;
 813   }
 814 
 815   // See if it is 2 unrelated classes.
<span class="line-modified"> 816   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-modified"> 817   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-modified"> 818   if (p0 &amp;&amp; p1) {</span>


 819     Node* in1 = in(1)-&gt;uncast();
 820     Node* in2 = in(2)-&gt;uncast();
 821     AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
 822     AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
 823     if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
 824       return TypeInt::CC_GT;  // different pointers
 825     }
<span class="line-modified"> 826     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-modified"> 827     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-modified"> 828     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-modified"> 829     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-modified"> 830     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
























 831     if (klass0 &amp;&amp; klass1 &amp;&amp;
<span class="line-removed"> 832         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
 833         klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
 834         klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
 835         (!klass0-&gt;is_obj_array_klass() ||
 836          !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
 837         (!klass1-&gt;is_obj_array_klass() ||
 838          !klass1-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface())) {
 839       bool unrelated_classes = false;
 840       // See if neither subclasses the other, or if the class on top
 841       // is precise.  In either of these cases, the compare is known
 842       // to fail if at least one of the pointers is provably not null.
 843       if (klass0-&gt;equals(klass1)) {  // if types are unequal but klasses are equal
 844         // Do nothing; we know nothing for imprecise types
 845       } else if (klass0-&gt;is_subtype_of(klass1)) {
 846         // If klass1&#39;s type is PRECISE, then classes are unrelated.
 847         unrelated_classes = xklass1;
 848       } else if (klass1-&gt;is_subtype_of(klass0)) {
 849         // If klass0&#39;s type is PRECISE, then classes are unrelated.
 850         unrelated_classes = xklass0;
 851       } else {                  // Neither subtypes the other
 852         unrelated_classes = true;
</pre>
<hr />
<pre>
1031   if (superklass-&gt;is_instance_klass()) {
1032     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1033     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1034     // Add a dependency if there is a chance that a subclass will be added later.
1035     if (!ik-&gt;is_final()) {
1036       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
1037     }
1038   }
1039 
1040   // Bypass the dependent load, and compare directly
1041   this-&gt;set_req(1,ldk2);
1042 
1043   return this;
1044 }
1045 
1046 //=============================================================================
1047 //------------------------------sub--------------------------------------------
1048 // Simplify an CmpN (compare 2 pointers) node, based on local information.
1049 // If both inputs are constants, compare them.
1050 const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
<span class="line-modified">1051   const TypePtr *r0 = t1-&gt;make_ptr(); // Handy access</span>
<span class="line-modified">1052   const TypePtr *r1 = t2-&gt;make_ptr();</span>
<span class="line-removed">1053 </span>
<span class="line-removed">1054   // Undefined inputs makes for an undefined result</span>
<span class="line-removed">1055   if ((r0 == NULL) || (r1 == NULL) ||</span>
<span class="line-removed">1056       TypePtr::above_centerline(r0-&gt;_ptr) ||</span>
<span class="line-removed">1057       TypePtr::above_centerline(r1-&gt;_ptr)) {</span>
<span class="line-removed">1058     return Type::TOP;</span>
<span class="line-removed">1059   }</span>
<span class="line-removed">1060   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {</span>
<span class="line-removed">1061     // Equal pointer constants (klasses, nulls, etc.)</span>
<span class="line-removed">1062     return TypeInt::CC_EQ;</span>
<span class="line-removed">1063   }</span>
<span class="line-removed">1064 </span>
<span class="line-removed">1065   // See if it is 2 unrelated classes.</span>
<span class="line-removed">1066   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-removed">1067   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-removed">1068   if (p0 &amp;&amp; p1) {</span>
<span class="line-removed">1069     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-removed">1070     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-removed">1071     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-removed">1072     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-removed">1073     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
<span class="line-removed">1074     if (klass0 &amp;&amp; klass1 &amp;&amp;</span>
<span class="line-removed">1075         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
<span class="line-removed">1076         !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces</span>
<span class="line-removed">1077         !klass1-&gt;is_interface()) {</span>
<span class="line-removed">1078       bool unrelated_classes = false;</span>
<span class="line-removed">1079       // See if neither subclasses the other, or if the class on top</span>
<span class="line-removed">1080       // is precise.  In either of these cases, the compare is known</span>
<span class="line-removed">1081       // to fail if at least one of the pointers is provably not null.</span>
<span class="line-removed">1082       if (klass0-&gt;equals(klass1)) { // if types are unequal but klasses are equal</span>
<span class="line-removed">1083         // Do nothing; we know nothing for imprecise types</span>
<span class="line-removed">1084       } else if (klass0-&gt;is_subtype_of(klass1)) {</span>
<span class="line-removed">1085         // If klass1&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">1086         unrelated_classes = xklass1;</span>
<span class="line-removed">1087       } else if (klass1-&gt;is_subtype_of(klass0)) {</span>
<span class="line-removed">1088         // If klass0&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">1089         unrelated_classes = xklass0;</span>
<span class="line-removed">1090       } else {                  // Neither subtypes the other</span>
<span class="line-removed">1091         unrelated_classes = true;</span>
<span class="line-removed">1092       }</span>
<span class="line-removed">1093       if (unrelated_classes) {</span>
<span class="line-removed">1094         // The oops classes are known to be unrelated. If the joined PTRs of</span>
<span class="line-removed">1095         // two oops is not Null and not Bottom, then we are sure that one</span>
<span class="line-removed">1096         // of the two oops is non-null, and the comparison will always fail.</span>
<span class="line-removed">1097         TypePtr::PTR jp = r0-&gt;join_ptr(r1-&gt;_ptr);</span>
<span class="line-removed">1098         if (jp != TypePtr::Null &amp;&amp; jp != TypePtr::BotPTR) {</span>
<span class="line-removed">1099           return TypeInt::CC_GT;</span>
<span class="line-removed">1100         }</span>
<span class="line-removed">1101       }</span>
<span class="line-removed">1102     }</span>
<span class="line-removed">1103   }</span>
<span class="line-removed">1104 </span>
<span class="line-removed">1105   // Known constants can be compared exactly</span>
<span class="line-removed">1106   // Null can be distinguished from any NotNull pointers</span>
<span class="line-removed">1107   // Unknown inputs makes an unknown result</span>
<span class="line-removed">1108   if( r0-&gt;singleton() ) {</span>
<span class="line-removed">1109     intptr_t bits0 = r0-&gt;get_con();</span>
<span class="line-removed">1110     if( r1-&gt;singleton() )</span>
<span class="line-removed">1111       return bits0 == r1-&gt;get_con() ? TypeInt::CC_EQ : TypeInt::CC_GT;</span>
<span class="line-removed">1112     return ( r1-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits0==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">1113   } else if( r1-&gt;singleton() ) {</span>
<span class="line-removed">1114     intptr_t bits1 = r1-&gt;get_con();</span>
<span class="line-removed">1115     return ( r0-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits1==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">1116   } else</span>
<span class="line-removed">1117     return TypeInt::CC;</span>
1118 }
1119 
1120 //------------------------------Ideal------------------------------------------
1121 Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
1122   return NULL;
1123 }
1124 
1125 //=============================================================================
1126 //------------------------------Value------------------------------------------
1127 // Simplify an CmpF (compare 2 floats ) node, based on local information.
1128 // If both inputs are constants, compare them.
1129 const Type* CmpFNode::Value(PhaseGVN* phase) const {
1130   const Node* in1 = in(1);
1131   const Node* in2 = in(2);
1132   // Either input is TOP ==&gt; the result is TOP
1133   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1134   if( t1 == Type::TOP ) return Type::TOP;
1135   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1136   if( t2 == Type::TOP ) return Type::TOP;
1137 
</pre>
<hr />
<pre>
1262   const mask res[illegal+1][illegal+1] = {
1263     // eq,      gt,      of,      lt,      ne,      le,      nof,     ge,      never,   illegal
1264       {eq,      never,   illegal, never,   never,   eq,      illegal, eq,      never,   illegal},  // eq
1265       {never,   gt,      illegal, never,   gt,      never,   illegal, gt,      never,   illegal},  // gt
1266       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // of
1267       {never,   never,   illegal, lt,      lt,      lt,      illegal, never,   never,   illegal},  // lt
1268       {never,   gt,      illegal, lt,      ne,      lt,      illegal, gt,      never,   illegal},  // ne
1269       {eq,      never,   illegal, lt,      lt,      le,      illegal, eq,      never,   illegal},  // le
1270       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // nof
1271       {eq,      gt,      illegal, never,   gt,      eq,      illegal, ge,      never,   illegal},  // ge
1272       {never,   never,   never,   never,   never,   never,   never,   never,   never,   illegal},  // never
1273       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal}}; // illegal
1274   return res[_test][other._test];
1275 }
1276 
1277 //=============================================================================
1278 uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
1279 uint BoolNode::size_of() const { return sizeof(BoolNode); }
1280 
1281 //------------------------------operator==-------------------------------------
<span class="line-modified">1282 uint BoolNode::cmp( const Node &amp;n ) const {</span>
1283   const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
1284   return (_test._test == b-&gt;_test._test);
1285 }
1286 
1287 //-------------------------------make_predicate--------------------------------
1288 Node* BoolNode::make_predicate(Node* test_value, PhaseGVN* phase) {
1289   if (test_value-&gt;is_Con())   return test_value;
1290   if (test_value-&gt;is_Bool())  return test_value;
1291   if (test_value-&gt;is_CMove() &amp;&amp;
1292       test_value-&gt;in(CMoveNode::Condition)-&gt;is_Bool()) {
1293     BoolNode*   bol   = test_value-&gt;in(CMoveNode::Condition)-&gt;as_Bool();
1294     const Type* ftype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfFalse));
1295     const Type* ttype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfTrue));
1296     if (ftype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ttype)) {
1297       return bol;
1298     } else if (ttype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ftype)) {
1299       return phase-&gt;transform( bol-&gt;negate(phase) );
1300     }
1301     // Else fall through.  The CMove gets in the way of the test.
1302     // It should be the case that make_predicate(bol-&gt;as_int_value()) == bol.
</pre>
<hr />
<pre>
1369   }
1370   return NULL;
1371 }
1372 
1373 static bool is_counted_loop_cmp(Node *cmp) {
1374   Node *n = cmp-&gt;in(1)-&gt;in(1);
1375   return n != NULL &amp;&amp;
1376          n-&gt;is_Phi() &amp;&amp;
1377          n-&gt;in(0) != NULL &amp;&amp;
1378          n-&gt;in(0)-&gt;is_CountedLoop() &amp;&amp;
1379          n-&gt;in(0)-&gt;as_CountedLoop()-&gt;phi() == n;
1380 }
1381 
1382 //------------------------------Ideal------------------------------------------
1383 Node *BoolNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1384   // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
1385   // This moves the constant to the right.  Helps value-numbering.
1386   Node *cmp = in(1);
1387   if( !cmp-&gt;is_Sub() ) return NULL;
1388   int cop = cmp-&gt;Opcode();
<span class="line-modified">1389   if( cop == Op_FastLock || cop == Op_FastUnlock) return NULL;</span>
1390   Node *cmp1 = cmp-&gt;in(1);
1391   Node *cmp2 = cmp-&gt;in(2);
1392   if( !cmp1 ) return NULL;
1393 
1394   if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
1395     return NULL;
1396   }
1397 
1398   // Constant on left?
1399   Node *con = cmp1;
1400   uint op2 = cmp2-&gt;Opcode();
1401   // Move constants to the right of compare&#39;s to canonicalize.
1402   // Do not muck with Opaque1 nodes, as this indicates a loop
1403   // guard that cannot change shape.
1404   if( con-&gt;is_Con() &amp;&amp; !cmp2-&gt;is_Con() &amp;&amp; op2 != Op_Opaque1 &amp;&amp;
1405       // Because of NaN&#39;s, CmpD and CmpF are not commutative
1406       cop != Op_CmpD &amp;&amp; cop != Op_CmpF &amp;&amp;
1407       // Protect against swapping inputs to a compare when it is used by a
1408       // counted loop exit, which requires maintaining the loop-limit as in(2)
1409       !is_counted_loop_exit_test() ) {
</pre>
</td>
<td>
<hr />
<pre>
  97 
  98   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
  99   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 100     return bottom_type();
 101 
 102   return NULL;
 103 }
 104 
 105 const Type* SubNode::Value(PhaseGVN* phase) const {
 106   const Type* t = Value_common(phase);
 107   if (t != NULL) {
 108     return t;
 109   }
 110   const Type* t1 = phase-&gt;type(in(1));
 111   const Type* t2 = phase-&gt;type(in(2));
 112   return sub(t1,t2);            // Local flavor of type subtraction
 113 
 114 }
 115 
 116 //=============================================================================

 117 //------------------------------Helper function--------------------------------
<span class="line-modified"> 118 </span>
<span class="line-modified"> 119 static bool is_cloop_increment(Node* inc) {</span>
<span class="line-modified"> 120   precond(inc-&gt;Opcode() == Op_AddI || inc-&gt;Opcode() == Op_AddL);</span>
<span class="line-modified"> 121 </span>
<span class="line-modified"> 122   if (!inc-&gt;in(1)-&gt;is_Phi()) {</span>
<span class="line-modified"> 123     return false;</span>
<span class="line-modified"> 124   }</span>
<span class="line-modified"> 125   const PhiNode* phi = inc-&gt;in(1)-&gt;as_Phi();</span>
<span class="line-modified"> 126 </span>
<span class="line-modified"> 127   if (phi-&gt;is_copy() || !phi-&gt;region()-&gt;is_CountedLoop()) {</span>
<span class="line-modified"> 128     return false;</span>
<span class="line-modified"> 129   }</span>
<span class="line-modified"> 130 </span>
<span class="line-modified"> 131   return inc == phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr();</span>








 132 }
<span class="line-added"> 133 </span>
<span class="line-added"> 134 // Given the expression &#39;(x + C) - v&#39;, or</span>
<span class="line-added"> 135 //                      &#39;v - (x + C)&#39;, we examine nodes &#39;+&#39; and &#39;v&#39;:</span>
<span class="line-added"> 136 //</span>
<span class="line-added"> 137 //  1. Do not convert if &#39;+&#39; is a counted-loop increment, because the &#39;-&#39; is</span>
<span class="line-added"> 138 //     loop invariant and converting extends the live-range of &#39;x&#39; to overlap</span>
<span class="line-added"> 139 //     with the &#39;+&#39;, forcing another register to be used in the loop.</span>
<span class="line-added"> 140 //</span>
<span class="line-added"> 141 //  2. Do not convert if &#39;v&#39; is a counted-loop induction variable, because</span>
<span class="line-added"> 142 //     &#39;x&#39; might be invariant.</span>
<span class="line-added"> 143 //</span>
<span class="line-added"> 144 static bool ok_to_convert(Node* inc, Node* var) {</span>
<span class="line-added"> 145   return !(is_cloop_increment(inc) || var-&gt;is_cloop_ind_var());</span>
<span class="line-added"> 146 }</span>
<span class="line-added"> 147 </span>
 148 //------------------------------Ideal------------------------------------------
 149 Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
 150   Node *in1 = in(1);
 151   Node *in2 = in(2);
 152   uint op1 = in1-&gt;Opcode();
 153   uint op2 = in2-&gt;Opcode();
 154 
 155 #ifdef ASSERT
 156   // Check for dead loop
 157   if( phase-&gt;eqv( in1, this ) || phase-&gt;eqv( in2, this ) ||
 158       ( ( op1 == Op_AddI || op1 == Op_SubI ) &amp;&amp;
 159         ( phase-&gt;eqv( in1-&gt;in(1), this ) || phase-&gt;eqv( in1-&gt;in(2), this ) ||
 160           phase-&gt;eqv( in1-&gt;in(1), in1  ) || phase-&gt;eqv( in1-&gt;in(2), in1 ) ) ) )
 161     assert(false, &quot;dead loop in SubINode::Ideal&quot;);
 162 #endif
 163 
 164   const Type *t2 = phase-&gt;type( in2 );
 165   if( t2 == Type::TOP ) return NULL;
 166   // Convert &quot;x-c0&quot; into &quot;x+ -c0&quot;.
 167   if( t2-&gt;base() == Type::Int ){        // Might be bottom or top...
</pre>
<hr />
<pre>
 802 
 803 //=============================================================================
 804 //------------------------------sub--------------------------------------------
 805 // Simplify an CmpP (compare 2 pointers) node, based on local information.
 806 // If both inputs are constants, compare them.
 807 const Type *CmpPNode::sub( const Type *t1, const Type *t2 ) const {
 808   const TypePtr *r0 = t1-&gt;is_ptr(); // Handy access
 809   const TypePtr *r1 = t2-&gt;is_ptr();
 810 
 811   // Undefined inputs makes for an undefined result
 812   if( TypePtr::above_centerline(r0-&gt;_ptr) ||
 813       TypePtr::above_centerline(r1-&gt;_ptr) )
 814     return Type::TOP;
 815 
 816   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {
 817     // Equal pointer constants (klasses, nulls, etc.)
 818     return TypeInt::CC_EQ;
 819   }
 820 
 821   // See if it is 2 unrelated classes.
<span class="line-modified"> 822   const TypeOopPtr* oop_p0 = r0-&gt;isa_oopptr();</span>
<span class="line-modified"> 823   const TypeOopPtr* oop_p1 = r1-&gt;isa_oopptr();</span>
<span class="line-modified"> 824   bool both_oop_ptr = oop_p0 &amp;&amp; oop_p1;</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826   if (both_oop_ptr) {</span>
 827     Node* in1 = in(1)-&gt;uncast();
 828     Node* in2 = in(2)-&gt;uncast();
 829     AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
 830     AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
 831     if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
 832       return TypeInt::CC_GT;  // different pointers
 833     }
<span class="line-modified"> 834   }</span>
<span class="line-modified"> 835 </span>
<span class="line-modified"> 836   const TypeKlassPtr* klass_p0 = r0-&gt;isa_klassptr();</span>
<span class="line-modified"> 837   const TypeKlassPtr* klass_p1 = r1-&gt;isa_klassptr();</span>
<span class="line-modified"> 838 </span>
<span class="line-added"> 839   if (both_oop_ptr || (klass_p0 &amp;&amp; klass_p1)) { // both or neither are klass pointers</span>
<span class="line-added"> 840     ciKlass* klass0 = NULL;</span>
<span class="line-added"> 841     bool    xklass0 = false;</span>
<span class="line-added"> 842     ciKlass* klass1 = NULL;</span>
<span class="line-added"> 843     bool    xklass1 = false;</span>
<span class="line-added"> 844 </span>
<span class="line-added"> 845     if (oop_p0) {</span>
<span class="line-added"> 846       klass0 = oop_p0-&gt;klass();</span>
<span class="line-added"> 847       xklass0 = oop_p0-&gt;klass_is_exact();</span>
<span class="line-added"> 848     } else {</span>
<span class="line-added"> 849       assert(klass_p0, &quot;must be non-null if oop_p0 is null&quot;);</span>
<span class="line-added"> 850       klass0 = klass_p0-&gt;klass();</span>
<span class="line-added"> 851       xklass0 = klass_p0-&gt;klass_is_exact();</span>
<span class="line-added"> 852     }</span>
<span class="line-added"> 853 </span>
<span class="line-added"> 854     if (oop_p1) {</span>
<span class="line-added"> 855       klass1 = oop_p1-&gt;klass();</span>
<span class="line-added"> 856       xklass1 = oop_p1-&gt;klass_is_exact();</span>
<span class="line-added"> 857     } else {</span>
<span class="line-added"> 858       assert(klass_p1, &quot;must be non-null if oop_p1 is null&quot;);</span>
<span class="line-added"> 859       klass1 = klass_p1-&gt;klass();</span>
<span class="line-added"> 860       xklass1 = klass_p1-&gt;klass_is_exact();</span>
<span class="line-added"> 861     }</span>
<span class="line-added"> 862 </span>
 863     if (klass0 &amp;&amp; klass1 &amp;&amp;

 864         klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
 865         klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
 866         (!klass0-&gt;is_obj_array_klass() ||
 867          !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
 868         (!klass1-&gt;is_obj_array_klass() ||
 869          !klass1-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface())) {
 870       bool unrelated_classes = false;
 871       // See if neither subclasses the other, or if the class on top
 872       // is precise.  In either of these cases, the compare is known
 873       // to fail if at least one of the pointers is provably not null.
 874       if (klass0-&gt;equals(klass1)) {  // if types are unequal but klasses are equal
 875         // Do nothing; we know nothing for imprecise types
 876       } else if (klass0-&gt;is_subtype_of(klass1)) {
 877         // If klass1&#39;s type is PRECISE, then classes are unrelated.
 878         unrelated_classes = xklass1;
 879       } else if (klass1-&gt;is_subtype_of(klass0)) {
 880         // If klass0&#39;s type is PRECISE, then classes are unrelated.
 881         unrelated_classes = xklass0;
 882       } else {                  // Neither subtypes the other
 883         unrelated_classes = true;
</pre>
<hr />
<pre>
1062   if (superklass-&gt;is_instance_klass()) {
1063     ciInstanceKlass* ik = superklass-&gt;as_instance_klass();
1064     if (ik-&gt;has_subklass() || ik-&gt;is_interface())  return NULL;
1065     // Add a dependency if there is a chance that a subclass will be added later.
1066     if (!ik-&gt;is_final()) {
1067       phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
1068     }
1069   }
1070 
1071   // Bypass the dependent load, and compare directly
1072   this-&gt;set_req(1,ldk2);
1073 
1074   return this;
1075 }
1076 
1077 //=============================================================================
1078 //------------------------------sub--------------------------------------------
1079 // Simplify an CmpN (compare 2 pointers) node, based on local information.
1080 // If both inputs are constants, compare them.
1081 const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
<span class="line-modified">1082   ShouldNotReachHere();</span>
<span class="line-modified">1083   return bottom_type();</span>

































































1084 }
1085 
1086 //------------------------------Ideal------------------------------------------
1087 Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
1088   return NULL;
1089 }
1090 
1091 //=============================================================================
1092 //------------------------------Value------------------------------------------
1093 // Simplify an CmpF (compare 2 floats ) node, based on local information.
1094 // If both inputs are constants, compare them.
1095 const Type* CmpFNode::Value(PhaseGVN* phase) const {
1096   const Node* in1 = in(1);
1097   const Node* in2 = in(2);
1098   // Either input is TOP ==&gt; the result is TOP
1099   const Type* t1 = (in1 == this) ? Type::TOP : phase-&gt;type(in1);
1100   if( t1 == Type::TOP ) return Type::TOP;
1101   const Type* t2 = (in2 == this) ? Type::TOP : phase-&gt;type(in2);
1102   if( t2 == Type::TOP ) return Type::TOP;
1103 
</pre>
<hr />
<pre>
1228   const mask res[illegal+1][illegal+1] = {
1229     // eq,      gt,      of,      lt,      ne,      le,      nof,     ge,      never,   illegal
1230       {eq,      never,   illegal, never,   never,   eq,      illegal, eq,      never,   illegal},  // eq
1231       {never,   gt,      illegal, never,   gt,      never,   illegal, gt,      never,   illegal},  // gt
1232       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // of
1233       {never,   never,   illegal, lt,      lt,      lt,      illegal, never,   never,   illegal},  // lt
1234       {never,   gt,      illegal, lt,      ne,      lt,      illegal, gt,      never,   illegal},  // ne
1235       {eq,      never,   illegal, lt,      lt,      le,      illegal, eq,      never,   illegal},  // le
1236       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, never,   illegal},  // nof
1237       {eq,      gt,      illegal, never,   gt,      eq,      illegal, ge,      never,   illegal},  // ge
1238       {never,   never,   never,   never,   never,   never,   never,   never,   never,   illegal},  // never
1239       {illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal, illegal}}; // illegal
1240   return res[_test][other._test];
1241 }
1242 
1243 //=============================================================================
1244 uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
1245 uint BoolNode::size_of() const { return sizeof(BoolNode); }
1246 
1247 //------------------------------operator==-------------------------------------
<span class="line-modified">1248 bool BoolNode::cmp( const Node &amp;n ) const {</span>
1249   const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
1250   return (_test._test == b-&gt;_test._test);
1251 }
1252 
1253 //-------------------------------make_predicate--------------------------------
1254 Node* BoolNode::make_predicate(Node* test_value, PhaseGVN* phase) {
1255   if (test_value-&gt;is_Con())   return test_value;
1256   if (test_value-&gt;is_Bool())  return test_value;
1257   if (test_value-&gt;is_CMove() &amp;&amp;
1258       test_value-&gt;in(CMoveNode::Condition)-&gt;is_Bool()) {
1259     BoolNode*   bol   = test_value-&gt;in(CMoveNode::Condition)-&gt;as_Bool();
1260     const Type* ftype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfFalse));
1261     const Type* ttype = phase-&gt;type(test_value-&gt;in(CMoveNode::IfTrue));
1262     if (ftype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ttype)) {
1263       return bol;
1264     } else if (ttype == TypeInt::ZERO &amp;&amp; !TypeInt::ZERO-&gt;higher_equal(ftype)) {
1265       return phase-&gt;transform( bol-&gt;negate(phase) );
1266     }
1267     // Else fall through.  The CMove gets in the way of the test.
1268     // It should be the case that make_predicate(bol-&gt;as_int_value()) == bol.
</pre>
<hr />
<pre>
1335   }
1336   return NULL;
1337 }
1338 
1339 static bool is_counted_loop_cmp(Node *cmp) {
1340   Node *n = cmp-&gt;in(1)-&gt;in(1);
1341   return n != NULL &amp;&amp;
1342          n-&gt;is_Phi() &amp;&amp;
1343          n-&gt;in(0) != NULL &amp;&amp;
1344          n-&gt;in(0)-&gt;is_CountedLoop() &amp;&amp;
1345          n-&gt;in(0)-&gt;as_CountedLoop()-&gt;phi() == n;
1346 }
1347 
1348 //------------------------------Ideal------------------------------------------
1349 Node *BoolNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1350   // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
1351   // This moves the constant to the right.  Helps value-numbering.
1352   Node *cmp = in(1);
1353   if( !cmp-&gt;is_Sub() ) return NULL;
1354   int cop = cmp-&gt;Opcode();
<span class="line-modified">1355   if( cop == Op_FastLock || cop == Op_FastUnlock || cmp-&gt;is_SubTypeCheck()) return NULL;</span>
1356   Node *cmp1 = cmp-&gt;in(1);
1357   Node *cmp2 = cmp-&gt;in(2);
1358   if( !cmp1 ) return NULL;
1359 
1360   if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
1361     return NULL;
1362   }
1363 
1364   // Constant on left?
1365   Node *con = cmp1;
1366   uint op2 = cmp2-&gt;Opcode();
1367   // Move constants to the right of compare&#39;s to canonicalize.
1368   // Do not muck with Opaque1 nodes, as this indicates a loop
1369   // guard that cannot change shape.
1370   if( con-&gt;is_Con() &amp;&amp; !cmp2-&gt;is_Con() &amp;&amp; op2 != Op_Opaque1 &amp;&amp;
1371       // Because of NaN&#39;s, CmpD and CmpF are not commutative
1372       cop != Op_CmpD &amp;&amp; cop != Op_CmpF &amp;&amp;
1373       // Protect against swapping inputs to a compare when it is used by a
1374       // counted loop exit, which requires maintaining the loop-limit as in(2)
1375       !is_counted_loop_exit_test() ) {
</pre>
</td>
</tr>
</table>
<center><a href="stringopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
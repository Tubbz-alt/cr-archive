<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/graphKit.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 384,10 ***</span>
<span class="line-new-header">--- 384,15 ---</span>
                         bool speculative = false);
  
    // Check the null_seen bit.
    bool seems_never_null(Node* obj, ciProfileData* data, bool&amp; speculating);
  
<span class="line-added">+   void guard_klass_being_initialized(Node* klass);</span>
<span class="line-added">+   void guard_init_thread(Node* klass);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void clinit_barrier(ciInstanceKlass* ik, ciMethod* context);</span>
<span class="line-added">+ </span>
    // Check for unique class for receiver at call
    ciKlass* profile_has_unique_klass() {
      ciCallProfile profile = method()-&gt;call_profile_at_bci(bci());
      if (profile.count() &gt;= 0 &amp;&amp;         // no cast failures here
          profile.has_receiver(0) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 516,31 ***</span>
    // adapted the `do_put_xxx&#39; and `do_get_xxx&#39; procedures for the case
    // of volatile fields.
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false) {</span>
      // This version computes alias_index from bottom_type
      return make_load(ctl, adr, t, bt, adr-&gt;bottom_type()-&gt;is_ptr(),
                       mo, control_dependency, require_atomic_access,
<span class="line-modified">!                      unaligned, mismatched, unsafe);</span>
    }
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, const TypePtr* adr_type,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false) {</span>
      // This version computes alias_index from an address type
      assert(adr_type != NULL, &quot;use other make_load factory&quot;);
      return make_load(ctl, adr, t, bt, C-&gt;get_alias_index(adr_type),
                       mo, control_dependency, require_atomic_access,
<span class="line-modified">!                      unaligned, mismatched, unsafe);</span>
    }
    // This is the base version which is given an alias index.
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, int adr_idx,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false);</span>
  
    // Create &amp; transform a StoreNode and store the effect into the
    // parser&#39;s memory state.
    //
    // We must ensure that stores of object references will be visible
<span class="line-new-header">--- 521,31 ---</span>
    // adapted the `do_put_xxx&#39; and `do_get_xxx&#39; procedures for the case
    // of volatile fields.
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0) {</span>
      // This version computes alias_index from bottom_type
      return make_load(ctl, adr, t, bt, adr-&gt;bottom_type()-&gt;is_ptr(),
                       mo, control_dependency, require_atomic_access,
<span class="line-modified">!                      unaligned, mismatched, unsafe, barrier_data);</span>
    }
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, const TypePtr* adr_type,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0) {</span>
      // This version computes alias_index from an address type
      assert(adr_type != NULL, &quot;use other make_load factory&quot;);
      return make_load(ctl, adr, t, bt, C-&gt;get_alias_index(adr_type),
                       mo, control_dependency, require_atomic_access,
<span class="line-modified">!                      unaligned, mismatched, unsafe, barrier_data);</span>
    }
    // This is the base version which is given an alias index.
    Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, int adr_idx,
                    MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,
                    bool require_atomic_access = false, bool unaligned = false,
<span class="line-modified">!                   bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);</span>
  
    // Create &amp; transform a StoreNode and store the effect into the
    // parser&#39;s memory state.
    //
    // We must ensure that stores of object references will be visible
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,11 ***</span>
      // This version computes alias_index from an address type
      assert(adr_type != NULL, &quot;use other store_to_memory factory&quot;);
      return store_to_memory(ctl, adr, val, bt,
                             C-&gt;get_alias_index(adr_type),
                             mo, require_atomic_access,
<span class="line-modified">!                            unaligned, mismatched);</span>
    }
    // This is the base version which is given alias index
    // Return the new StoreXNode
    Node* store_to_memory(Node* ctl, Node* adr, Node* val, BasicType bt,
                          int adr_idx,
<span class="line-new-header">--- 563,11 ---</span>
      // This version computes alias_index from an address type
      assert(adr_type != NULL, &quot;use other store_to_memory factory&quot;);
      return store_to_memory(ctl, adr, val, bt,
                             C-&gt;get_alias_index(adr_type),
                             mo, require_atomic_access,
<span class="line-modified">!                            unaligned, mismatched, unsafe);</span>
    }
    // This is the base version which is given alias index
    // Return the new StoreXNode
    Node* store_to_memory(Node* ctl, Node* adr, Node* val, BasicType bt,
                          int adr_idx,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,12 ***</span>
                               BasicType bt,
                               DecoratorSet decorators);
  
    void access_clone(Node* src, Node* dst, Node* size, bool is_array);
  
<span class="line-removed">-   Node* access_resolve(Node* n, DecoratorSet decorators);</span>
<span class="line-removed">- </span>
    // Return addressing for an array element.
    Node* array_element_address(Node* ary, Node* idx, BasicType elembt,
                                // Optional constraint on the array size:
                                const TypeInt* sizetype = NULL,
                                // Optional control dependency (for example, on range check)
<span class="line-new-header">--- 637,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,17 ***</span>
    // Generate a check-cast idiom.  Used by both the check-cast bytecode
    // and the array-store bytecode
    Node* gen_checkcast( Node *subobj, Node* superkls,
                         Node* *failure_control = NULL );
  
<span class="line-modified">!   Node* gen_subtype_check(Node* subklass, Node* superklass) {</span>
<span class="line-removed">-     MergeMemNode* mem = merged_memory();</span>
<span class="line-removed">-     Node* ctrl = control();</span>
<span class="line-removed">-     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, &amp;_gvn);</span>
<span class="line-removed">-     set_control(ctrl);</span>
<span class="line-removed">-     return n;</span>
<span class="line-removed">-   }</span>
  
    // Exact type check used for predicted calls and casts.
    // Rewrites (*casted_receiver) to be casted to the stronger type.
    // (Caller is responsible for doing replace_in_map.)
    Node* type_check_receiver(Node* receiver, ciKlass* klass, float prob,
<span class="line-new-header">--- 823,11 ---</span>
    // Generate a check-cast idiom.  Used by both the check-cast bytecode
    // and the array-store bytecode
    Node* gen_checkcast( Node *subobj, Node* superkls,
                         Node* *failure_control = NULL );
  
<span class="line-modified">!   Node* gen_subtype_check(Node* obj, Node* superklass);</span>
  
    // Exact type check used for predicted calls and casts.
    // Rewrites (*casted_receiver) to be casted to the stronger type.
    // (Caller is responsible for doing replace_in_map.)
    Node* type_check_receiver(Node* receiver, ciKlass* klass, float prob,
</pre>
<center><a href="graphKit.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
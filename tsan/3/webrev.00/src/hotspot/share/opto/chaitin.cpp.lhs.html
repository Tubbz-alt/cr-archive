<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;compiler/oopMap.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/block.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/chaitin.hpp&quot;
  35 #include &quot;opto/coalesce.hpp&quot;
  36 #include &quot;opto/connode.hpp&quot;
  37 #include &quot;opto/idealGraphPrinter.hpp&quot;
  38 #include &quot;opto/indexSet.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 
  46 #ifndef PRODUCT
  47 void LRG::dump() const {
  48   ttyLocker ttyl;
  49   tty-&gt;print(&quot;%d &quot;,num_regs());
  50   _mask.dump();
  51   if( _msize_valid ) {
  52     if( mask_size() == compute_mask_size() ) tty-&gt;print(&quot;, #%d &quot;,_mask_size);
  53     else tty-&gt;print(&quot;, #!!!_%d_vs_%d &quot;,_mask_size,_mask.Size());
  54   } else {
  55     tty-&gt;print(&quot;, #?(%d) &quot;,_mask.Size());
  56   }
  57 
  58   tty-&gt;print(&quot;EffDeg: &quot;);
  59   if( _degree_valid ) tty-&gt;print( &quot;%d &quot;, _eff_degree );
  60   else tty-&gt;print(&quot;? &quot;);
  61 
  62   if( is_multidef() ) {
  63     tty-&gt;print(&quot;MultiDef &quot;);
  64     if (_defs != NULL) {
  65       tty-&gt;print(&quot;(&quot;);
  66       for (int i = 0; i &lt; _defs-&gt;length(); i++) {
  67         tty-&gt;print(&quot;N%d &quot;, _defs-&gt;at(i)-&gt;_idx);
  68       }
  69       tty-&gt;print(&quot;) &quot;);
  70     }
  71   }
  72   else if( _def == 0 ) tty-&gt;print(&quot;Dead &quot;);
  73   else tty-&gt;print(&quot;Def: N%d &quot;,_def-&gt;_idx);
  74 
  75   tty-&gt;print(&quot;Cost:%4.2g Area:%4.2g Score:%4.2g &quot;,_cost,_area, score());
  76   // Flags
  77   if( _is_oop ) tty-&gt;print(&quot;Oop &quot;);
  78   if( _is_float ) tty-&gt;print(&quot;Float &quot;);
  79   if( _is_vector ) tty-&gt;print(&quot;Vector &quot;);
  80   if( _was_spilled1 ) tty-&gt;print(&quot;Spilled &quot;);
  81   if( _was_spilled2 ) tty-&gt;print(&quot;Spilled2 &quot;);
  82   if( _direct_conflict ) tty-&gt;print(&quot;Direct_conflict &quot;);
  83   if( _fat_proj ) tty-&gt;print(&quot;Fat &quot;);
  84   if( _was_lo ) tty-&gt;print(&quot;Lo &quot;);
  85   if( _has_copy ) tty-&gt;print(&quot;Copy &quot;);
  86   if( _at_risk ) tty-&gt;print(&quot;Risk &quot;);
  87 
  88   if( _must_spill ) tty-&gt;print(&quot;Must_spill &quot;);
  89   if( _is_bound ) tty-&gt;print(&quot;Bound &quot;);
  90   if( _msize_valid ) {
  91     if( _degree_valid &amp;&amp; lo_degree() ) tty-&gt;print(&quot;Trivial &quot;);
  92   }
  93 
  94   tty-&gt;cr();
  95 }
  96 #endif
  97 
  98 // Compute score from cost and area.  Low score is best to spill.
  99 static double raw_score( double cost, double area ) {
 100   return cost - (area*RegisterCostAreaRatio) * 1.52588e-5;
 101 }
 102 
 103 double LRG::score() const {
 104   // Scale _area by RegisterCostAreaRatio/64K then subtract from cost.
 105   // Bigger area lowers score, encourages spilling this live range.
 106   // Bigger cost raise score, prevents spilling this live range.
 107   // (Note: 1/65536 is the magic constant below; I dont trust the C optimizer
 108   // to turn a divide by a constant into a multiply by the reciprical).
 109   double score = raw_score( _cost, _area);
 110 
 111   // Account for area.  Basically, LRGs covering large areas are better
 112   // to spill because more other LRGs get freed up.
 113   if( _area == 0.0 )            // No area?  Then no progress to spill
 114     return 1e35;
 115 
 116   if( _was_spilled2 )           // If spilled once before, we are unlikely
 117     return score + 1e30;        // to make progress again.
 118 
 119   if( _cost &gt;= _area*3.0 )      // Tiny area relative to cost
 120     return score + 1e17;        // Probably no progress to spill
 121 
 122   if( (_cost+_cost) &gt;= _area*3.0 ) // Small area relative to cost
 123     return score + 1e10;        // Likely no progress to spill
 124 
 125   return score;
 126 }
 127 
 128 #define NUMBUCKS 3
 129 
 130 // Straight out of Tarjan&#39;s union-find algorithm
 131 uint LiveRangeMap::find_compress(uint lrg) {
 132   uint cur = lrg;
 133   uint next = _uf_map.at(cur);
 134   while (next != cur) { // Scan chain of equivalences
 135     assert( next &lt; cur, &quot;always union smaller&quot;);
 136     cur = next; // until find a fixed-point
 137     next = _uf_map.at(cur);
 138   }
 139 
 140   // Core of union-find algorithm: update chain of
 141   // equivalences to be equal to the root.
 142   while (lrg != next) {
 143     uint tmp = _uf_map.at(lrg);
 144     _uf_map.at_put(lrg, next);
 145     lrg = tmp;
 146   }
 147   return lrg;
 148 }
 149 
 150 // Reset the Union-Find map to identity
 151 void LiveRangeMap::reset_uf_map(uint max_lrg_id) {
 152   _max_lrg_id= max_lrg_id;
 153   // Force the Union-Find mapping to be at least this large
 154   _uf_map.at_put_grow(_max_lrg_id, 0);
 155   // Initialize it to be the ID mapping.
 156   for (uint i = 0; i &lt; _max_lrg_id; ++i) {
 157     _uf_map.at_put(i, i);
 158   }
 159 }
 160 
 161 // Make all Nodes map directly to their final live range; no need for
 162 // the Union-Find mapping after this call.
 163 void LiveRangeMap::compress_uf_map_for_nodes() {
 164   // For all Nodes, compress mapping
 165   uint unique = _names.length();
 166   for (uint i = 0; i &lt; unique; ++i) {
 167     uint lrg = _names.at(i);
 168     uint compressed_lrg = find(lrg);
 169     if (lrg != compressed_lrg) {
 170       _names.at_put(i, compressed_lrg);
 171     }
 172   }
 173 }
 174 
 175 // Like Find above, but no path compress, so bad asymptotic behavior
 176 uint LiveRangeMap::find_const(uint lrg) const {
 177   if (!lrg) {
 178     return lrg; // Ignore the zero LRG
 179   }
 180 
 181   // Off the end?  This happens during debugging dumps when you got
 182   // brand new live ranges but have not told the allocator yet.
 183   if (lrg &gt;= _max_lrg_id) {
 184     return lrg;
 185   }
 186 
 187   uint next = _uf_map.at(lrg);
 188   while (next != lrg) { // Scan chain of equivalences
 189     assert(next &lt; lrg, &quot;always union smaller&quot;);
 190     lrg = next; // until find a fixed-point
 191     next = _uf_map.at(lrg);
 192   }
 193   return next;
 194 }
 195 
 196 PhaseChaitin::PhaseChaitin(uint unique, PhaseCFG &amp;cfg, Matcher &amp;matcher, bool scheduling_info_generated)
 197   : PhaseRegAlloc(unique, cfg, matcher,
 198 #ifndef PRODUCT
 199        print_chaitin_statistics
 200 #else
 201        NULL
 202 #endif
 203        )
 204   , _live(0)
 205   , _spilled_once(Thread::current()-&gt;resource_area())
 206   , _spilled_twice(Thread::current()-&gt;resource_area())
 207   , _lo_degree(0), _lo_stk_degree(0), _hi_degree(0), _simplified(0)
 208   , _oldphi(unique)
 209 #ifndef PRODUCT
 210   , _trace_spilling(C-&gt;directive()-&gt;TraceSpillingOption)
 211 #endif
 212   , _lrg_map(Thread::current()-&gt;resource_area(), unique)
 213   , _scheduling_info_generated(scheduling_info_generated)
 214   , _sched_int_pressure(0, INTPRESSURE)
 215   , _sched_float_pressure(0, FLOATPRESSURE)
 216   , _scratch_int_pressure(0, INTPRESSURE)
 217   , _scratch_float_pressure(0, FLOATPRESSURE)
 218 {
 219   Compile::TracePhase tp(&quot;ctorChaitin&quot;, &amp;timers[_t_ctorChaitin]);
 220 
 221   _high_frequency_lrg = MIN2(double(OPTO_LRG_HIGH_FREQ), _cfg.get_outer_loop_frequency());
 222 
 223   // Build a list of basic blocks, sorted by frequency
 224   _blks = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 225   // Experiment with sorting strategies to speed compilation
 226   double  cutoff = BLOCK_FREQUENCY(1.0); // Cutoff for high frequency bucket
 227   Block **buckets[NUMBUCKS];             // Array of buckets
 228   uint    buckcnt[NUMBUCKS];             // Array of bucket counters
 229   double  buckval[NUMBUCKS];             // Array of bucket value cutoffs
 230   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 231     buckets[i] = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 232     buckcnt[i] = 0;
 233     // Bump by three orders of magnitude each time
 234     cutoff *= 0.001;
 235     buckval[i] = cutoff;
 236     for (uint j = 0; j &lt; _cfg.number_of_blocks(); j++) {
 237       buckets[i][j] = NULL;
 238     }
 239   }
 240   // Sort blocks into buckets
 241   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 242     for (uint j = 0; j &lt; NUMBUCKS; j++) {
 243       if ((j == NUMBUCKS - 1) || (_cfg.get_block(i)-&gt;_freq &gt; buckval[j])) {
 244         // Assign block to end of list for appropriate bucket
 245         buckets[j][buckcnt[j]++] = _cfg.get_block(i);
 246         break; // kick out of inner loop
 247       }
 248     }
 249   }
 250   // Dump buckets into final block array
 251   uint blkcnt = 0;
 252   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 253     for (uint j = 0; j &lt; buckcnt[i]; j++) {
 254       _blks[blkcnt++] = buckets[i][j];
 255     }
 256   }
 257 
 258   assert(blkcnt == _cfg.number_of_blocks(), &quot;Block array not totally filled&quot;);
 259 }
 260 
 261 // union 2 sets together.
 262 void PhaseChaitin::Union( const Node *src_n, const Node *dst_n ) {
 263   uint src = _lrg_map.find(src_n);
 264   uint dst = _lrg_map.find(dst_n);
 265   assert(src, &quot;&quot;);
 266   assert(dst, &quot;&quot;);
 267   assert(src &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 268   assert(dst &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 269   assert(src &lt; dst, &quot;always union smaller&quot;);
 270   _lrg_map.uf_map(dst, src);
 271 }
 272 
 273 void PhaseChaitin::new_lrg(const Node *x, uint lrg) {
 274   // Make the Node-&gt;LRG mapping
 275   _lrg_map.extend(x-&gt;_idx,lrg);
 276   // Make the Union-Find mapping an identity function
 277   _lrg_map.uf_extend(lrg, lrg);
 278 }
 279 
 280 
 281 int PhaseChaitin::clone_projs(Block* b, uint idx, Node* orig, Node* copy, uint&amp; max_lrg_id) {
 282   assert(b-&gt;find_node(copy) == (idx - 1), &quot;incorrect insert index for copy kill projections&quot;);
 283   DEBUG_ONLY( Block* borig = _cfg.get_block_for_node(orig); )
 284   int found_projs = 0;
 285   uint cnt = orig-&gt;outcnt();
 286   for (uint i = 0; i &lt; cnt; i++) {
 287     Node* proj = orig-&gt;raw_out(i);
 288     if (proj-&gt;is_MachProj()) {
 289       assert(proj-&gt;outcnt() == 0, &quot;only kill projections are expected here&quot;);
 290       assert(_cfg.get_block_for_node(proj) == borig, &quot;incorrect block for kill projections&quot;);
 291       found_projs++;
 292       // Copy kill projections after the cloned node
 293       Node* kills = proj-&gt;clone();
 294       kills-&gt;set_req(0, copy);
 295       b-&gt;insert_node(kills, idx++);
 296       _cfg.map_node_to_block(kills, b);
 297       new_lrg(kills, max_lrg_id++);
 298     }
 299   }
 300   return found_projs;
 301 }
 302 
 303 // Renumber the live ranges to compact them.  Makes the IFG smaller.
 304 void PhaseChaitin::compact() {
 305   Compile::TracePhase tp(&quot;chaitinCompact&quot;, &amp;timers[_t_chaitinCompact]);
 306 
 307   // Current the _uf_map contains a series of short chains which are headed
 308   // by a self-cycle.  All the chains run from big numbers to little numbers.
 309   // The Find() call chases the chains &amp; shortens them for the next Find call.
 310   // We are going to change this structure slightly.  Numbers above a moving
 311   // wave &#39;i&#39; are unchanged.  Numbers below &#39;j&#39; point directly to their
 312   // compacted live range with no further chaining.  There are no chains or
 313   // cycles below &#39;i&#39;, so the Find call no longer works.
 314   uint j=1;
 315   uint i;
 316   for (i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
 317     uint lr = _lrg_map.uf_live_range_id(i);
 318     // Ignore unallocated live ranges
 319     if (!lr) {
 320       continue;
 321     }
 322     assert(lr &lt;= i, &quot;&quot;);
 323     _lrg_map.uf_map(i, ( lr == i ) ? j++ : _lrg_map.uf_live_range_id(lr));
 324   }
 325   // Now change the Node-&gt;LR mapping to reflect the compacted names
 326   uint unique = _lrg_map.size();
 327   for (i = 0; i &lt; unique; i++) {
 328     uint lrg_id = _lrg_map.live_range_id(i);
 329     _lrg_map.map(i, _lrg_map.uf_live_range_id(lrg_id));
 330   }
 331 
 332   // Reset the Union-Find mapping
 333   _lrg_map.reset_uf_map(j);
 334 }
 335 
 336 void PhaseChaitin::Register_Allocate() {
 337 
 338   // Above the OLD FP (and in registers) are the incoming arguments.  Stack
 339   // slots in this area are called &quot;arg_slots&quot;.  Above the NEW FP (and in
 340   // registers) is the outgoing argument area; above that is the spill/temp
 341   // area.  These are all &quot;frame_slots&quot;.  Arg_slots start at the zero
 342   // stack_slots and count up to the known arg_size.  Frame_slots start at
 343   // the stack_slot #arg_size and go up.  After allocation I map stack
 344   // slots to actual offsets.  Stack-slots in the arg_slot area are biased
 345   // by the frame_size; stack-slots in the frame_slot area are biased by 0.
 346 
 347   _trip_cnt = 0;
 348   _alternate = 0;
 349   _matcher._allocation_started = true;
 350 
 351   ResourceArea split_arena(mtCompiler);     // Arena for Split local resources
 352   ResourceArea live_arena(mtCompiler);      // Arena for liveness &amp; IFG info
 353   ResourceMark rm(&amp;live_arena);
 354 
 355   // Need live-ness for the IFG; need the IFG for coalescing.  If the
 356   // liveness is JUST for coalescing, then I can get some mileage by renaming
 357   // all copy-related live ranges low and then using the max copy-related
 358   // live range as a cut-off for LIVE and the IFG.  In other words, I can
 359   // build a subset of LIVE and IFG just for copies.
 360   PhaseLive live(_cfg, _lrg_map.names(), &amp;live_arena, false);
 361 
 362   // Need IFG for coalescing and coloring
 363   PhaseIFG ifg(&amp;live_arena);
 364   _ifg = &amp;ifg;
 365 
 366   // Come out of SSA world to the Named world.  Assign (virtual) registers to
 367   // Nodes.  Use the same register for all inputs and the output of PhiNodes
 368   // - effectively ending SSA form.  This requires either coalescing live
 369   // ranges or inserting copies.  For the moment, we insert &quot;virtual copies&quot;
 370   // - we pretend there is a copy prior to each Phi in predecessor blocks.
 371   // We will attempt to coalesce such &quot;virtual copies&quot; before we manifest
 372   // them for real.
 373   de_ssa();
 374 
 375 #ifdef ASSERT
 376   // Veify the graph before RA.
 377   verify(&amp;live_arena);
 378 #endif
 379 
 380   {
 381     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 382     _live = NULL;                 // Mark live as being not available
 383     rm.reset_to_mark();           // Reclaim working storage
 384     IndexSet::reset_memory(C, &amp;live_arena);
 385     ifg.init(_lrg_map.max_lrg_id()); // Empty IFG
 386     gather_lrg_masks( false );    // Collect LRG masks
 387     live.compute(_lrg_map.max_lrg_id()); // Compute liveness
 388     _live = &amp;live;                // Mark LIVE as being available
 389   }
 390 
 391   // Base pointers are currently &quot;used&quot; by instructions which define new
 392   // derived pointers.  This makes base pointers live up to the where the
 393   // derived pointer is made, but not beyond.  Really, they need to be live
 394   // across any GC point where the derived value is live.  So this code looks
 395   // at all the GC points, and &quot;stretches&quot; the live range of any base pointer
 396   // to the GC point.
 397   if (stretch_base_pointer_live_ranges(&amp;live_arena)) {
 398     Compile::TracePhase tp(&quot;computeLive (sbplr)&quot;, &amp;timers[_t_computeLive]);
 399     // Since some live range stretched, I need to recompute live
 400     _live = NULL;
 401     rm.reset_to_mark();         // Reclaim working storage
 402     IndexSet::reset_memory(C, &amp;live_arena);
 403     ifg.init(_lrg_map.max_lrg_id());
 404     gather_lrg_masks(false);
 405     live.compute(_lrg_map.max_lrg_id());
 406     _live = &amp;live;
 407   }
 408   // Create the interference graph using virtual copies
 409   build_ifg_virtual();  // Include stack slots this time
 410 
 411   // The IFG is/was triangular.  I am &#39;squaring it up&#39; so Union can run
 412   // faster.  Union requires a &#39;for all&#39; operation which is slow on the
 413   // triangular adjacency matrix (quick reminder: the IFG is &#39;sparse&#39; -
 414   // meaning I can visit all the Nodes neighbors less than a Node in time
 415   // O(# of neighbors), but I have to visit all the Nodes greater than a
 416   // given Node and search them for an instance, i.e., time O(#MaxLRG)).
 417   _ifg-&gt;SquareUp();
 418 
 419   // Aggressive (but pessimistic) copy coalescing.
 420   // This pass works on virtual copies.  Any virtual copies which are not
 421   // coalesced get manifested as actual copies
 422   {
 423     Compile::TracePhase tp(&quot;chaitinCoalesce1&quot;, &amp;timers[_t_chaitinCoalesce1]);
 424 
 425     PhaseAggressiveCoalesce coalesce(*this);
 426     coalesce.coalesce_driver();
 427     // Insert un-coalesced copies.  Visit all Phis.  Where inputs to a Phi do
 428     // not match the Phi itself, insert a copy.
 429     coalesce.insert_copies(_matcher);
 430     if (C-&gt;failing()) {
 431       return;
 432     }
 433   }
 434 
 435   // After aggressive coalesce, attempt a first cut at coloring.
 436   // To color, we need the IFG and for that we need LIVE.
 437   {
 438     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 439     _live = NULL;
 440     rm.reset_to_mark();           // Reclaim working storage
 441     IndexSet::reset_memory(C, &amp;live_arena);
 442     ifg.init(_lrg_map.max_lrg_id());
 443     gather_lrg_masks( true );
 444     live.compute(_lrg_map.max_lrg_id());
 445     _live = &amp;live;
 446   }
 447 
 448   // Build physical interference graph
 449   uint must_spill = 0;
 450   must_spill = build_ifg_physical(&amp;live_arena);
 451   // If we have a guaranteed spill, might as well spill now
 452   if (must_spill) {
 453     if(!_lrg_map.max_lrg_id()) {
 454       return;
 455     }
 456     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit)
 457     C-&gt;check_node_count(10*must_spill, &quot;out of nodes before split&quot;);
 458     if (C-&gt;failing()) {
 459       return;
 460     }
 461 
 462     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 463     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 464     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 465     // or we failed to split
 466     C-&gt;check_node_count(2*NodeLimitFudgeFactor, &quot;out of nodes after physical split&quot;);
 467     if (C-&gt;failing()) {
 468       return;
 469     }
 470 
 471     NOT_PRODUCT(C-&gt;verify_graph_edges();)
 472 
 473     compact();                  // Compact LRGs; return new lower max lrg
 474 
 475     {
 476       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 477       _live = NULL;
 478       rm.reset_to_mark();         // Reclaim working storage
 479       IndexSet::reset_memory(C, &amp;live_arena);
 480       ifg.init(_lrg_map.max_lrg_id()); // Build a new interference graph
 481       gather_lrg_masks( true );   // Collect intersect mask
 482       live.compute(_lrg_map.max_lrg_id()); // Compute LIVE
 483       _live = &amp;live;
 484     }
 485     build_ifg_physical(&amp;live_arena);
 486     _ifg-&gt;SquareUp();
 487     _ifg-&gt;Compute_Effective_Degree();
 488     // Only do conservative coalescing if requested
 489     if (OptoCoalesce) {
 490       Compile::TracePhase tp(&quot;chaitinCoalesce2&quot;, &amp;timers[_t_chaitinCoalesce2]);
 491       // Conservative (and pessimistic) copy coalescing of those spills
 492       PhaseConservativeCoalesce coalesce(*this);
 493       // If max live ranges greater than cutoff, don&#39;t color the stack.
 494       // This cutoff can be larger than below since it is only done once.
 495       coalesce.coalesce_driver();
 496     }
 497     _lrg_map.compress_uf_map_for_nodes();
 498 
 499 #ifdef ASSERT
 500     verify(&amp;live_arena, true);
 501 #endif
 502   } else {
 503     ifg.SquareUp();
 504     ifg.Compute_Effective_Degree();
 505 #ifdef ASSERT
 506     set_was_low();
 507 #endif
 508   }
 509 
 510   // Prepare for Simplify &amp; Select
 511   cache_lrg_info();           // Count degree of LRGs
 512 
 513   // Simplify the InterFerence Graph by removing LRGs of low degree.
 514   // LRGs of low degree are trivially colorable.
 515   Simplify();
 516 
 517   // Select colors by re-inserting LRGs back into the IFG in reverse order.
 518   // Return whether or not something spills.
 519   uint spills = Select( );
 520 
 521   // If we spill, split and recycle the entire thing
 522   while( spills ) {
 523     if( _trip_cnt++ &gt; 24 ) {
 524       DEBUG_ONLY( dump_for_spill_split_recycle(); )
 525       if( _trip_cnt &gt; 27 ) {
 526         C-&gt;record_method_not_compilable(&quot;failed spill-split-recycle sanity check&quot;);
 527         return;
 528       }
 529     }
 530 
 531     if (!_lrg_map.max_lrg_id()) {
 532       return;
 533     }
 534     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 535     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 536     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 537     C-&gt;check_node_count(2 * NodeLimitFudgeFactor, &quot;out of nodes after split&quot;);
 538     if (C-&gt;failing()) {
 539       return;
 540     }
 541 
 542     compact(); // Compact LRGs; return new lower max lrg
 543 
 544     // Nuke the live-ness and interference graph and LiveRanGe info
 545     {
 546       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 547       _live = NULL;
 548       rm.reset_to_mark();         // Reclaim working storage
 549       IndexSet::reset_memory(C, &amp;live_arena);
 550       ifg.init(_lrg_map.max_lrg_id());
 551 
 552       // Create LiveRanGe array.
 553       // Intersect register masks for all USEs and DEFs
 554       gather_lrg_masks(true);
 555       live.compute(_lrg_map.max_lrg_id());
 556       _live = &amp;live;
 557     }
 558     must_spill = build_ifg_physical(&amp;live_arena);
 559     _ifg-&gt;SquareUp();
 560     _ifg-&gt;Compute_Effective_Degree();
 561 
 562     // Only do conservative coalescing if requested
 563     if (OptoCoalesce) {
 564       Compile::TracePhase tp(&quot;chaitinCoalesce3&quot;, &amp;timers[_t_chaitinCoalesce3]);
 565       // Conservative (and pessimistic) copy coalescing
 566       PhaseConservativeCoalesce coalesce(*this);
 567       // Check for few live ranges determines how aggressive coalesce is.
 568       coalesce.coalesce_driver();
 569     }
 570     _lrg_map.compress_uf_map_for_nodes();
 571 #ifdef ASSERT
 572     verify(&amp;live_arena, true);
 573 #endif
 574     cache_lrg_info();           // Count degree of LRGs
 575 
 576     // Simplify the InterFerence Graph by removing LRGs of low degree.
 577     // LRGs of low degree are trivially colorable.
 578     Simplify();
 579 
 580     // Select colors by re-inserting LRGs back into the IFG in reverse order.
 581     // Return whether or not something spills.
 582     spills = Select();
 583   }
 584 
 585   // Count number of Simplify-Select trips per coloring success.
 586   _allocator_attempts += _trip_cnt + 1;
 587   _allocator_successes += 1;
 588 
 589   // Peephole remove copies
 590   post_allocate_copy_removal();
 591 
 592   // Merge multidefs if multiple defs representing the same value are used in a single block.
 593   merge_multidefs();
 594 
 595 #ifdef ASSERT
 596   // Veify the graph after RA.
 597   verify(&amp;live_arena);
 598 #endif
 599 
 600   // max_reg is past the largest *register* used.
 601   // Convert that to a frame_slot number.
 602   if (_max_reg &lt;= _matcher._new_SP) {
 603     _framesize = C-&gt;out_preserve_stack_slots();
 604   }
 605   else {
 606     _framesize = _max_reg -_matcher._new_SP;
 607   }
 608   assert((int)(_matcher._new_SP+_framesize) &gt;= (int)_matcher._out_arg_limit, &quot;framesize must be large enough&quot;);
 609 
 610   // This frame must preserve the required fp alignment
 611   _framesize = align_up(_framesize, Matcher::stack_alignment_in_slots());
 612   assert(_framesize &lt;= 1000000, &quot;sanity check&quot;);
 613 #ifndef PRODUCT
 614   _total_framesize += _framesize;
 615   if ((int)_framesize &gt; _max_framesize) {
 616     _max_framesize = _framesize;
 617   }
 618 #endif
 619 
 620   // Convert CISC spills
 621   fixup_spills();
 622 
 623   // Log regalloc results
 624   CompileLog* log = Compile::current()-&gt;log();
 625   if (log != NULL) {
 626     log-&gt;elem(&quot;regalloc attempts=&#39;%d&#39; success=&#39;%d&#39;&quot;, _trip_cnt, !C-&gt;failing());
 627   }
 628 
 629   if (C-&gt;failing()) {
 630     return;
 631   }
 632 
 633   NOT_PRODUCT(C-&gt;verify_graph_edges();)
 634 
 635   // Move important info out of the live_arena to longer lasting storage.
 636   alloc_node_regs(_lrg_map.size());
 637   for (uint i=0; i &lt; _lrg_map.size(); i++) {
 638     if (_lrg_map.live_range_id(i)) { // Live range associated with Node?
 639       LRG &amp;lrg = lrgs(_lrg_map.live_range_id(i));
 640       if (!lrg.alive()) {
 641         set_bad(i);
 642       } else if (lrg.num_regs() == 1) {
 643         set1(i, lrg.reg());
 644       } else {                  // Must be a register-set
 645         if (!lrg._fat_proj) {   // Must be aligned adjacent register set
 646           // Live ranges record the highest register in their mask.
 647           // We want the low register for the AD file writer&#39;s convenience.
 648           OptoReg::Name hi = lrg.reg(); // Get hi register
 649           OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); // Find lo
 650           // We have to use pair [lo,lo+1] even for wide vectors because
 651           // the rest of code generation works only with pairs. It is safe
 652           // since for registers encoding only &#39;lo&#39; is used.
 653           // Second reg from pair is used in ScheduleAndBundle on SPARC where
 654           // vector max size is 8 which corresponds to registers pair.
 655           // It is also used in BuildOopMaps but oop operations are not
 656           // vectorized.
 657           set2(i, lo);
 658         } else {                // Misaligned; extract 2 bits
 659           OptoReg::Name hi = lrg.reg(); // Get hi register
 660           lrg.Remove(hi);       // Yank from mask
 661           int lo = lrg.mask().find_first_elem(); // Find lo
 662           set_pair(i, hi, lo);
 663         }
 664       }
 665       if( lrg._is_oop ) _node_oops.set(i);
 666     } else {
 667       set_bad(i);
 668     }
 669   }
 670 
 671   // Done!
 672   _live = NULL;
 673   _ifg = NULL;
 674   C-&gt;set_indexSet_arena(NULL);  // ResourceArea is at end of scope
 675 }
 676 
 677 void PhaseChaitin::de_ssa() {
 678   // Set initial Names for all Nodes.  Most Nodes get the virtual register
 679   // number.  A few get the ZERO live range number.  These do not
 680   // get allocated, but instead rely on correct scheduling to ensure that
 681   // only one instance is simultaneously live at a time.
 682   uint lr_counter = 1;
 683   for( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 684     Block* block = _cfg.get_block(i);
 685     uint cnt = block-&gt;number_of_nodes();
 686 
 687     // Handle all the normal Nodes in the block
 688     for( uint j = 0; j &lt; cnt; j++ ) {
 689       Node *n = block-&gt;get_node(j);
 690       // Pre-color to the zero live range, or pick virtual register
 691       const RegMask &amp;rm = n-&gt;out_RegMask();
 692       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? lr_counter++ : 0);
 693     }
 694   }
 695 
 696   // Reset the Union-Find mapping to be identity
 697   _lrg_map.reset_uf_map(lr_counter);
 698 }
 699 
 700 void PhaseChaitin::mark_ssa() {
 701   // Use ssa names to populate the live range maps or if no mask
 702   // is available, use the 0 entry.
 703   uint max_idx = 0;
 704   for ( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 705     Block* block = _cfg.get_block(i);
 706     uint cnt = block-&gt;number_of_nodes();
 707 
 708     // Handle all the normal Nodes in the block
 709     for ( uint j = 0; j &lt; cnt; j++ ) {
 710       Node *n = block-&gt;get_node(j);
 711       // Pre-color to the zero live range, or pick virtual register
 712       const RegMask &amp;rm = n-&gt;out_RegMask();
 713       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? n-&gt;_idx : 0);
 714       max_idx = (n-&gt;_idx &gt; max_idx) ? n-&gt;_idx : max_idx;
 715     }
 716   }
 717   _lrg_map.set_max_lrg_id(max_idx+1);
 718 
 719   // Reset the Union-Find mapping to be identity
 720   _lrg_map.reset_uf_map(max_idx+1);
 721 }
 722 
 723 
 724 // Gather LiveRanGe information, including register masks.  Modification of
 725 // cisc spillable in_RegMasks should not be done before AggressiveCoalesce.
 726 void PhaseChaitin::gather_lrg_masks( bool after_aggressive ) {
 727 
 728   // Nail down the frame pointer live range
 729   uint fp_lrg = _lrg_map.live_range_id(_cfg.get_root_node()-&gt;in(1)-&gt;in(TypeFunc::FramePtr));
 730   lrgs(fp_lrg)._cost += 1e12;   // Cost is infinite
 731 
 732   // For all blocks
 733   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 734     Block* block = _cfg.get_block(i);
 735 
 736     // For all instructions
 737     for (uint j = 1; j &lt; block-&gt;number_of_nodes(); j++) {
 738       Node* n = block-&gt;get_node(j);
 739       uint input_edge_start =1; // Skip control most nodes
 740       bool is_machine_node = false;
 741       if (n-&gt;is_Mach()) {
 742         is_machine_node = true;
 743         input_edge_start = n-&gt;as_Mach()-&gt;oper_input_base();
 744       }
 745       uint idx = n-&gt;is_Copy();
 746 
 747       // Get virtual register number, same as LiveRanGe index
 748       uint vreg = _lrg_map.live_range_id(n);
 749       LRG&amp; lrg = lrgs(vreg);
 750       if (vreg) {              // No vreg means un-allocable (e.g. memory)
 751 
 752         // Check for float-vs-int live range (used in register-pressure
 753         // calculations)
 754         const Type *n_type = n-&gt;bottom_type();
 755         if (n_type-&gt;is_floatingpoint()) {
 756           lrg._is_float = 1;
 757         }
 758 
 759         // Check for twice prior spilling.  Once prior spilling might have
 760         // spilled &#39;soft&#39;, 2nd prior spill should have spilled &#39;hard&#39; and
 761         // further spilling is unlikely to make progress.
 762         if (_spilled_once.test(n-&gt;_idx)) {
 763           lrg._was_spilled1 = 1;
 764           if (_spilled_twice.test(n-&gt;_idx)) {
 765             lrg._was_spilled2 = 1;
 766           }
 767         }
 768 
 769 #ifndef PRODUCT
 770         // Collect bits not used by product code, but which may be useful for
 771         // debugging.
 772 
 773         // Collect has-copy bit
 774         if (idx) {
 775           lrg._has_copy = 1;
 776           uint clidx = _lrg_map.live_range_id(n-&gt;in(idx));
 777           LRG&amp; copy_src = lrgs(clidx);
 778           copy_src._has_copy = 1;
 779         }
 780 
 781         if (trace_spilling() &amp;&amp; lrg._def != NULL) {
 782           // collect defs for MultiDef printing
 783           if (lrg._defs == NULL) {
 784             lrg._defs = new (_ifg-&gt;_arena) GrowableArray&lt;Node*&gt;(_ifg-&gt;_arena, 2, 0, NULL);
 785             lrg._defs-&gt;append(lrg._def);
 786           }
 787           lrg._defs-&gt;append(n);
 788         }
 789 #endif
 790 
 791         // Check for a single def LRG; these can spill nicely
 792         // via rematerialization.  Flag as NULL for no def found
 793         // yet, or &#39;n&#39; for single def or -1 for many defs.
 794         lrg._def = lrg._def ? NodeSentinel : n;
 795 
 796         // Limit result register mask to acceptable registers
 797         const RegMask &amp;rm = n-&gt;out_RegMask();
 798         lrg.AND( rm );
 799 
 800         uint ireg = n-&gt;ideal_reg();
 801         assert( !n-&gt;bottom_type()-&gt;isa_oop_ptr() || ireg == Op_RegP,
 802                 &quot;oops must be in Op_RegP&#39;s&quot; );
 803 
 804         // Check for vector live range (only if vector register is used).
 805         // On SPARC vector uses RegD which could be misaligned so it is not
 806         // processes as vector in RA.
 807         if (RegMask::is_vector(ireg))
 808           lrg._is_vector = 1;
 809         assert(n_type-&gt;isa_vect() == NULL || lrg._is_vector || ireg == Op_RegD || ireg == Op_RegL,
 810                &quot;vector must be in vector registers&quot;);
 811 
 812         // Check for bound register masks
 813         const RegMask &amp;lrgmask = lrg.mask();
 814         if (lrgmask.is_bound(ireg)) {
 815           lrg._is_bound = 1;
 816         }
 817 
 818         // Check for maximum frequency value
 819         if (lrg._maxfreq &lt; block-&gt;_freq) {
 820           lrg._maxfreq = block-&gt;_freq;
 821         }
 822 
 823         // Check for oop-iness, or long/double
 824         // Check for multi-kill projection
 825         switch (ireg) {
 826         case MachProjNode::fat_proj:
 827           // Fat projections have size equal to number of registers killed
 828           lrg.set_num_regs(rm.Size());
 829           lrg.set_reg_pressure(lrg.num_regs());
 830           lrg._fat_proj = 1;
 831           lrg._is_bound = 1;
 832           break;
 833         case Op_RegP:
 834 #ifdef _LP64
 835           lrg.set_num_regs(2);  // Size is 2 stack words
 836 #else
 837           lrg.set_num_regs(1);  // Size is 1 stack word
 838 #endif
 839           // Register pressure is tracked relative to the maximum values
 840           // suggested for that platform, INTPRESSURE and FLOATPRESSURE,
 841           // and relative to other types which compete for the same regs.
 842           //
 843           // The following table contains suggested values based on the
 844           // architectures as defined in each .ad file.
 845           // INTPRESSURE and FLOATPRESSURE may be tuned differently for
 846           // compile-speed or performance.
 847           // Note1:
 848           // SPARC and SPARCV9 reg_pressures are at 2 instead of 1
 849           // since .ad registers are defined as high and low halves.
 850           // These reg_pressure values remain compatible with the code
 851           // in is_high_pressure() which relates get_invalid_mask_size(),
 852           // Block::_reg_pressure and INTPRESSURE, FLOATPRESSURE.
 853           // Note2:
 854           // SPARC -d32 has 24 registers available for integral values,
 855           // but only 10 of these are safe for 64-bit longs.
 856           // Using set_reg_pressure(2) for both int and long means
 857           // the allocator will believe it can fit 26 longs into
 858           // registers.  Using 2 for longs and 1 for ints means the
 859           // allocator will attempt to put 52 integers into registers.
 860           // The settings below limit this problem to methods with
 861           // many long values which are being run on 32-bit SPARC.
 862           //
 863           // ------------------- reg_pressure --------------------
 864           // Each entry is reg_pressure_per_value,number_of_regs
 865           //         RegL  RegI  RegFlags   RegF RegD    INTPRESSURE  FLOATPRESSURE
 866           // IA32     2     1     1          1    1          6           6
 867           // IA64     1     1     1          1    1         50          41
 868           // SPARC    2     2     2          2    2         48 (24)     52 (26)
 869           // SPARCV9  2     2     2          2    2         48 (24)     52 (26)
 870           // AMD64    1     1     1          1    1         14          15
 871           // -----------------------------------------------------
 872 #if defined(SPARC)
 873           lrg.set_reg_pressure(2);  // use for v9 as well
 874 #else
 875           lrg.set_reg_pressure(1);  // normally one value per register
 876 #endif
 877           if( n_type-&gt;isa_oop_ptr() ) {
 878             lrg._is_oop = 1;
 879           }
 880           break;
 881         case Op_RegL:           // Check for long or double
 882         case Op_RegD:
 883           lrg.set_num_regs(2);
 884           // Define platform specific register pressure
 885 #if defined(SPARC) || defined(ARM32)
 886           lrg.set_reg_pressure(2);
 887 #elif defined(IA32)
 888           if( ireg == Op_RegL ) {
 889             lrg.set_reg_pressure(2);
 890           } else {
 891             lrg.set_reg_pressure(1);
 892           }
 893 #else
 894           lrg.set_reg_pressure(1);  // normally one value per register
 895 #endif
 896           // If this def of a double forces a mis-aligned double,
 897           // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
 898           // AND changes how we count interferences.  A mis-aligned
 899           // double can interfere with TWO aligned pairs, or effectively
 900           // FOUR registers!
 901           if (rm.is_misaligned_pair()) {
 902             lrg._fat_proj = 1;
 903             lrg._is_bound = 1;
 904           }
 905           break;
 906         case Op_RegF:
 907         case Op_RegI:
 908         case Op_RegN:
 909         case Op_RegFlags:
 910         case 0:                 // not an ideal register
 911           lrg.set_num_regs(1);
 912 #ifdef SPARC
 913           lrg.set_reg_pressure(2);
 914 #else
 915           lrg.set_reg_pressure(1);
 916 #endif
 917           break;
 918         case Op_VecS:
 919           assert(Matcher::vector_size_supported(T_BYTE,4), &quot;sanity&quot;);
 920           assert(RegMask::num_registers(Op_VecS) == RegMask::SlotsPerVecS, &quot;sanity&quot;);
 921           lrg.set_num_regs(RegMask::SlotsPerVecS);
 922           lrg.set_reg_pressure(1);
 923           break;
 924         case Op_VecD:
 925           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecD), &quot;sanity&quot;);
 926           assert(RegMask::num_registers(Op_VecD) == RegMask::SlotsPerVecD, &quot;sanity&quot;);
 927           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecD), &quot;vector should be aligned&quot;);
 928           lrg.set_num_regs(RegMask::SlotsPerVecD);
 929           lrg.set_reg_pressure(1);
 930           break;
 931         case Op_VecX:
 932           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecX), &quot;sanity&quot;);
 933           assert(RegMask::num_registers(Op_VecX) == RegMask::SlotsPerVecX, &quot;sanity&quot;);
 934           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecX), &quot;vector should be aligned&quot;);
 935           lrg.set_num_regs(RegMask::SlotsPerVecX);
 936           lrg.set_reg_pressure(1);
 937           break;
 938         case Op_VecY:
 939           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecY), &quot;sanity&quot;);
 940           assert(RegMask::num_registers(Op_VecY) == RegMask::SlotsPerVecY, &quot;sanity&quot;);
 941           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecY), &quot;vector should be aligned&quot;);
 942           lrg.set_num_regs(RegMask::SlotsPerVecY);
 943           lrg.set_reg_pressure(1);
 944           break;
 945         case Op_VecZ:
 946           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecZ), &quot;sanity&quot;);
 947           assert(RegMask::num_registers(Op_VecZ) == RegMask::SlotsPerVecZ, &quot;sanity&quot;);
 948           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecZ), &quot;vector should be aligned&quot;);
 949           lrg.set_num_regs(RegMask::SlotsPerVecZ);
 950           lrg.set_reg_pressure(1);
 951           break;
 952         default:
 953           ShouldNotReachHere();
 954         }
 955       }
 956 
 957       // Now do the same for inputs
 958       uint cnt = n-&gt;req();
 959       // Setup for CISC SPILLING
 960       uint inp = (uint)AdlcVMDeps::Not_cisc_spillable;
 961       if( UseCISCSpill &amp;&amp; after_aggressive ) {
 962         inp = n-&gt;cisc_operand();
 963         if( inp != (uint)AdlcVMDeps::Not_cisc_spillable )
 964           // Convert operand number to edge index number
 965           inp = n-&gt;as_Mach()-&gt;operand_index(inp);
 966       }
 967 
 968       // Prepare register mask for each input
 969       for( uint k = input_edge_start; k &lt; cnt; k++ ) {
 970         uint vreg = _lrg_map.live_range_id(n-&gt;in(k));
 971         if (!vreg) {
 972           continue;
 973         }
 974 
 975         // If this instruction is CISC Spillable, add the flags
 976         // bit to its appropriate input
 977         if( UseCISCSpill &amp;&amp; after_aggressive &amp;&amp; inp == k ) {
 978 #ifndef PRODUCT
 979           if( TraceCISCSpill ) {
 980             tty-&gt;print(&quot;  use_cisc_RegMask: &quot;);
 981             n-&gt;dump();
 982           }
 983 #endif
 984           n-&gt;as_Mach()-&gt;use_cisc_RegMask();
 985         }
 986 
 987         if (is_machine_node &amp;&amp; _scheduling_info_generated) {
 988           MachNode* cur_node = n-&gt;as_Mach();
 989           // this is cleaned up by register allocation
 990           if (k &gt;= cur_node-&gt;num_opnds()) continue;
 991         }
 992 
 993         LRG &amp;lrg = lrgs(vreg);
 994         // // Testing for floating point code shape
 995         // Node *test = n-&gt;in(k);
 996         // if( test-&gt;is_Mach() ) {
 997         //   MachNode *m = test-&gt;as_Mach();
 998         //   int  op = m-&gt;ideal_Opcode();
 999         //   if (n-&gt;is_Call() &amp;&amp; (op == Op_AddF || op == Op_MulF) ) {
1000         //     int zzz = 1;
1001         //   }
1002         // }
1003 
1004         // Limit result register mask to acceptable registers.
1005         // Do not limit registers from uncommon uses before
1006         // AggressiveCoalesce.  This effectively pre-virtual-splits
1007         // around uncommon uses of common defs.
1008         const RegMask &amp;rm = n-&gt;in_RegMask(k);
1009         if (!after_aggressive &amp;&amp; _cfg.get_block_for_node(n-&gt;in(k))-&gt;_freq &gt; 1000 * block-&gt;_freq) {
1010           // Since we are BEFORE aggressive coalesce, leave the register
1011           // mask untrimmed by the call.  This encourages more coalescing.
1012           // Later, AFTER aggressive, this live range will have to spill
1013           // but the spiller handles slow-path calls very nicely.
1014         } else {
1015           lrg.AND( rm );
1016         }
1017 
1018         // Check for bound register masks
1019         const RegMask &amp;lrgmask = lrg.mask();
1020         uint kreg = n-&gt;in(k)-&gt;ideal_reg();
1021         bool is_vect = RegMask::is_vector(kreg);
1022         assert(n-&gt;in(k)-&gt;bottom_type()-&gt;isa_vect() == NULL ||
1023                is_vect || kreg == Op_RegD || kreg == Op_RegL,
1024                &quot;vector must be in vector registers&quot;);
1025         if (lrgmask.is_bound(kreg))
1026           lrg._is_bound = 1;
1027 
1028         // If this use of a double forces a mis-aligned double,
1029         // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
1030         // AND changes how we count interferences.  A mis-aligned
1031         // double can interfere with TWO aligned pairs, or effectively
1032         // FOUR registers!
1033 #ifdef ASSERT
1034         if (is_vect &amp;&amp; !_scheduling_info_generated) {
1035           if (lrg.num_regs() != 0) {
1036             assert(lrgmask.is_aligned_sets(lrg.num_regs()), &quot;vector should be aligned&quot;);
1037             assert(!lrg._fat_proj, &quot;sanity&quot;);
1038             assert(RegMask::num_registers(kreg) == lrg.num_regs(), &quot;sanity&quot;);
1039           } else {
1040             assert(n-&gt;is_Phi(), &quot;not all inputs processed only if Phi&quot;);
1041           }
1042         }
1043 #endif
1044         if (!is_vect &amp;&amp; lrg.num_regs() == 2 &amp;&amp; !lrg._fat_proj &amp;&amp; rm.is_misaligned_pair()) {
1045           lrg._fat_proj = 1;
1046           lrg._is_bound = 1;
1047         }
1048         // if the LRG is an unaligned pair, we will have to spill
1049         // so clear the LRG&#39;s register mask if it is not already spilled
1050         if (!is_vect &amp;&amp; !n-&gt;is_SpillCopy() &amp;&amp;
1051             (lrg._def == NULL || lrg.is_multidef() || !lrg._def-&gt;is_SpillCopy()) &amp;&amp;
1052             lrgmask.is_misaligned_pair()) {
1053           lrg.Clear();
1054         }
1055 
1056         // Check for maximum frequency value
1057         if (lrg._maxfreq &lt; block-&gt;_freq) {
1058           lrg._maxfreq = block-&gt;_freq;
1059         }
1060 
1061       } // End for all allocated inputs
1062     } // end for all instructions
1063   } // end for all blocks
1064 
1065   // Final per-liverange setup
1066   for (uint i2 = 0; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
1067     LRG &amp;lrg = lrgs(i2);
1068     assert(!lrg._is_vector || !lrg._fat_proj, &quot;sanity&quot;);
1069     if (lrg.num_regs() &gt; 1 &amp;&amp; !lrg._fat_proj) {
1070       lrg.clear_to_sets();
1071     }
1072     lrg.compute_set_mask_size();
1073     if (lrg.not_free()) {      // Handle case where we lose from the start
1074       lrg.set_reg(OptoReg::Name(LRG::SPILL_REG));
1075       lrg._direct_conflict = 1;
1076     }
1077     lrg.set_degree(0);          // no neighbors in IFG yet
1078   }
1079 }
1080 
1081 // Set the was-lo-degree bit.  Conservative coalescing should not change the
1082 // colorability of the graph.  If any live range was of low-degree before
1083 // coalescing, it should Simplify.  This call sets the was-lo-degree bit.
1084 // The bit is checked in Simplify.
1085 void PhaseChaitin::set_was_low() {
1086 #ifdef ASSERT
1087   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1088     int size = lrgs(i).num_regs();
1089     uint old_was_lo = lrgs(i)._was_lo;
1090     lrgs(i)._was_lo = 0;
1091     if( lrgs(i).lo_degree() ) {
1092       lrgs(i)._was_lo = 1;      // Trivially of low degree
1093     } else {                    // Else check the Brigg&#39;s assertion
1094       // Brigg&#39;s observation is that the lo-degree neighbors of a
1095       // hi-degree live range will not interfere with the color choices
1096       // of said hi-degree live range.  The Simplify reverse-stack-coloring
1097       // order takes care of the details.  Hence you do not have to count
1098       // low-degree neighbors when determining if this guy colors.
1099       int briggs_degree = 0;
1100       IndexSet *s = _ifg-&gt;neighbors(i);
1101       IndexSetIterator elements(s);
1102       uint lidx;
1103       while((lidx = elements.next()) != 0) {
1104         if( !lrgs(lidx).lo_degree() )
1105           briggs_degree += MAX2(size,lrgs(lidx).num_regs());
1106       }
1107       if( briggs_degree &lt; lrgs(i).degrees_of_freedom() )
1108         lrgs(i)._was_lo = 1;    // Low degree via the briggs assertion
1109     }
1110     assert(old_was_lo &lt;= lrgs(i)._was_lo, &quot;_was_lo may not decrease&quot;);
1111   }
1112 #endif
1113 }
1114 
1115 // Compute cost/area ratio, in case we spill.  Build the lo-degree list.
1116 void PhaseChaitin::cache_lrg_info( ) {
1117   Compile::TracePhase tp(&quot;chaitinCacheLRG&quot;, &amp;timers[_t_chaitinCacheLRG]);
1118 
1119   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1120     LRG &amp;lrg = lrgs(i);
1121 
1122     // Check for being of low degree: means we can be trivially colored.
1123     // Low degree, dead or must-spill guys just get to simplify right away
1124     if( lrg.lo_degree() ||
1125        !lrg.alive() ||
1126         lrg._must_spill ) {
1127       // Split low degree list into those guys that must get a
1128       // register and those that can go to register or stack.
1129       // The idea is LRGs that can go register or stack color first when
1130       // they have a good chance of getting a register.  The register-only
1131       // lo-degree live ranges always get a register.
1132       OptoReg::Name hi_reg = lrg.mask().find_last_elem();
1133       if( OptoReg::is_stack(hi_reg)) { // Can go to stack?
1134         lrg._next = _lo_stk_degree;
1135         _lo_stk_degree = i;
1136       } else {
1137         lrg._next = _lo_degree;
1138         _lo_degree = i;
1139       }
1140     } else {                    // Else high degree
1141       lrgs(_hi_degree)._prev = i;
1142       lrg._next = _hi_degree;
1143       lrg._prev = 0;
1144       _hi_degree = i;
1145     }
1146   }
1147 }
1148 
1149 // Simplify the IFG by removing LRGs of low degree.
1150 void PhaseChaitin::Simplify( ) {
1151   Compile::TracePhase tp(&quot;chaitinSimplify&quot;, &amp;timers[_t_chaitinSimplify]);
1152 
1153   while( 1 ) {                  // Repeat till simplified it all
1154     // May want to explore simplifying lo_degree before _lo_stk_degree.
1155     // This might result in more spills coloring into registers during
1156     // Select().
1157     while( _lo_degree || _lo_stk_degree ) {
1158       // If possible, pull from lo_stk first
1159       uint lo;
1160       if( _lo_degree ) {
1161         lo = _lo_degree;
1162         _lo_degree = lrgs(lo)._next;
1163       } else {
1164         lo = _lo_stk_degree;
1165         _lo_stk_degree = lrgs(lo)._next;
1166       }
1167 
1168       // Put the simplified guy on the simplified list.
1169       lrgs(lo)._next = _simplified;
1170       _simplified = lo;
1171       // If this guy is &quot;at risk&quot; then mark his current neighbors
<a name="2" id="anc2"></a><span class="line-modified">1172       if( lrgs(lo)._at_risk ) {</span>
1173         IndexSetIterator elements(_ifg-&gt;neighbors(lo));
1174         uint datum;
1175         while ((datum = elements.next()) != 0) {
1176           lrgs(datum)._risk_bias = lo;
1177         }
1178       }
1179 
1180       // Yank this guy from the IFG.
<a name="3" id="anc3"></a><span class="line-modified">1181       IndexSet *adj = _ifg-&gt;remove_node( lo );</span>



1182 
1183       // If any neighbors&#39; degrees fall below their number of
1184       // allowed registers, then put that neighbor on the low degree
1185       // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
1186       // unchanged by this action.  Thus the two are equal at most once,
1187       // so LRGs hit the lo-degree worklist at most once.
1188       IndexSetIterator elements(adj);
1189       uint neighbor;
1190       while ((neighbor = elements.next()) != 0) {
1191         LRG *n = &amp;lrgs(neighbor);
1192 #ifdef ASSERT
<a name="4" id="anc4"></a><span class="line-modified">1193         if( VerifyOpto || VerifyRegisterAllocator ) {</span>
1194           assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
1195         }
1196 #endif
1197 
1198         // Check for just becoming of-low-degree just counting registers.
1199         // _must_spill live ranges are already on the low degree list.
<a name="5" id="anc5"></a><span class="line-modified">1200         if( n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill ) {</span>
<span class="line-modified">1201           assert(!(*_ifg-&gt;_yanked)[neighbor],&quot;Cannot move to lo degree twice&quot;);</span>
1202           // Pull from hi-degree list
1203           uint prev = n-&gt;_prev;
1204           uint next = n-&gt;_next;
<a name="6" id="anc6"></a><span class="line-modified">1205           if( prev ) lrgs(prev)._next = next;</span>
<span class="line-modified">1206           else _hi_degree = next;</span>



1207           lrgs(next)._prev = prev;
1208           n-&gt;_next = _lo_degree;
1209           _lo_degree = neighbor;
1210         }
1211       }
1212     } // End of while lo-degree/lo_stk_degree worklist not empty
1213 
1214     // Check for got everything: is hi-degree list empty?
<a name="7" id="anc7"></a><span class="line-modified">1215     if( !_hi_degree ) break;</span>
1216 
1217     // Time to pick a potential spill guy
1218     uint lo_score = _hi_degree;
1219     double score = lrgs(lo_score).score();
1220     double area = lrgs(lo_score)._area;
1221     double cost = lrgs(lo_score)._cost;
1222     bool bound = lrgs(lo_score)._is_bound;
1223 
1224     // Find cheapest guy
1225     debug_only( int lo_no_simplify=0; );
<a name="8" id="anc8"></a><span class="line-modified">1226     for( uint i = _hi_degree; i; i = lrgs(i)._next ) {</span>
<span class="line-modified">1227       assert( !(*_ifg-&gt;_yanked)[i], &quot;&quot; );</span>
1228       // It&#39;s just vaguely possible to move hi-degree to lo-degree without
1229       // going through a just-lo-degree stage: If you remove a double from
1230       // a float live range it&#39;s degree will drop by 2 and you can skip the
1231       // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
1232       // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
1233       if( lrgs(i).lo_degree() ) {
1234         lo_score = i;
1235         break;
1236       }
1237       debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );
1238       double iscore = lrgs(i).score();
1239       double iarea = lrgs(i)._area;
1240       double icost = lrgs(i)._cost;
1241       bool ibound = lrgs(i)._is_bound;
1242 
1243       // Compare cost/area of i vs cost/area of lo_score.  Smaller cost/area
1244       // wins.  Ties happen because all live ranges in question have spilled
1245       // a few times before and the spill-score adds a huge number which
1246       // washes out the low order bits.  We are choosing the lesser of 2
1247       // evils; in this case pick largest area to spill.
1248       // Ties also happen when live ranges are defined and used only inside
1249       // one block. In which case their area is 0 and score set to max.
1250       // In such case choose bound live range over unbound to free registers
1251       // or with smaller cost to spill.
<a name="9" id="anc9"></a><span class="line-modified">1252       if( iscore &lt; score ||</span>
1253           (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
1254           (iscore == score &amp;&amp; iarea == area &amp;&amp;
1255            ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
1256         lo_score = i;
1257         score = iscore;
1258         area = iarea;
1259         cost = icost;
1260         bound = ibound;
1261       }
1262     }
1263     LRG *lo_lrg = &amp;lrgs(lo_score);
1264     // The live range we choose for spilling is either hi-degree, or very
1265     // rarely it can be low-degree.  If we choose a hi-degree live range
1266     // there better not be any lo-degree choices.
1267     assert( lo_lrg-&gt;lo_degree() || !lo_no_simplify, &quot;Live range was lo-degree before coalesce; should simplify&quot; );
1268 
1269     // Pull from hi-degree list
1270     uint prev = lo_lrg-&gt;_prev;
1271     uint next = lo_lrg-&gt;_next;
1272     if( prev ) lrgs(prev)._next = next;
1273     else _hi_degree = next;
1274     lrgs(next)._prev = prev;
1275     // Jam him on the lo-degree list, despite his high degree.
1276     // Maybe he&#39;ll get a color, and maybe he&#39;ll spill.
1277     // Only Select() will know.
1278     lrgs(lo_score)._at_risk = true;
1279     _lo_degree = lo_score;
1280     lo_lrg-&gt;_next = 0;
1281 
1282   } // End of while not simplified everything
1283 
1284 }
1285 
1286 // Is &#39;reg&#39; register legal for &#39;lrg&#39;?
1287 static bool is_legal_reg(LRG &amp;lrg, OptoReg::Name reg, int chunk) {
1288   if (reg &gt;= chunk &amp;&amp; reg &lt; (chunk + RegMask::CHUNK_SIZE) &amp;&amp;
1289       lrg.mask().Member(OptoReg::add(reg,-chunk))) {
1290     // RA uses OptoReg which represent the highest element of a registers set.
1291     // For example, vectorX (128bit) on x86 uses [XMM,XMMb,XMMc,XMMd] set
1292     // in which XMMd is used by RA to represent such vectors. A double value
1293     // uses [XMM,XMMb] pairs and XMMb is used by RA for it.
1294     // The register mask uses largest bits set of overlapping register sets.
1295     // On x86 with AVX it uses 8 bits for each XMM registers set.
1296     //
1297     // The &#39;lrg&#39; already has cleared-to-set register mask (done in Select()
1298     // before calling choose_color()). Passing mask.Member(reg) check above
1299     // indicates that the size (num_regs) of &#39;reg&#39; set is less or equal to
1300     // &#39;lrg&#39; set size.
1301     // For set size 1 any register which is member of &#39;lrg&#39; mask is legal.
1302     if (lrg.num_regs()==1)
1303       return true;
1304     // For larger sets only an aligned register with the same set size is legal.
1305     int mask = lrg.num_regs()-1;
1306     if ((reg&amp;mask) == mask)
1307       return true;
1308   }
1309   return false;
1310 }
1311 
1312 // Choose a color using the biasing heuristic
1313 OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
1314 
1315   // Check for &quot;at_risk&quot; LRG&#39;s
1316   uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<a name="10" id="anc10"></a><span class="line-modified">1317   if( risk_lrg != 0 ) {</span>
1318     // Walk the colored neighbors of the &quot;at_risk&quot; candidate
1319     // Choose a color which is both legal and already taken by a neighbor
1320     // of the &quot;at_risk&quot; candidate in order to improve the chances of the
1321     // &quot;at_risk&quot; candidate of coloring
1322     IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
1323     uint datum;
1324     while ((datum = elements.next()) != 0) {
1325       OptoReg::Name reg = lrgs(datum).reg();
1326       // If this LRG&#39;s register is legal for us, choose it
1327       if (is_legal_reg(lrg, reg, chunk))
1328         return reg;
1329     }
1330   }
1331 
1332   uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<a name="11" id="anc11"></a><span class="line-modified">1333   if( copy_lrg != 0 ) {</span>
1334     // If he has a color,
<a name="12" id="anc12"></a><span class="line-modified">1335     if( !(*(_ifg-&gt;_yanked))[copy_lrg] ) {</span>
1336       OptoReg::Name reg = lrgs(copy_lrg).reg();
1337       //  And it is legal for you,
1338       if (is_legal_reg(lrg, reg, chunk))
1339         return reg;
1340     } else if( chunk == 0 ) {
1341       // Choose a color which is legal for him
1342       RegMask tempmask = lrg.mask();
1343       tempmask.AND(lrgs(copy_lrg).mask());
1344       tempmask.clear_to_sets(lrg.num_regs());
1345       OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());
1346       if (OptoReg::is_valid(reg))
1347         return reg;
1348     }
1349   }
1350 
1351   // If no bias info exists, just go with the register selection ordering
1352   if (lrg._is_vector || lrg.num_regs() == 2) {
1353     // Find an aligned set
1354     return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);
1355   }
1356 
1357   // CNC - Fun hack.  Alternate 1st and 2nd selection.  Enables post-allocate
1358   // copy removal to remove many more copies, by preventing a just-assigned
1359   // register from being repeatedly assigned.
1360   OptoReg::Name reg = lrg.mask().find_first_elem();
1361   if( (++_alternate &amp; 1) &amp;&amp; OptoReg::is_valid(reg) ) {
1362     // This &#39;Remove; find; Insert&#39; idiom is an expensive way to find the
1363     // SECOND element in the mask.
1364     lrg.Remove(reg);
1365     OptoReg::Name reg2 = lrg.mask().find_first_elem();
1366     lrg.Insert(reg);
1367     if( OptoReg::is_reg(reg2))
1368       reg = reg2;
1369   }
1370   return OptoReg::add( reg, chunk );
1371 }
1372 
1373 // Choose a color in the current chunk
1374 OptoReg::Name PhaseChaitin::choose_color( LRG &amp;lrg, int chunk ) {
1375   assert( C-&gt;in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1376   assert(C-&gt;out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1377 
1378   if( lrg.num_regs() == 1 ||    // Common Case
1379       !lrg._fat_proj )          // Aligned+adjacent pairs ok
1380     // Use a heuristic to &quot;bias&quot; the color choice
1381     return bias_color(lrg, chunk);
1382 
1383   assert(!lrg._is_vector, &quot;should be not vector here&quot; );
1384   assert( lrg.num_regs() &gt;= 2, &quot;dead live ranges do not color&quot; );
1385 
1386   // Fat-proj case or misaligned double argument.
1387   assert(lrg.compute_mask_size() == lrg.num_regs() ||
1388          lrg.num_regs() == 2,&quot;fat projs exactly color&quot; );
1389   assert( !chunk, &quot;always color in 1st chunk&quot; );
1390   // Return the highest element in the set.
1391   return lrg.mask().find_last_elem();
1392 }
1393 
1394 // Select colors by re-inserting LRGs back into the IFG.  LRGs are re-inserted
1395 // in reverse order of removal.  As long as nothing of hi-degree was yanked,
1396 // everything going back is guaranteed a color.  Select that color.  If some
1397 // hi-degree LRG cannot get a color then we record that we must spill.
1398 uint PhaseChaitin::Select( ) {
1399   Compile::TracePhase tp(&quot;chaitinSelect&quot;, &amp;timers[_t_chaitinSelect]);
1400 
1401   uint spill_reg = LRG::SPILL_REG;
1402   _max_reg = OptoReg::Name(0);  // Past max register used
1403   while( _simplified ) {
1404     // Pull next LRG from the simplified list - in reverse order of removal
1405     uint lidx = _simplified;
1406     LRG *lrg = &amp;lrgs(lidx);
1407     _simplified = lrg-&gt;_next;
1408 
1409 
1410 #ifndef PRODUCT
1411     if (trace_spilling()) {
1412       ttyLocker ttyl;
1413       tty-&gt;print_cr(&quot;L%d selecting degree %d degrees_of_freedom %d&quot;, lidx, lrg-&gt;degree(),
1414                     lrg-&gt;degrees_of_freedom());
1415       lrg-&gt;dump();
1416     }
1417 #endif
1418 
1419     // Re-insert into the IFG
1420     _ifg-&gt;re_insert(lidx);
1421     if( !lrg-&gt;alive() ) continue;
1422     // capture allstackedness flag before mask is hacked
1423     const int is_allstack = lrg-&gt;mask().is_AllStack();
1424 
1425     // Yeah, yeah, yeah, I know, I know.  I can refactor this
1426     // to avoid the GOTO, although the refactored code will not
1427     // be much clearer.  We arrive here IFF we have a stack-based
1428     // live range that cannot color in the current chunk, and it
1429     // has to move into the next free stack chunk.
1430     int chunk = 0;              // Current chunk is first chunk
1431     retry_next_chunk:
1432 
1433     // Remove neighbor colors
1434     IndexSet *s = _ifg-&gt;neighbors(lidx);
<a name="13" id="anc13"></a><span class="line-removed">1435 </span>
1436     debug_only(RegMask orig_mask = lrg-&gt;mask();)
<a name="14" id="anc14"></a><span class="line-modified">1437     IndexSetIterator elements(s);</span>
<span class="line-modified">1438     uint neighbor;</span>
<span class="line-modified">1439     while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">1440       // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">1441       // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">1442       // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">1443       // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">1444       // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">1445       // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">1446       LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">1447       OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-modified">1448       // Only subtract masks in the same chunk</span>
<span class="line-modified">1449       if( nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE ) {</span>


1450 #ifndef PRODUCT
<a name="15" id="anc15"></a><span class="line-modified">1451         uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">1452         RegMask rm = lrg-&gt;mask();</span>
1453 #endif
<a name="16" id="anc16"></a><span class="line-modified">1454         lrg-&gt;SUBTRACT(nlrg.mask());</span>
1455 #ifndef PRODUCT
<a name="17" id="anc17"></a><span class="line-modified">1456         if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">1457           ttyLocker ttyl;</span>
<span class="line-modified">1458           tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">1459           rm.dump();</span>
<span class="line-modified">1460           tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">1461           nlrg.mask().dump();</span>
<span class="line-modified">1462           tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">1463           rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">1464           rm.dump();</span>
<span class="line-modified">1465           tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">1466           lrg-&gt;mask().dump();</span>
<span class="line-modified">1467           tty-&gt;cr();</span>
<span class="line-modified">1468         }</span>
1469 #endif
<a name="18" id="anc18"></a>
1470       }
1471     }
1472     //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
1473     // Aligned pairs need aligned masks
1474     assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1475     if (lrg-&gt;num_regs() &gt; 1 &amp;&amp; !lrg-&gt;_fat_proj) {
1476       lrg-&gt;clear_to_sets();
1477     }
1478 
1479     // Check if a color is available and if so pick the color
1480     OptoReg::Name reg = choose_color( *lrg, chunk );
1481 #ifdef SPARC
1482     debug_only(lrg-&gt;compute_set_mask_size());
1483     assert(lrg-&gt;num_regs() &lt; 2 || lrg-&gt;is_bound() || is_even(reg-1), &quot;allocate all doubles aligned&quot;);
1484 #endif
1485 
1486     //---------------
1487     // If we fail to color and the AllStack flag is set, trigger
1488     // a chunk-rollover event
1489     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) &amp;&amp; is_allstack) {
1490       // Bump register mask up to next stack chunk
1491       chunk += RegMask::CHUNK_SIZE;
1492       lrg-&gt;Set_All();
1493 
1494       goto retry_next_chunk;
1495     }
1496 
1497     //---------------
1498     // Did we get a color?
1499     else if( OptoReg::is_valid(reg)) {
1500 #ifndef PRODUCT
1501       RegMask avail_rm = lrg-&gt;mask();
1502 #endif
1503 
1504       // Record selected register
1505       lrg-&gt;set_reg(reg);
1506 
1507       if( reg &gt;= _max_reg )     // Compute max register limit
1508         _max_reg = OptoReg::add(reg,1);
1509       // Fold reg back into normal space
1510       reg = OptoReg::add(reg,-chunk);
1511 
1512       // If the live range is not bound, then we actually had some choices
1513       // to make.  In this case, the mask has more bits in it than the colors
1514       // chosen.  Restrict the mask to just what was picked.
1515       int n_regs = lrg-&gt;num_regs();
1516       assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1517       if (n_regs == 1 || !lrg-&gt;_fat_proj) {
1518         assert(!lrg-&gt;_is_vector || n_regs &lt;= RegMask::SlotsPerVecZ, &quot;sanity&quot;);
1519         lrg-&gt;Clear();           // Clear the mask
1520         lrg-&gt;Insert(reg);       // Set regmask to match selected reg
1521         // For vectors and pairs, also insert the low bit of the pair
1522         for (int i = 1; i &lt; n_regs; i++)
1523           lrg-&gt;Insert(OptoReg::add(reg,-i));
1524         lrg-&gt;set_mask_size(n_regs);
1525       } else {                  // Else fatproj
1526         // mask must be equal to fatproj bits, by definition
1527       }
1528 #ifndef PRODUCT
1529       if (trace_spilling()) {
1530         ttyLocker ttyl;
1531         tty-&gt;print(&quot;L%d selected &quot;, lidx);
1532         lrg-&gt;mask().dump();
1533         tty-&gt;print(&quot; from &quot;);
1534         avail_rm.dump();
1535         tty-&gt;cr();
1536       }
1537 #endif
1538       // Note that reg is the highest-numbered register in the newly-bound mask.
1539     } // end color available case
1540 
1541     //---------------
1542     // Live range is live and no colors available
1543     else {
1544       assert( lrg-&gt;alive(), &quot;&quot; );
1545       assert( !lrg-&gt;_fat_proj || lrg-&gt;is_multidef() ||
1546               lrg-&gt;_def-&gt;outcnt() &gt; 0, &quot;fat_proj cannot spill&quot;);
1547       assert( !orig_mask.is_AllStack(), &quot;All Stack does not spill&quot; );
1548 
1549       // Assign the special spillreg register
1550       lrg-&gt;set_reg(OptoReg::Name(spill_reg++));
1551       // Do not empty the regmask; leave mask_size lying around
1552       // for use during Spilling
1553 #ifndef PRODUCT
1554       if( trace_spilling() ) {
1555         ttyLocker ttyl;
1556         tty-&gt;print(&quot;L%d spilling with neighbors: &quot;, lidx);
1557         s-&gt;dump();
1558         debug_only(tty-&gt;print(&quot; original mask: &quot;));
1559         debug_only(orig_mask.dump());
1560         dump_lrg(lidx);
1561       }
1562 #endif
1563     } // end spill case
1564 
1565   }
1566 
1567   return spill_reg-LRG::SPILL_REG;      // Return number of spills
1568 }
1569 
1570 // Set the &#39;spilled_once&#39; or &#39;spilled_twice&#39; flag on a node.
1571 void PhaseChaitin::set_was_spilled( Node *n ) {
1572   if( _spilled_once.test_set(n-&gt;_idx) )
1573     _spilled_twice.set(n-&gt;_idx);
1574 }
1575 
1576 // Convert Ideal spill instructions into proper FramePtr + offset Loads and
1577 // Stores.  Use-def chains are NOT preserved, but Node-&gt;LRG-&gt;reg maps are.
1578 void PhaseChaitin::fixup_spills() {
1579   // This function does only cisc spill work.
1580   if( !UseCISCSpill ) return;
1581 
1582   Compile::TracePhase tp(&quot;fixupSpills&quot;, &amp;timers[_t_fixupSpills]);
1583 
1584   // Grab the Frame Pointer
1585   Node *fp = _cfg.get_root_block()-&gt;head()-&gt;in(1)-&gt;in(TypeFunc::FramePtr);
1586 
1587   // For all blocks
1588   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1589     Block* block = _cfg.get_block(i);
1590 
1591     // For all instructions in block
1592     uint last_inst = block-&gt;end_idx();
1593     for (uint j = 1; j &lt;= last_inst; j++) {
1594       Node* n = block-&gt;get_node(j);
1595 
1596       // Dead instruction???
1597       assert( n-&gt;outcnt() != 0 ||// Nothing dead after post alloc
1598               C-&gt;top() == n ||  // Or the random TOP node
1599               n-&gt;is_Proj(),     // Or a fat-proj kill node
1600               &quot;No dead instructions after post-alloc&quot; );
1601 
1602       int inp = n-&gt;cisc_operand();
1603       if( inp != AdlcVMDeps::Not_cisc_spillable ) {
1604         // Convert operand number to edge index number
1605         MachNode *mach = n-&gt;as_Mach();
1606         inp = mach-&gt;operand_index(inp);
1607         Node *src = n-&gt;in(inp);   // Value to load or store
1608         LRG &amp;lrg_cisc = lrgs(_lrg_map.find_const(src));
1609         OptoReg::Name src_reg = lrg_cisc.reg();
1610         // Doubles record the HIGH register of an adjacent pair.
1611         src_reg = OptoReg::add(src_reg,1-lrg_cisc.num_regs());
1612         if( OptoReg::is_stack(src_reg) ) { // If input is on stack
1613           // This is a CISC Spill, get stack offset and construct new node
1614 #ifndef PRODUCT
1615           if( TraceCISCSpill ) {
1616             tty-&gt;print(&quot;    reg-instr:  &quot;);
1617             n-&gt;dump();
1618           }
1619 #endif
1620           int stk_offset = reg2offset(src_reg);
1621           // Bailout if we might exceed node limit when spilling this instruction
1622           C-&gt;check_node_count(0, &quot;out of nodes fixing spills&quot;);
1623           if (C-&gt;failing())  return;
1624           // Transform node
1625           MachNode *cisc = mach-&gt;cisc_version(stk_offset)-&gt;as_Mach();
1626           cisc-&gt;set_req(inp,fp);          // Base register is frame pointer
1627           if( cisc-&gt;oper_input_base() &gt; 1 &amp;&amp; mach-&gt;oper_input_base() &lt;= 1 ) {
1628             assert( cisc-&gt;oper_input_base() == 2, &quot;Only adding one edge&quot;);
1629             cisc-&gt;ins_req(1,src);         // Requires a memory edge
1630           }
1631           block-&gt;map_node(cisc, j);          // Insert into basic block
1632           n-&gt;subsume_by(cisc, C); // Correct graph
1633           //
1634           ++_used_cisc_instructions;
1635 #ifndef PRODUCT
1636           if( TraceCISCSpill ) {
1637             tty-&gt;print(&quot;    cisc-instr: &quot;);
1638             cisc-&gt;dump();
1639           }
1640 #endif
1641         } else {
1642 #ifndef PRODUCT
1643           if( TraceCISCSpill ) {
1644             tty-&gt;print(&quot;    using reg-instr: &quot;);
1645             n-&gt;dump();
1646           }
1647 #endif
1648           ++_unused_cisc_instructions;    // input can be on stack
1649         }
1650       }
1651 
1652     } // End of for all instructions
1653 
1654   } // End of for all blocks
1655 }
1656 
1657 // Helper to stretch above; recursively discover the base Node for a
1658 // given derived Node.  Easy for AddP-related machine nodes, but needs
1659 // to be recursive for derived Phis.
1660 Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &amp;maxlrg ) {
1661   // See if already computed; if so return it
1662   if( derived_base_map[derived-&gt;_idx] )
1663     return derived_base_map[derived-&gt;_idx];
1664 
1665   // See if this happens to be a base.
1666   // NOTE: we use TypePtr instead of TypeOopPtr because we can have
1667   // pointers derived from NULL!  These are always along paths that
1668   // can&#39;t happen at run-time but the optimizer cannot deduce it so
1669   // we have to handle it gracefully.
1670   assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1671           derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1672   const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1673   // If its an OOP with a non-zero offset, then it is derived.
1674   if( tj == NULL || tj-&gt;_offset == 0 ) {
1675     derived_base_map[derived-&gt;_idx] = derived;
1676     return derived;
1677   }
1678   // Derived is NULL+offset?  Base is NULL!
1679   if( derived-&gt;is_Con() ) {
1680     Node *base = _matcher.mach_null();
1681     assert(base != NULL, &quot;sanity&quot;);
1682     if (base-&gt;in(0) == NULL) {
1683       // Initialize it once and make it shared:
1684       // set control to _root and place it into Start block
1685       // (where top() node is placed).
1686       base-&gt;init_req(0, _cfg.get_root_node());
1687       Block *startb = _cfg.get_block_for_node(C-&gt;top());
1688       uint node_pos = startb-&gt;find_node(C-&gt;top());
1689       startb-&gt;insert_node(base, node_pos);
1690       _cfg.map_node_to_block(base, startb);
1691       assert(_lrg_map.live_range_id(base) == 0, &quot;should not have LRG yet&quot;);
1692 
1693       // The loadConP0 might have projection nodes depending on architecture
1694       // Add the projection nodes to the CFG
1695       for (DUIterator_Fast imax, i = base-&gt;fast_outs(imax); i &lt; imax; i++) {
1696         Node* use = base-&gt;fast_out(i);
1697         if (use-&gt;is_MachProj()) {
1698           startb-&gt;insert_node(use, ++node_pos);
1699           _cfg.map_node_to_block(use, startb);
1700           new_lrg(use, maxlrg++);
1701         }
1702       }
1703     }
1704     if (_lrg_map.live_range_id(base) == 0) {
1705       new_lrg(base, maxlrg++);
1706     }
1707     assert(base-&gt;in(0) == _cfg.get_root_node() &amp;&amp; _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C-&gt;top()), &quot;base NULL should be shared&quot;);
1708     derived_base_map[derived-&gt;_idx] = base;
1709     return base;
1710   }
1711 
1712   // Check for AddP-related opcodes
1713   if (!derived-&gt;is_Phi()) {
1714     assert(derived-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP, &quot;but is: %s&quot;, derived-&gt;Name());
1715     Node *base = derived-&gt;in(AddPNode::Base);
1716     derived_base_map[derived-&gt;_idx] = base;
1717     return base;
1718   }
1719 
1720   // Recursively find bases for Phis.
1721   // First check to see if we can avoid a base Phi here.
1722   Node *base = find_base_for_derived( derived_base_map, derived-&gt;in(1),maxlrg);
1723   uint i;
1724   for( i = 2; i &lt; derived-&gt;req(); i++ )
1725     if( base != find_base_for_derived( derived_base_map,derived-&gt;in(i),maxlrg))
1726       break;
1727   // Went to the end without finding any different bases?
1728   if( i == derived-&gt;req() ) {   // No need for a base Phi here
1729     derived_base_map[derived-&gt;_idx] = base;
1730     return base;
1731   }
1732 
1733   // Now we see we need a base-Phi here to merge the bases
1734   const Type *t = base-&gt;bottom_type();
1735   base = new PhiNode( derived-&gt;in(0), t );
1736   for( i = 1; i &lt; derived-&gt;req(); i++ ) {
1737     base-&gt;init_req(i, find_base_for_derived(derived_base_map, derived-&gt;in(i), maxlrg));
1738     t = t-&gt;meet(base-&gt;in(i)-&gt;bottom_type());
1739   }
1740   base-&gt;as_Phi()-&gt;set_type(t);
1741 
1742   // Search the current block for an existing base-Phi
1743   Block *b = _cfg.get_block_for_node(derived);
1744   for( i = 1; i &lt;= b-&gt;end_idx(); i++ ) {// Search for matching Phi
1745     Node *phi = b-&gt;get_node(i);
1746     if( !phi-&gt;is_Phi() ) {      // Found end of Phis with no match?
1747       b-&gt;insert_node(base,  i); // Must insert created Phi here as base
1748       _cfg.map_node_to_block(base, b);
1749       new_lrg(base,maxlrg++);
1750       break;
1751     }
1752     // See if Phi matches.
1753     uint j;
1754     for( j = 1; j &lt; base-&gt;req(); j++ )
1755       if( phi-&gt;in(j) != base-&gt;in(j) &amp;&amp;
1756           !(phi-&gt;in(j)-&gt;is_Con() &amp;&amp; base-&gt;in(j)-&gt;is_Con()) ) // allow different NULLs
1757         break;
1758     if( j == base-&gt;req() ) {    // All inputs match?
1759       base = phi;               // Then use existing &#39;phi&#39; and drop &#39;base&#39;
1760       break;
1761     }
1762   }
1763 
1764 
1765   // Cache info for later passes
1766   derived_base_map[derived-&gt;_idx] = base;
1767   return base;
1768 }
1769 
1770 // At each Safepoint, insert extra debug edges for each pair of derived value/
1771 // base pointer that is live across the Safepoint for oopmap building.  The
1772 // edge pairs get added in after sfpt-&gt;jvmtail()-&gt;oopoff(), but are in the
1773 // required edge set.
1774 bool PhaseChaitin::stretch_base_pointer_live_ranges(ResourceArea *a) {
1775   int must_recompute_live = false;
1776   uint maxlrg = _lrg_map.max_lrg_id();
1777   Node **derived_base_map = (Node**)a-&gt;Amalloc(sizeof(Node*)*C-&gt;unique());
1778   memset( derived_base_map, 0, sizeof(Node*)*C-&gt;unique() );
1779 
1780   // For all blocks in RPO do...
1781   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1782     Block* block = _cfg.get_block(i);
1783     // Note use of deep-copy constructor.  I cannot hammer the original
1784     // liveout bits, because they are needed by the following coalesce pass.
1785     IndexSet liveout(_live-&gt;live(block));
1786 
1787     for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
1788       Node* n = block-&gt;get_node(j - 1);
1789 
1790       // Pre-split compares of loop-phis.  Loop-phis form a cycle we would
1791       // like to see in the same register.  Compare uses the loop-phi and so
1792       // extends its live range BUT cannot be part of the cycle.  If this
1793       // extended live range overlaps with the update of the loop-phi value
1794       // we need both alive at the same time -- which requires at least 1
1795       // copy.  But because Intel has only 2-address registers we end up with
1796       // at least 2 copies, one before the loop-phi update instruction and
1797       // one after.  Instead we split the input to the compare just after the
1798       // phi.
1799       if( n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CmpI ) {
1800         Node *phi = n-&gt;in(1);
1801         if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;as_Phi()-&gt;region()-&gt;is_Loop() ) {
1802           Block *phi_block = _cfg.get_block_for_node(phi);
1803           if (_cfg.get_block_for_node(phi_block-&gt;pred(2)) == block) {
1804             const RegMask *mask = C-&gt;matcher()-&gt;idealreg2spillmask[Op_RegI];
1805             Node *spill = new MachSpillCopyNode(MachSpillCopyNode::LoopPhiInput, phi, *mask, *mask);
1806             insert_proj( phi_block, 1, spill, maxlrg++ );
1807             n-&gt;set_req(1,spill);
1808             must_recompute_live = true;
1809           }
1810         }
1811       }
1812 
1813       // Get value being defined
1814       uint lidx = _lrg_map.live_range_id(n);
1815       // Ignore the occasional brand-new live range
1816       if (lidx &amp;&amp; lidx &lt; _lrg_map.max_lrg_id()) {
1817         // Remove from live-out set
1818         liveout.remove(lidx);
1819 
1820         // Copies do not define a new value and so do not interfere.
1821         // Remove the copies source from the liveout set before interfering.
1822         uint idx = n-&gt;is_Copy();
1823         if (idx) {
1824           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1825         }
1826       }
1827 
1828       // Found a safepoint?
1829       JVMState *jvms = n-&gt;jvms();
<a name="19" id="anc19"></a><span class="line-modified">1830       if( jvms ) {</span>
1831         // Now scan for a live derived pointer
1832         IndexSetIterator elements(&amp;liveout);
1833         uint neighbor;
1834         while ((neighbor = elements.next()) != 0) {
1835           // Find reaching DEF for base and derived values
1836           // This works because we are still in SSA during this call.
1837           Node *derived = lrgs(neighbor)._def;
1838           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1839           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1840                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1841           // If its an OOP with a non-zero offset, then it is derived.
1842           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {
1843             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1844             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1845             // Add reaching DEFs of derived pointer and base pointer as a
1846             // pair of inputs
1847             n-&gt;add_req(derived);
1848             n-&gt;add_req(base);
1849 
1850             // See if the base pointer is already live to this point.
1851             // Since I&#39;m working on the SSA form, live-ness amounts to
1852             // reaching def&#39;s.  So if I find the base&#39;s live range then
1853             // I know the base&#39;s def reaches here.
1854             if ((_lrg_map.live_range_id(base) &gt;= _lrg_map.max_lrg_id() || // (Brand new base (hence not live) or
1855                  !liveout.member(_lrg_map.live_range_id(base))) &amp;&amp; // not live) AND
1856                  (_lrg_map.live_range_id(base) &gt; 0) &amp;&amp; // not a constant
1857                  _cfg.get_block_for_node(base) != block) { // base not def&#39;d in blk)
1858               // Base pointer is not currently live.  Since I stretched
1859               // the base pointer to here and it crosses basic-block
1860               // boundaries, the global live info is now incorrect.
1861               // Recompute live.
1862               must_recompute_live = true;
1863             } // End of if base pointer is not live to debug info
1864           }
1865         } // End of scan all live data for derived ptrs crossing GC point
1866       } // End of if found a GC point
1867 
1868       // Make all inputs live
1869       if (!n-&gt;is_Phi()) {      // Phi function uses come from prior block
1870         for (uint k = 1; k &lt; n-&gt;req(); k++) {
1871           uint lidx = _lrg_map.live_range_id(n-&gt;in(k));
1872           if (lidx &lt; _lrg_map.max_lrg_id()) {
1873             liveout.insert(lidx);
1874           }
1875         }
1876       }
1877 
1878     } // End of forall instructions in block
1879     liveout.clear();  // Free the memory used by liveout.
1880 
1881   } // End of forall blocks
1882   _lrg_map.set_max_lrg_id(maxlrg);
1883 
1884   // If I created a new live range I need to recompute live
1885   if (maxlrg != _ifg-&gt;_maxlrg) {
1886     must_recompute_live = true;
1887   }
1888 
1889   return must_recompute_live != 0;
1890 }
1891 
1892 // Extend the node to LRG mapping
1893 
1894 void PhaseChaitin::add_reference(const Node *node, const Node *old_node) {
1895   _lrg_map.extend(node-&gt;_idx, _lrg_map.live_range_id(old_node));
1896 }
1897 
1898 #ifndef PRODUCT
1899 void PhaseChaitin::dump(const Node *n) const {
1900   uint r = (n-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(n) : 0;
1901   tty-&gt;print(&quot;L%d&quot;,r);
1902   if (r &amp;&amp; n-&gt;Opcode() != Op_Phi) {
1903     if( _node_regs ) {          // Got a post-allocation copy of allocation?
1904       tty-&gt;print(&quot;[&quot;);
1905       OptoReg::Name second = get_reg_second(n);
1906       if( OptoReg::is_valid(second) ) {
1907         if( OptoReg::is_reg(second) )
1908           tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1909         else
1910           tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(second));
1911       }
1912       OptoReg::Name first = get_reg_first(n);
1913       if( OptoReg::is_reg(first) )
1914         tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1915       else
1916          tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(first));
1917     } else
1918     n-&gt;out_RegMask().dump();
1919   }
1920   tty-&gt;print(&quot;/N%d\t&quot;,n-&gt;_idx);
1921   tty-&gt;print(&quot;%s === &quot;, n-&gt;Name());
1922   uint k;
1923   for (k = 0; k &lt; n-&gt;req(); k++) {
1924     Node *m = n-&gt;in(k);
1925     if (!m) {
1926       tty-&gt;print(&quot;_ &quot;);
1927     }
1928     else {
1929       uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1930       tty-&gt;print(&quot;L%d&quot;,r);
1931       // Data MultiNode&#39;s can have projections with no real registers.
1932       // Don&#39;t die while dumping them.
1933       int op = n-&gt;Opcode();
1934       if( r &amp;&amp; op != Op_Phi &amp;&amp; op != Op_Proj &amp;&amp; op != Op_SCMemProj) {
1935         if( _node_regs ) {
1936           tty-&gt;print(&quot;[&quot;);
1937           OptoReg::Name second = get_reg_second(n-&gt;in(k));
1938           if( OptoReg::is_valid(second) ) {
1939             if( OptoReg::is_reg(second) )
1940               tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1941             else
1942               tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1943                          reg2offset_unchecked(second));
1944           }
1945           OptoReg::Name first = get_reg_first(n-&gt;in(k));
1946           if( OptoReg::is_reg(first) )
1947             tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1948           else
1949             tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1950                        reg2offset_unchecked(first));
1951         } else
1952           n-&gt;in_RegMask(k).dump();
1953       }
1954       tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1955     }
1956   }
1957   if( k &lt; n-&gt;len() &amp;&amp; n-&gt;in(k) ) tty-&gt;print(&quot;| &quot;);
1958   for( ; k &lt; n-&gt;len(); k++ ) {
1959     Node *m = n-&gt;in(k);
1960     if(!m) {
1961       break;
1962     }
1963     uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1964     tty-&gt;print(&quot;L%d&quot;,r);
1965     tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1966   }
1967   if( n-&gt;is_Mach() ) n-&gt;as_Mach()-&gt;dump_spec(tty);
1968   else n-&gt;dump_spec(tty);
1969   if( _spilled_once.test(n-&gt;_idx ) ) {
1970     tty-&gt;print(&quot; Spill_1&quot;);
1971     if( _spilled_twice.test(n-&gt;_idx ) )
1972       tty-&gt;print(&quot; Spill_2&quot;);
1973   }
1974   tty-&gt;print(&quot;\n&quot;);
1975 }
1976 
1977 void PhaseChaitin::dump(const Block *b) const {
1978   b-&gt;dump_head(&amp;_cfg);
1979 
1980   // For all instructions
1981   for( uint j = 0; j &lt; b-&gt;number_of_nodes(); j++ )
1982     dump(b-&gt;get_node(j));
1983   // Print live-out info at end of block
1984   if( _live ) {
1985     tty-&gt;print(&quot;Liveout: &quot;);
1986     IndexSet *live = _live-&gt;live(b);
1987     IndexSetIterator elements(live);
1988     tty-&gt;print(&quot;{&quot;);
1989     uint i;
1990     while ((i = elements.next()) != 0) {
1991       tty-&gt;print(&quot;L%d &quot;, _lrg_map.find_const(i));
1992     }
1993     tty-&gt;print_cr(&quot;}&quot;);
1994   }
1995   tty-&gt;print(&quot;\n&quot;);
1996 }
1997 
1998 void PhaseChaitin::dump() const {
1999   tty-&gt;print( &quot;--- Chaitin -- argsize: %d  framesize: %d ---\n&quot;,
2000               _matcher._new_SP, _framesize );
2001 
2002   // For all blocks
2003   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2004     dump(_cfg.get_block(i));
2005   }
2006   // End of per-block dump
2007   tty-&gt;print(&quot;\n&quot;);
2008 
2009   if (!_ifg) {
2010     tty-&gt;print(&quot;(No IFG.)\n&quot;);
2011     return;
2012   }
2013 
2014   // Dump LRG array
2015   tty-&gt;print(&quot;--- Live RanGe Array ---\n&quot;);
2016   for (uint i2 = 1; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
2017     tty-&gt;print(&quot;L%d: &quot;,i2);
2018     if (i2 &lt; _ifg-&gt;_maxlrg) {
2019       lrgs(i2).dump();
2020     }
2021     else {
2022       tty-&gt;print_cr(&quot;new LRG&quot;);
2023     }
2024   }
2025   tty-&gt;cr();
2026 
2027   // Dump lo-degree list
2028   tty-&gt;print(&quot;Lo degree: &quot;);
2029   for(uint i3 = _lo_degree; i3; i3 = lrgs(i3)._next )
2030     tty-&gt;print(&quot;L%d &quot;,i3);
2031   tty-&gt;cr();
2032 
2033   // Dump lo-stk-degree list
2034   tty-&gt;print(&quot;Lo stk degree: &quot;);
2035   for(uint i4 = _lo_stk_degree; i4; i4 = lrgs(i4)._next )
2036     tty-&gt;print(&quot;L%d &quot;,i4);
2037   tty-&gt;cr();
2038 
2039   // Dump lo-degree list
2040   tty-&gt;print(&quot;Hi degree: &quot;);
2041   for(uint i5 = _hi_degree; i5; i5 = lrgs(i5)._next )
2042     tty-&gt;print(&quot;L%d &quot;,i5);
2043   tty-&gt;cr();
2044 }
2045 
2046 void PhaseChaitin::dump_degree_lists() const {
2047   // Dump lo-degree list
2048   tty-&gt;print(&quot;Lo degree: &quot;);
2049   for( uint i = _lo_degree; i; i = lrgs(i)._next )
2050     tty-&gt;print(&quot;L%d &quot;,i);
2051   tty-&gt;cr();
2052 
2053   // Dump lo-stk-degree list
2054   tty-&gt;print(&quot;Lo stk degree: &quot;);
2055   for(uint i2 = _lo_stk_degree; i2; i2 = lrgs(i2)._next )
2056     tty-&gt;print(&quot;L%d &quot;,i2);
2057   tty-&gt;cr();
2058 
2059   // Dump lo-degree list
2060   tty-&gt;print(&quot;Hi degree: &quot;);
2061   for(uint i3 = _hi_degree; i3; i3 = lrgs(i3)._next )
2062     tty-&gt;print(&quot;L%d &quot;,i3);
2063   tty-&gt;cr();
2064 }
2065 
2066 void PhaseChaitin::dump_simplified() const {
2067   tty-&gt;print(&quot;Simplified: &quot;);
2068   for( uint i = _simplified; i; i = lrgs(i)._next )
2069     tty-&gt;print(&quot;L%d &quot;,i);
2070   tty-&gt;cr();
2071 }
2072 
2073 static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {
2074   if ((int)reg &lt; 0)
2075     sprintf(buf, &quot;&lt;OptoReg::%d&gt;&quot;, (int)reg);
2076   else if (OptoReg::is_reg(reg))
2077     strcpy(buf, Matcher::regName[reg]);
2078   else
2079     sprintf(buf,&quot;%s + #%d&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
2080             pc-&gt;reg2offset(reg));
2081   return buf+strlen(buf);
2082 }
2083 
2084 // Dump a register name into a buffer.  Be intelligent if we get called
2085 // before allocation is complete.
2086 char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<a name="20" id="anc20"></a><span class="line-modified">2087   if( this == NULL ) {          // Not got anything?</span>
<span class="line-removed">2088     sprintf(buf,&quot;N%d&quot;,n-&gt;_idx); // Then use Node index</span>
<span class="line-removed">2089   } else if( _node_regs ) {</span>
2090     // Post allocation, use direct mappings, no LRG info available
2091     print_reg( get_reg_first(n), this, buf );
2092   } else {
2093     uint lidx = _lrg_map.find_const(n); // Grab LRG number
2094     if( !_ifg ) {
2095       sprintf(buf,&quot;L%d&quot;,lidx);  // No register binding yet
2096     } else if( !lidx ) {        // Special, not allocated value
2097       strcpy(buf,&quot;Special&quot;);
2098     } else {
2099       if (lrgs(lidx)._is_vector) {
2100         if (lrgs(lidx).mask().is_bound_set(lrgs(lidx).num_regs()))
2101           print_reg( lrgs(lidx).reg(), this, buf ); // a bound machine register
2102         else
2103           sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2104       } else if( (lrgs(lidx).num_regs() == 1)
2105                  ? lrgs(lidx).mask().is_bound1()
2106                  : lrgs(lidx).mask().is_bound_pair() ) {
2107         // Hah!  We have a bound machine register
2108         print_reg( lrgs(lidx).reg(), this, buf );
2109       } else {
2110         sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2111       }
2112     }
2113   }
2114   return buf+strlen(buf);
2115 }
2116 
2117 void PhaseChaitin::dump_for_spill_split_recycle() const {
2118   if( WizardMode &amp;&amp; (PrintCompilation || PrintOpto) ) {
2119     // Display which live ranges need to be split and the allocator&#39;s state
2120     tty-&gt;print_cr(&quot;Graph-Coloring Iteration %d will split the following live ranges&quot;, _trip_cnt);
2121     for (uint bidx = 1; bidx &lt; _lrg_map.max_lrg_id(); bidx++) {
2122       if( lrgs(bidx).alive() &amp;&amp; lrgs(bidx).reg() &gt;= LRG::SPILL_REG ) {
2123         tty-&gt;print(&quot;L%d: &quot;, bidx);
2124         lrgs(bidx).dump();
2125       }
2126     }
2127     tty-&gt;cr();
2128     dump();
2129   }
2130 }
2131 
2132 void PhaseChaitin::dump_frame() const {
2133   const char *fp = OptoReg::regname(OptoReg::c_frame_pointer);
2134   const TypeTuple *domain = C-&gt;tf()-&gt;domain();
2135   const int        argcnt = domain-&gt;cnt() - TypeFunc::Parms;
2136 
2137   // Incoming arguments in registers dump
2138   for( int k = 0; k &lt; argcnt; k++ ) {
2139     OptoReg::Name parmreg = _matcher._parm_regs[k].first();
2140     if( OptoReg::is_reg(parmreg))  {
2141       const char *reg_name = OptoReg::regname(parmreg);
2142       tty-&gt;print(&quot;#r%3.3d %s&quot;, parmreg, reg_name);
2143       parmreg = _matcher._parm_regs[k].second();
2144       if( OptoReg::is_reg(parmreg))  {
2145         tty-&gt;print(&quot;:%s&quot;, OptoReg::regname(parmreg));
2146       }
2147       tty-&gt;print(&quot;   : parm %d: &quot;, k);
2148       domain-&gt;field_at(k + TypeFunc::Parms)-&gt;dump();
2149       tty-&gt;cr();
2150     }
2151   }
2152 
2153   // Check for un-owned padding above incoming args
2154   OptoReg::Name reg = _matcher._new_SP;
2155   if( reg &gt; _matcher._in_arg_limit ) {
2156     reg = OptoReg::add(reg, -1);
2157     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: pad0, owned by CALLER&quot;, reg, fp, reg2offset_unchecked(reg));
2158   }
2159 
2160   // Incoming argument area dump
2161   OptoReg::Name begin_in_arg = OptoReg::add(_matcher._old_SP,C-&gt;out_preserve_stack_slots());
2162   while( reg &gt; begin_in_arg ) {
2163     reg = OptoReg::add(reg, -1);
2164     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2165     int j;
2166     for( j = 0; j &lt; argcnt; j++) {
2167       if( _matcher._parm_regs[j].first() == reg ||
2168           _matcher._parm_regs[j].second() == reg ) {
2169         tty-&gt;print(&quot;parm %d: &quot;,j);
2170         domain-&gt;field_at(j + TypeFunc::Parms)-&gt;dump();
2171         tty-&gt;cr();
2172         break;
2173       }
2174     }
2175     if( j &gt;= argcnt )
2176       tty-&gt;print_cr(&quot;HOLE, owned by SELF&quot;);
2177   }
2178 
2179   // Old outgoing preserve area
2180   while( reg &gt; _matcher._old_SP ) {
2181     reg = OptoReg::add(reg, -1);
2182     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: old out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2183   }
2184 
2185   // Old SP
2186   tty-&gt;print_cr(&quot;# -- Old %s -- Framesize: %d --&quot;,fp,
2187     reg2offset_unchecked(OptoReg::add(_matcher._old_SP,-1)) - reg2offset_unchecked(_matcher._new_SP)+jintSize);
2188 
2189   // Preserve area dump
2190   int fixed_slots = C-&gt;fixed_slots();
2191   OptoReg::Name begin_in_preserve = OptoReg::add(_matcher._old_SP, -(int)C-&gt;in_preserve_stack_slots());
2192   OptoReg::Name return_addr = _matcher.return_addr();
2193 
2194   reg = OptoReg::add(reg, -1);
2195   while (OptoReg::is_stack(reg)) {
2196     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2197     if (return_addr == reg) {
2198       tty-&gt;print_cr(&quot;return address&quot;);
2199     } else if (reg &gt;= begin_in_preserve) {
2200       // Preserved slots are present on x86
2201       if (return_addr == OptoReg::add(reg, VMRegImpl::slots_per_word))
2202         tty-&gt;print_cr(&quot;saved fp register&quot;);
2203       else if (return_addr == OptoReg::add(reg, 2*VMRegImpl::slots_per_word) &amp;&amp;
2204                VerifyStackAtCalls)
2205         tty-&gt;print_cr(&quot;0xBADB100D   +VerifyStackAtCalls&quot;);
2206       else
2207         tty-&gt;print_cr(&quot;in_preserve&quot;);
2208     } else if ((int)OptoReg::reg2stack(reg) &lt; fixed_slots) {
2209       tty-&gt;print_cr(&quot;Fixed slot %d&quot;, OptoReg::reg2stack(reg));
2210     } else {
2211       tty-&gt;print_cr(&quot;pad2, stack alignment&quot;);
2212     }
2213     reg = OptoReg::add(reg, -1);
2214   }
2215 
2216   // Spill area dump
2217   reg = OptoReg::add(_matcher._new_SP, _framesize );
2218   while( reg &gt; _matcher._out_arg_limit ) {
2219     reg = OptoReg::add(reg, -1);
2220     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: spill&quot;,reg,fp,reg2offset_unchecked(reg));
2221   }
2222 
2223   // Outgoing argument area dump
2224   while( reg &gt; OptoReg::add(_matcher._new_SP, C-&gt;out_preserve_stack_slots()) ) {
2225     reg = OptoReg::add(reg, -1);
2226     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: outgoing argument&quot;,reg,fp,reg2offset_unchecked(reg));
2227   }
2228 
2229   // Outgoing new preserve area
2230   while( reg &gt; _matcher._new_SP ) {
2231     reg = OptoReg::add(reg, -1);
2232     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: new out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2233   }
2234   tty-&gt;print_cr(&quot;#&quot;);
2235 }
2236 
2237 void PhaseChaitin::dump_bb( uint pre_order ) const {
2238   tty-&gt;print_cr(&quot;---dump of B%d---&quot;,pre_order);
2239   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2240     Block* block = _cfg.get_block(i);
2241     if (block-&gt;_pre_order == pre_order) {
2242       dump(block);
2243     }
2244   }
2245 }
2246 
2247 void PhaseChaitin::dump_lrg( uint lidx, bool defs_only ) const {
2248   tty-&gt;print_cr(&quot;---dump of L%d---&quot;,lidx);
2249 
2250   if (_ifg) {
2251     if (lidx &gt;= _lrg_map.max_lrg_id()) {
2252       tty-&gt;print(&quot;Attempt to print live range index beyond max live range.\n&quot;);
2253       return;
2254     }
2255     tty-&gt;print(&quot;L%d: &quot;,lidx);
2256     if (lidx &lt; _ifg-&gt;_maxlrg) {
2257       lrgs(lidx).dump();
2258     } else {
2259       tty-&gt;print_cr(&quot;new LRG&quot;);
2260     }
2261   }
2262   if( _ifg &amp;&amp; lidx &lt; _ifg-&gt;_maxlrg) {
2263     tty-&gt;print(&quot;Neighbors: %d - &quot;, _ifg-&gt;neighbor_cnt(lidx));
2264     _ifg-&gt;neighbors(lidx)-&gt;dump();
2265     tty-&gt;cr();
2266   }
2267   // For all blocks
2268   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2269     Block* block = _cfg.get_block(i);
2270     int dump_once = 0;
2271 
2272     // For all instructions
2273     for( uint j = 0; j &lt; block-&gt;number_of_nodes(); j++ ) {
2274       Node *n = block-&gt;get_node(j);
2275       if (_lrg_map.find_const(n) == lidx) {
2276         if (!dump_once++) {
2277           tty-&gt;cr();
2278           block-&gt;dump_head(&amp;_cfg);
2279         }
2280         dump(n);
2281         continue;
2282       }
2283       if (!defs_only) {
2284         uint cnt = n-&gt;req();
2285         for( uint k = 1; k &lt; cnt; k++ ) {
2286           Node *m = n-&gt;in(k);
2287           if (!m)  {
2288             continue;  // be robust in the dumper
2289           }
2290           if (_lrg_map.find_const(m) == lidx) {
2291             if (!dump_once++) {
2292               tty-&gt;cr();
2293               block-&gt;dump_head(&amp;_cfg);
2294             }
2295             dump(n);
2296           }
2297         }
2298       }
2299     }
2300   } // End of per-block dump
2301   tty-&gt;cr();
2302 }
2303 #endif // not PRODUCT
2304 
2305 int PhaseChaitin::_final_loads  = 0;
2306 int PhaseChaitin::_final_stores = 0;
2307 int PhaseChaitin::_final_memoves= 0;
2308 int PhaseChaitin::_final_copies = 0;
2309 double PhaseChaitin::_final_load_cost  = 0;
2310 double PhaseChaitin::_final_store_cost = 0;
2311 double PhaseChaitin::_final_memove_cost= 0;
2312 double PhaseChaitin::_final_copy_cost  = 0;
2313 int PhaseChaitin::_conserv_coalesce = 0;
2314 int PhaseChaitin::_conserv_coalesce_pair = 0;
2315 int PhaseChaitin::_conserv_coalesce_trie = 0;
2316 int PhaseChaitin::_conserv_coalesce_quad = 0;
2317 int PhaseChaitin::_post_alloc = 0;
2318 int PhaseChaitin::_lost_opp_pp_coalesce = 0;
2319 int PhaseChaitin::_lost_opp_cflow_coalesce = 0;
2320 int PhaseChaitin::_used_cisc_instructions   = 0;
2321 int PhaseChaitin::_unused_cisc_instructions = 0;
2322 int PhaseChaitin::_allocator_attempts       = 0;
2323 int PhaseChaitin::_allocator_successes      = 0;
2324 
2325 #ifndef PRODUCT
2326 uint PhaseChaitin::_high_pressure           = 0;
2327 uint PhaseChaitin::_low_pressure            = 0;
2328 
2329 void PhaseChaitin::print_chaitin_statistics() {
2330   tty-&gt;print_cr(&quot;Inserted %d spill loads, %d spill stores, %d mem-mem moves and %d copies.&quot;, _final_loads, _final_stores, _final_memoves, _final_copies);
2331   tty-&gt;print_cr(&quot;Total load cost= %6.0f, store cost = %6.0f, mem-mem cost = %5.2f, copy cost = %5.0f.&quot;, _final_load_cost, _final_store_cost, _final_memove_cost, _final_copy_cost);
2332   tty-&gt;print_cr(&quot;Adjusted spill cost = %7.0f.&quot;,
2333                 _final_load_cost*4.0 + _final_store_cost  * 2.0 +
2334                 _final_copy_cost*1.0 + _final_memove_cost*12.0);
2335   tty-&gt;print(&quot;Conservatively coalesced %d copies, %d pairs&quot;,
2336                 _conserv_coalesce, _conserv_coalesce_pair);
2337   if( _conserv_coalesce_trie || _conserv_coalesce_quad )
2338     tty-&gt;print(&quot;, %d tries, %d quads&quot;, _conserv_coalesce_trie, _conserv_coalesce_quad);
2339   tty-&gt;print_cr(&quot;, %d post alloc.&quot;, _post_alloc);
2340   if( _lost_opp_pp_coalesce || _lost_opp_cflow_coalesce )
2341     tty-&gt;print_cr(&quot;Lost coalesce opportunity, %d private-private, and %d cflow interfered.&quot;,
2342                   _lost_opp_pp_coalesce, _lost_opp_cflow_coalesce );
2343   if( _used_cisc_instructions || _unused_cisc_instructions )
2344     tty-&gt;print_cr(&quot;Used cisc instruction  %d,  remained in register %d&quot;,
2345                    _used_cisc_instructions, _unused_cisc_instructions);
2346   if( _allocator_successes != 0 )
2347     tty-&gt;print_cr(&quot;Average allocation trips %f&quot;, (float)_allocator_attempts/(float)_allocator_successes);
2348   tty-&gt;print_cr(&quot;High Pressure Blocks = %d, Low Pressure Blocks = %d&quot;, _high_pressure, _low_pressure);
2349 }
2350 #endif // not PRODUCT
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
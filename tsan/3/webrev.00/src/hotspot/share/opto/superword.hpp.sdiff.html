<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/superword.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="superword.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
342   int vector_width(Node* n) {
343     BasicType bt = velt_basic_type(n);
344     return MIN2(ABS(iv_stride()), Matcher::max_vector_size(bt));
345   }
346   int vector_width_in_bytes(Node* n) {
347     BasicType bt = velt_basic_type(n);
348     return vector_width(n)*type2aelembytes(bt);
349   }
350   int get_vw_bytes_special(MemNode* s);
351   MemNode* align_to_ref()            { return _align_to_ref; }
352   void  set_align_to_ref(MemNode* m) { _align_to_ref = m; }
353 
354   Node* ctrl(Node* n) const { return _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n; }
355 
356   // block accessors
357   bool in_bb(Node* n)      { return n != NULL &amp;&amp; n-&gt;outcnt() &gt; 0 &amp;&amp; ctrl(n) == _bb; }
358   int  bb_idx(Node* n)     { assert(in_bb(n), &quot;must be&quot;); return _bb_idx.at(n-&gt;_idx); }
359   void set_bb_idx(Node* n, int i) { _bb_idx.at_put_grow(n-&gt;_idx, i); }
360 
361   // visited set accessors
<span class="line-modified">362   void visited_clear()           { _visited.Clear(); }</span>
363   void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }
364   int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }
365   int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }
<span class="line-modified">366   void post_visited_clear()      { _post_visited.Clear(); }</span>
367   void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }
368   int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }
369 
370   // Ensure node_info contains element &quot;i&quot;
371   void grow_node_info(int i) { if (i &gt;= _node_info.length()) _node_info.at_put_grow(i, SWNodeInfo::initial); }
372 
373   // memory alignment for a node
374   int alignment(Node* n)                     { return _node_info.adr_at(bb_idx(n))-&gt;_alignment; }
375   void set_alignment(Node* n, int a)         { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_alignment = a; }
376 
377   // Max expression (DAG) depth from beginning of the block for each node
378   int depth(Node* n)                         { return _node_info.adr_at(bb_idx(n))-&gt;_depth; }
379   void set_depth(Node* n, int d)             { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_depth = d; }
380 
381   // vector element type
382   const Type* velt_type(Node* n)             { return _node_info.adr_at(bb_idx(n))-&gt;_velt_type; }
383   BasicType velt_basic_type(Node* n)         { return velt_type(n)-&gt;array_element_basic_type(); }
384   void set_velt_type(Node* n, const Type* t) { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_velt_type = t; }
385   bool same_velt_type(Node* n1, Node* n2);
386 
</pre>
<hr />
<pre>
391   bool is_cmov_pack(Node_List* p);
392   bool is_cmov_pack_internal_node(Node_List* p, Node* nd) { return is_cmov_pack(p) &amp;&amp; !nd-&gt;is_CMove(); }
393   // For pack p, are all idx operands the same?
394   bool same_inputs(Node_List* p, int idx);
395   // CloneMap utilities
396   bool same_origin_idx(Node* a, Node* b) const;
397   bool same_generation(Node* a, Node* b) const;
398 
399   // methods
400 
401   // Extract the superword level parallelism
402   void SLP_extract();
403   // Find the adjacent memory references and create pack pairs for them.
404   void find_adjacent_refs();
405   // Tracing support
406   #ifndef PRODUCT
407   void find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment);
408   void print_loop(bool whole);
409   #endif
410   // Find a memory reference to align the loop induction variable to.
<span class="line-modified">411   MemNode* find_align_to_ref(Node_List &amp;memops);</span>
412   // Calculate loop&#39;s iv adjustment for this memory ops.
413   int get_iv_adjustment(MemNode* mem);
414   // Can the preloop align the reference to position zero in the vector?
415   bool ref_is_alignable(SWPointer&amp; p);
416   // rebuild the graph so all loads in different iterations of cloned loop become dependant on phi node (in _do_vector_loop only)
417   bool hoist_loads_in_graph();
418   // Test whether MemNode::Memory dependency to the same load but in the first iteration of this loop is coming from memory phi
419   // Return false if failed
420   Node* find_phi_for_mem_dep(LoadNode* ld);
421   // Return same node but from the first generation. Return 0, if not found
422   Node* first_node(Node* nd);
423   // Return same node as this but from the last generation. Return 0, if not found
424   Node* last_node(Node* n);
425   // Mark nodes belonging to first and last generation
426   // returns first generation index or -1 if vectorization/simd is impossible
427   int mark_generations();
428   // swapping inputs of commutative instruction (Add or Mul)
429   bool fix_commutative_inputs(Node* gold, Node* fix);
430   // make packs forcefully (in _do_vector_loop only)
431   bool pack_parallel();
</pre>
</td>
<td>
<hr />
<pre>
342   int vector_width(Node* n) {
343     BasicType bt = velt_basic_type(n);
344     return MIN2(ABS(iv_stride()), Matcher::max_vector_size(bt));
345   }
346   int vector_width_in_bytes(Node* n) {
347     BasicType bt = velt_basic_type(n);
348     return vector_width(n)*type2aelembytes(bt);
349   }
350   int get_vw_bytes_special(MemNode* s);
351   MemNode* align_to_ref()            { return _align_to_ref; }
352   void  set_align_to_ref(MemNode* m) { _align_to_ref = m; }
353 
354   Node* ctrl(Node* n) const { return _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n; }
355 
356   // block accessors
357   bool in_bb(Node* n)      { return n != NULL &amp;&amp; n-&gt;outcnt() &gt; 0 &amp;&amp; ctrl(n) == _bb; }
358   int  bb_idx(Node* n)     { assert(in_bb(n), &quot;must be&quot;); return _bb_idx.at(n-&gt;_idx); }
359   void set_bb_idx(Node* n, int i) { _bb_idx.at_put_grow(n-&gt;_idx, i); }
360 
361   // visited set accessors
<span class="line-modified">362   void visited_clear()           { _visited.clear(); }</span>
363   void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }
364   int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }
365   int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }
<span class="line-modified">366   void post_visited_clear()      { _post_visited.clear(); }</span>
367   void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }
368   int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }
369 
370   // Ensure node_info contains element &quot;i&quot;
371   void grow_node_info(int i) { if (i &gt;= _node_info.length()) _node_info.at_put_grow(i, SWNodeInfo::initial); }
372 
373   // memory alignment for a node
374   int alignment(Node* n)                     { return _node_info.adr_at(bb_idx(n))-&gt;_alignment; }
375   void set_alignment(Node* n, int a)         { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_alignment = a; }
376 
377   // Max expression (DAG) depth from beginning of the block for each node
378   int depth(Node* n)                         { return _node_info.adr_at(bb_idx(n))-&gt;_depth; }
379   void set_depth(Node* n, int d)             { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_depth = d; }
380 
381   // vector element type
382   const Type* velt_type(Node* n)             { return _node_info.adr_at(bb_idx(n))-&gt;_velt_type; }
383   BasicType velt_basic_type(Node* n)         { return velt_type(n)-&gt;array_element_basic_type(); }
384   void set_velt_type(Node* n, const Type* t) { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)-&gt;_velt_type = t; }
385   bool same_velt_type(Node* n1, Node* n2);
386 
</pre>
<hr />
<pre>
391   bool is_cmov_pack(Node_List* p);
392   bool is_cmov_pack_internal_node(Node_List* p, Node* nd) { return is_cmov_pack(p) &amp;&amp; !nd-&gt;is_CMove(); }
393   // For pack p, are all idx operands the same?
394   bool same_inputs(Node_List* p, int idx);
395   // CloneMap utilities
396   bool same_origin_idx(Node* a, Node* b) const;
397   bool same_generation(Node* a, Node* b) const;
398 
399   // methods
400 
401   // Extract the superword level parallelism
402   void SLP_extract();
403   // Find the adjacent memory references and create pack pairs for them.
404   void find_adjacent_refs();
405   // Tracing support
406   #ifndef PRODUCT
407   void find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment);
408   void print_loop(bool whole);
409   #endif
410   // Find a memory reference to align the loop induction variable to.
<span class="line-modified">411   MemNode* find_align_to_ref(Node_List &amp;memops, int &amp;idx);</span>
412   // Calculate loop&#39;s iv adjustment for this memory ops.
413   int get_iv_adjustment(MemNode* mem);
414   // Can the preloop align the reference to position zero in the vector?
415   bool ref_is_alignable(SWPointer&amp; p);
416   // rebuild the graph so all loads in different iterations of cloned loop become dependant on phi node (in _do_vector_loop only)
417   bool hoist_loads_in_graph();
418   // Test whether MemNode::Memory dependency to the same load but in the first iteration of this loop is coming from memory phi
419   // Return false if failed
420   Node* find_phi_for_mem_dep(LoadNode* ld);
421   // Return same node but from the first generation. Return 0, if not found
422   Node* first_node(Node* nd);
423   // Return same node as this but from the last generation. Return 0, if not found
424   Node* last_node(Node* n);
425   // Mark nodes belonging to first and last generation
426   // returns first generation index or -1 if vectorization/simd is impossible
427   int mark_generations();
428   // swapping inputs of commutative instruction (Add or Mul)
429   bool fix_commutative_inputs(Node* gold, Node* fix);
430   // make packs forcefully (in _do_vector_loop only)
431   bool pack_parallel();
</pre>
</td>
</tr>
</table>
<center><a href="superword.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
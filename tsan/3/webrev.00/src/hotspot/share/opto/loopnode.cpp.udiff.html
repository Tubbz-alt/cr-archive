<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/loopnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopUnswitch.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,23 +38,20 @@</span>
  #include &quot;opto/idealGraphPrinter.hpp&quot;
  #include &quot;opto/loopnode.hpp&quot;
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/superword.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //=============================================================================
<span class="udiff-line-modified-removed">- //------------------------------is_loop_iv-------------------------------------</span>
<span class="udiff-line-modified-removed">- // Determine if a node is Counted loop induction variable.</span>
<span class="udiff-line-modified-removed">- // The method is declared in node.hpp.</span>
<span class="udiff-line-modified-removed">- const Node* Node::is_loop_iv() const {</span>
<span class="udiff-line-modified-removed">-   if (this-&gt;is_Phi() &amp;&amp; !this-&gt;as_Phi()-&gt;is_copy() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       this-&gt;as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       this-&gt;as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ //--------------------------is_cloop_ind_var-----------------------------------</span>
<span class="udiff-line-modified-added">+ // Determine if a node is a counted loop induction variable.</span>
<span class="udiff-line-modified-added">+ // NOTE: The method is declared in &quot;node.hpp&quot;.</span>
<span class="udiff-line-modified-added">+ bool Node::is_cloop_ind_var() const {</span>
<span class="udiff-line-modified-added">+   return (is_Phi() &amp;&amp; !as_Phi()-&gt;is_copy() &amp;&amp;</span>
<span class="udiff-line-modified-added">+           as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;</span>
<span class="udiff-line-modified-added">+           as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this);</span>
  }
  
  //=============================================================================
  //------------------------------dump_spec--------------------------------------
  // Dump special per-node info
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,21 +943,25 @@</span>
      phase-&gt;C-&gt;set_major_progress();
    }
    return RegionNode::Ideal(phase, can_reshape);
  }
  
<span class="udiff-line-removed">- void LoopNode::verify_strip_mined(int expect_skeleton) const {</span>
  #ifdef ASSERT
<span class="udiff-line-added">+ void LoopNode::verify_strip_mined(int expect_skeleton) const {</span>
    const OuterStripMinedLoopNode* outer = NULL;
    const CountedLoopNode* inner = NULL;
    if (is_strip_mined()) {
<span class="udiff-line-added">+     if (!is_valid_counted_loop()) {</span>
<span class="udiff-line-added">+       return; // Skip malformed counted loop</span>
<span class="udiff-line-added">+     }</span>
      assert(is_CountedLoop(), &quot;no Loop should be marked strip mined&quot;);
      inner = as_CountedLoop();
      outer = inner-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop();
    } else if (is_OuterStripMinedLoop()) {
      outer = this-&gt;as_OuterStripMinedLoop();
      inner = outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop();
<span class="udiff-line-added">+     assert(inner-&gt;is_valid_counted_loop() &amp;&amp; inner-&gt;is_strip_mined(), &quot;OuterStripMinedLoop should have been removed&quot;);</span>
      assert(!is_strip_mined(), &quot;outer loop shouldn&#39;t be marked strip mined&quot;);
    }
    if (inner != NULL || outer != NULL) {
      assert(inner != NULL &amp;&amp; outer != NULL, &quot;missing loop in strip mined nest&quot;);
      Node* outer_tail = outer-&gt;in(LoopNode::LoopBackControl);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -980,11 +981,11 @@</span>
          }
          wq.clear();
          wq.push(u);
          bool found_sfpt = false;
          for (uint next = 0; next &lt; wq.size() &amp;&amp; !found_sfpt; next++) {
<span class="udiff-line-modified-removed">-           Node *n = wq.at(next);</span>
<span class="udiff-line-modified-added">+           Node* n = wq.at(next);</span>
            for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !found_sfpt; i++) {
              Node* u = n-&gt;fast_out(i);
              if (u == sfpt) {
                found_sfpt = true;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -994,10 +995,11 @@</span>
            }
          }
          assert(found_sfpt, &quot;no node in loop that&#39;s not input to safepoint&quot;);
        }
      }
<span class="udiff-line-added">+ </span>
      CountedLoopEndNode* cle = inner_out-&gt;in(0)-&gt;as_CountedLoopEnd();
      assert(cle == inner-&gt;loopexit_or_null(), &quot;mismatch&quot;);
      bool has_skeleton = outer_le-&gt;in(1)-&gt;bottom_type()-&gt;singleton() &amp;&amp; outer_le-&gt;in(1)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0;
      if (has_skeleton) {
        assert(expect_skeleton == 1 || expect_skeleton == -1, &quot;unexpected skeleton node&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1025,12 +1027,12 @@</span>
        assert(outer-&gt;outcnt() &gt;= phis + 2 &amp;&amp; outer-&gt;outcnt() &lt;= phis + 2 + stores + 1, &quot;only phis&quot;);
      }
      assert(sfpt-&gt;outcnt() == 1, &quot;no data node&quot;);
      assert(outer_tail-&gt;outcnt() == 1 || !has_skeleton, &quot;no data node&quot;);
    }
<span class="udiff-line-removed">- #endif</span>
  }
<span class="udiff-line-added">+ #endif</span>
  
  //=============================================================================
  //------------------------------Ideal------------------------------------------
  // Return a node which is more &quot;ideal&quot; than the current node.
  // Attempt to convert into a counted-loop.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1237,11 +1239,11 @@</span>
    // failed
    return NULL;
  }
  
  LoopNode* CountedLoopNode::skip_strip_mined(int expect_skeleton) {
<span class="udiff-line-modified-removed">-   if (is_strip_mined()) {</span>
<span class="udiff-line-modified-added">+   if (is_strip_mined() &amp;&amp; is_valid_counted_loop()) {</span>
      verify_strip_mined(expect_skeleton);
      return in(EntryControl)-&gt;as_Loop();
    }
    return this;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1799,11 +1801,11 @@</span>
        old_phi-&gt;add_req(p);
        // Check for the special case of making the old phi useless and
        // disappear it.  In JavaGrande I have a case where this useless
        // Phi is the loop limit and prevents recognizing a CountedLoop
        // which in turn prevents removing an empty loop.
<span class="udiff-line-modified-removed">-       Node *id_old_phi = igvn.apply_identity(old_phi);</span>
<span class="udiff-line-modified-added">+       Node *id_old_phi = old_phi-&gt;Identity(&amp;igvn);</span>
        if( id_old_phi != old_phi ) { // Found a simple identity?
          // Note that I cannot call &#39;replace_node&#39; here, because
          // that will yank the edge from old_phi to the Region and
          // I&#39;m mid-iteration over the Region&#39;s uses.
          for (DUIterator_Last imin, i = old_phi-&gt;last_outs(imin); i &gt;= imin; ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2122,11 +2124,11 @@</span>
  // Allpaths backwards scan from loop tail, terminating each path at first safepoint
  // encountered.  Helper for check_safepts.
  void IdealLoopTree::allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
    assert(stack.size() == 0, &quot;empty stack&quot;);
    stack.push(_tail);
<span class="udiff-line-modified-removed">-   visited.Clear();</span>
<span class="udiff-line-modified-added">+   visited.clear();</span>
    visited.set(_tail-&gt;_idx);
    while (stack.size() &gt; 0) {
      Node* n = stack.pop();
      if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
        // Terminate this path
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2441,17 +2443,101 @@</span>
    assert(loop-&gt;_child != this || (loop-&gt;_child-&gt;_child == NULL &amp;&amp; loop-&gt;_child-&gt;_next == NULL), &quot;would miss some loops&quot;);
    if (loop-&gt;_child &amp;&amp; loop-&gt;_child != this) loop-&gt;_child-&gt;counted_loop(phase);
    if (loop-&gt;_next)  loop-&gt;_next -&gt;counted_loop(phase);
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // The Estimated Loop Clone Size:</span>
<span class="udiff-line-added">+ //   CloneFactor * (~112% * BodySize + BC) + CC + FanOutTerm,</span>
<span class="udiff-line-added">+ // where  BC and  CC are  totally ad-hoc/magic  &quot;body&quot; and &quot;clone&quot; constants,</span>
<span class="udiff-line-added">+ // respectively, used to ensure that the node usage estimates made are on the</span>
<span class="udiff-line-added">+ // safe side, for the most part. The FanOutTerm is an attempt to estimate the</span>
<span class="udiff-line-added">+ // possible additional/excessive nodes generated due to data and control flow</span>
<span class="udiff-line-added">+ // merging, for edges reaching outside the loop.</span>
<span class="udiff-line-added">+ uint IdealLoopTree::est_loop_clone_sz(uint factor) const {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   precond(0 &lt; factor &amp;&amp; factor &lt; 16);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint const bc = 13;</span>
<span class="udiff-line-added">+   uint const cc = 17;</span>
<span class="udiff-line-added">+   uint const sz = _body.size() + (_body.size() + 7) / 8;</span>
<span class="udiff-line-added">+   uint estimate = factor * (sz + bc) + cc;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert((estimate - cc) / factor == sz + bc, &quot;overflow&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return estimate + est_loop_flow_merge_sz();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // The Estimated Loop (full-) Unroll Size:</span>
<span class="udiff-line-added">+ //   UnrollFactor * (~106% * BodySize) + CC + FanOutTerm,</span>
<span class="udiff-line-added">+ // where CC is a (totally) ad-hoc/magic &quot;clone&quot; constant, used to ensure that</span>
<span class="udiff-line-added">+ // node usage estimates made are on the safe side, for the most part. This is</span>
<span class="udiff-line-added">+ // a &quot;light&quot; version of the loop clone size calculation (above), based on the</span>
<span class="udiff-line-added">+ // assumption that most of the loop-construct overhead will be unraveled when</span>
<span class="udiff-line-added">+ // (fully) unrolled. Defined for unroll factors larger or equal to one (&gt;=1),</span>
<span class="udiff-line-added">+ // including an overflow check and returning UINT_MAX in case of an overflow.</span>
<span class="udiff-line-added">+ uint IdealLoopTree::est_loop_unroll_sz(uint factor) const {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   precond(factor &gt; 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Take into account that after unroll conjoined heads and tails will fold.</span>
<span class="udiff-line-added">+   uint const b0 = _body.size() - EMPTY_LOOP_SIZE;</span>
<span class="udiff-line-added">+   uint const cc = 7;</span>
<span class="udiff-line-added">+   uint const sz = b0 + (b0 + 15) / 16;</span>
<span class="udiff-line-added">+   uint estimate = factor * sz + cc;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if ((estimate - cc) / factor != sz) {</span>
<span class="udiff-line-added">+     return UINT_MAX;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return estimate + est_loop_flow_merge_sz();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Estimate the growth effect (in nodes) of merging control and data flow when</span>
<span class="udiff-line-added">+ // cloning a loop body, based on the amount of  control and data flow reaching</span>
<span class="udiff-line-added">+ // outside of the (current) loop body.</span>
<span class="udiff-line-added">+ uint IdealLoopTree::est_loop_flow_merge_sz() const {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint ctrl_edge_out_cnt = 0;</span>
<span class="udiff-line-added">+   uint data_edge_out_cnt = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="udiff-line-added">+     Node* node = _body.at(i);</span>
<span class="udiff-line-added">+     uint outcnt = node-&gt;outcnt();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (uint k = 0; k &lt; outcnt; k++) {</span>
<span class="udiff-line-added">+       Node* out = node-&gt;raw_out(k);</span>
<span class="udiff-line-added">+       if (out == NULL) continue;</span>
<span class="udiff-line-added">+       if (out-&gt;is_CFG()) {</span>
<span class="udiff-line-added">+         if (!is_member(_phase-&gt;get_loop(out))) {</span>
<span class="udiff-line-added">+           ctrl_edge_out_cnt++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (_phase-&gt;has_ctrl(out)) {</span>
<span class="udiff-line-added">+         Node* ctrl = _phase-&gt;get_ctrl(out);</span>
<span class="udiff-line-added">+         assert(ctrl != NULL, &quot;must be&quot;);</span>
<span class="udiff-line-added">+         assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+         if (!is_member(_phase-&gt;get_loop(ctrl))) {</span>
<span class="udiff-line-added">+           data_edge_out_cnt++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Use data and control count (x2.0) in estimate iff both are &gt; 0. This is</span>
<span class="udiff-line-added">+   // a rather pessimistic estimate for the most part, in particular for some</span>
<span class="udiff-line-added">+   // complex loops, but still not enough to capture all loops.</span>
<span class="udiff-line-added">+   if (ctrl_edge_out_cnt &gt; 0 &amp;&amp; data_edge_out_cnt &gt; 0) {</span>
<span class="udiff-line-added">+     return 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #ifndef PRODUCT
  //------------------------------dump_head--------------------------------------
  // Dump 1 liner for loop header info
<span class="udiff-line-modified-removed">- void IdealLoopTree::dump_head( ) const {</span>
<span class="udiff-line-modified-removed">-   for (uint i=0; i&lt;_nest; i++)</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print(&quot;  &quot;);</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;Loop: N%d/N%d &quot;,_head-&gt;_idx,_tail-&gt;_idx);</span>
<span class="udiff-line-modified-added">+ void IdealLoopTree::dump_head() const {</span>
<span class="udiff-line-modified-added">+   tty-&gt;sp(2 * _nest);</span>
<span class="udiff-line-modified-added">+   tty-&gt;print(&quot;Loop: N%d/N%d &quot;, _head-&gt;_idx, _tail-&gt;_idx);</span>
    if (_irreducible) tty-&gt;print(&quot; IRREDUCIBLE&quot;);
    Node* entry = _head-&gt;is_Loop() ? _head-&gt;as_Loop()-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl) : _head-&gt;in(LoopNode::EntryControl);
    Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
    if (predicate != NULL ) {
      tty-&gt;print(&quot; limit_check&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2515,11 +2601,11 @@</span>
    tty-&gt;cr();
  }
  
  //------------------------------dump-------------------------------------------
  // Dump loops by loop tree
<span class="udiff-line-modified-removed">- void IdealLoopTree::dump( ) const {</span>
<span class="udiff-line-modified-added">+ void IdealLoopTree::dump() const {</span>
    dump_head();
    if (_child) _child-&gt;dump();
    if (_next)  _next -&gt;dump();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2712,11 +2798,11 @@</span>
  //=============================================================================
  //----------------------------build_and_optimize-------------------------------
  // Create a PhaseLoop.  Build the ideal Loop tree.  Map each Ideal Node to
  // its corresponding LoopNode.  If &#39;optimize&#39; is true, do some loop cleanups.
  void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {
<span class="udiff-line-modified-removed">-   bool do_split_ifs = (mode == LoopOptsDefault || mode == LoopOptsLastRound);</span>
<span class="udiff-line-modified-added">+   bool do_split_ifs = (mode == LoopOptsDefault);</span>
    bool skip_loop_opts = (mode == LoopOptsNone);
  
    int old_progress = C-&gt;major_progress();
    uint orig_worklist_size = _igvn._worklist.size();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2848,37 +2934,35 @@</span>
  
    // Allocate stack with enough space to avoid frequent realloc
    int stack_size = (C-&gt;live_nodes() &gt;&gt; 1) + 16; // (live_nodes&gt;&gt;1)+16 from Java2D stats
    Node_Stack nstack( a, stack_size );
  
<span class="udiff-line-modified-removed">-   visited.Clear();</span>
<span class="udiff-line-modified-added">+   visited.clear();</span>
    Node_List worklist(a);
    // Don&#39;t need C-&gt;root() on worklist since
    // it will be processed among C-&gt;top() inputs
<span class="udiff-line-modified-removed">-   worklist.push( C-&gt;top() );</span>
<span class="udiff-line-modified-removed">-   visited.set( C-&gt;top()-&gt;_idx ); // Set C-&gt;top() as visited now</span>
<span class="udiff-line-modified-added">+   worklist.push(C-&gt;top());</span>
<span class="udiff-line-modified-added">+   visited.set(C-&gt;top()-&gt;_idx); // Set C-&gt;top() as visited now</span>
    build_loop_early( visited, worklist, nstack );
  
    // Given early legal placement, try finding counted loops.  This placement
    // is good enough to discover most loop invariants.
    if (!_verify_me &amp;&amp; !_verify_only &amp;&amp; !strip_mined_loops_expanded) {
      _ltree_root-&gt;counted_loop( this );
    }
  
    // Find latest loop placement.  Find ideal loop placement.
<span class="udiff-line-modified-removed">-   visited.Clear();</span>
<span class="udiff-line-modified-added">+   visited.clear();</span>
    init_dom_lca_tags();
    // Need C-&gt;root() on worklist when processing outs
<span class="udiff-line-modified-removed">-   worklist.push( C-&gt;root() );</span>
<span class="udiff-line-modified-added">+   worklist.push(C-&gt;root());</span>
    NOT_PRODUCT( C-&gt;verify_graph_edges(); )
<span class="udiff-line-modified-removed">-   worklist.push( C-&gt;top() );</span>
<span class="udiff-line-modified-added">+   worklist.push(C-&gt;top());</span>
    build_loop_late( visited, worklist, nstack );
  
    if (_verify_only) {
<span class="udiff-line-modified-removed">-     // restore major progress flag</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; old_progress; i++)</span>
<span class="udiff-line-removed">-       C-&gt;set_major_progress();</span>
<span class="udiff-line-modified-added">+     C-&gt;restore_major_progress(old_progress);</span>
      assert(C-&gt;unique() == unique, &quot;verification mode made Nodes? ? ?&quot;);
      assert(_igvn._worklist.size() == orig_worklist_size, &quot;shouldn&#39;t push anything&quot;);
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2910,31 +2994,56 @@</span>
    if (_verify_me) {             // Nested verify pass?
      // Check to see if the verify mode is broken
      assert(C-&gt;unique() == unique, &quot;non-optimize mode made Nodes? ? ?&quot;);
      return;
    }
<span class="udiff-line-modified-removed">-   if(VerifyLoopOptimizations) verify();</span>
<span class="udiff-line-modified-removed">-   if(TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {</span>
<span class="udiff-line-modified-added">+   if (VerifyLoopOptimizations) verify();</span>
<span class="udiff-line-modified-added">+   if (TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {</span>
      _ltree_root-&gt;dump();
    }
  #endif
  
    if (skip_loop_opts) {
      // restore major progress flag
<span class="udiff-line-modified-removed">-     for (int i = 0; i &lt; old_progress; i++) {</span>
<span class="udiff-line-removed">-       C-&gt;set_major_progress();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     C-&gt;restore_major_progress(old_progress);</span>
  
      // Cleanup any modified bits
      _igvn.optimize();
  
      if (C-&gt;log() != NULL) {
        log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
      }
      return;
    }
  
<span class="udiff-line-added">+   if (mode == LoopOptsMaxUnroll) {</span>
<span class="udiff-line-added">+     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {</span>
<span class="udiff-line-added">+       IdealLoopTree* lpt = iter.current();</span>
<span class="udiff-line-added">+       if (lpt-&gt;is_innermost() &amp;&amp; lpt-&gt;_allow_optimizations &amp;&amp; !lpt-&gt;_has_call &amp;&amp; lpt-&gt;is_counted()) {</span>
<span class="udiff-line-added">+         lpt-&gt;compute_trip_count(this);</span>
<span class="udiff-line-added">+         if (!lpt-&gt;do_one_iteration_loop(this) &amp;&amp;</span>
<span class="udiff-line-added">+             !lpt-&gt;do_remove_empty_loop(this)) {</span>
<span class="udiff-line-added">+           AutoNodeBudget node_budget(this);</span>
<span class="udiff-line-added">+           if (lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_normal_loop() &amp;&amp;</span>
<span class="udiff-line-added">+               lpt-&gt;policy_maximally_unroll(this)) {</span>
<span class="udiff-line-added">+             memset( worklist.adr(), 0, worklist.Size()*sizeof(Node*) );</span>
<span class="udiff-line-added">+             do_maximally_unroll(lpt, worklist);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     C-&gt;restore_major_progress(old_progress);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _igvn.optimize();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (C-&gt;log() != NULL) {</span>
<span class="udiff-line-added">+       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (bs-&gt;optimize_loops(this, mode, visited, nstack, worklist)) {
      _igvn.optimize();
      if (C-&gt;log() != NULL) {
        log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2944,37 +3053,37 @@</span>
    if (ReassociateInvariants) {
      // Reassociate invariants and prep for split_thru_phi
      for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
        IdealLoopTree* lpt = iter.current();
        bool is_counted = lpt-&gt;is_counted();
<span class="udiff-line-modified-removed">-       if (!is_counted || !lpt-&gt;is_inner()) continue;</span>
<span class="udiff-line-modified-added">+       if (!is_counted || !lpt-&gt;is_innermost()) continue;</span>
  
        // check for vectorized loops, any reassociation of invariants was already done
<span class="udiff-line-modified-removed">-       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;do_unroll_only()) continue;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       lpt-&gt;reassociate_invariants(this);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
<span class="udiff-line-modified-added">+         continue;</span>
<span class="udiff-line-modified-added">+       } else {</span>
<span class="udiff-line-modified-added">+         AutoNodeBudget node_budget(this);</span>
<span class="udiff-line-added">+         lpt-&gt;reassociate_invariants(this);</span>
<span class="udiff-line-added">+       }</span>
        // Because RCE opportunities can be masked by split_thru_phi,
        // look for RCE candidates and inhibit split_thru_phi
        // on just their loop-phi&#39;s for this pass of loop opts
        if (SplitIfBlocks &amp;&amp; do_split_ifs) {
<span class="udiff-line-added">+         AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);</span>
          if (lpt-&gt;policy_range_check(this)) {
            lpt-&gt;_rce_candidate = 1; // = true
          }
        }
      }
    }
  
    // Check for aggressive application of split-if and other transforms
    // that require basic-block info (like cloning through Phi&#39;s)
    if( SplitIfBlocks &amp;&amp; do_split_ifs ) {
<span class="udiff-line-modified-removed">-     visited.Clear();</span>
<span class="udiff-line-modified-removed">-     split_if_with_blocks( visited, nstack, mode == LoopOptsLastRound );</span>
<span class="udiff-line-modified-added">+     visited.clear();</span>
<span class="udiff-line-modified-added">+     split_if_with_blocks( visited, nstack);</span>
      NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );
<span class="udiff-line-removed">-     if (mode == LoopOptsLastRound) {</span>
<span class="udiff-line-removed">-       C-&gt;set_major_progress();</span>
<span class="udiff-line-removed">-     }</span>
    }
  
    if (!C-&gt;major_progress() &amp;&amp; do_expensive_nodes &amp;&amp; process_expensive_nodes()) {
      C-&gt;set_major_progress();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3105,12 +3214,11 @@</span>
    assert( fail == 0, &quot;verify loops failed&quot; );
    // Verify loop structure is the same
    _ltree_root-&gt;verify_tree(loop_verify._ltree_root, NULL);
    // Reset major-progress.  It was cleared by creating a verify version of
    // PhaseIdealLoop.
<span class="udiff-line-modified-removed">-   for( int i=0; i&lt;old_progress; i++ )</span>
<span class="udiff-line-removed">-     C-&gt;set_major_progress();</span>
<span class="udiff-line-modified-added">+   C-&gt;restore_major_progress(old_progress);</span>
  }
  
  //------------------------------verify_compare---------------------------------
  // Make sure me and the given PhaseIdealLoop agree on key data structures
  void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3314,14 +3422,11 @@</span>
  
  //------------------------------set_idom---------------------------------------
  void PhaseIdealLoop::set_idom(Node* d, Node* n, uint dom_depth) {
    uint idx = d-&gt;_idx;
    if (idx &gt;= _idom_size) {
<span class="udiff-line-modified-removed">-     uint newsize = _idom_size&lt;&lt;1;</span>
<span class="udiff-line-removed">-     while( idx &gt;= newsize ) {</span>
<span class="udiff-line-removed">-       newsize &lt;&lt;= 1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     uint newsize = next_power_of_2(idx);</span>
      _idom      = REALLOC_RESOURCE_ARRAY( Node*,     _idom,_idom_size,newsize);
      _dom_depth = REALLOC_RESOURCE_ARRAY( uint, _dom_depth,_idom_size,newsize);
      memset( _dom_depth + _idom_size, 0, (newsize - _idom_size) * sizeof(uint) );
      _idom_size = newsize;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3592,11 +3697,11 @@</span>
            // V-N&#39;ing.  Easier and quicker than searching through
            // the program structure.
            Node *frame = new ParmNode( C-&gt;start(), TypeFunc::FramePtr );
            _igvn.register_new_node_with_optimizer(frame);
            // Halt &amp; Catch Fire
<span class="udiff-line-modified-removed">-           Node *halt = new HaltNode( if_f, frame );</span>
<span class="udiff-line-modified-added">+           Node* halt = new HaltNode(if_f, frame, &quot;never-taken loop exit reached&quot;);</span>
            _igvn.register_new_node_with_optimizer(halt);
            set_loop(halt, l);
            C-&gt;root()-&gt;add_req(halt);
          }
          set_loop(C-&gt;root(), _ltree_root);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3960,32 +4065,36 @@</span>
    // instructions and for rescheduling the load.  The users of the memory
    // input of this load are examined.  Any use which is not a load and is
    // dominated by early is considered a potentially interfering store.
    // This can produce false positives.
    if (n-&gt;is_Load() &amp;&amp; LCA != early) {
<span class="udiff-line-modified-removed">-     Node_List worklist;</span>
<span class="udiff-line-modified-added">+     int load_alias_idx = C-&gt;get_alias_index(n-&gt;adr_type());</span>
<span class="udiff-line-added">+     if (C-&gt;alias_type(load_alias_idx)-&gt;is_rewritable()) {</span>
  
<span class="udiff-line-modified-removed">-     Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-removed">-       Node* s = mem-&gt;fast_out(i);</span>
<span class="udiff-line-modified-removed">-       worklist.push(s);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     while(worklist.size() != 0 &amp;&amp; LCA != early) {</span>
<span class="udiff-line-modified-removed">-       Node* s = worklist.pop();</span>
<span class="udiff-line-modified-removed">-       if (s-&gt;is_Load() || s-&gt;is_ShenandoahBarrier() || s-&gt;Opcode() == Op_SafePoint ||</span>
<span class="udiff-line-modified-removed">-           (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {</span>
<span class="udiff-line-modified-removed">-         continue;</span>
<span class="udiff-line-modified-removed">-       } else if (s-&gt;is_MergeMem()) {</span>
<span class="udiff-line-modified-removed">-         for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-removed">-           Node* s1 = s-&gt;fast_out(i);</span>
<span class="udiff-line-modified-removed">-           worklist.push(s1);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       } else {</span>
<span class="udiff-line-modified-removed">-         Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);</span>
<span class="udiff-line-modified-removed">-         assert(sctrl != NULL || s-&gt;outcnt() == 0, &quot;must have control&quot;);</span>
<span class="udiff-line-modified-removed">-         if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; is_dominator(early, sctrl)) {</span>
<span class="udiff-line-modified-removed">-           LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);</span>
<span class="udiff-line-modified-added">+       Node_List worklist;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="udiff-line-modified-added">+       for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-added">+         Node* s = mem-&gt;fast_out(i);</span>
<span class="udiff-line-modified-added">+         worklist.push(s);</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       while(worklist.size() != 0 &amp;&amp; LCA != early) {</span>
<span class="udiff-line-modified-added">+         Node* s = worklist.pop();</span>
<span class="udiff-line-modified-added">+         if (s-&gt;is_Load() || s-&gt;Opcode() == Op_SafePoint ||</span>
<span class="udiff-line-modified-added">+             (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {</span>
<span class="udiff-line-modified-added">+           continue;</span>
<span class="udiff-line-modified-added">+         } else if (s-&gt;is_MergeMem()) {</span>
<span class="udiff-line-modified-added">+           for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-added">+             Node* s1 = s-&gt;fast_out(i);</span>
<span class="udiff-line-modified-added">+             worklist.push(s1);</span>
<span class="udiff-line-modified-added">+           }</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+           Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);</span>
<span class="udiff-line-modified-added">+           assert(sctrl != NULL || !s-&gt;is_reachable_from_root(), &quot;must have control&quot;);</span>
<span class="udiff-line-added">+           if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; C-&gt;can_alias(s-&gt;adr_type(), load_alias_idx) &amp;&amp; is_dominator(early, sctrl)) {</span>
<span class="udiff-line-added">+             LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);</span>
<span class="udiff-line-added">+           }</span>
          }
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4187,16 +4296,10 @@</span>
  
  //------------------------------build_loop_late_post---------------------------
  // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
  // Second pass finds latest legal placement, and ideal loop placement.
  void PhaseIdealLoop::build_loop_late_post(Node *n) {
<span class="udiff-line-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (bs-&gt;build_loop_late_post(this, n)) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    build_loop_late_post_work(n, true);
  }
  
  void PhaseIdealLoop::build_loop_late_post_work(Node *n, bool pinned) {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4235,12 +4338,10 @@</span>
      case Op_LoadKlass:
      case Op_LoadNKlass:
      case Op_LoadL:
      case Op_LoadS:
      case Op_LoadP:
<span class="udiff-line-removed">-     case Op_LoadBarrierSlowReg:</span>
<span class="udiff-line-removed">-     case Op_LoadBarrierWeakSlowReg:</span>
      case Op_LoadN:
      case Op_LoadRange:
      case Op_LoadD_unaligned:
      case Op_LoadL_unaligned:
      case Op_StrComp:            // Does a bunch of load-like effects
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4249,10 +4350,13 @@</span>
      case Op_StrIndexOfChar:
      case Op_AryEq:
      case Op_HasNegatives:
        pinned = false;
      }
<span class="udiff-line-added">+     if (n-&gt;is_CMove()) {</span>
<span class="udiff-line-added">+       pinned = false;</span>
<span class="udiff-line-added">+     }</span>
      if( pinned ) {
        IdealLoopTree *chosen_loop = get_loop(n-&gt;is_CFG() ? n : get_ctrl(n));
        if( !chosen_loop-&gt;_child )       // Inner loop?
          chosen_loop-&gt;_body.push(n); // Collect inner loops
        return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4444,84 +4548,82 @@</span>
  }
  #endif
  
  #ifndef PRODUCT
  //------------------------------dump-------------------------------------------
<span class="udiff-line-modified-removed">- void PhaseIdealLoop::dump( ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseIdealLoop::dump() const {</span>
    ResourceMark rm;
    Arena* arena = Thread::current()-&gt;resource_area();
    Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
    Node_List rpo_list;
    VectorSet visited(arena);
    visited.set(C-&gt;top()-&gt;_idx);
<span class="udiff-line-modified-removed">-   rpo( C-&gt;root(), stack, visited, rpo_list );</span>
<span class="udiff-line-modified-added">+   rpo(C-&gt;root(), stack, visited, rpo_list);</span>
    // Dump root loop indexed by last element in PO order
<span class="udiff-line-modified-removed">-   dump( _ltree_root, rpo_list.size(), rpo_list );</span>
<span class="udiff-line-modified-added">+   dump(_ltree_root, rpo_list.size(), rpo_list);</span>
  }
  
<span class="udiff-line-modified-removed">- void PhaseIdealLoop::dump( IdealLoopTree *loop, uint idx, Node_List &amp;rpo_list ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseIdealLoop::dump(IdealLoopTree* loop, uint idx, Node_List &amp;rpo_list) const {</span>
    loop-&gt;dump_head();
  
    // Now scan for CFG nodes in the same loop
<span class="udiff-line-modified-removed">-   for( uint j=idx; j &gt; 0;  j-- ) {</span>
<span class="udiff-line-modified-removed">-     Node *n = rpo_list[j-1];</span>
<span class="udiff-line-modified-removed">-     if( !_nodes[n-&gt;_idx] )      // Skip dead nodes</span>
<span class="udiff-line-modified-added">+   for (uint j = idx; j &gt; 0; j--) {</span>
<span class="udiff-line-modified-added">+     Node* n = rpo_list[j-1];</span>
<span class="udiff-line-modified-added">+     if (!_nodes[n-&gt;_idx])      // Skip dead nodes</span>
        continue;
<span class="udiff-line-modified-removed">-     if( get_loop(n) != loop ) { // Wrong loop nest</span>
<span class="udiff-line-modified-removed">-       if( get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?</span>
<span class="udiff-line-modified-removed">-           get_loop(n)-&gt;_parent == loop )</span>
<span class="udiff-line-modified-removed">-         dump(get_loop(n),rpo_list.size(),rpo_list);     // Print it nested-ly</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (get_loop(n) != loop) { // Wrong loop nest</span>
<span class="udiff-line-modified-added">+       if (get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?</span>
<span class="udiff-line-modified-added">+           get_loop(n)-&gt;_parent == loop)</span>
<span class="udiff-line-added">+         dump(get_loop(n), rpo_list.size(), rpo_list);     // Print it nested-ly</span>
        continue;
      }
  
      // Dump controlling node
<span class="udiff-line-modified-removed">-     for( uint x = 0; x &lt; loop-&gt;_nest; x++ )</span>
<span class="udiff-line-removed">-       tty-&gt;print(&quot;  &quot;);</span>
<span class="udiff-line-modified-added">+     tty-&gt;sp(2 * loop-&gt;_nest);</span>
      tty-&gt;print(&quot;C&quot;);
<span class="udiff-line-modified-removed">-     if( n == C-&gt;root() ) {</span>
<span class="udiff-line-modified-added">+     if (n == C-&gt;root()) {</span>
        n-&gt;dump();
      } else {
        Node* cached_idom   = idom_no_update(n);
<span class="udiff-line-modified-removed">-       Node *computed_idom = n-&gt;in(0);</span>
<span class="udiff-line-modified-removed">-       if( n-&gt;is_Region() ) {</span>
<span class="udiff-line-modified-added">+       Node* computed_idom = n-&gt;in(0);</span>
<span class="udiff-line-modified-added">+       if (n-&gt;is_Region()) {</span>
          computed_idom = compute_idom(n);
          // computed_idom() will return n-&gt;in(0) when idom(n) is an IfNode (or
          // any MultiBranch ctrl node), so apply a similar transform to
          // the cached idom returned from idom_no_update.
          cached_idom = find_non_split_ctrl(cached_idom);
        }
<span class="udiff-line-modified-removed">-       tty-&gt;print(&quot; ID:%d&quot;,computed_idom-&gt;_idx);</span>
<span class="udiff-line-modified-added">+       tty-&gt;print(&quot; ID:%d&quot;, computed_idom-&gt;_idx);</span>
        n-&gt;dump();
<span class="udiff-line-modified-removed">-       if( cached_idom != computed_idom ) {</span>
<span class="udiff-line-modified-added">+       if (cached_idom != computed_idom) {</span>
          tty-&gt;print_cr(&quot;*** BROKEN IDOM!  Computed as: %d, cached as: %d&quot;,
                        computed_idom-&gt;_idx, cached_idom-&gt;_idx);
        }
      }
      // Dump nodes it controls
<span class="udiff-line-modified-removed">-     for( uint k = 0; k &lt; _nodes.Size(); k++ ) {</span>
<span class="udiff-line-modified-added">+     for (uint k = 0; k &lt; _nodes.Size(); k++) {</span>
        // (k &lt; C-&gt;unique() &amp;&amp; get_ctrl(find(k)) == n)
        if (k &lt; C-&gt;unique() &amp;&amp; _nodes[k] == (Node*)((intptr_t)n + 1)) {
<span class="udiff-line-modified-removed">-         Node *m = C-&gt;root()-&gt;find(k);</span>
<span class="udiff-line-modified-removed">-         if( m &amp;&amp; m-&gt;outcnt() &gt; 0 ) {</span>
<span class="udiff-line-modified-added">+         Node* m = C-&gt;root()-&gt;find(k);</span>
<span class="udiff-line-modified-added">+         if (m &amp;&amp; m-&gt;outcnt() &gt; 0) {</span>
            if (!(has_ctrl(m) &amp;&amp; get_ctrl_no_update(m) == n)) {
              tty-&gt;print_cr(&quot;*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p&quot;,
                            _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);
            }
<span class="udiff-line-modified-removed">-           for( uint j = 0; j &lt; loop-&gt;_nest; j++ )</span>
<span class="udiff-line-removed">-             tty-&gt;print(&quot;  &quot;);</span>
<span class="udiff-line-removed">-           tty-&gt;print(&quot; &quot;);</span>
<span class="udiff-line-modified-added">+           tty-&gt;sp(2 * loop-&gt;_nest + 1);</span>
            m-&gt;dump();
          }
        }
      }
    }
  }
  #endif
  
  // Collect a R-P-O for the whole CFG.
  // Result list is in post-order (scan backwards for RPO)
<span class="udiff-line-modified-removed">- void PhaseIdealLoop::rpo( Node *start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list ) const {</span>
<span class="udiff-line-modified-added">+ void PhaseIdealLoop::rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const {</span>
    stk.push(start, 0);
    visited.set(start-&gt;_idx);
  
    while (stk.is_nonempty()) {
      Node* m   = stk.node();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4539,11 +4641,11 @@</span>
    }
  }
  
  
  //=============================================================================
<span class="udiff-line-modified-removed">- //------------------------------LoopTreeIterator-----------------------------------</span>
<span class="udiff-line-modified-added">+ //------------------------------LoopTreeIterator-------------------------------</span>
  
  // Advance to next loop tree using a preorder, left-to-right traversal.
  void LoopTreeIterator::next() {
    assert(!done(), &quot;must not be done.&quot;);
    if (_curnt-&gt;_child != NULL) {
</pre>
<center><a href="loopUnswitch.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="multnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/machnode.hpp&quot;
  36 #include &quot;opto/matcher.hpp&quot;
  37 #include &quot;opto/node.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;

  44 
  45 class RegMask;
  46 // #include &quot;phase.hpp&quot;
  47 class PhaseTransform;
  48 class PhaseGVN;
  49 
  50 // Arena we are currently building Nodes in
  51 const uint Node::NotAMachineReg = 0xffff0000;
  52 
  53 #ifndef PRODUCT
  54 extern int nodes_created;
  55 #endif
  56 #ifdef __clang__
  57 #pragma clang diagnostic push
  58 #pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
  59 #endif
  60 
  61 #ifdef ASSERT
  62 
  63 //-------------------------- construct_node------------------------------------
</pre>
<hr />
<pre>
 547     n-&gt;as_SafePoint()-&gt;clone_replaced_nodes();
 548   }
 549   return n;                     // Return the clone
 550 }
 551 
 552 //---------------------------setup_is_top--------------------------------------
 553 // Call this when changing the top node, to reassert the invariants
 554 // required by Node::is_top.  See Compile::set_cached_top_node.
 555 void Node::setup_is_top() {
 556   if (this == (Node*)Compile::current()-&gt;top()) {
 557     // This node has just become top.  Kill its out array.
 558     _outcnt = _outmax = 0;
 559     _out = NULL;                           // marker value for top
 560     assert(is_top(), &quot;must be top&quot;);
 561   } else {
 562     if (_out == NULL)  _out = NO_OUT_ARRAY;
 563     assert(!is_top(), &quot;must not be top&quot;);
 564   }
 565 }
 566 
<span class="line-removed"> 567 </span>
 568 //------------------------------~Node------------------------------------------
 569 // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 570 void Node::destruct() {
 571   // Eagerly reclaim unique Node numberings
 572   Compile* compile = Compile::current();
 573   if ((uint)_idx+1 == compile-&gt;unique()) {
 574     compile-&gt;set_unique(compile-&gt;unique()-1);
 575   }
 576   // Clear debug info:
 577   Node_Notes* nn = compile-&gt;node_notes_at(_idx);
 578   if (nn != NULL)  nn-&gt;clear();
 579   // Walk the input array, freeing the corresponding output edges
 580   _cnt = _max;  // forget req/prec distinction
 581   uint i;
 582   for( i = 0; i &lt; _max; i++ ) {
 583     set_req(i, NULL);
 584     //assert(def-&gt;out(def-&gt;outcnt()-1) == (Node *)this,&quot;bad def-use hacking in reclaim&quot;);
 585   }
 586   assert(outcnt() == 0, &quot;deleting a node must not leave a dangling use&quot;);
 587   // See if the input array was allocated just prior to the object
</pre>
<hr />
<pre>
 637   _max = _cnt = _outmax = _outcnt = 0;
 638   compile-&gt;remove_modified_node(this);
 639 #endif
 640 }
 641 
 642 //------------------------------grow-------------------------------------------
 643 // Grow the input array, making space for more edges
 644 void Node::grow( uint len ) {
 645   Arena* arena = Compile::current()-&gt;node_arena();
 646   uint new_max = _max;
 647   if( new_max == 0 ) {
 648     _max = 4;
 649     _in = (Node**)arena-&gt;Amalloc(4*sizeof(Node*));
 650     Node** to = _in;
 651     to[0] = NULL;
 652     to[1] = NULL;
 653     to[2] = NULL;
 654     to[3] = NULL;
 655     return;
 656   }
<span class="line-modified"> 657   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
 658   // Trimming to limit allows a uint8 to handle up to 255 edges.
 659   // Previously I was using only powers-of-2 which peaked at 128 edges.
 660   //if( new_max &gt;= limit ) new_max = limit-1;
 661   _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
 662   Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
 663   _max = new_max;               // Record new max length
 664   // This assertion makes sure that Node::_max is wide enough to
 665   // represent the numerical value of new_max.
 666   assert(_max == new_max &amp;&amp; _max &gt; len, &quot;int width of _max is too small&quot;);
 667 }
 668 
 669 //-----------------------------out_grow----------------------------------------
 670 // Grow the input array, making space for more edges
 671 void Node::out_grow( uint len ) {
 672   assert(!is_top(), &quot;cannot grow a top node&#39;s out array&quot;);
 673   Arena* arena = Compile::current()-&gt;node_arena();
 674   uint new_max = _outmax;
 675   if( new_max == 0 ) {
 676     _outmax = 4;
 677     _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
 678     return;
 679   }
<span class="line-modified"> 680   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
 681   // Trimming to limit allows a uint8 to handle up to 255 edges.
 682   // Previously I was using only powers-of-2 which peaked at 128 edges.
 683   //if( new_max &gt;= limit ) new_max = limit-1;
 684   assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
 685   _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
 686   //Copy::zero_to_bytes(&amp;_out[_outmax], (new_max-_outmax)*sizeof(Node*)); // NULL all new space
 687   _outmax = new_max;               // Record new max length
 688   // This assertion makes sure that Node::_max is wide enough to
 689   // represent the numerical value of new_max.
 690   assert(_outmax == new_max &amp;&amp; _outmax &gt; len, &quot;int width of _outmax is too small&quot;);
 691 }
 692 
 693 #ifdef ASSERT
 694 //------------------------------is_dead----------------------------------------
 695 bool Node::is_dead() const {
 696   // Mach and pinch point nodes may look like dead.
 697   if( is_top() || is_Mach() || (Opcode() == Op_Node &amp;&amp; _outcnt &gt; 0) )
 698     return false;
 699   for( uint i = 0; i &lt; _max; i++ )
 700     if( _in[i] != NULL )
 701       return false;
 702   dump();
 703   return true;
 704 }
<span class="line-removed"> 705 #endif</span>
 706 


















 707 
 708 //------------------------------is_unreachable---------------------------------
 709 bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
 710   assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
 711   return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
 712 }
 713 
 714 //------------------------------add_req----------------------------------------
 715 // Add a new required input at the end
 716 void Node::add_req( Node *n ) {
 717   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 718 
 719   // Look to see if I can move precedence down one without reallocating
 720   if( (_cnt &gt;= _max) || (in(_max-1) != NULL) )
 721     grow( _max+1 );
 722 
 723   // Find a precedence edge to move
 724   if( in(_cnt) != NULL ) {       // Next precedence edge is busy?
 725     uint i;
 726     for( i=_cnt; i&lt;_max; i++ )
</pre>
<hr />
<pre>
 874   if( (req() != len()) &amp;&amp; (in(req()) != NULL) ) {
 875     uint max = len();
 876     for( uint i = 0; i &lt; max; ++i ) {
 877       if( in(i) == 0 ) continue;
 878       if( in(i) == n ) ++edges_to_n;
 879       set_prec(i, NULL);
 880     }
 881   }
 882 
 883   // Node::destruct requires all out edges be deleted first
 884   // debug_only(destruct();)   // no reuse benefit expected
 885   if (edges_to_n == 0) {
 886     C-&gt;record_dead_node(_idx);
 887   }
 888   return edges_to_n;
 889 }
 890 
 891 //-----------------------------uncast---------------------------------------
 892 // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
 893 // Strip away casting.  (It is depth-limited.)
<span class="line-modified"> 894 Node* Node::uncast() const {</span>

 895   // Should be inline:
 896   //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
<span class="line-modified"> 897   if (is_ConstraintCast())</span>
<span class="line-modified"> 898     return uncast_helper(this);</span>
<span class="line-modified"> 899   else</span>
 900     return (Node*) this;

 901 }
 902 
 903 // Find out of current node that matches opcode.
 904 Node* Node::find_out_with(int opcode) {
 905   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 906     Node* use = fast_out(i);
 907     if (use-&gt;Opcode() == opcode) {
 908       return use;
 909     }
 910   }
 911   return NULL;
 912 }
 913 
 914 // Return true if the current node has an out that matches opcode.
 915 bool Node::has_out_with(int opcode) {
 916   return (find_out_with(opcode) != NULL);
 917 }
 918 
 919 // Return true if the current node has an out that matches any of the opcodes.
 920 bool Node::has_out_with(int opcode1, int opcode2, int opcode3, int opcode4) {
 921   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 922       int opcode = fast_out(i)-&gt;Opcode();
 923       if (opcode == opcode1 || opcode == opcode2 || opcode == opcode3 || opcode == opcode4) {
 924         return true;
 925       }
 926   }
 927   return false;
 928 }
 929 
 930 
 931 //---------------------------uncast_helper-------------------------------------
<span class="line-modified"> 932 Node* Node::uncast_helper(const Node* p) {</span>
 933 #ifdef ASSERT
 934   uint depth_count = 0;
 935   const Node* orig_p = p;
 936 #endif
 937 
 938   while (true) {
 939 #ifdef ASSERT
 940     if (depth_count &gt;= K) {
 941       orig_p-&gt;dump(4);
 942       if (p != orig_p)
 943         p-&gt;dump(1);
 944     }
 945     assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
 946 #endif
 947     if (p == NULL || p-&gt;req() != 2) {
 948       break;
 949     } else if (p-&gt;is_ConstraintCast()) {



 950       p = p-&gt;in(1);
 951     } else {
 952       break;
 953     }
 954   }
 955   return (Node*) p;
 956 }
 957 
 958 //------------------------------add_prec---------------------------------------
 959 // Add a new precedence input.  Precedence inputs are unordered, with
 960 // duplicates removed and NULLs packed down at the end.
 961 void Node::add_prec( Node *n ) {
 962   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 963 
 964   // Check for NULL at end
 965   if( _cnt &gt;= _max || in(_max-1) )
 966     grow( _max+1 );
 967 
 968   // Find a precedence edge to move
 969   uint i = _cnt;
</pre>
<hr />
<pre>
1127 bool Node::has_special_unique_user() const {
1128   assert(outcnt() == 1, &quot;match only for unique out&quot;);
1129   Node* n = unique_out();
1130   int op  = Opcode();
1131   if (this-&gt;is_Store()) {
1132     // Condition for back-to-back stores folding.
1133     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(MemNode::Memory) == this;
1134   } else if (this-&gt;is_Load() || this-&gt;is_DecodeN() || this-&gt;is_Phi()) {
1135     // Condition for removing an unused LoadNode or DecodeNNode from the MemBarAcquire precedence input
1136     return n-&gt;Opcode() == Op_MemBarAcquire;
1137   } else if (op == Op_AddL) {
1138     // Condition for convL2I(addL(x,y)) ==&gt; addI(convL2I(x),convL2I(y))
1139     return n-&gt;Opcode() == Op_ConvL2I &amp;&amp; n-&gt;in(1) == this;
1140   } else if (op == Op_SubI || op == Op_SubL) {
1141     // Condition for subI(x,subI(y,z)) ==&gt; subI(addI(x,z),y)
1142     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
1143   } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
1144     // See IfProjNode::Identity()
1145     return true;
1146   } else {
<span class="line-modified">1147     return BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;has_special_unique_user(this);</span>
1148   }
1149 };
1150 
1151 //--------------------------find_exact_control---------------------------------
1152 // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1153 Node* Node::find_exact_control(Node* ctrl) {
1154   if (ctrl == NULL &amp;&amp; this-&gt;is_Region())
1155     ctrl = this-&gt;as_Region()-&gt;is_copy();
1156 
1157   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_CatchProj()) {
1158     if (ctrl-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index)
1159       ctrl = ctrl-&gt;in(0);
1160     if (ctrl != NULL &amp;&amp; !ctrl-&gt;is_top())
1161       ctrl = ctrl-&gt;in(0);
1162   }
1163 
1164   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj())
1165     ctrl = ctrl-&gt;in(0);
1166 
1167   return ctrl;
</pre>
<hr />
<pre>
1204       } else {
1205         // Region nodes were visited. Continue walk up to Start or Root
1206         // to make sure that it did not walk in a cycle.
1207         met_dom = true; // first time meet
1208         iterations_without_region_limit = DominatorSearchLimit; // Reset
1209      }
1210     }
1211     if (sub-&gt;is_Start() || sub-&gt;is_Root()) {
1212       // Success if we met &#39;dom&#39; along a path to Start or Root.
1213       // We assume there are no alternative paths that avoid &#39;dom&#39;.
1214       // (This assumption is up to the caller to ensure!)
1215       return met_dom;
1216     }
1217     Node* up = sub-&gt;in(0);
1218     // Normalize simple pass-through regions and projections:
1219     up = sub-&gt;find_exact_control(up);
1220     // If sub == up, we found a self-loop.  Try to push past it.
1221     if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
1222       // Take loop entry path on the way up to &#39;dom&#39;.
1223       up = sub-&gt;in(1); // in(LoopNode::EntryControl);
<span class="line-modified">1224     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() != 3) {</span>
<span class="line-modified">1225       // Always take in(1) path on the way up to &#39;dom&#39; for clone regions</span>
<span class="line-removed">1226       // (with only one input) or regions which merge &gt; 2 paths</span>
<span class="line-removed">1227       // (usually used to merge fast/slow paths).</span>
1228       up = sub-&gt;in(1);
<span class="line-modified">1229     } else if (sub == up &amp;&amp; sub-&gt;is_Region()) {</span>
1230       // Try both paths for Regions with 2 input paths (it may be a loop head).
1231       // It could give conservative &#39;false&#39; answer without information
1232       // which region&#39;s input is the entry path.
1233       iterations_without_region_limit = DominatorSearchLimit; // Reset
1234 
1235       bool region_was_visited_before = false;
1236       // Was this Region node visited before?
1237       // If so, we have reached it because we accidentally took a
1238       // loop-back edge from &#39;sub&#39; back into the body of the loop,
1239       // and worked our way up again to the loop header &#39;sub&#39;.
1240       // So, take the first unexplored path on the way up to &#39;dom&#39;.
1241       for (int j = nlist.size() - 1; j &gt;= 0; j--) {
1242         intptr_t ni = (intptr_t)nlist.at(j);
1243         Node* visited = (Node*)(ni &amp; ~1);
1244         bool  visited_twice_already = ((ni &amp; 1) != 0);
1245         if (visited == sub) {
1246           if (visited_twice_already) {
1247             // Visited 2 paths, but still stuck in loop body.  Give up.
1248             return false;
1249           }
</pre>
<hr />
<pre>
1284     if (--iterations_without_region_limit &lt; 0) {
1285       break;    // dead cycle
1286     }
1287     sub = up;
1288   }
1289 
1290   // Did not meet Root or Start node in pred. chain.
1291   // Conservative answer for dead code.
1292   return false;
1293 }
1294 
1295 //------------------------------remove_dead_region-----------------------------
1296 // This control node is dead.  Follow the subgraph below it making everything
1297 // using it dead as well.  This will happen normally via the usual IterGVN
1298 // worklist but this call is more efficient.  Do not update use-def info
1299 // inside the dead region, just at the borders.
1300 static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
1301   // Con&#39;s are a popular node to re-hit in the hash table again.
1302   if( dead-&gt;is_Con() ) return;
1303 
<span class="line-modified">1304   // Can&#39;t put ResourceMark here since igvn-&gt;_worklist uses the same arena</span>
<span class="line-removed">1305   // for verify pass with +VerifyOpto and we add/remove elements in it here.</span>
1306   Node_List  nstack(Thread::current()-&gt;resource_area());
1307 
1308   Node *top = igvn-&gt;C-&gt;top();
1309   nstack.push(dead);
1310   bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
1311 
1312   while (nstack.size() &gt; 0) {
1313     dead = nstack.pop();
1314     if (dead-&gt;Opcode() == Op_SafePoint) {
1315       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(igvn);
1316     }
1317     if (dead-&gt;outcnt() &gt; 0) {
1318       // Keep dead node on stack until all uses are processed.
1319       nstack.push(dead);
1320       // For all Users of the Dead...    ;-)
1321       for (DUIterator_Last kmin, k = dead-&gt;last_outs(kmin); k &gt;= kmin; ) {
1322         Node* use = dead-&gt;last_out(k);
1323         igvn-&gt;hash_delete(use);       // Yank from hash table prior to mod
1324         if (use-&gt;in(0) == dead) {     // Found another dead node
1325           assert (!use-&gt;is_Con(), &quot;Control for Con node should be Root node.&quot;);
</pre>
<hr />
<pre>
1416 
1417   if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
1418     Node *m = n-&gt;nonnull_req();
1419     set_req(0, m);
1420     return true;
1421   }
1422   return false;
1423 }
1424 
1425 //------------------------------hash-------------------------------------------
1426 // Hash function over Nodes.
1427 uint Node::hash() const {
1428   uint sum = 0;
1429   for( uint i=0; i&lt;_cnt; i++ )  // Add in all inputs
1430     sum = (sum&lt;&lt;1)-(uintptr_t)in(i);        // Ignore embedded NULLs
1431   return (sum&gt;&gt;2) + _cnt + Opcode();
1432 }
1433 
1434 //------------------------------cmp--------------------------------------------
1435 // Compare special parts of simple Nodes
<span class="line-modified">1436 uint Node::cmp( const Node &amp;n ) const {</span>
<span class="line-modified">1437   return 1;                     // Must be same</span>
1438 }
1439 
1440 //------------------------------rematerialize-----------------------------------
1441 // Should we clone rather than spill this instruction?
1442 bool Node::rematerialize() const {
1443   if ( is_Mach() )
1444     return this-&gt;as_Mach()-&gt;rematerialize();
1445   else
1446     return (_flags &amp; Flag_rematerialize) != 0;
1447 }
1448 
1449 //------------------------------needs_anti_dependence_check---------------------
1450 // Nodes which use memory without consuming it, hence need antidependences.
1451 bool Node::needs_anti_dependence_check() const {
<span class="line-modified">1452   if( req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0 )</span>
1453     return false;
<span class="line-modified">1454   else</span>
<span class="line-modified">1455     return in(1)-&gt;bottom_type()-&gt;has_memory();</span>
1456 }
1457 
<span class="line-removed">1458 </span>
1459 // Get an integer constant from a ConNode (or CastIINode).
1460 // Return a default value if there is no apparent constant here.
1461 const TypeInt* Node::find_int_type() const {
1462   if (this-&gt;is_Type()) {
1463     return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
1464   } else if (this-&gt;is_Con()) {
1465     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1466     return this-&gt;bottom_type()-&gt;isa_int();
1467   }
1468   return NULL;
1469 }
1470 
1471 // Get a pointer constant from a ConstNode.
1472 // Returns the constant if it is a pointer ConstNode
1473 intptr_t Node::get_ptr() const {
1474   assert( Opcode() == Op_ConP, &quot;&quot; );
1475   return ((ConPNode*)this)-&gt;type()-&gt;is_ptr()-&gt;get_con();
1476 }
1477 
1478 // Get a narrow oop constant from a ConNNode.
</pre>
<hr />
<pre>
2088   if (visited.member(this))  return;
2089   visited.push(this);
2090 
2091   // Walk over all input edges, checking for correspondence
2092   for( i = 0; i &lt; len(); i++ ) {
2093     n = in(i);
2094     if (n != NULL &amp;&amp; !n-&gt;is_top()) {
2095       // Count instances of (Node *)this
2096       cnt = 0;
2097       for (idx = 0; idx &lt; n-&gt;_outcnt; idx++ ) {
2098         if (n-&gt;_out[idx] == (Node *)this)  cnt++;
2099       }
2100       assert( cnt &gt; 0,&quot;Failed to find Def-Use edge.&quot; );
2101       // Check for duplicate edges
2102       // walk the input array downcounting the input edges to n
2103       for( j = 0; j &lt; len(); j++ ) {
2104         if( in(j) == n ) cnt--;
2105       }
2106       assert( cnt == 0,&quot;Mismatched edge count.&quot;);
2107     } else if (n == NULL) {
<span class="line-modified">2108       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi(), &quot;only regions or phis have null data edges&quot;);</span>

2109     } else {
2110       assert(n-&gt;is_top(), &quot;sanity&quot;);
2111       // Nothing to check.
2112     }
2113   }
2114   // Recursive walk over all input edges
2115   for( i = 0; i &lt; len(); i++ ) {
2116     n = in(i);
2117     if( n != NULL )
2118       in(i)-&gt;verify_edges(visited);
2119   }
2120 }
2121 
<span class="line-removed">2122 //------------------------------verify_recur-----------------------------------</span>
<span class="line-removed">2123 static const Node *unique_top = NULL;</span>
<span class="line-removed">2124 </span>
2125 void Node::verify_recur(const Node *n, int verify_depth,
2126                         VectorSet &amp;old_space, VectorSet &amp;new_space) {
2127   if ( verify_depth == 0 )  return;
2128   if (verify_depth &gt; 0)  --verify_depth;
2129 
2130   Compile* C = Compile::current();
2131 
2132   // Contained in new_space or old_space?
2133   VectorSet *v = C-&gt;node_arena()-&gt;contains(n) ? &amp;new_space : &amp;old_space;
2134   // Check for visited in the proper space.  Numberings are not unique
2135   // across spaces so we need a separate VectorSet for each space.
2136   if( v-&gt;test_set(n-&gt;_idx) ) return;
2137 
2138   if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {
2139     if (C-&gt;cached_top_node() == NULL)
2140       C-&gt;set_cached_top_node((Node*)n);
2141     assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);
2142   }
2143 
2144   for( uint i = 0; i &lt; n-&gt;len(); i++ ) {
</pre>
<hr />
<pre>
2222   _a-&gt;Afree(_nodes,_max*sizeof(Node*));
2223   _max   = 0;
2224   _nodes = NULL;
2225   _a     = new_arena;
2226 }
2227 
2228 //------------------------------clear------------------------------------------
2229 // Clear all entries in _nodes to NULL but keep storage
2230 void Node_Array::clear() {
2231   Copy::zero_to_bytes( _nodes, _max*sizeof(Node*) );
2232 }
2233 
2234 //-----------------------------------------------------------------------------
2235 void Node_Array::grow( uint i ) {
2236   if( !_max ) {
2237     _max = 1;
2238     _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
2239     _nodes[0] = NULL;
2240   }
2241   uint old = _max;
<span class="line-modified">2242   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit</span>
2243   _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
2244   Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
2245 }
2246 
2247 //-----------------------------------------------------------------------------
2248 void Node_Array::insert( uint i, Node *n ) {
2249   if( _nodes[_max-1] ) grow(_max);      // Get more space if full
2250   Copy::conjoint_words_to_higher((HeapWord*)&amp;_nodes[i], (HeapWord*)&amp;_nodes[i+1], ((_max-i-1)*sizeof(Node*)));
2251   _nodes[i] = n;
2252 }
2253 
2254 //-----------------------------------------------------------------------------
2255 void Node_Array::remove( uint i ) {
2256   Copy::conjoint_words_to_lower((HeapWord*)&amp;_nodes[i+1], (HeapWord*)&amp;_nodes[i], ((_max-i-1)*sizeof(Node*)));
2257   _nodes[_max-1] = NULL;
2258 }
2259 
2260 //-----------------------------------------------------------------------------
2261 void Node_Array::sort( C_sort_func_t func) {
2262   qsort( _nodes, _max, sizeof( Node* ), func );
</pre>
<hr />
<pre>
2365     if( _nodes[i] ) {
2366       tty-&gt;print(&quot;%5d--&gt; &quot;,i);
2367       _nodes[i]-&gt;dump();
2368     }
2369 #endif
2370 }
2371 
2372 void Node_List::dump_simple() const {
2373 #ifndef PRODUCT
2374   for( uint i = 0; i &lt; _cnt; i++ )
2375     if( _nodes[i] ) {
2376       tty-&gt;print(&quot; %d&quot;, _nodes[i]-&gt;_idx);
2377     } else {
2378       tty-&gt;print(&quot; NULL&quot;);
2379     }
2380 #endif
2381 }
2382 
2383 //=============================================================================
2384 //------------------------------remove-----------------------------------------
<span class="line-modified">2385 void Unique_Node_List::remove( Node *n ) {</span>
<span class="line-modified">2386   if( _in_worklist[n-&gt;_idx] ) {</span>
<span class="line-modified">2387     for( uint i = 0; i &lt; size(); i++ )</span>
<span class="line-modified">2388       if( _nodes[i] == n ) {</span>
<span class="line-modified">2389         map(i,Node_List::pop());</span>
<span class="line-modified">2390         _in_worklist &gt;&gt;= n-&gt;_idx;</span>
2391         return;
2392       }

2393     ShouldNotReachHere();
2394   }
2395 }
2396 
2397 //-----------------------remove_useless_nodes----------------------------------
2398 // Remove useless nodes from worklist
2399 void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
2400 
<span class="line-modified">2401   for( uint i = 0; i &lt; size(); ++i ) {</span>
2402     Node *n = at(i);
2403     assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
<span class="line-modified">2404     if( ! useful.test(n-&gt;_idx) ) {</span>
<span class="line-modified">2405       _in_worklist &gt;&gt;= n-&gt;_idx;</span>
2406       map(i,Node_List::pop());
2407       // Node *replacement = Node_List::pop();
2408       // if( i != size() ) { // Check if removing last entry
2409       //   _nodes[i] = replacement;
2410       // }
2411       --i;  // Visit popped node
2412       // If it was last entry, loop terminates since size() was also reduced
2413     }
2414   }
2415 }
2416 
2417 //=============================================================================
2418 void Node_Stack::grow() {
2419   size_t old_top = pointer_delta(_inode_top,_inodes,sizeof(INode)); // save _top
2420   size_t old_max = pointer_delta(_inode_max,_inodes,sizeof(INode));
2421   size_t max = old_max &lt;&lt; 1;             // max * 2
2422   _inodes = REALLOC_ARENA_ARRAY(_a, INode, _inodes, old_max, max);
2423   _inode_max = _inodes + max;
2424   _inode_top = _inodes + old_top;        // restore _top
2425 }
</pre>
<hr />
<pre>
2435 }
2436 
2437 //=============================================================================
2438 uint TypeNode::size_of() const { return sizeof(*this); }
2439 #ifndef PRODUCT
2440 void TypeNode::dump_spec(outputStream *st) const {
2441   if( !Verbose &amp;&amp; !WizardMode ) {
2442     // standard dump does this in Verbose and WizardMode
2443     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
2444   }
2445 }
2446 
2447 void TypeNode::dump_compact_spec(outputStream *st) const {
2448   st-&gt;print(&quot;#&quot;);
2449   _type-&gt;dump_on(st);
2450 }
2451 #endif
2452 uint TypeNode::hash() const {
2453   return Node::hash() + _type-&gt;hash();
2454 }
<span class="line-modified">2455 uint TypeNode::cmp( const Node &amp;n ) const</span>
2456 { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
2457 const Type *TypeNode::bottom_type() const { return _type; }
2458 const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
2459 
2460 //------------------------------ideal_reg--------------------------------------
2461 uint TypeNode::ideal_reg() const {
2462   return _type-&gt;ideal_reg();
2463 }
</pre>
</td>
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/machnode.hpp&quot;
  36 #include &quot;opto/matcher.hpp&quot;
  37 #include &quot;opto/node.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  44 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  45 
  46 class RegMask;
  47 // #include &quot;phase.hpp&quot;
  48 class PhaseTransform;
  49 class PhaseGVN;
  50 
  51 // Arena we are currently building Nodes in
  52 const uint Node::NotAMachineReg = 0xffff0000;
  53 
  54 #ifndef PRODUCT
  55 extern int nodes_created;
  56 #endif
  57 #ifdef __clang__
  58 #pragma clang diagnostic push
  59 #pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
  60 #endif
  61 
  62 #ifdef ASSERT
  63 
  64 //-------------------------- construct_node------------------------------------
</pre>
<hr />
<pre>
 548     n-&gt;as_SafePoint()-&gt;clone_replaced_nodes();
 549   }
 550   return n;                     // Return the clone
 551 }
 552 
 553 //---------------------------setup_is_top--------------------------------------
 554 // Call this when changing the top node, to reassert the invariants
 555 // required by Node::is_top.  See Compile::set_cached_top_node.
 556 void Node::setup_is_top() {
 557   if (this == (Node*)Compile::current()-&gt;top()) {
 558     // This node has just become top.  Kill its out array.
 559     _outcnt = _outmax = 0;
 560     _out = NULL;                           // marker value for top
 561     assert(is_top(), &quot;must be top&quot;);
 562   } else {
 563     if (_out == NULL)  _out = NO_OUT_ARRAY;
 564     assert(!is_top(), &quot;must not be top&quot;);
 565   }
 566 }
 567 

 568 //------------------------------~Node------------------------------------------
 569 // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 570 void Node::destruct() {
 571   // Eagerly reclaim unique Node numberings
 572   Compile* compile = Compile::current();
 573   if ((uint)_idx+1 == compile-&gt;unique()) {
 574     compile-&gt;set_unique(compile-&gt;unique()-1);
 575   }
 576   // Clear debug info:
 577   Node_Notes* nn = compile-&gt;node_notes_at(_idx);
 578   if (nn != NULL)  nn-&gt;clear();
 579   // Walk the input array, freeing the corresponding output edges
 580   _cnt = _max;  // forget req/prec distinction
 581   uint i;
 582   for( i = 0; i &lt; _max; i++ ) {
 583     set_req(i, NULL);
 584     //assert(def-&gt;out(def-&gt;outcnt()-1) == (Node *)this,&quot;bad def-use hacking in reclaim&quot;);
 585   }
 586   assert(outcnt() == 0, &quot;deleting a node must not leave a dangling use&quot;);
 587   // See if the input array was allocated just prior to the object
</pre>
<hr />
<pre>
 637   _max = _cnt = _outmax = _outcnt = 0;
 638   compile-&gt;remove_modified_node(this);
 639 #endif
 640 }
 641 
 642 //------------------------------grow-------------------------------------------
 643 // Grow the input array, making space for more edges
 644 void Node::grow( uint len ) {
 645   Arena* arena = Compile::current()-&gt;node_arena();
 646   uint new_max = _max;
 647   if( new_max == 0 ) {
 648     _max = 4;
 649     _in = (Node**)arena-&gt;Amalloc(4*sizeof(Node*));
 650     Node** to = _in;
 651     to[0] = NULL;
 652     to[1] = NULL;
 653     to[2] = NULL;
 654     to[3] = NULL;
 655     return;
 656   }
<span class="line-modified"> 657   new_max = next_power_of_2(len);</span>
 658   // Trimming to limit allows a uint8 to handle up to 255 edges.
 659   // Previously I was using only powers-of-2 which peaked at 128 edges.
 660   //if( new_max &gt;= limit ) new_max = limit-1;
 661   _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
 662   Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
 663   _max = new_max;               // Record new max length
 664   // This assertion makes sure that Node::_max is wide enough to
 665   // represent the numerical value of new_max.
 666   assert(_max == new_max &amp;&amp; _max &gt; len, &quot;int width of _max is too small&quot;);
 667 }
 668 
 669 //-----------------------------out_grow----------------------------------------
 670 // Grow the input array, making space for more edges
 671 void Node::out_grow( uint len ) {
 672   assert(!is_top(), &quot;cannot grow a top node&#39;s out array&quot;);
 673   Arena* arena = Compile::current()-&gt;node_arena();
 674   uint new_max = _outmax;
 675   if( new_max == 0 ) {
 676     _outmax = 4;
 677     _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
 678     return;
 679   }
<span class="line-modified"> 680   new_max = next_power_of_2(len);</span>
 681   // Trimming to limit allows a uint8 to handle up to 255 edges.
 682   // Previously I was using only powers-of-2 which peaked at 128 edges.
 683   //if( new_max &gt;= limit ) new_max = limit-1;
 684   assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
 685   _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
 686   //Copy::zero_to_bytes(&amp;_out[_outmax], (new_max-_outmax)*sizeof(Node*)); // NULL all new space
 687   _outmax = new_max;               // Record new max length
 688   // This assertion makes sure that Node::_max is wide enough to
 689   // represent the numerical value of new_max.
 690   assert(_outmax == new_max &amp;&amp; _outmax &gt; len, &quot;int width of _outmax is too small&quot;);
 691 }
 692 
 693 #ifdef ASSERT
 694 //------------------------------is_dead----------------------------------------
 695 bool Node::is_dead() const {
 696   // Mach and pinch point nodes may look like dead.
 697   if( is_top() || is_Mach() || (Opcode() == Op_Node &amp;&amp; _outcnt &gt; 0) )
 698     return false;
 699   for( uint i = 0; i &lt; _max; i++ )
 700     if( _in[i] != NULL )
 701       return false;
 702   dump();
 703   return true;
 704 }

 705 
<span class="line-added"> 706 bool Node::is_reachable_from_root() const {</span>
<span class="line-added"> 707   ResourceMark rm;</span>
<span class="line-added"> 708   Unique_Node_List wq;</span>
<span class="line-added"> 709   wq.push((Node*)this);</span>
<span class="line-added"> 710   RootNode* root = Compile::current()-&gt;root();</span>
<span class="line-added"> 711   for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-added"> 712     Node* m = wq.at(i);</span>
<span class="line-added"> 713     if (m == root) {</span>
<span class="line-added"> 714       return true;</span>
<span class="line-added"> 715     }</span>
<span class="line-added"> 716     for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added"> 717       Node* u = m-&gt;fast_out(j);</span>
<span class="line-added"> 718       wq.push(u);</span>
<span class="line-added"> 719     }</span>
<span class="line-added"> 720   }</span>
<span class="line-added"> 721   return false;</span>
<span class="line-added"> 722 }</span>
<span class="line-added"> 723 #endif</span>
 724 
 725 //------------------------------is_unreachable---------------------------------
 726 bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
 727   assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
 728   return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
 729 }
 730 
 731 //------------------------------add_req----------------------------------------
 732 // Add a new required input at the end
 733 void Node::add_req( Node *n ) {
 734   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 735 
 736   // Look to see if I can move precedence down one without reallocating
 737   if( (_cnt &gt;= _max) || (in(_max-1) != NULL) )
 738     grow( _max+1 );
 739 
 740   // Find a precedence edge to move
 741   if( in(_cnt) != NULL ) {       // Next precedence edge is busy?
 742     uint i;
 743     for( i=_cnt; i&lt;_max; i++ )
</pre>
<hr />
<pre>
 891   if( (req() != len()) &amp;&amp; (in(req()) != NULL) ) {
 892     uint max = len();
 893     for( uint i = 0; i &lt; max; ++i ) {
 894       if( in(i) == 0 ) continue;
 895       if( in(i) == n ) ++edges_to_n;
 896       set_prec(i, NULL);
 897     }
 898   }
 899 
 900   // Node::destruct requires all out edges be deleted first
 901   // debug_only(destruct();)   // no reuse benefit expected
 902   if (edges_to_n == 0) {
 903     C-&gt;record_dead_node(_idx);
 904   }
 905   return edges_to_n;
 906 }
 907 
 908 //-----------------------------uncast---------------------------------------
 909 // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
 910 // Strip away casting.  (It is depth-limited.)
<span class="line-modified"> 911 // Optionally, keep casts with dependencies.</span>
<span class="line-added"> 912 Node* Node::uncast(bool keep_deps) const {</span>
 913   // Should be inline:
 914   //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
<span class="line-modified"> 915   if (is_ConstraintCast()) {</span>
<span class="line-modified"> 916     return uncast_helper(this, keep_deps);</span>
<span class="line-modified"> 917   } else {</span>
 918     return (Node*) this;
<span class="line-added"> 919   }</span>
 920 }
 921 
 922 // Find out of current node that matches opcode.
 923 Node* Node::find_out_with(int opcode) {
 924   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 925     Node* use = fast_out(i);
 926     if (use-&gt;Opcode() == opcode) {
 927       return use;
 928     }
 929   }
 930   return NULL;
 931 }
 932 
 933 // Return true if the current node has an out that matches opcode.
 934 bool Node::has_out_with(int opcode) {
 935   return (find_out_with(opcode) != NULL);
 936 }
 937 
 938 // Return true if the current node has an out that matches any of the opcodes.
 939 bool Node::has_out_with(int opcode1, int opcode2, int opcode3, int opcode4) {
 940   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 941       int opcode = fast_out(i)-&gt;Opcode();
 942       if (opcode == opcode1 || opcode == opcode2 || opcode == opcode3 || opcode == opcode4) {
 943         return true;
 944       }
 945   }
 946   return false;
 947 }
 948 
 949 
 950 //---------------------------uncast_helper-------------------------------------
<span class="line-modified"> 951 Node* Node::uncast_helper(const Node* p, bool keep_deps) {</span>
 952 #ifdef ASSERT
 953   uint depth_count = 0;
 954   const Node* orig_p = p;
 955 #endif
 956 
 957   while (true) {
 958 #ifdef ASSERT
 959     if (depth_count &gt;= K) {
 960       orig_p-&gt;dump(4);
 961       if (p != orig_p)
 962         p-&gt;dump(1);
 963     }
 964     assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
 965 #endif
 966     if (p == NULL || p-&gt;req() != 2) {
 967       break;
 968     } else if (p-&gt;is_ConstraintCast()) {
<span class="line-added"> 969       if (keep_deps &amp;&amp; p-&gt;as_ConstraintCast()-&gt;carry_dependency()) {</span>
<span class="line-added"> 970         break; // stop at casts with dependencies</span>
<span class="line-added"> 971       }</span>
 972       p = p-&gt;in(1);
 973     } else {
 974       break;
 975     }
 976   }
 977   return (Node*) p;
 978 }
 979 
 980 //------------------------------add_prec---------------------------------------
 981 // Add a new precedence input.  Precedence inputs are unordered, with
 982 // duplicates removed and NULLs packed down at the end.
 983 void Node::add_prec( Node *n ) {
 984   assert( is_not_dead(n), &quot;can not use dead node&quot;);
 985 
 986   // Check for NULL at end
 987   if( _cnt &gt;= _max || in(_max-1) )
 988     grow( _max+1 );
 989 
 990   // Find a precedence edge to move
 991   uint i = _cnt;
</pre>
<hr />
<pre>
1149 bool Node::has_special_unique_user() const {
1150   assert(outcnt() == 1, &quot;match only for unique out&quot;);
1151   Node* n = unique_out();
1152   int op  = Opcode();
1153   if (this-&gt;is_Store()) {
1154     // Condition for back-to-back stores folding.
1155     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(MemNode::Memory) == this;
1156   } else if (this-&gt;is_Load() || this-&gt;is_DecodeN() || this-&gt;is_Phi()) {
1157     // Condition for removing an unused LoadNode or DecodeNNode from the MemBarAcquire precedence input
1158     return n-&gt;Opcode() == Op_MemBarAcquire;
1159   } else if (op == Op_AddL) {
1160     // Condition for convL2I(addL(x,y)) ==&gt; addI(convL2I(x),convL2I(y))
1161     return n-&gt;Opcode() == Op_ConvL2I &amp;&amp; n-&gt;in(1) == this;
1162   } else if (op == Op_SubI || op == Op_SubL) {
1163     // Condition for subI(x,subI(y,z)) ==&gt; subI(addI(x,z),y)
1164     return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
1165   } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
1166     // See IfProjNode::Identity()
1167     return true;
1168   } else {
<span class="line-modified">1169     return false;</span>
1170   }
1171 };
1172 
1173 //--------------------------find_exact_control---------------------------------
1174 // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1175 Node* Node::find_exact_control(Node* ctrl) {
1176   if (ctrl == NULL &amp;&amp; this-&gt;is_Region())
1177     ctrl = this-&gt;as_Region()-&gt;is_copy();
1178 
1179   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_CatchProj()) {
1180     if (ctrl-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index)
1181       ctrl = ctrl-&gt;in(0);
1182     if (ctrl != NULL &amp;&amp; !ctrl-&gt;is_top())
1183       ctrl = ctrl-&gt;in(0);
1184   }
1185 
1186   if (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj())
1187     ctrl = ctrl-&gt;in(0);
1188 
1189   return ctrl;
</pre>
<hr />
<pre>
1226       } else {
1227         // Region nodes were visited. Continue walk up to Start or Root
1228         // to make sure that it did not walk in a cycle.
1229         met_dom = true; // first time meet
1230         iterations_without_region_limit = DominatorSearchLimit; // Reset
1231      }
1232     }
1233     if (sub-&gt;is_Start() || sub-&gt;is_Root()) {
1234       // Success if we met &#39;dom&#39; along a path to Start or Root.
1235       // We assume there are no alternative paths that avoid &#39;dom&#39;.
1236       // (This assumption is up to the caller to ensure!)
1237       return met_dom;
1238     }
1239     Node* up = sub-&gt;in(0);
1240     // Normalize simple pass-through regions and projections:
1241     up = sub-&gt;find_exact_control(up);
1242     // If sub == up, we found a self-loop.  Try to push past it.
1243     if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
1244       // Take loop entry path on the way up to &#39;dom&#39;.
1245       up = sub-&gt;in(1); // in(LoopNode::EntryControl);
<span class="line-modified">1246     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 2) {</span>
<span class="line-modified">1247       // Take in(1) path on the way up to &#39;dom&#39; for regions with only one input</span>


1248       up = sub-&gt;in(1);
<span class="line-modified">1249     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 3) {</span>
1250       // Try both paths for Regions with 2 input paths (it may be a loop head).
1251       // It could give conservative &#39;false&#39; answer without information
1252       // which region&#39;s input is the entry path.
1253       iterations_without_region_limit = DominatorSearchLimit; // Reset
1254 
1255       bool region_was_visited_before = false;
1256       // Was this Region node visited before?
1257       // If so, we have reached it because we accidentally took a
1258       // loop-back edge from &#39;sub&#39; back into the body of the loop,
1259       // and worked our way up again to the loop header &#39;sub&#39;.
1260       // So, take the first unexplored path on the way up to &#39;dom&#39;.
1261       for (int j = nlist.size() - 1; j &gt;= 0; j--) {
1262         intptr_t ni = (intptr_t)nlist.at(j);
1263         Node* visited = (Node*)(ni &amp; ~1);
1264         bool  visited_twice_already = ((ni &amp; 1) != 0);
1265         if (visited == sub) {
1266           if (visited_twice_already) {
1267             // Visited 2 paths, but still stuck in loop body.  Give up.
1268             return false;
1269           }
</pre>
<hr />
<pre>
1304     if (--iterations_without_region_limit &lt; 0) {
1305       break;    // dead cycle
1306     }
1307     sub = up;
1308   }
1309 
1310   // Did not meet Root or Start node in pred. chain.
1311   // Conservative answer for dead code.
1312   return false;
1313 }
1314 
1315 //------------------------------remove_dead_region-----------------------------
1316 // This control node is dead.  Follow the subgraph below it making everything
1317 // using it dead as well.  This will happen normally via the usual IterGVN
1318 // worklist but this call is more efficient.  Do not update use-def info
1319 // inside the dead region, just at the borders.
1320 static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
1321   // Con&#39;s are a popular node to re-hit in the hash table again.
1322   if( dead-&gt;is_Con() ) return;
1323 
<span class="line-modified">1324   ResourceMark rm;</span>

1325   Node_List  nstack(Thread::current()-&gt;resource_area());
1326 
1327   Node *top = igvn-&gt;C-&gt;top();
1328   nstack.push(dead);
1329   bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
1330 
1331   while (nstack.size() &gt; 0) {
1332     dead = nstack.pop();
1333     if (dead-&gt;Opcode() == Op_SafePoint) {
1334       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(igvn);
1335     }
1336     if (dead-&gt;outcnt() &gt; 0) {
1337       // Keep dead node on stack until all uses are processed.
1338       nstack.push(dead);
1339       // For all Users of the Dead...    ;-)
1340       for (DUIterator_Last kmin, k = dead-&gt;last_outs(kmin); k &gt;= kmin; ) {
1341         Node* use = dead-&gt;last_out(k);
1342         igvn-&gt;hash_delete(use);       // Yank from hash table prior to mod
1343         if (use-&gt;in(0) == dead) {     // Found another dead node
1344           assert (!use-&gt;is_Con(), &quot;Control for Con node should be Root node.&quot;);
</pre>
<hr />
<pre>
1435 
1436   if( n-&gt;is_Region() &amp;&amp; n-&gt;as_Region()-&gt;is_copy() ) {
1437     Node *m = n-&gt;nonnull_req();
1438     set_req(0, m);
1439     return true;
1440   }
1441   return false;
1442 }
1443 
1444 //------------------------------hash-------------------------------------------
1445 // Hash function over Nodes.
1446 uint Node::hash() const {
1447   uint sum = 0;
1448   for( uint i=0; i&lt;_cnt; i++ )  // Add in all inputs
1449     sum = (sum&lt;&lt;1)-(uintptr_t)in(i);        // Ignore embedded NULLs
1450   return (sum&gt;&gt;2) + _cnt + Opcode();
1451 }
1452 
1453 //------------------------------cmp--------------------------------------------
1454 // Compare special parts of simple Nodes
<span class="line-modified">1455 bool Node::cmp( const Node &amp;n ) const {</span>
<span class="line-modified">1456   return true;                  // Must be same</span>
1457 }
1458 
1459 //------------------------------rematerialize-----------------------------------
1460 // Should we clone rather than spill this instruction?
1461 bool Node::rematerialize() const {
1462   if ( is_Mach() )
1463     return this-&gt;as_Mach()-&gt;rematerialize();
1464   else
1465     return (_flags &amp; Flag_rematerialize) != 0;
1466 }
1467 
1468 //------------------------------needs_anti_dependence_check---------------------
1469 // Nodes which use memory without consuming it, hence need antidependences.
1470 bool Node::needs_anti_dependence_check() const {
<span class="line-modified">1471   if (req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0) {</span>
1472     return false;
<span class="line-modified">1473   }</span>
<span class="line-modified">1474   return in(1)-&gt;bottom_type()-&gt;has_memory();</span>
1475 }
1476 

1477 // Get an integer constant from a ConNode (or CastIINode).
1478 // Return a default value if there is no apparent constant here.
1479 const TypeInt* Node::find_int_type() const {
1480   if (this-&gt;is_Type()) {
1481     return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
1482   } else if (this-&gt;is_Con()) {
1483     assert(is_Mach(), &quot;should be ConNode(TypeNode) or else a MachNode&quot;);
1484     return this-&gt;bottom_type()-&gt;isa_int();
1485   }
1486   return NULL;
1487 }
1488 
1489 // Get a pointer constant from a ConstNode.
1490 // Returns the constant if it is a pointer ConstNode
1491 intptr_t Node::get_ptr() const {
1492   assert( Opcode() == Op_ConP, &quot;&quot; );
1493   return ((ConPNode*)this)-&gt;type()-&gt;is_ptr()-&gt;get_con();
1494 }
1495 
1496 // Get a narrow oop constant from a ConNNode.
</pre>
<hr />
<pre>
2106   if (visited.member(this))  return;
2107   visited.push(this);
2108 
2109   // Walk over all input edges, checking for correspondence
2110   for( i = 0; i &lt; len(); i++ ) {
2111     n = in(i);
2112     if (n != NULL &amp;&amp; !n-&gt;is_top()) {
2113       // Count instances of (Node *)this
2114       cnt = 0;
2115       for (idx = 0; idx &lt; n-&gt;_outcnt; idx++ ) {
2116         if (n-&gt;_out[idx] == (Node *)this)  cnt++;
2117       }
2118       assert( cnt &gt; 0,&quot;Failed to find Def-Use edge.&quot; );
2119       // Check for duplicate edges
2120       // walk the input array downcounting the input edges to n
2121       for( j = 0; j &lt; len(); j++ ) {
2122         if( in(j) == n ) cnt--;
2123       }
2124       assert( cnt == 0,&quot;Mismatched edge count.&quot;);
2125     } else if (n == NULL) {
<span class="line-modified">2126       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy()</span>
<span class="line-added">2127               || (is_Unlock() &amp;&amp; i == req()-1), &quot;only region, phi, arraycopy or unlock nodes have null data edges&quot;);</span>
2128     } else {
2129       assert(n-&gt;is_top(), &quot;sanity&quot;);
2130       // Nothing to check.
2131     }
2132   }
2133   // Recursive walk over all input edges
2134   for( i = 0; i &lt; len(); i++ ) {
2135     n = in(i);
2136     if( n != NULL )
2137       in(i)-&gt;verify_edges(visited);
2138   }
2139 }
2140 



2141 void Node::verify_recur(const Node *n, int verify_depth,
2142                         VectorSet &amp;old_space, VectorSet &amp;new_space) {
2143   if ( verify_depth == 0 )  return;
2144   if (verify_depth &gt; 0)  --verify_depth;
2145 
2146   Compile* C = Compile::current();
2147 
2148   // Contained in new_space or old_space?
2149   VectorSet *v = C-&gt;node_arena()-&gt;contains(n) ? &amp;new_space : &amp;old_space;
2150   // Check for visited in the proper space.  Numberings are not unique
2151   // across spaces so we need a separate VectorSet for each space.
2152   if( v-&gt;test_set(n-&gt;_idx) ) return;
2153 
2154   if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {
2155     if (C-&gt;cached_top_node() == NULL)
2156       C-&gt;set_cached_top_node((Node*)n);
2157     assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);
2158   }
2159 
2160   for( uint i = 0; i &lt; n-&gt;len(); i++ ) {
</pre>
<hr />
<pre>
2238   _a-&gt;Afree(_nodes,_max*sizeof(Node*));
2239   _max   = 0;
2240   _nodes = NULL;
2241   _a     = new_arena;
2242 }
2243 
2244 //------------------------------clear------------------------------------------
2245 // Clear all entries in _nodes to NULL but keep storage
2246 void Node_Array::clear() {
2247   Copy::zero_to_bytes( _nodes, _max*sizeof(Node*) );
2248 }
2249 
2250 //-----------------------------------------------------------------------------
2251 void Node_Array::grow( uint i ) {
2252   if( !_max ) {
2253     _max = 1;
2254     _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
2255     _nodes[0] = NULL;
2256   }
2257   uint old = _max;
<span class="line-modified">2258   _max = next_power_of_2(i);</span>
2259   _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
2260   Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
2261 }
2262 
2263 //-----------------------------------------------------------------------------
2264 void Node_Array::insert( uint i, Node *n ) {
2265   if( _nodes[_max-1] ) grow(_max);      // Get more space if full
2266   Copy::conjoint_words_to_higher((HeapWord*)&amp;_nodes[i], (HeapWord*)&amp;_nodes[i+1], ((_max-i-1)*sizeof(Node*)));
2267   _nodes[i] = n;
2268 }
2269 
2270 //-----------------------------------------------------------------------------
2271 void Node_Array::remove( uint i ) {
2272   Copy::conjoint_words_to_lower((HeapWord*)&amp;_nodes[i+1], (HeapWord*)&amp;_nodes[i], ((_max-i-1)*sizeof(Node*)));
2273   _nodes[_max-1] = NULL;
2274 }
2275 
2276 //-----------------------------------------------------------------------------
2277 void Node_Array::sort( C_sort_func_t func) {
2278   qsort( _nodes, _max, sizeof( Node* ), func );
</pre>
<hr />
<pre>
2381     if( _nodes[i] ) {
2382       tty-&gt;print(&quot;%5d--&gt; &quot;,i);
2383       _nodes[i]-&gt;dump();
2384     }
2385 #endif
2386 }
2387 
2388 void Node_List::dump_simple() const {
2389 #ifndef PRODUCT
2390   for( uint i = 0; i &lt; _cnt; i++ )
2391     if( _nodes[i] ) {
2392       tty-&gt;print(&quot; %d&quot;, _nodes[i]-&gt;_idx);
2393     } else {
2394       tty-&gt;print(&quot; NULL&quot;);
2395     }
2396 #endif
2397 }
2398 
2399 //=============================================================================
2400 //------------------------------remove-----------------------------------------
<span class="line-modified">2401 void Unique_Node_List::remove(Node* n) {</span>
<span class="line-modified">2402   if (_in_worklist.test(n-&gt;_idx)) {</span>
<span class="line-modified">2403     for (uint i = 0; i &lt; size(); i++) {</span>
<span class="line-modified">2404       if (_nodes[i] == n) {</span>
<span class="line-modified">2405         map(i, Node_List::pop());</span>
<span class="line-modified">2406         _in_worklist.remove(n-&gt;_idx);</span>
2407         return;
2408       }
<span class="line-added">2409     }</span>
2410     ShouldNotReachHere();
2411   }
2412 }
2413 
2414 //-----------------------remove_useless_nodes----------------------------------
2415 // Remove useless nodes from worklist
2416 void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
2417 
<span class="line-modified">2418   for (uint i = 0; i &lt; size(); ++i) {</span>
2419     Node *n = at(i);
2420     assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
<span class="line-modified">2421     if (!useful.test(n-&gt;_idx)) {</span>
<span class="line-modified">2422       _in_worklist.remove(n-&gt;_idx);</span>
2423       map(i,Node_List::pop());
2424       // Node *replacement = Node_List::pop();
2425       // if( i != size() ) { // Check if removing last entry
2426       //   _nodes[i] = replacement;
2427       // }
2428       --i;  // Visit popped node
2429       // If it was last entry, loop terminates since size() was also reduced
2430     }
2431   }
2432 }
2433 
2434 //=============================================================================
2435 void Node_Stack::grow() {
2436   size_t old_top = pointer_delta(_inode_top,_inodes,sizeof(INode)); // save _top
2437   size_t old_max = pointer_delta(_inode_max,_inodes,sizeof(INode));
2438   size_t max = old_max &lt;&lt; 1;             // max * 2
2439   _inodes = REALLOC_ARENA_ARRAY(_a, INode, _inodes, old_max, max);
2440   _inode_max = _inodes + max;
2441   _inode_top = _inodes + old_top;        // restore _top
2442 }
</pre>
<hr />
<pre>
2452 }
2453 
2454 //=============================================================================
2455 uint TypeNode::size_of() const { return sizeof(*this); }
2456 #ifndef PRODUCT
2457 void TypeNode::dump_spec(outputStream *st) const {
2458   if( !Verbose &amp;&amp; !WizardMode ) {
2459     // standard dump does this in Verbose and WizardMode
2460     st-&gt;print(&quot; #&quot;); _type-&gt;dump_on(st);
2461   }
2462 }
2463 
2464 void TypeNode::dump_compact_spec(outputStream *st) const {
2465   st-&gt;print(&quot;#&quot;);
2466   _type-&gt;dump_on(st);
2467 }
2468 #endif
2469 uint TypeNode::hash() const {
2470   return Node::hash() + _type-&gt;hash();
2471 }
<span class="line-modified">2472 bool TypeNode::cmp( const Node &amp;n ) const</span>
2473 { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
2474 const Type *TypeNode::bottom_type() const { return _type; }
2475 const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
2476 
2477 //------------------------------ideal_reg--------------------------------------
2478 uint TypeNode::ideal_reg() const {
2479   return _type-&gt;ideal_reg();
2480 }
</pre>
</td>
</tr>
</table>
<center><a href="multnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="machnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 144   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 145   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 146   // Check for PC-Relative displacement
 147   virtual relocInfo::relocType disp_reloc() const;
 148   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 149   virtual int  base_position()  const;  // base edge position, or -1
 150   virtual int  index_position() const;  // index edge position, or -1
 151 
 152   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 153   // Only returns non-null value for i486.ad&#39;s indOffset32X
 154   virtual const TypePtr *disp_as_type() const { return NULL; }
 155 
 156   // Return the label
 157   virtual Label *label() const;
 158 
 159   // Return the method&#39;s address
 160   virtual intptr_t  method() const;
 161 
 162   // Hash and compare over operands are currently identical
 163   virtual uint  hash() const;
<span class="line-modified"> 164   virtual uint  cmp( const MachOper &amp;oper ) const;</span>
 165 
 166   // Virtual clone, since I do not know how big the MachOper is.
 167   virtual MachOper *clone() const = 0;
 168 
 169   // Return ideal Type from simple operands.  Fail for complex operands.
 170   virtual const Type *type() const;
 171 
 172   // Set an integer offset if we have one, or error otherwise
 173   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 174 
 175 #ifndef PRODUCT
 176   // Return name of operand
 177   virtual const char    *Name() const { return &quot;???&quot;;}
 178 
 179   // Methods to output the text version of the operand
 180   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 181   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 182 
 183   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 184 
 185   // Check whether o is a valid oper.
 186   static bool notAnOper(const MachOper *o) {
 187     if (o == NULL)                   return true;
 188     if (((intptr_t)o &amp; 1) != 0)      return true;
 189     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 190     return false;
 191   }
 192 #endif // !PRODUCT
 193 };
 194 
 195 //------------------------------MachNode---------------------------------------
 196 // Base type for all machine specific nodes.  All node classes generated by the
 197 // ADLC inherit from this class.
 198 class MachNode : public Node {
 199 public:
<span class="line-modified"> 200   MachNode() : Node((uint)0), _num_opnds(0), _opnds(NULL) {</span>
 201     init_class_id(Class_Mach);
 202   }
 203   // Required boilerplate
 204   virtual uint size_of() const { return sizeof(MachNode); }
 205   virtual int  Opcode() const;          // Always equal to MachNode
 206   virtual uint rule() const = 0;        // Machine-specific opcode
 207   // Number of inputs which come before the first operand.
 208   // Generally at least 1, to skip the Control input
 209   virtual uint oper_input_base() const { return 1; }
 210   // Position of constant base node in node&#39;s inputs. -1 if
 211   // no constant base node input.
 212   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 213 



 214   // Copy inputs and operands to new node of instruction.
 215   // Called from cisc_version() and short_branch_version().
 216   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 217   void fill_new_machnode(MachNode *n) const;
 218 
 219   // Return an equivalent instruction using memory for cisc_operand position
 220   virtual MachNode *cisc_version(int offset);
 221   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 222   virtual void use_cisc_RegMask();
 223 
 224   // Support for short branches
 225   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 226 
 227   // Avoid back to back some instructions on some CPUs.
 228   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 229                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 230                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 231                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 232 
 233   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 234     return (flags() &amp; flag_value) == flag_value;
 235   }
 236 
 237   // instruction implemented with a call
 238   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 239 
 240   // First index in _in[] corresponding to operand, or -1 if there is none
 241   int  operand_index(uint operand) const;
 242   int  operand_index(const MachOper *oper) const;

 243 
 244   // Register class input is expected in
 245   virtual const RegMask &amp;in_RegMask(uint) const;
 246 
 247   // cisc-spillable instructions redefine for use by in_RegMask
 248   virtual const RegMask *cisc_RegMask() const { return NULL; }
 249 
 250   // If this instruction is a 2-address instruction, then return the
 251   // index of the input which must match the output.  Not nessecary
 252   // for instructions which bind the input and output register to the
 253   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 254   // both an input and an output).  It is nessecary when the input and
 255   // output have choices - but they must use the same choice.
 256   virtual uint two_adr( ) const { return 0; }
 257 



 258   // Array of complex operand pointers.  Each corresponds to zero or
 259   // more leafs.  Must be set by MachNode constructor to point to an
 260   // internal array of MachOpers.  The MachOper array is sized by
 261   // specific MachNodes described in the ADL.
 262   uint _num_opnds;
 263   MachOper **_opnds;
 264   uint  num_opnds() const { return _num_opnds; }
 265 
 266   // Emit bytes into cbuf
 267   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 268   // Expand node after register allocation.
 269   // Node is replaced by several nodes in the postalloc expand phase.
 270   // Corresponding methods are generated for nodes if they specify
 271   // postalloc_expand. See block.cpp for more documentation.
 272   virtual bool requires_postalloc_expand() const { return false; }
 273   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 274   // Size of instruction in bytes
 275   virtual uint  size(PhaseRegAlloc *ra_) const;
 276   // Helper function that computes size by emitting code
 277   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 278 
 279   // Return the alignment required (in units of relocInfo::addr_unit())
 280   // for this instruction (must be a power of 2)
 281   virtual int   alignment_required() const { return 1; }
 282 
 283   // Return the padding (in bytes) to be emitted before this
 284   // instruction to properly align it.
 285   virtual int   compute_padding(int current_offset) const { return 0; }
 286 
 287   // Return number of relocatable values contained in this instruction
 288   virtual int   reloc() const { return 0; }
 289 
 290   // Return number of words used for double constants in this instruction
 291   virtual int   ins_num_consts() const { return 0; }
 292 
 293   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 294   virtual uint  hash() const;
<span class="line-modified"> 295   virtual uint  cmp( const Node &amp;n ) const;</span>
 296 
 297   // Expand method for MachNode, replaces nodes representing pseudo
 298   // instructions with a set of nodes which represent real machine
 299   // instructions and compute the same value.
 300   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 301 
 302   // Bottom_type call; value comes from operand0
 303   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
<span class="line-modified"> 304   virtual uint ideal_reg() const { const Type *t = _opnds[0]-&gt;type(); return t == TypeInt::CC ? Op_RegFlags : t-&gt;ideal_reg(); }</span>







 305 
 306   // If this is a memory op, return the base pointer and fixed offset.
 307   // If there are no such, return NULL.  If there are multiple addresses
 308   // or the address is indeterminate (rare cases) then return (Node*)-1,
 309   // which serves as node bottom.
 310   // If the offset is not statically determined, set it to Type::OffsetBot.
 311   // This method is free to ignore stack slots if that helps.
 312   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 313   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 314   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 315 
 316   // Helper for get_base_and_disp: find the base and index input nodes.
 317   // Returns the MachOper as determined by memory_operand(), for use, if
 318   // needed by the caller. If (MachOper *)-1 is returned, base and index
 319   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 320   // index are set to NULL.
 321   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 322 
 323   // Helper for memory_inputs:  Which operand carries the necessary info?
 324   // By default, returns NULL, which means there is no such operand.
</pre>
<hr />
<pre>
 844   }
 845   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 846     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 847     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 848   }
 849   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 850     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 851     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 852   }
 853   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 854     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 855     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 856   }
 857 };
 858 
 859 //------------------------------MachCallNode----------------------------------
 860 // Machine-specific versions of subroutine calls
 861 class MachCallNode : public MachSafePointNode {
 862 protected:
 863   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
<span class="line-modified"> 864   virtual uint cmp( const Node &amp;n ) const;</span>
 865   virtual uint size_of() const = 0; // Size is bigger
 866 public:
 867   const TypeFunc *_tf;        // Function type
 868   address      _entry_point;  // Address of the method being called
 869   float        _cnt;          // Estimate of number of times called
 870   uint         _argsize;      // Size of argument block on stack
 871 
 872   const TypeFunc* tf()        const { return _tf; }
 873   const address entry_point() const { return _entry_point; }
 874   const float   cnt()         const { return _cnt; }
 875   uint argsize()              const { return _argsize; }
 876 
 877   void set_tf(const TypeFunc* tf) { _tf = tf; }
 878   void set_entry_point(address p) { _entry_point = p; }
 879   void set_cnt(float c)           { _cnt = c; }
 880   void set_argsize(int s)         { _argsize = s; }
 881 
 882   MachCallNode() : MachSafePointNode() {
 883     init_class_id(Class_MachCall);
 884   }
</pre>
<hr />
<pre>
 887   virtual bool  pinned() const { return false; }
 888   virtual const Type* Value(PhaseGVN* phase) const;
 889   virtual const RegMask &amp;in_RegMask(uint) const;
 890   virtual int ret_addr_offset() { return 0; }
 891 
 892   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 893   bool return_value_is_used() const;
 894 
 895   // Similar to cousin class CallNode::returns_pointer
 896   bool returns_pointer() const;
 897 
 898 #ifndef PRODUCT
 899   virtual void dump_spec(outputStream *st) const;
 900 #endif
 901 };
 902 
 903 //------------------------------MachCallJavaNode------------------------------
 904 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 905 class MachCallJavaNode : public MachCallNode {
 906 protected:
<span class="line-modified"> 907   virtual uint cmp( const Node &amp;n ) const;</span>
 908   virtual uint size_of() const; // Size is bigger
 909 public:
 910   ciMethod* _method;                 // Method being direct called
 911   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 912   int       _bci;                    // Byte Code index of call byte code
 913   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 914   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 915   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 916     init_class_id(Class_MachCallJava);
 917   }
 918 
 919   virtual const RegMask &amp;in_RegMask(uint) const;
 920 
 921   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 922     if (_override_symbolic_info) {
 923       // Attach corresponding Method* to the call site, so VM can use it during resolution
 924       // instead of querying symbolic info from bytecode.
 925       assert(_method != NULL, &quot;method should be set&quot;);
 926       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 927       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 928     }
 929     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 930   }
 931 
 932 #ifndef PRODUCT
 933   virtual void dump_spec(outputStream *st) const;
 934 #endif
 935 };
 936 
 937 //------------------------------MachCallStaticJavaNode------------------------
 938 // Machine-specific versions of monomorphic subroutine calls
 939 class MachCallStaticJavaNode : public MachCallJavaNode {
<span class="line-modified"> 940   virtual uint cmp( const Node &amp;n ) const;</span>
 941   virtual uint size_of() const; // Size is bigger
 942 public:
 943   const char *_name;            // Runtime wrapper name
 944   MachCallStaticJavaNode() : MachCallJavaNode() {
 945     init_class_id(Class_MachCallStaticJava);
 946   }
 947 
 948   // If this is an uncommon trap, return the request code, else zero.
 949   int uncommon_trap_request() const;
 950 
 951   virtual int ret_addr_offset();
 952 #ifndef PRODUCT
 953   virtual void dump_spec(outputStream *st) const;
 954   void dump_trap_args(outputStream *st) const;
 955 #endif
 956 };
 957 
 958 //------------------------------MachCallDynamicJavaNode------------------------
 959 // Machine-specific versions of possibly megamorphic subroutine calls
 960 class MachCallDynamicJavaNode : public MachCallJavaNode {
 961 public:
 962   int _vtable_index;
 963   MachCallDynamicJavaNode() : MachCallJavaNode() {
 964     init_class_id(Class_MachCallDynamicJava);
 965     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
 966   }
 967   virtual int ret_addr_offset();
 968 #ifndef PRODUCT
 969   virtual void dump_spec(outputStream *st) const;
 970 #endif
 971 };
 972 
 973 //------------------------------MachCallRuntimeNode----------------------------
 974 // Machine-specific versions of subroutine calls
 975 class MachCallRuntimeNode : public MachCallNode {
<span class="line-modified"> 976   virtual uint cmp( const Node &amp;n ) const;</span>
 977   virtual uint size_of() const; // Size is bigger
 978 public:
 979   const char *_name;            // Printable name, if _method is NULL
 980   MachCallRuntimeNode() : MachCallNode() {
 981     init_class_id(Class_MachCallRuntime);
 982   }
 983   virtual int ret_addr_offset();
 984 #ifndef PRODUCT
 985   virtual void dump_spec(outputStream *st) const;
 986 #endif
 987 };
 988 
 989 class MachCallLeafNode: public MachCallRuntimeNode {
 990 public:
 991   MachCallLeafNode() : MachCallRuntimeNode() {
 992     init_class_id(Class_MachCallLeaf);
 993   }
 994 };
 995 
 996 //------------------------------MachHaltNode-----------------------------------
 997 // Machine-specific versions of halt nodes
 998 class MachHaltNode : public MachReturnNode {
 999 public:

1000   virtual JVMState* jvms() const;
1001 };
1002 
1003 class MachMemBarNode : public MachNode {
1004   virtual uint size_of() const; // Size is bigger
1005 public:
1006   const TypePtr* _adr_type;     // memory effects
1007   MachMemBarNode() : MachNode() {
1008     init_class_id(Class_MachMemBar);
1009     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1010   }
1011 
1012   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1013   virtual const TypePtr *adr_type() const;
1014 };
1015 
1016 
1017 //------------------------------MachTempNode-----------------------------------
1018 // Node used by the adlc to construct inputs to represent temporary registers
1019 class MachTempNode : public MachNode {
</pre>
<hr />
<pre>
1049   virtual uint           num_edges() const { return 0; }
1050 public:
1051   // Supported for fixed size branches
1052   Label* _label;                // Label for branch(es)
1053 
1054   uint _block_num;
1055 
1056   labelOper() : _label(0), _block_num(0) {}
1057 
1058   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1059 
1060   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1061 
1062   virtual MachOper *clone() const;
1063 
1064   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1065 
1066   virtual uint           opcode() const;
1067 
1068   virtual uint           hash()   const;
<span class="line-modified">1069   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
1070 #ifndef PRODUCT
1071   virtual const char    *Name()   const { return &quot;Label&quot;;}
1072 
1073   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1074   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1075 #endif
1076 };
1077 
1078 
1079 //------------------------------methodOper--------------------------------------
1080 // Machine-independent version of method operand
1081 class methodOper : public MachOper {
1082 private:
1083   virtual uint           num_edges() const { return 0; }
1084 public:
1085   intptr_t _method;             // Address of method
1086   methodOper() :   _method(0) {}
1087   methodOper(intptr_t method) : _method(method)  {}
1088 
1089   virtual MachOper *clone() const;
1090 
1091   virtual intptr_t method() const { return _method; }
1092 
1093   virtual uint           opcode() const;
1094 
1095   virtual uint           hash()   const;
<span class="line-modified">1096   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
1097 #ifndef PRODUCT
1098   virtual const char    *Name()   const { return &quot;Method&quot;;}
1099 
1100   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1101   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1102 #endif
1103 };
1104 
1105 #endif // SHARE_OPTO_MACHNODE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 144   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 145   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 146   // Check for PC-Relative displacement
 147   virtual relocInfo::relocType disp_reloc() const;
 148   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 149   virtual int  base_position()  const;  // base edge position, or -1
 150   virtual int  index_position() const;  // index edge position, or -1
 151 
 152   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 153   // Only returns non-null value for i486.ad&#39;s indOffset32X
 154   virtual const TypePtr *disp_as_type() const { return NULL; }
 155 
 156   // Return the label
 157   virtual Label *label() const;
 158 
 159   // Return the method&#39;s address
 160   virtual intptr_t  method() const;
 161 
 162   // Hash and compare over operands are currently identical
 163   virtual uint  hash() const;
<span class="line-modified"> 164   virtual bool  cmp( const MachOper &amp;oper ) const;</span>
 165 
 166   // Virtual clone, since I do not know how big the MachOper is.
 167   virtual MachOper *clone() const = 0;
 168 
 169   // Return ideal Type from simple operands.  Fail for complex operands.
 170   virtual const Type *type() const;
 171 
 172   // Set an integer offset if we have one, or error otherwise
 173   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 174 
 175 #ifndef PRODUCT
 176   // Return name of operand
 177   virtual const char    *Name() const { return &quot;???&quot;;}
 178 
 179   // Methods to output the text version of the operand
 180   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 181   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 182 
 183   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 184 
 185   // Check whether o is a valid oper.
 186   static bool notAnOper(const MachOper *o) {
 187     if (o == NULL)                   return true;
 188     if (((intptr_t)o &amp; 1) != 0)      return true;
 189     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 190     return false;
 191   }
 192 #endif // !PRODUCT
 193 };
 194 
 195 //------------------------------MachNode---------------------------------------
 196 // Base type for all machine specific nodes.  All node classes generated by the
 197 // ADLC inherit from this class.
 198 class MachNode : public Node {
 199 public:
<span class="line-modified"> 200   MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {</span>
 201     init_class_id(Class_Mach);
 202   }
 203   // Required boilerplate
 204   virtual uint size_of() const { return sizeof(MachNode); }
 205   virtual int  Opcode() const;          // Always equal to MachNode
 206   virtual uint rule() const = 0;        // Machine-specific opcode
 207   // Number of inputs which come before the first operand.
 208   // Generally at least 1, to skip the Control input
 209   virtual uint oper_input_base() const { return 1; }
 210   // Position of constant base node in node&#39;s inputs. -1 if
 211   // no constant base node input.
 212   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 213 
<span class="line-added"> 214   uint8_t barrier_data() const { return _barrier; }</span>
<span class="line-added"> 215   void set_barrier_data(uint data) { _barrier = data; }</span>
<span class="line-added"> 216 </span>
 217   // Copy inputs and operands to new node of instruction.
 218   // Called from cisc_version() and short_branch_version().
 219   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 220   void fill_new_machnode(MachNode *n) const;
 221 
 222   // Return an equivalent instruction using memory for cisc_operand position
 223   virtual MachNode *cisc_version(int offset);
 224   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 225   virtual void use_cisc_RegMask();
 226 
 227   // Support for short branches
 228   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 229 
 230   // Avoid back to back some instructions on some CPUs.
 231   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 232                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 233                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 234                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 235 
 236   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 237     return (flags() &amp; flag_value) == flag_value;
 238   }
 239 
 240   // instruction implemented with a call
 241   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 242 
 243   // First index in _in[] corresponding to operand, or -1 if there is none
 244   int  operand_index(uint operand) const;
 245   int  operand_index(const MachOper *oper) const;
<span class="line-added"> 246   int  operand_index(Node* m) const;</span>
 247 
 248   // Register class input is expected in
 249   virtual const RegMask &amp;in_RegMask(uint) const;
 250 
 251   // cisc-spillable instructions redefine for use by in_RegMask
 252   virtual const RegMask *cisc_RegMask() const { return NULL; }
 253 
 254   // If this instruction is a 2-address instruction, then return the
 255   // index of the input which must match the output.  Not nessecary
 256   // for instructions which bind the input and output register to the
 257   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 258   // both an input and an output).  It is nessecary when the input and
 259   // output have choices - but they must use the same choice.
 260   virtual uint two_adr( ) const { return 0; }
 261 
<span class="line-added"> 262   // The GC might require some barrier metadata for machine code emission.</span>
<span class="line-added"> 263   uint8_t _barrier;</span>
<span class="line-added"> 264 </span>
 265   // Array of complex operand pointers.  Each corresponds to zero or
 266   // more leafs.  Must be set by MachNode constructor to point to an
 267   // internal array of MachOpers.  The MachOper array is sized by
 268   // specific MachNodes described in the ADL.
 269   uint _num_opnds;
 270   MachOper **_opnds;
 271   uint  num_opnds() const { return _num_opnds; }
 272 
 273   // Emit bytes into cbuf
 274   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 275   // Expand node after register allocation.
 276   // Node is replaced by several nodes in the postalloc expand phase.
 277   // Corresponding methods are generated for nodes if they specify
 278   // postalloc_expand. See block.cpp for more documentation.
 279   virtual bool requires_postalloc_expand() const { return false; }
 280   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 281   // Size of instruction in bytes
 282   virtual uint  size(PhaseRegAlloc *ra_) const;
 283   // Helper function that computes size by emitting code
 284   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 285 
 286   // Return the alignment required (in units of relocInfo::addr_unit())
 287   // for this instruction (must be a power of 2)
 288   virtual int   alignment_required() const { return 1; }
 289 
 290   // Return the padding (in bytes) to be emitted before this
 291   // instruction to properly align it.
 292   virtual int   compute_padding(int current_offset) const { return 0; }
 293 
 294   // Return number of relocatable values contained in this instruction
 295   virtual int   reloc() const { return 0; }
 296 
 297   // Return number of words used for double constants in this instruction
 298   virtual int   ins_num_consts() const { return 0; }
 299 
 300   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 301   virtual uint  hash() const;
<span class="line-modified"> 302   virtual bool  cmp( const Node &amp;n ) const;</span>
 303 
 304   // Expand method for MachNode, replaces nodes representing pseudo
 305   // instructions with a set of nodes which represent real machine
 306   // instructions and compute the same value.
 307   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 308 
 309   // Bottom_type call; value comes from operand0
 310   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
<span class="line-modified"> 311   virtual uint ideal_reg() const {</span>
<span class="line-added"> 312     const Type *t = _opnds[0]-&gt;type();</span>
<span class="line-added"> 313     if (t == TypeInt::CC) {</span>
<span class="line-added"> 314       return Op_RegFlags;</span>
<span class="line-added"> 315     } else {</span>
<span class="line-added"> 316       return t-&gt;ideal_reg();</span>
<span class="line-added"> 317     }</span>
<span class="line-added"> 318   }</span>
 319 
 320   // If this is a memory op, return the base pointer and fixed offset.
 321   // If there are no such, return NULL.  If there are multiple addresses
 322   // or the address is indeterminate (rare cases) then return (Node*)-1,
 323   // which serves as node bottom.
 324   // If the offset is not statically determined, set it to Type::OffsetBot.
 325   // This method is free to ignore stack slots if that helps.
 326   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 327   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 328   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 329 
 330   // Helper for get_base_and_disp: find the base and index input nodes.
 331   // Returns the MachOper as determined by memory_operand(), for use, if
 332   // needed by the caller. If (MachOper *)-1 is returned, base and index
 333   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 334   // index are set to NULL.
 335   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 336 
 337   // Helper for memory_inputs:  Which operand carries the necessary info?
 338   // By default, returns NULL, which means there is no such operand.
</pre>
<hr />
<pre>
 858   }
 859   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 860     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 861     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 862   }
 863   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 864     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 865     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 866   }
 867   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 868     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 869     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 870   }
 871 };
 872 
 873 //------------------------------MachCallNode----------------------------------
 874 // Machine-specific versions of subroutine calls
 875 class MachCallNode : public MachSafePointNode {
 876 protected:
 877   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
<span class="line-modified"> 878   virtual bool cmp( const Node &amp;n ) const;</span>
 879   virtual uint size_of() const = 0; // Size is bigger
 880 public:
 881   const TypeFunc *_tf;        // Function type
 882   address      _entry_point;  // Address of the method being called
 883   float        _cnt;          // Estimate of number of times called
 884   uint         _argsize;      // Size of argument block on stack
 885 
 886   const TypeFunc* tf()        const { return _tf; }
 887   const address entry_point() const { return _entry_point; }
 888   const float   cnt()         const { return _cnt; }
 889   uint argsize()              const { return _argsize; }
 890 
 891   void set_tf(const TypeFunc* tf) { _tf = tf; }
 892   void set_entry_point(address p) { _entry_point = p; }
 893   void set_cnt(float c)           { _cnt = c; }
 894   void set_argsize(int s)         { _argsize = s; }
 895 
 896   MachCallNode() : MachSafePointNode() {
 897     init_class_id(Class_MachCall);
 898   }
</pre>
<hr />
<pre>
 901   virtual bool  pinned() const { return false; }
 902   virtual const Type* Value(PhaseGVN* phase) const;
 903   virtual const RegMask &amp;in_RegMask(uint) const;
 904   virtual int ret_addr_offset() { return 0; }
 905 
 906   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 907   bool return_value_is_used() const;
 908 
 909   // Similar to cousin class CallNode::returns_pointer
 910   bool returns_pointer() const;
 911 
 912 #ifndef PRODUCT
 913   virtual void dump_spec(outputStream *st) const;
 914 #endif
 915 };
 916 
 917 //------------------------------MachCallJavaNode------------------------------
 918 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 919 class MachCallJavaNode : public MachCallNode {
 920 protected:
<span class="line-modified"> 921   virtual bool cmp( const Node &amp;n ) const;</span>
 922   virtual uint size_of() const; // Size is bigger
 923 public:
 924   ciMethod* _method;                 // Method being direct called
 925   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 926   int       _bci;                    // Byte Code index of call byte code
 927   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 928   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 929   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 930     init_class_id(Class_MachCallJava);
 931   }
 932 
 933   virtual const RegMask &amp;in_RegMask(uint) const;
 934 
 935   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 936     if (_override_symbolic_info) {
 937       // Attach corresponding Method* to the call site, so VM can use it during resolution
 938       // instead of querying symbolic info from bytecode.
 939       assert(_method != NULL, &quot;method should be set&quot;);
 940       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 941       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 942     }
 943     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 944   }
 945 
 946 #ifndef PRODUCT
 947   virtual void dump_spec(outputStream *st) const;
 948 #endif
 949 };
 950 
 951 //------------------------------MachCallStaticJavaNode------------------------
 952 // Machine-specific versions of monomorphic subroutine calls
 953 class MachCallStaticJavaNode : public MachCallJavaNode {
<span class="line-modified"> 954   virtual bool cmp( const Node &amp;n ) const;</span>
 955   virtual uint size_of() const; // Size is bigger
 956 public:
 957   const char *_name;            // Runtime wrapper name
 958   MachCallStaticJavaNode() : MachCallJavaNode() {
 959     init_class_id(Class_MachCallStaticJava);
 960   }
 961 
 962   // If this is an uncommon trap, return the request code, else zero.
 963   int uncommon_trap_request() const;
 964 
 965   virtual int ret_addr_offset();
 966 #ifndef PRODUCT
 967   virtual void dump_spec(outputStream *st) const;
 968   void dump_trap_args(outputStream *st) const;
 969 #endif
 970 };
 971 
 972 //------------------------------MachCallDynamicJavaNode------------------------
 973 // Machine-specific versions of possibly megamorphic subroutine calls
 974 class MachCallDynamicJavaNode : public MachCallJavaNode {
 975 public:
 976   int _vtable_index;
 977   MachCallDynamicJavaNode() : MachCallJavaNode() {
 978     init_class_id(Class_MachCallDynamicJava);
 979     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
 980   }
 981   virtual int ret_addr_offset();
 982 #ifndef PRODUCT
 983   virtual void dump_spec(outputStream *st) const;
 984 #endif
 985 };
 986 
 987 //------------------------------MachCallRuntimeNode----------------------------
 988 // Machine-specific versions of subroutine calls
 989 class MachCallRuntimeNode : public MachCallNode {
<span class="line-modified"> 990   virtual bool cmp( const Node &amp;n ) const;</span>
 991   virtual uint size_of() const; // Size is bigger
 992 public:
 993   const char *_name;            // Printable name, if _method is NULL
 994   MachCallRuntimeNode() : MachCallNode() {
 995     init_class_id(Class_MachCallRuntime);
 996   }
 997   virtual int ret_addr_offset();
 998 #ifndef PRODUCT
 999   virtual void dump_spec(outputStream *st) const;
1000 #endif
1001 };
1002 
1003 class MachCallLeafNode: public MachCallRuntimeNode {
1004 public:
1005   MachCallLeafNode() : MachCallRuntimeNode() {
1006     init_class_id(Class_MachCallLeaf);
1007   }
1008 };
1009 
1010 //------------------------------MachHaltNode-----------------------------------
1011 // Machine-specific versions of halt nodes
1012 class MachHaltNode : public MachReturnNode {
1013 public:
<span class="line-added">1014   const char* _halt_reason;</span>
1015   virtual JVMState* jvms() const;
1016 };
1017 
1018 class MachMemBarNode : public MachNode {
1019   virtual uint size_of() const; // Size is bigger
1020 public:
1021   const TypePtr* _adr_type;     // memory effects
1022   MachMemBarNode() : MachNode() {
1023     init_class_id(Class_MachMemBar);
1024     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1025   }
1026 
1027   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1028   virtual const TypePtr *adr_type() const;
1029 };
1030 
1031 
1032 //------------------------------MachTempNode-----------------------------------
1033 // Node used by the adlc to construct inputs to represent temporary registers
1034 class MachTempNode : public MachNode {
</pre>
<hr />
<pre>
1064   virtual uint           num_edges() const { return 0; }
1065 public:
1066   // Supported for fixed size branches
1067   Label* _label;                // Label for branch(es)
1068 
1069   uint _block_num;
1070 
1071   labelOper() : _label(0), _block_num(0) {}
1072 
1073   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1074 
1075   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1076 
1077   virtual MachOper *clone() const;
1078 
1079   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1080 
1081   virtual uint           opcode() const;
1082 
1083   virtual uint           hash()   const;
<span class="line-modified">1084   virtual bool           cmp( const MachOper &amp;oper ) const;</span>
1085 #ifndef PRODUCT
1086   virtual const char    *Name()   const { return &quot;Label&quot;;}
1087 
1088   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1089   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1090 #endif
1091 };
1092 
1093 
1094 //------------------------------methodOper--------------------------------------
1095 // Machine-independent version of method operand
1096 class methodOper : public MachOper {
1097 private:
1098   virtual uint           num_edges() const { return 0; }
1099 public:
1100   intptr_t _method;             // Address of method
1101   methodOper() :   _method(0) {}
1102   methodOper(intptr_t method) : _method(method)  {}
1103 
1104   virtual MachOper *clone() const;
1105 
1106   virtual intptr_t method() const { return _method; }
1107 
1108   virtual uint           opcode() const;
1109 
1110   virtual uint           hash()   const;
<span class="line-modified">1111   virtual bool           cmp( const MachOper &amp;oper ) const;</span>
1112 #ifndef PRODUCT
1113   virtual const char    *Name()   const { return &quot;Method&quot;;}
1114 
1115   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1116   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1117 #endif
1118 };
1119 
1120 #endif // SHARE_OPTO_MACHNODE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="machnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
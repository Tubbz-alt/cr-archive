<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/split_if.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="runtime.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringopts.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/split_if.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93     // the CMove block.  If the CMove is in the split-if block, then in the
 94     // next iteration this will become a simple Cmp/Bool/CMove set to clone-up.
 95     Node *bol, *cmov;
 96     if( !(n-&gt;outcnt() == 1 &amp;&amp; n-&gt;unique_out()-&gt;is_Bool() &amp;&amp;
 97           (bol = n-&gt;unique_out()-&gt;as_Bool()) &amp;&amp;
 98           (get_ctrl(bol) == blk1 ||
 99            get_ctrl(bol) == blk2) &amp;&amp;
100           bol-&gt;outcnt() == 1 &amp;&amp;
101           bol-&gt;unique_out()-&gt;is_CMove() &amp;&amp;
102           (cmov = bol-&gt;unique_out()-&gt;as_CMove()) &amp;&amp;
103           (get_ctrl(cmov) == blk1 ||
104            get_ctrl(cmov) == blk2) ) ) {
105 
106       // Must clone down
107 #ifndef PRODUCT
108       if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {
109         tty-&gt;print(&quot;Cloning down: &quot;);
110         n-&gt;dump();
111       }
112 #endif
<span class="line-modified">113       // Clone down any block-local BoolNode uses of this CmpNode</span>
<span class="line-modified">114       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-modified">115         Node* bol = n-&gt;out(i);</span>
<span class="line-modified">116         assert( bol-&gt;is_Bool(), &quot;&quot; );</span>
<span class="line-modified">117         if (bol-&gt;outcnt() == 1) {</span>
<span class="line-modified">118           Node* use = bol-&gt;unique_out();</span>
<span class="line-modified">119           if (use-&gt;Opcode() == Op_Opaque4) {</span>
<span class="line-modified">120             if (use-&gt;outcnt() == 1) {</span>
<span class="line-modified">121               Node* iff = use-&gt;unique_out();</span>
<span class="line-modified">122               assert(iff-&gt;is_If(), &quot;unexpected node type&quot;);</span>
<span class="line-modified">123               Node *use_c = iff-&gt;in(0);</span>









124               if (use_c == blk1 || use_c == blk2) {

125                 continue;
126               }
127             }
<span class="line-removed">128           } else {</span>
<span class="line-removed">129             // We might see an Opaque1 from a loop limit check here</span>
<span class="line-removed">130             assert(use-&gt;is_If() || use-&gt;is_CMove() || use-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);</span>
<span class="line-removed">131             Node *use_c = use-&gt;is_If() ? use-&gt;in(0) : get_ctrl(use);</span>
<span class="line-removed">132             if (use_c == blk1 || use_c == blk2) {</span>
<span class="line-removed">133               assert(use-&gt;is_CMove(), &quot;unexpected node type&quot;);</span>
<span class="line-removed">134               continue;</span>
<span class="line-removed">135             }</span>
136           }
<span class="line-modified">137         }</span>
<span class="line-modified">138         if (get_ctrl(bol) == blk1 || get_ctrl(bol) == blk2) {</span>
<span class="line-removed">139           // Recursively sink any BoolNode</span>
140 #ifndef PRODUCT
<span class="line-modified">141           if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {</span>
<span class="line-modified">142             tty-&gt;print(&quot;Cloning down: &quot;);</span>
<span class="line-modified">143             bol-&gt;dump();</span>
<span class="line-modified">144           }</span>
145 #endif
<span class="line-modified">146           for (DUIterator j = bol-&gt;outs(); bol-&gt;has_out(j); j++) {</span>
<span class="line-modified">147             Node* u = bol-&gt;out(j);</span>
<span class="line-modified">148             // Uses are either IfNodes, CMoves or Opaque4</span>
<span class="line-modified">149             if (u-&gt;Opcode() == Op_Opaque4) {</span>
<span class="line-modified">150               assert(u-&gt;in(1) == bol, &quot;bad input&quot;);</span>
<span class="line-modified">151               for (DUIterator_Last kmin, k = u-&gt;last_outs(kmin); k &gt;= kmin; --k) {</span>
<span class="line-modified">152                 Node* iff = u-&gt;last_out(k);</span>
<span class="line-modified">153                 assert(iff-&gt;is_If() || iff-&gt;is_CMove(), &quot;unexpected node type&quot;);</span>
<span class="line-modified">154                 assert( iff-&gt;in(1) == u, &quot;&quot; );</span>















155                 // Get control block of either the CMove or the If input
<span class="line-modified">156                 Node *iff_ctrl = iff-&gt;is_If() ? iff-&gt;in(0) : get_ctrl(iff);</span>
<span class="line-modified">157                 Node *x1 = bol-&gt;clone();</span>
<span class="line-modified">158                 Node *x2 = u-&gt;clone();</span>
<span class="line-modified">159                 register_new_node(x1, iff_ctrl);</span>
<span class="line-modified">160                 register_new_node(x2, iff_ctrl);</span>
<span class="line-modified">161                 _igvn.replace_input_of(x2, 1, x1);</span>
<span class="line-removed">162                 _igvn.replace_input_of(iff, 1, x2);</span>
163               }
<span class="line-removed">164               _igvn.remove_dead_node(u);</span>
<span class="line-removed">165               --j;</span>
<span class="line-removed">166             } else {</span>
<span class="line-removed">167               // We might see an Opaque1 from a loop limit check here</span>
<span class="line-removed">168               assert(u-&gt;is_If() || u-&gt;is_CMove() || u-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);</span>
<span class="line-removed">169               assert(u-&gt;in(1) == bol, &quot;&quot;);</span>
<span class="line-removed">170               // Get control block of either the CMove or the If input</span>
<span class="line-removed">171               Node *u_ctrl = u-&gt;is_If() ? u-&gt;in(0) : get_ctrl(u);</span>
<span class="line-removed">172               assert((u_ctrl != blk1 &amp;&amp; u_ctrl != blk2) || u-&gt;is_CMove(), &quot;won&#39;t converge&quot;);</span>
<span class="line-removed">173               Node *x = bol-&gt;clone();</span>
<span class="line-removed">174               register_new_node(x, u_ctrl);</span>
<span class="line-removed">175               _igvn.replace_input_of(u, 1, x);</span>
<span class="line-removed">176               --j;</span>
177             }


178           }
<span class="line-removed">179           _igvn.remove_dead_node(bol);</span>
<span class="line-removed">180           --i;</span>
181         }
182       }
183       // Clone down this CmpNode
184       for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; --j) {
<span class="line-modified">185         Node* bol = n-&gt;last_out(j);</span>
<span class="line-modified">186         assert( bol-&gt;in(1) == n, &quot;&quot; );</span>





187         Node *x = n-&gt;clone();
<span class="line-modified">188         register_new_node(x, get_ctrl(bol));</span>
<span class="line-modified">189         _igvn.replace_input_of(bol, 1, x);</span>
190       }
191       _igvn.remove_dead_node( n );
192 
193       return true;
194     }
195   }
196 
197   // See if splitting-up a Store.  Any anti-dep loads must go up as
198   // well.  An anti-dep load might be in the wrong block, because in
199   // this particular layout/schedule we ignored anti-deps and allow
200   // memory to be alive twice.  This only works if we do the same
201   // operations on anti-dep loads as we do their killing stores.
202   if( n-&gt;is_Store() &amp;&amp; n-&gt;in(MemNode::Memory)-&gt;in(0) == n-&gt;in(0) ) {
203     // Get store&#39;s memory slice
204     int alias_idx = C-&gt;get_alias_index(_igvn.type(n-&gt;in(MemNode::Address))-&gt;is_ptr());
205 
206     // Get memory-phi anti-dep loads will be using
207     Node *memphi = n-&gt;in(MemNode::Memory);
208     assert( memphi-&gt;is_Phi(), &quot;&quot; );
209     // Hoist any anti-dep load to the splitting block;
</pre>
</td>
<td>
<hr />
<pre>
 93     // the CMove block.  If the CMove is in the split-if block, then in the
 94     // next iteration this will become a simple Cmp/Bool/CMove set to clone-up.
 95     Node *bol, *cmov;
 96     if( !(n-&gt;outcnt() == 1 &amp;&amp; n-&gt;unique_out()-&gt;is_Bool() &amp;&amp;
 97           (bol = n-&gt;unique_out()-&gt;as_Bool()) &amp;&amp;
 98           (get_ctrl(bol) == blk1 ||
 99            get_ctrl(bol) == blk2) &amp;&amp;
100           bol-&gt;outcnt() == 1 &amp;&amp;
101           bol-&gt;unique_out()-&gt;is_CMove() &amp;&amp;
102           (cmov = bol-&gt;unique_out()-&gt;as_CMove()) &amp;&amp;
103           (get_ctrl(cmov) == blk1 ||
104            get_ctrl(cmov) == blk2) ) ) {
105 
106       // Must clone down
107 #ifndef PRODUCT
108       if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {
109         tty-&gt;print(&quot;Cloning down: &quot;);
110         n-&gt;dump();
111       }
112 #endif
<span class="line-modified">113       if (!n-&gt;is_FastLock()) {</span>
<span class="line-modified">114         // Clone down any block-local BoolNode uses of this CmpNode</span>
<span class="line-modified">115         for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-modified">116           Node* bol = n-&gt;out(i);</span>
<span class="line-modified">117           assert( bol-&gt;is_Bool(), &quot;&quot; );</span>
<span class="line-modified">118           if (bol-&gt;outcnt() == 1) {</span>
<span class="line-modified">119             Node* use = bol-&gt;unique_out();</span>
<span class="line-modified">120             if (use-&gt;Opcode() == Op_Opaque4) {</span>
<span class="line-modified">121               if (use-&gt;outcnt() == 1) {</span>
<span class="line-modified">122                 Node* iff = use-&gt;unique_out();</span>
<span class="line-modified">123                 assert(iff-&gt;is_If(), &quot;unexpected node type&quot;);</span>
<span class="line-added">124                 Node *use_c = iff-&gt;in(0);</span>
<span class="line-added">125                 if (use_c == blk1 || use_c == blk2) {</span>
<span class="line-added">126                   continue;</span>
<span class="line-added">127                 }</span>
<span class="line-added">128               }</span>
<span class="line-added">129             } else {</span>
<span class="line-added">130               // We might see an Opaque1 from a loop limit check here</span>
<span class="line-added">131               assert(use-&gt;is_If() || use-&gt;is_CMove() || use-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);</span>
<span class="line-added">132               Node *use_c = use-&gt;is_If() ? use-&gt;in(0) : get_ctrl(use);</span>
133               if (use_c == blk1 || use_c == blk2) {
<span class="line-added">134                 assert(use-&gt;is_CMove(), &quot;unexpected node type&quot;);</span>
135                 continue;
136               }
137             }








138           }
<span class="line-modified">139           if (get_ctrl(bol) == blk1 || get_ctrl(bol) == blk2) {</span>
<span class="line-modified">140             // Recursively sink any BoolNode</span>

141 #ifndef PRODUCT
<span class="line-modified">142             if( PrintOpto &amp;&amp; VerifyLoopOptimizations ) {</span>
<span class="line-modified">143               tty-&gt;print(&quot;Cloning down: &quot;);</span>
<span class="line-modified">144               bol-&gt;dump();</span>
<span class="line-modified">145             }</span>
146 #endif
<span class="line-modified">147             for (DUIterator j = bol-&gt;outs(); bol-&gt;has_out(j); j++) {</span>
<span class="line-modified">148               Node* u = bol-&gt;out(j);</span>
<span class="line-modified">149               // Uses are either IfNodes, CMoves or Opaque4</span>
<span class="line-modified">150               if (u-&gt;Opcode() == Op_Opaque4) {</span>
<span class="line-modified">151                 assert(u-&gt;in(1) == bol, &quot;bad input&quot;);</span>
<span class="line-modified">152                 for (DUIterator_Last kmin, k = u-&gt;last_outs(kmin); k &gt;= kmin; --k) {</span>
<span class="line-modified">153                   Node* iff = u-&gt;last_out(k);</span>
<span class="line-modified">154                   assert(iff-&gt;is_If() || iff-&gt;is_CMove(), &quot;unexpected node type&quot;);</span>
<span class="line-modified">155                   assert( iff-&gt;in(1) == u, &quot;&quot; );</span>
<span class="line-added">156                   // Get control block of either the CMove or the If input</span>
<span class="line-added">157                   Node *iff_ctrl = iff-&gt;is_If() ? iff-&gt;in(0) : get_ctrl(iff);</span>
<span class="line-added">158                   Node *x1 = bol-&gt;clone();</span>
<span class="line-added">159                   Node *x2 = u-&gt;clone();</span>
<span class="line-added">160                   register_new_node(x1, iff_ctrl);</span>
<span class="line-added">161                   register_new_node(x2, iff_ctrl);</span>
<span class="line-added">162                   _igvn.replace_input_of(x2, 1, x1);</span>
<span class="line-added">163                   _igvn.replace_input_of(iff, 1, x2);</span>
<span class="line-added">164                 }</span>
<span class="line-added">165                 _igvn.remove_dead_node(u);</span>
<span class="line-added">166                 --j;</span>
<span class="line-added">167               } else {</span>
<span class="line-added">168                 // We might see an Opaque1 from a loop limit check here</span>
<span class="line-added">169                 assert(u-&gt;is_If() || u-&gt;is_CMove() || u-&gt;Opcode() == Op_Opaque1, &quot;unexpected node type&quot;);</span>
<span class="line-added">170                 assert(u-&gt;in(1) == bol, &quot;&quot;);</span>
171                 // Get control block of either the CMove or the If input
<span class="line-modified">172                 Node *u_ctrl = u-&gt;is_If() ? u-&gt;in(0) : get_ctrl(u);</span>
<span class="line-modified">173                 assert((u_ctrl != blk1 &amp;&amp; u_ctrl != blk2) || u-&gt;is_CMove(), &quot;won&#39;t converge&quot;);</span>
<span class="line-modified">174                 Node *x = bol-&gt;clone();</span>
<span class="line-modified">175                 register_new_node(x, u_ctrl);</span>
<span class="line-modified">176                 _igvn.replace_input_of(u, 1, x);</span>
<span class="line-modified">177                 --j;</span>

178               }













179             }
<span class="line-added">180             _igvn.remove_dead_node(bol);</span>
<span class="line-added">181             --i;</span>
182           }


183         }
184       }
185       // Clone down this CmpNode
186       for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; --j) {
<span class="line-modified">187         Node* use = n-&gt;last_out(j);</span>
<span class="line-modified">188         uint pos = 1;</span>
<span class="line-added">189         if (n-&gt;is_FastLock()) {</span>
<span class="line-added">190           pos = TypeFunc::Parms + 2;</span>
<span class="line-added">191           assert(use-&gt;is_Lock(), &quot;FastLock only used by LockNode&quot;);</span>
<span class="line-added">192         }</span>
<span class="line-added">193         assert(use-&gt;in(pos) == n, &quot;&quot; );</span>
194         Node *x = n-&gt;clone();
<span class="line-modified">195         register_new_node(x, ctrl_or_self(use));</span>
<span class="line-modified">196         _igvn.replace_input_of(use, pos, x);</span>
197       }
198       _igvn.remove_dead_node( n );
199 
200       return true;
201     }
202   }
203 
204   // See if splitting-up a Store.  Any anti-dep loads must go up as
205   // well.  An anti-dep load might be in the wrong block, because in
206   // this particular layout/schedule we ignored anti-deps and allow
207   // memory to be alive twice.  This only works if we do the same
208   // operations on anti-dep loads as we do their killing stores.
209   if( n-&gt;is_Store() &amp;&amp; n-&gt;in(MemNode::Memory)-&gt;in(0) == n-&gt;in(0) ) {
210     // Get store&#39;s memory slice
211     int alias_idx = C-&gt;get_alias_index(_igvn.type(n-&gt;in(MemNode::Address))-&gt;is_ptr());
212 
213     // Get memory-phi anti-dep loads will be using
214     Node *memphi = n-&gt;in(MemNode::Memory);
215     assert( memphi-&gt;is_Phi(), &quot;&quot; );
216     // Hoist any anti-dep load to the splitting block;
</pre>
</td>
</tr>
</table>
<center><a href="runtime.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stringopts.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -182,13 +182,11 @@</span>
  public:
  
    inline void* operator new( size_t x ) throw() {
      Compile* compile = Compile::current();
      compile-&gt;set_type_last_size(x);
<span class="udiff-line-modified-removed">-     void *temp = compile-&gt;type_arena()-&gt;Amalloc_D(x);</span>
<span class="udiff-line-removed">-     compile-&gt;set_type_hwm(temp);</span>
<span class="udiff-line-removed">-     return temp;</span>
<span class="udiff-line-modified-added">+     return compile-&gt;type_arena()-&gt;Amalloc_D(x);</span>
    }
    inline void operator delete( void* ptr ) {
      Compile* compile = Compile::current();
      compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,10 +288,11 @@</span>
    const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
    const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
    const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
    const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
    const TypeAry    *is_ary() const;              // Array, NOT array pointer
<span class="udiff-line-added">+   const TypeAry    *isa_ary() const;             // Returns NULL of not ary</span>
    const TypeVect   *is_vect() const;             // Vector
    const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
    const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
    const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
    const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -454,11 +453,10 @@</span>
  
    virtual bool maybe_null() const { return true; }
  
  private:
    // support arrays
<span class="udiff-line-removed">-   static const BasicType _basic_type[];</span>
    static const Type*        _zero_type[T_CONFLICT+1];
    static const Type* _const_basic_type[T_CONFLICT+1];
  };
  
  //------------------------------TypeF------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1030,12 +1028,10 @@</span>
  
    virtual const Type *cast_to_exactness(bool klass_is_exact) const;
  
    virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
  
<span class="udiff-line-removed">-   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="udiff-line-removed">- </span>
    // corresponding pointer to klass, for a given instance
    const TypeKlassPtr* as_klass_type() const;
  
    virtual const TypePtr *add_offset( intptr_t offset ) const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1116,12 +1112,10 @@</span>
  
    virtual const Type *cast_to_exactness(bool klass_is_exact) const;
  
    virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
  
<span class="udiff-line-removed">-   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="udiff-line-removed">- </span>
    virtual const TypePtr *add_offset( intptr_t offset ) const;
  
    // Speculative type helper methods.
    virtual const Type* remove_speculative() const;
    virtual const TypePtr* with_inline_depth(int depth) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1202,12 +1196,10 @@</span>
  
    virtual const Type *cast_to_exactness(bool klass_is_exact) const;
  
    virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
  
<span class="udiff-line-removed">-   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="udiff-line-removed">- </span>
    virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
    virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
  
    virtual bool empty(void) const;        // TRUE if type is vacuous
    virtual const TypePtr *add_offset( intptr_t offset ) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1224,10 +1216,12 @@</span>
    const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
    int stable_dimension() const;
  
    const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
  
<span class="udiff-line-added">+   static jint max_array_length(BasicType etype) ;</span>
<span class="udiff-line-added">+ </span>
    // Convenience common pre-built types.
    static const TypeAryPtr *RANGE;
    static const TypeAryPtr *OOPS;
    static const TypeAryPtr *NARROWOOPS;
    static const TypeAryPtr *BYTES;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1615,10 +1609,14 @@</span>
  inline const TypeAry *Type::is_ary() const {
    assert( _base == Array , &quot;Not an Array&quot; );
    return (TypeAry*)this;
  }
  
<span class="udiff-line-added">+ inline const TypeAry *Type::isa_ary() const {</span>
<span class="udiff-line-added">+   return ((_base == Array) ? (TypeAry*)this : NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline const TypeVect *Type::is_vect() const {
    assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
    return (TypeVect*)this;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1791,10 +1789,11 @@</span>
  #define Op_AndX      Op_AndL
  #define Op_AddX      Op_AddL
  #define Op_SubX      Op_SubL
  #define Op_XorX      Op_XorL
  #define Op_URShiftX  Op_URShiftL
<span class="udiff-line-added">+ #define Op_LoadX     Op_LoadL</span>
  // conversions
  #define ConvI2X(x)   ConvI2L(x)
  #define ConvL2X(x)   (x)
  #define ConvX2I(x)   ConvL2I(x)
  #define ConvX2L(x)   (x)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1838,10 +1837,11 @@</span>
  #define Op_AndX      Op_AndI
  #define Op_AddX      Op_AddI
  #define Op_SubX      Op_SubI
  #define Op_XorX      Op_XorI
  #define Op_URShiftX  Op_URShiftI
<span class="udiff-line-added">+ #define Op_LoadX     Op_LoadI</span>
  // conversions
  #define ConvI2X(x)   (x)
  #define ConvL2X(x)   ConvL2I(x)
  #define ConvX2I(x)   (x)
  #define ConvX2L(x)   ConvI2L(x)
</pre>
<center><a href="type.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
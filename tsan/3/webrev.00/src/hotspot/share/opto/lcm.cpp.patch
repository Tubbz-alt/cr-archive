diff a/src/hotspot/share/opto/lcm.cpp b/src/hotspot/share/opto/lcm.cpp
--- a/src/hotspot/share/opto/lcm.cpp
+++ b/src/hotspot/share/opto/lcm.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,10 +23,11 @@
  */
 
 #include "precompiled.hpp"
 #include "asm/macroAssembler.inline.hpp"
 #include "memory/allocation.inline.hpp"
+#include "oops/compressedOops.hpp"
 #include "opto/ad.hpp"
 #include "opto/block.hpp"
 #include "opto/c2compiler.hpp"
 #include "opto/callnode.hpp"
 #include "opto/cfgnode.hpp"
@@ -38,11 +39,11 @@
 // Optimization - Graph Style
 
 // Check whether val is not-null-decoded compressed oop,
 // i.e. will grab into the base of the heap if it represents NULL.
 static bool accesses_heap_base_zone(Node *val) {
-  if (Universe::narrow_oop_base() != NULL) { // Implies UseCompressedOops.
+  if (CompressedOops::base() != NULL) { // Implies UseCompressedOops.
     if (val && val->is_Mach()) {
       if (val->as_Mach()->ideal_Opcode() == Op_DecodeN) {
         // This assumes all Decodes with TypePtr::NotNull are matched to nodes that
         // decode NULL to point to the heap base (Decode_NN).
         if (val->bottom_type()->is_oopptr()->ptr() == TypePtr::NotNull) {
@@ -64,12 +65,12 @@
   // If so, only Store operations will trap.
   if (os::zero_page_read_protected()) {
     return false;  // Implicit null check will work.
   }
   // Also a read accessing the base of a heap-based compressed heap will trap.
-  if (accesses_heap_base_zone(val) &&                    // Hits the base zone page.
-      Universe::narrow_oop_use_implicit_null_checks()) { // Base zone page is protected.
+  if (accesses_heap_base_zone(val) &&         // Hits the base zone page.
+      CompressedOops::use_implicit_null_checks()) { // Base zone page is protected.
     return false;
   }
 
   return true;
 }
@@ -167,20 +168,17 @@
     case Op_LoadD:
     case Op_LoadF:
     case Op_LoadI:
     case Op_LoadL:
     case Op_LoadP:
-    case Op_LoadBarrierSlowReg:
-    case Op_LoadBarrierWeakSlowReg:
     case Op_LoadN:
     case Op_LoadS:
     case Op_LoadKlass:
     case Op_LoadNKlass:
     case Op_LoadRange:
     case Op_LoadD_unaligned:
     case Op_LoadL_unaligned:
-    case Op_ShenandoahReadBarrier:
       assert(mach->in(2) == val, "should be address");
       break;
     case Op_StoreB:
     case Op_StoreC:
     case Op_StoreCM:
@@ -260,17 +258,17 @@
       if (base == NULL || base == NodeSentinel) {
         // Narrow oop address doesn't have base, only index.
         // Give up if offset is beyond page size or if heap base is not protected.
         if (val->bottom_type()->isa_narrowoop() &&
             (MacroAssembler::needs_explicit_null_check(offset) ||
-             !Universe::narrow_oop_use_implicit_null_checks()))
+             !CompressedOops::use_implicit_null_checks()))
           continue;
         // cannot reason about it; is probably not implicit null exception
       } else {
         const TypePtr* tptr;
-        if (UseCompressedOops && (Universe::narrow_oop_shift() == 0 ||
-                                  Universe::narrow_klass_shift() == 0)) {
+        if (UseCompressedOops && (CompressedOops::shift() == 0 ||
+                                  CompressedKlassPointers::shift() == 0)) {
           // 32-bits narrow oop can be the base of address expressions
           tptr = base->get_ptr_type();
         } else {
           // only regular oops are expected here
           tptr = base->bottom_type()->is_ptr();
@@ -282,11 +280,11 @@
         // Give up if reference is beyond page size.
         if (MacroAssembler::needs_explicit_null_check(offset))
           continue;
         // Give up if base is a decode node and the heap base is not protected.
         if (base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_DecodeN &&
-            !Universe::narrow_oop_use_implicit_null_checks())
+            !CompressedOops::use_implicit_null_checks())
           continue;
       }
     }
 
     // Check ctrl input to see if the null-check dominates the memory op
@@ -958,11 +956,11 @@
           local++;              // One more block-local input
       }
       ready_cnt.at_put(n->_idx, local); // Count em up
 
 #ifdef ASSERT
-      if( UseConcMarkSweepGC || UseG1GC ) {
+      if (UseG1GC) {
         if( n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_StoreCM ) {
           // Check the precedence edges
           for (uint prec = n->req(); prec < n->len(); prec++) {
             Node* oop_store = n->in(prec);
             if (oop_store != NULL) {

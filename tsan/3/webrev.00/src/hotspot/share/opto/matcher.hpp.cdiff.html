<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/matcher.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="matcher.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 123,10 ***</span>
<span class="line-new-header">--- 123,12 ---</span>
  
  #ifdef X86
    bool is_bmi_pattern(Node *n, Node *m);
  #endif
  
<span class="line-added">+   bool is_vshift_con_pattern(Node *n, Node *m);</span>
<span class="line-added">+ </span>
    // Debug and profile information for nodes in old space:
    GrowableArray&lt;Node_Notes*&gt;* _old_node_note_array;
  
    // Node labeling iterator for instruction selection
    Node *Label_Root( const Node *n, State *svec, Node *control, const Node *mem );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,11 ***</span>
    // should generate this one.
    static const bool match_rule_supported(int opcode);
  
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
<span class="line-modified">!   static const bool match_rule_supported_vector(int opcode, int vlen);</span>
  
    // Some microarchitectures have mask registers used on vectors
    static const bool has_predicated_vectors(void);
  
    // Some uarchs have different sized float register resources
<span class="line-new-header">--- 313,11 ---</span>
    // should generate this one.
    static const bool match_rule_supported(int opcode);
  
    // identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
<span class="line-modified">!   static const bool match_rule_supported_vector(int opcode, int vlen, BasicType bt);</span>
  
    // Some microarchitectures have mask registers used on vectors
    static const bool has_predicated_vectors(void);
  
    // Some uarchs have different sized float register resources
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,22 ***</span>
    //
    // decode narrow_oop_reg, oop_reg // only &#39;shift&#39;
    // [oop_reg + offset]
    // NullCheck oop_reg
    //
<span class="line-modified">!   inline static bool gen_narrow_oop_implicit_null_checks() {</span>
<span class="line-removed">-     // Advice matcher to perform null checks on the narrow oop side.</span>
<span class="line-removed">-     // Implicit checks are not possible on the uncompressed oop side anyway</span>
<span class="line-removed">-     // (at least not for read accesses).</span>
<span class="line-removed">-     // Performs significantly better (especially on Power 6).</span>
<span class="line-removed">-     if (!os::zero_page_read_protected()) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return Universe::narrow_oop_use_implicit_null_checks() &amp;&amp;</span>
<span class="line-removed">-            (narrow_oop_use_complex_address() ||</span>
<span class="line-removed">-             Universe::narrow_oop_base() != NULL);</span>
<span class="line-removed">-   }</span>
  
    // Is it better to copy float constants, or load them directly from memory?
    // Intel can load a float constant from a direct address, requiring no
    // extra registers.  Most RISCs will have to materialize an address into a
    // register first, so they may as well materialize the constant immediately.
<span class="line-new-header">--- 487,11 ---</span>
    //
    // decode narrow_oop_reg, oop_reg // only &#39;shift&#39;
    // [oop_reg + offset]
    // NullCheck oop_reg
    //
<span class="line-modified">!   static bool gen_narrow_oop_implicit_null_checks();</span>
  
    // Is it better to copy float constants, or load them directly from memory?
    // Intel can load a float constant from a direct address, requiring no
    // extra registers.  Most RISCs will have to materialize an address into a
    // register first, so they may as well materialize the constant immediately.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,16 ***</span>
  
    // Does the CPU require postalloc expand (see block.cpp for description of
    // postalloc expand)?
    static const bool require_postalloc_expand;
  
    // Perform a platform dependent implicit null fixup.  This is needed
    // on windows95 to take care of some unusual register constraints.
    void pd_implicit_null_fixup(MachNode *load, uint idx);
  
<span class="line-modified">!   // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">-   // to implement the UseStrictFP mode.</span>
    static const bool strict_fp_requires_explicit_rounding;
  
    // Are floats conerted to double when stored to stack during deoptimization?
    static bool float_in_double();
    // Do ints take an entire long register or just half?
<span class="line-new-header">--- 506,39 ---</span>
  
    // Does the CPU require postalloc expand (see block.cpp for description of
    // postalloc expand)?
    static const bool require_postalloc_expand;
  
<span class="line-added">+   // Does the platform support generic vector operands?</span>
<span class="line-added">+   // Requires cleanup after selection phase.</span>
<span class="line-added">+   static const bool supports_generic_vector_operands;</span>
<span class="line-added">+ </span>
<span class="line-added">+  private:</span>
<span class="line-added">+   void do_postselect_cleanup();</span>
<span class="line-added">+ </span>
<span class="line-added">+   void specialize_generic_vector_operands();</span>
<span class="line-added">+   void specialize_mach_node(MachNode* m);</span>
<span class="line-added">+   void specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx);</span>
<span class="line-added">+   MachOper* specialize_vector_operand(MachNode* m, uint opnd_idx);</span>
<span class="line-added">+   MachOper* specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt);</span>
<span class="line-added">+ </span>
<span class="line-added">+   static MachOper* specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp);</span>
<span class="line-added">+ </span>
<span class="line-added">+   static bool is_generic_reg2reg_move(MachNode* m);</span>
<span class="line-added">+   static bool is_generic_vector(MachOper* opnd);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const RegMask* regmask_for_ideal_register(uint ideal_reg, Node* ret);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Graph verification code</span>
<span class="line-added">+   DEBUG_ONLY( bool verify_after_postselect_cleanup(); )</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
    // Perform a platform dependent implicit null fixup.  This is needed
    // on windows95 to take care of some unusual register constraints.
    void pd_implicit_null_fixup(MachNode *load, uint idx);
  
<span class="line-modified">!   // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
    static const bool strict_fp_requires_explicit_rounding;
  
    // Are floats conerted to double when stored to stack during deoptimization?
    static bool float_in_double();
    // Do ints take an entire long register or just half?
</pre>
<center><a href="matcher.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
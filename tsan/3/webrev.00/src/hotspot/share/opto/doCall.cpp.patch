diff a/src/hotspot/share/opto/doCall.cpp b/src/hotspot/share/opto/doCall.cpp
--- a/src/hotspot/share/opto/doCall.cpp
+++ b/src/hotspot/share/opto/doCall.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -148,12 +148,13 @@
     CallGenerator* cg = CallGenerator::for_method_handle_call(jvms, caller, callee, delayed_forbidden);
     assert(cg == NULL || !delayed_forbidden || !cg->is_late_inline() || cg->is_mh_late_inline(), "unexpected CallGenerator");
     return cg;
   }
 
-  // Do not inline strict fp into non-strict code, or the reverse
-  if (caller->is_strict() ^ callee->is_strict()) {
+  // If explicit rounding is required, do not inline strict into non-strict code (or the reverse).
+  if (Matcher::strict_fp_requires_explicit_rounding &&
+      caller->is_strict() != callee->is_strict()) {
     allow_inline = false;
   }
 
   // Attempt to inline...
   if (allow_inline) {
@@ -308,14 +309,16 @@
     // it's 0 then no class implements decl_interface and there's
     // no point in inlining.
     if (call_does_dispatch && bytecode == Bytecodes::_invokeinterface) {
       ciInstanceKlass* declared_interface =
           caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();
+      ciInstanceKlass* singleton = declared_interface->unique_implementor();
 
-      if (declared_interface->nof_implementors() == 1 &&
+      if (singleton != NULL &&
           (!callee->is_default_method() || callee->is_overpass()) /* CHA doesn't support default methods yet */) {
-        ciInstanceKlass* singleton = declared_interface->implementor();
+        assert(singleton != declared_interface, "not a unique implementor");
+
         ciMethod* cha_monomorphic_target =
             callee->find_monomorphic_target(caller->holder(), declared_interface, singleton);
 
         if (cha_monomorphic_target != NULL &&
             cha_monomorphic_target->holder() != env()->Object_klass()) { // subtype check against Object is useless
@@ -698,12 +701,12 @@
           // The Java code knows this, at VerifyType.isNullConversion.
           pop_node(rt);  // whatever it was, pop it
         } else if (rt == T_INT || is_subword_type(rt)) {
           // Nothing.  These cases are handled in lambda form bytecode.
           assert(ct == T_INT || is_subword_type(ct), "must match: rt=%s, ct=%s", type2name(rt), type2name(ct));
-        } else if (rt == T_OBJECT || rt == T_ARRAY) {
-          assert(ct == T_OBJECT || ct == T_ARRAY, "rt=%s, ct=%s", type2name(rt), type2name(ct));
+        } else if (is_reference_type(rt)) {
+          assert(is_reference_type(ct), "rt=%s, ct=%s", type2name(rt), type2name(ct));
           if (ctype->is_loaded()) {
             const TypeOopPtr* arg_type = TypeOopPtr::make_from_klass(rtype->as_klass());
             const Type*       sig_type = TypeOopPtr::make_from_klass(ctype->as_klass());
             if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {
               Node* retnode = pop();
@@ -746,11 +749,11 @@
       set_bci(iter().next_bci());
       null_assert(peek());
       set_bci(iter().cur_bci()); // put it back
     }
     BasicType ct = ctype->basic_type();
-    if (ct == T_OBJECT || ct == T_ARRAY) {
+    if (is_reference_type(ct)) {
       record_profiled_return_for_speculation();
     }
   }
 
   // Restart record of parsing work after possible inlining of call
@@ -1150,18 +1153,23 @@
                        log()->identify(cha_monomorphic_target));
       }
       cha_monomorphic_target = NULL;
     }
   }
+
   if (cha_monomorphic_target != NULL) {
     // Hardwiring a virtual.
-    // If we inlined because CHA revealed only a single target method,
-    // then we are dependent on that target method not getting overridden
-    // by dynamic class loading.  Be sure to test the "static" receiver
-    // dest_method here, as opposed to the actual receiver, which may
-    // falsely lead us to believe that the receiver is final or private.
-    dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);
+    assert(!callee->can_be_statically_bound(), "should have been handled earlier");
+    assert(!cha_monomorphic_target->is_abstract(), "");
+    if (!cha_monomorphic_target->can_be_statically_bound(actual_receiver)) {
+      // If we inlined because CHA revealed only a single target method,
+      // then we are dependent on that target method not getting overridden
+      // by dynamic class loading.  Be sure to test the "static" receiver
+      // dest_method here, as opposed to the actual receiver, which may
+      // falsely lead us to believe that the receiver is final or private.
+      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);
+    }
     return cha_monomorphic_target;
   }
 
   // If the type is exact, we can still bind the method w/o a vcall.
   // (This case comes after CHA so we can see how much extra work it does.)

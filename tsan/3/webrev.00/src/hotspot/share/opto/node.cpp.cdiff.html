<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="multnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  #include &quot;opto/regmask.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/type.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  class RegMask;
  // #include &quot;phase.hpp&quot;
  class PhaseTransform;
  class PhaseGVN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
      if (_out == NULL)  _out = NO_OUT_ARRAY;
      assert(!is_top(), &quot;must not be top&quot;);
    }
  }
  
<span class="line-removed">- </span>
  //------------------------------~Node------------------------------------------
  // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
  void Node::destruct() {
    // Eagerly reclaim unique Node numberings
    Compile* compile = Compile::current();
<span class="line-new-header">--- 563,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,11 ***</span>
      to[1] = NULL;
      to[2] = NULL;
      to[3] = NULL;
      return;
    }
<span class="line-modified">!   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
    // Trimming to limit allows a uint8 to handle up to 255 edges.
    // Previously I was using only powers-of-2 which peaked at 128 edges.
    //if( new_max &gt;= limit ) new_max = limit-1;
    _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
    Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
<span class="line-new-header">--- 652,11 ---</span>
      to[1] = NULL;
      to[2] = NULL;
      to[3] = NULL;
      return;
    }
<span class="line-modified">!   new_max = next_power_of_2(len);</span>
    // Trimming to limit allows a uint8 to handle up to 255 edges.
    // Previously I was using only powers-of-2 which peaked at 128 edges.
    //if( new_max &gt;= limit ) new_max = limit-1;
    _in = (Node**)arena-&gt;Arealloc(_in, _max*sizeof(Node*), new_max*sizeof(Node*));
    Copy::zero_to_bytes(&amp;_in[_max], (new_max-_max)*sizeof(Node*)); // NULL all new space
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,11 ***</span>
    if( new_max == 0 ) {
      _outmax = 4;
      _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
      return;
    }
<span class="line-modified">!   while( new_max &lt;= len ) new_max &lt;&lt;= 1; // Find next power-of-2</span>
    // Trimming to limit allows a uint8 to handle up to 255 edges.
    // Previously I was using only powers-of-2 which peaked at 128 edges.
    //if( new_max &gt;= limit ) new_max = limit-1;
    assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
    _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
<span class="line-new-header">--- 675,11 ---</span>
    if( new_max == 0 ) {
      _outmax = 4;
      _out = (Node **)arena-&gt;Amalloc(4*sizeof(Node*));
      return;
    }
<span class="line-modified">!   new_max = next_power_of_2(len);</span>
    // Trimming to limit allows a uint8 to handle up to 255 edges.
    // Previously I was using only powers-of-2 which peaked at 128 edges.
    //if( new_max &gt;= limit ) new_max = limit-1;
    assert(_out != NULL &amp;&amp; _out != NO_OUT_ARRAY, &quot;out must have sensible value&quot;);
    _out = (Node**)arena-&gt;Arealloc(_out,_outmax*sizeof(Node*),new_max*sizeof(Node*));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 700,12 ***</span>
      if( _in[i] != NULL )
        return false;
    dump();
    return true;
  }
<span class="line-removed">- #endif</span>
  
  
  //------------------------------is_unreachable---------------------------------
  bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
    assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
    return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
<span class="line-new-header">--- 700,29 ---</span>
      if( _in[i] != NULL )
        return false;
    dump();
    return true;
  }
  
<span class="line-added">+ bool Node::is_reachable_from_root() const {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   Unique_Node_List wq;</span>
<span class="line-added">+   wq.push((Node*)this);</span>
<span class="line-added">+   RootNode* root = Compile::current()-&gt;root();</span>
<span class="line-added">+   for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-added">+     Node* m = wq.at(i);</span>
<span class="line-added">+     if (m == root) {</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added">+       Node* u = m-&gt;fast_out(j);</span>
<span class="line-added">+       wq.push(u);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
  
  //------------------------------is_unreachable---------------------------------
  bool Node::is_unreachable(PhaseIterGVN &amp;igvn) const {
    assert(!is_Mach(), &quot;doesn&#39;t work with MachNodes&quot;);
    return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL &amp;&amp; in(0)-&gt;is_top());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 889,17 ***</span>
  }
  
  //-----------------------------uncast---------------------------------------
  // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
  // Strip away casting.  (It is depth-limited.)
<span class="line-modified">! Node* Node::uncast() const {</span>
    // Should be inline:
    //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
<span class="line-modified">!   if (is_ConstraintCast())</span>
<span class="line-modified">!     return uncast_helper(this);</span>
<span class="line-modified">!   else</span>
      return (Node*) this;
  }
  
  // Find out of current node that matches opcode.
  Node* Node::find_out_with(int opcode) {
    for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
<span class="line-new-header">--- 906,19 ---</span>
  }
  
  //-----------------------------uncast---------------------------------------
  // %%% Temporary, until we sort out CheckCastPP vs. CastPP.
  // Strip away casting.  (It is depth-limited.)
<span class="line-modified">! // Optionally, keep casts with dependencies.</span>
<span class="line-added">+ Node* Node::uncast(bool keep_deps) const {</span>
    // Should be inline:
    //return is_ConstraintCast() ? uncast_helper(this) : (Node*) this;
<span class="line-modified">!   if (is_ConstraintCast()) {</span>
<span class="line-modified">!     return uncast_helper(this, keep_deps);</span>
<span class="line-modified">!   } else {</span>
      return (Node*) this;
<span class="line-added">+   }</span>
  }
  
  // Find out of current node that matches opcode.
  Node* Node::find_out_with(int opcode) {
    for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,11 ***</span>
    return false;
  }
  
  
  //---------------------------uncast_helper-------------------------------------
<span class="line-modified">! Node* Node::uncast_helper(const Node* p) {</span>
  #ifdef ASSERT
    uint depth_count = 0;
    const Node* orig_p = p;
  #endif
  
<span class="line-new-header">--- 946,11 ---</span>
    return false;
  }
  
  
  //---------------------------uncast_helper-------------------------------------
<span class="line-modified">! Node* Node::uncast_helper(const Node* p, bool keep_deps) {</span>
  #ifdef ASSERT
    uint depth_count = 0;
    const Node* orig_p = p;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,10 ***</span>
<span class="line-new-header">--- 964,13 ---</span>
      assert(depth_count++ &lt; K, &quot;infinite loop in Node::uncast_helper&quot;);
  #endif
      if (p == NULL || p-&gt;req() != 2) {
        break;
      } else if (p-&gt;is_ConstraintCast()) {
<span class="line-added">+       if (keep_deps &amp;&amp; p-&gt;as_ConstraintCast()-&gt;carry_dependency()) {</span>
<span class="line-added">+         break; // stop at casts with dependencies</span>
<span class="line-added">+       }</span>
        p = p-&gt;in(1);
      } else {
        break;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1142,11 ***</span>
      return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
    } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
      // See IfProjNode::Identity()
      return true;
    } else {
<span class="line-modified">!     return BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;has_special_unique_user(this);</span>
    }
  };
  
  //--------------------------find_exact_control---------------------------------
  // Skip Proj and CatchProj nodes chains. Check for Null and Top.
<span class="line-new-header">--- 1164,11 ---</span>
      return n-&gt;Opcode() == op &amp;&amp; n-&gt;in(2) == this;
    } else if (is_If() &amp;&amp; (n-&gt;is_IfFalse() || n-&gt;is_IfTrue())) {
      // See IfProjNode::Identity()
      return true;
    } else {
<span class="line-modified">!     return false;</span>
    }
  };
  
  //--------------------------find_exact_control---------------------------------
  // Skip Proj and CatchProj nodes chains. Check for Null and Top.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1219,16 ***</span>
      up = sub-&gt;find_exact_control(up);
      // If sub == up, we found a self-loop.  Try to push past it.
      if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
        // Take loop entry path on the way up to &#39;dom&#39;.
        up = sub-&gt;in(1); // in(LoopNode::EntryControl);
<span class="line-modified">!     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() != 3) {</span>
<span class="line-modified">!       // Always take in(1) path on the way up to &#39;dom&#39; for clone regions</span>
<span class="line-removed">-       // (with only one input) or regions which merge &gt; 2 paths</span>
<span class="line-removed">-       // (usually used to merge fast/slow paths).</span>
        up = sub-&gt;in(1);
<span class="line-modified">!     } else if (sub == up &amp;&amp; sub-&gt;is_Region()) {</span>
        // Try both paths for Regions with 2 input paths (it may be a loop head).
        // It could give conservative &#39;false&#39; answer without information
        // which region&#39;s input is the entry path.
        iterations_without_region_limit = DominatorSearchLimit; // Reset
  
<span class="line-new-header">--- 1241,14 ---</span>
      up = sub-&gt;find_exact_control(up);
      // If sub == up, we found a self-loop.  Try to push past it.
      if (sub == up &amp;&amp; sub-&gt;is_Loop()) {
        // Take loop entry path on the way up to &#39;dom&#39;.
        up = sub-&gt;in(1); // in(LoopNode::EntryControl);
<span class="line-modified">!     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 2) {</span>
<span class="line-modified">!       // Take in(1) path on the way up to &#39;dom&#39; for regions with only one input</span>
        up = sub-&gt;in(1);
<span class="line-modified">!     } else if (sub == up &amp;&amp; sub-&gt;is_Region() &amp;&amp; sub-&gt;req() == 3) {</span>
        // Try both paths for Regions with 2 input paths (it may be a loop head).
        // It could give conservative &#39;false&#39; answer without information
        // which region&#39;s input is the entry path.
        iterations_without_region_limit = DominatorSearchLimit; // Reset
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1299,12 ***</span>
  // inside the dead region, just at the borders.
  static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
    // Con&#39;s are a popular node to re-hit in the hash table again.
    if( dead-&gt;is_Con() ) return;
  
<span class="line-modified">!   // Can&#39;t put ResourceMark here since igvn-&gt;_worklist uses the same arena</span>
<span class="line-removed">-   // for verify pass with +VerifyOpto and we add/remove elements in it here.</span>
    Node_List  nstack(Thread::current()-&gt;resource_area());
  
    Node *top = igvn-&gt;C-&gt;top();
    nstack.push(dead);
    bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
<span class="line-new-header">--- 1319,11 ---</span>
  // inside the dead region, just at the borders.
  static void kill_dead_code( Node *dead, PhaseIterGVN *igvn ) {
    // Con&#39;s are a popular node to re-hit in the hash table again.
    if( dead-&gt;is_Con() ) return;
  
<span class="line-modified">!   ResourceMark rm;</span>
    Node_List  nstack(Thread::current()-&gt;resource_area());
  
    Node *top = igvn-&gt;C-&gt;top();
    nstack.push(dead);
    bool has_irreducible_loop = igvn-&gt;C-&gt;has_irreducible_loop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1431,12 ***</span>
    return (sum&gt;&gt;2) + _cnt + Opcode();
  }
  
  //------------------------------cmp--------------------------------------------
  // Compare special parts of simple Nodes
<span class="line-modified">! uint Node::cmp( const Node &amp;n ) const {</span>
<span class="line-modified">!   return 1;                     // Must be same</span>
  }
  
  //------------------------------rematerialize-----------------------------------
  // Should we clone rather than spill this instruction?
  bool Node::rematerialize() const {
<span class="line-new-header">--- 1450,12 ---</span>
    return (sum&gt;&gt;2) + _cnt + Opcode();
  }
  
  //------------------------------cmp--------------------------------------------
  // Compare special parts of simple Nodes
<span class="line-modified">! bool Node::cmp( const Node &amp;n ) const {</span>
<span class="line-modified">!   return true;                  // Must be same</span>
  }
  
  //------------------------------rematerialize-----------------------------------
  // Should we clone rather than spill this instruction?
  bool Node::rematerialize() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1447,17 ***</span>
  }
  
  //------------------------------needs_anti_dependence_check---------------------
  // Nodes which use memory without consuming it, hence need antidependences.
  bool Node::needs_anti_dependence_check() const {
<span class="line-modified">!   if( req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0 )</span>
      return false;
<span class="line-modified">!   else</span>
<span class="line-modified">!     return in(1)-&gt;bottom_type()-&gt;has_memory();</span>
  }
  
<span class="line-removed">- </span>
  // Get an integer constant from a ConNode (or CastIINode).
  // Return a default value if there is no apparent constant here.
  const TypeInt* Node::find_int_type() const {
    if (this-&gt;is_Type()) {
      return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
<span class="line-new-header">--- 1466,16 ---</span>
  }
  
  //------------------------------needs_anti_dependence_check---------------------
  // Nodes which use memory without consuming it, hence need antidependences.
  bool Node::needs_anti_dependence_check() const {
<span class="line-modified">!   if (req() &lt; 2 || (_flags &amp; Flag_needs_anti_dependence_check) == 0) {</span>
      return false;
<span class="line-modified">!   }</span>
<span class="line-modified">!   return in(1)-&gt;bottom_type()-&gt;has_memory();</span>
  }
  
  // Get an integer constant from a ConNode (or CastIINode).
  // Return a default value if there is no apparent constant here.
  const TypeInt* Node::find_int_type() const {
    if (this-&gt;is_Type()) {
      return this-&gt;as_Type()-&gt;type()-&gt;isa_int();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2103,11 ***</span>
        for( j = 0; j &lt; len(); j++ ) {
          if( in(j) == n ) cnt--;
        }
        assert( cnt == 0,&quot;Mismatched edge count.&quot;);
      } else if (n == NULL) {
<span class="line-modified">!       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi(), &quot;only regions or phis have null data edges&quot;);</span>
      } else {
        assert(n-&gt;is_top(), &quot;sanity&quot;);
        // Nothing to check.
      }
    }
<span class="line-new-header">--- 2121,12 ---</span>
        for( j = 0; j &lt; len(); j++ ) {
          if( in(j) == n ) cnt--;
        }
        assert( cnt == 0,&quot;Mismatched edge count.&quot;);
      } else if (n == NULL) {
<span class="line-modified">!       assert(i &gt;= req() || i == 0 || is_Region() || is_Phi() || is_ArrayCopy()</span>
<span class="line-added">+               || (is_Unlock() &amp;&amp; i == req()-1), &quot;only region, phi, arraycopy or unlock nodes have null data edges&quot;);</span>
      } else {
        assert(n-&gt;is_top(), &quot;sanity&quot;);
        // Nothing to check.
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2117,13 ***</span>
      if( n != NULL )
        in(i)-&gt;verify_edges(visited);
    }
  }
  
<span class="line-removed">- //------------------------------verify_recur-----------------------------------</span>
<span class="line-removed">- static const Node *unique_top = NULL;</span>
<span class="line-removed">- </span>
  void Node::verify_recur(const Node *n, int verify_depth,
                          VectorSet &amp;old_space, VectorSet &amp;new_space) {
    if ( verify_depth == 0 )  return;
    if (verify_depth &gt; 0)  --verify_depth;
  
<span class="line-new-header">--- 2136,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2237,11 ***</span>
      _max = 1;
      _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
      _nodes[0] = NULL;
    }
    uint old = _max;
<span class="line-modified">!   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit</span>
    _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
    Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
  }
  
  //-----------------------------------------------------------------------------
<span class="line-new-header">--- 2253,11 ---</span>
      _max = 1;
      _nodes = (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
      _nodes[0] = NULL;
    }
    uint old = _max;
<span class="line-modified">!   _max = next_power_of_2(i);</span>
    _nodes = (Node**)_a-&gt;Arealloc( _nodes, old*sizeof(Node*),_max*sizeof(Node*));
    Copy::zero_to_bytes( &amp;_nodes[old], (_max-old)*sizeof(Node*) );
  }
  
  //-----------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2380,31 ***</span>
  #endif
  }
  
  //=============================================================================
  //------------------------------remove-----------------------------------------
<span class="line-modified">! void Unique_Node_List::remove( Node *n ) {</span>
<span class="line-modified">!   if( _in_worklist[n-&gt;_idx] ) {</span>
<span class="line-modified">!     for( uint i = 0; i &lt; size(); i++ )</span>
<span class="line-modified">!       if( _nodes[i] == n ) {</span>
<span class="line-modified">!         map(i,Node_List::pop());</span>
<span class="line-modified">!         _in_worklist &gt;&gt;= n-&gt;_idx;</span>
          return;
        }
      ShouldNotReachHere();
    }
  }
  
  //-----------------------remove_useless_nodes----------------------------------
  // Remove useless nodes from worklist
  void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
  
<span class="line-modified">!   for( uint i = 0; i &lt; size(); ++i ) {</span>
      Node *n = at(i);
      assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
<span class="line-modified">!     if( ! useful.test(n-&gt;_idx) ) {</span>
<span class="line-modified">!       _in_worklist &gt;&gt;= n-&gt;_idx;</span>
        map(i,Node_List::pop());
        // Node *replacement = Node_List::pop();
        // if( i != size() ) { // Check if removing last entry
        //   _nodes[i] = replacement;
        // }
<span class="line-new-header">--- 2396,32 ---</span>
  #endif
  }
  
  //=============================================================================
  //------------------------------remove-----------------------------------------
<span class="line-modified">! void Unique_Node_List::remove(Node* n) {</span>
<span class="line-modified">!   if (_in_worklist.test(n-&gt;_idx)) {</span>
<span class="line-modified">!     for (uint i = 0; i &lt; size(); i++) {</span>
<span class="line-modified">!       if (_nodes[i] == n) {</span>
<span class="line-modified">!         map(i, Node_List::pop());</span>
<span class="line-modified">!         _in_worklist.remove(n-&gt;_idx);</span>
          return;
        }
<span class="line-added">+     }</span>
      ShouldNotReachHere();
    }
  }
  
  //-----------------------remove_useless_nodes----------------------------------
  // Remove useless nodes from worklist
  void Unique_Node_List::remove_useless_nodes(VectorSet &amp;useful) {
  
<span class="line-modified">!   for (uint i = 0; i &lt; size(); ++i) {</span>
      Node *n = at(i);
      assert( n != NULL, &quot;Did not expect null entries in worklist&quot;);
<span class="line-modified">!     if (!useful.test(n-&gt;_idx)) {</span>
<span class="line-modified">!       _in_worklist.remove(n-&gt;_idx);</span>
        map(i,Node_List::pop());
        // Node *replacement = Node_List::pop();
        // if( i != size() ) { // Check if removing last entry
        //   _nodes[i] = replacement;
        // }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2450,11 ***</span>
  }
  #endif
  uint TypeNode::hash() const {
    return Node::hash() + _type-&gt;hash();
  }
<span class="line-modified">! uint TypeNode::cmp( const Node &amp;n ) const</span>
  { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
  const Type *TypeNode::bottom_type() const { return _type; }
  const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
  
  //------------------------------ideal_reg--------------------------------------
<span class="line-new-header">--- 2467,11 ---</span>
  }
  #endif
  uint TypeNode::hash() const {
    return Node::hash() + _type-&gt;hash();
  }
<span class="line-modified">! bool TypeNode::cmp( const Node &amp;n ) const</span>
  { return !Type::cmp( _type, ((TypeNode&amp;)n)._type ); }
  const Type *TypeNode::bottom_type() const { return _type; }
  const Type* TypeNode::Value(PhaseGVN* phase) const { return _type; }
  
  //------------------------------ideal_reg--------------------------------------
</pre>
<center><a href="multnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/coalesce.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/coalesce.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
585           if( !lrgs(lidx).mask().is_AllStack() ) {
586             // If this coalesce will make any new neighbor uncolorable,
587             // do not coalesce.
588             if( lrgs(lidx).just_lo_degree() )
589               return max_juint;
590             // Bump our degree
591             if( ++reg_degree &gt;= rm_size )
592               return max_juint;
593           } // End of if not infinite-stack neighbor
594         } // End of if actually inserted
595       } // End of if live range overlaps
596     } // End of else collect interferences for 1 node
597   } // End of while forever, scan back for interferences
598   return reg_degree;
599 }
600 
601 void PhaseConservativeCoalesce::update_ifg(uint lr1, uint lr2, IndexSet *n_lr1, IndexSet *n_lr2) {
602   // Some original neighbors of lr1 might have gone away
603   // because the constrained register mask prevented them.
604   // Remove lr1 from such neighbors.
<span class="line-modified">605   IndexSetIterator one(n_lr1);</span>
<span class="line-removed">606   uint neighbor;</span>
607   LRG &amp;lrg1 = lrgs(lr1);
<span class="line-modified">608   while ((neighbor = one.next()) != 0)</span>
<span class="line-modified">609     if( !_ulr.member(neighbor) )</span>
<span class="line-modified">610       if( _phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr1) )</span>
<span class="line-modified">611         lrgs(neighbor).inc_degree( -lrg1.compute_degree(lrgs(neighbor)) );</span>






612 
613 
614   // lr2 is now called (coalesced into) lr1.
615   // Remove lr2 from the IFG.
<span class="line-removed">616   IndexSetIterator two(n_lr2);</span>
617   LRG &amp;lrg2 = lrgs(lr2);
<span class="line-modified">618   while ((neighbor = two.next()) != 0)</span>
<span class="line-modified">619     if( _phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr2) )</span>
<span class="line-modified">620       lrgs(neighbor).inc_degree( -lrg2.compute_degree(lrgs(neighbor)) );</span>





621 
622   // Some neighbors of intermediate copies now interfere with the
623   // combined live range.
<span class="line-modified">624   IndexSetIterator three(&amp;_ulr);</span>
<span class="line-modified">625   while ((neighbor = three.next()) != 0)</span>
<span class="line-modified">626     if( _phc._ifg-&gt;neighbors(neighbor)-&gt;insert(lr1) )</span>
<span class="line-modified">627       lrgs(neighbor).inc_degree( lrg1.compute_degree(lrgs(neighbor)) );</span>




628 }
629 
630 static void record_bias( const PhaseIFG *ifg, int lr1, int lr2 ) {
631   // Tag copy bias here
632   if( !ifg-&gt;lrgs(lr1)._copy_bias )
633     ifg-&gt;lrgs(lr1)._copy_bias = lr2;
634   if( !ifg-&gt;lrgs(lr2)._copy_bias )
635     ifg-&gt;lrgs(lr2)._copy_bias = lr1;
636 }
637 
638 // See if I can coalesce a series of multiple copies together.  I need the
639 // final dest copy and the original src copy.  They can be the same Node.
640 // Compute the compatible register masks.
641 bool PhaseConservativeCoalesce::copy_copy(Node *dst_copy, Node *src_copy, Block *b, uint bindex) {
642 
643   if (!dst_copy-&gt;is_SpillCopy()) {
644     return false;
645   }
646   if (!src_copy-&gt;is_SpillCopy()) {
647     return false;
</pre>
</td>
<td>
<hr />
<pre>
585           if( !lrgs(lidx).mask().is_AllStack() ) {
586             // If this coalesce will make any new neighbor uncolorable,
587             // do not coalesce.
588             if( lrgs(lidx).just_lo_degree() )
589               return max_juint;
590             // Bump our degree
591             if( ++reg_degree &gt;= rm_size )
592               return max_juint;
593           } // End of if not infinite-stack neighbor
594         } // End of if actually inserted
595       } // End of if live range overlaps
596     } // End of else collect interferences for 1 node
597   } // End of while forever, scan back for interferences
598   return reg_degree;
599 }
600 
601 void PhaseConservativeCoalesce::update_ifg(uint lr1, uint lr2, IndexSet *n_lr1, IndexSet *n_lr2) {
602   // Some original neighbors of lr1 might have gone away
603   // because the constrained register mask prevented them.
604   // Remove lr1 from such neighbors.
<span class="line-modified">605   uint neighbor = 0;</span>

606   LRG &amp;lrg1 = lrgs(lr1);
<span class="line-modified">607   if (!n_lr1-&gt;is_empty()) {</span>
<span class="line-modified">608     IndexSetIterator one(n_lr1);</span>
<span class="line-modified">609     while ((neighbor = one.next()) != 0) {</span>
<span class="line-modified">610       if (!_ulr.member(neighbor)) {</span>
<span class="line-added">611         if (_phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr1)) {</span>
<span class="line-added">612           lrgs(neighbor).inc_degree(-lrg1.compute_degree(lrgs(neighbor)));</span>
<span class="line-added">613         }</span>
<span class="line-added">614       }</span>
<span class="line-added">615     }</span>
<span class="line-added">616   }</span>
617 
618 
619   // lr2 is now called (coalesced into) lr1.
620   // Remove lr2 from the IFG.

621   LRG &amp;lrg2 = lrgs(lr2);
<span class="line-modified">622   if (!n_lr2-&gt;is_empty()) {</span>
<span class="line-modified">623     IndexSetIterator two(n_lr2);</span>
<span class="line-modified">624     while ((neighbor = two.next()) != 0) {</span>
<span class="line-added">625       if (_phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr2)) {</span>
<span class="line-added">626         lrgs(neighbor).inc_degree(-lrg2.compute_degree(lrgs(neighbor)));</span>
<span class="line-added">627       }</span>
<span class="line-added">628     }</span>
<span class="line-added">629   }</span>
630 
631   // Some neighbors of intermediate copies now interfere with the
632   // combined live range.
<span class="line-modified">633   if (!_ulr.is_empty()) {</span>
<span class="line-modified">634     IndexSetIterator three(&amp;_ulr);</span>
<span class="line-modified">635     while ((neighbor = three.next()) != 0) {</span>
<span class="line-modified">636       if (_phc._ifg-&gt;neighbors(neighbor)-&gt;insert(lr1)) {</span>
<span class="line-added">637         lrgs(neighbor).inc_degree(lrg1.compute_degree(lrgs(neighbor)));</span>
<span class="line-added">638       }</span>
<span class="line-added">639     }</span>
<span class="line-added">640   }</span>
641 }
642 
643 static void record_bias( const PhaseIFG *ifg, int lr1, int lr2 ) {
644   // Tag copy bias here
645   if( !ifg-&gt;lrgs(lr1)._copy_bias )
646     ifg-&gt;lrgs(lr1)._copy_bias = lr2;
647   if( !ifg-&gt;lrgs(lr2)._copy_bias )
648     ifg-&gt;lrgs(lr2)._copy_bias = lr1;
649 }
650 
651 // See if I can coalesce a series of multiple copies together.  I need the
652 // final dest copy and the original src copy.  They can be the same Node.
653 // Compute the compatible register masks.
654 bool PhaseConservativeCoalesce::copy_copy(Node *dst_copy, Node *src_copy, Block *b, uint bindex) {
655 
656   if (!dst_copy-&gt;is_SpillCopy()) {
657     return false;
658   }
659   if (!src_copy-&gt;is_SpillCopy()) {
660     return false;
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
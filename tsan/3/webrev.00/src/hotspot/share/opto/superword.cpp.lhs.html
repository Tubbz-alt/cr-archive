<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
<a name="1" id="anc1"></a>
  42 
  43 //
  44 //                  S U P E R W O R D   T R A N S F O R M
  45 //=============================================================================
  46 
  47 //------------------------------SuperWord---------------------------
  48 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  49   _phase(phase),
  50   _arena(phase-&gt;C-&gt;comp_arena()),
  51   _igvn(phase-&gt;_igvn),
  52   _packset(arena(), 8,  0, NULL),         // packs for the current block
  53   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  54   _block(arena(), 8,  0, NULL),           // nodes in current block
  55   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  56   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  57   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  58   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  59   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  60   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  61   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  62   _align_to_ref(NULL),                    // memory reference to align vectors to
  63   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  64   _dg(_arena),                            // dependence graph
  65   _visited(arena()),                      // visited node set
  66   _post_visited(arena()),                 // post visited node set
  67   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  68   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  69   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  70   _lpt(NULL),                             // loop tree node
  71   _lp(NULL),                              // LoopNode
  72   _bb(NULL),                              // basic block
  73   _iv(NULL),                              // induction var
  74   _race_possible(false),                  // cases where SDMU is true
  75   _early_return(true),                    // analysis evaluations routine
  76   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  77   _do_reserve_copy(DoReserveCopyInSuperWord),
  78   _num_work_vecs(0),                      // amount of vector work we have
  79   _num_reductions(0),                     // amount of reduction work we have
  80   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  81   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  82   _ii_order(arena(), 8, 0, 0)
  83 {
  84 #ifndef PRODUCT
  85   _vector_loop_debug = 0;
  86   if (_phase-&gt;C-&gt;method() != NULL) {
  87     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  88   }
  89 
  90 #endif
  91 }
  92 
  93 //------------------------------transform_loop---------------------------
  94 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  95   assert(UseSuperWord, &quot;should be&quot;);
  96   // Do vectors exist on this architecture?
  97   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  98 
  99   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 100   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 101 
 102   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 103 
 104   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 105   if (post_loop_allowed) {
 106     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 107     Node *limit = cl-&gt;limit();
 108     if (limit-&gt;is_Con()) return; // non constant limits only
 109     // Now check the limit for expressions we do not handle
 110     if (limit-&gt;is_Add()) {
 111       Node *in2 = limit-&gt;in(2);
 112       if (in2-&gt;is_Con()) {
 113         int val = in2-&gt;get_int();
 114         // should not try to program these cases
 115         if (val &lt; 0) return;
 116       }
 117     }
 118   }
 119 
 120   // skip any loop that has not been assigned max unroll by analysis
 121   if (do_optimization) {
 122     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 123   }
 124 
 125   // Check for no control flow in body (other than exit)
 126   Node *cl_exit = cl-&gt;loopexit();
 127   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 128     #ifndef PRODUCT
 129       if (TraceSuperWord) {
 130         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 131         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 132         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 133         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 134         lpt-&gt;dump_head();
 135       }
 136     #endif
 137     return;
 138   }
 139 
 140   // Make sure the are no extra control users of the loop backedge
 141   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 142     return;
 143   }
 144 
 145   // Skip any loops already optimized by slp
 146   if (cl-&gt;is_vectorized_loop()) return;
 147 
<a name="2" id="anc2"></a><span class="line-modified"> 148   if (cl-&gt;do_unroll_only()) return;</span>
 149 
 150   if (cl-&gt;is_main_loop()) {
 151     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 152     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 153     if (pre_end == NULL) return;
 154     Node *pre_opaq1 = pre_end-&gt;limit();
 155     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 156   }
 157 
 158   init(); // initialize data structures
 159 
 160   set_lpt(lpt);
 161   set_lp(cl);
 162 
 163   // For now, define one block which is the entire loop body
 164   set_bb(cl);
 165 
 166   if (do_optimization) {
 167     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 168     SLP_extract();
 169     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 170       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 171         IdealLoopTree *lpt_next = lpt-&gt;_next;
 172         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 173         _phase-&gt;has_range_checks(lpt_next);
 174         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 175           if (!cl_next-&gt;is_vectorized_loop()) {
 176             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 177             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 178           }
 179         }
 180       }
 181     }
 182   }
 183 }
 184 
 185 //------------------------------early unrolling analysis------------------------------
 186 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 187   bool is_slp = true;
 188   ResourceMark rm;
 189   size_t ignored_size = lpt()-&gt;_body.size();
 190   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 191   Node_Stack nstack((int)ignored_size);
 192   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 193   Node *cl_exit = cl-&gt;loopexit_or_null();
 194   int rpo_idx = _post_block.length();
 195 
 196   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 197 
 198   // First clear the entries
 199   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 200     ignored_loop_nodes[i] = -1;
 201   }
 202 
 203   int max_vector = Matcher::max_vector_size(T_BYTE);
 204   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 205 
 206   // Process the loop, some/all of the stack entries will not be in order, ergo
 207   // need to preprocess the ignored initial state before we process the loop
 208   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 209     Node* n = lpt()-&gt;_body.at(i);
 210     if (n == cl-&gt;incr() ||
 211       n-&gt;is_reduction() ||
 212       n-&gt;is_AddP() ||
 213       n-&gt;is_Cmp() ||
 214       n-&gt;is_IfTrue() ||
 215       n-&gt;is_CountedLoop() ||
 216       (n == cl_exit)) {
 217       ignored_loop_nodes[i] = n-&gt;_idx;
 218       continue;
 219     }
 220 
 221     if (n-&gt;is_If()) {
 222       IfNode *iff = n-&gt;as_If();
 223       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 224         if (lpt()-&gt;is_loop_exit(iff)) {
 225           ignored_loop_nodes[i] = n-&gt;_idx;
 226           continue;
 227         }
 228       }
 229     }
 230 
 231     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 232       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 233       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 234         if (!n_tail-&gt;is_Mem()) {
 235           is_slp = false;
 236           break;
 237         }
 238       }
 239     }
 240 
 241     // This must happen after check of phi/if
 242     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 243       ignored_loop_nodes[i] = n-&gt;_idx;
 244       continue;
 245     }
 246 
 247     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 248       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 249       is_slp = false;
 250       break;
 251     }
 252 
 253     // Ignore nodes with non-primitive type.
 254     BasicType bt;
 255     if (n-&gt;is_Mem()) {
 256       bt = n-&gt;as_Mem()-&gt;memory_type();
 257     } else {
 258       bt = n-&gt;bottom_type()-&gt;basic_type();
 259     }
 260     if (is_java_primitive(bt) == false) {
 261       ignored_loop_nodes[i] = n-&gt;_idx;
 262       continue;
 263     }
 264 
 265     if (n-&gt;is_Mem()) {
 266       MemNode* current = n-&gt;as_Mem();
 267       Node* adr = n-&gt;in(MemNode::Address);
 268       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 269 
 270       // save a queue of post process nodes
 271       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 272         // Process the memory expression
 273         int stack_idx = 0;
 274         bool have_side_effects = true;
 275         if (adr-&gt;is_AddP() == false) {
 276           nstack.push(adr, stack_idx++);
 277         } else {
 278           // Mark the components of the memory operation in nstack
 279           SWPointer p1(current, this, &amp;nstack, true);
 280           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 281         }
 282 
 283         // Process the pointer stack
 284         while (have_side_effects) {
 285           Node* pointer_node = nstack.node();
 286           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 287             Node* cur_node = lpt()-&gt;_body.at(j);
 288             if (cur_node == pointer_node) {
 289               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 290               break;
 291             }
 292           }
 293           nstack.pop();
 294           have_side_effects = nstack.is_nonempty();
 295         }
 296       }
 297     }
 298   }
 299 
 300   if (is_slp) {
 301     // Now we try to find the maximum supported consistent vector which the machine
 302     // description can use
 303     bool small_basic_type = false;
 304     bool flag_small_bt = false;
 305     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 306       if (ignored_loop_nodes[i] != -1) continue;
 307 
 308       BasicType bt;
 309       Node* n = lpt()-&gt;_body.at(i);
 310       if (n-&gt;is_Mem()) {
 311         bt = n-&gt;as_Mem()-&gt;memory_type();
 312       } else {
 313         bt = n-&gt;bottom_type()-&gt;basic_type();
 314       }
 315 
 316       if (post_loop_allowed) {
 317         if (!small_basic_type) {
 318           switch (bt) {
 319           case T_CHAR:
 320           case T_BYTE:
 321           case T_SHORT:
 322             small_basic_type = true;
 323             break;
 324 
 325           case T_LONG:
 326             // TODO: Remove when support completed for mask context with LONG.
 327             //       Support needs to be augmented for logical qword operations, currently we map to dword
 328             //       buckets for vectors on logicals as these were legacy.
 329             small_basic_type = true;
 330             break;
 331 
 332           default:
 333             break;
 334           }
 335         }
 336       }
 337 
 338       if (is_java_primitive(bt) == false) continue;
 339 
 340          int cur_max_vector = Matcher::max_vector_size(bt);
 341 
 342       // If a max vector exists which is not larger than _local_loop_unroll_factor
 343       // stop looking, we already have the max vector to map to.
 344       if (cur_max_vector &lt; local_loop_unroll_factor) {
 345         is_slp = false;
 346         if (TraceSuperWordLoopUnrollAnalysis) {
 347           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 348         }
 349         break;
 350       }
 351 
 352       // Map the maximal common vector
 353       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 354         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 355           max_vector = cur_max_vector;
 356         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 357           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 358           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 359           // We check for possibility of narrowing by looking through chain operations using subword types.
 360           if (is_subword_type(bt)) {
 361             uint start, end;
 362             VectorNode::vector_operands(n, &amp;start, &amp;end);
 363 
 364             for (uint j = start; j &lt; end; j++) {
 365               Node* in = n-&gt;in(j);
 366               // Don&#39;t propagate through a memory
 367               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 368                 bool same_type = true;
 369                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 370                   Node *use = in-&gt;fast_out(k);
 371                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 372                     same_type = false;
 373                     break;
 374                   }
 375                 }
 376                 if (same_type) {
 377                   max_vector = cur_max_vector;
 378                   flag_small_bt = true;
 379                   cl-&gt;mark_subword_loop();
 380                 }
 381               }
 382             }
 383           }
 384         }
 385         // We only process post loops on predicated targets where we want to
 386         // mask map the loop to a single iteration
 387         if (post_loop_allowed) {
 388           _post_block.at_put_grow(rpo_idx++, n);
 389         }
 390       }
 391     }
 392     if (is_slp) {
 393       local_loop_unroll_factor = max_vector;
 394       cl-&gt;mark_passed_slp();
 395     }
 396     cl-&gt;mark_was_slp();
 397     if (cl-&gt;is_main_loop()) {
 398       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 399     } else if (post_loop_allowed) {
 400       if (!small_basic_type) {
 401         // avoid replication context for small basic types in programmable masked loops
 402         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 403       }
 404     }
 405   }
 406 }
 407 
 408 //------------------------------SLP_extract---------------------------
 409 // Extract the superword level parallelism
 410 //
 411 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 412 //    this list from first to last, all definitions are visited before their uses.
 413 //
 414 // 2) A point-to-point dependence graph is constructed between memory references.
 415 //    This simplies the upcoming &quot;independence&quot; checker.
 416 //
 417 // 3) The maximum depth in the node graph from the beginning of the block
 418 //    to each node is computed.  This is used to prune the graph search
 419 //    in the independence checker.
 420 //
 421 // 4) For integer types, the necessary bit width is propagated backwards
 422 //    from stores to allow packed operations on byte, char, and short
 423 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 424 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 425 //
 426 // 5) One of the memory references is picked to be an aligned vector reference.
 427 //    The pre-loop trip count is adjusted to align this reference in the
 428 //    unrolled body.
 429 //
 430 // 6) The initial set of pack pairs is seeded with memory references.
 431 //
 432 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 433 //
 434 // 8) The pairs are combined into vector sized packs.
 435 //
 436 // 9) Reorder the memory slices to co-locate members of the memory packs.
 437 //
 438 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 439 //    inserting scalar promotion, vector creation from multiple scalars, and
 440 //    extraction of scalar values from vectors.
 441 //
 442 void SuperWord::SLP_extract() {
 443 
 444 #ifndef PRODUCT
 445   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 446     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 447     tty-&gt;print(&quot;input loop\n&quot;);
 448     _lpt-&gt;dump_head();
 449     _lpt-&gt;dump();
 450     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 451       _lpt-&gt;_body.at(i)-&gt;dump();
 452     }
 453   }
 454 #endif
 455   // Ready the block
 456   if (!construct_bb()) {
 457     return; // Exit if no interesting nodes or complex graph.
 458   }
 459 
 460   // build    _dg, _disjoint_ptrs
 461   dependence_graph();
 462 
 463   // compute function depth(Node*)
 464   compute_max_depth();
 465 
 466   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 467   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 468   if (cl-&gt;is_main_loop()) {
 469     if (_do_vector_loop) {
 470       if (mark_generations() != -1) {
 471         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 472 
 473         if (!construct_bb()) {
 474           return; // Exit if no interesting nodes or complex graph.
 475         }
 476         dependence_graph();
 477         compute_max_depth();
 478       }
 479 
 480 #ifndef PRODUCT
 481       if (TraceSuperWord) {
 482         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 483         _lpt-&gt;dump_head();
 484         for (int j = 0; j &lt; _block.length(); j++) {
 485           Node* n = _block.at(j);
 486           int d = depth(n);
 487           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 488           tty-&gt;print(&quot;%d :&quot;, d);
 489           n-&gt;dump();
 490         }
 491       }
 492 #endif
 493     }
 494 
 495     compute_vector_element_type();
 496 
 497     // Attempt vectorization
 498 
 499     find_adjacent_refs();
 500 
 501     extend_packlist();
 502 
 503     if (_do_vector_loop) {
 504       if (_packset.length() == 0) {
 505         if (TraceSuperWord) {
 506           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 507         }
 508         pack_parallel();
 509       }
 510     }
 511 
 512     combine_packs();
 513 
 514     construct_my_pack_map();
 515     if (UseVectorCmov) {
 516       merge_packs_to_cmovd();
 517     }
 518 
 519     filter_packs();
 520 
 521     schedule();
 522   } else if (post_loop_allowed) {
 523     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 524     if (saved_mapped_unroll_factor) {
 525       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 526 
 527       // now reset the slp_unroll_factor so that we can check the analysis mapped
 528       // what the vector loop was mapped to
 529       cl-&gt;set_slp_max_unroll(0);
 530 
 531       // do the analysis on the post loop
 532       unrolling_analysis(vector_mapped_unroll_factor);
 533 
 534       // if our analyzed loop is a canonical fit, start processing it
 535       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 536         // now add the vector nodes to packsets
 537         for (int i = 0; i &lt; _post_block.length(); i++) {
 538           Node* n = _post_block.at(i);
 539           Node_List* singleton = new Node_List();
 540           singleton-&gt;push(n);
 541           _packset.append(singleton);
 542           set_my_pack(n, singleton);
 543         }
 544 
 545         // map base types for vector usage
 546         compute_vector_element_type();
 547       } else {
 548         return;
 549       }
 550     } else {
 551       // for some reason we could not map the slp analysis state of the vectorized loop
 552       return;
 553     }
 554   }
 555 
 556   output();
 557 }
 558 
 559 //------------------------------find_adjacent_refs---------------------------
 560 // Find the adjacent memory references and create pack pairs for them.
 561 // This is the initial set of packs that will then be extended by
 562 // following use-&gt;def and def-&gt;use links.  The align positions are
 563 // assigned relative to the reference &quot;align_to_ref&quot;
 564 void SuperWord::find_adjacent_refs() {
 565   // Get list of memory operations
 566   Node_List memops;
 567   for (int i = 0; i &lt; _block.length(); i++) {
 568     Node* n = _block.at(i);
 569     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 570         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 571       int align = memory_alignment(n-&gt;as_Mem(), 0);
 572       if (align != bottom_align) {
 573         memops.push(n);
 574       }
 575     }
 576   }
 577 
 578   Node_List align_to_refs;
<a name="3" id="anc3"></a>
 579   int best_iv_adjustment = 0;
 580   MemNode* best_align_to_mem_ref = NULL;
 581 
 582   while (memops.size() != 0) {
 583     // Find a memory reference to align to.
<a name="4" id="anc4"></a><span class="line-modified"> 584     MemNode* mem_ref = find_align_to_ref(memops);</span>
 585     if (mem_ref == NULL) break;
 586     align_to_refs.push(mem_ref);
 587     int iv_adjustment = get_iv_adjustment(mem_ref);
 588 
 589     if (best_align_to_mem_ref == NULL) {
 590       // Set memory reference which is the best from all memory operations
 591       // to be used for alignment. The pre-loop trip count is modified to align
 592       // this reference to a vector-aligned address.
 593       best_align_to_mem_ref = mem_ref;
 594       best_iv_adjustment = iv_adjustment;
 595       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 596     }
 597 
 598     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 599     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 600     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 601       MemNode* s = memops.at(i)-&gt;as_Mem();
 602       if (isomorphic(s, mem_ref) &amp;&amp;
 603            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 604         SWPointer p2(s, this, NULL, false);
 605         if (p2.comparable(align_to_ref_p)) {
 606           int align = memory_alignment(s, iv_adjustment);
 607           set_alignment(s, align);
 608         }
 609       }
 610     }
 611 
 612     // Create initial pack pairs of memory operations for which
 613     // alignment is set and vectors will be aligned.
 614     bool create_pack = true;
 615     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 616       if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 617         int vw = vector_width(mem_ref);
 618         int vw_best = vector_width(best_align_to_mem_ref);
 619         if (vw &gt; vw_best) {
 620           // Do not vectorize a memory access with more elements per vector
 621           // if unaligned memory access is not allowed because number of
 622           // iterations in pre-loop will be not enough to align it.
 623           create_pack = false;
 624         } else {
 625           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 626           if (align_to_ref_p.invar() != p2.invar()) {
 627             // Do not vectorize memory accesses with different invariants
 628             // if unaligned memory accesses are not allowed.
 629             create_pack = false;
 630           }
 631         }
 632       }
 633     } else {
 634       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 635         // Can&#39;t allow vectorization of unaligned memory accesses with the
 636         // same type since it could be overlapped accesses to the same array.
 637         create_pack = false;
 638       } else {
 639         // Allow independent (different type) unaligned memory operations
 640         // if HW supports them.
 641         if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 642           create_pack = false;
 643         } else {
 644           // Check if packs of the same memory type but
 645           // with a different alignment were created before.
 646           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 647             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 648             if (mr == mem_ref) {
 649               // Skip when we are looking at same memory operation.
 650               continue;
 651             }
 652             if (same_velt_type(mr, mem_ref) &amp;&amp;
 653                 memory_alignment(mr, iv_adjustment) != 0)
 654               create_pack = false;
 655           }
 656         }
 657       }
 658     }
 659     if (create_pack) {
 660       for (uint i = 0; i &lt; memops.size(); i++) {
 661         Node* s1 = memops.at(i);
 662         int align = alignment(s1);
 663         if (align == top_align) continue;
 664         for (uint j = 0; j &lt; memops.size(); j++) {
 665           Node* s2 = memops.at(j);
 666           if (alignment(s2) == top_align) continue;
 667           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 668             if (stmts_can_pack(s1, s2, align)) {
 669               Node_List* pair = new Node_List();
 670               pair-&gt;push(s1);
 671               pair-&gt;push(s2);
 672               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 673                 _packset.append(pair);
 674               }
 675             }
 676           }
 677         }
 678       }
 679     } else { // Don&#39;t create unaligned pack
 680       // First, remove remaining memory ops of the same type from the list.
 681       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 682         MemNode* s = memops.at(i)-&gt;as_Mem();
 683         if (same_velt_type(s, mem_ref)) {
 684           memops.remove(i);
 685         }
 686       }
 687 
 688       // Second, remove already constructed packs of the same type.
 689       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 690         Node_List* p = _packset.at(i);
 691         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 692         if (same_velt_type(s, mem_ref)) {
 693           remove_pack_at(i);
 694         }
 695       }
 696 
 697       // If needed find the best memory reference for loop alignment again.
 698       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 699         // Put memory ops from remaining packs back on memops list for
 700         // the best alignment search.
 701         uint orig_msize = memops.size();
 702         for (int i = 0; i &lt; _packset.length(); i++) {
 703           Node_List* p = _packset.at(i);
 704           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 705           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 706           memops.push(s);
 707         }
<a name="5" id="anc5"></a><span class="line-modified"> 708         best_align_to_mem_ref = find_align_to_ref(memops);</span>
 709         if (best_align_to_mem_ref == NULL) {
 710           if (TraceSuperWord) {
 711             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 712           }
<a name="6" id="anc6"></a>















 713           break;
 714         }
 715         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 716         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 717         // Restore list.
 718         while (memops.size() &gt; orig_msize)
 719           (void)memops.pop();
 720       }
 721     } // unaligned memory accesses
 722 
 723     // Remove used mem nodes.
 724     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 725       MemNode* m = memops.at(i)-&gt;as_Mem();
 726       if (alignment(m) != top_align) {
 727         memops.remove(i);
 728       }
 729     }
 730 
 731   } // while (memops.size() != 0
 732   set_align_to_ref(best_align_to_mem_ref);
 733 
 734   if (TraceSuperWord) {
 735     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 736     print_packset();
 737   }
 738 }
 739 
 740 #ifndef PRODUCT
 741 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 742   if (is_trace_adjacent()) {
 743     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 744        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 745        best_align_to_mem_ref-&gt;dump();
 746   }
 747 }
 748 #endif
 749 
 750 //------------------------------find_align_to_ref---------------------------
 751 // Find a memory reference to align the loop induction variable to.
 752 // Looks first at stores then at loads, looking for a memory reference
 753 // with the largest number of references similar to it.
<a name="7" id="anc7"></a><span class="line-modified"> 754 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops) {</span>
 755   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 756 
 757   // Count number of comparable memory ops
 758   for (uint i = 0; i &lt; memops.size(); i++) {
 759     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 760     SWPointer p1(s1, this, NULL, false);
 761     // Discard if pre loop can&#39;t align this reference
 762     if (!ref_is_alignable(p1)) {
 763       *cmp_ct.adr_at(i) = 0;
 764       continue;
 765     }
 766     for (uint j = i+1; j &lt; memops.size(); j++) {
 767       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 768       if (isomorphic(s1, s2)) {
 769         SWPointer p2(s2, this, NULL, false);
 770         if (p1.comparable(p2)) {
 771           (*cmp_ct.adr_at(i))++;
 772           (*cmp_ct.adr_at(j))++;
 773         }
 774       }
 775     }
 776   }
 777 
 778   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 779   // biggest vector size, smallest data size and smallest iv offset.
 780   int max_ct        = 0;
 781   int max_vw        = 0;
 782   int max_idx       = -1;
 783   int min_size      = max_jint;
 784   int min_iv_offset = max_jint;
 785   for (uint j = 0; j &lt; memops.size(); j++) {
 786     MemNode* s = memops.at(j)-&gt;as_Mem();
 787     if (s-&gt;is_Store()) {
 788       int vw = vector_width_in_bytes(s);
 789       assert(vw &gt; 1, &quot;sanity&quot;);
 790       SWPointer p(s, this, NULL, false);
 791       if ( cmp_ct.at(j) &gt;  max_ct ||
 792           (cmp_ct.at(j) == max_ct &amp;&amp;
 793             ( vw &gt;  max_vw ||
 794              (vw == max_vw &amp;&amp;
 795               ( data_size(s) &lt;  min_size ||
 796                (data_size(s) == min_size &amp;&amp;
 797                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 798         max_ct = cmp_ct.at(j);
 799         max_vw = vw;
 800         max_idx = j;
 801         min_size = data_size(s);
 802         min_iv_offset = p.offset_in_bytes();
 803       }
 804     }
 805   }
 806   // If no stores, look at loads
 807   if (max_ct == 0) {
 808     for (uint j = 0; j &lt; memops.size(); j++) {
 809       MemNode* s = memops.at(j)-&gt;as_Mem();
 810       if (s-&gt;is_Load()) {
 811         int vw = vector_width_in_bytes(s);
 812         assert(vw &gt; 1, &quot;sanity&quot;);
 813         SWPointer p(s, this, NULL, false);
 814         if ( cmp_ct.at(j) &gt;  max_ct ||
 815             (cmp_ct.at(j) == max_ct &amp;&amp;
 816               ( vw &gt;  max_vw ||
 817                (vw == max_vw &amp;&amp;
 818                 ( data_size(s) &lt;  min_size ||
 819                  (data_size(s) == min_size &amp;&amp;
 820                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 821           max_ct = cmp_ct.at(j);
 822           max_vw = vw;
 823           max_idx = j;
 824           min_size = data_size(s);
 825           min_iv_offset = p.offset_in_bytes();
 826         }
 827       }
 828     }
 829   }
 830 
 831 #ifdef ASSERT
 832   if (TraceSuperWord &amp;&amp; Verbose) {
 833     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 834     for (uint i = 0; i &lt; memops.size(); i++) {
 835       MemNode* s = memops.at(i)-&gt;as_Mem();
 836       s-&gt;dump();
 837     }
 838   }
 839 #endif
 840 
<a name="8" id="anc8"></a>
 841   if (max_ct &gt; 0) {
 842 #ifdef ASSERT
 843     if (TraceSuperWord) {
 844       tty-&gt;print(&quot;\nVector align to node: &quot;);
 845       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 846     }
 847 #endif
 848     return memops.at(max_idx)-&gt;as_Mem();
 849   }
 850   return NULL;
 851 }
 852 
 853 //------------------span_works_for_memory_size-----------------------------
 854 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 855   bool span_matches_memory = false;
 856   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 857     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 858     // There is a mismatch on span size compared to memory.
 859     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 860       Node* use = mem-&gt;fast_out(j);
 861       if (!VectorNode::is_type_transition_to_int(use)) {
 862         return false;
 863       }
 864     }
 865     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 866     return true;
 867   }
 868   else {
 869     span_matches_memory = ABS(span) == mem_size;
 870   }
 871   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 872 }
 873 
 874 //------------------------------ref_is_alignable---------------------------
 875 // Can the preloop align the reference to position zero in the vector?
 876 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 877   if (!p.has_iv()) {
 878     return true;   // no induction variable
 879   }
 880   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 881   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 882   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 883   int preloop_stride = pre_end-&gt;stride_con();
 884 
 885   int span = preloop_stride * p.scale_in_bytes();
 886   int mem_size = p.memory_size();
 887   int offset   = p.offset_in_bytes();
 888   // Stride one accesses are alignable if offset is aligned to memory operation size.
 889   // Offset can be unaligned when UseUnalignedAccesses is used.
 890   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 891     return true;
 892   }
 893   // If the initial offset from start of the object is computable,
 894   // check if the pre-loop can align the final offset accordingly.
 895   //
 896   // In other words: Can we find an i such that the offset
 897   // after i pre-loop iterations is aligned to vw?
 898   //   (init_offset + pre_loop) % vw == 0              (1)
 899   // where
 900   //   pre_loop = i * span
 901   // is the number of bytes added to the offset by i pre-loop iterations.
 902   //
 903   // For this to hold we need pre_loop to increase init_offset by
 904   //   pre_loop = vw - (init_offset % vw)
 905   //
 906   // This is only possible if pre_loop is divisible by span because each
 907   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 908   //   (vw - (init_offset % vw)) % span == 0
 909   //
 910   int vw = vector_width_in_bytes(p.mem());
 911   assert(vw &gt; 1, &quot;sanity&quot;);
 912   Node* init_nd = pre_end-&gt;init_trip();
 913   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 914     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 915     int init_offset = init * p.scale_in_bytes() + offset;
 916     if (init_offset &lt; 0) { // negative offset from object start?
 917       return false;        // may happen in dead loop
 918     }
 919     if (vw % span == 0) {
 920       // If vm is a multiple of span, we use formula (1).
 921       if (span &gt; 0) {
 922         return (vw - (init_offset % vw)) % span == 0;
 923       } else {
 924         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 925         return (init_offset % vw) % -span == 0;
 926       }
 927     } else if (span % vw == 0) {
 928       // If span is a multiple of vw, we can simplify formula (1) to:
 929       //   (init_offset + i * span) % vw == 0
 930       //     =&gt;
 931       //   (init_offset % vw) + ((i * span) % vw) == 0
 932       //     =&gt;
 933       //   init_offset % vw == 0
 934       //
 935       // Because we add a multiple of vw to the initial offset, the final
 936       // offset is a multiple of vw if and only if init_offset is a multiple.
 937       //
 938       return (init_offset % vw) == 0;
 939     }
 940   }
 941   return false;
 942 }
 943 //---------------------------get_vw_bytes_special------------------------
 944 int SuperWord::get_vw_bytes_special(MemNode* s) {
 945   // Get the vector width in bytes.
 946   int vw = vector_width_in_bytes(s);
 947 
 948   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 949   BasicType btype = velt_basic_type(s);
 950   if (type2aelembytes(btype) == 2) {
 951     bool should_combine_adjacent = true;
 952     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 953       Node* user = s-&gt;fast_out(i);
 954       if (!VectorNode::is_muladds2i(user)) {
 955         should_combine_adjacent = false;
 956       }
 957     }
 958     if (should_combine_adjacent) {
 959       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 960     }
 961   }
 962 
 963   return vw;
 964 }
 965 
 966 //---------------------------get_iv_adjustment---------------------------
 967 // Calculate loop&#39;s iv adjustment for this memory ops.
 968 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 969   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 970   int offset = align_to_ref_p.offset_in_bytes();
 971   int scale  = align_to_ref_p.scale_in_bytes();
 972   int elt_size = align_to_ref_p.memory_size();
 973   int vw       = get_vw_bytes_special(mem_ref);
 974   assert(vw &gt; 1, &quot;sanity&quot;);
 975   int iv_adjustment;
 976   if (scale != 0) {
 977     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 978     // At least one iteration is executed in pre-loop by default. As result
 979     // several iterations are needed to align memory operations in main-loop even
 980     // if offset is 0.
 981     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
 982     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),
 983            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
 984     iv_adjustment = iv_adjustment_in_bytes/elt_size;
 985   } else {
 986     // This memory op is not dependent on iv (scale == 0)
 987     iv_adjustment = 0;
 988   }
 989 
 990 #ifndef PRODUCT
 991   if (TraceSuperWord) {
 992     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
 993       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
 994     mem_ref-&gt;dump();
 995   }
 996 #endif
 997   return iv_adjustment;
 998 }
 999 
1000 //---------------------------dependence_graph---------------------------
1001 // Construct dependency graph.
1002 // Add dependence edges to load/store nodes for memory dependence
1003 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1004 void SuperWord::dependence_graph() {
1005   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1006   // First, assign a dependence node to each memory node
1007   for (int i = 0; i &lt; _block.length(); i++ ) {
1008     Node *n = _block.at(i);
1009     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1010       _dg.make_node(n);
1011     }
1012   }
1013 
1014   // For each memory slice, create the dependences
1015   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1016     Node* n      = _mem_slice_head.at(i);
1017     Node* n_tail = _mem_slice_tail.at(i);
1018 
1019     // Get slice in predecessor order (last is first)
1020     if (cl-&gt;is_main_loop()) {
1021       mem_slice_preds(n_tail, n, _nlist);
1022     }
1023 
1024 #ifndef PRODUCT
1025     if(TraceSuperWord &amp;&amp; Verbose) {
1026       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1027       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1028         _nlist.at(j)-&gt;dump();
1029       }
1030     }
1031 #endif
1032     // Make the slice dependent on the root
1033     DepMem* slice = _dg.dep(n);
1034     _dg.make_edge(_dg.root(), slice);
1035 
1036     // Create a sink for the slice
1037     DepMem* slice_sink = _dg.make_node(NULL);
1038     _dg.make_edge(slice_sink, _dg.tail());
1039 
1040     // Now visit each pair of memory ops, creating the edges
1041     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1042       Node* s1 = _nlist.at(j);
1043 
1044       // If no dependency yet, use slice
1045       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1046         _dg.make_edge(slice, s1);
1047       }
1048       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1049       bool sink_dependent = true;
1050       for (int k = j - 1; k &gt;= 0; k--) {
1051         Node* s2 = _nlist.at(k);
1052         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1053           continue;
1054         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1055 
1056         int cmp = p1.cmp(p2);
1057         if (SuperWordRTDepCheck &amp;&amp;
1058             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1059           // Create a runtime check to disambiguate
1060           OrderedPair pp(p1.base(), p2.base());
1061           _disjoint_ptrs.append_if_missing(pp);
1062         } else if (!SWPointer::not_equal(cmp)) {
1063           // Possibly same address
1064           _dg.make_edge(s1, s2);
1065           sink_dependent = false;
1066         }
1067       }
1068       if (sink_dependent) {
1069         _dg.make_edge(s1, slice_sink);
1070       }
1071     }
1072 
1073     if (TraceSuperWord) {
1074       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1075       for (int q = 0; q &lt; _nlist.length(); q++) {
1076         _dg.print(_nlist.at(q));
1077       }
1078       tty-&gt;cr();
1079     }
1080 
1081     _nlist.clear();
1082   }
1083 
1084   if (TraceSuperWord) {
1085     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1086     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1087       _disjoint_ptrs.at(r).print();
1088       tty-&gt;cr();
1089     }
1090     tty-&gt;cr();
1091   }
1092 
1093 }
1094 
1095 //---------------------------mem_slice_preds---------------------------
1096 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1097 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1098   assert(preds.length() == 0, &quot;start empty&quot;);
1099   Node* n = start;
1100   Node* prev = NULL;
1101   while (true) {
1102     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1103     assert(in_bb(n), &quot;must be in block&quot;);
1104     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1105       Node* out = n-&gt;fast_out(i);
1106       if (out-&gt;is_Load()) {
1107         if (in_bb(out)) {
1108           preds.push(out);
1109           if (TraceSuperWord &amp;&amp; Verbose) {
1110             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1111           }
1112         }
1113       } else {
1114         // FIXME
1115         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1116           // Either unrolling is causing a memory edge not to disappear,
1117           // or need to run igvn.optimize() again before SLP
1118         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1119           // Ditto.  Not sure what else to check further.
1120         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1121           // StoreCM has an input edge used as a precedence edge.
1122           // Maybe an issue when oop stores are vectorized.
1123         } else {
1124           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1125         }
1126       }//else
1127     }//for
1128     if (n == stop) break;
1129     preds.push(n);
1130     if (TraceSuperWord &amp;&amp; Verbose) {
1131       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1132     }
1133     prev = n;
1134     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1135     n = n-&gt;in(MemNode::Memory);
1136   }
1137 }
1138 
1139 //------------------------------stmts_can_pack---------------------------
1140 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1141 // s1 aligned at &quot;align&quot;
1142 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1143 
1144   // Do not use superword for non-primitives
1145   BasicType bt1 = velt_basic_type(s1);
1146   BasicType bt2 = velt_basic_type(s2);
1147   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1148     return false;
1149   if (Matcher::max_vector_size(bt1) &lt; 2) {
1150     return false; // No vectors for this type
1151   }
1152 
1153   if (isomorphic(s1, s2)) {
1154     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1155       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1156         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1157           int s1_align = alignment(s1);
1158           int s2_align = alignment(s2);
1159           if (s1_align == top_align || s1_align == align) {
1160             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1161               return true;
1162             }
1163           }
1164         }
1165       }
1166     }
1167   }
1168   return false;
1169 }
1170 
1171 //------------------------------exists_at---------------------------
1172 // Does s exist in a pack at position pos?
1173 bool SuperWord::exists_at(Node* s, uint pos) {
1174   for (int i = 0; i &lt; _packset.length(); i++) {
1175     Node_List* p = _packset.at(i);
1176     if (p-&gt;at(pos) == s) {
1177       return true;
1178     }
1179   }
1180   return false;
1181 }
1182 
1183 //------------------------------are_adjacent_refs---------------------------
1184 // Is s1 immediately before s2 in memory?
1185 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1186   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1187   if (!in_bb(s1)    || !in_bb(s2))    return false;
1188 
1189   // Do not use superword for non-primitives
1190   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1191       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1192     return false;
1193   }
1194 
1195   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1196   // only pack memops that are in the same alias set until that&#39;s fixed.
1197   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1198       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1199     return false;
1200   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1201   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1202   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1203   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1204   return diff == data_size(s1);
1205 }
1206 
1207 //------------------------------isomorphic---------------------------
1208 // Are s1 and s2 similar?
1209 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1210   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1211   if (s1-&gt;req() != s2-&gt;req()) return false;
1212   if (!same_velt_type(s1, s2)) return false;
1213   Node* s1_ctrl = s1-&gt;in(0);
1214   Node* s2_ctrl = s2-&gt;in(0);
1215   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1216   if (s1_ctrl == s2_ctrl) {
1217     return true;
1218   } else {
1219     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1220     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1221     // If the control nodes are not invariant for the loop, fail isomorphism test.
1222     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1223       return false;
1224     }
1225     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1226       if (s1_ctrl-&gt;is_Proj()) {
1227         s1_ctrl = s1_ctrl-&gt;in(0);
1228         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1229       }
1230       if (s2_ctrl-&gt;is_Proj()) {
1231         s2_ctrl = s2_ctrl-&gt;in(0);
1232         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1233       }
1234       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1235         return false;
1236       }
1237     }
1238     // Control nodes are invariant. However, we have no way of checking whether they resolve
1239     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1240     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1241     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1242     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1243       Node* t1 = s1-&gt;fast_out(i);
1244       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1245         Node* t2 = s2-&gt;fast_out(j);
1246         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1247           return true;
1248         }
1249       }
1250     }
1251   }
1252   return false;
1253 }
1254 
1255 //------------------------------independent---------------------------
1256 // Is there no data path from s1 to s2 or s2 to s1?
1257 bool SuperWord::independent(Node* s1, Node* s2) {
1258   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1259   int d1 = depth(s1);
1260   int d2 = depth(s2);
1261   if (d1 == d2) return s1 != s2;
1262   Node* deep    = d1 &gt; d2 ? s1 : s2;
1263   Node* shallow = d1 &gt; d2 ? s2 : s1;
1264 
1265   visited_clear();
1266 
1267   return independent_path(shallow, deep);
1268 }
1269 
1270 //--------------------------have_similar_inputs-----------------------
1271 // For a node pair (s1, s2) which is isomorphic and independent,
1272 // do s1 and s2 have similar input edges?
1273 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1274   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1275   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1276   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1277     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1278       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1279     }
1280   }
1281   return true;
1282 }
1283 
1284 //------------------------------reduction---------------------------
1285 // Is there a data path between s1 and s2 and the nodes reductions?
1286 bool SuperWord::reduction(Node* s1, Node* s2) {
1287   bool retValue = false;
1288   int d1 = depth(s1);
1289   int d2 = depth(s2);
1290   if (d1 + 1 == d2) {
1291     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1292       // This is an ordered set, so s1 should define s2
1293       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1294         Node* t1 = s1-&gt;fast_out(i);
1295         if (t1 == s2) {
1296           // both nodes are reductions and connected
1297           retValue = true;
1298         }
1299       }
1300     }
1301   }
1302 
1303   return retValue;
1304 }
1305 
1306 //------------------------------independent_path------------------------------
1307 // Helper for independent
1308 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1309   if (dp &gt;= 1000) return false; // stop deep recursion
1310   visited_set(deep);
1311   int shal_depth = depth(shallow);
1312   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1313   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1314     Node* pred = preds.current();
1315     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1316       if (shallow == pred) {
1317         return false;
1318       }
1319       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1320         return false;
1321       }
1322     }
1323   }
1324   return true;
1325 }
1326 
1327 //------------------------------set_alignment---------------------------
1328 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1329   set_alignment(s1, align);
1330   if (align == top_align || align == bottom_align) {
1331     set_alignment(s2, align);
1332   } else {
1333     set_alignment(s2, align + data_size(s1));
1334   }
1335 }
1336 
1337 //------------------------------data_size---------------------------
1338 int SuperWord::data_size(Node* s) {
1339   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1340   if (UseVectorCmov) {
1341     use = _cmovev_kit.is_Bool_candidate(s);
1342     if (use != NULL) {
1343       return data_size(use);
1344     }
1345     use = _cmovev_kit.is_CmpD_candidate(s);
1346     if (use != NULL) {
1347       return data_size(use);
1348     }
1349   }
1350 
1351   int bsize = type2aelembytes(velt_basic_type(s));
1352   assert(bsize != 0, &quot;valid size&quot;);
1353   return bsize;
1354 }
1355 
1356 //------------------------------extend_packlist---------------------------
1357 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1358 void SuperWord::extend_packlist() {
1359   bool changed;
1360   do {
1361     packset_sort(_packset.length());
1362     changed = false;
1363     for (int i = 0; i &lt; _packset.length(); i++) {
1364       Node_List* p = _packset.at(i);
1365       changed |= follow_use_defs(p);
1366       changed |= follow_def_uses(p);
1367     }
1368   } while (changed);
1369 
1370   if (_race_possible) {
1371     for (int i = 0; i &lt; _packset.length(); i++) {
1372       Node_List* p = _packset.at(i);
1373       order_def_uses(p);
1374     }
1375   }
1376 
1377   if (TraceSuperWord) {
1378     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1379     print_packset();
1380   }
1381 }
1382 
1383 //------------------------------follow_use_defs---------------------------
1384 // Extend the packset by visiting operand definitions of nodes in pack p
1385 bool SuperWord::follow_use_defs(Node_List* p) {
1386   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1387   Node* s1 = p-&gt;at(0);
1388   Node* s2 = p-&gt;at(1);
1389   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1390   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1391 
1392   if (s1-&gt;is_Load()) return false;
1393 
1394   int align = alignment(s1);
1395   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1396   bool changed = false;
1397   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1398   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1399   for (int j = start; j &lt; end; j++) {
1400     Node* t1 = s1-&gt;in(j);
1401     Node* t2 = s2-&gt;in(j);
1402     if (!in_bb(t1) || !in_bb(t2))
1403       continue;
1404     if (stmts_can_pack(t1, t2, align)) {
1405       if (est_savings(t1, t2) &gt;= 0) {
1406         Node_List* pair = new Node_List();
1407         pair-&gt;push(t1);
1408         pair-&gt;push(t2);
1409         _packset.append(pair);
1410         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1411         set_alignment(t1, t2, align);
1412         changed = true;
1413       }
1414     }
1415   }
1416   return changed;
1417 }
1418 
1419 //------------------------------follow_def_uses---------------------------
1420 // Extend the packset by visiting uses of nodes in pack p
1421 bool SuperWord::follow_def_uses(Node_List* p) {
1422   bool changed = false;
1423   Node* s1 = p-&gt;at(0);
1424   Node* s2 = p-&gt;at(1);
1425   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1426   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1427   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1428 
1429   if (s1-&gt;is_Store()) return false;
1430 
1431   int align = alignment(s1);
1432   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1433   int savings = -1;
1434   int num_s1_uses = 0;
1435   Node* u1 = NULL;
1436   Node* u2 = NULL;
1437   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1438     Node* t1 = s1-&gt;fast_out(i);
1439     num_s1_uses++;
1440     if (!in_bb(t1)) continue;
1441     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1442       Node* t2 = s2-&gt;fast_out(j);
1443       if (!in_bb(t2)) continue;
1444       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1445       if (!opnd_positions_match(s1, t1, s2, t2))
1446         continue;
1447       if (stmts_can_pack(t1, t2, align)) {
1448         int my_savings = est_savings(t1, t2);
1449         if (my_savings &gt; savings) {
1450           savings = my_savings;
1451           u1 = t1;
1452           u2 = t2;
1453         }
1454       }
1455     }
1456   }
1457   if (num_s1_uses &gt; 1) {
1458     _race_possible = true;
1459   }
1460   if (savings &gt;= 0) {
1461     Node_List* pair = new Node_List();
1462     pair-&gt;push(u1);
1463     pair-&gt;push(u2);
1464     _packset.append(pair);
1465     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1466     set_alignment(u1, u2, align);
1467     changed = true;
1468   }
1469   return changed;
1470 }
1471 
1472 //------------------------------order_def_uses---------------------------
1473 // For extended packsets, ordinally arrange uses packset by major component
1474 void SuperWord::order_def_uses(Node_List* p) {
1475   Node* s1 = p-&gt;at(0);
1476 
1477   if (s1-&gt;is_Store()) return;
1478 
1479   // reductions are always managed beforehand
1480   if (s1-&gt;is_reduction()) return;
1481 
1482   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1483     Node* t1 = s1-&gt;fast_out(i);
1484 
1485     // Only allow operand swap on commuting operations
1486     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1487       break;
1488     }
1489 
1490     // Now find t1&#39;s packset
1491     Node_List* p2 = NULL;
1492     for (int j = 0; j &lt; _packset.length(); j++) {
1493       p2 = _packset.at(j);
1494       Node* first = p2-&gt;at(0);
1495       if (t1 == first) {
1496         break;
1497       }
1498       p2 = NULL;
1499     }
1500     // Arrange all sub components by the major component
1501     if (p2 != NULL) {
1502       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1503         Node* d1 = p-&gt;at(j);
1504         Node* u1 = p2-&gt;at(j);
1505         opnd_positions_match(s1, t1, d1, u1);
1506       }
1507     }
1508   }
1509 }
1510 
1511 //---------------------------opnd_positions_match-------------------------
1512 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1513 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1514   // check reductions to see if they are marshalled to represent the reduction
1515   // operator in a specified opnd
1516   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1517     // ensure reductions have phis and reduction definitions feeding the 1st operand
1518     Node* first = u1-&gt;in(2);
1519     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1520       u1-&gt;swap_edges(1, 2);
1521     }
1522     // ensure reductions have phis and reduction definitions feeding the 1st operand
1523     first = u2-&gt;in(2);
1524     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1525       u2-&gt;swap_edges(1, 2);
1526     }
1527     return true;
1528   }
1529 
1530   uint ct = u1-&gt;req();
1531   if (ct != u2-&gt;req()) return false;
1532   uint i1 = 0;
1533   uint i2 = 0;
1534   do {
1535     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1536     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1537     if (i1 != i2) {
1538       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1539         // Further analysis relies on operands position matching.
1540         u2-&gt;swap_edges(i1, i2);
1541       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1542         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1543           u2-&gt;swap_edges(1, 2);
1544           u2-&gt;swap_edges(3, 4);
1545         }
1546         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1547           u2-&gt;swap_edges(2, 3);
1548           u2-&gt;swap_edges(1, 4);
1549         }
1550         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1551       } else {
1552         return false;
1553       }
1554     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1555       u2-&gt;swap_edges(1, 3);
1556       u2-&gt;swap_edges(2, 4);
1557       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1558     }
1559   } while (i1 &lt; ct);
1560   return true;
1561 }
1562 
1563 //------------------------------est_savings---------------------------
1564 // Estimate the savings from executing s1 and s2 as a pack
1565 int SuperWord::est_savings(Node* s1, Node* s2) {
1566   int save_in = 2 - 1; // 2 operations per instruction in packed form
1567 
1568   // inputs
1569   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1570     Node* x1 = s1-&gt;in(i);
1571     Node* x2 = s2-&gt;in(i);
1572     if (x1 != x2) {
1573       if (are_adjacent_refs(x1, x2)) {
1574         save_in += adjacent_profit(x1, x2);
1575       } else if (!in_packset(x1, x2)) {
1576         save_in -= pack_cost(2);
1577       } else {
1578         save_in += unpack_cost(2);
1579       }
1580     }
1581   }
1582 
1583   // uses of result
1584   uint ct = 0;
1585   int save_use = 0;
1586   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1587     Node* s1_use = s1-&gt;fast_out(i);
1588     for (int j = 0; j &lt; _packset.length(); j++) {
1589       Node_List* p = _packset.at(j);
1590       if (p-&gt;at(0) == s1_use) {
1591         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1592           Node* s2_use = s2-&gt;fast_out(k);
1593           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1594             ct++;
1595             if (are_adjacent_refs(s1_use, s2_use)) {
1596               save_use += adjacent_profit(s1_use, s2_use);
1597             }
1598           }
1599         }
1600       }
1601     }
1602   }
1603 
1604   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1605   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1606 
1607   return MAX2(save_in, save_use);
1608 }
1609 
1610 //------------------------------costs---------------------------
1611 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1612 int SuperWord::pack_cost(int ct)   { return ct; }
1613 int SuperWord::unpack_cost(int ct) { return ct; }
1614 
1615 //------------------------------combine_packs---------------------------
1616 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1617 void SuperWord::combine_packs() {
1618   bool changed = true;
1619   // Combine packs regardless max vector size.
1620   while (changed) {
1621     changed = false;
1622     for (int i = 0; i &lt; _packset.length(); i++) {
1623       Node_List* p1 = _packset.at(i);
1624       if (p1 == NULL) continue;
1625       // Because of sorting we can start at i + 1
1626       for (int j = i + 1; j &lt; _packset.length(); j++) {
1627         Node_List* p2 = _packset.at(j);
1628         if (p2 == NULL) continue;
1629         if (i == j) continue;
1630         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1631           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1632             p1-&gt;push(p2-&gt;at(k));
1633           }
1634           _packset.at_put(j, NULL);
1635           changed = true;
1636         }
1637       }
1638     }
1639   }
1640 
1641   // Split packs which have size greater then max vector size.
1642   for (int i = 0; i &lt; _packset.length(); i++) {
1643     Node_List* p1 = _packset.at(i);
1644     if (p1 != NULL) {
1645       BasicType bt = velt_basic_type(p1-&gt;at(0));
1646       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1647       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1648       uint psize = p1-&gt;size();
1649       if (!is_power_of_2(psize)) {
1650         // Skip pack which can&#39;t be vector.
1651         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1652         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1653         _packset.at_put(i, NULL);
1654         continue;
1655       }
1656       if (psize &gt; max_vlen) {
1657         Node_List* pack = new Node_List();
1658         for (uint j = 0; j &lt; psize; j++) {
1659           pack-&gt;push(p1-&gt;at(j));
1660           if (pack-&gt;size() &gt;= max_vlen) {
1661             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1662             _packset.append(pack);
1663             pack = new Node_List();
1664           }
1665         }
1666         _packset.at_put(i, NULL);
1667       }
1668     }
1669   }
1670 
1671   // Compress list.
1672   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1673     Node_List* p1 = _packset.at(i);
1674     if (p1 == NULL) {
1675       _packset.remove_at(i);
1676     }
1677   }
1678 
1679   if (TraceSuperWord) {
1680     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1681     print_packset();
1682   }
1683 }
1684 
1685 //-----------------------------construct_my_pack_map--------------------------
1686 // Construct the map from nodes to packs.  Only valid after the
1687 // point where a node is only in one pack (after combine_packs).
1688 void SuperWord::construct_my_pack_map() {
1689   Node_List* rslt = NULL;
1690   for (int i = 0; i &lt; _packset.length(); i++) {
1691     Node_List* p = _packset.at(i);
1692     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1693       Node* s = p-&gt;at(j);
1694       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1695       set_my_pack(s, p);
1696     }
1697   }
1698 }
1699 
1700 //------------------------------filter_packs---------------------------
1701 // Remove packs that are not implemented or not profitable.
1702 void SuperWord::filter_packs() {
1703   // Remove packs that are not implemented
1704   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1705     Node_List* pk = _packset.at(i);
1706     bool impl = implemented(pk);
1707     if (!impl) {
1708 #ifndef PRODUCT
1709       if (TraceSuperWord &amp;&amp; Verbose) {
1710         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1711         pk-&gt;at(0)-&gt;dump();
1712       }
1713 #endif
1714       remove_pack_at(i);
1715     }
1716     Node *n = pk-&gt;at(0);
1717     if (n-&gt;is_reduction()) {
1718       _num_reductions++;
1719     } else {
1720       _num_work_vecs++;
1721     }
1722   }
1723 
1724   // Remove packs that are not profitable
1725   bool changed;
1726   do {
1727     changed = false;
1728     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1729       Node_List* pk = _packset.at(i);
1730       bool prof = profitable(pk);
1731       if (!prof) {
1732 #ifndef PRODUCT
1733         if (TraceSuperWord &amp;&amp; Verbose) {
1734           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1735           pk-&gt;at(0)-&gt;dump();
1736         }
1737 #endif
1738         remove_pack_at(i);
1739         changed = true;
1740       }
1741     }
1742   } while (changed);
1743 
1744 #ifndef PRODUCT
1745   if (TraceSuperWord) {
1746     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1747     print_packset();
1748     tty-&gt;cr();
1749   }
1750 #endif
1751 }
1752 
1753 //------------------------------merge_packs_to_cmovd---------------------------
1754 // Merge CMoveD into new vector-nodes
1755 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1756 //
1757 //                   SubD             ConD
1758 //                  /  |               /
1759 //                 /   |           /   /
1760 //                /    |       /      /
1761 //               /     |   /         /
1762 //              /      /            /
1763 //             /    /  |           /
1764 //            v /      |          /
1765 //         CmpD        |         /
1766 //          |          |        /
1767 //          v          |       /
1768 //         Bool        |      /
1769 //           \         |     /
1770 //             \       |    /
1771 //               \     |   /
1772 //                 \   |  /
1773 //                   \ v /
1774 //                   CMoveD
1775 //
1776 
1777 void SuperWord::merge_packs_to_cmovd() {
1778   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1779     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1780   }
1781   #ifndef PRODUCT
1782     if (TraceSuperWord) {
1783       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1784       print_packset();
1785       tty-&gt;cr();
1786     }
1787   #endif
1788 }
1789 
1790 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1791   Node* use = NULL;
1792   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1793     return NULL;
1794   }
1795   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1796     use = def-&gt;fast_out(j);
1797     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1798       return NULL;
1799     }
1800   }
1801   return use;
1802 }
1803 
1804 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1805   Node* use = NULL;
1806   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1807     return NULL;
1808   }
1809   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1810     use = def-&gt;fast_out(j);
1811     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1812       return NULL;
1813     }
1814   }
1815   return use;
1816 }
1817 
1818 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1819   Node *cmovd = cmovd_pk-&gt;at(0);
1820   if (!cmovd-&gt;is_CMove()) {
1821     return NULL;
1822   }
1823   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1824     return NULL;
1825   }
1826   if (pack(cmovd) != NULL) { // already in the cmov pack
1827     return NULL;
1828   }
1829   if (cmovd-&gt;in(0) != NULL) {
1830     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1831     return NULL;
1832   }
1833 
1834   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1835   if (!bol-&gt;is_Bool()
1836       || bol-&gt;outcnt() != 1
1837       || !_sw-&gt;same_generation(bol, cmovd)
1838       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1839       || _sw-&gt;my_pack(bol) == NULL) {
1840       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1841       return NULL;
1842   }
1843   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1844   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1845     return NULL;
1846   }
1847 
1848   Node* cmpd = bol-&gt;in(1);
1849   if (!cmpd-&gt;is_Cmp()
1850       || cmpd-&gt;outcnt() != 1
1851       || !_sw-&gt;same_generation(cmpd, cmovd)
1852       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1853       || _sw-&gt;my_pack(cmpd) == NULL) {
1854       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1855       return NULL;
1856   }
1857   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1858   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1859     return NULL;
1860   }
1861 
1862   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1863     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1864     return NULL;
1865   }
1866 
1867   Node_List* new_cmpd_pk = new Node_List();
1868   uint sz = cmovd_pk-&gt;size() - 1;
1869   for (uint i = 0; i &lt;= sz; ++i) {
1870     Node* cmov = cmovd_pk-&gt;at(i);
1871     Node* bol  = bool_pk-&gt;at(i);
1872     Node* cmp  = cmpd_pk-&gt;at(i);
1873 
1874     new_cmpd_pk-&gt;insert(i, cmov);
1875 
1876     map(cmov, new_cmpd_pk);
1877     map(bol, new_cmpd_pk);
1878     map(cmp, new_cmpd_pk);
1879 
1880     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1881   }
1882   _sw-&gt;_packset.remove(cmovd_pk);
1883   _sw-&gt;_packset.remove(bool_pk);
1884   _sw-&gt;_packset.remove(cmpd_pk);
1885   _sw-&gt;_packset.append(new_cmpd_pk);
1886   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1887   return new_cmpd_pk;
1888 }
1889 
1890 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1891   Node* cmpd0 = cmpd_pk-&gt;at(0);
1892   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1893   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1894   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1895   Node* in1 = cmpd0-&gt;in(1);
1896   Node* in2 = cmpd0-&gt;in(2);
1897   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1898   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1899 
1900   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1901      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1902     return false;
1903   }
1904 
1905   // test if &quot;all&quot; in1 are in the same pack or the same node
1906   if (in1_pk == NULL) {
1907     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1908       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1909         return false;
1910       }
1911     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1912   }
1913   // test if &quot;all&quot; in2 are in the same pack or the same node
1914   if (in2_pk == NULL) {
1915     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1916       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1917         return false;
1918       }
1919     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1920   }
1921   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1922   int cmovd_ind1, cmovd_ind2;
1923   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1924    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1925       cmovd_ind1 = CMoveNode::IfFalse;
1926       cmovd_ind2 = CMoveNode::IfTrue;
1927   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1928           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1929       cmovd_ind2 = CMoveNode::IfFalse;
1930       cmovd_ind1 = CMoveNode::IfTrue;
1931   }
1932   else {
1933     return false;
1934   }
1935 
1936   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1937     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1938         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1939         return false;
1940     }//if
1941   }
1942   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1943   return true;
1944 }
1945 
1946 //------------------------------implemented---------------------------
1947 // Can code be generated for pack p?
1948 bool SuperWord::implemented(Node_List* p) {
1949   bool retValue = false;
1950   Node* p0 = p-&gt;at(0);
1951   if (p0 != NULL) {
1952     int opc = p0-&gt;Opcode();
1953     uint size = p-&gt;size();
1954     if (p0-&gt;is_reduction()) {
1955       const Type *arith_type = p0-&gt;bottom_type();
1956       // Length 2 reductions of INT/LONG do not offer performance benefits
1957       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1958         retValue = false;
1959       } else {
1960         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1961       }
1962     } else {
1963       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1964     }
1965     if (!retValue) {
1966       if (is_cmov_pack(p)) {
1967         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1968         return true;
1969       }
1970     }
1971   }
1972   return retValue;
1973 }
1974 
1975 bool SuperWord::is_cmov_pack(Node_List* p) {
1976   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1977 }
1978 //------------------------------same_inputs--------------------------
1979 // For pack p, are all idx operands the same?
1980 bool SuperWord::same_inputs(Node_List* p, int idx) {
1981   Node* p0 = p-&gt;at(0);
1982   uint vlen = p-&gt;size();
1983   Node* p0_def = p0-&gt;in(idx);
1984   for (uint i = 1; i &lt; vlen; i++) {
1985     Node* pi = p-&gt;at(i);
1986     Node* pi_def = pi-&gt;in(idx);
1987     if (p0_def != pi_def) {
1988       return false;
1989     }
1990   }
1991   return true;
1992 }
1993 
1994 //------------------------------profitable---------------------------
1995 // For pack p, are all operands and all uses (with in the block) vector?
1996 bool SuperWord::profitable(Node_List* p) {
1997   Node* p0 = p-&gt;at(0);
1998   uint start, end;
1999   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2000 
2001   // Return false if some inputs are not vectors or vectors with different
2002   // size or alignment.
2003   // Also, for now, return false if not scalar promotion case when inputs are
2004   // the same. Later, implement PackNode and allow differing, non-vector inputs
2005   // (maybe just the ones from outside the block.)
2006   for (uint i = start; i &lt; end; i++) {
2007     if (!is_vector_use(p0, i)) {
2008       return false;
2009     }
2010   }
2011   // Check if reductions are connected
2012   if (p0-&gt;is_reduction()) {
2013     Node* second_in = p0-&gt;in(2);
2014     Node_List* second_pk = my_pack(second_in);
2015     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2016       // Remove reduction flag if no parent pack or if not enough work
2017       // to cover reduction expansion overhead
2018       p0-&gt;remove_flag(Node::Flag_is_reduction);
2019       return false;
2020     } else if (second_pk-&gt;size() != p-&gt;size()) {
2021       return false;
2022     }
2023   }
2024   if (VectorNode::is_shift(p0)) {
2025     // For now, return false if shift count is vector or not scalar promotion
2026     // case (different shift counts) because it is not supported yet.
2027     Node* cnt = p0-&gt;in(2);
2028     Node_List* cnt_pk = my_pack(cnt);
2029     if (cnt_pk != NULL)
2030       return false;
2031     if (!same_inputs(p, 2))
2032       return false;
2033   }
2034   if (!p0-&gt;is_Store()) {
2035     // For now, return false if not all uses are vector.
2036     // Later, implement ExtractNode and allow non-vector uses (maybe
2037     // just the ones outside the block.)
2038     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2039       Node* def = p-&gt;at(i);
2040       if (is_cmov_pack_internal_node(p, def)) {
2041         continue;
2042       }
2043       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2044         Node* use = def-&gt;fast_out(j);
2045         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2046           Node* n = use-&gt;in(k);
2047           if (def == n) {
<a name="9" id="anc9"></a><span class="line-modified">2048             // reductions should only have a Phi use at the the loop</span>
<span class="line-modified">2049             // head and out of loop uses</span>
2050             if (def-&gt;is_reduction() &amp;&amp;
2051                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
<a name="10" id="anc10"></a><span class="line-modified">2052                  !_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))))) {</span>
<span class="line-removed">2053               assert(i == p-&gt;size()-1, &quot;must be last element of the pack&quot;);</span>
2054               continue;
2055             }
2056             if (!is_vector_use(use, k)) {
2057               return false;
2058             }
2059           }
2060         }
2061       }
2062     }
2063   }
2064   return true;
2065 }
2066 
2067 //------------------------------schedule---------------------------
2068 // Adjust the memory graph for the packed operations
2069 void SuperWord::schedule() {
2070 
2071   // Co-locate in the memory graph the members of each memory pack
2072   for (int i = 0; i &lt; _packset.length(); i++) {
2073     co_locate_pack(_packset.at(i));
2074   }
2075 }
2076 
2077 //-------------------------------remove_and_insert-------------------
2078 // Remove &quot;current&quot; from its current position in the memory graph and insert
2079 // it after the appropriate insertion point (lip or uip).
2080 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2081                                   Node *uip, Unique_Node_List &amp;sched_before) {
2082   Node* my_mem = current-&gt;in(MemNode::Memory);
2083   bool sched_up = sched_before.member(current);
2084 
2085   // remove current_store from its current position in the memmory graph
2086   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2087     Node* use = current-&gt;out(i);
2088     if (use-&gt;is_Mem()) {
2089       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2090       if (use == prev) { // connect prev to my_mem
2091           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2092           --i; //deleted this edge; rescan position
2093       } else if (sched_before.member(use)) {
2094         if (!sched_up) { // Will be moved together with current
2095           _igvn.replace_input_of(use, MemNode::Memory, uip);
2096           --i; //deleted this edge; rescan position
2097         }
2098       } else {
2099         if (sched_up) { // Will be moved together with current
2100           _igvn.replace_input_of(use, MemNode::Memory, lip);
2101           --i; //deleted this edge; rescan position
2102         }
2103       }
2104     }
2105   }
2106 
2107   Node *insert_pt =  sched_up ?  uip : lip;
2108 
2109   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2110   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2111     Node* use = insert_pt-&gt;out(i);
2112     if (use-&gt;is_Mem()) {
2113       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2114       _igvn.replace_input_of(use, MemNode::Memory, current);
2115       --i; //deleted this edge; rescan position
2116     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2117       uint pos; //lip (lower insert point) must be the last one in the memory slice
2118       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2119         if (use-&gt;in(pos) == insert_pt) break;
2120       }
2121       _igvn.replace_input_of(use, pos, current);
2122       --i;
2123     }
2124   }
2125 
2126   //connect current to insert_pt
2127   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2128 }
2129 
2130 //------------------------------co_locate_pack----------------------------------
2131 // To schedule a store pack, we need to move any sandwiched memory ops either before
2132 // or after the pack, based upon dependence information:
2133 // (1) If any store in the pack depends on the sandwiched memory op, the
2134 //     sandwiched memory op must be scheduled BEFORE the pack;
2135 // (2) If a sandwiched memory op depends on any store in the pack, the
2136 //     sandwiched memory op must be scheduled AFTER the pack;
2137 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2138 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2139 //     scheduled before the pack, memB must also be scheduled before the pack;
2140 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2141 //     schedule this store AFTER the pack
2142 // (5) We know there is no dependence cycle, so there in no other case;
2143 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2144 //
2145 // To schedule a load pack, we use the memory state of either the first or the last load in
2146 // the pack, based on the dependence constraint.
2147 void SuperWord::co_locate_pack(Node_List* pk) {
2148   if (pk-&gt;at(0)-&gt;is_Store()) {
2149     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2150     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2151     Unique_Node_List schedule_before_pack;
2152     Unique_Node_List memops;
2153 
2154     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2155     MemNode* previous  = last;
2156     while (true) {
2157       assert(in_bb(current), &quot;stay in block&quot;);
2158       memops.push(previous);
2159       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2160         Node* use = current-&gt;out(i);
2161         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2162           memops.push(use);
2163       }
2164       if (current == first) break;
2165       previous = current;
2166       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2167     }
2168 
2169     // determine which memory operations should be scheduled before the pack
2170     for (uint i = 1; i &lt; memops.size(); i++) {
2171       Node *s1 = memops.at(i);
2172       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2173         for (uint j = 0; j&lt; i; j++) {
2174           Node *s2 = memops.at(j);
2175           if (!independent(s1, s2)) {
2176             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2177               schedule_before_pack.push(s1); // s1 must be scheduled before
2178               Node_List* mem_pk = my_pack(s1);
2179               if (mem_pk != NULL) {
2180                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2181                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2182                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2183                     schedule_before_pack.push(s);
2184                 }
2185               }
2186               break;
2187             }
2188           }
2189         }
2190       }
2191     }
2192 
2193     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2194     // Following code moves loads connected to upper_insert_pt below aliased stores.
2195     // Collect such loads here and reconnect them back to upper_insert_pt later.
2196     memops.clear();
2197     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2198       Node* use = upper_insert_pt-&gt;out(i);
2199       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2200         memops.push(use);
2201       }
2202     }
2203 
2204     MemNode* lower_insert_pt = last;
2205     previous                 = last; //previous store in pk
2206     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2207 
2208     // start scheduling from &quot;last&quot; to &quot;first&quot;
2209     while (true) {
2210       assert(in_bb(current), &quot;stay in block&quot;);
2211       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2212       Node* my_mem = current-&gt;in(MemNode::Memory);
2213 
2214       if (in_pack(current, pk)) {
2215         // Forward users of my memory state (except &quot;previous) to my input memory state
2216         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2217           Node* use = current-&gt;out(i);
2218           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2219             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2220             if (schedule_before_pack.member(use)) {
2221               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2222             } else {
2223               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2224             }
2225             --i; // deleted this edge; rescan position
2226           }
2227         }
2228         previous = current;
2229       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2230         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2231       }
2232 
2233       if (current == first) break;
2234       current = my_mem-&gt;as_Mem();
2235     } // end while
2236 
2237     // Reconnect loads back to upper_insert_pt.
2238     for (uint i = 0; i &lt; memops.size(); i++) {
2239       Node *ld = memops.at(i);
2240       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2241         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2242       }
2243     }
2244   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
2245     // all loads in the pack should have the same memory state. By default,
2246     // we use the memory state of the last load. However, if any load could
2247     // not be moved down due to the dependence constraint, we use the memory
2248     // state of the first load.
<a name="11" id="anc11"></a><span class="line-modified">2249     Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2250     Node* last_mem = first_mem;</span>
<span class="line-modified">2251     for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2252       Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">2253       Node* mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2254       assert(in_bb(first_mem) || in_bb(mem) || mem == first_mem, &quot;2 different memory state from outside the loop?&quot;);</span>
<span class="line-modified">2255       if (in_bb(mem)) {</span>
<span class="line-modified">2256         if (in_bb(first_mem) &amp;&amp; bb_idx(mem) &lt; bb_idx(first_mem)) {</span>
<span class="line-modified">2257           first_mem = mem;</span>
<span class="line-modified">2258         }</span>
<span class="line-modified">2259         if (!in_bb(last_mem) || bb_idx(mem) &gt; bb_idx(last_mem)) {</span>
<span class="line-modified">2260           last_mem = mem;</span>

2261         }
2262       }
2263     }
<a name="12" id="anc12"></a>





2264     bool schedule_last = true;
2265     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2266       Node* ld = pk-&gt;at(i);
<a name="13" id="anc13"></a><span class="line-modified">2267       for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2268            current=current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2269         assert(current != first_mem, &quot;corrupted memory graph&quot;);</span>
<span class="line-modified">2270         if(current-&gt;is_Mem() &amp;&amp; !independent(current, ld)){</span>


2271           schedule_last = false; // a later store depends on this load
<a name="14" id="anc14"></a><span class="line-removed">2272           break;</span>
2273         }
2274       }
2275     }
2276 
2277     Node* mem_input = schedule_last ? last_mem : first_mem;
2278     _igvn.hash_delete(mem_input);
2279     // Give each load the same memory state
2280     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2281       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2282       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2283     }
2284   }
2285 }
2286 
2287 #ifndef PRODUCT
2288 void SuperWord::print_loop(bool whole) {
2289   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2290   Node_List rpo_list;
2291   VectorSet visited(_arena);
2292   visited.set(lpt()-&gt;_head-&gt;_idx);
2293   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2294   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2295   if(whole) {
2296     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2297     _phase-&gt;dump();
2298     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2299   }
2300 }
2301 #endif
2302 
2303 //------------------------------output---------------------------
2304 // Convert packs into vector node operations
2305 void SuperWord::output() {
2306   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2307   Compile* C = _phase-&gt;C;
2308   if (_packset.length() == 0) {
2309     if (cl-&gt;is_main_loop()) {
2310       // Instigate more unrolling for optimization when vectorization fails.
2311       C-&gt;set_major_progress();
2312       cl-&gt;set_notpassed_slp();
2313       cl-&gt;mark_do_unroll_only();
2314     }
2315     return;
2316   }
2317 
2318 #ifndef PRODUCT
2319   if (TraceLoopOpts) {
2320     tty-&gt;print(&quot;SuperWord::output    &quot;);
2321     lpt()-&gt;dump_head();
2322   }
2323 #endif
2324 
2325   if (cl-&gt;is_main_loop()) {
2326     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2327     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2328 
2329     align_initial_loop_index(align_to_ref());
2330 
2331     // Insert extract (unpack) operations for scalar uses
2332     for (int i = 0; i &lt; _packset.length(); i++) {
2333       insert_extracts(_packset.at(i));
2334     }
2335   }
2336 
2337   uint max_vlen_in_bytes = 0;
2338   uint max_vlen = 0;
2339   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2340 
2341   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2342 
2343   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2344 
2345   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2346 
2347   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2348     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2349     return;
2350   }
2351 
2352   for (int i = 0; i &lt; _block.length(); i++) {
2353     Node* n = _block.at(i);
2354     Node_List* p = my_pack(n);
2355     if (p &amp;&amp; n == executed_last(p)) {
2356       uint vlen = p-&gt;size();
2357       uint vlen_in_bytes = 0;
2358       Node* vn = NULL;
2359       Node* low_adr = p-&gt;at(0);
2360       Node* first   = executed_first(p);
2361       if (can_process_post_loop) {
2362         // override vlen with the main loops vector length
2363         vlen = cl-&gt;slp_max_unroll();
2364       }
2365       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2366       int   opc = n-&gt;Opcode();
2367       if (n-&gt;is_Load()) {
2368         Node* ctl = n-&gt;in(MemNode::Control);
2369         Node* mem = first-&gt;in(MemNode::Memory);
2370         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2371         // Identify the memory dependency for the new loadVector node by
2372         // walking up through memory chain.
2373         // This is done to give flexibility to the new loadVector node so that
2374         // it can move above independent storeVector nodes.
2375         while (mem-&gt;is_StoreVector()) {
2376           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2377           int cmp = p1.cmp(p2);
2378           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2379             mem = mem-&gt;in(MemNode::Memory);
2380           } else {
2381             break; // dependent memory
2382           }
2383         }
2384         Node* adr = low_adr-&gt;in(MemNode::Address);
2385         const TypePtr* atyp = n-&gt;adr_type();
2386         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2387         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2388       } else if (n-&gt;is_Store()) {
2389         // Promote value to be stored to vector
2390         Node* val = vector_opd(p, MemNode::ValueIn);
2391         if (val == NULL) {
2392           if (do_reserve_copy()) {
2393             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2394             return; //and reverse to backup IG
2395           }
2396           ShouldNotReachHere();
2397         }
2398 
2399         Node* ctl = n-&gt;in(MemNode::Control);
2400         Node* mem = first-&gt;in(MemNode::Memory);
2401         Node* adr = low_adr-&gt;in(MemNode::Address);
2402         const TypePtr* atyp = n-&gt;adr_type();
2403         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2404         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
<a name="15" id="anc15"></a>





2405       } else if (VectorNode::is_muladds2i(n)) {
2406         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2407         Node* in1 = vector_opd(p, 1);
2408         Node* in2 = vector_opd(p, 2);
2409         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2410         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2411       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2412         // Promote operands to vector
2413         Node* in1 = NULL;
2414         bool node_isa_reduction = n-&gt;is_reduction();
2415         if (node_isa_reduction) {
2416           // the input to the first reduction operation is retained
2417           in1 = low_adr-&gt;in(1);
2418         } else {
2419           in1 = vector_opd(p, 1);
2420           if (in1 == NULL) {
2421             if (do_reserve_copy()) {
2422               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2423               return; //and reverse to backup IG
2424             }
2425             ShouldNotReachHere();
2426           }
2427         }
2428         Node* in2 = vector_opd(p, 2);
2429         if (in2 == NULL) {
2430           if (do_reserve_copy()) {
2431             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2432             return; //and reverse to backup IG
2433           }
2434           ShouldNotReachHere();
2435         }
2436         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2437           // Move invariant vector input into second position to avoid register spilling.
2438           Node* tmp = in1;
2439           in1 = in2;
2440           in2 = tmp;
2441         }
2442         if (node_isa_reduction) {
2443           const Type *arith_type = n-&gt;bottom_type();
2444           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2445           if (in2-&gt;is_Load()) {
2446             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2447           } else {
2448             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2449           }
2450         } else {
2451           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2452           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2453         }
2454       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2455                  opc == Op_AbsF || opc == Op_AbsD ||
<a name="16" id="anc16"></a>
2456                  opc == Op_NegF || opc == Op_NegD ||
2457                  opc == Op_PopCountI) {
2458         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2459         Node* in = vector_opd(p, 1);
2460         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2461         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2462       } else if (is_cmov_pack(p)) {
2463         if (can_process_post_loop) {
2464           // do not refactor of flow in post loop context
2465           return;
2466         }
2467         if (!n-&gt;is_CMove()) {
2468           continue;
2469         }
2470         // place here CMoveVDNode
2471         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2472         Node* bol = n-&gt;in(CMoveNode::Condition);
2473         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2474           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2475           bol = bol-&gt;in(1); //may be ExtractNode
2476         }
2477 
2478         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2479         if (!bol-&gt;is_Bool()) {
2480           if (do_reserve_copy()) {
2481             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2482             return; //and reverse to backup IG
2483           }
2484           ShouldNotReachHere();
2485         }
2486 
2487         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2488         Node* in_cc  = _igvn.intcon(cond);
2489         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2490         Node* cc = bol-&gt;clone();
2491         cc-&gt;set_req(1, in_cc);
2492         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2493 
2494         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2495         if (src1 == NULL) {
2496           if (do_reserve_copy()) {
2497             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2498             return; //and reverse to backup IG
2499           }
2500           ShouldNotReachHere();
2501         }
2502         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2503         if (src2 == NULL) {
2504           if (do_reserve_copy()) {
2505             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2506             return; //and reverse to backup IG
2507           }
2508           ShouldNotReachHere();
2509         }
2510         BasicType bt = velt_basic_type(n);
2511         const TypeVect* vt = TypeVect::make(bt, vlen);
2512         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2513         if (bt == T_FLOAT) {
2514           vn = new CMoveVFNode(cc, src1, src2, vt);
2515         } else {
2516           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2517           vn = new CMoveVDNode(cc, src1, src2, vt);
2518         }
2519         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2520       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2521         // Promote operands to vector
2522         Node* in1 = vector_opd(p, 1);
2523         Node* in2 = vector_opd(p, 2);
2524         Node* in3 = vector_opd(p, 3);
2525         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2526         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2527       } else {
2528         if (do_reserve_copy()) {
2529           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2530           return; //and reverse to backup IG
2531         }
2532         ShouldNotReachHere();
2533       }
2534 
2535       assert(vn != NULL, &quot;sanity&quot;);
2536       if (vn == NULL) {
2537         if (do_reserve_copy()){
2538           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2539           return; //and reverse to backup IG
2540         }
2541         ShouldNotReachHere();
2542       }
2543 
2544       _block.at_put(i, vn);
2545       _igvn.register_new_node_with_optimizer(vn);
2546       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2547       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2548         Node* pm = p-&gt;at(j);
2549         _igvn.replace_node(pm, vn);
2550       }
2551       _igvn._worklist.push(vn);
2552 
2553       if (can_process_post_loop) {
2554         // first check if the vector size if the maximum vector which we can use on the machine,
2555         // other vector size have reduced values for predicated data mapping.
2556         if (vlen_in_bytes != (uint)MaxVectorSize) {
2557           return;
2558         }
2559       }
2560 
2561       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2562         max_vlen = vlen;
2563         max_vlen_in_bytes = vlen_in_bytes;
2564       }
2565 #ifdef ASSERT
2566       if (TraceNewVectors) {
2567         tty-&gt;print(&quot;new Vector node: &quot;);
2568         vn-&gt;dump();
2569       }
2570 #endif
2571     }
2572   }//for (int i = 0; i &lt; _block.length(); i++)
2573 
2574   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2575     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2576   }
2577   if (max_vlen_in_bytes &gt; 0) {
2578     cl-&gt;mark_loop_vectorized();
2579   }
2580 
2581   if (SuperWordLoopUnrollAnalysis) {
2582     if (cl-&gt;has_passed_slp()) {
2583       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2584       if (slp_max_unroll_factor == max_vlen) {
2585         if (TraceSuperWordLoopUnrollAnalysis) {
2586           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2587         }
2588 
2589         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2590         cl-&gt;set_notpassed_slp();
2591         if (cl-&gt;is_main_loop()) {
2592           // if vector resources are limited, do not allow additional unrolling, also
2593           // do not unroll more on pure vector loops which were not reduced so that we can
2594           // program the post loop to single iteration execution.
2595           if (FLOATPRESSURE &gt; 8) {
2596             C-&gt;set_major_progress();
2597             cl-&gt;mark_do_unroll_only();
2598           }
2599         }
2600 
2601         if (do_reserve_copy()) {
2602           if (can_process_post_loop) {
2603             // Now create the difference of trip and limit and use it as our mask index.
2604             // Note: We limited the unroll of the vectorized loop so that
2605             //       only vlen-1 size iterations can remain to be mask programmed.
2606             Node *incr = cl-&gt;incr();
2607             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2608             _igvn.register_new_node_with_optimizer(index);
2609             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2610             _igvn.register_new_node_with_optimizer(mask);
2611             // make this a single iteration loop
2612             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2613             _igvn.register_new_node_with_optimizer(new_incr);
2614             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2615             _igvn.replace_node(incr, new_incr);
2616             cl-&gt;mark_is_multiversioned();
2617             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2618           }
2619         }
2620       }
2621     }
2622   }
2623 
2624   if (do_reserve_copy()) {
2625     make_reversable.use_new();
2626   }
2627   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2628   return;
2629 }
2630 
2631 //------------------------------vector_opd---------------------------
2632 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2633 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2634   Node* p0 = p-&gt;at(0);
2635   uint vlen = p-&gt;size();
2636   Node* opd = p0-&gt;in(opd_idx);
2637   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2638 
2639   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2640     // override vlen with the main loops vector length
2641     vlen = cl-&gt;slp_max_unroll();
2642   }
2643 
2644   if (same_inputs(p, opd_idx)) {
2645     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2646       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2647       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2648         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2649         return NULL;
2650       }
2651       return opd; // input is matching vector
2652     }
2653     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2654       Compile* C = _phase-&gt;C;
2655       Node* cnt = opd;
2656       // Vector instructions do not mask shift count, do it here.
2657       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2658       const TypeInt* t = opd-&gt;find_int_type();
2659       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2660         juint shift = t-&gt;get_con();
2661         if (shift &gt; mask) { // Unsigned cmp
2662           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2663         }
2664       } else {
2665         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2666           cnt = ConNode::make(TypeInt::make(mask));
2667           _igvn.register_new_node_with_optimizer(cnt);
2668           cnt = new AndINode(opd, cnt);
2669           _igvn.register_new_node_with_optimizer(cnt);
2670           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2671         }
2672         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2673         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2674           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2675           return NULL;
2676         }
<a name="17" id="anc17"></a><span class="line-removed">2677         // Move non constant shift count into vector register.</span>
<span class="line-removed">2678         cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-removed">2679       }</span>
<span class="line-removed">2680       if (cnt != opd) {</span>
<span class="line-removed">2681         _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-removed">2682         _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
2683       }
<a name="18" id="anc18"></a>



2684       return cnt;
2685     }
2686     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2687     if (opd-&gt;is_StoreVector()) {
2688       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2689       return NULL;
2690     }
2691     // Convert scalar input to vector with the same number of elements as
2692     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2693     // vector should match p0&#39;s size regardless operand&#39;s size.
2694     const Type* p0_t = velt_type(p0);
2695     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2696 
2697     _igvn.register_new_node_with_optimizer(vn);
2698     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2699 #ifdef ASSERT
2700     if (TraceNewVectors) {
2701       tty-&gt;print(&quot;new Vector node: &quot;);
2702       vn-&gt;dump();
2703     }
2704 #endif
2705     return vn;
2706   }
2707 
2708   // Insert pack operation
2709   BasicType bt = velt_basic_type(p0);
2710   PackNode* pk = PackNode::make(opd, vlen, bt);
2711   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2712 
2713   for (uint i = 1; i &lt; vlen; i++) {
2714     Node* pi = p-&gt;at(i);
2715     Node* in = pi-&gt;in(opd_idx);
2716     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2717     if (my_pack(in) != NULL) {
2718       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2719       return NULL;
2720     }
2721     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2722     pk-&gt;add_opd(in);
2723     if (VectorNode::is_muladds2i(pi)) {
2724       Node* in2 = pi-&gt;in(opd_idx + 2);
2725       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2726       if (my_pack(in2) != NULL) {
2727         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2728           return NULL;
2729       }
2730       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2731       pk-&gt;add_opd(in2);
2732     }
2733   }
2734   _igvn.register_new_node_with_optimizer(pk);
2735   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2736 #ifdef ASSERT
2737   if (TraceNewVectors) {
2738     tty-&gt;print(&quot;new Vector node: &quot;);
2739     pk-&gt;dump();
2740   }
2741 #endif
2742   return pk;
2743 }
2744 
2745 //------------------------------insert_extracts---------------------------
2746 // If a use of pack p is not a vector use, then replace the
2747 // use with an extract operation.
2748 void SuperWord::insert_extracts(Node_List* p) {
2749   if (p-&gt;at(0)-&gt;is_Store()) return;
2750   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2751 
2752   // Inspect each use of each pack member.  For each use that is
2753   // not a vector use, replace the use with an extract operation.
2754 
2755   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2756     Node* def = p-&gt;at(i);
2757     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2758       Node* use = def-&gt;fast_out(j);
2759       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2760         Node* n = use-&gt;in(k);
2761         if (def == n) {
2762           Node_List* u_pk = my_pack(use);
2763           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2764               _n_idx_list.push(use, k);
2765           }
2766         }
2767       }
2768     }
2769   }
2770 
2771   while (_n_idx_list.is_nonempty()) {
2772     Node* use = _n_idx_list.node();
2773     int   idx = _n_idx_list.index();
2774     _n_idx_list.pop();
2775     Node* def = use-&gt;in(idx);
2776 
2777     if (def-&gt;is_reduction()) continue;
2778 
2779     // Insert extract operation
2780     _igvn.hash_delete(def);
2781     int def_pos = alignment(def) / data_size(def);
2782 
2783     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2784     _igvn.register_new_node_with_optimizer(ex);
2785     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2786     _igvn.replace_input_of(use, idx, ex);
2787     _igvn._worklist.push(def);
2788 
2789     bb_insert_after(ex, bb_idx(def));
2790     set_velt_type(ex, velt_type(def));
2791   }
2792 }
2793 
2794 //------------------------------is_vector_use---------------------------
2795 // Is use-&gt;in(u_idx) a vector use?
2796 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2797   Node_List* u_pk = my_pack(use);
2798   if (u_pk == NULL) return false;
2799   if (use-&gt;is_reduction()) return true;
2800   Node* def = use-&gt;in(u_idx);
2801   Node_List* d_pk = my_pack(def);
2802   if (d_pk == NULL) {
2803     // check for scalar promotion
2804     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2805     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2806       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2807     }
2808     return true;
2809   }
2810   if (VectorNode::is_muladds2i(use)) {
2811     // MulAddS2I takes shorts and produces ints - hence the special checks
2812     // on alignment and size.
2813     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2814       return false;
2815     }
2816     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2817       Node* ui = u_pk-&gt;at(i);
2818       Node* di = d_pk-&gt;at(i);
2819       if (alignment(ui) != alignment(di) * 2) {
2820         return false;
2821       }
2822     }
2823     return true;
2824   }
2825   if (u_pk-&gt;size() != d_pk-&gt;size())
2826     return false;
2827   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2828     Node* ui = u_pk-&gt;at(i);
2829     Node* di = d_pk-&gt;at(i);
2830     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2831       return false;
2832   }
2833   return true;
2834 }
2835 
2836 //------------------------------construct_bb---------------------------
2837 // Construct reverse postorder list of block members
2838 bool SuperWord::construct_bb() {
2839   Node* entry = bb();
2840 
2841   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2842   assert(_block.length() == 0,          &quot;block is empty&quot;);
2843   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2844   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2845   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2846 
2847   // Find non-control nodes with no inputs from within block,
2848   // create a temporary map from node _idx to bb_idx for use
2849   // by the visited and post_visited sets,
2850   // and count number of nodes in block.
2851   int bb_ct = 0;
2852   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2853     Node *n = lpt()-&gt;_body.at(i);
2854     set_bb_idx(n, i); // Create a temporary map
2855     if (in_bb(n)) {
2856       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2857           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2858         // Bailout if the loop has LoadStore, MergeMem or data Proj
2859         // nodes. Superword optimization does not work with them.
2860         return false;
2861       }
2862       bb_ct++;
2863       if (!n-&gt;is_CFG()) {
2864         bool found = false;
2865         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2866           Node* def = n-&gt;in(j);
2867           if (def &amp;&amp; in_bb(def)) {
2868             found = true;
2869             break;
2870           }
2871         }
2872         if (!found) {
2873           assert(n != entry, &quot;can&#39;t be entry&quot;);
2874           _data_entry.push(n);
2875         }
2876       }
2877     }
2878   }
2879 
2880   // Find memory slices (head and tail)
2881   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2882     Node *n = lp()-&gt;fast_out(i);
2883     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2884       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2885       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2886         if (!n_tail-&gt;is_Mem()) {
2887           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2888           return false; // Bailout
2889         }
2890         _mem_slice_head.push(n);
2891         _mem_slice_tail.push(n_tail);
2892       }
2893     }
2894   }
2895 
2896   // Create an RPO list of nodes in block
2897 
2898   visited_clear();
2899   post_visited_clear();
2900 
2901   // Push all non-control nodes with no inputs from within block, then control entry
2902   for (int j = 0; j &lt; _data_entry.length(); j++) {
2903     Node* n = _data_entry.at(j);
2904     visited_set(n);
2905     _stk.push(n);
2906   }
2907   visited_set(entry);
2908   _stk.push(entry);
2909 
2910   // Do a depth first walk over out edges
2911   int rpo_idx = bb_ct - 1;
2912   int size;
2913   int reduction_uses = 0;
2914   while ((size = _stk.length()) &gt; 0) {
2915     Node* n = _stk.top(); // Leave node on stack
2916     if (!visited_test_set(n)) {
2917       // forward arc in graph
2918     } else if (!post_visited_test(n)) {
2919       // cross or back arc
2920       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2921         Node *use = n-&gt;fast_out(i);
2922         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2923             // Don&#39;t go around backedge
2924             (!use-&gt;is_Phi() || n == entry)) {
2925           if (use-&gt;is_reduction()) {
2926             // First see if we can map the reduction on the given system we are on, then
2927             // make a data entry operation for each reduction we see.
2928             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2929             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2930               reduction_uses++;
2931             }
2932           }
2933           _stk.push(use);
2934         }
2935       }
2936       if (_stk.length() == size) {
2937         // There were no additional uses, post visit node now
2938         _stk.pop(); // Remove node from stack
2939         assert(rpo_idx &gt;= 0, &quot;&quot;);
2940         _block.at_put_grow(rpo_idx, n);
2941         rpo_idx--;
2942         post_visited_set(n);
2943         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
2944       }
2945     } else {
2946       _stk.pop(); // Remove post-visited node from stack
2947     }
2948   }//while
2949 
2950   int ii_current = -1;
2951   unsigned int load_idx = (unsigned int)-1;
2952   _ii_order.clear();
2953   // Create real map of block indices for nodes
2954   for (int j = 0; j &lt; _block.length(); j++) {
2955     Node* n = _block.at(j);
2956     set_bb_idx(n, j);
2957     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
2958       if (ii_current == -1) {
2959         ii_current = _clone_map.gen(n-&gt;_idx);
2960         _ii_order.push(ii_current);
2961         load_idx = _clone_map.idx(n-&gt;_idx);
2962       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
2963         ii_current = _clone_map.gen(n-&gt;_idx);
2964         _ii_order.push(ii_current);
2965       }
2966     }
2967   }//for
2968 
2969   // Ensure extra info is allocated.
2970   initialize_bb();
2971 
2972 #ifndef PRODUCT
2973   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
2974     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
2975     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
2976       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
2977     }
2978     tty-&gt;print_cr(&quot; &quot;);
2979   }
2980   if (TraceSuperWord) {
2981     print_bb();
2982     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
2983     for (int m = 0; m &lt; _data_entry.length(); m++) {
2984       tty-&gt;print(&quot;%3d &quot;, m);
2985       _data_entry.at(m)-&gt;dump();
2986     }
2987     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
2988     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
2989       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
2990       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
2991     }
2992   }
2993 #endif
2994   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
2995   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
2996 }
2997 
2998 //------------------------------initialize_bb---------------------------
2999 // Initialize per node info
3000 void SuperWord::initialize_bb() {
3001   Node* last = _block.at(_block.length() - 1);
3002   grow_node_info(bb_idx(last));
3003 }
3004 
3005 //------------------------------bb_insert_after---------------------------
3006 // Insert n into block after pos
3007 void SuperWord::bb_insert_after(Node* n, int pos) {
3008   int n_pos = pos + 1;
3009   // Make room
3010   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3011     _block.at_put_grow(i+1, _block.at(i));
3012   }
3013   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3014     _node_info.at_put_grow(j+1, _node_info.at(j));
3015   }
3016   // Set value
3017   _block.at_put_grow(n_pos, n);
3018   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3019   // Adjust map from node-&gt;_idx to _block index
3020   for (int i = n_pos; i &lt; _block.length(); i++) {
3021     set_bb_idx(_block.at(i), i);
3022   }
3023 }
3024 
3025 //------------------------------compute_max_depth---------------------------
3026 // Compute max depth for expressions from beginning of block
3027 // Use to prune search paths during test for independence.
3028 void SuperWord::compute_max_depth() {
3029   int ct = 0;
3030   bool again;
3031   do {
3032     again = false;
3033     for (int i = 0; i &lt; _block.length(); i++) {
3034       Node* n = _block.at(i);
3035       if (!n-&gt;is_Phi()) {
3036         int d_orig = depth(n);
3037         int d_in   = 0;
3038         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3039           Node* pred = preds.current();
3040           if (in_bb(pred)) {
3041             d_in = MAX2(d_in, depth(pred));
3042           }
3043         }
3044         if (d_in + 1 != d_orig) {
3045           set_depth(n, d_in + 1);
3046           again = true;
3047         }
3048       }
3049     }
3050     ct++;
3051   } while (again);
3052 
3053   if (TraceSuperWord &amp;&amp; Verbose) {
3054     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3055   }
3056 }
3057 
3058 //-------------------------compute_vector_element_type-----------------------
3059 // Compute necessary vector element type for expressions
3060 // This propagates backwards a narrower integer type when the
3061 // upper bits of the value are not needed.
3062 // Example:  char a,b,c;  a = b + c;
3063 // Normally the type of the add is integer, but for packed character
3064 // operations the type of the add needs to be char.
3065 void SuperWord::compute_vector_element_type() {
3066   if (TraceSuperWord &amp;&amp; Verbose) {
3067     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3068   }
3069 
3070   // Initial type
3071   for (int i = 0; i &lt; _block.length(); i++) {
3072     Node* n = _block.at(i);
3073     set_velt_type(n, container_type(n));
3074   }
3075 
3076   // Propagate integer narrowed type backwards through operations
3077   // that don&#39;t depend on higher order bits
3078   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3079     Node* n = _block.at(i);
3080     // Only integer types need be examined
3081     const Type* vtn = velt_type(n);
3082     if (vtn-&gt;basic_type() == T_INT) {
3083       uint start, end;
3084       VectorNode::vector_operands(n, &amp;start, &amp;end);
3085 
3086       for (uint j = start; j &lt; end; j++) {
3087         Node* in  = n-&gt;in(j);
3088         // Don&#39;t propagate through a memory
3089         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3090             data_size(n) &lt; data_size(in)) {
3091           bool same_type = true;
3092           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3093             Node *use = in-&gt;fast_out(k);
3094             if (!in_bb(use) || !same_velt_type(use, n)) {
3095               same_type = false;
3096               break;
3097             }
3098           }
3099           if (same_type) {
3100             // For right shifts of small integer types (bool, byte, char, short)
3101             // we need precise information about sign-ness. Only Load nodes have
3102             // this information because Store nodes are the same for signed and
3103             // unsigned values. And any arithmetic operation after a load may
3104             // expand a value to signed Int so such right shifts can&#39;t be used
3105             // because vector elements do not have upper bits of Int.
3106             const Type* vt = vtn;
3107             if (VectorNode::is_shift(in)) {
3108               Node* load = in-&gt;in(1);
3109               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3110                 vt = velt_type(load);
3111               } else if (in-&gt;Opcode() != Op_LShiftI) {
3112                 // Widen type to Int to avoid creation of right shift vector
3113                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3114                 // Note, left shifts work regardless type.
3115                 vt = TypeInt::INT;
3116               }
3117             }
3118             set_velt_type(in, vt);
3119           }
3120         }
3121       }
3122     }
3123   }
3124 #ifndef PRODUCT
3125   if (TraceSuperWord &amp;&amp; Verbose) {
3126     for (int i = 0; i &lt; _block.length(); i++) {
3127       Node* n = _block.at(i);
3128       velt_type(n)-&gt;dump();
3129       tty-&gt;print(&quot;\t&quot;);
3130       n-&gt;dump();
3131     }
3132   }
3133 #endif
3134 }
3135 
3136 //------------------------------memory_alignment---------------------------
3137 // Alignment within a vector memory reference
3138 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3139   #ifndef PRODUCT
3140     if(TraceSuperWord &amp;&amp; Verbose) {
3141       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3142     }
3143   #endif
3144   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3145   SWPointer p(s, this, NULL, false);
3146   if (!p.valid()) {
3147     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3148     return bottom_align;
3149   }
3150   int vw = get_vw_bytes_special(s);
3151   if (vw &lt; 2) {
3152     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3153     return bottom_align; // No vectors for this type
3154   }
3155   int offset  = p.offset_in_bytes();
3156   offset     += iv_adjust*p.memory_size();
3157   int off_rem = offset % vw;
3158   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3159   if (TraceSuperWord &amp;&amp; Verbose) {
3160     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3161   }
3162   return off_mod;
3163 }
3164 
3165 //---------------------------container_type---------------------------
3166 // Smallest type containing range of values
3167 const Type* SuperWord::container_type(Node* n) {
3168   if (n-&gt;is_Mem()) {
3169     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3170     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3171       // Use T_SHORT type instead of T_CHAR for stored values because any
3172       // preceding arithmetic operation extends values to signed Int.
3173       bt = T_SHORT;
3174     }
3175     if (n-&gt;Opcode() == Op_LoadUB) {
3176       // Adjust type for unsigned byte loads, it is important for right shifts.
3177       // T_BOOLEAN is used because there is no basic type representing type
3178       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3179       // size (one byte) and sign is important.
3180       bt = T_BOOLEAN;
3181     }
3182     return Type::get_const_basic_type(bt);
3183   }
3184   const Type* t = _igvn.type(n);
3185   if (t-&gt;basic_type() == T_INT) {
3186     // A narrow type of arithmetic operations will be determined by
3187     // propagating the type of memory operations.
3188     return TypeInt::INT;
3189   }
3190   return t;
3191 }
3192 
3193 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3194   const Type* vt1 = velt_type(n1);
3195   const Type* vt2 = velt_type(n2);
3196   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3197     // Compare vectors element sizes for integer types.
3198     return data_size(n1) == data_size(n2);
3199   }
3200   return vt1 == vt2;
3201 }
3202 
3203 //------------------------------in_packset---------------------------
3204 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3205 bool SuperWord::in_packset(Node* s1, Node* s2) {
3206   for (int i = 0; i &lt; _packset.length(); i++) {
3207     Node_List* p = _packset.at(i);
3208     assert(p-&gt;size() == 2, &quot;must be&quot;);
3209     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3210       return true;
3211     }
3212   }
3213   return false;
3214 }
3215 
3216 //------------------------------in_pack---------------------------
3217 // Is s in pack p?
3218 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3219   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3220     if (p-&gt;at(i) == s) {
3221       return p;
3222     }
3223   }
3224   return NULL;
3225 }
3226 
3227 //------------------------------remove_pack_at---------------------------
3228 // Remove the pack at position pos in the packset
3229 void SuperWord::remove_pack_at(int pos) {
3230   Node_List* p = _packset.at(pos);
3231   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3232     Node* s = p-&gt;at(i);
3233     set_my_pack(s, NULL);
3234   }
3235   _packset.remove_at(pos);
3236 }
3237 
3238 void SuperWord::packset_sort(int n) {
3239   // simple bubble sort so that we capitalize with O(n) when its already sorted
3240   while (n != 0) {
3241     bool swapped = false;
3242     for (int i = 1; i &lt; n; i++) {
3243       Node_List* q_low = _packset.at(i-1);
3244       Node_List* q_i = _packset.at(i);
3245 
3246       // only swap when we find something to swap
3247       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3248         Node_List* t = q_i;
3249         *(_packset.adr_at(i)) = q_low;
3250         *(_packset.adr_at(i-1)) = q_i;
3251         swapped = true;
3252       }
3253     }
3254     if (swapped == false) break;
3255     n--;
3256   }
3257 }
3258 
3259 //------------------------------executed_first---------------------------
3260 // Return the node executed first in pack p.  Uses the RPO block list
3261 // to determine order.
3262 Node* SuperWord::executed_first(Node_List* p) {
3263   Node* n = p-&gt;at(0);
3264   int n_rpo = bb_idx(n);
3265   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3266     Node* s = p-&gt;at(i);
3267     int s_rpo = bb_idx(s);
3268     if (s_rpo &lt; n_rpo) {
3269       n = s;
3270       n_rpo = s_rpo;
3271     }
3272   }
3273   return n;
3274 }
3275 
3276 //------------------------------executed_last---------------------------
3277 // Return the node executed last in pack p.
3278 Node* SuperWord::executed_last(Node_List* p) {
3279   Node* n = p-&gt;at(0);
3280   int n_rpo = bb_idx(n);
3281   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3282     Node* s = p-&gt;at(i);
3283     int s_rpo = bb_idx(s);
3284     if (s_rpo &gt; n_rpo) {
3285       n = s;
3286       n_rpo = s_rpo;
3287     }
3288   }
3289   return n;
3290 }
3291 
3292 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3293   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3294   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3295     Node* n = p-&gt;at(i);
3296     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3297     if (!n-&gt;depends_only_on_test()) {
<a name="19" id="anc19"></a><span class="line-modified">3298       dep = LoadNode::Pinned;</span>







3299     }
3300   }
3301   return dep;
3302 }
3303 
3304 
3305 //----------------------------align_initial_loop_index---------------------------
3306 // Adjust pre-loop limit so that in main loop, a load/store reference
3307 // to align_to_ref will be a position zero in the vector.
3308 //   (iv + k) mod vector_align == 0
3309 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3310   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3311   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3312   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3313   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3314   Node *pre_opaq1 = pre_end-&gt;limit();
3315   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3316   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3317   Node *lim0 = pre_opaq-&gt;in(1);
3318 
3319   // Where we put new limit calculations
3320   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3321 
3322   // Ensure the original loop limit is available from the
3323   // pre-loop Opaque1 node.
3324   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3325   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3326 
3327   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3328   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3329 
3330   // Given:
3331   //     lim0 == original pre loop limit
3332   //     V == v_align (power of 2)
3333   //     invar == extra invariant piece of the address expression
3334   //     e == offset [ +/- invar ]
3335   //
3336   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3337   //     (a - b) % k == 0   =&gt;  a % k == b % k
3338   // and:
3339   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3340   //
3341   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3342   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3343   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3344   //     (2) (e + lim) % V == 0
3345   //   are true.
3346   //
3347   //   Substituting (1) into (2),
3348   //     (e + lim0 + N) % V == 0
3349   //   solve for N:
3350   //     N = (V - (e + lim0)) % V
3351   //   substitute back into (1), so that new limit
3352   //     lim = lim0 + (V - (e + lim0)) % V
3353   //
3354   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3355   //   Constraints:
3356   //     lim = lim0 + N
3357   //     (e - lim) % V == 0
3358   //   Solving for lim:
3359   //     (e - lim0 - N) % V == 0
3360   //     N = (e - lim0) % V
3361   //     lim = lim0 + (e - lim0) % V
3362   //
3363   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3364   //   Constraints:
3365   //     lim = lim0 - N
3366   //     (e + lim) % V == 0
3367   //   Solving for lim:
3368   //     (e + lim0 - N) % V == 0
3369   //     N = (e + lim0) % V
3370   //     lim = lim0 - (e + lim0) % V
3371   //
3372   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3373   //   Constraints:
3374   //     lim = lim0 - N
3375   //     (e - lim) % V == 0
3376   //   Solving for lim:
3377   //     (e - lim0 + N) % V == 0
3378   //     N = (V - (e - lim0)) % V
3379   //     lim = lim0 - (V - (e - lim0)) % V
3380 
3381   int vw = vector_width_in_bytes(align_to_ref);
3382   int stride   = iv_stride();
3383   int scale    = align_to_ref_p.scale_in_bytes();
3384   int elt_size = align_to_ref_p.memory_size();
3385   int v_align  = vw / elt_size;
3386   assert(v_align &gt; 1, &quot;sanity&quot;);
3387   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3388   Node *offsn  = _igvn.intcon(offset);
3389 
3390   Node *e = offsn;
3391   if (align_to_ref_p.invar() != NULL) {
3392     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3393     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3394     Node* invar = align_to_ref_p.invar();
3395     if (_igvn.type(invar)-&gt;isa_long()) {
3396       // Computations are done % (vector width/element size) so it&#39;s
3397       // safe to simply convert invar to an int and loose the upper 32
3398       // bit half.
3399       invar = new ConvL2INode(invar);
3400       _igvn.register_new_node_with_optimizer(invar);
3401     }
3402     Node* aref = new URShiftINode(invar, log2_elt);
3403     _igvn.register_new_node_with_optimizer(aref);
3404     _phase-&gt;set_ctrl(aref, pre_ctrl);
3405     if (align_to_ref_p.negate_invar()) {
3406       e = new SubINode(e, aref);
3407     } else {
3408       e = new AddINode(e, aref);
3409     }
3410     _igvn.register_new_node_with_optimizer(e);
3411     _phase-&gt;set_ctrl(e, pre_ctrl);
3412   }
3413   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3414     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3415     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3416     _igvn.register_new_node_with_optimizer(xbase);
3417 #ifdef _LP64
3418     xbase  = new ConvL2INode(xbase);
3419     _igvn.register_new_node_with_optimizer(xbase);
3420 #endif
3421     Node* mask = _igvn.intcon(vw-1);
3422     Node* masked_xbase  = new AndINode(xbase, mask);
3423     _igvn.register_new_node_with_optimizer(masked_xbase);
3424     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3425     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3426     _igvn.register_new_node_with_optimizer(bref);
3427     _phase-&gt;set_ctrl(bref, pre_ctrl);
3428     e = new AddINode(e, bref);
3429     _igvn.register_new_node_with_optimizer(e);
3430     _phase-&gt;set_ctrl(e, pre_ctrl);
3431   }
3432 
3433   // compute e +/- lim0
3434   if (scale &lt; 0) {
3435     e = new SubINode(e, lim0);
3436   } else {
3437     e = new AddINode(e, lim0);
3438   }
3439   _igvn.register_new_node_with_optimizer(e);
3440   _phase-&gt;set_ctrl(e, pre_ctrl);
3441 
3442   if (stride * scale &gt; 0) {
3443     // compute V - (e +/- lim0)
3444     Node* va  = _igvn.intcon(v_align);
3445     e = new SubINode(va, e);
3446     _igvn.register_new_node_with_optimizer(e);
3447     _phase-&gt;set_ctrl(e, pre_ctrl);
3448   }
3449   // compute N = (exp) % V
3450   Node* va_msk = _igvn.intcon(v_align - 1);
3451   Node* N = new AndINode(e, va_msk);
3452   _igvn.register_new_node_with_optimizer(N);
3453   _phase-&gt;set_ctrl(N, pre_ctrl);
3454 
3455   //   substitute back into (1), so that new limit
3456   //     lim = lim0 + N
3457   Node* lim;
3458   if (stride &lt; 0) {
3459     lim = new SubINode(lim0, N);
3460   } else {
3461     lim = new AddINode(lim0, N);
3462   }
3463   _igvn.register_new_node_with_optimizer(lim);
3464   _phase-&gt;set_ctrl(lim, pre_ctrl);
3465   Node* constrained =
3466     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3467                  : (Node*) new MaxINode(lim, orig_limit);
3468   _igvn.register_new_node_with_optimizer(constrained);
3469   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3470   _igvn.replace_input_of(pre_opaq, 1, constrained);
3471 }
3472 
3473 //----------------------------get_pre_loop_end---------------------------
3474 // Find pre loop end from main loop.  Returns null if none.
3475 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3476   // The loop cannot be optimized if the graph shape at
3477   // the loop entry is inappropriate.
3478   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3479     return NULL;
3480   }
3481 
3482   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3483   if (!p_f-&gt;is_IfFalse()) return NULL;
3484   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3485   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3486   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3487   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3488   return pre_end;
3489 }
3490 
3491 //------------------------------init---------------------------
3492 void SuperWord::init() {
3493   _dg.init();
3494   _packset.clear();
3495   _disjoint_ptrs.clear();
3496   _block.clear();
3497   _post_block.clear();
3498   _data_entry.clear();
3499   _mem_slice_head.clear();
3500   _mem_slice_tail.clear();
3501   _iteration_first.clear();
3502   _iteration_last.clear();
3503   _node_info.clear();
3504   _align_to_ref = NULL;
3505   _lpt = NULL;
3506   _lp = NULL;
3507   _bb = NULL;
3508   _iv = NULL;
3509   _race_possible = 0;
3510   _early_return = false;
3511   _num_work_vecs = 0;
3512   _num_reductions = 0;
3513 }
3514 
3515 //------------------------------restart---------------------------
3516 void SuperWord::restart() {
3517   _dg.init();
3518   _packset.clear();
3519   _disjoint_ptrs.clear();
3520   _block.clear();
3521   _post_block.clear();
3522   _data_entry.clear();
3523   _mem_slice_head.clear();
3524   _mem_slice_tail.clear();
3525   _node_info.clear();
3526 }
3527 
3528 //------------------------------print_packset---------------------------
3529 void SuperWord::print_packset() {
3530 #ifndef PRODUCT
3531   tty-&gt;print_cr(&quot;packset&quot;);
3532   for (int i = 0; i &lt; _packset.length(); i++) {
3533     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3534     Node_List* p = _packset.at(i);
3535     print_pack(p);
3536   }
3537 #endif
3538 }
3539 
3540 //------------------------------print_pack---------------------------
3541 void SuperWord::print_pack(Node_List* p) {
3542   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3543     print_stmt(p-&gt;at(i));
3544   }
3545 }
3546 
3547 //------------------------------print_bb---------------------------
3548 void SuperWord::print_bb() {
3549 #ifndef PRODUCT
3550   tty-&gt;print_cr(&quot;\nBlock&quot;);
3551   for (int i = 0; i &lt; _block.length(); i++) {
3552     Node* n = _block.at(i);
3553     tty-&gt;print(&quot;%d &quot;, i);
3554     if (n) {
3555       n-&gt;dump();
3556     }
3557   }
3558 #endif
3559 }
3560 
3561 //------------------------------print_stmt---------------------------
3562 void SuperWord::print_stmt(Node* s) {
3563 #ifndef PRODUCT
3564   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3565   s-&gt;dump();
3566 #endif
3567 }
3568 
3569 //------------------------------blank---------------------------
3570 char* SuperWord::blank(uint depth) {
3571   static char blanks[101];
3572   assert(depth &lt; 101, &quot;too deep&quot;);
3573   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3574   blanks[depth] = &#39;\0&#39;;
3575   return blanks;
3576 }
3577 
3578 
3579 //==============================SWPointer===========================
3580 #ifndef PRODUCT
3581 int SWPointer::Tracer::_depth = 0;
3582 #endif
3583 //----------------------------SWPointer------------------------
3584 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3585   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3586   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3587   _nstack(nstack), _analyze_only(analyze_only),
3588   _stack_idx(0)
3589 #ifndef PRODUCT
3590   , _tracer(slp)
3591 #endif
3592 {
3593   NOT_PRODUCT(_tracer.ctor_1(mem);)
3594 
3595   Node* adr = mem-&gt;in(MemNode::Address);
3596   if (!adr-&gt;is_AddP()) {
3597     assert(!valid(), &quot;too complex&quot;);
3598     return;
3599   }
3600   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3601   Node* base = adr-&gt;in(AddPNode::Base);
3602   // The base address should be loop invariant
3603   if (!invariant(base)) {
3604     assert(!valid(), &quot;base address is loop variant&quot;);
3605     return;
3606   }
3607   // unsafe references require misaligned vector access support
3608   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3609     assert(!valid(), &quot;unsafe access&quot;);
3610     return;
3611   }
3612 
3613   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3614   NOT_PRODUCT(_tracer.ctor_2(adr);)
3615 
3616   int i;
3617   for (i = 0; i &lt; 3; i++) {
3618     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3619 
3620     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3621       assert(!valid(), &quot;too complex&quot;);
3622       return;
3623     }
3624     adr = adr-&gt;in(AddPNode::Address);
3625     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3626 
3627     if (base == adr || !adr-&gt;is_AddP()) {
3628       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3629       break; // stop looking at addp&#39;s
3630     }
3631   }
3632   if (!invariant(adr)) {
3633     assert(!valid(), &quot;adr is loop variant&quot;);
3634     return;
3635   }
3636 
3637   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3638     assert(!valid(), &quot;adr and base differ&quot;);
3639     return;
3640   }
3641 
3642   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3643   NOT_PRODUCT(_tracer.ctor_6(mem);)
3644 
3645   _base = base;
3646   _adr  = adr;
3647   assert(valid(), &quot;Usable&quot;);
3648 }
3649 
3650 // Following is used to create a temporary object during
3651 // the pattern match of an address expression.
3652 SWPointer::SWPointer(SWPointer* p) :
3653   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3654   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3655   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3656   _stack_idx(p-&gt;_stack_idx)
3657   #ifndef PRODUCT
3658   , _tracer(p-&gt;_slp)
3659   #endif
3660 {}
3661 
3662 
3663 bool SWPointer::invariant(Node* n) {
3664   NOT_PRODUCT(Tracer::Depth dd;)
3665   Node *n_c = phase()-&gt;get_ctrl(n);
3666   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3667   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3668 }
3669 //------------------------scaled_iv_plus_offset--------------------
3670 // Match: k*iv + offset
3671 // where: k is a constant that maybe zero, and
3672 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3673 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3674   NOT_PRODUCT(Tracer::Depth ddd;)
3675   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3676 
3677   if (scaled_iv(n)) {
3678     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3679     return true;
3680   }
3681 
3682   if (offset_plus_k(n)) {
3683     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3684     return true;
3685   }
3686 
3687   int opc = n-&gt;Opcode();
3688   if (opc == Op_AddI) {
3689     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3690       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3691       return true;
3692     }
3693     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3694       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3695       return true;
3696     }
3697   } else if (opc == Op_SubI) {
3698     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3699       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3700       return true;
3701     }
3702     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3703       _scale *= -1;
3704       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3705       return true;
3706     }
3707   }
3708 
3709   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3710   return false;
3711 }
3712 
3713 //----------------------------scaled_iv------------------------
3714 // Match: k*iv where k is a constant that&#39;s not zero
3715 bool SWPointer::scaled_iv(Node* n) {
3716   NOT_PRODUCT(Tracer::Depth ddd;)
3717   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3718 
3719   if (_scale != 0) { // already found a scale
3720     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3721     return false;
3722   }
3723 
3724   if (n == iv()) {
3725     _scale = 1;
3726     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3727     return true;
3728   }
3729   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3730     _nstack-&gt;push(n, _stack_idx++);
3731   }
3732 
3733   int opc = n-&gt;Opcode();
3734   if (opc == Op_MulI) {
3735     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3736       _scale = n-&gt;in(2)-&gt;get_int();
3737       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3738       return true;
3739     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3740       _scale = n-&gt;in(1)-&gt;get_int();
3741       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3742       return true;
3743     }
3744   } else if (opc == Op_LShiftI) {
3745     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3746       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3747       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3748       return true;
3749     }
3750   } else if (opc == Op_ConvI2L) {
3751     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3752         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3753       // Skip range check dependent CastII nodes
3754       n = n-&gt;in(1);
3755     }
3756     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3757       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3758       return true;
3759     }
3760   } else if (opc == Op_LShiftL) {
3761     if (!has_iv() &amp;&amp; _invar == NULL) {
3762       // Need to preserve the current _offset value, so
3763       // create a temporary object for this expression subtree.
3764       // Hacky, so should re-engineer the address pattern match.
3765       NOT_PRODUCT(Tracer::Depth dddd;)
3766       SWPointer tmp(this);
3767       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3768 
3769       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3770         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3771           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3772           _scale   = tmp._scale  * mult;
3773           _offset += tmp._offset * mult;
3774           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3775           return true;
3776         }
3777       }
3778     }
3779   }
3780   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3781   return false;
3782 }
3783 
3784 //----------------------------offset_plus_k------------------------
3785 // Match: offset is (k [+/- invariant])
3786 // where k maybe zero and invariant is optional, but not both.
3787 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3788   NOT_PRODUCT(Tracer::Depth ddd;)
3789   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3790 
3791   int opc = n-&gt;Opcode();
3792   if (opc == Op_ConI) {
3793     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3794     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3795     return true;
3796   } else if (opc == Op_ConL) {
3797     // Okay if value fits into an int
3798     const TypeLong* t = n-&gt;find_long_type();
3799     if (t-&gt;higher_equal(TypeLong::INT)) {
3800       jlong loff = n-&gt;get_long();
3801       jint  off  = (jint)loff;
3802       _offset += negate ? -off : loff;
3803       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3804       return true;
3805     }
3806     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3807     return false;
3808   }
3809   if (_invar != NULL) { // already has an invariant
3810     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3811     return false;
3812   }
3813 
3814   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3815     _nstack-&gt;push(n, _stack_idx++);
3816   }
3817   if (opc == Op_AddI) {
3818     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3819       _negate_invar = negate;
3820       _invar = n-&gt;in(1);
3821       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3822       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3823       return true;
3824     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3825       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3826       _negate_invar = negate;
3827       _invar = n-&gt;in(2);
3828       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3829       return true;
3830     }
3831   }
3832   if (opc == Op_SubI) {
3833     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3834       _negate_invar = negate;
3835       _invar = n-&gt;in(1);
3836       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3837       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3838       return true;
3839     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3840       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3841       _negate_invar = !negate;
3842       _invar = n-&gt;in(2);
3843       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3844       return true;
3845     }
3846   }
3847   if (invariant(n)) {
3848     if (opc == Op_ConvI2L) {
3849       n = n-&gt;in(1);
3850       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3851           n-&gt;as_CastII()-&gt;has_range_check()) {
3852         // Skip range check dependent CastII nodes
3853         assert(invariant(n), &quot;sanity&quot;);
3854         n = n-&gt;in(1);
3855       }
3856     }
3857     _negate_invar = negate;
3858     _invar = n;
3859     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3860     return true;
3861   }
3862 
3863   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3864   return false;
3865 }
3866 
3867 //----------------------------print------------------------
3868 void SWPointer::print() {
3869 #ifndef PRODUCT
3870   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3871              _base != NULL ? _base-&gt;_idx : 0,
3872              _adr  != NULL ? _adr-&gt;_idx  : 0,
3873              _scale, _offset,
3874              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3875              _invar != NULL ? _invar-&gt;_idx : 0);
3876 #endif
3877 }
3878 
3879 //----------------------------tracing------------------------
3880 #ifndef PRODUCT
3881 void SWPointer::Tracer::print_depth() {
3882   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3883 }
3884 
3885 void SWPointer::Tracer::ctor_1 (Node* mem) {
3886   if(_slp-&gt;is_trace_alignment()) {
3887     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3888   }
3889 }
3890 
3891 void SWPointer::Tracer::ctor_2(Node* adr) {
3892   if(_slp-&gt;is_trace_alignment()) {
3893     //store_depth();
3894     inc_depth();
3895     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3896     inc_depth();
3897     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3898   }
3899 }
3900 
3901 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3902   if(_slp-&gt;is_trace_alignment()) {
3903     inc_depth();
3904     Node* offset = adr-&gt;in(AddPNode::Offset);
3905     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3906   }
3907 }
3908 
3909 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3910   if(_slp-&gt;is_trace_alignment()) {
3911     inc_depth();
3912     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3913   }
3914 }
3915 
3916 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3917   if(_slp-&gt;is_trace_alignment()) {
3918     inc_depth();
3919     if (base == adr) {
3920       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3921     } else if (!adr-&gt;is_AddP()) {
3922       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3923     }
3924   }
3925 }
3926 
3927 void SWPointer::Tracer::ctor_6(Node* mem) {
3928   if(_slp-&gt;is_trace_alignment()) {
3929     //restore_depth();
3930     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
3931   }
3932 }
3933 
3934 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
3935   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
3936     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
3937     int in_bb     =  _slp-&gt;in_bb(n);
3938     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
3939     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
3940     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
3941     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
3942   }
3943 }
3944 
3945 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
3946   if(_slp-&gt;is_trace_alignment()) {
3947     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
3948     n-&gt;dump();
3949   }
3950 }
3951 
3952 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
3953   if(_slp-&gt;is_trace_alignment()) {
3954     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3955   }
3956 }
3957 
3958 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
3959   if(_slp-&gt;is_trace_alignment()) {
3960     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3961   }
3962 }
3963 
3964 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
3965   if(_slp-&gt;is_trace_alignment()) {
3966     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
3967     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
3968     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
3969   }
3970 }
3971 
3972 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
3973   if(_slp-&gt;is_trace_alignment()) {
3974     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
3975     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
3976     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
3977   }
3978 }
3979 
3980 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
3981   if(_slp-&gt;is_trace_alignment()) {
3982     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
3983     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
3984     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
3985   }
3986 }
3987 
3988 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
3989   if(_slp-&gt;is_trace_alignment()) {
3990     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
3991     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
3992     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
3993   }
3994 }
3995 
3996 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
3997   if(_slp-&gt;is_trace_alignment()) {
3998     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
3999   }
4000 }
4001 
4002 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4003   if(_slp-&gt;is_trace_alignment()) {
4004     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4005   }
4006 }
4007 
4008 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4009   if(_slp-&gt;is_trace_alignment()) {
4010     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4011     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4012   }
4013 }
4014 
4015 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4016   if(_slp-&gt;is_trace_alignment()) {
4017     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4018   }
4019 }
4020 
4021 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4022   if(_slp-&gt;is_trace_alignment()) {
4023     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4024     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4025     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4026   }
4027 }
4028 
4029 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4030   if(_slp-&gt;is_trace_alignment()) {
4031     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4032     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4033     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4034   }
4035 }
4036 
4037 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4038   if(_slp-&gt;is_trace_alignment()) {
4039     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4040     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4041     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4042   }
4043 }
4044 
4045 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4046   if(_slp-&gt;is_trace_alignment()) {
4047     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4048     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4049     inc_depth(); inc_depth();
4050     print_depth(); n-&gt;in(1)-&gt;dump();
4051     dec_depth(); dec_depth();
4052   }
4053 }
4054 
4055 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4056   if(_slp-&gt;is_trace_alignment()) {
4057     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4058   }
4059 }
4060 
4061 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4062   if(_slp-&gt;is_trace_alignment()) {
4063     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4064     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4065     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4066     inc_depth(); inc_depth();
4067     print_depth(); n-&gt;in(1)-&gt;dump();
4068     print_depth(); n-&gt;in(2)-&gt;dump();
4069     dec_depth(); dec_depth();
4070   }
4071 }
4072 
4073 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4074   if(_slp-&gt;is_trace_alignment()) {
4075     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4076   }
4077 }
4078 
4079 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4080   if(_slp-&gt;is_trace_alignment()) {
4081     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4082   }
4083 }
4084 
4085 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4086   if(_slp-&gt;is_trace_alignment()) {
4087     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4088   }
4089 }
4090 
4091 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4092   if(_slp-&gt;is_trace_alignment()) {
4093     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4094   }
4095 }
4096 
4097 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4098   if(_slp-&gt;is_trace_alignment()) {
4099     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4100     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4101   }
4102 }
4103 
4104 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4105   if(_slp-&gt;is_trace_alignment()) {
4106     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4107     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4108   }
4109 }
4110 
4111 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4112   if(_slp-&gt;is_trace_alignment()) {
4113     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4114     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4115     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4116     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4117   }
4118 }
4119 
4120 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4121   if(_slp-&gt;is_trace_alignment()) {
4122     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4123     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4124     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4125     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4126   }
4127 }
4128 
4129 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4130   if(_slp-&gt;is_trace_alignment()) {
4131     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4132     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4133     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4134     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4135   }
4136 }
4137 
4138 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4139   if(_slp-&gt;is_trace_alignment()) {
4140     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4141     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4142     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4143   }
4144 }
4145 
4146 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4147   if(_slp-&gt;is_trace_alignment()) {
4148     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4149     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4150   }
4151 }
4152 
4153 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4154   if(_slp-&gt;is_trace_alignment()) {
4155     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4156   }
4157 }
4158 
4159 #endif
4160 // ========================= OrderedPair =====================
4161 
4162 const OrderedPair OrderedPair::initial;
4163 
4164 // ========================= SWNodeInfo =====================
4165 
4166 const SWNodeInfo SWNodeInfo::initial;
4167 
4168 
4169 // ============================ DepGraph ===========================
4170 
4171 //------------------------------make_node---------------------------
4172 // Make a new dependence graph node for an ideal node.
4173 DepMem* DepGraph::make_node(Node* node) {
4174   DepMem* m = new (_arena) DepMem(node);
4175   if (node != NULL) {
4176     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4177     _map.at_put_grow(node-&gt;_idx, m);
4178   }
4179   return m;
4180 }
4181 
4182 //------------------------------make_edge---------------------------
4183 // Make a new dependence graph edge from dpred -&gt; dsucc
4184 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4185   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4186   dpred-&gt;set_out_head(e);
4187   dsucc-&gt;set_in_head(e);
4188   return e;
4189 }
4190 
4191 // ========================== DepMem ========================
4192 
4193 //------------------------------in_cnt---------------------------
4194 int DepMem::in_cnt() {
4195   int ct = 0;
4196   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4197   return ct;
4198 }
4199 
4200 //------------------------------out_cnt---------------------------
4201 int DepMem::out_cnt() {
4202   int ct = 0;
4203   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4204   return ct;
4205 }
4206 
4207 //------------------------------print-----------------------------
4208 void DepMem::print() {
4209 #ifndef PRODUCT
4210   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4211   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4212     Node* pred = p-&gt;pred()-&gt;node();
4213     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4214   }
4215   tty-&gt;print(&quot;) [&quot;);
4216   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4217     Node* succ = s-&gt;succ()-&gt;node();
4218     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4219   }
4220   tty-&gt;print_cr(&quot; ]&quot;);
4221 #endif
4222 }
4223 
4224 // =========================== DepEdge =========================
4225 
4226 //------------------------------DepPreds---------------------------
4227 void DepEdge::print() {
4228 #ifndef PRODUCT
4229   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4230 #endif
4231 }
4232 
4233 // =========================== DepPreds =========================
4234 // Iterator over predecessor edges in the dependence graph.
4235 
4236 //------------------------------DepPreds---------------------------
4237 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4238   _n = n;
4239   _done = false;
4240   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4241     _next_idx = MemNode::Address;
4242     _end_idx  = n-&gt;req();
4243     _dep_next = dg.dep(_n)-&gt;in_head();
4244   } else if (_n-&gt;is_Mem()) {
4245     _next_idx = 0;
4246     _end_idx  = 0;
4247     _dep_next = dg.dep(_n)-&gt;in_head();
4248   } else {
4249     _next_idx = 1;
4250     _end_idx  = _n-&gt;req();
4251     _dep_next = NULL;
4252   }
4253   next();
4254 }
4255 
4256 //------------------------------next---------------------------
4257 void DepPreds::next() {
4258   if (_dep_next != NULL) {
4259     _current  = _dep_next-&gt;pred()-&gt;node();
4260     _dep_next = _dep_next-&gt;next_in();
4261   } else if (_next_idx &lt; _end_idx) {
4262     _current  = _n-&gt;in(_next_idx++);
4263   } else {
4264     _done = true;
4265   }
4266 }
4267 
4268 // =========================== DepSuccs =========================
4269 // Iterator over successor edges in the dependence graph.
4270 
4271 //------------------------------DepSuccs---------------------------
4272 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4273   _n = n;
4274   _done = false;
4275   if (_n-&gt;is_Load()) {
4276     _next_idx = 0;
4277     _end_idx  = _n-&gt;outcnt();
4278     _dep_next = dg.dep(_n)-&gt;out_head();
4279   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4280     _next_idx = 0;
4281     _end_idx  = 0;
4282     _dep_next = dg.dep(_n)-&gt;out_head();
4283   } else {
4284     _next_idx = 0;
4285     _end_idx  = _n-&gt;outcnt();
4286     _dep_next = NULL;
4287   }
4288   next();
4289 }
4290 
4291 //-------------------------------next---------------------------
4292 void DepSuccs::next() {
4293   if (_dep_next != NULL) {
4294     _current  = _dep_next-&gt;succ()-&gt;node();
4295     _dep_next = _dep_next-&gt;next_out();
4296   } else if (_next_idx &lt; _end_idx) {
4297     _current  = _n-&gt;raw_out(_next_idx++);
4298   } else {
4299     _done = true;
4300   }
4301 }
4302 
4303 //
4304 // --------------------------------- vectorization/simd -----------------------------------
4305 //
4306 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4307   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4308 }
4309 bool SuperWord::same_generation(Node* a, Node* b) const {
4310   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4311 }
4312 
4313 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4314   assert(in_bb(ld), &quot;must be in block&quot;);
4315   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4316 #ifndef PRODUCT
4317     if (_vector_loop_debug) {
4318       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4319         _clone_map.gen(ld-&gt;_idx));
4320     }
4321 #endif
4322     return NULL; //we think that any ld in the first gen being vectorizable
4323   }
4324 
4325   Node* mem = ld-&gt;in(MemNode::Memory);
4326   if (mem-&gt;outcnt() &lt;= 1) {
4327     // we don&#39;t want to remove the only edge from mem node to load
4328 #ifndef PRODUCT
4329     if (_vector_loop_debug) {
4330       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4331         mem-&gt;_idx, ld-&gt;_idx);
4332       ld-&gt;dump();
4333       mem-&gt;dump();
4334     }
4335 #endif
4336     return NULL;
4337   }
4338   if (!in_bb(mem) || same_generation(mem, ld)) {
4339 #ifndef PRODUCT
4340     if (_vector_loop_debug) {
4341       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4342         _clone_map.gen(mem-&gt;_idx));
4343     }
4344 #endif
4345     return NULL; // does not depend on loop volatile node or depends on the same generation
4346   }
4347 
4348   //otherwise first node should depend on mem-phi
4349   Node* first = first_node(ld);
4350   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4351   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4352   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4353 #ifndef PRODUCT
4354     if (_vector_loop_debug) {
4355       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4356       ld-&gt;dump();
4357       first-&gt;dump();
4358     }
4359 #endif
4360     return NULL;
4361   }
4362 
4363   Node* tail = 0;
4364   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4365     if (_mem_slice_head.at(m) == phi) {
4366       tail = _mem_slice_tail.at(m);
4367     }
4368   }
4369   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4370 #ifndef PRODUCT
4371     if (_vector_loop_debug) {
4372       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4373         ld-&gt;_idx, phi-&gt;_idx);
4374       ld-&gt;dump();
4375       phi-&gt;dump();
4376     }
4377 #endif
4378     return NULL;
4379   }
4380 
4381   // now all conditions are met
4382   return phi;
4383 }
4384 
4385 Node* SuperWord::first_node(Node* nd) {
4386   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4387     Node* nnn = _iteration_first.at(ii);
4388     if (same_origin_idx(nnn, nd)) {
4389 #ifndef PRODUCT
4390       if (_vector_loop_debug) {
4391         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4392           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4393       }
4394 #endif
4395       return nnn;
4396     }
4397   }
4398 
4399 #ifndef PRODUCT
4400   if (_vector_loop_debug) {
4401     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4402       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4403   }
4404 #endif
4405   return 0;
4406 }
4407 
4408 Node* SuperWord::last_node(Node* nd) {
4409   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4410     Node* nnn = _iteration_last.at(ii);
4411     if (same_origin_idx(nnn, nd)) {
4412 #ifndef PRODUCT
4413       if (_vector_loop_debug) {
4414         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4415           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4416       }
4417 #endif
4418       return nnn;
4419     }
4420   }
4421   return 0;
4422 }
4423 
4424 int SuperWord::mark_generations() {
4425   Node *ii_err = NULL, *tail_err = NULL;
4426   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4427     Node* phi  = _mem_slice_head.at(i);
4428     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4429 
4430     Node* tail = _mem_slice_tail.at(i);
4431     if (_ii_last == -1) {
4432       tail_err = tail;
4433       _ii_last = _clone_map.gen(tail-&gt;_idx);
4434     }
4435     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4436 #ifndef PRODUCT
4437       if (TraceSuperWord &amp;&amp; Verbose) {
4438         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4439         tail-&gt;dump();
4440         tail_err-&gt;dump();
4441       }
4442 #endif
4443       return -1;
4444     }
4445 
4446     // find first iteration in the loop
4447     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4448       Node* ii = phi-&gt;fast_out(i);
4449       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4450         if (_ii_first == -1) {
4451           ii_err = ii;
4452           _ii_first = _clone_map.gen(ii-&gt;_idx);
4453         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4454 #ifndef PRODUCT
4455           if (TraceSuperWord &amp;&amp; Verbose) {
4456             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4457             ii-&gt;dump();
4458             if (ii_err!= 0) {
4459               ii_err-&gt;dump();
4460             }
4461           }
4462 #endif
4463           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4464         }
4465       }
4466     }//for (DUIterator_Fast imax,
4467   }//for (int i...
4468 
4469   if (_ii_first == -1 || _ii_last == -1) {
4470     if (TraceSuperWord &amp;&amp; Verbose) {
4471       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4472     }
4473     return -1; // something vent wrong
4474   }
4475   // collect nodes in the first and last generations
4476   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4477   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4478   for (int j = 0; j &lt; _block.length(); j++) {
4479     Node* n = _block.at(j);
4480     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4481     if ((signed)gen == _ii_first) {
4482       _iteration_first.push(n);
4483     } else if ((signed)gen == _ii_last) {
4484       _iteration_last.push(n);
4485     }
4486   }
4487 
4488   // building order of iterations
4489   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4490     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4491     Node* nd = ii_err;
4492     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4493       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4494       bool found = false;
4495       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4496         Node* use = nd-&gt;fast_out(i);
4497         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4498           found = true;
4499           nd = use;
4500           break;
4501         }
4502       }//for
4503 
4504       if (found == false) {
4505         if (TraceSuperWord &amp;&amp; Verbose) {
4506           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4507         }
4508         _ii_order.clear();
4509         return -1;
4510       }
4511     } //while
4512     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4513   }
4514 
4515 #ifndef PRODUCT
4516   if (_vector_loop_debug) {
4517     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4518     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4519     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4520     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4521     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4522     tty-&gt;print_cr(&quot; &quot;);
4523 
4524     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4525     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4526       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4527     }
4528     tty-&gt;print_cr(&quot; &quot;);
4529   }
4530 #endif
4531 
4532   return _ii_first;
4533 }
4534 
4535 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4536   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4537   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4538   Node* gin1 = gold-&gt;in(1);
4539   Node* gin2 = gold-&gt;in(2);
4540   Node* fin1 = fix-&gt;in(1);
4541   Node* fin2 = fix-&gt;in(2);
4542   bool swapped = false;
4543 
4544   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4545     if (same_origin_idx(gin1, fin1) &amp;&amp;
4546         same_origin_idx(gin2, fin2)) {
4547       return true; // nothing to fix
4548     }
4549     if (same_origin_idx(gin1, fin2) &amp;&amp;
4550         same_origin_idx(gin2, fin1)) {
4551       fix-&gt;swap_edges(1, 2);
4552       swapped = true;
4553     }
4554   }
4555   // at least one input comes from outside of bb
4556   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4557     return true; // nothing to fix
4558   }
4559   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4560     fix-&gt;swap_edges(1, 2);
4561     swapped = true;
4562   }
4563 
4564   if (swapped) {
4565 #ifndef PRODUCT
4566     if (_vector_loop_debug) {
4567       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4568     }
4569 #endif
4570     return true;
4571   }
4572 
4573   if (TraceSuperWord &amp;&amp; Verbose) {
4574     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4575   }
4576 
4577   return false;
4578 }
4579 
4580 bool SuperWord::pack_parallel() {
4581 #ifndef PRODUCT
4582   if (_vector_loop_debug) {
4583     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4584   }
4585 #endif
4586 
4587   _packset.clear();
4588 
4589   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4590     Node* nd = _iteration_first.at(ii);
4591     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4592       Node_List* pk = new Node_List();
4593       pk-&gt;push(nd);
4594       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4595         for (int kk = 0; kk &lt; _block.length(); kk++) {
4596           Node* clone = _block.at(kk);
4597           if (same_origin_idx(clone, nd) &amp;&amp;
4598               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4599             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4600               fix_commutative_inputs(nd, clone);
4601             }
4602             pk-&gt;push(clone);
4603             if (pk-&gt;size() == 4) {
4604               _packset.append(pk);
4605 #ifndef PRODUCT
4606               if (_vector_loop_debug) {
4607                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4608                 pk-&gt;dump();
4609               }
4610 #endif
4611               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4612                 pk = new Node_List();
4613               }
4614             }
4615             break;
4616           }
4617         }
4618       }//for
4619     }//if
4620   }//for
4621 
4622 #ifndef PRODUCT
4623   if (_vector_loop_debug) {
4624     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4625   }
4626 #endif
4627 
4628   return true;
4629 }
4630 
4631 bool SuperWord::hoist_loads_in_graph() {
4632   GrowableArray&lt;Node*&gt; loads;
4633 
4634 #ifndef PRODUCT
4635   if (_vector_loop_debug) {
4636     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4637   }
4638 #endif
4639 
4640   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4641     Node* n = _mem_slice_head.at(i);
4642     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4643       if (TraceSuperWord &amp;&amp; Verbose) {
4644         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4645       }
4646       continue;
4647     }
4648 
4649 #ifndef PRODUCT
4650     if (_vector_loop_debug) {
4651       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4652     }
4653 #endif
4654 
4655     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4656       Node* ld = n-&gt;fast_out(i);
4657       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4658         for (int i = 0; i &lt; _block.length(); i++) {
4659           Node* ld2 = _block.at(i);
4660           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4661               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4662 #ifndef PRODUCT
4663             if (_vector_loop_debug) {
4664               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4665                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4666             }
4667 #endif
4668             // could not do on-the-fly, since iterator is immutable
4669             loads.push(ld2);
4670           }
4671         }// for
4672       }//if
4673     }//for (DUIterator_Fast imax,
4674   }//for (int i = 0; i
4675 
4676   for (int i = 0; i &lt; loads.length(); i++) {
4677     LoadNode* ld = loads.at(i)-&gt;as_Load();
4678     Node* phi = find_phi_for_mem_dep(ld);
4679     if (phi != NULL) {
4680 #ifndef PRODUCT
4681       if (_vector_loop_debug) {
4682         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4683           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4684       }
4685 #endif
4686       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4687     }
4688   }//for
4689 
4690   restart(); // invalidate all basic structures, since we rebuilt the graph
4691 
4692   if (TraceSuperWord &amp;&amp; Verbose) {
4693     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4694   }
4695 
4696   return true;
4697 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/block.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arraycopynode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="block.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/block.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/chaitin.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/machnode.hpp&quot;
  35 #include &quot;opto/matcher.hpp&quot;
  36 #include &quot;opto/opcodes.hpp&quot;
  37 #include &quot;opto/rootnode.hpp&quot;
  38 #include &quot;utilities/copy.hpp&quot;

  39 
  40 void Block_Array::grow( uint i ) {
  41   assert(i &gt;= Max(), &quot;must be an overflow&quot;);
  42   debug_only(_limit = i+1);
  43   if( i &lt; _size )  return;
  44   if( !_size ) {
  45     _size = 1;
  46     _blocks = (Block**)_arena-&gt;Amalloc( _size * sizeof(Block*) );
  47     _blocks[0] = NULL;
  48   }
  49   uint old = _size;
<span class="line-modified">  50   while( i &gt;= _size ) _size &lt;&lt;= 1;      // Double to fit</span>
  51   _blocks = (Block**)_arena-&gt;Arealloc( _blocks, old*sizeof(Block*),_size*sizeof(Block*));
  52   Copy::zero_to_bytes( &amp;_blocks[old], (_size-old)*sizeof(Block*) );
  53 }
  54 
  55 void Block_List::remove(uint i) {
  56   assert(i &lt; _cnt, &quot;index out of bounds&quot;);
  57   Copy::conjoint_words_to_lower((HeapWord*)&amp;_blocks[i+1], (HeapWord*)&amp;_blocks[i], ((_cnt-i-1)*sizeof(Block*)));
  58   pop(); // shrink list by one block
  59 }
  60 
  61 void Block_List::insert(uint i, Block *b) {
  62   push(b); // grow list by one block
  63   Copy::conjoint_words_to_higher((HeapWord*)&amp;_blocks[i], (HeapWord*)&amp;_blocks[i+1], ((_cnt-i-1)*sizeof(Block*)));
  64   _blocks[i] = b;
  65 }
  66 
  67 #ifndef PRODUCT
  68 void Block_List::print() {
  69   for (uint i=0; i &lt; size(); i++) {
  70     tty-&gt;print(&quot;B%d &quot;, _blocks[i]-&gt;_pre_order);
</pre>
<hr />
<pre>
 250       uncommon_preds++;
 251     } else {
 252       freq_preds++;
 253       if(block-&gt;_freq &lt; guard-&gt;_freq * guard_factor ) {
 254         uncommon_for_freq_preds++;
 255       }
 256     }
 257   }
 258   if( block-&gt;num_preds() &gt; 1 &amp;&amp;
 259       // The block is uncommon if all preds are uncommon or
 260       (uncommon_preds == (block-&gt;num_preds()-1) ||
 261       // it is uncommon for all frequent preds.
 262        uncommon_for_freq_preds == freq_preds) ) {
 263     return true;
 264   }
 265   return false;
 266 }
 267 
 268 #ifndef PRODUCT
 269 void Block::dump_bidx(const Block* orig, outputStream* st) const {
<span class="line-modified"> 270   if (_pre_order) st-&gt;print(&quot;B%d&quot;,_pre_order);</span>
 271   else st-&gt;print(&quot;N%d&quot;, head()-&gt;_idx);
 272 
 273   if (Verbose &amp;&amp; orig != this) {
 274     // Dump the original block&#39;s idx
 275     st-&gt;print(&quot; (&quot;);
 276     orig-&gt;dump_bidx(orig, st);
 277     st-&gt;print(&quot;)&quot;);
 278   }
 279 }
 280 
 281 void Block::dump_pred(const PhaseCFG* cfg, Block* orig, outputStream* st) const {
 282   if (is_connector()) {
 283     for (uint i=1; i&lt;num_preds(); i++) {
 284       Block *p = cfg-&gt;get_block_for_node(pred(i));
 285       p-&gt;dump_pred(cfg, orig, st);
 286     }
 287   } else {
 288     dump_bidx(orig, st);
 289     st-&gt;print(&quot; &quot;);
 290   }
 291 }
 292 
 293 void Block::dump_head(const PhaseCFG* cfg, outputStream* st) const {
<span class="line-modified"> 294   // Print the basic block</span>
 295   dump_bidx(this, st);
<span class="line-modified"> 296   st-&gt;print(&quot;: #\t&quot;);</span>
 297 
<span class="line-modified"> 298   // Print the incoming CFG edges and the outgoing CFG edges</span>

 299   for( uint i=0; i&lt;_num_succs; i++ ) {
 300     non_connector_successor(i)-&gt;dump_bidx(_succs[i], st);
 301     st-&gt;print(&quot; &quot;);
 302   }
<span class="line-modified"> 303   st-&gt;print(&quot;&lt;- &quot;);</span>


 304   if( head()-&gt;is_block_start() ) {

 305     for (uint i=1; i&lt;num_preds(); i++) {
 306       Node *s = pred(i);
 307       if (cfg != NULL) {
 308         Block *p = cfg-&gt;get_block_for_node(s);
 309         p-&gt;dump_pred(cfg, p, st);
 310       } else {
<span class="line-modified"> 311         while (!s-&gt;is_block_start())</span>
 312           s = s-&gt;in(0);

 313         st-&gt;print(&quot;N%d &quot;, s-&gt;_idx );
 314       }
 315     }

 316   } else {
<span class="line-modified"> 317     st-&gt;print(&quot;BLOCK HEAD IS JUNK  &quot;);</span>
 318   }
 319 
 320   // Print loop, if any
 321   const Block *bhead = this;    // Head of self-loop
 322   Node *bh = bhead-&gt;head();
 323 
 324   if ((cfg != NULL) &amp;&amp; bh-&gt;is_Loop() &amp;&amp; !head()-&gt;is_Root()) {
 325     LoopNode *loop = bh-&gt;as_Loop();
 326     const Block *bx = cfg-&gt;get_block_for_node(loop-&gt;in(LoopNode::LoopBackControl));
 327     while (bx-&gt;is_connector()) {
 328       bx = cfg-&gt;get_block_for_node(bx-&gt;pred(1));
 329     }
<span class="line-modified"> 330     st-&gt;print(&quot;\tLoop: B%d-B%d &quot;, bhead-&gt;_pre_order, bx-&gt;_pre_order);</span>
 331     // Dump any loop-specific bits, especially for CountedLoops.
 332     loop-&gt;dump_spec(st);

 333   } else if (has_loop_alignment()) {
<span class="line-modified"> 334     st-&gt;print(&quot; top-of-loop&quot;);</span>
 335   }


 336   st-&gt;print(&quot; Freq: %g&quot;,_freq);
 337   if( Verbose || WizardMode ) {
 338     st-&gt;print(&quot; IDom: %d/#%d&quot;, _idom ? _idom-&gt;_pre_order : 0, _dom_depth);
 339     st-&gt;print(&quot; RegPressure: %d&quot;,_reg_pressure);
 340     st-&gt;print(&quot; IHRP Index: %d&quot;,_ihrp_index);
 341     st-&gt;print(&quot; FRegPressure: %d&quot;,_freg_pressure);
 342     st-&gt;print(&quot; FHRP Index: %d&quot;,_fhrp_index);
 343   }
 344   st-&gt;cr();
 345 }
 346 
 347 void Block::dump() const {
 348   dump(NULL);
 349 }
 350 
 351 void Block::dump(const PhaseCFG* cfg) const {
 352   dump_head(cfg);
 353   for (uint i=0; i&lt; number_of_nodes(); i++) {
 354     get_node(i)-&gt;dump();
 355   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/chaitin.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/machnode.hpp&quot;
  35 #include &quot;opto/matcher.hpp&quot;
  36 #include &quot;opto/opcodes.hpp&quot;
  37 #include &quot;opto/rootnode.hpp&quot;
  38 #include &quot;utilities/copy.hpp&quot;
<span class="line-added">  39 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  40 
  41 void Block_Array::grow( uint i ) {
  42   assert(i &gt;= Max(), &quot;must be an overflow&quot;);
  43   debug_only(_limit = i+1);
  44   if( i &lt; _size )  return;
  45   if( !_size ) {
  46     _size = 1;
  47     _blocks = (Block**)_arena-&gt;Amalloc( _size * sizeof(Block*) );
  48     _blocks[0] = NULL;
  49   }
  50   uint old = _size;
<span class="line-modified">  51   _size = next_power_of_2(i);</span>
  52   _blocks = (Block**)_arena-&gt;Arealloc( _blocks, old*sizeof(Block*),_size*sizeof(Block*));
  53   Copy::zero_to_bytes( &amp;_blocks[old], (_size-old)*sizeof(Block*) );
  54 }
  55 
  56 void Block_List::remove(uint i) {
  57   assert(i &lt; _cnt, &quot;index out of bounds&quot;);
  58   Copy::conjoint_words_to_lower((HeapWord*)&amp;_blocks[i+1], (HeapWord*)&amp;_blocks[i], ((_cnt-i-1)*sizeof(Block*)));
  59   pop(); // shrink list by one block
  60 }
  61 
  62 void Block_List::insert(uint i, Block *b) {
  63   push(b); // grow list by one block
  64   Copy::conjoint_words_to_higher((HeapWord*)&amp;_blocks[i], (HeapWord*)&amp;_blocks[i+1], ((_cnt-i-1)*sizeof(Block*)));
  65   _blocks[i] = b;
  66 }
  67 
  68 #ifndef PRODUCT
  69 void Block_List::print() {
  70   for (uint i=0; i &lt; size(); i++) {
  71     tty-&gt;print(&quot;B%d &quot;, _blocks[i]-&gt;_pre_order);
</pre>
<hr />
<pre>
 251       uncommon_preds++;
 252     } else {
 253       freq_preds++;
 254       if(block-&gt;_freq &lt; guard-&gt;_freq * guard_factor ) {
 255         uncommon_for_freq_preds++;
 256       }
 257     }
 258   }
 259   if( block-&gt;num_preds() &gt; 1 &amp;&amp;
 260       // The block is uncommon if all preds are uncommon or
 261       (uncommon_preds == (block-&gt;num_preds()-1) ||
 262       // it is uncommon for all frequent preds.
 263        uncommon_for_freq_preds == freq_preds) ) {
 264     return true;
 265   }
 266   return false;
 267 }
 268 
 269 #ifndef PRODUCT
 270 void Block::dump_bidx(const Block* orig, outputStream* st) const {
<span class="line-modified"> 271   if (_pre_order) st-&gt;print(&quot;B%d&quot;, _pre_order);</span>
 272   else st-&gt;print(&quot;N%d&quot;, head()-&gt;_idx);
 273 
 274   if (Verbose &amp;&amp; orig != this) {
 275     // Dump the original block&#39;s idx
 276     st-&gt;print(&quot; (&quot;);
 277     orig-&gt;dump_bidx(orig, st);
 278     st-&gt;print(&quot;)&quot;);
 279   }
 280 }
 281 
 282 void Block::dump_pred(const PhaseCFG* cfg, Block* orig, outputStream* st) const {
 283   if (is_connector()) {
 284     for (uint i=1; i&lt;num_preds(); i++) {
 285       Block *p = cfg-&gt;get_block_for_node(pred(i));
 286       p-&gt;dump_pred(cfg, orig, st);
 287     }
 288   } else {
 289     dump_bidx(orig, st);
 290     st-&gt;print(&quot; &quot;);
 291   }
 292 }
 293 
 294 void Block::dump_head(const PhaseCFG* cfg, outputStream* st) const {
<span class="line-modified"> 295   // Print the basic block.</span>
 296   dump_bidx(this, st);
<span class="line-modified"> 297   st-&gt;print(&quot;: &quot;);</span>
 298 
<span class="line-modified"> 299   // Print the outgoing CFG edges.</span>
<span class="line-added"> 300   st-&gt;print(&quot;#\tout( &quot;);</span>
 301   for( uint i=0; i&lt;_num_succs; i++ ) {
 302     non_connector_successor(i)-&gt;dump_bidx(_succs[i], st);
 303     st-&gt;print(&quot; &quot;);
 304   }
<span class="line-modified"> 305 </span>
<span class="line-added"> 306   // Print the incoming CFG edges.</span>
<span class="line-added"> 307   st-&gt;print(&quot;) &lt;- &quot;);</span>
 308   if( head()-&gt;is_block_start() ) {
<span class="line-added"> 309     st-&gt;print(&quot;in( &quot;);</span>
 310     for (uint i=1; i&lt;num_preds(); i++) {
 311       Node *s = pred(i);
 312       if (cfg != NULL) {
 313         Block *p = cfg-&gt;get_block_for_node(s);
 314         p-&gt;dump_pred(cfg, p, st);
 315       } else {
<span class="line-modified"> 316         while (!s-&gt;is_block_start()) {</span>
 317           s = s-&gt;in(0);
<span class="line-added"> 318         }</span>
 319         st-&gt;print(&quot;N%d &quot;, s-&gt;_idx );
 320       }
 321     }
<span class="line-added"> 322     st-&gt;print(&quot;) &quot;);</span>
 323   } else {
<span class="line-modified"> 324     st-&gt;print(&quot;BLOCK HEAD IS JUNK &quot;);</span>
 325   }
 326 
 327   // Print loop, if any
 328   const Block *bhead = this;    // Head of self-loop
 329   Node *bh = bhead-&gt;head();
 330 
 331   if ((cfg != NULL) &amp;&amp; bh-&gt;is_Loop() &amp;&amp; !head()-&gt;is_Root()) {
 332     LoopNode *loop = bh-&gt;as_Loop();
 333     const Block *bx = cfg-&gt;get_block_for_node(loop-&gt;in(LoopNode::LoopBackControl));
 334     while (bx-&gt;is_connector()) {
 335       bx = cfg-&gt;get_block_for_node(bx-&gt;pred(1));
 336     }
<span class="line-modified"> 337     st-&gt;print(&quot;Loop( B%d-B%d &quot;, bhead-&gt;_pre_order, bx-&gt;_pre_order);</span>
 338     // Dump any loop-specific bits, especially for CountedLoops.
 339     loop-&gt;dump_spec(st);
<span class="line-added"> 340     st-&gt;print(&quot;)&quot;);</span>
 341   } else if (has_loop_alignment()) {
<span class="line-modified"> 342     st-&gt;print(&quot;top-of-loop&quot;);</span>
 343   }
<span class="line-added"> 344 </span>
<span class="line-added"> 345   // Print frequency and other optimization-relevant information</span>
 346   st-&gt;print(&quot; Freq: %g&quot;,_freq);
 347   if( Verbose || WizardMode ) {
 348     st-&gt;print(&quot; IDom: %d/#%d&quot;, _idom ? _idom-&gt;_pre_order : 0, _dom_depth);
 349     st-&gt;print(&quot; RegPressure: %d&quot;,_reg_pressure);
 350     st-&gt;print(&quot; IHRP Index: %d&quot;,_ihrp_index);
 351     st-&gt;print(&quot; FRegPressure: %d&quot;,_freg_pressure);
 352     st-&gt;print(&quot; FHRP Index: %d&quot;,_fhrp_index);
 353   }
 354   st-&gt;cr();
 355 }
 356 
 357 void Block::dump() const {
 358   dump(NULL);
 359 }
 360 
 361 void Block::dump(const PhaseCFG* cfg) const {
 362   dump_head(cfg);
 363   for (uint i=0; i&lt; number_of_nodes(); i++) {
 364     get_node(i)-&gt;dump();
 365   }
</pre>
</td>
</tr>
</table>
<center><a href="arraycopynode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="block.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
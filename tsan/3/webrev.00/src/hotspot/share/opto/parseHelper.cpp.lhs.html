<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parseHelper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;compiler/compileLog.hpp&quot;
 28 #include &quot;oops/objArrayKlass.hpp&quot;
 29 #include &quot;opto/addnode.hpp&quot;
 30 #include &quot;opto/memnode.hpp&quot;
 31 #include &quot;opto/mulnode.hpp&quot;
 32 #include &quot;opto/parse.hpp&quot;
 33 #include &quot;opto/rootnode.hpp&quot;
 34 #include &quot;opto/runtime.hpp&quot;
 35 #include &quot;runtime/sharedRuntime.hpp&quot;
 36 
 37 //------------------------------make_dtrace_method_entry_exit ----------------
 38 // Dtrace -- record entry or exit of a method if compiled with dtrace support
 39 void GraphKit::make_dtrace_method_entry_exit(ciMethod* method, bool is_entry) {
 40   const TypeFunc *call_type    = OptoRuntime::dtrace_method_entry_exit_Type();
 41   address         call_address = is_entry ? CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry) :
 42                                             CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit);
 43   const char     *call_name    = is_entry ? &quot;dtrace_method_entry&quot; : &quot;dtrace_method_exit&quot;;
 44 
 45   // Get base of thread-local storage area
 46   Node* thread = _gvn.transform( new ThreadLocalNode() );
 47 
 48   // Get method
 49   const TypePtr* method_type = TypeMetadataPtr::make(method);
 50   Node *method_node = _gvn.transform(ConNode::make(method_type));
 51 
 52   kill_dead_locals();
 53 
 54   // For some reason, this call reads only raw memory.
 55   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
 56   make_runtime_call(RC_LEAF | RC_NARROW_MEM,
 57                     call_type, call_address,
 58                     call_name, raw_adr_type,
 59                     thread, method_node);
 60 }
 61 
 62 
 63 //=============================================================================
 64 //------------------------------do_checkcast-----------------------------------
 65 void Parse::do_checkcast() {
 66   bool will_link;
 67   ciKlass* klass = iter().get_klass(will_link);
 68 
 69   Node *obj = peek();
 70 
 71   // Throw uncommon trap if class is not loaded or the value we are casting
 72   // _from_ is not loaded, and value is not null.  If the value _is_ NULL,
 73   // then the checkcast does nothing.
 74   const TypeOopPtr *tp = _gvn.type(obj)-&gt;isa_oopptr();
 75   if (!will_link || (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
 76     if (C-&gt;log() != NULL) {
 77       if (!will_link) {
 78         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast&#39; klass=&#39;%d&#39;&quot;,
 79                        C-&gt;log()-&gt;identify(klass));
 80       }
 81       if (tp &amp;&amp; tp-&gt;klass() &amp;&amp; !tp-&gt;klass()-&gt;is_loaded()) {
 82         // %%% Cannot happen?
 83         C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;checkcast source&#39; klass=&#39;%d&#39;&quot;,
 84                        C-&gt;log()-&gt;identify(tp-&gt;klass()));
 85       }
 86     }
 87     null_assert(obj);
 88     assert( stopped() || _gvn.type(peek())-&gt;higher_equal(TypePtr::NULL_PTR), &quot;what&#39;s left behind is null&quot; );
 89     if (!stopped()) {
 90       profile_null_checkcast();
 91     }
 92     return;
 93   }
 94 
 95   Node *res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)) );
 96 
 97   // Pop from stack AFTER gen_checkcast because it can uncommon trap and
 98   // the debug info has to be correct.
 99   pop();
100   push(res);
101 }
102 
103 
104 //------------------------------do_instanceof----------------------------------
105 void Parse::do_instanceof() {
106   if (stopped())  return;
107   // We would like to return false if class is not loaded, emitting a
108   // dependency, but Java requires instanceof to load its operand.
109 
110   // Throw uncommon trap if class is not loaded
111   bool will_link;
112   ciKlass* klass = iter().get_klass(will_link);
113 
114   if (!will_link) {
115     if (C-&gt;log() != NULL) {
116       C-&gt;log()-&gt;elem(&quot;assert_null reason=&#39;instanceof&#39; klass=&#39;%d&#39;&quot;,
117                      C-&gt;log()-&gt;identify(klass));
118     }
119     null_assert(peek());
120     assert( stopped() || _gvn.type(peek())-&gt;higher_equal(TypePtr::NULL_PTR), &quot;what&#39;s left behind is null&quot; );
121     if (!stopped()) {
122       // The object is now known to be null.
123       // Shortcut the effect of gen_instanceof and return &quot;false&quot; directly.
124       pop();                   // pop the null
125       push(_gvn.intcon(0));    // push false answer
126     }
127     return;
128   }
129 
130   // Push the bool result back on stack
131   Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);
132 
133   // Pop from stack AFTER gen_instanceof because it can uncommon trap.
134   pop();
135   push(res);
136 }
137 
138 //------------------------------array_store_check------------------------------
139 // pull array from stack and check that the store is valid
140 void Parse::array_store_check() {
141 
142   // Shorthand access to array store elements without popping them.
143   Node *obj = peek(0);
144   Node *idx = peek(1);
145   Node *ary = peek(2);
146 
147   if (_gvn.type(obj) == TypePtr::NULL_PTR) {
148     // There&#39;s never a type check on null values.
149     // This cutout lets us avoid the uncommon_trap(Reason_array_check)
150     // below, which turns into a performance liability if the
151     // gen_checkcast folds up completely.
152     return;
153   }
154 
155   // Extract the array klass type
156   int klass_offset = oopDesc::klass_offset_in_bytes();
157   Node* p = basic_plus_adr( ary, ary, klass_offset );
158   // p&#39;s type is array-of-OOPS plus klass_offset
159   Node* array_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS));
160   // Get the array klass
161   const TypeKlassPtr *tak = _gvn.type(array_klass)-&gt;is_klassptr();
162 
163   // The type of array_klass is usually INexact array-of-oop.  Heroically
164   // cast array_klass to EXACT array and uncommon-trap if the cast fails.
165   // Make constant out of the inexact array klass, but use it only if the cast
166   // succeeds.
167   bool always_see_exact_class = false;
168   if (MonomorphicArrayCheck
169       &amp;&amp; !too_many_traps(Deoptimization::Reason_array_check)
170       &amp;&amp; !tak-&gt;klass_is_exact()
171       &amp;&amp; tak != TypeKlassPtr::OBJECT) {
172       // Regarding the fourth condition in the if-statement from above:
173       //
174       // If the compiler has determined that the type of array &#39;ary&#39; (represented
175       // by &#39;array_klass&#39;) is java/lang/Object, the compiler must not assume that
176       // the array &#39;ary&#39; is monomorphic.
177       //
178       // If &#39;ary&#39; were of type java/lang/Object, this arraystore would have to fail,
179       // because it is not possible to perform a arraystore into an object that is not
180       // a &quot;proper&quot; array.
181       //
182       // Therefore, let&#39;s obtain at runtime the type of &#39;ary&#39; and check if we can still
183       // successfully perform the store.
184       //
185       // The implementation reasons for the condition are the following:
186       //
187       // java/lang/Object is the superclass of all arrays, but it is represented by the VM
188       // as an InstanceKlass. The checks generated by gen_checkcast() (see below) expect
189       // &#39;array_klass&#39; to be ObjArrayKlass, which can result in invalid memory accesses.
190       //
191       // See issue JDK-8057622 for details.
192 
193     always_see_exact_class = true;
194     // (If no MDO at all, hope for the best, until a trap actually occurs.)
195 
196     // Make a constant out of the inexact array klass
197     const TypeKlassPtr *extak = tak-&gt;cast_to_exactness(true)-&gt;is_klassptr();
198     Node* con = makecon(extak);
199     Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));
200     Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));
201     Node* ctrl= control();
202     { BuildCutout unless(this, bol, PROB_MAX);
203       uncommon_trap(Deoptimization::Reason_array_check,
204                     Deoptimization::Action_maybe_recompile,
205                     tak-&gt;klass());
206     }
207     if (stopped()) {          // MUST uncommon-trap?
208       set_control(ctrl);      // Then Don&#39;t Do It, just fall into the normal checking
209     } else {                  // Cast array klass to exactness:
210       // Use the exact constant value we know it is.
211       replace_in_map(array_klass,con);
212       CompileLog* log = C-&gt;log();
213       if (log != NULL) {
214         log-&gt;elem(&quot;cast_up reason=&#39;monomorphic_array&#39; from=&#39;%d&#39; to=&#39;(exact)&#39;&quot;,
215                   log-&gt;identify(tak-&gt;klass()));
216       }
217       array_klass = con;      // Use cast value moving forward
218     }
219   }
220 
221   // Come here for polymorphic array klasses
222 
223   // Extract the array element class
224   int element_klass_offset = in_bytes(ObjArrayKlass::element_klass_offset());
225   Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);
226   // We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,
227   // we must set a control edge from the IfTrue node created by the uncommon_trap above to the
228   // LoadKlassNode.
229   Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : NULL,
230                                                        immutable_memory(), p2, tak));
231 
232   // Check (the hard way) and throw if not a subklass.
233   // Result is ignored, we just need the CFG effects.
234   gen_checkcast(obj, a_e_klass);
235 }
236 
237 
<a name="1" id="anc1"></a><span class="line-removed">238 void Parse::emit_guard_for_new(ciInstanceKlass* klass) {</span>
<span class="line-removed">239   // Emit guarded new</span>
<span class="line-removed">240   //   if (klass-&gt;_init_thread != current_thread ||</span>
<span class="line-removed">241   //       klass-&gt;_init_state != being_initialized)</span>
<span class="line-removed">242   //      uncommon_trap</span>
<span class="line-removed">243   Node* cur_thread = _gvn.transform( new ThreadLocalNode() );</span>
<span class="line-removed">244   Node* merge = new RegionNode(3);</span>
<span class="line-removed">245   _gvn.set_type(merge, Type::CONTROL);</span>
<span class="line-removed">246   Node* kls = makecon(TypeKlassPtr::make(klass));</span>
<span class="line-removed">247 </span>
<span class="line-removed">248   Node* init_thread_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_thread_offset()));</span>
<span class="line-removed">249   Node* adr_node = basic_plus_adr(kls, kls, init_thread_offset);</span>
<span class="line-removed">250   Node* init_thread = make_load(NULL, adr_node, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);</span>
<span class="line-removed">251   Node *tst   = Bool( CmpP( init_thread, cur_thread), BoolTest::eq);</span>
<span class="line-removed">252   IfNode* iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">253   set_control(IfTrue(iff));</span>
<span class="line-removed">254   merge-&gt;set_req(1, IfFalse(iff));</span>
<span class="line-removed">255 </span>
<span class="line-removed">256   Node* init_state_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_state_offset()));</span>
<span class="line-removed">257   adr_node = basic_plus_adr(kls, kls, init_state_offset);</span>
<span class="line-removed">258   // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler</span>
<span class="line-removed">259   // can generate code to load it as unsigned byte.</span>
<span class="line-removed">260   Node* init_state = make_load(NULL, adr_node, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);</span>
<span class="line-removed">261   Node* being_init = _gvn.intcon(InstanceKlass::being_initialized);</span>
<span class="line-removed">262   tst   = Bool( CmpI( init_state, being_init), BoolTest::eq);</span>
<span class="line-removed">263   iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">264   set_control(IfTrue(iff));</span>
<span class="line-removed">265   merge-&gt;set_req(2, IfFalse(iff));</span>
<span class="line-removed">266 </span>
<span class="line-removed">267   PreserveJVMState pjvms(this);</span>
<span class="line-removed">268   record_for_igvn(merge);</span>
<span class="line-removed">269   set_control(merge);</span>
<span class="line-removed">270 </span>
<span class="line-removed">271   uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-removed">272                 Deoptimization::Action_reinterpret,</span>
<span class="line-removed">273                 klass);</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 </span>
277 //------------------------------do_new-----------------------------------------
278 void Parse::do_new() {
279   kill_dead_locals();
280 
281   bool will_link;
282   ciInstanceKlass* klass = iter().get_klass(will_link)-&gt;as_instance_klass();
283   assert(will_link, &quot;_new: typeflow responsibility&quot;);
284 
<a name="2" id="anc2"></a><span class="line-modified">285   // Should initialize, or throw an InstantiationError?</span>
<span class="line-modified">286   if ((!klass-&gt;is_initialized() &amp;&amp; !klass-&gt;is_being_initialized()) ||</span>
<span class="line-removed">287       klass-&gt;is_abstract() || klass-&gt;is_interface() ||</span>
288       klass-&gt;name() == ciSymbol::java_lang_Class() ||
289       iter().is_unresolved_klass()) {
<a name="3" id="anc3"></a><span class="line-modified">290     uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-modified">291                   Deoptimization::Action_reinterpret,</span>
292                   klass);
293     return;
294   }
<a name="4" id="anc4"></a><span class="line-modified">295   if (klass-&gt;is_being_initialized()) {</span>
<span class="line-modified">296     emit_guard_for_new(klass);</span>


297   }
298 
299   Node* kls = makecon(TypeKlassPtr::make(klass));
300   Node* obj = new_instance(kls);
301 
302   // Push resultant oop onto stack
303   push(obj);
304 
305   // Keep track of whether opportunities exist for StringBuilder
306   // optimizations.
307   if (OptimizeStringConcat &amp;&amp;
308       (klass == C-&gt;env()-&gt;StringBuilder_klass() ||
309        klass == C-&gt;env()-&gt;StringBuffer_klass())) {
310     C-&gt;set_has_stringbuilder(true);
311   }
312 
313   // Keep track of boxed values for EliminateAutoBox optimizations.
314   if (C-&gt;eliminate_boxing() &amp;&amp; klass-&gt;is_box_klass()) {
315     C-&gt;set_has_boxed_value(true);
316   }
317 }
318 
319 #ifndef PRODUCT
320 //------------------------------dump_map_adr_mem-------------------------------
321 // Debug dump of the mapping from address types to MergeMemNode indices.
322 void Parse::dump_map_adr_mem() const {
323   tty-&gt;print_cr(&quot;--- Mapping from address types to memory Nodes ---&quot;);
324   MergeMemNode *mem = map() == NULL ? NULL : (map()-&gt;memory()-&gt;is_MergeMem() ?
325                                       map()-&gt;memory()-&gt;as_MergeMem() : NULL);
326   for (uint i = 0; i &lt; (uint)C-&gt;num_alias_types(); i++) {
327     C-&gt;alias_type(i)-&gt;print_on(tty);
328     tty-&gt;print(&quot;\t&quot;);
329     // Node mapping, if any
330     if (mem &amp;&amp; i &lt; mem-&gt;req() &amp;&amp; mem-&gt;in(i) &amp;&amp; mem-&gt;in(i) != mem-&gt;empty_memory()) {
331       mem-&gt;in(i)-&gt;dump();
332     } else {
333       tty-&gt;cr();
334     }
335   }
336 }
337 
338 #endif
339 
340 
341 //=============================================================================
342 //
343 // parser methods for profiling
344 
345 
346 //----------------------test_counter_against_threshold ------------------------
347 void Parse::test_counter_against_threshold(Node* cnt, int limit) {
348   // Test the counter against the limit and uncommon trap if greater.
349 
350   // This code is largely copied from the range check code in
351   // array_addressing()
352 
353   // Test invocation count vs threshold
354   Node *threshold = makecon(TypeInt::make(limit));
355   Node *chk   = _gvn.transform( new CmpUNode( cnt, threshold) );
356   BoolTest::mask btest = BoolTest::lt;
357   Node *tst   = _gvn.transform( new BoolNode( chk, btest) );
358   // Branch to failure if threshold exceeded
359   { BuildCutout unless(this, tst, PROB_ALWAYS);
360     uncommon_trap(Deoptimization::Reason_age,
361                   Deoptimization::Action_maybe_recompile);
362   }
363 }
364 
365 //----------------------increment_and_test_invocation_counter-------------------
366 void Parse::increment_and_test_invocation_counter(int limit) {
367   if (!count_invocations()) return;
368 
369   // Get the Method* node.
370   ciMethod* m = method();
371   MethodCounters* counters_adr = m-&gt;ensure_method_counters();
372   if (counters_adr == NULL) {
373     C-&gt;record_failure(&quot;method counters allocation failed&quot;);
374     return;
375   }
376 
377   Node* ctrl = control();
378   const TypePtr* adr_type = TypeRawPtr::make((address) counters_adr);
379   Node *counters_node = makecon(adr_type);
380   Node* adr_iic_node = basic_plus_adr(counters_node, counters_node,
381     MethodCounters::interpreter_invocation_counter_offset_in_bytes());
382   Node* cnt = make_load(ctrl, adr_iic_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
383 
384   test_counter_against_threshold(cnt, limit);
385 
386   // Add one to the counter and store
387   Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(1)));
388   store_to_memory(ctrl, adr_iic_node, incr, T_INT, adr_type, MemNode::unordered);
389 }
390 
391 //----------------------------method_data_addressing---------------------------
392 Node* Parse::method_data_addressing(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {
393   // Get offset within MethodData* of the data array
394   ByteSize data_offset = MethodData::data_offset();
395 
396   // Get cell offset of the ProfileData within data array
397   int cell_offset = md-&gt;dp_to_di(data-&gt;dp());
398 
399   // Add in counter_offset, the # of bytes into the ProfileData of counter or flag
400   int offset = in_bytes(data_offset) + cell_offset + in_bytes(counter_offset);
401 
402   const TypePtr* adr_type = TypeMetadataPtr::make(md);
403   Node* mdo = makecon(adr_type);
404   Node* ptr = basic_plus_adr(mdo, mdo, offset);
405 
406   if (stride != 0) {
407     Node* str = _gvn.MakeConX(stride);
408     Node* scale = _gvn.transform( new MulXNode( idx, str ) );
409     ptr   = _gvn.transform( new AddPNode( mdo, ptr, scale ) );
410   }
411 
412   return ptr;
413 }
414 
415 //--------------------------increment_md_counter_at----------------------------
416 void Parse::increment_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {
417   Node* adr_node = method_data_addressing(md, data, counter_offset, idx, stride);
418 
419   const TypePtr* adr_type = _gvn.type(adr_node)-&gt;is_ptr();
420   Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
421   Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(DataLayout::counter_increment)));
422   store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);
423 }
424 
425 //--------------------------test_for_osr_md_counter_at-------------------------
426 void Parse::test_for_osr_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, int limit) {
427   Node* adr_node = method_data_addressing(md, data, counter_offset);
428 
429   const TypePtr* adr_type = _gvn.type(adr_node)-&gt;is_ptr();
430   Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
431 
432   test_counter_against_threshold(cnt, limit);
433 }
434 
435 //-------------------------------set_md_flag_at--------------------------------
436 void Parse::set_md_flag_at(ciMethodData* md, ciProfileData* data, int flag_constant) {
437   Node* adr_node = method_data_addressing(md, data, DataLayout::flags_offset());
438 
439   const TypePtr* adr_type = _gvn.type(adr_node)-&gt;is_ptr();
440   Node* flags = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
441   Node* incr = _gvn.transform(new OrINode(flags, _gvn.intcon(flag_constant)));
442   store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);
443 }
444 
445 //----------------------------profile_taken_branch-----------------------------
446 void Parse::profile_taken_branch(int target_bci, bool force_update) {
447   // This is a potential osr_site if we have a backedge.
448   int cur_bci = bci();
449   bool osr_site =
450     (target_bci &lt;= cur_bci) &amp;&amp; count_invocations() &amp;&amp; UseOnStackReplacement;
451 
452   // If we are going to OSR, restart at the target bytecode.
453   set_bci(target_bci);
454 
455   // To do: factor out the the limit calculations below. These duplicate
456   // the similar limit calculations in the interpreter.
457 
458   if (method_data_update() || force_update) {
459     ciMethodData* md = method()-&gt;method_data();
460     assert(md != NULL, &quot;expected valid ciMethodData&quot;);
461     ciProfileData* data = md-&gt;bci_to_data(cur_bci);
462     assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
463     increment_md_counter_at(md, data, JumpData::taken_offset());
464   }
465 
466   // In the new tiered system this is all we need to do. In the old
467   // (c2 based) tiered sytem we must do the code below.
468 #ifndef TIERED
469   if (method_data_update()) {
470     ciMethodData* md = method()-&gt;method_data();
471     if (osr_site) {
472       ciProfileData* data = md-&gt;bci_to_data(cur_bci);
473       assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
474       int limit = (int)((int64_t)CompileThreshold
475                    * (OnStackReplacePercentage - InterpreterProfilePercentage) / 100);
476       test_for_osr_md_counter_at(md, data, JumpData::taken_offset(), limit);
477     }
478   } else {
479     // With method data update off, use the invocation counter to trigger an
480     // OSR compilation, as done in the interpreter.
481     if (osr_site) {
482       int limit = (int)((int64_t)CompileThreshold * OnStackReplacePercentage / 100);
483       increment_and_test_invocation_counter(limit);
484     }
485   }
486 #endif // TIERED
487 
488   // Restore the original bytecode.
489   set_bci(cur_bci);
490 }
491 
492 //--------------------------profile_not_taken_branch---------------------------
493 void Parse::profile_not_taken_branch(bool force_update) {
494 
495   if (method_data_update() || force_update) {
496     ciMethodData* md = method()-&gt;method_data();
497     assert(md != NULL, &quot;expected valid ciMethodData&quot;);
498     ciProfileData* data = md-&gt;bci_to_data(bci());
499     assert(data != NULL &amp;&amp; data-&gt;is_BranchData(), &quot;need BranchData for not taken branch&quot;);
500     increment_md_counter_at(md, data, BranchData::not_taken_offset());
501   }
502 
503 }
504 
505 //---------------------------------profile_call--------------------------------
506 void Parse::profile_call(Node* receiver) {
507   if (!method_data_update()) return;
508 
509   switch (bc()) {
510   case Bytecodes::_invokevirtual:
511   case Bytecodes::_invokeinterface:
512     profile_receiver_type(receiver);
513     break;
514   case Bytecodes::_invokestatic:
515   case Bytecodes::_invokedynamic:
516   case Bytecodes::_invokespecial:
517     profile_generic_call();
518     break;
519   default: fatal(&quot;unexpected call bytecode&quot;);
520   }
521 }
522 
523 //------------------------------profile_generic_call---------------------------
524 void Parse::profile_generic_call() {
525   assert(method_data_update(), &quot;must be generating profile code&quot;);
526 
527   ciMethodData* md = method()-&gt;method_data();
528   assert(md != NULL, &quot;expected valid ciMethodData&quot;);
529   ciProfileData* data = md-&gt;bci_to_data(bci());
530   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for not taken branch&quot;);
531   increment_md_counter_at(md, data, CounterData::count_offset());
532 }
533 
534 //-----------------------------profile_receiver_type---------------------------
535 void Parse::profile_receiver_type(Node* receiver) {
536   assert(method_data_update(), &quot;must be generating profile code&quot;);
537 
538   ciMethodData* md = method()-&gt;method_data();
539   assert(md != NULL, &quot;expected valid ciMethodData&quot;);
540   ciProfileData* data = md-&gt;bci_to_data(bci());
541   assert(data != NULL &amp;&amp; data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData here&quot;);
542 
543   // Skip if we aren&#39;t tracking receivers
544   if (TypeProfileWidth &lt; 1) {
545     increment_md_counter_at(md, data, CounterData::count_offset());
546     return;
547   }
548   ciReceiverTypeData* rdata = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();
549 
550   Node* method_data = method_data_addressing(md, rdata, in_ByteSize(0));
551 
552   // Using an adr_type of TypePtr::BOTTOM to work around anti-dep problems.
553   // A better solution might be to use TypeRawPtr::BOTTOM with RC_NARROW_MEM.
554   make_runtime_call(RC_LEAF, OptoRuntime::profile_receiver_type_Type(),
555                     CAST_FROM_FN_PTR(address,
556                                      OptoRuntime::profile_receiver_type_C),
557                     &quot;profile_receiver_type_C&quot;,
558                     TypePtr::BOTTOM,
559                     method_data, receiver);
560 }
561 
562 //---------------------------------profile_ret---------------------------------
563 void Parse::profile_ret(int target_bci) {
564   if (!method_data_update()) return;
565 
566   // Skip if we aren&#39;t tracking ret targets
567   if (TypeProfileWidth &lt; 1) return;
568 
569   ciMethodData* md = method()-&gt;method_data();
570   assert(md != NULL, &quot;expected valid ciMethodData&quot;);
571   ciProfileData* data = md-&gt;bci_to_data(bci());
572   assert(data != NULL &amp;&amp; data-&gt;is_RetData(), &quot;need RetData for ret&quot;);
573   ciRetData* ret_data = (ciRetData*)data-&gt;as_RetData();
574 
575   // Look for the target_bci is already in the table
576   uint row;
577   bool table_full = true;
578   for (row = 0; row &lt; ret_data-&gt;row_limit(); row++) {
579     int key = ret_data-&gt;bci(row);
580     table_full &amp;= (key != RetData::no_bci);
581     if (key == target_bci) break;
582   }
583 
584   if (row &gt;= ret_data-&gt;row_limit()) {
585     // The target_bci was not found in the table.
586     if (!table_full) {
587       // XXX: Make slow call to update RetData
588     }
589     return;
590   }
591 
592   // the target_bci is already in the table
593   increment_md_counter_at(md, data, RetData::bci_count_offset(row));
594 }
595 
596 //--------------------------profile_null_checkcast----------------------------
597 void Parse::profile_null_checkcast() {
598   // Set the null-seen flag, done in conjunction with the usual null check. We
599   // never unset the flag, so this is a one-way switch.
600   if (!method_data_update()) return;
601 
602   ciMethodData* md = method()-&gt;method_data();
603   assert(md != NULL, &quot;expected valid ciMethodData&quot;);
604   ciProfileData* data = md-&gt;bci_to_data(bci());
605   assert(data != NULL &amp;&amp; data-&gt;is_BitData(), &quot;need BitData for checkcast&quot;);
606   set_md_flag_at(md, data, BitData::null_seen_byte_constant());
607 }
608 
609 //-----------------------------profile_switch_case-----------------------------
610 void Parse::profile_switch_case(int table_index) {
611   if (!method_data_update()) return;
612 
613   ciMethodData* md = method()-&gt;method_data();
614   assert(md != NULL, &quot;expected valid ciMethodData&quot;);
615 
616   ciProfileData* data = md-&gt;bci_to_data(bci());
617   assert(data != NULL &amp;&amp; data-&gt;is_MultiBranchData(), &quot;need MultiBranchData for switch case&quot;);
618   if (table_index &gt;= 0) {
619     increment_md_counter_at(md, data, MultiBranchData::case_count_offset(table_index));
620   } else {
621     increment_md_counter_at(md, data, MultiBranchData::default_count_offset());
622   }
623 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,12 +39,15 @@</span>
  #include &quot;opto/machnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/subtypenode.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/bitMap.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //----------------------------GraphKit-----------------------------------------
  // Main utility constructor.
  GraphKit::GraphKit(JVMState* jvms)
    : Phase(Phase::Parser),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1360,39 +1363,41 @@</span>
      return zerocon(type);
    }
  
    // Cast obj to not-null on this path, if there is no null_control.
    // (If there is a null_control, a non-null value may come back to haunt us.)
<span class="udiff-line-modified-removed">-   if (type == T_OBJECT) {</span>
<span class="udiff-line-removed">-     Node* cast = cast_not_null(value, false);</span>
<span class="udiff-line-removed">-     if (null_control == NULL || (*null_control) == top())</span>
<span class="udiff-line-removed">-       replace_in_map(value, cast);</span>
<span class="udiff-line-removed">-     value = cast;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return value;</span>
<span class="udiff-line-modified-added">+   return cast_not_null(value, (null_control == NULL || (*null_control) == top()));</span>
  }
  
  
  //------------------------------cast_not_null----------------------------------
  // Cast obj to not-null on this path
  Node* GraphKit::cast_not_null(Node* obj, bool do_replace_in_map) {
<span class="udiff-line-modified-removed">-   const Type *t = _gvn.type(obj);</span>
<span class="udiff-line-modified-removed">-   const Type *t_not_null = t-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-modified-removed">-   // Object is already not-null?</span>
<span class="udiff-line-modified-removed">-   if( t == t_not_null ) return obj;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   Node *cast = new CastPPNode(obj,t_not_null);</span>
<span class="udiff-line-modified-removed">-   cast-&gt;init_req(0, control());</span>
<span class="udiff-line-modified-removed">-   cast = _gvn.transform( cast );</span>
<span class="udiff-line-modified-added">+   Node* cast = NULL;</span>
<span class="udiff-line-modified-added">+   const Type* t = _gvn.type(obj);</span>
<span class="udiff-line-modified-added">+   if (t-&gt;make_ptr() != NULL) {</span>
<span class="udiff-line-modified-added">+     const Type* t_not_null = t-&gt;join_speculative(TypePtr::NOTNULL);</span>
<span class="udiff-line-modified-added">+     // Object is already not-null?</span>
<span class="udiff-line-modified-added">+     if (t == t_not_null) {</span>
<span class="udiff-line-modified-added">+       return obj;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     cast = ConstraintCastNode::make_cast(Op_CastPP, control(), obj, t_not_null, false);</span>
<span class="udiff-line-added">+   } else if (t-&gt;isa_int() != NULL) {</span>
<span class="udiff-line-added">+     cast = ConstraintCastNode::make_cast(Op_CastII, control(), obj, TypeInt::INT, true);</span>
<span class="udiff-line-added">+   } else if (t-&gt;isa_long() != NULL) {</span>
<span class="udiff-line-added">+     cast = ConstraintCastNode::make_cast(Op_CastLL, control(), obj, TypeLong::LONG, true);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     fatal(&quot;unexpected type: %s&quot;, type2name(t-&gt;basic_type()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   cast = _gvn.transform(cast);</span>
  
    // Scan for instances of &#39;obj&#39; in the current JVM mapping.
    // These instances are known to be not-null after the test.
<span class="udiff-line-modified-removed">-   if (do_replace_in_map)</span>
<span class="udiff-line-modified-added">+   if (do_replace_in_map) {</span>
      replace_in_map(obj, cast);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   return cast;                  // Return casted value</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return cast;</span>
  }
  
  // Sometimes in intrinsics, we implicitly know an object is not null
  // (there&#39;s no actual null check) so we can cast it to not null. In
  // the course of optimizations, the input to the cast can become null.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1401,18 +1406,21 @@</span>
  // add a check for null for which one branch can&#39;t be taken. It uses
  // an Opaque4 node that will cause the check to be removed after loop
  // opts so the test goes away and the compiled code doesn&#39;t execute a
  // useless check.
  Node* GraphKit::must_be_not_null(Node* value, bool do_replace_in_map) {
<span class="udiff-line-added">+   if (!TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(value))) {</span>
<span class="udiff-line-added">+     return value;</span>
<span class="udiff-line-added">+   }</span>
    Node* chk = _gvn.transform(new CmpPNode(value, null()));
    Node *tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));
    Node* opaq = _gvn.transform(new Opaque4Node(C, tst, intcon(1)));
    IfNode *iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);
    _gvn.set_type(iff, iff-&gt;Value(&amp;_gvn));
    Node *if_f = _gvn.transform(new IfFalseNode(iff));
    Node *frame = _gvn.transform(new ParmNode(C-&gt;start(), TypeFunc::FramePtr));
<span class="udiff-line-modified-removed">-   Node *halt = _gvn.transform(new HaltNode(if_f, frame));</span>
<span class="udiff-line-modified-added">+   Node* halt = _gvn.transform(new HaltNode(if_f, frame, &quot;unexpected null in intrinsic&quot;));</span>
    C-&gt;root()-&gt;add_req(halt);
    Node *if_t = _gvn.transform(new IfTrueNode(iff));
    set_control(if_t);
    return cast_not_null(value, do_replace_in_map);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1488,22 +1496,23 @@</span>
                            MemNode::MemOrd mo,
                            LoadNode::ControlDependency control_dependency,
                            bool require_atomic_access,
                            bool unaligned,
                            bool mismatched,
<span class="udiff-line-modified-removed">-                           bool unsafe) {</span>
<span class="udiff-line-modified-added">+                           bool unsafe,</span>
<span class="udiff-line-added">+                           uint8_t barrier_data) {</span>
    assert(adr_idx != Compile::AliasIdxTop, &quot;use other make_load factory&quot; );
    const TypePtr* adr_type = NULL; // debug-mode-only argument
    debug_only(adr_type = C-&gt;get_adr_type(adr_idx));
    Node* mem = memory(adr_idx);
    Node* ld;
    if (require_atomic_access &amp;&amp; bt == T_LONG) {
<span class="udiff-line-modified-removed">-     ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe);</span>
<span class="udiff-line-modified-added">+     ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);</span>
    } else if (require_atomic_access &amp;&amp; bt == T_DOUBLE) {
<span class="udiff-line-modified-removed">-     ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe);</span>
<span class="udiff-line-modified-added">+     ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);</span>
    } else {
<span class="udiff-line-modified-removed">-     ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe);</span>
<span class="udiff-line-modified-added">+     ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);</span>
    }
    ld = _gvn.transform(ld);
    if (((bt == T_OBJECT) &amp;&amp; C-&gt;do_escape_analysis()) || C-&gt;eliminate_boxing()) {
      // Improve graph before escape analysis and boxing elimination.
      record_for_igvn(ld);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1690,18 +1699,10 @@</span>
  
  void GraphKit::access_clone(Node* src, Node* dst, Node* size, bool is_array) {
    return _barrier_set-&gt;clone(this, src, dst, size, is_array);
  }
  
<span class="udiff-line-removed">- Node* GraphKit::access_resolve(Node* n, DecoratorSet decorators) {</span>
<span class="udiff-line-removed">-   // Use stronger ACCESS_WRITE|ACCESS_READ by default.</span>
<span class="udiff-line-removed">-   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {</span>
<span class="udiff-line-removed">-     decorators |= ACCESS_READ | ACCESS_WRITE;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return _barrier_set-&gt;resolve(this, n, decorators);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //-------------------------array_element_address-------------------------
  Node* GraphKit::array_element_address(Node* ary, Node* idx, BasicType elembt,
                                        const TypeInt* sizetype, Node* ctrl) {
    uint shift  = exact_log2(type2aelembytes(elembt));
    uint header = arrayOopDesc::base_offset_in_bytes(elembt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1857,10 +1858,22 @@</span>
      // This is not a &quot;slow path&quot; call; all memory comes from the call.
      set_all_memory_call(call);
    }
  }
  
<span class="udiff-line-added">+ // Keep track of MergeMems feeding into other MergeMems</span>
<span class="udiff-line-added">+ static void add_mergemem_users_to_worklist(Unique_Node_List&amp; wl, Node* mem) {</span>
<span class="udiff-line-added">+   if (!mem-&gt;is_MergeMem()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (SimpleDUIterator i(mem); i.has_next(); i.next()) {</span>
<span class="udiff-line-added">+     Node* use = i.get();</span>
<span class="udiff-line-added">+     if (use-&gt;is_MergeMem()) {</span>
<span class="udiff-line-added">+       wl.push(use);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  // Replace the call with the current state of the kit.
  void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {
    JVMState* ejvms = NULL;
    if (has_exceptions()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1875,10 +1888,11 @@</span>
  
    // Find all the needed outputs of this call
    CallProjections callprojs;
    call-&gt;extract_projections(&amp;callprojs, true);
  
<span class="udiff-line-added">+   Unique_Node_List wl;</span>
    Node* init_mem = call-&gt;in(TypeFunc::Memory);
    Node* final_mem = final_state-&gt;in(TypeFunc::Memory);
    Node* final_ctl = final_state-&gt;in(TypeFunc::Control);
    Node* final_io = final_state-&gt;in(TypeFunc::I_O);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1890,10 +1904,11 @@</span>
      if (final_mem-&gt;is_MergeMem()) {
        // Parser&#39;s exits MergeMem was not transformed but may be optimized
        final_mem = _gvn.transform(final_mem);
      }
      C-&gt;gvn_replace_by(callprojs.fallthrough_memproj,   final_mem);
<span class="udiff-line-added">+     add_mergemem_users_to_worklist(wl, final_mem);</span>
    }
    if (callprojs.fallthrough_ioproj != NULL) {
      C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj,    final_io);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1929,11 +1944,13 @@</span>
      if (callprojs.catchall_catchproj != NULL) {
        C-&gt;gvn_replace_by(callprojs.catchall_catchproj, ekit.control());
        ex_ctl = ekit.control();
      }
      if (callprojs.catchall_memproj != NULL) {
<span class="udiff-line-modified-removed">-       C-&gt;gvn_replace_by(callprojs.catchall_memproj,   ekit.reset_memory());</span>
<span class="udiff-line-modified-added">+       Node* ex_mem = ekit.reset_memory();</span>
<span class="udiff-line-added">+       C-&gt;gvn_replace_by(callprojs.catchall_memproj,   ex_mem);</span>
<span class="udiff-line-added">+       add_mergemem_users_to_worklist(wl, ex_mem);</span>
      }
      if (callprojs.catchall_ioproj != NULL) {
        C-&gt;gvn_replace_by(callprojs.catchall_ioproj,    ekit.i_o());
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1947,21 +1964,12 @@</span>
    call-&gt;disconnect_inputs(NULL, C);
    C-&gt;gvn_replace_by(call, C-&gt;top());
  
    // Clean up any MergeMems that feed other MergeMems since the
    // optimizer doesn&#39;t like that.
<span class="udiff-line-modified-removed">-   if (final_mem-&gt;is_MergeMem()) {</span>
<span class="udiff-line-modified-removed">-     Node_List wl;</span>
<span class="udiff-line-removed">-     for (SimpleDUIterator i(final_mem); i.has_next(); i.next()) {</span>
<span class="udiff-line-removed">-       Node* m = i.get();</span>
<span class="udiff-line-removed">-       if (m-&gt;is_MergeMem() &amp;&amp; !wl.contains(m)) {</span>
<span class="udiff-line-removed">-         wl.push(m);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     while (wl.size()  &gt; 0) {</span>
<span class="udiff-line-removed">-       _gvn.transform(wl.pop());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   while (wl.size() &gt; 0) {</span>
<span class="udiff-line-modified-added">+     _gvn.transform(wl.pop());</span>
    }
  
    if (callprojs.fallthrough_catchproj != NULL &amp;&amp; !final_ctl-&gt;is_top() &amp;&amp; do_replaced_nodes) {
      replaced_nodes.apply(C, final_ctl);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2105,11 +2113,11 @@</span>
  
    call-&gt;set_req(TypeFunc::ReturnAdr, returnadr());
    // The debug info is the only real input to this call.
  
    // Halt-and-catch fire here.  The above call should never return!
<span class="udiff-line-modified-removed">-   HaltNode* halt = new HaltNode(control(), frameptr());</span>
<span class="udiff-line-modified-added">+   HaltNode* halt = new HaltNode(control(), frameptr(), &quot;uncommon trap returned which should never happen&quot;);</span>
    _gvn.set_type_bottom(halt);
    root()-&gt;add_req(halt);
  
    stop_and_kill_map();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2134,26 +2142,10 @@</span>
    }
    return NULL;
  }
  
  
<span class="udiff-line-removed">- void GraphKit::round_double_arguments(ciMethod* dest_method) {</span>
<span class="udiff-line-removed">-   // (Note:  TypeFunc::make has a cache that makes this fast.)</span>
<span class="udiff-line-removed">-   const TypeFunc* tf    = TypeFunc::make(dest_method);</span>
<span class="udiff-line-removed">-   int             nargs = tf-&gt;domain()-&gt;cnt() - TypeFunc::Parms;</span>
<span class="udiff-line-removed">-   for (int j = 0; j &lt; nargs; j++) {</span>
<span class="udiff-line-removed">-     const Type *targ = tf-&gt;domain()-&gt;field_at(j + TypeFunc::Parms);</span>
<span class="udiff-line-removed">-     if( targ-&gt;basic_type() == T_DOUBLE ) {</span>
<span class="udiff-line-removed">-       // If any parameters are doubles, they must be rounded before</span>
<span class="udiff-line-removed">-       // the call, dstore_rounding does gvn.transform</span>
<span class="udiff-line-removed">-       Node *arg = argument(j);</span>
<span class="udiff-line-removed">-       arg = dstore_rounding(arg);</span>
<span class="udiff-line-removed">-       set_argument(j, arg);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  /**
   * Record profiling data exact_kls for Node n with the type system so
   * that it can propagate it (speculation)
   *
   * @param n          node that the type applies to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2265,11 +2257,11 @@</span>
    const TypeFunc* tf    = TypeFunc::make(dest_method);
    int             nargs = tf-&gt;domain()-&gt;cnt() - TypeFunc::Parms;
    int skip = Bytecodes::has_receiver(bc) ? 1 : 0;
    for (int j = skip, i = 0; j &lt; nargs &amp;&amp; i &lt; TypeProfileArgsLimit; j++) {
      const Type *targ = tf-&gt;domain()-&gt;field_at(j + TypeFunc::Parms);
<span class="udiff-line-modified-removed">-     if (targ-&gt;basic_type() == T_OBJECT || targ-&gt;basic_type() == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(targ-&gt;basic_type())) {</span>
        ProfilePtrKind ptr_kind = ProfileMaybeNull;
        ciKlass* better_type = NULL;
        if (method()-&gt;argument_profiled_type(bci(), i, better_type, ptr_kind)) {
          record_profile_for_speculation(argument(j), better_type, ptr_kind);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2315,47 +2307,84 @@</span>
      record_profile_for_speculation(stack(sp()-1), better_type, ptr_kind);
    }
  }
  
  void GraphKit::round_double_result(ciMethod* dest_method) {
<span class="udiff-line-modified-removed">-   // A non-strict method may return a double value which has an extended</span>
<span class="udiff-line-modified-removed">-   // exponent, but this must not be visible in a caller which is &#39;strict&#39;</span>
<span class="udiff-line-modified-removed">-   // If a strict caller invokes a non-strict callee, round a double result</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+     // If a strict caller invokes a non-strict callee, round a double result.</span>
<span class="udiff-line-modified-added">+     // A non-strict method may return a double value which has an extended exponent,</span>
<span class="udiff-line-added">+     // but this must not be visible in a caller which is strict.</span>
<span class="udiff-line-added">+     BasicType result_type = dest_method-&gt;return_type()-&gt;basic_type();</span>
<span class="udiff-line-added">+     assert(method() != NULL, &quot;must have caller context&quot;);</span>
<span class="udiff-line-added">+     if( result_type == T_DOUBLE &amp;&amp; method()-&gt;is_strict() &amp;&amp; !dest_method-&gt;is_strict() ) {</span>
<span class="udiff-line-added">+       // Destination method&#39;s return value is on top of stack</span>
<span class="udiff-line-added">+       // dstore_rounding() does gvn.transform</span>
<span class="udiff-line-added">+       Node *result = pop_pair();</span>
<span class="udiff-line-added">+       result = dstore_rounding(result);</span>
<span class="udiff-line-added">+       push_pair(result);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   BasicType result_type = dest_method-&gt;return_type()-&gt;basic_type();</span>
<span class="udiff-line-modified-removed">-   assert( method() != NULL, &quot;must have caller context&quot;);</span>
<span class="udiff-line-modified-removed">-   if( result_type == T_DOUBLE &amp;&amp; method()-&gt;is_strict() &amp;&amp; !dest_method-&gt;is_strict() ) {</span>
<span class="udiff-line-modified-removed">-     // Destination method&#39;s return value is on top of stack</span>
<span class="udiff-line-modified-removed">-     // dstore_rounding() does gvn.transform</span>
<span class="udiff-line-modified-removed">-     Node *result = pop_pair();</span>
<span class="udiff-line-modified-removed">-     result = dstore_rounding(result);</span>
<span class="udiff-line-modified-removed">-     push_pair(result);</span>
<span class="udiff-line-modified-added">+ void GraphKit::round_double_arguments(ciMethod* dest_method) {</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+     // (Note:  TypeFunc::make has a cache that makes this fast.)</span>
<span class="udiff-line-modified-added">+     const TypeFunc* tf    = TypeFunc::make(dest_method);</span>
<span class="udiff-line-modified-added">+     int             nargs = tf-&gt;domain()-&gt;cnt() - TypeFunc::Parms;</span>
<span class="udiff-line-modified-added">+     for (int j = 0; j &lt; nargs; j++) {</span>
<span class="udiff-line-modified-added">+       const Type *targ = tf-&gt;domain()-&gt;field_at(j + TypeFunc::Parms);</span>
<span class="udiff-line-modified-added">+       if (targ-&gt;basic_type() == T_DOUBLE) {</span>
<span class="udiff-line-added">+         // If any parameters are doubles, they must be rounded before</span>
<span class="udiff-line-added">+         // the call, dstore_rounding does gvn.transform</span>
<span class="udiff-line-added">+         Node *arg = argument(j);</span>
<span class="udiff-line-added">+         arg = dstore_rounding(arg);</span>
<span class="udiff-line-added">+         set_argument(j, arg);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
    }
  }
  
  // rounding for strict float precision conformance
  Node* GraphKit::precision_rounding(Node* n) {
<span class="udiff-line-modified-removed">-   return UseStrictFP &amp;&amp; _method-&gt;flags().is_strict()</span>
<span class="udiff-line-modified-removed">-     &amp;&amp; UseSSE == 0 &amp;&amp; Matcher::strict_fp_requires_explicit_rounding</span>
<span class="udiff-line-modified-removed">-     ? _gvn.transform( new RoundFloatNode(0, n) )</span>
<span class="udiff-line-modified-removed">-     : n;</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+ #ifdef IA32</span>
<span class="udiff-line-modified-added">+     if (_method-&gt;flags().is_strict() &amp;&amp; UseSSE == 0) {</span>
<span class="udiff-line-modified-added">+       return _gvn.transform(new RoundFloatNode(0, n));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+ #endif // IA32</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return n;</span>
  }
  
  // rounding for strict double precision conformance
  Node* GraphKit::dprecision_rounding(Node *n) {
<span class="udiff-line-modified-removed">-   return UseStrictFP &amp;&amp; _method-&gt;flags().is_strict()</span>
<span class="udiff-line-modified-removed">-     &amp;&amp; UseSSE &lt;= 1 &amp;&amp; Matcher::strict_fp_requires_explicit_rounding</span>
<span class="udiff-line-modified-removed">-     ? _gvn.transform( new RoundDoubleNode(0, n) )</span>
<span class="udiff-line-modified-removed">-     : n;</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+ #ifdef IA32</span>
<span class="udiff-line-modified-added">+     if (_method-&gt;flags().is_strict() &amp;&amp; UseSSE &lt; 2) {</span>
<span class="udiff-line-modified-added">+       return _gvn.transform(new RoundDoubleNode(0, n));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+ #endif // IA32</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return n;</span>
  }
  
  // rounding for non-strict double stores
  Node* GraphKit::dstore_rounding(Node* n) {
<span class="udiff-line-modified-removed">-   return Matcher::strict_fp_requires_explicit_rounding</span>
<span class="udiff-line-modified-removed">-     &amp;&amp; UseSSE &lt;= 1</span>
<span class="udiff-line-modified-removed">-     ? _gvn.transform( new RoundDoubleNode(0, n) )</span>
<span class="udiff-line-modified-removed">-     : n;</span>
<span class="udiff-line-modified-added">+   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="udiff-line-modified-added">+ #ifdef IA32</span>
<span class="udiff-line-modified-added">+     if (UseSSE &lt; 2) {</span>
<span class="udiff-line-modified-added">+       return _gvn.transform(new RoundDoubleNode(0, n));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+ #endif // IA32</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return n;</span>
  }
  
  //=============================================================================
  // Generate a fast path/slow path idiom.  Graph looks like:
  // [foo] indicates that &#39;foo&#39; is a parameter
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2448,10 +2477,12 @@</span>
                                    // The first NULL ends the list.
                                    Node* parm0, Node* parm1,
                                    Node* parm2, Node* parm3,
                                    Node* parm4, Node* parm5,
                                    Node* parm6, Node* parm7) {
<span class="udiff-line-added">+   assert(call_addr != NULL, &quot;must not call NULL targets&quot;);</span>
<span class="udiff-line-added">+ </span>
    // Slow-path call
    bool is_leaf = !(flags &amp; RC_NO_LEAF);
    bool has_io  = (!is_leaf &amp;&amp; !(flags &amp; RC_NO_IO));
    if (call_name == NULL) {
      assert(!is_leaf, &quot;must supply name for leaf&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2591,50 +2622,122 @@</span>
  
    // Get the no-exception control from the CatchNode.
    set_control(norm);
  }
  
<span class="udiff-line-modified-removed">- static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN* gvn, BasicType bt) {</span>
<span class="udiff-line-modified-added">+ static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN&amp; gvn, BasicType bt) {</span>
    Node* cmp = NULL;
    switch(bt) {
    case T_INT: cmp = new CmpINode(in1, in2); break;
    case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
    default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
    }
<span class="udiff-line-modified-removed">-   gvn-&gt;transform(cmp);</span>
<span class="udiff-line-modified-removed">-   Node* bol = gvn-&gt;transform(new BoolNode(cmp, test));</span>
<span class="udiff-line-modified-added">+   gvn.transform(cmp);</span>
<span class="udiff-line-modified-added">+   Node* bol = gvn.transform(new BoolNode(cmp, test));</span>
    IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
<span class="udiff-line-modified-removed">-   gvn-&gt;transform(iff);</span>
<span class="udiff-line-modified-removed">-   if (!bol-&gt;is_Con()) gvn-&gt;record_for_igvn(iff);</span>
<span class="udiff-line-modified-added">+   gvn.transform(iff);</span>
<span class="udiff-line-modified-added">+   if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);</span>
    return iff;
  }
  
<span class="udiff-line-added">+ // Find the memory state for the secondary super type cache load when</span>
<span class="udiff-line-added">+ // a subtype check is expanded at macro expansion time. That field is</span>
<span class="udiff-line-added">+ // mutable so should not use immutable memory but</span>
<span class="udiff-line-added">+ // PartialSubtypeCheckNode that might modify it doesn&#39;t produce a new</span>
<span class="udiff-line-added">+ // memory state so bottom memory is the most accurate memory state to</span>
<span class="udiff-line-added">+ // hook the load with. This follows the implementation used when the</span>
<span class="udiff-line-added">+ // subtype check is expanded at parse time.</span>
<span class="udiff-line-added">+ static Node* find_bottom_mem(Node* ctrl, Compile* C) {</span>
<span class="udiff-line-added">+   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="udiff-line-added">+   Node_Stack stack(0);</span>
<span class="udiff-line-added">+   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* c = ctrl;</span>
<span class="udiff-line-added">+   Node* mem = NULL;</span>
<span class="udiff-line-added">+   uint iter = 0;</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     iter++;</span>
<span class="udiff-line-added">+     assert(iter &lt; C-&gt;live_nodes(), &quot;infinite loop&quot;);</span>
<span class="udiff-line-added">+     if (c-&gt;is_Region()) {</span>
<span class="udiff-line-added">+       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="udiff-line-added">+         Node* u = c-&gt;fast_out(i);</span>
<span class="udiff-line-added">+         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="udiff-line-added">+             (u-&gt;adr_type() == TypePtr::BOTTOM || u-&gt;adr_type() == adr_type)) {</span>
<span class="udiff-line-added">+           mem = u;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (mem == NULL) {</span>
<span class="udiff-line-added">+         if (!seen.test_set(c-&gt;_idx)) {</span>
<span class="udiff-line-added">+           stack.push(c, 2);</span>
<span class="udiff-line-added">+           c = c-&gt;in(1);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           Node* phi = NULL;</span>
<span class="udiff-line-added">+           uint idx = 0;</span>
<span class="udiff-line-added">+           for (;;) {</span>
<span class="udiff-line-added">+             phi = stack.node();</span>
<span class="udiff-line-added">+             idx = stack.index();</span>
<span class="udiff-line-added">+             if (idx &lt; phi-&gt;req()) {</span>
<span class="udiff-line-added">+               break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             stack.pop();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           c = phi-&gt;in(idx);</span>
<span class="udiff-line-added">+           stack.set_index(idx+1);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (c-&gt;is_Proj() &amp;&amp; c-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-added">+       for (DUIterator_Fast imax, i = c-&gt;in(0)-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+         Node* u = c-&gt;in(0)-&gt;fast_out(i);</span>
<span class="udiff-line-added">+         if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u-&gt;as_Proj()-&gt;_is_io_use == c-&gt;as_Proj()-&gt;_is_io_use) {</span>
<span class="udiff-line-added">+           assert(mem == NULL, &quot;&quot;);</span>
<span class="udiff-line-added">+           mem = u;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (c-&gt;is_CatchProj() &amp;&amp; c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-added">+       Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0);</span>
<span class="udiff-line-added">+       assert(call-&gt;is_Call(), &quot;CatchProj with no call?&quot;);</span>
<span class="udiff-line-added">+       CallProjections projs;</span>
<span class="udiff-line-added">+       call-&gt;as_Call()-&gt;extract_projections(&amp;projs, false, false);</span>
<span class="udiff-line-added">+       if (projs.catchall_memproj == NULL) {</span>
<span class="udiff-line-added">+         mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-added">+       } else if (c == projs.fallthrough_catchproj) {</span>
<span class="udiff-line-added">+         mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         assert(c == projs.catchall_catchproj, &quot;strange control&quot;);</span>
<span class="udiff-line-added">+         mem = projs.catchall_memproj;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(!c-&gt;is_Start(), &quot;should stop before start&quot;);</span>
<span class="udiff-line-added">+       c = c-&gt;in(0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } while (mem == NULL);</span>
<span class="udiff-line-added">+   return mem;</span>
<span class="udiff-line-added">+ }</span>
  
  //-------------------------------gen_subtype_check-----------------------------
  // Generate a subtyping check.  Takes as input the subtype and supertype.
  // Returns 2 values: sets the default control() to the true path and returns
  // the false path.  Only reads invariant memory; sets no (visible) memory.
  // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
  // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
  // Object; if you wish to check an Object you need to load the Object&#39;s class
  // prior to coming here.
<span class="udiff-line-modified-removed">- Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, MergeMemNode* mem, PhaseGVN* gvn) {</span>
<span class="udiff-line-modified-removed">-   Compile* C = gvn-&gt;C;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN&amp; gvn) {</span>
<span class="udiff-line-modified-added">+   Compile* C = gvn.C;</span>
    if ((*ctrl)-&gt;is_top()) {
      return C-&gt;top();
    }
  
    // Fast check for identical types, perhaps identical constants.
    // The types can even be identical non-constants, in cases
    // involving Array.newInstance, Object.clone, etc.
    if (subklass == superklass)
      return C-&gt;top();             // false path is dead; no test needed.
  
<span class="udiff-line-modified-removed">-   if (gvn-&gt;type(superklass)-&gt;singleton()) {</span>
<span class="udiff-line-modified-removed">-     ciKlass* superk = gvn-&gt;type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-modified-removed">-     ciKlass* subk   = gvn-&gt;type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-modified-added">+   if (gvn.type(superklass)-&gt;singleton()) {</span>
<span class="udiff-line-modified-added">+     ciKlass* superk = gvn.type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-modified-added">+     ciKlass* subk   = gvn.type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
  
      // In the common case of an exact superklass, try to fold up the
      // test before generating code.  You may ask, why not just generate
      // the code and then let it fold up?  The answer is that the generated
      // code will necessarily include null checks, which do not always
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2645,21 +2748,21 @@</span>
      // of fa[1]=x will fold up, without testing the nullness of x.
      switch (C-&gt;static_subtype_check(superk, subk)) {
      case Compile::SSC_always_false:
        {
          Node* always_fail = *ctrl;
<span class="udiff-line-modified-removed">-         *ctrl = gvn-&gt;C-&gt;top();</span>
<span class="udiff-line-modified-added">+         *ctrl = gvn.C-&gt;top();</span>
          return always_fail;
        }
      case Compile::SSC_always_true:
        return C-&gt;top();
      case Compile::SSC_easy_test:
        {
          // Just do a direct pointer compare and be done.
          IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);
<span class="udiff-line-modified-removed">-         *ctrl = gvn-&gt;transform(new IfTrueNode(iff));</span>
<span class="udiff-line-modified-removed">-         return gvn-&gt;transform(new IfFalseNode(iff));</span>
<span class="udiff-line-modified-added">+         *ctrl = gvn.transform(new IfTrueNode(iff));</span>
<span class="udiff-line-modified-added">+         return gvn.transform(new IfFalseNode(iff));</span>
        }
      case Compile::SSC_full_test:
        break;
      default:
        ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2669,44 +2772,51 @@</span>
    // %%% Possible further optimization:  Even if the superklass is not exact,
    // if the subklass is the unique subtype of the superklass, the check
    // will always succeed.  We could leave a dependency behind to ensure this.
  
    // First load the super-klass&#39;s check-offset
<span class="udiff-line-modified-removed">-   Node *p1 = gvn-&gt;transform(new AddPNode(superklass, superklass, gvn-&gt;MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="udiff-line-modified-removed">-   Node* m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p1)-&gt;is_ptr()));</span>
<span class="udiff-line-modified-removed">-   Node *chk_off = gvn-&gt;transform(new LoadINode(NULL, m, p1, gvn-&gt;type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
<span class="udiff-line-modified-added">+   Node *p1 = gvn.transform(new AddPNode(superklass, superklass, gvn.MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="udiff-line-modified-added">+   Node* m = C-&gt;immutable_memory();</span>
<span class="udiff-line-modified-added">+   Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
    int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
<span class="udiff-line-modified-removed">-   bool might_be_cache = (gvn-&gt;find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
<span class="udiff-line-modified-added">+   bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
  
    // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
    // the secondary superclass list, or a failing value with a sentinel offset
    // if the super-klass is an interface or exceptionally deep in the Java
    // hierarchy and we have to scan the secondary superclass list the hard way.
    // Worst-case type is a little odd: NULL is allowed as a result (usually
    // klass loads can never produce a NULL).
    Node *chk_off_X = chk_off;
  #ifdef _LP64
<span class="udiff-line-modified-removed">-   chk_off_X = gvn-&gt;transform(new ConvI2LNode(chk_off_X));</span>
<span class="udiff-line-modified-added">+   chk_off_X = gvn.transform(new ConvI2LNode(chk_off_X));</span>
  #endif
<span class="udiff-line-modified-removed">-   Node *p2 = gvn-&gt;transform(new AddPNode(subklass,subklass,chk_off_X));</span>
<span class="udiff-line-modified-added">+   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));</span>
    // For some types like interfaces the following loadKlass is from a 1-word
    // cache which is mutable so can&#39;t use immutable memory.  Other
    // types load from the super-class display table which is immutable.
<span class="udiff-line-modified-removed">-   m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p2)-&gt;is_ptr()));</span>
<span class="udiff-line-modified-removed">-   Node *kmem = might_be_cache ? m : C-&gt;immutable_memory();</span>
<span class="udiff-line-modified-removed">-   Node *nkls = gvn-&gt;transform(LoadKlassNode::make(*gvn, NULL, kmem, p2, gvn-&gt;type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>
<span class="udiff-line-modified-added">+   Node *kmem = C-&gt;immutable_memory();</span>
<span class="udiff-line-modified-added">+   if (might_be_cache) {</span>
<span class="udiff-line-modified-added">+     assert((C-&gt;get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot)) ==</span>
<span class="udiff-line-added">+             C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())), &quot;&quot;);</span>
<span class="udiff-line-added">+     if (mem == NULL) {</span>
<span class="udiff-line-added">+       mem = find_bottom_mem(*ctrl, C);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>
  
    // Compile speed common case: ARE a subtype and we canNOT fail
    if( superklass == nkls )
      return C-&gt;top();             // false path is dead; no test needed.
  
    // See if we get an immediate positive hit.  Happens roughly 83% of the
    // time.  Test to see if the value loaded just previously from the subklass
    // is exactly the superklass.
    IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
<span class="udiff-line-modified-removed">-   Node *iftrue1 = gvn-&gt;transform( new IfTrueNode (iff1));</span>
<span class="udiff-line-modified-removed">-   *ctrl = gvn-&gt;transform(new IfFalseNode(iff1));</span>
<span class="udiff-line-modified-added">+   Node *iftrue1 = gvn.transform( new IfTrueNode (iff1));</span>
<span class="udiff-line-modified-added">+   *ctrl = gvn.transform(new IfFalseNode(iff1));</span>
  
    // Compile speed common case: Check for being deterministic right now.  If
    // chk_off is a constant and not equal to cacheoff then we are NOT a
    // subklass.  In this case we need exactly the 1 test above and we can
    // return those results immediately.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2716,32 +2826,32 @@</span>
      return not_subtype_ctrl;
    }
  
    // Gather the various success &amp; failures here
    RegionNode *r_ok_subtype = new RegionNode(4);
<span class="udiff-line-modified-removed">-   gvn-&gt;record_for_igvn(r_ok_subtype);</span>
<span class="udiff-line-modified-added">+   gvn.record_for_igvn(r_ok_subtype);</span>
    RegionNode *r_not_subtype = new RegionNode(3);
<span class="udiff-line-modified-removed">-   gvn-&gt;record_for_igvn(r_not_subtype);</span>
<span class="udiff-line-modified-added">+   gvn.record_for_igvn(r_not_subtype);</span>
  
    r_ok_subtype-&gt;init_req(1, iftrue1);
  
    // Check for immediate negative hit.  Happens roughly 11% of the time (which
    // is roughly 63% of the remaining cases).  Test to see if the loaded
    // check-offset points into the subklass display list or the 1-element
    // cache.  If it points to the display (and NOT the cache) and the display
    // missed then it&#39;s not a subtype.
<span class="udiff-line-modified-removed">-   Node *cacheoff = gvn-&gt;intcon(cacheoff_con);</span>
<span class="udiff-line-modified-added">+   Node *cacheoff = gvn.intcon(cacheoff_con);</span>
    IfNode *iff2 = gen_subtype_check_compare(*ctrl, chk_off, cacheoff, BoolTest::ne, PROB_LIKELY(0.63f), gvn, T_INT);
<span class="udiff-line-modified-removed">-   r_not_subtype-&gt;init_req(1, gvn-&gt;transform(new IfTrueNode (iff2)));</span>
<span class="udiff-line-modified-removed">-   *ctrl = gvn-&gt;transform(new IfFalseNode(iff2));</span>
<span class="udiff-line-modified-added">+   r_not_subtype-&gt;init_req(1, gvn.transform(new IfTrueNode (iff2)));</span>
<span class="udiff-line-modified-added">+   *ctrl = gvn.transform(new IfFalseNode(iff2));</span>
  
    // Check for self.  Very rare to get here, but it is taken 1/3 the time.
    // No performance impact (too rare) but allows sharing of secondary arrays
    // which has some footprint reduction.
    IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);
<span class="udiff-line-modified-removed">-   r_ok_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode(iff3)));</span>
<span class="udiff-line-modified-removed">-   *ctrl = gvn-&gt;transform(new IfFalseNode(iff3));</span>
<span class="udiff-line-modified-added">+   r_ok_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode(iff3)));</span>
<span class="udiff-line-modified-added">+   *ctrl = gvn.transform(new IfFalseNode(iff3));</span>
  
    // -- Roads not taken here: --
    // We could also have chosen to perform the self-check at the beginning
    // of this code sequence, as the assembler does.  This would not pay off
    // the same way, since the optimizer, unlike the assembler, can perform
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2760,20 +2870,42 @@</span>
    // performance impact (too rare) but it&#39;s gotta be done.
    // Since the code is rarely used, there is no penalty for moving it
    // out of line, and it can only improve I-cache density.
    // The decision to inline or out-of-line this final check is platform
    // dependent, and is found in the AD file definition of PartialSubtypeCheck.
<span class="udiff-line-modified-removed">-   Node* psc = gvn-&gt;transform(</span>
<span class="udiff-line-modified-added">+   Node* psc = gvn.transform(</span>
      new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
  
<span class="udiff-line-modified-removed">-   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn-&gt;zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="udiff-line-modified-removed">-   r_not_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode (iff4)));</span>
<span class="udiff-line-modified-removed">-   r_ok_subtype -&gt;init_req(3, gvn-&gt;transform(new IfFalseNode(iff4)));</span>
<span class="udiff-line-modified-added">+   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn.zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="udiff-line-modified-added">+   r_not_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode (iff4)));</span>
<span class="udiff-line-modified-added">+   r_ok_subtype -&gt;init_req(3, gvn.transform(new IfFalseNode(iff4)));</span>
  
    // Return false path; set default control to true path.
<span class="udiff-line-modified-removed">-   *ctrl = gvn-&gt;transform(r_ok_subtype);</span>
<span class="udiff-line-modified-removed">-   return gvn-&gt;transform(r_not_subtype);</span>
<span class="udiff-line-modified-added">+   *ctrl = gvn.transform(r_ok_subtype);</span>
<span class="udiff-line-modified-added">+   return gvn.transform(r_not_subtype);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Node* GraphKit::gen_subtype_check(Node* obj_or_subklass, Node* superklass) {</span>
<span class="udiff-line-added">+   if (ExpandSubTypeCheckAtParseTime) {</span>
<span class="udiff-line-added">+     MergeMemNode* mem = merged_memory();</span>
<span class="udiff-line-added">+     Node* ctrl = control();</span>
<span class="udiff-line-added">+     Node* subklass = obj_or_subklass;</span>
<span class="udiff-line-added">+     if (!_gvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
<span class="udiff-line-added">+       subklass = load_object_klass(obj_or_subklass);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, _gvn);</span>
<span class="udiff-line-added">+     set_control(ctrl);</span>
<span class="udiff-line-added">+     return n;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="udiff-line-added">+   Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));</span>
<span class="udiff-line-added">+   Node* bol = _gvn.transform(new BoolNode(check, BoolTest::eq));</span>
<span class="udiff-line-added">+   IfNode* iff = create_and_xform_if(control(), bol, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);</span>
<span class="udiff-line-added">+   set_control(_gvn.transform(new IfTrueNode(iff)));</span>
<span class="udiff-line-added">+   return _gvn.transform(new IfFalseNode(iff));</span>
  }
  
  // Profile-driven exact type check:
  Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
                                      float prob,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2801,14 +2933,13 @@</span>
  
  //------------------------------subtype_check_receiver-------------------------
  Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
                                         Node** casted_receiver) {
    const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
<span class="udiff-line-removed">-   Node* recv_klass = load_object_klass(receiver);</span>
    Node* want_klass = makecon(tklass);
  
<span class="udiff-line-modified-removed">-   Node* slow_ctl = gen_subtype_check(recv_klass, want_klass);</span>
<span class="udiff-line-modified-added">+   Node* slow_ctl = gen_subtype_check(receiver, want_klass);</span>
  
    // Cast receiver after successful check
    const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
    Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
    (*casted_receiver) = _gvn.transform(cast);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2843,10 +2974,64 @@</span>
    }
    speculating = false;
    return false;
  }
  
<span class="udiff-line-added">+ void GraphKit::guard_klass_being_initialized(Node* klass) {</span>
<span class="udiff-line-added">+   int init_state_off = in_bytes(InstanceKlass::init_state_offset());</span>
<span class="udiff-line-added">+   Node* adr = basic_plus_adr(top(), klass, init_state_off);</span>
<span class="udiff-line-added">+   Node* init_state = LoadNode::make(_gvn, NULL, immutable_memory(), adr,</span>
<span class="udiff-line-added">+                                     adr-&gt;bottom_type()-&gt;is_ptr(), TypeInt::BYTE,</span>
<span class="udiff-line-added">+                                     T_BYTE, MemNode::unordered);</span>
<span class="udiff-line-added">+   init_state = _gvn.transform(init_state);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* being_initialized_state = makecon(TypeInt::make(InstanceKlass::being_initialized));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* chk = _gvn.transform(new CmpINode(being_initialized_state, init_state));</span>
<span class="udiff-line-added">+   Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   { BuildCutout unless(this, tst, PROB_MAX);</span>
<span class="udiff-line-added">+     uncommon_trap(Deoptimization::Reason_initialized, Deoptimization::Action_reinterpret);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void GraphKit::guard_init_thread(Node* klass) {</span>
<span class="udiff-line-added">+   int init_thread_off = in_bytes(InstanceKlass::init_thread_offset());</span>
<span class="udiff-line-added">+   Node* adr = basic_plus_adr(top(), klass, init_thread_off);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* init_thread = LoadNode::make(_gvn, NULL, immutable_memory(), adr,</span>
<span class="udiff-line-added">+                                      adr-&gt;bottom_type()-&gt;is_ptr(), TypePtr::NOTNULL,</span>
<span class="udiff-line-added">+                                      T_ADDRESS, MemNode::unordered);</span>
<span class="udiff-line-added">+   init_thread = _gvn.transform(init_thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* cur_thread = _gvn.transform(new ThreadLocalNode());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* chk = _gvn.transform(new CmpPNode(cur_thread, init_thread));</span>
<span class="udiff-line-added">+   Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   { BuildCutout unless(this, tst, PROB_MAX);</span>
<span class="udiff-line-added">+     uncommon_trap(Deoptimization::Reason_uninitialized, Deoptimization::Action_none);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void GraphKit::clinit_barrier(ciInstanceKlass* ik, ciMethod* context) {</span>
<span class="udiff-line-added">+   if (ik-&gt;is_being_initialized()) {</span>
<span class="udiff-line-added">+     if (C-&gt;needs_clinit_barrier(ik, context)) {</span>
<span class="udiff-line-added">+       Node* klass = makecon(TypeKlassPtr::make(ik));</span>
<span class="udiff-line-added">+       guard_klass_being_initialized(klass);</span>
<span class="udiff-line-added">+       guard_init_thread(klass);</span>
<span class="udiff-line-added">+       insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else if (ik-&gt;is_initialized()) {</span>
<span class="udiff-line-added">+     return; // no barrier needed</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="udiff-line-added">+                   Deoptimization::Action_reinterpret,</span>
<span class="udiff-line-added">+                   NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //------------------------maybe_cast_profiled_receiver-------------------------
  // If the profile has seen exactly one type, narrow to exactly that type.
  // Subsequent type checks will always fold up.
  Node* GraphKit::maybe_cast_profiled_receiver(Node* not_null_obj,
                                               ciKlass* require_klass,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3015,15 +3200,12 @@</span>
          not_null_obj = cast_obj;
        }
      }
    }
  
<span class="udiff-line-removed">-   // Load the object&#39;s klass</span>
<span class="udiff-line-removed">-   Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="udiff-line-removed">- </span>
    // Generate the subtype check
<span class="udiff-line-modified-removed">-   Node* not_subtype_ctrl = gen_subtype_check(obj_klass, superklass);</span>
<span class="udiff-line-modified-added">+   Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);</span>
  
    // Plug in the success path to the general merge in slot 1.
    region-&gt;init_req(_obj_path, control());
    phi   -&gt;init_req(_obj_path, intcon(1));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3142,24 +3324,21 @@</span>
        }
      }
    }
  
    if (cast_obj == NULL) {
<span class="udiff-line-removed">-     // Load the object&#39;s klass</span>
<span class="udiff-line-removed">-     Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="udiff-line-removed">- </span>
      // Generate the subtype check
<span class="udiff-line-modified-removed">-     Node* not_subtype_ctrl = gen_subtype_check( obj_klass, superklass );</span>
<span class="udiff-line-modified-added">+     Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );</span>
  
      // Plug in success path into the merge
      cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));
      // Failure path ends in uncommon trap (or may be dead - failure impossible)
      if (failure_control == NULL) {
        if (not_subtype_ctrl != top()) { // If failure is possible
          PreserveJVMState pjvms(this);
          set_control(not_subtype_ctrl);
<span class="udiff-line-modified-removed">-         builtin_throw(Deoptimization::Reason_class_check, obj_klass);</span>
<span class="udiff-line-modified-added">+         builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));</span>
        }
      } else {
        (*failure_control) = not_subtype_ctrl;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3255,12 +3434,10 @@</span>
    if (stopped())                // Dead monitor?
      return NULL;
  
    assert(dead_locals_are_killed(), &quot;should kill locals before sync. point&quot;);
  
<span class="udiff-line-removed">-   obj = access_resolve(obj, ACCESS_READ | ACCESS_WRITE);</span>
<span class="udiff-line-removed">- </span>
    // Box the stack location
    Node* box = _gvn.transform(new BoxLockNode(next_monitor()));
    Node* mem = reset_memory();
  
    FastLockNode * flock = _gvn.transform(new FastLockNode(0, obj, box) )-&gt;as_FastLock();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3981,12 +4158,10 @@</span>
     * int i_char = start;
     * for (int i_byte = 0; i_byte &lt; count; i_byte++) {
     *   dst[i_char++] = (char)(src[i_byte] &amp; 0xff);
     * }
     */
<span class="udiff-line-removed">-   src = access_resolve(src, ACCESS_READ);</span>
<span class="udiff-line-removed">-   dst = access_resolve(dst, ACCESS_WRITE);</span>
    add_predicate();
    RegionNode* head = new RegionNode(3);
    head-&gt;init_req(1, control());
    gvn().set_type(head, Type::CONTROL);
    record_for_igvn(head);
</pre>
<center><a href="gcm.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
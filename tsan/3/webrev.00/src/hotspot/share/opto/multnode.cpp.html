<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/multnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;opto/callnode.hpp&quot;
 27 #include &quot;opto/cfgnode.hpp&quot;
 28 #include &quot;opto/matcher.hpp&quot;
 29 #include &quot;opto/mathexactnode.hpp&quot;
 30 #include &quot;opto/multnode.hpp&quot;
 31 #include &quot;opto/opcodes.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 #include &quot;opto/regmask.hpp&quot;
 34 #include &quot;opto/type.hpp&quot;
 35 #include &quot;utilities/vmError.hpp&quot;
 36 
 37 //=============================================================================
 38 //------------------------------MultiNode--------------------------------------
 39 const RegMask &amp;MultiNode::out_RegMask() const {
 40   return RegMask::Empty;
 41 }
 42 
 43 Node *MultiNode::match( const ProjNode *proj, const Matcher *m ) { return proj-&gt;clone(); }
 44 
 45 //------------------------------proj_out---------------------------------------
 46 // Get a named projection or null if not found
 47 ProjNode* MultiNode::proj_out_or_null(uint which_proj) const {
 48   assert((Opcode() != Op_If &amp;&amp; Opcode() != Op_RangeCheck) || which_proj == (uint)true || which_proj == (uint)false, &quot;must be 1 or 0&quot;);
 49   assert((Opcode() != Op_If &amp;&amp; Opcode() != Op_RangeCheck) || outcnt() == 2, &quot;bad if #1&quot;);
 50   for( DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++ ) {
 51     Node *p = fast_out(i);
 52     if (p-&gt;is_Proj()) {
 53       ProjNode *proj = p-&gt;as_Proj();
 54       if (proj-&gt;_con == which_proj) {
 55         assert((Opcode() != Op_If &amp;&amp; Opcode() != Op_RangeCheck) || proj-&gt;Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse), &quot;bad if #2&quot;);
 56         return proj;
 57       }
 58     } else {
 59       assert(p == this &amp;&amp; this-&gt;is_Start(), &quot;else must be proj&quot;);
 60       continue;
 61     }
 62   }
 63   return NULL;
 64 }
 65 
 66 // Get a named projection
 67 ProjNode* MultiNode::proj_out(uint which_proj) const {
 68   ProjNode* p = proj_out_or_null(which_proj);
 69   assert(p != NULL, &quot;named projection %u not found&quot;, which_proj);
 70   return p;
 71 }
 72 
 73 //=============================================================================
 74 //------------------------------ProjNode---------------------------------------
 75 uint ProjNode::hash() const {
 76   // only one input
 77   return (uintptr_t)in(TypeFunc::Control) + (_con &lt;&lt; 1) + (_is_io_use ? 1 : 0);
 78 }
 79 bool ProjNode::cmp( const Node &amp;n ) const { return _con == ((ProjNode&amp;)n)._con &amp;&amp; ((ProjNode&amp;)n)._is_io_use == _is_io_use; }
 80 uint ProjNode::size_of() const { return sizeof(ProjNode); }
 81 
 82 // Test if we propagate interesting control along this projection
 83 bool ProjNode::is_CFG() const {
 84   Node *def = in(0);
 85   return (_con == TypeFunc::Control &amp;&amp; def-&gt;is_CFG());
 86 }
 87 
 88 const Type* ProjNode::proj_type(const Type* t) const {
 89   if (t == Type::TOP) {
 90     return Type::TOP;
 91   }
 92   if (t == Type::BOTTOM) {
 93     return Type::BOTTOM;
 94   }
 95   t = t-&gt;is_tuple()-&gt;field_at(_con);
 96   Node* n = in(0);
 97   if ((_con == TypeFunc::Parms) &amp;&amp;
 98       n-&gt;is_CallStaticJava() &amp;&amp; n-&gt;as_CallStaticJava()-&gt;is_boxing_method()) {
 99     // The result of autoboxing is always non-null on normal path.
100     t = t-&gt;join_speculative(TypePtr::NOTNULL);
101   }
102   return t;
103 }
104 
105 const Type *ProjNode::bottom_type() const {
106   if (in(0) == NULL) return Type::TOP;
107   return proj_type(in(0)-&gt;bottom_type());
108 }
109 
110 const TypePtr *ProjNode::adr_type() const {
111   if (bottom_type() == Type::MEMORY) {
112     // in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM
113     Node* ctrl = in(0);
114     if (ctrl == NULL)  return NULL; // node is dead
115     const TypePtr* adr_type = ctrl-&gt;adr_type();
116     #ifdef ASSERT
117     if (!VMError::is_error_reported() &amp;&amp; !Node::in_dump())
118       assert(adr_type != NULL, &quot;source must have adr_type&quot;);
119     #endif
120     return adr_type;
121   }
122   assert(bottom_type()-&gt;base() != Type::Memory, &quot;no other memories?&quot;);
123   return NULL;
124 }
125 
126 bool ProjNode::pinned() const { return in(0)-&gt;pinned(); }
127 #ifndef PRODUCT
128 void ProjNode::dump_spec(outputStream *st) const { st-&gt;print(&quot;#%d&quot;,_con); if(_is_io_use) st-&gt;print(&quot; (i_o_use)&quot;);}
129 
130 void ProjNode::dump_compact_spec(outputStream *st) const {
131   for (DUIterator i = this-&gt;outs(); this-&gt;has_out(i); i++) {
132     Node* o = this-&gt;out(i);
133     if (NotANode(o)) {
134       st-&gt;print(&quot;[?]&quot;);
135     } else if (o == NULL) {
136       st-&gt;print(&quot;[_]&quot;);
137     } else {
138       st-&gt;print(&quot;[%d]&quot;, o-&gt;_idx);
139     }
140   }
141   st-&gt;print(&quot;#%d&quot;, _con);
142 }
143 #endif
144 
145 //----------------------------check_con----------------------------------------
146 void ProjNode::check_con() const {
147   Node* n = in(0);
148   if (n == NULL)       return;  // should be assert, but NodeHash makes bogons
149   if (n-&gt;is_Mach())    return;  // mach. projs. are not type-safe
150   if (n-&gt;is_Start())   return;  // alas, starts can have mach. projs. also
151   if (_con == SCMemProjNode::SCMEMPROJCON ) return;
152   const Type* t = n-&gt;bottom_type();
153   if (t == Type::TOP)  return;  // multi is dead
154   assert(_con &lt; t-&gt;is_tuple()-&gt;cnt(), &quot;ProjNode::_con must be in range&quot;);
155 }
156 
157 //------------------------------Value------------------------------------------
158 const Type* ProjNode::Value(PhaseGVN* phase) const {
159   if (in(0) == NULL) return Type::TOP;
160   return proj_type(phase-&gt;type(in(0)));
161 }
162 
163 //------------------------------out_RegMask------------------------------------
164 // Pass the buck uphill
165 const RegMask &amp;ProjNode::out_RegMask() const {
166   return RegMask::Empty;
167 }
168 
169 //------------------------------ideal_reg--------------------------------------
170 uint ProjNode::ideal_reg() const {
171   return bottom_type()-&gt;ideal_reg();
172 }
173 
174 //-------------------------------is_uncommon_trap_proj----------------------------
175 // Return uncommon trap call node if proj is for &quot;proj-&gt;[region-&gt;..]call_uct&quot;
176 // NULL otherwise
177 CallStaticJavaNode* ProjNode::is_uncommon_trap_proj(Deoptimization::DeoptReason reason) {
178   int path_limit = 10;
179   Node* out = this;
180   for (int ct = 0; ct &lt; path_limit; ct++) {
181     out = out-&gt;unique_ctrl_out();
182     if (out == NULL)
183       return NULL;
184     if (out-&gt;is_CallStaticJava()) {
185       CallStaticJavaNode* call = out-&gt;as_CallStaticJava();
186       int req = call-&gt;uncommon_trap_request();
187       if (req != 0) {
188         Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);
189         if (trap_reason == reason || reason == Deoptimization::Reason_none) {
190           return call;
191         }
192       }
193       return NULL; // don&#39;t do further after call
194     }
195     if (out-&gt;Opcode() != Op_Region)
196       return NULL;
197   }
198   return NULL;
199 }
200 
201 //-------------------------------is_uncommon_trap_if_pattern-------------------------
202 // Return uncommon trap call node for    &quot;if(test)-&gt; proj -&gt; ...
203 //                                                 |
204 //                                                 V
205 //                                             other_proj-&gt;[region-&gt;..]call_uct&quot;
206 // NULL otherwise
207 // &quot;must_reason_predicate&quot; means the uct reason must be Reason_predicate
208 CallStaticJavaNode* ProjNode::is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason) {
209   Node *in0 = in(0);
210   if (!in0-&gt;is_If()) return NULL;
211   // Variation of a dead If node.
212   if (in0-&gt;outcnt() &lt; 2)  return NULL;
213   IfNode* iff = in0-&gt;as_If();
214 
215   // we need &quot;If(Conv2B(Opaque1(...)))&quot; pattern for reason_predicate
216   if (reason != Deoptimization::Reason_none) {
217     if (iff-&gt;in(1)-&gt;Opcode() != Op_Conv2B ||
218        iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() != Op_Opaque1) {
219       return NULL;
220     }
221   }
222 
223   ProjNode* other_proj = iff-&gt;proj_out(1-_con);
224   CallStaticJavaNode* call = other_proj-&gt;is_uncommon_trap_proj(reason);
225   if (call != NULL) {
226     assert(reason == Deoptimization::Reason_none ||
227            Compile::current()-&gt;is_predicate_opaq(iff-&gt;in(1)-&gt;in(1)), &quot;should be on the list&quot;);
228     return call;
229   }
230   return NULL;
231 }
232 
233 ProjNode* ProjNode::other_if_proj() const {
234   assert(_con == 0 || _con == 1, &quot;not an if?&quot;);
235   return in(0)-&gt;as_If()-&gt;proj_out(1-_con);
236 }
    </pre>
  </body>
</html>
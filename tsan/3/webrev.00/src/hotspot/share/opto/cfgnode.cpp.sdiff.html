<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="castnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 866   return RegMask::Empty;
 867 }
 868 
 869 // Find the one non-null required input.  RegionNode only
 870 Node *Node::nonnull_req() const {
 871   assert( is_Region(), &quot;&quot; );
 872   for( uint i = 1; i &lt; _cnt; i++ )
 873     if( in(i) )
 874       return in(i);
 875   ShouldNotReachHere();
 876   return NULL;
 877 }
 878 
 879 
 880 //=============================================================================
 881 // note that these functions assume that the _adr_type field is flattened
 882 uint PhiNode::hash() const {
 883   const Type* at = _adr_type;
 884   return TypeNode::hash() + (at ? at-&gt;hash() : 0);
 885 }
<span class="line-modified"> 886 uint PhiNode::cmp( const Node &amp;n ) const {</span>
 887   return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
 888 }
 889 static inline
 890 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
 891   if (at == NULL || at == TypePtr::BOTTOM)  return at;
 892   return Compile::current()-&gt;alias_type(at)-&gt;adr_type();
 893 }
 894 
 895 //----------------------------make---------------------------------------------
 896 // create a new phi with edges matching r and set (initially) to x
 897 PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
 898   uint preds = r-&gt;req();   // Number of predecessor paths
 899   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), &quot;flatten at&quot;);
 900   PhiNode* p = new PhiNode(r, t, at);
 901   for (uint j = 1; j &lt; preds; j++) {
 902     // Fill in all inputs, except those which the region does not yet have
 903     if (r-&gt;in(j) != NULL)
 904       p-&gt;init_req(j, x);
 905   }
 906   return p;
</pre>
<hr />
<pre>
1432     flipped = 1-flipped;        // Test is vs 1 instead of 0!
1433   }
1434 
1435   // Check for setting zero/one opposite expected
1436   if( tzero == TypeInt::ZERO ) {
1437     if( tone == TypeInt::ONE ) {
1438     } else return NULL;
1439   } else if( tzero == TypeInt::ONE ) {
1440     if( tone == TypeInt::ZERO ) {
1441       flipped = 1-flipped;
1442     } else return NULL;
1443   } else return NULL;
1444 
1445   // Check for boolean test backwards
1446   if( b-&gt;_test._test == BoolTest::ne ) {
1447   } else if( b-&gt;_test._test == BoolTest::eq ) {
1448     flipped = 1-flipped;
1449   } else return NULL;
1450 
1451   // Build int-&gt;bool conversion
<span class="line-modified">1452   Node *in1 = cmp-&gt;in(1);</span>
<span class="line-removed">1453   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">1454   in1 = bs-&gt;step_over_gc_barrier(in1);</span>
<span class="line-removed">1455   Node *n = new Conv2BNode(in1);</span>
1456   if( flipped )
1457     n = new XorINode( phase-&gt;transform(n), phase-&gt;intcon(1) );
1458 
1459   return n;
1460 }
1461 
1462 //------------------------------is_cond_add------------------------------------
1463 // Check for simple conditional add pattern:  &quot;(P &lt; Q) ? X+Y : X;&quot;
1464 // To be profitable the control flow has to disappear; there can be no other
1465 // values merging here.  We replace the test-and-branch with:
1466 // &quot;(sgn(P-Q))&amp;Y) + X&quot;.  Basically, convert &quot;(P &lt; Q)&quot; into 0 or -1 by
1467 // moving the carry bit from (P-Q) into a register with &#39;sbb EAX,EAX&#39;.
1468 // Then convert Y to 0-or-Y and finally add.
1469 // This is a key transform for SpecJava _201_compress.
1470 static Node* is_cond_add(PhaseGVN *phase, PhiNode *phi, int true_path) {
1471   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1472 
1473   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1474   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1475   RegionNode *region = (RegionNode*)phi-&gt;in(0);
</pre>
<hr />
<pre>
1861       // or through other data nodes.
1862       if ((is_loop &amp;&amp; !uin-&gt;eqv_uncast(in(LoopNode::EntryControl))) ||
1863           (!is_loop &amp;&amp; is_unsafe_data_reference(uin))) {
1864         // Break this data loop to avoid creation of a dead loop.
1865         if (can_reshape) {
1866           return top;
1867         } else {
1868           // We can&#39;t return top if we are in Parse phase - cut inputs only
1869           // let Identity to handle the case.
1870           replace_edge(uin, top);
1871           return NULL;
1872         }
1873       }
1874     }
1875 
1876     if (uncasted) {
1877       // Add cast nodes between the phi to be removed and its unique input.
1878       // Wait until after parsing for the type information to propagate from the casts.
1879       assert(can_reshape, &quot;Invalid during parsing&quot;);
1880       const Type* phi_type = bottom_type();
<span class="line-modified">1881       assert(phi_type-&gt;isa_int() || phi_type-&gt;isa_ptr(), &quot;bad phi type&quot;);</span>
<span class="line-modified">1882       // Add casts to carry the control dependency of the Phi that is</span>
<span class="line-removed">1883       // going away</span>
1884       Node* cast = NULL;
1885       if (phi_type-&gt;isa_int()) {
1886         cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);


1887       } else {
1888         const Type* uin_type = phase-&gt;type(uin);
1889         if (!phi_type-&gt;isa_oopptr() &amp;&amp; !uin_type-&gt;isa_oopptr()) {
1890           cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
1891         } else {
1892           // Use a CastPP for a cast to not null and a CheckCastPP for
1893           // a cast to a new klass (and both if both null-ness and
1894           // klass change).
1895 
1896           // If the type of phi is not null but the type of uin may be
1897           // null, uin&#39;s type must be casted to not null
1898           if (phi_type-&gt;join(TypePtr::NOTNULL) == phi_type-&gt;remove_speculative() &amp;&amp;
1899               uin_type-&gt;join(TypePtr::NOTNULL) != uin_type-&gt;remove_speculative()) {
1900             cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, true);
1901           }
1902 
1903           // If the type of phi and uin, both casted to not null,
1904           // differ the klass of uin must be (check)cast&#39;ed to match
1905           // that of phi
1906           if (phi_type-&gt;join_speculative(TypePtr::NOTNULL) != uin_type-&gt;join_speculative(TypePtr::NOTNULL)) {
</pre>
<hr />
<pre>
1975         assert(req() == 3, &quot;only diamond merge phi here&quot;);
1976         set_req(1, top);
1977         set_req(2, top);
1978         return NULL;
1979       } else {
1980         return opt;
1981       }
1982     }
1983   }
1984 
1985   // Check for merging identical values and split flow paths
1986   if (can_reshape) {
1987     opt = split_flow_path(phase, this);
1988     // This optimization only modifies phi - don&#39;t need to check for dead loop.
1989     assert(opt == NULL || phase-&gt;eqv(opt, this), &quot;do not elide phi&quot;);
1990     if (opt != NULL)  return opt;
1991   }
1992 
1993   if (in(1) != NULL &amp;&amp; in(1)-&gt;Opcode() == Op_AddP &amp;&amp; can_reshape) {
1994     // Try to undo Phi of AddP:
<span class="line-modified">1995     // (Phi (AddP base base y) (AddP base2 base2 y))</span>
1996     // becomes:
1997     // newbase := (Phi base base2)
<span class="line-modified">1998     // (AddP newbase newbase y)</span>


1999     //
2000     // This occurs as a result of unsuccessful split_thru_phi and
2001     // interferes with taking advantage of addressing modes. See the
2002     // clone_shift_expressions code in matcher.cpp
2003     Node* addp = in(1);
<span class="line-modified">2004     const Type* type = addp-&gt;in(AddPNode::Base)-&gt;bottom_type();</span>
<span class="line-modified">2005     Node* y = addp-&gt;in(AddPNode::Offset);</span>
<span class="line-modified">2006     if (y != NULL &amp;&amp; addp-&gt;in(AddPNode::Base) == addp-&gt;in(AddPNode::Address)) {</span>




2007       // make sure that all the inputs are similar to the first one,
2008       // i.e. AddP with base == address and same offset as first AddP
2009       bool doit = true;
2010       for (uint i = 2; i &lt; req(); i++) {
2011         if (in(i) == NULL ||
2012             in(i)-&gt;Opcode() != Op_AddP ||
<span class="line-modified">2013             in(i)-&gt;in(AddPNode::Base) != in(i)-&gt;in(AddPNode::Address) ||</span>
<span class="line-modified">2014             in(i)-&gt;in(AddPNode::Offset) != y) {</span>




2015           doit = false;
2016           break;
2017         }









2018         // Accumulate type for resulting Phi
<span class="line-modified">2019         type = type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>

2020       }
<span class="line-modified">2021       Node* base = NULL;</span>
<span class="line-removed">2022       if (doit) {</span>
2023         // Check for neighboring AddP nodes in a tree.
2024         // If they have a base, use that it.
2025         for (DUIterator_Fast kmax, k = this-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2026           Node* u = this-&gt;fast_out(k);
2027           if (u-&gt;is_AddP()) {
2028             Node* base2 = u-&gt;in(AddPNode::Base);
2029             if (base2 != NULL &amp;&amp; !base2-&gt;is_top()) {
2030               if (base == NULL)
2031                 base = base2;
2032               else if (base != base2)
2033                 { doit = false; break; }
2034             }
2035           }
2036         }
2037       }
2038       if (doit) {
2039         if (base == NULL) {
<span class="line-modified">2040           base = new PhiNode(in(0), type, NULL);</span>
2041           for (uint i = 1; i &lt; req(); i++) {
2042             base-&gt;init_req(i, in(i)-&gt;in(AddPNode::Base));
2043           }
2044           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(base);
2045         }
<span class="line-modified">2046         return new AddPNode(base, base, y);</span>














2047       }
2048     }
2049   }
2050 
2051   // Split phis through memory merges, so that the memory merges will go away.
2052   // Piggy-back this transformation on the search for a unique input....
2053   // It will be as if the merged memory is the unique value of the phi.
2054   // (Do not attempt this optimization unless parsing is complete.
2055   // It would make the parser&#39;s memory-merge logic sick.)
2056   // (MergeMemNode is not dead_loop_safe - need to check for dead loop.)
2057   if (progress == NULL &amp;&amp; can_reshape &amp;&amp; type() == Type::MEMORY) {
2058     // see if this phi should be sliced
2059     uint merge_width = 0;
2060     bool saw_self = false;
2061     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2062       Node *ii = in(i);
2063       // TOP inputs should not be counted as safe inputs because if the
2064       // Phi references itself through all other inputs then splitting the
2065       // Phi through memory merges would create dead loop at later stage.
2066       if (ii == top) {
</pre>
<hr />
<pre>
2336   this-&gt;collect_nodes(in_rel, 1, false, false);
2337   this-&gt;collect_nodes(out_rel, -2, false, false);
2338 }
2339 #endif
2340 
2341 //=============================================================================
2342 const RegMask &amp;JProjNode::out_RegMask() const {
2343   return RegMask::Empty;
2344 }
2345 
2346 //=============================================================================
2347 const RegMask &amp;CProjNode::out_RegMask() const {
2348   return RegMask::Empty;
2349 }
2350 
2351 
2352 
2353 //=============================================================================
2354 
2355 uint PCTableNode::hash() const { return Node::hash() + _size; }
<span class="line-modified">2356 uint PCTableNode::cmp( const Node &amp;n ) const</span>
2357 { return _size == ((PCTableNode&amp;)n)._size; }
2358 
2359 const Type *PCTableNode::bottom_type() const {
2360   const Type** f = TypeTuple::fields(_size);
2361   for( uint i = 0; i &lt; _size; i++ ) f[i] = Type::CONTROL;
2362   return TypeTuple::make(_size, f);
2363 }
2364 
2365 //------------------------------Value------------------------------------------
2366 // Compute the type of the PCTableNode.  If reachable it is a tuple of
2367 // Control, otherwise the table targets are not reachable
2368 const Type* PCTableNode::Value(PhaseGVN* phase) const {
2369   if( phase-&gt;type(in(0)) == Type::CONTROL )
2370     return bottom_type();
2371   return Type::TOP;             // All paths dead?  Then so are we
2372 }
2373 
2374 //------------------------------Ideal------------------------------------------
2375 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
2376 // control copies
2377 Node *PCTableNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2378   return remove_dead_region(phase, can_reshape) ? this : NULL;
2379 }
2380 
2381 //=============================================================================
2382 uint JumpProjNode::hash() const {
2383   return Node::hash() + _dest_bci;
2384 }
2385 
<span class="line-modified">2386 uint JumpProjNode::cmp( const Node &amp;n ) const {</span>
2387   return ProjNode::cmp(n) &amp;&amp;
2388     _dest_bci == ((JumpProjNode&amp;)n)._dest_bci;
2389 }
2390 
2391 #ifndef PRODUCT
2392 void JumpProjNode::dump_spec(outputStream *st) const {
2393   ProjNode::dump_spec(st);
2394   st-&gt;print(&quot;@bci %d &quot;,_dest_bci);
2395 }
2396 
2397 void JumpProjNode::dump_compact_spec(outputStream *st) const {
2398   ProjNode::dump_compact_spec(st);
2399   st-&gt;print(&quot;(%d)%d@%d&quot;, _switch_val, _proj_no, _dest_bci);
2400 }
2401 
2402 void JumpProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2403   // The related nodes of a JumpProjNode are its inputs and outputs at level 1.
2404   this-&gt;collect_nodes(in_rel, 1, false, false);
2405   this-&gt;collect_nodes(out_rel, -1, false, false);
2406 }
</pre>
<hr />
<pre>
2429         f[CatchProjNode::fall_through_index] = Type::TOP;
2430       } else if( call-&gt;req() &gt; TypeFunc::Parms ) {
2431         const Type *arg0 = phase-&gt;type( call-&gt;in(TypeFunc::Parms) );
2432         // Check for null receiver to virtual or interface calls
2433         if( call-&gt;is_CallDynamicJava() &amp;&amp;
2434             arg0-&gt;higher_equal(TypePtr::NULL_PTR) ) {
2435           f[CatchProjNode::fall_through_index] = Type::TOP;
2436         }
2437       } // End of if not a runtime stub
2438     } // End of if have call above me
2439   } // End of slot 1 is not a projection
2440   return TypeTuple::make(_size, f);
2441 }
2442 
2443 //=============================================================================
2444 uint CatchProjNode::hash() const {
2445   return Node::hash() + _handler_bci;
2446 }
2447 
2448 
<span class="line-modified">2449 uint CatchProjNode::cmp( const Node &amp;n ) const {</span>
2450   return ProjNode::cmp(n) &amp;&amp;
2451     _handler_bci == ((CatchProjNode&amp;)n)._handler_bci;
2452 }
2453 
2454 
2455 //------------------------------Identity---------------------------------------
2456 // If only 1 target is possible, choose it if it is the main control
2457 Node* CatchProjNode::Identity(PhaseGVN* phase) {
2458   // If my value is control and no other value is, then treat as ID
2459   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
2460   if (t-&gt;field_at(_con) != Type::CONTROL)  return this;
2461   // If we remove the last CatchProj and elide the Catch/CatchProj, then we
2462   // also remove any exception table entry.  Thus we must know the call
2463   // feeding the Catch will not really throw an exception.  This is ok for
2464   // the main fall-thru control (happens when we know a call can never throw
2465   // an exception) or for &quot;rethrow&quot;, because a further optimization will
2466   // yank the rethrow (happens when we inline a function that can throw an
2467   // exception and the caller has no handler).  Not legal, e.g., for passing
2468   // a NULL receiver to a v-call, or passing bad types to a slow-check-cast.
2469   // These cases MUST throw an exception via the runtime system, so the VM
</pre>
</td>
<td>
<hr />
<pre>
 866   return RegMask::Empty;
 867 }
 868 
 869 // Find the one non-null required input.  RegionNode only
 870 Node *Node::nonnull_req() const {
 871   assert( is_Region(), &quot;&quot; );
 872   for( uint i = 1; i &lt; _cnt; i++ )
 873     if( in(i) )
 874       return in(i);
 875   ShouldNotReachHere();
 876   return NULL;
 877 }
 878 
 879 
 880 //=============================================================================
 881 // note that these functions assume that the _adr_type field is flattened
 882 uint PhiNode::hash() const {
 883   const Type* at = _adr_type;
 884   return TypeNode::hash() + (at ? at-&gt;hash() : 0);
 885 }
<span class="line-modified"> 886 bool PhiNode::cmp( const Node &amp;n ) const {</span>
 887   return TypeNode::cmp(n) &amp;&amp; _adr_type == ((PhiNode&amp;)n)._adr_type;
 888 }
 889 static inline
 890 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
 891   if (at == NULL || at == TypePtr::BOTTOM)  return at;
 892   return Compile::current()-&gt;alias_type(at)-&gt;adr_type();
 893 }
 894 
 895 //----------------------------make---------------------------------------------
 896 // create a new phi with edges matching r and set (initially) to x
 897 PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
 898   uint preds = r-&gt;req();   // Number of predecessor paths
 899   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), &quot;flatten at&quot;);
 900   PhiNode* p = new PhiNode(r, t, at);
 901   for (uint j = 1; j &lt; preds; j++) {
 902     // Fill in all inputs, except those which the region does not yet have
 903     if (r-&gt;in(j) != NULL)
 904       p-&gt;init_req(j, x);
 905   }
 906   return p;
</pre>
<hr />
<pre>
1432     flipped = 1-flipped;        // Test is vs 1 instead of 0!
1433   }
1434 
1435   // Check for setting zero/one opposite expected
1436   if( tzero == TypeInt::ZERO ) {
1437     if( tone == TypeInt::ONE ) {
1438     } else return NULL;
1439   } else if( tzero == TypeInt::ONE ) {
1440     if( tone == TypeInt::ZERO ) {
1441       flipped = 1-flipped;
1442     } else return NULL;
1443   } else return NULL;
1444 
1445   // Check for boolean test backwards
1446   if( b-&gt;_test._test == BoolTest::ne ) {
1447   } else if( b-&gt;_test._test == BoolTest::eq ) {
1448     flipped = 1-flipped;
1449   } else return NULL;
1450 
1451   // Build int-&gt;bool conversion
<span class="line-modified">1452   Node *n = new Conv2BNode(cmp-&gt;in(1));</span>



1453   if( flipped )
1454     n = new XorINode( phase-&gt;transform(n), phase-&gt;intcon(1) );
1455 
1456   return n;
1457 }
1458 
1459 //------------------------------is_cond_add------------------------------------
1460 // Check for simple conditional add pattern:  &quot;(P &lt; Q) ? X+Y : X;&quot;
1461 // To be profitable the control flow has to disappear; there can be no other
1462 // values merging here.  We replace the test-and-branch with:
1463 // &quot;(sgn(P-Q))&amp;Y) + X&quot;.  Basically, convert &quot;(P &lt; Q)&quot; into 0 or -1 by
1464 // moving the carry bit from (P-Q) into a register with &#39;sbb EAX,EAX&#39;.
1465 // Then convert Y to 0-or-Y and finally add.
1466 // This is a key transform for SpecJava _201_compress.
1467 static Node* is_cond_add(PhaseGVN *phase, PhiNode *phi, int true_path) {
1468   assert(true_path !=0, &quot;only diamond shape graph expected&quot;);
1469 
1470   // is_diamond_phi() has guaranteed the correctness of the nodes sequence:
1471   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1472   RegionNode *region = (RegionNode*)phi-&gt;in(0);
</pre>
<hr />
<pre>
1858       // or through other data nodes.
1859       if ((is_loop &amp;&amp; !uin-&gt;eqv_uncast(in(LoopNode::EntryControl))) ||
1860           (!is_loop &amp;&amp; is_unsafe_data_reference(uin))) {
1861         // Break this data loop to avoid creation of a dead loop.
1862         if (can_reshape) {
1863           return top;
1864         } else {
1865           // We can&#39;t return top if we are in Parse phase - cut inputs only
1866           // let Identity to handle the case.
1867           replace_edge(uin, top);
1868           return NULL;
1869         }
1870       }
1871     }
1872 
1873     if (uncasted) {
1874       // Add cast nodes between the phi to be removed and its unique input.
1875       // Wait until after parsing for the type information to propagate from the casts.
1876       assert(can_reshape, &quot;Invalid during parsing&quot;);
1877       const Type* phi_type = bottom_type();
<span class="line-modified">1878       assert(phi_type-&gt;isa_int() || phi_type-&gt;isa_long() || phi_type-&gt;isa_ptr(), &quot;bad phi type&quot;);</span>
<span class="line-modified">1879       // Add casts to carry the control dependency of the Phi that is going away</span>

1880       Node* cast = NULL;
1881       if (phi_type-&gt;isa_int()) {
1882         cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);
<span class="line-added">1883       } else if (phi_type-&gt;isa_long()) {</span>
<span class="line-added">1884         cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);</span>
1885       } else {
1886         const Type* uin_type = phase-&gt;type(uin);
1887         if (!phi_type-&gt;isa_oopptr() &amp;&amp; !uin_type-&gt;isa_oopptr()) {
1888           cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
1889         } else {
1890           // Use a CastPP for a cast to not null and a CheckCastPP for
1891           // a cast to a new klass (and both if both null-ness and
1892           // klass change).
1893 
1894           // If the type of phi is not null but the type of uin may be
1895           // null, uin&#39;s type must be casted to not null
1896           if (phi_type-&gt;join(TypePtr::NOTNULL) == phi_type-&gt;remove_speculative() &amp;&amp;
1897               uin_type-&gt;join(TypePtr::NOTNULL) != uin_type-&gt;remove_speculative()) {
1898             cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, true);
1899           }
1900 
1901           // If the type of phi and uin, both casted to not null,
1902           // differ the klass of uin must be (check)cast&#39;ed to match
1903           // that of phi
1904           if (phi_type-&gt;join_speculative(TypePtr::NOTNULL) != uin_type-&gt;join_speculative(TypePtr::NOTNULL)) {
</pre>
<hr />
<pre>
1973         assert(req() == 3, &quot;only diamond merge phi here&quot;);
1974         set_req(1, top);
1975         set_req(2, top);
1976         return NULL;
1977       } else {
1978         return opt;
1979       }
1980     }
1981   }
1982 
1983   // Check for merging identical values and split flow paths
1984   if (can_reshape) {
1985     opt = split_flow_path(phase, this);
1986     // This optimization only modifies phi - don&#39;t need to check for dead loop.
1987     assert(opt == NULL || phase-&gt;eqv(opt, this), &quot;do not elide phi&quot;);
1988     if (opt != NULL)  return opt;
1989   }
1990 
1991   if (in(1) != NULL &amp;&amp; in(1)-&gt;Opcode() == Op_AddP &amp;&amp; can_reshape) {
1992     // Try to undo Phi of AddP:
<span class="line-modified">1993     // (Phi (AddP base address offset) (AddP base2 address2 offset2))</span>
1994     // becomes:
1995     // newbase := (Phi base base2)
<span class="line-modified">1996     // newaddress := (Phi address address2)</span>
<span class="line-added">1997     // newoffset := (Phi offset offset2)</span>
<span class="line-added">1998     // (AddP newbase newaddress newoffset)</span>
1999     //
2000     // This occurs as a result of unsuccessful split_thru_phi and
2001     // interferes with taking advantage of addressing modes. See the
2002     // clone_shift_expressions code in matcher.cpp
2003     Node* addp = in(1);
<span class="line-modified">2004     Node* base = addp-&gt;in(AddPNode::Base);</span>
<span class="line-modified">2005     Node* address = addp-&gt;in(AddPNode::Address);</span>
<span class="line-modified">2006     Node* offset = addp-&gt;in(AddPNode::Offset);</span>
<span class="line-added">2007     if (base != NULL &amp;&amp; address != NULL &amp;&amp; offset != NULL &amp;&amp;</span>
<span class="line-added">2008         !base-&gt;is_top() &amp;&amp; !address-&gt;is_top() &amp;&amp; !offset-&gt;is_top()) {</span>
<span class="line-added">2009       const Type* base_type = base-&gt;bottom_type();</span>
<span class="line-added">2010       const Type* address_type = address-&gt;bottom_type();</span>
2011       // make sure that all the inputs are similar to the first one,
2012       // i.e. AddP with base == address and same offset as first AddP
2013       bool doit = true;
2014       for (uint i = 2; i &lt; req(); i++) {
2015         if (in(i) == NULL ||
2016             in(i)-&gt;Opcode() != Op_AddP ||
<span class="line-modified">2017             in(i)-&gt;in(AddPNode::Base) == NULL ||</span>
<span class="line-modified">2018             in(i)-&gt;in(AddPNode::Address) == NULL ||</span>
<span class="line-added">2019             in(i)-&gt;in(AddPNode::Offset) == NULL ||</span>
<span class="line-added">2020             in(i)-&gt;in(AddPNode::Base)-&gt;is_top() ||</span>
<span class="line-added">2021             in(i)-&gt;in(AddPNode::Address)-&gt;is_top() ||</span>
<span class="line-added">2022             in(i)-&gt;in(AddPNode::Offset)-&gt;is_top()) {</span>
2023           doit = false;
2024           break;
2025         }
<span class="line-added">2026         if (in(i)-&gt;in(AddPNode::Offset) != base) {</span>
<span class="line-added">2027           base = NULL;</span>
<span class="line-added">2028         }</span>
<span class="line-added">2029         if (in(i)-&gt;in(AddPNode::Offset) != offset) {</span>
<span class="line-added">2030           offset = NULL;</span>
<span class="line-added">2031         }</span>
<span class="line-added">2032         if (in(i)-&gt;in(AddPNode::Address) != address) {</span>
<span class="line-added">2033           address = NULL;</span>
<span class="line-added">2034         }</span>
2035         // Accumulate type for resulting Phi
<span class="line-modified">2036         base_type = base_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>
<span class="line-added">2037         address_type = address_type-&gt;meet_speculative(in(i)-&gt;in(AddPNode::Base)-&gt;bottom_type());</span>
2038       }
<span class="line-modified">2039       if (doit &amp;&amp; base == NULL) {</span>

2040         // Check for neighboring AddP nodes in a tree.
2041         // If they have a base, use that it.
2042         for (DUIterator_Fast kmax, k = this-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2043           Node* u = this-&gt;fast_out(k);
2044           if (u-&gt;is_AddP()) {
2045             Node* base2 = u-&gt;in(AddPNode::Base);
2046             if (base2 != NULL &amp;&amp; !base2-&gt;is_top()) {
2047               if (base == NULL)
2048                 base = base2;
2049               else if (base != base2)
2050                 { doit = false; break; }
2051             }
2052           }
2053         }
2054       }
2055       if (doit) {
2056         if (base == NULL) {
<span class="line-modified">2057           base = new PhiNode(in(0), base_type, NULL);</span>
2058           for (uint i = 1; i &lt; req(); i++) {
2059             base-&gt;init_req(i, in(i)-&gt;in(AddPNode::Base));
2060           }
2061           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(base);
2062         }
<span class="line-modified">2063         if (address == NULL) {</span>
<span class="line-added">2064           address = new PhiNode(in(0), address_type, NULL);</span>
<span class="line-added">2065           for (uint i = 1; i &lt; req(); i++) {</span>
<span class="line-added">2066             address-&gt;init_req(i, in(i)-&gt;in(AddPNode::Address));</span>
<span class="line-added">2067           }</span>
<span class="line-added">2068           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(address);</span>
<span class="line-added">2069         }</span>
<span class="line-added">2070         if (offset == NULL) {</span>
<span class="line-added">2071           offset = new PhiNode(in(0), TypeX_X, NULL);</span>
<span class="line-added">2072           for (uint i = 1; i &lt; req(); i++) {</span>
<span class="line-added">2073             offset-&gt;init_req(i, in(i)-&gt;in(AddPNode::Offset));</span>
<span class="line-added">2074           }</span>
<span class="line-added">2075           phase-&gt;is_IterGVN()-&gt;register_new_node_with_optimizer(offset);</span>
<span class="line-added">2076         }</span>
<span class="line-added">2077         return new AddPNode(base, address, offset);</span>
2078       }
2079     }
2080   }
2081 
2082   // Split phis through memory merges, so that the memory merges will go away.
2083   // Piggy-back this transformation on the search for a unique input....
2084   // It will be as if the merged memory is the unique value of the phi.
2085   // (Do not attempt this optimization unless parsing is complete.
2086   // It would make the parser&#39;s memory-merge logic sick.)
2087   // (MergeMemNode is not dead_loop_safe - need to check for dead loop.)
2088   if (progress == NULL &amp;&amp; can_reshape &amp;&amp; type() == Type::MEMORY) {
2089     // see if this phi should be sliced
2090     uint merge_width = 0;
2091     bool saw_self = false;
2092     for( uint i=1; i&lt;req(); ++i ) {// For all paths in
2093       Node *ii = in(i);
2094       // TOP inputs should not be counted as safe inputs because if the
2095       // Phi references itself through all other inputs then splitting the
2096       // Phi through memory merges would create dead loop at later stage.
2097       if (ii == top) {
</pre>
<hr />
<pre>
2367   this-&gt;collect_nodes(in_rel, 1, false, false);
2368   this-&gt;collect_nodes(out_rel, -2, false, false);
2369 }
2370 #endif
2371 
2372 //=============================================================================
2373 const RegMask &amp;JProjNode::out_RegMask() const {
2374   return RegMask::Empty;
2375 }
2376 
2377 //=============================================================================
2378 const RegMask &amp;CProjNode::out_RegMask() const {
2379   return RegMask::Empty;
2380 }
2381 
2382 
2383 
2384 //=============================================================================
2385 
2386 uint PCTableNode::hash() const { return Node::hash() + _size; }
<span class="line-modified">2387 bool PCTableNode::cmp( const Node &amp;n ) const</span>
2388 { return _size == ((PCTableNode&amp;)n)._size; }
2389 
2390 const Type *PCTableNode::bottom_type() const {
2391   const Type** f = TypeTuple::fields(_size);
2392   for( uint i = 0; i &lt; _size; i++ ) f[i] = Type::CONTROL;
2393   return TypeTuple::make(_size, f);
2394 }
2395 
2396 //------------------------------Value------------------------------------------
2397 // Compute the type of the PCTableNode.  If reachable it is a tuple of
2398 // Control, otherwise the table targets are not reachable
2399 const Type* PCTableNode::Value(PhaseGVN* phase) const {
2400   if( phase-&gt;type(in(0)) == Type::CONTROL )
2401     return bottom_type();
2402   return Type::TOP;             // All paths dead?  Then so are we
2403 }
2404 
2405 //------------------------------Ideal------------------------------------------
2406 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
2407 // control copies
2408 Node *PCTableNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2409   return remove_dead_region(phase, can_reshape) ? this : NULL;
2410 }
2411 
2412 //=============================================================================
2413 uint JumpProjNode::hash() const {
2414   return Node::hash() + _dest_bci;
2415 }
2416 
<span class="line-modified">2417 bool JumpProjNode::cmp( const Node &amp;n ) const {</span>
2418   return ProjNode::cmp(n) &amp;&amp;
2419     _dest_bci == ((JumpProjNode&amp;)n)._dest_bci;
2420 }
2421 
2422 #ifndef PRODUCT
2423 void JumpProjNode::dump_spec(outputStream *st) const {
2424   ProjNode::dump_spec(st);
2425   st-&gt;print(&quot;@bci %d &quot;,_dest_bci);
2426 }
2427 
2428 void JumpProjNode::dump_compact_spec(outputStream *st) const {
2429   ProjNode::dump_compact_spec(st);
2430   st-&gt;print(&quot;(%d)%d@%d&quot;, _switch_val, _proj_no, _dest_bci);
2431 }
2432 
2433 void JumpProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
2434   // The related nodes of a JumpProjNode are its inputs and outputs at level 1.
2435   this-&gt;collect_nodes(in_rel, 1, false, false);
2436   this-&gt;collect_nodes(out_rel, -1, false, false);
2437 }
</pre>
<hr />
<pre>
2460         f[CatchProjNode::fall_through_index] = Type::TOP;
2461       } else if( call-&gt;req() &gt; TypeFunc::Parms ) {
2462         const Type *arg0 = phase-&gt;type( call-&gt;in(TypeFunc::Parms) );
2463         // Check for null receiver to virtual or interface calls
2464         if( call-&gt;is_CallDynamicJava() &amp;&amp;
2465             arg0-&gt;higher_equal(TypePtr::NULL_PTR) ) {
2466           f[CatchProjNode::fall_through_index] = Type::TOP;
2467         }
2468       } // End of if not a runtime stub
2469     } // End of if have call above me
2470   } // End of slot 1 is not a projection
2471   return TypeTuple::make(_size, f);
2472 }
2473 
2474 //=============================================================================
2475 uint CatchProjNode::hash() const {
2476   return Node::hash() + _handler_bci;
2477 }
2478 
2479 
<span class="line-modified">2480 bool CatchProjNode::cmp( const Node &amp;n ) const {</span>
2481   return ProjNode::cmp(n) &amp;&amp;
2482     _handler_bci == ((CatchProjNode&amp;)n)._handler_bci;
2483 }
2484 
2485 
2486 //------------------------------Identity---------------------------------------
2487 // If only 1 target is possible, choose it if it is the main control
2488 Node* CatchProjNode::Identity(PhaseGVN* phase) {
2489   // If my value is control and no other value is, then treat as ID
2490   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
2491   if (t-&gt;field_at(_con) != Type::CONTROL)  return this;
2492   // If we remove the last CatchProj and elide the Catch/CatchProj, then we
2493   // also remove any exception table entry.  Thus we must know the call
2494   // feeding the Catch will not really throw an exception.  This is ok for
2495   // the main fall-thru control (happens when we know a call can never throw
2496   // an exception) or for &quot;rethrow&quot;, because a further optimization will
2497   // yank the rethrow (happens when we inline a function that can throw an
2498   // exception and the caller has no handler).  Not legal, e.g., for passing
2499   // a NULL receiver to a v-call, or passing bad types to a slow-check-cast.
2500   // These cases MUST throw an exception via the runtime system, so the VM
</pre>
</td>
</tr>
</table>
<center><a href="castnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
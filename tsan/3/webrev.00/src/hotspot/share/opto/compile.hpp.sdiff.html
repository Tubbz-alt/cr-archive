<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="convertnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 #include &quot;libadt/vectset.hpp&quot;
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/phasetype.hpp&quot;
  41 #include &quot;opto/phase.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/timerTrace.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;utilities/ticks.hpp&quot;
  47 
  48 class AddPNode;
  49 class Block;
  50 class Bundle;
  51 class C2Compiler;
  52 class CallGenerator;
  53 class CloneMap;
  54 class ConnectionGraph;

  55 class InlineTree;
  56 class Int_Array;
<span class="line-removed">  57 class LoadBarrierNode;</span>
  58 class Matcher;
  59 class MachConstantNode;
  60 class MachConstantBaseNode;
  61 class MachNode;
  62 class MachOper;
  63 class MachSafePointNode;
  64 class Node;
  65 class Node_Array;
  66 class Node_Notes;
  67 class NodeCloneInfo;
  68 class OptoReg;
  69 class PhaseCFG;
  70 class PhaseGVN;
  71 class PhaseIterGVN;
  72 class PhaseRegAlloc;
  73 class PhaseCCP;
  74 class PhaseCCP_DCE;
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
  87 class Unique_Node_List;
  88 class nmethod;
  89 class WarmCallInfo;
  90 class Node_Stack;
  91 struct Final_Reshape_Counts;
  92 
  93 enum LoopOptsMode {
  94   LoopOptsDefault,
  95   LoopOptsNone,

  96   LoopOptsShenandoahExpand,
  97   LoopOptsShenandoahPostExpand,
  98   LoopOptsSkipSplitIf,
<span class="line-modified">  99   LoopOptsVerify,</span>
<span class="line-removed"> 100   LoopOptsLastRound</span>
 101 };
 102 
 103 typedef unsigned int node_idx_t;
 104 class NodeCloneInfo {
 105  private:
 106   uint64_t _idx_clone_orig;
 107  public:
 108 
 109   void set_idx(node_idx_t idx) {
 110     _idx_clone_orig = (_idx_clone_orig &amp; CONST64(0xFFFFFFFF00000000)) | idx;
 111   }
 112   node_idx_t idx() const { return (node_idx_t)(_idx_clone_orig &amp; 0xFFFFFFFF); }
 113 
 114   void set_gen(int generation) {
 115     uint64_t g = (uint64_t)generation &lt;&lt; 32;
 116     _idx_clone_orig = (_idx_clone_orig &amp; 0xFFFFFFFF) | g;
 117   }
 118   int gen() const { return (int)(_idx_clone_orig &gt;&gt; 32); }
 119 
 120   void set(uint64_t x) { _idx_clone_orig = x; }
</pre>
<hr />
<pre>
 392   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 393   uint                  _max_vector_size;       // Maximum size of generated vectors
 394   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 395   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 396   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 397   uint                  _decompile_count;       // Cumulative decompilation counts.
 398   bool                  _do_inlining;           // True if we intend to do inlining
 399   bool                  _do_scheduling;         // True if we intend to do scheduling
 400   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 401   bool                  _do_count_invocations;  // True if we generate code to count invocations
 402   bool                  _do_method_data_update; // True if we generate code to update MethodData*s
 403   bool                  _do_vector_loop;        // True if allowed to execute loop in parallel iterations
 404   bool                  _use_cmove;             // True if CMove should be used without profitability analysis
 405   bool                  _age_code;              // True if we need to profile code age (decrement the aging counter)
 406   int                   _AliasLevel;            // Locally-adjusted version of AliasLevel flag.
 407   bool                  _print_assembly;        // True if we should dump assembly code for this compilation
 408   bool                  _print_inlining;        // True if we should print inlining for this compilation
 409   bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
 410 #ifndef PRODUCT
 411   bool                  _trace_opto_output;

 412   bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
 413 #endif
 414   bool                  _has_irreducible_loop;  // Found irreducible loops
 415   // JSR 292
 416   bool                  _has_method_handle_invokes; // True if this method has MethodHandle invokes.
 417   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 418   int                   _loop_opts_cnt;         // loop opts round

 419 
 420   // Compilation environment.
 421   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 422   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 423   ciEnv*                _env;                   // CI interface
 424   DirectiveSet*         _directive;             // Compiler directive
 425   CompileLog*           _log;                   // from CompilerThread
 426   const char*           _failure_reason;        // for record_failure/failing pattern
 427   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 428   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 429   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 430   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 431   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 432   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 433   ConnectionGraph*      _congraph;
 434 #ifndef PRODUCT
 435   IdealGraphPrinter*    _printer;
 436 #endif
 437 
 438 
</pre>
<hr />
<pre>
 459   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 460 
 461 
 462   // Blocked array of debugging and profiling information,
 463   // tracked per node.
 464   enum { _log2_node_notes_block_size = 8,
 465          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 466   };
 467   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 468   Node_Notes*           _default_node_notes;  // default notes for new nodes
 469 
 470   // After parsing and every bulk phase we hang onto the Root instruction.
 471   // The RootNode instruction is where the whole program begins.  It produces
 472   // the initial Control and BOTTOM for everybody else.
 473 
 474   // Type management
 475   Arena                 _Compile_types;         // Arena for all types
 476   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 477   Dict*                 _type_dict;             // Intern table
 478   CloneMap              _clone_map;             // used for recording history of cloned nodes
<span class="line-removed"> 479   void*                 _type_hwm;              // Last allocation (see Type::operator new/delete)</span>
 480   size_t                _type_last_size;        // Last allocation size (see Type::operator new/delete)
 481   ciMethod*             _last_tf_m;             // Cache for
 482   const TypeFunc*       _last_tf;               //  TypeFunc::make
 483   AliasType**           _alias_types;           // List of alias types seen so far.
 484   int                   _num_alias_types;       // Logical length of _alias_types
 485   int                   _max_alias_types;       // Physical length of _alias_types
 486   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 487 
 488   // Parsing, optimization
 489   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 490   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 491   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 492 
 493   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 494                                                       // main parsing has finished.
 495   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 496 
 497   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 498 
 499   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 500   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 501 
 502 
 503   // Inlining may not happen in parse order which would make
 504   // PrintInlining output confusing. Keep track of PrintInlining
 505   // pieces in order.
 506   class PrintInliningBuffer : public ResourceObj {
 507    private:
 508     CallGenerator* _cg;
 509     stringStream* _ss;
 510 
 511    public:
 512     PrintInliningBuffer()
 513       : _cg(NULL) { _ss = new stringStream(); }
 514 


 515     stringStream* ss() const { return _ss; }
 516     CallGenerator* cg() const { return _cg; }
 517     void set_cg(CallGenerator* cg) { _cg = cg; }
 518   };
 519 
 520   stringStream* _print_inlining_stream;
 521   GrowableArray&lt;PrintInliningBuffer&gt;* _print_inlining_list;
 522   int _print_inlining_idx;
 523   char* _print_inlining_output;
 524 
 525   // Only keep nodes in the expensive node list that need to be optimized
 526   void cleanup_expensive_nodes(PhaseIterGVN &amp;igvn);
 527   // Use for sorting expensive nodes to bring similar nodes together
 528   static int cmp_expensive_nodes(Node** n1, Node** n2);
 529   // Expensive nodes list already sorted?
 530   bool expensive_nodes_sorted() const;
 531   // Remove the speculative part of types and clean up the graph
 532   void remove_speculative_types(PhaseIterGVN &amp;igvn);
 533 
 534   void* _replay_inline_data; // Pointer to data loaded from file
 535 

 536   void print_inlining_init();
 537   void print_inlining_reinit();
 538   void print_inlining_commit();
 539   void print_inlining_push();
 540   PrintInliningBuffer&amp; print_inlining_current();
 541 
 542   void log_late_inline_failure(CallGenerator* cg, const char* msg);
 543 
 544  public:
 545 
 546   void* barrier_set_state() const { return _barrier_set_state; }
 547 
 548   outputStream* print_inlining_stream() const {
 549     assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
 550     return _print_inlining_stream;
 551   }
 552 
 553   void print_inlining_update(CallGenerator* cg);
 554   void print_inlining_update_delayed(CallGenerator* cg);
 555   void print_inlining_move_to(CallGenerator* cg);
</pre>
<hr />
<pre>
 561     CompileTask::print_inlining_inner(&amp;ss, method, inline_level, bci, msg);
 562     print_inlining_stream()-&gt;print(&quot;%s&quot;, ss.as_string());
 563   }
 564 
 565 #ifndef PRODUCT
 566   IdealGraphPrinter* printer() { return _printer; }
 567 #endif
 568 
 569   void log_late_inline(CallGenerator* cg);
 570   void log_inline_id(CallGenerator* cg);
 571   void log_inline_failure(const char* msg);
 572 
 573   void* replay_inline_data() const { return _replay_inline_data; }
 574 
 575   // Dump inlining replay data to the stream.
 576   void dump_inline_data(outputStream* out);
 577 
 578  private:
 579   // Matching, CFG layout, allocation, code generation
 580   PhaseCFG*             _cfg;                   // Results of CFG finding
<span class="line-removed"> 581   bool                  _select_24_bit_instr;   // We selected an instruction with a 24-bit result</span>
<span class="line-removed"> 582   bool                  _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results</span>
 583   int                   _java_calls;            // Number of java calls in the method
 584   int                   _inner_loops;           // Number of inner loops in the method
 585   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 586   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
 587   int                   _frame_slots;           // Size of total frame in stack slots
 588   CodeOffsets           _code_offsets;          // Offsets into the code for various interesting entries
 589   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 590   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 591   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 592   int                   _interpreter_frame_size;
 593 
 594   uint                  _node_bundling_limit;
 595   Bundle*               _node_bundling_base;    // Information for instruction bundling
 596 
 597   // Instruction bits passed off to the VM
 598   int                   _method_size;           // Size of nmethod code segment in bytes
 599   CodeBuffer            _code_buffer;           // Where the code is assembled
 600   int                   _first_block_size;      // Size of unvalidated entry point code / OSR poison code
 601   ExceptionHandlerTable _handler_table;         // Table of native-code exception handlers
 602   ImplicitExceptionTable _inc_table;            // Table of implicit null checks in native code
</pre>
<hr />
<pre>
 640   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 641   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 642   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 643   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 644   InlineTree*       ilt() const                 { return _ilt; }
 645   address           stub_function() const       { return _stub_function; }
 646   const char*       stub_name() const           { return _stub_name; }
 647   address           stub_entry_point() const    { return _stub_entry_point; }
 648 
 649   // Control of this compilation.
 650   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 651   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 652   int               major_progress() const      { return _major_progress; }
 653   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 654   int               inlining_progress() const   { return _inlining_progress; }
 655   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 656   int               inlining_incrementally() const { return _inlining_incrementally; }
 657   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 658   int               do_cleanup() const          { return _do_cleanup; }
 659   void          set_major_progress()            { _major_progress++; }

 660   void        clear_major_progress()            { _major_progress = 0; }
 661   int               max_inline_size() const     { return _max_inline_size; }
 662   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 663   int               freq_inline_size() const    { return _freq_inline_size; }
 664   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 665   bool              has_loops() const           { return _has_loops; }
 666   void          set_has_loops(bool z)           { _has_loops = z; }
 667   bool              has_split_ifs() const       { return _has_split_ifs; }
 668   void          set_has_split_ifs(bool z)       { _has_split_ifs = z; }
 669   bool              has_unsafe_access() const   { return _has_unsafe_access; }
 670   void          set_has_unsafe_access(bool z)   { _has_unsafe_access = z; }
 671   bool              has_stringbuilder() const   { return _has_stringbuilder; }
 672   void          set_has_stringbuilder(bool z)   { _has_stringbuilder = z; }
 673   bool              has_boxed_value() const     { return _has_boxed_value; }
 674   void          set_has_boxed_value(bool z)     { _has_boxed_value = z; }
 675   bool              has_reserved_stack_access() const { return _has_reserved_stack_access; }
 676   void          set_has_reserved_stack_access(bool z) { _has_reserved_stack_access = z; }
 677   uint              max_vector_size() const     { return _max_vector_size; }
 678   void          set_max_vector_size(uint s)     { _max_vector_size = s; }
 679   bool              clear_upper_avx() const     { return _clear_upper_avx; }
</pre>
<hr />
<pre>
 697   void          set_do_method_data_update(bool z) { _do_method_data_update = z; }
 698   bool              do_vector_loop() const      { return _do_vector_loop; }
 699   void          set_do_vector_loop(bool z)      { _do_vector_loop = z; }
 700   bool              use_cmove() const           { return _use_cmove; }
 701   void          set_use_cmove(bool z)           { _use_cmove = z; }
 702   bool              age_code() const             { return _age_code; }
 703   void          set_age_code(bool z)             { _age_code = z; }
 704   int               AliasLevel() const           { return _AliasLevel; }
 705   bool              print_assembly() const       { return _print_assembly; }
 706   void          set_print_assembly(bool z)       { _print_assembly = z; }
 707   bool              print_inlining() const       { return _print_inlining; }
 708   void          set_print_inlining(bool z)       { _print_inlining = z; }
 709   bool              print_intrinsics() const     { return _print_intrinsics; }
 710   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 711   RTMState          rtm_state()  const           { return _rtm_state; }
 712   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 713   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 714   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 715   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 716   void          set_max_node_limit(uint n)       { _max_node_limit = n; }


 717 
 718   // check the CompilerOracle for special behaviours for this compile
 719   bool          method_has_option(const char * option) {
 720     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 721   }
 722 
 723 #ifndef PRODUCT
 724   bool          trace_opto_output() const       { return _trace_opto_output; }

 725   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 726   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 727   int _in_dump_cnt;  // Required for dumping ir nodes.
 728 #endif
 729   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 730   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 731 
 732   // JSR 292
 733   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 734   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 735 
 736   Ticks _latest_stage_start_counter;
 737 
 738   void begin_method() {
 739 #ifndef PRODUCT
 740     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 741       _printer-&gt;begin_method();
 742     }
 743 #endif
 744     C-&gt;_latest_stage_start_counter.stamp();
 745   }
 746 
<span class="line-modified"> 747   void print_method(CompilerPhaseType cpt, int level = 1) {</span>








 748     EventCompilerPhase event;
 749     if (event.should_commit()) {
 750       event.set_starttime(C-&gt;_latest_stage_start_counter);
 751       event.set_phase((u1) cpt);
 752       event.set_compileId(C-&gt;_compile_id);
 753       event.set_phaseLevel(level);
 754       event.commit();
 755     }
 756 
<span class="line-removed"> 757 </span>
 758 #ifndef PRODUCT
<span class="line-modified"> 759     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {</span>
<span class="line-modified"> 760       _printer-&gt;print_method(CompilerPhaseTypeHelper::to_string(cpt), level);</span>






 761     }
 762 #endif
 763     C-&gt;_latest_stage_start_counter.stamp();
 764   }
 765 
 766   void end_method(int level = 1) {
 767     EventCompilerPhase event;
 768     if (event.should_commit()) {
 769       event.set_starttime(C-&gt;_latest_stage_start_counter);
 770       event.set_phase((u1) PHASE_END);
 771       event.set_compileId(C-&gt;_compile_id);
 772       event.set_phaseLevel(level);
 773       event.commit();
 774     }
 775 #ifndef PRODUCT
 776     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 777       _printer-&gt;end_method();
 778     }
 779 #endif
 780   }
</pre>
<hr />
<pre>
 883   void         set_unique(uint i)          { _unique = i; }
 884   static int   debug_idx()                 { return debug_only(_debug_idx)+0; }
 885   static void  set_debug_idx(int i)        { debug_only(_debug_idx = i); }
 886   Arena*       node_arena()                { return &amp;_node_arena; }
 887   Arena*       old_arena()                 { return &amp;_old_arena; }
 888   RootNode*    root() const                { return _root; }
 889   void         set_root(RootNode* r)       { _root = r; }
 890   StartNode*   start() const;              // (Derived from root.)
 891   void         init_start(StartNode* s);
 892   Node*        immutable_memory();
 893 
 894   Node*        recent_alloc_ctl() const    { return _recent_alloc_ctl; }
 895   Node*        recent_alloc_obj() const    { return _recent_alloc_obj; }
 896   void         set_recent_alloc(Node* ctl, Node* obj) {
 897                                                   _recent_alloc_ctl = ctl;
 898                                                   _recent_alloc_obj = obj;
 899                                            }
 900   void         record_dead_node(uint idx)  { if (_dead_node_list.test_set(idx)) return;
 901                                              _dead_node_count++;
 902                                            }
<span class="line-modified"> 903   bool         is_dead_node(uint idx)      { return _dead_node_list.test(idx) != 0; }</span>
<span class="line-removed"> 904   uint         dead_node_count()           { return _dead_node_count; }</span>
<span class="line-removed"> 905   void         reset_dead_node_list()      { _dead_node_list.Reset();</span>
 906                                              _dead_node_count = 0;
 907                                            }
 908   uint          live_nodes() const         {
 909     int  val = _unique - _dead_node_count;
 910     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 911             return (uint) val;
 912                                            }
 913 #ifdef ASSERT
 914   uint         count_live_nodes_by_graph_walk();
 915   void         print_missing_nodes();
 916 #endif
 917 
 918   // Record modified nodes to check that they are put on IGVN worklist
 919   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 920   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 921   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 922 
 923   // Constant table
 924   ConstantTable&amp;   constant_table() { return _constant_table; }
 925 
</pre>
<hr />
<pre>
 942 
 943   Node_Notes*       node_notes_at(int idx) {
 944     return locate_node_notes(_node_note_array, idx, false);
 945   }
 946   inline bool   set_node_notes_at(int idx, Node_Notes* value);
 947 
 948   // Copy notes from source to dest, if they exist.
 949   // Overwrite dest only if source provides something.
 950   // Return true if information was moved.
 951   bool copy_node_notes_to(Node* dest, Node* source);
 952 
 953   // Workhorse function to sort out the blocked Node_Notes array:
 954   inline Node_Notes* locate_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr,
 955                                        int idx, bool can_grow = false);
 956 
 957   void grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by);
 958 
 959   // Type management
 960   Arena*            type_arena()                { return _type_arena; }
 961   Dict*             type_dict()                 { return _type_dict; }
<span class="line-removed"> 962   void*             type_hwm()                  { return _type_hwm; }</span>
 963   size_t            type_last_size()            { return _type_last_size; }
 964   int               num_alias_types()           { return _num_alias_types; }
 965 
 966   void          init_type_arena()                       { _type_arena = &amp;_Compile_types; }
 967   void          set_type_arena(Arena* a)                { _type_arena = a; }
 968   void          set_type_dict(Dict* d)                  { _type_dict = d; }
<span class="line-removed"> 969   void          set_type_hwm(void* p)                   { _type_hwm = p; }</span>
 970   void          set_type_last_size(size_t sz)           { _type_last_size = sz; }
 971 
 972   const TypeFunc* last_tf(ciMethod* m) {
 973     return (m == _last_tf_m) ? _last_tf : NULL;
 974   }
 975   void set_last_tf(ciMethod* m, const TypeFunc* tf) {
 976     assert(m != NULL || tf == NULL, &quot;&quot;);
 977     _last_tf_m = m;
 978     _last_tf = tf;
 979   }
 980 
 981   AliasType*        alias_type(int                idx)  { assert(idx &lt; num_alias_types(), &quot;oob&quot;); return _alias_types[idx]; }
 982   AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }
 983   bool         have_alias_type(const TypePtr* adr_type);
 984   AliasType*        alias_type(ciField*         field);
 985 
 986   int               get_alias_index(const TypePtr* at)  { return alias_type(at)-&gt;index(); }
 987   const TypePtr*    get_adr_type(uint aidx)             { return alias_type(aidx)-&gt;adr_type(); }
 988   int               get_general_index(uint aidx)        { return alias_type(aidx)-&gt;general_index(); }
 989 
</pre>
<hr />
<pre>
1088       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
1089       // dead node elimination step happens (see Compile::inline_incrementally).
1090       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
1091     }
1092   }
1093 
1094   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
1095   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
1096   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
1097 
1098   bool inline_incrementally_one();
1099   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
1100   void inline_incrementally(PhaseIterGVN&amp; igvn);
1101   void inline_string_calls(bool parse_time);
1102   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
1103   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
1104   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1105 
1106   // Matching, CFG layout, allocation, code generation
1107   PhaseCFG*         cfg()                       { return _cfg; }
<span class="line-removed">1108   bool              select_24_bit_instr() const { return _select_24_bit_instr; }</span>
<span class="line-removed">1109   bool              in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }</span>
1110   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1111   int               java_calls() const          { return _java_calls; }
1112   int               inner_loops() const         { return _inner_loops; }
1113   Matcher*          matcher()                   { return _matcher; }
1114   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
1115   int               frame_slots() const         { return _frame_slots; }
1116   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;
1117   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }
1118   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1119   Arena*            indexSet_arena()            { return _indexSet_arena; }
1120   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
1121   uint              node_bundling_limit()       { return _node_bundling_limit; }
1122   Bundle*           node_bundling_base()        { return _node_bundling_base; }
1123   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }
1124   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }
1125   bool          starts_bundle(const Node *n) const;
1126   bool          need_stack_bang(int frame_size_in_bytes) const;
1127   bool          need_register_stack_bang() const;
1128 
1129   void  update_interpreter_frame_size(int size) {
1130     if (_interpreter_frame_size &lt; size) {
1131       _interpreter_frame_size = size;
1132     }
1133   }
1134   int           bang_size_in_bytes() const;
1135 
1136   void          set_matcher(Matcher* m)                 { _matcher = m; }
1137 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1138   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1139   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1140 
<span class="line-removed">1141   // Remember if this compilation changes hardware mode to 24-bit precision</span>
<span class="line-removed">1142   void set_24_bit_selection_and_mode(bool selection, bool mode) {</span>
<span class="line-removed">1143     _select_24_bit_instr = selection;</span>
<span class="line-removed">1144     _in_24_bit_fp_mode   = mode;</span>
<span class="line-removed">1145   }</span>
<span class="line-removed">1146 </span>
1147   void  set_java_calls(int z) { _java_calls  = z; }
1148   void set_inner_loops(int z) { _inner_loops = z; }
1149 
1150   // Instruction bits passed off to the VM
1151   int               code_size()                 { return _method_size; }
1152   CodeBuffer*       code_buffer()               { return &amp;_code_buffer; }
1153   int               first_block_size()          { return _first_block_size; }
1154   void              set_frame_complete(int off) { if (!in_scratch_emit_size()) { _code_offsets.set_value(CodeOffsets::Frame_Complete, off); } }
1155   ExceptionHandlerTable*  handler_table()       { return &amp;_handler_table; }
1156   ImplicitExceptionTable* inc_table()           { return &amp;_inc_table; }
1157   OopMapSet*        oop_map_set()               { return _oop_map_set; }
1158   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }
1159   Dependencies*     dependencies()              { return env()-&gt;dependencies(); }
1160   static int        CompiledZap_count()         { return _CompiledZap_count; }
1161   BufferBlob*       scratch_buffer_blob()       { return _scratch_buffer_blob; }
1162   void         init_scratch_buffer_blob(int const_size);
1163   void        clear_scratch_buffer_blob();
1164   void          set_scratch_buffer_blob(BufferBlob* b) { _scratch_buffer_blob = b; }
1165   relocInfo*        scratch_locs_memory()       { return _scratch_locs_memory; }
1166   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }
1167 
1168   // emit to scratch blob, report resulting size
1169   uint              scratch_emit_size(const Node* n);
1170   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }
1171   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }
1172 
1173   enum ScratchBufferBlob {
<span class="line-removed">1174 #if defined(PPC64)</span>
1175     MAX_inst_size       = 2048,
<span class="line-removed">1176 #else</span>
<span class="line-removed">1177     MAX_inst_size       = 1024,</span>
<span class="line-removed">1178 #endif</span>
1179     MAX_locs_size       = 128, // number of relocInfo elements
1180     MAX_const_size      = 128,
1181     MAX_stubs_size      = 128
1182   };
1183 
1184   // Major entry point.  Given a Scope, compile the associated method.
1185   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1186   // replacement, entry_bci indicates the bytecode for which to compile a
1187   // continuation.
1188   Compile(ciEnv* ci_env, C2Compiler* compiler, ciMethod* target,
1189           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1190           bool eliminate_boxing, DirectiveSet* directive);
1191 
1192   // Second major entry point.  From the TypeFunc signature, generate code
1193   // to pass arguments from the Java calling convention to the C calling
1194   // convention.
1195   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1196           address stub_function, const char *stub_name,
1197           int is_fancy_jump, bool pass_tls,
1198           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
</pre>
<hr />
<pre>
1233   // Build OopMaps for each GC point
1234   void BuildOopMaps();
1235 
1236   // Append debug info for the node &quot;local&quot; at safepoint node &quot;sfpt&quot; to the
1237   // &quot;array&quot;,   May also consult and add to &quot;objs&quot;, which describes the
1238   // scalar-replaced objects.
1239   void FillLocArray( int idx, MachSafePointNode* sfpt,
1240                      Node *local, GrowableArray&lt;ScopeValue*&gt; *array,
1241                      GrowableArray&lt;ScopeValue*&gt; *objs );
1242 
1243   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1244   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
1245   // Requres that &quot;objs&quot; does not contains an ObjectValue whose id matches
1246   // that of &quot;sv.  Appends &quot;sv&quot;.
1247   static void set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
1248                                      ObjectValue* sv );
1249 
1250   // Process an OopMap Element while emitting nodes
1251   void Process_OopMap_Node(MachNode *mach, int code_offset);
1252 















1253   // Initialize code buffer
<span class="line-modified">1254   CodeBuffer* init_buffer(uint* blk_starts);</span>

1255 
1256   // Write out basic block data to code buffer
1257   void fill_buffer(CodeBuffer* cb, uint* blk_starts);
1258 
1259   // Determine which variable sized branches can be shortened
<span class="line-modified">1260   void shorten_branches(uint* blk_starts, int&amp; code_size, int&amp; reloc_size, int&amp; stub_size);</span>
1261 
1262   // Compute the size of first NumberOfLoopInstrToAlign instructions
1263   // at the head of a loop.
1264   void compute_loop_first_inst_sizes();
1265 
1266   // Compute the information for the exception tables
1267   void FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels);
1268 
1269   // Stack slots that may be unused by the calling convention but must
1270   // otherwise be preserved.  On Intel this includes the return address.
1271   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1272   uint in_preserve_stack_slots();
1273 
1274   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1275   // otherwise be preserved.
1276   // On Intel these are not necessary and the value can be zero.
1277   // On Sparc this describes the words reserved for storing a register window
1278   // when an interrupt occurs.
1279   static uint out_preserve_stack_slots();
1280 
</pre>
<hr />
<pre>
1331     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1332     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1333     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1334   };
1335   // Update histogram.  Return boolean if this is a first-time occurrence.
1336   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1337                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1338   static void print_intrinsic_statistics() PRODUCT_RETURN;
1339 
1340   // Graph verification code
1341   // Walk the node list, verifying that there is a one-to-one
1342   // correspondence between Use-Def edges and Def-Use edges
1343   // The option no_dead_code enables stronger checks that the
1344   // graph is strongly connected from root in both directions.
1345   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1346 
1347   // End-of-run dumps.
1348   static void print_statistics() PRODUCT_RETURN;
1349 
1350   // Dump formatted assembly
<span class="line-modified">1351   void dump_asm(int *pcs = NULL, uint pc_limit = 0) PRODUCT_RETURN;</span>






1352   void dump_pc(int *pcs, int pc_limit, Node *n);
1353 
1354   // Verify ADLC assumptions during startup
1355   static void adlc_verification() PRODUCT_RETURN;
1356 
1357   // Definitions of pd methods
1358   static void pd_compiler2_init();
1359 
1360   // Static parse-time type checking logic for gen_subtype_check:
1361   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1362   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1363 
1364   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1365                               // Optional control dependency (for example, on range check)
1366                               Node* ctrl = NULL);
1367 
1368   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1369   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1370 
1371   // Auxiliary method for randomized fuzzing/stressing
1372   static bool randomized_select(int count);
1373 
1374   // supporting clone_map
1375   CloneMap&amp;     clone_map();
1376   void          set_clone_map(Dict* d);
1377 
<span class="line-modified">1378   bool is_compiling_clinit_for(ciKlass* k);</span>


















1379 };
1380 
1381 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  35 #include &quot;libadt/vectset.hpp&quot;
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/phasetype.hpp&quot;
  41 #include &quot;opto/phase.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/timerTrace.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;utilities/ticks.hpp&quot;
  47 
  48 class AddPNode;
  49 class Block;
  50 class Bundle;
  51 class C2Compiler;
  52 class CallGenerator;
  53 class CloneMap;
  54 class ConnectionGraph;
<span class="line-added">  55 class IdealGraphPrinter;</span>
  56 class InlineTree;
  57 class Int_Array;

  58 class Matcher;
  59 class MachConstantNode;
  60 class MachConstantBaseNode;
  61 class MachNode;
  62 class MachOper;
  63 class MachSafePointNode;
  64 class Node;
  65 class Node_Array;
  66 class Node_Notes;
  67 class NodeCloneInfo;
  68 class OptoReg;
  69 class PhaseCFG;
  70 class PhaseGVN;
  71 class PhaseIterGVN;
  72 class PhaseRegAlloc;
  73 class PhaseCCP;
  74 class PhaseCCP_DCE;
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
  87 class Unique_Node_List;
  88 class nmethod;
  89 class WarmCallInfo;
  90 class Node_Stack;
  91 struct Final_Reshape_Counts;
  92 
  93 enum LoopOptsMode {
  94   LoopOptsDefault,
  95   LoopOptsNone,
<span class="line-added">  96   LoopOptsMaxUnroll,</span>
  97   LoopOptsShenandoahExpand,
  98   LoopOptsShenandoahPostExpand,
  99   LoopOptsSkipSplitIf,
<span class="line-modified"> 100   LoopOptsVerify</span>

 101 };
 102 
 103 typedef unsigned int node_idx_t;
 104 class NodeCloneInfo {
 105  private:
 106   uint64_t _idx_clone_orig;
 107  public:
 108 
 109   void set_idx(node_idx_t idx) {
 110     _idx_clone_orig = (_idx_clone_orig &amp; CONST64(0xFFFFFFFF00000000)) | idx;
 111   }
 112   node_idx_t idx() const { return (node_idx_t)(_idx_clone_orig &amp; 0xFFFFFFFF); }
 113 
 114   void set_gen(int generation) {
 115     uint64_t g = (uint64_t)generation &lt;&lt; 32;
 116     _idx_clone_orig = (_idx_clone_orig &amp; 0xFFFFFFFF) | g;
 117   }
 118   int gen() const { return (int)(_idx_clone_orig &gt;&gt; 32); }
 119 
 120   void set(uint64_t x) { _idx_clone_orig = x; }
</pre>
<hr />
<pre>
 392   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 393   uint                  _max_vector_size;       // Maximum size of generated vectors
 394   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 395   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 396   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 397   uint                  _decompile_count;       // Cumulative decompilation counts.
 398   bool                  _do_inlining;           // True if we intend to do inlining
 399   bool                  _do_scheduling;         // True if we intend to do scheduling
 400   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 401   bool                  _do_count_invocations;  // True if we generate code to count invocations
 402   bool                  _do_method_data_update; // True if we generate code to update MethodData*s
 403   bool                  _do_vector_loop;        // True if allowed to execute loop in parallel iterations
 404   bool                  _use_cmove;             // True if CMove should be used without profitability analysis
 405   bool                  _age_code;              // True if we need to profile code age (decrement the aging counter)
 406   int                   _AliasLevel;            // Locally-adjusted version of AliasLevel flag.
 407   bool                  _print_assembly;        // True if we should dump assembly code for this compilation
 408   bool                  _print_inlining;        // True if we should print inlining for this compilation
 409   bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
 410 #ifndef PRODUCT
 411   bool                  _trace_opto_output;
<span class="line-added"> 412   bool                  _print_ideal;</span>
 413   bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
 414 #endif
 415   bool                  _has_irreducible_loop;  // Found irreducible loops
 416   // JSR 292
 417   bool                  _has_method_handle_invokes; // True if this method has MethodHandle invokes.
 418   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 419   int                   _loop_opts_cnt;         // loop opts round
<span class="line-added"> 420   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry</span>
 421 
 422   // Compilation environment.
 423   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 424   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 425   ciEnv*                _env;                   // CI interface
 426   DirectiveSet*         _directive;             // Compiler directive
 427   CompileLog*           _log;                   // from CompilerThread
 428   const char*           _failure_reason;        // for record_failure/failing pattern
 429   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 430   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 431   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 432   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 433   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 434   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 435   ConnectionGraph*      _congraph;
 436 #ifndef PRODUCT
 437   IdealGraphPrinter*    _printer;
 438 #endif
 439 
 440 
</pre>
<hr />
<pre>
 461   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 462 
 463 
 464   // Blocked array of debugging and profiling information,
 465   // tracked per node.
 466   enum { _log2_node_notes_block_size = 8,
 467          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 468   };
 469   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 470   Node_Notes*           _default_node_notes;  // default notes for new nodes
 471 
 472   // After parsing and every bulk phase we hang onto the Root instruction.
 473   // The RootNode instruction is where the whole program begins.  It produces
 474   // the initial Control and BOTTOM for everybody else.
 475 
 476   // Type management
 477   Arena                 _Compile_types;         // Arena for all types
 478   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 479   Dict*                 _type_dict;             // Intern table
 480   CloneMap              _clone_map;             // used for recording history of cloned nodes

 481   size_t                _type_last_size;        // Last allocation size (see Type::operator new/delete)
 482   ciMethod*             _last_tf_m;             // Cache for
 483   const TypeFunc*       _last_tf;               //  TypeFunc::make
 484   AliasType**           _alias_types;           // List of alias types seen so far.
 485   int                   _num_alias_types;       // Logical length of _alias_types
 486   int                   _max_alias_types;       // Physical length of _alias_types
 487   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 488 
 489   // Parsing, optimization
 490   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 491   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 492   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 493 
 494   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 495                                                       // main parsing has finished.
 496   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 497 
 498   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 499 
 500   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 501   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 502 
 503 
 504   // Inlining may not happen in parse order which would make
 505   // PrintInlining output confusing. Keep track of PrintInlining
 506   // pieces in order.
 507   class PrintInliningBuffer : public ResourceObj {
 508    private:
 509     CallGenerator* _cg;
 510     stringStream* _ss;
 511 
 512    public:
 513     PrintInliningBuffer()
 514       : _cg(NULL) { _ss = new stringStream(); }
 515 
<span class="line-added"> 516     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }</span>
<span class="line-added"> 517 </span>
 518     stringStream* ss() const { return _ss; }
 519     CallGenerator* cg() const { return _cg; }
 520     void set_cg(CallGenerator* cg) { _cg = cg; }
 521   };
 522 
 523   stringStream* _print_inlining_stream;
 524   GrowableArray&lt;PrintInliningBuffer&gt;* _print_inlining_list;
 525   int _print_inlining_idx;
 526   char* _print_inlining_output;
 527 
 528   // Only keep nodes in the expensive node list that need to be optimized
 529   void cleanup_expensive_nodes(PhaseIterGVN &amp;igvn);
 530   // Use for sorting expensive nodes to bring similar nodes together
 531   static int cmp_expensive_nodes(Node** n1, Node** n2);
 532   // Expensive nodes list already sorted?
 533   bool expensive_nodes_sorted() const;
 534   // Remove the speculative part of types and clean up the graph
 535   void remove_speculative_types(PhaseIterGVN &amp;igvn);
 536 
 537   void* _replay_inline_data; // Pointer to data loaded from file
 538 
<span class="line-added"> 539   void print_inlining_stream_free();</span>
 540   void print_inlining_init();
 541   void print_inlining_reinit();
 542   void print_inlining_commit();
 543   void print_inlining_push();
 544   PrintInliningBuffer&amp; print_inlining_current();
 545 
 546   void log_late_inline_failure(CallGenerator* cg, const char* msg);
 547 
 548  public:
 549 
 550   void* barrier_set_state() const { return _barrier_set_state; }
 551 
 552   outputStream* print_inlining_stream() const {
 553     assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
 554     return _print_inlining_stream;
 555   }
 556 
 557   void print_inlining_update(CallGenerator* cg);
 558   void print_inlining_update_delayed(CallGenerator* cg);
 559   void print_inlining_move_to(CallGenerator* cg);
</pre>
<hr />
<pre>
 565     CompileTask::print_inlining_inner(&amp;ss, method, inline_level, bci, msg);
 566     print_inlining_stream()-&gt;print(&quot;%s&quot;, ss.as_string());
 567   }
 568 
 569 #ifndef PRODUCT
 570   IdealGraphPrinter* printer() { return _printer; }
 571 #endif
 572 
 573   void log_late_inline(CallGenerator* cg);
 574   void log_inline_id(CallGenerator* cg);
 575   void log_inline_failure(const char* msg);
 576 
 577   void* replay_inline_data() const { return _replay_inline_data; }
 578 
 579   // Dump inlining replay data to the stream.
 580   void dump_inline_data(outputStream* out);
 581 
 582  private:
 583   // Matching, CFG layout, allocation, code generation
 584   PhaseCFG*             _cfg;                   // Results of CFG finding


 585   int                   _java_calls;            // Number of java calls in the method
 586   int                   _inner_loops;           // Number of inner loops in the method
 587   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 588   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
 589   int                   _frame_slots;           // Size of total frame in stack slots
 590   CodeOffsets           _code_offsets;          // Offsets into the code for various interesting entries
 591   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 592   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 593   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 594   int                   _interpreter_frame_size;
 595 
 596   uint                  _node_bundling_limit;
 597   Bundle*               _node_bundling_base;    // Information for instruction bundling
 598 
 599   // Instruction bits passed off to the VM
 600   int                   _method_size;           // Size of nmethod code segment in bytes
 601   CodeBuffer            _code_buffer;           // Where the code is assembled
 602   int                   _first_block_size;      // Size of unvalidated entry point code / OSR poison code
 603   ExceptionHandlerTable _handler_table;         // Table of native-code exception handlers
 604   ImplicitExceptionTable _inc_table;            // Table of implicit null checks in native code
</pre>
<hr />
<pre>
 642   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 643   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 644   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 645   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 646   InlineTree*       ilt() const                 { return _ilt; }
 647   address           stub_function() const       { return _stub_function; }
 648   const char*       stub_name() const           { return _stub_name; }
 649   address           stub_entry_point() const    { return _stub_entry_point; }
 650 
 651   // Control of this compilation.
 652   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 653   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 654   int               major_progress() const      { return _major_progress; }
 655   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 656   int               inlining_progress() const   { return _inlining_progress; }
 657   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 658   int               inlining_incrementally() const { return _inlining_incrementally; }
 659   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 660   int               do_cleanup() const          { return _do_cleanup; }
 661   void          set_major_progress()            { _major_progress++; }
<span class="line-added"> 662   void          restore_major_progress(int progress) { _major_progress += progress; }</span>
 663   void        clear_major_progress()            { _major_progress = 0; }
 664   int               max_inline_size() const     { return _max_inline_size; }
 665   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 666   int               freq_inline_size() const    { return _freq_inline_size; }
 667   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 668   bool              has_loops() const           { return _has_loops; }
 669   void          set_has_loops(bool z)           { _has_loops = z; }
 670   bool              has_split_ifs() const       { return _has_split_ifs; }
 671   void          set_has_split_ifs(bool z)       { _has_split_ifs = z; }
 672   bool              has_unsafe_access() const   { return _has_unsafe_access; }
 673   void          set_has_unsafe_access(bool z)   { _has_unsafe_access = z; }
 674   bool              has_stringbuilder() const   { return _has_stringbuilder; }
 675   void          set_has_stringbuilder(bool z)   { _has_stringbuilder = z; }
 676   bool              has_boxed_value() const     { return _has_boxed_value; }
 677   void          set_has_boxed_value(bool z)     { _has_boxed_value = z; }
 678   bool              has_reserved_stack_access() const { return _has_reserved_stack_access; }
 679   void          set_has_reserved_stack_access(bool z) { _has_reserved_stack_access = z; }
 680   uint              max_vector_size() const     { return _max_vector_size; }
 681   void          set_max_vector_size(uint s)     { _max_vector_size = s; }
 682   bool              clear_upper_avx() const     { return _clear_upper_avx; }
</pre>
<hr />
<pre>
 700   void          set_do_method_data_update(bool z) { _do_method_data_update = z; }
 701   bool              do_vector_loop() const      { return _do_vector_loop; }
 702   void          set_do_vector_loop(bool z)      { _do_vector_loop = z; }
 703   bool              use_cmove() const           { return _use_cmove; }
 704   void          set_use_cmove(bool z)           { _use_cmove = z; }
 705   bool              age_code() const             { return _age_code; }
 706   void          set_age_code(bool z)             { _age_code = z; }
 707   int               AliasLevel() const           { return _AliasLevel; }
 708   bool              print_assembly() const       { return _print_assembly; }
 709   void          set_print_assembly(bool z)       { _print_assembly = z; }
 710   bool              print_inlining() const       { return _print_inlining; }
 711   void          set_print_inlining(bool z)       { _print_inlining = z; }
 712   bool              print_intrinsics() const     { return _print_intrinsics; }
 713   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 714   RTMState          rtm_state()  const           { return _rtm_state; }
 715   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 716   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 717   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 718   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 719   void          set_max_node_limit(uint n)       { _max_node_limit = n; }
<span class="line-added"> 720   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }</span>
<span class="line-added"> 721   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }</span>
 722 
 723   // check the CompilerOracle for special behaviours for this compile
 724   bool          method_has_option(const char * option) {
 725     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 726   }
 727 
 728 #ifndef PRODUCT
 729   bool          trace_opto_output() const       { return _trace_opto_output; }
<span class="line-added"> 730   bool          print_ideal() const             { return _print_ideal; }</span>
 731   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 732   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 733   int _in_dump_cnt;  // Required for dumping ir nodes.
 734 #endif
 735   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 736   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 737 
 738   // JSR 292
 739   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 740   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 741 
 742   Ticks _latest_stage_start_counter;
 743 
 744   void begin_method() {
 745 #ifndef PRODUCT
 746     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 747       _printer-&gt;begin_method();
 748     }
 749 #endif
 750     C-&gt;_latest_stage_start_counter.stamp();
 751   }
 752 
<span class="line-modified"> 753   bool should_print(int level = 1) {</span>
<span class="line-added"> 754 #ifndef PRODUCT</span>
<span class="line-added"> 755     return (_printer &amp;&amp; _printer-&gt;should_print(level));</span>
<span class="line-added"> 756 #else</span>
<span class="line-added"> 757     return false;</span>
<span class="line-added"> 758 #endif</span>
<span class="line-added"> 759   }</span>
<span class="line-added"> 760 </span>
<span class="line-added"> 761   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {</span>
 762     EventCompilerPhase event;
 763     if (event.should_commit()) {
 764       event.set_starttime(C-&gt;_latest_stage_start_counter);
 765       event.set_phase((u1) cpt);
 766       event.set_compileId(C-&gt;_compile_id);
 767       event.set_phaseLevel(level);
 768       event.commit();
 769     }
 770 

 771 #ifndef PRODUCT
<span class="line-modified"> 772     if (should_print(level)) {</span>
<span class="line-modified"> 773       char output[1024];</span>
<span class="line-added"> 774       if (idx != 0) {</span>
<span class="line-added"> 775         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
<span class="line-added"> 776       } else {</span>
<span class="line-added"> 777         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
<span class="line-added"> 778       }</span>
<span class="line-added"> 779       _printer-&gt;print_method(output, level);</span>
 780     }
 781 #endif
 782     C-&gt;_latest_stage_start_counter.stamp();
 783   }
 784 
 785   void end_method(int level = 1) {
 786     EventCompilerPhase event;
 787     if (event.should_commit()) {
 788       event.set_starttime(C-&gt;_latest_stage_start_counter);
 789       event.set_phase((u1) PHASE_END);
 790       event.set_compileId(C-&gt;_compile_id);
 791       event.set_phaseLevel(level);
 792       event.commit();
 793     }
 794 #ifndef PRODUCT
 795     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 796       _printer-&gt;end_method();
 797     }
 798 #endif
 799   }
</pre>
<hr />
<pre>
 902   void         set_unique(uint i)          { _unique = i; }
 903   static int   debug_idx()                 { return debug_only(_debug_idx)+0; }
 904   static void  set_debug_idx(int i)        { debug_only(_debug_idx = i); }
 905   Arena*       node_arena()                { return &amp;_node_arena; }
 906   Arena*       old_arena()                 { return &amp;_old_arena; }
 907   RootNode*    root() const                { return _root; }
 908   void         set_root(RootNode* r)       { _root = r; }
 909   StartNode*   start() const;              // (Derived from root.)
 910   void         init_start(StartNode* s);
 911   Node*        immutable_memory();
 912 
 913   Node*        recent_alloc_ctl() const    { return _recent_alloc_ctl; }
 914   Node*        recent_alloc_obj() const    { return _recent_alloc_obj; }
 915   void         set_recent_alloc(Node* ctl, Node* obj) {
 916                                                   _recent_alloc_ctl = ctl;
 917                                                   _recent_alloc_obj = obj;
 918                                            }
 919   void         record_dead_node(uint idx)  { if (_dead_node_list.test_set(idx)) return;
 920                                              _dead_node_count++;
 921                                            }
<span class="line-modified"> 922   void         reset_dead_node_list()      { _dead_node_list.reset();</span>


 923                                              _dead_node_count = 0;
 924                                            }
 925   uint          live_nodes() const         {
 926     int  val = _unique - _dead_node_count;
 927     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 928             return (uint) val;
 929                                            }
 930 #ifdef ASSERT
 931   uint         count_live_nodes_by_graph_walk();
 932   void         print_missing_nodes();
 933 #endif
 934 
 935   // Record modified nodes to check that they are put on IGVN worklist
 936   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 937   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 938   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 939 
 940   // Constant table
 941   ConstantTable&amp;   constant_table() { return _constant_table; }
 942 
</pre>
<hr />
<pre>
 959 
 960   Node_Notes*       node_notes_at(int idx) {
 961     return locate_node_notes(_node_note_array, idx, false);
 962   }
 963   inline bool   set_node_notes_at(int idx, Node_Notes* value);
 964 
 965   // Copy notes from source to dest, if they exist.
 966   // Overwrite dest only if source provides something.
 967   // Return true if information was moved.
 968   bool copy_node_notes_to(Node* dest, Node* source);
 969 
 970   // Workhorse function to sort out the blocked Node_Notes array:
 971   inline Node_Notes* locate_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr,
 972                                        int idx, bool can_grow = false);
 973 
 974   void grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by);
 975 
 976   // Type management
 977   Arena*            type_arena()                { return _type_arena; }
 978   Dict*             type_dict()                 { return _type_dict; }

 979   size_t            type_last_size()            { return _type_last_size; }
 980   int               num_alias_types()           { return _num_alias_types; }
 981 
 982   void          init_type_arena()                       { _type_arena = &amp;_Compile_types; }
 983   void          set_type_arena(Arena* a)                { _type_arena = a; }
 984   void          set_type_dict(Dict* d)                  { _type_dict = d; }

 985   void          set_type_last_size(size_t sz)           { _type_last_size = sz; }
 986 
 987   const TypeFunc* last_tf(ciMethod* m) {
 988     return (m == _last_tf_m) ? _last_tf : NULL;
 989   }
 990   void set_last_tf(ciMethod* m, const TypeFunc* tf) {
 991     assert(m != NULL || tf == NULL, &quot;&quot;);
 992     _last_tf_m = m;
 993     _last_tf = tf;
 994   }
 995 
 996   AliasType*        alias_type(int                idx)  { assert(idx &lt; num_alias_types(), &quot;oob&quot;); return _alias_types[idx]; }
 997   AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }
 998   bool         have_alias_type(const TypePtr* adr_type);
 999   AliasType*        alias_type(ciField*         field);
1000 
1001   int               get_alias_index(const TypePtr* at)  { return alias_type(at)-&gt;index(); }
1002   const TypePtr*    get_adr_type(uint aidx)             { return alias_type(aidx)-&gt;adr_type(); }
1003   int               get_general_index(uint aidx)        { return alias_type(aidx)-&gt;general_index(); }
1004 
</pre>
<hr />
<pre>
1103       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
1104       // dead node elimination step happens (see Compile::inline_incrementally).
1105       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
1106     }
1107   }
1108 
1109   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
1110   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
1111   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
1112 
1113   bool inline_incrementally_one();
1114   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
1115   void inline_incrementally(PhaseIterGVN&amp; igvn);
1116   void inline_string_calls(bool parse_time);
1117   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
1118   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
1119   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1120 
1121   // Matching, CFG layout, allocation, code generation
1122   PhaseCFG*         cfg()                       { return _cfg; }


1123   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1124   int               java_calls() const          { return _java_calls; }
1125   int               inner_loops() const         { return _inner_loops; }
1126   Matcher*          matcher()                   { return _matcher; }
1127   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
1128   int               frame_slots() const         { return _frame_slots; }
1129   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;
1130   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }
1131   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1132   Arena*            indexSet_arena()            { return _indexSet_arena; }
1133   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
1134   uint              node_bundling_limit()       { return _node_bundling_limit; }
1135   Bundle*           node_bundling_base()        { return _node_bundling_base; }
1136   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }
1137   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }
1138   bool          starts_bundle(const Node *n) const;
1139   bool          need_stack_bang(int frame_size_in_bytes) const;
1140   bool          need_register_stack_bang() const;
1141 
1142   void  update_interpreter_frame_size(int size) {
1143     if (_interpreter_frame_size &lt; size) {
1144       _interpreter_frame_size = size;
1145     }
1146   }
1147   int           bang_size_in_bytes() const;
1148 
1149   void          set_matcher(Matcher* m)                 { _matcher = m; }
1150 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1151   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1152   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1153 






1154   void  set_java_calls(int z) { _java_calls  = z; }
1155   void set_inner_loops(int z) { _inner_loops = z; }
1156 
1157   // Instruction bits passed off to the VM
1158   int               code_size()                 { return _method_size; }
1159   CodeBuffer*       code_buffer()               { return &amp;_code_buffer; }
1160   int               first_block_size()          { return _first_block_size; }
1161   void              set_frame_complete(int off) { if (!in_scratch_emit_size()) { _code_offsets.set_value(CodeOffsets::Frame_Complete, off); } }
1162   ExceptionHandlerTable*  handler_table()       { return &amp;_handler_table; }
1163   ImplicitExceptionTable* inc_table()           { return &amp;_inc_table; }
1164   OopMapSet*        oop_map_set()               { return _oop_map_set; }
1165   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }
1166   Dependencies*     dependencies()              { return env()-&gt;dependencies(); }
1167   static int        CompiledZap_count()         { return _CompiledZap_count; }
1168   BufferBlob*       scratch_buffer_blob()       { return _scratch_buffer_blob; }
1169   void         init_scratch_buffer_blob(int const_size);
1170   void        clear_scratch_buffer_blob();
1171   void          set_scratch_buffer_blob(BufferBlob* b) { _scratch_buffer_blob = b; }
1172   relocInfo*        scratch_locs_memory()       { return _scratch_locs_memory; }
1173   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }
1174 
1175   // emit to scratch blob, report resulting size
1176   uint              scratch_emit_size(const Node* n);
1177   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }
1178   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }
1179 
1180   enum ScratchBufferBlob {

1181     MAX_inst_size       = 2048,



1182     MAX_locs_size       = 128, // number of relocInfo elements
1183     MAX_const_size      = 128,
1184     MAX_stubs_size      = 128
1185   };
1186 
1187   // Major entry point.  Given a Scope, compile the associated method.
1188   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1189   // replacement, entry_bci indicates the bytecode for which to compile a
1190   // continuation.
1191   Compile(ciEnv* ci_env, C2Compiler* compiler, ciMethod* target,
1192           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1193           bool eliminate_boxing, DirectiveSet* directive);
1194 
1195   // Second major entry point.  From the TypeFunc signature, generate code
1196   // to pass arguments from the Java calling convention to the C calling
1197   // convention.
1198   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1199           address stub_function, const char *stub_name,
1200           int is_fancy_jump, bool pass_tls,
1201           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
</pre>
<hr />
<pre>
1236   // Build OopMaps for each GC point
1237   void BuildOopMaps();
1238 
1239   // Append debug info for the node &quot;local&quot; at safepoint node &quot;sfpt&quot; to the
1240   // &quot;array&quot;,   May also consult and add to &quot;objs&quot;, which describes the
1241   // scalar-replaced objects.
1242   void FillLocArray( int idx, MachSafePointNode* sfpt,
1243                      Node *local, GrowableArray&lt;ScopeValue*&gt; *array,
1244                      GrowableArray&lt;ScopeValue*&gt; *objs );
1245 
1246   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1247   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
1248   // Requres that &quot;objs&quot; does not contains an ObjectValue whose id matches
1249   // that of &quot;sv.  Appends &quot;sv&quot;.
1250   static void set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
1251                                      ObjectValue* sv );
1252 
1253   // Process an OopMap Element while emitting nodes
1254   void Process_OopMap_Node(MachNode *mach, int code_offset);
1255 
<span class="line-added">1256   class BufferSizingData {</span>
<span class="line-added">1257   public:</span>
<span class="line-added">1258     int _stub;</span>
<span class="line-added">1259     int _code;</span>
<span class="line-added">1260     int _const;</span>
<span class="line-added">1261     int _reloc;</span>
<span class="line-added">1262 </span>
<span class="line-added">1263       BufferSizingData() :</span>
<span class="line-added">1264       _stub(0),</span>
<span class="line-added">1265       _code(0),</span>
<span class="line-added">1266       _const(0),</span>
<span class="line-added">1267       _reloc(0)</span>
<span class="line-added">1268       { };</span>
<span class="line-added">1269   };</span>
<span class="line-added">1270 </span>
1271   // Initialize code buffer
<span class="line-modified">1272   void        estimate_buffer_size(int&amp; const_req);</span>
<span class="line-added">1273   CodeBuffer* init_buffer(BufferSizingData&amp; buf_sizes);</span>
1274 
1275   // Write out basic block data to code buffer
1276   void fill_buffer(CodeBuffer* cb, uint* blk_starts);
1277 
1278   // Determine which variable sized branches can be shortened
<span class="line-modified">1279   void shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes);</span>
1280 
1281   // Compute the size of first NumberOfLoopInstrToAlign instructions
1282   // at the head of a loop.
1283   void compute_loop_first_inst_sizes();
1284 
1285   // Compute the information for the exception tables
1286   void FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels);
1287 
1288   // Stack slots that may be unused by the calling convention but must
1289   // otherwise be preserved.  On Intel this includes the return address.
1290   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1291   uint in_preserve_stack_slots();
1292 
1293   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1294   // otherwise be preserved.
1295   // On Intel these are not necessary and the value can be zero.
1296   // On Sparc this describes the words reserved for storing a register window
1297   // when an interrupt occurs.
1298   static uint out_preserve_stack_slots();
1299 
</pre>
<hr />
<pre>
1350     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1351     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1352     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1353   };
1354   // Update histogram.  Return boolean if this is a first-time occurrence.
1355   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1356                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1357   static void print_intrinsic_statistics() PRODUCT_RETURN;
1358 
1359   // Graph verification code
1360   // Walk the node list, verifying that there is a one-to-one
1361   // correspondence between Use-Def edges and Def-Use edges
1362   // The option no_dead_code enables stronger checks that the
1363   // graph is strongly connected from root in both directions.
1364   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1365 
1366   // End-of-run dumps.
1367   static void print_statistics() PRODUCT_RETURN;
1368 
1369   // Dump formatted assembly
<span class="line-modified">1370 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-added">1371   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);</span>
<span class="line-added">1372   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }</span>
<span class="line-added">1373 #else</span>
<span class="line-added">1374   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }</span>
<span class="line-added">1375   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }</span>
<span class="line-added">1376 #endif</span>
1377   void dump_pc(int *pcs, int pc_limit, Node *n);
1378 
1379   // Verify ADLC assumptions during startup
1380   static void adlc_verification() PRODUCT_RETURN;
1381 
1382   // Definitions of pd methods
1383   static void pd_compiler2_init();
1384 
1385   // Static parse-time type checking logic for gen_subtype_check:
1386   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1387   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1388 
1389   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1390                               // Optional control dependency (for example, on range check)
1391                               Node* ctrl = NULL);
1392 
1393   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1394   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1395 
1396   // Auxiliary method for randomized fuzzing/stressing
1397   static bool randomized_select(int count);
1398 
1399   // supporting clone_map
1400   CloneMap&amp;     clone_map();
1401   void          set_clone_map(Dict* d);
1402 
<span class="line-modified">1403   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);</span>
<span class="line-added">1404   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);</span>
<span class="line-added">1405   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);</span>
<span class="line-added">1406 </span>
<span class="line-added">1407 #ifdef IA32</span>
<span class="line-added">1408  private:</span>
<span class="line-added">1409   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result</span>
<span class="line-added">1410   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results</span>
<span class="line-added">1411 </span>
<span class="line-added">1412   // Remember if this compilation changes hardware mode to 24-bit precision.</span>
<span class="line-added">1413   void set_24_bit_selection_and_mode(bool selection, bool mode) {</span>
<span class="line-added">1414     _select_24_bit_instr = selection;</span>
<span class="line-added">1415     _in_24_bit_fp_mode   = mode;</span>
<span class="line-added">1416   }</span>
<span class="line-added">1417 </span>
<span class="line-added">1418  public:</span>
<span class="line-added">1419   bool select_24_bit_instr() const { return _select_24_bit_instr; }</span>
<span class="line-added">1420   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }</span>
<span class="line-added">1421 #endif // IA32</span>
1422 };
1423 
1424 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="convertnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
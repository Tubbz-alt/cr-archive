<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/indexSet.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;opto/chaitin.hpp&quot;
 28 #include &quot;opto/compile.hpp&quot;
 29 #include &quot;opto/indexSet.hpp&quot;
 30 #include &quot;opto/regmask.hpp&quot;
 31 
 32 // This file defines the IndexSet class, a set of sparse integer indices.
 33 // This data structure is used by the compiler in its liveness analysis and
 34 // during register allocation.  It also defines an iterator for this class.
 35 
 36 //-------------------------------- Initializations ------------------------------
 37 
 38 IndexSet::BitBlock  IndexSet::_empty_block     = IndexSet::BitBlock();
 39 
 40 #ifdef ASSERT
 41 // Initialize statistics counters
 42 julong IndexSet::_alloc_new = 0;
 43 julong IndexSet::_alloc_total = 0;
 44 
 45 julong IndexSet::_total_bits = 0;
 46 julong IndexSet::_total_used_blocks = 0;
 47 julong IndexSet::_total_unused_blocks = 0;
 48 
 49 // Per set, or all sets operation tracing
 50 int IndexSet::_serial_count = 1;
 51 #endif
 52 
 53 //---------------------------- IndexSet::populate_free_list() -----------------------------
 54 // Populate the free BitBlock list with a batch of BitBlocks.  The BitBlocks
 55 // are 32 bit aligned.
 56 
 57 void IndexSet::populate_free_list() {
 58   Compile *compile = Compile::current();
 59   BitBlock *free = (BitBlock*)compile-&gt;indexSet_free_block_list();
 60 
 61   char *mem = (char*)arena()-&gt;Amalloc_4(sizeof(BitBlock) *
 62                                         bitblock_alloc_chunk_size + 32);
 63 
 64   // Align the pointer to a 32 bit boundary.
 65   BitBlock *new_blocks = (BitBlock*)(((uintptr_t)mem + 32) &amp; ~0x001F);
 66 
 67   // Add the new blocks to the free list.
 68   for (int i = 0; i &lt; bitblock_alloc_chunk_size; i++) {
 69     new_blocks-&gt;set_next(free);
 70     free = new_blocks;
 71     new_blocks++;
 72   }
 73 
 74   compile-&gt;set_indexSet_free_block_list(free);
 75 
 76 #ifdef ASSERT
 77   if (CollectIndexSetStatistics) {
 78     inc_stat_counter(&amp;_alloc_new, bitblock_alloc_chunk_size);
 79   }
 80 #endif
 81 }
 82 
 83 
 84 //---------------------------- IndexSet::alloc_block() ------------------------
 85 // Allocate a BitBlock from the free list.  If the free list is empty,
 86 // prime it.
 87 
 88 IndexSet::BitBlock *IndexSet::alloc_block() {
 89 #ifdef ASSERT
 90   if (CollectIndexSetStatistics) {
 91     inc_stat_counter(&amp;_alloc_total, 1);
 92   }
 93 #endif
 94   Compile *compile = Compile::current();
 95   BitBlock* free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 96   if (free_list == NULL) {
 97     populate_free_list();
 98     free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 99   }
100   BitBlock *block = free_list;
101   compile-&gt;set_indexSet_free_block_list(block-&gt;next());
102 
103   block-&gt;clear();
104   return block;
105 }
106 
107 //---------------------------- IndexSet::alloc_block_containing() -------------
108 // Allocate a new BitBlock and put it into the position in the _blocks array
109 // corresponding to element.
110 
111 IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
112   BitBlock *block = alloc_block();
113   uint bi = get_block_index(element);
<a name="1" id="anc1"></a><span class="line-added">114   if (bi &gt;= _current_block_limit) {</span>
<span class="line-added">115     _current_block_limit = bi + 1;</span>
<span class="line-added">116   }</span>
117   _blocks[bi] = block;
118   return block;
119 }
120 
121 //---------------------------- IndexSet::free_block() -------------------------
122 // Add a BitBlock to the free list.
123 
124 void IndexSet::free_block(uint i) {
125   debug_only(check_watch(&quot;free block&quot;, i));
126   assert(i &lt; _max_blocks, &quot;block index too large&quot;);
127   BitBlock *block = _blocks[i];
128   assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
129   block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
130   Compile::current()-&gt;set_indexSet_free_block_list(block);
<a name="2" id="anc2"></a><span class="line-modified">131   set_block(i, &amp;_empty_block);</span>
132 }
133 
134 //------------------------------lrg_union--------------------------------------
135 // Compute the union of all elements of one and two which interfere with
136 // the RegMask mask.  If the degree of the union becomes exceeds
137 // fail_degree, the union bails out.  The underlying set is cleared before
138 // the union is performed.
139 
140 uint IndexSet::lrg_union(uint lr1, uint lr2,
141                          const uint fail_degree,
142                          const PhaseIFG *ifg,
143                          const RegMask &amp;mask ) {
144   IndexSet *one = ifg-&gt;neighbors(lr1);
145   IndexSet *two = ifg-&gt;neighbors(lr2);
146   LRG &amp;lrg1 = ifg-&gt;lrgs(lr1);
147   LRG &amp;lrg2 = ifg-&gt;lrgs(lr2);
148 #ifdef ASSERT
149   assert(_max_elements == one-&gt;_max_elements, &quot;max element mismatch&quot;);
150   check_watch(&quot;union destination&quot;);
151   one-&gt;check_watch(&quot;union source&quot;);
152   two-&gt;check_watch(&quot;union source&quot;);
153 #endif
154 
155   // Compute the degree of the combined live-range.  The combined
156   // live-range has the union of the original live-ranges&#39; neighbors set as
157   // well as the neighbors of all intermediate copies, minus those neighbors
158   // that can not use the intersected allowed-register-set.
159 
160   // Copy the larger set.  Insert the smaller set into the larger.
161   if (two-&gt;count() &gt; one-&gt;count()) {
162     IndexSet *temp = one;
163     one = two;
164     two = temp;
165   }
166 
167   clear();
168 
169   // Used to compute degree of register-only interferences.  Infinite-stack
170   // neighbors do not alter colorability, as they can always color to some
171   // other color.  (A variant of the Briggs assertion)
172   uint reg_degree = 0;
173 
<a name="3" id="anc3"></a><span class="line-modified">174   uint element = 0;</span>
175   // Load up the combined interference set with the neighbors of one
<a name="4" id="anc4"></a><span class="line-modified">176   if (!one-&gt;is_empty()) {</span>
<span class="line-modified">177     IndexSetIterator elements(one);</span>
<span class="line-modified">178     while ((element = elements.next()) != 0) {</span>
<span class="line-modified">179       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-modified">180       if (mask.overlap(lrg.mask())) {</span>
<span class="line-modified">181         insert(element);</span>
<span class="line-modified">182         if (!lrg.mask().is_AllStack()) {</span>
<span class="line-modified">183           reg_degree += lrg1.compute_degree(lrg);</span>
<span class="line-modified">184           if (reg_degree &gt;= fail_degree) return reg_degree;</span>
















185         } else {
186           // !!!!! Danger!  No update to reg_degree despite having a neighbor.
187           // A variant of the Briggs assertion.
188           // Not needed if I simplify during coalesce, ala George/Appel.
<a name="5" id="anc5"></a><span class="line-modified">189           assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">190         }</span>
<span class="line-added">191       }</span>
<span class="line-added">192     }</span>
<span class="line-added">193   }</span>
<span class="line-added">194   // Add neighbors of two as well</span>
<span class="line-added">195 </span>
<span class="line-added">196   if (!two-&gt;is_empty()) {</span>
<span class="line-added">197     IndexSetIterator elements2(two);</span>
<span class="line-added">198     while ((element = elements2.next()) != 0) {</span>
<span class="line-added">199       LRG &amp;lrg = ifg-&gt;lrgs(element);</span>
<span class="line-added">200       if (mask.overlap(lrg.mask())) {</span>
<span class="line-added">201         if (insert(element)) {</span>
<span class="line-added">202           if (!lrg.mask().is_AllStack()) {</span>
<span class="line-added">203             reg_degree += lrg2.compute_degree(lrg);</span>
<span class="line-added">204             if (reg_degree &gt;= fail_degree) return reg_degree;</span>
<span class="line-added">205           } else {</span>
<span class="line-added">206             // !!!!! Danger!  No update to reg_degree despite having a neighbor.</span>
<span class="line-added">207             // A variant of the Briggs assertion.</span>
<span class="line-added">208             // Not needed if I simplify during coalesce, ala George/Appel.</span>
<span class="line-added">209             assert(lrg.lo_degree(), &quot;&quot;);</span>
<span class="line-added">210           }</span>
211         }
212       }
213     }
214   }
215 
216   return reg_degree;
217 }
218 
219 //---------------------------- IndexSet() -----------------------------
220 // A deep copy constructor.  This is used when you need a scratch copy of this set.
221 
222 IndexSet::IndexSet (IndexSet *set) {
223 #ifdef ASSERT
224   _serial_number = _serial_count++;
225   set-&gt;check_watch(&quot;copied&quot;, _serial_number);
226   check_watch(&quot;initialized by copy&quot;, set-&gt;_serial_number);
227   _max_elements = set-&gt;_max_elements;
228 #endif
229   _count = set-&gt;_count;
<a name="6" id="anc6"></a><span class="line-added">230   _current_block_limit = set-&gt;_current_block_limit;</span>
231   _max_blocks = set-&gt;_max_blocks;
232   if (_max_blocks &lt;= preallocated_block_list_size) {
233     _blocks = _preallocated_block_list;
234   } else {
235     _blocks =
236       (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock**) * _max_blocks);
237   }
238   for (uint i = 0; i &lt; _max_blocks; i++) {
239     BitBlock *block = set-&gt;_blocks[i];
240     if (block == &amp;_empty_block) {
241       set_block(i, &amp;_empty_block);
242     } else {
243       BitBlock *new_block = alloc_block();
244       memcpy(new_block-&gt;words(), block-&gt;words(), sizeof(uint32_t) * words_per_block);
245       set_block(i, new_block);
246     }
247   }
248 }
249 
250 //---------------------------- IndexSet::initialize() -----------------------------
251 // Prepare an IndexSet for use.
252 
253 void IndexSet::initialize(uint max_elements) {
254 #ifdef ASSERT
255   _serial_number = _serial_count++;
256   check_watch(&quot;initialized&quot;, max_elements);
257   _max_elements = max_elements;
258 #endif
259   _count = 0;
<a name="7" id="anc7"></a><span class="line-added">260   _current_block_limit = 0;</span>
261   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
262 
263   if (_max_blocks &lt;= preallocated_block_list_size) {
264     _blocks = _preallocated_block_list;
265   } else {
266     _blocks = (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
267   }
268   for (uint i = 0; i &lt; _max_blocks; i++) {
269     set_block(i, &amp;_empty_block);
270   }
271 }
272 
273 //---------------------------- IndexSet::initialize()------------------------------
274 // Prepare an IndexSet for use.  If it needs to allocate its _blocks array, it does
275 // so from the Arena passed as a parameter.  BitBlock allocation is still done from
276 // the static Arena which was set with reset_memory().
277 
278 void IndexSet::initialize(uint max_elements, Arena *arena) {
279 #ifdef ASSERT
280   _serial_number = _serial_count++;
281   check_watch(&quot;initialized2&quot;, max_elements);
282   _max_elements = max_elements;
283 #endif // ASSERT
284   _count = 0;
<a name="8" id="anc8"></a><span class="line-added">285   _current_block_limit = 0;</span>
286   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
287 
288   if (_max_blocks &lt;= preallocated_block_list_size) {
289     _blocks = _preallocated_block_list;
290   } else {
291     _blocks = (IndexSet::BitBlock**) arena-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
292   }
293   for (uint i = 0; i &lt; _max_blocks; i++) {
294     set_block(i, &amp;_empty_block);
295   }
296 }
297 
298 //---------------------------- IndexSet::swap() -----------------------------
299 // Exchange two IndexSets.
300 
301 void IndexSet::swap(IndexSet *set) {
302 #ifdef ASSERT
303   assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
304   check_watch(&quot;swap&quot;, set-&gt;_serial_number);
305   set-&gt;check_watch(&quot;swap&quot;, _serial_number);
306 #endif
307 
<a name="9" id="anc9"></a><span class="line-modified">308   uint max = MAX2(_current_block_limit, set-&gt;_current_block_limit);</span>
<span class="line-added">309   for (uint i = 0; i &lt; max; i++) {</span>
310     BitBlock *temp = _blocks[i];
311     set_block(i, set-&gt;_blocks[i]);
312     set-&gt;set_block(i, temp);
313   }
314   uint temp = _count;
315   _count = set-&gt;_count;
316   set-&gt;_count = temp;
<a name="10" id="anc10"></a><span class="line-added">317 </span>
<span class="line-added">318   temp = _current_block_limit;</span>
<span class="line-added">319   _current_block_limit = set-&gt;_current_block_limit;</span>
<span class="line-added">320   set-&gt;_current_block_limit = temp;</span>
<span class="line-added">321 </span>
322 }
323 
324 //---------------------------- IndexSet::dump() -----------------------------
325 // Print this set.  Used for debugging.
326 
327 #ifndef PRODUCT
328 void IndexSet::dump() const {
329   IndexSetIterator elements(this);
330 
331   tty-&gt;print(&quot;{&quot;);
332   uint i;
333   while ((i = elements.next()) != 0) {
334     tty-&gt;print(&quot;L%d &quot;, i);
335   }
336   tty-&gt;print_cr(&quot;}&quot;);
337 }
338 #endif
339 
340 #ifdef ASSERT
341 //---------------------------- IndexSet::tally_iteration_statistics() -----------------------------
342 // Update block/bit counts to reflect that this set has been iterated over.
343 
344 void IndexSet::tally_iteration_statistics() const {
345   inc_stat_counter(&amp;_total_bits, count());
346 
347   for (uint i = 0; i &lt; _max_blocks; i++) {
348     if (_blocks[i] != &amp;_empty_block) {
349       inc_stat_counter(&amp;_total_used_blocks, 1);
350     } else {
351       inc_stat_counter(&amp;_total_unused_blocks, 1);
352     }
353   }
354 }
355 
356 //---------------------------- IndexSet::print_statistics() -----------------------------
357 // Print statistics about IndexSet usage.
358 
359 void IndexSet::print_statistics() {
360   julong total_blocks = _total_used_blocks + _total_unused_blocks;
361   tty-&gt;print_cr (&quot;Accumulated IndexSet usage statistics:&quot;);
362   tty-&gt;print_cr (&quot;--------------------------------------&quot;);
363   tty-&gt;print_cr (&quot;  Iteration:&quot;);
364   tty-&gt;print_cr (&quot;    blocks visited: &quot; UINT64_FORMAT, total_blocks);
365   tty-&gt;print_cr (&quot;    blocks empty: %4.2f%%&quot;, 100.0*(double)_total_unused_blocks/total_blocks);
366   tty-&gt;print_cr (&quot;    bit density (bits/used blocks): %4.2f&quot;, (double)_total_bits/_total_used_blocks);
367   tty-&gt;print_cr (&quot;    bit density (bits/all blocks): %4.2f&quot;, (double)_total_bits/total_blocks);
368   tty-&gt;print_cr (&quot;  Allocation:&quot;);
369   tty-&gt;print_cr (&quot;    blocks allocated: &quot; UINT64_FORMAT, _alloc_new);
370   tty-&gt;print_cr (&quot;    blocks used/reused: &quot; UINT64_FORMAT, _alloc_total);
371 }
372 
373 //---------------------------- IndexSet::verify() -----------------------------
374 // Expensive test of IndexSet sanity.  Ensure that the count agrees with the
375 // number of bits in the blocks.  Make sure the iterator is seeing all elements
376 // of the set.  Meant for use during development.
377 
378 void IndexSet::verify() const {
379   assert(!member(0), &quot;zero cannot be a member&quot;);
380   uint count = 0;
381   uint i;
382   for (i = 1; i &lt; _max_elements; i++) {
383     if (member(i)) {
384       count++;
385       assert(count &lt;= _count, &quot;_count is messed up&quot;);
386     }
387   }
388 
389   IndexSetIterator elements(this);
390   count = 0;
391   while ((i = elements.next()) != 0) {
392     count++;
393     assert(member(i), &quot;returned a non member&quot;);
394     assert(count &lt;= _count, &quot;iterator returned wrong number of elements&quot;);
395   }
396 }
397 #endif
398 
399 //---------------------------- IndexSetIterator() -----------------------------
400 // Create an iterator for a set.  If empty blocks are detected when iterating
401 // over the set, these blocks are replaced.
402 
<a name="11" id="anc11"></a>







































































403 //---------------------------- List16Iterator::advance_and_next() -----------------------------
404 // Advance to the next non-empty word in the set being iterated over.  Return the next element
405 // if there is one.  If we are done, return 0.  This method is called from the next() method
406 // when it gets done with a word.
407 
408 uint IndexSetIterator::advance_and_next() {
409   // See if there is another non-empty word in the current block.
410   for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
411     if (_words[wi] != 0) {
412       // Found a non-empty word.
413       _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
414       _current = _words[wi];
<a name="12" id="anc12"></a><span class="line-modified">415       _next_word = wi + 1;</span>
<span class="line-modified">416       return next_value();</span>


417     }
418   }
419 
420   // We ran out of words in the current block.  Advance to next non-empty block.
421   for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
422     if (_blocks[bi] != &amp;IndexSet::_empty_block) {
423       // Found a non-empty block.
424 
425       _words = _blocks[bi]-&gt;words();
426       for (uint wi = 0; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
427         if (_words[wi] != 0) {
428           // Found a non-empty word.
429           _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
430           _current = _words[wi];
431 
432           _next_block = bi+1;
433           _next_word = wi+1;
<a name="13" id="anc13"></a><span class="line-modified">434           return next_value();</span>

435         }
436       }
437 
438       // All of the words in the block were empty.  Replace
439       // the block with the empty block.
440       if (_set) {
441         _set-&gt;free_block(bi);
442       }
443     }
444   }
445 
<a name="14" id="anc14"></a>




446   // No more words.
447   return 0;
448 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
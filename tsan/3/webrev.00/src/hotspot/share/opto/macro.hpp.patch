diff a/src/hotspot/share/opto/macro.hpp b/src/hotspot/share/opto/macro.hpp
--- a/src/hotspot/share/opto/macro.hpp
+++ b/src/hotspot/share/opto/macro.hpp
@@ -28,10 +28,11 @@
 #include "opto/phase.hpp"
 
 class  AllocateNode;
 class  AllocateArrayNode;
 class  CallNode;
+class  SubTypeCheckNode;
 class  Node;
 class  PhaseIterGVN;
 
 class PhaseMacroExpand : public Phase {
 private:
@@ -61,10 +62,26 @@
   Node* make_load( Node* ctl, Node* mem, Node* base, int offset,
                    const Type* value_type, BasicType bt);
   Node* make_store(Node* ctl, Node* mem, Node* base, int offset,
                    Node* value, BasicType bt);
 
+  Node* make_leaf_call(Node* ctrl, Node* mem,
+                       const TypeFunc* call_type, address call_addr,
+                       const char* call_name,
+                       const TypePtr* adr_type,
+                       Node* parm0 = NULL, Node* parm1 = NULL,
+                       Node* parm2 = NULL, Node* parm3 = NULL,
+                       Node* parm4 = NULL, Node* parm5 = NULL,
+                       Node* parm6 = NULL, Node* parm7 = NULL);
+
+  address basictype2arraycopy(BasicType t,
+                              Node* src_offset,
+                              Node* dest_offset,
+                              bool disjoint_bases,
+                              const char* &name,
+                              bool dest_uninitialized);
+
 private:
   // projections extracted from a call node
   ProjNode *_fallthroughproj;
   ProjNode *_fallthroughcatchproj;
   ProjNode *_ioproj_fallthrough;
@@ -81,10 +98,12 @@
   void expand_allocate_array(AllocateArrayNode *alloc);
   void expand_allocate_common(AllocateNode* alloc,
                               Node* length,
                               const TypeFunc* slow_call_type,
                               address slow_call_address);
+  void yank_initalize_node(InitializeNode* node);
+  void yank_alloc_node(AllocateNode* alloc);
   Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);
   Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);
 
   bool eliminate_boxing_node(CallStaticJavaNode *boxing);
   bool eliminate_allocate_node(AllocateNode *alloc);
@@ -101,34 +120,20 @@
 
   // More helper methods modeled after GraphKit for array copy
   void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);
   Node* array_element_address(Node* ary, Node* idx, BasicType elembt);
   Node* ConvI2L(Node* offset);
-  Node* make_leaf_call(Node* ctrl, Node* mem,
-                       const TypeFunc* call_type, address call_addr,
-                       const char* call_name,
-                       const TypePtr* adr_type,
-                       Node* parm0 = NULL, Node* parm1 = NULL,
-                       Node* parm2 = NULL, Node* parm3 = NULL,
-                       Node* parm4 = NULL, Node* parm5 = NULL,
-                       Node* parm6 = NULL, Node* parm7 = NULL);
 
   // helper methods modeled after LibraryCallKit for array copy
   Node* generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob);
   Node* generate_slow_guard(Node** ctrl, Node* test, RegionNode* region);
   void generate_negative_guard(Node** ctrl, Node* index, RegionNode* region);
   void generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region);
 
   // More helper methods for array copy
   Node* generate_nonpositive_guard(Node** ctrl, Node* index, bool never_negative);
   void finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type);
-  address basictype2arraycopy(BasicType t,
-                              Node* src_offset,
-                              Node* dest_offset,
-                              bool disjoint_bases,
-                              const char* &name,
-                              bool dest_uninitialized);
   Node* generate_arraycopy(ArrayCopyNode *ac,
                            AllocateArrayNode* alloc,
                            Node** ctrl, MergeMemNode* mem, Node** io,
                            const TypePtr* adr_type,
                            BasicType basic_elem_type,
@@ -177,11 +182,14 @@
                                     Node* dest, Node* dest_offset,
                                     Node* copy_length, bool dest_uninitialized);
 
   void expand_arraycopy_node(ArrayCopyNode *ac);
 
+  void expand_subtypecheck_node(SubTypeCheckNode *check);
+
   int replace_input(Node *use, Node *oldref, Node *newref);
+  void migrate_outs(Node *old, Node *target);
   void copy_call_debug_info(CallNode *oldcall, CallNode * newcall);
   Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);
   void copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call);
   CallNode* make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type, address slow_call,
                            const char* leaf_name, Node* slow_path, Node* parm0, Node* parm1,
@@ -213,8 +221,10 @@
 
   Node* prefetch_allocation(Node* i_o,
                             Node*& needgc_false, Node*& contended_phi_rawmem,
                             Node* old_eden_top, Node* new_eden_top,
                             intx lines);
+  void expand_dtrace_alloc_probe(AllocateNode* alloc, Node* fast_oop, Node*&fast_oop_ctrl, Node*&fast_oop_rawmem);
+  void expand_initialize_membar(AllocateNode* alloc, InitializeNode* init, Node*&fast_oop_ctrl, Node*&fast_oop_rawmem);
 };
 
 #endif // SHARE_OPTO_MACRO_HPP

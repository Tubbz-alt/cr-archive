<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;runtime/sharedRuntime.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 35   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 36     _kind(None),
 37     _alloc_tightly_coupled(alloc_tightly_coupled),
 38     _has_negative_length_guard(has_negative_length_guard),
 39     _arguments_validated(false),
 40     _src_type(TypeOopPtr::BOTTOM),
 41     _dest_type(TypeOopPtr::BOTTOM) {
 42   init_class_id(Class_ArrayCopy);
 43   init_flags(Flag_is_macro);
 44   C-&gt;add_macro_node(this);
 45 }
 46 
 47 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 48 
 49 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 50                                    Node* src, Node* src_offset,
 51                                    Node* dest, Node* dest_offset,
 52                                    Node* length,
 53                                    bool alloc_tightly_coupled,
 54                                    bool has_negative_length_guard,
 55                                    Node* src_klass, Node* dest_klass,
 56                                    Node* src_length, Node* dest_length) {
 57 
 58   ArrayCopyNode* ac = new ArrayCopyNode(kit-&gt;C, alloc_tightly_coupled, has_negative_length_guard);
 59   Node* prev_mem = kit-&gt;set_predefined_input_for_runtime_call(ac);
 60 
 61   ac-&gt;init_req(ArrayCopyNode::Src, src);
 62   ac-&gt;init_req(ArrayCopyNode::SrcPos, src_offset);
 63   ac-&gt;init_req(ArrayCopyNode::Dest, dest);
 64   ac-&gt;init_req(ArrayCopyNode::DestPos, dest_offset);
 65   ac-&gt;init_req(ArrayCopyNode::Length, length);
 66   ac-&gt;init_req(ArrayCopyNode::SrcLen, src_length);
 67   ac-&gt;init_req(ArrayCopyNode::DestLen, dest_length);
 68   ac-&gt;init_req(ArrayCopyNode::SrcKlass, src_klass);
 69   ac-&gt;init_req(ArrayCopyNode::DestKlass, dest_klass);
 70 
 71   if (may_throw) {
 72     ac-&gt;set_req(TypeFunc::I_O , kit-&gt;i_o());
 73     kit-&gt;add_safepoint_edges(ac, false);
 74   }
 75 
 76   return ac;
 77 }
 78 
 79 void ArrayCopyNode::connect_outputs(GraphKit* kit) {
 80   kit-&gt;set_all_memory_call(this, true);
 81   kit-&gt;set_control(kit-&gt;gvn().transform(new ProjNode(this,TypeFunc::Control)));
 82   kit-&gt;set_i_o(kit-&gt;gvn().transform(new ProjNode(this, TypeFunc::I_O)));
 83   kit-&gt;make_slow_call_ex(this, kit-&gt;env()-&gt;Throwable_klass(), true);
 84   kit-&gt;set_all_memory_call(this);
 85 }
 86 
 87 #ifndef PRODUCT
 88 const char* ArrayCopyNode::_kind_names[] = {&quot;arraycopy&quot;, &quot;arraycopy, validated arguments&quot;, &quot;clone&quot;, &quot;oop array clone&quot;, &quot;CopyOf&quot;, &quot;CopyOfRange&quot;};
 89 
 90 void ArrayCopyNode::dump_spec(outputStream *st) const {
 91   CallNode::dump_spec(st);
 92   st-&gt;print(&quot; (%s%s)&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;, tightly coupled allocation&quot; : &quot;&quot;);
 93 }
 94 
 95 void ArrayCopyNode::dump_compact_spec(outputStream* st) const {
 96   st-&gt;print(&quot;%s%s&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;,tight&quot; : &quot;&quot;);
 97 }
 98 #endif
 99 
100 intptr_t ArrayCopyNode::get_length_if_constant(PhaseGVN *phase) const {
101   // check that length is constant
102   Node* length = in(ArrayCopyNode::Length);
103   const Type* length_type = phase-&gt;type(length);
104 
105   if (length_type == Type::TOP) {
106     return -1;
107   }
108 
109   assert(is_clonebasic() || is_arraycopy() || is_copyof() || is_copyofrange(), &quot;unexpected array copy type&quot;);
110 
111   return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
112 }
113 
114 int ArrayCopyNode::get_count(PhaseGVN *phase) const {
115   Node* src = in(ArrayCopyNode::Src);
116   const Type* src_type = phase-&gt;type(src);
117 
118   if (is_clonebasic()) {
119     if (src_type-&gt;isa_instptr()) {
120       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
121       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
122       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
123       // fields into account. They are rare anyway so easier to simply
124       // skip instances with injected fields.
125       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
126         return -1;
127       }
128       int nb_fields = ik-&gt;nof_nonstatic_fields();
129       return nb_fields;
130     } else {
131       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
132       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
133       // clone passes a length as a rounded number of longs. If we&#39;re
134       // cloning an array we&#39;ll do it element by element. If the
135       // length input to ArrayCopyNode is constant, length of input
136       // array must be too.
137 
138       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
139              phase-&gt;is_IterGVN(), &quot;inconsistent&quot;);
140 
141       if (ary_src-&gt;size()-&gt;is_con()) {
142         return ary_src-&gt;size()-&gt;get_con();
143       }
144       return -1;
145     }
146   }
147 
148   return get_length_if_constant(phase);
149 }
150 
151 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
152   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
153   C2AccessValuePtr addr(adr, adr_type);
154   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
155   Node* res = bs-&gt;load_at(access, type);
156   ctl = access.ctl();
157   return res;
158 }
159 
160 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
161   DecoratorSet decorators = C2_WRITE_ACCESS | IN_HEAP | C2_ARRAY_COPY;
162   if (is_alloc_tightly_coupled()) {
163     decorators |= C2_TIGHTLY_COUPLED_ALLOC;
164   }
165   C2AccessValuePtr addr(adr, adr_type);
166   C2AccessValue value(val, type);
167   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
168   bs-&gt;store_at(access, value);
169   ctl = access.ctl();
170 }
171 
172 
173 Node* ArrayCopyNode::try_clone_instance(PhaseGVN *phase, bool can_reshape, int count) {
174   if (!is_clonebasic()) {
175     return NULL;
176   }
177 
178   Node* src = in(ArrayCopyNode::Src);
179   Node* dest = in(ArrayCopyNode::Dest);
180   Node* ctl = in(TypeFunc::Control);
181   Node* in_mem = in(TypeFunc::Memory);
182 
183   const Type* src_type = phase-&gt;type(src);
184 
185   assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
186   assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
187   Node* base_src = src-&gt;in(AddPNode::Base);
188   Node* base_dest = dest-&gt;in(AddPNode::Base);
189 
190   MergeMemNode* mem = MergeMemNode::make(in_mem);
191 
192   const TypeInstPtr* inst_src = src_type-&gt;isa_instptr();
193 
194   if (inst_src == NULL) {
195     return NULL;
196   }
197 
198   if (!inst_src-&gt;klass_is_exact()) {
199     ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
200     assert(!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass(), &quot;inconsistent klass hierarchy&quot;);
201     phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
202   }
203 
204   ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
205   assert(ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem, &quot;too many fields&quot;);
206 
207   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
208   for (int i = 0; i &lt; count; i++) {
209     ciField* field = ik-&gt;nonstatic_field_at(i);
210     int fieldidx = phase-&gt;C-&gt;alias_type(field)-&gt;index();
211     const TypePtr* adr_type = phase-&gt;C-&gt;alias_type(field)-&gt;adr_type();
212     Node* off = phase-&gt;MakeConX(field-&gt;offset());
213     Node* next_src = phase-&gt;transform(new AddPNode(base_src,base_src,off));
214     Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,base_dest,off));
215     BasicType bt = field-&gt;layout_type();
216 
217     const Type *type;
218     if (bt == T_OBJECT) {
219       if (!field-&gt;type()-&gt;is_loaded()) {
220         type = TypeInstPtr::BOTTOM;
221       } else {
222         ciType* field_klass = field-&gt;type();
223         type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
224       }
225     } else {
226       type = Type::get_const_basic_type(bt);
227     }
228 
229     Node* v = load(bs, phase, ctl, mem, next_src, adr_type, type, bt);
230     store(bs, phase, ctl, mem, next_dest, adr_type, v, type, bt);
231   }
232 
233   if (!finish_transform(phase, can_reshape, ctl, mem)) {
234     // Return NodeSentinel to indicate that the transform failed
235     return NodeSentinel;
236   }
237 
238   return mem;
239 }
240 
241 bool ArrayCopyNode::prepare_array_copy(PhaseGVN *phase, bool can_reshape,
242                                        Node*&amp; adr_src,
243                                        Node*&amp; base_src,
244                                        Node*&amp; adr_dest,
245                                        Node*&amp; base_dest,
246                                        BasicType&amp; copy_type,
247                                        const Type*&amp; value_type,
248                                        bool&amp; disjoint_bases) {
249   Node* src = in(ArrayCopyNode::Src);
250   Node* dest = in(ArrayCopyNode::Dest);
251   const Type* src_type = phase-&gt;type(src);
252   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
253 
254   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
255     const Type* dest_type = phase-&gt;type(dest);
256     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
257     Node* src_offset = in(ArrayCopyNode::SrcPos);
258     Node* dest_offset = in(ArrayCopyNode::DestPos);
259 
260     // newly allocated object is guaranteed to not overlap with source object
261     disjoint_bases = is_alloc_tightly_coupled();
262 
263     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
264         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
265       // We don&#39;t know if arguments are arrays
266       return false;
267     }
268 
269     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
270     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
271     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;
272     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;
273 
274     if (src_elem != dest_elem || dest_elem == T_VOID) {
275       // We don&#39;t know if arguments are arrays of the same type
276       return false;
277     }
278 
279     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
280     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization)) {
281       // It&#39;s an object array copy but we can&#39;t emit the card marking
282       // that is needed
283       return false;
284     }
285 
286     value_type = ary_src-&gt;elem();
287 
288     base_src = src;
289     base_dest = dest;
290 
291     uint shift  = exact_log2(type2aelembytes(dest_elem));
292     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
293 
294     adr_src = src;
295     adr_dest = dest;
296 
297     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
298     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
299 
300     Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
301     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
302 
303     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));
304     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, dest_scale));
305 
306     adr_src = new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header));
307     adr_dest = new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header));
308 
309     adr_src = phase-&gt;transform(adr_src);
310     adr_dest = phase-&gt;transform(adr_dest);
311 
312     copy_type = dest_elem;
313   } else {
314     assert(ary_src != NULL, &quot;should be a clone&quot;);
315     assert(is_clonebasic(), &quot;should be&quot;);
316 
317     disjoint_bases = true;
318     assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
319     assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
320     adr_src = src;
321     base_src = src-&gt;in(AddPNode::Base);
322     adr_dest = dest;
323     base_dest = dest-&gt;in(AddPNode::Base);
324 
325     assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
326     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
327     if (elem == T_ARRAY)  elem = T_OBJECT;
328 
329     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
330     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
331       return false;
332     }
333 
334     int diff = arrayOopDesc::base_offset_in_bytes(elem) - phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con();
335     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
336     if (diff &gt; 0) {
337       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
338       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
339     }
340 
341     copy_type = elem;
342     value_type = ary_src-&gt;elem();
343   }
344   return true;
345 }
346 
347 const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN *phase, Node* n) {
348   const Type* at = phase-&gt;type(n);
349   assert(at != Type::TOP, &quot;unexpected type&quot;);
350   const TypePtr* atp = at-&gt;isa_ptr();
351   // adjust atp to be the correct array element address type
352   atp = atp-&gt;add_offset(Type::OffsetBot);
353   return atp;
354 }
355 
356 void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {
357   Node* ctl = in(TypeFunc::Control);
358   if (!disjoint_bases &amp;&amp; count &gt; 1) {
359     Node* src_offset = in(ArrayCopyNode::SrcPos);
360     Node* dest_offset = in(ArrayCopyNode::DestPos);
361     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
362     Node* cmp = phase-&gt;transform(new CmpINode(src_offset, dest_offset));
363     Node *bol = phase-&gt;transform(new BoolNode(cmp, BoolTest::lt));
364     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
365 
366     phase-&gt;transform(iff);
367 
368     forward_ctl = phase-&gt;transform(new IfFalseNode(iff));
369     backward_ctl = phase-&gt;transform(new IfTrueNode(iff));
370   } else {
371     forward_ctl = ctl;
372   }
373 }
374 
375 Node* ArrayCopyNode::array_copy_forward(PhaseGVN *phase,
376                                         bool can_reshape,
377                                         Node*&amp; forward_ctl,
378                                         MergeMemNode* mm,
379                                         const TypePtr* atp_src,
380                                         const TypePtr* atp_dest,
381                                         Node* adr_src,
382                                         Node* base_src,
383                                         Node* adr_dest,
384                                         Node* base_dest,
385                                         BasicType copy_type,
386                                         const Type* value_type,
387                                         int count) {
388   if (!forward_ctl-&gt;is_top()) {
389     // copy forward
390     mm = mm-&gt;clone()-&gt;as_MergeMem();
391 
392     if (count &gt; 0) {
393       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
394       Node* v = load(bs, phase, forward_ctl, mm, adr_src, atp_src, value_type, copy_type);
395       store(bs, phase, forward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);
396       for (int i = 1; i &lt; count; i++) {
397         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);
398         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));
399         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));
400         v = load(bs, phase, forward_ctl, mm, next_src, atp_src, value_type, copy_type);
401         store(bs, phase, forward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);
402       }
403     } else if(can_reshape) {
404       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
405       igvn-&gt;_worklist.push(adr_src);
406       igvn-&gt;_worklist.push(adr_dest);
407     }
408     return mm;
409   }
410   return phase-&gt;C-&gt;top();
411 }
412 
413 Node* ArrayCopyNode::array_copy_backward(PhaseGVN *phase,
414                                          bool can_reshape,
415                                          Node*&amp; backward_ctl,
416                                          MergeMemNode* mm,
417                                          const TypePtr* atp_src,
418                                          const TypePtr* atp_dest,
419                                          Node* adr_src,
420                                          Node* base_src,
421                                          Node* adr_dest,
422                                          Node* base_dest,
423                                          BasicType copy_type,
424                                          const Type* value_type,
425                                          int count) {
426   if (!backward_ctl-&gt;is_top()) {
427     // copy backward
428     mm = mm-&gt;clone()-&gt;as_MergeMem();
429 
430     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
431     assert(copy_type != T_OBJECT || !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Optimization), &quot;only tightly coupled allocations for object arrays&quot;);
432 
433     if (count &gt; 0) {
434       for (int i = count-1; i &gt;= 1; i--) {
435         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);
436         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));
437         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));
438         Node* v = load(bs, phase, backward_ctl, mm, next_src, atp_src, value_type, copy_type);
439         store(bs, phase, backward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);
440       }
441       Node* v = load(bs, phase, backward_ctl, mm, adr_src, atp_src, value_type, copy_type);
442       store(bs, phase, backward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);
443     } else if(can_reshape) {
444       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
445       igvn-&gt;_worklist.push(adr_src);
446       igvn-&gt;_worklist.push(adr_dest);
447     }
448     return phase-&gt;transform(mm);
449   }
450   return phase-&gt;C-&gt;top();
451 }
452 
453 bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
454                                      Node* ctl, Node *mem) {
455   if (can_reshape) {
456     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
457     igvn-&gt;set_delay_transform(false);
458     if (is_clonebasic()) {
459       Node* out_mem = proj_out(TypeFunc::Memory);
460 
461       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
462       if (out_mem-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;is_MergeMem() ||
463           out_mem-&gt;raw_out(0)-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;raw_out(0)-&gt;is_MemBar()) {
464         assert(bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization), &quot;can only happen with card marking&quot;);
465         return false;
466       }
467 
468       igvn-&gt;replace_node(out_mem-&gt;raw_out(0), mem);
469 
470       Node* out_ctl = proj_out(TypeFunc::Control);
471       igvn-&gt;replace_node(out_ctl, ctl);
472     } else {
473       // replace fallthrough projections of the ArrayCopyNode by the
474       // new memory, control and the input IO.
475       CallProjections callprojs;
476       extract_projections(&amp;callprojs, true, false);
477 
478       if (callprojs.fallthrough_ioproj != NULL) {
479         igvn-&gt;replace_node(callprojs.fallthrough_ioproj, in(TypeFunc::I_O));
480       }
481       if (callprojs.fallthrough_memproj != NULL) {
482         igvn-&gt;replace_node(callprojs.fallthrough_memproj, mem);
483       }
484       if (callprojs.fallthrough_catchproj != NULL) {
485         igvn-&gt;replace_node(callprojs.fallthrough_catchproj, ctl);
486       }
487 
488       // The ArrayCopyNode is not disconnected. It still has the
489       // projections for the exception case. Replace current
490       // ArrayCopyNode with a dummy new one with a top() control so
491       // that this part of the graph stays consistent but is
492       // eventually removed.
493 
494       set_req(0, phase-&gt;C-&gt;top());
495       remove_dead_region(phase, can_reshape);
496     }
497   } else {
498     if (in(TypeFunc::Control) != ctl) {
499       // we can&#39;t return new memory and control from Ideal at parse time
500       assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
501       phase-&gt;record_for_igvn(this);
502       return false;
503     }
504   }
505   return true;
506 }
507 
508 
509 Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
510   if (remove_dead_region(phase, can_reshape))  return this;
511 
512   if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
513     phase-&gt;record_for_igvn(this);
514     return NULL;
515   }
516 
517   // See if it&#39;s a small array copy and we can inline it as
518   // loads/stores
519   // Here we can only do:
520   // - arraycopy if all arguments were validated before and we don&#39;t
521   // need card marking
522   // - clone for which we don&#39;t need to do card marking
523 
524   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
525       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
526     return NULL;
527   }
528 
529   assert(in(TypeFunc::Control) != NULL &amp;&amp;
530          in(TypeFunc::Memory) != NULL &amp;&amp;
531          in(ArrayCopyNode::Src) != NULL &amp;&amp;
532          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
533          in(ArrayCopyNode::Length) != NULL &amp;&amp;
534          ((in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos) != NULL) ||
535           is_clonebasic()), &quot;broken inputs&quot;);
536 
537   if (in(TypeFunc::Control)-&gt;is_top() ||
538       in(TypeFunc::Memory)-&gt;is_top() ||
539       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
540       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
541       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
542       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
543     return NULL;
544   }
545 
546   int count = get_count(phase);
547 
548   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
549     return NULL;
550   }
551 
552   Node* mem = try_clone_instance(phase, can_reshape, count);
553   if (mem != NULL) {
554     return (mem == NodeSentinel) ? NULL : mem;
555   }
556 
557   Node* adr_src = NULL;
558   Node* base_src = NULL;
559   Node* adr_dest = NULL;
560   Node* base_dest = NULL;
561   BasicType copy_type = T_ILLEGAL;
562   const Type* value_type = NULL;
563   bool disjoint_bases = false;
564 
565   if (!prepare_array_copy(phase, can_reshape,
566                           adr_src, base_src, adr_dest, base_dest,
567                           copy_type, value_type, disjoint_bases)) {
568     return NULL;
569   }
570 
571   Node* src = in(ArrayCopyNode::Src);
572   Node* dest = in(ArrayCopyNode::Dest);
573   const TypePtr* atp_src = get_address_type(phase, src);
574   const TypePtr* atp_dest = get_address_type(phase, dest);
575 
576   Node *in_mem = in(TypeFunc::Memory);
577   if (!in_mem-&gt;is_MergeMem()) {
578     in_mem = MergeMemNode::make(in_mem);
579   }
580 
581 
582   if (can_reshape) {
583     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
584     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
585   }
586 
587   Node* backward_ctl = phase-&gt;C-&gt;top();
588   Node* forward_ctl = phase-&gt;C-&gt;top();
589   array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);
590 
591   Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,
592                                          in_mem-&gt;as_MergeMem(),
593                                          atp_src, atp_dest,
594                                          adr_src, base_src, adr_dest, base_dest,
595                                          copy_type, value_type, count);
596 
597   Node* backward_mem = array_copy_backward(phase, can_reshape, backward_ctl,
598                                            in_mem-&gt;as_MergeMem(),
599                                            atp_src, atp_dest,
600                                            adr_src, base_src, adr_dest, base_dest,
601                                            copy_type, value_type, count);
602 
603   Node* ctl = NULL;
604   if (!forward_ctl-&gt;is_top() &amp;&amp; !backward_ctl-&gt;is_top()) {
605     ctl = new RegionNode(3);
606     ctl-&gt;init_req(1, forward_ctl);
607     ctl-&gt;init_req(2, backward_ctl);
608     ctl = phase-&gt;transform(ctl);
609     MergeMemNode* forward_mm = forward_mem-&gt;as_MergeMem();
610     MergeMemNode* backward_mm = backward_mem-&gt;as_MergeMem();
611     for (MergeMemStream mms(forward_mm, backward_mm); mms.next_non_empty2(); ) {
612       if (mms.memory() != mms.memory2()) {
613         Node* phi = new PhiNode(ctl, Type::MEMORY, phase-&gt;C-&gt;get_adr_type(mms.alias_idx()));
614         phi-&gt;init_req(1, mms.memory());
615         phi-&gt;init_req(2, mms.memory2());
616         phi = phase-&gt;transform(phi);
617         mms.set_memory(phi);
618       }
619     }
620     mem = forward_mem;
621   } else if (!forward_ctl-&gt;is_top()) {
622     ctl = forward_ctl;
623     mem = forward_mem;
624   } else {
625     assert(!backward_ctl-&gt;is_top(), &quot;no copy?&quot;);
626     ctl = backward_ctl;
627     mem = backward_mem;
628   }
629 
630   if (can_reshape) {
631     assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
632     phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
633   }
634 
635   if (!finish_transform(phase, can_reshape, ctl, mem)) {
636     return NULL;
637   }
638 
639   return mem;
640 }
641 
642 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
643   Node* dest = in(ArrayCopyNode::Dest);
644   if (dest-&gt;is_top()) {
645     return false;
646   }
647   const TypeOopPtr* dest_t = phase-&gt;type(dest)-&gt;is_oopptr();
648   assert(!dest_t-&gt;is_known_instance() || _dest_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
649   assert(in(ArrayCopyNode::Src)-&gt;is_top() || !phase-&gt;type(in(ArrayCopyNode::Src))-&gt;is_oopptr()-&gt;is_known_instance() ||
650          _src_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
651 
652   if (_dest_type != TypeOopPtr::BOTTOM || t_oop-&gt;is_known_instance()) {
653     assert(_dest_type == TypeOopPtr::BOTTOM || _dest_type-&gt;is_known_instance(), &quot;result of EA is known instance&quot;);
654     return t_oop-&gt;instance_id() == _dest_type-&gt;instance_id();
655   }
656 
657   return CallNode::may_modify_arraycopy_helper(dest_t, t_oop, phase);
658 }
659 
660 bool ArrayCopyNode::may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*&amp; call) {
661   if (n != NULL &amp;&amp;
662       n-&gt;is_Call() &amp;&amp;
663       n-&gt;as_Call()-&gt;may_modify(t_oop, phase) &amp;&amp;
664       (n-&gt;as_Call()-&gt;is_ArrayCopy() || n-&gt;as_Call()-&gt;is_call_to_arraycopystub())) {
665     call = n-&gt;as_Call();
666     return true;
667   }
668   return false;
669 }
670 
671 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*&amp; ac) {
672 
673   Node* c = mb-&gt;in(0);
674 
675   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
676   // step over g1 gc barrier if we&#39;re at e.g. a clone with ReduceInitialCardMarks off
677   c = bs-&gt;step_over_gc_barrier(c);
678 
679   CallNode* call = NULL;
680   guarantee(c != NULL, &quot;step_over_gc_barrier failed, there must be something to step to.&quot;);
681   if (c-&gt;is_Region()) {
682     for (uint i = 1; i &lt; c-&gt;req(); i++) {
683       if (c-&gt;in(i) != NULL) {
684         Node* n = c-&gt;in(i)-&gt;in(0);
685         if (may_modify_helper(t_oop, n, phase, call)) {
686           ac = call-&gt;isa_ArrayCopy();
687           assert(c == mb-&gt;in(0), &quot;only for clone&quot;);
688           return true;
689         }
690       }
691     }
692   } else if (may_modify_helper(t_oop, c-&gt;in(0), phase, call)) {
693     ac = call-&gt;isa_ArrayCopy();
694 #ifdef ASSERT
695     bool use_ReduceInitialCardMarks = BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
696       static_cast&lt;CardTableBarrierSetC2*&gt;(bs)-&gt;use_ReduceInitialCardMarks();
697     assert(c == mb-&gt;in(0) || (ac != NULL &amp;&amp; ac-&gt;is_clonebasic() &amp;&amp; !use_ReduceInitialCardMarks), &quot;only for clone&quot;);
698 #endif
699     return true;
700   }
701 
702   return false;
703 }
704 
705 // Does this array copy modify offsets between offset_lo and offset_hi
706 // in the destination array
707 // if must_modify is false, return true if the copy could write
708 // between offset_lo and offset_hi
709 // if must_modify is true, return true if the copy is guaranteed to
710 // write between offset_lo and offset_hi
711 bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {
712   assert(_kind == ArrayCopy || _kind == CopyOf || _kind == CopyOfRange, &quot;only for real array copies&quot;);
713 
714   Node* dest = in(Dest);
715   Node* dest_pos = in(DestPos);
716   Node* len = in(Length);
717 
718   const TypeInt *dest_pos_t = phase-&gt;type(dest_pos)-&gt;isa_int();
719   const TypeInt *len_t = phase-&gt;type(len)-&gt;isa_int();
720   const TypeAryPtr* ary_t = phase-&gt;type(dest)-&gt;isa_aryptr();
721 
722   if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
723     return !must_modify;
724   }
725 
726   BasicType ary_elem = ary_t-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
727   uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
728   uint elemsize = type2aelembytes(ary_elem);
729 
730   jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
731   jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
732   jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
733   jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
734 
735   if (must_modify) {
736     if (offset_lo &gt;= dest_pos_hi &amp;&amp; offset_hi &lt; dest_pos_plus_len_lo) {
737       return true;
738     }
739   } else {
740     if (offset_hi &gt;= dest_pos_lo &amp;&amp; offset_lo &lt; dest_pos_plus_len_hi) {
741       return true;
742     }
743   }
744   return false;
745 }
    </pre>
  </body>
</html>
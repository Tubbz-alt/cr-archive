diff a/src/hotspot/share/opto/indexSet.cpp b/src/hotspot/share/opto/indexSet.cpp
--- a/src/hotspot/share/opto/indexSet.cpp
+++ b/src/hotspot/share/opto/indexSet.cpp
@@ -109,10 +109,13 @@
 // corresponding to element.
 
 IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
   BitBlock *block = alloc_block();
   uint bi = get_block_index(element);
+  if (bi >= _current_block_limit) {
+    _current_block_limit = bi + 1;
+  }
   _blocks[bi] = block;
   return block;
 }
 
 //---------------------------- IndexSet::free_block() -------------------------
@@ -123,11 +126,11 @@
   assert(i < _max_blocks, "block index too large");
   BitBlock *block = _blocks[i];
   assert(block != &_empty_block, "cannot free the empty block");
   block->set_next((IndexSet::BitBlock*)Compile::current()->indexSet_free_block_list());
   Compile::current()->set_indexSet_free_block_list(block);
-  set_block(i,&_empty_block);
+  set_block(i, &_empty_block);
 }
 
 //------------------------------lrg_union--------------------------------------
 // Compute the union of all elements of one and two which interfere with
 // the RegMask mask.  If the degree of the union becomes exceeds
@@ -166,42 +169,47 @@
   // Used to compute degree of register-only interferences.  Infinite-stack
   // neighbors do not alter colorability, as they can always color to some
   // other color.  (A variant of the Briggs assertion)
   uint reg_degree = 0;
 
-  uint element;
+  uint element = 0;
   // Load up the combined interference set with the neighbors of one
-  IndexSetIterator elements(one);
-  while ((element = elements.next()) != 0) {
-    LRG &lrg = ifg->lrgs(element);
-    if (mask.overlap(lrg.mask())) {
-      insert(element);
-      if( !lrg.mask().is_AllStack() ) {
-        reg_degree += lrg1.compute_degree(lrg);
-        if( reg_degree >= fail_degree ) return reg_degree;
-      } else {
-        // !!!!! Danger!  No update to reg_degree despite having a neighbor.
-        // A variant of the Briggs assertion.
-        // Not needed if I simplify during coalesce, ala George/Appel.
-        assert( lrg.lo_degree(), "" );
-      }
-    }
-  }
-  // Add neighbors of two as well
-  IndexSetIterator elements2(two);
-  while ((element = elements2.next()) != 0) {
-    LRG &lrg = ifg->lrgs(element);
-    if (mask.overlap(lrg.mask())) {
-      if (insert(element)) {
-        if( !lrg.mask().is_AllStack() ) {
-          reg_degree += lrg2.compute_degree(lrg);
-          if( reg_degree >= fail_degree ) return reg_degree;
+  if (!one->is_empty()) {
+    IndexSetIterator elements(one);
+    while ((element = elements.next()) != 0) {
+      LRG &lrg = ifg->lrgs(element);
+      if (mask.overlap(lrg.mask())) {
+        insert(element);
+        if (!lrg.mask().is_AllStack()) {
+          reg_degree += lrg1.compute_degree(lrg);
+          if (reg_degree >= fail_degree) return reg_degree;
         } else {
           // !!!!! Danger!  No update to reg_degree despite having a neighbor.
           // A variant of the Briggs assertion.
           // Not needed if I simplify during coalesce, ala George/Appel.
-          assert( lrg.lo_degree(), "" );
+          assert(lrg.lo_degree(), "");
+        }
+      }
+    }
+  }
+  // Add neighbors of two as well
+
+  if (!two->is_empty()) {
+    IndexSetIterator elements2(two);
+    while ((element = elements2.next()) != 0) {
+      LRG &lrg = ifg->lrgs(element);
+      if (mask.overlap(lrg.mask())) {
+        if (insert(element)) {
+          if (!lrg.mask().is_AllStack()) {
+            reg_degree += lrg2.compute_degree(lrg);
+            if (reg_degree >= fail_degree) return reg_degree;
+          } else {
+            // !!!!! Danger!  No update to reg_degree despite having a neighbor.
+            // A variant of the Briggs assertion.
+            // Not needed if I simplify during coalesce, ala George/Appel.
+            assert(lrg.lo_degree(), "");
+          }
         }
       }
     }
   }
 
@@ -217,10 +225,11 @@
   set->check_watch("copied", _serial_number);
   check_watch("initialized by copy", set->_serial_number);
   _max_elements = set->_max_elements;
 #endif
   _count = set->_count;
+  _current_block_limit = set->_current_block_limit;
   _max_blocks = set->_max_blocks;
   if (_max_blocks <= preallocated_block_list_size) {
     _blocks = _preallocated_block_list;
   } else {
     _blocks =
@@ -246,10 +255,11 @@
   _serial_number = _serial_count++;
   check_watch("initialized", max_elements);
   _max_elements = max_elements;
 #endif
   _count = 0;
+  _current_block_limit = 0;
   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
 
   if (_max_blocks <= preallocated_block_list_size) {
     _blocks = _preallocated_block_list;
   } else {
@@ -270,10 +280,11 @@
   _serial_number = _serial_count++;
   check_watch("initialized2", max_elements);
   _max_elements = max_elements;
 #endif // ASSERT
   _count = 0;
+  _current_block_limit = 0;
   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
 
   if (_max_blocks <= preallocated_block_list_size) {
     _blocks = _preallocated_block_list;
   } else {
@@ -292,18 +303,24 @@
   assert(_max_elements == set->_max_elements, "must have same universe size to swap");
   check_watch("swap", set->_serial_number);
   set->check_watch("swap", _serial_number);
 #endif
 
-  for (uint i = 0; i < _max_blocks; i++) {
+  uint max = MAX2(_current_block_limit, set->_current_block_limit);
+  for (uint i = 0; i < max; i++) {
     BitBlock *temp = _blocks[i];
     set_block(i, set->_blocks[i]);
     set->set_block(i, temp);
   }
   uint temp = _count;
   _count = set->_count;
   set->_count = temp;
+
+  temp = _current_block_limit;
+  _current_block_limit = set->_current_block_limit;
+  set->_current_block_limit = temp;
+
 }
 
 //---------------------------- IndexSet::dump() -----------------------------
 // Print this set.  Used for debugging.
 
@@ -381,82 +398,10 @@
 
 //---------------------------- IndexSetIterator() -----------------------------
 // Create an iterator for a set.  If empty blocks are detected when iterating
 // over the set, these blocks are replaced.
 
-IndexSetIterator::IndexSetIterator(IndexSet *set) {
-#ifdef ASSERT
-  if (CollectIndexSetStatistics) {
-    set->tally_iteration_statistics();
-  }
-  set->check_watch("traversed", set->count());
-#endif
-  if (set->is_empty()) {
-    _current = 0;
-    _next_word = IndexSet::words_per_block;
-    _next_block = 1;
-    _max_blocks = 1;
-
-    // We don't need the following values when we iterate over an empty set.
-    // The commented out code is left here to document that the omission
-    // is intentional.
-    //
-    //_value = 0;
-    //_words = NULL;
-    //_blocks = NULL;
-    //_set = NULL;
-  } else {
-    _current = 0;
-    _value = 0;
-    _next_block = 0;
-    _next_word = IndexSet::words_per_block;
-
-    _max_blocks = set->_max_blocks;
-    _words = NULL;
-    _blocks = set->_blocks;
-    _set = set;
-  }
-}
-
-//---------------------------- IndexSetIterator(const) -----------------------------
-// Iterate over a constant IndexSet.
-
-IndexSetIterator::IndexSetIterator(const IndexSet *set) {
-#ifdef ASSERT
-  if (CollectIndexSetStatistics) {
-    set->tally_iteration_statistics();
-  }
-  // We don't call check_watch from here to avoid bad recursion.
-  //   set->check_watch("traversed const", set->count());
-#endif
-  if (set->is_empty()) {
-    _current = 0;
-    _next_word = IndexSet::words_per_block;
-    _next_block = 1;
-    _max_blocks = 1;
-
-    // We don't need the following values when we iterate over an empty set.
-    // The commented out code is left here to document that the omission
-    // is intentional.
-    //
-    //_value = 0;
-    //_words = NULL;
-    //_blocks = NULL;
-    //_set = NULL;
-  } else {
-    _current = 0;
-    _value = 0;
-    _next_block = 0;
-    _next_word = IndexSet::words_per_block;
-
-    _max_blocks = set->_max_blocks;
-    _words = NULL;
-    _blocks = set->_blocks;
-    _set = NULL;
-  }
-}
-
 //---------------------------- List16Iterator::advance_and_next() -----------------------------
 // Advance to the next non-empty word in the set being iterated over.  Return the next element
 // if there is one.  If we are done, return 0.  This method is called from the next() method
 // when it gets done with a word.
 
@@ -465,14 +410,12 @@
   for (uint wi = _next_word; wi < (unsigned)IndexSet::words_per_block; wi++) {
     if (_words[wi] != 0) {
       // Found a non-empty word.
       _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
       _current = _words[wi];
-
-      _next_word = wi+1;
-
-      return next();
+      _next_word = wi + 1;
+      return next_value();
     }
   }
 
   // We ran out of words in the current block.  Advance to next non-empty block.
   for (uint bi = _next_block; bi < _max_blocks; bi++) {
@@ -486,12 +429,11 @@
           _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
           _current = _words[wi];
 
           _next_block = bi+1;
           _next_word = wi+1;
-
-          return next();
+          return next_value();
         }
       }
 
       // All of the words in the block were empty.  Replace
       // the block with the empty block.
@@ -499,13 +441,8 @@
         _set->free_block(bi);
       }
     }
   }
 
-  // These assignments make redundant calls to next on a finished iterator
-  // faster.  Probably not necessary.
-  _next_block = _max_blocks;
-  _next_word = IndexSet::words_per_block;
-
   // No more words.
   return 0;
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MEMNODE_HPP
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.
<a name="1" id="anc1"></a>

  46 protected:
  47 #ifdef ASSERT
  48   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  49 #endif
  50   virtual uint size_of() const;
  51 public:
  52   enum { Control,               // When is it safe to do this load?
  53          Memory,                // Chunk of memory is being loaded from
  54          Address,               // Actually address, derived from base
  55          ValueIn,               // Value to store
  56          OopStore               // Preceeding oop store, only in StoreCM
  57   };
  58   typedef enum { unordered = 0,
  59                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  60                  release,       // Store has to release or be preceded by MemBarRelease.
  61                  seqcst,        // LoadStore has to have both acquire and release semantics.
  62                  unset          // The memory ordering is not set (used for testing)
  63   } MemOrd;
  64 protected:
<a name="2" id="anc2"></a><span class="line-modified">  65   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at )</span>
<span class="line-modified">  66     : Node(c0,c1,c2   ), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  67     init_class_id(Class_Mem);
  68     debug_only(_adr_type=at; adr_type();)
  69   }
<a name="3" id="anc3"></a><span class="line-modified">  70   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 )</span>
<span class="line-modified">  71     : Node(c0,c1,c2,c3), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  72     init_class_id(Class_Mem);
  73     debug_only(_adr_type=at; adr_type();)
  74   }
<a name="4" id="anc4"></a><span class="line-modified">  75   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4)</span>
<span class="line-modified">  76     : Node(c0,c1,c2,c3,c4), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  77     init_class_id(Class_Mem);
  78     debug_only(_adr_type=at; adr_type();)
  79   }
  80 
  81   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  82   static bool check_if_adr_maybe_raw(Node* adr);
  83 
  84 public:
  85   // Helpers for the optimizer.  Documented in memnode.cpp.
  86   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
  87                                       Node* p2, AllocateNode* a2,
  88                                       PhaseTransform* phase);
  89   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
  90 
  91   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
  92   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
  93   // This one should probably be a phase-specific function:
  94   static bool all_controls_dominate(Node* dom, Node* sub);
  95 
  96   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
  97 
  98   // Shared code for Ideal methods:
  99   Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  // Return -1 for short-circuit NULL.
 100 
 101   // Helper function for adr_type() implementations.
 102   static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);
 103 
 104   // Raw access function, to allow copying of adr_type efficiently in
 105   // product builds and retain the debug info for debug builds.
 106   const TypePtr *raw_adr_type() const {
 107 #ifdef ASSERT
 108     return _adr_type;
 109 #else
 110     return 0;
 111 #endif
 112   }
 113 
 114   // Map a load or store opcode to its corresponding store opcode.
 115   // (Return -1 if unknown.)
 116   virtual int store_Opcode() const { return -1; }
 117 
 118   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 119   virtual BasicType memory_type() const = 0;
 120   virtual int memory_size() const {
 121 #ifdef ASSERT
 122     return type2aelembytes(memory_type(), true);
 123 #else
 124     return type2aelembytes(memory_type());
 125 #endif
 126   }
 127 
<a name="5" id="anc5"></a>


 128   // Search through memory states which precede this node (load or store).
 129   // Look for an exact match for the address, with no intervening
 130   // aliased stores.
 131   Node* find_previous_store(PhaseTransform* phase);
 132 
 133   // Can this node (load or store) accurately see a stored value in
 134   // the given memory state?  (The state may or may not be in(Memory).)
 135   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 136 
 137   void set_unaligned_access() { _unaligned_access = true; }
 138   bool is_unaligned_access() const { return _unaligned_access; }
 139   void set_mismatched_access() { _mismatched_access = true; }
 140   bool is_mismatched_access() const { return _mismatched_access; }
 141   void set_unsafe_access() { _unsafe_access = true; }
 142   bool is_unsafe_access() const { return _unsafe_access; }
 143 
 144 #ifndef PRODUCT
 145   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 146   virtual void dump_spec(outputStream *st) const;
 147 #endif
 148 };
 149 
 150 //------------------------------LoadNode---------------------------------------
 151 // Load value; requires Memory and Address
 152 class LoadNode : public MemNode {
 153 public:
 154   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 155   // on the dominating test.  The field _control_dependency below records
 156   // whether that node depends only on the dominating test.
<a name="6" id="anc6"></a><span class="line-modified"> 157   // Methods used to build LoadNodes pass an argument of type enum</span>
<span class="line-modified"> 158   // ControlDependency instead of a boolean because those methods</span>
<span class="line-modified"> 159   // typically have multiple boolean parameters with default values:</span>
<span class="line-removed"> 160   // passing the wrong boolean to one of these parameters by mistake</span>
<span class="line-removed"> 161   // goes easily unnoticed. Using an enum, the compiler can check that</span>
<span class="line-removed"> 162   // the type of a value and the type of the parameter match.</span>
 163   enum ControlDependency {
 164     Pinned,
<a name="7" id="anc7"></a>
 165     DependsOnlyOnTest
 166   };
<a name="8" id="anc8"></a>
 167 private:
 168   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 169   // into account: If the graph already has a non-pinned LoadNode and
 170   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 171   // to replace the pinned LoadNode with the non-pinned LoadNode,
 172   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 173   // those inputs in the first place. If the graph already has a
 174   // pinned LoadNode and we add a non pinned LoadNode with the same
 175   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 176   // non-pinned LoadNode by the pinned LoadNode.
 177   ControlDependency _control_dependency;
 178 
 179   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 180   // loads that can be reordered, and such requiring acquire semantics to
 181   // adhere to the Java specification.  The required behaviour is stored in
 182   // this field.
 183   const MemOrd _mo;
 184 
<a name="9" id="anc9"></a>

 185 protected:
<a name="10" id="anc10"></a><span class="line-modified"> 186   virtual uint cmp(const Node &amp;n) const;</span>
 187   virtual uint size_of() const; // Size is bigger
 188   // Should LoadNode::Ideal() attempt to remove control edges?
 189   virtual bool can_remove_control() const;
 190   const Type* const _type;      // What kind of value is loaded?
 191 
 192   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 193 public:
 194 
 195   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 196     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 197     init_class_id(Class_Load);
 198   }
 199   inline bool is_unordered() const { return !is_acquire(); }
 200   inline bool is_acquire() const {
 201     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 202     return _mo == acquire;
 203   }
 204   inline bool is_unsigned() const {
 205     int lop = Opcode();
 206     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 207   }
 208 
 209   // Polymorphic factory method:
 210   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 211                     const TypePtr* at, const Type *rt, BasicType bt,
 212                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<a name="11" id="anc11"></a><span class="line-modified"> 213                     bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>

 214 
 215   virtual uint hash()   const;  // Check the type
 216 
 217   // Handle algebraic identities here.  If we have an identity, return the Node
 218   // we are equivalent to.  We look for Load of a Store.
 219   virtual Node* Identity(PhaseGVN* phase);
 220 
 221   // If the load is from Field memory and the pointer is non-null, it might be possible to
 222   // zero out the control input.
 223   // If the offset is constant and the base is an object allocation,
 224   // try to hook me up to the exact initializing store.
 225   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 226 
 227   // Split instance field load through Phi.
 228   Node* split_through_phi(PhaseGVN *phase);
 229 
 230   // Recover original value from boxed values
 231   Node *eliminate_autobox(PhaseGVN *phase);
 232 
 233   // Compute a new Type for this node.  Basically we just do the pre-check,
 234   // then call the virtual add() to set the type.
 235   virtual const Type* Value(PhaseGVN* phase) const;
 236 
 237   // Common methods for LoadKlass and LoadNKlass nodes.
 238   const Type* klass_value_common(PhaseGVN* phase) const;
 239   Node* klass_identity_common(PhaseGVN* phase);
 240 
 241   virtual uint ideal_reg() const;
 242   virtual const Type *bottom_type() const;
 243   // Following method is copied from TypeNode:
 244   void set_type(const Type* t) {
 245     assert(t != NULL, &quot;sanity&quot;);
 246     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 247     *(const Type**)&amp;_type = t;   // cast away const-ness
 248     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 249     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 250   }
 251   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 252 
 253   // Do not match memory edge
 254   virtual uint match_edge(uint idx) const;
 255 
 256   // Map a load opcode to its corresponding store opcode.
 257   virtual int store_Opcode() const = 0;
 258 
 259   // Check if the load&#39;s memory input is a Phi node with the same control.
 260   bool is_instance_field_load_with_local_phi(Node* ctrl);
 261 
 262   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 263   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 264 
<a name="12" id="anc12"></a>


 265 #ifndef PRODUCT
 266   virtual void dump_spec(outputStream *st) const;
 267 #endif
 268 #ifdef ASSERT
 269   // Helper function to allow a raw load without control edge for some cases
 270   static bool is_immutable_value(Node* adr);
 271 #endif
 272 protected:
 273   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 274                                      ciKlass* klass) const;
 275 
 276   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 277 
 278   // depends_only_on_test is almost always true, and needs to be almost always
 279   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 280   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 281   // GC barriers, the control edge carries the dependence preventing hoisting past
 282   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 283   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 284   // which produce results (new raw memory state) inside of loops preventing all
 285   // manner of other optimizations).  Basically, it&#39;s ugly but so is the alternative.
 286   // See comment in macro.cpp, around line 125 expand_allocate_common().
 287   virtual bool depends_only_on_test() const {
 288     return adr_type() != TypeRawPtr::BOTTOM &amp;&amp; _control_dependency == DependsOnlyOnTest;
 289   }
 290 };
 291 
 292 //------------------------------LoadBNode--------------------------------------
 293 // Load a byte (8bits signed) from memory
 294 class LoadBNode : public LoadNode {
 295 public:
 296   LoadBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 297     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 298   virtual int Opcode() const;
 299   virtual uint ideal_reg() const { return Op_RegI; }
 300   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 301   virtual const Type* Value(PhaseGVN* phase) const;
 302   virtual int store_Opcode() const { return Op_StoreB; }
 303   virtual BasicType memory_type() const { return T_BYTE; }
 304 };
 305 
 306 //------------------------------LoadUBNode-------------------------------------
 307 // Load a unsigned byte (8bits unsigned) from memory
 308 class LoadUBNode : public LoadNode {
 309 public:
 310   LoadUBNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeInt* ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 311     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 312   virtual int Opcode() const;
 313   virtual uint ideal_reg() const { return Op_RegI; }
 314   virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);
 315   virtual const Type* Value(PhaseGVN* phase) const;
 316   virtual int store_Opcode() const { return Op_StoreB; }
 317   virtual BasicType memory_type() const { return T_BYTE; }
 318 };
 319 
 320 //------------------------------LoadUSNode-------------------------------------
 321 // Load an unsigned short/char (16bits unsigned) from memory
 322 class LoadUSNode : public LoadNode {
 323 public:
 324   LoadUSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 325     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 326   virtual int Opcode() const;
 327   virtual uint ideal_reg() const { return Op_RegI; }
 328   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 329   virtual const Type* Value(PhaseGVN* phase) const;
 330   virtual int store_Opcode() const { return Op_StoreC; }
 331   virtual BasicType memory_type() const { return T_CHAR; }
 332 };
 333 
 334 //------------------------------LoadSNode--------------------------------------
 335 // Load a short (16bits signed) from memory
 336 class LoadSNode : public LoadNode {
 337 public:
 338   LoadSNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 339     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 340   virtual int Opcode() const;
 341   virtual uint ideal_reg() const { return Op_RegI; }
 342   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 343   virtual const Type* Value(PhaseGVN* phase) const;
 344   virtual int store_Opcode() const { return Op_StoreC; }
 345   virtual BasicType memory_type() const { return T_SHORT; }
 346 };
 347 
 348 //------------------------------LoadINode--------------------------------------
 349 // Load an integer from memory
 350 class LoadINode : public LoadNode {
 351 public:
 352   LoadINode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeInt *ti, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 353     : LoadNode(c, mem, adr, at, ti, mo, control_dependency) {}
 354   virtual int Opcode() const;
 355   virtual uint ideal_reg() const { return Op_RegI; }
 356   virtual int store_Opcode() const { return Op_StoreI; }
 357   virtual BasicType memory_type() const { return T_INT; }
 358 };
 359 
 360 //------------------------------LoadRangeNode----------------------------------
 361 // Load an array length from the array
 362 class LoadRangeNode : public LoadINode {
 363 public:
 364   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 365     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 366   virtual int Opcode() const;
 367   virtual const Type* Value(PhaseGVN* phase) const;
 368   virtual Node* Identity(PhaseGVN* phase);
 369   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 370 };
 371 
 372 //------------------------------LoadLNode--------------------------------------
 373 // Load a long from memory
 374 class LoadLNode : public LoadNode {
 375   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<a name="13" id="anc13"></a><span class="line-modified"> 376   virtual uint cmp( const Node &amp;n ) const {</span>
 377     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 378       &amp;&amp; LoadNode::cmp(n);
 379   }
 380   virtual uint size_of() const { return sizeof(*this); }
 381   const bool _require_atomic_access;  // is piecewise load forbidden?
 382 
 383 public:
 384   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 385             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 386     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 387   virtual int Opcode() const;
 388   virtual uint ideal_reg() const { return Op_RegL; }
 389   virtual int store_Opcode() const { return Op_StoreL; }
 390   virtual BasicType memory_type() const { return T_LONG; }
 391   bool require_atomic_access() const { return _require_atomic_access; }
 392   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 393                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<a name="14" id="anc14"></a><span class="line-modified"> 394                                 bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>
 395 #ifndef PRODUCT
 396   virtual void dump_spec(outputStream *st) const {
 397     LoadNode::dump_spec(st);
 398     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 399   }
 400 #endif
 401 };
 402 
 403 //------------------------------LoadL_unalignedNode----------------------------
 404 // Load a long from unaligned memory
 405 class LoadL_unalignedNode : public LoadLNode {
 406 public:
 407   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 408     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 409   virtual int Opcode() const;
 410 };
 411 
 412 //------------------------------LoadFNode--------------------------------------
 413 // Load a float (64 bits) from memory
 414 class LoadFNode : public LoadNode {
 415 public:
 416   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 417     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 418   virtual int Opcode() const;
 419   virtual uint ideal_reg() const { return Op_RegF; }
 420   virtual int store_Opcode() const { return Op_StoreF; }
 421   virtual BasicType memory_type() const { return T_FLOAT; }
 422 };
 423 
 424 //------------------------------LoadDNode--------------------------------------
 425 // Load a double (64 bits) from memory
 426 class LoadDNode : public LoadNode {
 427   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<a name="15" id="anc15"></a><span class="line-modified"> 428   virtual uint cmp( const Node &amp;n ) const {</span>
 429     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 430       &amp;&amp; LoadNode::cmp(n);
 431   }
 432   virtual uint size_of() const { return sizeof(*this); }
 433   const bool _require_atomic_access;  // is piecewise load forbidden?
 434 
 435 public:
 436   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 437             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 438     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 439   virtual int Opcode() const;
 440   virtual uint ideal_reg() const { return Op_RegD; }
 441   virtual int store_Opcode() const { return Op_StoreD; }
 442   virtual BasicType memory_type() const { return T_DOUBLE; }
 443   bool require_atomic_access() const { return _require_atomic_access; }
 444   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 445                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<a name="16" id="anc16"></a><span class="line-modified"> 446                                 bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>
 447 #ifndef PRODUCT
 448   virtual void dump_spec(outputStream *st) const {
 449     LoadNode::dump_spec(st);
 450     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 451   }
 452 #endif
 453 };
 454 
 455 //------------------------------LoadD_unalignedNode----------------------------
 456 // Load a double from unaligned memory
 457 class LoadD_unalignedNode : public LoadDNode {
 458 public:
 459   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 460     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 461   virtual int Opcode() const;
 462 };
 463 
 464 //------------------------------LoadPNode--------------------------------------
 465 // Load a pointer from memory (either object or array)
 466 class LoadPNode : public LoadNode {
 467 public:
 468   LoadPNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypePtr* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 469     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 470   virtual int Opcode() const;
 471   virtual uint ideal_reg() const { return Op_RegP; }
 472   virtual int store_Opcode() const { return Op_StoreP; }
 473   virtual BasicType memory_type() const { return T_ADDRESS; }
 474 };
 475 
 476 
 477 //------------------------------LoadNNode--------------------------------------
 478 // Load a narrow oop from memory (either object or array)
 479 class LoadNNode : public LoadNode {
 480 public:
 481   LoadNNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const Type* t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 482     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 483   virtual int Opcode() const;
 484   virtual uint ideal_reg() const { return Op_RegN; }
 485   virtual int store_Opcode() const { return Op_StoreN; }
 486   virtual BasicType memory_type() const { return T_NARROWOOP; }
 487 };
 488 
 489 //------------------------------LoadKlassNode----------------------------------
 490 // Load a Klass from an object
 491 class LoadKlassNode : public LoadPNode {
 492 protected:
 493   // In most cases, LoadKlassNode does not have the control input set. If the control
 494   // input is set, it must not be removed (by LoadNode::Ideal()).
 495   virtual bool can_remove_control() const;
 496 public:
 497   LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)
 498     : LoadPNode(c, mem, adr, at, tk, mo) {}
 499   virtual int Opcode() const;
 500   virtual const Type* Value(PhaseGVN* phase) const;
 501   virtual Node* Identity(PhaseGVN* phase);
 502   virtual bool depends_only_on_test() const { return true; }
 503 
 504   // Polymorphic factory method:
 505   static Node* make(PhaseGVN&amp; gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,
 506                     const TypeKlassPtr* tk = TypeKlassPtr::OBJECT);
 507 };
 508 
 509 //------------------------------LoadNKlassNode---------------------------------
 510 // Load a narrow Klass from an object.
 511 class LoadNKlassNode : public LoadNNode {
 512 public:
 513   LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)
 514     : LoadNNode(c, mem, adr, at, tk, mo) {}
 515   virtual int Opcode() const;
 516   virtual uint ideal_reg() const { return Op_RegN; }
 517   virtual int store_Opcode() const { return Op_StoreNKlass; }
 518   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 519 
 520   virtual const Type* Value(PhaseGVN* phase) const;
 521   virtual Node* Identity(PhaseGVN* phase);
 522   virtual bool depends_only_on_test() const { return true; }
 523 };
 524 
 525 
 526 //------------------------------StoreNode--------------------------------------
 527 // Store value; requires Store, Address and Value
 528 class StoreNode : public MemNode {
 529 private:
 530   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 531   // stores that can be reordered, and such requiring release semantics to
 532   // adhere to the Java specification.  The required behaviour is stored in
 533   // this field.
 534   const MemOrd _mo;
 535   // Needed for proper cloning.
 536   virtual uint size_of() const { return sizeof(*this); }
 537 protected:
<a name="17" id="anc17"></a><span class="line-modified"> 538   virtual uint cmp( const Node &amp;n ) const;</span>
 539   virtual bool depends_only_on_test() const { return false; }
 540 
 541   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 542   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 543 
 544 public:
 545   // We must ensure that stores of object references will be visible
 546   // only after the object&#39;s initialization. So the callers of this
 547   // procedure must indicate that the store requires `release&#39;
 548   // semantics, if the stored value is an object reference that might
 549   // point to a new object and may become externally visible.
 550   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 551     : MemNode(c, mem, adr, at, val), _mo(mo) {
 552     init_class_id(Class_Store);
 553   }
 554   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 555     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 556     init_class_id(Class_Store);
 557   }
 558 
 559   inline bool is_unordered() const { return !is_release(); }
 560   inline bool is_release() const {
 561     assert((_mo == unordered || _mo == release), &quot;unexpected&quot;);
 562     return _mo == release;
 563   }
 564 
 565   // Conservatively release stores of object references in order to
 566   // ensure visibility of object initialization.
 567   static inline MemOrd release_if_reference(const BasicType t) {
 568 #ifdef AARCH64
 569     // AArch64 doesn&#39;t need a release store here because object
 570     // initialization contains the necessary barriers.
 571     return unordered;
 572 #else
 573     const MemOrd mo = (t == T_ARRAY ||
 574                        t == T_ADDRESS || // Might be the address of an object reference (`boxing&#39;).
 575                        t == T_OBJECT) ? release : unordered;
 576     return mo;
 577 #endif
 578   }
 579 
 580   // Polymorphic factory method
 581   //
 582   // We must ensure that stores of object references will be visible
 583   // only after the object&#39;s initialization. So the callers of this
 584   // procedure must indicate that the store requires `release&#39;
 585   // semantics, if the stored value is an object reference that might
 586   // point to a new object and may become externally visible.
 587   static StoreNode* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 588                          const TypePtr* at, Node *val, BasicType bt, MemOrd mo);
 589 
 590   virtual uint hash() const;    // Check the type
 591 
 592   // If the store is to Field memory and the pointer is non-null, we can
 593   // zero out the control input.
 594   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 595 
 596   // Compute a new Type for this node.  Basically we just do the pre-check,
 597   // then call the virtual add() to set the type.
 598   virtual const Type* Value(PhaseGVN* phase) const;
 599 
 600   // Check for identity function on memory (Load then Store at same address)
 601   virtual Node* Identity(PhaseGVN* phase);
 602 
 603   // Do not match memory edge
 604   virtual uint match_edge(uint idx) const;
 605 
 606   virtual const Type *bottom_type() const;  // returns Type::MEMORY
 607 
 608   // Map a store opcode to its corresponding own opcode, trivially.
 609   virtual int store_Opcode() const { return Opcode(); }
 610 
 611   // have all possible loads of the value stored been optimized away?
 612   bool value_never_loaded(PhaseTransform *phase) const;
 613 
 614   MemBarNode* trailing_membar() const;
 615 };
 616 
 617 //------------------------------StoreBNode-------------------------------------
 618 // Store byte to memory
 619 class StoreBNode : public StoreNode {
 620 public:
 621   StoreBNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 622     : StoreNode(c, mem, adr, at, val, mo) {}
 623   virtual int Opcode() const;
 624   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 625   virtual BasicType memory_type() const { return T_BYTE; }
 626 };
 627 
 628 //------------------------------StoreCNode-------------------------------------
 629 // Store char/short to memory
 630 class StoreCNode : public StoreNode {
 631 public:
 632   StoreCNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 633     : StoreNode(c, mem, adr, at, val, mo) {}
 634   virtual int Opcode() const;
 635   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 636   virtual BasicType memory_type() const { return T_CHAR; }
 637 };
 638 
 639 //------------------------------StoreINode-------------------------------------
 640 // Store int to memory
 641 class StoreINode : public StoreNode {
 642 public:
 643   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 644     : StoreNode(c, mem, adr, at, val, mo) {}
 645   virtual int Opcode() const;
 646   virtual BasicType memory_type() const { return T_INT; }
 647 };
 648 
 649 //------------------------------StoreLNode-------------------------------------
 650 // Store long to memory
 651 class StoreLNode : public StoreNode {
 652   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<a name="18" id="anc18"></a><span class="line-modified"> 653   virtual uint cmp( const Node &amp;n ) const {</span>
 654     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 655       &amp;&amp; StoreNode::cmp(n);
 656   }
 657   virtual uint size_of() const { return sizeof(*this); }
 658   const bool _require_atomic_access;  // is piecewise store forbidden?
 659 
 660 public:
 661   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 662     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 663   virtual int Opcode() const;
 664   virtual BasicType memory_type() const { return T_LONG; }
 665   bool require_atomic_access() const { return _require_atomic_access; }
 666   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 667 #ifndef PRODUCT
 668   virtual void dump_spec(outputStream *st) const {
 669     StoreNode::dump_spec(st);
 670     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 671   }
 672 #endif
 673 };
 674 
 675 //------------------------------StoreFNode-------------------------------------
 676 // Store float to memory
 677 class StoreFNode : public StoreNode {
 678 public:
 679   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 680     : StoreNode(c, mem, adr, at, val, mo) {}
 681   virtual int Opcode() const;
 682   virtual BasicType memory_type() const { return T_FLOAT; }
 683 };
 684 
 685 //------------------------------StoreDNode-------------------------------------
 686 // Store double to memory
 687 class StoreDNode : public StoreNode {
 688   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<a name="19" id="anc19"></a><span class="line-modified"> 689   virtual uint cmp( const Node &amp;n ) const {</span>
 690     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 691       &amp;&amp; StoreNode::cmp(n);
 692   }
 693   virtual uint size_of() const { return sizeof(*this); }
 694   const bool _require_atomic_access;  // is piecewise store forbidden?
 695 public:
 696   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 697              MemOrd mo, bool require_atomic_access = false)
 698     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 699   virtual int Opcode() const;
 700   virtual BasicType memory_type() const { return T_DOUBLE; }
 701   bool require_atomic_access() const { return _require_atomic_access; }
 702   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 703 #ifndef PRODUCT
 704   virtual void dump_spec(outputStream *st) const {
 705     StoreNode::dump_spec(st);
 706     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 707   }
 708 #endif
 709 
 710 };
 711 
 712 //------------------------------StorePNode-------------------------------------
 713 // Store pointer to memory
 714 class StorePNode : public StoreNode {
 715 public:
 716   StorePNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 717     : StoreNode(c, mem, adr, at, val, mo) {}
 718   virtual int Opcode() const;
 719   virtual BasicType memory_type() const { return T_ADDRESS; }
 720 };
 721 
 722 //------------------------------StoreNNode-------------------------------------
 723 // Store narrow oop to memory
 724 class StoreNNode : public StoreNode {
 725 public:
 726   StoreNNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 727     : StoreNode(c, mem, adr, at, val, mo) {}
 728   virtual int Opcode() const;
 729   virtual BasicType memory_type() const { return T_NARROWOOP; }
 730 };
 731 
 732 //------------------------------StoreNKlassNode--------------------------------------
 733 // Store narrow klass to memory
 734 class StoreNKlassNode : public StoreNNode {
 735 public:
 736   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 737     : StoreNNode(c, mem, adr, at, val, mo) {}
 738   virtual int Opcode() const;
 739   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 740 };
 741 
 742 //------------------------------StoreCMNode-----------------------------------
 743 // Store card-mark byte to memory for CM
 744 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 745 // Preceeding equivalent StoreCMs may be eliminated.
 746 class StoreCMNode : public StoreNode {
 747  private:
 748   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
<a name="20" id="anc20"></a><span class="line-modified"> 749   virtual uint cmp( const Node &amp;n ) const {</span>
 750     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 751       &amp;&amp; StoreNode::cmp(n);
 752   }
 753   virtual uint size_of() const { return sizeof(*this); }
 754   int _oop_alias_idx;   // The alias_idx of OopStore
 755 
 756 public:
 757   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 758     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 759     _oop_alias_idx(oop_alias_idx) {
 760     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 761            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 762            &quot;bad oop alias idx&quot;);
 763   }
 764   virtual int Opcode() const;
 765   virtual Node* Identity(PhaseGVN* phase);
 766   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 767   virtual const Type* Value(PhaseGVN* phase) const;
 768   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 769   int oop_alias_idx() const { return _oop_alias_idx; }
 770 };
 771 
 772 //------------------------------LoadPLockedNode---------------------------------
 773 // Load-locked a pointer from memory (either object or array).
 774 // On Sparc &amp; Intel this is implemented as a normal pointer load.
 775 // On PowerPC and friends it&#39;s a real load-locked.
 776 class LoadPLockedNode : public LoadPNode {
 777 public:
 778   LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)
 779     : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}
 780   virtual int Opcode() const;
 781   virtual int store_Opcode() const { return Op_StorePConditional; }
 782   virtual bool depends_only_on_test() const { return true; }
 783 };
 784 
 785 //------------------------------SCMemProjNode---------------------------------------
 786 // This class defines a projection of the memory  state of a store conditional node.
 787 // These nodes return a value, but also update memory.
 788 class SCMemProjNode : public ProjNode {
 789 public:
 790   enum {SCMEMPROJCON = (uint)-2};
 791   SCMemProjNode( Node *src) : ProjNode( src, SCMEMPROJCON) { }
 792   virtual int Opcode() const;
 793   virtual bool      is_CFG() const  { return false; }
 794   virtual const Type *bottom_type() const {return Type::MEMORY;}
 795   virtual const TypePtr *adr_type() const {
 796     Node* ctrl = in(0);
 797     if (ctrl == NULL)  return NULL; // node is dead
 798     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 799   }
 800   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 801   virtual const Type* Value(PhaseGVN* phase) const;
 802 #ifndef PRODUCT
 803   virtual void dump_spec(outputStream *st) const {};
 804 #endif
 805 };
 806 
 807 //------------------------------LoadStoreNode---------------------------
 808 // Note: is_Mem() method returns &#39;true&#39; for this class.
 809 class LoadStoreNode : public Node {
 810 private:
 811   const Type* const _type;      // What kind of value is loaded?
 812   const TypePtr* _adr_type;     // What kind of memory is being addressed?
<a name="21" id="anc21"></a>
 813   virtual uint size_of() const; // Size is bigger
 814 public:
 815   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 816   virtual bool depends_only_on_test() const { return false; }
 817   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 818 
 819   virtual const Type *bottom_type() const { return _type; }
 820   virtual uint ideal_reg() const;
 821   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 822 
 823   bool result_not_used() const;
 824   MemBarNode* trailing_membar() const;
<a name="22" id="anc22"></a>


 825 };
 826 
 827 class LoadStoreConditionalNode : public LoadStoreNode {
 828 public:
 829   enum {
 830     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 831   };
 832   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 833 };
 834 
 835 //------------------------------StorePConditionalNode---------------------------
 836 // Conditionally store pointer to memory, if no change since prior
 837 // load-locked.  Sets flags for success or failure of the store.
 838 class StorePConditionalNode : public LoadStoreConditionalNode {
 839 public:
 840   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 841   virtual int Opcode() const;
 842   // Produces flags
 843   virtual uint ideal_reg() const { return Op_RegFlags; }
 844 };
 845 
 846 //------------------------------StoreIConditionalNode---------------------------
 847 // Conditionally store int to memory, if no change since prior
 848 // load-locked.  Sets flags for success or failure of the store.
 849 class StoreIConditionalNode : public LoadStoreConditionalNode {
 850 public:
 851   StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }
 852   virtual int Opcode() const;
 853   // Produces flags
 854   virtual uint ideal_reg() const { return Op_RegFlags; }
 855 };
 856 
 857 //------------------------------StoreLConditionalNode---------------------------
 858 // Conditionally store long to memory, if no change since prior
 859 // load-locked.  Sets flags for success or failure of the store.
 860 class StoreLConditionalNode : public LoadStoreConditionalNode {
 861 public:
 862   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 863   virtual int Opcode() const;
 864   // Produces flags
 865   virtual uint ideal_reg() const { return Op_RegFlags; }
 866 };
 867 
 868 class CompareAndSwapNode : public LoadStoreConditionalNode {
 869 private:
 870   const MemNode::MemOrd _mem_ord;
 871 public:
 872   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 873   MemNode::MemOrd order() const {
 874     return _mem_ord;
 875   }
<a name="23" id="anc23"></a>
 876 };
 877 
 878 class CompareAndExchangeNode : public LoadStoreNode {
 879 private:
 880   const MemNode::MemOrd _mem_ord;
 881 public:
 882   enum {
 883     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 884   };
 885   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 886     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 887      init_req(ExpectedIn, ex );
 888   }
 889 
 890   MemNode::MemOrd order() const {
 891     return _mem_ord;
 892   }
<a name="24" id="anc24"></a>
 893 };
 894 
 895 //------------------------------CompareAndSwapBNode---------------------------
 896 class CompareAndSwapBNode : public CompareAndSwapNode {
 897 public:
 898   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 899   virtual int Opcode() const;
 900 };
 901 
 902 //------------------------------CompareAndSwapSNode---------------------------
 903 class CompareAndSwapSNode : public CompareAndSwapNode {
 904 public:
 905   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 906   virtual int Opcode() const;
 907 };
 908 
 909 //------------------------------CompareAndSwapINode---------------------------
 910 class CompareAndSwapINode : public CompareAndSwapNode {
 911 public:
 912   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 913   virtual int Opcode() const;
 914 };
 915 
 916 //------------------------------CompareAndSwapLNode---------------------------
 917 class CompareAndSwapLNode : public CompareAndSwapNode {
 918 public:
 919   CompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 920   virtual int Opcode() const;
 921 };
 922 
 923 //------------------------------CompareAndSwapPNode---------------------------
 924 class CompareAndSwapPNode : public CompareAndSwapNode {
 925 public:
 926   CompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 927   virtual int Opcode() const;
 928 };
 929 
 930 //------------------------------CompareAndSwapNNode---------------------------
 931 class CompareAndSwapNNode : public CompareAndSwapNode {
 932 public:
 933   CompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 934   virtual int Opcode() const;
 935 };
 936 
 937 //------------------------------WeakCompareAndSwapBNode---------------------------
 938 class WeakCompareAndSwapBNode : public CompareAndSwapNode {
 939 public:
 940   WeakCompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 941   virtual int Opcode() const;
 942 };
 943 
 944 //------------------------------WeakCompareAndSwapSNode---------------------------
 945 class WeakCompareAndSwapSNode : public CompareAndSwapNode {
 946 public:
 947   WeakCompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 948   virtual int Opcode() const;
 949 };
 950 
 951 //------------------------------WeakCompareAndSwapINode---------------------------
 952 class WeakCompareAndSwapINode : public CompareAndSwapNode {
 953 public:
 954   WeakCompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 955   virtual int Opcode() const;
 956 };
 957 
 958 //------------------------------WeakCompareAndSwapLNode---------------------------
 959 class WeakCompareAndSwapLNode : public CompareAndSwapNode {
 960 public:
 961   WeakCompareAndSwapLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 962   virtual int Opcode() const;
 963 };
 964 
 965 //------------------------------WeakCompareAndSwapPNode---------------------------
 966 class WeakCompareAndSwapPNode : public CompareAndSwapNode {
 967 public:
 968   WeakCompareAndSwapPNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 969   virtual int Opcode() const;
 970 };
 971 
 972 //------------------------------WeakCompareAndSwapNNode---------------------------
 973 class WeakCompareAndSwapNNode : public CompareAndSwapNode {
 974 public:
 975   WeakCompareAndSwapNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 976   virtual int Opcode() const;
 977 };
 978 
 979 //------------------------------CompareAndExchangeBNode---------------------------
 980 class CompareAndExchangeBNode : public CompareAndExchangeNode {
 981 public:
 982   CompareAndExchangeBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::BYTE) { }
 983   virtual int Opcode() const;
 984 };
 985 
 986 
 987 //------------------------------CompareAndExchangeSNode---------------------------
 988 class CompareAndExchangeSNode : public CompareAndExchangeNode {
 989 public:
 990   CompareAndExchangeSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::SHORT) { }
 991   virtual int Opcode() const;
 992 };
 993 
 994 //------------------------------CompareAndExchangeLNode---------------------------
 995 class CompareAndExchangeLNode : public CompareAndExchangeNode {
 996 public:
 997   CompareAndExchangeLNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeLong::LONG) { }
 998   virtual int Opcode() const;
 999 };
1000 
1001 
1002 //------------------------------CompareAndExchangeINode---------------------------
1003 class CompareAndExchangeINode : public CompareAndExchangeNode {
1004 public:
1005   CompareAndExchangeINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, TypeInt::INT) { }
1006   virtual int Opcode() const;
1007 };
1008 
1009 
1010 //------------------------------CompareAndExchangePNode---------------------------
1011 class CompareAndExchangePNode : public CompareAndExchangeNode {
1012 public:
1013   CompareAndExchangePNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1014   virtual int Opcode() const;
1015 };
1016 
1017 //------------------------------CompareAndExchangeNNode---------------------------
1018 class CompareAndExchangeNNode : public CompareAndExchangeNode {
1019 public:
1020   CompareAndExchangeNNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord) : CompareAndExchangeNode(c, mem, adr, val, ex, mem_ord, at, t) { }
1021   virtual int Opcode() const;
1022 };
1023 
1024 //------------------------------GetAndAddBNode---------------------------
1025 class GetAndAddBNode : public LoadStoreNode {
1026 public:
1027   GetAndAddBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1028   virtual int Opcode() const;
1029 };
1030 
1031 //------------------------------GetAndAddSNode---------------------------
1032 class GetAndAddSNode : public LoadStoreNode {
1033 public:
1034   GetAndAddSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1035   virtual int Opcode() const;
1036 };
1037 
1038 //------------------------------GetAndAddINode---------------------------
1039 class GetAndAddINode : public LoadStoreNode {
1040 public:
1041   GetAndAddINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1042   virtual int Opcode() const;
1043 };
1044 
1045 //------------------------------GetAndAddLNode---------------------------
1046 class GetAndAddLNode : public LoadStoreNode {
1047 public:
1048   GetAndAddLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1049   virtual int Opcode() const;
1050 };
1051 
1052 //------------------------------GetAndSetBNode---------------------------
1053 class GetAndSetBNode : public LoadStoreNode {
1054 public:
1055   GetAndSetBNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::BYTE, 4) { }
1056   virtual int Opcode() const;
1057 };
1058 
1059 //------------------------------GetAndSetSNode---------------------------
1060 class GetAndSetSNode : public LoadStoreNode {
1061 public:
1062   GetAndSetSNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::SHORT, 4) { }
1063   virtual int Opcode() const;
1064 };
1065 
1066 //------------------------------GetAndSetINode---------------------------
1067 class GetAndSetINode : public LoadStoreNode {
1068 public:
1069   GetAndSetINode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeInt::INT, 4) { }
1070   virtual int Opcode() const;
1071 };
1072 
1073 //------------------------------GetAndSetLNode---------------------------
1074 class GetAndSetLNode : public LoadStoreNode {
1075 public:
1076   GetAndSetLNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at ) : LoadStoreNode(c, mem, adr, val, at, TypeLong::LONG, 4) { }
1077   virtual int Opcode() const;
1078 };
1079 
1080 //------------------------------GetAndSetPNode---------------------------
1081 class GetAndSetPNode : public LoadStoreNode {
1082 public:
1083   GetAndSetPNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1084   virtual int Opcode() const;
1085 };
1086 
1087 //------------------------------GetAndSetNNode---------------------------
1088 class GetAndSetNNode : public LoadStoreNode {
1089 public:
1090   GetAndSetNNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* t ) : LoadStoreNode(c, mem, adr, val, at, t, 4) { }
1091   virtual int Opcode() const;
1092 };
1093 
1094 //------------------------------ClearArray-------------------------------------
1095 class ClearArrayNode: public Node {
1096 private:
1097   bool _is_large;
1098 public:
1099   ClearArrayNode( Node *ctrl, Node *arymem, Node *word_cnt, Node *base, bool is_large)
1100     : Node(ctrl,arymem,word_cnt,base), _is_large(is_large) {
1101     init_class_id(Class_ClearArray);
1102   }
1103   virtual int         Opcode() const;
1104   virtual const Type *bottom_type() const { return Type::MEMORY; }
1105   // ClearArray modifies array elements, and so affects only the
1106   // array memory addressed by the bottom_type of its base address.
1107   virtual const class TypePtr *adr_type() const;
1108   virtual Node* Identity(PhaseGVN* phase);
1109   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1110   virtual uint match_edge(uint idx) const;
1111   bool is_large() const { return _is_large; }
1112 
1113   // Clear the given area of an object or array.
1114   // The start offset must always be aligned mod BytesPerInt.
1115   // The end offset must always be aligned mod BytesPerLong.
1116   // Return the new memory.
1117   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1118                             intptr_t start_offset,
1119                             intptr_t end_offset,
1120                             PhaseGVN* phase);
1121   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1122                             intptr_t start_offset,
1123                             Node* end_offset,
1124                             PhaseGVN* phase);
1125   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1126                             Node* start_offset,
1127                             Node* end_offset,
1128                             PhaseGVN* phase);
1129   // Return allocation input memory edge if it is different instance
1130   // or itself if it is the one we are looking for.
1131   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1132 };
1133 
1134 //------------------------------MemBar-----------------------------------------
1135 // There are different flavors of Memory Barriers to match the Java Memory
1136 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1137 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1138 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1139 // preceding ref can be moved to after them.  We insert a MemBar-Release
1140 // before a FastUnlock or volatile-store.  All volatiles need to be
1141 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1142 // separate it from any following volatile-load.
1143 class MemBarNode: public MultiNode {
1144   virtual uint hash() const ;                  // { return NO_HASH; }
<a name="25" id="anc25"></a><span class="line-modified">1145   virtual uint cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1146 
1147   virtual uint size_of() const { return sizeof(*this); }
1148   // Memory type this node is serializing.  Usually either rawptr or bottom.
1149   const TypePtr* _adr_type;
1150 
1151   // How is this membar related to a nearby memory access?
1152   enum {
1153     Standalone,
1154     TrailingLoad,
1155     TrailingStore,
1156     LeadingStore,
1157     TrailingLoadStore,
1158     LeadingLoadStore
1159   } _kind;
1160 
1161 #ifdef ASSERT
1162   uint _pair_idx;
1163 #endif
1164 
1165 public:
1166   enum {
1167     Precedent = TypeFunc::Parms  // optional edge to force precedence
1168   };
1169   MemBarNode(Compile* C, int alias_idx, Node* precedent);
1170   virtual int Opcode() const = 0;
1171   virtual const class TypePtr *adr_type() const { return _adr_type; }
1172   virtual const Type* Value(PhaseGVN* phase) const;
1173   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1174   virtual uint match_edge(uint idx) const { return 0; }
1175   virtual const Type *bottom_type() const { return TypeTuple::MEMBAR; }
1176   virtual Node *match( const ProjNode *proj, const Matcher *m );
1177   // Factory method.  Builds a wide or narrow membar.
1178   // Optional &#39;precedent&#39; becomes an extra edge if not null.
1179   static MemBarNode* make(Compile* C, int opcode,
1180                           int alias_idx = Compile::AliasIdxBot,
1181                           Node* precedent = NULL);
1182 
1183   MemBarNode* trailing_membar() const;
1184   MemBarNode* leading_membar() const;
1185 
1186   void set_trailing_load() { _kind = TrailingLoad; }
1187   bool trailing_load() const { return _kind == TrailingLoad; }
1188   bool trailing_store() const { return _kind == TrailingStore; }
1189   bool leading_store() const { return _kind == LeadingStore; }
1190   bool trailing_load_store() const { return _kind == TrailingLoadStore; }
1191   bool leading_load_store() const { return _kind == LeadingLoadStore; }
1192   bool trailing() const { return _kind == TrailingLoad || _kind == TrailingStore || _kind == TrailingLoadStore; }
1193   bool leading() const { return _kind == LeadingStore || _kind == LeadingLoadStore; }
1194   bool standalone() const { return _kind == Standalone; }
1195 
1196   static void set_store_pair(MemBarNode* leading, MemBarNode* trailing);
1197   static void set_load_store_pair(MemBarNode* leading, MemBarNode* trailing);
1198 
1199   void remove(PhaseIterGVN *igvn);
1200 };
1201 
1202 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1203 // follow, like an early Load stalled in cache).  Requires multi-cpu
1204 // visibility.  Inserted after a volatile load.
1205 class MemBarAcquireNode: public MemBarNode {
1206 public:
1207   MemBarAcquireNode(Compile* C, int alias_idx, Node* precedent)
1208     : MemBarNode(C, alias_idx, precedent) {}
1209   virtual int Opcode() const;
1210 };
1211 
1212 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1213 // follow, like an early Load stalled in cache).  Requires multi-cpu
1214 // visibility.  Inserted independ of any load, as required
1215 // for intrinsic Unsafe.loadFence().
1216 class LoadFenceNode: public MemBarNode {
1217 public:
1218   LoadFenceNode(Compile* C, int alias_idx, Node* precedent)
1219     : MemBarNode(C, alias_idx, precedent) {}
1220   virtual int Opcode() const;
1221 };
1222 
1223 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1224 // up, like a speculative pipelined cache-hitting Load).  Requires
1225 // multi-cpu visibility.  Inserted before a volatile store.
1226 class MemBarReleaseNode: public MemBarNode {
1227 public:
1228   MemBarReleaseNode(Compile* C, int alias_idx, Node* precedent)
1229     : MemBarNode(C, alias_idx, precedent) {}
1230   virtual int Opcode() const;
1231 };
1232 
1233 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1234 // up, like a speculative pipelined cache-hitting Load).  Requires
1235 // multi-cpu visibility.  Inserted independent of any store, as required
1236 // for intrinsic Unsafe.storeFence().
1237 class StoreFenceNode: public MemBarNode {
1238 public:
1239   StoreFenceNode(Compile* C, int alias_idx, Node* precedent)
1240     : MemBarNode(C, alias_idx, precedent) {}
1241   virtual int Opcode() const;
1242 };
1243 
1244 // &quot;Acquire&quot; - no following ref can move before (but earlier refs can
1245 // follow, like an early Load stalled in cache).  Requires multi-cpu
1246 // visibility.  Inserted after a FastLock.
1247 class MemBarAcquireLockNode: public MemBarNode {
1248 public:
1249   MemBarAcquireLockNode(Compile* C, int alias_idx, Node* precedent)
1250     : MemBarNode(C, alias_idx, precedent) {}
1251   virtual int Opcode() const;
1252 };
1253 
1254 // &quot;Release&quot; - no earlier ref can move after (but later refs can move
1255 // up, like a speculative pipelined cache-hitting Load).  Requires
1256 // multi-cpu visibility.  Inserted before a FastUnLock.
1257 class MemBarReleaseLockNode: public MemBarNode {
1258 public:
1259   MemBarReleaseLockNode(Compile* C, int alias_idx, Node* precedent)
1260     : MemBarNode(C, alias_idx, precedent) {}
1261   virtual int Opcode() const;
1262 };
1263 
1264 class MemBarStoreStoreNode: public MemBarNode {
1265 public:
1266   MemBarStoreStoreNode(Compile* C, int alias_idx, Node* precedent)
1267     : MemBarNode(C, alias_idx, precedent) {
1268     init_class_id(Class_MemBarStoreStore);
1269   }
1270   virtual int Opcode() const;
1271 };
1272 
1273 // Ordering between a volatile store and a following volatile load.
1274 // Requires multi-CPU visibility?
1275 class MemBarVolatileNode: public MemBarNode {
1276 public:
1277   MemBarVolatileNode(Compile* C, int alias_idx, Node* precedent)
1278     : MemBarNode(C, alias_idx, precedent) {}
1279   virtual int Opcode() const;
1280 };
1281 
1282 // Ordering within the same CPU.  Used to order unsafe memory references
1283 // inside the compiler when we lack alias info.  Not needed &quot;outside&quot; the
1284 // compiler because the CPU does all the ordering for us.
1285 class MemBarCPUOrderNode: public MemBarNode {
1286 public:
1287   MemBarCPUOrderNode(Compile* C, int alias_idx, Node* precedent)
1288     : MemBarNode(C, alias_idx, precedent) {}
1289   virtual int Opcode() const;
1290   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1291 };
1292 
1293 class OnSpinWaitNode: public MemBarNode {
1294 public:
1295   OnSpinWaitNode(Compile* C, int alias_idx, Node* precedent)
1296     : MemBarNode(C, alias_idx, precedent) {}
1297   virtual int Opcode() const;
1298 };
1299 
1300 // Isolation of object setup after an AllocateNode and before next safepoint.
1301 // (See comment in memnode.cpp near InitializeNode::InitializeNode for semantics.)
1302 class InitializeNode: public MemBarNode {
1303   friend class AllocateNode;
1304 
1305   enum {
1306     Incomplete    = 0,
1307     Complete      = 1,
1308     WithArraycopy = 2
1309   };
1310   int _is_complete;
1311 
1312   bool _does_not_escape;
1313 
1314 public:
1315   enum {
1316     Control    = TypeFunc::Control,
1317     Memory     = TypeFunc::Memory,     // MergeMem for states affected by this op
1318     RawAddress = TypeFunc::Parms+0,    // the newly-allocated raw address
1319     RawStores  = TypeFunc::Parms+1     // zero or more stores (or TOP)
1320   };
1321 
1322   InitializeNode(Compile* C, int adr_type, Node* rawoop);
1323   virtual int Opcode() const;
1324   virtual uint size_of() const { return sizeof(*this); }
1325   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
1326   virtual const RegMask &amp;in_RegMask(uint) const;  // mask for RawAddress
1327 
1328   // Manage incoming memory edges via a MergeMem on in(Memory):
1329   Node* memory(uint alias_idx);
1330 
1331   // The raw memory edge coming directly from the Allocation.
1332   // The contents of this memory are *always* all-zero-bits.
1333   Node* zero_memory() { return memory(Compile::AliasIdxRaw); }
1334 
1335   // Return the corresponding allocation for this initialization (or null if none).
1336   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
1337   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
1338   AllocateNode* allocation();
1339 
1340   // Anything other than zeroing in this init?
1341   bool is_non_zero();
1342 
1343   // An InitializeNode must completed before macro expansion is done.
1344   // Completion requires that the AllocateNode must be followed by
1345   // initialization of the new memory to zero, then to any initializers.
1346   bool is_complete() { return _is_complete != Incomplete; }
1347   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1348 
1349   // Mark complete.  (Must not yet be complete.)
1350   void set_complete(PhaseGVN* phase);
1351   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1352 
1353   bool does_not_escape() { return _does_not_escape; }
1354   void set_does_not_escape() { _does_not_escape = true; }
1355 
1356 #ifdef ASSERT
1357   // ensure all non-degenerate stores are ordered and non-overlapping
1358   bool stores_are_sane(PhaseTransform* phase);
1359 #endif //ASSERT
1360 
1361   // See if this store can be captured; return offset where it initializes.
1362   // Return 0 if the store cannot be moved (any sort of problem).
<a name="26" id="anc26"></a><span class="line-modified">1363   intptr_t can_capture_store(StoreNode* st, PhaseTransform* phase, bool can_reshape);</span>
1364 
1365   // Capture another store; reformat it to write my internal raw memory.
1366   // Return the captured copy, else NULL if there is some sort of problem.
<a name="27" id="anc27"></a><span class="line-modified">1367   Node* capture_store(StoreNode* st, intptr_t start, PhaseTransform* phase, bool can_reshape);</span>
1368 
1369   // Find captured store which corresponds to the range [start..start+size).
1370   // Return my own memory projection (meaning the initial zero bits)
1371   // if there is no such store.  Return NULL if there is a problem.
1372   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1373 
1374   // Called when the associated AllocateNode is expanded into CFG.
1375   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1376                         intptr_t header_size, Node* size_in_bytes,
<a name="28" id="anc28"></a><span class="line-modified">1377                         PhaseGVN* phase);</span>
1378 
1379  private:
1380   void remove_extra_zeroes();
1381 
1382   // Find out where a captured store should be placed (or already is placed).
1383   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1384                                      PhaseTransform* phase);
1385 
1386   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1387 
1388   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1389 
<a name="29" id="anc29"></a><span class="line-modified">1390   bool detect_init_independence(Node* n, int&amp; count);</span>
1391 
1392   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1393                                PhaseGVN* phase);
1394 
1395   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1396 };
1397 
1398 //------------------------------MergeMem---------------------------------------
1399 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1400 class MergeMemNode: public Node {
1401   virtual uint hash() const ;                  // { return NO_HASH; }
<a name="30" id="anc30"></a><span class="line-modified">1402   virtual uint cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1403   friend class MergeMemStream;
1404   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1405 
1406 public:
1407   // If the input is a whole memory state, clone it with all its slices intact.
1408   // Otherwise, make a new memory state with just that base memory input.
1409   // In either case, the result is a newly created MergeMem.
1410   static MergeMemNode* make(Node* base_memory);
1411 
1412   virtual int Opcode() const;
1413   virtual Node* Identity(PhaseGVN* phase);
1414   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1415   virtual uint ideal_reg() const { return NotAMachineReg; }
1416   virtual uint match_edge(uint idx) const { return 0; }
1417   virtual const RegMask &amp;out_RegMask() const;
1418   virtual const Type *bottom_type() const { return Type::MEMORY; }
1419   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1420   // sparse accessors
1421   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1422   // (Caller should clone it if it is a phi-nest.)
1423   Node* memory_at(uint alias_idx) const;
1424   // set the memory, regardless of its previous value
1425   void set_memory_at(uint alias_idx, Node* n);
1426   // the &quot;base&quot; is the memory that provides the non-finite support
1427   Node* base_memory() const       { return in(Compile::AliasIdxBot); }
1428   // warning: setting the base can implicitly set any of the other slices too
1429   void set_base_memory(Node* def);
1430   // sentinel value which denotes a copy of the base memory:
1431   Node*   empty_memory() const    { return in(Compile::AliasIdxTop); }
1432   static Node* make_empty_memory(); // where the sentinel comes from
1433   bool is_empty_memory(Node* n) const { assert((n == empty_memory()) == n-&gt;is_top(), &quot;sanity&quot;); return n-&gt;is_top(); }
1434   // hook for the iterator, to perform any necessary setup
1435   void iteration_setup(const MergeMemNode* other = NULL);
1436   // push sentinels until I am at least as long as the other (semantic no-op)
1437   void grow_to_match(const MergeMemNode* other);
1438   bool verify_sparse() const PRODUCT_RETURN0;
1439 #ifndef PRODUCT
1440   virtual void dump_spec(outputStream *st) const;
1441 #endif
1442 };
1443 
1444 class MergeMemStream : public StackObj {
1445  private:
1446   MergeMemNode*       _mm;
1447   const MergeMemNode* _mm2;  // optional second guy, contributes non-empty iterations
1448   Node*               _mm_base;  // loop-invariant base memory of _mm
1449   int                 _idx;
1450   int                 _cnt;
1451   Node*               _mem;
1452   Node*               _mem2;
1453   int                 _cnt2;
1454 
1455   void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {
1456     // subsume_node will break sparseness at times, whenever a memory slice
1457     // folds down to a copy of the base (&quot;fat&quot;) memory.  In such a case,
1458     // the raw edge will update to base, although it should be top.
1459     // This iterator will recognize either top or base_memory as an
1460     // &quot;empty&quot; slice.  See is_empty, is_empty2, and next below.
1461     //
1462     // The sparseness property is repaired in MergeMemNode::Ideal.
1463     // As long as access to a MergeMem goes through this iterator
1464     // or the memory_at accessor, flaws in the sparseness will
1465     // never be observed.
1466     //
1467     // Also, iteration_setup repairs sparseness.
1468     assert(mm-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1469     assert(mm2==NULL || mm2-&gt;verify_sparse(), &quot;please, no dups of base&quot;);
1470 
1471     _mm  = mm;
1472     _mm_base = mm-&gt;base_memory();
1473     _mm2 = mm2;
1474     _cnt = mm-&gt;req();
1475     _idx = Compile::AliasIdxBot-1; // start at the base memory
1476     _mem = NULL;
1477     _mem2 = NULL;
1478   }
1479 
1480 #ifdef ASSERT
1481   Node* check_memory() const {
1482     if (at_base_memory())
1483       return _mm-&gt;base_memory();
1484     else if ((uint)_idx &lt; _mm-&gt;req() &amp;&amp; !_mm-&gt;in(_idx)-&gt;is_top())
1485       return _mm-&gt;memory_at(_idx);
1486     else
1487       return _mm_base;
1488   }
1489   Node* check_memory2() const {
1490     return at_base_memory()? _mm2-&gt;base_memory(): _mm2-&gt;memory_at(_idx);
1491   }
1492 #endif
1493 
1494   static bool match_memory(Node* mem, const MergeMemNode* mm, int idx) PRODUCT_RETURN0;
1495   void assert_synch() const {
1496     assert(!_mem || _idx &gt;= _cnt || match_memory(_mem, _mm, _idx),
1497            &quot;no side-effects except through the stream&quot;);
1498   }
1499 
1500  public:
1501 
1502   // expected usages:
1503   // for (MergeMemStream mms(mem-&gt;is_MergeMem()); next_non_empty(); ) { ... }
1504   // for (MergeMemStream mms(mem1, mem2); next_non_empty2(); ) { ... }
1505 
1506   // iterate over one merge
1507   MergeMemStream(MergeMemNode* mm) {
1508     mm-&gt;iteration_setup();
1509     init(mm);
1510     debug_only(_cnt2 = 999);
1511   }
1512   // iterate in parallel over two merges
1513   // only iterates through non-empty elements of mm2
1514   MergeMemStream(MergeMemNode* mm, const MergeMemNode* mm2) {
1515     assert(mm2, &quot;second argument must be a MergeMem also&quot;);
1516     ((MergeMemNode*)mm2)-&gt;iteration_setup();  // update hidden state
1517     mm-&gt;iteration_setup(mm2);
1518     init(mm, mm2);
1519     _cnt2 = mm2-&gt;req();
1520   }
1521 #ifdef ASSERT
1522   ~MergeMemStream() {
1523     assert_synch();
1524   }
1525 #endif
1526 
1527   MergeMemNode* all_memory() const {
1528     return _mm;
1529   }
1530   Node* base_memory() const {
1531     assert(_mm_base == _mm-&gt;base_memory(), &quot;no update to base memory, please&quot;);
1532     return _mm_base;
1533   }
1534   const MergeMemNode* all_memory2() const {
1535     assert(_mm2 != NULL, &quot;&quot;);
1536     return _mm2;
1537   }
1538   bool at_base_memory() const {
1539     return _idx == Compile::AliasIdxBot;
1540   }
1541   int alias_idx() const {
1542     assert(_mem, &quot;must call next 1st&quot;);
1543     return _idx;
1544   }
1545 
1546   const TypePtr* adr_type() const {
1547     return Compile::current()-&gt;get_adr_type(alias_idx());
1548   }
1549 
1550   const TypePtr* adr_type(Compile* C) const {
1551     return C-&gt;get_adr_type(alias_idx());
1552   }
1553   bool is_empty() const {
1554     assert(_mem, &quot;must call next 1st&quot;);
1555     assert(_mem-&gt;is_top() == (_mem==_mm-&gt;empty_memory()), &quot;correct sentinel&quot;);
1556     return _mem-&gt;is_top();
1557   }
1558   bool is_empty2() const {
1559     assert(_mem2, &quot;must call next 1st&quot;);
1560     assert(_mem2-&gt;is_top() == (_mem2==_mm2-&gt;empty_memory()), &quot;correct sentinel&quot;);
1561     return _mem2-&gt;is_top();
1562   }
1563   Node* memory() const {
1564     assert(!is_empty(), &quot;must not be empty&quot;);
1565     assert_synch();
1566     return _mem;
1567   }
1568   // get the current memory, regardless of empty or non-empty status
1569   Node* force_memory() const {
1570     assert(!is_empty() || !at_base_memory(), &quot;&quot;);
1571     // Use _mm_base to defend against updates to _mem-&gt;base_memory().
1572     Node *mem = _mem-&gt;is_top() ? _mm_base : _mem;
1573     assert(mem == check_memory(), &quot;&quot;);
1574     return mem;
1575   }
1576   Node* memory2() const {
1577     assert(_mem2 == check_memory2(), &quot;&quot;);
1578     return _mem2;
1579   }
1580   void set_memory(Node* mem) {
1581     if (at_base_memory()) {
1582       // Note that this does not change the invariant _mm_base.
1583       _mm-&gt;set_base_memory(mem);
1584     } else {
1585       _mm-&gt;set_memory_at(_idx, mem);
1586     }
1587     _mem = mem;
1588     assert_synch();
1589   }
1590 
1591   // Recover from a side effect to the MergeMemNode.
1592   void set_memory() {
1593     _mem = _mm-&gt;in(_idx);
1594   }
1595 
1596   bool next()  { return next(false); }
1597   bool next2() { return next(true); }
1598 
1599   bool next_non_empty()  { return next_non_empty(false); }
1600   bool next_non_empty2() { return next_non_empty(true); }
1601   // next_non_empty2 can yield states where is_empty() is true
1602 
1603  private:
1604   // find the next item, which might be empty
1605   bool next(bool have_mm2) {
1606     assert((_mm2 != NULL) == have_mm2, &quot;use other next&quot;);
1607     assert_synch();
1608     if (++_idx &lt; _cnt) {
1609       // Note:  This iterator allows _mm to be non-sparse.
1610       // It behaves the same whether _mem is top or base_memory.
1611       _mem = _mm-&gt;in(_idx);
1612       if (have_mm2)
1613         _mem2 = _mm2-&gt;in((_idx &lt; _cnt2) ? _idx : Compile::AliasIdxTop);
1614       return true;
1615     }
1616     return false;
1617   }
1618 
1619   // find the next non-empty item
1620   bool next_non_empty(bool have_mm2) {
1621     while (next(have_mm2)) {
1622       if (!is_empty()) {
1623         // make sure _mem2 is filled in sensibly
1624         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1625         return true;
1626       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1627         return true;   // is_empty() == true
1628       }
1629     }
1630     return false;
1631   }
1632 };
1633 
<a name="31" id="anc31"></a>



































1634 //------------------------------Prefetch---------------------------------------
1635 
1636 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1637 class PrefetchAllocationNode : public Node {
1638 public:
1639   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1640   virtual int Opcode() const;
1641   virtual uint ideal_reg() const { return NotAMachineReg; }
1642   virtual uint match_edge(uint idx) const { return idx==2; }
1643   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1644 };
1645 
1646 #endif // SHARE_OPTO_MEMNODE_HPP
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/rootnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="regmask.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rootnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/rootnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45   }
 46 
 47   // I used to do tail-splitting in the Ideal graph here, but it does not
 48   // work.  The tail-splitting forces values live into the Return to be
 49   // ready at a point which dominates the split returns.  This forces Stores
 50   // to be hoisted high.  The &quot;proper&quot; fix would be to split Stores down
 51   // each path, but this makes the split unprofitable.  If we want to do this
 52   // optimization, it needs to be done after allocation so we can count all
 53   // the instructions needing to be cloned in the cost metric.
 54 
 55   // There used to be a spoof here for caffeine marks which completely
 56   // eliminated very simple self-recursion recursions, but it&#39;s not worth it.
 57   // Deep inlining of self-calls gets nearly all of the same benefits.
 58   // If we want to get the rest of the win later, we should pattern match
 59   // simple recursive call trees to closed-form solutions.
 60 
 61   return modified ? this : NULL;
 62 }
 63 
 64 //=============================================================================
<span class="line-modified"> 65 HaltNode::HaltNode( Node *ctrl, Node *frameptr ) : Node(TypeFunc::Parms) {</span>

 66   Node* top = Compile::current()-&gt;top();
 67   init_req(TypeFunc::Control,  ctrl        );
 68   init_req(TypeFunc::I_O,      top);
 69   init_req(TypeFunc::Memory,   top);
 70   init_req(TypeFunc::FramePtr, frameptr    );
 71   init_req(TypeFunc::ReturnAdr,top);
 72 }
 73 
 74 const Type *HaltNode::bottom_type() const { return Type::BOTTOM; }
 75 
 76 //------------------------------Ideal------------------------------------------
 77 Node *HaltNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 78   return remove_dead_region(phase, can_reshape) ? this : NULL;
 79 }
 80 
 81 //------------------------------Value------------------------------------------
 82 const Type* HaltNode::Value(PhaseGVN* phase) const {
 83   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 84     ? Type::TOP
 85     : Type::BOTTOM;
</pre>
</td>
<td>
<hr />
<pre>
 45   }
 46 
 47   // I used to do tail-splitting in the Ideal graph here, but it does not
 48   // work.  The tail-splitting forces values live into the Return to be
 49   // ready at a point which dominates the split returns.  This forces Stores
 50   // to be hoisted high.  The &quot;proper&quot; fix would be to split Stores down
 51   // each path, but this makes the split unprofitable.  If we want to do this
 52   // optimization, it needs to be done after allocation so we can count all
 53   // the instructions needing to be cloned in the cost metric.
 54 
 55   // There used to be a spoof here for caffeine marks which completely
 56   // eliminated very simple self-recursion recursions, but it&#39;s not worth it.
 57   // Deep inlining of self-calls gets nearly all of the same benefits.
 58   // If we want to get the rest of the win later, we should pattern match
 59   // simple recursive call trees to closed-form solutions.
 60 
 61   return modified ? this : NULL;
 62 }
 63 
 64 //=============================================================================
<span class="line-modified"> 65 HaltNode::HaltNode(Node* ctrl, Node* frameptr, const char* halt_reason) : Node(TypeFunc::Parms), _halt_reason(halt_reason) {</span>
<span class="line-added"> 66   init_class_id(Class_Halt);</span>
 67   Node* top = Compile::current()-&gt;top();
 68   init_req(TypeFunc::Control,  ctrl        );
 69   init_req(TypeFunc::I_O,      top);
 70   init_req(TypeFunc::Memory,   top);
 71   init_req(TypeFunc::FramePtr, frameptr    );
 72   init_req(TypeFunc::ReturnAdr,top);
 73 }
 74 
 75 const Type *HaltNode::bottom_type() const { return Type::BOTTOM; }
 76 
 77 //------------------------------Ideal------------------------------------------
 78 Node *HaltNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 79   return remove_dead_region(phase, can_reshape) ? this : NULL;
 80 }
 81 
 82 //------------------------------Value------------------------------------------
 83 const Type* HaltNode::Value(PhaseGVN* phase) const {
 84   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 85     ? Type::TOP
 86     : Type::BOTTOM;
</pre>
</td>
</tr>
</table>
<center><a href="regmask.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="rootnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
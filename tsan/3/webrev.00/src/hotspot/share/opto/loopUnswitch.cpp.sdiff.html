<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopUnswitch.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopUnswitch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 38 //  loop                           loop
 39 //    stmt1                          stmt1
 40 //    if (invariant-test) then       stmt2
 41 //      stmt2                        stmt4
 42 //    else                         endloop
 43 //      stmt3                    else
 44 //    endif                        predicate [clone]
 45 //    stmt4                        loop [clone]
 46 //  endloop                          stmt1 [clone]
 47 //                                   stmt3
 48 //                                   stmt4 [clone]
 49 //                                 endloop
 50 //                               endif
 51 //
 52 // Note: the &quot;else&quot; clause may be empty
 53 
 54 //------------------------------policy_unswitching-----------------------------
 55 // Return TRUE or FALSE if the loop should be unswitched
 56 // (ie. clone loop with an invariant test that does not exit the loop)
 57 bool IdealLoopTree::policy_unswitching( PhaseIdealLoop *phase ) const {
<span class="line-modified"> 58   if( !LoopUnswitching ) {</span>
 59     return false;
 60   }
 61   if (!_head-&gt;is_Loop()) {
 62     return false;
 63   }
 64 



 65   // check for vectorized loops, any unswitching was already applied
<span class="line-modified"> 66   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) {</span>
 67     return false;
 68   }
 69 
<span class="line-removed"> 70   int nodes_left = phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes();</span>
<span class="line-removed"> 71   if ((int)(2 * _body.size()) &gt; nodes_left) {</span>
<span class="line-removed"> 72     return false; // Too speculative if running low on nodes.</span>
<span class="line-removed"> 73   }</span>
 74   LoopNode* head = _head-&gt;as_Loop();
 75   if (head-&gt;unswitch_count() + 1 &gt; head-&gt;unswitch_max()) {
 76     return false;
 77   }
<span class="line-modified"> 78   return phase-&gt;find_unswitching_candidate(this) != NULL;</span>





 79 }
 80 
 81 //------------------------------find_unswitching_candidate-----------------------------
 82 // Find candidate &quot;if&quot; for unswitching
 83 IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {
 84 
 85   // Find first invariant test that doesn&#39;t exit the loop
 86   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
 87   IfNode* unswitch_iff = NULL;
 88   Node* n = head-&gt;in(LoopNode::LoopBackControl);
 89   while (n != head) {
 90     Node* n_dom = idom(n);
 91     if (n-&gt;is_Region()) {
 92       if (n_dom-&gt;is_If()) {
 93         IfNode* iff = n_dom-&gt;as_If();
 94         if (iff-&gt;in(1)-&gt;is_Bool()) {
 95           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 96           if (bol-&gt;in(1)-&gt;is_Cmp()) {
 97             // If condition is invariant and not a loop exit,
 98             // then found reason to unswitch.
 99             if (loop-&gt;is_invariant(bol) &amp;&amp; !loop-&gt;is_loop_exit(iff)) {
100               unswitch_iff = iff;
101             }
102           }
103         }
104       }
105     }
106     n = n_dom;
107   }
108   return unswitch_iff;
109 }
110 
111 //------------------------------do_unswitching-----------------------------
112 // Clone loop with an invariant test (that does not exit) and
113 // insert a clone of the test that selects which version to
114 // execute.
<span class="line-modified">115 void PhaseIdealLoop::do_unswitching (IdealLoopTree *loop, Node_List &amp;old_new) {</span>
116 
<span class="line-removed">117   // Find first invariant test that doesn&#39;t exit the loop</span>
118   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
<span class="line-modified">119 </span>












120   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);
121   assert(unswitch_iff != NULL, &quot;should be at least one&quot;);
122 
123 #ifndef PRODUCT
124   if (TraceLoopOpts) {
125     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
126     loop-&gt;dump_head();
127   }
128 #endif
129 
130   // Need to revert back to normal loop
131   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
132     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
133   }
134 
135   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
136 
137 #ifdef ASSERT
138   Node* uniqc = proj_true-&gt;unique_ctrl_out();
<span class="line-modified">139   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);</span>
140   Node* predicate = find_predicate(entry);
141   if (predicate != NULL) {
142     entry = skip_loop_predicates(entry);
143   }
144   if (predicate != NULL &amp;&amp; UseLoopPredicate) {
145     // We may have two predicates, find first.
146     Node* n = find_predicate(entry);
147     if (n != NULL) {
148       predicate = n;
149       entry = skip_loop_predicates(entry);
150     }
151   }
152   if (predicate != NULL &amp;&amp; UseProfiledLoopPredicate) {
153     entry = find_predicate(entry);
154     if (entry != NULL) predicate = entry;
155   }
156   if (predicate != NULL) predicate = predicate-&gt;in(0);
157   assert(proj_true-&gt;is_IfTrue() &amp;&amp;
158          (predicate == NULL &amp;&amp; uniqc == head &amp;&amp; !head-&gt;is_strip_mined() ||
159           predicate == NULL &amp;&amp; uniqc == head-&gt;in(LoopNode::EntryControl) &amp;&amp; head-&gt;is_strip_mined() ||
</pre>
<hr />
<pre>
241   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
242   _igvn.rehash_node_delayed(entry);
243   IdealLoopTree* outer_loop = loop-&gt;_parent;
244 
245   head-&gt;verify_strip_mined(1);
246 
247   Node *cont      = _igvn.intcon(1);
248   set_ctrl(cont, C-&gt;root());
249   Node* opq       = new Opaque1Node(C, cont);
250   register_node(opq, outer_loop, entry, dom_depth(entry));
251   Node *bol       = new Conv2BNode(opq);
252   register_node(bol, outer_loop, entry, dom_depth(entry));
253   IfNode* iff = (opcode == Op_RangeCheck) ? new RangeCheckNode(entry, bol, PROB_MAX, COUNT_UNKNOWN) :
254     new IfNode(entry, bol, PROB_MAX, COUNT_UNKNOWN);
255   register_node(iff, outer_loop, entry, dom_depth(entry));
256   ProjNode* iffast = new IfTrueNode(iff);
257   register_node(iffast, outer_loop, iff, dom_depth(iff));
258   ProjNode* ifslow = new IfFalseNode(iff);
259   register_node(ifslow, outer_loop, iff, dom_depth(iff));
260 
<span class="line-modified">261   // Clone the loop body.  The clone becomes the fast loop.  The</span>
262   // original pre-header will (illegally) have 3 control users
263   // (old &amp; new loops &amp; new if).
264   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), mode, iff);
265   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
266 
267   // Fast (true) control
268   Node* iffast_pred = clone_loop_predicates(entry, iffast, !counted_loop);
269 
270   // Slow (false) control
271   Node* ifslow_pred = clone_loop_predicates(entry, ifslow, !counted_loop);
272 
273   Node* l = head-&gt;skip_strip_mined();
274   _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);
275   set_idom(l, iffast_pred, dom_depth(l));
276   LoopNode* slow_l = old_new[head-&gt;_idx]-&gt;as_Loop()-&gt;skip_strip_mined();
277   _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);
278   set_idom(slow_l, ifslow_pred, dom_depth(l));
279 
280   recompute_dom_depth();
281 
282   return iffast;
283 }
284 
285 LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {
286   Node_List old_new;
287   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
288   bool counted_loop = head-&gt;is_CountedLoop();
289   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
290   _igvn.rehash_node_delayed(entry);
291   IdealLoopTree* outer_loop = head-&gt;is_strip_mined() ? loop-&gt;_parent-&gt;_parent : loop-&gt;_parent;
292 
293   ConINode* const_1 = _igvn.intcon(1);
294   set_ctrl(const_1, C-&gt;root());
295   IfNode* iff = new IfNode(entry, const_1, PROB_MAX, COUNT_UNKNOWN);
296   register_node(iff, outer_loop, entry, dom_depth(entry));
297   ProjNode* iffast = new IfTrueNode(iff);
298   register_node(iffast, outer_loop, iff, dom_depth(iff));
299   ProjNode* ifslow = new IfFalseNode(iff);
300   register_node(ifslow, outer_loop, iff, dom_depth(iff));
301 
<span class="line-modified">302   // Clone the loop body.  The clone becomes the fast loop.  The</span>
303   // original pre-header will (illegally) have 3 control users
304   // (old &amp; new loops &amp; new if).
305   clone_loop(loop, old_new, dom_depth(head), CloneIncludesStripMined, iff);
306   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
307 
308   LoopNode* slow_head = old_new[head-&gt;_idx]-&gt;as_Loop();
309 
310 #ifndef PRODUCT
311   if (TraceLoopOpts) {
312     tty-&gt;print_cr(&quot;PhaseIdealLoop::create_reserve_version_of_loop:&quot;);
313     tty-&gt;print(&quot;\t iff = %d, &quot;, iff-&gt;_idx); iff-&gt;dump();
314     tty-&gt;print(&quot;\t iffast = %d, &quot;, iffast-&gt;_idx); iffast-&gt;dump();
315     tty-&gt;print(&quot;\t ifslow = %d, &quot;, ifslow-&gt;_idx); ifslow-&gt;dump();
316     tty-&gt;print(&quot;\t before replace_input_of: head = %d, &quot;, head-&gt;_idx); head-&gt;dump();
317     tty-&gt;print(&quot;\t before replace_input_of: slow_head = %d, &quot;, slow_head-&gt;_idx); slow_head-&gt;dump();
318   }
319 #endif
320 
321   // Fast (true) control
322   _igvn.replace_input_of(head-&gt;skip_strip_mined(), LoopNode::EntryControl, iffast);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 38 //  loop                           loop
 39 //    stmt1                          stmt1
 40 //    if (invariant-test) then       stmt2
 41 //      stmt2                        stmt4
 42 //    else                         endloop
 43 //      stmt3                    else
 44 //    endif                        predicate [clone]
 45 //    stmt4                        loop [clone]
 46 //  endloop                          stmt1 [clone]
 47 //                                   stmt3
 48 //                                   stmt4 [clone]
 49 //                                 endloop
 50 //                               endif
 51 //
 52 // Note: the &quot;else&quot; clause may be empty
 53 
 54 //------------------------------policy_unswitching-----------------------------
 55 // Return TRUE or FALSE if the loop should be unswitched
 56 // (ie. clone loop with an invariant test that does not exit the loop)
 57 bool IdealLoopTree::policy_unswitching( PhaseIdealLoop *phase ) const {
<span class="line-modified"> 58   if (!LoopUnswitching) {</span>
 59     return false;
 60   }
 61   if (!_head-&gt;is_Loop()) {
 62     return false;
 63   }
 64 
<span class="line-added"> 65   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added"> 66   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added"> 67 </span>
 68   // check for vectorized loops, any unswitching was already applied
<span class="line-modified"> 69   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
 70     return false;
 71   }
 72 




 73   LoopNode* head = _head-&gt;as_Loop();
 74   if (head-&gt;unswitch_count() + 1 &gt; head-&gt;unswitch_max()) {
 75     return false;
 76   }
<span class="line-modified"> 77   if (phase-&gt;find_unswitching_candidate(this) == NULL) {</span>
<span class="line-added"> 78     return false;</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   // Too speculative if running low on nodes.</span>
<span class="line-added"> 82   return phase-&gt;may_require_nodes(est_loop_clone_sz(2));</span>
 83 }
 84 
 85 //------------------------------find_unswitching_candidate-----------------------------
 86 // Find candidate &quot;if&quot; for unswitching
 87 IfNode* PhaseIdealLoop::find_unswitching_candidate(const IdealLoopTree *loop) const {
 88 
 89   // Find first invariant test that doesn&#39;t exit the loop
 90   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
 91   IfNode* unswitch_iff = NULL;
 92   Node* n = head-&gt;in(LoopNode::LoopBackControl);
 93   while (n != head) {
 94     Node* n_dom = idom(n);
 95     if (n-&gt;is_Region()) {
 96       if (n_dom-&gt;is_If()) {
 97         IfNode* iff = n_dom-&gt;as_If();
 98         if (iff-&gt;in(1)-&gt;is_Bool()) {
 99           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
100           if (bol-&gt;in(1)-&gt;is_Cmp()) {
101             // If condition is invariant and not a loop exit,
102             // then found reason to unswitch.
103             if (loop-&gt;is_invariant(bol) &amp;&amp; !loop-&gt;is_loop_exit(iff)) {
104               unswitch_iff = iff;
105             }
106           }
107         }
108       }
109     }
110     n = n_dom;
111   }
112   return unswitch_iff;
113 }
114 
115 //------------------------------do_unswitching-----------------------------
116 // Clone loop with an invariant test (that does not exit) and
117 // insert a clone of the test that selects which version to
118 // execute.
<span class="line-modified">119 void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
120 

121   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
<span class="line-modified">122   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);</span>
<span class="line-added">123   if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != NULL</span>
<span class="line-added">124       || (UseProfiledLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != NULL)</span>
<span class="line-added">125       || (UseLoopPredicate &amp;&amp; find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != NULL)) {</span>
<span class="line-added">126     assert(entry-&gt;is_IfProj(), &quot;sanity - must be ifProj since there is at least one predicate&quot;);</span>
<span class="line-added">127     if (entry-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">128       // Bailout if there are loop predicates from which there are additional control dependencies (i.e. from</span>
<span class="line-added">129       // loop entry &#39;entry&#39;) to previously partially peeled statements since this case is not handled and can lead</span>
<span class="line-added">130       // to wrong execution. Remove this bailout, once this is fixed.</span>
<span class="line-added">131       return;</span>
<span class="line-added">132     }</span>
<span class="line-added">133   }</span>
<span class="line-added">134   // Find first invariant test that doesn&#39;t exit the loop</span>
135   IfNode* unswitch_iff = find_unswitching_candidate((const IdealLoopTree *)loop);
136   assert(unswitch_iff != NULL, &quot;should be at least one&quot;);
137 
138 #ifndef PRODUCT
139   if (TraceLoopOpts) {
140     tty-&gt;print(&quot;Unswitch   %d &quot;, head-&gt;unswitch_count()+1);
141     loop-&gt;dump_head();
142   }
143 #endif
144 
145   // Need to revert back to normal loop
146   if (head-&gt;is_CountedLoop() &amp;&amp; !head-&gt;as_CountedLoop()-&gt;is_normal_loop()) {
147     head-&gt;as_CountedLoop()-&gt;set_normal_loop();
148   }
149 
150   ProjNode* proj_true = create_slow_version_of_loop(loop, old_new, unswitch_iff-&gt;Opcode(), CloneIncludesStripMined);
151 
152 #ifdef ASSERT
153   Node* uniqc = proj_true-&gt;unique_ctrl_out();
<span class="line-modified">154   entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);</span>
155   Node* predicate = find_predicate(entry);
156   if (predicate != NULL) {
157     entry = skip_loop_predicates(entry);
158   }
159   if (predicate != NULL &amp;&amp; UseLoopPredicate) {
160     // We may have two predicates, find first.
161     Node* n = find_predicate(entry);
162     if (n != NULL) {
163       predicate = n;
164       entry = skip_loop_predicates(entry);
165     }
166   }
167   if (predicate != NULL &amp;&amp; UseProfiledLoopPredicate) {
168     entry = find_predicate(entry);
169     if (entry != NULL) predicate = entry;
170   }
171   if (predicate != NULL) predicate = predicate-&gt;in(0);
172   assert(proj_true-&gt;is_IfTrue() &amp;&amp;
173          (predicate == NULL &amp;&amp; uniqc == head &amp;&amp; !head-&gt;is_strip_mined() ||
174           predicate == NULL &amp;&amp; uniqc == head-&gt;in(LoopNode::EntryControl) &amp;&amp; head-&gt;is_strip_mined() ||
</pre>
<hr />
<pre>
256   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
257   _igvn.rehash_node_delayed(entry);
258   IdealLoopTree* outer_loop = loop-&gt;_parent;
259 
260   head-&gt;verify_strip_mined(1);
261 
262   Node *cont      = _igvn.intcon(1);
263   set_ctrl(cont, C-&gt;root());
264   Node* opq       = new Opaque1Node(C, cont);
265   register_node(opq, outer_loop, entry, dom_depth(entry));
266   Node *bol       = new Conv2BNode(opq);
267   register_node(bol, outer_loop, entry, dom_depth(entry));
268   IfNode* iff = (opcode == Op_RangeCheck) ? new RangeCheckNode(entry, bol, PROB_MAX, COUNT_UNKNOWN) :
269     new IfNode(entry, bol, PROB_MAX, COUNT_UNKNOWN);
270   register_node(iff, outer_loop, entry, dom_depth(entry));
271   ProjNode* iffast = new IfTrueNode(iff);
272   register_node(iffast, outer_loop, iff, dom_depth(iff));
273   ProjNode* ifslow = new IfFalseNode(iff);
274   register_node(ifslow, outer_loop, iff, dom_depth(iff));
275 
<span class="line-modified">276   // Clone the loop body.  The clone becomes the slow loop.  The</span>
277   // original pre-header will (illegally) have 3 control users
278   // (old &amp; new loops &amp; new if).
279   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), mode, iff);
280   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
281 
282   // Fast (true) control
283   Node* iffast_pred = clone_loop_predicates(entry, iffast, !counted_loop);
284 
285   // Slow (false) control
286   Node* ifslow_pred = clone_loop_predicates(entry, ifslow, !counted_loop);
287 
288   Node* l = head-&gt;skip_strip_mined();
289   _igvn.replace_input_of(l, LoopNode::EntryControl, iffast_pred);
290   set_idom(l, iffast_pred, dom_depth(l));
291   LoopNode* slow_l = old_new[head-&gt;_idx]-&gt;as_Loop()-&gt;skip_strip_mined();
292   _igvn.replace_input_of(slow_l, LoopNode::EntryControl, ifslow_pred);
293   set_idom(slow_l, ifslow_pred, dom_depth(l));
294 
295   recompute_dom_depth();
296 
297   return iffast;
298 }
299 
300 LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {
301   Node_List old_new;
302   LoopNode* head  = loop-&gt;_head-&gt;as_Loop();
303   bool counted_loop = head-&gt;is_CountedLoop();
304   Node*     entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
305   _igvn.rehash_node_delayed(entry);
306   IdealLoopTree* outer_loop = head-&gt;is_strip_mined() ? loop-&gt;_parent-&gt;_parent : loop-&gt;_parent;
307 
308   ConINode* const_1 = _igvn.intcon(1);
309   set_ctrl(const_1, C-&gt;root());
310   IfNode* iff = new IfNode(entry, const_1, PROB_MAX, COUNT_UNKNOWN);
311   register_node(iff, outer_loop, entry, dom_depth(entry));
312   ProjNode* iffast = new IfTrueNode(iff);
313   register_node(iffast, outer_loop, iff, dom_depth(iff));
314   ProjNode* ifslow = new IfFalseNode(iff);
315   register_node(ifslow, outer_loop, iff, dom_depth(iff));
316 
<span class="line-modified">317   // Clone the loop body.  The clone becomes the slow loop.  The</span>
318   // original pre-header will (illegally) have 3 control users
319   // (old &amp; new loops &amp; new if).
320   clone_loop(loop, old_new, dom_depth(head), CloneIncludesStripMined, iff);
321   assert(old_new[head-&gt;_idx]-&gt;is_Loop(), &quot;&quot; );
322 
323   LoopNode* slow_head = old_new[head-&gt;_idx]-&gt;as_Loop();
324 
325 #ifndef PRODUCT
326   if (TraceLoopOpts) {
327     tty-&gt;print_cr(&quot;PhaseIdealLoop::create_reserve_version_of_loop:&quot;);
328     tty-&gt;print(&quot;\t iff = %d, &quot;, iff-&gt;_idx); iff-&gt;dump();
329     tty-&gt;print(&quot;\t iffast = %d, &quot;, iffast-&gt;_idx); iffast-&gt;dump();
330     tty-&gt;print(&quot;\t ifslow = %d, &quot;, ifslow-&gt;_idx); ifslow-&gt;dump();
331     tty-&gt;print(&quot;\t before replace_input_of: head = %d, &quot;, head-&gt;_idx); head-&gt;dump();
332     tty-&gt;print(&quot;\t before replace_input_of: slow_head = %d, &quot;, slow_head-&gt;_idx); slow_head-&gt;dump();
333   }
334 #endif
335 
336   // Fast (true) control
337   _igvn.replace_input_of(head-&gt;skip_strip_mined(), LoopNode::EntryControl, iffast);
</pre>
</td>
</tr>
</table>
<center><a href="loopTransform.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
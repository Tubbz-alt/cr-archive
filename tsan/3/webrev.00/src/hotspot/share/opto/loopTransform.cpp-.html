<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
  48   if( iff-&gt;outcnt() != 2 ) return NULL; // Ignore partially dead tests
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
  52   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(0) )) )
  53     return iff-&gt;raw_out(0);
  54   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(1) )) )
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
  66   for( uint i = 0; i &lt; _body.size(); i++ ) {
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
  87     _phase-&gt;_igvn._worklist.push(cle_out);
  88   }
  89 }
  90 
  91 //------------------------------compute_exact_trip_count-----------------------
  92 // Compute loop trip count if possible. Do not recalculate trip count for
  93 // split loops (pre-main-post) which have their limits and inits behind Opaque node.
  94 void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {
  95   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
  96     return;
  97   }
  98   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
  99   // Trip count may become nonexact for iteration split loops since
 100   // RCE modifies limits. Note, _trip_count value is not reset since
 101   // it is used to limit unrolling of main loop.
 102   cl-&gt;set_nonexact_trip_count();
 103 
 104   // Loop&#39;s test should be part of loop.
 105   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))
 106     return; // Infinite loop
 107 
 108 #ifdef ASSERT
 109   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 110   assert(bt == BoolTest::lt || bt == BoolTest::gt ||
 111          bt == BoolTest::ne, &quot;canonical test is expected&quot;);
 112 #endif
 113 
 114   Node* init_n = cl-&gt;init_trip();
 115   Node* limit_n = cl-&gt;limit();
 116   if (init_n != NULL &amp;&amp; limit_n != NULL) {
 117     // Use longs to avoid integer overflow.
 118     int stride_con = cl-&gt;stride_con();
 119     const TypeInt* init_type = phase-&gt;_igvn.type(init_n)-&gt;is_int();
 120     const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 121     jlong init_con = (stride_con &gt; 0) ? init_type-&gt;_lo : init_type-&gt;_hi;
 122     jlong limit_con = (stride_con &gt; 0) ? limit_type-&gt;_hi : limit_type-&gt;_lo;
 123     int stride_m = stride_con - (stride_con &gt; 0 ? 1 : -1);
 124     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
 125     if (trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint) {
 126       if (init_n-&gt;is_Con() &amp;&amp; limit_n-&gt;is_Con()) {
 127         // Set exact trip count.
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
 148         if (exit-&gt;Opcode() == Op_IfFalse) exit_prob = 1.0 - exit_prob;
 149         if (exit_prob &gt; PROB_MIN) {
 150           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 151           return exit_cnt;
 152         }
 153       }
 154     }
 155   }
 156   if (n-&gt;is_Jump()) {
 157     JumpNode *jmp = n-&gt;as_Jump();
 158     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 159       float* probs = jmp-&gt;_probs;
 160       float exit_prob = 0;
 161       PhaseIdealLoop *phase = _phase;
 162       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 163         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 164         if (!is_member(_phase-&gt;get_loop(u))) {
 165           exit_prob += probs[u-&gt;_con];
 166         }
 167       }
 168       return exit_prob * jmp-&gt;_fcnt;
 169     }
 170   }
 171   return 0;
 172 }
 173 
 174 void IdealLoopTree::compute_profile_trip_cnt(PhaseIdealLoop *phase) {
 175   if (!_head-&gt;is_Loop()) {
 176     return;
 177   }
 178   LoopNode* head = _head-&gt;as_Loop();
 179   if (head-&gt;profile_trip_cnt() != COUNT_UNKNOWN) {
 180     return; // Already computed
 181   }
 182   float trip_cnt = (float)max_jint; // default is big
 183 
 184   Node* back = head-&gt;in(LoopNode::LoopBackControl);
 185   while (back != head) {
 186     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 187         back-&gt;in(0) &amp;&amp;
 188         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 189         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 190         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 191         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 192       break;
 193     }
 194     back = phase-&gt;idom(back);
 195   }
 196   if (back != head) {
 197     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 198            back-&gt;in(0), &quot;if-projection exists&quot;);
 199     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 200     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 201 
 202     // Now compute a loop exit count
 203     float loop_exit_cnt = 0.0f;
 204     if (_child == NULL) {
 205       for( uint i = 0; i &lt; _body.size(); i++ ) {
 206         Node *n = _body[i];
 207         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 208       }
 209     } else {
 210       ResourceMark rm;
 211       Unique_Node_List wq;
 212       wq.push(back);
 213       for (uint i = 0; i &lt; wq.size(); i++) {
 214         Node *n = wq.at(i);
 215         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 216         if (n != head) {
 217           if (n-&gt;is_Region()) {
 218             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 219               wq.push(n-&gt;in(j));
 220             }
 221           } else {
 222             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 223             wq.push(n-&gt;in(0));
 224           }
 225         }
 226       }
 227 
 228     }
 229     if (loop_exit_cnt &gt; 0.0f) {
 230       trip_cnt = (loop_back_cnt + loop_exit_cnt) / loop_exit_cnt;
 231     } else {
 232       // No exit count so use
 233       trip_cnt = loop_back_cnt;
 234     }
 235   } else {
 236     head-&gt;mark_profile_trip_failed();
 237   }
 238 #ifndef PRODUCT
 239   if (TraceProfileTripCount) {
 240     tty-&gt;print_cr(&quot;compute_profile_trip_cnt  lp: %d cnt: %f\n&quot;, head-&gt;_idx, trip_cnt);
 241   }
 242 #endif
 243   head-&gt;set_profile_trip_cnt(trip_cnt);
 244 }
 245 
 246 //---------------------is_invariant_addition-----------------------------
 247 // Return nonzero index of invariant operand for an Add or Sub
 248 // of (nonconstant) invariant and variant values. Helper for reassociate_invariants.
 249 int IdealLoopTree::is_invariant_addition(Node* n, PhaseIdealLoop *phase) {
 250   int op = n-&gt;Opcode();
 251   if (op == Op_AddI || op == Op_SubI) {
 252     bool in1_invar = this-&gt;is_invariant(n-&gt;in(1));
 253     bool in2_invar = this-&gt;is_invariant(n-&gt;in(2));
 254     if (in1_invar &amp;&amp; !in2_invar) return 1;
 255     if (!in1_invar &amp;&amp; in2_invar) return 2;
 256   }
 257   return 0;
 258 }
 259 
 260 //---------------------reassociate_add_sub-----------------------------
 261 // Reassociate invariant add and subtract expressions:
 262 //
 263 // inv1 + (x + inv2)  =&gt;  ( inv1 + inv2) + x
 264 // (x + inv2) + inv1  =&gt;  ( inv1 + inv2) + x
 265 // inv1 + (x - inv2)  =&gt;  ( inv1 - inv2) + x
 266 // inv1 - (inv2 - x)  =&gt;  ( inv1 - inv2) + x
 267 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 268 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 269 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 270 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 271 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 272 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 273 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 274 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 275 //
 276 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 277   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 278   if (is_invariant(n1)) return NULL;
 279   int inv1_idx = is_invariant_addition(n1, phase);
 280   if (!inv1_idx) return NULL;
 281   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 282   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 283   Node* inv1 = n1-&gt;in(inv1_idx);
 284   Node* n2 = n1-&gt;in(3 - inv1_idx);
 285   int inv2_idx = is_invariant_addition(n2, phase);
 286   if (!inv2_idx) return NULL;
 287   Node* x    = n2-&gt;in(3 - inv2_idx);
 288   Node* inv2 = n2-&gt;in(inv2_idx);
 289 
 290   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 291   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 292   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 293   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 294     neg_x    = !neg_x;
 295     neg_inv2 = !neg_inv2;
 296   }
 297   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 298   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 299   Node* n_inv1;
 300   if (neg_inv1) {
 301     Node *zero = phase-&gt;_igvn.intcon(0);
 302     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 303     n_inv1 = new SubINode(zero, inv1);
 304     phase-&gt;register_new_node(n_inv1, inv1_c);
 305   } else {
 306     n_inv1 = inv1;
 307   }
 308   Node* inv;
 309   if (neg_inv2) {
 310     inv = new SubINode(n_inv1, inv2);
 311   } else {
 312     inv = new AddINode(n_inv1, inv2);
 313   }
 314   phase-&gt;register_new_node(inv, phase-&gt;get_early_ctrl(inv));
 315 
 316   Node* addx;
 317   if (neg_x) {
 318     addx = new SubINode(inv, x);
 319   } else {
 320     addx = new AddINode(x, inv);
 321   }
 322   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 323   phase-&gt;_igvn.replace_node(n1, addx);
 324   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 325   _body.yank(n1);
 326   return addx;
 327 }
 328 
 329 //---------------------reassociate_invariants-----------------------------
 330 // Reassociate invariant expressions:
 331 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 332   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 333     Node *n = _body.at(i);
 334     for (int j = 0; j &lt; 5; j++) {
 335       Node* nn = reassociate_add_sub(n, phase);
 336       if (nn == NULL) break;
 337       n = nn; // again
 338     };
 339   }
 340 }
 341 
 342 //------------------------------policy_peeling---------------------------------
 343 // Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can
 344 // make some loop-invariant test (usually a null-check) happen before the loop.
 345 bool IdealLoopTree::policy_peeling( PhaseIdealLoop *phase ) const {
 346   Node *test = ((IdealLoopTree*)this)-&gt;tail();
 347   int  body_size = ((IdealLoopTree*)this)-&gt;_body.size();
 348   // Peeling does loop cloning which can result in O(N^2) node construction
 349   if( body_size &gt; 255 /* Prevent overflow for large body_size */
 350       || (body_size * body_size + phase-&gt;C-&gt;live_nodes()) &gt; phase-&gt;C-&gt;max_node_limit() ) {
 351     return false;           // too large to safely clone
 352   }
 353 
 354   // check for vectorized loops, any peeling done was already applied
 355   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;
 356 
 357   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;trip_count() == 1) {
 358     return false;
 359   }
 360 
 361   while( test != _head ) {      // Scan till run off top of loop
 362     if( test-&gt;is_If() ) {       // Test?
 363       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
 364       if (ctrl-&gt;is_top())
 365         return false;           // Found dead test on live IF?  No peeling!
 366       // Standard IF only has one input value to check for loop invariance
 367       assert(test-&gt;Opcode() == Op_If || test-&gt;Opcode() == Op_CountedLoopEnd || test-&gt;Opcode() == Op_RangeCheck, &quot;Check this code when new subtype is added&quot;);
 368       // Condition is not a member of this loop?
 369       if( !is_member(phase-&gt;get_loop(ctrl)) &amp;&amp;
 370           is_loop_exit(test) )
 371         return true;            // Found reason to peel!
 372     }
 373     // Walk up dominators to loop _head looking for test which is
 374     // executed on every path thru loop.
 375     test = phase-&gt;idom(test);
 376   }
 377   return false;
 378 }
 379 
 380 //------------------------------peeled_dom_test_elim---------------------------
 381 // If we got the effect of peeling, either by actually peeling or by making
 382 // a pre-loop which must execute at least once, we can remove all
 383 // loop-invariant dominated tests in the main body.
 384 void PhaseIdealLoop::peeled_dom_test_elim( IdealLoopTree *loop, Node_List &amp;old_new ) {
 385   bool progress = true;
 386   while( progress ) {
 387     progress = false;           // Reset for next iteration
 388     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 389     Node *test = prev-&gt;in(0);
 390     while( test != loop-&gt;_head ) { // Scan till run off top of loop
 391 
 392       int p_op = prev-&gt;Opcode();
 393       if( (p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;
 394           test-&gt;is_If() &amp;&amp;      // Test?
 395           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 396           // Condition is not a member of this loop?
 397           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 398         // Walk loop body looking for instances of this test
 399         for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
 400           Node *n = loop-&gt;_body.at(i);
 401           if( n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/ ) {
 402             // IfNode was dominated by version in peeled loop body
 403             progress = true;
 404             dominated_by( old_new[prev-&gt;_idx], n );
 405           }
 406         }
 407       }
 408       prev = test;
 409       test = idom(test);
 410     } // End of scan tests in loop
 411 
 412   } // End of while( progress )
 413 }
 414 
 415 //------------------------------do_peeling-------------------------------------
 416 // Peel the first iteration of the given loop.
 417 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 418 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 419 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 420 //         Do this by making the old-loop fall-in edges act as if they came
 421 //         around the loopback from the prior iteration (follow the old-loop
 422 //         backedges) and then map to the new peeled iteration.  This leaves
 423 //         the pre-loop with only 1 user (the new peeled iteration), but the
 424 //         peeled-loop backedge has 2 users.
 425 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 426 //         extra backedge user.
 427 //
 428 //                   orig
 429 //
 430 //                  stmt1
 431 //                    |
 432 //                    v
 433 //              loop predicate
 434 //                    |
 435 //                    v
 436 //                   loop&lt;----+
 437 //                     |      |
 438 //                   stmt2    |
 439 //                     |      |
 440 //                     v      |
 441 //                    if      ^
 442 //                   / \      |
 443 //                  /   \     |
 444 //                 v     v    |
 445 //               false true   |
 446 //               /       \    |
 447 //              /         ----+
 448 //             |
 449 //             v
 450 //           exit
 451 //
 452 //
 453 //            after clone loop
 454 //
 455 //                   stmt1
 456 //                     |
 457 //                     v
 458 //               loop predicate
 459 //                 /       \
 460 //        clone   /         \   orig
 461 //               /           \
 462 //              /             \
 463 //             v               v
 464 //   +----&gt;loop clone          loop&lt;----+
 465 //   |      |                    |      |
 466 //   |    stmt2 clone          stmt2    |
 467 //   |      |                    |      |
 468 //   |      v                    v      |
 469 //   ^      if clone            If      ^
 470 //   |      / \                / \      |
 471 //   |     /   \              /   \     |
 472 //   |    v     v            v     v    |
 473 //   |    true  false      false true   |
 474 //   |    /         \      /       \    |
 475 //   +----           \    /         ----+
 476 //                    \  /
 477 //                    1v v2
 478 //                  region
 479 //                     |
 480 //                     v
 481 //                   exit
 482 //
 483 //
 484 //         after peel and predicate move
 485 //
 486 //                   stmt1
 487 //                    /
 488 //                   /
 489 //        clone     /            orig
 490 //                 /
 491 //                /              +----------+
 492 //               /               |          |
 493 //              /          loop predicate   |
 494 //             /                 |          |
 495 //            v                  v          |
 496 //   TOP--&gt;loop clone          loop&lt;----+   |
 497 //          |                    |      |   |
 498 //        stmt2 clone          stmt2    |   |
 499 //          |                    |      |   ^
 500 //          v                    v      |   |
 501 //          if clone            If      ^   |
 502 //          / \                / \      |   |
 503 //         /   \              /   \     |   |
 504 //        v     v            v     v    |   |
 505 //      true   false      false  true   |   |
 506 //        |         \      /       \    |   |
 507 //        |          \    /         ----+   ^
 508 //        |           \  /                  |
 509 //        |           1v v2                 |
 510 //        v         region                  |
 511 //        |            |                    |
 512 //        |            v                    |
 513 //        |          exit                   |
 514 //        |                                 |
 515 //        +---------------&gt;-----------------+
 516 //
 517 //
 518 //              final graph
 519 //
 520 //                  stmt1
 521 //                    |
 522 //                    v
 523 //                  stmt2 clone
 524 //                    |
 525 //                    v
 526 //                   if clone
 527 //                  / |
 528 //                 /  |
 529 //                v   v
 530 //            false  true
 531 //             |      |
 532 //             |      v
 533 //             | loop predicate
 534 //             |      |
 535 //             |      v
 536 //             |     loop&lt;----+
 537 //             |      |       |
 538 //             |    stmt2     |
 539 //             |      |       |
 540 //             |      v       |
 541 //             v      if      ^
 542 //             |     /  \     |
 543 //             |    /    \    |
 544 //             |   v     v    |
 545 //             | false  true  |
 546 //             |  |        \  |
 547 //             v  v         --+
 548 //            region
 549 //              |
 550 //              v
 551 //             exit
 552 //
 553 void PhaseIdealLoop::do_peeling( IdealLoopTree *loop, Node_List &amp;old_new ) {
 554 
 555   C-&gt;set_major_progress();
 556   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 557   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 558   // iterations adjusted.  Therefore, we need to declare this loop as
 559   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 560   // we can do further RCE.
 561 #ifndef PRODUCT
 562   if (TraceLoopOpts) {
 563     tty-&gt;print(&quot;Peel         &quot;);
 564     loop-&gt;dump_head();
 565   }
 566 #endif
 567   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 568   bool counted_loop = head-&gt;is_CountedLoop();
 569   if (counted_loop) {
 570     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 571     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 572     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 573     if (cl-&gt;is_main_loop()) {
 574       cl-&gt;set_normal_loop();
 575 #ifndef PRODUCT
 576       if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 577         tty-&gt;print(&quot;Peeling a &#39;main&#39; loop; resetting to &#39;normal&#39; &quot;);
 578         loop-&gt;dump_head();
 579       }
 580 #endif
 581     }
 582   }
 583   Node* entry = head-&gt;in(LoopNode::EntryControl);
 584 
 585   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 586   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 587   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 588 
 589   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 590   //         Do this by making the old-loop fall-in edges act as if they came
 591   //         around the loopback from the prior iteration (follow the old-loop
 592   //         backedges) and then map to the new peeled iteration.  This leaves
 593   //         the pre-loop with only 1 user (the new peeled iteration), but the
 594   //         peeled-loop backedge has 2 users.
 595   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 596   _igvn.hash_delete(head-&gt;skip_strip_mined());
 597   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 598   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 599     Node* old = head-&gt;fast_out(j);
 600     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 601       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 602       if (!new_exit_value )     // Backedge value is ALSO loop invariant?
 603         // Then loop body backedge value remains the same.
 604         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 605       _igvn.hash_delete(old);
 606       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 607     }
 608   }
 609 
 610 
 611   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 612   //         extra backedge user.
 613   Node* new_head = old_new[head-&gt;_idx];
 614   _igvn.hash_delete(new_head);
 615   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 616   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 617     Node* use = new_head-&gt;fast_out(j2);
 618     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 619       _igvn.hash_delete(use);
 620       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 621     }
 622   }
 623 
 624 
 625   // Step 4: Correct dom-depth info.  Set to loop-head depth.
 626   int dd = dom_depth(head);
 627   set_idom(head, head-&gt;in(1), dd);
 628   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 629     Node *old = loop-&gt;_body.at(j3);
 630     Node *nnn = old_new[old-&gt;_idx];
 631     if (!has_ctrl(nnn))
 632       set_idom(nnn, idom(nnn), dd-1);
 633   }
 634 
 635   // Now force out all loop-invariant dominating tests.  The optimizer
 636   // finds some, but we _know_ they are all useless.
 637   peeled_dom_test_elim(loop,old_new);
 638 
 639   loop-&gt;record_for_igvn();
 640 }
 641 
 642 #define EMPTY_LOOP_SIZE 7 // number of nodes in an empty loop
 643 
 644 //------------------------------policy_maximally_unroll------------------------
 645 // Calculate exact loop trip count and return true if loop can be maximally
 646 // unrolled.
 647 bool IdealLoopTree::policy_maximally_unroll( PhaseIdealLoop *phase ) const {
 648   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 649   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
 650   if (!cl-&gt;is_valid_counted_loop())
 651     return false; // Malformed counted loop
 652 
 653   if (!cl-&gt;has_exact_trip_count()) {
 654     // Trip count is not exact.
 655     return false;
 656   }
 657 
 658   uint trip_count = cl-&gt;trip_count();
 659   // Note, max_juint is used to indicate unknown trip count.
 660   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
 661   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_uint.&quot;);
 662 
 663   // Real policy: if we maximally unroll, does it get too big?
 664   // Allow the unrolled mess to get larger than standard loop
 665   // size.  After all, it will no longer be a loop.
 666   uint body_size    = _body.size();
 667   uint unroll_limit = (uint)LoopUnrollLimit * 4;
 668   assert( (intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);
 669   if (trip_count &gt; unroll_limit || body_size &gt; unroll_limit) {
 670     return false;
 671   }
 672 
 673   // Fully unroll a loop with few iterations regardless next
 674   // conditions since following loop optimizations will split
 675   // such loop anyway (pre-main-post).
 676   if (trip_count &lt;= 3)
 677     return true;
 678 
 679   // Take into account that after unroll conjoined heads and tails will fold,
 680   // otherwise policy_unroll() may allow more unrolling than max unrolling.
 681   uint new_body_size = EMPTY_LOOP_SIZE + (body_size - EMPTY_LOOP_SIZE) * trip_count;
 682   uint tst_body_size = (new_body_size - EMPTY_LOOP_SIZE) / trip_count + EMPTY_LOOP_SIZE;
 683   if (body_size != tst_body_size) // Check for int overflow
 684     return false;
 685   if (new_body_size &gt; unroll_limit ||
 686       // Unrolling can result in a large amount of node construction
 687       new_body_size &gt;= phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes()) {
 688     return false;
 689   }
 690 
 691   // Do not unroll a loop with String intrinsics code.
 692   // String intrinsics are large and have loops.
 693   for (uint k = 0; k &lt; _body.size(); k++) {
 694     Node* n = _body.at(k);
 695     switch (n-&gt;Opcode()) {
 696       case Op_StrComp:
 697       case Op_StrEquals:
 698       case Op_StrIndexOf:
 699       case Op_StrIndexOfChar:
 700       case Op_EncodeISOArray:
 701       case Op_AryEq:
 702       case Op_HasNegatives: {
 703         return false;
 704       }
 705 #if INCLUDE_RTM_OPT
 706       case Op_FastLock:
 707       case Op_FastUnlock: {
 708         // Don&#39;t unroll RTM locking code because it is large.
 709         if (UseRTMLocking) {
 710           return false;
 711         }
 712       }
 713 #endif
 714     } // switch
 715   }
 716 
 717   return true; // Do maximally unroll
 718 }
 719 
 720 
 721 //------------------------------policy_unroll----------------------------------
 722 // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if
 723 // the loop is a CountedLoop and the body is small enough.
 724 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 725 
 726   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 727   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 728 
 729   if (!cl-&gt;is_valid_counted_loop())
 730     return false; // Malformed counted loop
 731 
 732   // Protect against over-unrolling.
 733   // After split at least one iteration will be executed in pre-loop.
 734   if (cl-&gt;trip_count() &lt;= (uint)(cl-&gt;is_normal_loop() ? 2 : 1)) return false;
 735 
 736   _local_loop_unroll_limit = LoopUnrollLimit;
 737   _local_loop_unroll_factor = 4;
 738   int future_unroll_ct = cl-&gt;unrolled_count() * 2;
 739   if (!cl-&gt;is_vectorized_loop()) {
 740     if (future_unroll_ct &gt; LoopMaxUnroll) return false;
 741   } else {
 742     // obey user constraints on vector mapped loops with additional unrolling applied
 743     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
 744     if ((future_unroll_ct / unroll_constraint) &gt; LoopMaxUnroll) return false;
 745   }
 746 
 747   // Check for initial stride being a small enough constant
 748   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_ct) return false;
 749 
 750   // Don&#39;t unroll if the next round of unrolling would push us
 751   // over the expected trip count of the loop.  One is subtracted
 752   // from the expected trip count because the pre-loop normally
 753   // executes 1 iteration.
 754   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 755       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
 756       future_unroll_ct        &gt; UnrollLimitForProfileCheck &amp;&amp;
 757       (float)future_unroll_ct &gt; cl-&gt;profile_trip_cnt() - 1.0) {
 758     return false;
 759   }
 760 
 761   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 762   //   the residual iterations are more than 10% of the trip count
 763   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 764   //   Progress defined as current size less than 20% larger than previous size.
 765   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
 766       future_unroll_ct &gt; LoopUnrollMin &amp;&amp;
 767       (future_unroll_ct - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;
 768       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 769     return false;
 770   }
 771 
 772   Node *init_n = cl-&gt;init_trip();
 773   Node *limit_n = cl-&gt;limit();
 774   int stride_con = cl-&gt;stride_con();
 775   if (limit_n == NULL) return false; // We will dereference it below.
 776 
 777   // Non-constant bounds.
 778   // Protect against over-unrolling when init or/and limit are not constant
 779   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 780   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 781     Node* phi = cl-&gt;phi();
 782     if (phi != NULL) {
 783       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 784       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 785       int next_stride = stride_con * 2; // stride after this unroll
 786       if (next_stride &gt; 0) {
 787         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
 788             iv_type-&gt;_lo + next_stride &gt;  iv_type-&gt;_hi) {
 789           return false;  // over-unrolling
 790         }
 791       } else if (next_stride &lt; 0) {
 792         if (iv_type-&gt;_hi + next_stride &gt;= iv_type-&gt;_hi || // overflow
 793             iv_type-&gt;_hi + next_stride &lt;  iv_type-&gt;_lo) {
 794           return false;  // over-unrolling
 795         }
 796       }
 797     }
 798   }
 799 
 800   // After unroll limit will be adjusted: new_limit = limit-stride.
 801   // Bailout if adjustment overflow.
 802   const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 803   if ((stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &gt;= limit_type-&gt;_hi)) ||
 804       (stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &lt;= limit_type-&gt;_lo)))
 805     return false;  // overflow
 806 
 807   // Adjust body_size to determine if we unroll or not
 808   uint body_size = _body.size();
 809   // Key test to unroll loop in CRC32 java code
 810   int xors_in_loop = 0;
 811   // Also count ModL, DivL and MulL which expand mightly
 812   for (uint k = 0; k &lt; _body.size(); k++) {
 813     Node* n = _body.at(k);
 814     switch (n-&gt;Opcode()) {
 815       case Op_XorI: xors_in_loop++; break; // CRC32 java code
 816       case Op_ModL: body_size += 30; break;
 817       case Op_DivL: body_size += 30; break;
 818       case Op_MulL: body_size += 10; break;
 819       case Op_StrComp:
 820       case Op_StrEquals:
 821       case Op_StrIndexOf:
 822       case Op_StrIndexOfChar:
 823       case Op_EncodeISOArray:
 824       case Op_AryEq:
 825       case Op_HasNegatives: {
 826         // Do not unroll a loop with String intrinsics code.
 827         // String intrinsics are large and have loops.
 828         return false;
 829       }
 830 #if INCLUDE_RTM_OPT
 831       case Op_FastLock:
 832       case Op_FastUnlock: {
 833         // Don&#39;t unroll RTM locking code because it is large.
 834         if (UseRTMLocking) {
 835           return false;
 836         }
 837       }
 838 #endif
 839     } // switch
 840   }
 841 
 842   if (UseSuperWord) {
 843     if (!cl-&gt;is_reduction_loop()) {
 844       phase-&gt;mark_reductions(this);
 845     }
 846 
 847     // Only attempt slp analysis when user controls do not prohibit it
 848     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 849       // Once policy_slp_analysis succeeds, mark the loop with the
 850       // maximal unroll factor so that we minimize analysis passes
 851       if (future_unroll_ct &gt;= _local_loop_unroll_factor) {
 852         policy_unroll_slp_analysis(cl, phase, future_unroll_ct);
 853       }
 854     }
 855   }
 856 
 857   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 858   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 859     LoopMaxUnroll = slp_max_unroll_factor;
 860   }
 861   if (cl-&gt;has_passed_slp()) {
 862     if (slp_max_unroll_factor &gt;= future_unroll_ct) return true;
 863     // Normal case: loop too big
 864     return false;
 865   }
 866 
 867   // Check for being too big
 868   if (body_size &gt; (uint)_local_loop_unroll_limit) {
 869     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; (uint)LoopUnrollLimit * 4) {
 870       return true;
 871     }
 872     // Normal case: loop too big
 873     return false;
 874   }
 875 
 876   if (cl-&gt;do_unroll_only()) {
 877     if (TraceSuperWordLoopUnrollAnalysis) {
 878       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d,factor = %d)\n&quot;, slp_max_unroll_factor, future_unroll_ct);
 879     }
 880   }
 881 
 882   // Unroll once!  (Each trip will soon do double iterations)
 883   return true;
 884 }
 885 
 886 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct) {
 887   // Enable this functionality target by target as needed
 888   if (SuperWordLoopUnrollAnalysis) {
 889     if (!cl-&gt;was_slp_analyzed()) {
 890       SuperWord sw(phase);
 891       sw.transform_loop(this, false);
 892 
 893       // If the loop is slp canonical analyze it
 894       if (sw.early_return() == false) {
 895         sw.unrolling_analysis(_local_loop_unroll_factor);
 896       }
 897     }
 898 
 899     if (cl-&gt;has_passed_slp()) {
 900       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 901       if (slp_max_unroll_factor &gt;= future_unroll_ct) {
 902         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 903         if (new_limit &gt; LoopUnrollLimit) {
 904           if (TraceSuperWordLoopUnrollAnalysis) {
 905             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 906           }
 907           _local_loop_unroll_limit = new_limit;
 908         }
 909       }
 910     }
 911   }
 912 }
 913 
 914 //------------------------------policy_align-----------------------------------
 915 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 916 // expression that does the alignment.  Note that only one array base can be
 917 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 918 // if we vectorize short memory ops into longer memory ops, we may want to
 919 // increase alignment.
 920 bool IdealLoopTree::policy_align( PhaseIdealLoop *phase ) const {
 921   return false;
 922 }
 923 
 924 //------------------------------policy_range_check-----------------------------
 925 // Return TRUE or FALSE if the loop should be range-check-eliminated.
 926 // Actually we do iteration-splitting, a more powerful form of RCE.
 927 bool IdealLoopTree::policy_range_check( PhaseIdealLoop *phase ) const {
 928   if (!RangeCheckElimination) return false;
 929 
 930   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 931   // If we unrolled with no intention of doing RCE and we later
 932   // changed our minds, we got no pre-loop.  Either we need to
 933   // make a new pre-loop, or we gotta disallow RCE.
 934   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 935   Node *trip_counter = cl-&gt;phi();
 936 
 937   // check for vectorized loops, some opts are no longer needed
 938   if (cl-&gt;do_unroll_only()) return false;
 939 
 940   // Check loop body for tests of trip-counter plus loop-invariant vs
 941   // loop-invariant.
 942   for (uint i = 0; i &lt; _body.size(); i++) {
 943     Node *iff = _body[i];
 944     if (iff-&gt;Opcode() == Op_If ||
 945         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 946 
 947       // Comparing trip+off vs limit
 948       Node *bol = iff-&gt;in(1);
 949       if (bol-&gt;req() != 2) continue; // dead constant test
 950       if (!bol-&gt;is_Bool()) {
 951         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
 952         continue;
 953       }
 954       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne)
 955         continue; // not RC
 956 
 957       Node *cmp = bol-&gt;in(1);
 958       Node *rc_exp = cmp-&gt;in(1);
 959       Node *limit = cmp-&gt;in(2);
 960 
 961       Node *limit_c = phase-&gt;get_ctrl(limit);
 962       if( limit_c == phase-&gt;C-&gt;top() )
 963         return false;           // Found dead test on live IF?  No RCE!
 964       if( is_member(phase-&gt;get_loop(limit_c) ) ) {
 965         // Compare might have operands swapped; commute them
 966         rc_exp = cmp-&gt;in(2);
 967         limit  = cmp-&gt;in(1);
 968         limit_c = phase-&gt;get_ctrl(limit);
 969         if( is_member(phase-&gt;get_loop(limit_c) ) )
 970           continue;             // Both inputs are loop varying; cannot RCE
 971       }
 972 
 973       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
 974         continue;
 975       }
 976       // Yeah!  Found a test like &#39;trip+off vs limit&#39;
 977       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
 978       // we need loop unswitching instead of iteration splitting.
 979       if( is_loop_exit(iff) )
 980         return true;            // Found reason to split iterations
 981     } // End of is IF
 982   }
 983 
 984   return false;
 985 }
 986 
 987 //------------------------------policy_peel_only-------------------------------
 988 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
 989 // for unrolling loops with NO array accesses.
 990 bool IdealLoopTree::policy_peel_only( PhaseIdealLoop *phase ) const {
 991   // check for vectorized loops, any peeling done was already applied
 992   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;
 993 
 994   for( uint i = 0; i &lt; _body.size(); i++ )
 995     if( _body[i]-&gt;is_Mem() )
 996       return false;
 997 
 998   // No memory accesses at all!
 999   return true;
1000 }
1001 
1002 //------------------------------clone_up_backedge_goo--------------------------
1003 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1004 // version of n in preheader_ctrl block and return that, otherwise return n.
1005 Node *PhaseIdealLoop::clone_up_backedge_goo( Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones ) {
1006   if( get_ctrl(n) != back_ctrl ) return n;
1007 
1008   // Only visit once
1009   if (visited.test_set(n-&gt;_idx)) {
1010     Node *x = clones.find(n-&gt;_idx);
1011     if (x != NULL)
1012       return x;
1013     return n;
1014   }
1015 
1016   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1017   // Check for &#39;n&#39; being pinned in the backedge.
1018   if( n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl ) {
1019     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1020     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1021     clones.push(x, n-&gt;_idx);
1022     x-&gt;set_req( 0, preheader_ctrl ); // Fix x&#39;s control input to preheader
1023   }
1024 
1025   // Recursive fixup any other input edges into x.
1026   // If there are no changes we can just return &#39;n&#39;, otherwise
1027   // we need to clone a private copy and change it.
1028   for( uint i = 1; i &lt; n-&gt;req(); i++ ) {
1029     Node *g = clone_up_backedge_goo( back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones );
1030     if( g != n-&gt;in(i) ) {
1031       if( !x ) {
1032         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1033         x = n-&gt;clone();
1034         clones.push(x, n-&gt;_idx);
1035       }
1036       x-&gt;set_req(i, g);
1037     }
1038   }
1039   if( x ) {                     // x can legally float to pre-header location
1040     register_new_node( x, preheader_ctrl );
1041     return x;
1042   } else {                      // raise n to cover LCA of uses
1043     set_ctrl( n, find_non_split_ctrl(back_ctrl-&gt;in(0)) );
1044   }
1045   return n;
1046 }
1047 
1048 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1049   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1050   castii-&gt;set_req(0, ctrl);
1051   register_new_node(castii, ctrl);
1052   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1053     Node* n = incr-&gt;fast_out(i);
1054     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1055       int nrep = n-&gt;replace_edge(incr, castii);
1056       return castii;
1057     }
1058   }
1059   return NULL;
1060 }
1061 
1062 // Make a copy of the skeleton range check predicates before the main
1063 // loop and set the initial value of loop as input. After unrolling,
1064 // the range of values for the induction variable in the main loop can
1065 // fall outside the allowed range of values by the array access (main
1066 // loop is never executed). When that happens, range check
1067 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1068 // the control paths must die too but the range checks were removed by
1069 // predication. The range checks that we add here guarantee that they do.
1070 void PhaseIdealLoop::duplicate_predicates_helper(Node* predicate, Node* start, Node* end,
1071                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1072                                                  uint dd_main_head) {
1073   if (predicate != NULL) {
1074     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1075     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1076     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1077     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1078     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1079     predicate = iff-&gt;in(0);
1080     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1081     Node* prev_proj = current_proj;
1082     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1083       iff = predicate-&gt;in(0)-&gt;as_If();
1084       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1085       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1086         break;
1087       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1088         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
1089         // Clone the predicate twice and initialize one with the initial
1090         // value of the loop induction variable. Leave the other predicate
1091         // to be initialized when increasing the stride during loop unrolling.
1092         prev_proj = clone_skeleton_predicate(iff, start, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1093         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (start-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1094         prev_proj = clone_skeleton_predicate(iff, end, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1095         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (end-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1096         // Remove the skeleton predicate from the pre-loop
1097         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1098       }
1099       predicate = predicate-&gt;in(0)-&gt;in(0);
1100     }
1101     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1102     set_idom(outer_main_head, prev_proj, dd_main_head);
1103   }
1104 }
1105 
1106 static bool skeleton_follow_inputs(Node* n, int op) {
1107   return (n-&gt;is_Bool() ||
1108           n-&gt;is_Cmp() ||
1109           op == Op_AndL ||
1110           op == Op_OrL ||
1111           op == Op_RShiftL ||
1112           op == Op_LShiftL ||
1113           op == Op_AddL ||
1114           op == Op_AddI ||
1115           op == Op_MulL ||
1116           op == Op_MulI ||
1117           op == Op_SubL ||
1118           op == Op_SubI ||
1119           op == Op_ConvI2L);
1120 }
1121 
1122 bool PhaseIdealLoop::skeleton_predicate_has_opaque(IfNode* iff) {
1123   ResourceMark rm;
1124   Unique_Node_List wq;
1125   wq.push(iff-&gt;in(1)-&gt;in(1));
1126   for (uint i = 0; i &lt; wq.size(); i++) {
1127     Node* n = wq.at(i);
1128     int op = n-&gt;Opcode();
1129     if (skeleton_follow_inputs(n, op)) {
1130       for (uint j = 1; j &lt; n-&gt;req(); j++) {
1131         Node* m = n-&gt;in(j);
1132         if (m != NULL) {
1133           wq.push(m);
1134         }
1135       }
1136       continue;
1137     }
1138     if (op == Op_Opaque1) {
1139       return true;
1140     }
1141   }
1142   return false;
1143 }
1144 
1145 Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
1146                                                Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {
1147   Node_Stack to_clone(2);
1148   to_clone.push(iff-&gt;in(1), 1);
1149   uint current = C-&gt;unique();
1150   Node* result = NULL;
1151   // Look for the opaque node to replace with the new value
1152   // and clone everything in between. We keep the Opaque4 node
1153   // so the duplicated predicates are eliminated once loop
1154   // opts are over: they are here only to keep the IR graph
1155   // consistent.
1156   do {
1157     Node* n = to_clone.node();
1158     uint i = to_clone.index();
1159     Node* m = n-&gt;in(i);
1160     int op = m-&gt;Opcode();
1161     if (skeleton_follow_inputs(m, op)) {
1162         to_clone.push(m, 1);
1163         continue;
1164     }
1165     if (op == Op_Opaque1) {
1166       if (n-&gt;_idx &lt; current) {
1167         n = n-&gt;clone();
1168       }
1169       n-&gt;set_req(i, value);
1170       register_new_node(n, current_proj);
1171       to_clone.set_node(n);
1172     }
1173     for (;;) {
1174       Node* cur = to_clone.node();
1175       uint j = to_clone.index();
1176       if (j+1 &lt; cur-&gt;req()) {
1177         to_clone.set_index(j+1);
1178         break;
1179       }
1180       to_clone.pop();
1181       if (to_clone.size() == 0) {
1182         result = cur;
1183         break;
1184       }
1185       Node* next = to_clone.node();
1186       j = to_clone.index();
1187       if (next-&gt;in(j) != cur) {
1188         assert(cur-&gt;_idx &gt;= current || next-&gt;in(j)-&gt;Opcode() == Op_Opaque1, &quot;new node or Opaque1 being replaced&quot;);
1189         if (next-&gt;_idx &lt; current) {
1190           next = next-&gt;clone();
1191           register_new_node(next, current_proj);
1192           to_clone.set_node(next);
1193         }
1194         next-&gt;set_req(j, cur);
1195       }
1196     }
1197   } while (result == NULL);
1198   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1199 
1200   Node* proj = predicate-&gt;clone();
1201   Node* other_proj = uncommon_proj-&gt;clone();
1202   Node* new_iff = iff-&gt;clone();
1203   new_iff-&gt;set_req(1, result);
1204   proj-&gt;set_req(0, new_iff);
1205   other_proj-&gt;set_req(0, new_iff);
1206   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1207   register_new_node(frame, C-&gt;start());
1208   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
1209   Node* halt = new HaltNode(other_proj, frame);
1210   C-&gt;root()-&gt;add_req(halt);
1211   new_iff-&gt;set_req(0, prev_proj);
1212 
1213   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1214   register_control(proj, outer_loop-&gt;_parent, new_iff);
1215   register_control(other_proj, _ltree_root, new_iff);
1216   register_control(halt, _ltree_root, other_proj);
1217   return proj;
1218 }
1219 
1220 void PhaseIdealLoop::duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end,
1221                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
1222                                           uint dd_main_head) {
1223   if (UseLoopPredicate) {
1224     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1225     Node* predicate = NULL;
1226     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1227     if (predicate != NULL) {
1228       entry = skip_loop_predicates(entry);
1229     }
1230     Node* profile_predicate = NULL;
1231     if (UseProfiledLoopPredicate) {
1232       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1233       if (profile_predicate != NULL) {
1234         entry = skip_loop_predicates(entry);
1235       }
1236     }
1237     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1238     duplicate_predicates_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1239     duplicate_predicates_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head);
1240   }
1241 }
1242 
1243 //------------------------------insert_pre_post_loops--------------------------
1244 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1245 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1246 // alignment.  Useful to unroll loops that do no array accesses.
1247 void PhaseIdealLoop::insert_pre_post_loops( IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only ) {
1248 
1249 #ifndef PRODUCT
1250   if (TraceLoopOpts) {
1251     if (peel_only)
1252       tty-&gt;print(&quot;PeelMainPost &quot;);
1253     else
1254       tty-&gt;print(&quot;PreMainPost  &quot;);
1255     loop-&gt;dump_head();
1256   }
1257 #endif
1258   C-&gt;set_major_progress();
1259 
1260   // Find common pieces of the loop being guarded with pre &amp; post loops
1261   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1262   assert( main_head-&gt;is_normal_loop(), &quot;&quot; );
1263   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1264   assert( main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot; );
1265 
1266   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1267   Node *init      = main_head-&gt;init_trip();
1268   Node *incr      = main_end -&gt;incr();
1269   Node *limit     = main_end -&gt;limit();
1270   Node *stride    = main_end -&gt;stride();
1271   Node *cmp       = main_end -&gt;cmp_node();
1272   BoolTest::mask b_test = main_end-&gt;test_trip();
1273 
1274   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1275   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
1276   if( bol-&gt;outcnt() != 1 ) {
1277     bol = bol-&gt;clone();
1278     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1279     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1280   }
1281   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
1282   if( cmp-&gt;outcnt() != 1 ) {
1283     cmp = cmp-&gt;clone();
1284     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1285     _igvn.replace_input_of(bol, 1, cmp);
1286   }
1287 
1288   // Add the post loop
1289   CountedLoopNode *post_head = NULL;
1290   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1291 
1292   //------------------------------
1293   // Step B: Create Pre-Loop.
1294 
1295   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1296   // loop pre-header illegally has 2 control users (old &amp; new loops).
1297   LoopNode* outer_main_head = main_head;
1298   IdealLoopTree* outer_loop = loop;
1299   if (main_head-&gt;is_strip_mined()) {
1300     main_head-&gt;verify_strip_mined(1);
1301     outer_main_head = main_head-&gt;outer_loop();
1302     outer_loop = loop-&gt;_parent;
1303     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1304   }
1305   uint dd_main_head = dom_depth(outer_main_head);
1306   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1307   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1308   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1309   pre_head-&gt;set_pre_loop(main_head);
1310   Node *pre_incr = old_new[incr-&gt;_idx];
1311 
1312   // Reduce the pre-loop trip count.
1313   pre_end-&gt;_prob = PROB_FAIR;
1314 
1315   // Find the pre-loop normal exit.
1316   Node* pre_exit = pre_end-&gt;proj_out(false);
1317   assert( pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
1318   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
1319   _igvn.register_new_node_with_optimizer( new_pre_exit );
1320   set_idom(new_pre_exit, pre_end, dd_main_head);
1321   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1322 
1323   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1324   // pre-loop, the main-loop may not execute at all.  Later in life this
1325   // zero-trip guard will become the minimum-trip guard when we unroll
1326   // the main-loop.
1327   Node *min_opaq = new Opaque1Node(C, limit);
1328   Node *min_cmp  = new CmpINode( pre_incr, min_opaq );
1329   Node *min_bol  = new BoolNode( min_cmp, b_test );
1330   register_new_node( min_opaq, new_pre_exit );
1331   register_new_node( min_cmp , new_pre_exit );
1332   register_new_node( min_bol , new_pre_exit );
1333 
1334   // Build the IfNode (assume the main-loop is executed always).
1335   IfNode *min_iff = new IfNode( new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN );
1336   _igvn.register_new_node_with_optimizer( min_iff );
1337   set_idom(min_iff, new_pre_exit, dd_main_head);
1338   set_loop(min_iff, outer_loop-&gt;_parent);
1339 
1340   // Plug in the false-path, taken if we need to skip main-loop
1341   _igvn.hash_delete( pre_exit );
1342   pre_exit-&gt;set_req(0, min_iff);
1343   set_idom(pre_exit, min_iff, dd_main_head);
1344   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1345   // Make the true-path, must enter the main loop
1346   Node *min_taken = new IfTrueNode( min_iff );
1347   _igvn.register_new_node_with_optimizer( min_taken );
1348   set_idom(min_taken, min_iff, dd_main_head);
1349   set_loop(min_taken, outer_loop-&gt;_parent);
1350   // Plug in the true path
1351   _igvn.hash_delete(outer_main_head);
1352   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1353   set_idom(outer_main_head, min_taken, dd_main_head);
1354 
1355   Arena *a = Thread::current()-&gt;resource_area();
1356   VectorSet visited(a);
1357   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1358   // Step B3: Make the fall-in values to the main-loop come from the
1359   // fall-out values of the pre-loop.
1360   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1361     Node* main_phi = main_head-&gt;fast_out(i2);
1362     if( main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0 ) {
1363       Node *pre_phi = old_new[main_phi-&gt;_idx];
1364       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1365                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1366                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1367                                              visited, clones);
1368       _igvn.hash_delete(main_phi);
1369       main_phi-&gt;set_req( LoopNode::EntryControl, fallpre );
1370     }
1371   }
1372 
1373   // Nodes inside the loop may be control dependent on a predicate
1374   // that was moved before the preloop. If the back branch of the main
1375   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1376   // test that guards that loop nest anymore which could lead to an
1377   // incorrect array access because it executes independently of the
1378   // test that was guarding the loop nest. We add a special CastII on
1379   // the if branch that enters the loop, between the input induction
1380   // variable value and the induction variable Phi to preserve correct
1381   // dependencies.
1382 
1383   // CastII for the main loop:
1384   Node* castii = cast_incr_before_loop( pre_incr, min_taken, main_head );
1385   assert(castii != NULL, &quot;no castII inserted&quot;);
1386   Node* opaque_castii = new Opaque1Node(C, castii);
1387   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
1388   duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
1389 
1390   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1391   // RCE and alignment may change this later.
1392   Node *cmp_end = pre_end-&gt;cmp_node();
1393   assert( cmp_end-&gt;in(2) == limit, &quot;&quot; );
1394   Node *pre_limit = new AddINode( init, stride );
1395 
1396   // Save the original loop limit in this Opaque1 node for
1397   // use by range check elimination.
1398   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1399 
1400   register_new_node( pre_limit, pre_head-&gt;in(0) );
1401   register_new_node( pre_opaq , pre_head-&gt;in(0) );
1402 
1403   // Since no other users of pre-loop compare, I can hack limit directly
1404   assert( cmp_end-&gt;outcnt() == 1, &quot;no other users&quot; );
1405   _igvn.hash_delete(cmp_end);
1406   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1407 
1408   // Special case for not-equal loop bounds:
1409   // Change pre loop test, main loop test, and the
1410   // main loop guard test to use lt or gt depending on stride
1411   // direction:
1412   // positive stride use &lt;
1413   // negative stride use &gt;
1414   //
1415   // not-equal test is kept for post loop to handle case
1416   // when init &gt; limit when stride &gt; 0 (and reverse).
1417 
1418   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1419 
1420     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1421     // Modify pre loop end condition
1422     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1423     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
1424     register_new_node( new_bol0, pre_head-&gt;in(0) );
1425     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1426     // Modify main loop guard condition
1427     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1428     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
1429     register_new_node( new_bol1, new_pre_exit );
1430     _igvn.hash_delete(min_iff);
1431     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1432     // Modify main loop end condition
1433     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1434     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
1435     register_new_node( new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl) );
1436     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1437   }
1438 
1439   // Flag main loop
1440   main_head-&gt;set_main_loop();
1441   if( peel_only ) main_head-&gt;set_main_no_pre_loop();
1442 
1443   // Subtract a trip count for the pre-loop.
1444   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1445 
1446   // It&#39;s difficult to be precise about the trip-counts
1447   // for the pre/post loops.  They are usually very short,
1448   // so guess that 4 trips is a reasonable value.
1449   post_head-&gt;set_profile_trip_cnt(4.0);
1450   pre_head-&gt;set_profile_trip_cnt(4.0);
1451 
1452   // Now force out all loop-invariant dominating tests.  The optimizer
1453   // finds some, but we _know_ they are all useless.
1454   peeled_dom_test_elim(loop,old_new);
1455   loop-&gt;record_for_igvn();
1456 }
1457 
1458 //------------------------------insert_vector_post_loop------------------------
1459 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
1460 // unroll_policy has already informed us that more unrolling is about to happen to
1461 // the main loop.  The resultant post loop will serve as a vectorized drain loop.
1462 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1463   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1464 
1465   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1466 
1467   // only process vectorized main loops
1468   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1469 
1470   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1471   int cur_unroll = cl-&gt;unrolled_count();
1472 
1473   if (slp_max_unroll_factor == 0) return;
1474 
1475   // only process atomic unroll vector loops (not super unrolled after vectorization)
1476   if (cur_unroll != slp_max_unroll_factor) return;
1477 
1478   // we only ever process this one time
1479   if (cl-&gt;has_atomic_post_loop()) return;
1480 
1481 #ifndef PRODUCT
1482   if (TraceLoopOpts) {
1483     tty-&gt;print(&quot;PostVector  &quot;);
1484     loop-&gt;dump_head();
1485   }
1486 #endif
1487   C-&gt;set_major_progress();
1488 
1489   // Find common pieces of the loop being guarded with pre &amp; post loops
1490   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1491   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1492   // diagnostic to show loop end is not properly formed
1493   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1494 
1495   // mark this loop as processed
1496   main_head-&gt;mark_has_atomic_post_loop();
1497 
1498   Node *incr = main_end-&gt;incr();
1499   Node *limit = main_end-&gt;limit();
1500 
1501   // In this case we throw away the result as we are not using it to connect anything else.
1502   CountedLoopNode *post_head = NULL;
1503   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1504 
1505   // It&#39;s difficult to be precise about the trip-counts
1506   // for post loops.  They are usually very short,
1507   // so guess that unit vector trips is a reasonable value.
1508   post_head-&gt;set_profile_trip_cnt(cur_unroll);
1509 
1510   // Now force out all loop-invariant dominating tests.  The optimizer
1511   // finds some, but we _know_ they are all useless.
1512   peeled_dom_test_elim(loop, old_new);
1513   loop-&gt;record_for_igvn();
1514 }
1515 
1516 
1517 //-------------------------insert_scalar_rced_post_loop------------------------
1518 // Insert a copy of the rce&#39;d main loop as a post loop,
1519 // We have not unrolled the main loop, so this is the right time to inject this.
1520 // Later we will examine the partner of this post loop pair which still has range checks
1521 // to see inject code which tests at runtime if the range checks are applicable.
1522 void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1523   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1524 
1525   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1526 
1527   // only process RCE&#39;d main loops
1528   if (!cl-&gt;is_main_loop() || cl-&gt;range_checks_present()) return;
1529 
1530 #ifndef PRODUCT
1531   if (TraceLoopOpts) {
1532     tty-&gt;print(&quot;PostScalarRce  &quot;);
1533     loop-&gt;dump_head();
1534   }
1535 #endif
1536   C-&gt;set_major_progress();
1537 
1538   // Find common pieces of the loop being guarded with pre &amp; post loops
1539   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1540   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1541   // diagnostic to show loop end is not properly formed
1542   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1543 
1544   Node *incr = main_end-&gt;incr();
1545   Node *limit = main_end-&gt;limit();
1546 
1547   // In this case we throw away the result as we are not using it to connect anything else.
1548   CountedLoopNode *post_head = NULL;
1549   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1550 
1551   // It&#39;s difficult to be precise about the trip-counts
1552   // for post loops.  They are usually very short,
1553   // so guess that unit vector trips is a reasonable value.
1554   post_head-&gt;set_profile_trip_cnt(4.0);
1555   post_head-&gt;set_is_rce_post_loop();
1556 
1557   // Now force out all loop-invariant dominating tests.  The optimizer
1558   // finds some, but we _know_ they are all useless.
1559   peeled_dom_test_elim(loop, old_new);
1560   loop-&gt;record_for_igvn();
1561 }
1562 
1563 
1564 //------------------------------insert_post_loop-------------------------------
1565 // Insert post loops.  Add a post loop to the given loop passed.
1566 Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &amp;old_new,
1567                                        CountedLoopNode *main_head, CountedLoopEndNode *main_end,
1568                                        Node *incr, Node *limit, CountedLoopNode *&amp;post_head) {
1569   IfNode* outer_main_end = main_end;
1570   IdealLoopTree* outer_loop = loop;
1571   if (main_head-&gt;is_strip_mined()) {
1572     main_head-&gt;verify_strip_mined(1);
1573     outer_main_end = main_head-&gt;outer_loop_end();
1574     outer_loop = loop-&gt;_parent;
1575     assert(outer_loop-&gt;_head == main_head-&gt;in(LoopNode::EntryControl), &quot;broken loop tree&quot;);
1576   }
1577 
1578   //------------------------------
1579   // Step A: Create a new post-Loop.
1580   Node* main_exit = outer_main_end-&gt;proj_out(false);
1581   assert(main_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1582   int dd_main_exit = dom_depth(main_exit);
1583 
1584   // Step A1: Clone the loop body of main. The clone becomes the post-loop.
1585   // The main loop pre-header illegally has 2 control users (old &amp; new loops).
1586   clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);
1587   assert(old_new[main_end-&gt;_idx]-&gt;Opcode() == Op_CountedLoopEnd, &quot;&quot;);
1588   post_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1589   post_head-&gt;set_normal_loop();
1590   post_head-&gt;set_post_loop(main_head);
1591 
1592   // Reduce the post-loop trip count.
1593   CountedLoopEndNode* post_end = old_new[main_end-&gt;_idx]-&gt;as_CountedLoopEnd();
1594   post_end-&gt;_prob = PROB_FAIR;
1595 
1596   // Build the main-loop normal exit.
1597   IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);
1598   _igvn.register_new_node_with_optimizer(new_main_exit);
1599   set_idom(new_main_exit, outer_main_end, dd_main_exit);
1600   set_loop(new_main_exit, outer_loop-&gt;_parent);
1601 
1602   // Step A2: Build a zero-trip guard for the post-loop.  After leaving the
1603   // main-loop, the post-loop may not execute at all.  We &#39;opaque&#39; the incr
1604   // (the previous loop trip-counter exit value) because we will be changing
1605   // the exit value (via additional unrolling) so we cannot constant-fold away the zero
1606   // trip guard until all unrolling is done.
1607   Node *zer_opaq = new Opaque1Node(C, incr);
1608   Node *zer_cmp = new CmpINode(zer_opaq, limit);
1609   Node *zer_bol = new BoolNode(zer_cmp, main_end-&gt;test_trip());
1610   register_new_node(zer_opaq, new_main_exit);
1611   register_new_node(zer_cmp, new_main_exit);
1612   register_new_node(zer_bol, new_main_exit);
1613 
1614   // Build the IfNode
1615   IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);
1616   _igvn.register_new_node_with_optimizer(zer_iff);
1617   set_idom(zer_iff, new_main_exit, dd_main_exit);
1618   set_loop(zer_iff, outer_loop-&gt;_parent);
1619 
1620   // Plug in the false-path, taken if we need to skip this post-loop
1621   _igvn.replace_input_of(main_exit, 0, zer_iff);
1622   set_idom(main_exit, zer_iff, dd_main_exit);
1623   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1624   // Make the true-path, must enter this post loop
1625   Node *zer_taken = new IfTrueNode(zer_iff);
1626   _igvn.register_new_node_with_optimizer(zer_taken);
1627   set_idom(zer_taken, zer_iff, dd_main_exit);
1628   set_loop(zer_taken, outer_loop-&gt;_parent);
1629   // Plug in the true path
1630   _igvn.hash_delete(post_head);
1631   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1632   set_idom(post_head, zer_taken, dd_main_exit);
1633 
1634   Arena *a = Thread::current()-&gt;resource_area();
1635   VectorSet visited(a);
1636   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1637   // Step A3: Make the fall-in values to the post-loop come from the
1638   // fall-out values of the main-loop.
1639   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1640     Node* main_phi = main_head-&gt;fast_out(i);
1641     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt;0) {
1642       Node *cur_phi = old_new[main_phi-&gt;_idx];
1643       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1644                                             post_head-&gt;init_control(),
1645                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1646                                             visited, clones);
1647       _igvn.hash_delete(cur_phi);
1648       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1649     }
1650   }
1651 
1652   // CastII for the new post loop:
1653   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1654   assert(castii != NULL, &quot;no castII inserted&quot;);
1655 
1656   return new_main_exit;
1657 }
1658 
1659 //------------------------------is_invariant-----------------------------
1660 // Return true if n is invariant
1661 bool IdealLoopTree::is_invariant(Node* n) const {
1662   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1663   if (n_c-&gt;is_top()) return false;
1664   return !is_member(_phase-&gt;get_loop(n_c));
1665 }
1666 
1667 void PhaseIdealLoop::update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {
1668   // Search for skeleton predicates and update them according to the new stride
1669   Node* entry = ctrl;
1670   Node* prev_proj = ctrl;
1671   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1672   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1673   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1674     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1675     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1676     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1677       break;
1678     }
1679     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1680       // Look for predicate with an Opaque1 node that can be used as a template
1681       if (!skeleton_predicate_has_opaque(iff)) {
1682         // No Opaque1 node? It&#39;s either the check for the first value
1683         // of the first iteration or the check for the last value of
1684         // the first iteration of an unrolled loop. We can&#39;t
1685         // tell. Kill it in any case.
1686         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1687       } else {
1688         // Add back the predicate for the value at the beginning of the first entry
1689         prev_proj = clone_skeleton_predicate(iff, init, entry, proj, ctrl, outer_loop, prev_proj);
1690         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1691         // Compute the value of the loop induction variable at the end of the
1692         // first iteration of the unrolled loop: init + new_stride_con - init_inc
1693         int init_inc = stride_con/loop_head-&gt;unrolled_count();
1694         assert(init_inc != 0, &quot;invalid loop increment&quot;);
1695         int new_stride_con = stride_con * 2;
1696         Node* max_value = _igvn.intcon(new_stride_con - init_inc);
1697         max_value = new AddINode(init, max_value);
1698         register_new_node(max_value, get_ctrl(iff-&gt;in(1)));
1699         prev_proj = clone_skeleton_predicate(iff, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1700         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1701       }
1702     }
1703     entry = entry-&gt;in(0)-&gt;in(0);
1704   }
1705   if (prev_proj != ctrl) {
1706     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1707     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1708   }
1709 }
1710 
1711 //------------------------------do_unroll--------------------------------------
1712 // Unroll the loop body one step - make each trip do 2 iterations.
1713 void PhaseIdealLoop::do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip ) {
1714   assert(LoopUnrollLimit, &quot;&quot;);
1715   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1716   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1717 #ifndef PRODUCT
1718   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1719     tty-&gt;print(&quot;Unrolling &quot;);
1720     loop-&gt;dump_head();
1721   } else if (TraceLoopOpts) {
1722     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1723       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1724     } else {
1725       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1726     }
1727     loop-&gt;dump_head();
1728   }
1729 
1730   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1731     Arena* arena = Thread::current()-&gt;resource_area();
1732     Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
1733     Node_List rpo_list;
1734     VectorSet visited(arena);
1735     visited.set(loop_head-&gt;_idx);
1736     rpo( loop_head, stack, visited, rpo_list );
1737     dump(loop, rpo_list.size(), rpo_list );
1738   }
1739 #endif
1740 
1741   // Remember loop node count before unrolling to detect
1742   // if rounds of unroll,optimize are making progress
1743   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1744 
1745   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1746   Node *limit = loop_head-&gt;limit();
1747   Node *init  = loop_head-&gt;init_trip();
1748   Node *stride = loop_head-&gt;stride();
1749 
1750   Node *opaq = NULL;
1751   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1752     // Search for zero-trip guard.
1753 
1754     // Check the shape of the graph at the loop entry. If an inappropriate
1755     // graph shape is encountered, the compiler bails out loop unrolling;
1756     // compilation of the method will still succeed.
1757     if (!is_canonical_loop_entry(loop_head)) {
1758       return;
1759     }
1760     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1761     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1762     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1763   }
1764 
1765   C-&gt;set_major_progress();
1766 
1767   Node* new_limit = NULL;
1768   int stride_con = stride-&gt;get_int();
1769   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1770   uint old_trip_count = loop_head-&gt;trip_count();
1771   // Verify that unroll policy result is still valid.
1772   assert(old_trip_count &gt; 1 &amp;&amp;
1773       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1774 
1775   update_skeleton_predicates(ctrl, loop_head, init, stride_con);
1776 
1777   // Adjust loop limit to keep valid iterations number after unroll.
1778   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1779   // which may overflow.
1780   if (!adjust_min_trip) {
1781     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1782         &quot;odd trip count for maximally unroll&quot;);
1783     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1784   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1785     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1786     // become peeled iteration.
1787     jlong init_con = init-&gt;get_int();
1788     // We can keep old loop limit if iterations count stays the same:
1789     //   old_trip_count == new_trip_count * 2
1790     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1791     // so we also don&#39;t need to adjust zero trip test.
1792     jlong limit_con  = limit-&gt;get_int();
1793     // (stride_con*2) not overflow since stride_con &lt;= 8.
1794     int new_stride_con = stride_con * 2;
1795     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1796     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1797     // New trip count should satisfy next conditions.
1798     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1799     uint new_trip_count = (uint)trip_count;
1800     adjust_min_trip = (old_trip_count != new_trip_count*2);
1801   }
1802 
1803   if (adjust_min_trip) {
1804     // Step 2: Adjust the trip limit if it is called for.
1805     // The adjustment amount is -stride. Need to make sure if the
1806     // adjustment underflows or overflows, then the main loop is skipped.
1807     Node* cmp = loop_end-&gt;cmp_node();
1808     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1809     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1810 
1811     // Verify that policy_unroll result is still valid.
1812     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1813     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
1814         stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo), &quot;sanity&quot;);
1815 
1816     if (limit-&gt;is_Con()) {
1817       // The check in policy_unroll and the assert above guarantee
1818       // no underflow if limit is constant.
1819       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1820       set_ctrl(new_limit, C-&gt;root());
1821     } else {
1822       // Limit is not constant.
1823       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1824         // Separate limit by Opaque node in case it is an incremented
1825         // variable from previous loop to avoid using pre-incremented
1826         // value which could increase register pressure.
1827         // Otherwise reorg_offsets() optimization will create a separate
1828         // Opaque node for each use of trip-counter and as result
1829         // zero trip guard limit will be different from loop limit.
1830         assert(has_ctrl(opaq), &quot;should have it&quot;);
1831         Node* opaq_ctrl = get_ctrl(opaq);
1832         limit = new Opaque2Node( C, limit );
1833         register_new_node( limit, opaq_ctrl );
1834       }
1835       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1836           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1837         // No underflow.
1838         new_limit = new SubINode(limit, stride);
1839       } else {
1840         // (limit - stride) may underflow.
1841         // Clamp the adjustment value with MININT or MAXINT:
1842         //
1843         //   new_limit = limit-stride
1844         //   if (stride &gt; 0)
1845         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1846         //   else
1847         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1848         //
1849         BoolTest::mask bt = loop_end-&gt;test_trip();
1850         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1851         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1852         set_ctrl(adj_max, C-&gt;root());
1853         Node* old_limit = NULL;
1854         Node* adj_limit = NULL;
1855         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1856         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1857             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1858             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1859             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1860             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1861             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1862           // Loop was unrolled before.
1863           // Optimize the limit to avoid nested CMove:
1864           // use original limit as old limit.
1865           old_limit = bol-&gt;in(1)-&gt;in(1);
1866           // Adjust previous adjusted limit.
1867           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1868           adj_limit = new SubINode(adj_limit, stride);
1869         } else {
1870           old_limit = limit;
1871           adj_limit = new SubINode(limit, stride);
1872         }
1873         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
1874         register_new_node( adj_limit, ctrl ); // adjust amount
1875         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
1876         register_new_node( adj_cmp, ctrl );
1877         Node* adj_bool = new BoolNode(adj_cmp, bt);
1878         register_new_node( adj_bool, ctrl );
1879         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
1880       }
1881       register_new_node(new_limit, ctrl);
1882     }
1883     assert(new_limit != NULL, &quot;&quot;);
1884     // Replace in loop test.
1885     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
1886     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
1887       // Don&#39;t need to create new test since only one user.
1888       _igvn.hash_delete(cmp);
1889       cmp-&gt;set_req(2, new_limit);
1890     } else {
1891       // Create new test since it is shared.
1892       Node* ctrl2 = loop_end-&gt;in(0);
1893       Node* cmp2  = cmp-&gt;clone();
1894       cmp2-&gt;set_req(2, new_limit);
1895       register_new_node(cmp2, ctrl2);
1896       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
1897       bol2-&gt;set_req(1, cmp2);
1898       register_new_node(bol2, ctrl2);
1899       _igvn.replace_input_of(loop_end, 1, bol2);
1900     }
1901     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
1902     // Make it a 1-trip test (means at least 2 trips).
1903 
1904     // Guard test uses an &#39;opaque&#39; node which is not shared.  Hence I
1905     // can edit it&#39;s inputs directly.  Hammer in the new limit for the
1906     // minimum-trip guard.
1907     assert(opaq-&gt;outcnt() == 1, &quot;&quot;);
1908     _igvn.replace_input_of(opaq, 1, new_limit);
1909   }
1910 
1911   // Adjust max trip count. The trip count is intentionally rounded
1912   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
1913   // the main, unrolled, part of the loop will never execute as it is protected
1914   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
1915   // and later determined that part of the unrolled loop was dead.
1916   loop_head-&gt;set_trip_count(old_trip_count / 2);
1917 
1918   // Double the count of original iterations in the unrolled loop body.
1919   loop_head-&gt;double_unrolled_count();
1920 
1921   // ---------
1922   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
1923   // represents the odd iterations; since the loop trips an even number of
1924   // times its backedge is never taken.  Kill the backedge.
1925   uint dd = dom_depth(loop_head);
1926   clone_loop(loop, old_new, dd, IgnoreStripMined);
1927 
1928   // Make backedges of the clone equal to backedges of the original.
1929   // Make the fall-in from the original come from the fall-out of the clone.
1930   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1931     Node* phi = loop_head-&gt;fast_out(j);
1932     if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0 ) {
1933       Node *newphi = old_new[phi-&gt;_idx];
1934       _igvn.hash_delete( phi );
1935       _igvn.hash_delete( newphi );
1936 
1937       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
1938       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
1939       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
1940     }
1941   }
1942   Node *clone_head = old_new[loop_head-&gt;_idx];
1943   _igvn.hash_delete( clone_head );
1944   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
1945   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
1946   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
1947   loop-&gt;_head = clone_head;     // New loop header
1948 
1949   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
1950   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
1951 
1952   // Kill the clone&#39;s backedge
1953   Node *newcle = old_new[loop_end-&gt;_idx];
1954   _igvn.hash_delete( newcle );
1955   Node *one = _igvn.intcon(1);
1956   set_ctrl(one, C-&gt;root());
1957   newcle-&gt;set_req(1, one);
1958   // Force clone into same loop body
1959   uint max = loop-&gt;_body.size();
1960   for( uint k = 0; k &lt; max; k++ ) {
1961     Node *old = loop-&gt;_body.at(k);
1962     Node *nnn = old_new[old-&gt;_idx];
1963     loop-&gt;_body.push(nnn);
1964     if (!has_ctrl(old))
1965       set_loop(nnn, loop);
1966   }
1967 
1968   loop-&gt;record_for_igvn();
1969   loop_head-&gt;clear_strip_mined();
1970 
1971 #ifndef PRODUCT
1972   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1973     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
1974     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
1975       loop-&gt;_body.at(i)-&gt;dump();
1976     }
1977     if(C-&gt;clone_map().is_debug()) {
1978       tty-&gt;print(&quot;\nCloneMap\n&quot;);
1979       Dict* dict = C-&gt;clone_map().dict();
1980       DictI i(dict);
1981       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
1982       for (int ii = 0; i.test(); ++i, ++ii) {
1983         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
1984         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
1985         if (ii % 10 == 9) {
1986           tty-&gt;print_cr(&quot; &quot;);
1987         }
1988       }
1989       tty-&gt;print_cr(&quot; &quot;);
1990     }
1991   }
1992 #endif
1993 
1994 }
1995 
1996 //------------------------------do_maximally_unroll----------------------------
1997 
1998 void PhaseIdealLoop::do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new ) {
1999   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2000   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2001   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2002 #ifndef PRODUCT
2003   if (TraceLoopOpts) {
2004     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2005     loop-&gt;dump_head();
2006   }
2007 #endif
2008 
2009   // If loop is tripping an odd number of times, peel odd iteration
2010   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2011     do_peeling(loop, old_new);
2012   }
2013 
2014   // Now its tripping an even number of times remaining.  Double loop body.
2015   // Do not adjust pre-guards; they are not needed and do not exist.
2016   if (cl-&gt;trip_count() &gt; 0) {
2017     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2018     do_unroll(loop, old_new, false);
2019   }
2020 }
2021 
2022 void PhaseIdealLoop::mark_reductions(IdealLoopTree *loop) {
2023   if (SuperWordReductions == false) return;
2024 
2025   CountedLoopNode* loop_head = loop-&gt;_head-&gt;as_CountedLoop();
2026   if (loop_head-&gt;unrolled_count() &gt; 1) {
2027     return;
2028   }
2029 
2030   Node* trip_phi = loop_head-&gt;phi();
2031   for (DUIterator_Fast imax, i = loop_head-&gt;fast_outs(imax); i &lt; imax; i++) {
2032     Node* phi = loop_head-&gt;fast_out(i);
2033     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;outcnt() &gt; 0 &amp;&amp; phi != trip_phi) {
2034       // For definitions which are loop inclusive and not tripcounts.
2035       Node* def_node = phi-&gt;in(LoopNode::LoopBackControl);
2036 
2037       if (def_node != NULL) {
2038         Node* n_ctrl = get_ctrl(def_node);
2039         if (n_ctrl != NULL &amp;&amp; loop-&gt;is_member(get_loop(n_ctrl))) {
2040           // Now test it to see if it fits the standard pattern for a reduction operator.
2041           int opc = def_node-&gt;Opcode();
2042           if (opc != ReductionNode::opcode(opc, def_node-&gt;bottom_type()-&gt;basic_type())
2043               || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF) {
2044             if (!def_node-&gt;is_reduction()) { // Not marked yet
2045               // To be a reduction, the arithmetic node must have the phi as input and provide a def to it
2046               bool ok = false;
2047               for (unsigned j = 1; j &lt; def_node-&gt;req(); j++) {
2048                 Node* in = def_node-&gt;in(j);
2049                 if (in == phi) {
2050                   ok = true;
2051                   break;
2052                 }
2053               }
2054 
2055               // do nothing if we did not match the initial criteria
2056               if (ok == false) {
2057                 continue;
2058               }
2059 
2060               // The result of the reduction must not be used in the loop
2061               for (DUIterator_Fast imax, i = def_node-&gt;fast_outs(imax); i &lt; imax &amp;&amp; ok; i++) {
2062                 Node* u = def_node-&gt;fast_out(i);
2063                 if (!loop-&gt;is_member(get_loop(ctrl_or_self(u)))) {
2064                   continue;
2065                 }
2066                 if (u == phi) {
2067                   continue;
2068                 }
2069                 ok = false;
2070               }
2071 
2072               // iff the uses conform
2073               if (ok) {
2074                 def_node-&gt;add_flag(Node::Flag_is_reduction);
2075                 loop_head-&gt;mark_has_reductions();
2076               }
2077             }
2078           }
2079         }
2080       }
2081     }
2082   }
2083 }
2084 
2085 //------------------------------adjust_limit-----------------------------------
2086 // Helper function for add_constraint().
2087 Node* PhaseIdealLoop::adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up) {
2088   // Compute &quot;I :: (limit-offset)/scale&quot;
2089   Node *con = new SubINode(rc_limit, offset);
2090   register_new_node(con, pre_ctrl);
2091   Node *X = new DivINode(0, con, scale);
2092   register_new_node(X, pre_ctrl);
2093 
2094   // When the absolute value of scale is greater than one, the integer
2095   // division may round limit down so add one to the limit.
2096   if (round_up) {
2097     X = new AddINode(X, _igvn.intcon(1));
2098     register_new_node(X, pre_ctrl);
2099   }
2100 
2101   // Adjust loop limit
2102   loop_limit = (stride_con &gt; 0)
2103                ? (Node*)(new MinINode(loop_limit, X))
2104                : (Node*)(new MaxINode(loop_limit, X));
2105   register_new_node(loop_limit, pre_ctrl);
2106   return loop_limit;
2107 }
2108 
2109 //------------------------------add_constraint---------------------------------
2110 // Constrain the main loop iterations so the conditions:
2111 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2112 // always holds true.  That is, either increase the number of iterations in
2113 // the pre-loop or the post-loop until the condition holds true in the main
2114 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2115 // stride and scale are constants (offset and limit often are).
2116 void PhaseIdealLoop::add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit ) {
2117   // For positive stride, the pre-loop limit always uses a MAX function
2118   // and the main loop a MIN function.  For negative stride these are
2119   // reversed.
2120 
2121   // Also for positive stride*scale the affine function is increasing, so the
2122   // pre-loop must check for underflow and the post-loop for overflow.
2123   // Negative stride*scale reverses this; pre-loop checks for overflow and
2124   // post-loop for underflow.
2125 
2126   Node *scale = _igvn.intcon(scale_con);
2127   set_ctrl(scale, C-&gt;root());
2128 
2129   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2130     // The overflow limit: scale*I+offset &lt; upper_limit
2131     // For main-loop compute
2132     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2133     //       I &lt; (upper_limit-offset)/scale
2134     //     else /* scale &lt; 0 and stride &lt; 0 */
2135     //       I &gt; (upper_limit-offset)/scale
2136     //   )
2137     //
2138     // (upper_limit-offset) may overflow or underflow.
2139     // But it is fine since main loop will either have
2140     // less iterations or will be skipped in such case.
2141     *main_limit = adjust_limit(stride_con, scale, offset, upper_limit, *main_limit, pre_ctrl, false);
2142 
2143     // The underflow limit: low_limit &lt;= scale*I+offset.
2144     // For pre-loop compute
2145     //   NOT(scale*I+offset &gt;= low_limit)
2146     //   scale*I+offset &lt; low_limit
2147     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2148     //       I &lt; (low_limit-offset)/scale
2149     //     else /* scale &lt; 0 and stride &lt; 0 */
2150     //       I &gt; (low_limit-offset)/scale
2151     //   )
2152 
2153     if (low_limit-&gt;get_int() == -max_jint) {
2154       // We need this guard when scale*pre_limit+offset &gt;= limit
2155       // due to underflow. So we need execute pre-loop until
2156       // scale*I+offset &gt;= min_int. But (min_int-offset) will
2157       // underflow when offset &gt; 0 and X will be &gt; original_limit
2158       // when stride &gt; 0. To avoid it we replace positive offset with 0.
2159       //
2160       // Also (min_int+1 == -max_int) is used instead of min_int here
2161       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2162       Node* shift = _igvn.intcon(31);
2163       set_ctrl(shift, C-&gt;root());
2164       Node* sign = new RShiftINode(offset, shift);
2165       register_new_node(sign, pre_ctrl);
2166       offset = new AndINode(offset, sign);
2167       register_new_node(offset, pre_ctrl);
2168     } else {
2169       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2170       // The only problem we have here when offset == min_int
2171       // since (0-min_int) == min_int. It may be fine for stride &gt; 0
2172       // but for stride &lt; 0 X will be &lt; original_limit. To avoid it
2173       // max(pre_limit, original_limit) is used in do_range_check().
2174     }
2175     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2176     *pre_limit = adjust_limit((-stride_con), scale, offset, low_limit, *pre_limit, pre_ctrl,
2177                               scale_con &gt; 1 &amp;&amp; stride_con &gt; 0);
2178 
2179   } else { // stride_con*scale_con &lt; 0
2180     // For negative stride*scale pre-loop checks for overflow and
2181     // post-loop for underflow.
2182     //
2183     // The overflow limit: scale*I+offset &lt; upper_limit
2184     // For pre-loop compute
2185     //   NOT(scale*I+offset &lt; upper_limit)
2186     //   scale*I+offset &gt;= upper_limit
2187     //   scale*I+offset+1 &gt; upper_limit
2188     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2189     //       I &lt; (upper_limit-(offset+1))/scale
2190     //     else /* scale &gt; 0 and stride &lt; 0 */
2191     //       I &gt; (upper_limit-(offset+1))/scale
2192     //   )
2193     //
2194     // (upper_limit-offset-1) may underflow or overflow.
2195     // To avoid it min(pre_limit, original_limit) is used
2196     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2197     Node *one  = _igvn.intcon(1);
2198     set_ctrl(one, C-&gt;root());
2199 
2200     Node *plus_one = new AddINode(offset, one);
2201     register_new_node( plus_one, pre_ctrl );
2202     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2203     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2204                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2205 
2206     if (low_limit-&gt;get_int() == -max_jint) {
2207       // We need this guard when scale*main_limit+offset &gt;= limit
2208       // due to underflow. So we need execute main-loop while
2209       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2210       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2211       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2212       // positive (offset+1) with 0.
2213       //
2214       // Also (min_int+1 == -max_int) is used instead of min_int here
2215       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2216       Node* shift = _igvn.intcon(31);
2217       set_ctrl(shift, C-&gt;root());
2218       Node* sign = new RShiftINode(plus_one, shift);
2219       register_new_node(sign, pre_ctrl);
2220       plus_one = new AndINode(plus_one, sign);
2221       register_new_node(plus_one, pre_ctrl);
2222     } else {
2223       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2224       // The only problem we have here when offset == max_int
2225       // since (max_int+1) == min_int and (0-min_int) == min_int.
2226       // But it is fine since main loop will either have
2227       // less iterations or will be skipped in such case.
2228     }
2229     // The underflow limit: low_limit &lt;= scale*I+offset.
2230     // For main-loop compute
2231     //   scale*I+offset+1 &gt; low_limit
2232     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2233     //       I &lt; (low_limit-(offset+1))/scale
2234     //     else /* scale &gt; 0 and stride &lt; 0 */
2235     //       I &gt; (low_limit-(offset+1))/scale
2236     //   )
2237 
2238     *main_limit = adjust_limit(stride_con, scale, plus_one, low_limit, *main_limit, pre_ctrl,
2239                                false);
2240   }
2241 }
2242 
2243 
2244 //------------------------------is_scaled_iv---------------------------------
2245 // Return true if exp is a constant times an induction var
2246 bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {
2247   if (exp == iv) {
2248     if (p_scale != NULL) {
2249       *p_scale = 1;
2250     }
2251     return true;
2252   }
2253   int opc = exp-&gt;Opcode();
2254   if (opc == Op_MulI) {
2255     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2256       if (p_scale != NULL) {
2257         *p_scale = exp-&gt;in(2)-&gt;get_int();
2258       }
2259       return true;
2260     }
2261     if (exp-&gt;in(2) == iv &amp;&amp; exp-&gt;in(1)-&gt;is_Con()) {
2262       if (p_scale != NULL) {
2263         *p_scale = exp-&gt;in(1)-&gt;get_int();
2264       }
2265       return true;
2266     }
2267   } else if (opc == Op_LShiftI) {
2268     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2269       if (p_scale != NULL) {
2270         *p_scale = 1 &lt;&lt; exp-&gt;in(2)-&gt;get_int();
2271       }
2272       return true;
2273     }
2274   }
2275   return false;
2276 }
2277 
2278 //-----------------------------is_scaled_iv_plus_offset------------------------------
2279 // Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)
2280 bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {
2281   if (is_scaled_iv(exp, iv, p_scale)) {
2282     if (p_offset != NULL) {
2283       Node *zero = _igvn.intcon(0);
2284       set_ctrl(zero, C-&gt;root());
2285       *p_offset = zero;
2286     }
2287     return true;
2288   }
2289   int opc = exp-&gt;Opcode();
2290   if (opc == Op_AddI) {
2291     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2292       if (p_offset != NULL) {
2293         *p_offset = exp-&gt;in(2);
2294       }
2295       return true;
2296     }
2297     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2298       if (p_offset != NULL) {
2299         *p_offset = exp-&gt;in(1);
2300       }
2301       return true;
2302     }
2303     if (exp-&gt;in(2)-&gt;is_Con()) {
2304       Node* offset2 = NULL;
2305       if (depth &lt; 2 &amp;&amp;
2306           is_scaled_iv_plus_offset(exp-&gt;in(1), iv, p_scale,
2307                                    p_offset != NULL ? &amp;offset2 : NULL, depth+1)) {
2308         if (p_offset != NULL) {
2309           Node *ctrl_off2 = get_ctrl(offset2);
2310           Node* offset = new AddINode(offset2, exp-&gt;in(2));
2311           register_new_node(offset, ctrl_off2);
2312           *p_offset = offset;
2313         }
2314         return true;
2315       }
2316     }
2317   } else if (opc == Op_SubI) {
2318     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2319       if (p_offset != NULL) {
2320         Node *zero = _igvn.intcon(0);
2321         set_ctrl(zero, C-&gt;root());
2322         Node *ctrl_off = get_ctrl(exp-&gt;in(2));
2323         Node* offset = new SubINode(zero, exp-&gt;in(2));
2324         register_new_node(offset, ctrl_off);
2325         *p_offset = offset;
2326       }
2327       return true;
2328     }
2329     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2330       if (p_offset != NULL) {
2331         *p_scale *= -1;
2332         *p_offset = exp-&gt;in(1);
2333       }
2334       return true;
2335     }
2336   }
2337   return false;
2338 }
2339 
2340 // Same as PhaseIdealLoop::duplicate_predicates() but for range checks
2341 // eliminated by iteration splitting.
2342 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2343                                                 Node* predicate_proj, int scale_con, Node* offset,
2344                                                 Node* limit, jint stride_con, Node* value) {
2345   bool overflow = false;
2346   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2347   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2348   register_new_node(opaque_bol, predicate_proj);
2349   IfNode* new_iff = NULL;
2350   if (overflow) {
2351     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2352   } else {
2353     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2354   }
2355   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2356   Node* iffalse = new IfFalseNode(new_iff);
2357   register_control(iffalse, _ltree_root, new_iff);
2358   ProjNode* iftrue = new IfTrueNode(new_iff);
2359   register_control(iftrue, loop-&gt;_parent, new_iff);
2360   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2361   register_new_node(frame, C-&gt;start());
2362   Node* halt = new HaltNode(iffalse, frame);
2363   register_control(halt, _ltree_root, iffalse);
2364   C-&gt;root()-&gt;add_req(halt);
2365   return iftrue;
2366 }
2367 
2368 //------------------------------do_range_check---------------------------------
2369 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
2370 int PhaseIdealLoop::do_range_check( IdealLoopTree *loop, Node_List &amp;old_new ) {
2371 #ifndef PRODUCT
2372   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2373     tty-&gt;print(&quot;Range Check Elimination &quot;);
2374     loop-&gt;dump_head();
2375   } else if (TraceLoopOpts) {
2376     tty-&gt;print(&quot;RangeCheck   &quot;);
2377     loop-&gt;dump_head();
2378   }
2379 #endif
2380   assert(RangeCheckElimination, &quot;&quot;);
2381   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2382   // If we fail before trying to eliminate range checks, set multiversion state
2383   int closed_range_checks = 1;
2384 
2385   // protect against stride not being a constant
2386   if (!cl-&gt;stride_is_con())
2387     return closed_range_checks;
2388 
2389   // Find the trip counter; we are iteration splitting based on it
2390   Node *trip_counter = cl-&gt;phi();
2391   // Find the main loop limit; we will trim it&#39;s iterations
2392   // to not ever trip end tests
2393   Node *main_limit = cl-&gt;limit();
2394 
2395   // Check graph shape. Cannot optimize a loop if zero-trip
2396   // Opaque1 node is optimized away and then another round
2397   // of loop opts attempted.
2398   if (!is_canonical_loop_entry(cl)) {
2399     return closed_range_checks;
2400   }
2401 
2402   // Need to find the main-loop zero-trip guard
2403   Node *ctrl  = cl-&gt;skip_predicates();
2404   Node *iffm = ctrl-&gt;in(0);
2405   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2406   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2407 
2408   // Find the pre-loop limit; we will expand its iterations to
2409   // not ever trip low tests.
2410   Node *p_f = iffm-&gt;in(0);
2411   // pre loop may have been optimized out
2412   if (p_f-&gt;Opcode() != Op_IfFalse) {
2413     return closed_range_checks;
2414   }
2415   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2416   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2417   Node *pre_opaq1 = pre_end-&gt;limit();
2418   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2419   // optimized away and then another round of loop opts attempted.
2420   // We can not optimize this particular loop in that case.
2421   if (pre_opaq1-&gt;Opcode() != Op_Opaque1)
2422     return closed_range_checks;
2423   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2424   Node *pre_limit = pre_opaq-&gt;in(1);
2425 
2426   // Where do we put new limit calculations
2427   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2428 
2429   // Ensure the original loop limit is available from the
2430   // pre-loop Opaque1 node.
2431   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
2432   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP)
2433     return closed_range_checks;
2434 
2435   // Must know if its a count-up or count-down loop
2436 
2437   int stride_con = cl-&gt;stride_con();
2438   Node *zero = _igvn.intcon(0);
2439   Node *one  = _igvn.intcon(1);
2440   // Use symmetrical int range [-max_jint,max_jint]
2441   Node *mini = _igvn.intcon(-max_jint);
2442   set_ctrl(zero, C-&gt;root());
2443   set_ctrl(one,  C-&gt;root());
2444   set_ctrl(mini, C-&gt;root());
2445 
2446   // Range checks that do not dominate the loop backedge (ie.
2447   // conditionally executed) can lengthen the pre loop limit beyond
2448   // the original loop limit. To prevent this, the pre limit is
2449   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2450   // stride &lt; 0) when some range_check (rc) is conditionally
2451   // executed.
2452   bool conditional_rc = false;
2453 
2454   // Count number of range checks and reduce by load range limits, if zero,
2455   // the loop is in canonical form to multiversion.
2456   closed_range_checks = 0;
2457 
2458   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2459   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
2460   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
2461   for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {
2462     Node *iff = loop-&gt;_body[i];
2463     if (iff-&gt;Opcode() == Op_If ||
2464         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2465       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2466       // we need loop unswitching instead of iteration splitting.
2467       closed_range_checks++;
2468       Node *exit = loop-&gt;is_loop_exit(iff);
2469       if( !exit ) continue;
2470       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2471 
2472       // Get boolean condition to test
2473       Node *i1 = iff-&gt;in(1);
2474       if( !i1-&gt;is_Bool() ) continue;
2475       BoolNode *bol = i1-&gt;as_Bool();
2476       BoolTest b_test = bol-&gt;_test;
2477       // Flip sense of test if exit condition is flipped
2478       if( flip )
2479         b_test = b_test.negate();
2480 
2481       // Get compare
2482       Node *cmp = bol-&gt;in(1);
2483 
2484       // Look for trip_counter + offset vs limit
2485       Node *rc_exp = cmp-&gt;in(1);
2486       Node *limit  = cmp-&gt;in(2);
2487       int scale_con= 1;        // Assume trip counter not scaled
2488 
2489       Node *limit_c = get_ctrl(limit);
2490       if( loop-&gt;is_member(get_loop(limit_c) ) ) {
2491         // Compare might have operands swapped; commute them
2492         b_test = b_test.commute();
2493         rc_exp = cmp-&gt;in(2);
2494         limit  = cmp-&gt;in(1);
2495         limit_c = get_ctrl(limit);
2496         if( loop-&gt;is_member(get_loop(limit_c) ) )
2497           continue;             // Both inputs are loop varying; cannot RCE
2498       }
2499       // Here we know &#39;limit&#39; is loop invariant
2500 
2501       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2502       // previous round of rce), in which case, it can&#39;t be used in the
2503       // zero trip test expression which must occur before the zero test&#39;s if.
2504       if (is_dominator(ctrl, limit_c)) {
2505         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2506       }
2507 
2508       // Check for scaled induction variable plus an offset
2509       Node *offset = NULL;
2510 
2511       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2512         continue;
2513       }
2514 
2515       Node *offset_c = get_ctrl(offset);
2516       if( loop-&gt;is_member( get_loop(offset_c) ) )
2517         continue;               // Offset is not really loop invariant
2518       // Here we know &#39;offset&#39; is loop invariant.
2519 
2520       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2521       // zero trip test.
2522       if (is_dominator(ctrl, offset_c)) {
2523         continue; // Don&#39;t rce this check but continue looking for other candidates.
2524       }
2525 #ifdef ASSERT
2526       if (TraceRangeLimitCheck) {
2527         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2528         bol-&gt;dump(2);
2529       }
2530 #endif
2531       // At this point we have the expression as:
2532       //   scale_con * trip_counter + offset :: limit
2533       // where scale_con, offset and limit are loop invariant.  Trip_counter
2534       // monotonically increases by stride_con, a constant.  Both (or either)
2535       // stride_con and scale_con can be negative which will flip about the
2536       // sense of the test.
2537 
2538       // Adjust pre and main loop limits to guard the correct iteration set
2539       if( cmp-&gt;Opcode() == Op_CmpU ) {// Unsigned compare is really 2 tests
2540         if( b_test._test == BoolTest::lt ) { // Range checks always use lt
2541           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
2542           add_constraint( stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );
2543           // (0-offset)/scale could be outside of loop iterations range.
2544           conditional_rc = true;
2545           Node* init = cl-&gt;init_trip();
2546           Node* opaque_init = new Opaque1Node(C, init);
2547           register_new_node(opaque_init, predicate_proj);
2548           // template predicate so it can be updated on next unrolling
2549           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2550           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2551           // predicate on first value of first iteration
2552           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2553           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2554           int init_inc = stride_con/cl-&gt;unrolled_count();
2555           assert(init_inc != 0, &quot;invalid loop increment&quot;);
2556           Node* max_value = _igvn.intcon(stride_con - init_inc);
2557           max_value = new AddINode(init, max_value);
2558           register_new_node(max_value, predicate_proj);
2559           // predicate on last value of first iteration (in case unrolling has already happened)
2560           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2561           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2562         } else {
2563           if (PrintOpto) {
2564             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2565           }
2566           continue;             // In release mode, ignore it
2567         }
2568       } else {                  // Otherwise work on normal compares
2569         switch( b_test._test ) {
2570         case BoolTest::gt:
2571           // Fall into GE case
2572         case BoolTest::ge:
2573           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2574           scale_con = -scale_con;
2575           offset = new SubINode( zero, offset );
2576           register_new_node( offset, pre_ctrl );
2577           limit  = new SubINode( zero, limit );
2578           register_new_node( limit, pre_ctrl );
2579           // Fall into LE case
2580         case BoolTest::le:
2581           if (b_test._test != BoolTest::gt) {
2582             // Convert X &lt;= Y to X &lt; Y+1
2583             limit = new AddINode( limit, one );
2584             register_new_node( limit, pre_ctrl );
2585           }
2586           // Fall into LT case
2587         case BoolTest::lt:
2588           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2589           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2590           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
2591           add_constraint( stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );
2592           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2593           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2594           // still be outside of loop range.
2595           conditional_rc = true;
2596           break;
2597         default:
2598           if (PrintOpto) {
2599             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2600           }
2601           continue;             // Unhandled case
2602         }
2603       }
2604 
2605       // Kill the eliminated test
2606       C-&gt;set_major_progress();
2607       Node *kill_con = _igvn.intcon( 1-flip );
2608       set_ctrl(kill_con, C-&gt;root());
2609       _igvn.replace_input_of(iff, 1, kill_con);
2610       // Find surviving projection
2611       assert(iff-&gt;is_If(), &quot;&quot;);
2612       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2613       // Find loads off the surviving projection; remove their control edge
2614       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2615         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2616         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2617           // Allow the load to float around in the loop, or before it
2618           // but NOT before the pre-loop.
2619           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2620           --i;
2621           --imax;
2622         }
2623       }
2624       if (limit-&gt;Opcode() == Op_LoadRange) {
2625         closed_range_checks--;
2626       }
2627 
2628     } // End of is IF
2629 
2630   }
2631   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2632     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2633     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2634   }
2635 
2636   // Update loop limits
2637   if (conditional_rc) {
2638     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2639                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2640     register_new_node(pre_limit, pre_ctrl);
2641   }
2642   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2643 
2644   // Note:: we are making the main loop limit no longer precise;
2645   // need to round up based on stride.
2646   cl-&gt;set_nonexact_trip_count();
2647   Node *main_cle = cl-&gt;loopexit();
2648   Node *main_bol = main_cle-&gt;in(1);
2649   // Hacking loop bounds; need private copies of exit test
2650   if( main_bol-&gt;outcnt() &gt; 1 ) {// BoolNode shared?
2651     main_bol = main_bol-&gt;clone();// Clone a private BoolNode
2652     register_new_node( main_bol, main_cle-&gt;in(0) );
2653     _igvn.replace_input_of(main_cle, 1, main_bol);
2654   }
2655   Node *main_cmp = main_bol-&gt;in(1);
2656   if( main_cmp-&gt;outcnt() &gt; 1 ) { // CmpNode shared?
2657     main_cmp = main_cmp-&gt;clone();// Clone a private CmpNode
2658     register_new_node( main_cmp, main_cle-&gt;in(0) );
2659     _igvn.replace_input_of(main_bol, 1, main_cmp);
2660   }
2661   // Hack the now-private loop bounds
2662   _igvn.replace_input_of(main_cmp, 2, main_limit);
2663   // The OpaqueNode is unshared by design
2664   assert( opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot; );
2665   _igvn.replace_input_of(opqzm, 1, main_limit);
2666 
2667   return closed_range_checks;
2668 }
2669 
2670 //------------------------------has_range_checks-------------------------------
2671 // Check to see if RCE cleaned the current loop of range-checks.
2672 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2673   assert(RangeCheckElimination, &quot;&quot;);
2674 
2675   // skip if not a counted loop
2676   if (!loop-&gt;is_counted()) return;
2677 
2678   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2679 
2680   // skip this loop if it is already checked
2681   if (cl-&gt;has_been_range_checked()) return;
2682 
2683   // Now check for existence of range checks
2684   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2685     Node *iff = loop-&gt;_body[i];
2686     int iff_opc = iff-&gt;Opcode();
2687     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2688       cl-&gt;mark_has_range_checks();
2689       break;
2690     }
2691   }
2692   cl-&gt;set_has_been_range_checked();
2693 }
2694 
2695 //-------------------------multi_version_post_loops----------------------------
2696 // Check the range checks that remain, if simple, use the bounds to guard
2697 // which version to a post loop we execute, one with range checks or one without
2698 bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {
2699   bool multi_version_succeeded = false;
2700   assert(RangeCheckElimination, &quot;&quot;);
2701   CountedLoopNode *legacy_cl = legacy_loop-&gt;_head-&gt;as_CountedLoop();
2702   assert(legacy_cl-&gt;is_post_loop(), &quot;&quot;);
2703 
2704   // Check for existence of range checks using the unique instance to make a guard with
2705   Unique_Node_List worklist;
2706   for (uint i = 0; i &lt; legacy_loop-&gt;_body.size(); i++) {
2707     Node *iff = legacy_loop-&gt;_body[i];
2708     int iff_opc = iff-&gt;Opcode();
2709     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2710       worklist.push(iff);
2711     }
2712   }
2713 
2714   // Find RCE&#39;d post loop so that we can stage its guard.
2715   if (!is_canonical_loop_entry(legacy_cl)) return multi_version_succeeded;
2716   Node* ctrl = legacy_cl-&gt;in(LoopNode::EntryControl);
2717   Node* iffm = ctrl-&gt;in(0);
2718 
2719   // Now we test that both the post loops are connected
2720   Node* post_loop_region = iffm-&gt;in(0);
2721   if (post_loop_region == NULL) return multi_version_succeeded;
2722   if (!post_loop_region-&gt;is_Region()) return multi_version_succeeded;
2723   Node* covering_region = post_loop_region-&gt;in(RegionNode::Control+1);
2724   if (covering_region == NULL) return multi_version_succeeded;
2725   if (!covering_region-&gt;is_Region()) return multi_version_succeeded;
2726   Node* p_f = covering_region-&gt;in(RegionNode::Control);
2727   if (p_f == NULL) return multi_version_succeeded;
2728   if (!p_f-&gt;is_IfFalse()) return multi_version_succeeded;
2729   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return multi_version_succeeded;
2730   CountedLoopEndNode* rce_loop_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2731   if (rce_loop_end == NULL) return multi_version_succeeded;
2732   CountedLoopNode* rce_cl = rce_loop_end-&gt;loopnode();
2733   if (rce_cl == NULL || !rce_cl-&gt;is_post_loop()) return multi_version_succeeded;
2734   CountedLoopNode *known_rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2735   if (rce_cl != known_rce_cl) return multi_version_succeeded;
2736 
2737   // Then we fetch the cover entry test
2738   ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2739   if (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse()) return multi_version_succeeded;
2740 
2741 #ifndef PRODUCT
2742   if (TraceLoopOpts) {
2743     tty-&gt;print(&quot;PostMultiVersion\n&quot;);
2744     rce_loop-&gt;dump_head();
2745     legacy_loop-&gt;dump_head();
2746   }
2747 #endif
2748 
2749   // Now fetch the limit we want to compare against
2750   Node *limit = rce_cl-&gt;limit();
2751   bool first_time = true;
2752 
2753   // If we got this far, we identified the post loop which has been RCE&#39;d and
2754   // we have a work list.  Now we will try to transform the if guard to cause
2755   // the loop pair to be multi version executed with the determination left to runtime
2756   // or the optimizer if full information is known about the given arrays at compile time.
2757   Node *last_min = NULL;
2758   multi_version_succeeded = true;
2759   while (worklist.size()) {
2760     Node* rc_iffm = worklist.pop();
2761     if (rc_iffm-&gt;is_If()) {
2762       Node *rc_bolzm = rc_iffm-&gt;in(1);
2763       if (rc_bolzm-&gt;is_Bool()) {
2764         Node *rc_cmpzm = rc_bolzm-&gt;in(1);
2765         if (rc_cmpzm-&gt;is_Cmp()) {
2766           Node *rc_left = rc_cmpzm-&gt;in(2);
2767           if (rc_left-&gt;Opcode() != Op_LoadRange) {
2768             multi_version_succeeded = false;
2769             break;
2770           }
2771           if (first_time) {
2772             last_min = rc_left;
2773             first_time = false;
2774           } else {
2775             Node *cur_min = new MinINode(last_min, rc_left);
2776             last_min = cur_min;
2777             _igvn.register_new_node_with_optimizer(last_min);
2778           }
2779         }
2780       }
2781     }
2782   }
2783 
2784   // All we have to do is update the limit of the rce loop
2785   // with the min of our expression and the current limit.
2786   // We will use this expression to replace the current limit.
2787   if (last_min &amp;&amp; multi_version_succeeded) {
2788     Node *cur_min = new MinINode(last_min, limit);
2789     _igvn.register_new_node_with_optimizer(cur_min);
2790     Node *cmp_node = rce_loop_end-&gt;cmp_node();
2791     _igvn.replace_input_of(cmp_node, 2, cur_min);
2792     set_ctrl(cur_min, ctrl);
2793     set_loop(cur_min, rce_loop-&gt;_parent);
2794 
2795     legacy_cl-&gt;mark_is_multiversioned();
2796     rce_cl-&gt;mark_is_multiversioned();
2797     multi_version_succeeded = true;
2798 
2799     C-&gt;set_major_progress();
2800   }
2801 
2802   return multi_version_succeeded;
2803 }
2804 
2805 //-------------------------poison_rce_post_loop--------------------------------
2806 // Causes the rce&#39;d post loop to be optimized away if multiversioning fails
2807 void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {
2808   CountedLoopNode *rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2809   Node* ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2810   if (ctrl-&gt;is_IfTrue() || ctrl-&gt;is_IfFalse()) {
2811     Node* iffm = ctrl-&gt;in(0);
2812     if (iffm-&gt;is_If()) {
2813       Node* cur_bool = iffm-&gt;in(1);
2814       if (cur_bool-&gt;is_Bool()) {
2815         Node* cur_cmp = cur_bool-&gt;in(1);
2816         if (cur_cmp-&gt;is_Cmp()) {
2817           BoolTest::mask new_test = BoolTest::gt;
2818           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2819           _igvn.replace_node(cur_bool, new_bool);
2820           _igvn._worklist.push(new_bool);
2821           Node* left_op = cur_cmp-&gt;in(1);
2822           _igvn.replace_input_of(cur_cmp, 2, left_op);
2823           C-&gt;set_major_progress();
2824         }
2825       }
2826     }
2827   }
2828 }
2829 
2830 //------------------------------DCE_loop_body----------------------------------
2831 // Remove simplistic dead code from loop body
2832 void IdealLoopTree::DCE_loop_body() {
2833   for( uint i = 0; i &lt; _body.size(); i++ )
2834     if( _body.at(i)-&gt;outcnt() == 0 )
2835       _body.map( i--, _body.pop() );
2836 }
2837 
2838 
2839 //------------------------------adjust_loop_exit_prob--------------------------
2840 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2841 // Replace with a 1-in-10 exit guess.
2842 void IdealLoopTree::adjust_loop_exit_prob( PhaseIdealLoop *phase ) {
2843   Node *test = tail();
2844   while( test != _head ) {
2845     uint top = test-&gt;Opcode();
2846     if( top == Op_IfTrue || top == Op_IfFalse ) {
2847       int test_con = ((ProjNode*)test)-&gt;_con;
2848       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2849       IfNode *iff = test-&gt;in(0)-&gt;as_If();
2850       if( iff-&gt;outcnt() == 2 ) {        // Ignore dead tests
2851         Node *bol = iff-&gt;in(1);
2852         if( bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;
2853             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional ) ||
2854              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional ) ||
2855              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional ) ||
2856              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB ) ||
2857              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS ) ||
2858              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI ) ||
2859              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL ) ||
2860              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP ) ||
2861              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN ) ||
2862              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB ) ||
2863              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS ) ||
2864              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI ) ||
2865              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL ) ||
2866              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP ) ||
2867              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN ) ||
2868              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB ) ||
2869              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS ) ||
2870              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI ) ||
2871              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL ) ||
2872              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP ) ||
2873              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN ) ||
2874              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ) ||
2875              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN ) ||
2876              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP ) ||
2877              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN ) ||
2878              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP ) ||
2879              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN )))
2880           return;               // Allocation loops RARELY take backedge
2881         // Find the OTHER exit path from the IF
2882         Node* ex = iff-&gt;proj_out(1-test_con);
2883         float p = iff-&gt;_prob;
2884         if( !phase-&gt;is_member( this, ex ) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN ) {
2885           if( top == Op_IfTrue ) {
2886             if( p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {
2887               iff-&gt;_prob = PROB_STATIC_FREQUENT;
2888             }
2889           } else {
2890             if( p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {
2891               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
2892             }
2893           }
2894         }
2895       }
2896     }
2897     test = phase-&gt;idom(test);
2898   }
2899 }
2900 
2901 #ifdef ASSERT
2902 static CountedLoopNode* locate_pre_from_main(CountedLoopNode *cl) {
2903   Node *ctrl  = cl-&gt;skip_predicates();
2904   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
2905   Node *iffm = ctrl-&gt;in(0);
2906   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
2907   Node *p_f = iffm-&gt;in(0);
2908   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
2909   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2910   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2911   return pre_end-&gt;loopnode();
2912 }
2913 #endif
2914 
2915 // Remove the main and post loops and make the pre loop execute all
2916 // iterations. Useful when the pre loop is found empty.
2917 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
2918   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
2919   Node* pre_cmp = pre_end-&gt;cmp_node();
2920   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
2921     // Only safe to remove the main loop if the compiler optimized it
2922     // out based on an unknown number of iterations
2923     return;
2924   }
2925 
2926   // Can we find the main loop?
2927   if (_next == NULL) {
2928     return;
2929   }
2930 
2931   Node* next_head = _next-&gt;_head;
2932   if (!next_head-&gt;is_CountedLoop()) {
2933     return;
2934   }
2935 
2936   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
2937   if (!main_head-&gt;is_main_loop()) {
2938     return;
2939   }
2940 
2941   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
2942   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
2943 
2944   // Remove the Opaque1Node of the pre loop and make it execute all iterations
2945   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
2946   // Remove the Opaque1Node of the main loop so it can be optimized out
2947   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
2948   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
2949   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
2950 }
2951 
2952 //------------------------------policy_do_remove_empty_loop--------------------
2953 // Micro-benchmark spamming.  Policy is to always remove empty loops.
2954 // The &#39;DO&#39; part is to replace the trip counter with the value it will
2955 // have on the last iteration.  This will break the loop.
2956 bool IdealLoopTree::policy_do_remove_empty_loop( PhaseIdealLoop *phase ) {
2957   // Minimum size must be empty loop
2958   if (_body.size() &gt; EMPTY_LOOP_SIZE)
2959     return false;
2960 
2961   if (!_head-&gt;is_CountedLoop())
2962     return false;     // Dead loop
2963   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
2964   if (!cl-&gt;is_valid_counted_loop())
2965     return false; // Malformed loop
2966   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))
2967     return false;             // Infinite loop
2968 
2969   if (cl-&gt;is_pre_loop()) {
2970     // If the loop we are removing is a pre-loop then the main and
2971     // post loop can be removed as well
2972     remove_main_post_loops(cl, phase);
2973   }
2974 
2975 #ifdef ASSERT
2976   // Ensure only one phi which is the iv.
2977   Node* iv = NULL;
2978   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
2979     Node* n = cl-&gt;fast_out(i);
2980     if (n-&gt;Opcode() == Op_Phi) {
2981       assert(iv == NULL, &quot;Too many phis&quot; );
2982       iv = n;
2983     }
2984   }
2985   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot; );
2986 #endif
2987 
2988   // main and post loops have explicitly created zero trip guard
2989   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
2990   if (needs_guard) {
2991     // Skip guard if values not overlap.
2992     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
2993     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
2994     int  stride_con = cl-&gt;stride_con();
2995     if (stride_con &gt; 0) {
2996       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
2997     } else {
2998       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
2999     }
3000   }
3001   if (needs_guard) {
3002     // Check for an obvious zero trip guard.
3003     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3004     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3005       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
3006       // The test should look like just the backedge of a CountedLoop
3007       Node* iff = inctrl-&gt;in(0);
3008       if (iff-&gt;is_If()) {
3009         Node* bol = iff-&gt;in(1);
3010         if (bol-&gt;is_Bool()) {
3011           BoolTest test = bol-&gt;as_Bool()-&gt;_test;
3012           if (maybe_swapped) {
3013             test._test = test.commute();
3014             test._test = test.negate();
3015           }
3016           if (test._test == cl-&gt;loopexit()-&gt;test_trip()) {
3017             Node* cmp = bol-&gt;in(1);
3018             int init_idx = maybe_swapped ? 2 : 1;
3019             int limit_idx = maybe_swapped ? 1 : 2;
3020             if (cmp-&gt;is_Cmp() &amp;&amp; cmp-&gt;in(init_idx) == cl-&gt;init_trip() &amp;&amp; cmp-&gt;in(limit_idx) == cl-&gt;limit()) {
3021               needs_guard = false;
3022             }
3023           }
3024         }
3025       }
3026     }
3027   }
3028 
3029 #ifndef PRODUCT
3030   if (PrintOpto) {
3031     tty-&gt;print(&quot;Removing empty loop with%s zero trip guard&quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3032     this-&gt;dump_head();
3033   } else if (TraceLoopOpts) {
3034     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3035     this-&gt;dump_head();
3036   }
3037 #endif
3038 
3039   if (needs_guard) {
3040     // Peel the loop to ensure there&#39;s a zero trip guard
3041     Node_List old_new;
3042     phase-&gt;do_peeling(this, old_new);
3043   }
3044 
3045   // Replace the phi at loop head with the final value of the last
3046   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3047   // taken) and all loop-invariant uses of the exit values will be correct.
3048   Node *phi = cl-&gt;phi();
3049   Node *exact_limit = phase-&gt;exact_limit(this);
3050   if (exact_limit != cl-&gt;limit()) {
3051     // We also need to replace the original limit to collapse loop exit.
3052     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3053     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
3054     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3055     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3056   }
3057   // Note: the final value after increment should not overflow since
3058   // counted loop has limit check predicate.
3059   Node *final = new SubINode( exact_limit, cl-&gt;stride() );
3060   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3061   phase-&gt;_igvn.replace_node(phi,final);
3062   phase-&gt;C-&gt;set_major_progress();
3063   return true;
3064 }
3065 
3066 //------------------------------policy_do_one_iteration_loop-------------------
3067 // Convert one iteration loop into normal code.
3068 bool IdealLoopTree::policy_do_one_iteration_loop( PhaseIdealLoop *phase ) {
3069   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop())
3070     return false; // Only for counted loop
3071 
3072   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3073   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3074     return false;
3075   }
3076 
3077 #ifndef PRODUCT
3078   if(TraceLoopOpts) {
3079     tty-&gt;print(&quot;OneIteration &quot;);
3080     this-&gt;dump_head();
3081   }
3082 #endif
3083 
3084   Node *init_n = cl-&gt;init_trip();
3085 #ifdef ASSERT
3086   // Loop boundaries should be constant since trip count is exact.
3087   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3088 #endif
3089   // Replace the phi at loop head with the value of the init_trip.
3090   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3091   // and all loop-invariant uses of the exit values will be correct.
3092   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3093   phase-&gt;C-&gt;set_major_progress();
3094   return true;
3095 }
3096 
3097 //=============================================================================
3098 //------------------------------iteration_split_impl---------------------------
3099 bool IdealLoopTree::iteration_split_impl( PhaseIdealLoop *phase, Node_List &amp;old_new ) {
3100   // Compute loop trip count if possible.
3101   compute_trip_count(phase);
3102 
3103   // Convert one iteration loop into normal code.
3104   if (policy_do_one_iteration_loop(phase))
3105     return true;
3106 
3107   // Check and remove empty loops (spam micro-benchmarks)
3108   if (policy_do_remove_empty_loop(phase))
3109     return true;  // Here we removed an empty loop
3110 
3111   bool should_peel = policy_peeling(phase); // Should we peel?
3112 
3113   bool should_unswitch = policy_unswitching(phase);
3114 
3115   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3116   // This removes loop-invariant tests (usually null checks).
3117   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3118     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3119       // Partial peel succeeded so terminate this round of loop opts
3120       return false;
3121     }
3122     if (should_peel) {            // Should we peel?
3123       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
3124       phase-&gt;do_peeling(this,old_new);
3125     } else if (should_unswitch) {
3126       phase-&gt;do_unswitching(this, old_new);
3127     }
3128     return true;
3129   }
3130   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3131 
3132   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3133 
3134   // Do nothing special to pre- and post- loops
3135   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3136 
3137   // Compute loop trip count from profile data
3138   compute_profile_trip_cnt(phase);
3139 
3140   // Before attempting fancy unrolling, RCE or alignment, see if we want
3141   // to completely unroll this loop or do loop unswitching.
3142   if (cl-&gt;is_normal_loop()) {
3143     if (should_unswitch) {
3144       phase-&gt;do_unswitching(this, old_new);
3145       return true;
3146     }
3147     bool should_maximally_unroll =  policy_maximally_unroll(phase);
3148     if (should_maximally_unroll) {
3149       // Here we did some unrolling and peeling.  Eventually we will
3150       // completely unroll this loop and it will no longer be a loop.
3151       phase-&gt;do_maximally_unroll(this,old_new);
3152       return true;
3153     }
3154   }
3155 
3156   // Skip next optimizations if running low on nodes. Note that
3157   // policy_unswitching and policy_maximally_unroll have this check.
3158   int nodes_left = phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes();
3159   if ((int)(2 * _body.size()) &gt; nodes_left) {
3160     return true;
3161   }
3162 
3163   // Counted loops may be peeled, may need some iterations run up
3164   // front for RCE, and may want to align loop refs to a cache
3165   // line.  Thus we clone a full loop up front whose trip count is
3166   // at least 1 (if peeling), but may be several more.
3167 
3168   // The main loop will start cache-line aligned with at least 1
3169   // iteration of the unrolled body (zero-trip test required) and
3170   // will have some range checks removed.
3171 
3172   // A post-loop will finish any odd iterations (leftover after
3173   // unrolling), plus any needed for RCE purposes.
3174 
3175   bool should_unroll = policy_unroll(phase);
3176 
3177   bool should_rce = policy_range_check(phase);
3178 
3179   bool should_align = policy_align(phase);
3180 
3181   // If not RCE&#39;ing (iteration splitting) or Aligning, then we do not
3182   // need a pre-loop.  We may still need to peel an initial iteration but
3183   // we will not be needing an unknown number of pre-iterations.
3184   //
3185   // Basically, if may_rce_align reports FALSE first time through,
3186   // we will not be able to later do RCE or Aligning on this loop.
3187   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3188 
3189   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3190   // we switch to the pre-/main-/post-loop model.  This model also covers
3191   // peeling.
3192   if (should_rce || should_align || should_unroll) {
3193     if (cl-&gt;is_normal_loop())  // Convert to &#39;pre/main/post&#39; loops
3194       phase-&gt;insert_pre_post_loops(this,old_new, !may_rce_align);
3195 
3196     // Adjust the pre- and main-loop limits to let the pre and post loops run
3197     // with full checks, but the main-loop with no checks.  Remove said
3198     // checks from the main body.
3199     if (should_rce) {
3200       if (phase-&gt;do_range_check(this, old_new) != 0) {
3201         cl-&gt;mark_has_range_checks();
3202       }
3203     } else if (PostLoopMultiversioning) {
3204       phase-&gt;has_range_checks(this);
3205     }
3206 
3207     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3208       // Try to setup multiversioning on main loops before they are unrolled
3209       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3210         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3211       }
3212     }
3213 
3214     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3215     // twice as many iterations as before) and the main body limit (only do
3216     // an even number of trips).  If we are peeling, we might enable some RCE
3217     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3218     // peeling.
3219     if (should_unroll &amp;&amp; !should_peel) {
3220       if (SuperWordLoopUnrollAnalysis) {
3221         phase-&gt;insert_vector_post_loop(this, old_new);
3222       }
3223       phase-&gt;do_unroll(this, old_new, true);
3224     }
3225 
3226     // Adjust the pre-loop limits to align the main body
3227     // iterations.
3228     if (should_align)
3229       Unimplemented();
3230 
3231   } else {                      // Else we have an unchanged counted loop
3232     if (should_peel)           // Might want to peel but do nothing else
3233       phase-&gt;do_peeling(this,old_new);
3234   }
3235   return true;
3236 }
3237 
3238 
3239 //=============================================================================
3240 //------------------------------iteration_split--------------------------------
3241 bool IdealLoopTree::iteration_split( PhaseIdealLoop *phase, Node_List &amp;old_new ) {
3242   // Recursively iteration split nested loops
3243   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new))
3244     return false;
3245 
3246   // Clean out prior deadwood
3247   DCE_loop_body();
3248 
3249 
3250   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3251   // Replace with a 1-in-10 exit guess.
3252   if (_parent /*not the root loop*/ &amp;&amp;
3253       !_irreducible &amp;&amp;
3254       // Also ignore the occasional dead backedge
3255       !tail()-&gt;is_top()) {
3256     adjust_loop_exit_prob(phase);
3257   }
3258 
3259   // Gate unrolling, RCE and peeling efforts.
3260   if (!_child &amp;&amp;                // If not an inner loop, do not split
3261       !_irreducible &amp;&amp;
3262       _allow_optimizations &amp;&amp;
3263       !tail()-&gt;is_top()) {     // Also ignore the occasional dead backedge
3264     if (!_has_call) {
3265         if (!iteration_split_impl(phase, old_new)) {
3266           return false;
3267         }
3268     } else if (policy_unswitching(phase)) {
3269       phase-&gt;do_unswitching(this, old_new);
3270     }
3271   }
3272 
3273   // Minor offset re-organization to remove loop-fallout uses of
3274   // trip counter when there was no major reshaping.
3275   phase-&gt;reorg_offsets(this);
3276 
3277   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new))
3278     return false;
3279   return true;
3280 }
3281 
3282 
3283 //=============================================================================
3284 // Process all the loops in the loop tree and replace any fill
3285 // patterns with an intrinsic version.
3286 bool PhaseIdealLoop::do_intrinsify_fill() {
3287   bool changed = false;
3288   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3289     IdealLoopTree* lpt = iter.current();
3290     changed |= intrinsify_fill(lpt);
3291   }
3292   return changed;
3293 }
3294 
3295 
3296 // Examine an inner loop looking for a a single store of an invariant
3297 // value in a unit stride loop,
3298 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
3299                                      Node*&amp; shift, Node*&amp; con) {
3300   const char* msg = NULL;
3301   Node* msg_node = NULL;
3302 
3303   store_value = NULL;
3304   con = NULL;
3305   shift = NULL;
3306 
3307   // Process the loop looking for stores.  If there are multiple
3308   // stores or extra control flow give at this point.
3309   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3310   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3311     Node* n = lpt-&gt;_body.at(i);
3312     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3313     if (n-&gt;is_Store()) {
3314       if (store != NULL) {
3315         msg = &quot;multiple stores&quot;;
3316         break;
3317       }
3318       int opc = n-&gt;Opcode();
3319       if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {
3320         msg = &quot;oop fills not handled&quot;;
3321         break;
3322       }
3323       Node* value = n-&gt;in(MemNode::ValueIn);
3324       if (!lpt-&gt;is_invariant(value)) {
3325         msg  = &quot;variant store value&quot;;
3326       } else if (!_igvn.type(n-&gt;in(MemNode::Address))-&gt;isa_aryptr()) {
3327         msg = &quot;not array address&quot;;
3328       }
3329       store = n;
3330       store_value = value;
3331     } else if (n-&gt;is_If() &amp;&amp; n != head-&gt;loopexit_or_null()) {
3332       msg = &quot;extra control flow&quot;;
3333       msg_node = n;
3334     }
3335   }
3336 
3337   if (store == NULL) {
3338     // No store in loop
3339     return false;
3340   }
3341 
3342   if (msg == NULL &amp;&amp; head-&gt;stride_con() != 1) {
3343     // could handle negative strides too
3344     if (head-&gt;stride_con() &lt; 0) {
3345       msg = &quot;negative stride&quot;;
3346     } else {
3347       msg = &quot;non-unit stride&quot;;
3348     }
3349   }
3350 
3351   if (msg == NULL &amp;&amp; !store-&gt;in(MemNode::Address)-&gt;is_AddP()) {
3352     msg = &quot;can&#39;t handle store address&quot;;
3353     msg_node = store-&gt;in(MemNode::Address);
3354   }
3355 
3356   if (msg == NULL &amp;&amp;
3357       (!store-&gt;in(MemNode::Memory)-&gt;is_Phi() ||
3358        store-&gt;in(MemNode::Memory)-&gt;in(LoopNode::LoopBackControl) != store)) {
3359     msg = &quot;store memory isn&#39;t proper phi&quot;;
3360     msg_node = store-&gt;in(MemNode::Memory);
3361   }
3362 
3363   // Make sure there is an appropriate fill routine
3364   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3365   const char* fill_name;
3366   if (msg == NULL &amp;&amp;
3367       StubRoutines::select_fill_function(t, false, fill_name) == NULL) {
3368     msg = &quot;unsupported store&quot;;
3369     msg_node = store;
3370   }
3371 
3372   if (msg != NULL) {
3373 #ifndef PRODUCT
3374     if (TraceOptimizeFill) {
3375       tty-&gt;print_cr(&quot;not fill intrinsic candidate: %s&quot;, msg);
3376       if (msg_node != NULL) msg_node-&gt;dump();
3377     }
3378 #endif
3379     return false;
3380   }
3381 
3382   // Make sure the address expression can be handled.  It should be
3383   // head-&gt;phi * elsize + con.  head-&gt;phi might have a ConvI2L(CastII()).
3384   Node* elements[4];
3385   Node* cast = NULL;
3386   Node* conv = NULL;
3387   bool found_index = false;
3388   int count = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;unpack_offsets(elements, ARRAY_SIZE(elements));
3389   for (int e = 0; e &lt; count; e++) {
3390     Node* n = elements[e];
3391     if (n-&gt;is_Con() &amp;&amp; con == NULL) {
3392       con = n;
3393     } else if (n-&gt;Opcode() == Op_LShiftX &amp;&amp; shift == NULL) {
3394       Node* value = n-&gt;in(1);
3395 #ifdef _LP64
3396       if (value-&gt;Opcode() == Op_ConvI2L) {
3397         conv = value;
3398         value = value-&gt;in(1);
3399       }
3400       if (value-&gt;Opcode() == Op_CastII &amp;&amp;
3401           value-&gt;as_CastII()-&gt;has_range_check()) {
3402         // Skip range check dependent CastII nodes
3403         cast = value;
3404         value = value-&gt;in(1);
3405       }
3406 #endif
3407       if (value != head-&gt;phi()) {
3408         msg = &quot;unhandled shift in address&quot;;
3409       } else {
3410         if (type2aelembytes(store-&gt;as_Mem()-&gt;memory_type(), true) != (1 &lt;&lt; n-&gt;in(2)-&gt;get_int())) {
3411           msg = &quot;scale doesn&#39;t match&quot;;
3412         } else {
3413           found_index = true;
3414           shift = n;
3415         }
3416       }
3417     } else if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; conv == NULL) {
3418       conv = n;
3419       n = n-&gt;in(1);
3420       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3421           n-&gt;as_CastII()-&gt;has_range_check()) {
3422         // Skip range check dependent CastII nodes
3423         cast = n;
3424         n = n-&gt;in(1);
3425       }
3426       if (n == head-&gt;phi()) {
3427         found_index = true;
3428       } else {
3429         msg = &quot;unhandled input to ConvI2L&quot;;
3430       }
3431     } else if (n == head-&gt;phi()) {
3432       // no shift, check below for allowed cases
3433       found_index = true;
3434     } else {
3435       msg = &quot;unhandled node in address&quot;;
3436       msg_node = n;
3437     }
3438   }
3439 
3440   if (count == -1) {
3441     msg = &quot;malformed address expression&quot;;
3442     msg_node = store;
3443   }
3444 
3445   if (!found_index) {
3446     msg = &quot;missing use of index&quot;;
3447   }
3448 
3449   // byte sized items won&#39;t have a shift
3450   if (msg == NULL &amp;&amp; shift == NULL &amp;&amp; t != T_BYTE &amp;&amp; t != T_BOOLEAN) {
3451     msg = &quot;can&#39;t find shift&quot;;
3452     msg_node = store;
3453   }
3454 
3455   if (msg != NULL) {
3456 #ifndef PRODUCT
3457     if (TraceOptimizeFill) {
3458       tty-&gt;print_cr(&quot;not fill intrinsic: %s&quot;, msg);
3459       if (msg_node != NULL) msg_node-&gt;dump();
3460     }
3461 #endif
3462     return false;
3463   }
3464 
3465   // No make sure all the other nodes in the loop can be handled
3466   VectorSet ok(Thread::current()-&gt;resource_area());
3467 
3468   // store related values are ok
3469   ok.set(store-&gt;_idx);
3470   ok.set(store-&gt;in(MemNode::Memory)-&gt;_idx);
3471 
3472   CountedLoopEndNode* loop_exit = head-&gt;loopexit();
3473 
3474   // Loop structure is ok
3475   ok.set(head-&gt;_idx);
3476   ok.set(loop_exit-&gt;_idx);
3477   ok.set(head-&gt;phi()-&gt;_idx);
3478   ok.set(head-&gt;incr()-&gt;_idx);
3479   ok.set(loop_exit-&gt;cmp_node()-&gt;_idx);
3480   ok.set(loop_exit-&gt;in(1)-&gt;_idx);
3481 
3482   // Address elements are ok
3483   if (con)   ok.set(con-&gt;_idx);
3484   if (shift) ok.set(shift-&gt;_idx);
3485   if (cast)  ok.set(cast-&gt;_idx);
3486   if (conv)  ok.set(conv-&gt;_idx);
3487 
3488   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3489     Node* n = lpt-&gt;_body.at(i);
3490     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3491     if (ok.test(n-&gt;_idx)) continue;
3492     // Backedge projection is ok
3493     if (n-&gt;is_IfTrue() &amp;&amp; n-&gt;in(0) == loop_exit) continue;
3494     if (!n-&gt;is_AddP()) {
3495       msg = &quot;unhandled node&quot;;
3496       msg_node = n;
3497       break;
3498     }
3499   }
3500 
3501   // Make sure no unexpected values are used outside the loop
3502   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3503     Node* n = lpt-&gt;_body.at(i);
3504     // These values can be replaced with other nodes if they are used
3505     // outside the loop.
3506     if (n == store || n == loop_exit || n == head-&gt;incr() || n == store-&gt;in(MemNode::Memory)) continue;
3507     for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {
3508       Node* use = iter.get();
3509       if (!lpt-&gt;_body.contains(use)) {
3510         msg = &quot;node is used outside loop&quot;;
3511         // lpt-&gt;_body.dump();
3512         msg_node = n;
3513         break;
3514       }
3515     }
3516   }
3517 
3518 #ifdef ASSERT
3519   if (TraceOptimizeFill) {
3520     if (msg != NULL) {
3521       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3522       if (msg_node != NULL) msg_node-&gt;dump();
3523     } else {
3524       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3525     }
3526     store-&gt;dump();
3527     if (Verbose) {
3528       lpt-&gt;_body.dump();
3529     }
3530   }
3531 #endif
3532 
3533   return msg == NULL;
3534 }
3535 
3536 
3537 
3538 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3539   // Only for counted inner loops
3540   if (!lpt-&gt;is_counted() || !lpt-&gt;is_inner()) {
3541     return false;
3542   }
3543 
3544   // Must have constant stride
3545   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3546   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3547     return false;
3548   }
3549 
3550   head-&gt;verify_strip_mined(1);
3551 
3552   // Check that the body only contains a store of a loop invariant
3553   // value that is indexed by the loop phi.
3554   Node* store = NULL;
3555   Node* store_value = NULL;
3556   Node* shift = NULL;
3557   Node* offset = NULL;
3558   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3559     return false;
3560   }
3561 
3562   Node* exit = head-&gt;loopexit()-&gt;proj_out_or_null(0);
3563   if (exit == NULL) {
3564     return false;
3565   }
3566 
3567 #ifndef PRODUCT
3568   if (TraceLoopOpts) {
3569     tty-&gt;print(&quot;ArrayFill    &quot;);
3570     lpt-&gt;dump_head();
3571   }
3572 #endif
3573 
3574   // Now replace the whole loop body by a call to a fill routine that
3575   // covers the same region as the loop.
3576   Node* base = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;in(AddPNode::Base);
3577 
3578   // Build an expression for the beginning of the copy region
3579   Node* index = head-&gt;init_trip();
3580 #ifdef _LP64
3581   index = new ConvI2LNode(index);
3582   _igvn.register_new_node_with_optimizer(index);
3583 #endif
3584   if (shift != NULL) {
3585     // byte arrays don&#39;t require a shift but others do.
3586     index = new LShiftXNode(index, shift-&gt;in(2));
3587     _igvn.register_new_node_with_optimizer(index);
3588   }
3589   index = new AddPNode(base, base, index);
3590   _igvn.register_new_node_with_optimizer(index);
3591   Node* from = new AddPNode(base, index, offset);
3592   _igvn.register_new_node_with_optimizer(from);
3593   // Compute the number of elements to copy
3594   Node* len = new SubINode(head-&gt;limit(), head-&gt;init_trip());
3595   _igvn.register_new_node_with_optimizer(len);
3596 
3597   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3598   bool aligned = false;
3599   if (offset != NULL &amp;&amp; head-&gt;init_trip()-&gt;is_Con()) {
3600     int element_size = type2aelembytes(t);
3601     aligned = (offset-&gt;find_intptr_t_type()-&gt;get_con() + head-&gt;init_trip()-&gt;get_int() * element_size) % HeapWordSize == 0;
3602   }
3603 
3604   // Build a call to the fill routine
3605   const char* fill_name;
3606   address fill = StubRoutines::select_fill_function(t, aligned, fill_name);
3607   assert(fill != NULL, &quot;what?&quot;);
3608 
3609   // Convert float/double to int/long for fill routines
3610   if (t == T_FLOAT) {
3611     store_value = new MoveF2INode(store_value);
3612     _igvn.register_new_node_with_optimizer(store_value);
3613   } else if (t == T_DOUBLE) {
3614     store_value = new MoveD2LNode(store_value);
3615     _igvn.register_new_node_with_optimizer(store_value);
3616   }
3617 
3618   Node* mem_phi = store-&gt;in(MemNode::Memory);
3619   Node* result_ctrl;
3620   Node* result_mem;
3621   const TypeFunc* call_type = OptoRuntime::array_fill_Type();
3622   CallLeafNode *call = new CallLeafNoFPNode(call_type, fill,
3623                                             fill_name, TypeAryPtr::get_array_body_type(t));
3624   uint cnt = 0;
3625   call-&gt;init_req(TypeFunc::Parms + cnt++, from);
3626   call-&gt;init_req(TypeFunc::Parms + cnt++, store_value);
3627 #ifdef _LP64
3628   len = new ConvI2LNode(len);
3629   _igvn.register_new_node_with_optimizer(len);
3630 #endif
3631   call-&gt;init_req(TypeFunc::Parms + cnt++, len);
3632 #ifdef _LP64
3633   call-&gt;init_req(TypeFunc::Parms + cnt++, C-&gt;top());
3634 #endif
3635   call-&gt;init_req(TypeFunc::Control,   head-&gt;init_control());
3636   call-&gt;init_req(TypeFunc::I_O,       C-&gt;top());       // Does no I/O.
3637   call-&gt;init_req(TypeFunc::Memory,    mem_phi-&gt;in(LoopNode::EntryControl));
3638   call-&gt;init_req(TypeFunc::ReturnAdr, C-&gt;start()-&gt;proj_out_or_null(TypeFunc::ReturnAdr));
3639   call-&gt;init_req(TypeFunc::FramePtr,  C-&gt;start()-&gt;proj_out_or_null(TypeFunc::FramePtr));
3640   _igvn.register_new_node_with_optimizer(call);
3641   result_ctrl = new ProjNode(call,TypeFunc::Control);
3642   _igvn.register_new_node_with_optimizer(result_ctrl);
3643   result_mem = new ProjNode(call,TypeFunc::Memory);
3644   _igvn.register_new_node_with_optimizer(result_mem);
3645 
3646 /* Disable following optimization until proper fix (add missing checks).
3647 
3648   // If this fill is tightly coupled to an allocation and overwrites
3649   // the whole body, allow it to take over the zeroing.
3650   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
3651   if (alloc != NULL &amp;&amp; alloc-&gt;is_AllocateArray()) {
3652     Node* length = alloc-&gt;as_AllocateArray()-&gt;Ideal_length();
3653     if (head-&gt;limit() == length &amp;&amp;
3654         head-&gt;init_trip() == _igvn.intcon(0)) {
3655       if (TraceOptimizeFill) {
3656         tty-&gt;print_cr(&quot;Eliminated zeroing in allocation&quot;);
3657       }
3658       alloc-&gt;maybe_set_complete(&amp;_igvn);
3659     } else {
3660 #ifdef ASSERT
3661       if (TraceOptimizeFill) {
3662         tty-&gt;print_cr(&quot;filling array but bounds don&#39;t match&quot;);
3663         alloc-&gt;dump();
3664         head-&gt;init_trip()-&gt;dump();
3665         head-&gt;limit()-&gt;dump();
3666         length-&gt;dump();
3667       }
3668 #endif
3669     }
3670   }
3671 */
3672 
3673   if (head-&gt;is_strip_mined()) {
3674     // Inner strip mined loop goes away so get rid of outer strip
3675     // mined loop
3676     Node* outer_sfpt = head-&gt;outer_safepoint();
3677     Node* in = outer_sfpt-&gt;in(0);
3678     Node* outer_out = head-&gt;outer_loop_exit();
3679     lazy_replace(outer_out, in);
3680     _igvn.replace_input_of(outer_sfpt, 0, C-&gt;top());
3681   }
3682 
3683   // Redirect the old control and memory edges that are outside the loop.
3684   // Sometimes the memory phi of the head is used as the outgoing
3685   // state of the loop.  It&#39;s safe in this case to replace it with the
3686   // result_mem.
3687   _igvn.replace_node(store-&gt;in(MemNode::Memory), result_mem);
3688   lazy_replace(exit, result_ctrl);
3689   _igvn.replace_node(store, result_mem);
3690   // Any uses the increment outside of the loop become the loop limit.
3691   _igvn.replace_node(head-&gt;incr(), head-&gt;limit());
3692 
3693   // Disconnect the head from the loop.
3694   for (uint i = 0; i &lt; lpt-&gt;_body.size(); i++) {
3695     Node* n = lpt-&gt;_body.at(i);
3696     _igvn.replace_node(n, C-&gt;top());
3697   }
3698 
3699   return true;
3700 }
    </pre>
  </body>
</html>
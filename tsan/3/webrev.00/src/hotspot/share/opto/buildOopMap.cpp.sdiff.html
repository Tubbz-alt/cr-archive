<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/buildOopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="block.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/buildOopMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
335         uint cnt = mcall-&gt;tf()-&gt;domain()-&gt;cnt();
336         uint j;
337         for( j = TypeFunc::Parms; j &lt; cnt; j++)
338           if( mcall-&gt;in(j) == def )
339             break;            // reaching def is an argument oop
340         if( j &lt; cnt )         // arg oops dont go in GC map
341           continue;           // Continue on to the next register
342       }
343       omap-&gt;set_narrowoop(r);
344     } else if( OptoReg::is_valid(_callees[reg])) { // callee-save?
345       // It&#39;s a callee-save value
346       assert( dup_check[_callees[reg]]==0, &quot;trying to callee save same reg twice&quot; );
347       debug_only( dup_check[_callees[reg]]=1; )
348       VMReg callee = OptoReg::as_VMReg(OptoReg::Name(_callees[reg]));
349       if ( callee-&gt;is_concrete() || true ) {
350         omap-&gt;set_callee_saved( r, callee);
351       }
352 
353     } else {
354       // Other - some reaching non-oop value
<span class="line-removed">355       omap-&gt;set_value( r);</span>
356 #ifdef ASSERT
357       if( t-&gt;isa_rawptr() &amp;&amp; C-&gt;cfg()-&gt;_raw_oops.member(def) ) {
358         def-&gt;dump();
359         n-&gt;dump();
360         assert(false, &quot;there should be a oop in OopMap instead of a live raw oop at safepoint&quot;);
361       }
362 #endif
363     }
364 
365   }
366 
367 #ifdef ASSERT
368   /* Nice, Intel-only assert
369   int cnt_callee_saves=0;
370   int reg2 = 0;
371   while (OptoReg::is_reg(reg2)) {
372     if( dup_check[reg2] != 0) cnt_callee_saves++;
373     assert( cnt_callee_saves==3 || cnt_callee_saves==5, &quot;missed some callee-save&quot; );
374     reg2++;
375   }
376   */
377 #endif
378 
379 #ifdef ASSERT
<span class="line-modified">380   for( OopMapStream oms1(omap, OopMapValue::derived_oop_value); !oms1.is_done(); oms1.next()) {</span>
381     OopMapValue omv1 = oms1.current();



382     bool found = false;
<span class="line-modified">383     for( OopMapStream oms2(omap,OopMapValue::oop_value); !oms2.is_done(); oms2.next()) {</span>
<span class="line-modified">384       if( omv1.content_reg() == oms2.current().reg() ) {</span>




385         found = true;
386         break;
387       }
388     }
389     assert( found, &quot;derived with no base in oopmap&quot; );
390   }
391 #endif
392 
393   return omap;
394 }
395 
396 // Compute backwards liveness on registers
397 static void do_liveness(PhaseRegAlloc* regalloc, PhaseCFG* cfg, Block_List* worklist, int max_reg_ints, Arena* A, Dict* safehash) {
398   int* live = NEW_ARENA_ARRAY(A, int, (cfg-&gt;number_of_blocks() + 1) * max_reg_ints);
399   int* tmp_live = &amp;live[cfg-&gt;number_of_blocks() * max_reg_ints];
400   Node* root = cfg-&gt;get_root_node();
401   // On CISC platforms, get the node representing the stack pointer  that regalloc
402   // used for spills
403   Node *fp = NodeSentinel;
404   if (UseCISCSpill &amp;&amp; root-&gt;req() &gt; 1) {
</pre>
</td>
<td>
<hr />
<pre>
335         uint cnt = mcall-&gt;tf()-&gt;domain()-&gt;cnt();
336         uint j;
337         for( j = TypeFunc::Parms; j &lt; cnt; j++)
338           if( mcall-&gt;in(j) == def )
339             break;            // reaching def is an argument oop
340         if( j &lt; cnt )         // arg oops dont go in GC map
341           continue;           // Continue on to the next register
342       }
343       omap-&gt;set_narrowoop(r);
344     } else if( OptoReg::is_valid(_callees[reg])) { // callee-save?
345       // It&#39;s a callee-save value
346       assert( dup_check[_callees[reg]]==0, &quot;trying to callee save same reg twice&quot; );
347       debug_only( dup_check[_callees[reg]]=1; )
348       VMReg callee = OptoReg::as_VMReg(OptoReg::Name(_callees[reg]));
349       if ( callee-&gt;is_concrete() || true ) {
350         omap-&gt;set_callee_saved( r, callee);
351       }
352 
353     } else {
354       // Other - some reaching non-oop value

355 #ifdef ASSERT
356       if( t-&gt;isa_rawptr() &amp;&amp; C-&gt;cfg()-&gt;_raw_oops.member(def) ) {
357         def-&gt;dump();
358         n-&gt;dump();
359         assert(false, &quot;there should be a oop in OopMap instead of a live raw oop at safepoint&quot;);
360       }
361 #endif
362     }
363 
364   }
365 
366 #ifdef ASSERT
367   /* Nice, Intel-only assert
368   int cnt_callee_saves=0;
369   int reg2 = 0;
370   while (OptoReg::is_reg(reg2)) {
371     if( dup_check[reg2] != 0) cnt_callee_saves++;
372     assert( cnt_callee_saves==3 || cnt_callee_saves==5, &quot;missed some callee-save&quot; );
373     reg2++;
374   }
375   */
376 #endif
377 
378 #ifdef ASSERT
<span class="line-modified">379   for( OopMapStream oms1(omap); !oms1.is_done(); oms1.next()) {</span>
380     OopMapValue omv1 = oms1.current();
<span class="line-added">381     if (omv1.type() != OopMapValue::derived_oop_value) {</span>
<span class="line-added">382       continue;</span>
<span class="line-added">383     }</span>
384     bool found = false;
<span class="line-modified">385     for( OopMapStream oms2(omap); !oms2.is_done(); oms2.next()) {</span>
<span class="line-modified">386       OopMapValue omv2 = oms2.current();</span>
<span class="line-added">387       if (omv2.type() != OopMapValue::oop_value) {</span>
<span class="line-added">388         continue;</span>
<span class="line-added">389       }</span>
<span class="line-added">390       if( omv1.content_reg() == omv2.reg() ) {</span>
391         found = true;
392         break;
393       }
394     }
395     assert( found, &quot;derived with no base in oopmap&quot; );
396   }
397 #endif
398 
399   return omap;
400 }
401 
402 // Compute backwards liveness on registers
403 static void do_liveness(PhaseRegAlloc* regalloc, PhaseCFG* cfg, Block_List* worklist, int max_reg_ints, Arena* A, Dict* safehash) {
404   int* live = NEW_ARENA_ARRAY(A, int, (cfg-&gt;number_of_blocks() + 1) * max_reg_ints);
405   int* tmp_live = &amp;live[cfg-&gt;number_of_blocks() * max_reg_ints];
406   Node* root = cfg-&gt;get_root_node();
407   // On CISC platforms, get the node representing the stack pointer  that regalloc
408   // used for spills
409   Node *fp = NodeSentinel;
410   if (UseCISCSpill &amp;&amp; root-&gt;req() &gt; 1) {
</pre>
</td>
</tr>
</table>
<center><a href="block.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bytecodeInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
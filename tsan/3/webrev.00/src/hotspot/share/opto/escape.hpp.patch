diff a/src/hotspot/share/opto/escape.hpp b/src/hotspot/share/opto/escape.hpp
--- a/src/hotspot/share/opto/escape.hpp
+++ b/src/hotspot/share/opto/escape.hpp
@@ -331,20 +331,23 @@
                                // is still being collected. If false,
                                // no new nodes will be processed.
 
   bool               _verify;  // verify graph
 
-  JavaObjectNode* phantom_obj; // Unknown object
   JavaObjectNode*    null_obj;
   Node*             _pcmp_neq; // ConI(#CC_GT)
   Node*              _pcmp_eq; // ConI(#CC_EQ)
 
   Compile*           _compile; // Compile object for current compilation
   PhaseIterGVN*         _igvn; // Value numbering
 
   Unique_Node_List ideal_nodes; // Used by CG construction and types splitting.
 
+public:
+  JavaObjectNode* phantom_obj; // Unknown object
+
+private:
   // Address of an element in _nodes.  Used when the element is to be modified
   PointsToNode* ptnode_adr(int idx) const {
     // There should be no new ideal nodes during ConnectionGraph build,
     // growableArray::at() will throw assert otherwise.
     return _nodes.at(idx);
@@ -363,16 +366,10 @@
   void process_call_arguments(CallNode *call);
 
   // Add PointsToNode node corresponding to a call
   void add_call_node(CallNode* call);
 
-  // Map ideal node to existing PointsTo node (usually phantom_object).
-  void map_ideal_node(Node *n, PointsToNode* ptn) {
-    assert(ptn != NULL, "only existing PointsTo node");
-    _nodes.at_put(n->_idx, ptn);
-  }
-
   // Create PointsToNode node and add it to Connection Graph.
   void add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist);
 
   // Add final simple edges to graph.
   void add_final_edges(Node *n);
@@ -592,10 +589,16 @@
       assert(ptn != NULL, "node should be registered");
     }
     add_edge(ptnode_adr(n->_idx), ptn);
   }
 
+  // Map ideal node to existing PointsTo node (usually phantom_object).
+  void map_ideal_node(Node *n, PointsToNode* ptn) {
+    assert(ptn != NULL, "only existing PointsTo node");
+    _nodes.at_put(n->_idx, ptn);
+  }
+
   void add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist);
   bool add_final_edges_unsafe_access(Node* n, uint opcode);
 
 #ifndef PRODUCT
   void dump(GrowableArray<PointsToNode*>& ptnodes_worklist);

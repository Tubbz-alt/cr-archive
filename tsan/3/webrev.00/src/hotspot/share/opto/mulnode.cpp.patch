diff a/src/hotspot/share/opto/mulnode.cpp b/src/hotspot/share/opto/mulnode.cpp
--- a/src/hotspot/share/opto/mulnode.cpp
+++ b/src/hotspot/share/opto/mulnode.cpp
@@ -29,10 +29,11 @@
 #include "opto/convertnode.hpp"
 #include "opto/memnode.hpp"
 #include "opto/mulnode.hpp"
 #include "opto/phaseX.hpp"
 #include "opto/subnode.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // Portions of code courtesy of Clifford Click
 
 
 //=============================================================================
@@ -304,11 +305,11 @@
     if (bit2 + bit1 == abs_con) {    // Found all bits in con?
       Node *n1 = phase->transform(new LShiftLNode(in(1), phase->intcon(log2_long(bit1))));
       Node *n2 = phase->transform(new LShiftLNode(in(1), phase->intcon(log2_long(bit2))));
       res = new AddLNode(n2, n1);
 
-    } else if (is_power_of_2_long(abs_con+1)) {
+    } else if (is_power_of_2(abs_con+1)) {
       // Sleezy: power-of-2 -1.  Next time be generic.
       julong temp = abs_con + 1;
       Node *n1 = phase->transform( new LShiftLNode(in(1), phase->intcon(log2_long(temp))));
       res = new SubLNode(n1, in(1));
     } else {
@@ -1407,6 +1408,5 @@
 // Hash function for MulAddS2INode.  Operation is commutative with commutative pairs.
 // The hash function must return the same value when edge swapping is performed.
 uint MulAddS2INode::hash() const {
   return (uintptr_t)in(1) + (uintptr_t)in(2) + (uintptr_t)in(3) + (uintptr_t)in(4) + Opcode();
 }
-

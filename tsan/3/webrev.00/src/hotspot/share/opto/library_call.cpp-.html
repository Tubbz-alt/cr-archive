<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;opto/addnode.hpp&quot;
  37 #include &quot;opto/arraycopynode.hpp&quot;
  38 #include &quot;opto/c2compiler.hpp&quot;
  39 #include &quot;opto/callGenerator.hpp&quot;
  40 #include &quot;opto/castnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/convertnode.hpp&quot;
  43 #include &quot;opto/countbitsnode.hpp&quot;
  44 #include &quot;opto/intrinsicnode.hpp&quot;
  45 #include &quot;opto/idealKit.hpp&quot;
  46 #include &quot;opto/mathexactnode.hpp&quot;
  47 #include &quot;opto/movenode.hpp&quot;
  48 #include &quot;opto/mulnode.hpp&quot;
  49 #include &quot;opto/narrowptrnode.hpp&quot;
  50 #include &quot;opto/opaquenode.hpp&quot;
  51 #include &quot;opto/parse.hpp&quot;
  52 #include &quot;opto/runtime.hpp&quot;
  53 #include &quot;opto/rootnode.hpp&quot;
  54 #include &quot;opto/subnode.hpp&quot;
  55 #include &quot;prims/nativeLookup.hpp&quot;
  56 #include &quot;prims/unsafe.hpp&quot;
  57 #include &quot;runtime/objectMonitor.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;utilities/macros.hpp&quot;
  60 
  61 
  62 class LibraryIntrinsic : public InlineCallGenerator {
  63   // Extend the set of intrinsics known to the runtime:
  64  public:
  65  private:
  66   bool             _is_virtual;
  67   bool             _does_virtual_dispatch;
  68   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  69   int8_t           _last_predicate; // Last generated predicate
  70   vmIntrinsics::ID _intrinsic_id;
  71 
  72  public:
  73   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  74     : InlineCallGenerator(m),
  75       _is_virtual(is_virtual),
  76       _does_virtual_dispatch(does_virtual_dispatch),
  77       _predicates_count((int8_t)predicates_count),
  78       _last_predicate((int8_t)-1),
  79       _intrinsic_id(id)
  80   {
  81   }
  82   virtual bool is_intrinsic() const { return true; }
  83   virtual bool is_virtual()   const { return _is_virtual; }
  84   virtual bool is_predicated() const { return _predicates_count &gt; 0; }
  85   virtual int  predicates_count() const { return _predicates_count; }
  86   virtual bool does_virtual_dispatch()   const { return _does_virtual_dispatch; }
  87   virtual JVMState* generate(JVMState* jvms);
  88   virtual Node* generate_predicate(JVMState* jvms, int predicate);
  89   vmIntrinsics::ID intrinsic_id() const { return _intrinsic_id; }
  90 };
  91 
  92 
  93 // Local helper class for LibraryIntrinsic:
  94 class LibraryCallKit : public GraphKit {
  95  private:
  96   LibraryIntrinsic* _intrinsic;     // the library intrinsic being called
  97   Node*             _result;        // the result node, if any
  98   int               _reexecute_sp;  // the stack pointer when bytecode needs to be reexecuted
  99 
 100   const TypeOopPtr* sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type);
 101 
 102  public:
 103   LibraryCallKit(JVMState* jvms, LibraryIntrinsic* intrinsic)
 104     : GraphKit(jvms),
 105       _intrinsic(intrinsic),
 106       _result(NULL)
 107   {
 108     // Check if this is a root compile.  In that case we don&#39;t have a caller.
 109     if (!jvms-&gt;has_method()) {
 110       _reexecute_sp = sp();
 111     } else {
 112       // Find out how many arguments the interpreter needs when deoptimizing
 113       // and save the stack pointer value so it can used by uncommon_trap.
 114       // We find the argument count by looking at the declared signature.
 115       bool ignored_will_link;
 116       ciSignature* declared_signature = NULL;
 117       ciMethod* ignored_callee = caller()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
 118       const int nargs = declared_signature-&gt;arg_size_for_bc(caller()-&gt;java_code_at_bci(bci()));
 119       _reexecute_sp = sp() + nargs;  // &quot;push&quot; arguments back on stack
 120     }
 121   }
 122 
 123   virtual LibraryCallKit* is_LibraryCallKit() const { return (LibraryCallKit*)this; }
 124 
 125   ciMethod*         caller()    const    { return jvms()-&gt;method(); }
 126   int               bci()       const    { return jvms()-&gt;bci(); }
 127   LibraryIntrinsic* intrinsic() const    { return _intrinsic; }
 128   vmIntrinsics::ID  intrinsic_id() const { return _intrinsic-&gt;intrinsic_id(); }
 129   ciMethod*         callee()    const    { return _intrinsic-&gt;method(); }
 130 
 131   bool  try_to_inline(int predicate);
 132   Node* try_to_predicate(int predicate);
 133 
 134   void push_result() {
 135     // Push the result onto the stack.
 136     if (!stopped() &amp;&amp; result() != NULL) {
 137       BasicType bt = result()-&gt;bottom_type()-&gt;basic_type();
 138       push_node(bt, result());
 139     }
 140   }
 141 
 142  private:
 143   void fatal_unexpected_iid(vmIntrinsics::ID iid) {
 144     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
 145   }
 146 
 147   void  set_result(Node* n) { assert(_result == NULL, &quot;only set once&quot;); _result = n; }
 148   void  set_result(RegionNode* region, PhiNode* value);
 149   Node*     result() { return _result; }
 150 
 151   virtual int reexecute_sp() { return _reexecute_sp; }
 152 
 153   // Helper functions to inline natives
 154   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 155   Node* generate_slow_guard(Node* test, RegionNode* region);
 156   Node* generate_fair_guard(Node* test, RegionNode* region);
 157   Node* generate_negative_guard(Node* index, RegionNode* region,
 158                                 // resulting CastII of index:
 159                                 Node* *pos_index = NULL);
 160   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 161                              Node* array_length,
 162                              RegionNode* region);
 163   void  generate_string_range_check(Node* array, Node* offset,
 164                                     Node* length, bool char_count);
 165   Node* generate_current_thread(Node* &amp;tls_output);
 166   Node* load_mirror_from_klass(Node* klass);
 167   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 168                                       RegionNode* region, int null_path,
 169                                       int offset);
 170   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 171                                RegionNode* region, int null_path) {
 172     int offset = java_lang_Class::klass_offset_in_bytes();
 173     return load_klass_from_mirror_common(mirror, never_see_null,
 174                                          region, null_path,
 175                                          offset);
 176   }
 177   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 178                                      RegionNode* region, int null_path) {
 179     int offset = java_lang_Class::array_klass_offset_in_bytes();
 180     return load_klass_from_mirror_common(mirror, never_see_null,
 181                                          region, null_path,
 182                                          offset);
 183   }
 184   Node* generate_access_flags_guard(Node* kls,
 185                                     int modifier_mask, int modifier_bits,
 186                                     RegionNode* region);
 187   Node* generate_interface_guard(Node* kls, RegionNode* region);
 188   Node* generate_array_guard(Node* kls, RegionNode* region) {
 189     return generate_array_guard_common(kls, region, false, false);
 190   }
 191   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 192     return generate_array_guard_common(kls, region, false, true);
 193   }
 194   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 195     return generate_array_guard_common(kls, region, true, false);
 196   }
 197   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 198     return generate_array_guard_common(kls, region, true, true);
 199   }
 200   Node* generate_array_guard_common(Node* kls, RegionNode* region,
 201                                     bool obj_array, bool not_array);
 202   Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
 203   CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
 204                                      bool is_virtual = false, bool is_static = false);
 205   CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {
 206     return generate_method_call(method_id, false, true);
 207   }
 208   CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {
 209     return generate_method_call(method_id, true, false);
 210   }
 211   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 212   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 213 
 214   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 215   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 216   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 217   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 218   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 219                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 220   bool inline_string_indexOfChar();
 221   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 222   bool inline_string_toBytesU();
 223   bool inline_string_getCharsU();
 224   bool inline_string_copy(bool compress);
 225   bool inline_string_char_access(bool is_store);
 226   Node* round_double_node(Node* n);
 227   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 228   bool inline_math_native(vmIntrinsics::ID id);
 229   bool inline_math(vmIntrinsics::ID id);
 230   template &lt;typename OverflowOp&gt;
 231   bool inline_math_overflow(Node* arg1, Node* arg2);
 232   void inline_math_mathExact(Node* math, Node* test);
 233   bool inline_math_addExactI(bool is_increment);
 234   bool inline_math_addExactL(bool is_increment);
 235   bool inline_math_multiplyExactI();
 236   bool inline_math_multiplyExactL();
 237   bool inline_math_multiplyHigh();
 238   bool inline_math_negateExactI();
 239   bool inline_math_negateExactL();
 240   bool inline_math_subtractExactI(bool is_decrement);
 241   bool inline_math_subtractExactL(bool is_decrement);
 242   bool inline_min_max(vmIntrinsics::ID id);
 243   bool inline_notify(vmIntrinsics::ID id);
 244   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 245   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 246   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 247   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 248 
 249   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 250   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 251   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 252   static bool klass_needs_init_guard(Node* kls);
 253   bool inline_unsafe_allocate();
 254   bool inline_unsafe_newArray(bool uninitialized);
 255   bool inline_unsafe_copyMemory();
 256   bool inline_native_currentThread();
 257 
 258   bool inline_native_time_funcs(address method, const char* funcName);
 259 #ifdef JFR_HAVE_INTRINSICS
 260   bool inline_native_classID();
 261   bool inline_native_getEventWriter();
 262 #endif
 263   bool inline_native_isInterrupted();
 264   bool inline_native_Class_query(vmIntrinsics::ID id);
 265   bool inline_native_subtype_check();
 266   bool inline_native_getLength();
 267   bool inline_array_copyOf(bool is_copyOfRange);
 268   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 269   bool inline_preconditions_checkIndex();
 270   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 271   bool inline_native_clone(bool is_virtual);
 272   bool inline_native_Reflection_getCallerClass();
 273   // Helper function for inlining native object hash method
 274   bool inline_native_hashcode(bool is_virtual, bool is_static);
 275   bool inline_native_getClass();
 276 
 277   // Helper functions for inlining arraycopy
 278   bool inline_arraycopy();
 279   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 280                                                 RegionNode* slow_region);
 281   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 282   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 283                                       uint new_idx);
 284 
 285   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 286   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 287   bool inline_unsafe_fence(vmIntrinsics::ID id);
 288   bool inline_onspinwait();
 289   bool inline_fp_conversions(vmIntrinsics::ID id);
 290   bool inline_number_methods(vmIntrinsics::ID id);
 291   bool inline_reference_get();
 292   bool inline_Class_cast();
 293   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 294   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 295   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 296   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 297   Node* inline_counterMode_AESCrypt_predicate();
 298   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 299   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 300   bool inline_ghash_processBlocks();
 301   bool inline_base64_encodeBlock();
 302   bool inline_sha_implCompress(vmIntrinsics::ID id);
 303   bool inline_digestBase_implCompressMB(int predicate);
 304   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 305                                  bool long_state, address stubAddr, const char *stubName,
 306                                  Node* src_start, Node* ofs, Node* limit);
 307   Node* get_state_from_sha_object(Node *sha_object);
 308   Node* get_state_from_sha5_object(Node *sha_object);
 309   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 310   bool inline_encodeISOArray();
 311   bool inline_updateCRC32();
 312   bool inline_updateBytesCRC32();
 313   bool inline_updateByteBufferCRC32();
 314   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 315   bool inline_updateBytesCRC32C();
 316   bool inline_updateDirectByteBufferCRC32C();
 317   bool inline_updateBytesAdler32();
 318   bool inline_updateByteBufferAdler32();
 319   bool inline_multiplyToLen();
 320   bool inline_hasNegatives();
 321   bool inline_squareToLen();
 322   bool inline_mulAdd();
 323   bool inline_montgomeryMultiply();
 324   bool inline_montgomerySquare();
 325   bool inline_vectorizedMismatch();
 326   bool inline_fma(vmIntrinsics::ID id);
 327   bool inline_character_compare(vmIntrinsics::ID id);
 328   bool inline_fp_min_max(vmIntrinsics::ID id);
 329 
 330   bool inline_profileBoolean();
 331   bool inline_isCompileConstant();
 332   void clear_upper_avx() {
 333 #ifdef X86
 334     if (UseAVX &gt;= 2) {
 335       C-&gt;set_clear_upper_avx(true);
 336     }
 337 #endif
 338   }
 339 };
 340 
 341 //---------------------------make_vm_intrinsic----------------------------
 342 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 343   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 344   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 345 
 346   if (!m-&gt;is_loaded()) {
 347     // Do not attempt to inline unloaded methods.
 348     return NULL;
 349   }
 350 
 351   C2Compiler* compiler = (C2Compiler*)CompileBroker::compiler(CompLevel_full_optimization);
 352   bool is_available = false;
 353 
 354   {
 355     // For calling is_intrinsic_supported and is_intrinsic_disabled_by_flag
 356     // the compiler must transition to &#39;_thread_in_vm&#39; state because both
 357     // methods access VM-internal data.
 358     VM_ENTRY_MARK;
 359     methodHandle mh(THREAD, m-&gt;get_Method());
 360     is_available = compiler != NULL &amp;&amp; compiler-&gt;is_intrinsic_supported(mh, is_virtual) &amp;&amp;
 361                    !C-&gt;directive()-&gt;is_intrinsic_disabled(mh) &amp;&amp;
 362                    !vmIntrinsics::is_disabled_by_flags(mh);
 363 
 364   }
 365 
 366   if (is_available) {
 367     assert(id &lt;= vmIntrinsics::LAST_COMPILER_INLINE, &quot;caller responsibility&quot;);
 368     assert(id != vmIntrinsics::_Object_init &amp;&amp; id != vmIntrinsics::_invoke, &quot;enum out of order?&quot;);
 369     return new LibraryIntrinsic(m, is_virtual,
 370                                 vmIntrinsics::predicates_needed(id),
 371                                 vmIntrinsics::does_virtual_dispatch(id),
 372                                 (vmIntrinsics::ID) id);
 373   } else {
 374     return NULL;
 375   }
 376 }
 377 
 378 //----------------------register_library_intrinsics-----------------------
 379 // Initialize this file&#39;s data structures, for each Compile instance.
 380 void Compile::register_library_intrinsics() {
 381   // Nothing to do here.
 382 }
 383 
 384 JVMState* LibraryIntrinsic::generate(JVMState* jvms) {
 385   LibraryCallKit kit(jvms, this);
 386   Compile* C = kit.C;
 387   int nodes = C-&gt;unique();
 388 #ifndef PRODUCT
 389   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 390     char buf[1000];
 391     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 392     tty-&gt;print_cr(&quot;Intrinsic %s&quot;, str);
 393   }
 394 #endif
 395   ciMethod* callee = kit.callee();
 396   const int bci    = kit.bci();
 397 
 398   // Try to inline the intrinsic.
 399   if ((CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true) &amp;&amp;
 400       kit.try_to_inline(_last_predicate)) {
 401     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual)&quot;
 402                                           : &quot;(intrinsic)&quot;;
 403     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 404     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 405       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 406     }
 407     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 408     if (C-&gt;log()) {
 409       C-&gt;log()-&gt;elem(&quot;intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 410                      vmIntrinsics::name_at(intrinsic_id()),
 411                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 412                      C-&gt;unique() - nodes);
 413     }
 414     // Push the result from the inlined method onto the stack.
 415     kit.push_result();
 416     C-&gt;print_inlining_update(this);
 417     return kit.transfer_exceptions_into_jvms();
 418   }
 419 
 420   // The intrinsic bailed out
 421   if (jvms-&gt;has_method()) {
 422     // Not a root compile.
 423     const char* msg;
 424     if (callee-&gt;intrinsic_candidate()) {
 425       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual)&quot; : &quot;failed to inline (intrinsic)&quot;;
 426     } else {
 427       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual), method not annotated&quot;
 428                          : &quot;failed to inline (intrinsic), method not annotated&quot;;
 429     }
 430     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, msg);
 431     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 432       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, msg);
 433     }
 434   } else {
 435     // Root compile
 436     ResourceMark rm;
 437     stringStream msg_stream;
 438     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 439                      vmIntrinsics::name_at(intrinsic_id()),
 440                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 441     const char *msg = msg_stream.as_string();
 442     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 443     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 444       tty-&gt;print(&quot;%s&quot;, msg);
 445     }
 446   }
 447   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 448   C-&gt;print_inlining_update(this);
 449   return NULL;
 450 }
 451 
 452 Node* LibraryIntrinsic::generate_predicate(JVMState* jvms, int predicate) {
 453   LibraryCallKit kit(jvms, this);
 454   Compile* C = kit.C;
 455   int nodes = C-&gt;unique();
 456   _last_predicate = predicate;
 457 #ifndef PRODUCT
 458   assert(is_predicated() &amp;&amp; predicate &lt; predicates_count(), &quot;sanity&quot;);
 459   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 460     char buf[1000];
 461     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 462     tty-&gt;print_cr(&quot;Predicate for intrinsic %s&quot;, str);
 463   }
 464 #endif
 465   ciMethod* callee = kit.callee();
 466   const int bci    = kit.bci();
 467 
 468   Node* slow_ctl = kit.try_to_predicate(predicate);
 469   if (!kit.failing()) {
 470     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual, predicate)&quot;
 471                                           : &quot;(intrinsic, predicate)&quot;;
 472     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 473     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 474       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 475     }
 476     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 477     if (C-&gt;log()) {
 478       C-&gt;log()-&gt;elem(&quot;predicate_intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 479                      vmIntrinsics::name_at(intrinsic_id()),
 480                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 481                      C-&gt;unique() - nodes);
 482     }
 483     return slow_ctl; // Could be NULL if the check folds.
 484   }
 485 
 486   // The intrinsic bailed out
 487   if (jvms-&gt;has_method()) {
 488     // Not a root compile.
 489     const char* msg = &quot;failed to generate predicate for intrinsic&quot;;
 490     CompileTask::print_inlining_ul(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 491     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 492       C-&gt;print_inlining(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 493     }
 494   } else {
 495     // Root compile
 496     ResourceMark rm;
 497     stringStream msg_stream;
 498     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 499                      vmIntrinsics::name_at(intrinsic_id()),
 500                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 501     const char *msg = msg_stream.as_string();
 502     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 503     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 504       C-&gt;print_inlining_stream()-&gt;print(&quot;%s&quot;, msg);
 505     }
 506   }
 507   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 508   return NULL;
 509 }
 510 
 511 bool LibraryCallKit::try_to_inline(int predicate) {
 512   // Handle symbolic names for otherwise undistinguished boolean switches:
 513   const bool is_store       = true;
 514   const bool is_compress    = true;
 515   const bool is_static      = true;
 516   const bool is_volatile    = true;
 517 
 518   if (!jvms()-&gt;has_method()) {
 519     // Root JVMState has a null method.
 520     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 521     // Insert the memory aliasing node
 522     set_all_memory(reset_memory());
 523   }
 524   assert(merged_memory(), &quot;&quot;);
 525 
 526 
 527   switch (intrinsic_id()) {
 528   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 529   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 530   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 531 
 532   case vmIntrinsics::_dsin:
 533   case vmIntrinsics::_dcos:
 534   case vmIntrinsics::_dtan:
 535   case vmIntrinsics::_dabs:
 536   case vmIntrinsics::_datan2:
 537   case vmIntrinsics::_dsqrt:
 538   case vmIntrinsics::_dexp:
 539   case vmIntrinsics::_dlog:
 540   case vmIntrinsics::_dlog10:
 541   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 542 
 543   case vmIntrinsics::_min:
 544   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 545 
 546   case vmIntrinsics::_notify:
 547   case vmIntrinsics::_notifyAll:
 548     return inline_notify(intrinsic_id());
 549 
 550   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 551   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 552   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 553   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 554   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 555   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
 556   case vmIntrinsics::_multiplyExactI:           return inline_math_multiplyExactI();
 557   case vmIntrinsics::_multiplyExactL:           return inline_math_multiplyExactL();
 558   case vmIntrinsics::_multiplyHigh:             return inline_math_multiplyHigh();
 559   case vmIntrinsics::_negateExactI:             return inline_math_negateExactI();
 560   case vmIntrinsics::_negateExactL:             return inline_math_negateExactL();
 561   case vmIntrinsics::_subtractExactI:           return inline_math_subtractExactI(false /* subtract */);
 562   case vmIntrinsics::_subtractExactL:           return inline_math_subtractExactL(false /* subtract */);
 563 
 564   case vmIntrinsics::_arraycopy:                return inline_arraycopy();
 565 
 566   case vmIntrinsics::_compareToL:               return inline_string_compareTo(StrIntrinsicNode::LL);
 567   case vmIntrinsics::_compareToU:               return inline_string_compareTo(StrIntrinsicNode::UU);
 568   case vmIntrinsics::_compareToLU:              return inline_string_compareTo(StrIntrinsicNode::LU);
 569   case vmIntrinsics::_compareToUL:              return inline_string_compareTo(StrIntrinsicNode::UL);
 570 
 571   case vmIntrinsics::_indexOfL:                 return inline_string_indexOf(StrIntrinsicNode::LL);
 572   case vmIntrinsics::_indexOfU:                 return inline_string_indexOf(StrIntrinsicNode::UU);
 573   case vmIntrinsics::_indexOfUL:                return inline_string_indexOf(StrIntrinsicNode::UL);
 574   case vmIntrinsics::_indexOfIL:                return inline_string_indexOfI(StrIntrinsicNode::LL);
 575   case vmIntrinsics::_indexOfIU:                return inline_string_indexOfI(StrIntrinsicNode::UU);
 576   case vmIntrinsics::_indexOfIUL:               return inline_string_indexOfI(StrIntrinsicNode::UL);
 577   case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();
 578 
 579   case vmIntrinsics::_equalsL:                  return inline_string_equals(StrIntrinsicNode::LL);
 580   case vmIntrinsics::_equalsU:                  return inline_string_equals(StrIntrinsicNode::UU);
 581 
 582   case vmIntrinsics::_toBytesStringU:           return inline_string_toBytesU();
 583   case vmIntrinsics::_getCharsStringU:          return inline_string_getCharsU();
 584   case vmIntrinsics::_getCharStringU:           return inline_string_char_access(!is_store);
 585   case vmIntrinsics::_putCharStringU:           return inline_string_char_access( is_store);
 586 
 587   case vmIntrinsics::_compressStringC:
 588   case vmIntrinsics::_compressStringB:          return inline_string_copy( is_compress);
 589   case vmIntrinsics::_inflateStringC:
 590   case vmIntrinsics::_inflateStringB:           return inline_string_copy(!is_compress);
 591 
 592   case vmIntrinsics::_getReference:             return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false);
 593   case vmIntrinsics::_getBoolean:               return inline_unsafe_access(!is_store, T_BOOLEAN,  Relaxed, false);
 594   case vmIntrinsics::_getByte:                  return inline_unsafe_access(!is_store, T_BYTE,     Relaxed, false);
 595   case vmIntrinsics::_getShort:                 return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, false);
 596   case vmIntrinsics::_getChar:                  return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, false);
 597   case vmIntrinsics::_getInt:                   return inline_unsafe_access(!is_store, T_INT,      Relaxed, false);
 598   case vmIntrinsics::_getLong:                  return inline_unsafe_access(!is_store, T_LONG,     Relaxed, false);
 599   case vmIntrinsics::_getFloat:                 return inline_unsafe_access(!is_store, T_FLOAT,    Relaxed, false);
 600   case vmIntrinsics::_getDouble:                return inline_unsafe_access(!is_store, T_DOUBLE,   Relaxed, false);
 601 
 602   case vmIntrinsics::_putReference:             return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false);
 603   case vmIntrinsics::_putBoolean:               return inline_unsafe_access( is_store, T_BOOLEAN,  Relaxed, false);
 604   case vmIntrinsics::_putByte:                  return inline_unsafe_access( is_store, T_BYTE,     Relaxed, false);
 605   case vmIntrinsics::_putShort:                 return inline_unsafe_access( is_store, T_SHORT,    Relaxed, false);
 606   case vmIntrinsics::_putChar:                  return inline_unsafe_access( is_store, T_CHAR,     Relaxed, false);
 607   case vmIntrinsics::_putInt:                   return inline_unsafe_access( is_store, T_INT,      Relaxed, false);
 608   case vmIntrinsics::_putLong:                  return inline_unsafe_access( is_store, T_LONG,     Relaxed, false);
 609   case vmIntrinsics::_putFloat:                 return inline_unsafe_access( is_store, T_FLOAT,    Relaxed, false);
 610   case vmIntrinsics::_putDouble:                return inline_unsafe_access( is_store, T_DOUBLE,   Relaxed, false);
 611 
 612   case vmIntrinsics::_getReferenceVolatile:     return inline_unsafe_access(!is_store, T_OBJECT,   Volatile, false);
 613   case vmIntrinsics::_getBooleanVolatile:       return inline_unsafe_access(!is_store, T_BOOLEAN,  Volatile, false);
 614   case vmIntrinsics::_getByteVolatile:          return inline_unsafe_access(!is_store, T_BYTE,     Volatile, false);
 615   case vmIntrinsics::_getShortVolatile:         return inline_unsafe_access(!is_store, T_SHORT,    Volatile, false);
 616   case vmIntrinsics::_getCharVolatile:          return inline_unsafe_access(!is_store, T_CHAR,     Volatile, false);
 617   case vmIntrinsics::_getIntVolatile:           return inline_unsafe_access(!is_store, T_INT,      Volatile, false);
 618   case vmIntrinsics::_getLongVolatile:          return inline_unsafe_access(!is_store, T_LONG,     Volatile, false);
 619   case vmIntrinsics::_getFloatVolatile:         return inline_unsafe_access(!is_store, T_FLOAT,    Volatile, false);
 620   case vmIntrinsics::_getDoubleVolatile:        return inline_unsafe_access(!is_store, T_DOUBLE,   Volatile, false);
 621 
 622   case vmIntrinsics::_putReferenceVolatile:     return inline_unsafe_access( is_store, T_OBJECT,   Volatile, false);
 623   case vmIntrinsics::_putBooleanVolatile:       return inline_unsafe_access( is_store, T_BOOLEAN,  Volatile, false);
 624   case vmIntrinsics::_putByteVolatile:          return inline_unsafe_access( is_store, T_BYTE,     Volatile, false);
 625   case vmIntrinsics::_putShortVolatile:         return inline_unsafe_access( is_store, T_SHORT,    Volatile, false);
 626   case vmIntrinsics::_putCharVolatile:          return inline_unsafe_access( is_store, T_CHAR,     Volatile, false);
 627   case vmIntrinsics::_putIntVolatile:           return inline_unsafe_access( is_store, T_INT,      Volatile, false);
 628   case vmIntrinsics::_putLongVolatile:          return inline_unsafe_access( is_store, T_LONG,     Volatile, false);
 629   case vmIntrinsics::_putFloatVolatile:         return inline_unsafe_access( is_store, T_FLOAT,    Volatile, false);
 630   case vmIntrinsics::_putDoubleVolatile:        return inline_unsafe_access( is_store, T_DOUBLE,   Volatile, false);
 631 
 632   case vmIntrinsics::_getShortUnaligned:        return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, true);
 633   case vmIntrinsics::_getCharUnaligned:         return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, true);
 634   case vmIntrinsics::_getIntUnaligned:          return inline_unsafe_access(!is_store, T_INT,      Relaxed, true);
 635   case vmIntrinsics::_getLongUnaligned:         return inline_unsafe_access(!is_store, T_LONG,     Relaxed, true);
 636 
 637   case vmIntrinsics::_putShortUnaligned:        return inline_unsafe_access( is_store, T_SHORT,    Relaxed, true);
 638   case vmIntrinsics::_putCharUnaligned:         return inline_unsafe_access( is_store, T_CHAR,     Relaxed, true);
 639   case vmIntrinsics::_putIntUnaligned:          return inline_unsafe_access( is_store, T_INT,      Relaxed, true);
 640   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access( is_store, T_LONG,     Relaxed, true);
 641 
 642   case vmIntrinsics::_getReferenceAcquire:      return inline_unsafe_access(!is_store, T_OBJECT,   Acquire, false);
 643   case vmIntrinsics::_getBooleanAcquire:        return inline_unsafe_access(!is_store, T_BOOLEAN,  Acquire, false);
 644   case vmIntrinsics::_getByteAcquire:           return inline_unsafe_access(!is_store, T_BYTE,     Acquire, false);
 645   case vmIntrinsics::_getShortAcquire:          return inline_unsafe_access(!is_store, T_SHORT,    Acquire, false);
 646   case vmIntrinsics::_getCharAcquire:           return inline_unsafe_access(!is_store, T_CHAR,     Acquire, false);
 647   case vmIntrinsics::_getIntAcquire:            return inline_unsafe_access(!is_store, T_INT,      Acquire, false);
 648   case vmIntrinsics::_getLongAcquire:           return inline_unsafe_access(!is_store, T_LONG,     Acquire, false);
 649   case vmIntrinsics::_getFloatAcquire:          return inline_unsafe_access(!is_store, T_FLOAT,    Acquire, false);
 650   case vmIntrinsics::_getDoubleAcquire:         return inline_unsafe_access(!is_store, T_DOUBLE,   Acquire, false);
 651 
 652   case vmIntrinsics::_putReferenceRelease:      return inline_unsafe_access( is_store, T_OBJECT,   Release, false);
 653   case vmIntrinsics::_putBooleanRelease:        return inline_unsafe_access( is_store, T_BOOLEAN,  Release, false);
 654   case vmIntrinsics::_putByteRelease:           return inline_unsafe_access( is_store, T_BYTE,     Release, false);
 655   case vmIntrinsics::_putShortRelease:          return inline_unsafe_access( is_store, T_SHORT,    Release, false);
 656   case vmIntrinsics::_putCharRelease:           return inline_unsafe_access( is_store, T_CHAR,     Release, false);
 657   case vmIntrinsics::_putIntRelease:            return inline_unsafe_access( is_store, T_INT,      Release, false);
 658   case vmIntrinsics::_putLongRelease:           return inline_unsafe_access( is_store, T_LONG,     Release, false);
 659   case vmIntrinsics::_putFloatRelease:          return inline_unsafe_access( is_store, T_FLOAT,    Release, false);
 660   case vmIntrinsics::_putDoubleRelease:         return inline_unsafe_access( is_store, T_DOUBLE,   Release, false);
 661 
 662   case vmIntrinsics::_getReferenceOpaque:       return inline_unsafe_access(!is_store, T_OBJECT,   Opaque, false);
 663   case vmIntrinsics::_getBooleanOpaque:         return inline_unsafe_access(!is_store, T_BOOLEAN,  Opaque, false);
 664   case vmIntrinsics::_getByteOpaque:            return inline_unsafe_access(!is_store, T_BYTE,     Opaque, false);
 665   case vmIntrinsics::_getShortOpaque:           return inline_unsafe_access(!is_store, T_SHORT,    Opaque, false);
 666   case vmIntrinsics::_getCharOpaque:            return inline_unsafe_access(!is_store, T_CHAR,     Opaque, false);
 667   case vmIntrinsics::_getIntOpaque:             return inline_unsafe_access(!is_store, T_INT,      Opaque, false);
 668   case vmIntrinsics::_getLongOpaque:            return inline_unsafe_access(!is_store, T_LONG,     Opaque, false);
 669   case vmIntrinsics::_getFloatOpaque:           return inline_unsafe_access(!is_store, T_FLOAT,    Opaque, false);
 670   case vmIntrinsics::_getDoubleOpaque:          return inline_unsafe_access(!is_store, T_DOUBLE,   Opaque, false);
 671 
 672   case vmIntrinsics::_putReferenceOpaque:       return inline_unsafe_access( is_store, T_OBJECT,   Opaque, false);
 673   case vmIntrinsics::_putBooleanOpaque:         return inline_unsafe_access( is_store, T_BOOLEAN,  Opaque, false);
 674   case vmIntrinsics::_putByteOpaque:            return inline_unsafe_access( is_store, T_BYTE,     Opaque, false);
 675   case vmIntrinsics::_putShortOpaque:           return inline_unsafe_access( is_store, T_SHORT,    Opaque, false);
 676   case vmIntrinsics::_putCharOpaque:            return inline_unsafe_access( is_store, T_CHAR,     Opaque, false);
 677   case vmIntrinsics::_putIntOpaque:             return inline_unsafe_access( is_store, T_INT,      Opaque, false);
 678   case vmIntrinsics::_putLongOpaque:            return inline_unsafe_access( is_store, T_LONG,     Opaque, false);
 679   case vmIntrinsics::_putFloatOpaque:           return inline_unsafe_access( is_store, T_FLOAT,    Opaque, false);
 680   case vmIntrinsics::_putDoubleOpaque:          return inline_unsafe_access( is_store, T_DOUBLE,   Opaque, false);
 681 
 682   case vmIntrinsics::_compareAndSetReference:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap,      Volatile);
 683   case vmIntrinsics::_compareAndSetByte:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap,      Volatile);
 684   case vmIntrinsics::_compareAndSetShort:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap,      Volatile);
 685   case vmIntrinsics::_compareAndSetInt:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap,      Volatile);
 686   case vmIntrinsics::_compareAndSetLong:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap,      Volatile);
 687 
 688   case vmIntrinsics::_weakCompareAndSetReferencePlain:     return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Relaxed);
 689   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Acquire);
 690   case vmIntrinsics::_weakCompareAndSetReferenceRelease:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Release);
 691   case vmIntrinsics::_weakCompareAndSetReference:          return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Volatile);
 692   case vmIntrinsics::_weakCompareAndSetBytePlain:          return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Relaxed);
 693   case vmIntrinsics::_weakCompareAndSetByteAcquire:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Acquire);
 694   case vmIntrinsics::_weakCompareAndSetByteRelease:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Release);
 695   case vmIntrinsics::_weakCompareAndSetByte:               return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Volatile);
 696   case vmIntrinsics::_weakCompareAndSetShortPlain:         return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Relaxed);
 697   case vmIntrinsics::_weakCompareAndSetShortAcquire:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Acquire);
 698   case vmIntrinsics::_weakCompareAndSetShortRelease:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Release);
 699   case vmIntrinsics::_weakCompareAndSetShort:              return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Volatile);
 700   case vmIntrinsics::_weakCompareAndSetIntPlain:           return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Relaxed);
 701   case vmIntrinsics::_weakCompareAndSetIntAcquire:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Acquire);
 702   case vmIntrinsics::_weakCompareAndSetIntRelease:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Release);
 703   case vmIntrinsics::_weakCompareAndSetInt:                return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Volatile);
 704   case vmIntrinsics::_weakCompareAndSetLongPlain:          return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Relaxed);
 705   case vmIntrinsics::_weakCompareAndSetLongAcquire:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Acquire);
 706   case vmIntrinsics::_weakCompareAndSetLongRelease:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Release);
 707   case vmIntrinsics::_weakCompareAndSetLong:               return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Volatile);
 708 
 709   case vmIntrinsics::_compareAndExchangeReference:         return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Volatile);
 710   case vmIntrinsics::_compareAndExchangeReferenceAcquire:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Acquire);
 711   case vmIntrinsics::_compareAndExchangeReferenceRelease:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Release);
 712   case vmIntrinsics::_compareAndExchangeByte:              return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Volatile);
 713   case vmIntrinsics::_compareAndExchangeByteAcquire:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Acquire);
 714   case vmIntrinsics::_compareAndExchangeByteRelease:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Release);
 715   case vmIntrinsics::_compareAndExchangeShort:             return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Volatile);
 716   case vmIntrinsics::_compareAndExchangeShortAcquire:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Acquire);
 717   case vmIntrinsics::_compareAndExchangeShortRelease:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Release);
 718   case vmIntrinsics::_compareAndExchangeInt:               return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Volatile);
 719   case vmIntrinsics::_compareAndExchangeIntAcquire:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Acquire);
 720   case vmIntrinsics::_compareAndExchangeIntRelease:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Release);
 721   case vmIntrinsics::_compareAndExchangeLong:              return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Volatile);
 722   case vmIntrinsics::_compareAndExchangeLongAcquire:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Acquire);
 723   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 724 
 725   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 726   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 727   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 728   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 729 
 730   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 731   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 732   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 733   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 734   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 735 
 736   case vmIntrinsics::_loadFence:
 737   case vmIntrinsics::_storeFence:
 738   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 739 
 740   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 741 
 742   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 743   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();
 744 
 745 #ifdef JFR_HAVE_INTRINSICS
 746   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 747   case vmIntrinsics::_getClassId:               return inline_native_classID();
 748   case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 749 #endif
 750   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 751   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
 752   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 753   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 754   case vmIntrinsics::_getLength:                return inline_native_getLength();
 755   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 756   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 757   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 758   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 759   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 760   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 761 
 762   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 763   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 764 
 765   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 766 
 767   case vmIntrinsics::_isInstance:
 768   case vmIntrinsics::_getModifiers:
 769   case vmIntrinsics::_isInterface:
 770   case vmIntrinsics::_isArray:
 771   case vmIntrinsics::_isPrimitive:
 772   case vmIntrinsics::_getSuperclass:
 773   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 774 
 775   case vmIntrinsics::_floatToRawIntBits:
 776   case vmIntrinsics::_floatToIntBits:
 777   case vmIntrinsics::_intBitsToFloat:
 778   case vmIntrinsics::_doubleToRawLongBits:
 779   case vmIntrinsics::_doubleToLongBits:
 780   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 781 
 782   case vmIntrinsics::_numberOfLeadingZeros_i:
 783   case vmIntrinsics::_numberOfLeadingZeros_l:
 784   case vmIntrinsics::_numberOfTrailingZeros_i:
 785   case vmIntrinsics::_numberOfTrailingZeros_l:
 786   case vmIntrinsics::_bitCount_i:
 787   case vmIntrinsics::_bitCount_l:
 788   case vmIntrinsics::_reverseBytes_i:
 789   case vmIntrinsics::_reverseBytes_l:
 790   case vmIntrinsics::_reverseBytes_s:
 791   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 792 
 793   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 794 
 795   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 796 
 797   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 798 
 799   case vmIntrinsics::_aescrypt_encryptBlock:
 800   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 801 
 802   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 803   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 804     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 805 
 806   case vmIntrinsics::_counterMode_AESCrypt:
 807     return inline_counterMode_AESCrypt(intrinsic_id());
 808 
 809   case vmIntrinsics::_sha_implCompress:
 810   case vmIntrinsics::_sha2_implCompress:
 811   case vmIntrinsics::_sha5_implCompress:
 812     return inline_sha_implCompress(intrinsic_id());
 813 
 814   case vmIntrinsics::_digestBase_implCompressMB:
 815     return inline_digestBase_implCompressMB(predicate);
 816 
 817   case vmIntrinsics::_multiplyToLen:
 818     return inline_multiplyToLen();
 819 
 820   case vmIntrinsics::_squareToLen:
 821     return inline_squareToLen();
 822 
 823   case vmIntrinsics::_mulAdd:
 824     return inline_mulAdd();
 825 
 826   case vmIntrinsics::_montgomeryMultiply:
 827     return inline_montgomeryMultiply();
 828   case vmIntrinsics::_montgomerySquare:
 829     return inline_montgomerySquare();
 830 
 831   case vmIntrinsics::_vectorizedMismatch:
 832     return inline_vectorizedMismatch();
 833 
 834   case vmIntrinsics::_ghash_processBlocks:
 835     return inline_ghash_processBlocks();
 836   case vmIntrinsics::_base64_encodeBlock:
 837     return inline_base64_encodeBlock();
 838 
 839   case vmIntrinsics::_encodeISOArray:
 840   case vmIntrinsics::_encodeByteISOArray:
 841     return inline_encodeISOArray();
 842 
 843   case vmIntrinsics::_updateCRC32:
 844     return inline_updateCRC32();
 845   case vmIntrinsics::_updateBytesCRC32:
 846     return inline_updateBytesCRC32();
 847   case vmIntrinsics::_updateByteBufferCRC32:
 848     return inline_updateByteBufferCRC32();
 849 
 850   case vmIntrinsics::_updateBytesCRC32C:
 851     return inline_updateBytesCRC32C();
 852   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 853     return inline_updateDirectByteBufferCRC32C();
 854 
 855   case vmIntrinsics::_updateBytesAdler32:
 856     return inline_updateBytesAdler32();
 857   case vmIntrinsics::_updateByteBufferAdler32:
 858     return inline_updateByteBufferAdler32();
 859 
 860   case vmIntrinsics::_profileBoolean:
 861     return inline_profileBoolean();
 862   case vmIntrinsics::_isCompileConstant:
 863     return inline_isCompileConstant();
 864 
 865   case vmIntrinsics::_hasNegatives:
 866     return inline_hasNegatives();
 867 
 868   case vmIntrinsics::_fmaD:
 869   case vmIntrinsics::_fmaF:
 870     return inline_fma(intrinsic_id());
 871 
 872   case vmIntrinsics::_isDigit:
 873   case vmIntrinsics::_isLowerCase:
 874   case vmIntrinsics::_isUpperCase:
 875   case vmIntrinsics::_isWhitespace:
 876     return inline_character_compare(intrinsic_id());
 877 
 878   case vmIntrinsics::_maxF:
 879   case vmIntrinsics::_minF:
 880   case vmIntrinsics::_maxD:
 881   case vmIntrinsics::_minD:
 882     return inline_fp_min_max(intrinsic_id());
 883 
 884   default:
 885     // If you get here, it may be that someone has added a new intrinsic
 886     // to the list in vmSymbols.hpp without implementing it here.
 887 #ifndef PRODUCT
 888     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 889       tty-&gt;print_cr(&quot;*** Warning: Unimplemented intrinsic %s(%d)&quot;,
 890                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 891     }
 892 #endif
 893     return false;
 894   }
 895 }
 896 
 897 Node* LibraryCallKit::try_to_predicate(int predicate) {
 898   if (!jvms()-&gt;has_method()) {
 899     // Root JVMState has a null method.
 900     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 901     // Insert the memory aliasing node
 902     set_all_memory(reset_memory());
 903   }
 904   assert(merged_memory(), &quot;&quot;);
 905 
 906   switch (intrinsic_id()) {
 907   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 908     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 909   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 910     return inline_cipherBlockChaining_AESCrypt_predicate(true);
 911   case vmIntrinsics::_counterMode_AESCrypt:
 912     return inline_counterMode_AESCrypt_predicate();
 913   case vmIntrinsics::_digestBase_implCompressMB:
 914     return inline_digestBase_implCompressMB_predicate(predicate);
 915 
 916   default:
 917     // If you get here, it may be that someone has added a new intrinsic
 918     // to the list in vmSymbols.hpp without implementing it here.
 919 #ifndef PRODUCT
 920     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 921       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 922                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 923     }
 924 #endif
 925     Node* slow_ctl = control();
 926     set_control(top()); // No fast path instrinsic
 927     return slow_ctl;
 928   }
 929 }
 930 
 931 //------------------------------set_result-------------------------------
 932 // Helper function for finishing intrinsics.
 933 void LibraryCallKit::set_result(RegionNode* region, PhiNode* value) {
 934   record_for_igvn(region);
 935   set_control(_gvn.transform(region));
 936   set_result( _gvn.transform(value));
 937   assert(value-&gt;type()-&gt;basic_type() == result()-&gt;bottom_type()-&gt;basic_type(), &quot;sanity&quot;);
 938 }
 939 
 940 //------------------------------generate_guard---------------------------
 941 // Helper function for generating guarded fast-slow graph structures.
 942 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
 943 // then a fast path can be taken.  (We generally hope it fails.)
 944 // In all cases, GraphKit::control() is updated to the fast path.
 945 // The returned value represents the control for the slow path.
 946 // The return value is never &#39;top&#39;; it is either a valid control
 947 // or NULL if it is obvious that the slow path can never be taken.
 948 // Also, if region and the slow control are not NULL, the slow edge
 949 // is appended to the region.
 950 Node* LibraryCallKit::generate_guard(Node* test, RegionNode* region, float true_prob) {
 951   if (stopped()) {
 952     // Already short circuited.
 953     return NULL;
 954   }
 955 
 956   // Build an if node and its projections.
 957   // If test is true we take the slow path, which we assume is uncommon.
 958   if (_gvn.type(test) == TypeInt::ZERO) {
 959     // The slow branch is never taken.  No need to build this guard.
 960     return NULL;
 961   }
 962 
 963   IfNode* iff = create_and_map_if(control(), test, true_prob, COUNT_UNKNOWN);
 964 
 965   Node* if_slow = _gvn.transform(new IfTrueNode(iff));
 966   if (if_slow == top()) {
 967     // The slow branch is never taken.  No need to build this guard.
 968     return NULL;
 969   }
 970 
 971   if (region != NULL)
 972     region-&gt;add_req(if_slow);
 973 
 974   Node* if_fast = _gvn.transform(new IfFalseNode(iff));
 975   set_control(if_fast);
 976 
 977   return if_slow;
 978 }
 979 
 980 inline Node* LibraryCallKit::generate_slow_guard(Node* test, RegionNode* region) {
 981   return generate_guard(test, region, PROB_UNLIKELY_MAG(3));
 982 }
 983 inline Node* LibraryCallKit::generate_fair_guard(Node* test, RegionNode* region) {
 984   return generate_guard(test, region, PROB_FAIR);
 985 }
 986 
 987 inline Node* LibraryCallKit::generate_negative_guard(Node* index, RegionNode* region,
 988                                                      Node* *pos_index) {
 989   if (stopped())
 990     return NULL;                // already stopped
 991   if (_gvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
 992     return NULL;                // index is already adequately typed
 993   Node* cmp_lt = _gvn.transform(new CmpINode(index, intcon(0)));
 994   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
 995   Node* is_neg = generate_guard(bol_lt, region, PROB_MIN);
 996   if (is_neg != NULL &amp;&amp; pos_index != NULL) {
 997     // Emulate effect of Parse::adjust_map_after_if.
 998     Node* ccast = new CastIINode(index, TypeInt::POS);
 999     ccast-&gt;set_req(0, control());
1000     (*pos_index) = _gvn.transform(ccast);
1001   }
1002   return is_neg;
1003 }
1004 
1005 // Make sure that &#39;position&#39; is a valid limit index, in [0..length].
1006 // There are two equivalent plans for checking this:
1007 //   A. (offset + copyLength)  unsigned&lt;=  arrayLength
1008 //   B. offset  &lt;=  (arrayLength - copyLength)
1009 // We require that all of the values above, except for the sum and
1010 // difference, are already known to be non-negative.
1011 // Plan A is robust in the face of overflow, if offset and copyLength
1012 // are both hugely positive.
1013 //
1014 // Plan B is less direct and intuitive, but it does not overflow at
1015 // all, since the difference of two non-negatives is always
1016 // representable.  Whenever Java methods must perform the equivalent
1017 // check they generally use Plan B instead of Plan A.
1018 // For the moment we use Plan A.
1019 inline Node* LibraryCallKit::generate_limit_guard(Node* offset,
1020                                                   Node* subseq_length,
1021                                                   Node* array_length,
1022                                                   RegionNode* region) {
1023   if (stopped())
1024     return NULL;                // already stopped
1025   bool zero_offset = _gvn.type(offset) == TypeInt::ZERO;
1026   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
1027     return NULL;                // common case of whole-array copy
1028   Node* last = subseq_length;
1029   if (!zero_offset)             // last += offset
1030     last = _gvn.transform(new AddINode(last, offset));
1031   Node* cmp_lt = _gvn.transform(new CmpUNode(array_length, last));
1032   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1033   Node* is_over = generate_guard(bol_lt, region, PROB_MIN);
1034   return is_over;
1035 }
1036 
1037 // Emit range checks for the given String.value byte array
1038 void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {
1039   if (stopped()) {
1040     return; // already stopped
1041   }
1042   RegionNode* bailout = new RegionNode(1);
1043   record_for_igvn(bailout);
1044   if (char_count) {
1045     // Convert char count to byte count
1046     count = _gvn.transform(new LShiftINode(count, intcon(1)));
1047   }
1048 
1049   // Offset and count must not be negative
1050   generate_negative_guard(offset, bailout);
1051   generate_negative_guard(count, bailout);
1052   // Offset + count must not exceed length of array
1053   generate_limit_guard(offset, count, load_array_length(array), bailout);
1054 
1055   if (bailout-&gt;req() &gt; 1) {
1056     PreserveJVMState pjvms(this);
1057     set_control(_gvn.transform(bailout));
1058     uncommon_trap(Deoptimization::Reason_intrinsic,
1059                   Deoptimization::Action_maybe_recompile);
1060   }
1061 }
1062 
1063 //--------------------------generate_current_thread--------------------
1064 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1065   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1066   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1067   Node* thread = _gvn.transform(new ThreadLocalNode());
1068   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
1069   Node* threadObj = make_load(NULL, p, thread_type, T_OBJECT, MemNode::unordered);
1070   tls_output = thread;
1071   return threadObj;
1072 }
1073 
1074 
1075 //------------------------------make_string_method_node------------------------
1076 // Helper method for String intrinsic functions. This version is called with
1077 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1078 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1079 // containing the lengths of str1 and str2.
1080 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1081   Node* result = NULL;
1082   switch (opcode) {
1083   case Op_StrIndexOf:
1084     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1085                                 str1_start, cnt1, str2_start, cnt2, ae);
1086     break;
1087   case Op_StrComp:
1088     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1089                              str1_start, cnt1, str2_start, cnt2, ae);
1090     break;
1091   case Op_StrEquals:
1092     // We already know that cnt1 == cnt2 here (checked in &#39;inline_string_equals&#39;).
1093     // Use the constant length if there is one because optimized match rule may exist.
1094     result = new StrEqualsNode(control(), memory(TypeAryPtr::BYTES),
1095                                str1_start, str2_start, cnt2-&gt;is_Con() ? cnt2 : cnt1, ae);
1096     break;
1097   default:
1098     ShouldNotReachHere();
1099     return NULL;
1100   }
1101 
1102   // All these intrinsics have checks.
1103   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1104   clear_upper_avx();
1105 
1106   return _gvn.transform(result);
1107 }
1108 
1109 //------------------------------inline_string_compareTo------------------------
1110 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1111   Node* arg1 = argument(0);
1112   Node* arg2 = argument(1);
1113 
1114   arg1 = must_be_not_null(arg1, true);
1115   arg2 = must_be_not_null(arg2, true);
1116 
1117   arg1 = access_resolve(arg1, ACCESS_READ);
1118   arg2 = access_resolve(arg2, ACCESS_READ);
1119 
1120   // Get start addr and length of first argument
1121   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1122   Node* arg1_cnt    = load_array_length(arg1);
1123 
1124   // Get start addr and length of second argument
1125   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1126   Node* arg2_cnt    = load_array_length(arg2);
1127 
1128   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1129   set_result(result);
1130   return true;
1131 }
1132 
1133 //------------------------------inline_string_equals------------------------
1134 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1135   Node* arg1 = argument(0);
1136   Node* arg2 = argument(1);
1137 
1138   // paths (plus control) merge
1139   RegionNode* region = new RegionNode(3);
1140   Node* phi = new PhiNode(region, TypeInt::BOOL);
1141 
1142   if (!stopped()) {
1143 
1144     arg1 = must_be_not_null(arg1, true);
1145     arg2 = must_be_not_null(arg2, true);
1146 
1147     arg1 = access_resolve(arg1, ACCESS_READ);
1148     arg2 = access_resolve(arg2, ACCESS_READ);
1149 
1150     // Get start addr and length of first argument
1151     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1152     Node* arg1_cnt    = load_array_length(arg1);
1153 
1154     // Get start addr and length of second argument
1155     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1156     Node* arg2_cnt    = load_array_length(arg2);
1157 
1158     // Check for arg1_cnt != arg2_cnt
1159     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1160     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1161     Node* if_ne = generate_slow_guard(bol, NULL);
1162     if (if_ne != NULL) {
1163       phi-&gt;init_req(2, intcon(0));
1164       region-&gt;init_req(2, if_ne);
1165     }
1166 
1167     // Check for count == 0 is done by assembler code for StrEquals.
1168 
1169     if (!stopped()) {
1170       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1171       phi-&gt;init_req(1, equals);
1172       region-&gt;init_req(1, control());
1173     }
1174   }
1175 
1176   // post merge
1177   set_control(_gvn.transform(region));
1178   record_for_igvn(region);
1179 
1180   set_result(_gvn.transform(phi));
1181   return true;
1182 }
1183 
1184 //------------------------------inline_array_equals----------------------------
1185 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1186   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1187   Node* arg1 = argument(0);
1188   Node* arg2 = argument(1);
1189 
1190   arg1 = access_resolve(arg1, ACCESS_READ);
1191   arg2 = access_resolve(arg2, ACCESS_READ);
1192 
1193   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1194   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1195   clear_upper_avx();
1196 
1197   return true;
1198 }
1199 
1200 //------------------------------inline_hasNegatives------------------------------
1201 bool LibraryCallKit::inline_hasNegatives() {
1202   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1203     return false;
1204   }
1205 
1206   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1207   // no receiver since it is static method
1208   Node* ba         = argument(0);
1209   Node* offset     = argument(1);
1210   Node* len        = argument(2);
1211 
1212   ba = must_be_not_null(ba, true);
1213 
1214   // Range checks
1215   generate_string_range_check(ba, offset, len, false);
1216   if (stopped()) {
1217     return true;
1218   }
1219   ba = access_resolve(ba, ACCESS_READ);
1220   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1221   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1222   set_result(_gvn.transform(result));
1223   return true;
1224 }
1225 
1226 bool LibraryCallKit::inline_preconditions_checkIndex() {
1227   Node* index = argument(0);
1228   Node* length = argument(1);
1229   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1230     return false;
1231   }
1232 
1233   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1234   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1235 
1236   {
1237     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1238     uncommon_trap(Deoptimization::Reason_intrinsic,
1239                   Deoptimization::Action_make_not_entrant);
1240   }
1241 
1242   if (stopped()) {
1243     return false;
1244   }
1245 
1246   Node* rc_cmp = _gvn.transform(new CmpUNode(index, length));
1247   BoolTest::mask btest = BoolTest::lt;
1248   Node* rc_bool = _gvn.transform(new BoolNode(rc_cmp, btest));
1249   RangeCheckNode* rc = new RangeCheckNode(control(), rc_bool, PROB_MAX, COUNT_UNKNOWN);
1250   _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
1251   if (!rc_bool-&gt;is_Con()) {
1252     record_for_igvn(rc);
1253   }
1254   set_control(_gvn.transform(new IfTrueNode(rc)));
1255   {
1256     PreserveJVMState pjvms(this);
1257     set_control(_gvn.transform(new IfFalseNode(rc)));
1258     uncommon_trap(Deoptimization::Reason_range_check,
1259                   Deoptimization::Action_make_not_entrant);
1260   }
1261 
1262   if (stopped()) {
1263     return false;
1264   }
1265 
1266   Node* result = new CastIINode(index, TypeInt::make(0, _gvn.type(length)-&gt;is_int()-&gt;_hi, Type::WidenMax));
1267   result-&gt;set_req(0, control());
1268   result = _gvn.transform(result);
1269   set_result(result);
1270   replace_in_map(index, result);
1271   clear_upper_avx();
1272   return true;
1273 }
1274 
1275 //------------------------------inline_string_indexOf------------------------
1276 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1277   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1278     return false;
1279   }
1280   Node* src = argument(0);
1281   Node* tgt = argument(1);
1282 
1283   // Make the merge point
1284   RegionNode* result_rgn = new RegionNode(4);
1285   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1286 
1287   src = must_be_not_null(src, true);
1288   tgt = must_be_not_null(tgt, true);
1289 
1290   src = access_resolve(src, ACCESS_READ);
1291   tgt = access_resolve(tgt, ACCESS_READ);
1292 
1293   // Get start addr and length of source string
1294   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1295   Node* src_count = load_array_length(src);
1296 
1297   // Get start addr and length of substring
1298   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1299   Node* tgt_count = load_array_length(tgt);
1300 
1301   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1302     // Divide src size by 2 if String is UTF16 encoded
1303     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1304   }
1305   if (ae == StrIntrinsicNode::UU) {
1306     // Divide substring size by 2 if String is UTF16 encoded
1307     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1308   }
1309 
1310   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1311   if (result != NULL) {
1312     result_phi-&gt;init_req(3, result);
1313     result_rgn-&gt;init_req(3, control());
1314   }
1315   set_control(_gvn.transform(result_rgn));
1316   record_for_igvn(result_rgn);
1317   set_result(_gvn.transform(result_phi));
1318 
1319   return true;
1320 }
1321 
1322 //-----------------------------inline_string_indexOf-----------------------
1323 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1324   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1325     return false;
1326   }
1327   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1328     return false;
1329   }
1330   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1331   Node* src         = argument(0); // byte[]
1332   Node* src_count   = argument(1); // char count
1333   Node* tgt         = argument(2); // byte[]
1334   Node* tgt_count   = argument(3); // char count
1335   Node* from_index  = argument(4); // char index
1336 
1337   src = must_be_not_null(src, true);
1338   tgt = must_be_not_null(tgt, true);
1339 
1340   src = access_resolve(src, ACCESS_READ);
1341   tgt = access_resolve(tgt, ACCESS_READ);
1342 
1343   // Multiply byte array index by 2 if String is UTF16 encoded
1344   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1345   src_count = _gvn.transform(new SubINode(src_count, from_index));
1346   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1347   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1348 
1349   // Range checks
1350   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1351   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1352   if (stopped()) {
1353     return true;
1354   }
1355 
1356   RegionNode* region = new RegionNode(5);
1357   Node* phi = new PhiNode(region, TypeInt::INT);
1358 
1359   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1360   if (result != NULL) {
1361     // The result is index relative to from_index if substring was found, -1 otherwise.
1362     // Generate code which will fold into cmove.
1363     Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1364     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1365 
1366     Node* if_lt = generate_slow_guard(bol, NULL);
1367     if (if_lt != NULL) {
1368       // result == -1
1369       phi-&gt;init_req(3, result);
1370       region-&gt;init_req(3, if_lt);
1371     }
1372     if (!stopped()) {
1373       result = _gvn.transform(new AddINode(result, from_index));
1374       phi-&gt;init_req(4, result);
1375       region-&gt;init_req(4, control());
1376     }
1377   }
1378 
1379   set_control(_gvn.transform(region));
1380   record_for_igvn(region);
1381   set_result(_gvn.transform(phi));
1382   clear_upper_avx();
1383 
1384   return true;
1385 }
1386 
1387 // Create StrIndexOfNode with fast path checks
1388 Node* LibraryCallKit::make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
1389                                         RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae) {
1390   // Check for substr count &gt; string count
1391   Node* cmp = _gvn.transform(new CmpINode(tgt_count, src_count));
1392   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::gt));
1393   Node* if_gt = generate_slow_guard(bol, NULL);
1394   if (if_gt != NULL) {
1395     phi-&gt;init_req(1, intcon(-1));
1396     region-&gt;init_req(1, if_gt);
1397   }
1398   if (!stopped()) {
1399     // Check for substr count == 0
1400     cmp = _gvn.transform(new CmpINode(tgt_count, intcon(0)));
1401     bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
1402     Node* if_zero = generate_slow_guard(bol, NULL);
1403     if (if_zero != NULL) {
1404       phi-&gt;init_req(2, intcon(0));
1405       region-&gt;init_req(2, if_zero);
1406     }
1407   }
1408   if (!stopped()) {
1409     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1410   }
1411   return NULL;
1412 }
1413 
1414 //-----------------------------inline_string_indexOfChar-----------------------
1415 bool LibraryCallKit::inline_string_indexOfChar() {
1416   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1417     return false;
1418   }
1419   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1420     return false;
1421   }
1422   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1423   Node* src         = argument(0); // byte[]
1424   Node* tgt         = argument(1); // tgt is int ch
1425   Node* from_index  = argument(2);
1426   Node* max         = argument(3);
1427 
1428   src = must_be_not_null(src, true);
1429   src = access_resolve(src, ACCESS_READ);
1430 
1431   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1432   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1433   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1434 
1435   // Range checks
1436   generate_string_range_check(src, src_offset, src_count, true);
1437   if (stopped()) {
1438     return true;
1439   }
1440 
1441   RegionNode* region = new RegionNode(3);
1442   Node* phi = new PhiNode(region, TypeInt::INT);
1443 
1444   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1445   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1446   _gvn.transform(result);
1447 
1448   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1449   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1450 
1451   Node* if_lt = generate_slow_guard(bol, NULL);
1452   if (if_lt != NULL) {
1453     // result == -1
1454     phi-&gt;init_req(2, result);
1455     region-&gt;init_req(2, if_lt);
1456   }
1457   if (!stopped()) {
1458     result = _gvn.transform(new AddINode(result, from_index));
1459     phi-&gt;init_req(1, result);
1460     region-&gt;init_req(1, control());
1461   }
1462   set_control(_gvn.transform(region));
1463   record_for_igvn(region);
1464   set_result(_gvn.transform(phi));
1465 
1466   return true;
1467 }
1468 //---------------------------inline_string_copy---------------------
1469 // compressIt == true --&gt; generate a compressed copy operation (compress char[]/byte[] to byte[])
1470 //   int StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)
1471 //   int StringUTF16.compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1472 // compressIt == false --&gt; generate an inflated copy operation (inflate byte[] to char[]/byte[])
1473 //   void StringLatin1.inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)
1474 //   void StringLatin1.inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1475 bool LibraryCallKit::inline_string_copy(bool compress) {
1476   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1477     return false;
1478   }
1479   int nargs = 5;  // 2 oops, 3 ints
1480   assert(callee()-&gt;signature()-&gt;size() == nargs, &quot;string copy has 5 arguments&quot;);
1481 
1482   Node* src         = argument(0);
1483   Node* src_offset  = argument(1);
1484   Node* dst         = argument(2);
1485   Node* dst_offset  = argument(3);
1486   Node* length      = argument(4);
1487 
1488   // Check for allocation before we add nodes that would confuse
1489   // tightly_coupled_allocation()
1490   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1491 
1492   // Figure out the size and type of the elements we will be copying.
1493   const Type* src_type = src-&gt;Value(&amp;_gvn);
1494   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
1495   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1496   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1497   assert((compress &amp;&amp; dst_elem == T_BYTE &amp;&amp; (src_elem == T_BYTE || src_elem == T_CHAR)) ||
1498          (!compress &amp;&amp; src_elem == T_BYTE &amp;&amp; (dst_elem == T_BYTE || dst_elem == T_CHAR)),
1499          &quot;Unsupported array types for inline_string_copy&quot;);
1500 
1501   src = must_be_not_null(src, true);
1502   dst = must_be_not_null(dst, true);
1503 
1504   // Convert char[] offsets to byte[] offsets
1505   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1506   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1507   if (convert_src) {
1508     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1509   } else if (convert_dst) {
1510     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1511   }
1512 
1513   // Range checks
1514   generate_string_range_check(src, src_offset, length, convert_src);
1515   generate_string_range_check(dst, dst_offset, length, convert_dst);
1516   if (stopped()) {
1517     return true;
1518   }
1519 
1520   src = access_resolve(src, ACCESS_READ);
1521   dst = access_resolve(dst, ACCESS_WRITE);
1522 
1523   Node* src_start = array_element_address(src, src_offset, src_elem);
1524   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1525   // &#39;src_start&#39; points to src array + scaled offset
1526   // &#39;dst_start&#39; points to dst array + scaled offset
1527   Node* count = NULL;
1528   if (compress) {
1529     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1530   } else {
1531     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1532   }
1533 
1534   if (alloc != NULL) {
1535     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1536       // &quot;You break it, you buy it.&quot;
1537       InitializeNode* init = alloc-&gt;initialization();
1538       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1539       init-&gt;set_complete_with_arraycopy();
1540       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1541       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1542     }
1543     // Do not let stores that initialize this object be reordered with
1544     // a subsequent store that would make this object accessible by
1545     // other threads.
1546     // Record what AllocateNode this StoreStore protects so that
1547     // escape analysis can go from the MemBarStoreStoreNode to the
1548     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1549     // based on the escape status of the AllocateNode.
1550     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1551   }
1552   if (compress) {
1553     set_result(_gvn.transform(count));
1554   }
1555   clear_upper_avx();
1556 
1557   return true;
1558 }
1559 
1560 #ifdef _LP64
1561 #define XTOP ,top() /*additional argument*/
1562 #else  //_LP64
1563 #define XTOP        /*no additional argument*/
1564 #endif //_LP64
1565 
1566 //------------------------inline_string_toBytesU--------------------------
1567 // public static byte[] StringUTF16.toBytes(char[] value, int off, int len)
1568 bool LibraryCallKit::inline_string_toBytesU() {
1569   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1570     return false;
1571   }
1572   // Get the arguments.
1573   Node* value     = argument(0);
1574   Node* offset    = argument(1);
1575   Node* length    = argument(2);
1576 
1577   Node* newcopy = NULL;
1578 
1579   // Set the original stack and the reexecute bit for the interpreter to reexecute
1580   // the bytecode that invokes StringUTF16.toBytes() if deoptimization happens.
1581   { PreserveReexecuteState preexecs(this);
1582     jvms()-&gt;set_should_reexecute(true);
1583 
1584     // Check if a null path was taken unconditionally.
1585     value = null_check(value);
1586 
1587     RegionNode* bailout = new RegionNode(1);
1588     record_for_igvn(bailout);
1589 
1590     // Range checks
1591     generate_negative_guard(offset, bailout);
1592     generate_negative_guard(length, bailout);
1593     generate_limit_guard(offset, length, load_array_length(value), bailout);
1594     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1595     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1596 
1597     if (bailout-&gt;req() &gt; 1) {
1598       PreserveJVMState pjvms(this);
1599       set_control(_gvn.transform(bailout));
1600       uncommon_trap(Deoptimization::Reason_intrinsic,
1601                     Deoptimization::Action_maybe_recompile);
1602     }
1603     if (stopped()) {
1604       return true;
1605     }
1606 
1607     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1608     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1609     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1610     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1611 
1612     // Calculate starting addresses.
1613     value = access_resolve(value, ACCESS_READ);
1614     Node* src_start = array_element_address(value, offset, T_CHAR);
1615     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1616 
1617     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1618     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1619     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1620 
1621     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1622     const char* copyfunc_name = &quot;arraycopy&quot;;
1623     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1624     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1625                       OptoRuntime::fast_arraycopy_Type(),
1626                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1627                       src_start, dst_start, ConvI2X(length) XTOP);
1628     // Do not let reads from the cloned object float above the arraycopy.
1629     if (alloc != NULL) {
1630       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1631         // &quot;You break it, you buy it.&quot;
1632         InitializeNode* init = alloc-&gt;initialization();
1633         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1634         init-&gt;set_complete_with_arraycopy();
1635         assert(newcopy-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1636         assert(newcopy-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1637       }
1638       // Do not let stores that initialize this object be reordered with
1639       // a subsequent store that would make this object accessible by
1640       // other threads.
1641       // Record what AllocateNode this StoreStore protects so that
1642       // escape analysis can go from the MemBarStoreStoreNode to the
1643       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1644       // based on the escape status of the AllocateNode.
1645       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1646     } else {
1647       insert_mem_bar(Op_MemBarCPUOrder);
1648     }
1649   } // original reexecute is set back here
1650 
1651   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1652   if (!stopped()) {
1653     set_result(newcopy);
1654   }
1655   clear_upper_avx();
1656 
1657   return true;
1658 }
1659 
1660 //------------------------inline_string_getCharsU--------------------------
1661 // public void StringUTF16.getChars(byte[] src, int srcBegin, int srcEnd, char dst[], int dstBegin)
1662 bool LibraryCallKit::inline_string_getCharsU() {
1663   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1664     return false;
1665   }
1666 
1667   // Get the arguments.
1668   Node* src       = argument(0);
1669   Node* src_begin = argument(1);
1670   Node* src_end   = argument(2); // exclusive offset (i &lt; src_end)
1671   Node* dst       = argument(3);
1672   Node* dst_begin = argument(4);
1673 
1674   // Check for allocation before we add nodes that would confuse
1675   // tightly_coupled_allocation()
1676   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1677 
1678   // Check if a null path was taken unconditionally.
1679   src = null_check(src);
1680   dst = null_check(dst);
1681   if (stopped()) {
1682     return true;
1683   }
1684 
1685   // Get length and convert char[] offset to byte[] offset
1686   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1687   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1688 
1689   // Range checks
1690   generate_string_range_check(src, src_begin, length, true);
1691   generate_string_range_check(dst, dst_begin, length, false);
1692   if (stopped()) {
1693     return true;
1694   }
1695 
1696   if (!stopped()) {
1697     src = access_resolve(src, ACCESS_READ);
1698     dst = access_resolve(dst, ACCESS_WRITE);
1699 
1700     // Calculate starting addresses.
1701     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1702     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1703 
1704     // Check if array addresses are aligned to HeapWordSize
1705     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1706     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1707     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1708                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1709 
1710     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1711     const char* copyfunc_name = &quot;arraycopy&quot;;
1712     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1713     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1714                       OptoRuntime::fast_arraycopy_Type(),
1715                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1716                       src_start, dst_start, ConvI2X(length) XTOP);
1717     // Do not let reads from the cloned object float above the arraycopy.
1718     if (alloc != NULL) {
1719       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1720         // &quot;You break it, you buy it.&quot;
1721         InitializeNode* init = alloc-&gt;initialization();
1722         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1723         init-&gt;set_complete_with_arraycopy();
1724         assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1725         assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1726       }
1727       // Do not let stores that initialize this object be reordered with
1728       // a subsequent store that would make this object accessible by
1729       // other threads.
1730       // Record what AllocateNode this StoreStore protects so that
1731       // escape analysis can go from the MemBarStoreStoreNode to the
1732       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1733       // based on the escape status of the AllocateNode.
1734       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1735     } else {
1736       insert_mem_bar(Op_MemBarCPUOrder);
1737     }
1738   }
1739 
1740   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1741   return true;
1742 }
1743 
1744 //----------------------inline_string_char_access----------------------------
1745 // Store/Load char to/from byte[] array.
1746 // static void StringUTF16.putChar(byte[] val, int index, int c)
1747 // static char StringUTF16.getChar(byte[] val, int index)
1748 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1749   Node* value  = argument(0);
1750   Node* index  = argument(1);
1751   Node* ch = is_store ? argument(2) : NULL;
1752 
1753   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1754   // correctly requires matched array shapes.
1755   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1756           &quot;sanity: byte[] and char[] bases agree&quot;);
1757   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1758           &quot;sanity: byte[] and char[] scales agree&quot;);
1759 
1760   // Bail when getChar over constants is requested: constant folding would
1761   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1762   // Java method would constant fold nicely instead.
1763   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1764     return false;
1765   }
1766 
1767   value = must_be_not_null(value, true);
1768   value = access_resolve(value, is_store ? ACCESS_WRITE : ACCESS_READ);
1769 
1770   Node* adr = array_element_address(value, index, T_CHAR);
1771   if (adr-&gt;is_top()) {
1772     return false;
1773   }
1774   if (is_store) {
1775     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1776   } else {
1777     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1778     set_result(ch);
1779   }
1780   return true;
1781 }
1782 
1783 //--------------------------round_double_node--------------------------------
1784 // Round a double node if necessary.
1785 Node* LibraryCallKit::round_double_node(Node* n) {
1786   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt;= 1)
1787     n = _gvn.transform(new RoundDoubleNode(0, n));
1788   return n;
1789 }
1790 
1791 //------------------------------inline_math-----------------------------------
1792 // public static double Math.abs(double)
1793 // public static double Math.sqrt(double)
1794 // public static double Math.log(double)
1795 // public static double Math.log10(double)
1796 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {
1797   Node* arg = round_double_node(argument(0));
1798   Node* n = NULL;
1799   switch (id) {
1800   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1801   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
1802   default:  fatal_unexpected_iid(id);  break;
1803   }
1804   set_result(_gvn.transform(n));
1805   return true;
1806 }
1807 
1808 //------------------------------runtime_math-----------------------------
1809 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1810   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1811          &quot;must be (DD)D or (D)D type&quot;);
1812 
1813   // Inputs
1814   Node* a = round_double_node(argument(0));
1815   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1816 
1817   const TypePtr* no_memory_effects = NULL;
1818   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1819                                  no_memory_effects,
1820                                  a, top(), b, b ? top() : NULL);
1821   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
1822 #ifdef ASSERT
1823   Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));
1824   assert(value_top == top(), &quot;second value must be top&quot;);
1825 #endif
1826 
1827   set_result(value);
1828   return true;
1829 }
1830 
1831 //------------------------------inline_math_native-----------------------------
1832 bool LibraryCallKit::inline_math_native(vmIntrinsics::ID id) {
1833 #define FN_PTR(f) CAST_FROM_FN_PTR(address, f)
1834   switch (id) {
1835     // These intrinsics are not properly supported on all hardware
1836   case vmIntrinsics::_dsin:
1837     return StubRoutines::dsin() != NULL ?
1838       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1839       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1840   case vmIntrinsics::_dcos:
1841     return StubRoutines::dcos() != NULL ?
1842       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1843       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1844   case vmIntrinsics::_dtan:
1845     return StubRoutines::dtan() != NULL ?
1846       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1847       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1848   case vmIntrinsics::_dlog:
1849     return StubRoutines::dlog() != NULL ?
1850       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1851       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1852   case vmIntrinsics::_dlog10:
1853     return StubRoutines::dlog10() != NULL ?
1854       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1855       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1856 
1857     // These intrinsics are supported on all hardware
1858   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_math(id) : false;
1859   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_math(id) : false;
1860 
1861   case vmIntrinsics::_dexp:
1862     return StubRoutines::dexp() != NULL ?
1863       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1864       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1865   case vmIntrinsics::_dpow: {
1866     Node* exp = round_double_node(argument(2));
1867     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1868     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1869       // Special case: pow(x, 2.0) =&gt; x * x
1870       Node* base = round_double_node(argument(0));
1871       set_result(_gvn.transform(new MulDNode(base, base)));
1872       return true;
1873     }
1874     return StubRoutines::dpow() != NULL ?
1875       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1876       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1877   }
1878 #undef FN_PTR
1879 
1880    // These intrinsics are not yet correctly implemented
1881   case vmIntrinsics::_datan2:
1882     return false;
1883 
1884   default:
1885     fatal_unexpected_iid(id);
1886     return false;
1887   }
1888 }
1889 
1890 static bool is_simple_name(Node* n) {
1891   return (n-&gt;req() == 1         // constant
1892           || (n-&gt;is_Type() &amp;&amp; n-&gt;as_Type()-&gt;type()-&gt;singleton())
1893           || n-&gt;is_Proj()       // parameter or return value
1894           || n-&gt;is_Phi()        // local of some sort
1895           );
1896 }
1897 
1898 //----------------------------inline_notify-----------------------------------*
1899 bool LibraryCallKit::inline_notify(vmIntrinsics::ID id) {
1900   const TypeFunc* ftype = OptoRuntime::monitor_notify_Type();
1901   address func;
1902   if (id == vmIntrinsics::_notify) {
1903     func = OptoRuntime::monitor_notify_Java();
1904   } else {
1905     func = OptoRuntime::monitor_notifyAll_Java();
1906   }
1907   Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));
1908   make_slow_call_ex(call, env()-&gt;Throwable_klass(), false);
1909   return true;
1910 }
1911 
1912 
1913 //----------------------------inline_min_max-----------------------------------
1914 bool LibraryCallKit::inline_min_max(vmIntrinsics::ID id) {
1915   set_result(generate_min_max(id, argument(0), argument(1)));
1916   return true;
1917 }
1918 
1919 void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {
1920   Node* bol = _gvn.transform( new BoolNode(test, BoolTest::overflow) );
1921   IfNode* check = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);
1922   Node* fast_path = _gvn.transform( new IfFalseNode(check));
1923   Node* slow_path = _gvn.transform( new IfTrueNode(check) );
1924 
1925   {
1926     PreserveJVMState pjvms(this);
1927     PreserveReexecuteState preexecs(this);
1928     jvms()-&gt;set_should_reexecute(true);
1929 
1930     set_control(slow_path);
1931     set_i_o(i_o());
1932 
1933     uncommon_trap(Deoptimization::Reason_intrinsic,
1934                   Deoptimization::Action_none);
1935   }
1936 
1937   set_control(fast_path);
1938   set_result(math);
1939 }
1940 
1941 template &lt;typename OverflowOp&gt;
1942 bool LibraryCallKit::inline_math_overflow(Node* arg1, Node* arg2) {
1943   typedef typename OverflowOp::MathOp MathOp;
1944 
1945   MathOp* mathOp = new MathOp(arg1, arg2);
1946   Node* operation = _gvn.transform( mathOp );
1947   Node* ofcheck = _gvn.transform( new OverflowOp(arg1, arg2) );
1948   inline_math_mathExact(operation, ofcheck);
1949   return true;
1950 }
1951 
1952 bool LibraryCallKit::inline_math_addExactI(bool is_increment) {
1953   return inline_math_overflow&lt;OverflowAddINode&gt;(argument(0), is_increment ? intcon(1) : argument(1));
1954 }
1955 
1956 bool LibraryCallKit::inline_math_addExactL(bool is_increment) {
1957   return inline_math_overflow&lt;OverflowAddLNode&gt;(argument(0), is_increment ? longcon(1) : argument(2));
1958 }
1959 
1960 bool LibraryCallKit::inline_math_subtractExactI(bool is_decrement) {
1961   return inline_math_overflow&lt;OverflowSubINode&gt;(argument(0), is_decrement ? intcon(1) : argument(1));
1962 }
1963 
1964 bool LibraryCallKit::inline_math_subtractExactL(bool is_decrement) {
1965   return inline_math_overflow&lt;OverflowSubLNode&gt;(argument(0), is_decrement ? longcon(1) : argument(2));
1966 }
1967 
1968 bool LibraryCallKit::inline_math_negateExactI() {
1969   return inline_math_overflow&lt;OverflowSubINode&gt;(intcon(0), argument(0));
1970 }
1971 
1972 bool LibraryCallKit::inline_math_negateExactL() {
1973   return inline_math_overflow&lt;OverflowSubLNode&gt;(longcon(0), argument(0));
1974 }
1975 
1976 bool LibraryCallKit::inline_math_multiplyExactI() {
1977   return inline_math_overflow&lt;OverflowMulINode&gt;(argument(0), argument(1));
1978 }
1979 
1980 bool LibraryCallKit::inline_math_multiplyExactL() {
1981   return inline_math_overflow&lt;OverflowMulLNode&gt;(argument(0), argument(2));
1982 }
1983 
1984 bool LibraryCallKit::inline_math_multiplyHigh() {
1985   set_result(_gvn.transform(new MulHiLNode(argument(0), argument(2))));
1986   return true;
1987 }
1988 
1989 Node*
1990 LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {
1991   // These are the candidate return value:
1992   Node* xvalue = x0;
1993   Node* yvalue = y0;
1994 
1995   if (xvalue == yvalue) {
1996     return xvalue;
1997   }
1998 
1999   bool want_max = (id == vmIntrinsics::_max);
2000 
2001   const TypeInt* txvalue = _gvn.type(xvalue)-&gt;isa_int();
2002   const TypeInt* tyvalue = _gvn.type(yvalue)-&gt;isa_int();
2003   if (txvalue == NULL || tyvalue == NULL)  return top();
2004   // This is not really necessary, but it is consistent with a
2005   // hypothetical MaxINode::Value method:
2006   int widen = MAX2(txvalue-&gt;_widen, tyvalue-&gt;_widen);
2007 
2008   // %%% This folding logic should (ideally) be in a different place.
2009   // Some should be inside IfNode, and there to be a more reliable
2010   // transformation of ?: style patterns into cmoves.  We also want
2011   // more powerful optimizations around cmove and min/max.
2012 
2013   // Try to find a dominating comparison of these guys.
2014   // It can simplify the index computation for Arrays.copyOf
2015   // and similar uses of System.arraycopy.
2016   // First, compute the normalized version of CmpI(x, y).
2017   int   cmp_op = Op_CmpI;
2018   Node* xkey = xvalue;
2019   Node* ykey = yvalue;
2020   Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));
2021   if (ideal_cmpxy-&gt;is_Cmp()) {
2022     // E.g., if we have CmpI(length - offset, count),
2023     // it might idealize to CmpI(length, count + offset)
2024     cmp_op = ideal_cmpxy-&gt;Opcode();
2025     xkey = ideal_cmpxy-&gt;in(1);
2026     ykey = ideal_cmpxy-&gt;in(2);
2027   }
2028 
2029   // Start by locating any relevant comparisons.
2030   Node* start_from = (xkey-&gt;outcnt() &lt; ykey-&gt;outcnt()) ? xkey : ykey;
2031   Node* cmpxy = NULL;
2032   Node* cmpyx = NULL;
2033   for (DUIterator_Fast kmax, k = start_from-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2034     Node* cmp = start_from-&gt;fast_out(k);
2035     if (cmp-&gt;outcnt() &gt; 0 &amp;&amp;            // must have prior uses
2036         cmp-&gt;in(0) == NULL &amp;&amp;           // must be context-independent
2037         cmp-&gt;Opcode() == cmp_op) {      // right kind of compare
2038       if (cmp-&gt;in(1) == xkey &amp;&amp; cmp-&gt;in(2) == ykey)  cmpxy = cmp;
2039       if (cmp-&gt;in(1) == ykey &amp;&amp; cmp-&gt;in(2) == xkey)  cmpyx = cmp;
2040     }
2041   }
2042 
2043   const int NCMPS = 2;
2044   Node* cmps[NCMPS] = { cmpxy, cmpyx };
2045   int cmpn;
2046   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2047     if (cmps[cmpn] != NULL)  break;     // find a result
2048   }
2049   if (cmpn &lt; NCMPS) {
2050     // Look for a dominating test that tells us the min and max.
2051     int depth = 0;                // Limit search depth for speed
2052     Node* dom = control();
2053     for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {
2054       if (++depth &gt;= 100)  break;
2055       Node* ifproj = dom;
2056       if (!ifproj-&gt;is_Proj())  continue;
2057       Node* iff = ifproj-&gt;in(0);
2058       if (!iff-&gt;is_If())  continue;
2059       Node* bol = iff-&gt;in(1);
2060       if (!bol-&gt;is_Bool())  continue;
2061       Node* cmp = bol-&gt;in(1);
2062       if (cmp == NULL)  continue;
2063       for (cmpn = 0; cmpn &lt; NCMPS; cmpn++)
2064         if (cmps[cmpn] == cmp)  break;
2065       if (cmpn == NCMPS)  continue;
2066       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2067       if (ifproj-&gt;is_IfFalse())  btest = BoolTest(btest).negate();
2068       if (cmp-&gt;in(1) == ykey)    btest = BoolTest(btest).commute();
2069       // At this point, we know that &#39;x btest y&#39; is true.
2070       switch (btest) {
2071       case BoolTest::eq:
2072         // They are proven equal, so we can collapse the min/max.
2073         // Either value is the answer.  Choose the simpler.
2074         if (is_simple_name(yvalue) &amp;&amp; !is_simple_name(xvalue))
2075           return yvalue;
2076         return xvalue;
2077       case BoolTest::lt:          // x &lt; y
2078       case BoolTest::le:          // x &lt;= y
2079         return (want_max ? yvalue : xvalue);
2080       case BoolTest::gt:          // x &gt; y
2081       case BoolTest::ge:          // x &gt;= y
2082         return (want_max ? xvalue : yvalue);
2083       default:
2084         break;
2085       }
2086     }
2087   }
2088 
2089   // We failed to find a dominating test.
2090   // Let&#39;s pick a test that might GVN with prior tests.
2091   Node*          best_bol   = NULL;
2092   BoolTest::mask best_btest = BoolTest::illegal;
2093   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2094     Node* cmp = cmps[cmpn];
2095     if (cmp == NULL)  continue;
2096     for (DUIterator_Fast jmax, j = cmp-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2097       Node* bol = cmp-&gt;fast_out(j);
2098       if (!bol-&gt;is_Bool())  continue;
2099       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2100       if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;
2101       if (cmp-&gt;in(1) == ykey)   btest = BoolTest(btest).commute();
2102       if (bol-&gt;outcnt() &gt; (best_bol == NULL ? 0 : best_bol-&gt;outcnt())) {
2103         best_bol   = bol-&gt;as_Bool();
2104         best_btest = btest;
2105       }
2106     }
2107   }
2108 
2109   Node* answer_if_true  = NULL;
2110   Node* answer_if_false = NULL;
2111   switch (best_btest) {
2112   default:
2113     if (cmpxy == NULL)
2114       cmpxy = ideal_cmpxy;
2115     best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));
2116     // and fall through:
2117   case BoolTest::lt:          // x &lt; y
2118   case BoolTest::le:          // x &lt;= y
2119     answer_if_true  = (want_max ? yvalue : xvalue);
2120     answer_if_false = (want_max ? xvalue : yvalue);
2121     break;
2122   case BoolTest::gt:          // x &gt; y
2123   case BoolTest::ge:          // x &gt;= y
2124     answer_if_true  = (want_max ? xvalue : yvalue);
2125     answer_if_false = (want_max ? yvalue : xvalue);
2126     break;
2127   }
2128 
2129   jint hi, lo;
2130   if (want_max) {
2131     // We can sharpen the minimum.
2132     hi = MAX2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2133     lo = MAX2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2134   } else {
2135     // We can sharpen the maximum.
2136     hi = MIN2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2137     lo = MIN2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2138   }
2139 
2140   // Use a flow-free graph structure, to avoid creating excess control edges
2141   // which could hinder other optimizations.
2142   // Since Math.min/max is often used with arraycopy, we want
2143   // tightly_coupled_allocation to be able to see beyond min/max expressions.
2144   Node* cmov = CMoveNode::make(NULL, best_bol,
2145                                answer_if_false, answer_if_true,
2146                                TypeInt::make(lo, hi, widen));
2147 
2148   return _gvn.transform(cmov);
2149 
2150   /*
2151   // This is not as desirable as it may seem, since Min and Max
2152   // nodes do not have a full set of optimizations.
2153   // And they would interfere, anyway, with &#39;if&#39; optimizations
2154   // and with CMoveI canonical forms.
2155   switch (id) {
2156   case vmIntrinsics::_min:
2157     result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;
2158   case vmIntrinsics::_max:
2159     result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;
2160   default:
2161     ShouldNotReachHere();
2162   }
2163   */
2164 }
2165 
2166 inline int
2167 LibraryCallKit::classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type) {
2168   const TypePtr* base_type = TypePtr::NULL_PTR;
2169   if (base != NULL)  base_type = _gvn.type(base)-&gt;isa_ptr();
2170   if (base_type == NULL) {
2171     // Unknown type.
2172     return Type::AnyPtr;
2173   } else if (base_type == TypePtr::NULL_PTR) {
2174     // Since this is a NULL+long form, we have to switch to a rawptr.
2175     base   = _gvn.transform(new CastX2PNode(offset));
2176     offset = MakeConX(0);
2177     return Type::RawPtr;
2178   } else if (base_type-&gt;base() == Type::RawPtr) {
2179     return Type::RawPtr;
2180   } else if (base_type-&gt;isa_oopptr()) {
2181     // Base is never null =&gt; always a heap address.
2182     if (!TypePtr::NULL_PTR-&gt;higher_equal(base_type)) {
2183       return Type::OopPtr;
2184     }
2185     // Offset is small =&gt; always a heap address.
2186     const TypeX* offset_type = _gvn.type(offset)-&gt;isa_intptr_t();
2187     if (offset_type != NULL &amp;&amp;
2188         base_type-&gt;offset() == 0 &amp;&amp;     // (should always be?)
2189         offset_type-&gt;_lo &gt;= 0 &amp;&amp;
2190         !MacroAssembler::needs_explicit_null_check(offset_type-&gt;_hi)) {
2191       return Type::OopPtr;
2192     } else if (type == T_OBJECT) {
2193       // off heap access to an oop doesn&#39;t make any sense. Has to be on
2194       // heap.
2195       return Type::OopPtr;
2196     }
2197     // Otherwise, it might either be oop+off or NULL+addr.
2198     return Type::AnyPtr;
2199   } else {
2200     // No information:
2201     return Type::AnyPtr;
2202   }
2203 }
2204 
2205 inline Node* LibraryCallKit::make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {
2206   Node* uncasted_base = base;
2207   int kind = classify_unsafe_addr(uncasted_base, offset, type);
2208   if (kind == Type::RawPtr) {
2209     return basic_plus_adr(top(), uncasted_base, offset);
2210   } else if (kind == Type::AnyPtr) {
2211     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2212     if (can_cast) {
2213       if (!_gvn.type(base)-&gt;speculative_maybe_null() &amp;&amp;
2214           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2215         // According to profiling, this access is always on
2216         // heap. Casting the base to not null and thus avoiding membars
2217         // around the access should allow better optimizations
2218         Node* null_ctl = top();
2219         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2220         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2221         return basic_plus_adr(base, offset);
2222       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2223                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2224         // According to profiling, this access is always off
2225         // heap.
2226         base = null_assert(base);
2227         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2228         offset = MakeConX(0);
2229         return basic_plus_adr(top(), raw_base, offset);
2230       }
2231     }
2232     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2233     // to raw memory access.
2234     base = access_resolve(base, decorators);
2235     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2236     return basic_plus_adr(top(), raw, offset);
2237   } else {
2238     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2239     // We know it&#39;s an on heap access so base can&#39;t be null
2240     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2241       base = must_be_not_null(base, true);
2242     }
2243     return basic_plus_adr(base, offset);
2244   }
2245 }
2246 
2247 //--------------------------inline_number_methods-----------------------------
2248 // inline int     Integer.numberOfLeadingZeros(int)
2249 // inline int        Long.numberOfLeadingZeros(long)
2250 //
2251 // inline int     Integer.numberOfTrailingZeros(int)
2252 // inline int        Long.numberOfTrailingZeros(long)
2253 //
2254 // inline int     Integer.bitCount(int)
2255 // inline int        Long.bitCount(long)
2256 //
2257 // inline char  Character.reverseBytes(char)
2258 // inline short     Short.reverseBytes(short)
2259 // inline int     Integer.reverseBytes(int)
2260 // inline long       Long.reverseBytes(long)
2261 bool LibraryCallKit::inline_number_methods(vmIntrinsics::ID id) {
2262   Node* arg = argument(0);
2263   Node* n = NULL;
2264   switch (id) {
2265   case vmIntrinsics::_numberOfLeadingZeros_i:   n = new CountLeadingZerosINode( arg);  break;
2266   case vmIntrinsics::_numberOfLeadingZeros_l:   n = new CountLeadingZerosLNode( arg);  break;
2267   case vmIntrinsics::_numberOfTrailingZeros_i:  n = new CountTrailingZerosINode(arg);  break;
2268   case vmIntrinsics::_numberOfTrailingZeros_l:  n = new CountTrailingZerosLNode(arg);  break;
2269   case vmIntrinsics::_bitCount_i:               n = new PopCountINode(          arg);  break;
2270   case vmIntrinsics::_bitCount_l:               n = new PopCountLNode(          arg);  break;
2271   case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;
2272   case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;
2273   case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;
2274   case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;
2275   default:  fatal_unexpected_iid(id);  break;
2276   }
2277   set_result(_gvn.transform(n));
2278   return true;
2279 }
2280 
2281 //----------------------------inline_unsafe_access----------------------------
2282 
2283 const TypeOopPtr* LibraryCallKit::sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type) {
2284   // Attempt to infer a sharper value type from the offset and base type.
2285   ciKlass* sharpened_klass = NULL;
2286 
2287   // See if it is an instance field, with an object type.
2288   if (alias_type-&gt;field() != NULL) {
2289     if (alias_type-&gt;field()-&gt;type()-&gt;is_klass()) {
2290       sharpened_klass = alias_type-&gt;field()-&gt;type()-&gt;as_klass();
2291     }
2292   }
2293 
2294   // See if it is a narrow oop array.
2295   if (adr_type-&gt;isa_aryptr()) {
2296     if (adr_type-&gt;offset() &gt;= objArrayOopDesc::base_offset_in_bytes()) {
2297       const TypeOopPtr *elem_type = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_oopptr();
2298       if (elem_type != NULL) {
2299         sharpened_klass = elem_type-&gt;klass();
2300       }
2301     }
2302   }
2303 
2304   // The sharpened class might be unloaded if there is no class loader
2305   // contraint in place.
2306   if (sharpened_klass != NULL &amp;&amp; sharpened_klass-&gt;is_loaded()) {
2307     const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);
2308 
2309 #ifndef PRODUCT
2310     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
2311       tty-&gt;print(&quot;  from base type:  &quot;);  adr_type-&gt;dump(); tty-&gt;cr();
2312       tty-&gt;print(&quot;  sharpened value: &quot;);  tjp-&gt;dump();      tty-&gt;cr();
2313     }
2314 #endif
2315     // Sharpen the value type.
2316     return tjp;
2317   }
2318   return NULL;
2319 }
2320 
2321 DecoratorSet LibraryCallKit::mo_decorator_for_access_kind(AccessKind kind) {
2322   switch (kind) {
2323       case Relaxed:
2324         return MO_UNORDERED;
2325       case Opaque:
2326         return MO_RELAXED;
2327       case Acquire:
2328         return MO_ACQUIRE;
2329       case Release:
2330         return MO_RELEASE;
2331       case Volatile:
2332         return MO_SEQ_CST;
2333       default:
2334         ShouldNotReachHere();
2335         return 0;
2336   }
2337 }
2338 
2339 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2340   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2341   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2342   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2343   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2344   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2345 
2346   if (type == T_OBJECT || type == T_ARRAY) {
2347     decorators |= ON_UNKNOWN_OOP_REF;
2348   }
2349 
2350   if (unaligned) {
2351     decorators |= C2_UNALIGNED;
2352   }
2353 
2354 #ifndef PRODUCT
2355   {
2356     ResourceMark rm;
2357     // Check the signatures.
2358     ciSignature* sig = callee()-&gt;signature();
2359 #ifdef ASSERT
2360     if (!is_store) {
2361       // Object getReference(Object base, int/long offset), etc.
2362       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2363       assert(rtype == type, &quot;getter must return the expected value&quot;);
2364       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);
2365       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2366       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
2367     } else {
2368       // void putReference(Object base, int/long offset, Object x), etc.
2369       assert(sig-&gt;return_type()-&gt;basic_type() == T_VOID, &quot;putter must not return a value&quot;);
2370       assert(sig-&gt;count() == 3, &quot;oop putter has 3 arguments&quot;);
2371       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;putter base is object&quot;);
2372       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;putter offset is correct&quot;);
2373       BasicType vtype = sig-&gt;type_at(sig-&gt;count()-1)-&gt;basic_type();
2374       assert(vtype == type, &quot;putter must accept the expected value&quot;);
2375     }
2376 #endif // ASSERT
2377  }
2378 #endif //PRODUCT
2379 
2380   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2381 
2382   Node* receiver = argument(0);  // type: oop
2383 
2384   // Build address expression.
2385   Node* adr;
2386   Node* heap_base_oop = top();
2387   Node* offset = top();
2388   Node* val;
2389 
2390   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2391   Node* base = argument(1);  // type: oop
2392   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2393   offset = argument(2);  // type: long
2394   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2395   // to be plain byte offsets, which are also the same as those accepted
2396   // by oopDesc::field_addr.
2397   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2398          &quot;fieldOffset must be byte-scaled&quot;);
2399   // 32-bit machines ignore the high half!
2400   offset = ConvL2X(offset);
2401   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2402 
2403   if (_gvn.type(base)-&gt;isa_ptr() != TypePtr::NULL_PTR) {
2404     heap_base_oop = base;
2405   } else if (type == T_OBJECT) {
2406     return false; // off-heap oop accesses are not supported
2407   }
2408 
2409   // Can base be NULL? Otherwise, always on-heap access.
2410   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(heap_base_oop));
2411 
2412   if (!can_access_non_heap) {
2413     decorators |= IN_HEAP;
2414   }
2415 
2416   val = is_store ? argument(4) : NULL;
2417 
2418   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2419 
2420   // Try to categorize the address.
2421   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2422   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2423 
2424   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2425       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2426     return false; // not supported
2427   }
2428 
2429   bool mismatched = false;
2430   BasicType bt = alias_type-&gt;basic_type();
2431   if (bt != T_ILLEGAL) {
2432     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2433     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2434       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2435       // Use address type to get the element type.
2436       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2437     }
2438     if (bt == T_ARRAY || bt == T_NARROWOOP) {
2439       // accessing an array field with getReference is not a mismatch
2440       bt = T_OBJECT;
2441     }
2442     if ((bt == T_OBJECT) != (type == T_OBJECT)) {
2443       // Don&#39;t intrinsify mismatched object accesses
2444       return false;
2445     }
2446     mismatched = (bt != type);
2447   } else if (alias_type-&gt;adr_type()-&gt;isa_oopptr()) {
2448     mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
2449   }
2450 
2451   assert(!mismatched || alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;off-heap access can&#39;t be mismatched&quot;);
2452 
2453   if (mismatched) {
2454     decorators |= C2_MISMATCHED;
2455   }
2456 
2457   // First guess at the value type.
2458   const Type *value_type = Type::get_const_basic_type(type);
2459 
2460   // Figure out the memory ordering.
2461   decorators |= mo_decorator_for_access_kind(kind);
2462 
2463   if (!is_store &amp;&amp; type == T_OBJECT) {
2464     const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2465     if (tjp != NULL) {
2466       value_type = tjp;
2467     }
2468   }
2469 
2470   receiver = null_check(receiver);
2471   if (stopped()) {
2472     return true;
2473   }
2474   // Heap pointers get a null-check from the interpreter,
2475   // as a courtesy.  However, this is not guaranteed by Unsafe,
2476   // and it is not possible to fully distinguish unintended nulls
2477   // from intended ones in this API.
2478 
2479   if (!is_store) {
2480     Node* p = NULL;
2481     // Try to constant fold a load from a constant field
2482     ciField* field = alias_type-&gt;field();
2483     if (heap_base_oop != top() &amp;&amp; field != NULL &amp;&amp; field-&gt;is_constant() &amp;&amp; !mismatched) {
2484       // final or stable field
2485       p = make_constant_from_field(field, heap_base_oop);
2486     }
2487 
2488     if (p == NULL) { // Could not constant fold the load
2489       p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);
2490       // Normalize the value returned by getBoolean in the following cases
2491       if (type == T_BOOLEAN &amp;&amp;
2492           (mismatched ||
2493            heap_base_oop == top() ||                  // - heap_base_oop is NULL or
2494            (can_access_non_heap &amp;&amp; field == NULL))    // - heap_base_oop is potentially NULL
2495                                                       //   and the unsafe access is made to large offset
2496                                                       //   (i.e., larger than the maximum offset necessary for any
2497                                                       //   field access)
2498             ) {
2499           IdealKit ideal = IdealKit(this);
2500 #define __ ideal.
2501           IdealVariable normalized_result(ideal);
2502           __ declarations_done();
2503           __ set(normalized_result, p);
2504           __ if_then(p, BoolTest::ne, ideal.ConI(0));
2505           __ set(normalized_result, ideal.ConI(1));
2506           ideal.end_if();
2507           final_sync(ideal);
2508           p = __ value(normalized_result);
2509 #undef __
2510       }
2511     }
2512     if (type == T_ADDRESS) {
2513       p = gvn().transform(new CastP2XNode(NULL, p));
2514       p = ConvX2UL(p);
2515     }
2516     // The load node has the control of the preceding MemBarCPUOrder.  All
2517     // following nodes will have the control of the MemBarCPUOrder inserted at
2518     // the end of this method.  So, pushing the load onto the stack at a later
2519     // point is fine.
2520     set_result(p);
2521   } else {
2522     if (bt == T_ADDRESS) {
2523       // Repackage the long as a pointer.
2524       val = ConvL2X(val);
2525       val = gvn().transform(new CastX2PNode(val));
2526     }
2527     access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);
2528   }
2529 
2530   return true;
2531 }
2532 
2533 //----------------------------inline_unsafe_load_store----------------------------
2534 // This method serves a couple of different customers (depending on LoadStoreKind):
2535 //
2536 // LS_cmp_swap:
2537 //
2538 //   boolean compareAndSetReference(Object o, long offset, Object expected, Object x);
2539 //   boolean compareAndSetInt(   Object o, long offset, int    expected, int    x);
2540 //   boolean compareAndSetLong(  Object o, long offset, long   expected, long   x);
2541 //
2542 // LS_cmp_swap_weak:
2543 //
2544 //   boolean weakCompareAndSetReference(       Object o, long offset, Object expected, Object x);
2545 //   boolean weakCompareAndSetReferencePlain(  Object o, long offset, Object expected, Object x);
2546 //   boolean weakCompareAndSetReferenceAcquire(Object o, long offset, Object expected, Object x);
2547 //   boolean weakCompareAndSetReferenceRelease(Object o, long offset, Object expected, Object x);
2548 //
2549 //   boolean weakCompareAndSetInt(          Object o, long offset, int    expected, int    x);
2550 //   boolean weakCompareAndSetIntPlain(     Object o, long offset, int    expected, int    x);
2551 //   boolean weakCompareAndSetIntAcquire(   Object o, long offset, int    expected, int    x);
2552 //   boolean weakCompareAndSetIntRelease(   Object o, long offset, int    expected, int    x);
2553 //
2554 //   boolean weakCompareAndSetLong(         Object o, long offset, long   expected, long   x);
2555 //   boolean weakCompareAndSetLongPlain(    Object o, long offset, long   expected, long   x);
2556 //   boolean weakCompareAndSetLongAcquire(  Object o, long offset, long   expected, long   x);
2557 //   boolean weakCompareAndSetLongRelease(  Object o, long offset, long   expected, long   x);
2558 //
2559 // LS_cmp_exchange:
2560 //
2561 //   Object compareAndExchangeReferenceVolatile(Object o, long offset, Object expected, Object x);
2562 //   Object compareAndExchangeReferenceAcquire( Object o, long offset, Object expected, Object x);
2563 //   Object compareAndExchangeReferenceRelease( Object o, long offset, Object expected, Object x);
2564 //
2565 //   Object compareAndExchangeIntVolatile(   Object o, long offset, Object expected, Object x);
2566 //   Object compareAndExchangeIntAcquire(    Object o, long offset, Object expected, Object x);
2567 //   Object compareAndExchangeIntRelease(    Object o, long offset, Object expected, Object x);
2568 //
2569 //   Object compareAndExchangeLongVolatile(  Object o, long offset, Object expected, Object x);
2570 //   Object compareAndExchangeLongAcquire(   Object o, long offset, Object expected, Object x);
2571 //   Object compareAndExchangeLongRelease(   Object o, long offset, Object expected, Object x);
2572 //
2573 // LS_get_add:
2574 //
2575 //   int  getAndAddInt( Object o, long offset, int  delta)
2576 //   long getAndAddLong(Object o, long offset, long delta)
2577 //
2578 // LS_get_set:
2579 //
2580 //   int    getAndSet(Object o, long offset, int    newValue)
2581 //   long   getAndSet(Object o, long offset, long   newValue)
2582 //   Object getAndSet(Object o, long offset, Object newValue)
2583 //
2584 bool LibraryCallKit::inline_unsafe_load_store(const BasicType type, const LoadStoreKind kind, const AccessKind access_kind) {
2585   // This basic scheme here is the same as inline_unsafe_access, but
2586   // differs in enough details that combining them would make the code
2587   // overly confusing.  (This is a true fact! I originally combined
2588   // them, but even I was confused by it!) As much code/comments as
2589   // possible are retained from inline_unsafe_access though to make
2590   // the correspondences clearer. - dl
2591 
2592   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2593 
2594   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2595   decorators |= mo_decorator_for_access_kind(access_kind);
2596 
2597 #ifndef PRODUCT
2598   BasicType rtype;
2599   {
2600     ResourceMark rm;
2601     // Check the signatures.
2602     ciSignature* sig = callee()-&gt;signature();
2603     rtype = sig-&gt;return_type()-&gt;basic_type();
2604     switch(kind) {
2605       case LS_get_add:
2606       case LS_get_set: {
2607       // Check the signatures.
2608 #ifdef ASSERT
2609       assert(rtype == type, &quot;get and set must return the expected type&quot;);
2610       assert(sig-&gt;count() == 3, &quot;get and set has 3 arguments&quot;);
2611       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;get and set base is object&quot;);
2612       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;get and set offset is long&quot;);
2613       assert(sig-&gt;type_at(2)-&gt;basic_type() == type, &quot;get and set must take expected type as new value/delta&quot;);
2614       assert(access_kind == Volatile, &quot;mo is not passed to intrinsic nodes in current implementation&quot;);
2615 #endif // ASSERT
2616         break;
2617       }
2618       case LS_cmp_swap:
2619       case LS_cmp_swap_weak: {
2620       // Check the signatures.
2621 #ifdef ASSERT
2622       assert(rtype == T_BOOLEAN, &quot;CAS must return boolean&quot;);
2623       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2624       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2625       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2626 #endif // ASSERT
2627         break;
2628       }
2629       case LS_cmp_exchange: {
2630       // Check the signatures.
2631 #ifdef ASSERT
2632       assert(rtype == type, &quot;CAS must return the expected type&quot;);
2633       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2634       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2635       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2636 #endif // ASSERT
2637         break;
2638       }
2639       default:
2640         ShouldNotReachHere();
2641     }
2642   }
2643 #endif //PRODUCT
2644 
2645   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2646 
2647   // Get arguments:
2648   Node* receiver = NULL;
2649   Node* base     = NULL;
2650   Node* offset   = NULL;
2651   Node* oldval   = NULL;
2652   Node* newval   = NULL;
2653   switch(kind) {
2654     case LS_cmp_swap:
2655     case LS_cmp_swap_weak:
2656     case LS_cmp_exchange: {
2657       const bool two_slot_type = type2size[type] == 2;
2658       receiver = argument(0);  // type: oop
2659       base     = argument(1);  // type: oop
2660       offset   = argument(2);  // type: long
2661       oldval   = argument(4);  // type: oop, int, or long
2662       newval   = argument(two_slot_type ? 6 : 5);  // type: oop, int, or long
2663       break;
2664     }
2665     case LS_get_add:
2666     case LS_get_set: {
2667       receiver = argument(0);  // type: oop
2668       base     = argument(1);  // type: oop
2669       offset   = argument(2);  // type: long
2670       oldval   = NULL;
2671       newval   = argument(4);  // type: oop, int, or long
2672       break;
2673     }
2674     default:
2675       ShouldNotReachHere();
2676   }
2677 
2678   // Build field offset expression.
2679   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2680   // to be plain byte offsets, which are also the same as those accepted
2681   // by oopDesc::field_addr.
2682   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2683   // 32-bit machines ignore the high half of long offsets
2684   offset = ConvL2X(offset);
2685   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2686   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2687 
2688   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2689   BasicType bt = alias_type-&gt;basic_type();
2690   if (bt != T_ILLEGAL &amp;&amp;
2691       ((bt == T_OBJECT || bt == T_ARRAY) != (type == T_OBJECT))) {
2692     // Don&#39;t intrinsify mismatched object accesses.
2693     return false;
2694   }
2695 
2696   // For CAS, unlike inline_unsafe_access, there seems no point in
2697   // trying to refine types. Just use the coarse types here.
2698   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2699   const Type *value_type = Type::get_const_basic_type(type);
2700 
2701   switch (kind) {
2702     case LS_get_set:
2703     case LS_cmp_exchange: {
2704       if (type == T_OBJECT) {
2705         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2706         if (tjp != NULL) {
2707           value_type = tjp;
2708         }
2709       }
2710       break;
2711     }
2712     case LS_cmp_swap:
2713     case LS_cmp_swap_weak:
2714     case LS_get_add:
2715       break;
2716     default:
2717       ShouldNotReachHere();
2718   }
2719 
2720   // Null check receiver.
2721   receiver = null_check(receiver);
2722   if (stopped()) {
2723     return true;
2724   }
2725 
2726   int alias_idx = C-&gt;get_alias_index(adr_type);
2727 
2728   if (type == T_OBJECT || type == T_ARRAY) {
2729     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2730 
2731     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2732     // could be delayed during Parse (for example, in adjust_map_after_if()).
2733     // Execute transformation here to avoid barrier generation in such case.
2734     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2735       newval = _gvn.makecon(TypePtr::NULL_PTR);
2736 
2737     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2738       // Refine the value to a null constant, when it is known to be null
2739       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2740     }
2741   }
2742 
2743   Node* result = NULL;
2744   switch (kind) {
2745     case LS_cmp_exchange: {
2746       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
2747                                             oldval, newval, value_type, type, decorators);
2748       break;
2749     }
2750     case LS_cmp_swap_weak:
2751       decorators |= C2_WEAK_CMPXCHG;
2752     case LS_cmp_swap: {
2753       result = access_atomic_cmpxchg_bool_at(base, adr, adr_type, alias_idx,
2754                                              oldval, newval, value_type, type, decorators);
2755       break;
2756     }
2757     case LS_get_set: {
2758       result = access_atomic_xchg_at(base, adr, adr_type, alias_idx,
2759                                      newval, value_type, type, decorators);
2760       break;
2761     }
2762     case LS_get_add: {
2763       result = access_atomic_add_at(base, adr, adr_type, alias_idx,
2764                                     newval, value_type, type, decorators);
2765       break;
2766     }
2767     default:
2768       ShouldNotReachHere();
2769   }
2770 
2771   assert(type2size[result-&gt;bottom_type()-&gt;basic_type()] == type2size[rtype], &quot;result type should match&quot;);
2772   set_result(result);
2773   return true;
2774 }
2775 
2776 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
2777   // Regardless of form, don&#39;t allow previous ld/st to move down,
2778   // then issue acquire, release, or volatile mem_bar.
2779   insert_mem_bar(Op_MemBarCPUOrder);
2780   switch(id) {
2781     case vmIntrinsics::_loadFence:
2782       insert_mem_bar(Op_LoadFence);
2783       return true;
2784     case vmIntrinsics::_storeFence:
2785       insert_mem_bar(Op_StoreFence);
2786       return true;
2787     case vmIntrinsics::_fullFence:
2788       insert_mem_bar(Op_MemBarVolatile);
2789       return true;
2790     default:
2791       fatal_unexpected_iid(id);
2792       return false;
2793   }
2794 }
2795 
2796 bool LibraryCallKit::inline_onspinwait() {
2797   insert_mem_bar(Op_OnSpinWait);
2798   return true;
2799 }
2800 
2801 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2802   if (!kls-&gt;is_Con()) {
2803     return true;
2804   }
2805   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2806   if (klsptr == NULL) {
2807     return true;
2808   }
2809   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2810   // don&#39;t need a guard for a klass that is already initialized
2811   return !ik-&gt;is_initialized();
2812 }
2813 
2814 //----------------------------inline_unsafe_allocate---------------------------
2815 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
2816 bool LibraryCallKit::inline_unsafe_allocate() {
2817   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2818 
2819   null_check_receiver();  // null-check, then ignore
2820   Node* cls = null_check(argument(1));
2821   if (stopped())  return true;
2822 
2823   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2824   kls = null_check(kls);
2825   if (stopped())  return true;  // argument was like int.class
2826 
2827   Node* test = NULL;
2828   if (LibraryCallKit::klass_needs_init_guard(kls)) {
2829     // Note:  The argument might still be an illegal value like
2830     // Serializable.class or Object[].class.   The runtime will handle it.
2831     // But we must make an explicit check for initialization.
2832     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
2833     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
2834     // can generate code to load it as unsigned byte.
2835     Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);
2836     Node* bits = intcon(InstanceKlass::fully_initialized);
2837     test = _gvn.transform(new SubINode(inst, bits));
2838     // The &#39;test&#39; is non-zero if we need to take a slow path.
2839   }
2840 
2841   Node* obj = new_instance(kls, test);
2842   set_result(obj);
2843   return true;
2844 }
2845 
2846 //------------------------inline_native_time_funcs--------------
2847 // inline code for System.currentTimeMillis() and System.nanoTime()
2848 // these have the same type and signature
2849 bool LibraryCallKit::inline_native_time_funcs(address funcAddr, const char* funcName) {
2850   const TypeFunc* tf = OptoRuntime::void_long_Type();
2851   const TypePtr* no_memory_effects = NULL;
2852   Node* time = make_runtime_call(RC_LEAF, tf, funcAddr, funcName, no_memory_effects);
2853   Node* value = _gvn.transform(new ProjNode(time, TypeFunc::Parms+0));
2854 #ifdef ASSERT
2855   Node* value_top = _gvn.transform(new ProjNode(time, TypeFunc::Parms+1));
2856   assert(value_top == top(), &quot;second value must be top&quot;);
2857 #endif
2858   set_result(value);
2859   return true;
2860 }
2861 
2862 #ifdef JFR_HAVE_INTRINSICS
2863 
2864 /*
2865 * oop -&gt; myklass
2866 * myklass-&gt;trace_id |= USED
2867 * return myklass-&gt;trace_id &amp; ~0x3
2868 */
2869 bool LibraryCallKit::inline_native_classID() {
2870   Node* cls = null_check(argument(0), T_OBJECT);
2871   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2872   kls = null_check(kls, T_OBJECT);
2873 
2874   ByteSize offset = KLASS_TRACE_ID_OFFSET;
2875   Node* insp = basic_plus_adr(kls, in_bytes(offset));
2876   Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);
2877 
2878   Node* clsused = longcon(0x01l); // set the class bit
2879   Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));
2880   const TypePtr *adr_type = _gvn.type(insp)-&gt;isa_ptr();
2881   store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);
2882 
2883 #ifdef TRACE_ID_META_BITS
2884   Node* mbits = longcon(~TRACE_ID_META_BITS);
2885   tvalue = _gvn.transform(new AndLNode(tvalue, mbits));
2886 #endif
2887 #ifdef TRACE_ID_SHIFT
2888   Node* cbits = intcon(TRACE_ID_SHIFT);
2889   tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));
2890 #endif
2891 
2892   set_result(tvalue);
2893   return true;
2894 
2895 }
2896 
2897 bool LibraryCallKit::inline_native_getEventWriter() {
2898   Node* tls_ptr = _gvn.transform(new ThreadLocalNode());
2899 
2900   Node* jobj_ptr = basic_plus_adr(top(), tls_ptr,
2901                                   in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR));
2902 
2903   Node* jobj = make_load(control(), jobj_ptr, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);
2904 
2905   Node* jobj_cmp_null = _gvn.transform( new CmpPNode(jobj, null()) );
2906   Node* test_jobj_eq_null  = _gvn.transform( new BoolNode(jobj_cmp_null, BoolTest::eq) );
2907 
2908   IfNode* iff_jobj_null =
2909     create_and_map_if(control(), test_jobj_eq_null, PROB_MIN, COUNT_UNKNOWN);
2910 
2911   enum { _normal_path = 1,
2912          _null_path = 2,
2913          PATH_LIMIT };
2914 
2915   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);
2916   PhiNode*    result_val = new PhiNode(result_rgn, TypeInstPtr::BOTTOM);
2917 
2918   Node* jobj_is_null = _gvn.transform(new IfTrueNode(iff_jobj_null));
2919   result_rgn-&gt;init_req(_null_path, jobj_is_null);
2920   result_val-&gt;init_req(_null_path, null());
2921 
2922   Node* jobj_is_not_null = _gvn.transform(new IfFalseNode(iff_jobj_null));
2923   set_control(jobj_is_not_null);
2924   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
2925                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
2926   result_rgn-&gt;init_req(_normal_path, control());
2927   result_val-&gt;init_req(_normal_path, res);
2928 
2929   set_result(result_rgn, result_val);
2930 
2931   return true;
2932 }
2933 
2934 #endif // JFR_HAVE_INTRINSICS
2935 
2936 //------------------------inline_native_currentThread------------------
2937 bool LibraryCallKit::inline_native_currentThread() {
2938   Node* junk = NULL;
2939   set_result(generate_current_thread(junk));
2940   return true;
2941 }
2942 
2943 //------------------------inline_native_isInterrupted------------------
2944 // private native boolean java.lang.Thread.isInterrupted(boolean ClearInterrupted);
2945 bool LibraryCallKit::inline_native_isInterrupted() {
2946   // Add a fast path to t.isInterrupted(clear_int):
2947   //   (t == Thread.current() &amp;&amp;
2948   //    (!TLS._osthread._interrupted || WINDOWS_ONLY(false) NOT_WINDOWS(!clear_int)))
2949   //   ? TLS._osthread._interrupted : /*slow path:*/ t.isInterrupted(clear_int)
2950   // So, in the common case that the interrupt bit is false,
2951   // we avoid making a call into the VM.  Even if the interrupt bit
2952   // is true, if the clear_int argument is false, we avoid the VM call.
2953   // However, if the receiver is not currentThread, we must call the VM,
2954   // because there must be some locking done around the operation.
2955 
2956   // We only go to the fast case code if we pass two guards.
2957   // Paths which do not pass are accumulated in the slow_region.
2958 
2959   enum {
2960     no_int_result_path   = 1, // t == Thread.current() &amp;&amp; !TLS._osthread._interrupted
2961     no_clear_result_path = 2, // t == Thread.current() &amp;&amp;  TLS._osthread._interrupted &amp;&amp; !clear_int
2962     slow_result_path     = 3, // slow path: t.isInterrupted(clear_int)
2963     PATH_LIMIT
2964   };
2965 
2966   // Ensure that it&#39;s not possible to move the load of TLS._osthread._interrupted flag
2967   // out of the function.
2968   insert_mem_bar(Op_MemBarCPUOrder);
2969 
2970   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);
2971   PhiNode*    result_val = new PhiNode(result_rgn, TypeInt::BOOL);
2972 
2973   RegionNode* slow_region = new RegionNode(1);
2974   record_for_igvn(slow_region);
2975 
2976   // (a) Receiving thread must be the current thread.
2977   Node* rec_thr = argument(0);
2978   Node* tls_ptr = NULL;
2979   Node* cur_thr = generate_current_thread(tls_ptr);
2980 
2981   // Resolve oops to stable for CmpP below.
2982   cur_thr = access_resolve(cur_thr, 0);
2983   rec_thr = access_resolve(rec_thr, 0);
2984 
2985   Node* cmp_thr = _gvn.transform(new CmpPNode(cur_thr, rec_thr));
2986   Node* bol_thr = _gvn.transform(new BoolNode(cmp_thr, BoolTest::ne));
2987 
2988   generate_slow_guard(bol_thr, slow_region);
2989 
2990   // (b) Interrupt bit on TLS must be false.
2991   Node* p = basic_plus_adr(top()/*!oop*/, tls_ptr, in_bytes(JavaThread::osthread_offset()));
2992   Node* osthread = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
2993   p = basic_plus_adr(top()/*!oop*/, osthread, in_bytes(OSThread::interrupted_offset()));
2994 
2995   // Set the control input on the field _interrupted read to prevent it floating up.
2996   Node* int_bit = make_load(control(), p, TypeInt::BOOL, T_INT, MemNode::unordered);
2997   Node* cmp_bit = _gvn.transform(new CmpINode(int_bit, intcon(0)));
2998   Node* bol_bit = _gvn.transform(new BoolNode(cmp_bit, BoolTest::ne));
2999 
3000   IfNode* iff_bit = create_and_map_if(control(), bol_bit, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);
3001 
3002   // First fast path:  if (!TLS._interrupted) return false;
3003   Node* false_bit = _gvn.transform(new IfFalseNode(iff_bit));
3004   result_rgn-&gt;init_req(no_int_result_path, false_bit);
3005   result_val-&gt;init_req(no_int_result_path, intcon(0));
3006 
3007   // drop through to next case
3008   set_control( _gvn.transform(new IfTrueNode(iff_bit)));
3009 
3010 #ifndef _WINDOWS
3011   // (c) Or, if interrupt bit is set and clear_int is false, use 2nd fast path.
3012   Node* clr_arg = argument(1);
3013   Node* cmp_arg = _gvn.transform(new CmpINode(clr_arg, intcon(0)));
3014   Node* bol_arg = _gvn.transform(new BoolNode(cmp_arg, BoolTest::ne));
3015   IfNode* iff_arg = create_and_map_if(control(), bol_arg, PROB_FAIR, COUNT_UNKNOWN);
3016 
3017   // Second fast path:  ... else if (!clear_int) return true;
3018   Node* false_arg = _gvn.transform(new IfFalseNode(iff_arg));
3019   result_rgn-&gt;init_req(no_clear_result_path, false_arg);
3020   result_val-&gt;init_req(no_clear_result_path, intcon(1));
3021 
3022   // drop through to next case
3023   set_control( _gvn.transform(new IfTrueNode(iff_arg)));
3024 #else
3025   // To return true on Windows you must read the _interrupted field
3026   // and check the event state i.e. take the slow path.
3027 #endif // _WINDOWS
3028 
3029   // (d) Otherwise, go to the slow path.
3030   slow_region-&gt;add_req(control());
3031   set_control( _gvn.transform(slow_region));
3032 
3033   if (stopped()) {
3034     // There is no slow path.
3035     result_rgn-&gt;init_req(slow_result_path, top());
3036     result_val-&gt;init_req(slow_result_path, top());
3037   } else {
3038     // non-virtual because it is a private non-static
3039     CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_isInterrupted);
3040 
3041     Node* slow_val = set_results_for_java_call(slow_call);
3042     // this-&gt;control() comes from set_results_for_java_call
3043 
3044     Node* fast_io  = slow_call-&gt;in(TypeFunc::I_O);
3045     Node* fast_mem = slow_call-&gt;in(TypeFunc::Memory);
3046 
3047     // These two phis are pre-filled with copies of of the fast IO and Memory
3048     PhiNode* result_mem  = PhiNode::make(result_rgn, fast_mem, Type::MEMORY, TypePtr::BOTTOM);
3049     PhiNode* result_io   = PhiNode::make(result_rgn, fast_io,  Type::ABIO);
3050 
3051     result_rgn-&gt;init_req(slow_result_path, control());
3052     result_io -&gt;init_req(slow_result_path, i_o());
3053     result_mem-&gt;init_req(slow_result_path, reset_memory());
3054     result_val-&gt;init_req(slow_result_path, slow_val);
3055 
3056     set_all_memory(_gvn.transform(result_mem));
3057     set_i_o(       _gvn.transform(result_io));
3058   }
3059 
3060   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3061   set_result(result_rgn, result_val);
3062   return true;
3063 }
3064 
3065 //---------------------------load_mirror_from_klass----------------------------
3066 // Given a klass oop, load its java mirror (a java.lang.Class oop).
3067 Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
3068   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
3069   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3070   // mirror = ((OopHandle)mirror)-&gt;resolve();
3071   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);
3072 }
3073 
3074 //-----------------------load_klass_from_mirror_common-------------------------
3075 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3076 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3077 // and branch to the given path on the region.
3078 // If never_see_null, take an uncommon trap on null, so we can optimistically
3079 // compile for the non-null case.
3080 // If the region is NULL, force never_see_null = true.
3081 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3082                                                     bool never_see_null,
3083                                                     RegionNode* region,
3084                                                     int null_path,
3085                                                     int offset) {
3086   if (region == NULL)  never_see_null = true;
3087   Node* p = basic_plus_adr(mirror, offset);
3088   const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3089   Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));
3090   Node* null_ctl = top();
3091   kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3092   if (region != NULL) {
3093     // Set region-&gt;in(null_path) if the mirror is a primitive (e.g, int.class).
3094     region-&gt;init_req(null_path, null_ctl);
3095   } else {
3096     assert(null_ctl == top(), &quot;no loose ends&quot;);
3097   }
3098   return kls;
3099 }
3100 
3101 //--------------------(inline_native_Class_query helpers)---------------------
3102 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3103 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3104 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3105   // Branch around if the given klass has the given modifier bit set.
3106   // Like generate_guard, adds a new path onto the region.
3107   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3108   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3109   Node* mask = intcon(modifier_mask);
3110   Node* bits = intcon(modifier_bits);
3111   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3112   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3113   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3114   return generate_fair_guard(bol, region);
3115 }
3116 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3117   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3118 }
3119 
3120 //-------------------------inline_native_Class_query-------------------
3121 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3122   const Type* return_type = TypeInt::BOOL;
3123   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3124   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3125   bool expect_prim = false;     // most of these guys expect to work on refs
3126 
3127   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3128 
3129   Node* mirror = argument(0);
3130   Node* obj    = top();
3131 
3132   switch (id) {
3133   case vmIntrinsics::_isInstance:
3134     // nothing is an instance of a primitive type
3135     prim_return_value = intcon(0);
3136     obj = argument(1);
3137     break;
3138   case vmIntrinsics::_getModifiers:
3139     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3140     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3141     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3142     break;
3143   case vmIntrinsics::_isInterface:
3144     prim_return_value = intcon(0);
3145     break;
3146   case vmIntrinsics::_isArray:
3147     prim_return_value = intcon(0);
3148     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3149     break;
3150   case vmIntrinsics::_isPrimitive:
3151     prim_return_value = intcon(1);
3152     expect_prim = true;  // obviously
3153     break;
3154   case vmIntrinsics::_getSuperclass:
3155     prim_return_value = null();
3156     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3157     break;
3158   case vmIntrinsics::_getClassAccessFlags:
3159     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3160     return_type = TypeInt::INT;  // not bool!  6297094
3161     break;
3162   default:
3163     fatal_unexpected_iid(id);
3164     break;
3165   }
3166 
3167   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3168   if (mirror_con == NULL)  return false;  // cannot happen?
3169 
3170 #ifndef PRODUCT
3171   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3172     ciType* k = mirror_con-&gt;java_mirror_type();
3173     if (k) {
3174       tty-&gt;print(&quot;Inlining %s on constant Class &quot;, vmIntrinsics::name_at(intrinsic_id()));
3175       k-&gt;print_name();
3176       tty-&gt;cr();
3177     }
3178   }
3179 #endif
3180 
3181   // Null-check the mirror, and the mirror&#39;s klass ptr (in case it is a primitive).
3182   RegionNode* region = new RegionNode(PATH_LIMIT);
3183   record_for_igvn(region);
3184   PhiNode* phi = new PhiNode(region, return_type);
3185 
3186   // The mirror will never be null of Reflection.getClassAccessFlags, however
3187   // it may be null for Class.isInstance or Class.getModifiers. Throw a NPE
3188   // if it is. See bug 4774291.
3189 
3190   // For Reflection.getClassAccessFlags(), the null check occurs in
3191   // the wrong place; see inline_unsafe_access(), above, for a similar
3192   // situation.
3193   mirror = null_check(mirror);
3194   // If mirror or obj is dead, only null-path is taken.
3195   if (stopped())  return true;
3196 
3197   if (expect_prim)  never_see_null = false;  // expect nulls (meaning prims)
3198 
3199   // Now load the mirror&#39;s klass metaobject, and null-check it.
3200   // Side-effects region with the control path if the klass is null.
3201   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3202   // If kls is null, we have a primitive mirror.
3203   phi-&gt;init_req(_prim_path, prim_return_value);
3204   if (stopped()) { set_result(region, phi); return true; }
3205   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3206 
3207   Node* p;  // handy temp
3208   Node* null_ctl;
3209 
3210   // Now that we have the non-null klass, we can perform the real query.
3211   // For constant classes, the query will constant-fold in LoadNode::Value.
3212   Node* query_value = top();
3213   switch (id) {
3214   case vmIntrinsics::_isInstance:
3215     // nothing is an instance of a primitive type
3216     query_value = gen_instanceof(obj, kls, safe_for_replace);
3217     break;
3218 
3219   case vmIntrinsics::_getModifiers:
3220     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3221     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3222     break;
3223 
3224   case vmIntrinsics::_isInterface:
3225     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3226     if (generate_interface_guard(kls, region) != NULL)
3227       // A guard was added.  If the guard is taken, it was an interface.
3228       phi-&gt;add_req(intcon(1));
3229     // If we fall through, it&#39;s a plain class.
3230     query_value = intcon(0);
3231     break;
3232 
3233   case vmIntrinsics::_isArray:
3234     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3235     if (generate_array_guard(kls, region) != NULL)
3236       // A guard was added.  If the guard is taken, it was an array.
3237       phi-&gt;add_req(intcon(1));
3238     // If we fall through, it&#39;s a plain class.
3239     query_value = intcon(0);
3240     break;
3241 
3242   case vmIntrinsics::_isPrimitive:
3243     query_value = intcon(0); // &quot;normal&quot; path produces false
3244     break;
3245 
3246   case vmIntrinsics::_getSuperclass:
3247     // The rules here are somewhat unfortunate, but we can still do better
3248     // with random logic than with a JNI call.
3249     // Interfaces store null or Object as _super, but must report null.
3250     // Arrays store an intermediate super as _super, but must report Object.
3251     // Other types can report the actual _super.
3252     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3253     if (generate_interface_guard(kls, region) != NULL)
3254       // A guard was added.  If the guard is taken, it was an interface.
3255       phi-&gt;add_req(null());
3256     if (generate_array_guard(kls, region) != NULL)
3257       // A guard was added.  If the guard is taken, it was an array.
3258       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3259     // If we fall through, it&#39;s a plain class.  Get its _super.
3260     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3261     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3262     null_ctl = top();
3263     kls = null_check_oop(kls, &amp;null_ctl);
3264     if (null_ctl != top()) {
3265       // If the guard is taken, Object.superClass is null (both klass and mirror).
3266       region-&gt;add_req(null_ctl);
3267       phi   -&gt;add_req(null());
3268     }
3269     if (!stopped()) {
3270       query_value = load_mirror_from_klass(kls);
3271     }
3272     break;
3273 
3274   case vmIntrinsics::_getClassAccessFlags:
3275     p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3276     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3277     break;
3278 
3279   default:
3280     fatal_unexpected_iid(id);
3281     break;
3282   }
3283 
3284   // Fall-through is the normal case of a query to a real class.
3285   phi-&gt;init_req(1, query_value);
3286   region-&gt;init_req(1, control());
3287 
3288   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3289   set_result(region, phi);
3290   return true;
3291 }
3292 
3293 //-------------------------inline_Class_cast-------------------
3294 bool LibraryCallKit::inline_Class_cast() {
3295   Node* mirror = argument(0); // Class
3296   Node* obj    = argument(1);
3297   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3298   if (mirror_con == NULL) {
3299     return false;  // dead path (mirror-&gt;is_top()).
3300   }
3301   if (obj == NULL || obj-&gt;is_top()) {
3302     return false;  // dead path
3303   }
3304   const TypeOopPtr* tp = _gvn.type(obj)-&gt;isa_oopptr();
3305 
3306   // First, see if Class.cast() can be folded statically.
3307   // java_mirror_type() returns non-null for compile-time Class constants.
3308   ciType* tm = mirror_con-&gt;java_mirror_type();
3309   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp;
3310       tp != NULL &amp;&amp; tp-&gt;klass() != NULL) {
3311     if (!tp-&gt;klass()-&gt;is_loaded()) {
3312       // Don&#39;t use intrinsic when class is not loaded.
3313       return false;
3314     } else {
3315       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), tp-&gt;klass());
3316       if (static_res == Compile::SSC_always_true) {
3317         // isInstance() is true - fold the code.
3318         set_result(obj);
3319         return true;
3320       } else if (static_res == Compile::SSC_always_false) {
3321         // Don&#39;t use intrinsic, have to throw ClassCastException.
3322         // If the reference is null, the non-intrinsic bytecode will
3323         // be optimized appropriately.
3324         return false;
3325       }
3326     }
3327   }
3328 
3329   // Bailout intrinsic and do normal inlining if exception path is frequent.
3330   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
3331     return false;
3332   }
3333 
3334   // Generate dynamic checks.
3335   // Class.cast() is java implementation of _checkcast bytecode.
3336   // Do checkcast (Parse::do_checkcast()) optimizations here.
3337 
3338   mirror = null_check(mirror);
3339   // If mirror is dead, only null-path is taken.
3340   if (stopped()) {
3341     return true;
3342   }
3343 
3344   // Not-subtype or the mirror&#39;s klass ptr is NULL (in case it is a primitive).
3345   enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };
3346   RegionNode* region = new RegionNode(PATH_LIMIT);
3347   record_for_igvn(region);
3348 
3349   // Now load the mirror&#39;s klass metaobject, and null-check it.
3350   // If kls is null, we have a primitive mirror and
3351   // nothing is an instance of a primitive type.
3352   Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
3353 
3354   Node* res = top();
3355   if (!stopped()) {
3356     Node* bad_type_ctrl = top();
3357     // Do checkcast optimizations.
3358     res = gen_checkcast(obj, kls, &amp;bad_type_ctrl);
3359     region-&gt;init_req(_bad_type_path, bad_type_ctrl);
3360   }
3361   if (region-&gt;in(_prim_path) != top() ||
3362       region-&gt;in(_bad_type_path) != top()) {
3363     // Let Interpreter throw ClassCastException.
3364     PreserveJVMState pjvms(this);
3365     set_control(_gvn.transform(region));
3366     uncommon_trap(Deoptimization::Reason_intrinsic,
3367                   Deoptimization::Action_maybe_recompile);
3368   }
3369   if (!stopped()) {
3370     set_result(res);
3371   }
3372   return true;
3373 }
3374 
3375 
3376 //--------------------------inline_native_subtype_check------------------------
3377 // This intrinsic takes the JNI calls out of the heart of
3378 // UnsafeFieldAccessorImpl.set, which improves Field.set, readObject, etc.
3379 bool LibraryCallKit::inline_native_subtype_check() {
3380   // Pull both arguments off the stack.
3381   Node* args[2];                // two java.lang.Class mirrors: superc, subc
3382   args[0] = argument(0);
3383   args[1] = argument(1);
3384   Node* klasses[2];             // corresponding Klasses: superk, subk
3385   klasses[0] = klasses[1] = top();
3386 
3387   enum {
3388     // A full decision tree on {superc is prim, subc is prim}:
3389     _prim_0_path = 1,           // {P,N} =&gt; false
3390                                 // {P,P} &amp; superc!=subc =&gt; false
3391     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3392     _prim_1_path,               // {N,P} =&gt; false
3393     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3394     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3395     PATH_LIMIT
3396   };
3397 
3398   RegionNode* region = new RegionNode(PATH_LIMIT);
3399   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3400   record_for_igvn(region);
3401 
3402   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3403   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3404   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();
3405 
3406   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3407   int which_arg;
3408   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3409     Node* arg = args[which_arg];
3410     arg = null_check(arg);
3411     if (stopped())  break;
3412     args[which_arg] = arg;
3413 
3414     Node* p = basic_plus_adr(arg, class_klass_offset);
3415     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3416     klasses[which_arg] = _gvn.transform(kls);
3417   }
3418 
3419   // Resolve oops to stable for CmpP below.
3420   args[0] = access_resolve(args[0], 0);
3421   args[1] = access_resolve(args[1], 0);
3422 
3423   // Having loaded both klasses, test each for null.
3424   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3425   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3426     Node* kls = klasses[which_arg];
3427     Node* null_ctl = top();
3428     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3429     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);
3430     region-&gt;init_req(prim_path, null_ctl);
3431     if (stopped())  break;
3432     klasses[which_arg] = kls;
3433   }
3434 
3435   if (!stopped()) {
3436     // now we have two reference types, in klasses[0..1]
3437     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3438     Node* superk = klasses[0];  // the receiver
3439     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3440     // now we have a successful reference subtype check
3441     region-&gt;set_req(_ref_subtype_path, control());
3442   }
3443 
3444   // If both operands are primitive (both klasses null), then
3445   // we must return true when they are identical primitives.
3446   // It is convenient to test this after the first null klass check.
3447   set_control(region-&gt;in(_prim_0_path)); // go back to first null check
3448   if (!stopped()) {
3449     // Since superc is primitive, make a guard for the superc==subc case.
3450     Node* cmp_eq = _gvn.transform(new CmpPNode(args[0], args[1]));
3451     Node* bol_eq = _gvn.transform(new BoolNode(cmp_eq, BoolTest::eq));
3452     generate_guard(bol_eq, region, PROB_FAIR);
3453     if (region-&gt;req() == PATH_LIMIT+1) {
3454       // A guard was added.  If the added guard is taken, superc==subc.
3455       region-&gt;swap_edges(PATH_LIMIT, _prim_same_path);
3456       region-&gt;del_req(PATH_LIMIT);
3457     }
3458     region-&gt;set_req(_prim_0_path, control()); // Not equal after all.
3459   }
3460 
3461   // these are the only paths that produce &#39;true&#39;:
3462   phi-&gt;set_req(_prim_same_path,   intcon(1));
3463   phi-&gt;set_req(_ref_subtype_path, intcon(1));
3464 
3465   // pull together the cases:
3466   assert(region-&gt;req() == PATH_LIMIT, &quot;sane region&quot;);
3467   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3468     Node* ctl = region-&gt;in(i);
3469     if (ctl == NULL || ctl == top()) {
3470       region-&gt;set_req(i, top());
3471       phi   -&gt;set_req(i, top());
3472     } else if (phi-&gt;in(i) == NULL) {
3473       phi-&gt;set_req(i, intcon(0)); // all other paths produce &#39;false&#39;
3474     }
3475   }
3476 
3477   set_control(_gvn.transform(region));
3478   set_result(_gvn.transform(phi));
3479   return true;
3480 }
3481 
3482 //---------------------generate_array_guard_common------------------------
3483 Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,
3484                                                   bool obj_array, bool not_array) {
3485 
3486   if (stopped()) {
3487     return NULL;
3488   }
3489 
3490   // If obj_array/non_array==false/false:
3491   // Branch around if the given klass is in fact an array (either obj or prim).
3492   // If obj_array/non_array==false/true:
3493   // Branch around if the given klass is not an array klass of any kind.
3494   // If obj_array/non_array==true/true:
3495   // Branch around if the kls is not an oop array (kls is int[], String, etc.)
3496   // If obj_array/non_array==true/false:
3497   // Branch around if the kls is an oop array (Object[] or subtype)
3498   //
3499   // Like generate_guard, adds a new path onto the region.
3500   jint  layout_con = 0;
3501   Node* layout_val = get_layout_helper(kls, layout_con);
3502   if (layout_val == NULL) {
3503     bool query = (obj_array
3504                   ? Klass::layout_helper_is_objArray(layout_con)
3505                   : Klass::layout_helper_is_array(layout_con));
3506     if (query == not_array) {
3507       return NULL;                       // never a branch
3508     } else {                             // always a branch
3509       Node* always_branch = control();
3510       if (region != NULL)
3511         region-&gt;add_req(always_branch);
3512       set_control(top());
3513       return always_branch;
3514     }
3515   }
3516   // Now test the correct condition.
3517   jint  nval = (obj_array
3518                 ? (jint)(Klass::_lh_array_tag_type_value
3519                    &lt;&lt;    Klass::_lh_array_tag_shift)
3520                 : Klass::_lh_neutral_value);
3521   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
3522   BoolTest::mask btest = BoolTest::lt;  // correct for testing is_[obj]array
3523   // invert the test if we are looking for a non-array
3524   if (not_array)  btest = BoolTest(btest).negate();
3525   Node* bol = _gvn.transform(new BoolNode(cmp, btest));
3526   return generate_fair_guard(bol, region);
3527 }
3528 
3529 
3530 //-----------------------inline_native_newArray--------------------------
3531 // private static native Object java.lang.reflect.newArray(Class&lt;?&gt; componentType, int length);
3532 // private        native Object Unsafe.allocateUninitializedArray0(Class&lt;?&gt; cls, int size);
3533 bool LibraryCallKit::inline_unsafe_newArray(bool uninitialized) {
3534   Node* mirror;
3535   Node* count_val;
3536   if (uninitialized) {
3537     mirror    = argument(1);
3538     count_val = argument(2);
3539   } else {
3540     mirror    = argument(0);
3541     count_val = argument(1);
3542   }
3543 
3544   mirror = null_check(mirror);
3545   // If mirror or obj is dead, only null-path is taken.
3546   if (stopped())  return true;
3547 
3548   enum { _normal_path = 1, _slow_path = 2, PATH_LIMIT };
3549   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3550   PhiNode*    result_val = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
3551   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3552   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3553 
3554   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3555   Node* klass_node = load_array_klass_from_mirror(mirror, never_see_null,
3556                                                   result_reg, _slow_path);
3557   Node* normal_ctl   = control();
3558   Node* no_array_ctl = result_reg-&gt;in(_slow_path);
3559 
3560   // Generate code for the slow case.  We make a call to newArray().
3561   set_control(no_array_ctl);
3562   if (!stopped()) {
3563     // Either the input type is void.class, or else the
3564     // array klass has not yet been cached.  Either the
3565     // ensuing call will throw an exception, or else it
3566     // will cache the array klass for next time.
3567     PreserveJVMState pjvms(this);
3568     CallJavaNode* slow_call = generate_method_call_static(vmIntrinsics::_newArray);
3569     Node* slow_result = set_results_for_java_call(slow_call);
3570     // this-&gt;control() comes from set_results_for_java_call
3571     result_reg-&gt;set_req(_slow_path, control());
3572     result_val-&gt;set_req(_slow_path, slow_result);
3573     result_io -&gt;set_req(_slow_path, i_o());
3574     result_mem-&gt;set_req(_slow_path, reset_memory());
3575   }
3576 
3577   set_control(normal_ctl);
3578   if (!stopped()) {
3579     // Normal case:  The array type has been cached in the java.lang.Class.
3580     // The following call works fine even if the array type is polymorphic.
3581     // It could be a dynamic mix of int[], boolean[], Object[], etc.
3582     Node* obj = new_array(klass_node, count_val, 0);  // no arguments to push
3583     result_reg-&gt;init_req(_normal_path, control());
3584     result_val-&gt;init_req(_normal_path, obj);
3585     result_io -&gt;init_req(_normal_path, i_o());
3586     result_mem-&gt;init_req(_normal_path, reset_memory());
3587 
3588     if (uninitialized) {
3589       // Mark the allocation so that zeroing is skipped
3590       AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &amp;_gvn);
3591       alloc-&gt;maybe_set_complete(&amp;_gvn);
3592     }
3593   }
3594 
3595   // Return the combined state.
3596   set_i_o(        _gvn.transform(result_io)  );
3597   set_all_memory( _gvn.transform(result_mem));
3598 
3599   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3600   set_result(result_reg, result_val);
3601   return true;
3602 }
3603 
3604 //----------------------inline_native_getLength--------------------------
3605 // public static native int java.lang.reflect.Array.getLength(Object array);
3606 bool LibraryCallKit::inline_native_getLength() {
3607   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3608 
3609   Node* array = null_check(argument(0));
3610   // If array is dead, only null-path is taken.
3611   if (stopped())  return true;
3612 
3613   // Deoptimize if it is a non-array.
3614   Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);
3615 
3616   if (non_array != NULL) {
3617     PreserveJVMState pjvms(this);
3618     set_control(non_array);
3619     uncommon_trap(Deoptimization::Reason_intrinsic,
3620                   Deoptimization::Action_maybe_recompile);
3621   }
3622 
3623   // If control is dead, only non-array-path is taken.
3624   if (stopped())  return true;
3625 
3626   // The works fine even if the array type is polymorphic.
3627   // It could be a dynamic mix of int[], boolean[], Object[], etc.
3628   Node* result = load_array_length(array);
3629 
3630   C-&gt;set_has_split_ifs(true);  // Has chance for split-if optimization
3631   set_result(result);
3632   return true;
3633 }
3634 
3635 //------------------------inline_array_copyOf----------------------------
3636 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOf(     U[] original, int newLength,         Class&lt;? extends T[]&gt; newType);
3637 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOfRange(U[] original, int from,      int to, Class&lt;? extends T[]&gt; newType);
3638 bool LibraryCallKit::inline_array_copyOf(bool is_copyOfRange) {
3639   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3640 
3641   // Get the arguments.
3642   Node* original          = argument(0);
3643   Node* start             = is_copyOfRange? argument(1): intcon(0);
3644   Node* end               = is_copyOfRange? argument(2): argument(1);
3645   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
3646 
3647   Node* newcopy = NULL;
3648 
3649   // Set the original stack and the reexecute bit for the interpreter to reexecute
3650   // the bytecode that invokes Arrays.copyOf if deoptimization happens.
3651   { PreserveReexecuteState preexecs(this);
3652     jvms()-&gt;set_should_reexecute(true);
3653 
3654     array_type_mirror = null_check(array_type_mirror);
3655     original          = null_check(original);
3656 
3657     // Check if a null path was taken unconditionally.
3658     if (stopped())  return true;
3659 
3660     Node* orig_length = load_array_length(original);
3661 
3662     Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);
3663     klass_node = null_check(klass_node);
3664 
3665     RegionNode* bailout = new RegionNode(1);
3666     record_for_igvn(bailout);
3667 
3668     // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
3669     // Bail out if that is so.
3670     Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);
3671     if (not_objArray != NULL) {
3672       // Improve the klass node&#39;s type from the new optimistic assumption:
3673       ciKlass* ak = ciArrayKlass::make(env()-&gt;Object_klass());
3674       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0/*offset*/);
3675       Node* cast = new CastPPNode(klass_node, akls);
3676       cast-&gt;init_req(0, control());
3677       klass_node = _gvn.transform(cast);
3678     }
3679 
3680     // Bail out if either start or end is negative.
3681     generate_negative_guard(start, bailout, &amp;start);
3682     generate_negative_guard(end,   bailout, &amp;end);
3683 
3684     Node* length = end;
3685     if (_gvn.type(start) != TypeInt::ZERO) {
3686       length = _gvn.transform(new SubINode(end, start));
3687     }
3688 
3689     // Bail out if length is negative.
3690     // Without this the new_array would throw
3691     // NegativeArraySizeException but IllegalArgumentException is what
3692     // should be thrown
3693     generate_negative_guard(length, bailout, &amp;length);
3694 
3695     if (bailout-&gt;req() &gt; 1) {
3696       PreserveJVMState pjvms(this);
3697       set_control(_gvn.transform(bailout));
3698       uncommon_trap(Deoptimization::Reason_intrinsic,
3699                     Deoptimization::Action_maybe_recompile);
3700     }
3701 
3702     if (!stopped()) {
3703       // How many elements will we copy from the original?
3704       // The answer is MinI(orig_length - start, length).
3705       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3706       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3707 
3708       original = access_resolve(original, ACCESS_READ);
3709 
3710       // Generate a direct call to the right arraycopy function(s).
3711       // We know the copy is disjoint but we might not know if the
3712       // oop stores need checking.
3713       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
3714       // This will fail a store-check if x contains any non-nulls.
3715 
3716       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3717       // loads/stores but it is legal only if we&#39;re sure the
3718       // Arrays.copyOf would succeed. So we need all input arguments
3719       // to the copyOf to be validated, including that the copy to the
3720       // new array won&#39;t trigger an ArrayStoreException. That subtype
3721       // check can be optimized if we know something on the type of
3722       // the input array from type speculation.
3723       if (_gvn.type(klass_node)-&gt;singleton()) {
3724         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3725         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3726 
3727         int test = C-&gt;static_subtype_check(superk, subk);
3728         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3729           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3730           if (t_original-&gt;speculative_type() != NULL) {
3731             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3732           }
3733         }
3734       }
3735 
3736       bool validated = false;
3737       // Reason_class_check rather than Reason_intrinsic because we
3738       // want to intrinsify even if this traps.
3739       if (!too_many_traps(Deoptimization::Reason_class_check)) {
3740         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),
3741                                                    klass_node);
3742 
3743         if (not_subtype_ctrl != top()) {
3744           PreserveJVMState pjvms(this);
3745           set_control(not_subtype_ctrl);
3746           uncommon_trap(Deoptimization::Reason_class_check,
3747                         Deoptimization::Action_make_not_entrant);
3748           assert(stopped(), &quot;Should be stopped&quot;);
3749         }
3750         validated = true;
3751       }
3752 
3753       if (!stopped()) {
3754         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3755 
3756         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3757                                                 load_object_klass(original), klass_node);
3758         if (!is_copyOfRange) {
3759           ac-&gt;set_copyof(validated);
3760         } else {
3761           ac-&gt;set_copyofrange(validated);
3762         }
3763         Node* n = _gvn.transform(ac);
3764         if (n == ac) {
3765           ac-&gt;connect_outputs(this);
3766         } else {
3767           assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
3768           set_all_memory(n);
3769         }
3770       }
3771     }
3772   } // original reexecute is set back here
3773 
3774   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3775   if (!stopped()) {
3776     set_result(newcopy);
3777   }
3778   return true;
3779 }
3780 
3781 
3782 //----------------------generate_virtual_guard---------------------------
3783 // Helper for hashCode and clone.  Peeks inside the vtable to avoid a call.
3784 Node* LibraryCallKit::generate_virtual_guard(Node* obj_klass,
3785                                              RegionNode* slow_region) {
3786   ciMethod* method = callee();
3787   int vtable_index = method-&gt;vtable_index();
3788   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3789          &quot;bad index %d&quot;, vtable_index);
3790   // Get the Method* out of the appropriate vtable entry.
3791   int entry_offset  = in_bytes(Klass::vtable_start_offset()) +
3792                      vtable_index*vtableEntry::size_in_bytes() +
3793                      vtableEntry::method_offset_in_bytes();
3794   Node* entry_addr  = basic_plus_adr(obj_klass, entry_offset);
3795   Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3796 
3797   // Compare the target method with the expected method (e.g., Object.hashCode).
3798   const TypePtr* native_call_addr = TypeMetadataPtr::make(method);
3799 
3800   Node* native_call = makecon(native_call_addr);
3801   Node* chk_native  = _gvn.transform(new CmpPNode(target_call, native_call));
3802   Node* test_native = _gvn.transform(new BoolNode(chk_native, BoolTest::ne));
3803 
3804   return generate_slow_guard(test_native, slow_region);
3805 }
3806 
3807 //-----------------------generate_method_call----------------------------
3808 // Use generate_method_call to make a slow-call to the real
3809 // method if the fast path fails.  An alternative would be to
3810 // use a stub like OptoRuntime::slow_arraycopy_Java.
3811 // This only works for expanding the current library call,
3812 // not another intrinsic.  (E.g., don&#39;t use this for making an
3813 // arraycopy call inside of the copyOf intrinsic.)
3814 CallJavaNode*
3815 LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {
3816   // When compiling the intrinsic method itself, do not use this technique.
3817   guarantee(callee() != C-&gt;method(), &quot;cannot make slow-call to self&quot;);
3818 
3819   ciMethod* method = callee();
3820   // ensure the JVMS we have will be correct for this call
3821   guarantee(method_id == method-&gt;intrinsic_id(), &quot;must match&quot;);
3822 
3823   const TypeFunc* tf = TypeFunc::make(method);
3824   CallJavaNode* slow_call;
3825   if (is_static) {
3826     assert(!is_virtual, &quot;&quot;);
3827     slow_call = new CallStaticJavaNode(C, tf,
3828                            SharedRuntime::get_resolve_static_call_stub(),
3829                            method, bci());
3830   } else if (is_virtual) {
3831     null_check_receiver();
3832     int vtable_index = Method::invalid_vtable_index;
3833     if (UseInlineCaches) {
3834       // Suppress the vtable call
3835     } else {
3836       // hashCode and clone are not a miranda methods,
3837       // so the vtable index is fixed.
3838       // No need to use the linkResolver to get it.
3839        vtable_index = method-&gt;vtable_index();
3840        assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3841               &quot;bad index %d&quot;, vtable_index);
3842     }
3843     slow_call = new CallDynamicJavaNode(tf,
3844                           SharedRuntime::get_resolve_virtual_call_stub(),
3845                           method, vtable_index, bci());
3846   } else {  // neither virtual nor static:  opt_virtual
3847     null_check_receiver();
3848     slow_call = new CallStaticJavaNode(C, tf,
3849                                 SharedRuntime::get_resolve_opt_virtual_call_stub(),
3850                                 method, bci());
3851     slow_call-&gt;set_optimized_virtual(true);
3852   }
3853   if (CallGenerator::is_inlined_method_handle_intrinsic(this-&gt;method(), bci(), callee())) {
3854     // To be able to issue a direct call (optimized virtual or virtual)
3855     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
3856     // about the method being invoked should be attached to the call site to
3857     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
3858     slow_call-&gt;set_override_symbolic_info(true);
3859   }
3860   set_arguments_for_java_call(slow_call);
3861   set_edges_for_java_call(slow_call);
3862   return slow_call;
3863 }
3864 
3865 
3866 /**
3867  * Build special case code for calls to hashCode on an object. This call may
3868  * be virtual (invokevirtual) or bound (invokespecial). For each case we generate
3869  * slightly different code.
3870  */
3871 bool LibraryCallKit::inline_native_hashcode(bool is_virtual, bool is_static) {
3872   assert(is_static == callee()-&gt;is_static(), &quot;correct intrinsic selection&quot;);
3873   assert(!(is_virtual &amp;&amp; is_static), &quot;either virtual, special, or static&quot;);
3874 
3875   enum { _slow_path = 1, _fast_path, _null_path, PATH_LIMIT };
3876 
3877   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3878   PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
3879   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3880   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3881   Node* obj = NULL;
3882   if (!is_static) {
3883     // Check for hashing null object
3884     obj = null_check_receiver();
3885     if (stopped())  return true;        // unconditionally null
3886     result_reg-&gt;init_req(_null_path, top());
3887     result_val-&gt;init_req(_null_path, top());
3888   } else {
3889     // Do a null check, and return zero if null.
3890     // System.identityHashCode(null) == 0
3891     obj = argument(0);
3892     Node* null_ctl = top();
3893     obj = null_check_oop(obj, &amp;null_ctl);
3894     result_reg-&gt;init_req(_null_path, null_ctl);
3895     result_val-&gt;init_req(_null_path, _gvn.intcon(0));
3896   }
3897 
3898   // Unconditionally null?  Then return right away.
3899   if (stopped()) {
3900     set_control( result_reg-&gt;in(_null_path));
3901     if (!stopped())
3902       set_result(result_val-&gt;in(_null_path));
3903     return true;
3904   }
3905 
3906   // We only go to the fast case code if we pass a number of guards.  The
3907   // paths which do not pass are accumulated in the slow_region.
3908   RegionNode* slow_region = new RegionNode(1);
3909   record_for_igvn(slow_region);
3910 
3911   // If this is a virtual call, we generate a funny guard.  We pull out
3912   // the vtable entry corresponding to hashCode() from the target object.
3913   // If the target method which we are calling happens to be the native
3914   // Object hashCode() method, we pass the guard.  We do not need this
3915   // guard for non-virtual calls -- the caller is known to be the native
3916   // Object hashCode().
3917   if (is_virtual) {
3918     // After null check, get the object&#39;s klass.
3919     Node* obj_klass = load_object_klass(obj);
3920     generate_virtual_guard(obj_klass, slow_region);
3921   }
3922 
3923   // Get the header out of the object, use LoadMarkNode when available
3924   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3925   // The control of the load must be NULL. Otherwise, the load can move before
3926   // the null check after castPP removal.
3927   Node* no_ctrl = NULL;
3928   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3929 
3930   // Test the header to see if it is unlocked.
3931   Node *lock_mask      = _gvn.MakeConX(markOopDesc::biased_lock_mask_in_place);
3932   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
3933   Node *unlocked_val   = _gvn.MakeConX(markOopDesc::unlocked_value);
3934   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
3935   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
3936 
3937   generate_slow_guard(test_unlocked, slow_region);
3938 
3939   // Get the hash value and check to see that it has been properly assigned.
3940   // We depend on hash_mask being at most 32 bits and avoid the use of
3941   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
3942   // vm: see markOop.hpp.
3943   Node *hash_mask      = _gvn.intcon(markOopDesc::hash_mask);
3944   Node *hash_shift     = _gvn.intcon(markOopDesc::hash_shift);
3945   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
3946   // This hack lets the hash bits live anywhere in the mark object now, as long
3947   // as the shift drops the relevant bits into the low 32 bits.  Note that
3948   // Java spec says that HashCode is an int so there&#39;s no point in capturing
3949   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
3950   hshifted_header      = ConvX2I(hshifted_header);
3951   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
3952 
3953   Node *no_hash_val    = _gvn.intcon(markOopDesc::no_hash);
3954   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
3955   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
3956 
3957   generate_slow_guard(test_assigned, slow_region);
3958 
3959   Node* init_mem = reset_memory();
3960   // fill in the rest of the null path:
3961   result_io -&gt;init_req(_null_path, i_o());
3962   result_mem-&gt;init_req(_null_path, init_mem);
3963 
3964   result_val-&gt;init_req(_fast_path, hash_val);
3965   result_reg-&gt;init_req(_fast_path, control());
3966   result_io -&gt;init_req(_fast_path, i_o());
3967   result_mem-&gt;init_req(_fast_path, init_mem);
3968 
3969   // Generate code for the slow case.  We make a call to hashCode().
3970   set_control(_gvn.transform(slow_region));
3971   if (!stopped()) {
3972     // No need for PreserveJVMState, because we&#39;re using up the present state.
3973     set_all_memory(init_mem);
3974     vmIntrinsics::ID hashCode_id = is_static ? vmIntrinsics::_identityHashCode : vmIntrinsics::_hashCode;
3975     CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);
3976     Node* slow_result = set_results_for_java_call(slow_call);
3977     // this-&gt;control() comes from set_results_for_java_call
3978     result_reg-&gt;init_req(_slow_path, control());
3979     result_val-&gt;init_req(_slow_path, slow_result);
3980     result_io  -&gt;set_req(_slow_path, i_o());
3981     result_mem -&gt;set_req(_slow_path, reset_memory());
3982   }
3983 
3984   // Return the combined state.
3985   set_i_o(        _gvn.transform(result_io)  );
3986   set_all_memory( _gvn.transform(result_mem));
3987 
3988   set_result(result_reg, result_val);
3989   return true;
3990 }
3991 
3992 //---------------------------inline_native_getClass----------------------------
3993 // public final native Class&lt;?&gt; java.lang.Object.getClass();
3994 //
3995 // Build special case code for calls to getClass on an object.
3996 bool LibraryCallKit::inline_native_getClass() {
3997   Node* obj = null_check_receiver();
3998   if (stopped())  return true;
3999   set_result(load_mirror_from_klass(load_object_klass(obj)));
4000   return true;
4001 }
4002 
4003 //-----------------inline_native_Reflection_getCallerClass---------------------
4004 // public static native Class&lt;?&gt; sun.reflect.Reflection.getCallerClass();
4005 //
4006 // In the presence of deep enough inlining, getCallerClass() becomes a no-op.
4007 //
4008 // NOTE: This code must perform the same logic as JVM_GetCallerClass
4009 // in that it must skip particular security frames and checks for
4010 // caller sensitive methods.
4011 bool LibraryCallKit::inline_native_Reflection_getCallerClass() {
4012 #ifndef PRODUCT
4013   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4014     tty-&gt;print_cr(&quot;Attempting to inline sun.reflect.Reflection.getCallerClass&quot;);
4015   }
4016 #endif
4017 
4018   if (!jvms()-&gt;has_method()) {
4019 #ifndef PRODUCT
4020     if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4021       tty-&gt;print_cr(&quot;  Bailing out because intrinsic was inlined at top level&quot;);
4022     }
4023 #endif
4024     return false;
4025   }
4026 
4027   // Walk back up the JVM state to find the caller at the required
4028   // depth.
4029   JVMState* caller_jvms = jvms();
4030 
4031   // Cf. JVM_GetCallerClass
4032   // NOTE: Start the loop at depth 1 because the current JVM state does
4033   // not include the Reflection.getCallerClass() frame.
4034   for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms-&gt;caller(), n++) {
4035     ciMethod* m = caller_jvms-&gt;method();
4036     switch (n) {
4037     case 0:
4038       fatal(&quot;current JVM state does not include the Reflection.getCallerClass frame&quot;);
4039       break;
4040     case 1:
4041       // Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
4042       if (!m-&gt;caller_sensitive()) {
4043 #ifndef PRODUCT
4044         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4045           tty-&gt;print_cr(&quot;  Bailing out: CallerSensitive annotation expected at frame %d&quot;, n);
4046         }
4047 #endif
4048         return false;  // bail-out; let JVM_GetCallerClass do the work
4049       }
4050       break;
4051     default:
4052       if (!m-&gt;is_ignored_by_security_stack_walk()) {
4053         // We have reached the desired frame; return the holder class.
4054         // Acquire method holder as java.lang.Class and push as constant.
4055         ciInstanceKlass* caller_klass = caller_jvms-&gt;method()-&gt;holder();
4056         ciInstance* caller_mirror = caller_klass-&gt;java_mirror();
4057         set_result(makecon(TypeInstPtr::make(caller_mirror)));
4058 
4059 #ifndef PRODUCT
4060         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4061           tty-&gt;print_cr(&quot;  Succeeded: caller = %d) %s.%s, JVMS depth = %d&quot;, n, caller_klass-&gt;name()-&gt;as_utf8(), caller_jvms-&gt;method()-&gt;name()-&gt;as_utf8(), jvms()-&gt;depth());
4062           tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4063           for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4064             ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4065             tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4066           }
4067         }
4068 #endif
4069         return true;
4070       }
4071       break;
4072     }
4073   }
4074 
4075 #ifndef PRODUCT
4076   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4077     tty-&gt;print_cr(&quot;  Bailing out because caller depth exceeded inlining depth = %d&quot;, jvms()-&gt;depth());
4078     tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4079     for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4080       ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4081       tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4082     }
4083   }
4084 #endif
4085 
4086   return false;  // bail-out; let JVM_GetCallerClass do the work
4087 }
4088 
4089 bool LibraryCallKit::inline_fp_conversions(vmIntrinsics::ID id) {
4090   Node* arg = argument(0);
4091   Node* result = NULL;
4092 
4093   switch (id) {
4094   case vmIntrinsics::_floatToRawIntBits:    result = new MoveF2INode(arg);  break;
4095   case vmIntrinsics::_intBitsToFloat:       result = new MoveI2FNode(arg);  break;
4096   case vmIntrinsics::_doubleToRawLongBits:  result = new MoveD2LNode(arg);  break;
4097   case vmIntrinsics::_longBitsToDouble:     result = new MoveL2DNode(arg);  break;
4098 
4099   case vmIntrinsics::_doubleToLongBits: {
4100     // two paths (plus control) merge in a wood
4101     RegionNode *r = new RegionNode(3);
4102     Node *phi = new PhiNode(r, TypeLong::LONG);
4103 
4104     Node *cmpisnan = _gvn.transform(new CmpDNode(arg, arg));
4105     // Build the boolean node
4106     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4107 
4108     // Branch either way.
4109     // NaN case is less traveled, which makes all the difference.
4110     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4111     Node *opt_isnan = _gvn.transform(ifisnan);
4112     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4113     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4114     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4115 
4116     set_control(iftrue);
4117 
4118     static const jlong nan_bits = CONST64(0x7ff8000000000000);
4119     Node *slow_result = longcon(nan_bits); // return NaN
4120     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4121     r-&gt;init_req(1, iftrue);
4122 
4123     // Else fall through
4124     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4125     set_control(iffalse);
4126 
4127     phi-&gt;init_req(2, _gvn.transform(new MoveD2LNode(arg)));
4128     r-&gt;init_req(2, iffalse);
4129 
4130     // Post merge
4131     set_control(_gvn.transform(r));
4132     record_for_igvn(r);
4133 
4134     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4135     result = phi;
4136     assert(result-&gt;bottom_type()-&gt;isa_long(), &quot;must be&quot;);
4137     break;
4138   }
4139 
4140   case vmIntrinsics::_floatToIntBits: {
4141     // two paths (plus control) merge in a wood
4142     RegionNode *r = new RegionNode(3);
4143     Node *phi = new PhiNode(r, TypeInt::INT);
4144 
4145     Node *cmpisnan = _gvn.transform(new CmpFNode(arg, arg));
4146     // Build the boolean node
4147     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4148 
4149     // Branch either way.
4150     // NaN case is less traveled, which makes all the difference.
4151     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4152     Node *opt_isnan = _gvn.transform(ifisnan);
4153     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4154     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4155     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4156 
4157     set_control(iftrue);
4158 
4159     static const jint nan_bits = 0x7fc00000;
4160     Node *slow_result = makecon(TypeInt::make(nan_bits)); // return NaN
4161     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4162     r-&gt;init_req(1, iftrue);
4163 
4164     // Else fall through
4165     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4166     set_control(iffalse);
4167 
4168     phi-&gt;init_req(2, _gvn.transform(new MoveF2INode(arg)));
4169     r-&gt;init_req(2, iffalse);
4170 
4171     // Post merge
4172     set_control(_gvn.transform(r));
4173     record_for_igvn(r);
4174 
4175     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4176     result = phi;
4177     assert(result-&gt;bottom_type()-&gt;isa_int(), &quot;must be&quot;);
4178     break;
4179   }
4180 
4181   default:
4182     fatal_unexpected_iid(id);
4183     break;
4184   }
4185   set_result(_gvn.transform(result));
4186   return true;
4187 }
4188 
4189 //----------------------inline_unsafe_copyMemory-------------------------
4190 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4191 bool LibraryCallKit::inline_unsafe_copyMemory() {
4192   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4193   null_check_receiver();  // null-check receiver
4194   if (stopped())  return true;
4195 
4196   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4197 
4198   Node* src_ptr =         argument(1);   // type: oop
4199   Node* src_off = ConvL2X(argument(2));  // type: long
4200   Node* dst_ptr =         argument(4);   // type: oop
4201   Node* dst_off = ConvL2X(argument(5));  // type: long
4202   Node* size    = ConvL2X(argument(7));  // type: long
4203 
4204   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4205          &quot;fieldOffset must be byte-scaled&quot;);
4206 
4207   src_ptr = access_resolve(src_ptr, ACCESS_READ);
4208   dst_ptr = access_resolve(dst_ptr, ACCESS_WRITE);
4209   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4210   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4211 
4212   // Conservatively insert a memory barrier on all memory slices.
4213   // Do not let writes of the copy source or destination float below the copy.
4214   insert_mem_bar(Op_MemBarCPUOrder);
4215 
4216   // Call it.  Note that the length argument is not scaled.
4217   make_runtime_call(RC_LEAF|RC_NO_FP,
4218                     OptoRuntime::fast_arraycopy_Type(),
4219                     StubRoutines::unsafe_arraycopy(),
4220                     &quot;unsafe_arraycopy&quot;,
4221                     TypeRawPtr::BOTTOM,
4222                     src, dst, size XTOP);
4223 
4224   // Do not let reads of the copy destination float above the copy.
4225   insert_mem_bar(Op_MemBarCPUOrder);
4226 
4227   return true;
4228 }
4229 
4230 //------------------------clone_coping-----------------------------------
4231 // Helper function for inline_native_clone.
4232 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4233   assert(obj_size != NULL, &quot;&quot;);
4234   Node* raw_obj = alloc_obj-&gt;in(1);
4235   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4236 
4237   AllocateNode* alloc = NULL;
4238   if (ReduceBulkZeroing) {
4239     // We will be completely responsible for initializing this object -
4240     // mark Initialize node as complete.
4241     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4242     // The object was just allocated - there should be no any stores!
4243     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4244     // Mark as complete_with_arraycopy so that on AllocateNode
4245     // expansion, we know this AllocateNode is initialized by an array
4246     // copy and a StoreStore barrier exists after the array copy.
4247     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4248   }
4249 
4250   // Copy the fastest available way.
4251   // TODO: generate fields copies for small objects instead.
4252   Node* size = _gvn.transform(obj_size);
4253 
4254   access_clone(obj, alloc_obj, size, is_array);
4255 
4256   // Do not let reads from the cloned object float above the arraycopy.
4257   if (alloc != NULL) {
4258     // Do not let stores that initialize this object be reordered with
4259     // a subsequent store that would make this object accessible by
4260     // other threads.
4261     // Record what AllocateNode this StoreStore protects so that
4262     // escape analysis can go from the MemBarStoreStoreNode to the
4263     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4264     // based on the escape status of the AllocateNode.
4265     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4266   } else {
4267     insert_mem_bar(Op_MemBarCPUOrder);
4268   }
4269 }
4270 
4271 //------------------------inline_native_clone----------------------------
4272 // protected native Object java.lang.Object.clone();
4273 //
4274 // Here are the simple edge cases:
4275 //  null receiver =&gt; normal trap
4276 //  virtual and clone was overridden =&gt; slow path to out-of-line clone
4277 //  not cloneable or finalizer =&gt; slow path to out-of-line Object.clone
4278 //
4279 // The general case has two steps, allocation and copying.
4280 // Allocation has two cases, and uses GraphKit::new_instance or new_array.
4281 //
4282 // Copying also has two cases, oop arrays and everything else.
4283 // Oop arrays use arrayof_oop_arraycopy (same as System.arraycopy).
4284 // Everything else uses the tight inline loop supplied by CopyArrayNode.
4285 //
4286 // These steps fold up nicely if and when the cloned object&#39;s klass
4287 // can be sharply typed as an object array, a type array, or an instance.
4288 //
4289 bool LibraryCallKit::inline_native_clone(bool is_virtual) {
4290   PhiNode* result_val;
4291 
4292   // Set the reexecute bit for the interpreter to reexecute
4293   // the bytecode that invokes Object.clone if deoptimization happens.
4294   { PreserveReexecuteState preexecs(this);
4295     jvms()-&gt;set_should_reexecute(true);
4296 
4297     Node* obj = null_check_receiver();
4298     if (stopped())  return true;
4299 
4300     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4301 
4302     // If we are going to clone an instance, we need its exact type to
4303     // know the number and types of fields to convert the clone to
4304     // loads/stores. Maybe a speculative type can help us.
4305     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4306         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4307         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {
4308       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4309       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4310           !spec_ik-&gt;has_injected_fields()) {
4311         ciKlass* k = obj_type-&gt;klass();
4312         if (!k-&gt;is_instance_klass() ||
4313             k-&gt;as_instance_klass()-&gt;is_interface() ||
4314             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4315           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4316         }
4317       }
4318     }
4319 
4320     Node* obj_klass = load_object_klass(obj);
4321     const TypeKlassPtr* tklass = _gvn.type(obj_klass)-&gt;isa_klassptr();
4322     const TypeOopPtr*   toop   = ((tklass != NULL)
4323                                 ? tklass-&gt;as_instance_type()
4324                                 : TypeInstPtr::NOTNULL);
4325 
4326     // Conservatively insert a memory barrier on all memory slices.
4327     // Do not let writes into the original float below the clone.
4328     insert_mem_bar(Op_MemBarCPUOrder);
4329 
4330     // paths into result_reg:
4331     enum {
4332       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4333       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4334       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4335       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4336       PATH_LIMIT
4337     };
4338     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4339     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4340     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4341     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4342     record_for_igvn(result_reg);
4343 
4344     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4345     if (array_ctl != NULL) {
4346       // It&#39;s an array.
4347       PreserveJVMState pjvms(this);
4348       set_control(array_ctl);
4349       Node* obj_length = load_array_length(obj);
4350       Node* obj_size  = NULL;
4351       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size);  // no arguments to push
4352 
4353       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4354       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4355         // If it is an oop array, it requires very special treatment,
4356         // because gc barriers are required when accessing the array.
4357         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4358         if (is_obja != NULL) {
4359           PreserveJVMState pjvms2(this);
4360           set_control(is_obja);
4361           obj = access_resolve(obj, ACCESS_READ);
4362           // Generate a direct call to the right arraycopy function(s).
4363           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4364           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
4365           ac-&gt;set_cloneoop();
4366           Node* n = _gvn.transform(ac);
4367           assert(n == ac, &quot;cannot disappear&quot;);
4368           ac-&gt;connect_outputs(this);
4369 
4370           result_reg-&gt;init_req(_objArray_path, control());
4371           result_val-&gt;init_req(_objArray_path, alloc_obj);
4372           result_i_o -&gt;set_req(_objArray_path, i_o());
4373           result_mem -&gt;set_req(_objArray_path, reset_memory());
4374         }
4375       }
4376       // Otherwise, there are no barriers to worry about.
4377       // (We can dispense with card marks if we know the allocation
4378       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4379       //  causes the non-eden paths to take compensating steps to
4380       //  simulate a fresh allocation, so that no further
4381       //  card marks are required in compiled code to initialize
4382       //  the object.)
4383 
4384       if (!stopped()) {
4385         copy_to_clone(obj, alloc_obj, obj_size, true);
4386 
4387         // Present the results of the copy.
4388         result_reg-&gt;init_req(_array_path, control());
4389         result_val-&gt;init_req(_array_path, alloc_obj);
4390         result_i_o -&gt;set_req(_array_path, i_o());
4391         result_mem -&gt;set_req(_array_path, reset_memory());
4392       }
4393     }
4394 
4395     // We only go to the instance fast case code if we pass a number of guards.
4396     // The paths which do not pass are accumulated in the slow_region.
4397     RegionNode* slow_region = new RegionNode(1);
4398     record_for_igvn(slow_region);
4399     if (!stopped()) {
4400       // It&#39;s an instance (we did array above).  Make the slow-path tests.
4401       // If this is a virtual call, we generate a funny guard.  We grab
4402       // the vtable entry corresponding to clone() from the target object.
4403       // If the target method which we are calling happens to be the
4404       // Object clone() method, we pass the guard.  We do not need this
4405       // guard for non-virtual calls; the caller is known to be the native
4406       // Object clone().
4407       if (is_virtual) {
4408         generate_virtual_guard(obj_klass, slow_region);
4409       }
4410 
4411       // The object must be easily cloneable and must not have a finalizer.
4412       // Both of these conditions may be checked in a single test.
4413       // We could optimize the test further, but we don&#39;t care.
4414       generate_access_flags_guard(obj_klass,
4415                                   // Test both conditions:
4416                                   JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,
4417                                   // Must be cloneable but not finalizer:
4418                                   JVM_ACC_IS_CLONEABLE_FAST,
4419                                   slow_region);
4420     }
4421 
4422     if (!stopped()) {
4423       // It&#39;s an instance, and it passed the slow-path tests.
4424       PreserveJVMState pjvms(this);
4425       Node* obj_size  = NULL;
4426       // Need to deoptimize on exception from allocation since Object.clone intrinsic
4427       // is reexecuted if deoptimization occurs and there could be problems when merging
4428       // exception state between multiple Object.clone versions (reexecute=true vs reexecute=false).
4429       Node* alloc_obj = new_instance(obj_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
4430 
4431       copy_to_clone(obj, alloc_obj, obj_size, false);
4432 
4433       // Present the results of the slow call.
4434       result_reg-&gt;init_req(_instance_path, control());
4435       result_val-&gt;init_req(_instance_path, alloc_obj);
4436       result_i_o -&gt;set_req(_instance_path, i_o());
4437       result_mem -&gt;set_req(_instance_path, reset_memory());
4438     }
4439 
4440     // Generate code for the slow case.  We make a call to clone().
4441     set_control(_gvn.transform(slow_region));
4442     if (!stopped()) {
4443       PreserveJVMState pjvms(this);
4444       CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);
4445       // We need to deoptimize on exception (see comment above)
4446       Node* slow_result = set_results_for_java_call(slow_call, false, /* deoptimize */ true);
4447       // this-&gt;control() comes from set_results_for_java_call
4448       result_reg-&gt;init_req(_slow_path, control());
4449       result_val-&gt;init_req(_slow_path, slow_result);
4450       result_i_o -&gt;set_req(_slow_path, i_o());
4451       result_mem -&gt;set_req(_slow_path, reset_memory());
4452     }
4453 
4454     // Return the combined state.
4455     set_control(    _gvn.transform(result_reg));
4456     set_i_o(        _gvn.transform(result_i_o));
4457     set_all_memory( _gvn.transform(result_mem));
4458   } // original reexecute is set back here
4459 
4460   set_result(_gvn.transform(result_val));
4461   return true;
4462 }
4463 
4464 // If we have a tightly coupled allocation, the arraycopy may take care
4465 // of the array initialization. If one of the guards we insert between
4466 // the allocation and the arraycopy causes a deoptimization, an
4467 // unitialized array will escape the compiled method. To prevent that
4468 // we set the JVM state for uncommon traps between the allocation and
4469 // the arraycopy to the state before the allocation so, in case of
4470 // deoptimization, we&#39;ll reexecute the allocation and the
4471 // initialization.
4472 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4473   if (alloc != NULL) {
4474     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4475     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4476 
4477     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;
4478           !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {
4479       // Make sure there&#39;s no store between the allocation and the
4480       // arraycopy otherwise visible side effects could be rexecuted
4481       // in case of deoptimization and cause incorrect execution.
4482       bool no_interfering_store = true;
4483       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4484       if (mem-&gt;is_MergeMem()) {
4485         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4486           Node* n = mms.memory();
4487           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4488             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);
4489             no_interfering_store = false;
4490             break;
4491           }
4492         }
4493       } else {
4494         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4495           Node* n = mms.memory();
4496           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4497             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);
4498             no_interfering_store = false;
4499             break;
4500           }
4501         }
4502       }
4503 
4504       if (no_interfering_store) {
4505         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4506         uint size = alloc-&gt;req();
4507         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4508         old_jvms-&gt;set_map(sfpt);
4509         for (uint i = 0; i &lt; size; i++) {
4510           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4511         }
4512         // re-push array length for deoptimization
4513         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4514         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4515         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4516         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4517         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
4518         old_jvms-&gt;set_should_reexecute(true);
4519 
4520         sfpt-&gt;set_i_o(map()-&gt;i_o());
4521         sfpt-&gt;set_memory(map()-&gt;memory());
4522         sfpt-&gt;set_control(map()-&gt;control());
4523 
4524         JVMState* saved_jvms = jvms();
4525         saved_reexecute_sp = _reexecute_sp;
4526 
4527         set_jvms(sfpt-&gt;jvms());
4528         _reexecute_sp = jvms()-&gt;sp();
4529 
4530         return saved_jvms;
4531       }
4532     }
4533   }
4534   return NULL;
4535 }
4536 
4537 // In case of a deoptimization, we restart execution at the
4538 // allocation, allocating a new array. We would leave an uninitialized
4539 // array in the heap that GCs wouldn&#39;t expect. Move the allocation
4540 // after the traps so we don&#39;t allocate the array if we
4541 // deoptimize. This is possible because tightly_coupled_allocation()
4542 // guarantees there&#39;s no observer of the allocated array at this point
4543 // and the control flow is simple enough.
4544 void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,
4545                                                     int saved_reexecute_sp, uint new_idx) {
4546   if (saved_jvms != NULL &amp;&amp; !stopped()) {
4547     assert(alloc != NULL, &quot;only with a tightly coupled allocation&quot;);
4548     // restore JVM state to the state at the arraycopy
4549     saved_jvms-&gt;map()-&gt;set_control(map()-&gt;control());
4550     assert(saved_jvms-&gt;map()-&gt;memory() == map()-&gt;memory(), &quot;memory state changed?&quot;);
4551     assert(saved_jvms-&gt;map()-&gt;i_o() == map()-&gt;i_o(), &quot;IO state changed?&quot;);
4552     // If we&#39;ve improved the types of some nodes (null check) while
4553     // emitting the guards, propagate them to the current state
4554     map()-&gt;replaced_nodes().apply(saved_jvms-&gt;map(), new_idx);
4555     set_jvms(saved_jvms);
4556     _reexecute_sp = saved_reexecute_sp;
4557 
4558     // Remove the allocation from above the guards
4559     CallProjections callprojs;
4560     alloc-&gt;extract_projections(&amp;callprojs, true);
4561     InitializeNode* init = alloc-&gt;initialization();
4562     Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
4563     C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));
4564     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Memory), alloc_mem);
4565     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Control), alloc-&gt;in(0));
4566 
4567     // move the allocation here (after the guards)
4568     _gvn.hash_delete(alloc);
4569     alloc-&gt;set_req(TypeFunc::Control, control());
4570     alloc-&gt;set_req(TypeFunc::I_O, i_o());
4571     Node *mem = reset_memory();
4572     set_all_memory(mem);
4573     alloc-&gt;set_req(TypeFunc::Memory, mem);
4574     set_control(init-&gt;proj_out_or_null(TypeFunc::Control));
4575     set_i_o(callprojs.fallthrough_ioproj);
4576 
4577     // Update memory as done in GraphKit::set_output_for_allocation()
4578     const TypeInt* length_type = _gvn.find_int_type(alloc-&gt;in(AllocateNode::ALength));
4579     const TypeOopPtr* ary_type = _gvn.type(alloc-&gt;in(AllocateNode::KlassNode))-&gt;is_klassptr()-&gt;as_instance_type();
4580     if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4581       ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4582     }
4583     const TypePtr* telemref = ary_type-&gt;add_offset(Type::OffsetBot);
4584     int            elemidx  = C-&gt;get_alias_index(telemref);
4585     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);
4586     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), elemidx);
4587 
4588     Node* allocx = _gvn.transform(alloc);
4589     assert(allocx == alloc, &quot;where has the allocation gone?&quot;);
4590     assert(dest-&gt;is_CheckCastPP(), &quot;not an allocation result?&quot;);
4591 
4592     _gvn.hash_delete(dest);
4593     dest-&gt;set_req(0, control());
4594     Node* destx = _gvn.transform(dest);
4595     assert(destx == dest, &quot;where has the allocation result gone?&quot;);
4596   }
4597 }
4598 
4599 
4600 //------------------------------inline_arraycopy-----------------------
4601 // public static native void java.lang.System.arraycopy(Object src,  int  srcPos,
4602 //                                                      Object dest, int destPos,
4603 //                                                      int length);
4604 bool LibraryCallKit::inline_arraycopy() {
4605   // Get the arguments.
4606   Node* src         = argument(0);  // type: oop
4607   Node* src_offset  = argument(1);  // type: int
4608   Node* dest        = argument(2);  // type: oop
4609   Node* dest_offset = argument(3);  // type: int
4610   Node* length      = argument(4);  // type: int
4611 
4612   uint new_idx = C-&gt;unique();
4613 
4614   // Check for allocation before we add nodes that would confuse
4615   // tightly_coupled_allocation()
4616   AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);
4617 
4618   int saved_reexecute_sp = -1;
4619   JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);
4620   // See arraycopy_restore_alloc_state() comment
4621   // if alloc == NULL we don&#39;t have to worry about a tightly coupled allocation so we can emit all needed guards
4622   // if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation
4623   // if saved_jvms == NULL and alloc != NULL, we can&#39;t emit any guards
4624   bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);
4625 
4626   // The following tests must be performed
4627   // (1) src and dest are arrays.
4628   // (2) src and dest arrays must have elements of the same BasicType
4629   // (3) src and dest must not be null.
4630   // (4) src_offset must not be negative.
4631   // (5) dest_offset must not be negative.
4632   // (6) length must not be negative.
4633   // (7) src_offset + length must not exceed length of src.
4634   // (8) dest_offset + length must not exceed length of dest.
4635   // (9) each element of an oop array must be assignable
4636 
4637   // (3) src and dest must not be null.
4638   // always do this here because we need the JVM state for uncommon traps
4639   Node* null_ctl = top();
4640   src  = saved_jvms != NULL ? null_check_oop(src, &amp;null_ctl, true, true) : null_check(src,  T_ARRAY);
4641   assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
4642   dest = null_check(dest, T_ARRAY);
4643 
4644   if (!can_emit_guards) {
4645     // if saved_jvms == NULL and alloc != NULL, we don&#39;t emit any
4646     // guards but the arraycopy node could still take advantage of a
4647     // tightly allocated allocation. tightly_coupled_allocation() is
4648     // called again to make sure it takes the null check above into
4649     // account: the null check is mandatory and if it caused an
4650     // uncommon trap to be emitted then the allocation can&#39;t be
4651     // considered tightly coupled in this context.
4652     alloc = tightly_coupled_allocation(dest, NULL);
4653   }
4654 
4655   bool validated = false;
4656 
4657   const Type* src_type  = _gvn.type(src);
4658   const Type* dest_type = _gvn.type(dest);
4659   const TypeAryPtr* top_src  = src_type-&gt;isa_aryptr();
4660   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
4661 
4662   // Do we have the type of src?
4663   bool has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4664   // Do we have the type of dest?
4665   bool has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4666   // Is the type for src from speculation?
4667   bool src_spec = false;
4668   // Is the type for dest from speculation?
4669   bool dest_spec = false;
4670 
4671   if ((!has_src || !has_dest) &amp;&amp; can_emit_guards) {
4672     // We don&#39;t have sufficient type information, let&#39;s see if
4673     // speculative types can help. We need to have types for both src
4674     // and dest so that it pays off.
4675 
4676     // Do we already have or could we have type information for src
4677     bool could_have_src = has_src;
4678     // Do we already have or could we have type information for dest
4679     bool could_have_dest = has_dest;
4680 
4681     ciKlass* src_k = NULL;
4682     if (!has_src) {
4683       src_k = src_type-&gt;speculative_type_not_null();
4684       if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4685         could_have_src = true;
4686       }
4687     }
4688 
4689     ciKlass* dest_k = NULL;
4690     if (!has_dest) {
4691       dest_k = dest_type-&gt;speculative_type_not_null();
4692       if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4693         could_have_dest = true;
4694       }
4695     }
4696 
4697     if (could_have_src &amp;&amp; could_have_dest) {
4698       // This is going to pay off so emit the required guards
4699       if (!has_src) {
4700         src = maybe_cast_profiled_obj(src, src_k, true);
4701         src_type  = _gvn.type(src);
4702         top_src  = src_type-&gt;isa_aryptr();
4703         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4704         src_spec = true;
4705       }
4706       if (!has_dest) {
4707         dest = maybe_cast_profiled_obj(dest, dest_k, true);
4708         dest_type  = _gvn.type(dest);
4709         top_dest  = dest_type-&gt;isa_aryptr();
4710         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4711         dest_spec = true;
4712       }
4713     }
4714   }
4715 
4716   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
4717     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4718     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4719     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;
4720     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;
4721 
4722     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
4723       // If both arrays are object arrays then having the exact types
4724       // for both will remove the need for a subtype check at runtime
4725       // before the call and may make it possible to pick a faster copy
4726       // routine (without a subtype check on every element)
4727       // Do we have the exact type of src?
4728       bool could_have_src = src_spec;
4729       // Do we have the exact type of dest?
4730       bool could_have_dest = dest_spec;
4731       ciKlass* src_k = top_src-&gt;klass();
4732       ciKlass* dest_k = top_dest-&gt;klass();
4733       if (!src_spec) {
4734         src_k = src_type-&gt;speculative_type_not_null();
4735         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4736           could_have_src = true;
4737         }
4738       }
4739       if (!dest_spec) {
4740         dest_k = dest_type-&gt;speculative_type_not_null();
4741         if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4742           could_have_dest = true;
4743         }
4744       }
4745       if (could_have_src &amp;&amp; could_have_dest) {
4746         // If we can have both exact types, emit the missing guards
4747         if (could_have_src &amp;&amp; !src_spec) {
4748           src = maybe_cast_profiled_obj(src, src_k, true);
4749         }
4750         if (could_have_dest &amp;&amp; !dest_spec) {
4751           dest = maybe_cast_profiled_obj(dest, dest_k, true);
4752         }
4753       }
4754     }
4755   }
4756 
4757   ciMethod* trap_method = method();
4758   int trap_bci = bci();
4759   if (saved_jvms != NULL) {
4760     trap_method = alloc-&gt;jvms()-&gt;method();
4761     trap_bci = alloc-&gt;jvms()-&gt;bci();
4762   }
4763 
4764   bool negative_length_guard_generated = false;
4765 
4766   if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4767       can_emit_guards &amp;&amp;
4768       !src-&gt;is_top() &amp;&amp; !dest-&gt;is_top()) {
4769     // validate arguments: enables transformation the ArrayCopyNode
4770     validated = true;
4771 
4772     RegionNode* slow_region = new RegionNode(1);
4773     record_for_igvn(slow_region);
4774 
4775     // (1) src and dest are arrays.
4776     generate_non_array_guard(load_object_klass(src), slow_region);
4777     generate_non_array_guard(load_object_klass(dest), slow_region);
4778 
4779     // (2) src and dest arrays must have elements of the same BasicType
4780     // done at macro expansion or at Ideal transformation time
4781 
4782     // (4) src_offset must not be negative.
4783     generate_negative_guard(src_offset, slow_region);
4784 
4785     // (5) dest_offset must not be negative.
4786     generate_negative_guard(dest_offset, slow_region);
4787 
4788     // (7) src_offset + length must not exceed length of src.
4789     generate_limit_guard(src_offset, length,
4790                          load_array_length(src),
4791                          slow_region);
4792 
4793     // (8) dest_offset + length must not exceed length of dest.
4794     generate_limit_guard(dest_offset, length,
4795                          load_array_length(dest),
4796                          slow_region);
4797 
4798     // (6) length must not be negative.
4799     // This is also checked in generate_arraycopy() during macro expansion, but
4800     // we also have to check it here for the case where the ArrayCopyNode will
4801     // be eliminated by Escape Analysis.
4802     if (EliminateAllocations) {
4803       generate_negative_guard(length, slow_region);
4804       negative_length_guard_generated = true;
4805     }
4806 
4807     // (9) each element of an oop array must be assignable
4808     Node* src_klass  = load_object_klass(src);
4809     Node* dest_klass = load_object_klass(dest);
4810     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);
4811 
4812     if (not_subtype_ctrl != top()) {
4813       PreserveJVMState pjvms(this);
4814       set_control(not_subtype_ctrl);
4815       uncommon_trap(Deoptimization::Reason_intrinsic,
4816                     Deoptimization::Action_make_not_entrant);
4817       assert(stopped(), &quot;Should be stopped&quot;);
4818     }
4819     {
4820       PreserveJVMState pjvms(this);
4821       set_control(_gvn.transform(slow_region));
4822       uncommon_trap(Deoptimization::Reason_intrinsic,
4823                     Deoptimization::Action_make_not_entrant);
4824       assert(stopped(), &quot;Should be stopped&quot;);
4825     }
4826 
4827     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4828     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4829     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4830   }
4831 
4832   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4833 
4834   if (stopped()) {
4835     return true;
4836   }
4837 
4838   Node* new_src = access_resolve(src, ACCESS_READ);
4839   Node* new_dest = access_resolve(dest, ACCESS_WRITE);
4840 
4841   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, new_src, src_offset, new_dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,
4842                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
4843                                           // so the compiler has a chance to eliminate them: during macro expansion,
4844                                           // we have to set their control (CastPP nodes are eliminated).
4845                                           load_object_klass(src), load_object_klass(dest),
4846                                           load_array_length(src), load_array_length(dest));
4847 
4848   ac-&gt;set_arraycopy(validated);
4849 
4850   Node* n = _gvn.transform(ac);
4851   if (n == ac) {
4852     ac-&gt;connect_outputs(this);
4853   } else {
4854     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4855     set_all_memory(n);
4856   }
4857   clear_upper_avx();
4858 
4859 
4860   return true;
4861 }
4862 
4863 
4864 // Helper function which determines if an arraycopy immediately follows
4865 // an allocation, with no intervening tests or other escapes for the object.
4866 AllocateArrayNode*
4867 LibraryCallKit::tightly_coupled_allocation(Node* ptr,
4868                                            RegionNode* slow_region) {
4869   if (stopped())             return NULL;  // no fast path
4870   if (C-&gt;AliasLevel() == 0)  return NULL;  // no MergeMems around
4871 
4872   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &amp;_gvn);
4873   if (alloc == NULL)  return NULL;
4874 
4875   Node* rawmem = memory(Compile::AliasIdxRaw);
4876   // Is the allocation&#39;s memory state untouched?
4877   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
4878     // Bail out if there have been raw-memory effects since the allocation.
4879     // (Example:  There might have been a call or safepoint.)
4880     return NULL;
4881   }
4882   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
4883   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
4884     return NULL;
4885   }
4886 
4887   // There must be no unexpected observers of this allocation.
4888   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
4889     Node* obs = ptr-&gt;fast_out(i);
4890     if (obs != this-&gt;map()) {
4891       return NULL;
4892     }
4893   }
4894 
4895   // This arraycopy must unconditionally follow the allocation of the ptr.
4896   Node* alloc_ctl = ptr-&gt;in(0);
4897   assert(just_allocated_object(alloc_ctl) == ptr, &quot;most recent allo&quot;);
4898 
4899   Node* ctl = control();
4900   while (ctl != alloc_ctl) {
4901     // There may be guards which feed into the slow_region.
4902     // Any other control flow means that we might not get a chance
4903     // to finish initializing the allocated object.
4904     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
4905       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
4906       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
4907       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
4908       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
4909         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
4910         continue;
4911       }
4912       // One more try:  Various low-level checks bottom out in
4913       // uncommon traps.  If the debug-info of the trap omits
4914       // any reference to the allocation, as we&#39;ve already
4915       // observed, then there can be no objection to the trap.
4916       bool found_trap = false;
4917       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4918         Node* obs = not_ctl-&gt;fast_out(j);
4919         if (obs-&gt;in(0) == not_ctl &amp;&amp; obs-&gt;is_Call() &amp;&amp;
4920             (obs-&gt;as_Call()-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point())) {
4921           found_trap = true; break;
4922         }
4923       }
4924       if (found_trap) {
4925         ctl = iff-&gt;in(0);       // This test feeds a harmless uncommon trap.
4926         continue;
4927       }
4928     }
4929     return NULL;
4930   }
4931 
4932   // If we get this far, we have an allocation which immediately
4933   // precedes the arraycopy, and we can take over zeroing the new object.
4934   // The arraycopy will finish the initialization, and provide
4935   // a new control state to which we will anchor the destination pointer.
4936 
4937   return alloc;
4938 }
4939 
4940 //-------------inline_encodeISOArray-----------------------------------
4941 // encode char[] to byte[] in ISO_8859_1
4942 bool LibraryCallKit::inline_encodeISOArray() {
4943   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
4944   // no receiver since it is static method
4945   Node *src         = argument(0);
4946   Node *src_offset  = argument(1);
4947   Node *dst         = argument(2);
4948   Node *dst_offset  = argument(3);
4949   Node *length      = argument(4);
4950 
4951   src = must_be_not_null(src, true);
4952   dst = must_be_not_null(dst, true);
4953 
4954   src = access_resolve(src, ACCESS_READ);
4955   dst = access_resolve(dst, ACCESS_WRITE);
4956 
4957   const Type* src_type = src-&gt;Value(&amp;_gvn);
4958   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
4959   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
4960   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
4961   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
4962       top_dest == NULL || top_dest-&gt;klass() == NULL) {
4963     // failed array check
4964     return false;
4965   }
4966 
4967   // Figure out the size and type of the elements we will be copying.
4968   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4969   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4970   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
4971     return false;
4972   }
4973 
4974   Node* src_start = array_element_address(src, src_offset, T_CHAR);
4975   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
4976   // &#39;src_start&#39; points to src array + scaled offset
4977   // &#39;dst_start&#39; points to dst array + scaled offset
4978 
4979   const TypeAryPtr* mtype = TypeAryPtr::BYTES;
4980   Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);
4981   enc = _gvn.transform(enc);
4982   Node* res_mem = _gvn.transform(new SCMemProjNode(enc));
4983   set_memory(res_mem, mtype);
4984   set_result(enc);
4985   clear_upper_avx();
4986 
4987   return true;
4988 }
4989 
4990 //-------------inline_multiplyToLen-----------------------------------
4991 bool LibraryCallKit::inline_multiplyToLen() {
4992   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
4993 
4994   address stubAddr = StubRoutines::multiplyToLen();
4995   if (stubAddr == NULL) {
4996     return false; // Intrinsic&#39;s stub is not implemented on this platform
4997   }
4998   const char* stubName = &quot;multiplyToLen&quot;;
4999 
5000   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
5001 
5002   // no receiver because it is a static method
5003   Node* x    = argument(0);
5004   Node* xlen = argument(1);
5005   Node* y    = argument(2);
5006   Node* ylen = argument(3);
5007   Node* z    = argument(4);
5008 
5009   x = must_be_not_null(x, true);
5010   y = must_be_not_null(y, true);
5011 
5012   x = access_resolve(x, ACCESS_READ);
5013   y = access_resolve(y, ACCESS_READ);
5014   z = access_resolve(z, ACCESS_WRITE);
5015 
5016   const Type* x_type = x-&gt;Value(&amp;_gvn);
5017   const Type* y_type = y-&gt;Value(&amp;_gvn);
5018   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5019   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
5020   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5021       top_y == NULL || top_y-&gt;klass() == NULL) {
5022     // failed array check
5023     return false;
5024   }
5025 
5026   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5027   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5028   if (x_elem != T_INT || y_elem != T_INT) {
5029     return false;
5030   }
5031 
5032   // Set the original stack and the reexecute bit for the interpreter to reexecute
5033   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
5034   // on the return from z array allocation in runtime.
5035   { PreserveReexecuteState preexecs(this);
5036     jvms()-&gt;set_should_reexecute(true);
5037 
5038     Node* x_start = array_element_address(x, intcon(0), x_elem);
5039     Node* y_start = array_element_address(y, intcon(0), y_elem);
5040     // &#39;x_start&#39; points to x array + scaled xlen
5041     // &#39;y_start&#39; points to y array + scaled ylen
5042 
5043     // Allocate the result array
5044     Node* zlen = _gvn.transform(new AddINode(xlen, ylen));
5045     ciKlass* klass = ciTypeArrayKlass::make(T_INT);
5046     Node* klass_node = makecon(TypeKlassPtr::make(klass));
5047 
5048     IdealKit ideal(this);
5049 
5050 #define __ ideal.
5051      Node* one = __ ConI(1);
5052      Node* zero = __ ConI(0);
5053      IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();
5054      __ set(need_alloc, zero);
5055      __ set(z_alloc, z);
5056      __ if_then(z, BoolTest::eq, null()); {
5057        __ increment (need_alloc, one);
5058      } __ else_(); {
5059        // Update graphKit memory and control from IdealKit.
5060        sync_kit(ideal);
5061        Node *cast = new CastPPNode(z, TypePtr::NOTNULL);
5062        cast-&gt;init_req(0, control());
5063        _gvn.set_type(cast, cast-&gt;bottom_type());
5064        C-&gt;record_for_igvn(cast);
5065 
5066        Node* zlen_arg = load_array_length(cast);
5067        // Update IdealKit memory and control from graphKit.
5068        __ sync_kit(this);
5069        __ if_then(zlen_arg, BoolTest::lt, zlen); {
5070          __ increment (need_alloc, one);
5071        } __ end_if();
5072      } __ end_if();
5073 
5074      __ if_then(__ value(need_alloc), BoolTest::ne, zero); {
5075        // Update graphKit memory and control from IdealKit.
5076        sync_kit(ideal);
5077        Node * narr = new_array(klass_node, zlen, 1);
5078        // Update IdealKit memory and control from graphKit.
5079        __ sync_kit(this);
5080        __ set(z_alloc, narr);
5081      } __ end_if();
5082 
5083      sync_kit(ideal);
5084      z = __ value(z_alloc);
5085      // Can&#39;t use TypeAryPtr::INTS which uses Bottom offset.
5086      _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));
5087      // Final sync IdealKit and GraphKit.
5088      final_sync(ideal);
5089 #undef __
5090 
5091     Node* z_start = array_element_address(z, intcon(0), T_INT);
5092 
5093     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
5094                                    OptoRuntime::multiplyToLen_Type(),
5095                                    stubAddr, stubName, TypePtr::BOTTOM,
5096                                    x_start, xlen, y_start, ylen, z_start, zlen);
5097   } // original reexecute is set back here
5098 
5099   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
5100   set_result(z);
5101   return true;
5102 }
5103 
5104 //-------------inline_squareToLen------------------------------------
5105 bool LibraryCallKit::inline_squareToLen() {
5106   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5107 
5108   address stubAddr = StubRoutines::squareToLen();
5109   if (stubAddr == NULL) {
5110     return false; // Intrinsic&#39;s stub is not implemented on this platform
5111   }
5112   const char* stubName = &quot;squareToLen&quot;;
5113 
5114   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5115 
5116   Node* x    = argument(0);
5117   Node* len  = argument(1);
5118   Node* z    = argument(2);
5119   Node* zlen = argument(3);
5120 
5121   x = must_be_not_null(x, true);
5122   z = must_be_not_null(z, true);
5123 
5124   x = access_resolve(x, ACCESS_READ);
5125   z = access_resolve(z, ACCESS_WRITE);
5126 
5127   const Type* x_type = x-&gt;Value(&amp;_gvn);
5128   const Type* z_type = z-&gt;Value(&amp;_gvn);
5129   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5130   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5131   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5132       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5133     // failed array check
5134     return false;
5135   }
5136 
5137   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5138   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5139   if (x_elem != T_INT || z_elem != T_INT) {
5140     return false;
5141   }
5142 
5143 
5144   Node* x_start = array_element_address(x, intcon(0), x_elem);
5145   Node* z_start = array_element_address(z, intcon(0), z_elem);
5146 
5147   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5148                                   OptoRuntime::squareToLen_Type(),
5149                                   stubAddr, stubName, TypePtr::BOTTOM,
5150                                   x_start, len, z_start, zlen);
5151 
5152   set_result(z);
5153   return true;
5154 }
5155 
5156 //-------------inline_mulAdd------------------------------------------
5157 bool LibraryCallKit::inline_mulAdd() {
5158   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5159 
5160   address stubAddr = StubRoutines::mulAdd();
5161   if (stubAddr == NULL) {
5162     return false; // Intrinsic&#39;s stub is not implemented on this platform
5163   }
5164   const char* stubName = &quot;mulAdd&quot;;
5165 
5166   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5167 
5168   Node* out      = argument(0);
5169   Node* in       = argument(1);
5170   Node* offset   = argument(2);
5171   Node* len      = argument(3);
5172   Node* k        = argument(4);
5173 
5174   out = must_be_not_null(out, true);
5175 
5176   in = access_resolve(in, ACCESS_READ);
5177   out = access_resolve(out, ACCESS_WRITE);
5178 
5179   const Type* out_type = out-&gt;Value(&amp;_gvn);
5180   const Type* in_type = in-&gt;Value(&amp;_gvn);
5181   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5182   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5183   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5184       top_in == NULL || top_in-&gt;klass() == NULL) {
5185     // failed array check
5186     return false;
5187   }
5188 
5189   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5190   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5191   if (out_elem != T_INT || in_elem != T_INT) {
5192     return false;
5193   }
5194 
5195   Node* outlen = load_array_length(out);
5196   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5197   Node* out_start = array_element_address(out, intcon(0), out_elem);
5198   Node* in_start = array_element_address(in, intcon(0), in_elem);
5199 
5200   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5201                                   OptoRuntime::mulAdd_Type(),
5202                                   stubAddr, stubName, TypePtr::BOTTOM,
5203                                   out_start,in_start, new_offset, len, k);
5204   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5205   set_result(result);
5206   return true;
5207 }
5208 
5209 //-------------inline_montgomeryMultiply-----------------------------------
5210 bool LibraryCallKit::inline_montgomeryMultiply() {
5211   address stubAddr = StubRoutines::montgomeryMultiply();
5212   if (stubAddr == NULL) {
5213     return false; // Intrinsic&#39;s stub is not implemented on this platform
5214   }
5215 
5216   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5217   const char* stubName = &quot;montgomery_multiply&quot;;
5218 
5219   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5220 
5221   Node* a    = argument(0);
5222   Node* b    = argument(1);
5223   Node* n    = argument(2);
5224   Node* len  = argument(3);
5225   Node* inv  = argument(4);
5226   Node* m    = argument(6);
5227 
5228   a = access_resolve(a, ACCESS_READ);
5229   b = access_resolve(b, ACCESS_READ);
5230   n = access_resolve(n, ACCESS_READ);
5231   m = access_resolve(m, ACCESS_WRITE);
5232 
5233   const Type* a_type = a-&gt;Value(&amp;_gvn);
5234   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5235   const Type* b_type = b-&gt;Value(&amp;_gvn);
5236   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5237   const Type* n_type = a-&gt;Value(&amp;_gvn);
5238   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5239   const Type* m_type = a-&gt;Value(&amp;_gvn);
5240   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5241   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5242       top_b == NULL || top_b-&gt;klass()  == NULL ||
5243       top_n == NULL || top_n-&gt;klass()  == NULL ||
5244       top_m == NULL || top_m-&gt;klass()  == NULL) {
5245     // failed array check
5246     return false;
5247   }
5248 
5249   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5250   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5251   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5252   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5253   if (a_elem != T_INT || b_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5254     return false;
5255   }
5256 
5257   // Make the call
5258   {
5259     Node* a_start = array_element_address(a, intcon(0), a_elem);
5260     Node* b_start = array_element_address(b, intcon(0), b_elem);
5261     Node* n_start = array_element_address(n, intcon(0), n_elem);
5262     Node* m_start = array_element_address(m, intcon(0), m_elem);
5263 
5264     Node* call = make_runtime_call(RC_LEAF,
5265                                    OptoRuntime::montgomeryMultiply_Type(),
5266                                    stubAddr, stubName, TypePtr::BOTTOM,
5267                                    a_start, b_start, n_start, len, inv, top(),
5268                                    m_start);
5269     set_result(m);
5270   }
5271 
5272   return true;
5273 }
5274 
5275 bool LibraryCallKit::inline_montgomerySquare() {
5276   address stubAddr = StubRoutines::montgomerySquare();
5277   if (stubAddr == NULL) {
5278     return false; // Intrinsic&#39;s stub is not implemented on this platform
5279   }
5280 
5281   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5282   const char* stubName = &quot;montgomery_square&quot;;
5283 
5284   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5285 
5286   Node* a    = argument(0);
5287   Node* n    = argument(1);
5288   Node* len  = argument(2);
5289   Node* inv  = argument(3);
5290   Node* m    = argument(5);
5291 
5292   a = access_resolve(a, ACCESS_READ);
5293   n = access_resolve(n, ACCESS_READ);
5294   m = access_resolve(m, ACCESS_WRITE);
5295 
5296   const Type* a_type = a-&gt;Value(&amp;_gvn);
5297   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5298   const Type* n_type = a-&gt;Value(&amp;_gvn);
5299   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5300   const Type* m_type = a-&gt;Value(&amp;_gvn);
5301   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5302   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5303       top_n == NULL || top_n-&gt;klass()  == NULL ||
5304       top_m == NULL || top_m-&gt;klass()  == NULL) {
5305     // failed array check
5306     return false;
5307   }
5308 
5309   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5310   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5311   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5312   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5313     return false;
5314   }
5315 
5316   // Make the call
5317   {
5318     Node* a_start = array_element_address(a, intcon(0), a_elem);
5319     Node* n_start = array_element_address(n, intcon(0), n_elem);
5320     Node* m_start = array_element_address(m, intcon(0), m_elem);
5321 
5322     Node* call = make_runtime_call(RC_LEAF,
5323                                    OptoRuntime::montgomerySquare_Type(),
5324                                    stubAddr, stubName, TypePtr::BOTTOM,
5325                                    a_start, n_start, len, inv, top(),
5326                                    m_start);
5327     set_result(m);
5328   }
5329 
5330   return true;
5331 }
5332 
5333 //-------------inline_vectorizedMismatch------------------------------
5334 bool LibraryCallKit::inline_vectorizedMismatch() {
5335   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5336 
5337   address stubAddr = StubRoutines::vectorizedMismatch();
5338   if (stubAddr == NULL) {
5339     return false; // Intrinsic&#39;s stub is not implemented on this platform
5340   }
5341   const char* stubName = &quot;vectorizedMismatch&quot;;
5342   int size_l = callee()-&gt;signature()-&gt;size();
5343   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5344 
5345   Node* obja = argument(0);
5346   Node* aoffset = argument(1);
5347   Node* objb = argument(3);
5348   Node* boffset = argument(4);
5349   Node* length = argument(6);
5350   Node* scale = argument(7);
5351 
5352   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5353   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5354   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5355   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5356   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5357     top_b == NULL || top_b-&gt;klass() == NULL) {
5358     // failed array check
5359     return false;
5360   }
5361 
5362   Node* call;
5363   jvms()-&gt;set_should_reexecute(true);
5364 
5365   obja = access_resolve(obja, ACCESS_READ);
5366   objb = access_resolve(objb, ACCESS_READ);
5367   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5368   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5369 
5370   call = make_runtime_call(RC_LEAF,
5371     OptoRuntime::vectorizedMismatch_Type(),
5372     stubAddr, stubName, TypePtr::BOTTOM,
5373     obja_adr, objb_adr, length, scale);
5374 
5375   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5376   set_result(result);
5377   return true;
5378 }
5379 
5380 /**
5381  * Calculate CRC32 for byte.
5382  * int java.util.zip.CRC32.update(int crc, int b)
5383  */
5384 bool LibraryCallKit::inline_updateCRC32() {
5385   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5386   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
5387   // no receiver since it is static method
5388   Node* crc  = argument(0); // type: int
5389   Node* b    = argument(1); // type: int
5390 
5391   /*
5392    *    int c = ~ crc;
5393    *    b = timesXtoThe32[(b ^ c) &amp; 0xFF];
5394    *    b = b ^ (c &gt;&gt;&gt; 8);
5395    *    crc = ~b;
5396    */
5397 
5398   Node* M1 = intcon(-1);
5399   crc = _gvn.transform(new XorINode(crc, M1));
5400   Node* result = _gvn.transform(new XorINode(crc, b));
5401   result = _gvn.transform(new AndINode(result, intcon(0xFF)));
5402 
5403   Node* base = makecon(TypeRawPtr::make(StubRoutines::crc_table_addr()));
5404   Node* offset = _gvn.transform(new LShiftINode(result, intcon(0x2)));
5405   Node* adr = basic_plus_adr(top(), base, ConvI2X(offset));
5406   result = make_load(control(), adr, TypeInt::INT, T_INT, MemNode::unordered);
5407 
5408   crc = _gvn.transform(new URShiftINode(crc, intcon(8)));
5409   result = _gvn.transform(new XorINode(crc, result));
5410   result = _gvn.transform(new XorINode(result, M1));
5411   set_result(result);
5412   return true;
5413 }
5414 
5415 /**
5416  * Calculate CRC32 for byte[] array.
5417  * int java.util.zip.CRC32.updateBytes(int crc, byte[] buf, int off, int len)
5418  */
5419 bool LibraryCallKit::inline_updateBytesCRC32() {
5420   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5421   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5422   // no receiver since it is static method
5423   Node* crc     = argument(0); // type: int
5424   Node* src     = argument(1); // type: oop
5425   Node* offset  = argument(2); // type: int
5426   Node* length  = argument(3); // type: int
5427 
5428   const Type* src_type = src-&gt;Value(&amp;_gvn);
5429   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5430   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5431     // failed array check
5432     return false;
5433   }
5434 
5435   // Figure out the size and type of the elements we will be copying.
5436   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5437   if (src_elem != T_BYTE) {
5438     return false;
5439   }
5440 
5441   // &#39;src_start&#39; points to src array + scaled offset
5442   src = must_be_not_null(src, true);
5443   src = access_resolve(src, ACCESS_READ);
5444   Node* src_start = array_element_address(src, offset, src_elem);
5445 
5446   // We assume that range check is done by caller.
5447   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5448 
5449   // Call the stub.
5450   address stubAddr = StubRoutines::updateBytesCRC32();
5451   const char *stubName = &quot;updateBytesCRC32&quot;;
5452 
5453   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5454                                  stubAddr, stubName, TypePtr::BOTTOM,
5455                                  crc, src_start, length);
5456   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5457   set_result(result);
5458   return true;
5459 }
5460 
5461 /**
5462  * Calculate CRC32 for ByteBuffer.
5463  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
5464  */
5465 bool LibraryCallKit::inline_updateByteBufferCRC32() {
5466   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5467   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5468   // no receiver since it is static method
5469   Node* crc     = argument(0); // type: int
5470   Node* src     = argument(1); // type: long
5471   Node* offset  = argument(3); // type: int
5472   Node* length  = argument(4); // type: int
5473 
5474   src = ConvL2X(src);  // adjust Java long to machine word
5475   Node* base = _gvn.transform(new CastX2PNode(src));
5476   offset = ConvI2X(offset);
5477 
5478   // &#39;src_start&#39; points to src array + scaled offset
5479   Node* src_start = basic_plus_adr(top(), base, offset);
5480 
5481   // Call the stub.
5482   address stubAddr = StubRoutines::updateBytesCRC32();
5483   const char *stubName = &quot;updateBytesCRC32&quot;;
5484 
5485   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5486                                  stubAddr, stubName, TypePtr::BOTTOM,
5487                                  crc, src_start, length);
5488   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5489   set_result(result);
5490   return true;
5491 }
5492 
5493 //------------------------------get_table_from_crc32c_class-----------------------
5494 Node * LibraryCallKit::get_table_from_crc32c_class(ciInstanceKlass *crc32c_class) {
5495   Node* table = load_field_from_object(NULL, &quot;byteTable&quot;, &quot;[I&quot;, /*is_exact*/ false, /*is_static*/ true, crc32c_class);
5496   assert (table != NULL, &quot;wrong version of java.util.zip.CRC32C&quot;);
5497 
5498   return table;
5499 }
5500 
5501 //------------------------------inline_updateBytesCRC32C-----------------------
5502 //
5503 // Calculate CRC32C for byte[] array.
5504 // int java.util.zip.CRC32C.updateBytes(int crc, byte[] buf, int off, int end)
5505 //
5506 bool LibraryCallKit::inline_updateBytesCRC32C() {
5507   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5508   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5509   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5510   // no receiver since it is a static method
5511   Node* crc     = argument(0); // type: int
5512   Node* src     = argument(1); // type: oop
5513   Node* offset  = argument(2); // type: int
5514   Node* end     = argument(3); // type: int
5515 
5516   Node* length = _gvn.transform(new SubINode(end, offset));
5517 
5518   const Type* src_type = src-&gt;Value(&amp;_gvn);
5519   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5520   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5521     // failed array check
5522     return false;
5523   }
5524 
5525   // Figure out the size and type of the elements we will be copying.
5526   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5527   if (src_elem != T_BYTE) {
5528     return false;
5529   }
5530 
5531   // &#39;src_start&#39; points to src array + scaled offset
5532   src = must_be_not_null(src, true);
5533   src = access_resolve(src, ACCESS_READ);
5534   Node* src_start = array_element_address(src, offset, src_elem);
5535 
5536   // static final int[] byteTable in class CRC32C
5537   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5538   table = must_be_not_null(table, true);
5539   table = access_resolve(table, ACCESS_READ);
5540   Node* table_start = array_element_address(table, intcon(0), T_INT);
5541 
5542   // We assume that range check is done by caller.
5543   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5544 
5545   // Call the stub.
5546   address stubAddr = StubRoutines::updateBytesCRC32C();
5547   const char *stubName = &quot;updateBytesCRC32C&quot;;
5548 
5549   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5550                                  stubAddr, stubName, TypePtr::BOTTOM,
5551                                  crc, src_start, length, table_start);
5552   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5553   set_result(result);
5554   return true;
5555 }
5556 
5557 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5558 //
5559 // Calculate CRC32C for DirectByteBuffer.
5560 // int java.util.zip.CRC32C.updateDirectByteBuffer(int crc, long buf, int off, int end)
5561 //
5562 bool LibraryCallKit::inline_updateDirectByteBufferCRC32C() {
5563   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5564   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5565   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5566   // no receiver since it is a static method
5567   Node* crc     = argument(0); // type: int
5568   Node* src     = argument(1); // type: long
5569   Node* offset  = argument(3); // type: int
5570   Node* end     = argument(4); // type: int
5571 
5572   Node* length = _gvn.transform(new SubINode(end, offset));
5573 
5574   src = ConvL2X(src);  // adjust Java long to machine word
5575   Node* base = _gvn.transform(new CastX2PNode(src));
5576   offset = ConvI2X(offset);
5577 
5578   // &#39;src_start&#39; points to src array + scaled offset
5579   Node* src_start = basic_plus_adr(top(), base, offset);
5580 
5581   // static final int[] byteTable in class CRC32C
5582   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5583   table = must_be_not_null(table, true);
5584   table = access_resolve(table, ACCESS_READ);
5585   Node* table_start = array_element_address(table, intcon(0), T_INT);
5586 
5587   // Call the stub.
5588   address stubAddr = StubRoutines::updateBytesCRC32C();
5589   const char *stubName = &quot;updateBytesCRC32C&quot;;
5590 
5591   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5592                                  stubAddr, stubName, TypePtr::BOTTOM,
5593                                  crc, src_start, length, table_start);
5594   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5595   set_result(result);
5596   return true;
5597 }
5598 
5599 //------------------------------inline_updateBytesAdler32----------------------
5600 //
5601 // Calculate Adler32 checksum for byte[] array.
5602 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5603 //
5604 bool LibraryCallKit::inline_updateBytesAdler32() {
5605   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5606   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5607   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5608   // no receiver since it is static method
5609   Node* crc     = argument(0); // type: int
5610   Node* src     = argument(1); // type: oop
5611   Node* offset  = argument(2); // type: int
5612   Node* length  = argument(3); // type: int
5613 
5614   const Type* src_type = src-&gt;Value(&amp;_gvn);
5615   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5616   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5617     // failed array check
5618     return false;
5619   }
5620 
5621   // Figure out the size and type of the elements we will be copying.
5622   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5623   if (src_elem != T_BYTE) {
5624     return false;
5625   }
5626 
5627   // &#39;src_start&#39; points to src array + scaled offset
5628   src = access_resolve(src, ACCESS_READ);
5629   Node* src_start = array_element_address(src, offset, src_elem);
5630 
5631   // We assume that range check is done by caller.
5632   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5633 
5634   // Call the stub.
5635   address stubAddr = StubRoutines::updateBytesAdler32();
5636   const char *stubName = &quot;updateBytesAdler32&quot;;
5637 
5638   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5639                                  stubAddr, stubName, TypePtr::BOTTOM,
5640                                  crc, src_start, length);
5641   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5642   set_result(result);
5643   return true;
5644 }
5645 
5646 //------------------------------inline_updateByteBufferAdler32---------------
5647 //
5648 // Calculate Adler32 checksum for DirectByteBuffer.
5649 // int java.util.zip.Adler32.updateByteBuffer(int crc, long buf, int off, int len)
5650 //
5651 bool LibraryCallKit::inline_updateByteBufferAdler32() {
5652   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5653   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5654   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5655   // no receiver since it is static method
5656   Node* crc     = argument(0); // type: int
5657   Node* src     = argument(1); // type: long
5658   Node* offset  = argument(3); // type: int
5659   Node* length  = argument(4); // type: int
5660 
5661   src = ConvL2X(src);  // adjust Java long to machine word
5662   Node* base = _gvn.transform(new CastX2PNode(src));
5663   offset = ConvI2X(offset);
5664 
5665   // &#39;src_start&#39; points to src array + scaled offset
5666   Node* src_start = basic_plus_adr(top(), base, offset);
5667 
5668   // Call the stub.
5669   address stubAddr = StubRoutines::updateBytesAdler32();
5670   const char *stubName = &quot;updateBytesAdler32&quot;;
5671 
5672   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5673                                  stubAddr, stubName, TypePtr::BOTTOM,
5674                                  crc, src_start, length);
5675 
5676   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5677   set_result(result);
5678   return true;
5679 }
5680 
5681 //----------------------------inline_reference_get----------------------------
5682 // public T java.lang.ref.Reference.get();
5683 bool LibraryCallKit::inline_reference_get() {
5684   const int referent_offset = java_lang_ref_Reference::referent_offset;
5685   guarantee(referent_offset &gt; 0, &quot;should have already been set&quot;);
5686 
5687   // Get the argument:
5688   Node* reference_obj = null_check_receiver();
5689   if (stopped()) return true;
5690 
5691   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
5692   assert(tinst != NULL, &quot;obj is null&quot;);
5693   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5694   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
5695   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
5696                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
5697                                                      false);
5698   assert (field != NULL, &quot;undefined field&quot;);
5699 
5700   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
5701   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5702 
5703   ciInstanceKlass* klass = env()-&gt;Object_klass();
5704   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
5705 
5706   DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;
5707   Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);
5708   // Add memory barrier to prevent commoning reads from this field
5709   // across safepoint since GC can change its value.
5710   insert_mem_bar(Op_MemBarCPUOrder);
5711 
5712   set_result(result);
5713   return true;
5714 }
5715 
5716 
5717 Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5718                                               bool is_exact=true, bool is_static=false,
5719                                               ciInstanceKlass * fromKls=NULL) {
5720   if (fromKls == NULL) {
5721     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5722     assert(tinst != NULL, &quot;obj is null&quot;);
5723     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5724     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5725     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5726   } else {
5727     assert(is_static, &quot;only for static field access&quot;);
5728   }
5729   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5730                                               ciSymbol::make(fieldTypeString),
5731                                               is_static);
5732 
5733   assert (field != NULL, &quot;undefined field&quot;);
5734   if (field == NULL) return (Node *) NULL;
5735 
5736   if (is_static) {
5737     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5738     fromObj = makecon(tip);
5739   }
5740 
5741   // Next code  copied from Parse::do_get_xxx():
5742 
5743   // Compute address and memory type.
5744   int offset  = field-&gt;offset_in_bytes();
5745   bool is_vol = field-&gt;is_volatile();
5746   ciType* field_klass = field-&gt;type();
5747   assert(field_klass-&gt;is_loaded(), &quot;should be loaded&quot;);
5748   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5749   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5750   BasicType bt = field-&gt;layout_type();
5751 
5752   // Build the resultant type of the load
5753   const Type *type;
5754   if (bt == T_OBJECT) {
5755     type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
5756   } else {
5757     type = Type::get_const_basic_type(bt);
5758   }
5759 
5760   DecoratorSet decorators = IN_HEAP;
5761 
5762   if (is_vol) {
5763     decorators |= MO_SEQ_CST;
5764   }
5765 
5766   return access_load_at(fromObj, adr, adr_type, type, bt, decorators);
5767 }
5768 
5769 Node * LibraryCallKit::field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5770                                                  bool is_exact = true, bool is_static = false,
5771                                                  ciInstanceKlass * fromKls = NULL) {
5772   if (fromKls == NULL) {
5773     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5774     assert(tinst != NULL, &quot;obj is null&quot;);
5775     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5776     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5777     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5778   }
5779   else {
5780     assert(is_static, &quot;only for static field access&quot;);
5781   }
5782   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5783     ciSymbol::make(fieldTypeString),
5784     is_static);
5785 
5786   assert(field != NULL, &quot;undefined field&quot;);
5787   assert(!field-&gt;is_volatile(), &quot;not defined for volatile fields&quot;);
5788 
5789   if (is_static) {
5790     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5791     fromObj = makecon(tip);
5792   }
5793 
5794   // Next code  copied from Parse::do_get_xxx():
5795 
5796   // Compute address and memory type.
5797   int offset = field-&gt;offset_in_bytes();
5798   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5799 
5800   return adr;
5801 }
5802 
5803 //------------------------------inline_aescrypt_Block-----------------------
5804 bool LibraryCallKit::inline_aescrypt_Block(vmIntrinsics::ID id) {
5805   address stubAddr = NULL;
5806   const char *stubName;
5807   assert(UseAES, &quot;need AES instruction support&quot;);
5808 
5809   switch(id) {
5810   case vmIntrinsics::_aescrypt_encryptBlock:
5811     stubAddr = StubRoutines::aescrypt_encryptBlock();
5812     stubName = &quot;aescrypt_encryptBlock&quot;;
5813     break;
5814   case vmIntrinsics::_aescrypt_decryptBlock:
5815     stubAddr = StubRoutines::aescrypt_decryptBlock();
5816     stubName = &quot;aescrypt_decryptBlock&quot;;
5817     break;
5818   default:
5819     break;
5820   }
5821   if (stubAddr == NULL) return false;
5822 
5823   Node* aescrypt_object = argument(0);
5824   Node* src             = argument(1);
5825   Node* src_offset      = argument(2);
5826   Node* dest            = argument(3);
5827   Node* dest_offset     = argument(4);
5828 
5829   src = must_be_not_null(src, true);
5830   dest = must_be_not_null(dest, true);
5831 
5832   src = access_resolve(src, ACCESS_READ);
5833   dest = access_resolve(dest, ACCESS_WRITE);
5834 
5835   // (1) src and dest are arrays.
5836   const Type* src_type = src-&gt;Value(&amp;_gvn);
5837   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5838   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5839   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5840   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5841 
5842   // for the quick and dirty code we will skip all the checks.
5843   // we are just trying to get the call to be generated.
5844   Node* src_start  = src;
5845   Node* dest_start = dest;
5846   if (src_offset != NULL || dest_offset != NULL) {
5847     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5848     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5849     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5850   }
5851 
5852   // now need to get the start of its expanded key array
5853   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5854   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5855   if (k_start == NULL) return false;
5856 
5857   if (Matcher::pass_original_key_for_aes()) {
5858     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5859     // compatibility issues between Java key expansion and SPARC crypto instructions
5860     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5861     if (original_k_start == NULL) return false;
5862 
5863     // Call the stub.
5864     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5865                       stubAddr, stubName, TypePtr::BOTTOM,
5866                       src_start, dest_start, k_start, original_k_start);
5867   } else {
5868     // Call the stub.
5869     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5870                       stubAddr, stubName, TypePtr::BOTTOM,
5871                       src_start, dest_start, k_start);
5872   }
5873 
5874   return true;
5875 }
5876 
5877 //------------------------------inline_cipherBlockChaining_AESCrypt-----------------------
5878 bool LibraryCallKit::inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id) {
5879   address stubAddr = NULL;
5880   const char *stubName = NULL;
5881 
5882   assert(UseAES, &quot;need AES instruction support&quot;);
5883 
5884   switch(id) {
5885   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
5886     stubAddr = StubRoutines::cipherBlockChaining_encryptAESCrypt();
5887     stubName = &quot;cipherBlockChaining_encryptAESCrypt&quot;;
5888     break;
5889   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
5890     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
5891     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
5892     break;
5893   default:
5894     break;
5895   }
5896   if (stubAddr == NULL) return false;
5897 
5898   Node* cipherBlockChaining_object = argument(0);
5899   Node* src                        = argument(1);
5900   Node* src_offset                 = argument(2);
5901   Node* len                        = argument(3);
5902   Node* dest                       = argument(4);
5903   Node* dest_offset                = argument(5);
5904 
5905   src = must_be_not_null(src, false);
5906   dest = must_be_not_null(dest, false);
5907 
5908   src = access_resolve(src, ACCESS_READ);
5909   dest = access_resolve(dest, ACCESS_WRITE);
5910 
5911   // (1) src and dest are arrays.
5912   const Type* src_type = src-&gt;Value(&amp;_gvn);
5913   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5914   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5915   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5916   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
5917           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5918 
5919   // checks are the responsibility of the caller
5920   Node* src_start  = src;
5921   Node* dest_start = dest;
5922   if (src_offset != NULL || dest_offset != NULL) {
5923     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5924     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5925     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5926   }
5927 
5928   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
5929   // (because of the predicated logic executed earlier).
5930   // so we cast it here safely.
5931   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5932 
5933   Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
5934   if (embeddedCipherObj == NULL) return false;
5935 
5936   // cast it to what we know it will be at runtime
5937   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
5938   assert(tinst != NULL, &quot;CBC obj is null&quot;);
5939   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
5940   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
5941   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
5942 
5943   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
5944   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
5945   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
5946   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
5947   aescrypt_object = _gvn.transform(aescrypt_object);
5948 
5949   // we need to get the start of the aescrypt_object&#39;s expanded key array
5950   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5951   if (k_start == NULL) return false;
5952 
5953   // similarly, get the start address of the r vector
5954   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
5955   if (objRvec == NULL) return false;
5956   objRvec = access_resolve(objRvec, ACCESS_WRITE);
5957   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
5958 
5959   Node* cbcCrypt;
5960   if (Matcher::pass_original_key_for_aes()) {
5961     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5962     // compatibility issues between Java key expansion and SPARC crypto instructions
5963     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5964     if (original_k_start == NULL) return false;
5965 
5966     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
5967     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5968                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5969                                  stubAddr, stubName, TypePtr::BOTTOM,
5970                                  src_start, dest_start, k_start, r_start, len, original_k_start);
5971   } else {
5972     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
5973     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5974                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5975                                  stubAddr, stubName, TypePtr::BOTTOM,
5976                                  src_start, dest_start, k_start, r_start, len);
5977   }
5978 
5979   // return cipher length (int)
5980   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
5981   set_result(retvalue);
5982   return true;
5983 }
5984 
5985 //------------------------------inline_counterMode_AESCrypt-----------------------
5986 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
5987   assert(UseAES, &quot;need AES instruction support&quot;);
5988   if (!UseAESCTRIntrinsics) return false;
5989 
5990   address stubAddr = NULL;
5991   const char *stubName = NULL;
5992   if (id == vmIntrinsics::_counterMode_AESCrypt) {
5993     stubAddr = StubRoutines::counterMode_AESCrypt();
5994     stubName = &quot;counterMode_AESCrypt&quot;;
5995   }
5996   if (stubAddr == NULL) return false;
5997 
5998   Node* counterMode_object = argument(0);
5999   Node* src = argument(1);
6000   Node* src_offset = argument(2);
6001   Node* len = argument(3);
6002   Node* dest = argument(4);
6003   Node* dest_offset = argument(5);
6004 
6005   src = access_resolve(src, ACCESS_READ);
6006   dest = access_resolve(dest, ACCESS_WRITE);
6007   counterMode_object = access_resolve(counterMode_object, ACCESS_WRITE);
6008 
6009   // (1) src and dest are arrays.
6010   const Type* src_type = src-&gt;Value(&amp;_gvn);
6011   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6012   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6013   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6014   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6015          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6016 
6017   // checks are the responsibility of the caller
6018   Node* src_start = src;
6019   Node* dest_start = dest;
6020   if (src_offset != NULL || dest_offset != NULL) {
6021     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6022     src_start = array_element_address(src, src_offset, T_BYTE);
6023     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6024   }
6025 
6026   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6027   // (because of the predicated logic executed earlier).
6028   // so we cast it here safely.
6029   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6030   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6031   if (embeddedCipherObj == NULL) return false;
6032   // cast it to what we know it will be at runtime
6033   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6034   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6035   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6036   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6037   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6038   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6039   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6040   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6041   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6042   aescrypt_object = _gvn.transform(aescrypt_object);
6043   // we need to get the start of the aescrypt_object&#39;s expanded key array
6044   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6045   if (k_start == NULL) return false;
6046   // similarly, get the start address of the r vector
6047   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6048   if (obj_counter == NULL) return false;
6049   obj_counter = access_resolve(obj_counter, ACCESS_WRITE);
6050   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6051 
6052   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6053   if (saved_encCounter == NULL) return false;
6054   saved_encCounter = access_resolve(saved_encCounter, ACCESS_WRITE);
6055   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6056   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6057 
6058   Node* ctrCrypt;
6059   if (Matcher::pass_original_key_for_aes()) {
6060     // no SPARC version for AES/CTR intrinsics now.
6061     return false;
6062   }
6063   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6064   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6065                                OptoRuntime::counterMode_aescrypt_Type(),
6066                                stubAddr, stubName, TypePtr::BOTTOM,
6067                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6068 
6069   // return cipher length (int)
6070   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6071   set_result(retvalue);
6072   return true;
6073 }
6074 
6075 //------------------------------get_key_start_from_aescrypt_object-----------------------
6076 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6077 #if defined(PPC64) || defined(S390)
6078   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6079   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6080   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6081   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6082   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6083   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6084   if (objSessionK == NULL) {
6085     return (Node *) NULL;
6086   }
6087   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6088 #else
6089   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6090 #endif // PPC64
6091   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6092   if (objAESCryptKey == NULL) return (Node *) NULL;
6093 
6094   // now have the array, need to get the start address of the K array
6095   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);
6096   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6097   return k_start;
6098 }
6099 
6100 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6101 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6102   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6103   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6104   if (objAESCryptKey == NULL) return (Node *) NULL;
6105 
6106   // now have the array, need to get the start address of the lastKey array
6107   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);
6108   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6109   return original_k_start;
6110 }
6111 
6112 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6113 // Return node representing slow path of predicate check.
6114 // the pseudo code we want to emulate with this predicate is:
6115 // for encryption:
6116 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6117 // for decryption:
6118 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6119 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6120 //
6121 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6122   // The receiver was checked for NULL already.
6123   Node* objCBC = argument(0);
6124 
6125   Node* src = argument(1);
6126   Node* dest = argument(4);
6127 
6128   // Load embeddedCipher field of CipherBlockChaining object.
6129   Node* embeddedCipherObj = load_field_from_object(objCBC, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6130 
6131   // get AESCrypt klass for instanceOf check
6132   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6133   // will have same classloader as CipherBlockChaining object
6134   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6135   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6136   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6137 
6138   // we want to do an instanceof comparison against the AESCrypt class
6139   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6140   if (!klass_AESCrypt-&gt;is_loaded()) {
6141     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6142     Node* ctrl = control();
6143     set_control(top()); // no regular fast path
6144     return ctrl;
6145   }
6146 
6147   src = must_be_not_null(src, true);
6148   dest = must_be_not_null(dest, true);
6149 
6150   // Resolve oops to stable for CmpP below.
6151   src = access_resolve(src, 0);
6152   dest = access_resolve(dest, 0);
6153 
6154   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6155 
6156   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6157   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6158   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6159 
6160   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6161 
6162   // for encryption, we are done
6163   if (!decrypting)
6164     return instof_false;  // even if it is NULL
6165 
6166   // for decryption, we need to add a further check to avoid
6167   // taking the intrinsic path when cipher and plain are the same
6168   // see the original java code for why.
6169   RegionNode* region = new RegionNode(3);
6170   region-&gt;init_req(1, instof_false);
6171 
6172   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6173   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6174   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6175   region-&gt;init_req(2, src_dest_conjoint);
6176 
6177   record_for_igvn(region);
6178   return _gvn.transform(region);
6179 }
6180 
6181 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6182 // Return node representing slow path of predicate check.
6183 // the pseudo code we want to emulate with this predicate is:
6184 // for encryption:
6185 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6186 // for decryption:
6187 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6188 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6189 //
6190 
6191 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6192   // The receiver was checked for NULL already.
6193   Node* objCTR = argument(0);
6194 
6195   // Load embeddedCipher field of CipherBlockChaining object.
6196   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6197 
6198   // get AESCrypt klass for instanceOf check
6199   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6200   // will have same classloader as CipherBlockChaining object
6201   const TypeInstPtr* tinst = _gvn.type(objCTR)-&gt;isa_instptr();
6202   assert(tinst != NULL, &quot;CTRobj is null&quot;);
6203   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTRobj is not loaded&quot;);
6204 
6205   // we want to do an instanceof comparison against the AESCrypt class
6206   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6207   if (!klass_AESCrypt-&gt;is_loaded()) {
6208     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6209     Node* ctrl = control();
6210     set_control(top()); // no regular fast path
6211     return ctrl;
6212   }
6213 
6214   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6215   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6216   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6217   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6218   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6219 
6220   return instof_false; // even if it is NULL
6221 }
6222 
6223 //------------------------------inline_ghash_processBlocks
6224 bool LibraryCallKit::inline_ghash_processBlocks() {
6225   address stubAddr;
6226   const char *stubName;
6227   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6228 
6229   stubAddr = StubRoutines::ghash_processBlocks();
6230   stubName = &quot;ghash_processBlocks&quot;;
6231 
6232   Node* data           = argument(0);
6233   Node* offset         = argument(1);
6234   Node* len            = argument(2);
6235   Node* state          = argument(3);
6236   Node* subkeyH        = argument(4);
6237 
6238   state = must_be_not_null(state, true);
6239   subkeyH = must_be_not_null(subkeyH, true);
6240   data = must_be_not_null(data, true);
6241 
6242   state = access_resolve(state, ACCESS_WRITE);
6243   subkeyH = access_resolve(subkeyH, ACCESS_READ);
6244   data = access_resolve(data, ACCESS_READ);
6245 
6246   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6247   assert(state_start, &quot;state is NULL&quot;);
6248   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6249   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6250   Node* data_start  = array_element_address(data, offset, T_BYTE);
6251   assert(data_start, &quot;data is NULL&quot;);
6252 
6253   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6254                                   OptoRuntime::ghash_processBlocks_Type(),
6255                                   stubAddr, stubName, TypePtr::BOTTOM,
6256                                   state_start, subkeyH_start, data_start, len);
6257   return true;
6258 }
6259 
6260 bool LibraryCallKit::inline_base64_encodeBlock() {
6261   address stubAddr;
6262   const char *stubName;
6263   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6264   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6265   stubAddr = StubRoutines::base64_encodeBlock();
6266   stubName = &quot;encodeBlock&quot;;
6267 
6268   if (!stubAddr) return false;
6269   Node* base64obj = argument(0);
6270   Node* src = argument(1);
6271   Node* offset = argument(2);
6272   Node* len = argument(3);
6273   Node* dest = argument(4);
6274   Node* dp = argument(5);
6275   Node* isURL = argument(6);
6276 
6277   src = must_be_not_null(src, true);
6278   src = access_resolve(src, ACCESS_READ);
6279   dest = must_be_not_null(dest, true);
6280   dest = access_resolve(dest, ACCESS_WRITE);
6281 
6282   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6283   assert(src_start, &quot;source array is NULL&quot;);
6284   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6285   assert(dest_start, &quot;destination array is NULL&quot;);
6286 
6287   Node* base64 = make_runtime_call(RC_LEAF,
6288                                    OptoRuntime::base64_encodeBlock_Type(),
6289                                    stubAddr, stubName, TypePtr::BOTTOM,
6290                                    src_start, offset, len, dest_start, dp, isURL);
6291   return true;
6292 }
6293 
6294 //------------------------------inline_sha_implCompress-----------------------
6295 //
6296 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6297 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6298 //
6299 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6300 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
6301 //
6302 // Calculate SHA5 (i.e., SHA-384 or SHA-512) for single-block byte[] array.
6303 // void com.sun.security.provider.SHA5.implCompress(byte[] buf, int ofs)
6304 //
6305 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6306   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6307 
6308   Node* sha_obj = argument(0);
6309   Node* src     = argument(1); // type oop
6310   Node* ofs     = argument(2); // type int
6311 
6312   const Type* src_type = src-&gt;Value(&amp;_gvn);
6313   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6314   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6315     // failed array check
6316     return false;
6317   }
6318   // Figure out the size and type of the elements we will be copying.
6319   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6320   if (src_elem != T_BYTE) {
6321     return false;
6322   }
6323   // &#39;src_start&#39; points to src array + offset
6324   src = must_be_not_null(src, true);
6325   src = access_resolve(src, ACCESS_READ);
6326   Node* src_start = array_element_address(src, ofs, src_elem);
6327   Node* state = NULL;
6328   address stubAddr;
6329   const char *stubName;
6330 
6331   switch(id) {
6332   case vmIntrinsics::_sha_implCompress:
6333     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6334     state = get_state_from_sha_object(sha_obj);
6335     stubAddr = StubRoutines::sha1_implCompress();
6336     stubName = &quot;sha1_implCompress&quot;;
6337     break;
6338   case vmIntrinsics::_sha2_implCompress:
6339     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6340     state = get_state_from_sha_object(sha_obj);
6341     stubAddr = StubRoutines::sha256_implCompress();
6342     stubName = &quot;sha256_implCompress&quot;;
6343     break;
6344   case vmIntrinsics::_sha5_implCompress:
6345     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6346     state = get_state_from_sha5_object(sha_obj);
6347     stubAddr = StubRoutines::sha512_implCompress();
6348     stubName = &quot;sha512_implCompress&quot;;
6349     break;
6350   default:
6351     fatal_unexpected_iid(id);
6352     return false;
6353   }
6354   if (state == NULL) return false;
6355 
6356   // Call the stub.
6357   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6358                                  stubAddr, stubName, TypePtr::BOTTOM,
6359                                  src_start, state);
6360 
6361   return true;
6362 }
6363 
6364 //------------------------------inline_digestBase_implCompressMB-----------------------
6365 //
6366 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6367 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6368 //
6369 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6370   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6371          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6372   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6373   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6374 
6375   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6376   Node* src            = argument(1); // byte[] array
6377   Node* ofs            = argument(2); // type int
6378   Node* limit          = argument(3); // type int
6379 
6380   const Type* src_type = src-&gt;Value(&amp;_gvn);
6381   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6382   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6383     // failed array check
6384     return false;
6385   }
6386   // Figure out the size and type of the elements we will be copying.
6387   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6388   if (src_elem != T_BYTE) {
6389     return false;
6390   }
6391   // &#39;src_start&#39; points to src array + offset
6392   src = must_be_not_null(src, false);
6393   src = access_resolve(src, ACCESS_READ);
6394   Node* src_start = array_element_address(src, ofs, src_elem);
6395 
6396   const char* klass_SHA_name = NULL;
6397   const char* stub_name = NULL;
6398   address     stub_addr = NULL;
6399   bool        long_state = false;
6400 
6401   switch (predicate) {
6402   case 0:
6403     if (UseSHA1Intrinsics) {
6404       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6405       stub_name = &quot;sha1_implCompressMB&quot;;
6406       stub_addr = StubRoutines::sha1_implCompressMB();
6407     }
6408     break;
6409   case 1:
6410     if (UseSHA256Intrinsics) {
6411       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6412       stub_name = &quot;sha256_implCompressMB&quot;;
6413       stub_addr = StubRoutines::sha256_implCompressMB();
6414     }
6415     break;
6416   case 2:
6417     if (UseSHA512Intrinsics) {
6418       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6419       stub_name = &quot;sha512_implCompressMB&quot;;
6420       stub_addr = StubRoutines::sha512_implCompressMB();
6421       long_state = true;
6422     }
6423     break;
6424   default:
6425     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6426   }
6427   if (klass_SHA_name != NULL) {
6428     // get DigestBase klass to lookup for SHA klass
6429     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6430     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6431     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6432 
6433     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6434     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6435     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6436     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6437   }
6438   return false;
6439 }
6440 //------------------------------inline_sha_implCompressMB-----------------------
6441 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6442                                                bool long_state, address stubAddr, const char *stubName,
6443                                                Node* src_start, Node* ofs, Node* limit) {
6444   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6445   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6446   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6447   sha_obj = _gvn.transform(sha_obj);
6448 
6449   Node* state;
6450   if (long_state) {
6451     state = get_state_from_sha5_object(sha_obj);
6452   } else {
6453     state = get_state_from_sha_object(sha_obj);
6454   }
6455   if (state == NULL) return false;
6456 
6457   // Call the stub.
6458   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6459                                  OptoRuntime::digestBase_implCompressMB_Type(),
6460                                  stubAddr, stubName, TypePtr::BOTTOM,
6461                                  src_start, state, ofs, limit);
6462   // return ofs (int)
6463   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6464   set_result(result);
6465 
6466   return true;
6467 }
6468 
6469 //------------------------------get_state_from_sha_object-----------------------
6470 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6471   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6472   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6473   if (sha_state == NULL) return (Node *) NULL;
6474 
6475   // now have the array, need to get the start address of the state array
6476   sha_state = access_resolve(sha_state, ACCESS_WRITE);
6477   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6478   return state;
6479 }
6480 
6481 //------------------------------get_state_from_sha5_object-----------------------
6482 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6483   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6484   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6485   if (sha_state == NULL) return (Node *) NULL;
6486 
6487   // now have the array, need to get the start address of the state array
6488   sha_state = access_resolve(sha_state, ACCESS_WRITE);
6489   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6490   return state;
6491 }
6492 
6493 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6494 // Return node representing slow path of predicate check.
6495 // the pseudo code we want to emulate with this predicate is:
6496 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6497 //
6498 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6499   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6500          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6501   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6502 
6503   // The receiver was checked for NULL already.
6504   Node* digestBaseObj = argument(0);
6505 
6506   // get DigestBase klass for instanceOf check
6507   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6508   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
6509   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6510 
6511   const char* klass_SHA_name = NULL;
6512   switch (predicate) {
6513   case 0:
6514     if (UseSHA1Intrinsics) {
6515       // we want to do an instanceof comparison against the SHA class
6516       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6517     }
6518     break;
6519   case 1:
6520     if (UseSHA256Intrinsics) {
6521       // we want to do an instanceof comparison against the SHA2 class
6522       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6523     }
6524     break;
6525   case 2:
6526     if (UseSHA512Intrinsics) {
6527       // we want to do an instanceof comparison against the SHA5 class
6528       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6529     }
6530     break;
6531   default:
6532     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6533   }
6534 
6535   ciKlass* klass_SHA = NULL;
6536   if (klass_SHA_name != NULL) {
6537     klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6538   }
6539   if ((klass_SHA == NULL) || !klass_SHA-&gt;is_loaded()) {
6540     // if none of SHA/SHA2/SHA5 is loaded, we never take the intrinsic fast path
6541     Node* ctrl = control();
6542     set_control(top()); // no intrinsic path
6543     return ctrl;
6544   }
6545   ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6546 
6547   Node* instofSHA = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass_SHA)));
6548   Node* cmp_instof = _gvn.transform(new CmpINode(instofSHA, intcon(1)));
6549   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6550   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6551 
6552   return instof_false;  // even if it is NULL
6553 }
6554 
6555 //-------------inline_fma-----------------------------------
6556 bool LibraryCallKit::inline_fma(vmIntrinsics::ID id) {
6557   Node *a = NULL;
6558   Node *b = NULL;
6559   Node *c = NULL;
6560   Node* result = NULL;
6561   switch (id) {
6562   case vmIntrinsics::_fmaD:
6563     assert(callee()-&gt;signature()-&gt;size() == 6, &quot;fma has 3 parameters of size 2 each.&quot;);
6564     // no receiver since it is static method
6565     a = round_double_node(argument(0));
6566     b = round_double_node(argument(2));
6567     c = round_double_node(argument(4));
6568     result = _gvn.transform(new FmaDNode(control(), a, b, c));
6569     break;
6570   case vmIntrinsics::_fmaF:
6571     assert(callee()-&gt;signature()-&gt;size() == 3, &quot;fma has 3 parameters of size 1 each.&quot;);
6572     a = argument(0);
6573     b = argument(1);
6574     c = argument(2);
6575     result = _gvn.transform(new FmaFNode(control(), a, b, c));
6576     break;
6577   default:
6578     fatal_unexpected_iid(id);  break;
6579   }
6580   set_result(result);
6581   return true;
6582 }
6583 
6584 bool LibraryCallKit::inline_character_compare(vmIntrinsics::ID id) {
6585   // argument(0) is receiver
6586   Node* codePoint = argument(1);
6587   Node* n = NULL;
6588 
6589   switch (id) {
6590     case vmIntrinsics::_isDigit :
6591       n = new DigitNode(control(), codePoint);
6592       break;
6593     case vmIntrinsics::_isLowerCase :
6594       n = new LowerCaseNode(control(), codePoint);
6595       break;
6596     case vmIntrinsics::_isUpperCase :
6597       n = new UpperCaseNode(control(), codePoint);
6598       break;
6599     case vmIntrinsics::_isWhitespace :
6600       n = new WhitespaceNode(control(), codePoint);
6601       break;
6602     default:
6603       fatal_unexpected_iid(id);
6604   }
6605 
6606   set_result(_gvn.transform(n));
6607   return true;
6608 }
6609 
6610 //------------------------------inline_fp_min_max------------------------------
6611 bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {
6612 /* DISABLED BECAUSE METHOD DATA ISN&#39;T COLLECTED PER CALL-SITE, SEE JDK-8015416.
6613 
6614   // The intrinsic should be used only when the API branches aren&#39;t predictable,
6615   // the last one performing the most important comparison. The following heuristic
6616   // uses the branch statistics to eventually bail out if necessary.
6617 
6618   ciMethodData *md = callee()-&gt;method_data();
6619 
6620   if ( md != NULL &amp;&amp; md-&gt;is_mature() &amp;&amp; md-&gt;invocation_count() &gt; 0 ) {
6621     ciCallProfile cp = caller()-&gt;call_profile_at_bci(bci());
6622 
6623     if ( ((double)cp.count()) / ((double)md-&gt;invocation_count()) &lt; 0.8 ) {
6624       // Bail out if the call-site didn&#39;t contribute enough to the statistics.
6625       return false;
6626     }
6627 
6628     uint taken = 0, not_taken = 0;
6629 
6630     for (ciProfileData *p = md-&gt;first_data(); md-&gt;is_valid(p); p = md-&gt;next_data(p)) {
6631       if (p-&gt;is_BranchData()) {
6632         taken = ((ciBranchData*)p)-&gt;taken();
6633         not_taken = ((ciBranchData*)p)-&gt;not_taken();
6634       }
6635     }
6636 
6637     double balance = (((double)taken) - ((double)not_taken)) / ((double)md-&gt;invocation_count());
6638     balance = balance &lt; 0 ? -balance : balance;
6639     if ( balance &gt; 0.2 ) {
6640       // Bail out if the most important branch is predictable enough.
6641       return false;
6642     }
6643   }
6644 */
6645 
6646   Node *a = NULL;
6647   Node *b = NULL;
6648   Node *n = NULL;
6649   switch (id) {
6650   case vmIntrinsics::_maxF:
6651   case vmIntrinsics::_minF:
6652     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
6653     a = argument(0);
6654     b = argument(1);
6655     break;
6656   case vmIntrinsics::_maxD:
6657   case vmIntrinsics::_minD:
6658     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
6659     a = round_double_node(argument(0));
6660     b = round_double_node(argument(2));
6661     break;
6662   default:
6663     fatal_unexpected_iid(id);
6664     break;
6665   }
6666   if (a-&gt;is_Con() || b-&gt;is_Con()) {
6667     return false;
6668   }
6669   switch (id) {
6670   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
6671   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
6672   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
6673   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
6674   default:  fatal_unexpected_iid(id);  break;
6675   }
6676   set_result(_gvn.transform(n));
6677   return true;
6678 }
6679 
6680 bool LibraryCallKit::inline_profileBoolean() {
6681   Node* counts = argument(1);
6682   const TypeAryPtr* ary = NULL;
6683   ciArray* aobj = NULL;
6684   if (counts-&gt;is_Con()
6685       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
6686       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
6687       &amp;&amp; (aobj-&gt;length() == 2)) {
6688     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
6689     jint false_cnt = aobj-&gt;element_value(0).as_int();
6690     jint  true_cnt = aobj-&gt;element_value(1).as_int();
6691 
6692     if (C-&gt;log() != NULL) {
6693       C-&gt;log()-&gt;elem(&quot;observe source=&#39;profileBoolean&#39; false=&#39;%d&#39; true=&#39;%d&#39;&quot;,
6694                      false_cnt, true_cnt);
6695     }
6696 
6697     if (false_cnt + true_cnt == 0) {
6698       // According to profile, never executed.
6699       uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6700                           Deoptimization::Action_reinterpret);
6701       return true;
6702     }
6703 
6704     // result is a boolean (0 or 1) and its profile (false_cnt &amp; true_cnt)
6705     // is a number of each value occurrences.
6706     Node* result = argument(0);
6707     if (false_cnt == 0 || true_cnt == 0) {
6708       // According to profile, one value has been never seen.
6709       int expected_val = (false_cnt == 0) ? 1 : 0;
6710 
6711       Node* cmp  = _gvn.transform(new CmpINode(result, intcon(expected_val)));
6712       Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
6713 
6714       IfNode* check = create_and_map_if(control(), test, PROB_ALWAYS, COUNT_UNKNOWN);
6715       Node* fast_path = _gvn.transform(new IfTrueNode(check));
6716       Node* slow_path = _gvn.transform(new IfFalseNode(check));
6717 
6718       { // Slow path: uncommon trap for never seen value and then reexecute
6719         // MethodHandleImpl::profileBoolean() to bump the count, so JIT knows
6720         // the value has been seen at least once.
6721         PreserveJVMState pjvms(this);
6722         PreserveReexecuteState preexecs(this);
6723         jvms()-&gt;set_should_reexecute(true);
6724 
6725         set_control(slow_path);
6726         set_i_o(i_o());
6727 
6728         uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6729                             Deoptimization::Action_reinterpret);
6730       }
6731       // The guard for never seen value enables sharpening of the result and
6732       // returning a constant. It allows to eliminate branches on the same value
6733       // later on.
6734       set_control(fast_path);
6735       result = intcon(expected_val);
6736     }
6737     // Stop profiling.
6738     // MethodHandleImpl::profileBoolean() has profiling logic in its bytecode.
6739     // By replacing method body with profile data (represented as ProfileBooleanNode
6740     // on IR level) we effectively disable profiling.
6741     // It enables full speed execution once optimized code is generated.
6742     Node* profile = _gvn.transform(new ProfileBooleanNode(result, false_cnt, true_cnt));
6743     C-&gt;record_for_igvn(profile);
6744     set_result(profile);
6745     return true;
6746   } else {
6747     // Continue profiling.
6748     // Profile data isn&#39;t available at the moment. So, execute method&#39;s bytecode version.
6749     // Usually, when GWT LambdaForms are profiled it means that a stand-alone nmethod
6750     // is compiled and counters aren&#39;t available since corresponding MethodHandle
6751     // isn&#39;t a compile-time constant.
6752     return false;
6753   }
6754 }
6755 
6756 bool LibraryCallKit::inline_isCompileConstant() {
6757   Node* n = argument(0);
6758   set_result(n-&gt;is_Con() ? intcon(1) : intcon(0));
6759   return true;
6760 }
    </pre>
  </body>
</html>
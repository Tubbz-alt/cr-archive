<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopopts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,14 +38,12 @@</span>
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/movenode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/subtypenode.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-removed">- #if INCLUDE_ZGC</span>
<span class="udiff-line-removed">- #include &quot;gc/z/c2/zBarrierSetC2.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
  
  //=============================================================================
  //------------------------------split_thru_phi---------------------------------
  // Split Node &#39;n&#39; through merge point if there is enough win.
  Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,11 +125,11 @@</span>
        _igvn.set_type(x, t);
        // If x is a TypeNode, capture any more-precise type permanently into Node
        // otherwise it will be not updated during igvn-&gt;transform since
        // igvn-&gt;type(x) is set to x-&gt;Value() already.
        x-&gt;raise_bottom_type(t);
<span class="udiff-line-modified-removed">-       Node *y = _igvn.apply_identity(x);</span>
<span class="udiff-line-modified-added">+       Node* y = x-&gt;Identity(&amp;_igvn);</span>
        if (y != x) {
          wins++;
          x = y;
        } else {
          y = _igvn.hash_find(x);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,11 +320,11 @@</span>
          set_ctrl_and_loop(m, c);
          continue;
        }
        return NULL;
      }
<span class="udiff-line-modified-removed">-     assert(m-&gt;is_Phi() || is_dominator(get_ctrl(m), n_ctrl), &quot;m has strange control&quot;);</span>
<span class="udiff-line-modified-added">+     assert(n-&gt;is_Phi() || m-&gt;is_Phi() || is_dominator(get_ctrl(m), n_ctrl), &quot;m has strange control&quot;);</span>
    }
  
    return n_ctrl;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -499,13 +497,14 @@</span>
    Node * nn = NULL;
    Node * in1 = n-&gt;in(1);
    Node * in2 = n-&gt;in(2);
    if (in1-&gt;Opcode() == Op_MulI &amp;&amp; in2-&gt;Opcode() == Op_MulI) {
      IdealLoopTree* loop_n = get_loop(get_ctrl(n));
<span class="udiff-line-modified-removed">-     if (loop_n-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         Matcher::match_rule_supported(Op_MulAddS2I) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         Matcher::match_rule_supported(Op_MulAddVS2VI)) {</span>
<span class="udiff-line-modified-added">+     if (loop_n-&gt;is_counted() &amp;&amp;</span>
<span class="udiff-line-modified-added">+         loop_n-&gt;_head-&gt;as_Loop()-&gt;is_valid_counted_loop() &amp;&amp;</span>
<span class="udiff-line-modified-added">+         Matcher::match_rule_supported(Op_MulAddVS2VI) &amp;&amp;</span>
<span class="udiff-line-added">+         Matcher::match_rule_supported(Op_MulAddS2I)) {</span>
        Node* mul_in1 = in1-&gt;in(1);
        Node* mul_in2 = in1-&gt;in(2);
        Node* mul_in3 = in2-&gt;in(1);
        Node* mul_in4 = in2-&gt;in(2);
        if (mul_in1-&gt;Opcode() == Op_LoadS &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -651,12 +650,18 @@</span>
          }
        }
      }
    }//for
    Node* bol = iff-&gt;in(1);
<span class="udiff-line-modified-removed">-   assert(bol-&gt;Opcode() == Op_Bool, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   if (bol-&gt;Opcode() == Op_Opaque4) {</span>
<span class="udiff-line-added">+     return NULL; // Ignore loop predicate checks (the Opaque4 ensures they will go away)</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(bol-&gt;Opcode() == Op_Bool, &quot;Unexpected node&quot;);</span>
    int cmp_op = bol-&gt;in(1)-&gt;Opcode();
<span class="udiff-line-added">+   if (cmp_op == Op_SubTypeCheck) { // SubTypeCheck expansion expects an IfNode</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
    // It is expensive to generate flags from a float compare.
    // Avoid duplicated float compare.
    if (phis &gt; 1 &amp;&amp; (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;
  
    float infrequent_prob = PROB_UNLIKELY_MAG(3);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,10 +900,11 @@</span>
            }
            if (mem_ok) {
              // Move the store out of the loop if the LCA of all
              // users (except for the phi) is outside the loop.
              Node* hook = new Node(1);
<span class="udiff-line-added">+             hook-&gt;init_req(0, n_ctrl); // Add an input to prevent hook from being dead</span>
              _igvn.rehash_node_delayed(phi);
              int count = phi-&gt;replace_edge(n, hook);
              assert(count &gt; 0, &quot;inconsistent phi&quot;);
  
              // Compute latest point this store can go
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -939,15 +945,10 @@</span>
  
  //------------------------------split_if_with_blocks_pre-----------------------
  // Do the real work in a non-recursive function.  Data nodes want to be
  // cloned in the pre-order so they can feed each other nicely.
  Node *PhaseIdealLoop::split_if_with_blocks_pre( Node *n ) {
<span class="udiff-line-removed">-   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-removed">-   Node* bs_res = bs-&gt;split_if_pre(this, n);</span>
<span class="udiff-line-removed">-   if (bs_res != NULL) {</span>
<span class="udiff-line-removed">-     return bs_res;</span>
<span class="udiff-line-removed">-   }</span>
    // Cloning these guys is unlikely to win
    int n_op = n-&gt;Opcode();
    if( n_op == Op_MergeMem ) return n;
    if( n-&gt;is_Proj() ) return n;
    // Do not clone-up CmpFXXX variations, as these are always
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1070,35 +1071,25 @@</span>
    // ConvI2LNode may become TOP if the input Value() does not
    // overlap the ConvI2L range, leaving a node which may not dominate its
    // uses.
    // A better fix for this problem can be found in the BugTraq entry, but
    // expediency for Mantis demands this hack.
<span class="udiff-line-modified-removed">-   // 6855164: If the merge point has a FastLockNode with a PhiNode input, we stop</span>
<span class="udiff-line-removed">-   // split_if_with_blocks from splitting a block because we could not move around</span>
<span class="udiff-line-removed">-   // the FastLockNode.</span>
<span class="udiff-line-modified-added">+ #ifdef _LP64</span>
    for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* n = region-&gt;fast_out(i);
      if (n-&gt;is_Phi()) {
        for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
          Node* m = n-&gt;fast_out(j);
<span class="udiff-line-removed">-         if (m-&gt;is_FastLock())</span>
<span class="udiff-line-removed">-           return false;</span>
<span class="udiff-line-removed">- #if INCLUDE_SHENANDOAHGC</span>
<span class="udiff-line-removed">-         if (m-&gt;is_ShenandoahBarrier() &amp;&amp; m-&gt;has_out_with(Op_FastLock)) {</span>
<span class="udiff-line-removed">-           return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
          if (m-&gt;Opcode() == Op_ConvI2L)
            return false;
          if (m-&gt;is_CastII() &amp;&amp; m-&gt;isa_CastII()-&gt;has_range_check()) {
            return false;
          }
<span class="udiff-line-removed">- #endif</span>
        }
      }
    }
<span class="udiff-line-added">+ #endif</span>
    return true;
  }
  
  
  //------------------------------place_near_use---------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1194,19 +1185,35 @@</span>
    }
  
    return true;
  }
  
<span class="udiff-line-added">+ // Detect if the node is the inner strip-mined loop</span>
<span class="udiff-line-added">+ // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop</span>
<span class="udiff-line-added">+ static Node* is_inner_of_stripmined_loop(const Node* out) {</span>
<span class="udiff-line-added">+   Node* out_le = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (out-&gt;is_CountedLoopEnd()) {</span>
<span class="udiff-line-added">+       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {</span>
<span class="udiff-line-added">+         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return out_le;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //------------------------------split_if_with_blocks_post----------------------
  // Do the real work in a non-recursive function.  CFG hackery wants to be
  // in the post-order, so it can dirty the I-DOM info and not use the dirtied
  // info.
<span class="udiff-line-modified-removed">- void PhaseIdealLoop::split_if_with_blocks_post(Node *n, bool last_round) {</span>
<span class="udiff-line-modified-added">+ void PhaseIdealLoop::split_if_with_blocks_post(Node *n) {</span>
  
    // Cloning Cmp through Phi&#39;s involves the split-if transform.
    // FastLock is not used by an If
<span class="udiff-line-modified-removed">-   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock() &amp;&amp; !last_round) {</span>
<span class="udiff-line-modified-added">+   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock()) {</span>
      Node *n_ctrl = get_ctrl(n);
      // Determine if the Node has inputs from some local Phi.
      // Returns the block to clone thru.
      Node *n_blk = has_local_phi_input(n);
      if (n_blk != n_ctrl) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1327,10 +1334,19 @@</span>
        // Now search up IDOMs till cutoff, looking for a dominating test
        Node *prevdom = n;
        Node *dom = idom(prevdom);
        while (dom != cutoff) {
          if (dom-&gt;req() &gt; 1 &amp;&amp; dom-&gt;in(1) == bol &amp;&amp; prevdom-&gt;in(0) == dom) {
<span class="udiff-line-added">+           // It&#39;s invalid to move control dependent data nodes in the inner</span>
<span class="udiff-line-added">+           // strip-mined loop, because:</span>
<span class="udiff-line-added">+           //  1) break validation of LoopNode::verify_strip_mined()</span>
<span class="udiff-line-added">+           //  2) move code with side-effect in strip-mined loop</span>
<span class="udiff-line-added">+           // Move to the exit of outer strip-mined loop in that case.</span>
<span class="udiff-line-added">+           Node* out_le = is_inner_of_stripmined_loop(dom);</span>
<span class="udiff-line-added">+           if (out_le != NULL) {</span>
<span class="udiff-line-added">+             prevdom = out_le;</span>
<span class="udiff-line-added">+           }</span>
            // Replace the dominated test with an obvious true or false.
            // Place it on the IGVN worklist for later cleanup.
            C-&gt;set_major_progress();
            dominated_by(prevdom, n, false, true);
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1372,11 +1388,10 @@</span>
          }
          // If n is a load, and the late control is the same as the current
          // control, then the cloning of n is a pointless exercise, because
          // GVN will ensure that we end up where we started.
          if (!n-&gt;is_Load() || late_load_ctrl != n_ctrl) {
<span class="udiff-line-removed">-           BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
            for (DUIterator_Last jmin, j = n-&gt;last_outs(jmin); j &gt;= jmin; ) {
              Node *u = n-&gt;last_out(j); // Clone private computation per use
              _igvn.rehash_node_delayed(u);
              Node *x = n-&gt;clone(); // Clone computation
              Node *x_ctrl = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1403,14 +1418,10 @@</span>
  
              // Find control for &#39;x&#39; next to use but not inside inner loops.
              // For inner loop uses get the preheader area.
              x_ctrl = place_near_use(x_ctrl);
  
<span class="udiff-line-removed">-             if (bs-&gt;sink_node(this, n, x, x_ctrl, n_ctrl)) {</span>
<span class="udiff-line-removed">-               continue;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
              if (n-&gt;is_Load()) {
                // For loads, add a control edge to a CFG node outside of the loop
                // to force them to not combine and return back inside the loop
                // during GVN optimization (4641526).
                //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1421,22 +1432,35 @@</span>
  
                // Don&#39;t allow the control input to be a CFG splitting node.
                // Such nodes should only have ProjNodes as outs, e.g. IfNode
                // should only have IfTrueNode and IfFalseNode (4985384).
                x_ctrl = find_non_split_ctrl(x_ctrl);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+               IdealLoopTree* x_loop = get_loop(x_ctrl);</span>
<span class="udiff-line-added">+               Node* x_head = x_loop-&gt;_head;</span>
<span class="udiff-line-added">+               if (x_head-&gt;is_Loop() &amp;&amp; (x_head-&gt;is_OuterStripMinedLoop() || x_head-&gt;as_Loop()-&gt;is_strip_mined()) &amp;&amp; is_dominator(n_ctrl, x_head)) {</span>
<span class="udiff-line-added">+                 // Anti dependence analysis is sometimes too</span>
<span class="udiff-line-added">+                 // conservative: a store in the outer strip mined loop</span>
<span class="udiff-line-added">+                 // can prevent a load from floating out of the outer</span>
<span class="udiff-line-added">+                 // strip mined loop but the load may not be referenced</span>
<span class="udiff-line-added">+                 // from the safepoint: loop strip mining verification</span>
<span class="udiff-line-added">+                 // code reports a problem in that case. Make sure the</span>
<span class="udiff-line-added">+                 // load is not moved in the outer strip mined loop in</span>
<span class="udiff-line-added">+                 // that case.</span>
<span class="udiff-line-added">+                 x_ctrl = x_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);</span>
<span class="udiff-line-added">+               }</span>
                assert(dom_depth(n_ctrl) &lt;= dom_depth(x_ctrl), &quot;n is later than its clone&quot;);
  
                x-&gt;set_req(0, x_ctrl);
              }
              register_new_node(x, x_ctrl);
  
              // Some institutional knowledge is needed here: &#39;x&#39; is
              // yanked because if the optimizer runs GVN on it all the
              // cloned x&#39;s will common up and undo this optimization and
<span class="udiff-line-modified-removed">-             // be forced back in the loop.  This is annoying because it</span>
<span class="udiff-line-modified-removed">-             // makes +VerifyOpto report false-positives on progress.  I</span>
<span class="udiff-line-removed">-             // tried setting control edges on the x&#39;s to force them to</span>
<span class="udiff-line-modified-added">+             // be forced back in the loop.</span>
<span class="udiff-line-modified-added">+             // I tried setting control edges on the x&#39;s to force them to</span>
              // not combine, but the matching gets worried when it tries
              // to fold a StoreP and an AddP together (as part of an
              // address expression) and the AddP and StoreP have
              // different controls.
              if (!x-&gt;is_Load() &amp;&amp; !x-&gt;is_DecodeNarrowPtr()) _igvn._worklist.yank(x);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1454,22 +1478,16 @@</span>
    if( n_op == Op_Opaque2 &amp;&amp;
        n-&gt;in(1) != NULL &amp;&amp;
        get_loop(get_ctrl(n)) == get_loop(get_ctrl(n-&gt;in(1))) ) {
      _igvn.replace_node( n, n-&gt;in(1) );
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if INCLUDE_ZGC</span>
<span class="udiff-line-removed">-   if (UseZGC) {</span>
<span class="udiff-line-removed">-     ZBarrierSetC2::loop_optimize_gc_barrier(this, n, last_round);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
  }
  
  //------------------------------split_if_with_blocks---------------------------
  // Check for aggressive application of &#39;split-if&#39; optimization,
  // using basic block level info.
<span class="udiff-line-modified-removed">- void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack, bool last_round) {</span>
<span class="udiff-line-modified-added">+ void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack) {</span>
    Node* root = C-&gt;root();
    visited.set(root-&gt;_idx); // first, mark root as visited
    // Do pre-visit work for root
    Node* n   = split_if_with_blocks_pre(root);
    uint  cnt = n-&gt;outcnt();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1491,11 +1509,11 @@</span>
      }
      else {
        // All of n&#39;s children have been processed, complete post-processing.
        if (cnt != 0 &amp;&amp; !n-&gt;is_Con()) {
          assert(has_node(n), &quot;no dead nodes&quot;);
<span class="udiff-line-modified-removed">-         split_if_with_blocks_post(n, last_round);</span>
<span class="udiff-line-modified-added">+         split_if_with_blocks_post(n);</span>
        }
        if (must_throttle_split_if()) {
          nstack.clear();
        }
        if (nstack.is_empty()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1703,11 +1721,12 @@</span>
      // Check for data-use outside of loop - at least one of OLD or USE
      // must not be a CFG node.
  #ifdef ASSERT
      if (loop-&gt;_head-&gt;as_Loop()-&gt;is_strip_mined() &amp;&amp; outer_loop-&gt;is_member(use_loop) &amp;&amp; !loop-&gt;is_member(use_loop) &amp;&amp; old_new[use-&gt;_idx] == NULL) {
        Node* sfpt = loop-&gt;_head-&gt;as_CountedLoop()-&gt;outer_safepoint();
<span class="udiff-line-modified-removed">-       assert(mode == ControlAroundStripMined &amp;&amp; use == sfpt, &quot;missed a node&quot;);</span>
<span class="udiff-line-modified-added">+       assert(mode != IgnoreStripMined, &quot;incorrect cloning mode&quot;);</span>
<span class="udiff-line-added">+       assert((mode == ControlAroundStripMined &amp;&amp; use == sfpt) || !use-&gt;is_reachable_from_root(), &quot;missed a node&quot;);</span>
      }
  #endif
      if (!loop-&gt;is_member(use_loop) &amp;&amp; !outer_loop-&gt;is_member(use_loop) &amp;&amp; (!old-&gt;is_CFG() || !use-&gt;is_CFG())) {
  
        // If the Data use is an IF, that means we have an IF outside of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2665,11 +2684,11 @@</span>
      }
      set_ctrl(n_clone, use_c);
      assert(!loop-&gt;is_member(get_loop(use_c)), &quot;should be outside loop&quot;);
      get_loop(use_c)-&gt;_body.push(n_clone);
      _igvn.register_new_node_with_optimizer(n_clone);
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
      if (TracePartialPeeling) {
        tty-&gt;print_cr(&quot;loop exit cloning old: %d new: %d newbb: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx, get_ctrl(n_clone)-&gt;_idx);
      }
  #endif
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2702,12 +2721,12 @@</span>
      Node* n_clone = n-&gt;clone();
      loop-&gt;_body.push(n_clone);
      _igvn.register_new_node_with_optimizer(n_clone);
      set_ctrl(n_clone, get_ctrl(n));
      sink_list.push(n_clone);
<span class="udiff-line-modified-removed">-     not_peel &lt;&lt;= n_clone-&gt;_idx;  // add n_clone to not_peel set.</span>
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+     not_peel.set(n_clone-&gt;_idx);</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
      if (TracePartialPeeling) {
        tty-&gt;print_cr(&quot;special not_peeled cloning old: %d new: %d&quot;, n-&gt;_idx, n_clone-&gt;_idx);
      }
  #endif
      while( worklist.size() ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3032,28 +3051,28 @@</span>
  //
  bool PhaseIdealLoop::partial_peel( IdealLoopTree *loop, Node_List &amp;old_new ) {
  
    assert(!loop-&gt;_head-&gt;is_CountedLoop(), &quot;Non-counted loop only&quot;);
    if (!loop-&gt;_head-&gt;is_Loop()) {
<span class="udiff-line-modified-removed">-     return false;  }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   LoopNode *head  = loop-&gt;_head-&gt;as_Loop();</span>
<span class="udiff-line-modified-added">+     return false;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   LoopNode *head = loop-&gt;_head-&gt;as_Loop();</span>
  
    if (head-&gt;is_partial_peel_loop() || head-&gt;partial_peel_has_failed()) {
      return false;
    }
  
    // Check for complex exit control
<span class="udiff-line-modified-removed">-   for(uint ii = 0; ii &lt; loop-&gt;_body.size(); ii++ ) {</span>
<span class="udiff-line-modified-added">+   for (uint ii = 0; ii &lt; loop-&gt;_body.size(); ii++) {</span>
      Node *n = loop-&gt;_body.at(ii);
      int opc = n-&gt;Opcode();
      if (n-&gt;is_Call()        ||
          opc == Op_Catch     ||
          opc == Op_CatchProj ||
          opc == Op_Jump      ||
          opc == Op_JumpProj) {
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
        if (TracePartialPeeling) {
          tty-&gt;print_cr(&quot;\nExit control too complex: lp: %d&quot;, head-&gt;_idx);
        }
  #endif
        return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3068,16 +3087,16 @@</span>
    // which is executed on every path thru loop.
    IfNode *peel_if = NULL;
    IfNode *peel_if_cmpu = NULL;
  
    Node *iff = loop-&gt;tail();
<span class="udiff-line-modified-removed">-   while( iff != head ) {</span>
<span class="udiff-line-modified-removed">-     if( iff-&gt;is_If() ) {</span>
<span class="udiff-line-modified-added">+   while (iff != head) {</span>
<span class="udiff-line-modified-added">+     if (iff-&gt;is_If()) {</span>
        Node *ctrl = get_ctrl(iff-&gt;in(1));
        if (ctrl-&gt;is_top()) return false; // Dead test on live IF.
        // If loop-varying exit-test, check for induction variable
<span class="udiff-line-modified-removed">-       if( loop-&gt;is_member(get_loop(ctrl)) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       if (loop-&gt;is_member(get_loop(ctrl)) &amp;&amp;</span>
            loop-&gt;is_loop_exit(iff) &amp;&amp;
            is_possible_iv_test(iff)) {
          Node* cmp = iff-&gt;in(1)-&gt;in(1);
          if (cmp-&gt;Opcode() == Op_CmpI) {
            peel_if = iff-&gt;as_If();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3087,10 +3106,11 @@</span>
          }
        }
      }
      iff = idom(iff);
    }
<span class="udiff-line-added">+ </span>
    // Prefer signed compare over unsigned compare.
    IfNode* new_peel_if = NULL;
    if (peel_if == NULL) {
      if (!PartialPeelAtUnsignedTests || peel_if_cmpu == NULL) {
        return false;   // No peel point found
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3105,11 +3125,11 @@</span>
    Node* first_not_peeled = stay_in_loop(last_peel, loop);
    if (first_not_peeled == NULL || first_not_peeled == head) {
      return false;
    }
  
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
    if (TraceLoopOpts) {
      tty-&gt;print(&quot;PartialPeel  &quot;);
      loop-&gt;dump_head();
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3134,10 +3154,15 @@</span>
    VectorSet not_peel(area);
    Node_List peel_list(area);
    Node_List worklist(area);
    Node_List sink_list(area);
  
<span class="udiff-line-added">+   uint estimate = loop-&gt;est_loop_clone_sz(1);</span>
<span class="udiff-line-added">+   if (exceeding_node_budget(estimate)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Set of cfg nodes to peel are those that are executable from
    // the head through last_peel.
    assert(worklist.size() == 0, &quot;should be empty&quot;);
    worklist.push(head);
    peel.set(head-&gt;_idx);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3155,12 +3180,11 @@</span>
      }
    }
  
    // Set of non-cfg nodes to peel are those that are control
    // dependent on the cfg nodes.
<span class="udiff-line-modified-removed">-   uint i;</span>
<span class="udiff-line-removed">-   for(i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
<span class="udiff-line-modified-added">+   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
      Node *n = loop-&gt;_body.at(i);
      Node *n_c = has_ctrl(n) ? get_ctrl(n) : n;
      if (peel.test(n_c-&gt;_idx)) {
        peel.set(n-&gt;_idx);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3171,74 +3195,74 @@</span>
    // Step 2: move operations from the peeled section down into the
    //         not-peeled section
  
    // Get a post order schedule of nodes in the peel region
    // Result in right-most operand.
<span class="udiff-line-modified-removed">-   scheduled_nodelist(loop, peel, peel_list );</span>
<span class="udiff-line-modified-added">+   scheduled_nodelist(loop, peel, peel_list);</span>
  
    assert(is_valid_loop_partition(loop, peel, peel_list, not_peel), &quot;bad partition&quot;);
  
    // For future check for too many new phis
    uint old_phi_cnt = 0;
    for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
      Node* use = head-&gt;fast_out(j);
      if (use-&gt;is_Phi()) old_phi_cnt++;
    }
  
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
    if (TracePartialPeeling) {
      tty-&gt;print_cr(&quot;\npeeled list&quot;);
    }
  #endif
  
    // Evacuate nodes in peel region into the not_peeled region if possible
    uint new_phi_cnt = 0;
    uint cloned_for_outside_use = 0;
<span class="udiff-line-modified-removed">-   for (i = 0; i &lt; peel_list.size();) {</span>
<span class="udiff-line-modified-added">+   for (uint i = 0; i &lt; peel_list.size();) {</span>
      Node* n = peel_list.at(i);
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
    if (TracePartialPeeling) n-&gt;dump();
  #endif
      bool incr = true;
<span class="udiff-line-modified-removed">-     if ( !n-&gt;is_CFG() ) {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-       if ( has_use_in_set(n, not_peel) ) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     if (!n-&gt;is_CFG()) {</span>
<span class="udiff-line-modified-added">+       if (has_use_in_set(n, not_peel)) {</span>
          // If not used internal to the peeled region,
          // move &quot;n&quot; from peeled to not_peeled region.
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         if ( !has_use_internal_to_set(n, peel, loop) ) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+         if (!has_use_internal_to_set(n, peel, loop)) {</span>
            // if not pinned and not a load (which maybe anti-dependent on a store)
            // and not a CMove (Matcher expects only bool-&gt;cmove).
<span class="udiff-line-modified-removed">-           if (n-&gt;in(0) == NULL &amp;&amp; !n-&gt;is_Load() &amp;&amp; !n-&gt;is_CMove() &amp;&amp; n-&gt;Opcode() != Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-modified-removed">-             cloned_for_outside_use += clone_for_use_outside_loop( loop, n, worklist );</span>
<span class="udiff-line-modified-added">+           if (n-&gt;in(0) == NULL &amp;&amp; !n-&gt;is_Load() &amp;&amp; !n-&gt;is_CMove()) {</span>
<span class="udiff-line-modified-added">+             cloned_for_outside_use += clone_for_use_outside_loop(loop, n, worklist);</span>
              sink_list.push(n);
<span class="udiff-line-modified-removed">-             peel     &gt;&gt;= n-&gt;_idx; // delete n from peel set.</span>
<span class="udiff-line-modified-removed">-             not_peel &lt;&lt;= n-&gt;_idx; // add n to not_peel set.</span>
<span class="udiff-line-modified-added">+             peel.remove(n-&gt;_idx);</span>
<span class="udiff-line-modified-added">+             not_peel.set(n-&gt;_idx);</span>
              peel_list.remove(i);
              incr = false;
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
              if (TracePartialPeeling) {
                tty-&gt;print_cr(&quot;sink to not_peeled region: %d newbb: %d&quot;,
                              n-&gt;_idx, get_ctrl(n)-&gt;_idx);
              }
  #endif
            }
          } else {
            // Otherwise check for special def-use cases that span
            // the peel/not_peel boundary such as bool-&gt;if
<span class="udiff-line-modified-removed">-           clone_for_special_use_inside_loop( loop, n, not_peel, sink_list, worklist );</span>
<span class="udiff-line-modified-added">+           clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);</span>
            new_phi_cnt++;
          }
        }
      }
      if (incr) i++;
    }
  
<span class="udiff-line-modified-removed">-   if (new_phi_cnt &gt; old_phi_cnt + PartialPeelNewPhiDelta) {</span>
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+   estimate += cloned_for_outside_use + new_phi_cnt;</span>
<span class="udiff-line-modified-added">+   bool exceed_node_budget = !may_require_nodes(estimate);</span>
<span class="udiff-line-added">+   bool exceed_phi_limit = new_phi_cnt &gt; old_phi_cnt + PartialPeelNewPhiDelta;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (exceed_node_budget || exceed_phi_limit) {</span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
      if (TracePartialPeeling) {
        tty-&gt;print_cr(&quot;\nToo many new phis: %d  old %d new cmpi: %c&quot;,
                      new_phi_cnt, old_phi_cnt, new_peel_if != NULL?&#39;T&#39;:&#39;F&#39;);
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3281,19 +3305,19 @@</span>
  
    clone_loop(loop, old_new, dd, IgnoreStripMined);
  
    const uint clone_exit_idx = 1;
    const uint orig_exit_idx  = 2;
<span class="udiff-line-modified-removed">-   assert(is_valid_clone_loop_form( loop, peel_list, orig_exit_idx, clone_exit_idx ), &quot;bad clone loop&quot;);</span>
<span class="udiff-line-modified-added">+   assert(is_valid_clone_loop_form(loop, peel_list, orig_exit_idx, clone_exit_idx), &quot;bad clone loop&quot;);</span>
  
    Node* head_clone             = old_new[head-&gt;_idx];
    LoopNode* new_head_clone     = old_new[new_head-&gt;_idx]-&gt;as_Loop();
    Node* orig_tail_clone        = head_clone-&gt;in(2);
  
    // Add phi if &quot;def&quot; node is in peel set and &quot;use&quot; is not
  
<span class="udiff-line-modified-removed">-   for(i = 0; i &lt; peel_list.size(); i++ ) {</span>
<span class="udiff-line-modified-added">+   for (uint i = 0; i &lt; peel_list.size(); i++) {</span>
      Node *def  = peel_list.at(i);
      if (!def-&gt;is_CFG()) {
        for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
          Node *use = def-&gt;fast_out(j);
          if (has_node(use) &amp;&amp; use-&gt;in(0) != C-&gt;top() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3345,11 +3369,11 @@</span>
    //          cloned-peeled    &lt;---+
    //    new_head_clone:            |    &lt;--+
    //          cloned-not_peeled  in(0)    in(0)
    //          orig-peeled
  
<span class="udiff-line-modified-removed">-   for(i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
<span class="udiff-line-modified-added">+   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
      Node *n = loop-&gt;_body.at(i);
      if (!n-&gt;is_CFG()           &amp;&amp; n-&gt;in(0) != NULL        &amp;&amp;
          not_peel.test(n-&gt;_idx) &amp;&amp; peel.test(n-&gt;in(0)-&gt;_idx)) {
        Node* n_clone = old_new[n-&gt;_idx];
        _igvn.replace_input_of(n_clone, 0, new_head_clone);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3392,11 +3416,11 @@</span>
    // Inhibit more partial peeling on this loop
    new_head_clone-&gt;set_partial_peel_loop();
    C-&gt;set_major_progress();
    loop-&gt;record_for_igvn();
  
<span class="udiff-line-modified-removed">- #if !defined(PRODUCT)</span>
<span class="udiff-line-modified-added">+ #ifndef PRODUCT</span>
    if (TracePartialPeeling) {
      tty-&gt;print_cr(&quot;\nafter partial peel one iteration&quot;);
      Node_List wl(area);
      Node* t = last_peel;
      while (true) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3432,14 +3456,14 @@</span>
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
    CountedLoopEndNode *cle = cl-&gt;loopexit();
    Node *exit = cle-&gt;proj_out(false);
    Node *phi = cl-&gt;phi();
  
<span class="udiff-line-modified-removed">-   // Check for the special case of folks using the pre-incremented</span>
<span class="udiff-line-modified-removed">-   // trip-counter on the fall-out path (forces the pre-incremented</span>
<span class="udiff-line-modified-removed">-   // and post-incremented trip counter to be live at the same time).</span>
<span class="udiff-line-modified-removed">-   // Fix this by adjusting to use the post-increment trip counter.</span>
<span class="udiff-line-modified-added">+   // Check for the special case when using the pre-incremented trip-counter on</span>
<span class="udiff-line-modified-added">+   // the fall-out  path (forces the pre-incremented  and post-incremented trip</span>
<span class="udiff-line-modified-added">+   // counter to be live  at the same time).  Fix this by  adjusting to use the</span>
<span class="udiff-line-modified-added">+   // post-increment trip counter.</span>
  
    bool progress = true;
    while (progress) {
      progress = false;
      for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
</pre>
<center><a href="loopnode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
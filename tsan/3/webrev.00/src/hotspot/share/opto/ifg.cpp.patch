diff a/src/hotspot/share/opto/ifg.cpp b/src/hotspot/share/opto/ifg.cpp
--- a/src/hotspot/share/opto/ifg.cpp
+++ b/src/hotspot/share/opto/ifg.cpp
@@ -78,15 +78,17 @@
 // Convert triangular matrix to square matrix
 void PhaseIFG::SquareUp() {
   assert( !_is_square, "only on triangular" );
 
   // Simple transpose
-  for( uint i = 0; i < _maxlrg; i++ ) {
-    IndexSetIterator elements(&_adjs[i]);
-    uint datum;
-    while ((datum = elements.next()) != 0) {
-      _adjs[datum].insert( i );
+  for(uint i = 0; i < _maxlrg; i++ ) {
+    if (!_adjs[i].is_empty()) {
+      IndexSetIterator elements(&_adjs[i]);
+      uint datum;
+      while ((datum = elements.next()) != 0) {
+        _adjs[datum].insert(i);
+      }
     }
   }
   _is_square = true;
 }
 
@@ -106,20 +108,22 @@
   //return _adjs[a].unordered_member(b);
   return _adjs[a].member(b);
 }
 
 // Union edges of B into A
-void PhaseIFG::Union( uint a, uint b ) {
+void PhaseIFG::Union(uint a, uint b) {
   assert( _is_square, "only on square" );
   IndexSet *A = &_adjs[a];
-  IndexSetIterator b_elements(&_adjs[b]);
-  uint datum;
-  while ((datum = b_elements.next()) != 0) {
-    if(A->insert(datum)) {
-      _adjs[datum].insert(a);
-      lrgs(a).invalid_degree();
-      lrgs(datum).invalid_degree();
+  if (!_adjs[b].is_empty()) {
+    IndexSetIterator b_elements(&_adjs[b]);
+    uint datum;
+    while ((datum = b_elements.next()) != 0) {
+      if (A->insert(datum)) {
+        _adjs[datum].insert(a);
+        lrgs(a).invalid_degree();
+        lrgs(datum).invalid_degree();
+      }
     }
   }
 }
 
 // Yank a Node and all connected edges from the IFG.  Return a
@@ -128,25 +132,30 @@
   assert( _is_square, "only on square" );
   assert( !_yanked->test(a), "" );
   _yanked->set(a);
 
   // I remove the LRG from all neighbors.
-  IndexSetIterator elements(&_adjs[a]);
   LRG &lrg_a = lrgs(a);
-  uint datum;
-  while ((datum = elements.next()) != 0) {
-    _adjs[datum].remove(a);
-    lrgs(datum).inc_degree( -lrg_a.compute_degree(lrgs(datum)) );
+
+  if (!_adjs[a].is_empty()) {
+    IndexSetIterator elements(&_adjs[a]);
+    uint datum;
+    while ((datum = elements.next()) != 0) {
+      _adjs[datum].remove(a);
+      lrgs(datum).inc_degree(-lrg_a.compute_degree(lrgs(datum)));
+    }
   }
   return neighbors(a);
 }
 
 // Re-insert a yanked Node.
-void PhaseIFG::re_insert( uint a ) {
+void PhaseIFG::re_insert(uint a) {
   assert( _is_square, "only on square" );
   assert( _yanked->test(a), "" );
-  (*_yanked) >>= a;
+  _yanked->remove(a);
+
+  if (_adjs[a].is_empty()) return;
 
   IndexSetIterator elements(&_adjs[a]);
   uint datum;
   while ((datum = elements.next()) != 0) {
     _adjs[datum].insert(a);
@@ -157,11 +166,11 @@
 // Compute the degree between 2 live ranges.  If both live ranges are
 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
 // MULTIPLY the sizes.  Inspect Brigg's thesis on register pairs to see why
 // this is so.
-int LRG::compute_degree( LRG &l ) const {
+int LRG::compute_degree(LRG &l) const {
   int tmp;
   int num_regs = _num_regs;
   int nregs = l.num_regs();
   tmp =  (_fat_proj || l._fat_proj)     // either is a fat-proj?
     ? (num_regs * nregs)                // then use product
@@ -172,18 +181,19 @@
 // Compute effective degree for this live range.  If both live ranges are
 // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
 // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
 // MULTIPLY the sizes.  Inspect Brigg's thesis on register pairs to see why
 // this is so.
-int PhaseIFG::effective_degree( uint lidx ) const {
+int PhaseIFG::effective_degree(uint lidx) const {
+  IndexSet *s = neighbors(lidx);
+  if (s->is_empty()) return 0;
   int eff = 0;
   int num_regs = lrgs(lidx).num_regs();
   int fat_proj = lrgs(lidx)._fat_proj;
-  IndexSet *s = neighbors(lidx);
   IndexSetIterator elements(s);
   uint nidx;
-  while((nidx = elements.next()) != 0) {
+  while ((nidx = elements.next()) != 0) {
     LRG &lrgn = lrgs(nidx);
     int nregs = lrgn.num_regs();
     eff += (fat_proj || lrgn._fat_proj) // either is a fat-proj?
       ? (num_regs * nregs)              // then use product
       : MAX2(num_regs,nregs);           // else use max
@@ -194,39 +204,43 @@
 
 #ifndef PRODUCT
 void PhaseIFG::dump() const {
   tty->print_cr("-- Interference Graph --%s--",
                 _is_square ? "square" : "triangular" );
-  if( _is_square ) {
-    for( uint i = 0; i < _maxlrg; i++ ) {
-      tty->print( (*_yanked)[i] ? "XX " : "  ");
+  if (_is_square) {
+    for (uint i = 0; i < _maxlrg; i++) {
+      tty->print(_yanked->test(i) ? "XX " : "  ");
       tty->print("L%d: { ",i);
-      IndexSetIterator elements(&_adjs[i]);
-      uint datum;
-      while ((datum = elements.next()) != 0) {
-        tty->print("L%d ", datum);
+      if (!_adjs[i].is_empty()) {
+        IndexSetIterator elements(&_adjs[i]);
+        uint datum;
+        while ((datum = elements.next()) != 0) {
+          tty->print("L%d ", datum);
+        }
       }
       tty->print_cr("}");
 
     }
     return;
   }
 
   // Triangular
   for( uint i = 0; i < _maxlrg; i++ ) {
     uint j;
-    tty->print( (*_yanked)[i] ? "XX " : "  ");
+    tty->print(_yanked->test(i) ? "XX " : "  ");
     tty->print("L%d: { ",i);
     for( j = _maxlrg; j > i; j-- )
       if( test_edge(j - 1,i) ) {
         tty->print("L%d ",j - 1);
       }
     tty->print("| ");
-    IndexSetIterator elements(&_adjs[i]);
-    uint datum;
-    while ((datum = elements.next()) != 0) {
-      tty->print("L%d ", datum);
+    if (!_adjs[i].is_empty()) {
+      IndexSetIterator elements(&_adjs[i]);
+      uint datum;
+      while ((datum = elements.next()) != 0) {
+        tty->print("L%d ", datum);
+      }
     }
     tty->print("}\n");
   }
   tty->print("\n");
 }
@@ -247,22 +261,24 @@
 }
 
 void PhaseIFG::verify( const PhaseChaitin *pc ) const {
   // IFG is square, sorted and no need for Find
   for( uint i = 0; i < _maxlrg; i++ ) {
-    assert(!((*_yanked)[i]) || !neighbor_cnt(i), "Is removed completely" );
+    assert(!_yanked->test(i) || !neighbor_cnt(i), "Is removed completely" );
     IndexSet *set = &_adjs[i];
-    IndexSetIterator elements(set);
-    uint idx;
-    uint last = 0;
-    while ((idx = elements.next()) != 0) {
-      assert(idx != i, "Must have empty diagonal");
-      assert(pc->_lrg_map.find_const(idx) == idx, "Must not need Find");
-      assert(_adjs[idx].member(i), "IFG not square");
-      assert(!(*_yanked)[idx], "No yanked neighbors");
-      assert(last < idx, "not sorted increasing");
-      last = idx;
+    if (!set->is_empty()) {
+      IndexSetIterator elements(set);
+      uint idx;
+      uint last = 0;
+      while ((idx = elements.next()) != 0) {
+        assert(idx != i, "Must have empty diagonal");
+        assert(pc->_lrg_map.find_const(idx) == idx, "Must not need Find");
+        assert(_adjs[idx].member(i), "IFG not square");
+        assert(!_yanked->test(idx), "No yanked neighbors");
+        assert(last < idx, "not sorted increasing");
+        last = idx;
+      }
     }
     assert(!lrgs(i)._degree_valid || effective_degree(i) == lrgs(i).degree(), "degree is valid but wrong");
   }
 }
 #endif
@@ -271,20 +287,22 @@
  * Interfere this register with everything currently live.
  * Check for interference by checking overlap of regmasks.
  * Only interfere if acceptable register masks overlap.
  */
 void PhaseChaitin::interfere_with_live(uint lid, IndexSet* liveout) {
-  LRG& lrg = lrgs(lid);
-  const RegMask& rm = lrg.mask();
-  IndexSetIterator elements(liveout);
-  uint interfering_lid = elements.next();
-  while (interfering_lid != 0) {
-    LRG& interfering_lrg = lrgs(interfering_lid);
-    if (rm.overlap(interfering_lrg.mask())) {
-      _ifg->add_edge(lid, interfering_lid);
+  if (!liveout->is_empty()) {
+    LRG& lrg = lrgs(lid);
+    const RegMask &rm = lrg.mask();
+    IndexSetIterator elements(liveout);
+    uint interfering_lid = elements.next();
+    while (interfering_lid != 0) {
+      LRG& interfering_lrg = lrgs(interfering_lid);
+      if (rm.overlap(interfering_lrg.mask())) {
+        _ifg->add_edge(lid, interfering_lid);
+      }
+      interfering_lid = elements.next();
     }
-    interfering_lid = elements.next();
   }
 }
 
 // Actually build the interference graph.  Uses virtual registers only, no
 // physical register masks.  This allows me to be very aggressive when
@@ -379,10 +397,13 @@
   } // End of forall blocks
 }
 
 #ifdef ASSERT
 uint PhaseChaitin::count_int_pressure(IndexSet* liveout) {
+  if (liveout->is_empty()) {
+    return 0;
+  }
   IndexSetIterator elements(liveout);
   uint lidx = elements.next();
   uint cnt = 0;
   while (lidx != 0) {
     LRG& lrg = lrgs(lidx);
@@ -395,10 +416,13 @@
   }
   return cnt;
 }
 
 uint PhaseChaitin::count_float_pressure(IndexSet* liveout) {
+  if (liveout->is_empty()) {
+    return 0;
+  }
   IndexSetIterator elements(liveout);
   uint lidx = elements.next();
   uint cnt = 0;
   while (lidx != 0) {
     LRG& lrg = lrgs(lidx);
@@ -492,17 +516,19 @@
  * We add the cost for the whole block to the area of the live ranges initially.
  * If a live range gets killed in the block, we'll subtract the unused part of
  * the block from the area.
  */
 void PhaseChaitin::compute_initial_block_pressure(Block* b, IndexSet* liveout, Pressure& int_pressure, Pressure& float_pressure, double cost) {
-  IndexSetIterator elements(liveout);
-  uint lid = elements.next();
-  while (lid != 0) {
-    LRG& lrg = lrgs(lid);
-    lrg._area += cost;
-    raise_pressure(b, lrg, int_pressure, float_pressure);
-    lid = elements.next();
+  if (!liveout->is_empty()) {
+    IndexSetIterator elements(liveout);
+    uint lid = elements.next();
+    while (lid != 0) {
+      LRG &lrg = lrgs(lid);
+      lrg._area += cost;
+      raise_pressure(b, lrg, int_pressure, float_pressure);
+      lid = elements.next();
+    }
   }
   assert(int_pressure.current_pressure() == count_int_pressure(liveout), "the int pressure is incorrect");
   assert(float_pressure.current_pressure() == count_float_pressure(liveout), "the float pressure is incorrect");
 }
 
@@ -510,17 +536,19 @@
 * Computes the entry register pressure of a block, looking at all live
 * ranges in the livein. The register pressure is computed for both float
 * and int/pointer registers.
 */
 void PhaseChaitin::compute_entry_block_pressure(Block* b) {
-  IndexSet* livein = _live->livein(b);
-  IndexSetIterator elements(livein);
-  uint lid = elements.next();
-  while (lid != 0) {
-    LRG& lrg = lrgs(lid);
-    raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
-    lid = elements.next();
+  IndexSet *livein = _live->livein(b);
+  if (!livein->is_empty()) {
+    IndexSetIterator elements(livein);
+    uint lid = elements.next();
+    while (lid != 0) {
+      LRG &lrg = lrgs(lid);
+      raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
+      lid = elements.next();
+    }
   }
   // Now check phis for locally defined inputs
   for (uint j = 0; j < b->number_of_nodes(); j++) {
     Node* n = b->get_node(j);
     if (n->is_Phi()) {
@@ -544,19 +572,22 @@
 * Computes the exit register pressure of a block, looking at all live
 * ranges in the liveout. The register pressure is computed for both float
 * and int/pointer registers.
 */
 void PhaseChaitin::compute_exit_block_pressure(Block* b) {
+
   IndexSet* livein = _live->live(b);
-  IndexSetIterator elements(livein);
   _sched_int_pressure.set_current_pressure(0);
   _sched_float_pressure.set_current_pressure(0);
-  uint lid = elements.next();
-  while (lid != 0) {
-    LRG& lrg = lrgs(lid);
-    raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
-    lid = elements.next();
+  if (!livein->is_empty()) {
+    IndexSetIterator elements(livein);
+    uint lid = elements.next();
+    while (lid != 0) {
+      LRG &lrg = lrgs(lid);
+      raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);
+      lid = elements.next();
+    }
   }
 }
 
 /*
  * Remove dead node if it's not used.
@@ -652,10 +683,11 @@
 /*
  * The defined value must go in a particular register. Remove that register from
  * all conflicting parties and avoid the interference.
  */
 void PhaseChaitin::remove_bound_register_from_interfering_live_ranges(LRG& lrg, IndexSet* liveout, uint& must_spill) {
+  if (liveout->is_empty()) return;
   // Check for common case
   const RegMask& rm = lrg.mask();
   int r_size = lrg.num_regs();
   // Smear odd bits
   IndexSetIterator elements(liveout);
@@ -831,11 +863,11 @@
 
     for (uint location = last_inst; location > 0; location--) {
       Node* n = block->get_node(location);
       uint lid = _lrg_map.live_range_id(n);
 
-      if(lid) {
+      if (lid) {
         LRG& lrg = lrgs(lid);
 
         // A DEF normally costs block frequency; rematerialized values are
         // removed from the DEF sight, so LOWER costs here.
         lrg._cost += n->rematerialize() ? 0 : block->_freq;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="machnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 159,11 ***</span>
    // Return the method&#39;s address
    virtual intptr_t  method() const;
  
    // Hash and compare over operands are currently identical
    virtual uint  hash() const;
<span class="line-modified">!   virtual uint  cmp( const MachOper &amp;oper ) const;</span>
  
    // Virtual clone, since I do not know how big the MachOper is.
    virtual MachOper *clone() const = 0;
  
    // Return ideal Type from simple operands.  Fail for complex operands.
<span class="line-new-header">--- 159,11 ---</span>
    // Return the method&#39;s address
    virtual intptr_t  method() const;
  
    // Hash and compare over operands are currently identical
    virtual uint  hash() const;
<span class="line-modified">!   virtual bool  cmp( const MachOper &amp;oper ) const;</span>
  
    // Virtual clone, since I do not know how big the MachOper is.
    virtual MachOper *clone() const = 0;
  
    // Return ideal Type from simple operands.  Fail for complex operands.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
  //------------------------------MachNode---------------------------------------
  // Base type for all machine specific nodes.  All node classes generated by the
  // ADLC inherit from this class.
  class MachNode : public Node {
  public:
<span class="line-modified">!   MachNode() : Node((uint)0), _num_opnds(0), _opnds(NULL) {</span>
      init_class_id(Class_Mach);
    }
    // Required boilerplate
    virtual uint size_of() const { return sizeof(MachNode); }
    virtual int  Opcode() const;          // Always equal to MachNode
<span class="line-new-header">--- 195,11 ---</span>
  //------------------------------MachNode---------------------------------------
  // Base type for all machine specific nodes.  All node classes generated by the
  // ADLC inherit from this class.
  class MachNode : public Node {
  public:
<span class="line-modified">!   MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {</span>
      init_class_id(Class_Mach);
    }
    // Required boilerplate
    virtual uint size_of() const { return sizeof(MachNode); }
    virtual int  Opcode() const;          // Always equal to MachNode
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,10 ***</span>
<span class="line-new-header">--- 209,13 ---</span>
    virtual uint oper_input_base() const { return 1; }
    // Position of constant base node in node&#39;s inputs. -1 if
    // no constant base node input.
    virtual uint mach_constant_base_node_input() const { return (uint)-1; }
  
<span class="line-added">+   uint8_t barrier_data() const { return _barrier; }</span>
<span class="line-added">+   void set_barrier_data(uint data) { _barrier = data; }</span>
<span class="line-added">+ </span>
    // Copy inputs and operands to new node of instruction.
    // Called from cisc_version() and short_branch_version().
    // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
    void fill_new_machnode(MachNode *n) const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,10 ***</span>
<span class="line-new-header">--- 241,11 ---</span>
    bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
  
    // First index in _in[] corresponding to operand, or -1 if there is none
    int  operand_index(uint operand) const;
    int  operand_index(const MachOper *oper) const;
<span class="line-added">+   int  operand_index(Node* m) const;</span>
  
    // Register class input is expected in
    virtual const RegMask &amp;in_RegMask(uint) const;
  
    // cisc-spillable instructions redefine for use by in_RegMask
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,10 ***</span>
<span class="line-new-header">--- 257,13 ---</span>
    // same singleton regiser (e.g., Intel IDIV which binds AX to be
    // both an input and an output).  It is nessecary when the input and
    // output have choices - but they must use the same choice.
    virtual uint two_adr( ) const { return 0; }
  
<span class="line-added">+   // The GC might require some barrier metadata for machine code emission.</span>
<span class="line-added">+   uint8_t _barrier;</span>
<span class="line-added">+ </span>
    // Array of complex operand pointers.  Each corresponds to zero or
    // more leafs.  Must be set by MachNode constructor to point to an
    // internal array of MachOpers.  The MachOper array is sized by
    // specific MachNodes described in the ADL.
    uint _num_opnds;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,20 ***</span>
    // Return number of words used for double constants in this instruction
    virtual int   ins_num_consts() const { return 0; }
  
    // Hash and compare over operands.  Used to do GVN on machine Nodes.
    virtual uint  hash() const;
<span class="line-modified">!   virtual uint  cmp( const Node &amp;n ) const;</span>
  
    // Expand method for MachNode, replaces nodes representing pseudo
    // instructions with a set of nodes which represent real machine
    // instructions and compute the same value.
    virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
  
    // Bottom_type call; value comes from operand0
    virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
<span class="line-modified">!   virtual uint ideal_reg() const { const Type *t = _opnds[0]-&gt;type(); return t == TypeInt::CC ? Op_RegFlags : t-&gt;ideal_reg(); }</span>
  
    // If this is a memory op, return the base pointer and fixed offset.
    // If there are no such, return NULL.  If there are multiple addresses
    // or the address is indeterminate (rare cases) then return (Node*)-1,
    // which serves as node bottom.
<span class="line-new-header">--- 297,27 ---</span>
    // Return number of words used for double constants in this instruction
    virtual int   ins_num_consts() const { return 0; }
  
    // Hash and compare over operands.  Used to do GVN on machine Nodes.
    virtual uint  hash() const;
<span class="line-modified">!   virtual bool  cmp( const Node &amp;n ) const;</span>
  
    // Expand method for MachNode, replaces nodes representing pseudo
    // instructions with a set of nodes which represent real machine
    // instructions and compute the same value.
    virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
  
    // Bottom_type call; value comes from operand0
    virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
<span class="line-modified">!   virtual uint ideal_reg() const {</span>
<span class="line-added">+     const Type *t = _opnds[0]-&gt;type();</span>
<span class="line-added">+     if (t == TypeInt::CC) {</span>
<span class="line-added">+       return Op_RegFlags;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       return t-&gt;ideal_reg();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
    // If this is a memory op, return the base pointer and fixed offset.
    // If there are no such, return NULL.  If there are multiple addresses
    // or the address is indeterminate (rare cases) then return (Node*)-1,
    // which serves as node bottom.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 859,11 ***</span>
  //------------------------------MachCallNode----------------------------------
  // Machine-specific versions of subroutine calls
  class MachCallNode : public MachSafePointNode {
  protected:
    virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const = 0; // Size is bigger
  public:
    const TypeFunc *_tf;        // Function type
    address      _entry_point;  // Address of the method being called
    float        _cnt;          // Estimate of number of times called
<span class="line-new-header">--- 873,11 ---</span>
  //------------------------------MachCallNode----------------------------------
  // Machine-specific versions of subroutine calls
  class MachCallNode : public MachSafePointNode {
  protected:
    virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const = 0; // Size is bigger
  public:
    const TypeFunc *_tf;        // Function type
    address      _entry_point;  // Address of the method being called
    float        _cnt;          // Estimate of number of times called
</pre>
<hr />
<pre>
<span class="line-old-header">*** 902,11 ***</span>
  
  //------------------------------MachCallJavaNode------------------------------
  // &quot;Base&quot; class for machine-specific versions of subroutine calls
  class MachCallJavaNode : public MachCallNode {
  protected:
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    ciMethod* _method;                 // Method being direct called
    bool      _override_symbolic_info; // Override symbolic call site info from bytecode
    int       _bci;                    // Byte Code index of call byte code
<span class="line-new-header">--- 916,11 ---</span>
  
  //------------------------------MachCallJavaNode------------------------------
  // &quot;Base&quot; class for machine-specific versions of subroutine calls
  class MachCallJavaNode : public MachCallNode {
  protected:
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    ciMethod* _method;                 // Method being direct called
    bool      _override_symbolic_info; // Override symbolic call site info from bytecode
    int       _bci;                    // Byte Code index of call byte code
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,11 ***</span>
  };
  
  //------------------------------MachCallStaticJavaNode------------------------
  // Machine-specific versions of monomorphic subroutine calls
  class MachCallStaticJavaNode : public MachCallJavaNode {
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    const char *_name;            // Runtime wrapper name
    MachCallStaticJavaNode() : MachCallJavaNode() {
      init_class_id(Class_MachCallStaticJava);
<span class="line-new-header">--- 949,11 ---</span>
  };
  
  //------------------------------MachCallStaticJavaNode------------------------
  // Machine-specific versions of monomorphic subroutine calls
  class MachCallStaticJavaNode : public MachCallJavaNode {
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    const char *_name;            // Runtime wrapper name
    MachCallStaticJavaNode() : MachCallJavaNode() {
      init_class_id(Class_MachCallStaticJava);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 971,11 ***</span>
  };
  
  //------------------------------MachCallRuntimeNode----------------------------
  // Machine-specific versions of subroutine calls
  class MachCallRuntimeNode : public MachCallNode {
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    const char *_name;            // Printable name, if _method is NULL
    MachCallRuntimeNode() : MachCallNode() {
      init_class_id(Class_MachCallRuntime);
<span class="line-new-header">--- 985,11 ---</span>
  };
  
  //------------------------------MachCallRuntimeNode----------------------------
  // Machine-specific versions of subroutine calls
  class MachCallRuntimeNode : public MachCallNode {
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    const char *_name;            // Printable name, if _method is NULL
    MachCallRuntimeNode() : MachCallNode() {
      init_class_id(Class_MachCallRuntime);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,10 ***</span>
<span class="line-new-header">--- 1009,11 ---</span>
  
  //------------------------------MachHaltNode-----------------------------------
  // Machine-specific versions of halt nodes
  class MachHaltNode : public MachReturnNode {
  public:
<span class="line-added">+   const char* _halt_reason;</span>
    virtual JVMState* jvms() const;
  };
  
  class MachMemBarNode : public MachNode {
    virtual uint size_of() const; // Size is bigger
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1064,11 ***</span>
    virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
  
    virtual uint           opcode() const;
  
    virtual uint           hash()   const;
<span class="line-modified">!   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
  #ifndef PRODUCT
    virtual const char    *Name()   const { return &quot;Label&quot;;}
  
    virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
    virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
<span class="line-new-header">--- 1079,11 ---</span>
    virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
  
    virtual uint           opcode() const;
  
    virtual uint           hash()   const;
<span class="line-modified">!   virtual bool           cmp( const MachOper &amp;oper ) const;</span>
  #ifndef PRODUCT
    virtual const char    *Name()   const { return &quot;Label&quot;;}
  
    virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
    virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1091,11 ***</span>
    virtual intptr_t method() const { return _method; }
  
    virtual uint           opcode() const;
  
    virtual uint           hash()   const;
<span class="line-modified">!   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
  #ifndef PRODUCT
    virtual const char    *Name()   const { return &quot;Method&quot;;}
  
    virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
    virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
<span class="line-new-header">--- 1106,11 ---</span>
    virtual intptr_t method() const { return _method; }
  
    virtual uint           opcode() const;
  
    virtual uint           hash()   const;
<span class="line-modified">!   virtual bool           cmp( const MachOper &amp;oper ) const;</span>
  #ifndef PRODUCT
    virtual const char    *Name()   const { return &quot;Method&quot;;}
  
    virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
    virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
</pre>
<center><a href="machnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
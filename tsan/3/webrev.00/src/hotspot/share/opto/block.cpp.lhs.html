<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/block.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/chaitin.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/machnode.hpp&quot;
  35 #include &quot;opto/matcher.hpp&quot;
  36 #include &quot;opto/opcodes.hpp&quot;
  37 #include &quot;opto/rootnode.hpp&quot;
  38 #include &quot;utilities/copy.hpp&quot;
<a name="2" id="anc2"></a>
  39 
  40 void Block_Array::grow( uint i ) {
  41   assert(i &gt;= Max(), &quot;must be an overflow&quot;);
  42   debug_only(_limit = i+1);
  43   if( i &lt; _size )  return;
  44   if( !_size ) {
  45     _size = 1;
  46     _blocks = (Block**)_arena-&gt;Amalloc( _size * sizeof(Block*) );
  47     _blocks[0] = NULL;
  48   }
  49   uint old = _size;
<a name="3" id="anc3"></a><span class="line-modified">  50   while( i &gt;= _size ) _size &lt;&lt;= 1;      // Double to fit</span>
  51   _blocks = (Block**)_arena-&gt;Arealloc( _blocks, old*sizeof(Block*),_size*sizeof(Block*));
  52   Copy::zero_to_bytes( &amp;_blocks[old], (_size-old)*sizeof(Block*) );
  53 }
  54 
  55 void Block_List::remove(uint i) {
  56   assert(i &lt; _cnt, &quot;index out of bounds&quot;);
  57   Copy::conjoint_words_to_lower((HeapWord*)&amp;_blocks[i+1], (HeapWord*)&amp;_blocks[i], ((_cnt-i-1)*sizeof(Block*)));
  58   pop(); // shrink list by one block
  59 }
  60 
  61 void Block_List::insert(uint i, Block *b) {
  62   push(b); // grow list by one block
  63   Copy::conjoint_words_to_higher((HeapWord*)&amp;_blocks[i], (HeapWord*)&amp;_blocks[i+1], ((_cnt-i-1)*sizeof(Block*)));
  64   _blocks[i] = b;
  65 }
  66 
  67 #ifndef PRODUCT
  68 void Block_List::print() {
  69   for (uint i=0; i &lt; size(); i++) {
  70     tty-&gt;print(&quot;B%d &quot;, _blocks[i]-&gt;_pre_order);
  71   }
  72   tty-&gt;print(&quot;size = %d\n&quot;, size());
  73 }
  74 #endif
  75 
  76 uint Block::code_alignment() const {
  77   // Check for Root block
  78   if (_pre_order == 0) return CodeEntryAlignment;
  79   // Check for Start block
  80   if (_pre_order == 1) return InteriorEntryAlignment;
  81   // Check for loop alignment
  82   if (has_loop_alignment()) return loop_alignment();
  83 
  84   return relocInfo::addr_unit(); // no particular alignment
  85 }
  86 
  87 uint Block::compute_loop_alignment() {
  88   Node *h = head();
  89   int unit_sz = relocInfo::addr_unit();
  90   if (h-&gt;is_Loop() &amp;&amp; h-&gt;as_Loop()-&gt;is_inner_loop())  {
  91     // Pre- and post-loops have low trip count so do not bother with
  92     // NOPs for align loop head.  The constants are hidden from tuning
  93     // but only because my &quot;divide by 4&quot; heuristic surely gets nearly
  94     // all possible gain (a &quot;do not align at all&quot; heuristic has a
  95     // chance of getting a really tiny gain).
  96     if (h-&gt;is_CountedLoop() &amp;&amp; (h-&gt;as_CountedLoop()-&gt;is_pre_loop() ||
  97                                 h-&gt;as_CountedLoop()-&gt;is_post_loop())) {
  98       return (OptoLoopAlignment &gt; 4*unit_sz) ? (OptoLoopAlignment&gt;&gt;2) : unit_sz;
  99     }
 100     // Loops with low backedge frequency should not be aligned.
 101     Node *n = h-&gt;in(LoopNode::LoopBackControl)-&gt;in(0);
 102     if (n-&gt;is_MachIf() &amp;&amp; n-&gt;as_MachIf()-&gt;_prob &lt; 0.01) {
 103       return unit_sz; // Loop does not loop, more often than not!
 104     }
 105     return OptoLoopAlignment; // Otherwise align loop head
 106   }
 107 
 108   return unit_sz; // no particular alignment
 109 }
 110 
 111 // Compute the size of first &#39;inst_cnt&#39; instructions in this block.
 112 // Return the number of instructions left to compute if the block has
 113 // less then &#39;inst_cnt&#39; instructions. Stop, and return 0 if sum_size
 114 // exceeds OptoLoopAlignment.
 115 uint Block::compute_first_inst_size(uint&amp; sum_size, uint inst_cnt,
 116                                     PhaseRegAlloc* ra) {
 117   uint last_inst = number_of_nodes();
 118   for( uint j = 0; j &lt; last_inst &amp;&amp; inst_cnt &gt; 0; j++ ) {
 119     uint inst_size = get_node(j)-&gt;size(ra);
 120     if( inst_size &gt; 0 ) {
 121       inst_cnt--;
 122       uint sz = sum_size + inst_size;
 123       if( sz &lt;= (uint)OptoLoopAlignment ) {
 124         // Compute size of instructions which fit into fetch buffer only
 125         // since all inst_cnt instructions will not fit even if we align them.
 126         sum_size = sz;
 127       } else {
 128         return 0;
 129       }
 130     }
 131   }
 132   return inst_cnt;
 133 }
 134 
 135 uint Block::find_node( const Node *n ) const {
 136   for( uint i = 0; i &lt; number_of_nodes(); i++ ) {
 137     if( get_node(i) == n )
 138       return i;
 139   }
 140   ShouldNotReachHere();
 141   return 0;
 142 }
 143 
 144 // Find and remove n from block list
 145 void Block::find_remove( const Node *n ) {
 146   remove_node(find_node(n));
 147 }
 148 
 149 bool Block::contains(const Node *n) const {
 150   return _nodes.contains(n);
 151 }
 152 
 153 // Return empty status of a block.  Empty blocks contain only the head, other
 154 // ideal nodes, and an optional trailing goto.
 155 int Block::is_Empty() const {
 156 
 157   // Root or start block is not considered empty
 158   if (head()-&gt;is_Root() || head()-&gt;is_Start()) {
 159     return not_empty;
 160   }
 161 
 162   int success_result = completely_empty;
 163   int end_idx = number_of_nodes() - 1;
 164 
 165   // Check for ending goto
 166   if ((end_idx &gt; 0) &amp;&amp; (get_node(end_idx)-&gt;is_MachGoto())) {
 167     success_result = empty_with_goto;
 168     end_idx--;
 169   }
 170 
 171   // Unreachable blocks are considered empty
 172   if (num_preds() &lt;= 1) {
 173     return success_result;
 174   }
 175 
 176   // Ideal nodes are allowable in empty blocks: skip them  Only MachNodes
 177   // turn directly into code, because only MachNodes have non-trivial
 178   // emit() functions.
 179   while ((end_idx &gt; 0) &amp;&amp; !get_node(end_idx)-&gt;is_Mach()) {
 180     end_idx--;
 181   }
 182 
 183   // No room for any interesting instructions?
 184   if (end_idx == 0) {
 185     return success_result;
 186   }
 187 
 188   return not_empty;
 189 }
 190 
 191 // Return true if the block&#39;s code implies that it is likely to be
 192 // executed infrequently.  Check to see if the block ends in a Halt or
 193 // a low probability call.
 194 bool Block::has_uncommon_code() const {
 195   Node* en = end();
 196 
 197   if (en-&gt;is_MachGoto())
 198     en = en-&gt;in(0);
 199   if (en-&gt;is_Catch())
 200     en = en-&gt;in(0);
 201   if (en-&gt;is_MachProj() &amp;&amp; en-&gt;in(0)-&gt;is_MachCall()) {
 202     MachCallNode* call = en-&gt;in(0)-&gt;as_MachCall();
 203     if (call-&gt;cnt() != COUNT_UNKNOWN &amp;&amp; call-&gt;cnt() &lt;= PROB_UNLIKELY_MAG(4)) {
 204       // This is true for slow-path stubs like new_{instance,array},
 205       // slow_arraycopy, complete_monitor_locking, uncommon_trap.
 206       // The magic number corresponds to the probability of an uncommon_trap,
 207       // even though it is a count not a probability.
 208       return true;
 209     }
 210   }
 211 
 212   int op = en-&gt;is_Mach() ? en-&gt;as_Mach()-&gt;ideal_Opcode() : en-&gt;Opcode();
 213   return op == Op_Halt;
 214 }
 215 
 216 // True if block is low enough frequency or guarded by a test which
 217 // mostly does not go here.
 218 bool PhaseCFG::is_uncommon(const Block* block) {
 219   // Initial blocks must never be moved, so are never uncommon.
 220   if (block-&gt;head()-&gt;is_Root() || block-&gt;head()-&gt;is_Start())  return false;
 221 
 222   // Check for way-low freq
 223   if(block-&gt;_freq &lt; BLOCK_FREQUENCY(0.00001f) ) return true;
 224 
 225   // Look for code shape indicating uncommon_trap or slow path
 226   if (block-&gt;has_uncommon_code()) return true;
 227 
 228   const float epsilon = 0.05f;
 229   const float guard_factor = PROB_UNLIKELY_MAG(4) / (1.f - epsilon);
 230   uint uncommon_preds = 0;
 231   uint freq_preds = 0;
 232   uint uncommon_for_freq_preds = 0;
 233 
 234   for( uint i=1; i&lt; block-&gt;num_preds(); i++ ) {
 235     Block* guard = get_block_for_node(block-&gt;pred(i));
 236     // Check to see if this block follows its guard 1 time out of 10000
 237     // or less.
 238     //
 239     // See list of magnitude-4 unlikely probabilities in cfgnode.hpp which
 240     // we intend to be &quot;uncommon&quot;, such as slow-path TLE allocation,
 241     // predicted call failure, and uncommon trap triggers.
 242     //
 243     // Use an epsilon value of 5% to allow for variability in frequency
 244     // predictions and floating point calculations. The net effect is
 245     // that guard_factor is set to 9500.
 246     //
 247     // Ignore low-frequency blocks.
 248     // The next check is (guard-&gt;_freq &lt; 1.e-5 * 9500.).
 249     if(guard-&gt;_freq*BLOCK_FREQUENCY(guard_factor) &lt; BLOCK_FREQUENCY(0.00001f)) {
 250       uncommon_preds++;
 251     } else {
 252       freq_preds++;
 253       if(block-&gt;_freq &lt; guard-&gt;_freq * guard_factor ) {
 254         uncommon_for_freq_preds++;
 255       }
 256     }
 257   }
 258   if( block-&gt;num_preds() &gt; 1 &amp;&amp;
 259       // The block is uncommon if all preds are uncommon or
 260       (uncommon_preds == (block-&gt;num_preds()-1) ||
 261       // it is uncommon for all frequent preds.
 262        uncommon_for_freq_preds == freq_preds) ) {
 263     return true;
 264   }
 265   return false;
 266 }
 267 
 268 #ifndef PRODUCT
 269 void Block::dump_bidx(const Block* orig, outputStream* st) const {
<a name="4" id="anc4"></a><span class="line-modified"> 270   if (_pre_order) st-&gt;print(&quot;B%d&quot;,_pre_order);</span>
 271   else st-&gt;print(&quot;N%d&quot;, head()-&gt;_idx);
 272 
 273   if (Verbose &amp;&amp; orig != this) {
 274     // Dump the original block&#39;s idx
 275     st-&gt;print(&quot; (&quot;);
 276     orig-&gt;dump_bidx(orig, st);
 277     st-&gt;print(&quot;)&quot;);
 278   }
 279 }
 280 
 281 void Block::dump_pred(const PhaseCFG* cfg, Block* orig, outputStream* st) const {
 282   if (is_connector()) {
 283     for (uint i=1; i&lt;num_preds(); i++) {
 284       Block *p = cfg-&gt;get_block_for_node(pred(i));
 285       p-&gt;dump_pred(cfg, orig, st);
 286     }
 287   } else {
 288     dump_bidx(orig, st);
 289     st-&gt;print(&quot; &quot;);
 290   }
 291 }
 292 
 293 void Block::dump_head(const PhaseCFG* cfg, outputStream* st) const {
<a name="5" id="anc5"></a><span class="line-modified"> 294   // Print the basic block</span>
 295   dump_bidx(this, st);
<a name="6" id="anc6"></a><span class="line-modified"> 296   st-&gt;print(&quot;: #\t&quot;);</span>
 297 
<a name="7" id="anc7"></a><span class="line-modified"> 298   // Print the incoming CFG edges and the outgoing CFG edges</span>

 299   for( uint i=0; i&lt;_num_succs; i++ ) {
 300     non_connector_successor(i)-&gt;dump_bidx(_succs[i], st);
 301     st-&gt;print(&quot; &quot;);
 302   }
<a name="8" id="anc8"></a><span class="line-modified"> 303   st-&gt;print(&quot;&lt;- &quot;);</span>


 304   if( head()-&gt;is_block_start() ) {
<a name="9" id="anc9"></a>
 305     for (uint i=1; i&lt;num_preds(); i++) {
 306       Node *s = pred(i);
 307       if (cfg != NULL) {
 308         Block *p = cfg-&gt;get_block_for_node(s);
 309         p-&gt;dump_pred(cfg, p, st);
 310       } else {
<a name="10" id="anc10"></a><span class="line-modified"> 311         while (!s-&gt;is_block_start())</span>
 312           s = s-&gt;in(0);
<a name="11" id="anc11"></a>
 313         st-&gt;print(&quot;N%d &quot;, s-&gt;_idx );
 314       }
 315     }
<a name="12" id="anc12"></a>
 316   } else {
<a name="13" id="anc13"></a><span class="line-modified"> 317     st-&gt;print(&quot;BLOCK HEAD IS JUNK  &quot;);</span>
 318   }
 319 
 320   // Print loop, if any
 321   const Block *bhead = this;    // Head of self-loop
 322   Node *bh = bhead-&gt;head();
 323 
 324   if ((cfg != NULL) &amp;&amp; bh-&gt;is_Loop() &amp;&amp; !head()-&gt;is_Root()) {
 325     LoopNode *loop = bh-&gt;as_Loop();
 326     const Block *bx = cfg-&gt;get_block_for_node(loop-&gt;in(LoopNode::LoopBackControl));
 327     while (bx-&gt;is_connector()) {
 328       bx = cfg-&gt;get_block_for_node(bx-&gt;pred(1));
 329     }
<a name="14" id="anc14"></a><span class="line-modified"> 330     st-&gt;print(&quot;\tLoop: B%d-B%d &quot;, bhead-&gt;_pre_order, bx-&gt;_pre_order);</span>
 331     // Dump any loop-specific bits, especially for CountedLoops.
 332     loop-&gt;dump_spec(st);
<a name="15" id="anc15"></a>
 333   } else if (has_loop_alignment()) {
<a name="16" id="anc16"></a><span class="line-modified"> 334     st-&gt;print(&quot; top-of-loop&quot;);</span>
 335   }
<a name="17" id="anc17"></a>

 336   st-&gt;print(&quot; Freq: %g&quot;,_freq);
 337   if( Verbose || WizardMode ) {
 338     st-&gt;print(&quot; IDom: %d/#%d&quot;, _idom ? _idom-&gt;_pre_order : 0, _dom_depth);
 339     st-&gt;print(&quot; RegPressure: %d&quot;,_reg_pressure);
 340     st-&gt;print(&quot; IHRP Index: %d&quot;,_ihrp_index);
 341     st-&gt;print(&quot; FRegPressure: %d&quot;,_freg_pressure);
 342     st-&gt;print(&quot; FHRP Index: %d&quot;,_fhrp_index);
 343   }
 344   st-&gt;cr();
 345 }
 346 
 347 void Block::dump() const {
 348   dump(NULL);
 349 }
 350 
 351 void Block::dump(const PhaseCFG* cfg) const {
 352   dump_head(cfg);
 353   for (uint i=0; i&lt; number_of_nodes(); i++) {
 354     get_node(i)-&gt;dump();
 355   }
 356   tty-&gt;print(&quot;\n&quot;);
 357 }
 358 #endif
 359 
 360 PhaseCFG::PhaseCFG(Arena* arena, RootNode* root, Matcher&amp; matcher)
 361 : Phase(CFG)
 362 , _root(root)
 363 , _block_arena(arena)
 364 , _regalloc(NULL)
 365 , _scheduling_for_pressure(false)
 366 , _matcher(matcher)
 367 , _node_to_block_mapping(arena)
 368 , _node_latency(NULL)
 369 #ifndef PRODUCT
 370 , _trace_opto_pipelining(C-&gt;directive()-&gt;TraceOptoPipeliningOption)
 371 #endif
 372 #ifdef ASSERT
 373 , _raw_oops(arena)
 374 #endif
 375 {
 376   ResourceMark rm;
 377   // I&#39;ll need a few machine-specific GotoNodes.  Make an Ideal GotoNode,
 378   // then Match it into a machine-specific Node.  Then clone the machine
 379   // Node on demand.
 380   Node *x = new GotoNode(NULL);
 381   x-&gt;init_req(0, x);
 382   _goto = matcher.match_tree(x);
 383   assert(_goto != NULL, &quot;&quot;);
 384   _goto-&gt;set_req(0,_goto);
 385 
 386   // Build the CFG in Reverse Post Order
 387   _number_of_blocks = build_cfg();
 388   _root_block = get_block_for_node(_root);
 389 }
 390 
 391 // Build a proper looking CFG.  Make every block begin with either a StartNode
 392 // or a RegionNode.  Make every block end with either a Goto, If or Return.
 393 // The RootNode both starts and ends it&#39;s own block.  Do this with a recursive
 394 // backwards walk over the control edges.
 395 uint PhaseCFG::build_cfg() {
 396   Arena *a = Thread::current()-&gt;resource_area();
 397   VectorSet visited(a);
 398 
 399   // Allocate stack with enough space to avoid frequent realloc
 400   Node_Stack nstack(a, C-&gt;live_nodes() &gt;&gt; 1);
 401   nstack.push(_root, 0);
 402   uint sum = 0;                 // Counter for blocks
 403 
 404   while (nstack.is_nonempty()) {
 405     // node and in&#39;s index from stack&#39;s top
 406     // &#39;np&#39; is _root (see above) or RegionNode, StartNode: we push on stack
 407     // only nodes which point to the start of basic block (see below).
 408     Node *np = nstack.node();
 409     // idx &gt; 0, except for the first node (_root) pushed on stack
 410     // at the beginning when idx == 0.
 411     // We will use the condition (idx == 0) later to end the build.
 412     uint idx = nstack.index();
 413     Node *proj = np-&gt;in(idx);
 414     const Node *x = proj-&gt;is_block_proj();
 415     // Does the block end with a proper block-ending Node?  One of Return,
 416     // If or Goto? (This check should be done for visited nodes also).
 417     if (x == NULL) {                    // Does not end right...
 418       Node *g = _goto-&gt;clone(); // Force it to end in a Goto
 419       g-&gt;set_req(0, proj);
 420       np-&gt;set_req(idx, g);
 421       x = proj = g;
 422     }
 423     if (!visited.test_set(x-&gt;_idx)) { // Visit this block once
 424       // Skip any control-pinned middle&#39;in stuff
 425       Node *p = proj;
 426       do {
 427         proj = p;                   // Update pointer to last Control
 428         p = p-&gt;in(0);               // Move control forward
 429       } while( !p-&gt;is_block_proj() &amp;&amp;
 430                !p-&gt;is_block_start() );
 431       // Make the block begin with one of Region or StartNode.
 432       if( !p-&gt;is_block_start() ) {
 433         RegionNode *r = new RegionNode( 2 );
 434         r-&gt;init_req(1, p);         // Insert RegionNode in the way
 435         proj-&gt;set_req(0, r);        // Insert RegionNode in the way
 436         p = r;
 437       }
 438       // &#39;p&#39; now points to the start of this basic block
 439 
 440       // Put self in array of basic blocks
 441       Block *bb = new (_block_arena) Block(_block_arena, p);
 442       map_node_to_block(p, bb);
 443       map_node_to_block(x, bb);
 444       if( x != p ) {                // Only for root is x == p
 445         bb-&gt;push_node((Node*)x);
 446       }
 447       // Now handle predecessors
 448       ++sum;                        // Count 1 for self block
 449       uint cnt = bb-&gt;num_preds();
 450       for (int i = (cnt - 1); i &gt; 0; i-- ) { // For all predecessors
 451         Node *prevproj = p-&gt;in(i);  // Get prior input
 452         assert( !prevproj-&gt;is_Con(), &quot;dead input not removed&quot; );
 453         // Check to see if p-&gt;in(i) is a &quot;control-dependent&quot; CFG edge -
 454         // i.e., it splits at the source (via an IF or SWITCH) and merges
 455         // at the destination (via a many-input Region).
 456         // This breaks critical edges.  The RegionNode to start the block
 457         // will be added when &lt;p,i&gt; is pulled off the node stack
 458         if ( cnt &gt; 2 ) {             // Merging many things?
 459           assert( prevproj== bb-&gt;pred(i),&quot;&quot;);
 460           if(prevproj-&gt;is_block_proj() != prevproj) { // Control-dependent edge?
 461             // Force a block on the control-dependent edge
 462             Node *g = _goto-&gt;clone();       // Force it to end in a Goto
 463             g-&gt;set_req(0,prevproj);
 464             p-&gt;set_req(i,g);
 465           }
 466         }
 467         nstack.push(p, i);  // &#39;p&#39; is RegionNode or StartNode
 468       }
 469     } else { // Post-processing visited nodes
 470       nstack.pop();                 // remove node from stack
 471       // Check if it the fist node pushed on stack at the beginning.
 472       if (idx == 0) break;          // end of the build
 473       // Find predecessor basic block
 474       Block *pb = get_block_for_node(x);
 475       // Insert into nodes array, if not already there
 476       if (!has_block(proj)) {
 477         assert( x != proj, &quot;&quot; );
 478         // Map basic block of projection
 479         map_node_to_block(proj, pb);
 480         pb-&gt;push_node(proj);
 481       }
 482       // Insert self as a child of my predecessor block
 483       pb-&gt;_succs.map(pb-&gt;_num_succs++, get_block_for_node(np));
 484       assert( pb-&gt;get_node(pb-&gt;number_of_nodes() - pb-&gt;_num_succs)-&gt;is_block_proj(),
 485               &quot;too many control users, not a CFG?&quot; );
 486     }
 487   }
 488   // Return number of basic blocks for all children and self
 489   return sum;
 490 }
 491 
 492 // Inserts a goto &amp; corresponding basic block between
 493 // block[block_no] and its succ_no&#39;th successor block
 494 void PhaseCFG::insert_goto_at(uint block_no, uint succ_no) {
 495   // get block with block_no
 496   assert(block_no &lt; number_of_blocks(), &quot;illegal block number&quot;);
 497   Block* in  = get_block(block_no);
 498   // get successor block succ_no
 499   assert(succ_no &lt; in-&gt;_num_succs, &quot;illegal successor number&quot;);
 500   Block* out = in-&gt;_succs[succ_no];
 501   // Compute frequency of the new block. Do this before inserting
 502   // new block in case succ_prob() needs to infer the probability from
 503   // surrounding blocks.
 504   float freq = in-&gt;_freq * in-&gt;succ_prob(succ_no);
 505   // get ProjNode corresponding to the succ_no&#39;th successor of the in block
 506   ProjNode* proj = in-&gt;get_node(in-&gt;number_of_nodes() - in-&gt;_num_succs + succ_no)-&gt;as_Proj();
 507   // create region for basic block
 508   RegionNode* region = new RegionNode(2);
 509   region-&gt;init_req(1, proj);
 510   // setup corresponding basic block
 511   Block* block = new (_block_arena) Block(_block_arena, region);
 512   map_node_to_block(region, block);
 513   C-&gt;regalloc()-&gt;set_bad(region-&gt;_idx);
 514   // add a goto node
 515   Node* gto = _goto-&gt;clone(); // get a new goto node
 516   gto-&gt;set_req(0, region);
 517   // add it to the basic block
 518   block-&gt;push_node(gto);
 519   map_node_to_block(gto, block);
 520   C-&gt;regalloc()-&gt;set_bad(gto-&gt;_idx);
 521   // hook up successor block
 522   block-&gt;_succs.map(block-&gt;_num_succs++, out);
 523   // remap successor&#39;s predecessors if necessary
 524   for (uint i = 1; i &lt; out-&gt;num_preds(); i++) {
 525     if (out-&gt;pred(i) == proj) out-&gt;head()-&gt;set_req(i, gto);
 526   }
 527   // remap predecessor&#39;s successor to new block
 528   in-&gt;_succs.map(succ_no, block);
 529   // Set the frequency of the new block
 530   block-&gt;_freq = freq;
 531   // add new basic block to basic block list
 532   add_block_at(block_no + 1, block);
 533 }
 534 
 535 // Does this block end in a multiway branch that cannot have the default case
 536 // flipped for another case?
 537 static bool no_flip_branch(Block *b) {
 538   int branch_idx = b-&gt;number_of_nodes() - b-&gt;_num_succs-1;
 539   if (branch_idx &lt; 1) {
 540     return false;
 541   }
 542   Node *branch = b-&gt;get_node(branch_idx);
 543   if (branch-&gt;is_Catch()) {
 544     return true;
 545   }
 546   if (branch-&gt;is_Mach()) {
 547     if (branch-&gt;is_MachNullCheck()) {
 548       return true;
 549     }
 550     int iop = branch-&gt;as_Mach()-&gt;ideal_Opcode();
 551     if (iop == Op_FastLock || iop == Op_FastUnlock) {
 552       return true;
 553     }
 554     // Don&#39;t flip if branch has an implicit check.
 555     if (branch-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
 556       return true;
 557     }
 558   }
 559   return false;
 560 }
 561 
 562 // Check for NeverBranch at block end.  This needs to become a GOTO to the
 563 // true target.  NeverBranch are treated as a conditional branch that always
 564 // goes the same direction for most of the optimizer and are used to give a
 565 // fake exit path to infinite loops.  At this late stage they need to turn
 566 // into Goto&#39;s so that when you enter the infinite loop you indeed hang.
 567 void PhaseCFG::convert_NeverBranch_to_Goto(Block *b) {
 568   // Find true target
 569   int end_idx = b-&gt;end_idx();
 570   int idx = b-&gt;get_node(end_idx+1)-&gt;as_Proj()-&gt;_con;
 571   Block *succ = b-&gt;_succs[idx];
 572   Node* gto = _goto-&gt;clone(); // get a new goto node
 573   gto-&gt;set_req(0, b-&gt;head());
 574   Node *bp = b-&gt;get_node(end_idx);
 575   b-&gt;map_node(gto, end_idx); // Slam over NeverBranch
 576   map_node_to_block(gto, b);
 577   C-&gt;regalloc()-&gt;set_bad(gto-&gt;_idx);
 578   b-&gt;pop_node();              // Yank projections
 579   b-&gt;pop_node();              // Yank projections
 580   b-&gt;_succs.map(0,succ);        // Map only successor
 581   b-&gt;_num_succs = 1;
 582   // remap successor&#39;s predecessors if necessary
 583   uint j;
 584   for( j = 1; j &lt; succ-&gt;num_preds(); j++)
 585     if( succ-&gt;pred(j)-&gt;in(0) == bp )
 586       succ-&gt;head()-&gt;set_req(j, gto);
 587   // Kill alternate exit path
 588   Block *dead = b-&gt;_succs[1-idx];
 589   for( j = 1; j &lt; dead-&gt;num_preds(); j++)
 590     if( dead-&gt;pred(j)-&gt;in(0) == bp )
 591       break;
 592   // Scan through block, yanking dead path from
 593   // all regions and phis.
 594   dead-&gt;head()-&gt;del_req(j);
 595   for( int k = 1; dead-&gt;get_node(k)-&gt;is_Phi(); k++ )
 596     dead-&gt;get_node(k)-&gt;del_req(j);
 597 }
 598 
 599 // Helper function to move block bx to the slot following b_index. Return
 600 // true if the move is successful, otherwise false
 601 bool PhaseCFG::move_to_next(Block* bx, uint b_index) {
 602   if (bx == NULL) return false;
 603 
 604   // Return false if bx is already scheduled.
 605   uint bx_index = bx-&gt;_pre_order;
 606   if ((bx_index &lt;= b_index) &amp;&amp; (get_block(bx_index) == bx)) {
 607     return false;
 608   }
 609 
 610   // Find the current index of block bx on the block list
 611   bx_index = b_index + 1;
 612   while (bx_index &lt; number_of_blocks() &amp;&amp; get_block(bx_index) != bx) {
 613     bx_index++;
 614   }
 615   assert(get_block(bx_index) == bx, &quot;block not found&quot;);
 616 
 617   // If the previous block conditionally falls into bx, return false,
 618   // because moving bx will create an extra jump.
 619   for(uint k = 1; k &lt; bx-&gt;num_preds(); k++ ) {
 620     Block* pred = get_block_for_node(bx-&gt;pred(k));
 621     if (pred == get_block(bx_index - 1)) {
 622       if (pred-&gt;_num_succs != 1) {
 623         return false;
 624       }
 625     }
 626   }
 627 
 628   // Reinsert bx just past block &#39;b&#39;
 629   _blocks.remove(bx_index);
 630   _blocks.insert(b_index + 1, bx);
 631   return true;
 632 }
 633 
 634 // Move empty and uncommon blocks to the end.
 635 void PhaseCFG::move_to_end(Block *b, uint i) {
 636   int e = b-&gt;is_Empty();
 637   if (e != Block::not_empty) {
 638     if (e == Block::empty_with_goto) {
 639       // Remove the goto, but leave the block.
 640       b-&gt;pop_node();
 641     }
 642     // Mark this block as a connector block, which will cause it to be
 643     // ignored in certain functions such as non_connector_successor().
 644     b-&gt;set_connector();
 645   }
 646   // Move the empty block to the end, and don&#39;t recheck.
 647   _blocks.remove(i);
 648   _blocks.push(b);
 649 }
 650 
 651 // Set loop alignment for every block
 652 void PhaseCFG::set_loop_alignment() {
 653   uint last = number_of_blocks();
 654   assert(get_block(0) == get_root_block(), &quot;&quot;);
 655 
 656   for (uint i = 1; i &lt; last; i++) {
 657     Block* block = get_block(i);
 658     if (block-&gt;head()-&gt;is_Loop()) {
 659       block-&gt;set_loop_alignment(block);
 660     }
 661   }
 662 }
 663 
 664 // Make empty basic blocks to be &quot;connector&quot; blocks, Move uncommon blocks
 665 // to the end.
 666 void PhaseCFG::remove_empty_blocks() {
 667   // Move uncommon blocks to the end
 668   uint last = number_of_blocks();
 669   assert(get_block(0) == get_root_block(), &quot;&quot;);
 670 
 671   for (uint i = 1; i &lt; last; i++) {
 672     Block* block = get_block(i);
 673     if (block-&gt;is_connector()) {
 674       break;
 675     }
 676 
 677     // Check for NeverBranch at block end.  This needs to become a GOTO to the
 678     // true target.  NeverBranch are treated as a conditional branch that
 679     // always goes the same direction for most of the optimizer and are used
 680     // to give a fake exit path to infinite loops.  At this late stage they
 681     // need to turn into Goto&#39;s so that when you enter the infinite loop you
 682     // indeed hang.
 683     if (block-&gt;get_node(block-&gt;end_idx())-&gt;Opcode() == Op_NeverBranch) {
 684       convert_NeverBranch_to_Goto(block);
 685     }
 686 
 687     // Look for uncommon blocks and move to end.
 688     if (!C-&gt;do_freq_based_layout()) {
 689       if (is_uncommon(block)) {
 690         move_to_end(block, i);
 691         last--;                   // No longer check for being uncommon!
 692         if (no_flip_branch(block)) { // Fall-thru case must follow?
 693           // Find the fall-thru block
 694           block = get_block(i);
 695           move_to_end(block, i);
 696           last--;
 697         }
 698         // backup block counter post-increment
 699         i--;
 700       }
 701     }
 702   }
 703 
 704   // Move empty blocks to the end
 705   last = number_of_blocks();
 706   for (uint i = 1; i &lt; last; i++) {
 707     Block* block = get_block(i);
 708     if (block-&gt;is_Empty() != Block::not_empty) {
 709       move_to_end(block, i);
 710       last--;
 711       i--;
 712     }
 713   } // End of for all blocks
 714 }
 715 
 716 Block *PhaseCFG::fixup_trap_based_check(Node *branch, Block *block, int block_pos, Block *bnext) {
 717   // Trap based checks must fall through to the successor with
 718   // PROB_ALWAYS.
 719   // They should be an If with 2 successors.
 720   assert(branch-&gt;is_MachIf(),   &quot;must be If&quot;);
 721   assert(block-&gt;_num_succs == 2, &quot;must have 2 successors&quot;);
 722 
 723   // Get the If node and the projection for the first successor.
 724   MachIfNode *iff   = block-&gt;get_node(block-&gt;number_of_nodes()-3)-&gt;as_MachIf();
 725   ProjNode   *proj0 = block-&gt;get_node(block-&gt;number_of_nodes()-2)-&gt;as_Proj();
 726   ProjNode   *proj1 = block-&gt;get_node(block-&gt;number_of_nodes()-1)-&gt;as_Proj();
 727   ProjNode   *projt = (proj0-&gt;Opcode() == Op_IfTrue)  ? proj0 : proj1;
 728   ProjNode   *projf = (proj0-&gt;Opcode() == Op_IfFalse) ? proj0 : proj1;
 729 
 730   // Assert that proj0 and succs[0] match up. Similarly for proj1 and succs[1].
 731   assert(proj0-&gt;raw_out(0) == block-&gt;_succs[0]-&gt;head(), &quot;Mismatch successor 0&quot;);
 732   assert(proj1-&gt;raw_out(0) == block-&gt;_succs[1]-&gt;head(), &quot;Mismatch successor 1&quot;);
 733 
 734   ProjNode *proj_always;
 735   ProjNode *proj_never;
 736   // We must negate the branch if the implicit check doesn&#39;t follow
 737   // the branch&#39;s TRUE path. Then, the new TRUE branch target will
 738   // be the old FALSE branch target.
 739   if (iff-&gt;_prob &lt;= 2*PROB_NEVER) {   // There are small rounding errors.
 740     proj_never  = projt;
 741     proj_always = projf;
 742   } else {
 743     // We must negate the branch if the trap doesn&#39;t follow the
 744     // branch&#39;s TRUE path. Then, the new TRUE branch target will
 745     // be the old FALSE branch target.
 746     proj_never  = projf;
 747     proj_always = projt;
 748     iff-&gt;negate();
 749   }
 750   assert(iff-&gt;_prob &lt;= 2*PROB_NEVER, &quot;Trap based checks are expected to trap never!&quot;);
 751   // Map the successors properly
 752   block-&gt;_succs.map(0, get_block_for_node(proj_never -&gt;raw_out(0)));   // The target of the trap.
 753   block-&gt;_succs.map(1, get_block_for_node(proj_always-&gt;raw_out(0)));   // The fall through target.
 754 
 755   if (block-&gt;get_node(block-&gt;number_of_nodes() - block-&gt;_num_succs + 1) != proj_always) {
 756     block-&gt;map_node(proj_never,  block-&gt;number_of_nodes() - block-&gt;_num_succs + 0);
 757     block-&gt;map_node(proj_always, block-&gt;number_of_nodes() - block-&gt;_num_succs + 1);
 758   }
 759 
 760   // Place the fall through block after this block.
 761   Block *bs1 = block-&gt;non_connector_successor(1);
 762   if (bs1 != bnext &amp;&amp; move_to_next(bs1, block_pos)) {
 763     bnext = bs1;
 764   }
 765   // If the fall through block still is not the next block, insert a goto.
 766   if (bs1 != bnext) {
 767     insert_goto_at(block_pos, 1);
 768   }
 769   return bnext;
 770 }
 771 
 772 // Fix up the final control flow for basic blocks.
 773 void PhaseCFG::fixup_flow() {
 774   // Fixup final control flow for the blocks.  Remove jump-to-next
 775   // block. If neither arm of an IF follows the conditional branch, we
 776   // have to add a second jump after the conditional.  We place the
 777   // TRUE branch target in succs[0] for both GOTOs and IFs.
 778   for (uint i = 0; i &lt; number_of_blocks(); i++) {
 779     Block* block = get_block(i);
 780     block-&gt;_pre_order = i;          // turn pre-order into block-index
 781 
 782     // Connector blocks need no further processing.
 783     if (block-&gt;is_connector()) {
 784       assert((i+1) == number_of_blocks() || get_block(i + 1)-&gt;is_connector(), &quot;All connector blocks should sink to the end&quot;);
 785       continue;
 786     }
 787     assert(block-&gt;is_Empty() != Block::completely_empty, &quot;Empty blocks should be connectors&quot;);
 788 
 789     Block* bnext = (i &lt; number_of_blocks() - 1) ? get_block(i + 1) : NULL;
 790     Block* bs0 = block-&gt;non_connector_successor(0);
 791 
 792     // Check for multi-way branches where I cannot negate the test to
 793     // exchange the true and false targets.
 794     if (no_flip_branch(block)) {
 795       // Find fall through case - if must fall into its target.
 796       // Get the index of the branch&#39;s first successor.
 797       int branch_idx = block-&gt;number_of_nodes() - block-&gt;_num_succs;
 798 
 799       // The branch is 1 before the branch&#39;s first successor.
 800       Node *branch = block-&gt;get_node(branch_idx-1);
 801 
 802       // Handle no-flip branches which have implicit checks and which require
 803       // special block ordering and individual semantics of the &#39;fall through
 804       // case&#39;.
 805       if ((TrapBasedNullChecks || TrapBasedRangeChecks) &amp;&amp;
 806           branch-&gt;is_Mach() &amp;&amp; branch-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
 807         bnext = fixup_trap_based_check(branch, block, i, bnext);
 808       } else {
 809         // Else, default handling for no-flip branches
 810         for (uint j2 = 0; j2 &lt; block-&gt;_num_succs; j2++) {
 811           const ProjNode* p = block-&gt;get_node(branch_idx + j2)-&gt;as_Proj();
 812           if (p-&gt;_con == 0) {
 813             // successor j2 is fall through case
 814             if (block-&gt;non_connector_successor(j2) != bnext) {
 815               // but it is not the next block =&gt; insert a goto
 816               insert_goto_at(i, j2);
 817             }
 818             // Put taken branch in slot 0
 819             if (j2 == 0 &amp;&amp; block-&gt;_num_succs == 2) {
 820               // Flip targets in succs map
 821               Block *tbs0 = block-&gt;_succs[0];
 822               Block *tbs1 = block-&gt;_succs[1];
 823               block-&gt;_succs.map(0, tbs1);
 824               block-&gt;_succs.map(1, tbs0);
 825             }
 826             break;
 827           }
 828         }
 829       }
 830 
 831       // Remove all CatchProjs
 832       for (uint j = 0; j &lt; block-&gt;_num_succs; j++) {
 833         block-&gt;pop_node();
 834       }
 835 
 836     } else if (block-&gt;_num_succs == 1) {
 837       // Block ends in a Goto?
 838       if (bnext == bs0) {
 839         // We fall into next block; remove the Goto
 840         block-&gt;pop_node();
 841       }
 842 
 843     } else if(block-&gt;_num_succs == 2) { // Block ends in a If?
 844       // Get opcode of 1st projection (matches _succs[0])
 845       // Note: Since this basic block has 2 exits, the last 2 nodes must
 846       //       be projections (in any order), the 3rd last node must be
 847       //       the IfNode (we have excluded other 2-way exits such as
 848       //       CatchNodes already).
 849       MachNode* iff   = block-&gt;get_node(block-&gt;number_of_nodes() - 3)-&gt;as_Mach();
 850       ProjNode* proj0 = block-&gt;get_node(block-&gt;number_of_nodes() - 2)-&gt;as_Proj();
 851       ProjNode* proj1 = block-&gt;get_node(block-&gt;number_of_nodes() - 1)-&gt;as_Proj();
 852 
 853       // Assert that proj0 and succs[0] match up. Similarly for proj1 and succs[1].
 854       assert(proj0-&gt;raw_out(0) == block-&gt;_succs[0]-&gt;head(), &quot;Mismatch successor 0&quot;);
 855       assert(proj1-&gt;raw_out(0) == block-&gt;_succs[1]-&gt;head(), &quot;Mismatch successor 1&quot;);
 856 
 857       Block* bs1 = block-&gt;non_connector_successor(1);
 858 
 859       // Check for neither successor block following the current
 860       // block ending in a conditional. If so, move one of the
 861       // successors after the current one, provided that the
 862       // successor was previously unscheduled, but moveable
 863       // (i.e., all paths to it involve a branch).
 864       if (!C-&gt;do_freq_based_layout() &amp;&amp; bnext != bs0 &amp;&amp; bnext != bs1) {
 865         // Choose the more common successor based on the probability
 866         // of the conditional branch.
 867         Block* bx = bs0;
 868         Block* by = bs1;
 869 
 870         // _prob is the probability of taking the true path. Make
 871         // p the probability of taking successor #1.
 872         float p = iff-&gt;as_MachIf()-&gt;_prob;
 873         if (proj0-&gt;Opcode() == Op_IfTrue) {
 874           p = 1.0 - p;
 875         }
 876 
 877         // Prefer successor #1 if p &gt; 0.5
 878         if (p &gt; PROB_FAIR) {
 879           bx = bs1;
 880           by = bs0;
 881         }
 882 
 883         // Attempt the more common successor first
 884         if (move_to_next(bx, i)) {
 885           bnext = bx;
 886         } else if (move_to_next(by, i)) {
 887           bnext = by;
 888         }
 889       }
 890 
 891       // Check for conditional branching the wrong way.  Negate
 892       // conditional, if needed, so it falls into the following block
 893       // and branches to the not-following block.
 894 
 895       // Check for the next block being in succs[0].  We are going to branch
 896       // to succs[0], so we want the fall-thru case as the next block in
 897       // succs[1].
 898       if (bnext == bs0) {
 899         // Fall-thru case in succs[0], so flip targets in succs map
 900         Block* tbs0 = block-&gt;_succs[0];
 901         Block* tbs1 = block-&gt;_succs[1];
 902         block-&gt;_succs.map(0, tbs1);
 903         block-&gt;_succs.map(1, tbs0);
 904         // Flip projection for each target
 905         ProjNode* tmp = proj0;
 906         proj0 = proj1;
 907         proj1 = tmp;
 908 
 909       } else if(bnext != bs1) {
 910         // Need a double-branch
 911         // The existing conditional branch need not change.
 912         // Add a unconditional branch to the false target.
 913         // Alas, it must appear in its own block and adding a
 914         // block this late in the game is complicated.  Sigh.
 915         insert_goto_at(i, 1);
 916       }
 917 
 918       // Make sure we TRUE branch to the target
 919       if (proj0-&gt;Opcode() == Op_IfFalse) {
 920         iff-&gt;as_MachIf()-&gt;negate();
 921       }
 922 
 923       block-&gt;pop_node();          // Remove IfFalse &amp; IfTrue projections
 924       block-&gt;pop_node();
 925 
 926     } else {
 927       // Multi-exit block, e.g. a switch statement
 928       // But we don&#39;t need to do anything here
 929     }
 930   } // End of for all blocks
 931 }
 932 
 933 
 934 // postalloc_expand: Expand nodes after register allocation.
 935 //
 936 // postalloc_expand has to be called after register allocation, just
 937 // before output (i.e. scheduling). It only gets called if
 938 // Matcher::require_postalloc_expand is true.
 939 //
 940 // Background:
 941 //
 942 // Nodes that are expandend (one compound node requiring several
 943 // assembler instructions to be implemented split into two or more
 944 // non-compound nodes) after register allocation are not as nice as
 945 // the ones expanded before register allocation - they don&#39;t
 946 // participate in optimizations as global code motion. But after
 947 // register allocation we can expand nodes that use registers which
 948 // are not spillable or registers that are not allocated, because the
 949 // old compound node is simply replaced (in its location in the basic
 950 // block) by a new subgraph which does not contain compound nodes any
 951 // more. The scheduler called during output can later on process these
 952 // non-compound nodes.
 953 //
 954 // Implementation:
 955 //
 956 // Nodes requiring postalloc expand are specified in the ad file by using
 957 // a postalloc_expand statement instead of ins_encode. A postalloc_expand
 958 // contains a single call to an encoding, as does an ins_encode
 959 // statement. Instead of an emit() function a postalloc_expand() function
 960 // is generated that doesn&#39;t emit assembler but creates a new
 961 // subgraph. The code below calls this postalloc_expand function for each
 962 // node with the appropriate attribute. This function returns the new
 963 // nodes generated in an array passed in the call. The old node,
 964 // potential MachTemps before and potential Projs after it then get
 965 // disconnected and replaced by the new nodes. The instruction
 966 // generating the result has to be the last one in the array. In
 967 // general it is assumed that Projs after the node expanded are
 968 // kills. These kills are not required any more after expanding as
 969 // there are now explicitly visible def-use chains and the Projs are
 970 // removed. This does not hold for calls: They do not only have
 971 // kill-Projs but also Projs defining values. Therefore Projs after
 972 // the node expanded are removed for all but for calls. If a node is
 973 // to be reused, it must be added to the nodes list returned, and it
 974 // will be added again.
 975 //
 976 // Implementing the postalloc_expand function for a node in an enc_class
 977 // is rather tedious. It requires knowledge about many node details, as
 978 // the nodes and the subgraph must be hand crafted. To simplify this,
 979 // adlc generates some utility variables into the postalloc_expand function,
 980 // e.g., holding the operands as specified by the postalloc_expand encoding
 981 // specification, e.g.:
 982 //  * unsigned idx_&lt;par_name&gt;  holding the index of the node in the ins
 983 //  * Node *n_&lt;par_name&gt;       holding the node loaded from the ins
 984 //  * MachOpnd *op_&lt;par_name&gt;  holding the corresponding operand
 985 //
 986 // The ordering of operands can not be determined by looking at a
 987 // rule. Especially if a match rule matches several different trees,
 988 // several nodes are generated from one instruct specification with
 989 // different operand orderings. In this case the adlc generated
 990 // variables are the only way to access the ins and operands
 991 // deterministically.
 992 //
 993 // If assigning a register to a node that contains an oop, don&#39;t
 994 // forget to call ra_-&gt;set_oop() for the node.
 995 void PhaseCFG::postalloc_expand(PhaseRegAlloc* _ra) {
 996   GrowableArray &lt;Node *&gt; new_nodes(32); // Array with new nodes filled by postalloc_expand function of node.
 997   GrowableArray &lt;Node *&gt; remove(32);
 998   GrowableArray &lt;Node *&gt; succs(32);
 999   unsigned int max_idx = C-&gt;unique();   // Remember to distinguish new from old nodes.
1000   DEBUG_ONLY(bool foundNode = false);
1001 
1002   // for all blocks
1003   for (uint i = 0; i &lt; number_of_blocks(); i++) {
1004     Block *b = _blocks[i];
1005     // For all instructions in the current block.
1006     for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1007       Node *n = b-&gt;get_node(j);
1008       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;requires_postalloc_expand()) {
1009 #ifdef ASSERT
1010         if (TracePostallocExpand) {
1011           if (!foundNode) {
1012             foundNode = true;
1013             tty-&gt;print(&quot;POSTALLOC EXPANDING %d %s\n&quot;, C-&gt;compile_id(),
1014                        C-&gt;method() ? C-&gt;method()-&gt;name()-&gt;as_utf8() : C-&gt;stub_name());
1015           }
1016           tty-&gt;print(&quot;  postalloc expanding &quot;); n-&gt;dump();
1017           if (Verbose) {
1018             tty-&gt;print(&quot;    with ins:\n&quot;);
1019             for (uint k = 0; k &lt; n-&gt;len(); ++k) {
1020               if (n-&gt;in(k)) { tty-&gt;print(&quot;        &quot;); n-&gt;in(k)-&gt;dump(); }
1021             }
1022           }
1023         }
1024 #endif
1025         new_nodes.clear();
1026         // Collect nodes that have to be removed from the block later on.
1027         uint req = n-&gt;req();
1028         remove.clear();
1029         for (uint k = 0; k &lt; req; ++k) {
1030           if (n-&gt;in(k) &amp;&amp; n-&gt;in(k)-&gt;is_MachTemp()) {
1031             remove.push(n-&gt;in(k)); // MachTemps which are inputs to the old node have to be removed.
1032             n-&gt;in(k)-&gt;del_req(0);
1033             j--;
1034           }
1035         }
1036 
1037         // Check whether we can allocate enough nodes. We set a fix limit for
1038         // the size of postalloc expands with this.
1039         uint unique_limit = C-&gt;unique() + 40;
1040         if (unique_limit &gt;= _ra-&gt;node_regs_max_index()) {
1041           Compile::current()-&gt;record_failure(&quot;out of nodes in postalloc expand&quot;);
1042           return;
1043         }
1044 
1045         // Emit (i.e. generate new nodes).
1046         n-&gt;as_Mach()-&gt;postalloc_expand(&amp;new_nodes, _ra);
1047 
1048         assert(C-&gt;unique() &lt; unique_limit, &quot;You allocated too many nodes in your postalloc expand.&quot;);
1049 
1050         // Disconnect the inputs of the old node.
1051         //
1052         // We reuse MachSpillCopy nodes. If we need to expand them, there
1053         // are many, so reusing pays off. If reused, the node already
1054         // has the new ins. n must be the last node on new_nodes list.
1055         if (!n-&gt;is_MachSpillCopy()) {
1056           for (int k = req - 1; k &gt;= 0; --k) {
1057             n-&gt;del_req(k);
1058           }
1059         }
1060 
1061 #ifdef ASSERT
1062         // Check that all nodes have proper operands.
1063         for (int k = 0; k &lt; new_nodes.length(); ++k) {
1064           if (new_nodes.at(k)-&gt;_idx &lt; max_idx || !new_nodes.at(k)-&gt;is_Mach()) continue; // old node, Proj ...
1065           MachNode *m = new_nodes.at(k)-&gt;as_Mach();
1066           for (unsigned int l = 0; l &lt; m-&gt;num_opnds(); ++l) {
1067             if (MachOper::notAnOper(m-&gt;_opnds[l])) {
1068               outputStream *os = tty;
1069               os-&gt;print(&quot;Node %s &quot;, m-&gt;Name());
1070               os-&gt;print(&quot;has invalid opnd %d: %p\n&quot;, l, m-&gt;_opnds[l]);
1071               assert(0, &quot;Invalid operands, see inline trace in hs_err_pid file.&quot;);
1072             }
1073           }
1074         }
1075 #endif
1076 
1077         // Collect succs of old node in remove (for projections) and in succs (for
1078         // all other nodes) do _not_ collect projections in remove (but in succs)
1079         // in case the node is a call. We need the projections for calls as they are
1080         // associated with registes (i.e. they are defs).
1081         succs.clear();
1082         for (DUIterator k = n-&gt;outs(); n-&gt;has_out(k); k++) {
1083           if (n-&gt;out(k)-&gt;is_Proj() &amp;&amp; !n-&gt;is_MachCall() &amp;&amp; !n-&gt;is_MachBranch()) {
1084             remove.push(n-&gt;out(k));
1085           } else {
1086             succs.push(n-&gt;out(k));
1087           }
1088         }
1089         // Replace old node n as input of its succs by last of the new nodes.
1090         for (int k = 0; k &lt; succs.length(); ++k) {
1091           Node *succ = succs.at(k);
1092           for (uint l = 0; l &lt; succ-&gt;req(); ++l) {
1093             if (succ-&gt;in(l) == n) {
1094               succ-&gt;set_req(l, new_nodes.at(new_nodes.length() - 1));
1095             }
1096           }
1097           for (uint l = succ-&gt;req(); l &lt; succ-&gt;len(); ++l) {
1098             if (succ-&gt;in(l) == n) {
1099               succ-&gt;set_prec(l, new_nodes.at(new_nodes.length() - 1));
1100             }
1101           }
1102         }
1103 
1104         // Index of old node in block.
1105         uint index = b-&gt;find_node(n);
1106         // Insert new nodes into block and map them in nodes-&gt;blocks array
1107         // and remember last node in n2.
1108         Node *n2 = NULL;
1109         for (int k = 0; k &lt; new_nodes.length(); ++k) {
1110           n2 = new_nodes.at(k);
1111           b-&gt;insert_node(n2, ++index);
1112           map_node_to_block(n2, b);
1113         }
1114 
1115         // Add old node n to remove and remove them all from block.
1116         remove.push(n);
1117         j--;
1118 #ifdef ASSERT
1119         if (TracePostallocExpand &amp;&amp; Verbose) {
1120           tty-&gt;print(&quot;    removing:\n&quot;);
1121           for (int k = 0; k &lt; remove.length(); ++k) {
1122             tty-&gt;print(&quot;        &quot;); remove.at(k)-&gt;dump();
1123           }
1124           tty-&gt;print(&quot;    inserting:\n&quot;);
1125           for (int k = 0; k &lt; new_nodes.length(); ++k) {
1126             tty-&gt;print(&quot;        &quot;); new_nodes.at(k)-&gt;dump();
1127           }
1128         }
1129 #endif
1130         for (int k = 0; k &lt; remove.length(); ++k) {
1131           if (b-&gt;contains(remove.at(k))) {
1132             b-&gt;find_remove(remove.at(k));
1133           } else {
1134             assert(remove.at(k)-&gt;is_Proj() &amp;&amp; (remove.at(k)-&gt;in(0)-&gt;is_MachBranch()), &quot;&quot;);
1135           }
1136         }
1137         // If anything has been inserted (n2 != NULL), continue after last node inserted.
1138         // This does not always work. Some postalloc expands don&#39;t insert any nodes, if they
1139         // do optimizations (e.g., max(x,x)). In this case we decrement j accordingly.
1140         j = n2 ? b-&gt;find_node(n2) : j;
1141       }
1142     }
1143   }
1144 
1145 #ifdef ASSERT
1146   if (foundNode) {
1147     tty-&gt;print(&quot;FINISHED %d %s\n&quot;, C-&gt;compile_id(),
1148                C-&gt;method() ? C-&gt;method()-&gt;name()-&gt;as_utf8() : C-&gt;stub_name());
1149     tty-&gt;flush();
1150   }
1151 #endif
1152 }
1153 
1154 
1155 //------------------------------dump-------------------------------------------
1156 #ifndef PRODUCT
1157 void PhaseCFG::_dump_cfg( const Node *end, VectorSet &amp;visited  ) const {
1158   const Node *x = end-&gt;is_block_proj();
1159   assert( x, &quot;not a CFG&quot; );
1160 
1161   // Do not visit this block again
1162   if( visited.test_set(x-&gt;_idx) ) return;
1163 
1164   // Skip through this block
1165   const Node *p = x;
1166   do {
1167     p = p-&gt;in(0);               // Move control forward
1168     assert( !p-&gt;is_block_proj() || p-&gt;is_Root(), &quot;not a CFG&quot; );
1169   } while( !p-&gt;is_block_start() );
1170 
1171   // Recursively visit
1172   for (uint i = 1; i &lt; p-&gt;req(); i++) {
1173     _dump_cfg(p-&gt;in(i), visited);
1174   }
1175 
1176   // Dump the block
1177   get_block_for_node(p)-&gt;dump(this);
1178 }
1179 
1180 void PhaseCFG::dump( ) const {
1181   tty-&gt;print(&quot;\n--- CFG --- %d BBs\n&quot;, number_of_blocks());
1182   if (_blocks.size()) {        // Did we do basic-block layout?
1183     for (uint i = 0; i &lt; number_of_blocks(); i++) {
1184       const Block* block = get_block(i);
1185       block-&gt;dump(this);
1186     }
1187   } else {                      // Else do it with a DFS
1188     VectorSet visited(_block_arena);
1189     _dump_cfg(_root,visited);
1190   }
1191 }
1192 
1193 void PhaseCFG::dump_headers() {
1194   for (uint i = 0; i &lt; number_of_blocks(); i++) {
1195     Block* block = get_block(i);
1196     if (block != NULL) {
1197       block-&gt;dump_head(this);
1198     }
1199   }
1200 }
1201 
1202 void PhaseCFG::verify() const {
1203 #ifdef ASSERT
1204   // Verify sane CFG
1205   for (uint i = 0; i &lt; number_of_blocks(); i++) {
1206     Block* block = get_block(i);
1207     uint cnt = block-&gt;number_of_nodes();
1208     uint j;
1209     for (j = 0; j &lt; cnt; j++)  {
1210       Node *n = block-&gt;get_node(j);
1211       assert(get_block_for_node(n) == block, &quot;&quot;);
1212       if (j &gt;= 1 &amp;&amp; n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CreateEx) {
1213         assert(j == 1 || block-&gt;get_node(j-1)-&gt;is_Phi(), &quot;CreateEx must be first instruction in block&quot;);
1214       }
1215       if (n-&gt;needs_anti_dependence_check()) {
1216         verify_anti_dependences(block, n);
1217       }
1218       for (uint k = 0; k &lt; n-&gt;req(); k++) {
1219         Node *def = n-&gt;in(k);
1220         if (def &amp;&amp; def != n) {
1221           assert(get_block_for_node(def) || def-&gt;is_Con(), &quot;must have block; constants for debug info ok&quot;);
1222           // Verify that instructions in the block is in correct order.
1223           // Uses must follow their definition if they are at the same block.
1224           // Mostly done to check that MachSpillCopy nodes are placed correctly
1225           // when CreateEx node is moved in build_ifg_physical().
1226           if (get_block_for_node(def) == block &amp;&amp; !(block-&gt;head()-&gt;is_Loop() &amp;&amp; n-&gt;is_Phi()) &amp;&amp;
1227               // See (+++) comment in reg_split.cpp
1228               !(n-&gt;jvms() != NULL &amp;&amp; n-&gt;jvms()-&gt;is_monitor_use(k))) {
1229             bool is_loop = false;
1230             if (n-&gt;is_Phi()) {
1231               for (uint l = 1; l &lt; def-&gt;req(); l++) {
1232                 if (n == def-&gt;in(l)) {
1233                   is_loop = true;
1234                   break; // Some kind of loop
1235                 }
1236               }
1237             }
1238             assert(is_loop || block-&gt;find_node(def) &lt; j, &quot;uses must follow definitions&quot;);
1239           }
1240         }
1241       }
1242     }
1243 
1244     j = block-&gt;end_idx();
1245     Node* bp = (Node*)block-&gt;get_node(block-&gt;number_of_nodes() - 1)-&gt;is_block_proj();
1246     assert(bp, &quot;last instruction must be a block proj&quot;);
1247     assert(bp == block-&gt;get_node(j), &quot;wrong number of successors for this block&quot;);
1248     if (bp-&gt;is_Catch()) {
1249       while (block-&gt;get_node(--j)-&gt;is_MachProj()) {
1250         ;
1251       }
1252       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1253     } else if (bp-&gt;is_Mach() &amp;&amp; bp-&gt;as_Mach()-&gt;ideal_Opcode() == Op_If) {
1254       assert(block-&gt;_num_succs == 2, &quot;Conditional branch must have two targets&quot;);
1255     }
1256   }
1257 #endif
1258 }
1259 #endif
1260 
1261 UnionFind::UnionFind( uint max ) : _cnt(max), _max(max), _indices(NEW_RESOURCE_ARRAY(uint,max)) {
1262   Copy::zero_to_bytes( _indices, sizeof(uint)*max );
1263 }
1264 
1265 void UnionFind::extend( uint from_idx, uint to_idx ) {
1266   _nesting.check();
1267   if( from_idx &gt;= _max ) {
1268     uint size = 16;
1269     while( size &lt;= from_idx ) size &lt;&lt;=1;
1270     _indices = REALLOC_RESOURCE_ARRAY( uint, _indices, _max, size );
1271     _max = size;
1272   }
1273   while( _cnt &lt;= from_idx ) _indices[_cnt++] = 0;
1274   _indices[from_idx] = to_idx;
1275 }
1276 
1277 void UnionFind::reset( uint max ) {
1278   // Force the Union-Find mapping to be at least this large
1279   extend(max,0);
1280   // Initialize to be the ID mapping.
1281   for( uint i=0; i&lt;max; i++ ) map(i,i);
1282 }
1283 
1284 // Straight out of Tarjan&#39;s union-find algorithm
1285 uint UnionFind::Find_compress( uint idx ) {
1286   uint cur  = idx;
1287   uint next = lookup(cur);
1288   while( next != cur ) {        // Scan chain of equivalences
1289     assert( next &lt; cur, &quot;always union smaller&quot; );
1290     cur = next;                 // until find a fixed-point
1291     next = lookup(cur);
1292   }
1293   // Core of union-find algorithm: update chain of
1294   // equivalences to be equal to the root.
1295   while( idx != next ) {
1296     uint tmp = lookup(idx);
1297     map(idx, next);
1298     idx = tmp;
1299   }
1300   return idx;
1301 }
1302 
1303 // Like Find above, but no path compress, so bad asymptotic behavior
1304 uint UnionFind::Find_const( uint idx ) const {
1305   if( idx == 0 ) return idx;    // Ignore the zero idx
1306   // Off the end?  This can happen during debugging dumps
1307   // when data structures have not finished being updated.
1308   if( idx &gt;= _max ) return idx;
1309   uint next = lookup(idx);
1310   while( next != idx ) {        // Scan chain of equivalences
1311     idx = next;                 // until find a fixed-point
1312     next = lookup(idx);
1313   }
1314   return next;
1315 }
1316 
1317 // union 2 sets together.
1318 void UnionFind::Union( uint idx1, uint idx2 ) {
1319   uint src = Find(idx1);
1320   uint dst = Find(idx2);
1321   assert( src, &quot;&quot; );
1322   assert( dst, &quot;&quot; );
1323   assert( src &lt; _max, &quot;oob&quot; );
1324   assert( dst &lt; _max, &quot;oob&quot; );
1325   assert( src &lt; dst, &quot;always union smaller&quot; );
1326   map(dst,src);
1327 }
1328 
1329 #ifndef PRODUCT
1330 void Trace::dump( ) const {
1331   tty-&gt;print_cr(&quot;Trace (freq %f)&quot;, first_block()-&gt;_freq);
1332   for (Block *b = first_block(); b != NULL; b = next(b)) {
1333     tty-&gt;print(&quot;  B%d&quot;, b-&gt;_pre_order);
1334     if (b-&gt;head()-&gt;is_Loop()) {
1335       tty-&gt;print(&quot; (L%d)&quot;, b-&gt;compute_loop_alignment());
1336     }
1337     if (b-&gt;has_loop_alignment()) {
1338       tty-&gt;print(&quot; (T%d)&quot;, b-&gt;code_alignment());
1339     }
1340   }
1341   tty-&gt;cr();
1342 }
1343 
1344 void CFGEdge::dump( ) const {
1345   tty-&gt;print(&quot; B%d  --&gt;  B%d  Freq: %f  out:%3d%%  in:%3d%%  State: &quot;,
1346              from()-&gt;_pre_order, to()-&gt;_pre_order, freq(), _from_pct, _to_pct);
1347   switch(state()) {
1348   case connected:
1349     tty-&gt;print(&quot;connected&quot;);
1350     break;
1351   case open:
1352     tty-&gt;print(&quot;open&quot;);
1353     break;
1354   case interior:
1355     tty-&gt;print(&quot;interior&quot;);
1356     break;
1357   }
1358   if (infrequent()) {
1359     tty-&gt;print(&quot;  infrequent&quot;);
1360   }
1361   tty-&gt;cr();
1362 }
1363 #endif
1364 
1365 // Comparison function for edges
1366 static int edge_order(CFGEdge **e0, CFGEdge **e1) {
1367   float freq0 = (*e0)-&gt;freq();
1368   float freq1 = (*e1)-&gt;freq();
1369   if (freq0 != freq1) {
1370     return freq0 &gt; freq1 ? -1 : 1;
1371   }
1372 
1373   int dist0 = (*e0)-&gt;to()-&gt;_rpo - (*e0)-&gt;from()-&gt;_rpo;
1374   int dist1 = (*e1)-&gt;to()-&gt;_rpo - (*e1)-&gt;from()-&gt;_rpo;
1375 
1376   return dist1 - dist0;
1377 }
1378 
1379 // Comparison function for edges
1380 extern &quot;C&quot; int trace_frequency_order(const void *p0, const void *p1) {
1381   Trace *tr0 = *(Trace **) p0;
1382   Trace *tr1 = *(Trace **) p1;
1383   Block *b0 = tr0-&gt;first_block();
1384   Block *b1 = tr1-&gt;first_block();
1385 
1386   // The trace of connector blocks goes at the end;
1387   // we only expect one such trace
1388   if (b0-&gt;is_connector() != b1-&gt;is_connector()) {
1389     return b1-&gt;is_connector() ? -1 : 1;
1390   }
1391 
1392   // Pull more frequently executed blocks to the beginning
1393   float freq0 = b0-&gt;_freq;
1394   float freq1 = b1-&gt;_freq;
1395   if (freq0 != freq1) {
1396     return freq0 &gt; freq1 ? -1 : 1;
1397   }
1398 
1399   int diff = tr0-&gt;first_block()-&gt;_rpo - tr1-&gt;first_block()-&gt;_rpo;
1400 
1401   return diff;
1402 }
1403 
1404 // Find edges of interest, i.e, those which can fall through. Presumes that
1405 // edges which don&#39;t fall through are of low frequency and can be generally
1406 // ignored.  Initialize the list of traces.
1407 void PhaseBlockLayout::find_edges() {
1408   // Walk the blocks, creating edges and Traces
1409   uint i;
1410   Trace *tr = NULL;
1411   for (i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1412     Block* b = _cfg.get_block(i);
1413     tr = new Trace(b, next, prev);
1414     traces[tr-&gt;id()] = tr;
1415 
1416     // All connector blocks should be at the end of the list
1417     if (b-&gt;is_connector()) break;
1418 
1419     // If this block and the next one have a one-to-one successor
1420     // predecessor relationship, simply append the next block
1421     int nfallthru = b-&gt;num_fall_throughs();
1422     while (nfallthru == 1 &amp;&amp;
1423            b-&gt;succ_fall_through(0)) {
1424       Block *n = b-&gt;_succs[0];
1425 
1426       // Skip over single-entry connector blocks, we don&#39;t want to
1427       // add them to the trace.
1428       while (n-&gt;is_connector() &amp;&amp; n-&gt;num_preds() == 1) {
1429         n = n-&gt;_succs[0];
1430       }
1431 
1432       // We see a merge point, so stop search for the next block
1433       if (n-&gt;num_preds() != 1) break;
1434 
1435       i++;
1436       assert(n == _cfg.get_block(i), &quot;expecting next block&quot;);
1437       tr-&gt;append(n);
1438       uf-&gt;map(n-&gt;_pre_order, tr-&gt;id());
1439       traces[n-&gt;_pre_order] = NULL;
1440       nfallthru = b-&gt;num_fall_throughs();
1441       b = n;
1442     }
1443 
1444     if (nfallthru &gt; 0) {
1445       // Create a CFGEdge for each outgoing
1446       // edge that could be a fall-through.
1447       for (uint j = 0; j &lt; b-&gt;_num_succs; j++ ) {
1448         if (b-&gt;succ_fall_through(j)) {
1449           Block *target = b-&gt;non_connector_successor(j);
1450           float freq = b-&gt;_freq * b-&gt;succ_prob(j);
1451           int from_pct = (int) ((100 * freq) / b-&gt;_freq);
1452           int to_pct = (int) ((100 * freq) / target-&gt;_freq);
1453           edges-&gt;append(new CFGEdge(b, target, freq, from_pct, to_pct));
1454         }
1455       }
1456     }
1457   }
1458 
1459   // Group connector blocks into one trace
1460   for (i++; i &lt; _cfg.number_of_blocks(); i++) {
1461     Block *b = _cfg.get_block(i);
1462     assert(b-&gt;is_connector(), &quot;connector blocks at the end&quot;);
1463     tr-&gt;append(b);
1464     uf-&gt;map(b-&gt;_pre_order, tr-&gt;id());
1465     traces[b-&gt;_pre_order] = NULL;
1466   }
1467 }
1468 
1469 // Union two traces together in uf, and null out the trace in the list
1470 void PhaseBlockLayout::union_traces(Trace* updated_trace, Trace* old_trace) {
1471   uint old_id = old_trace-&gt;id();
1472   uint updated_id = updated_trace-&gt;id();
1473 
1474   uint lo_id = updated_id;
1475   uint hi_id = old_id;
1476 
1477   // If from is greater than to, swap values to meet
1478   // UnionFind guarantee.
1479   if (updated_id &gt; old_id) {
1480     lo_id = old_id;
1481     hi_id = updated_id;
1482 
1483     // Fix up the trace ids
1484     traces[lo_id] = traces[updated_id];
1485     updated_trace-&gt;set_id(lo_id);
1486   }
1487 
1488   // Union the lower with the higher and remove the pointer
1489   // to the higher.
1490   uf-&gt;Union(lo_id, hi_id);
1491   traces[hi_id] = NULL;
1492 }
1493 
1494 // Append traces together via the most frequently executed edges
1495 void PhaseBlockLayout::grow_traces() {
1496   // Order the edges, and drive the growth of Traces via the most
1497   // frequently executed edges.
1498   edges-&gt;sort(edge_order);
1499   for (int i = 0; i &lt; edges-&gt;length(); i++) {
1500     CFGEdge *e = edges-&gt;at(i);
1501 
1502     if (e-&gt;state() != CFGEdge::open) continue;
1503 
1504     Block *src_block = e-&gt;from();
1505     Block *targ_block = e-&gt;to();
1506 
1507     // Don&#39;t grow traces along backedges?
1508     if (!BlockLayoutRotateLoops) {
1509       if (targ_block-&gt;_rpo &lt;= src_block-&gt;_rpo) {
1510         targ_block-&gt;set_loop_alignment(targ_block);
1511         continue;
1512       }
1513     }
1514 
1515     Trace *src_trace = trace(src_block);
1516     Trace *targ_trace = trace(targ_block);
1517 
1518     // If the edge in question can join two traces at their ends,
1519     // append one trace to the other.
1520    if (src_trace-&gt;last_block() == src_block) {
1521       if (src_trace == targ_trace) {
1522         e-&gt;set_state(CFGEdge::interior);
1523         if (targ_trace-&gt;backedge(e)) {
1524           // Reset i to catch any newly eligible edge
1525           // (Or we could remember the first &quot;open&quot; edge, and reset there)
1526           i = 0;
1527         }
1528       } else if (targ_trace-&gt;first_block() == targ_block) {
1529         e-&gt;set_state(CFGEdge::connected);
1530         src_trace-&gt;append(targ_trace);
1531         union_traces(src_trace, targ_trace);
1532       }
1533     }
1534   }
1535 }
1536 
1537 // Embed one trace into another, if the fork or join points are sufficiently
1538 // balanced.
1539 void PhaseBlockLayout::merge_traces(bool fall_thru_only) {
1540   // Walk the edge list a another time, looking at unprocessed edges.
1541   // Fold in diamonds
1542   for (int i = 0; i &lt; edges-&gt;length(); i++) {
1543     CFGEdge *e = edges-&gt;at(i);
1544 
1545     if (e-&gt;state() != CFGEdge::open) continue;
1546     if (fall_thru_only) {
1547       if (e-&gt;infrequent()) continue;
1548     }
1549 
1550     Block *src_block = e-&gt;from();
1551     Trace *src_trace = trace(src_block);
1552     bool src_at_tail = src_trace-&gt;last_block() == src_block;
1553 
1554     Block *targ_block  = e-&gt;to();
1555     Trace *targ_trace  = trace(targ_block);
1556     bool targ_at_start = targ_trace-&gt;first_block() == targ_block;
1557 
1558     if (src_trace == targ_trace) {
1559       // This may be a loop, but we can&#39;t do much about it.
1560       e-&gt;set_state(CFGEdge::interior);
1561       continue;
1562     }
1563 
1564     if (fall_thru_only) {
1565       // If the edge links the middle of two traces, we can&#39;t do anything.
1566       // Mark the edge and continue.
1567       if (!src_at_tail &amp; !targ_at_start) {
1568         continue;
1569       }
1570 
1571       // Don&#39;t grow traces along backedges?
1572       if (!BlockLayoutRotateLoops &amp;&amp; (targ_block-&gt;_rpo &lt;= src_block-&gt;_rpo)) {
1573           continue;
1574       }
1575 
1576       // If both ends of the edge are available, why didn&#39;t we handle it earlier?
1577       assert(src_at_tail ^ targ_at_start, &quot;Should have caught this edge earlier.&quot;);
1578 
1579       if (targ_at_start) {
1580         // Insert the &quot;targ&quot; trace in the &quot;src&quot; trace if the insertion point
1581         // is a two way branch.
1582         // Better profitability check possible, but may not be worth it.
1583         // Someday, see if the this &quot;fork&quot; has an associated &quot;join&quot;;
1584         // then make a policy on merging this trace at the fork or join.
1585         // For example, other things being equal, it may be better to place this
1586         // trace at the join point if the &quot;src&quot; trace ends in a two-way, but
1587         // the insertion point is one-way.
1588         assert(src_block-&gt;num_fall_throughs() == 2, &quot;unexpected diamond&quot;);
1589         e-&gt;set_state(CFGEdge::connected);
1590         src_trace-&gt;insert_after(src_block, targ_trace);
1591         union_traces(src_trace, targ_trace);
1592       } else if (src_at_tail) {
1593         if (src_trace != trace(_cfg.get_root_block())) {
1594           e-&gt;set_state(CFGEdge::connected);
1595           targ_trace-&gt;insert_before(targ_block, src_trace);
1596           union_traces(targ_trace, src_trace);
1597         }
1598       }
1599     } else if (e-&gt;state() == CFGEdge::open) {
1600       // Append traces, even without a fall-thru connection.
1601       // But leave root entry at the beginning of the block list.
1602       if (targ_trace != trace(_cfg.get_root_block())) {
1603         e-&gt;set_state(CFGEdge::connected);
1604         src_trace-&gt;append(targ_trace);
1605         union_traces(src_trace, targ_trace);
1606       }
1607     }
1608   }
1609 }
1610 
1611 // Order the sequence of the traces in some desirable way, and fixup the
1612 // jumps at the end of each block.
1613 void PhaseBlockLayout::reorder_traces(int count) {
1614   ResourceArea *area = Thread::current()-&gt;resource_area();
1615   Trace ** new_traces = NEW_ARENA_ARRAY(area, Trace *, count);
1616   Block_List worklist;
1617   int new_count = 0;
1618 
1619   // Compact the traces.
1620   for (int i = 0; i &lt; count; i++) {
1621     Trace *tr = traces[i];
1622     if (tr != NULL) {
1623       new_traces[new_count++] = tr;
1624     }
1625   }
1626 
1627   // The entry block should be first on the new trace list.
1628   Trace *tr = trace(_cfg.get_root_block());
1629   assert(tr == new_traces[0], &quot;entry trace misplaced&quot;);
1630 
1631   // Sort the new trace list by frequency
1632   qsort(new_traces + 1, new_count - 1, sizeof(new_traces[0]), trace_frequency_order);
1633 
1634   // Patch up the successor blocks
1635   _cfg.clear_blocks();
1636   for (int i = 0; i &lt; new_count; i++) {
1637     Trace *tr = new_traces[i];
1638     if (tr != NULL) {
1639       tr-&gt;fixup_blocks(_cfg);
1640     }
1641   }
1642 }
1643 
1644 // Order basic blocks based on frequency
1645 PhaseBlockLayout::PhaseBlockLayout(PhaseCFG &amp;cfg)
1646 : Phase(BlockLayout)
1647 , _cfg(cfg) {
1648   ResourceMark rm;
1649   ResourceArea *area = Thread::current()-&gt;resource_area();
1650 
1651   // List of traces
1652   int size = _cfg.number_of_blocks() + 1;
1653   traces = NEW_ARENA_ARRAY(area, Trace *, size);
1654   memset(traces, 0, size*sizeof(Trace*));
1655   next = NEW_ARENA_ARRAY(area, Block *, size);
1656   memset(next,   0, size*sizeof(Block *));
1657   prev = NEW_ARENA_ARRAY(area, Block *, size);
1658   memset(prev  , 0, size*sizeof(Block *));
1659 
1660   // List of edges
1661   edges = new GrowableArray&lt;CFGEdge*&gt;;
1662 
1663   // Mapping block index --&gt; block_trace
1664   uf = new UnionFind(size);
1665   uf-&gt;reset(size);
1666 
1667   // Find edges and create traces.
1668   find_edges();
1669 
1670   // Grow traces at their ends via most frequent edges.
1671   grow_traces();
1672 
1673   // Merge one trace into another, but only at fall-through points.
1674   // This may make diamonds and other related shapes in a trace.
1675   merge_traces(true);
1676 
1677   // Run merge again, allowing two traces to be catenated, even if
1678   // one does not fall through into the other. This appends loosely
1679   // related traces to be near each other.
1680   merge_traces(false);
1681 
1682   // Re-order all the remaining traces by frequency
1683   reorder_traces(size);
1684 
1685   assert(_cfg.number_of_blocks() &gt;= (uint) (size - 1), &quot;number of blocks can not shrink&quot;);
1686 }
1687 
1688 
1689 // Edge e completes a loop in a trace. If the target block is head of the
1690 // loop, rotate the loop block so that the loop ends in a conditional branch.
1691 bool Trace::backedge(CFGEdge *e) {
1692   bool loop_rotated = false;
1693   Block *src_block  = e-&gt;from();
1694   Block *targ_block    = e-&gt;to();
1695 
1696   assert(last_block() == src_block, &quot;loop discovery at back branch&quot;);
1697   if (first_block() == targ_block) {
1698     if (BlockLayoutRotateLoops &amp;&amp; last_block()-&gt;num_fall_throughs() &lt; 2) {
1699       // Find the last block in the trace that has a conditional
1700       // branch.
1701       Block *b;
1702       for (b = last_block(); b != NULL; b = prev(b)) {
1703         if (b-&gt;num_fall_throughs() == 2) {
1704           break;
1705         }
1706       }
1707 
1708       if (b != last_block() &amp;&amp; b != NULL) {
1709         loop_rotated = true;
1710 
1711         // Rotate the loop by doing two-part linked-list surgery.
1712         append(first_block());
1713         break_loop_after(b);
1714       }
1715     }
1716 
1717     // Backbranch to the top of a trace
1718     // Scroll forward through the trace from the targ_block. If we find
1719     // a loop head before another loop top, use the the loop head alignment.
1720     for (Block *b = targ_block; b != NULL; b = next(b)) {
1721       if (b-&gt;has_loop_alignment()) {
1722         break;
1723       }
1724       if (b-&gt;head()-&gt;is_Loop()) {
1725         targ_block = b;
1726         break;
1727       }
1728     }
1729 
1730     first_block()-&gt;set_loop_alignment(targ_block);
1731 
1732   } else {
1733     // That loop may already have a loop top (we&#39;re reaching it again
1734     // through the backedge of an outer loop)
1735     Block* b = prev(targ_block);
1736     bool has_top = targ_block-&gt;head()-&gt;is_Loop() &amp;&amp; b-&gt;has_loop_alignment() &amp;&amp; !b-&gt;head()-&gt;is_Loop();
1737     if (!has_top) {
1738       // Backbranch into the middle of a trace
1739       targ_block-&gt;set_loop_alignment(targ_block);
1740     }
1741   }
1742 
1743   return loop_rotated;
1744 }
1745 
1746 // push blocks onto the CFG list
1747 // ensure that blocks have the correct two-way branch sense
1748 void Trace::fixup_blocks(PhaseCFG &amp;cfg) {
1749   Block *last = last_block();
1750   for (Block *b = first_block(); b != NULL; b = next(b)) {
1751     cfg.add_block(b);
1752     if (!b-&gt;is_connector()) {
1753       int nfallthru = b-&gt;num_fall_throughs();
1754       if (b != last) {
1755         if (nfallthru == 2) {
1756           // Ensure that the sense of the branch is correct
1757           Block *bnext = next(b);
1758           Block *bs0 = b-&gt;non_connector_successor(0);
1759 
1760           MachNode *iff = b-&gt;get_node(b-&gt;number_of_nodes() - 3)-&gt;as_Mach();
1761           ProjNode *proj0 = b-&gt;get_node(b-&gt;number_of_nodes() - 2)-&gt;as_Proj();
1762           ProjNode *proj1 = b-&gt;get_node(b-&gt;number_of_nodes() - 1)-&gt;as_Proj();
1763 
1764           if (bnext == bs0) {
1765             // Fall-thru case in succs[0], should be in succs[1]
1766 
1767             // Flip targets in _succs map
1768             Block *tbs0 = b-&gt;_succs[0];
1769             Block *tbs1 = b-&gt;_succs[1];
1770             b-&gt;_succs.map( 0, tbs1 );
1771             b-&gt;_succs.map( 1, tbs0 );
1772 
1773             // Flip projections to match targets
1774             b-&gt;map_node(proj1, b-&gt;number_of_nodes() - 2);
1775             b-&gt;map_node(proj0, b-&gt;number_of_nodes() - 1);
1776           }
1777         }
1778       }
1779     }
1780   }
1781 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
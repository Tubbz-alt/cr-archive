diff a/src/hotspot/share/opto/callnode.hpp b/src/hotspot/share/opto/callnode.hpp
--- a/src/hotspot/share/opto/callnode.hpp
+++ b/src/hotspot/share/opto/callnode.hpp
@@ -61,11 +61,11 @@
 class FastLockNode;
 
 //------------------------------StartNode--------------------------------------
 // The method start node
 class StartNode : public MultiNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   const TypeTuple *_domain;
   StartNode( Node *root, const TypeTuple *domain ) : MultiNode(2), _domain(domain) {
     init_class_id(Class_Start);
@@ -319,11 +319,11 @@
 //------------------------------SafePointNode----------------------------------
 // A SafePointNode is a subclass of a MultiNode for convenience (and
 // potential code sharing) only - conceptually it is independent of
 // the Node semantics.
 class SafePointNode : public MultiNode {
-  virtual uint           cmp( const Node &n ) const;
+  virtual bool           cmp( const Node &n ) const;
   virtual uint           size_of() const;       // Size is bigger
 
 public:
   SafePointNode(uint edges, JVMState* jvms,
                 // A plain safepoint advertises no memory effects (NULL):
@@ -495,11 +495,11 @@
                      // It is relative to the last (youngest) jvms->_scloff.
   uint _n_fields;    // Number of non-static fields of the scalarized object.
   DEBUG_ONLY(AllocateNode* _alloc;)
 
   virtual uint hash() const ; // { return NO_HASH; }
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
 
   uint first_index() const { return _first_index; }
 
 public:
   SafePointScalarObjectNode(const TypeOopPtr* tp,
@@ -596,11 +596,11 @@
 
   virtual const Type *bottom_type() const;
   virtual const Type* Value(PhaseGVN* phase) const;
   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
   virtual Node* Identity(PhaseGVN* phase) { return this; }
-  virtual uint        cmp( const Node &n ) const;
+  virtual bool        cmp( const Node &n ) const;
   virtual uint        size_of() const = 0;
   virtual void        calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
   virtual Node       *match( const ProjNode *proj, const Matcher *m );
   virtual uint        ideal_reg() const { return NotAMachineReg; }
   // Are we guaranteed that this node is a safepoint?  Not true for leaf calls and
@@ -652,11 +652,11 @@
 // convention.  (The "Java" calling convention is the compiler's calling
 // convention, as opposed to the interpreter's or that of native C.)
 class CallJavaNode : public CallNode {
   friend class VMStructs;
 protected:
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 
   bool    _optimized_virtual;
   bool    _method_handle_invoke;
   bool    _override_symbolic_info; // Override symbolic call site info from bytecode
@@ -694,11 +694,11 @@
 //------------------------------CallStaticJavaNode-----------------------------
 // Make a direct subroutine call using Java calling convention (for static
 // calls and optimized virtual calls, plus calls to wrappers for run-time
 // routines); generates static stub.
 class CallStaticJavaNode : public CallJavaNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   CallStaticJavaNode(Compile* C, const TypeFunc* tf, address addr, ciMethod* method, int bci)
     : CallJavaNode(tf, addr, method, bci) {
     init_class_id(Class_CallStaticJava);
@@ -748,11 +748,11 @@
 };
 
 //------------------------------CallDynamicJavaNode----------------------------
 // Make a dispatched call using Java calling convention.
 class CallDynamicJavaNode : public CallJavaNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   CallDynamicJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int vtable_index, int bci ) : CallJavaNode(tf,addr,method,bci), _vtable_index(vtable_index) {
     init_class_id(Class_CallDynamicJava);
   }
@@ -765,11 +765,11 @@
 };
 
 //------------------------------CallRuntimeNode--------------------------------
 // Make a direct subroutine call node into compiled C++ code.
 class CallRuntimeNode : public CallNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   CallRuntimeNode(const TypeFunc* tf, address addr, const char* name,
                   const TypePtr* adr_type)
     : CallNode(tf, addr, adr_type)
@@ -934,10 +934,12 @@
   // inserted at exit of its <.init>, memory barrier for new is not necessary.
   // Inovke this method when MemBar at exit of initializer and post-dominate
   // allocation node.
   void compute_MemBar_redundancy(ciMethod* initializer);
   bool is_allocation_MemBar_redundant() { return _is_allocation_MemBar_redundant; }
+
+  Node* make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem);
 };
 
 //------------------------------AllocateArray---------------------------------
 //
 // High-level array allocation

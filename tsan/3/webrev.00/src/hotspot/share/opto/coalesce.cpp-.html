<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/coalesce.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;opto/block.hpp&quot;
 28 #include &quot;opto/c2compiler.hpp&quot;
 29 #include &quot;opto/cfgnode.hpp&quot;
 30 #include &quot;opto/chaitin.hpp&quot;
 31 #include &quot;opto/coalesce.hpp&quot;
 32 #include &quot;opto/connode.hpp&quot;
 33 #include &quot;opto/indexSet.hpp&quot;
 34 #include &quot;opto/machnode.hpp&quot;
 35 #include &quot;opto/matcher.hpp&quot;
 36 #include &quot;opto/regmask.hpp&quot;
 37 
 38 #ifndef PRODUCT
 39 void PhaseCoalesce::dump(Node *n) const {
 40   // Being a const function means I cannot use &#39;Find&#39;
 41   uint r = _phc._lrg_map.find(n);
 42   tty-&gt;print(&quot;L%d/N%d &quot;,r,n-&gt;_idx);
 43 }
 44 
 45 void PhaseCoalesce::dump() const {
 46   // I know I have a block layout now, so I can print blocks in a loop
 47   for( uint i=0; i&lt;_phc._cfg.number_of_blocks(); i++ ) {
 48     uint j;
 49     Block* b = _phc._cfg.get_block(i);
 50     // Print a nice block header
 51     tty-&gt;print(&quot;B%d: &quot;,b-&gt;_pre_order);
 52     for( j=1; j&lt;b-&gt;num_preds(); j++ )
 53       tty-&gt;print(&quot;B%d &quot;, _phc._cfg.get_block_for_node(b-&gt;pred(j))-&gt;_pre_order);
 54     tty-&gt;print(&quot;-&gt; &quot;);
 55     for( j=0; j&lt;b-&gt;_num_succs; j++ )
 56       tty-&gt;print(&quot;B%d &quot;,b-&gt;_succs[j]-&gt;_pre_order);
 57     tty-&gt;print(&quot; IDom: B%d/#%d\n&quot;, b-&gt;_idom ? b-&gt;_idom-&gt;_pre_order : 0, b-&gt;_dom_depth);
 58     uint cnt = b-&gt;number_of_nodes();
 59     for( j=0; j&lt;cnt; j++ ) {
 60       Node *n = b-&gt;get_node(j);
 61       dump( n );
 62       tty-&gt;print(&quot;\t%s\t&quot;,n-&gt;Name());
 63 
 64       // Dump the inputs
 65       uint k;                   // Exit value of loop
 66       for( k=0; k&lt;n-&gt;req(); k++ ) // For all required inputs
 67         if( n-&gt;in(k) ) dump( n-&gt;in(k) );
 68         else tty-&gt;print(&quot;_ &quot;);
 69       int any_prec = 0;
 70       for( ; k&lt;n-&gt;len(); k++ )          // For all precedence inputs
 71         if( n-&gt;in(k) ) {
 72           if( !any_prec++ ) tty-&gt;print(&quot; |&quot;);
 73           dump( n-&gt;in(k) );
 74         }
 75 
 76       // Dump node-specific info
 77       n-&gt;dump_spec(tty);
 78       tty-&gt;print(&quot;\n&quot;);
 79 
 80     }
 81     tty-&gt;print(&quot;\n&quot;);
 82   }
 83 }
 84 #endif
 85 
 86 // Combine the live ranges def&#39;d by these 2 Nodes.  N2 is an input to N1.
 87 void PhaseCoalesce::combine_these_two(Node *n1, Node *n2) {
 88   uint lr1 = _phc._lrg_map.find(n1);
 89   uint lr2 = _phc._lrg_map.find(n2);
 90   if( lr1 != lr2 &amp;&amp;             // Different live ranges already AND
 91       !_phc._ifg-&gt;test_edge_sq( lr1, lr2 ) ) {  // Do not interfere
 92     LRG *lrg1 = &amp;_phc.lrgs(lr1);
 93     LRG *lrg2 = &amp;_phc.lrgs(lr2);
 94     // Not an oop-&gt;int cast; oop-&gt;oop, int-&gt;int, AND int-&gt;oop are OK.
 95 
 96     // Now, why is int-&gt;oop OK?  We end up declaring a raw-pointer as an oop
 97     // and in general that&#39;s a bad thing.  However, int-&gt;oop conversions only
 98     // happen at GC points, so the lifetime of the misclassified raw-pointer
 99     // is from the CheckCastPP (that converts it to an oop) backwards up
100     // through a merge point and into the slow-path call, and around the
101     // diamond up to the heap-top check and back down into the slow-path call.
102     // The misclassified raw pointer is NOT live across the slow-path call,
103     // and so does not appear in any GC info, so the fact that it is
104     // misclassified is OK.
105 
106     if( (lrg1-&gt;_is_oop || !lrg2-&gt;_is_oop) &amp;&amp; // not an oop-&gt;int cast AND
107         // Compatible final mask
108         lrg1-&gt;mask().overlap( lrg2-&gt;mask() ) ) {
109       // Merge larger into smaller.
110       if( lr1 &gt; lr2 ) {
111         uint  tmp =  lr1;  lr1 =  lr2;  lr2 =  tmp;
112         Node   *n =   n1;   n1 =   n2;   n2 =    n;
113         LRG *ltmp = lrg1; lrg1 = lrg2; lrg2 = ltmp;
114       }
115       // Union lr2 into lr1
116       _phc.Union( n1, n2 );
117       if (lrg1-&gt;_maxfreq &lt; lrg2-&gt;_maxfreq)
118         lrg1-&gt;_maxfreq = lrg2-&gt;_maxfreq;
119       // Merge in the IFG
120       _phc._ifg-&gt;Union( lr1, lr2 );
121       // Combine register restrictions
122       lrg1-&gt;AND(lrg2-&gt;mask());
123     }
124   }
125 }
126 
127 // Copy coalescing
128 void PhaseCoalesce::coalesce_driver() {
129   verify();
130   // Coalesce from high frequency to low
131   for (uint i = 0; i &lt; _phc._cfg.number_of_blocks(); i++) {
132     coalesce(_phc._blks[i]);
133   }
134 }
135 
136 // I am inserting copies to come out of SSA form.  In the general case, I am
137 // doing a parallel renaming.  I&#39;m in the Named world now, so I can&#39;t do a
138 // general parallel renaming.  All the copies now use  &quot;names&quot; (live-ranges)
139 // to carry values instead of the explicit use-def chains.  Suppose I need to
140 // insert 2 copies into the same block.  They copy L161-&gt;L128 and L128-&gt;L132.
141 // If I insert them in the wrong order then L128 will get clobbered before it
142 // can get used by the second copy.  This cannot happen in the SSA model;
143 // direct use-def chains get me the right value.  It DOES happen in the named
144 // model so I have to handle the reordering of copies.
145 //
146 // In general, I need to topo-sort the placed copies to avoid conflicts.
147 // Its possible to have a closed cycle of copies (e.g., recirculating the same
148 // values around a loop).  In this case I need a temp to break the cycle.
149 void PhaseAggressiveCoalesce::insert_copy_with_overlap( Block *b, Node *copy, uint dst_name, uint src_name ) {
150 
151   // Scan backwards for the locations of the last use of the dst_name.
152   // I am about to clobber the dst_name, so the copy must be inserted
153   // after the last use.  Last use is really first-use on a backwards scan.
154   uint i = b-&gt;end_idx()-1;
155   while(1) {
156     Node *n = b-&gt;get_node(i);
157     // Check for end of virtual copies; this is also the end of the
158     // parallel renaming effort.
159     if (n-&gt;_idx &lt; _unique) {
160       break;
161     }
162     uint idx = n-&gt;is_Copy();
163     assert( idx || n-&gt;is_Con() || n-&gt;is_MachProj(), &quot;Only copies during parallel renaming&quot; );
164     if (idx &amp;&amp; _phc._lrg_map.find(n-&gt;in(idx)) == dst_name) {
165       break;
166     }
167     i--;
168   }
169   uint last_use_idx = i;
170 
171   // Also search for any kill of src_name that exits the block.
172   // Since the copy uses src_name, I have to come before any kill.
173   uint kill_src_idx = b-&gt;end_idx();
174   // There can be only 1 kill that exits any block and that is
175   // the last kill.  Thus it is the first kill on a backwards scan.
176   i = b-&gt;end_idx()-1;
177   while (1) {
178     Node *n = b-&gt;get_node(i);
179     // Check for end of virtual copies; this is also the end of the
180     // parallel renaming effort.
181     if (n-&gt;_idx &lt; _unique) {
182       break;
183     }
184     assert( n-&gt;is_Copy() || n-&gt;is_Con() || n-&gt;is_MachProj(), &quot;Only copies during parallel renaming&quot; );
185     if (_phc._lrg_map.find(n) == src_name) {
186       kill_src_idx = i;
187       break;
188     }
189     i--;
190   }
191   // Need a temp?  Last use of dst comes after the kill of src?
192   if (last_use_idx &gt;= kill_src_idx) {
193     // Need to break a cycle with a temp
194     uint idx = copy-&gt;is_Copy();
195     Node *tmp = copy-&gt;clone();
196     uint max_lrg_id = _phc._lrg_map.max_lrg_id();
197     _phc.new_lrg(tmp, max_lrg_id);
198     _phc._lrg_map.set_max_lrg_id(max_lrg_id + 1);
199 
200     // Insert new temp between copy and source
201     tmp -&gt;set_req(idx,copy-&gt;in(idx));
202     copy-&gt;set_req(idx,tmp);
203     // Save source in temp early, before source is killed
204     b-&gt;insert_node(tmp, kill_src_idx);
205     _phc._cfg.map_node_to_block(tmp, b);
206     last_use_idx++;
207   }
208 
209   // Insert just after last use
210   b-&gt;insert_node(copy, last_use_idx + 1);
211 }
212 
213 void PhaseAggressiveCoalesce::insert_copies( Matcher &amp;matcher ) {
214   // We do LRGs compressing and fix a liveout data only here since the other
215   // place in Split() is guarded by the assert which we never hit.
216   _phc._lrg_map.compress_uf_map_for_nodes();
217   // Fix block&#39;s liveout data for compressed live ranges.
218   for (uint lrg = 1; lrg &lt; _phc._lrg_map.max_lrg_id(); lrg++) {
219     uint compressed_lrg = _phc._lrg_map.find(lrg);
220     if (lrg != compressed_lrg) {
221       for (uint bidx = 0; bidx &lt; _phc._cfg.number_of_blocks(); bidx++) {
222         IndexSet *liveout = _phc._live-&gt;live(_phc._cfg.get_block(bidx));
223         if (liveout-&gt;member(lrg)) {
224           liveout-&gt;remove(lrg);
225           liveout-&gt;insert(compressed_lrg);
226         }
227       }
228     }
229   }
230 
231   // All new nodes added are actual copies to replace virtual copies.
232   // Nodes with index less than &#39;_unique&#39; are original, non-virtual Nodes.
233   _unique = C-&gt;unique();
234 
235   for (uint i = 0; i &lt; _phc._cfg.number_of_blocks(); i++) {
236     C-&gt;check_node_count(NodeLimitFudgeFactor, &quot;out of nodes in coalesce&quot;);
237     if (C-&gt;failing()) return;
238     Block *b = _phc._cfg.get_block(i);
239     uint cnt = b-&gt;num_preds();  // Number of inputs to the Phi
240 
241     for( uint l = 1; l&lt;b-&gt;number_of_nodes(); l++ ) {
242       Node *n = b-&gt;get_node(l);
243 
244       // Do not use removed-copies, use copied value instead
245       uint ncnt = n-&gt;req();
246       for( uint k = 1; k&lt;ncnt; k++ ) {
247         Node *copy = n-&gt;in(k);
248         uint cidx = copy-&gt;is_Copy();
249         if( cidx ) {
250           Node *def = copy-&gt;in(cidx);
251           if (_phc._lrg_map.find(copy) == _phc._lrg_map.find(def)) {
252             n-&gt;set_req(k, def);
253           }
254         }
255       }
256 
257       // Remove any explicit copies that get coalesced.
258       uint cidx = n-&gt;is_Copy();
259       if( cidx ) {
260         Node *def = n-&gt;in(cidx);
261         if (_phc._lrg_map.find(n) == _phc._lrg_map.find(def)) {
262           n-&gt;replace_by(def);
263           n-&gt;set_req(cidx,NULL);
264           b-&gt;remove_node(l);
265           l--;
266           continue;
267         }
268       }
269 
270       if (n-&gt;is_Phi()) {
271         // Get the chosen name for the Phi
272         uint phi_name = _phc._lrg_map.find(n);
273         // Ignore the pre-allocated specials
274         if (!phi_name) {
275           continue;
276         }
277         // Check for mismatch inputs to Phi
278         for (uint j = 1; j &lt; cnt; j++) {
279           Node *m = n-&gt;in(j);
280           uint src_name = _phc._lrg_map.find(m);
281           if (src_name != phi_name) {
282             Block *pred = _phc._cfg.get_block_for_node(b-&gt;pred(j));
283             Node *copy;
284             assert(!m-&gt;is_Con() || m-&gt;is_Mach(), &quot;all Con must be Mach&quot;);
285             // Rematerialize constants instead of copying them.
286             // We do this only for immediate constants, we avoid constant table loads
287             // because that will unsafely extend the live range of the constant table base.
288             if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;is_Con() &amp;&amp; !m-&gt;as_Mach()-&gt;is_MachConstant() &amp;&amp;
289                 m-&gt;as_Mach()-&gt;rematerialize()) {
290               copy = m-&gt;clone();
291               // Insert the copy in the predecessor basic block
292               pred-&gt;add_inst(copy);
293               // Copy any flags as well
294               _phc.clone_projs(pred, pred-&gt;end_idx(), m, copy, _phc._lrg_map);
295             } else {
296               uint ireg = m-&gt;ideal_reg();
297               if (ireg == 0 || ireg == Op_RegFlags) {
298                 if (C-&gt;subsume_loads()) {
299                   C-&gt;record_failure(C2Compiler::retry_no_subsuming_loads());
300                 } else {
301                   assert(false, &quot;attempted to spill a non-spillable item: %d: %s, ireg = %u, spill_type: %s&quot;,
302                          m-&gt;_idx, m-&gt;Name(), ireg, MachSpillCopyNode::spill_type(MachSpillCopyNode::PhiInput));
303                   C-&gt;record_method_not_compilable(&quot;attempted to spill a non-spillable item&quot;);
304                 }
305                 return;
306               }
307               const RegMask *rm = C-&gt;matcher()-&gt;idealreg2spillmask[ireg];
308               copy = new MachSpillCopyNode(MachSpillCopyNode::PhiInput, m, *rm, *rm);
309               // Find a good place to insert.  Kinda tricky, use a subroutine
310               insert_copy_with_overlap(pred,copy,phi_name,src_name);
311             }
312             // Insert the copy in the use-def chain
313             n-&gt;set_req(j, copy);
314             _phc._cfg.map_node_to_block(copy, pred);
315             // Extend (&quot;register allocate&quot;) the names array for the copy.
316             _phc._lrg_map.extend(copy-&gt;_idx, phi_name);
317           } // End of if Phi names do not match
318         } // End of for all inputs to Phi
319       } else { // End of if Phi
320 
321         // Now check for 2-address instructions
322         uint idx;
323         if( n-&gt;is_Mach() &amp;&amp; (idx=n-&gt;as_Mach()-&gt;two_adr()) ) {
324           // Get the chosen name for the Node
325           uint name = _phc._lrg_map.find(n);
326           assert (name, &quot;no 2-address specials&quot;);
327           // Check for name mis-match on the 2-address input
328           Node *m = n-&gt;in(idx);
329           if (_phc._lrg_map.find(m) != name) {
330             Node *copy;
331             assert(!m-&gt;is_Con() || m-&gt;is_Mach(), &quot;all Con must be Mach&quot;);
332             // At this point it is unsafe to extend live ranges (6550579).
333             // Rematerialize only constants as we do for Phi above.
334             if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;is_Con() &amp;&amp; !m-&gt;as_Mach()-&gt;is_MachConstant() &amp;&amp;
335                 m-&gt;as_Mach()-&gt;rematerialize()) {
336               copy = m-&gt;clone();
337               // Insert the copy in the basic block, just before us
338               b-&gt;insert_node(copy, l++);
339               l += _phc.clone_projs(b, l, m, copy, _phc._lrg_map);
340             } else {
341               uint ireg = m-&gt;ideal_reg();
342               if (ireg == 0 || ireg == Op_RegFlags) {
343                 assert(false, &quot;attempted to spill a non-spillable item: %d: %s, ireg = %u, spill_type: %s&quot;,
344                        m-&gt;_idx, m-&gt;Name(), ireg, MachSpillCopyNode::spill_type(MachSpillCopyNode::TwoAddress));
345                 C-&gt;record_method_not_compilable(&quot;attempted to spill a non-spillable item&quot;);
346                 return;
347               }
348               const RegMask *rm = C-&gt;matcher()-&gt;idealreg2spillmask[ireg];
349               copy = new MachSpillCopyNode(MachSpillCopyNode::TwoAddress, m, *rm, *rm);
350               // Insert the copy in the basic block, just before us
351               b-&gt;insert_node(copy, l++);
352             }
353             // Insert the copy in the use-def chain
354             n-&gt;set_req(idx, copy);
355             // Extend (&quot;register allocate&quot;) the names array for the copy.
356             _phc._lrg_map.extend(copy-&gt;_idx, name);
357             _phc._cfg.map_node_to_block(copy, b);
358           }
359 
360         } // End of is two-adr
361 
362         // Insert a copy at a debug use for a lrg which has high frequency
363         if (b-&gt;_freq &lt; OPTO_DEBUG_SPLIT_FREQ || _phc._cfg.is_uncommon(b)) {
364           // Walk the debug inputs to the node and check for lrg freq
365           JVMState* jvms = n-&gt;jvms();
366           uint debug_start = jvms ? jvms-&gt;debug_start() : 999999;
367           uint debug_end   = jvms ? jvms-&gt;debug_end()   : 999999;
368           for(uint inpidx = debug_start; inpidx &lt; debug_end; inpidx++) {
369             // Do not split monitors; they are only needed for debug table
370             // entries and need no code.
371             if (jvms-&gt;is_monitor_use(inpidx)) {
372               continue;
373             }
374             Node *inp = n-&gt;in(inpidx);
375             uint nidx = _phc._lrg_map.live_range_id(inp);
376             LRG &amp;lrg = lrgs(nidx);
377 
378             // If this lrg has a high frequency use/def
379             if( lrg._maxfreq &gt;= _phc.high_frequency_lrg() ) {
380               // If the live range is also live out of this block (like it
381               // would be for a fast/slow idiom), the normal spill mechanism
382               // does an excellent job.  If it is not live out of this block
383               // (like it would be for debug info to uncommon trap) splitting
384               // the live range now allows a better allocation in the high
385               // frequency blocks.
386               //   Build_IFG_virtual has converted the live sets to
387               // live-IN info, not live-OUT info.
388               uint k;
389               for( k=0; k &lt; b-&gt;_num_succs; k++ )
390                 if( _phc._live-&gt;live(b-&gt;_succs[k])-&gt;member( nidx ) )
391                   break;      // Live in to some successor block?
392               if( k &lt; b-&gt;_num_succs )
393                 continue;     // Live out; do not pre-split
394               // Split the lrg at this use
395               uint ireg = inp-&gt;ideal_reg();
396               if (ireg == 0 || ireg == Op_RegFlags) {
397                 assert(false, &quot;attempted to spill a non-spillable item: %d: %s, ireg = %u, spill_type: %s&quot;,
398                        inp-&gt;_idx, inp-&gt;Name(), ireg, MachSpillCopyNode::spill_type(MachSpillCopyNode::DebugUse));
399                 C-&gt;record_method_not_compilable(&quot;attempted to spill a non-spillable item&quot;);
400                 return;
401               }
402               const RegMask *rm = C-&gt;matcher()-&gt;idealreg2spillmask[ireg];
403               Node* copy = new MachSpillCopyNode(MachSpillCopyNode::DebugUse, inp, *rm, *rm);
404               // Insert the copy in the use-def chain
405               n-&gt;set_req(inpidx, copy );
406               // Insert the copy in the basic block, just before us
407               b-&gt;insert_node(copy,  l++);
408               // Extend (&quot;register allocate&quot;) the names array for the copy.
409               uint max_lrg_id = _phc._lrg_map.max_lrg_id();
410               _phc.new_lrg(copy, max_lrg_id);
411               _phc._lrg_map.set_max_lrg_id(max_lrg_id + 1);
412               _phc._cfg.map_node_to_block(copy, b);
413               //tty-&gt;print_cr(&quot;Split a debug use in Aggressive Coalesce&quot;);
414             }  // End of if high frequency use/def
415           }  // End of for all debug inputs
416         }  // End of if low frequency safepoint
417 
418       } // End of if Phi
419 
420     } // End of for all instructions
421   } // End of for all blocks
422 }
423 
424 
425 // Aggressive (but pessimistic) copy coalescing of a single block
426 
427 // The following coalesce pass represents a single round of aggressive
428 // pessimistic coalesce.  &quot;Aggressive&quot; means no attempt to preserve
429 // colorability when coalescing.  This occasionally means more spills, but
430 // it also means fewer rounds of coalescing for better code - and that means
431 // faster compiles.
432 
433 // &quot;Pessimistic&quot; means we do not hit the fixed point in one pass (and we are
434 // reaching for the least fixed point to boot).  This is typically solved
435 // with a few more rounds of coalescing, but the compiler must run fast.  We
436 // could optimistically coalescing everything touching PhiNodes together
437 // into one big live range, then check for self-interference.  Everywhere
438 // the live range interferes with self it would have to be split.  Finding
439 // the right split points can be done with some heuristics (based on
440 // expected frequency of edges in the live range).  In short, it&#39;s a real
441 // research problem and the timeline is too short to allow such research.
442 // Further thoughts: (1) build the LR in a pass, (2) find self-interference
443 // in another pass, (3) per each self-conflict, split, (4) split by finding
444 // the low-cost cut (min-cut) of the LR, (5) edges in the LR are weighted
445 // according to the GCM algorithm (or just exec freq on CFG edges).
446 
447 void PhaseAggressiveCoalesce::coalesce( Block *b ) {
448   // Copies are still &quot;virtual&quot; - meaning we have not made them explicitly
449   // copies.  Instead, Phi functions of successor blocks have mis-matched
450   // live-ranges.  If I fail to coalesce, I&#39;ll have to insert a copy to line
451   // up the live-ranges.  Check for Phis in successor blocks.
452   uint i;
453   for( i=0; i&lt;b-&gt;_num_succs; i++ ) {
454     Block *bs = b-&gt;_succs[i];
455     // Find index of &#39;b&#39; in &#39;bs&#39; predecessors
456     uint j=1;
457     while (_phc._cfg.get_block_for_node(bs-&gt;pred(j)) != b) {
458       j++;
459     }
460 
461     // Visit all the Phis in successor block
462     for( uint k = 1; k&lt;bs-&gt;number_of_nodes(); k++ ) {
463       Node *n = bs-&gt;get_node(k);
464       if( !n-&gt;is_Phi() ) break;
465       combine_these_two( n, n-&gt;in(j) );
466     }
467   } // End of for all successor blocks
468 
469 
470   // Check _this_ block for 2-address instructions and copies.
471   uint cnt = b-&gt;end_idx();
472   for( i = 1; i&lt;cnt; i++ ) {
473     Node *n = b-&gt;get_node(i);
474     uint idx;
475     // 2-address instructions have a virtual Copy matching their input
476     // to their output
477     if (n-&gt;is_Mach() &amp;&amp; (idx = n-&gt;as_Mach()-&gt;two_adr())) {
478       MachNode *mach = n-&gt;as_Mach();
479       combine_these_two(mach, mach-&gt;in(idx));
480     }
481   } // End of for all instructions in block
482 }
483 
484 PhaseConservativeCoalesce::PhaseConservativeCoalesce(PhaseChaitin &amp;chaitin) : PhaseCoalesce(chaitin) {
485   _ulr.initialize(_phc._lrg_map.max_lrg_id());
486 }
487 
488 void PhaseConservativeCoalesce::verify() {
489 #ifdef ASSERT
490   _phc.set_was_low();
491 #endif
492 }
493 
494 void PhaseConservativeCoalesce::union_helper( Node *lr1_node, Node *lr2_node, uint lr1, uint lr2, Node *src_def, Node *dst_copy, Node *src_copy, Block *b, uint bindex ) {
495   // Join live ranges.  Merge larger into smaller.  Union lr2 into lr1 in the
496   // union-find tree
497   _phc.Union( lr1_node, lr2_node );
498 
499   // Single-def live range ONLY if both live ranges are single-def.
500   // If both are single def, then src_def powers one live range
501   // and def_copy powers the other.  After merging, src_def powers
502   // the combined live range.
503   lrgs(lr1)._def = (lrgs(lr1).is_multidef() ||
504                         lrgs(lr2).is_multidef() )
505     ? NodeSentinel : src_def;
506   lrgs(lr2)._def = NULL;    // No def for lrg 2
507   lrgs(lr2).Clear();        // Force empty mask for LRG 2
508   //lrgs(lr2)._size = 0;      // Live-range 2 goes dead
509   lrgs(lr1)._is_oop |= lrgs(lr2)._is_oop;
510   lrgs(lr2)._is_oop = 0;    // In particular, not an oop for GC info
511 
512   if (lrgs(lr1)._maxfreq &lt; lrgs(lr2)._maxfreq)
513     lrgs(lr1)._maxfreq = lrgs(lr2)._maxfreq;
514 
515   // Copy original value instead.  Intermediate copies go dead, and
516   // the dst_copy becomes useless.
517   int didx = dst_copy-&gt;is_Copy();
518   dst_copy-&gt;set_req( didx, src_def );
519   // Add copy to free list
520   // _phc.free_spillcopy(b-&gt;_nodes[bindex]);
521   assert( b-&gt;get_node(bindex) == dst_copy, &quot;&quot; );
522   dst_copy-&gt;replace_by( dst_copy-&gt;in(didx) );
523   dst_copy-&gt;set_req( didx, NULL);
524   b-&gt;remove_node(bindex);
525   if( bindex &lt; b-&gt;_ihrp_index ) b-&gt;_ihrp_index--;
526   if( bindex &lt; b-&gt;_fhrp_index ) b-&gt;_fhrp_index--;
527 
528   // Stretched lr1; add it to liveness of intermediate blocks
529   Block *b2 = _phc._cfg.get_block_for_node(src_copy);
530   while( b != b2 ) {
531     b = _phc._cfg.get_block_for_node(b-&gt;pred(1));
532     _phc._live-&gt;live(b)-&gt;insert(lr1);
533   }
534 }
535 
536 // Factored code from copy_copy that computes extra interferences from
537 // lengthening a live range by double-coalescing.
538 uint PhaseConservativeCoalesce::compute_separating_interferences(Node *dst_copy, Node *src_copy, Block *b, uint bindex, RegMask &amp;rm, uint reg_degree, uint rm_size, uint lr1, uint lr2 ) {
539 
540   assert(!lrgs(lr1)._fat_proj, &quot;cannot coalesce fat_proj&quot;);
541   assert(!lrgs(lr2)._fat_proj, &quot;cannot coalesce fat_proj&quot;);
542   Node *prev_copy = dst_copy-&gt;in(dst_copy-&gt;is_Copy());
543   Block *b2 = b;
544   uint bindex2 = bindex;
545   while( 1 ) {
546     // Find previous instruction
547     bindex2--;                  // Chain backwards 1 instruction
548     while( bindex2 == 0 ) {     // At block start, find prior block
549       assert( b2-&gt;num_preds() == 2, &quot;cannot double coalesce across c-flow&quot; );
550       b2 = _phc._cfg.get_block_for_node(b2-&gt;pred(1));
551       bindex2 = b2-&gt;end_idx()-1;
552     }
553     // Get prior instruction
554     assert(bindex2 &lt; b2-&gt;number_of_nodes(), &quot;index out of bounds&quot;);
555     Node *x = b2-&gt;get_node(bindex2);
556     if( x == prev_copy ) {      // Previous copy in copy chain?
557       if( prev_copy == src_copy)// Found end of chain and all interferences
558         break;                  // So break out of loop
559       // Else work back one in copy chain
560       prev_copy = prev_copy-&gt;in(prev_copy-&gt;is_Copy());
561     } else {                    // Else collect interferences
562       uint lidx = _phc._lrg_map.find(x);
563       // Found another def of live-range being stretched?
564       if(lidx == lr1) {
565         return max_juint;
566       }
567       if(lidx == lr2) {
568         return max_juint;
569       }
570 
571       // If we attempt to coalesce across a bound def
572       if( lrgs(lidx).is_bound() ) {
573         // Do not let the coalesced LRG expect to get the bound color
574         rm.SUBTRACT( lrgs(lidx).mask() );
575         // Recompute rm_size
576         rm_size = rm.Size();
577         //if( rm._flags ) rm_size += 1000000;
578         if( reg_degree &gt;= rm_size ) return max_juint;
579       }
580       if( rm.overlap(lrgs(lidx).mask()) ) {
581         // Insert lidx into union LRG; returns TRUE if actually inserted
582         if( _ulr.insert(lidx) ) {
583           // Infinite-stack neighbors do not alter colorability, as they
584           // can always color to some other color.
585           if( !lrgs(lidx).mask().is_AllStack() ) {
586             // If this coalesce will make any new neighbor uncolorable,
587             // do not coalesce.
588             if( lrgs(lidx).just_lo_degree() )
589               return max_juint;
590             // Bump our degree
591             if( ++reg_degree &gt;= rm_size )
592               return max_juint;
593           } // End of if not infinite-stack neighbor
594         } // End of if actually inserted
595       } // End of if live range overlaps
596     } // End of else collect interferences for 1 node
597   } // End of while forever, scan back for interferences
598   return reg_degree;
599 }
600 
601 void PhaseConservativeCoalesce::update_ifg(uint lr1, uint lr2, IndexSet *n_lr1, IndexSet *n_lr2) {
602   // Some original neighbors of lr1 might have gone away
603   // because the constrained register mask prevented them.
604   // Remove lr1 from such neighbors.
605   IndexSetIterator one(n_lr1);
606   uint neighbor;
607   LRG &amp;lrg1 = lrgs(lr1);
608   while ((neighbor = one.next()) != 0)
609     if( !_ulr.member(neighbor) )
610       if( _phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr1) )
611         lrgs(neighbor).inc_degree( -lrg1.compute_degree(lrgs(neighbor)) );
612 
613 
614   // lr2 is now called (coalesced into) lr1.
615   // Remove lr2 from the IFG.
616   IndexSetIterator two(n_lr2);
617   LRG &amp;lrg2 = lrgs(lr2);
618   while ((neighbor = two.next()) != 0)
619     if( _phc._ifg-&gt;neighbors(neighbor)-&gt;remove(lr2) )
620       lrgs(neighbor).inc_degree( -lrg2.compute_degree(lrgs(neighbor)) );
621 
622   // Some neighbors of intermediate copies now interfere with the
623   // combined live range.
624   IndexSetIterator three(&amp;_ulr);
625   while ((neighbor = three.next()) != 0)
626     if( _phc._ifg-&gt;neighbors(neighbor)-&gt;insert(lr1) )
627       lrgs(neighbor).inc_degree( lrg1.compute_degree(lrgs(neighbor)) );
628 }
629 
630 static void record_bias( const PhaseIFG *ifg, int lr1, int lr2 ) {
631   // Tag copy bias here
632   if( !ifg-&gt;lrgs(lr1)._copy_bias )
633     ifg-&gt;lrgs(lr1)._copy_bias = lr2;
634   if( !ifg-&gt;lrgs(lr2)._copy_bias )
635     ifg-&gt;lrgs(lr2)._copy_bias = lr1;
636 }
637 
638 // See if I can coalesce a series of multiple copies together.  I need the
639 // final dest copy and the original src copy.  They can be the same Node.
640 // Compute the compatible register masks.
641 bool PhaseConservativeCoalesce::copy_copy(Node *dst_copy, Node *src_copy, Block *b, uint bindex) {
642 
643   if (!dst_copy-&gt;is_SpillCopy()) {
644     return false;
645   }
646   if (!src_copy-&gt;is_SpillCopy()) {
647     return false;
648   }
649   Node *src_def = src_copy-&gt;in(src_copy-&gt;is_Copy());
650   uint lr1 = _phc._lrg_map.find(dst_copy);
651   uint lr2 = _phc._lrg_map.find(src_def);
652 
653   // Same live ranges already?
654   if (lr1 == lr2) {
655     return false;
656   }
657 
658   // Interfere?
659   if (_phc._ifg-&gt;test_edge_sq(lr1, lr2)) {
660     return false;
661   }
662 
663   // Not an oop-&gt;int cast; oop-&gt;oop, int-&gt;int, AND int-&gt;oop are OK.
664   if (!lrgs(lr1)._is_oop &amp;&amp; lrgs(lr2)._is_oop) { // not an oop-&gt;int cast
665     return false;
666   }
667 
668   // Coalescing between an aligned live range and a mis-aligned live range?
669   // No, no!  Alignment changes how we count degree.
670   if (lrgs(lr1)._fat_proj != lrgs(lr2)._fat_proj) {
671     return false;
672   }
673 
674   // Sort; use smaller live-range number
675   Node *lr1_node = dst_copy;
676   Node *lr2_node = src_def;
677   if (lr1 &gt; lr2) {
678     uint tmp = lr1; lr1 = lr2; lr2 = tmp;
679     lr1_node = src_def;  lr2_node = dst_copy;
680   }
681 
682   // Check for compatibility of the 2 live ranges by
683   // intersecting their allowed register sets.
684   RegMask rm = lrgs(lr1).mask();
685   rm.AND(lrgs(lr2).mask());
686   // Number of bits free
687   uint rm_size = rm.Size();
688 
689   if (UseFPUForSpilling &amp;&amp; rm.is_AllStack() ) {
690     // Don&#39;t coalesce when frequency difference is large
691     Block *dst_b = _phc._cfg.get_block_for_node(dst_copy);
692     Block *src_def_b = _phc._cfg.get_block_for_node(src_def);
693     if (src_def_b-&gt;_freq &gt; 10*dst_b-&gt;_freq )
694       return false;
695   }
696 
697   // If we can use any stack slot, then effective size is infinite
698   if( rm.is_AllStack() ) rm_size += 1000000;
699   // Incompatible masks, no way to coalesce
700   if( rm_size == 0 ) return false;
701 
702   // Another early bail-out test is when we are double-coalescing and the
703   // 2 copies are separated by some control flow.
704   if( dst_copy != src_copy ) {
705     Block *src_b = _phc._cfg.get_block_for_node(src_copy);
706     Block *b2 = b;
707     while( b2 != src_b ) {
708       if( b2-&gt;num_preds() &gt; 2 ){// Found merge-point
709         _phc._lost_opp_cflow_coalesce++;
710         // extra record_bias commented out because Chris believes it is not
711         // productive.  Since we can record only 1 bias, we want to choose one
712         // that stands a chance of working and this one probably does not.
713         //record_bias( _phc._lrgs, lr1, lr2 );
714         return false;           // To hard to find all interferences
715       }
716       b2 = _phc._cfg.get_block_for_node(b2-&gt;pred(1));
717     }
718   }
719 
720   // Union the two interference sets together into &#39;_ulr&#39;
721   uint reg_degree = _ulr.lrg_union( lr1, lr2, rm_size, _phc._ifg, rm );
722 
723   if( reg_degree &gt;= rm_size ) {
724     record_bias( _phc._ifg, lr1, lr2 );
725     return false;
726   }
727 
728   // Now I need to compute all the interferences between dst_copy and
729   // src_copy.  I&#39;m not willing visit the entire interference graph, so
730   // I limit my search to things in dst_copy&#39;s block or in a straight
731   // line of previous blocks.  I give up at merge points or when I get
732   // more interferences than my degree.  I can stop when I find src_copy.
733   if( dst_copy != src_copy ) {
734     reg_degree = compute_separating_interferences(dst_copy, src_copy, b, bindex, rm, rm_size, reg_degree, lr1, lr2 );
735     if( reg_degree == max_juint ) {
736       record_bias( _phc._ifg, lr1, lr2 );
737       return false;
738     }
739   } // End of if dst_copy &amp; src_copy are different
740 
741 
742   // ---- THE COMBINED LRG IS COLORABLE ----
743 
744   // YEAH - Now coalesce this copy away
745   assert( lrgs(lr1).num_regs() == lrgs(lr2).num_regs(),   &quot;&quot; );
746 
747   IndexSet *n_lr1 = _phc._ifg-&gt;neighbors(lr1);
748   IndexSet *n_lr2 = _phc._ifg-&gt;neighbors(lr2);
749 
750   // Update the interference graph
751   update_ifg(lr1, lr2, n_lr1, n_lr2);
752 
753   _ulr.remove(lr1);
754 
755   // Uncomment the following code to trace Coalescing in great detail.
756   //
757   //if (false) {
758   //  tty-&gt;cr();
759   //  tty-&gt;print_cr(&quot;#######################################&quot;);
760   //  tty-&gt;print_cr(&quot;union %d and %d&quot;, lr1, lr2);
761   //  n_lr1-&gt;dump();
762   //  n_lr2-&gt;dump();
763   //  tty-&gt;print_cr(&quot;resulting set is&quot;);
764   //  _ulr.dump();
765   //}
766 
767   // Replace n_lr1 with the new combined live range.  _ulr will use
768   // n_lr1&#39;s old memory on the next iteration.  n_lr2 is cleared to
769   // send its internal memory to the free list.
770   _ulr.swap(n_lr1);
771   _ulr.clear();
772   n_lr2-&gt;clear();
773 
774   lrgs(lr1).set_degree( _phc._ifg-&gt;effective_degree(lr1) );
775   lrgs(lr2).set_degree( 0 );
776 
777   // Join live ranges.  Merge larger into smaller.  Union lr2 into lr1 in the
778   // union-find tree
779   union_helper( lr1_node, lr2_node, lr1, lr2, src_def, dst_copy, src_copy, b, bindex );
780   // Combine register restrictions
781   lrgs(lr1).set_mask(rm);
782   lrgs(lr1).compute_set_mask_size();
783   lrgs(lr1)._cost += lrgs(lr2)._cost;
784   lrgs(lr1)._area += lrgs(lr2)._area;
785 
786   // While its uncommon to successfully coalesce live ranges that started out
787   // being not-lo-degree, it can happen.  In any case the combined coalesced
788   // live range better Simplify nicely.
789   lrgs(lr1)._was_lo = 1;
790 
791   // kinda expensive to do all the time
792   //tty-&gt;print_cr(&quot;warning: slow verify happening&quot;);
793   //_phc._ifg-&gt;verify( &amp;_phc );
794   return true;
795 }
796 
797 // Conservative (but pessimistic) copy coalescing of a single block
798 void PhaseConservativeCoalesce::coalesce( Block *b ) {
799   // Bail out on infrequent blocks
800   if (_phc._cfg.is_uncommon(b)) {
801     return;
802   }
803   // Check this block for copies.
804   for( uint i = 1; i&lt;b-&gt;end_idx(); i++ ) {
805     // Check for actual copies on inputs.  Coalesce a copy into its
806     // input if use and copy&#39;s input are compatible.
807     Node *copy1 = b-&gt;get_node(i);
808     uint idx1 = copy1-&gt;is_Copy();
809     if( !idx1 ) continue;       // Not a copy
810 
811     if( copy_copy(copy1,copy1,b,i) ) {
812       i--;                      // Retry, same location in block
813       PhaseChaitin::_conserv_coalesce++;  // Collect stats on success
814       continue;
815     }
816   }
817 }
    </pre>
  </body>
</html>
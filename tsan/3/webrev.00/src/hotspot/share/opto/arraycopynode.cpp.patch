diff a/src/hotspot/share/opto/arraycopynode.cpp b/src/hotspot/share/opto/arraycopynode.cpp
--- a/src/hotspot/share/opto/arraycopynode.cpp
+++ b/src/hotspot/share/opto/arraycopynode.cpp
@@ -28,10 +28,11 @@
 #include "gc/shared/c2/cardTableBarrierSetC2.hpp"
 #include "opto/arraycopynode.hpp"
 #include "opto/graphKit.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "utilities/macros.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
     _kind(None),
     _alloc_tightly_coupled(alloc_tightly_coupled),
@@ -134,11 +135,11 @@
       // cloning an array we'll do it element by element. If the
       // length input to ArrayCopyNode is constant, length of input
       // array must be too.
 
       assert((get_length_if_constant(phase) == -1) == !ary_src->size()->is_con() ||
-             phase->is_IterGVN(), "inconsistent");
+             phase->is_IterGVN() || StressReflectiveCode, "inconsistent");
 
       if (ary_src->size()->is_con()) {
         return ary_src->size()->get_con();
       }
       return -1;
@@ -266,12 +267,12 @@
       return false;
     }
 
     BasicType src_elem  = ary_src->klass()->as_array_klass()->element_type()->basic_type();
     BasicType dest_elem = ary_dest->klass()->as_array_klass()->element_type()->basic_type();
-    if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;
-    if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;
+    if (is_reference_type(src_elem))   src_elem  = T_OBJECT;
+    if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;
 
     if (src_elem != dest_elem || dest_elem == T_VOID) {
       // We don't know if arguments are arrays of the same type
       return false;
     }
@@ -294,10 +295,14 @@
     adr_src = src;
     adr_dest = dest;
 
     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src->size());
     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest->size());
+    if (src_offset->is_top() || dest_offset->is_top()) {
+      // Offset is out of bounds (the ArrayCopyNode will be removed)
+      return false;
+    }
 
     Node* src_scale = phase->transform(new LShiftXNode(src_offset, phase->intcon(shift)));
     Node* dest_scale = phase->transform(new LShiftXNode(dest_offset, phase->intcon(shift)));
 
     adr_src = phase->transform(new AddPNode(base_src, adr_src, src_scale));
@@ -322,11 +327,11 @@
     adr_dest = dest;
     base_dest = dest->in(AddPNode::Base);
 
     assert(phase->type(src->in(AddPNode::Offset))->is_intptr_t()->get_con() == phase->type(dest->in(AddPNode::Offset))->is_intptr_t()->get_con(), "same start offset?");
     BasicType elem = ary_src->klass()->as_array_klass()->element_type()->basic_type();
-    if (elem == T_ARRAY)  elem = T_OBJECT;
+    if (is_reference_type(elem))  elem = T_OBJECT;
 
     BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
     if (bs->array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {
       return false;
     }
@@ -342,17 +347,16 @@
     value_type = ary_src->elem();
   }
   return true;
 }
 
-const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN *phase, Node* n) {
-  const Type* at = phase->type(n);
-  assert(at != Type::TOP, "unexpected type");
-  const TypePtr* atp = at->isa_ptr();
+const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {
+  if (atp == TypeOopPtr::BOTTOM) {
+    atp = phase->type(n)->isa_ptr();
+  }
   // adjust atp to be the correct array element address type
-  atp = atp->add_offset(Type::OffsetBot);
-  return atp;
+  return atp->add_offset(Type::OffsetBot);
 }
 
 void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*& forward_ctl, Node*& backward_ctl) {
   Node* ctl = in(TypeFunc::Control);
   if (!disjoint_bases && count > 1) {
@@ -568,12 +572,12 @@
     return NULL;
   }
 
   Node* src = in(ArrayCopyNode::Src);
   Node* dest = in(ArrayCopyNode::Dest);
-  const TypePtr* atp_src = get_address_type(phase, src);
-  const TypePtr* atp_dest = get_address_type(phase, dest);
+  const TypePtr* atp_src = get_address_type(phase, _src_type, src);
+  const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);
 
   Node *in_mem = in(TypeFunc::Memory);
   if (!in_mem->is_MergeMem()) {
     in_mem = MergeMemNode::make(in_mem);
   }

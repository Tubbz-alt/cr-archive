<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>
  30 #include &quot;opto/ad.hpp&quot;
  31 #include &quot;opto/addnode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/idealGraphPrinter.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/regmask.hpp&quot;
  39 #include &quot;opto/rootnode.hpp&quot;
  40 #include &quot;opto/runtime.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 #include &quot;runtime/os.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;utilities/align.hpp&quot;
  46 
  47 OptoReg::Name OptoReg::c_frame_pointer;
  48 
  49 const RegMask *Matcher::idealreg2regmask[_last_machine_leaf];
  50 RegMask Matcher::mreg2regmask[_last_Mach_Reg];
  51 RegMask Matcher::STACK_ONLY_mask;
  52 RegMask Matcher::c_frame_ptr_mask;
  53 const uint Matcher::_begin_rematerialize = _BEGIN_REMATERIALIZE;
  54 const uint Matcher::_end_rematerialize   = _END_REMATERIALIZE;
  55 
  56 //---------------------------Matcher-------------------------------------------
  57 Matcher::Matcher()
  58 : PhaseTransform( Phase::Ins_Select ),
  59   _states_arena(Chunk::medium_size, mtCompiler),
  60   _visited(&amp;_states_arena),
  61   _shared(&amp;_states_arena),
  62   _dontcare(&amp;_states_arena),
  63   _reduceOp(reduceOp), _leftOp(leftOp), _rightOp(rightOp),
  64   _swallowed(swallowed),
  65   _begin_inst_chain_rule(_BEGIN_INST_CHAIN_RULE),
  66   _end_inst_chain_rule(_END_INST_CHAIN_RULE),
  67   _must_clone(must_clone),
  68   _shared_nodes(C-&gt;comp_arena()),
  69 #ifdef ASSERT
  70   _old2new_map(C-&gt;comp_arena()),
  71   _new2old_map(C-&gt;comp_arena()),
  72 #endif
  73   _allocation_started(false),
  74   _ruleName(ruleName),
  75   _register_save_policy(register_save_policy),
  76   _c_reg_save_policy(c_reg_save_policy),
  77   _register_save_type(register_save_type) {
  78   C-&gt;set_matcher(this);
  79 
  80   idealreg2spillmask  [Op_RegI] = NULL;
  81   idealreg2spillmask  [Op_RegN] = NULL;
  82   idealreg2spillmask  [Op_RegL] = NULL;
  83   idealreg2spillmask  [Op_RegF] = NULL;
  84   idealreg2spillmask  [Op_RegD] = NULL;
  85   idealreg2spillmask  [Op_RegP] = NULL;
  86   idealreg2spillmask  [Op_VecS] = NULL;
  87   idealreg2spillmask  [Op_VecD] = NULL;
  88   idealreg2spillmask  [Op_VecX] = NULL;
  89   idealreg2spillmask  [Op_VecY] = NULL;
  90   idealreg2spillmask  [Op_VecZ] = NULL;
  91   idealreg2spillmask  [Op_RegFlags] = NULL;
  92 
  93   idealreg2debugmask  [Op_RegI] = NULL;
  94   idealreg2debugmask  [Op_RegN] = NULL;
  95   idealreg2debugmask  [Op_RegL] = NULL;
  96   idealreg2debugmask  [Op_RegF] = NULL;
  97   idealreg2debugmask  [Op_RegD] = NULL;
  98   idealreg2debugmask  [Op_RegP] = NULL;
  99   idealreg2debugmask  [Op_VecS] = NULL;
 100   idealreg2debugmask  [Op_VecD] = NULL;
 101   idealreg2debugmask  [Op_VecX] = NULL;
 102   idealreg2debugmask  [Op_VecY] = NULL;
 103   idealreg2debugmask  [Op_VecZ] = NULL;
 104   idealreg2debugmask  [Op_RegFlags] = NULL;
 105 
 106   idealreg2mhdebugmask[Op_RegI] = NULL;
 107   idealreg2mhdebugmask[Op_RegN] = NULL;
 108   idealreg2mhdebugmask[Op_RegL] = NULL;
 109   idealreg2mhdebugmask[Op_RegF] = NULL;
 110   idealreg2mhdebugmask[Op_RegD] = NULL;
 111   idealreg2mhdebugmask[Op_RegP] = NULL;
 112   idealreg2mhdebugmask[Op_VecS] = NULL;
 113   idealreg2mhdebugmask[Op_VecD] = NULL;
 114   idealreg2mhdebugmask[Op_VecX] = NULL;
 115   idealreg2mhdebugmask[Op_VecY] = NULL;
 116   idealreg2mhdebugmask[Op_VecZ] = NULL;
 117   idealreg2mhdebugmask[Op_RegFlags] = NULL;
 118 
 119   debug_only(_mem_node = NULL;)   // Ideal memory node consumed by mach node
 120 }
 121 
 122 //------------------------------warp_incoming_stk_arg------------------------
 123 // This warps a VMReg into an OptoReg::Name
 124 OptoReg::Name Matcher::warp_incoming_stk_arg( VMReg reg ) {
 125   OptoReg::Name warped;
 126   if( reg-&gt;is_stack() ) {  // Stack slot argument?
 127     warped = OptoReg::add(_old_SP, reg-&gt;reg2stack() );
 128     warped = OptoReg::add(warped, C-&gt;out_preserve_stack_slots());
 129     if( warped &gt;= _in_arg_limit )
 130       _in_arg_limit = OptoReg::add(warped, 1); // Bump max stack slot seen
 131     if (!RegMask::can_represent_arg(warped)) {
 132       // the compiler cannot represent this method&#39;s calling sequence
 133       C-&gt;record_method_not_compilable(&quot;unsupported incoming calling sequence&quot;);
 134       return OptoReg::Bad;
 135     }
 136     return warped;
 137   }
 138   return OptoReg::as_OptoReg(reg);
 139 }
 140 
 141 //---------------------------compute_old_SP------------------------------------
 142 OptoReg::Name Compile::compute_old_SP() {
 143   int fixed    = fixed_slots();
 144   int preserve = in_preserve_stack_slots();
 145   return OptoReg::stack2reg(align_up(fixed + preserve, (int)Matcher::stack_alignment_in_slots()));
 146 }
 147 
 148 
 149 
 150 #ifdef ASSERT
 151 void Matcher::verify_new_nodes_only(Node* xroot) {
 152   // Make sure that the new graph only references new nodes
 153   ResourceMark rm;
 154   Unique_Node_List worklist;
 155   VectorSet visited(Thread::current()-&gt;resource_area());
 156   worklist.push(xroot);
 157   while (worklist.size() &gt; 0) {
 158     Node* n = worklist.pop();
<a name="2" id="anc2"></a><span class="line-modified"> 159     visited &lt;&lt;= n-&gt;_idx;</span>
 160     assert(C-&gt;node_arena()-&gt;contains(n), &quot;dead node&quot;);
 161     for (uint j = 0; j &lt; n-&gt;req(); j++) {
 162       Node* in = n-&gt;in(j);
 163       if (in != NULL) {
 164         assert(C-&gt;node_arena()-&gt;contains(in), &quot;dead node&quot;);
 165         if (!visited.test(in-&gt;_idx)) {
 166           worklist.push(in);
 167         }
 168       }
 169     }
 170   }
 171 }
 172 #endif
 173 
 174 
 175 //---------------------------match---------------------------------------------
 176 void Matcher::match( ) {
 177   if( MaxLabelRootDepth &lt; 100 ) { // Too small?
 178     assert(false, &quot;invalid MaxLabelRootDepth, increase it to 100 minimum&quot;);
 179     MaxLabelRootDepth = 100;
 180   }
 181   // One-time initialization of some register masks.
 182   init_spill_mask( C-&gt;root()-&gt;in(1) );
 183   _return_addr_mask = return_addr();
 184 #ifdef _LP64
 185   // Pointers take 2 slots in 64-bit land
 186   _return_addr_mask.Insert(OptoReg::add(return_addr(),1));
 187 #endif
 188 
 189   // Map a Java-signature return type into return register-value
 190   // machine registers for 0, 1 and 2 returned values.
 191   const TypeTuple *range = C-&gt;tf()-&gt;range();
 192   if( range-&gt;cnt() &gt; TypeFunc::Parms ) { // If not a void function
 193     // Get ideal-register return type
 194     uint ireg = range-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 195     // Get machine return register
 196     uint sop = C-&gt;start()-&gt;Opcode();
 197     OptoRegPair regs = return_value(ireg, false);
 198 
 199     // And mask for same
 200     _return_value_mask = RegMask(regs.first());
 201     if( OptoReg::is_valid(regs.second()) )
 202       _return_value_mask.Insert(regs.second());
 203   }
 204 
 205   // ---------------
 206   // Frame Layout
 207 
 208   // Need the method signature to determine the incoming argument types,
 209   // because the types determine which registers the incoming arguments are
 210   // in, and this affects the matched code.
 211   const TypeTuple *domain = C-&gt;tf()-&gt;domain();
 212   uint             argcnt = domain-&gt;cnt() - TypeFunc::Parms;
 213   BasicType *sig_bt        = NEW_RESOURCE_ARRAY( BasicType, argcnt );
 214   VMRegPair *vm_parm_regs  = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
 215   _parm_regs               = NEW_RESOURCE_ARRAY( OptoRegPair, argcnt );
 216   _calling_convention_mask = NEW_RESOURCE_ARRAY( RegMask, argcnt );
 217   uint i;
 218   for( i = 0; i&lt;argcnt; i++ ) {
 219     sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
 220   }
 221 
 222   // Pass array of ideal registers and length to USER code (from the AD file)
 223   // that will convert this to an array of register numbers.
 224   const StartNode *start = C-&gt;start();
 225   start-&gt;calling_convention( sig_bt, vm_parm_regs, argcnt );
 226 #ifdef ASSERT
 227   // Sanity check users&#39; calling convention.  Real handy while trying to
 228   // get the initial port correct.
 229   { for (uint i = 0; i&lt;argcnt; i++) {
 230       if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 231         assert(domain-&gt;field_at(i+TypeFunc::Parms)==Type::HALF, &quot;only allowed on halve&quot; );
 232         _parm_regs[i].set_bad();
 233         continue;
 234       }
 235       VMReg parm_reg = vm_parm_regs[i].first();
 236       assert(parm_reg-&gt;is_valid(), &quot;invalid arg?&quot;);
 237       if (parm_reg-&gt;is_reg()) {
 238         OptoReg::Name opto_parm_reg = OptoReg::as_OptoReg(parm_reg);
 239         assert(can_be_java_arg(opto_parm_reg) ||
 240                C-&gt;stub_function() == CAST_FROM_FN_PTR(address, OptoRuntime::rethrow_C) ||
 241                opto_parm_reg == inline_cache_reg(),
 242                &quot;parameters in register must be preserved by runtime stubs&quot;);
 243       }
 244       for (uint j = 0; j &lt; i; j++) {
 245         assert(parm_reg != vm_parm_regs[j].first(),
 246                &quot;calling conv. must produce distinct regs&quot;);
 247       }
 248     }
 249   }
 250 #endif
 251 
 252   // Do some initial frame layout.
 253 
 254   // Compute the old incoming SP (may be called FP) as
 255   //   OptoReg::stack0() + locks + in_preserve_stack_slots + pad2.
 256   _old_SP = C-&gt;compute_old_SP();
 257   assert( is_even(_old_SP), &quot;must be even&quot; );
 258 
 259   // Compute highest incoming stack argument as
 260   //   _old_SP + out_preserve_stack_slots + incoming argument size.
 261   _in_arg_limit = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 262   assert( is_even(_in_arg_limit), &quot;out_preserve must be even&quot; );
 263   for( i = 0; i &lt; argcnt; i++ ) {
 264     // Permit args to have no register
 265     _calling_convention_mask[i].Clear();
 266     if( !vm_parm_regs[i].first()-&gt;is_valid() &amp;&amp; !vm_parm_regs[i].second()-&gt;is_valid() ) {
 267       continue;
 268     }
 269     // calling_convention returns stack arguments as a count of
 270     // slots beyond OptoReg::stack0()/VMRegImpl::stack0.  We need to convert this to
 271     // the allocators point of view, taking into account all the
 272     // preserve area, locks &amp; pad2.
 273 
 274     OptoReg::Name reg1 = warp_incoming_stk_arg(vm_parm_regs[i].first());
 275     if( OptoReg::is_valid(reg1))
 276       _calling_convention_mask[i].Insert(reg1);
 277 
 278     OptoReg::Name reg2 = warp_incoming_stk_arg(vm_parm_regs[i].second());
 279     if( OptoReg::is_valid(reg2))
 280       _calling_convention_mask[i].Insert(reg2);
 281 
 282     // Saved biased stack-slot register number
 283     _parm_regs[i].set_pair(reg2, reg1);
 284   }
 285 
 286   // Finally, make sure the incoming arguments take up an even number of
 287   // words, in case the arguments or locals need to contain doubleword stack
 288   // slots.  The rest of the system assumes that stack slot pairs (in
 289   // particular, in the spill area) which look aligned will in fact be
 290   // aligned relative to the stack pointer in the target machine.  Double
 291   // stack slots will always be allocated aligned.
 292   _new_SP = OptoReg::Name(align_up(_in_arg_limit, (int)RegMask::SlotsPerLong));
 293 
 294   // Compute highest outgoing stack argument as
 295   //   _new_SP + out_preserve_stack_slots + max(outgoing argument size).
 296   _out_arg_limit = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
 297   assert( is_even(_out_arg_limit), &quot;out_preserve must be even&quot; );
 298 
 299   if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {
 300     // the compiler cannot represent this method&#39;s calling sequence
 301     C-&gt;record_method_not_compilable(&quot;must be able to represent all call arguments in reg mask&quot;);
 302   }
 303 
 304   if (C-&gt;failing())  return;  // bailed out on incoming arg failure
 305 
 306   // ---------------
 307   // Collect roots of matcher trees.  Every node for which
 308   // _shared[_idx] is cleared is guaranteed to not be shared, and thus
 309   // can be a valid interior of some tree.
 310   find_shared( C-&gt;root() );
 311   find_shared( C-&gt;top() );
 312 
 313   C-&gt;print_method(PHASE_BEFORE_MATCHING);
 314 
 315   // Create new ideal node ConP #NULL even if it does exist in old space
 316   // to avoid false sharing if the corresponding mach node is not used.
 317   // The corresponding mach node is only used in rare cases for derived
 318   // pointers.
 319   Node* new_ideal_null = ConNode::make(TypePtr::NULL_PTR);
 320 
 321   // Swap out to old-space; emptying new-space
 322   Arena *old = C-&gt;node_arena()-&gt;move_contents(C-&gt;old_arena());
 323 
 324   // Save debug and profile information for nodes in old space:
 325   _old_node_note_array = C-&gt;node_note_array();
 326   if (_old_node_note_array != NULL) {
 327     C-&gt;set_node_note_array(new(C-&gt;comp_arena()) GrowableArray&lt;Node_Notes*&gt;
 328                            (C-&gt;comp_arena(), _old_node_note_array-&gt;length(),
 329                             0, NULL));
 330   }
 331 
 332   // Pre-size the new_node table to avoid the need for range checks.
 333   grow_new_node_array(C-&gt;unique());
 334 
 335   // Reset node counter so MachNodes start with _idx at 0
 336   int live_nodes = C-&gt;live_nodes();
 337   C-&gt;set_unique(0);
 338   C-&gt;reset_dead_node_list();
 339 
 340   // Recursively match trees from old space into new space.
 341   // Correct leaves of new-space Nodes; they point to old-space.
<a name="3" id="anc3"></a><span class="line-modified"> 342   _visited.Clear();             // Clear visit bits for xform call</span>
 343   C-&gt;set_cached_top_node(xform( C-&gt;top(), live_nodes ));
 344   if (!C-&gt;failing()) {
 345     Node* xroot =        xform( C-&gt;root(), 1 );
 346     if (xroot == NULL) {
 347       Matcher::soft_match_failure();  // recursive matching process failed
 348       C-&gt;record_method_not_compilable(&quot;instruction match failed&quot;);
 349     } else {
 350       // During matching shared constants were attached to C-&gt;root()
 351       // because xroot wasn&#39;t available yet, so transfer the uses to
 352       // the xroot.
 353       for( DUIterator_Fast jmax, j = C-&gt;root()-&gt;fast_outs(jmax); j &lt; jmax; j++ ) {
 354         Node* n = C-&gt;root()-&gt;fast_out(j);
 355         if (C-&gt;node_arena()-&gt;contains(n)) {
 356           assert(n-&gt;in(0) == C-&gt;root(), &quot;should be control user&quot;);
 357           n-&gt;set_req(0, xroot);
 358           --j;
 359           --jmax;
 360         }
 361       }
 362 
 363       // Generate new mach node for ConP #NULL
 364       assert(new_ideal_null != NULL, &quot;sanity&quot;);
 365       _mach_null = match_tree(new_ideal_null);
 366       // Don&#39;t set control, it will confuse GCM since there are no uses.
 367       // The control will be set when this node is used first time
 368       // in find_base_for_derived().
 369       assert(_mach_null != NULL, &quot;&quot;);
 370 
 371       C-&gt;set_root(xroot-&gt;is_Root() ? xroot-&gt;as_Root() : NULL);
 372 
 373 #ifdef ASSERT
 374       verify_new_nodes_only(xroot);
 375 #endif
 376     }
 377   }
 378   if (C-&gt;top() == NULL || C-&gt;root() == NULL) {
 379     C-&gt;record_method_not_compilable(&quot;graph lost&quot;); // %%% cannot happen?
 380   }
 381   if (C-&gt;failing()) {
 382     // delete old;
 383     old-&gt;destruct_contents();
 384     return;
 385   }
 386   assert( C-&gt;top(), &quot;&quot; );
 387   assert( C-&gt;root(), &quot;&quot; );
 388   validate_null_checks();
 389 
 390   // Now smoke old-space
 391   NOT_DEBUG( old-&gt;destruct_contents() );
 392 
 393   // ------------------------
<a name="4" id="anc4"></a><span class="line-modified"> 394   // Set up save-on-entry registers</span>
 395   Fixup_Save_On_Entry( );
<a name="5" id="anc5"></a><span class="line-removed"> 396 }</span>
 397 
<a name="6" id="anc6"></a>






 398 
 399 //------------------------------Fixup_Save_On_Entry----------------------------
 400 // The stated purpose of this routine is to take care of save-on-entry
 401 // registers.  However, the overall goal of the Match phase is to convert into
 402 // machine-specific instructions which have RegMasks to guide allocation.
 403 // So what this procedure really does is put a valid RegMask on each input
 404 // to the machine-specific variations of all Return, TailCall and Halt
 405 // instructions.  It also adds edgs to define the save-on-entry values (and of
 406 // course gives them a mask).
 407 
 408 static RegMask *init_input_masks( uint size, RegMask &amp;ret_adr, RegMask &amp;fp ) {
 409   RegMask *rms = NEW_RESOURCE_ARRAY( RegMask, size );
 410   // Do all the pre-defined register masks
 411   rms[TypeFunc::Control  ] = RegMask::Empty;
 412   rms[TypeFunc::I_O      ] = RegMask::Empty;
 413   rms[TypeFunc::Memory   ] = RegMask::Empty;
 414   rms[TypeFunc::ReturnAdr] = ret_adr;
 415   rms[TypeFunc::FramePtr ] = fp;
 416   return rms;
 417 }
 418 
<a name="7" id="anc7"></a><span class="line-modified"> 419 //---------------------------init_first_stack_mask-----------------------------</span>

 420 // Create the initial stack mask used by values spilling to the stack.
 421 // Disallow any debug info in outgoing argument areas by setting the
 422 // initial mask accordingly.
 423 void Matcher::init_first_stack_mask() {
 424 
 425   // Allocate storage for spill masks as masks for the appropriate load type.
<a name="8" id="anc8"></a><span class="line-modified"> 426   RegMask *rms = (RegMask*)C-&gt;comp_arena()-&gt;Amalloc_D(sizeof(RegMask) * (3*6+5));</span>





 427 
 428   idealreg2spillmask  [Op_RegN] = &amp;rms[0];
 429   idealreg2spillmask  [Op_RegI] = &amp;rms[1];
 430   idealreg2spillmask  [Op_RegL] = &amp;rms[2];
 431   idealreg2spillmask  [Op_RegF] = &amp;rms[3];
 432   idealreg2spillmask  [Op_RegD] = &amp;rms[4];
 433   idealreg2spillmask  [Op_RegP] = &amp;rms[5];
 434 
 435   idealreg2debugmask  [Op_RegN] = &amp;rms[6];
 436   idealreg2debugmask  [Op_RegI] = &amp;rms[7];
 437   idealreg2debugmask  [Op_RegL] = &amp;rms[8];
 438   idealreg2debugmask  [Op_RegF] = &amp;rms[9];
 439   idealreg2debugmask  [Op_RegD] = &amp;rms[10];
 440   idealreg2debugmask  [Op_RegP] = &amp;rms[11];
 441 
 442   idealreg2mhdebugmask[Op_RegN] = &amp;rms[12];
 443   idealreg2mhdebugmask[Op_RegI] = &amp;rms[13];
 444   idealreg2mhdebugmask[Op_RegL] = &amp;rms[14];
 445   idealreg2mhdebugmask[Op_RegF] = &amp;rms[15];
 446   idealreg2mhdebugmask[Op_RegD] = &amp;rms[16];
 447   idealreg2mhdebugmask[Op_RegP] = &amp;rms[17];
 448 
 449   idealreg2spillmask  [Op_VecS] = &amp;rms[18];
 450   idealreg2spillmask  [Op_VecD] = &amp;rms[19];
 451   idealreg2spillmask  [Op_VecX] = &amp;rms[20];
 452   idealreg2spillmask  [Op_VecY] = &amp;rms[21];
 453   idealreg2spillmask  [Op_VecZ] = &amp;rms[22];
 454 
 455   OptoReg::Name i;
 456 
 457   // At first, start with the empty mask
 458   C-&gt;FIRST_STACK_mask().Clear();
 459 
 460   // Add in the incoming argument area
 461   OptoReg::Name init_in = OptoReg::add(_old_SP, C-&gt;out_preserve_stack_slots());
 462   for (i = init_in; i &lt; _in_arg_limit; i = OptoReg::add(i,1)) {
 463     C-&gt;FIRST_STACK_mask().Insert(i);
 464   }
 465   // Add in all bits past the outgoing argument area
 466   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
 467             &quot;must be able to represent all call arguments in reg mask&quot;);
 468   OptoReg::Name init = _out_arg_limit;
 469   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
 470     C-&gt;FIRST_STACK_mask().Insert(i);
 471   }
 472   // Finally, set the &quot;infinite stack&quot; bit.
 473   C-&gt;FIRST_STACK_mask().set_AllStack();
 474 
 475   // Make spill masks.  Registers for their class, plus FIRST_STACK_mask.
 476   RegMask aligned_stack_mask = C-&gt;FIRST_STACK_mask();
 477   // Keep spill masks aligned.
 478   aligned_stack_mask.clear_to_pairs();
 479   assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 480 
 481   *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];
 482 #ifdef _LP64
 483   *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];
 484    idealreg2spillmask[Op_RegN]-&gt;OR(C-&gt;FIRST_STACK_mask());
 485    idealreg2spillmask[Op_RegP]-&gt;OR(aligned_stack_mask);
 486 #else
 487    idealreg2spillmask[Op_RegP]-&gt;OR(C-&gt;FIRST_STACK_mask());
 488 #endif
 489   *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];
 490    idealreg2spillmask[Op_RegI]-&gt;OR(C-&gt;FIRST_STACK_mask());
 491   *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];
 492    idealreg2spillmask[Op_RegL]-&gt;OR(aligned_stack_mask);
 493   *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];
 494    idealreg2spillmask[Op_RegF]-&gt;OR(C-&gt;FIRST_STACK_mask());
 495   *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];
 496    idealreg2spillmask[Op_RegD]-&gt;OR(aligned_stack_mask);
 497 
 498   if (Matcher::vector_size_supported(T_BYTE,4)) {
 499     *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];
 500      idealreg2spillmask[Op_VecS]-&gt;OR(C-&gt;FIRST_STACK_mask());
 501   }
 502   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 503     // For VecD we need dual alignment and 8 bytes (2 slots) for spills.
 504     // RA guarantees such alignment since it is needed for Double and Long values.
 505     *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];
 506      idealreg2spillmask[Op_VecD]-&gt;OR(aligned_stack_mask);
 507   }
 508   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 509     // For VecX we need quadro alignment and 16 bytes (4 slots) for spills.
 510     //
 511     // RA can use input arguments stack slots for spills but until RA
 512     // we don&#39;t know frame size and offset of input arg stack slots.
 513     //
 514     // Exclude last input arg stack slots to avoid spilling vectors there
 515     // otherwise vector spills could stomp over stack slots in caller frame.
 516     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 517     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecX); k++) {
 518       aligned_stack_mask.Remove(in);
 519       in = OptoReg::add(in, -1);
 520     }
 521      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);
 522      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 523     *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];
 524      idealreg2spillmask[Op_VecX]-&gt;OR(aligned_stack_mask);
 525   }
 526   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 527     // For VecY we need octo alignment and 32 bytes (8 slots) for spills.
 528     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 529     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecY); k++) {
 530       aligned_stack_mask.Remove(in);
 531       in = OptoReg::add(in, -1);
 532     }
 533      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);
 534      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 535     *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];
 536      idealreg2spillmask[Op_VecY]-&gt;OR(aligned_stack_mask);
 537   }
 538   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 539     // For VecZ we need enough alignment and 64 bytes (16 slots) for spills.
 540     OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
 541     for (int k = 1; (in &gt;= init_in) &amp;&amp; (k &lt; RegMask::SlotsPerVecZ); k++) {
 542       aligned_stack_mask.Remove(in);
 543       in = OptoReg::add(in, -1);
 544     }
 545      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);
 546      assert(aligned_stack_mask.is_AllStack(), &quot;should be infinite stack&quot;);
 547     *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];
 548      idealreg2spillmask[Op_VecZ]-&gt;OR(aligned_stack_mask);
 549   }
 550    if (UseFPUForSpilling) {
 551      // This mask logic assumes that the spill operations are
 552      // symmetric and that the registers involved are the same size.
 553      // On sparc for instance we may have to use 64 bit moves will
 554      // kill 2 registers when used with F0-F31.
 555      idealreg2spillmask[Op_RegI]-&gt;OR(*idealreg2regmask[Op_RegF]);
 556      idealreg2spillmask[Op_RegF]-&gt;OR(*idealreg2regmask[Op_RegI]);
 557 #ifdef _LP64
 558      idealreg2spillmask[Op_RegN]-&gt;OR(*idealreg2regmask[Op_RegF]);
 559      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 560      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 561      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegD]);
 562 #else
 563      idealreg2spillmask[Op_RegP]-&gt;OR(*idealreg2regmask[Op_RegF]);
 564 #ifdef ARM
 565      // ARM has support for moving 64bit values between a pair of
 566      // integer registers and a double register
 567      idealreg2spillmask[Op_RegL]-&gt;OR(*idealreg2regmask[Op_RegD]);
 568      idealreg2spillmask[Op_RegD]-&gt;OR(*idealreg2regmask[Op_RegL]);
 569 #endif
 570 #endif
 571    }
 572 
 573   // Make up debug masks.  Any spill slot plus callee-save registers.
 574   // Caller-save registers are assumed to be trashable by the various
 575   // inline-cache fixup routines.
 576   *idealreg2debugmask  [Op_RegN]= *idealreg2spillmask[Op_RegN];
 577   *idealreg2debugmask  [Op_RegI]= *idealreg2spillmask[Op_RegI];
 578   *idealreg2debugmask  [Op_RegL]= *idealreg2spillmask[Op_RegL];
 579   *idealreg2debugmask  [Op_RegF]= *idealreg2spillmask[Op_RegF];
 580   *idealreg2debugmask  [Op_RegD]= *idealreg2spillmask[Op_RegD];
 581   *idealreg2debugmask  [Op_RegP]= *idealreg2spillmask[Op_RegP];
 582 
 583   *idealreg2mhdebugmask[Op_RegN]= *idealreg2spillmask[Op_RegN];
 584   *idealreg2mhdebugmask[Op_RegI]= *idealreg2spillmask[Op_RegI];
 585   *idealreg2mhdebugmask[Op_RegL]= *idealreg2spillmask[Op_RegL];
 586   *idealreg2mhdebugmask[Op_RegF]= *idealreg2spillmask[Op_RegF];
 587   *idealreg2mhdebugmask[Op_RegD]= *idealreg2spillmask[Op_RegD];
 588   *idealreg2mhdebugmask[Op_RegP]= *idealreg2spillmask[Op_RegP];
 589 
 590   // Prevent stub compilations from attempting to reference
 591   // callee-saved registers from debug info
 592   bool exclude_soe = !Compile::current()-&gt;is_method_compilation();
 593 
 594   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 595     // registers the caller has to save do not work
 596     if( _register_save_policy[i] == &#39;C&#39; ||
 597         _register_save_policy[i] == &#39;A&#39; ||
 598         (_register_save_policy[i] == &#39;E&#39; &amp;&amp; exclude_soe) ) {
 599       idealreg2debugmask  [Op_RegN]-&gt;Remove(i);
 600       idealreg2debugmask  [Op_RegI]-&gt;Remove(i); // Exclude save-on-call
 601       idealreg2debugmask  [Op_RegL]-&gt;Remove(i); // registers from debug
 602       idealreg2debugmask  [Op_RegF]-&gt;Remove(i); // masks
 603       idealreg2debugmask  [Op_RegD]-&gt;Remove(i);
 604       idealreg2debugmask  [Op_RegP]-&gt;Remove(i);
 605 
 606       idealreg2mhdebugmask[Op_RegN]-&gt;Remove(i);
 607       idealreg2mhdebugmask[Op_RegI]-&gt;Remove(i);
 608       idealreg2mhdebugmask[Op_RegL]-&gt;Remove(i);
 609       idealreg2mhdebugmask[Op_RegF]-&gt;Remove(i);
 610       idealreg2mhdebugmask[Op_RegD]-&gt;Remove(i);
 611       idealreg2mhdebugmask[Op_RegP]-&gt;Remove(i);
 612     }
 613   }
 614 
 615   // Subtract the register we use to save the SP for MethodHandle
 616   // invokes to from the debug mask.
 617   const RegMask save_mask = method_handle_invoke_SP_save_mask();
 618   idealreg2mhdebugmask[Op_RegN]-&gt;SUBTRACT(save_mask);
 619   idealreg2mhdebugmask[Op_RegI]-&gt;SUBTRACT(save_mask);
 620   idealreg2mhdebugmask[Op_RegL]-&gt;SUBTRACT(save_mask);
 621   idealreg2mhdebugmask[Op_RegF]-&gt;SUBTRACT(save_mask);
 622   idealreg2mhdebugmask[Op_RegD]-&gt;SUBTRACT(save_mask);
 623   idealreg2mhdebugmask[Op_RegP]-&gt;SUBTRACT(save_mask);
 624 }
 625 
 626 //---------------------------is_save_on_entry----------------------------------
 627 bool Matcher::is_save_on_entry( int reg ) {
 628   return
 629     _register_save_policy[reg] == &#39;E&#39; ||
 630     _register_save_policy[reg] == &#39;A&#39; || // Save-on-entry register?
 631     // Also save argument registers in the trampolining stubs
 632     (C-&gt;save_argument_registers() &amp;&amp; is_spillable_arg(reg));
 633 }
 634 
 635 //---------------------------Fixup_Save_On_Entry-------------------------------
 636 void Matcher::Fixup_Save_On_Entry( ) {
 637   init_first_stack_mask();
 638 
 639   Node *root = C-&gt;root();       // Short name for root
 640   // Count number of save-on-entry registers.
 641   uint soe_cnt = number_of_saved_registers();
 642   uint i;
 643 
 644   // Find the procedure Start Node
 645   StartNode *start = C-&gt;start();
 646   assert( start, &quot;Expect a start node&quot; );
 647 
 648   // Save argument registers in the trampolining stubs
 649   if( C-&gt;save_argument_registers() )
 650     for( i = 0; i &lt; _last_Mach_Reg; i++ )
 651       if( is_spillable_arg(i) )
 652         soe_cnt++;
 653 
 654   // Input RegMask array shared by all Returns.
 655   // The type for doubles and longs has a count of 2, but
 656   // there is only 1 returned value
 657   uint ret_edge_cnt = TypeFunc::Parms + ((C-&gt;tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) ? 0 : 1);
 658   RegMask *ret_rms  = init_input_masks( ret_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 659   // Returns have 0 or 1 returned values depending on call signature.
 660   // Return register is specified by return_value in the AD file.
 661   if (ret_edge_cnt &gt; TypeFunc::Parms)
 662     ret_rms[TypeFunc::Parms+0] = _return_value_mask;
 663 
 664   // Input RegMask array shared by all Rethrows.
 665   uint reth_edge_cnt = TypeFunc::Parms+1;
 666   RegMask *reth_rms  = init_input_masks( reth_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 667   // Rethrow takes exception oop only, but in the argument 0 slot.
 668   OptoReg::Name reg = find_receiver(false);
 669   if (reg &gt;= 0) {
 670     reth_rms[TypeFunc::Parms] = mreg2regmask[reg];
 671 #ifdef _LP64
 672     // Need two slots for ptrs in 64-bit land
 673     reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));
 674 #endif
 675   }
 676 
 677   // Input RegMask array shared by all TailCalls
 678   uint tail_call_edge_cnt = TypeFunc::Parms+2;
 679   RegMask *tail_call_rms = init_input_masks( tail_call_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 680 
 681   // Input RegMask array shared by all TailJumps
 682   uint tail_jump_edge_cnt = TypeFunc::Parms+2;
 683   RegMask *tail_jump_rms = init_input_masks( tail_jump_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 684 
 685   // TailCalls have 2 returned values (target &amp; moop), whose masks come
 686   // from the usual MachNode/MachOper mechanism.  Find a sample
 687   // TailCall to extract these masks and put the correct masks into
 688   // the tail_call_rms array.
 689   for( i=1; i &lt; root-&gt;req(); i++ ) {
 690     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 691     if( m-&gt;ideal_Opcode() == Op_TailCall ) {
 692       tail_call_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 693       tail_call_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 694       break;
 695     }
 696   }
 697 
 698   // TailJumps have 2 returned values (target &amp; ex_oop), whose masks come
 699   // from the usual MachNode/MachOper mechanism.  Find a sample
 700   // TailJump to extract these masks and put the correct masks into
 701   // the tail_jump_rms array.
 702   for( i=1; i &lt; root-&gt;req(); i++ ) {
 703     MachReturnNode *m = root-&gt;in(i)-&gt;as_MachReturn();
 704     if( m-&gt;ideal_Opcode() == Op_TailJump ) {
 705       tail_jump_rms[TypeFunc::Parms+0] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+0);
 706       tail_jump_rms[TypeFunc::Parms+1] = m-&gt;MachNode::in_RegMask(TypeFunc::Parms+1);
 707       break;
 708     }
 709   }
 710 
 711   // Input RegMask array shared by all Halts
 712   uint halt_edge_cnt = TypeFunc::Parms;
 713   RegMask *halt_rms = init_input_masks( halt_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );
 714 
 715   // Capture the return input masks into each exit flavor
 716   for( i=1; i &lt; root-&gt;req(); i++ ) {
 717     MachReturnNode *exit = root-&gt;in(i)-&gt;as_MachReturn();
 718     switch( exit-&gt;ideal_Opcode() ) {
 719       case Op_Return   : exit-&gt;_in_rms = ret_rms;  break;
 720       case Op_Rethrow  : exit-&gt;_in_rms = reth_rms; break;
 721       case Op_TailCall : exit-&gt;_in_rms = tail_call_rms; break;
 722       case Op_TailJump : exit-&gt;_in_rms = tail_jump_rms; break;
 723       case Op_Halt     : exit-&gt;_in_rms = halt_rms; break;
 724       default          : ShouldNotReachHere();
 725     }
 726   }
 727 
 728   // Next unused projection number from Start.
 729   int proj_cnt = C-&gt;tf()-&gt;domain()-&gt;cnt();
 730 
 731   // Do all the save-on-entry registers.  Make projections from Start for
 732   // them, and give them a use at the exit points.  To the allocator, they
 733   // look like incoming register arguments.
 734   for( i = 0; i &lt; _last_Mach_Reg; i++ ) {
 735     if( is_save_on_entry(i) ) {
 736 
 737       // Add the save-on-entry to the mask array
 738       ret_rms      [      ret_edge_cnt] = mreg2regmask[i];
 739       reth_rms     [     reth_edge_cnt] = mreg2regmask[i];
 740       tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];
 741       tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];
 742       // Halts need the SOE registers, but only in the stack as debug info.
 743       // A just-prior uncommon-trap or deoptimization will use the SOE regs.
 744       halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];
 745 
 746       Node *mproj;
 747 
 748       // Is this a RegF low half of a RegD?  Double up 2 adjacent RegF&#39;s
 749       // into a single RegD.
 750       if( (i&amp;1) == 0 &amp;&amp;
 751           _register_save_type[i  ] == Op_RegF &amp;&amp;
 752           _register_save_type[i+1] == Op_RegF &amp;&amp;
 753           is_save_on_entry(i+1) ) {
 754         // Add other bit for double
 755         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 756         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 757         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 758         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 759         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 760         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegD );
 761         proj_cnt += 2;          // Skip 2 for doubles
 762       }
 763       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of double
 764                _register_save_type[i-1] == Op_RegF &amp;&amp;
 765                _register_save_type[i  ] == Op_RegF &amp;&amp;
 766                is_save_on_entry(i-1) ) {
 767         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 768         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 769         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 770         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 771         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 772         mproj = C-&gt;top();
 773       }
 774       // Is this a RegI low half of a RegL?  Double up 2 adjacent RegI&#39;s
 775       // into a single RegL.
 776       else if( (i&amp;1) == 0 &amp;&amp;
 777           _register_save_type[i  ] == Op_RegI &amp;&amp;
 778           _register_save_type[i+1] == Op_RegI &amp;&amp;
 779         is_save_on_entry(i+1) ) {
 780         // Add other bit for long
 781         ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));
 782         reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));
 783         tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));
 784         tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));
 785         halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));
 786         mproj = new MachProjNode( start, proj_cnt, ret_rms[ret_edge_cnt], Op_RegL );
 787         proj_cnt += 2;          // Skip 2 for longs
 788       }
 789       else if( (i&amp;1) == 1 &amp;&amp;    // Else check for high half of long
 790                _register_save_type[i-1] == Op_RegI &amp;&amp;
 791                _register_save_type[i  ] == Op_RegI &amp;&amp;
 792                is_save_on_entry(i-1) ) {
 793         ret_rms      [      ret_edge_cnt] = RegMask::Empty;
 794         reth_rms     [     reth_edge_cnt] = RegMask::Empty;
 795         tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;
 796         tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;
 797         halt_rms     [     halt_edge_cnt] = RegMask::Empty;
 798         mproj = C-&gt;top();
 799       } else {
 800         // Make a projection for it off the Start
 801         mproj = new MachProjNode( start, proj_cnt++, ret_rms[ret_edge_cnt], _register_save_type[i] );
 802       }
 803 
 804       ret_edge_cnt ++;
 805       reth_edge_cnt ++;
 806       tail_call_edge_cnt ++;
 807       tail_jump_edge_cnt ++;
 808       halt_edge_cnt ++;
 809 
 810       // Add a use of the SOE register to all exit paths
 811       for( uint j=1; j &lt; root-&gt;req(); j++ )
 812         root-&gt;in(j)-&gt;add_req(mproj);
 813     } // End of if a save-on-entry register
 814   } // End of for all machine registers
 815 }
 816 
 817 //------------------------------init_spill_mask--------------------------------
 818 void Matcher::init_spill_mask( Node *ret ) {
 819   if( idealreg2regmask[Op_RegI] ) return; // One time only init
 820 
 821   OptoReg::c_frame_pointer = c_frame_pointer();
 822   c_frame_ptr_mask = c_frame_pointer();
 823 #ifdef _LP64
 824   // pointers are twice as big
 825   c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));
 826 #endif
 827 
 828   // Start at OptoReg::stack0()
 829   STACK_ONLY_mask.Clear();
 830   OptoReg::Name init = OptoReg::stack2reg(0);
 831   // STACK_ONLY_mask is all stack bits
 832   OptoReg::Name i;
 833   for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))
 834     STACK_ONLY_mask.Insert(i);
 835   // Also set the &quot;infinite stack&quot; bit.
 836   STACK_ONLY_mask.set_AllStack();
 837 
 838   // Copy the register names over into the shared world
 839   for( i=OptoReg::Name(0); i&lt;OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i,1) ) {
 840     // SharedInfo::regName[i] = regName[i];
 841     // Handy RegMasks per machine register
 842     mreg2regmask[i].Insert(i);
 843   }
 844 
 845   // Grab the Frame Pointer
 846   Node *fp  = ret-&gt;in(TypeFunc::FramePtr);
<a name="9" id="anc9"></a><span class="line-removed"> 847   Node *mem = ret-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 848   const TypePtr* atp = TypePtr::BOTTOM;</span>
 849   // Share frame pointer while making spill ops
 850   set_shared(fp);
 851 
<a name="10" id="anc10"></a><span class="line-modified"> 852   // Compute generic short-offset Loads</span>
<span class="line-removed"> 853 #ifdef _LP64</span>
<span class="line-removed"> 854   MachNode *spillCP = match_tree(new LoadNNode(NULL,mem,fp,atp,TypeInstPtr::BOTTOM,MemNode::unordered));</span>
<span class="line-removed"> 855 #endif</span>
<span class="line-removed"> 856   MachNode *spillI  = match_tree(new LoadINode(NULL,mem,fp,atp,TypeInt::INT,MemNode::unordered));</span>
<span class="line-removed"> 857   MachNode *spillL  = match_tree(new LoadLNode(NULL,mem,fp,atp,TypeLong::LONG,MemNode::unordered, LoadNode::DependsOnlyOnTest, false));</span>
<span class="line-removed"> 858   MachNode *spillF  = match_tree(new LoadFNode(NULL,mem,fp,atp,Type::FLOAT,MemNode::unordered));</span>
<span class="line-removed"> 859   MachNode *spillD  = match_tree(new LoadDNode(NULL,mem,fp,atp,Type::DOUBLE,MemNode::unordered));</span>
<span class="line-removed"> 860   MachNode *spillP  = match_tree(new LoadPNode(NULL,mem,fp,atp,TypeInstPtr::BOTTOM,MemNode::unordered));</span>
<span class="line-removed"> 861   assert(spillI != NULL &amp;&amp; spillL != NULL &amp;&amp; spillF != NULL &amp;&amp;</span>
<span class="line-removed"> 862          spillD != NULL &amp;&amp; spillP != NULL, &quot;&quot;);</span>
<span class="line-removed"> 863   // Get the ADLC notion of the right regmask, for each basic type.</span>
 864 #ifdef _LP64
<a name="11" id="anc11"></a><span class="line-modified"> 865   idealreg2regmask[Op_RegN] = &amp;spillCP-&gt;out_RegMask();</span>
 866 #endif
<a name="12" id="anc12"></a><span class="line-modified"> 867   idealreg2regmask[Op_RegI] = &amp;spillI-&gt;out_RegMask();</span>
<span class="line-modified"> 868   idealreg2regmask[Op_RegL] = &amp;spillL-&gt;out_RegMask();</span>
<span class="line-modified"> 869   idealreg2regmask[Op_RegF] = &amp;spillF-&gt;out_RegMask();</span>
<span class="line-modified"> 870   idealreg2regmask[Op_RegD] = &amp;spillD-&gt;out_RegMask();</span>
<span class="line-modified"> 871   idealreg2regmask[Op_RegP] = &amp;spillP-&gt;out_RegMask();</span>
<span class="line-modified"> 872 </span>
<span class="line-modified"> 873   // Vector regmasks.</span>
<span class="line-modified"> 874   if (Matcher::vector_size_supported(T_BYTE,4)) {</span>
<span class="line-modified"> 875     TypeVect::VECTS = TypeVect::make(T_BYTE, 4);</span>
<span class="line-modified"> 876     MachNode *spillVectS = match_tree(new LoadVectorNode(NULL,mem,fp,atp,TypeVect::VECTS));</span>
<span class="line-removed"> 877     idealreg2regmask[Op_VecS] = &amp;spillVectS-&gt;out_RegMask();</span>
<span class="line-removed"> 878   }</span>
<span class="line-removed"> 879   if (Matcher::vector_size_supported(T_FLOAT,2)) {</span>
<span class="line-removed"> 880     MachNode *spillVectD = match_tree(new LoadVectorNode(NULL,mem,fp,atp,TypeVect::VECTD));</span>
<span class="line-removed"> 881     idealreg2regmask[Op_VecD] = &amp;spillVectD-&gt;out_RegMask();</span>
<span class="line-removed"> 882   }</span>
<span class="line-removed"> 883   if (Matcher::vector_size_supported(T_FLOAT,4)) {</span>
<span class="line-removed"> 884     MachNode *spillVectX = match_tree(new LoadVectorNode(NULL,mem,fp,atp,TypeVect::VECTX));</span>
<span class="line-removed"> 885     idealreg2regmask[Op_VecX] = &amp;spillVectX-&gt;out_RegMask();</span>
<span class="line-removed"> 886   }</span>
<span class="line-removed"> 887   if (Matcher::vector_size_supported(T_FLOAT,8)) {</span>
<span class="line-removed"> 888     MachNode *spillVectY = match_tree(new LoadVectorNode(NULL,mem,fp,atp,TypeVect::VECTY));</span>
<span class="line-removed"> 889     idealreg2regmask[Op_VecY] = &amp;spillVectY-&gt;out_RegMask();</span>
<span class="line-removed"> 890   }</span>
<span class="line-removed"> 891   if (Matcher::vector_size_supported(T_FLOAT,16)) {</span>
<span class="line-removed"> 892     MachNode *spillVectZ = match_tree(new LoadVectorNode(NULL,mem,fp,atp,TypeVect::VECTZ));</span>
<span class="line-removed"> 893     idealreg2regmask[Op_VecZ] = &amp;spillVectZ-&gt;out_RegMask();</span>
<span class="line-removed"> 894   }</span>
 895 }
 896 
 897 #ifdef ASSERT
 898 static void match_alias_type(Compile* C, Node* n, Node* m) {
 899   if (!VerifyAliases)  return;  // do not go looking for trouble by default
 900   const TypePtr* nat = n-&gt;adr_type();
 901   const TypePtr* mat = m-&gt;adr_type();
 902   int nidx = C-&gt;get_alias_index(nat);
 903   int midx = C-&gt;get_alias_index(mat);
 904   // Detune the assert for cases like (AndI 0xFF (LoadB p)).
 905   if (nidx == Compile::AliasIdxTop &amp;&amp; midx &gt;= Compile::AliasIdxRaw) {
 906     for (uint i = 1; i &lt; n-&gt;req(); i++) {
 907       Node* n1 = n-&gt;in(i);
 908       const TypePtr* n1at = n1-&gt;adr_type();
 909       if (n1at != NULL) {
 910         nat = n1at;
 911         nidx = C-&gt;get_alias_index(n1at);
 912       }
 913     }
 914   }
 915   // %%% Kludgery.  Instead, fix ideal adr_type methods for all these cases:
 916   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxRaw) {
 917     switch (n-&gt;Opcode()) {
 918     case Op_PrefetchAllocation:
 919       nidx = Compile::AliasIdxRaw;
 920       nat = TypeRawPtr::BOTTOM;
 921       break;
 922     }
 923   }
 924   if (nidx == Compile::AliasIdxRaw &amp;&amp; midx == Compile::AliasIdxTop) {
 925     switch (n-&gt;Opcode()) {
 926     case Op_ClearArray:
 927       midx = Compile::AliasIdxRaw;
 928       mat = TypeRawPtr::BOTTOM;
 929       break;
 930     }
 931   }
 932   if (nidx == Compile::AliasIdxTop &amp;&amp; midx == Compile::AliasIdxBot) {
 933     switch (n-&gt;Opcode()) {
 934     case Op_Return:
 935     case Op_Rethrow:
 936     case Op_Halt:
 937     case Op_TailCall:
 938     case Op_TailJump:
 939       nidx = Compile::AliasIdxBot;
 940       nat = TypePtr::BOTTOM;
 941       break;
 942     }
 943   }
 944   if (nidx == Compile::AliasIdxBot &amp;&amp; midx == Compile::AliasIdxTop) {
 945     switch (n-&gt;Opcode()) {
 946     case Op_StrComp:
 947     case Op_StrEquals:
 948     case Op_StrIndexOf:
 949     case Op_StrIndexOfChar:
 950     case Op_AryEq:
 951     case Op_HasNegatives:
 952     case Op_MemBarVolatile:
 953     case Op_MemBarCPUOrder: // %%% these ideals should have narrower adr_type?
 954     case Op_StrInflatedCopy:
 955     case Op_StrCompressedCopy:
 956     case Op_OnSpinWait:
 957     case Op_EncodeISOArray:
 958       nidx = Compile::AliasIdxTop;
 959       nat = NULL;
 960       break;
 961     }
 962   }
 963   if (nidx != midx) {
 964     if (PrintOpto || (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose))) {
 965       tty-&gt;print_cr(&quot;==== Matcher alias shift %d =&gt; %d&quot;, nidx, midx);
 966       n-&gt;dump();
 967       m-&gt;dump();
 968     }
 969     assert(C-&gt;subsume_loads() &amp;&amp; C-&gt;must_alias(nat, midx),
 970            &quot;must not lose alias info when matching&quot;);
 971   }
 972 }
 973 #endif
 974 
 975 //------------------------------xform------------------------------------------
 976 // Given a Node in old-space, Match him (Label/Reduce) to produce a machine
 977 // Node in new-space.  Given a new-space Node, recursively walk his children.
 978 Node *Matcher::transform( Node *n ) { ShouldNotCallThis(); return n; }
 979 Node *Matcher::xform( Node *n, int max_stack ) {
 980   // Use one stack to keep both: child&#39;s node/state and parent&#39;s node/index
 981   MStack mstack(max_stack * 2 * 2); // usually: C-&gt;live_nodes() * 2 * 2
 982   mstack.push(n, Visit, NULL, -1);  // set NULL as parent to indicate root
 983   while (mstack.is_nonempty()) {
 984     C-&gt;check_node_count(NodeLimitFudgeFactor, &quot;too many nodes matching instructions&quot;);
 985     if (C-&gt;failing()) return NULL;
 986     n = mstack.node();          // Leave node on stack
 987     Node_State nstate = mstack.state();
 988     if (nstate == Visit) {
 989       mstack.set_state(Post_Visit);
 990       Node *oldn = n;
 991       // Old-space or new-space check
 992       if (!C-&gt;node_arena()-&gt;contains(n)) {
 993         // Old space!
 994         Node* m;
 995         if (has_new_node(n)) {  // Not yet Label/Reduced
 996           m = new_node(n);
 997         } else {
 998           if (!is_dontcare(n)) { // Matcher can match this guy
 999             // Calls match special.  They match alone with no children.
1000             // Their children, the incoming arguments, match normally.
1001             m = n-&gt;is_SafePoint() ? match_sfpt(n-&gt;as_SafePoint()):match_tree(n);
1002             if (C-&gt;failing())  return NULL;
1003             if (m == NULL) { Matcher::soft_match_failure(); return NULL; }
1004             if (n-&gt;is_MemBar()) {
1005               m-&gt;as_MachMemBar()-&gt;set_adr_type(n-&gt;adr_type());
1006             }
1007           } else {                  // Nothing the matcher cares about
1008             if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Multi()) {       // Projections?
1009               // Convert to machine-dependent projection
1010               m = n-&gt;in(0)-&gt;as_Multi()-&gt;match( n-&gt;as_Proj(), this );
1011 #ifdef ASSERT
1012               _new2old_map.map(m-&gt;_idx, n);
1013 #endif
1014               if (m-&gt;in(0) != NULL) // m might be top
1015                 collect_null_checks(m, n);
1016             } else {                // Else just a regular &#39;ol guy
1017               m = n-&gt;clone();       // So just clone into new-space
1018 #ifdef ASSERT
1019               _new2old_map.map(m-&gt;_idx, n);
1020 #endif
1021               // Def-Use edges will be added incrementally as Uses
1022               // of this node are matched.
1023               assert(m-&gt;outcnt() == 0, &quot;no Uses of this clone yet&quot;);
1024             }
1025           }
1026 
1027           set_new_node(n, m);       // Map old to new
1028           if (_old_node_note_array != NULL) {
1029             Node_Notes* nn = C-&gt;locate_node_notes(_old_node_note_array,
1030                                                   n-&gt;_idx);
1031             C-&gt;set_node_notes_at(m-&gt;_idx, nn);
1032           }
1033           debug_only(match_alias_type(C, n, m));
1034         }
1035         n = m;    // n is now a new-space node
1036         mstack.set_node(n);
1037       }
1038 
1039       // New space!
1040       if (_visited.test_set(n-&gt;_idx)) continue; // while(mstack.is_nonempty())
1041 
1042       int i;
1043       // Put precedence edges on stack first (match them last).
1044       for (i = oldn-&gt;req(); (uint)i &lt; oldn-&gt;len(); i++) {
1045         Node *m = oldn-&gt;in(i);
1046         if (m == NULL) break;
1047         // set -1 to call add_prec() instead of set_req() during Step1
1048         mstack.push(m, Visit, n, -1);
1049       }
1050 
1051       // Handle precedence edges for interior nodes
1052       for (i = n-&gt;len()-1; (uint)i &gt;= n-&gt;req(); i--) {
1053         Node *m = n-&gt;in(i);
1054         if (m == NULL || C-&gt;node_arena()-&gt;contains(m)) continue;
1055         n-&gt;rm_prec(i);
1056         // set -1 to call add_prec() instead of set_req() during Step1
1057         mstack.push(m, Visit, n, -1);
1058       }
1059 
1060       // For constant debug info, I&#39;d rather have unmatched constants.
1061       int cnt = n-&gt;req();
1062       JVMState* jvms = n-&gt;jvms();
1063       int debug_cnt = jvms ? jvms-&gt;debug_start() : cnt;
1064 
1065       // Now do only debug info.  Clone constants rather than matching.
1066       // Constants are represented directly in the debug info without
1067       // the need for executable machine instructions.
1068       // Monitor boxes are also represented directly.
1069       for (i = cnt - 1; i &gt;= debug_cnt; --i) { // For all debug inputs do
1070         Node *m = n-&gt;in(i);          // Get input
1071         int op = m-&gt;Opcode();
1072         assert((op == Op_BoxLock) == jvms-&gt;is_monitor_use(i), &quot;boxes only at monitor sites&quot;);
1073         if( op == Op_ConI || op == Op_ConP || op == Op_ConN || op == Op_ConNKlass ||
1074             op == Op_ConF || op == Op_ConD || op == Op_ConL
1075             // || op == Op_BoxLock  // %%%% enable this and remove (+++) in chaitin.cpp
1076             ) {
1077           m = m-&gt;clone();
1078 #ifdef ASSERT
1079           _new2old_map.map(m-&gt;_idx, n);
1080 #endif
1081           mstack.push(m, Post_Visit, n, i); // Don&#39;t need to visit
1082           mstack.push(m-&gt;in(0), Visit, m, 0);
1083         } else {
1084           mstack.push(m, Visit, n, i);
1085         }
1086       }
1087 
1088       // And now walk his children, and convert his inputs to new-space.
1089       for( ; i &gt;= 0; --i ) { // For all normal inputs do
1090         Node *m = n-&gt;in(i);  // Get input
1091         if(m != NULL)
1092           mstack.push(m, Visit, n, i);
1093       }
1094 
1095     }
1096     else if (nstate == Post_Visit) {
1097       // Set xformed input
1098       Node *p = mstack.parent();
1099       if (p != NULL) { // root doesn&#39;t have parent
1100         int i = (int)mstack.index();
1101         if (i &gt;= 0)
1102           p-&gt;set_req(i, n); // required input
1103         else if (i == -1)
1104           p-&gt;add_prec(n);   // precedence input
1105         else
1106           ShouldNotReachHere();
1107       }
1108       mstack.pop(); // remove processed node from stack
1109     }
1110     else {
1111       ShouldNotReachHere();
1112     }
1113   } // while (mstack.is_nonempty())
1114   return n; // Return new-space Node
1115 }
1116 
1117 //------------------------------warp_outgoing_stk_arg------------------------
1118 OptoReg::Name Matcher::warp_outgoing_stk_arg( VMReg reg, OptoReg::Name begin_out_arg_area, OptoReg::Name &amp;out_arg_limit_per_call ) {
1119   // Convert outgoing argument location to a pre-biased stack offset
1120   if (reg-&gt;is_stack()) {
1121     OptoReg::Name warped = reg-&gt;reg2stack();
1122     // Adjust the stack slot offset to be the register number used
1123     // by the allocator.
1124     warped = OptoReg::add(begin_out_arg_area, warped);
1125     // Keep track of the largest numbered stack slot used for an arg.
1126     // Largest used slot per call-site indicates the amount of stack
1127     // that is killed by the call.
1128     if( warped &gt;= out_arg_limit_per_call )
1129       out_arg_limit_per_call = OptoReg::add(warped,1);
1130     if (!RegMask::can_represent_arg(warped)) {
1131       C-&gt;record_method_not_compilable(&quot;unsupported calling sequence&quot;);
1132       return OptoReg::Bad;
1133     }
1134     return warped;
1135   }
1136   return OptoReg::as_OptoReg(reg);
1137 }
1138 
1139 
1140 //------------------------------match_sfpt-------------------------------------
1141 // Helper function to match call instructions.  Calls match special.
1142 // They match alone with no children.  Their children, the incoming
1143 // arguments, match normally.
1144 MachNode *Matcher::match_sfpt( SafePointNode *sfpt ) {
1145   MachSafePointNode *msfpt = NULL;
1146   MachCallNode      *mcall = NULL;
1147   uint               cnt;
1148   // Split out case for SafePoint vs Call
1149   CallNode *call;
1150   const TypeTuple *domain;
1151   ciMethod*        method = NULL;
1152   bool             is_method_handle_invoke = false;  // for special kill effects
1153   if( sfpt-&gt;is_Call() ) {
1154     call = sfpt-&gt;as_Call();
1155     domain = call-&gt;tf()-&gt;domain();
1156     cnt = domain-&gt;cnt();
1157 
1158     // Match just the call, nothing else
1159     MachNode *m = match_tree(call);
1160     if (C-&gt;failing())  return NULL;
1161     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
1162 
1163     // Copy data from the Ideal SafePoint to the machine version
1164     mcall = m-&gt;as_MachCall();
1165 
1166     mcall-&gt;set_tf(         call-&gt;tf());
1167     mcall-&gt;set_entry_point(call-&gt;entry_point());
1168     mcall-&gt;set_cnt(        call-&gt;cnt());
1169 
1170     if( mcall-&gt;is_MachCallJava() ) {
1171       MachCallJavaNode *mcall_java  = mcall-&gt;as_MachCallJava();
1172       const CallJavaNode *call_java =  call-&gt;as_CallJava();
1173       assert(call_java-&gt;validate_symbolic_info(), &quot;inconsistent info&quot;);
1174       method = call_java-&gt;method();
1175       mcall_java-&gt;_method = method;
1176       mcall_java-&gt;_bci = call_java-&gt;_bci;
1177       mcall_java-&gt;_optimized_virtual = call_java-&gt;is_optimized_virtual();
1178       is_method_handle_invoke = call_java-&gt;is_method_handle_invoke();
1179       mcall_java-&gt;_method_handle_invoke = is_method_handle_invoke;
1180       mcall_java-&gt;_override_symbolic_info = call_java-&gt;override_symbolic_info();
1181       if (is_method_handle_invoke) {
1182         C-&gt;set_has_method_handle_invokes(true);
1183       }
1184       if( mcall_java-&gt;is_MachCallStaticJava() )
1185         mcall_java-&gt;as_MachCallStaticJava()-&gt;_name =
1186          call_java-&gt;as_CallStaticJava()-&gt;_name;
1187       if( mcall_java-&gt;is_MachCallDynamicJava() )
1188         mcall_java-&gt;as_MachCallDynamicJava()-&gt;_vtable_index =
1189          call_java-&gt;as_CallDynamicJava()-&gt;_vtable_index;
1190     }
1191     else if( mcall-&gt;is_MachCallRuntime() ) {
1192       mcall-&gt;as_MachCallRuntime()-&gt;_name = call-&gt;as_CallRuntime()-&gt;_name;
1193     }
1194     msfpt = mcall;
1195   }
1196   // This is a non-call safepoint
1197   else {
1198     call = NULL;
1199     domain = NULL;
1200     MachNode *mn = match_tree(sfpt);
1201     if (C-&gt;failing())  return NULL;
1202     msfpt = mn-&gt;as_MachSafePoint();
1203     cnt = TypeFunc::Parms;
1204   }
1205 
1206   // Advertise the correct memory effects (for anti-dependence computation).
1207   msfpt-&gt;set_adr_type(sfpt-&gt;adr_type());
1208 
1209   // Allocate a private array of RegMasks.  These RegMasks are not shared.
1210   msfpt-&gt;_in_rms = NEW_RESOURCE_ARRAY( RegMask, cnt );
1211   // Empty them all.
1212   for (uint i = 0; i &lt; cnt; i++) ::new (&amp;(msfpt-&gt;_in_rms[i])) RegMask();
1213 
1214   // Do all the pre-defined non-Empty register masks
1215   msfpt-&gt;_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;
1216   msfpt-&gt;_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;
1217 
1218   // Place first outgoing argument can possibly be put.
1219   OptoReg::Name begin_out_arg_area = OptoReg::add(_new_SP, C-&gt;out_preserve_stack_slots());
1220   assert( is_even(begin_out_arg_area), &quot;&quot; );
1221   // Compute max outgoing register number per call site.
1222   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
1223   // Calls to C may hammer extra stack slots above and beyond any arguments.
1224   // These are usually backing store for register arguments for varargs.
1225   if( call != NULL &amp;&amp; call-&gt;is_CallRuntime() )
1226     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C-&gt;varargs_C_out_slots_killed());
1227 
1228 
1229   // Do the normal argument list (parameters) register masks
1230   int argcnt = cnt - TypeFunc::Parms;
1231   if( argcnt &gt; 0 ) {          // Skip it all if we have no args
1232     BasicType *sig_bt  = NEW_RESOURCE_ARRAY( BasicType, argcnt );
1233     VMRegPair *parm_regs = NEW_RESOURCE_ARRAY( VMRegPair, argcnt );
1234     int i;
1235     for( i = 0; i &lt; argcnt; i++ ) {
1236       sig_bt[i] = domain-&gt;field_at(i+TypeFunc::Parms)-&gt;basic_type();
1237     }
1238     // V-call to pick proper calling convention
1239     call-&gt;calling_convention( sig_bt, parm_regs, argcnt );
1240 
1241 #ifdef ASSERT
1242     // Sanity check users&#39; calling convention.  Really handy during
1243     // the initial porting effort.  Fairly expensive otherwise.
1244     { for (int i = 0; i&lt;argcnt; i++) {
1245       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1246           !parm_regs[i].second()-&gt;is_valid() ) continue;
1247       VMReg reg1 = parm_regs[i].first();
1248       VMReg reg2 = parm_regs[i].second();
1249       for (int j = 0; j &lt; i; j++) {
1250         if( !parm_regs[j].first()-&gt;is_valid() &amp;&amp;
1251             !parm_regs[j].second()-&gt;is_valid() ) continue;
1252         VMReg reg3 = parm_regs[j].first();
1253         VMReg reg4 = parm_regs[j].second();
1254         if( !reg1-&gt;is_valid() ) {
1255           assert( !reg2-&gt;is_valid(), &quot;valid halvsies&quot; );
1256         } else if( !reg3-&gt;is_valid() ) {
1257           assert( !reg4-&gt;is_valid(), &quot;valid halvsies&quot; );
1258         } else {
1259           assert( reg1 != reg2, &quot;calling conv. must produce distinct regs&quot;);
1260           assert( reg1 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1261           assert( reg1 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1262           assert( reg2 != reg3, &quot;calling conv. must produce distinct regs&quot;);
1263           assert( reg2 != reg4 || !reg2-&gt;is_valid(), &quot;calling conv. must produce distinct regs&quot;);
1264           assert( reg3 != reg4, &quot;calling conv. must produce distinct regs&quot;);
1265         }
1266       }
1267     }
1268     }
1269 #endif
1270 
1271     // Visit each argument.  Compute its outgoing register mask.
1272     // Return results now can have 2 bits returned.
1273     // Compute max over all outgoing arguments both per call-site
1274     // and over the entire method.
1275     for( i = 0; i &lt; argcnt; i++ ) {
1276       // Address of incoming argument mask to fill in
1277       RegMask *rm = &amp;mcall-&gt;_in_rms[i+TypeFunc::Parms];
1278       if( !parm_regs[i].first()-&gt;is_valid() &amp;&amp;
1279           !parm_regs[i].second()-&gt;is_valid() ) {
1280         continue;               // Avoid Halves
1281       }
1282       // Grab first register, adjust stack slots and insert in mask.
1283       OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );
1284       if (OptoReg::is_valid(reg1))
1285         rm-&gt;Insert( reg1 );
1286       // Grab second register (if any), adjust stack slots and insert in mask.
1287       OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );
1288       if (OptoReg::is_valid(reg2))
1289         rm-&gt;Insert( reg2 );
1290     } // End of for all arguments
1291 
1292     // Compute number of stack slots needed to restore stack in case of
1293     // Pascal-style argument popping.
1294     mcall-&gt;_argsize = out_arg_limit_per_call - begin_out_arg_area;
1295   }
1296 
1297   // Compute the max stack slot killed by any call.  These will not be
1298   // available for debug info, and will be used to adjust FIRST_STACK_mask
1299   // after all call sites have been visited.
1300   if( _out_arg_limit &lt; out_arg_limit_per_call)
1301     _out_arg_limit = out_arg_limit_per_call;
1302 
1303   if (mcall) {
1304     // Kill the outgoing argument area, including any non-argument holes and
1305     // any legacy C-killed slots.  Use Fat-Projections to do the killing.
1306     // Since the max-per-method covers the max-per-call-site and debug info
1307     // is excluded on the max-per-method basis, debug info cannot land in
1308     // this killed area.
1309     uint r_cnt = mcall-&gt;tf()-&gt;range()-&gt;cnt();
1310     MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );
1311     if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {
1312       C-&gt;record_method_not_compilable(&quot;unsupported outgoing calling sequence&quot;);
1313     } else {
1314       for (int i = begin_out_arg_area; i &lt; out_arg_limit_per_call; i++)
1315         proj-&gt;_rout.Insert(OptoReg::Name(i));
1316     }
1317     if (proj-&gt;_rout.is_NotEmpty()) {
1318       push_projection(proj);
1319     }
1320   }
1321   // Transfer the safepoint information from the call to the mcall
1322   // Move the JVMState list
1323   msfpt-&gt;set_jvms(sfpt-&gt;jvms());
1324   for (JVMState* jvms = msfpt-&gt;jvms(); jvms; jvms = jvms-&gt;caller()) {
1325     jvms-&gt;set_map(sfpt);
1326   }
1327 
1328   // Debug inputs begin just after the last incoming parameter
1329   assert((mcall == NULL) || (mcall-&gt;jvms() == NULL) ||
1330          (mcall-&gt;jvms()-&gt;debug_start() + mcall-&gt;_jvmadj == mcall-&gt;tf()-&gt;domain()-&gt;cnt()), &quot;&quot;);
1331 
1332   // Move the OopMap
1333   msfpt-&gt;_oop_map = sfpt-&gt;_oop_map;
1334 
1335   // Add additional edges.
1336   if (msfpt-&gt;mach_constant_base_node_input() != (uint)-1 &amp;&amp; !msfpt-&gt;is_MachCallLeaf()) {
1337     // For these calls we can not add MachConstantBase in expand(), as the
1338     // ins are not complete then.
1339     msfpt-&gt;ins_req(msfpt-&gt;mach_constant_base_node_input(), C-&gt;mach_constant_base_node());
1340     if (msfpt-&gt;jvms() &amp;&amp;
1341         msfpt-&gt;mach_constant_base_node_input() &lt;= msfpt-&gt;jvms()-&gt;debug_start() + msfpt-&gt;_jvmadj) {
1342       // We added an edge before jvms, so we must adapt the position of the ins.
1343       msfpt-&gt;jvms()-&gt;adapt_position(+1);
1344     }
1345   }
1346 
1347   // Registers killed by the call are set in the local scheduling pass
1348   // of Global Code Motion.
1349   return msfpt;
1350 }
1351 
1352 //---------------------------match_tree----------------------------------------
1353 // Match a Ideal Node DAG - turn it into a tree; Label &amp; Reduce.  Used as part
1354 // of the whole-sale conversion from Ideal to Mach Nodes.  Also used for
1355 // making GotoNodes while building the CFG and in init_spill_mask() to identify
1356 // a Load&#39;s result RegMask for memoization in idealreg2regmask[]
1357 MachNode *Matcher::match_tree( const Node *n ) {
1358   assert( n-&gt;Opcode() != Op_Phi, &quot;cannot match&quot; );
1359   assert( !n-&gt;is_block_start(), &quot;cannot match&quot; );
1360   // Set the mark for all locally allocated State objects.
1361   // When this call returns, the _states_arena arena will be reset
1362   // freeing all State objects.
1363   ResourceMark rm( &amp;_states_arena );
1364 
1365   LabelRootDepth = 0;
1366 
1367   // StoreNodes require their Memory input to match any LoadNodes
1368   Node *mem = n-&gt;is_Store() ? n-&gt;in(MemNode::Memory) : (Node*)1 ;
1369 #ifdef ASSERT
1370   Node* save_mem_node = _mem_node;
1371   _mem_node = n-&gt;is_Store() ? (Node*)n : NULL;
1372 #endif
1373   // State object for root node of match tree
1374   // Allocate it on _states_arena - stack allocation can cause stack overflow.
1375   State *s = new (&amp;_states_arena) State;
1376   s-&gt;_kids[0] = NULL;
1377   s-&gt;_kids[1] = NULL;
1378   s-&gt;_leaf = (Node*)n;
1379   // Label the input tree, allocating labels from top-level arena
1380   Label_Root( n, s, n-&gt;in(0), mem );
1381   if (C-&gt;failing())  return NULL;
1382 
1383   // The minimum cost match for the whole tree is found at the root State
1384   uint mincost = max_juint;
1385   uint cost = max_juint;
1386   uint i;
1387   for( i = 0; i &lt; NUM_OPERANDS; i++ ) {
1388     if( s-&gt;valid(i) &amp;&amp;                // valid entry and
1389         s-&gt;_cost[i] &lt; cost &amp;&amp;         // low cost and
1390         s-&gt;_rule[i] &gt;= NUM_OPERANDS ) // not an operand
1391       cost = s-&gt;_cost[mincost=i];
1392   }
1393   if (mincost == max_juint) {
1394 #ifndef PRODUCT
1395     tty-&gt;print(&quot;No matching rule for:&quot;);
1396     s-&gt;dump();
1397 #endif
1398     Matcher::soft_match_failure();
1399     return NULL;
1400   }
1401   // Reduce input tree based upon the state labels to machine Nodes
1402   MachNode *m = ReduceInst( s, s-&gt;_rule[mincost], mem );
1403 #ifdef ASSERT
1404   _old2new_map.map(n-&gt;_idx, m);
1405   _new2old_map.map(m-&gt;_idx, (Node*)n);
1406 #endif
1407 
1408   // Add any Matcher-ignored edges
1409   uint cnt = n-&gt;req();
1410   uint start = 1;
1411   if( mem != (Node*)1 ) start = MemNode::Memory+1;
1412   if( n-&gt;is_AddP() ) {
1413     assert( mem == (Node*)1, &quot;&quot; );
1414     start = AddPNode::Base+1;
1415   }
1416   for( i = start; i &lt; cnt; i++ ) {
1417     if( !n-&gt;match_edge(i) ) {
1418       if( i &lt; m-&gt;req() )
1419         m-&gt;ins_req( i, n-&gt;in(i) );
1420       else
1421         m-&gt;add_req( n-&gt;in(i) );
1422     }
1423   }
1424 
1425   debug_only( _mem_node = save_mem_node; )
1426   return m;
1427 }
1428 
1429 
1430 //------------------------------match_into_reg---------------------------------
1431 // Choose to either match this Node in a register or part of the current
1432 // match tree.  Return true for requiring a register and false for matching
1433 // as part of the current match tree.
1434 static bool match_into_reg( const Node *n, Node *m, Node *control, int i, bool shared ) {
1435 
1436   const Type *t = m-&gt;bottom_type();
1437 
1438   if (t-&gt;singleton()) {
1439     // Never force constants into registers.  Allow them to match as
1440     // constants or registers.  Copies of the same value will share
1441     // the same register.  See find_shared_node.
1442     return false;
1443   } else {                      // Not a constant
1444     // Stop recursion if they have different Controls.
1445     Node* m_control = m-&gt;in(0);
1446     // Control of load&#39;s memory can post-dominates load&#39;s control.
1447     // So use it since load can&#39;t float above its memory.
1448     Node* mem_control = (m-&gt;is_Load()) ? m-&gt;in(MemNode::Memory)-&gt;in(0) : NULL;
1449     if (control &amp;&amp; m_control &amp;&amp; control != m_control &amp;&amp; control != mem_control) {
1450 
1451       // Actually, we can live with the most conservative control we
1452       // find, if it post-dominates the others.  This allows us to
1453       // pick up load/op/store trees where the load can float a little
1454       // above the store.
1455       Node *x = control;
1456       const uint max_scan = 6;  // Arbitrary scan cutoff
1457       uint j;
1458       for (j=0; j&lt;max_scan; j++) {
1459         if (x-&gt;is_Region())     // Bail out at merge points
1460           return true;
1461         x = x-&gt;in(0);
1462         if (x == m_control)     // Does &#39;control&#39; post-dominate
1463           break;                // m-&gt;in(0)?  If so, we can use it
1464         if (x == mem_control)   // Does &#39;control&#39; post-dominate
1465           break;                // mem_control?  If so, we can use it
1466       }
1467       if (j == max_scan)        // No post-domination before scan end?
1468         return true;            // Then break the match tree up
1469     }
1470     if ((m-&gt;is_DecodeN() &amp;&amp; Matcher::narrow_oop_use_complex_address()) ||
1471         (m-&gt;is_DecodeNKlass() &amp;&amp; Matcher::narrow_klass_use_complex_address())) {
1472       // These are commonly used in address expressions and can
1473       // efficiently fold into them on X64 in some cases.
1474       return false;
1475     }
1476   }
1477 
1478   // Not forceable cloning.  If shared, put it into a register.
1479   return shared;
1480 }
1481 
1482 
1483 //------------------------------Instruction Selection--------------------------
1484 // Label method walks a &quot;tree&quot; of nodes, using the ADLC generated DFA to match
1485 // ideal nodes to machine instructions.  Trees are delimited by shared Nodes,
1486 // things the Matcher does not match (e.g., Memory), and things with different
1487 // Controls (hence forced into different blocks).  We pass in the Control
1488 // selected for this entire State tree.
1489 
1490 // The Matcher works on Trees, but an Intel add-to-memory requires a DAG: the
1491 // Store and the Load must have identical Memories (as well as identical
1492 // pointers).  Since the Matcher does not have anything for Memory (and
1493 // does not handle DAGs), I have to match the Memory input myself.  If the
1494 // Tree root is a Store, I require all Loads to have the identical memory.
1495 Node *Matcher::Label_Root( const Node *n, State *svec, Node *control, const Node *mem){
1496   // Since Label_Root is a recursive function, its possible that we might run
1497   // out of stack space.  See bugs 6272980 &amp; 6227033 for more info.
1498   LabelRootDepth++;
1499   if (LabelRootDepth &gt; MaxLabelRootDepth) {
1500     C-&gt;record_method_not_compilable(&quot;Out of stack space, increase MaxLabelRootDepth&quot;);
1501     return NULL;
1502   }
1503   uint care = 0;                // Edges matcher cares about
1504   uint cnt = n-&gt;req();
1505   uint i = 0;
1506 
1507   // Examine children for memory state
1508   // Can only subsume a child into your match-tree if that child&#39;s memory state
1509   // is not modified along the path to another input.
1510   // It is unsafe even if the other inputs are separate roots.
1511   Node *input_mem = NULL;
1512   for( i = 1; i &lt; cnt; i++ ) {
1513     if( !n-&gt;match_edge(i) ) continue;
1514     Node *m = n-&gt;in(i);         // Get ith input
1515     assert( m, &quot;expect non-null children&quot; );
1516     if( m-&gt;is_Load() ) {
1517       if( input_mem == NULL ) {
1518         input_mem = m-&gt;in(MemNode::Memory);
1519       } else if( input_mem != m-&gt;in(MemNode::Memory) ) {
1520         input_mem = NodeSentinel;
1521       }
1522     }
1523   }
1524 
1525   for( i = 1; i &lt; cnt; i++ ){// For my children
1526     if( !n-&gt;match_edge(i) ) continue;
1527     Node *m = n-&gt;in(i);         // Get ith input
1528     // Allocate states out of a private arena
1529     State *s = new (&amp;_states_arena) State;
1530     svec-&gt;_kids[care++] = s;
1531     assert( care &lt;= 2, &quot;binary only for now&quot; );
1532 
1533     // Recursively label the State tree.
1534     s-&gt;_kids[0] = NULL;
1535     s-&gt;_kids[1] = NULL;
1536     s-&gt;_leaf = m;
1537 
1538     // Check for leaves of the State Tree; things that cannot be a part of
1539     // the current tree.  If it finds any, that value is matched as a
1540     // register operand.  If not, then the normal matching is used.
1541     if( match_into_reg(n, m, control, i, is_shared(m)) ||
1542         //
1543         // Stop recursion if this is LoadNode and the root of this tree is a
1544         // StoreNode and the load &amp; store have different memories.
1545         ((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem) ||
1546         // Can NOT include the match of a subtree when its memory state
1547         // is used by any of the other subtrees
1548         (input_mem == NodeSentinel) ) {
1549       // Print when we exclude matching due to different memory states at input-loads
1550       if (PrintOpto &amp;&amp; (Verbose &amp;&amp; WizardMode) &amp;&amp; (input_mem == NodeSentinel)
1551         &amp;&amp; !((mem!=(Node*)1) &amp;&amp; m-&gt;is_Load() &amp;&amp; m-&gt;in(MemNode::Memory) != mem)) {
1552         tty-&gt;print_cr(&quot;invalid input_mem&quot;);
1553       }
1554       // Switch to a register-only opcode; this value must be in a register
1555       // and cannot be subsumed as part of a larger instruction.
1556       s-&gt;DFA( m-&gt;ideal_reg(), m );
1557 
1558     } else {
1559       // If match tree has no control and we do, adopt it for entire tree
1560       if( control == NULL &amp;&amp; m-&gt;in(0) != NULL &amp;&amp; m-&gt;req() &gt; 1 )
1561         control = m-&gt;in(0);         // Pick up control
1562       // Else match as a normal part of the match tree.
1563       control = Label_Root(m,s,control,mem);
1564       if (C-&gt;failing()) return NULL;
1565     }
1566   }
1567 
1568 
1569   // Call DFA to match this node, and return
1570   svec-&gt;DFA( n-&gt;Opcode(), n );
1571 
1572 #ifdef ASSERT
1573   uint x;
1574   for( x = 0; x &lt; _LAST_MACH_OPER; x++ )
1575     if( svec-&gt;valid(x) )
1576       break;
1577 
1578   if (x &gt;= _LAST_MACH_OPER) {
1579     n-&gt;dump();
1580     svec-&gt;dump();
1581     assert( false, &quot;bad AD file&quot; );
1582   }
1583 #endif
1584   return control;
1585 }
1586 
1587 
1588 // Con nodes reduced using the same rule can share their MachNode
1589 // which reduces the number of copies of a constant in the final
1590 // program.  The register allocator is free to split uses later to
1591 // split live ranges.
1592 MachNode* Matcher::find_shared_node(Node* leaf, uint rule) {
1593   if (!leaf-&gt;is_Con() &amp;&amp; !leaf-&gt;is_DecodeNarrowPtr()) return NULL;
1594 
1595   // See if this Con has already been reduced using this rule.
1596   if (_shared_nodes.Size() &lt;= leaf-&gt;_idx) return NULL;
1597   MachNode* last = (MachNode*)_shared_nodes.at(leaf-&gt;_idx);
1598   if (last != NULL &amp;&amp; rule == last-&gt;rule()) {
1599     // Don&#39;t expect control change for DecodeN
1600     if (leaf-&gt;is_DecodeNarrowPtr())
1601       return last;
1602     // Get the new space root.
1603     Node* xroot = new_node(C-&gt;root());
1604     if (xroot == NULL) {
1605       // This shouldn&#39;t happen give the order of matching.
1606       return NULL;
1607     }
1608 
1609     // Shared constants need to have their control be root so they
1610     // can be scheduled properly.
1611     Node* control = last-&gt;in(0);
1612     if (control != xroot) {
1613       if (control == NULL || control == C-&gt;root()) {
1614         last-&gt;set_req(0, xroot);
1615       } else {
1616         assert(false, &quot;unexpected control&quot;);
1617         return NULL;
1618       }
1619     }
1620     return last;
1621   }
1622   return NULL;
1623 }
1624 
1625 
1626 //------------------------------ReduceInst-------------------------------------
1627 // Reduce a State tree (with given Control) into a tree of MachNodes.
1628 // This routine (and it&#39;s cohort ReduceOper) convert Ideal Nodes into
1629 // complicated machine Nodes.  Each MachNode covers some tree of Ideal Nodes.
1630 // Each MachNode has a number of complicated MachOper operands; each
1631 // MachOper also covers a further tree of Ideal Nodes.
1632 
1633 // The root of the Ideal match tree is always an instruction, so we enter
1634 // the recursion here.  After building the MachNode, we need to recurse
1635 // the tree checking for these cases:
1636 // (1) Child is an instruction -
1637 //     Build the instruction (recursively), add it as an edge.
1638 //     Build a simple operand (register) to hold the result of the instruction.
1639 // (2) Child is an interior part of an instruction -
1640 //     Skip over it (do nothing)
1641 // (3) Child is the start of a operand -
1642 //     Build the operand, place it inside the instruction
1643 //     Call ReduceOper.
1644 MachNode *Matcher::ReduceInst( State *s, int rule, Node *&amp;mem ) {
1645   assert( rule &gt;= NUM_OPERANDS, &quot;called with operand rule&quot; );
1646 
1647   MachNode* shared_node = find_shared_node(s-&gt;_leaf, rule);
1648   if (shared_node != NULL) {
1649     return shared_node;
1650   }
1651 
1652   // Build the object to represent this state &amp; prepare for recursive calls
1653   MachNode *mach = s-&gt;MachNodeGenerator(rule);
1654   guarantee(mach != NULL, &quot;Missing MachNode&quot;);
1655   mach-&gt;_opnds[0] = s-&gt;MachOperGenerator(_reduceOp[rule]);
1656   assert( mach-&gt;_opnds[0] != NULL, &quot;Missing result operand&quot; );
1657   Node *leaf = s-&gt;_leaf;
1658   // Check for instruction or instruction chain rule
1659   if( rule &gt;= _END_INST_CHAIN_RULE || rule &lt; _BEGIN_INST_CHAIN_RULE ) {
1660     assert(C-&gt;node_arena()-&gt;contains(s-&gt;_leaf) || !has_new_node(s-&gt;_leaf),
1661            &quot;duplicating node that&#39;s already been matched&quot;);
1662     // Instruction
1663     mach-&gt;add_req( leaf-&gt;in(0) ); // Set initial control
1664     // Reduce interior of complex instruction
1665     ReduceInst_Interior( s, rule, mem, mach, 1 );
1666   } else {
1667     // Instruction chain rules are data-dependent on their inputs
1668     mach-&gt;add_req(0);             // Set initial control to none
1669     ReduceInst_Chain_Rule( s, rule, mem, mach );
1670   }
1671 
1672   // If a Memory was used, insert a Memory edge
1673   if( mem != (Node*)1 ) {
1674     mach-&gt;ins_req(MemNode::Memory,mem);
1675 #ifdef ASSERT
1676     // Verify adr type after matching memory operation
1677     const MachOper* oper = mach-&gt;memory_operand();
1678     if (oper != NULL &amp;&amp; oper != (MachOper*)-1) {
1679       // It has a unique memory operand.  Find corresponding ideal mem node.
1680       Node* m = NULL;
1681       if (leaf-&gt;is_Mem()) {
1682         m = leaf;
1683       } else {
1684         m = _mem_node;
1685         assert(m != NULL &amp;&amp; m-&gt;is_Mem(), &quot;expecting memory node&quot;);
1686       }
1687       const Type* mach_at = mach-&gt;adr_type();
1688       // DecodeN node consumed by an address may have different type
1689       // than its input. Don&#39;t compare types for such case.
1690       if (m-&gt;adr_type() != mach_at &amp;&amp;
1691           (m-&gt;in(MemNode::Address)-&gt;is_DecodeNarrowPtr() ||
1692            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1693             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()) ||
1694            (m-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
1695             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;is_AddP() &amp;&amp;
1696             m-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;in(AddPNode::Address)-&gt;is_DecodeNarrowPtr()))) {
1697         mach_at = m-&gt;adr_type();
1698       }
1699       if (m-&gt;adr_type() != mach_at) {
1700         m-&gt;dump();
1701         tty-&gt;print_cr(&quot;mach:&quot;);
1702         mach-&gt;dump(1);
1703       }
1704       assert(m-&gt;adr_type() == mach_at, &quot;matcher should not change adr type&quot;);
1705     }
1706 #endif
1707   }
1708 
1709   // If the _leaf is an AddP, insert the base edge
1710   if (leaf-&gt;is_AddP()) {
1711     mach-&gt;ins_req(AddPNode::Base,leaf-&gt;in(AddPNode::Base));
1712   }
1713 
1714   uint number_of_projections_prior = number_of_projections();
1715 
1716   // Perform any 1-to-many expansions required
1717   MachNode *ex = mach-&gt;Expand(s, _projection_list, mem);
1718   if (ex != mach) {
1719     assert(ex-&gt;ideal_reg() == mach-&gt;ideal_reg(), &quot;ideal types should match&quot;);
1720     if( ex-&gt;in(1)-&gt;is_Con() )
1721       ex-&gt;in(1)-&gt;set_req(0, C-&gt;root());
1722     // Remove old node from the graph
1723     for( uint i=0; i&lt;mach-&gt;req(); i++ ) {
1724       mach-&gt;set_req(i,NULL);
1725     }
1726 #ifdef ASSERT
1727     _new2old_map.map(ex-&gt;_idx, s-&gt;_leaf);
1728 #endif
1729   }
1730 
1731   // PhaseChaitin::fixup_spills will sometimes generate spill code
1732   // via the matcher.  By the time, nodes have been wired into the CFG,
1733   // and any further nodes generated by expand rules will be left hanging
1734   // in space, and will not get emitted as output code.  Catch this.
1735   // Also, catch any new register allocation constraints (&quot;projections&quot;)
1736   // generated belatedly during spill code generation.
1737   if (_allocation_started) {
1738     guarantee(ex == mach, &quot;no expand rules during spill generation&quot;);
1739     guarantee(number_of_projections_prior == number_of_projections(), &quot;no allocation during spill generation&quot;);
1740   }
1741 
1742   if (leaf-&gt;is_Con() || leaf-&gt;is_DecodeNarrowPtr()) {
1743     // Record the con for sharing
1744     _shared_nodes.map(leaf-&gt;_idx, ex);
1745   }
1746 
<a name="13" id="anc13"></a>






1747   return ex;
1748 }
1749 
1750 void Matcher::handle_precedence_edges(Node* n, MachNode *mach) {
1751   for (uint i = n-&gt;req(); i &lt; n-&gt;len(); i++) {
1752     if (n-&gt;in(i) != NULL) {
1753       mach-&gt;add_prec(n-&gt;in(i));
1754     }
1755   }
1756 }
1757 
1758 void Matcher::ReduceInst_Chain_Rule( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1759   // &#39;op&#39; is what I am expecting to receive
1760   int op = _leftOp[rule];
1761   // Operand type to catch childs result
1762   // This is what my child will give me.
1763   int opnd_class_instance = s-&gt;_rule[op];
1764   // Choose between operand class or not.
1765   // This is what I will receive.
1766   int catch_op = (FIRST_OPERAND_CLASS &lt;= op &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1767   // New rule for child.  Chase operand classes to get the actual rule.
1768   int newrule = s-&gt;_rule[catch_op];
1769 
1770   if( newrule &lt; NUM_OPERANDS ) {
1771     // Chain from operand or operand class, may be output of shared node
1772     assert( 0 &lt;= opnd_class_instance &amp;&amp; opnd_class_instance &lt; NUM_OPERANDS,
1773             &quot;Bad AD file: Instruction chain rule must chain from operand&quot;);
1774     // Insert operand into array of operands for this instruction
1775     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(opnd_class_instance);
1776 
1777     ReduceOper( s, newrule, mem, mach );
1778   } else {
1779     // Chain from the result of an instruction
1780     assert( newrule &gt;= _LAST_MACH_OPER, &quot;Do NOT chain from internal operand&quot;);
1781     mach-&gt;_opnds[1] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1782     Node *mem1 = (Node*)1;
1783     debug_only(Node *save_mem_node = _mem_node;)
1784     mach-&gt;add_req( ReduceInst(s, newrule, mem1) );
1785     debug_only(_mem_node = save_mem_node;)
1786   }
1787   return;
1788 }
1789 
1790 
1791 uint Matcher::ReduceInst_Interior( State *s, int rule, Node *&amp;mem, MachNode *mach, uint num_opnds ) {
1792   handle_precedence_edges(s-&gt;_leaf, mach);
1793 
1794   if( s-&gt;_leaf-&gt;is_Load() ) {
1795     Node *mem2 = s-&gt;_leaf-&gt;in(MemNode::Memory);
1796     assert( mem == (Node*)1 || mem == mem2, &quot;multiple Memories being matched at once?&quot; );
1797     debug_only( if( mem == (Node*)1 ) _mem_node = s-&gt;_leaf;)
1798     mem = mem2;
1799   }
1800   if( s-&gt;_leaf-&gt;in(0) != NULL &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1801     if( mach-&gt;in(0) == NULL )
1802       mach-&gt;set_req(0, s-&gt;_leaf-&gt;in(0));
1803   }
1804 
1805   // Now recursively walk the state tree &amp; add operand list.
1806   for( uint i=0; i&lt;2; i++ ) {   // binary tree
1807     State *newstate = s-&gt;_kids[i];
1808     if( newstate == NULL ) break;      // Might only have 1 child
1809     // &#39;op&#39; is what I am expecting to receive
1810     int op;
1811     if( i == 0 ) {
1812       op = _leftOp[rule];
1813     } else {
1814       op = _rightOp[rule];
1815     }
1816     // Operand type to catch childs result
1817     // This is what my child will give me.
1818     int opnd_class_instance = newstate-&gt;_rule[op];
1819     // Choose between operand class or not.
1820     // This is what I will receive.
1821     int catch_op = (op &gt;= FIRST_OPERAND_CLASS &amp;&amp; op &lt; NUM_OPERANDS) ? opnd_class_instance : op;
1822     // New rule for child.  Chase operand classes to get the actual rule.
1823     int newrule = newstate-&gt;_rule[catch_op];
1824 
1825     if( newrule &lt; NUM_OPERANDS ) { // Operand/operandClass or internalOp/instruction?
1826       // Operand/operandClass
1827       // Insert operand into array of operands for this instruction
1828       mach-&gt;_opnds[num_opnds++] = newstate-&gt;MachOperGenerator(opnd_class_instance);
1829       ReduceOper( newstate, newrule, mem, mach );
1830 
1831     } else {                    // Child is internal operand or new instruction
1832       if( newrule &lt; _LAST_MACH_OPER ) { // internal operand or instruction?
1833         // internal operand --&gt; call ReduceInst_Interior
1834         // Interior of complex instruction.  Do nothing but recurse.
1835         num_opnds = ReduceInst_Interior( newstate, newrule, mem, mach, num_opnds );
1836       } else {
1837         // instruction --&gt; call build operand(  ) to catch result
1838         //             --&gt; ReduceInst( newrule )
1839         mach-&gt;_opnds[num_opnds++] = s-&gt;MachOperGenerator(_reduceOp[catch_op]);
1840         Node *mem1 = (Node*)1;
1841         debug_only(Node *save_mem_node = _mem_node;)
1842         mach-&gt;add_req( ReduceInst( newstate, newrule, mem1 ) );
1843         debug_only(_mem_node = save_mem_node;)
1844       }
1845     }
1846     assert( mach-&gt;_opnds[num_opnds-1], &quot;&quot; );
1847   }
1848   return num_opnds;
1849 }
1850 
1851 // This routine walks the interior of possible complex operands.
1852 // At each point we check our children in the match tree:
1853 // (1) No children -
1854 //     We are a leaf; add _leaf field as an input to the MachNode
1855 // (2) Child is an internal operand -
1856 //     Skip over it ( do nothing )
1857 // (3) Child is an instruction -
1858 //     Call ReduceInst recursively and
1859 //     and instruction as an input to the MachNode
1860 void Matcher::ReduceOper( State *s, int rule, Node *&amp;mem, MachNode *mach ) {
1861   assert( rule &lt; _LAST_MACH_OPER, &quot;called with operand rule&quot; );
1862   State *kid = s-&gt;_kids[0];
1863   assert( kid == NULL || s-&gt;_leaf-&gt;in(0) == NULL, &quot;internal operands have no control&quot; );
1864 
1865   // Leaf?  And not subsumed?
1866   if( kid == NULL &amp;&amp; !_swallowed[rule] ) {
1867     mach-&gt;add_req( s-&gt;_leaf );  // Add leaf pointer
1868     return;                     // Bail out
1869   }
1870 
1871   if( s-&gt;_leaf-&gt;is_Load() ) {
1872     assert( mem == (Node*)1, &quot;multiple Memories being matched at once?&quot; );
1873     mem = s-&gt;_leaf-&gt;in(MemNode::Memory);
1874     debug_only(_mem_node = s-&gt;_leaf;)
1875   }
1876 
1877   handle_precedence_edges(s-&gt;_leaf, mach);
1878 
1879   if( s-&gt;_leaf-&gt;in(0) &amp;&amp; s-&gt;_leaf-&gt;req() &gt; 1) {
1880     if( !mach-&gt;in(0) )
1881       mach-&gt;set_req(0,s-&gt;_leaf-&gt;in(0));
1882     else {
1883       assert( s-&gt;_leaf-&gt;in(0) == mach-&gt;in(0), &quot;same instruction, differing controls?&quot; );
1884     }
1885   }
1886 
1887   for( uint i=0; kid != NULL &amp;&amp; i&lt;2; kid = s-&gt;_kids[1], i++ ) {   // binary tree
1888     int newrule;
1889     if( i == 0)
1890       newrule = kid-&gt;_rule[_leftOp[rule]];
1891     else
1892       newrule = kid-&gt;_rule[_rightOp[rule]];
1893 
1894     if( newrule &lt; _LAST_MACH_OPER ) { // Operand or instruction?
1895       // Internal operand; recurse but do nothing else
1896       ReduceOper( kid, newrule, mem, mach );
1897 
1898     } else {                    // Child is a new instruction
1899       // Reduce the instruction, and add a direct pointer from this
1900       // machine instruction to the newly reduced one.
1901       Node *mem1 = (Node*)1;
1902       debug_only(Node *save_mem_node = _mem_node;)
1903       mach-&gt;add_req( ReduceInst( kid, newrule, mem1 ) );
1904       debug_only(_mem_node = save_mem_node;)
1905     }
1906   }
1907 }
1908 
1909 
1910 // -------------------------------------------------------------------------
1911 // Java-Java calling convention
1912 // (what you use when Java calls Java)
1913 
1914 //------------------------------find_receiver----------------------------------
1915 // For a given signature, return the OptoReg for parameter 0.
1916 OptoReg::Name Matcher::find_receiver( bool is_outgoing ) {
1917   VMRegPair regs;
1918   BasicType sig_bt = T_OBJECT;
1919   calling_convention(&amp;sig_bt, &amp;regs, 1, is_outgoing);
1920   // Return argument 0 register.  In the LP64 build pointers
1921   // take 2 registers, but the VM wants only the &#39;main&#39; name.
1922   return OptoReg::as_OptoReg(regs.first());
1923 }
1924 
1925 // This function identifies sub-graphs in which a &#39;load&#39; node is
1926 // input to two different nodes, and such that it can be matched
1927 // with BMI instructions like blsi, blsr, etc.
1928 // Example : for b = -a[i] &amp; a[i] can be matched to blsi r32, m32.
1929 // The graph is (AndL (SubL Con0 LoadL*) LoadL*), where LoadL*
1930 // refers to the same node.
1931 #ifdef X86
1932 // Match the generic fused operations pattern (op1 (op2 Con{ConType} mop) mop)
1933 // This is a temporary solution until we make DAGs expressible in ADL.
1934 template&lt;typename ConType&gt;
1935 class FusedPatternMatcher {
1936   Node* _op1_node;
1937   Node* _mop_node;
1938   int _con_op;
1939 
1940   static int match_next(Node* n, int next_op, int next_op_idx) {
1941     if (n-&gt;in(1) == NULL || n-&gt;in(2) == NULL) {
1942       return -1;
1943     }
1944 
1945     if (next_op_idx == -1) { // n is commutative, try rotations
1946       if (n-&gt;in(1)-&gt;Opcode() == next_op) {
1947         return 1;
1948       } else if (n-&gt;in(2)-&gt;Opcode() == next_op) {
1949         return 2;
1950       }
1951     } else {
1952       assert(next_op_idx &gt; 0 &amp;&amp; next_op_idx &lt;= 2, &quot;Bad argument index&quot;);
1953       if (n-&gt;in(next_op_idx)-&gt;Opcode() == next_op) {
1954         return next_op_idx;
1955       }
1956     }
1957     return -1;
1958   }
1959 public:
1960   FusedPatternMatcher(Node* op1_node, Node *mop_node, int con_op) :
1961     _op1_node(op1_node), _mop_node(mop_node), _con_op(con_op) { }
1962 
1963   bool match(int op1, int op1_op2_idx,  // op1 and the index of the op1-&gt;op2 edge, -1 if op1 is commutative
1964              int op2, int op2_con_idx,  // op2 and the index of the op2-&gt;con edge, -1 if op2 is commutative
1965              typename ConType::NativeType con_value) {
1966     if (_op1_node-&gt;Opcode() != op1) {
1967       return false;
1968     }
1969     if (_mop_node-&gt;outcnt() &gt; 2) {
1970       return false;
1971     }
1972     op1_op2_idx = match_next(_op1_node, op2, op1_op2_idx);
1973     if (op1_op2_idx == -1) {
1974       return false;
1975     }
1976     // Memory operation must be the other edge
1977     int op1_mop_idx = (op1_op2_idx &amp; 1) + 1;
1978 
1979     // Check that the mop node is really what we want
1980     if (_op1_node-&gt;in(op1_mop_idx) == _mop_node) {
1981       Node *op2_node = _op1_node-&gt;in(op1_op2_idx);
1982       if (op2_node-&gt;outcnt() &gt; 1) {
1983         return false;
1984       }
1985       assert(op2_node-&gt;Opcode() == op2, &quot;Should be&quot;);
1986       op2_con_idx = match_next(op2_node, _con_op, op2_con_idx);
1987       if (op2_con_idx == -1) {
1988         return false;
1989       }
1990       // Memory operation must be the other edge
1991       int op2_mop_idx = (op2_con_idx &amp; 1) + 1;
1992       // Check that the memory operation is the same node
1993       if (op2_node-&gt;in(op2_mop_idx) == _mop_node) {
1994         // Now check the constant
1995         const Type* con_type = op2_node-&gt;in(op2_con_idx)-&gt;bottom_type();
1996         if (con_type != Type::TOP &amp;&amp; ConType::as_self(con_type)-&gt;get_con() == con_value) {
1997           return true;
1998         }
1999       }
2000     }
2001     return false;
2002   }
2003 };
2004 
2005 
2006 bool Matcher::is_bmi_pattern(Node *n, Node *m) {
2007   if (n != NULL &amp;&amp; m != NULL) {
2008     if (m-&gt;Opcode() == Op_LoadI) {
2009       FusedPatternMatcher&lt;TypeInt&gt; bmii(n, m, Op_ConI);
2010       return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||
2011              bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||
2012              bmii.match(Op_XorI, -1, Op_AddI, -1, -1);
2013     } else if (m-&gt;Opcode() == Op_LoadL) {
2014       FusedPatternMatcher&lt;TypeLong&gt; bmil(n, m, Op_ConL);
2015       return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||
2016              bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||
2017              bmil.match(Op_XorL, -1, Op_AddL, -1, -1);
2018     }
2019   }
2020   return false;
2021 }
2022 #endif // X86
2023 
<a name="14" id="anc14"></a>








2024 bool Matcher::clone_base_plus_offset_address(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
2025   Node *off = m-&gt;in(AddPNode::Offset);
2026   if (off-&gt;is_Con()) {
2027     address_visited.test_set(m-&gt;_idx); // Flag as address_visited
2028     mstack.push(m-&gt;in(AddPNode::Address), Pre_Visit);
2029     // Clone X+offset as it also folds into most addressing expressions
2030     mstack.push(off, Visit);
2031     mstack.push(m-&gt;in(AddPNode::Base), Pre_Visit);
2032     return true;
2033   }
2034   return false;
2035 }
2036 
2037 // A method-klass-holder may be passed in the inline_cache_reg
2038 // and then expanded into the inline_cache_reg and a method_oop register
2039 //   defined in ad_&lt;arch&gt;.cpp
2040 
2041 //------------------------------find_shared------------------------------------
2042 // Set bits if Node is shared or otherwise a root
2043 void Matcher::find_shared( Node *n ) {
2044   // Allocate stack of size C-&gt;live_nodes() * 2 to avoid frequent realloc
2045   MStack mstack(C-&gt;live_nodes() * 2);
2046   // Mark nodes as address_visited if they are inputs to an address expression
2047   VectorSet address_visited(Thread::current()-&gt;resource_area());
2048   mstack.push(n, Visit);     // Don&#39;t need to pre-visit root node
2049   while (mstack.is_nonempty()) {
2050     n = mstack.node();       // Leave node on stack
2051     Node_State nstate = mstack.state();
2052     uint nop = n-&gt;Opcode();
2053     if (nstate == Pre_Visit) {
2054       if (address_visited.test(n-&gt;_idx)) { // Visited in address already?
2055         // Flag as visited and shared now.
2056         set_visited(n);
2057       }
2058       if (is_visited(n)) {   // Visited already?
2059         // Node is shared and has no reason to clone.  Flag it as shared.
2060         // This causes it to match into a register for the sharing.
2061         set_shared(n);       // Flag as shared and
<a name="15" id="anc15"></a>





2062         mstack.pop();        // remove node from stack
2063         continue;
2064       }
2065       nstate = Visit; // Not already visited; so visit now
2066     }
2067     if (nstate == Visit) {
2068       mstack.set_state(Post_Visit);
2069       set_visited(n);   // Flag as visited now
2070       bool mem_op = false;
2071       int mem_addr_idx = MemNode::Address;
<a name="16" id="anc16"></a><span class="line-modified">2072       bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_find_shared_visit(this, mstack, n, nop, mem_op, mem_addr_idx);</span>
<span class="line-modified">2073       if (!gc_handled) {</span>
<span class="line-removed">2074         if (find_shared_visit(mstack, n, nop, mem_op, mem_addr_idx)) {</span>
<span class="line-removed">2075           continue;</span>
<span class="line-removed">2076         }</span>
2077       }
2078       for(int i = n-&gt;req() - 1; i &gt;= 0; --i) { // For my children
2079         Node *m = n-&gt;in(i); // Get ith input
2080         if (m == NULL) continue;  // Ignore NULLs
2081         uint mop = m-&gt;Opcode();
2082 
2083         // Must clone all producers of flags, or we will not match correctly.
2084         // Suppose a compare setting int-flags is shared (e.g., a switch-tree)
2085         // then it will match into an ideal Op_RegFlags.  Alas, the fp-flags
2086         // are also there, so we may match a float-branch to int-flags and
2087         // expect the allocator to haul the flags from the int-side to the
2088         // fp-side.  No can do.
2089         if( _must_clone[mop] ) {
2090           mstack.push(m, Visit);
2091           continue; // for(int i = ...)
2092         }
2093 
<a name="17" id="anc17"></a><span class="line-removed">2094         if( mop == Op_AddP &amp;&amp; m-&gt;in(AddPNode::Base)-&gt;is_DecodeNarrowPtr()) {</span>
<span class="line-removed">2095           // Bases used in addresses must be shared but since</span>
<span class="line-removed">2096           // they are shared through a DecodeN they may appear</span>
<span class="line-removed">2097           // to have a single use so force sharing here.</span>
<span class="line-removed">2098           set_shared(m-&gt;in(AddPNode::Base)-&gt;in(1));</span>
<span class="line-removed">2099         }</span>
<span class="line-removed">2100 </span>
2101         // if &#39;n&#39; and &#39;m&#39; are part of a graph for BMI instruction, clone this node.
2102 #ifdef X86
2103         if (UseBMI1Instructions &amp;&amp; is_bmi_pattern(n, m)) {
2104           mstack.push(m, Visit);
2105           continue;
2106         }
2107 #endif
<a name="18" id="anc18"></a>



2108 
2109         // Clone addressing expressions as they are &quot;free&quot; in memory access instructions
2110         if (mem_op &amp;&amp; i == mem_addr_idx &amp;&amp; mop == Op_AddP &amp;&amp;
2111             // When there are other uses besides address expressions
2112             // put it on stack and mark as shared.
2113             !is_visited(m)) {
2114           // Some inputs for address expression are not put on stack
2115           // to avoid marking them as shared and forcing them into register
2116           // if they are used only in address expressions.
2117           // But they should be marked as shared if there are other uses
2118           // besides address expressions.
2119 
2120           if (clone_address_expressions(m-&gt;as_AddP(), mstack, address_visited)) {
2121             continue;
2122           }
2123         }   // if( mem_op &amp;&amp;
2124         mstack.push(m, Pre_Visit);
2125       }     // for(int i = ...)
2126     }
2127     else if (nstate == Alt_Post_Visit) {
2128       mstack.pop(); // Remove node from stack
2129       // We cannot remove the Cmp input from the Bool here, as the Bool may be
2130       // shared and all users of the Bool need to move the Cmp in parallel.
2131       // This leaves both the Bool and the If pointing at the Cmp.  To
2132       // prevent the Matcher from trying to Match the Cmp along both paths
2133       // BoolNode::match_edge always returns a zero.
2134 
2135       // We reorder the Op_If in a pre-order manner, so we can visit without
2136       // accidentally sharing the Cmp (the Bool and the If make 2 users).
2137       n-&gt;add_req( n-&gt;in(1)-&gt;in(1) ); // Add the Cmp next to the Bool
2138     }
2139     else if (nstate == Post_Visit) {
2140       mstack.pop(); // Remove node from stack
2141 
2142       // Now hack a few special opcodes
2143       uint opcode = n-&gt;Opcode();
2144       bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_find_shared_post_visit(this, n, opcode);
2145       if (!gc_handled) {
2146         find_shared_post_visit(n, opcode);
2147       }
2148     }
2149     else {
2150       ShouldNotReachHere();
2151     }
2152   } // end of while (mstack.is_nonempty())
2153 }
2154 
2155 bool Matcher::find_shared_visit(MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) {
2156   switch(opcode) {  // Handle some opcodes special
2157     case Op_Phi:             // Treat Phis as shared roots
2158     case Op_Parm:
2159     case Op_Proj:            // All handled specially during matching
2160     case Op_SafePointScalarObject:
2161       set_shared(n);
2162       set_dontcare(n);
2163       break;
2164     case Op_If:
2165     case Op_CountedLoopEnd:
2166       mstack.set_state(Alt_Post_Visit); // Alternative way
2167       // Convert (If (Bool (CmpX A B))) into (If (Bool) (CmpX A B)).  Helps
2168       // with matching cmp/branch in 1 instruction.  The Matcher needs the
2169       // Bool and CmpX side-by-side, because it can only get at constants
2170       // that are at the leaves of Match trees, and the Bool&#39;s condition acts
2171       // as a constant here.
2172       mstack.push(n-&gt;in(1), Visit);         // Clone the Bool
2173       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit control input
2174       return true; // while (mstack.is_nonempty())
2175     case Op_ConvI2D:         // These forms efficiently match with a prior
2176     case Op_ConvI2F:         //   Load but not a following Store
2177       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2178           n-&gt;outcnt() == 1 &amp;&amp;           // Not already shared
2179           n-&gt;unique_out()-&gt;is_Store() ) // Following store
2180         set_shared(n);       // Force it to be a root
2181       break;
2182     case Op_ReverseBytesI:
2183     case Op_ReverseBytesL:
2184       if( n-&gt;in(1)-&gt;is_Load() &amp;&amp;        // Prior load
2185           n-&gt;outcnt() == 1 )            // Not already shared
2186         set_shared(n);                  // Force it to be a root
2187       break;
2188     case Op_BoxLock:         // Cant match until we get stack-regs in ADLC
2189     case Op_IfFalse:
2190     case Op_IfTrue:
2191     case Op_MachProj:
2192     case Op_MergeMem:
2193     case Op_Catch:
2194     case Op_CatchProj:
2195     case Op_CProj:
2196     case Op_JumpProj:
2197     case Op_JProj:
2198     case Op_NeverBranch:
2199       set_dontcare(n);
2200       break;
2201     case Op_Jump:
2202       mstack.push(n-&gt;in(1), Pre_Visit);     // Switch Value (could be shared)
2203       mstack.push(n-&gt;in(0), Pre_Visit);     // Visit Control input
2204       return true;                             // while (mstack.is_nonempty())
2205     case Op_StrComp:
2206     case Op_StrEquals:
2207     case Op_StrIndexOf:
2208     case Op_StrIndexOfChar:
2209     case Op_AryEq:
2210     case Op_HasNegatives:
2211     case Op_StrInflatedCopy:
2212     case Op_StrCompressedCopy:
2213     case Op_EncodeISOArray:
2214     case Op_FmaD:
2215     case Op_FmaF:
2216     case Op_FmaVD:
2217     case Op_FmaVF:
2218       set_shared(n); // Force result into register (it will be anyways)
2219       break;
2220     case Op_ConP: {  // Convert pointers above the centerline to NUL
2221       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2222       const TypePtr* tp = tn-&gt;type()-&gt;is_ptr();
2223       if (tp-&gt;_ptr == TypePtr::AnyNull) {
2224         tn-&gt;set_type(TypePtr::NULL_PTR);
2225       }
2226       break;
2227     }
2228     case Op_ConN: {  // Convert narrow pointers above the centerline to NUL
2229       TypeNode *tn = n-&gt;as_Type(); // Constants derive from type nodes
2230       const TypePtr* tp = tn-&gt;type()-&gt;make_ptr();
2231       if (tp &amp;&amp; tp-&gt;_ptr == TypePtr::AnyNull) {
2232         tn-&gt;set_type(TypeNarrowOop::NULL_PTR);
2233       }
2234       break;
2235     }
2236     case Op_Binary:         // These are introduced in the Post_Visit state.
2237       ShouldNotReachHere();
2238       break;
2239     case Op_ClearArray:
2240     case Op_SafePoint:
2241       mem_op = true;
2242       break;
2243     default:
2244       if( n-&gt;is_Store() ) {
2245         // Do match stores, despite no ideal reg
2246         mem_op = true;
2247         break;
2248       }
2249       if( n-&gt;is_Mem() ) { // Loads and LoadStores
2250         mem_op = true;
2251         // Loads must be root of match tree due to prior load conflict
2252         if( C-&gt;subsume_loads() == false )
2253           set_shared(n);
2254       }
2255       // Fall into default case
2256       if( !n-&gt;ideal_reg() )
2257         set_dontcare(n);  // Unmatchable Nodes
2258   } // end_switch
2259   return false;
2260 }
2261 
2262 void Matcher::find_shared_post_visit(Node* n, uint opcode) {
2263   switch(opcode) {       // Handle some opcodes special
2264     case Op_StorePConditional:
2265     case Op_StoreIConditional:
2266     case Op_StoreLConditional:
2267     case Op_CompareAndExchangeB:
2268     case Op_CompareAndExchangeS:
2269     case Op_CompareAndExchangeI:
2270     case Op_CompareAndExchangeL:
2271     case Op_CompareAndExchangeP:
2272     case Op_CompareAndExchangeN:
2273     case Op_WeakCompareAndSwapB:
2274     case Op_WeakCompareAndSwapS:
2275     case Op_WeakCompareAndSwapI:
2276     case Op_WeakCompareAndSwapL:
2277     case Op_WeakCompareAndSwapP:
2278     case Op_WeakCompareAndSwapN:
2279     case Op_CompareAndSwapB:
2280     case Op_CompareAndSwapS:
2281     case Op_CompareAndSwapI:
2282     case Op_CompareAndSwapL:
2283     case Op_CompareAndSwapP:
2284     case Op_CompareAndSwapN: {   // Convert trinary to binary-tree
2285       Node* newval = n-&gt;in(MemNode::ValueIn);
2286       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
2287       Node* pair = new BinaryNode(oldval, newval);
2288       n-&gt;set_req(MemNode::ValueIn, pair);
2289       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
2290       break;
2291     }
2292     case Op_CMoveD:              // Convert trinary to binary-tree
2293     case Op_CMoveF:
2294     case Op_CMoveI:
2295     case Op_CMoveL:
2296     case Op_CMoveN:
2297     case Op_CMoveP:
2298     case Op_CMoveVF:
2299     case Op_CMoveVD:  {
2300       // Restructure into a binary tree for Matching.  It&#39;s possible that
2301       // we could move this code up next to the graph reshaping for IfNodes
2302       // or vice-versa, but I do not want to debug this for Ladybird.
2303       // 10/2/2000 CNC.
2304       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(1)-&gt;in(1));
2305       n-&gt;set_req(1, pair1);
2306       Node* pair2 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2307       n-&gt;set_req(2, pair2);
2308       n-&gt;del_req(3);
2309       break;
2310     }
2311     case Op_LoopLimit: {
2312       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2313       n-&gt;set_req(1, pair1);
2314       n-&gt;set_req(2, n-&gt;in(3));
2315       n-&gt;del_req(3);
2316       break;
2317     }
2318     case Op_StrEquals:
2319     case Op_StrIndexOfChar: {
2320       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2321       n-&gt;set_req(2, pair1);
2322       n-&gt;set_req(3, n-&gt;in(4));
2323       n-&gt;del_req(4);
2324       break;
2325     }
2326     case Op_StrComp:
2327     case Op_StrIndexOf: {
2328       Node* pair1 = new BinaryNode(n-&gt;in(2), n-&gt;in(3));
2329       n-&gt;set_req(2, pair1);
2330       Node* pair2 = new BinaryNode(n-&gt;in(4),n-&gt;in(5));
2331       n-&gt;set_req(3, pair2);
2332       n-&gt;del_req(5);
2333       n-&gt;del_req(4);
2334       break;
2335     }
2336     case Op_StrCompressedCopy:
2337     case Op_StrInflatedCopy:
2338     case Op_EncodeISOArray: {
2339       // Restructure into a binary tree for Matching.
2340       Node* pair = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2341       n-&gt;set_req(3, pair);
2342       n-&gt;del_req(4);
2343       break;
2344     }
2345     case Op_FmaD:
2346     case Op_FmaF:
2347     case Op_FmaVD:
2348     case Op_FmaVF: {
2349       // Restructure into a binary tree for Matching.
2350       Node* pair = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2351       n-&gt;set_req(2, pair);
2352       n-&gt;set_req(1, n-&gt;in(3));
2353       n-&gt;del_req(3);
2354       break;
2355     }
2356     case Op_MulAddS2I: {
2357       Node* pair1 = new BinaryNode(n-&gt;in(1), n-&gt;in(2));
2358       Node* pair2 = new BinaryNode(n-&gt;in(3), n-&gt;in(4));
2359       n-&gt;set_req(1, pair1);
2360       n-&gt;set_req(2, pair2);
2361       n-&gt;del_req(4);
2362       n-&gt;del_req(3);
2363       break;
2364     }
2365     default:
2366       break;
2367   }
2368 }
2369 
2370 #ifdef ASSERT
2371 // machine-independent root to machine-dependent root
2372 void Matcher::dump_old2new_map() {
2373   _old2new_map.dump();
2374 }
2375 #endif
2376 
2377 //---------------------------collect_null_checks-------------------------------
2378 // Find null checks in the ideal graph; write a machine-specific node for
2379 // it.  Used by later implicit-null-check handling.  Actually collects
2380 // either an IfTrue or IfFalse for the common NOT-null path, AND the ideal
2381 // value being tested.
2382 void Matcher::collect_null_checks( Node *proj, Node *orig_proj ) {
2383   Node *iff = proj-&gt;in(0);
2384   if( iff-&gt;Opcode() == Op_If ) {
2385     // During matching If&#39;s have Bool &amp; Cmp side-by-side
2386     BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
2387     Node *cmp = iff-&gt;in(2);
2388     int opc = cmp-&gt;Opcode();
2389     if (opc != Op_CmpP &amp;&amp; opc != Op_CmpN) return;
2390 
2391     const Type* ct = cmp-&gt;in(2)-&gt;bottom_type();
2392     if (ct == TypePtr::NULL_PTR ||
2393         (opc == Op_CmpN &amp;&amp; ct == TypeNarrowOop::NULL_PTR)) {
2394 
2395       bool push_it = false;
2396       if( proj-&gt;Opcode() == Op_IfTrue ) {
2397 #ifndef PRODUCT
2398         extern int all_null_checks_found;
2399         all_null_checks_found++;
2400 #endif
2401         if( b-&gt;_test._test == BoolTest::ne ) {
2402           push_it = true;
2403         }
2404       } else {
2405         assert( proj-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
2406         if( b-&gt;_test._test == BoolTest::eq ) {
2407           push_it = true;
2408         }
2409       }
2410       if( push_it ) {
2411         _null_check_tests.push(proj);
2412         Node* val = cmp-&gt;in(1);
2413 #ifdef _LP64
2414         if (val-&gt;bottom_type()-&gt;isa_narrowoop() &amp;&amp;
2415             !Matcher::narrow_oop_use_complex_address()) {
2416           //
2417           // Look for DecodeN node which should be pinned to orig_proj.
2418           // On platforms (Sparc) which can not handle 2 adds
2419           // in addressing mode we have to keep a DecodeN node and
2420           // use it to do implicit NULL check in address.
2421           //
2422           // DecodeN node was pinned to non-null path (orig_proj) during
2423           // CastPP transformation in final_graph_reshaping_impl().
2424           //
2425           uint cnt = orig_proj-&gt;outcnt();
2426           for (uint i = 0; i &lt; orig_proj-&gt;outcnt(); i++) {
2427             Node* d = orig_proj-&gt;raw_out(i);
2428             if (d-&gt;is_DecodeN() &amp;&amp; d-&gt;in(1) == val) {
2429               val = d;
2430               val-&gt;set_req(0, NULL); // Unpin now.
2431               // Mark this as special case to distinguish from
2432               // a regular case: CmpP(DecodeN, NULL).
2433               val = (Node*)(((intptr_t)val) | 1);
2434               break;
2435             }
2436           }
2437         }
2438 #endif
2439         _null_check_tests.push(val);
2440       }
2441     }
2442   }
2443 }
2444 
2445 //---------------------------validate_null_checks------------------------------
2446 // Its possible that the value being NULL checked is not the root of a match
2447 // tree.  If so, I cannot use the value in an implicit null check.
2448 void Matcher::validate_null_checks( ) {
2449   uint cnt = _null_check_tests.size();
2450   for( uint i=0; i &lt; cnt; i+=2 ) {
2451     Node *test = _null_check_tests[i];
2452     Node *val = _null_check_tests[i+1];
2453     bool is_decoden = ((intptr_t)val) &amp; 1;
2454     val = (Node*)(((intptr_t)val) &amp; ~1);
2455     if (has_new_node(val)) {
2456       Node* new_val = new_node(val);
2457       if (is_decoden) {
2458         assert(val-&gt;is_DecodeNarrowPtr() &amp;&amp; val-&gt;in(0) == NULL, &quot;sanity&quot;);
2459         // Note: new_val may have a control edge if
2460         // the original ideal node DecodeN was matched before
2461         // it was unpinned in Matcher::collect_null_checks().
2462         // Unpin the mach node and mark it.
2463         new_val-&gt;set_req(0, NULL);
2464         new_val = (Node*)(((intptr_t)new_val) | 1);
2465       }
2466       // Is a match-tree root, so replace with the matched value
2467       _null_check_tests.map(i+1, new_val);
2468     } else {
2469       // Yank from candidate list
2470       _null_check_tests.map(i+1,_null_check_tests[--cnt]);
2471       _null_check_tests.map(i,_null_check_tests[--cnt]);
2472       _null_check_tests.pop();
2473       _null_check_tests.pop();
2474       i-=2;
2475     }
2476   }
2477 }
2478 
<a name="19" id="anc19"></a>











































































































































































2479 // Used by the DFA in dfa_xxx.cpp.  Check for a following barrier or
2480 // atomic instruction acting as a store_load barrier without any
2481 // intervening volatile load, and thus we don&#39;t need a barrier here.
2482 // We retain the Node to act as a compiler ordering barrier.
2483 bool Matcher::post_store_load_barrier(const Node* vmb) {
2484   Compile* C = Compile::current();
2485   assert(vmb-&gt;is_MemBar(), &quot;&quot;);
2486   assert(vmb-&gt;Opcode() != Op_MemBarAcquire &amp;&amp; vmb-&gt;Opcode() != Op_LoadFence, &quot;&quot;);
2487   const MemBarNode* membar = vmb-&gt;as_MemBar();
2488 
2489   // Get the Ideal Proj node, ctrl, that can be used to iterate forward
2490   Node* ctrl = NULL;
2491   for (DUIterator_Fast imax, i = membar-&gt;fast_outs(imax); i &lt; imax; i++) {
2492     Node* p = membar-&gt;fast_out(i);
2493     assert(p-&gt;is_Proj(), &quot;only projections here&quot;);
2494     if ((p-&gt;as_Proj()-&gt;_con == TypeFunc::Control) &amp;&amp;
2495         !C-&gt;node_arena()-&gt;contains(p)) { // Unmatched old-space only
2496       ctrl = p;
2497       break;
2498     }
2499   }
2500   assert((ctrl != NULL), &quot;missing control projection&quot;);
2501 
2502   for (DUIterator_Fast jmax, j = ctrl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2503     Node *x = ctrl-&gt;fast_out(j);
2504     int xop = x-&gt;Opcode();
2505 
2506     // We don&#39;t need current barrier if we see another or a lock
2507     // before seeing volatile load.
2508     //
2509     // Op_Fastunlock previously appeared in the Op_* list below.
2510     // With the advent of 1-0 lock operations we&#39;re no longer guaranteed
2511     // that a monitor exit operation contains a serializing instruction.
2512 
2513     if (xop == Op_MemBarVolatile ||
2514         xop == Op_CompareAndExchangeB ||
2515         xop == Op_CompareAndExchangeS ||
2516         xop == Op_CompareAndExchangeI ||
2517         xop == Op_CompareAndExchangeL ||
2518         xop == Op_CompareAndExchangeP ||
2519         xop == Op_CompareAndExchangeN ||
2520         xop == Op_WeakCompareAndSwapB ||
2521         xop == Op_WeakCompareAndSwapS ||
2522         xop == Op_WeakCompareAndSwapL ||
2523         xop == Op_WeakCompareAndSwapP ||
2524         xop == Op_WeakCompareAndSwapN ||
2525         xop == Op_WeakCompareAndSwapI ||
2526         xop == Op_CompareAndSwapB ||
2527         xop == Op_CompareAndSwapS ||
2528         xop == Op_CompareAndSwapL ||
2529         xop == Op_CompareAndSwapP ||
2530         xop == Op_CompareAndSwapN ||
2531         xop == Op_CompareAndSwapI ||
2532         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;matcher_is_store_load_barrier(x, xop)) {
2533       return true;
2534     }
2535 
2536     // Op_FastLock previously appeared in the Op_* list above.
2537     // With biased locking we&#39;re no longer guaranteed that a monitor
2538     // enter operation contains a serializing instruction.
2539     if ((xop == Op_FastLock) &amp;&amp; !UseBiasedLocking) {
2540       return true;
2541     }
2542 
2543     if (x-&gt;is_MemBar()) {
2544       // We must retain this membar if there is an upcoming volatile
2545       // load, which will be followed by acquire membar.
2546       if (xop == Op_MemBarAcquire || xop == Op_LoadFence) {
2547         return false;
2548       } else {
2549         // For other kinds of barriers, check by pretending we
2550         // are them, and seeing if we can be removed.
2551         return post_store_load_barrier(x-&gt;as_MemBar());
2552       }
2553     }
2554 
2555     // probably not necessary to check for these
2556     if (x-&gt;is_Call() || x-&gt;is_SafePoint() || x-&gt;is_block_proj()) {
2557       return false;
2558     }
2559   }
2560   return false;
2561 }
2562 
2563 // Check whether node n is a branch to an uncommon trap that we could
2564 // optimize as test with very high branch costs in case of going to
2565 // the uncommon trap. The code must be able to be recompiled to use
2566 // a cheaper test.
2567 bool Matcher::branches_to_uncommon_trap(const Node *n) {
2568   // Don&#39;t do it for natives, adapters, or runtime stubs
2569   Compile *C = Compile::current();
2570   if (!C-&gt;is_method_compilation()) return false;
2571 
2572   assert(n-&gt;is_If(), &quot;You should only call this on if nodes.&quot;);
2573   IfNode *ifn = n-&gt;as_If();
2574 
2575   Node *ifFalse = NULL;
2576   for (DUIterator_Fast imax, i = ifn-&gt;fast_outs(imax); i &lt; imax; i++) {
2577     if (ifn-&gt;fast_out(i)-&gt;is_IfFalse()) {
2578       ifFalse = ifn-&gt;fast_out(i);
2579       break;
2580     }
2581   }
2582   assert(ifFalse, &quot;An If should have an ifFalse. Graph is broken.&quot;);
2583 
2584   Node *reg = ifFalse;
2585   int cnt = 4; // We must protect against cycles.  Limit to 4 iterations.
2586                // Alternatively use visited set?  Seems too expensive.
2587   while (reg != NULL &amp;&amp; cnt &gt; 0) {
2588     CallNode *call = NULL;
2589     RegionNode *nxt_reg = NULL;
2590     for (DUIterator_Fast imax, i = reg-&gt;fast_outs(imax); i &lt; imax; i++) {
2591       Node *o = reg-&gt;fast_out(i);
2592       if (o-&gt;is_Call()) {
2593         call = o-&gt;as_Call();
2594       }
2595       if (o-&gt;is_Region()) {
2596         nxt_reg = o-&gt;as_Region();
2597       }
2598     }
2599 
2600     if (call &amp;&amp;
2601         call-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point()) {
2602       const Type* trtype = call-&gt;in(TypeFunc::Parms)-&gt;bottom_type();
2603       if (trtype-&gt;isa_int() &amp;&amp; trtype-&gt;is_int()-&gt;is_con()) {
2604         jint tr_con = trtype-&gt;is_int()-&gt;get_con();
2605         Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(tr_con);
2606         Deoptimization::DeoptAction action = Deoptimization::trap_request_action(tr_con);
2607         assert((int)reason &lt; (int)BitsPerInt, &quot;recode bit map&quot;);
2608 
2609         if (is_set_nth_bit(C-&gt;allowed_deopt_reasons(), (int)reason)
2610             &amp;&amp; action != Deoptimization::Action_none) {
2611           // This uncommon trap is sure to recompile, eventually.
2612           // When that happens, C-&gt;too_many_traps will prevent
2613           // this transformation from happening again.
2614           return true;
2615         }
2616       }
2617     }
2618 
2619     reg = nxt_reg;
2620     cnt--;
2621   }
2622 
2623   return false;
2624 }
2625 
2626 //=============================================================================
2627 //---------------------------State---------------------------------------------
2628 State::State(void) {
2629 #ifdef ASSERT
2630   _id = 0;
2631   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2632   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2633   //memset(_cost, -1, sizeof(_cost));
2634   //memset(_rule, -1, sizeof(_rule));
2635 #endif
2636   memset(_valid, 0, sizeof(_valid));
2637 }
2638 
2639 #ifdef ASSERT
2640 State::~State() {
2641   _id = 99;
2642   _kids[0] = _kids[1] = (State*)(intptr_t) CONST64(0xcafebabecafebabe);
2643   _leaf = (Node*)(intptr_t) CONST64(0xbaadf00dbaadf00d);
2644   memset(_cost, -3, sizeof(_cost));
2645   memset(_rule, -3, sizeof(_rule));
2646 }
2647 #endif
2648 
2649 #ifndef PRODUCT
2650 //---------------------------dump----------------------------------------------
2651 void State::dump() {
2652   tty-&gt;print(&quot;\n&quot;);
2653   dump(0);
2654 }
2655 
2656 void State::dump(int depth) {
2657   for( int j = 0; j &lt; depth; j++ )
2658     tty-&gt;print(&quot;   &quot;);
2659   tty-&gt;print(&quot;--N: &quot;);
2660   _leaf-&gt;dump();
2661   uint i;
2662   for( i = 0; i &lt; _LAST_MACH_OPER; i++ )
2663     // Check for valid entry
2664     if( valid(i) ) {
2665       for( int j = 0; j &lt; depth; j++ )
2666         tty-&gt;print(&quot;   &quot;);
2667         assert(_cost[i] != max_juint, &quot;cost must be a valid value&quot;);
2668         assert(_rule[i] &lt; _last_Mach_Node, &quot;rule[i] must be valid rule&quot;);
2669         tty-&gt;print_cr(&quot;%s  %d  %s&quot;,
2670                       ruleName[i], _cost[i], ruleName[_rule[i]] );
2671       }
2672   tty-&gt;cr();
2673 
2674   for( i=0; i&lt;2; i++ )
2675     if( _kids[i] )
2676       _kids[i]-&gt;dump(depth+1);
2677 }
2678 #endif
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
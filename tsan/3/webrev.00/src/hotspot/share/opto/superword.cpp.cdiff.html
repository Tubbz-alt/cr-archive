<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;opto/opcodes.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/superword.hpp&quot;
  #include &quot;opto/vectornode.hpp&quot;
  #include &quot;opto/movenode.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //
  //                  S U P E R W O R D   T R A N S F O R M
  //=============================================================================
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
    }
  
    // Skip any loops already optimized by slp
    if (cl-&gt;is_vectorized_loop()) return;
  
<span class="line-modified">!   if (cl-&gt;do_unroll_only()) return;</span>
  
    if (cl-&gt;is_main_loop()) {
      // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
      CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
      if (pre_end == NULL) return;
<span class="line-new-header">--- 144,11 ---</span>
    }
  
    // Skip any loops already optimized by slp
    if (cl-&gt;is_vectorized_loop()) return;
  
<span class="line-modified">!   if (cl-&gt;is_unroll_only()) return;</span>
  
    if (cl-&gt;is_main_loop()) {
      // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
      CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
      if (pre_end == NULL) return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,16 ***</span>
        }
      }
    }
  
    Node_List align_to_refs;
    int best_iv_adjustment = 0;
    MemNode* best_align_to_mem_ref = NULL;
  
    while (memops.size() != 0) {
      // Find a memory reference to align to.
<span class="line-modified">!     MemNode* mem_ref = find_align_to_ref(memops);</span>
      if (mem_ref == NULL) break;
      align_to_refs.push(mem_ref);
      int iv_adjustment = get_iv_adjustment(mem_ref);
  
      if (best_align_to_mem_ref == NULL) {
<span class="line-new-header">--- 575,17 ---</span>
        }
      }
    }
  
    Node_List align_to_refs;
<span class="line-added">+   int max_idx;</span>
    int best_iv_adjustment = 0;
    MemNode* best_align_to_mem_ref = NULL;
  
    while (memops.size() != 0) {
      // Find a memory reference to align to.
<span class="line-modified">!     MemNode* mem_ref = find_align_to_ref(memops, max_idx);</span>
      if (mem_ref == NULL) break;
      align_to_refs.push(mem_ref);
      int iv_adjustment = get_iv_adjustment(mem_ref);
  
      if (best_align_to_mem_ref == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 703,15 ***</span>
            Node_List* p = _packset.at(i);
            MemNode* s = p-&gt;at(0)-&gt;as_Mem();
            assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
            memops.push(s);
          }
<span class="line-modified">!         best_align_to_mem_ref = find_align_to_ref(memops);</span>
          if (best_align_to_mem_ref == NULL) {
            if (TraceSuperWord) {
              tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
            }
            break;
          }
          best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
          NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
          // Restore list.
<span class="line-new-header">--- 705,31 ---</span>
            Node_List* p = _packset.at(i);
            MemNode* s = p-&gt;at(0)-&gt;as_Mem();
            assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
            memops.push(s);
          }
<span class="line-modified">!         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);</span>
          if (best_align_to_mem_ref == NULL) {
            if (TraceSuperWord) {
              tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
            }
<span class="line-added">+           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in</span>
<span class="line-added">+           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,</span>
<span class="line-added">+           // smallest data size and smallest iv offset from memory ops from remaining packs.</span>
<span class="line-added">+           if (_packset.length() &gt; 0) {</span>
<span class="line-added">+             if (orig_msize == 0) {</span>
<span class="line-added">+               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+               for (uint i = 0; i &lt; orig_msize; i++) {</span>
<span class="line-added">+                 memops.remove(0);</span>
<span class="line-added">+               }</span>
<span class="line-added">+               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);</span>
<span class="line-added">+               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);</span>
<span class="line-added">+               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+           }</span>
            break;
          }
          best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
          NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
          // Restore list.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 749,11 ***</span>
  
  //------------------------------find_align_to_ref---------------------------
  // Find a memory reference to align the loop induction variable to.
  // Looks first at stores then at loads, looking for a memory reference
  // with the largest number of references similar to it.
<span class="line-modified">! MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops) {</span>
    GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
  
    // Count number of comparable memory ops
    for (uint i = 0; i &lt; memops.size(); i++) {
      MemNode* s1 = memops.at(i)-&gt;as_Mem();
<span class="line-new-header">--- 767,11 ---</span>
  
  //------------------------------find_align_to_ref---------------------------
  // Find a memory reference to align the loop induction variable to.
  // Looks first at stores then at loads, looking for a memory reference
  // with the largest number of references similar to it.
<span class="line-modified">! MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {</span>
    GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
  
    // Count number of comparable memory ops
    for (uint i = 0; i &lt; memops.size(); i++) {
      MemNode* s1 = memops.at(i)-&gt;as_Mem();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 836,10 ***</span>
<span class="line-new-header">--- 854,11 ---</span>
        s-&gt;dump();
      }
    }
  #endif
  
<span class="line-added">+   idx = max_idx;</span>
    if (max_ct &gt; 0) {
  #ifdef ASSERT
      if (TraceSuperWord) {
        tty-&gt;print(&quot;\nVector align to node: &quot;);
        memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2043,16 ***</span>
        for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
          Node* use = def-&gt;fast_out(j);
          for (uint k = 0; k &lt; use-&gt;req(); k++) {
            Node* n = use-&gt;in(k);
            if (def == n) {
<span class="line-modified">!             // reductions should only have a Phi use at the the loop</span>
<span class="line-modified">!             // head and out of loop uses</span>
              if (def-&gt;is_reduction() &amp;&amp;
                  ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
<span class="line-modified">!                  !_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))))) {</span>
<span class="line-removed">-               assert(i == p-&gt;size()-1, &quot;must be last element of the pack&quot;);</span>
                continue;
              }
              if (!is_vector_use(use, k)) {
                return false;
              }
<span class="line-new-header">--- 2062,15 ---</span>
        for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
          Node* use = def-&gt;fast_out(j);
          for (uint k = 0; k &lt; use-&gt;req(); k++) {
            Node* n = use-&gt;in(k);
            if (def == n) {
<span class="line-modified">!             // Reductions should only have a Phi use at the loop head or a non-phi use</span>
<span class="line-modified">!             // outside of the loop if it is the last element of the pack (e.g. SafePoint).</span>
              if (def-&gt;is_reduction() &amp;&amp;
                  ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
<span class="line-modified">!                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {</span>
                continue;
              }
              if (!is_vector_use(use, k)) {
                return false;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2244,34 ***</span>
    } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
      // all loads in the pack should have the same memory state. By default,
      // we use the memory state of the last load. However, if any load could
      // not be moved down due to the dependence constraint, we use the memory
      // state of the first load.
<span class="line-modified">!     Node* first_mem = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">!     Node* last_mem = first_mem;</span>
<span class="line-modified">!     for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">!       Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">!       Node* mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">!       assert(in_bb(first_mem) || in_bb(mem) || mem == first_mem, &quot;2 different memory state from outside the loop?&quot;);</span>
<span class="line-modified">!       if (in_bb(mem)) {</span>
<span class="line-modified">!         if (in_bb(first_mem) &amp;&amp; bb_idx(mem) &lt; bb_idx(first_mem)) {</span>
<span class="line-modified">!           first_mem = mem;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (!in_bb(last_mem) || bb_idx(mem) &gt; bb_idx(last_mem)) {</span>
<span class="line-modified">!           last_mem = mem;</span>
          }
        }
      }
      bool schedule_last = true;
      for (uint i = 0; i &lt; pk-&gt;size(); i++) {
        Node* ld = pk-&gt;at(i);
<span class="line-modified">!       for (Node* current = last_mem; current != ld-&gt;in(MemNode::Memory);</span>
<span class="line-modified">!            current=current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">!         assert(current != first_mem, &quot;corrupted memory graph&quot;);</span>
<span class="line-modified">!         if(current-&gt;is_Mem() &amp;&amp; !independent(current, ld)){</span>
            schedule_last = false; // a later store depends on this load
<span class="line-removed">-           break;</span>
          }
        }
      }
  
      Node* mem_input = schedule_last ? last_mem : first_mem;
<span class="line-new-header">--- 2262,42 ---</span>
    } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
      // all loads in the pack should have the same memory state. By default,
      // we use the memory state of the last load. However, if any load could
      // not be moved down due to the dependence constraint, we use the memory
      // state of the first load.
<span class="line-modified">!     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">!     Node* first_mem = last_mem;</span>
<span class="line-modified">!     // Walk the memory graph from the current first load until the</span>
<span class="line-modified">!     // start of the loop and check if nodes on the way are memory</span>
<span class="line-modified">!     // edges of loads in the pack. The last one we encounter is the</span>
<span class="line-modified">!     // first load.</span>
<span class="line-modified">!     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">!      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);</span>
<span class="line-modified">!      for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">!         Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">!         if (ld-&gt;in(MemNode::Memory) == current) {</span>
<span class="line-modified">!           first_mem = current;</span>
<span class="line-added">+           break;</span>
          }
        }
      }
<span class="line-added">+     // Find the last load by going over the pack again and walking</span>
<span class="line-added">+     // the memory graph from the loads of the pack to the memory of</span>
<span class="line-added">+     // the first load. If we encounter the memory of the current last</span>
<span class="line-added">+     // load, then we started from further down in the memory graph and</span>
<span class="line-added">+     // the load we started from is the last load. Check for dependence</span>
<span class="line-added">+     // constraints in that loop as well.</span>
      bool schedule_last = true;
      for (uint i = 0; i &lt; pk-&gt;size(); i++) {
        Node* ld = pk-&gt;at(i);
<span class="line-modified">!       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">!         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-modified">!         if (current-&gt;in(MemNode::Memory) == last_mem) {</span>
<span class="line-modified">!           last_mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!independent(current, ld)) {</span>
            schedule_last = false; // a later store depends on this load
          }
        }
      }
  
      Node* mem_input = schedule_last ? last_mem : first_mem;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2400,10 ***</span>
<span class="line-new-header">--- 2426,16 ---</span>
          Node* mem = first-&gt;in(MemNode::Memory);
          Node* adr = low_adr-&gt;in(MemNode::Address);
          const TypePtr* atyp = n-&gt;adr_type();
          vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
          vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
<span class="line-added">+       } else if (VectorNode::is_roundopD(n)) {</span>
<span class="line-added">+         Node* in1 = vector_opd(p, 1);</span>
<span class="line-added">+         Node* in2 = low_adr-&gt;in(2);</span>
<span class="line-added">+         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);</span>
<span class="line-added">+         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));</span>
<span class="line-added">+         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();</span>
        } else if (VectorNode::is_muladds2i(n)) {
          assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
          Node* in1 = vector_opd(p, 1);
          Node* in2 = vector_opd(p, 2);
          vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2451,10 ***</span>
<span class="line-new-header">--- 2483,11 ---</span>
            vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
            vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
          }
        } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
                   opc == Op_AbsF || opc == Op_AbsD ||
<span class="line-added">+                  opc == Op_AbsI || opc == Op_AbsL ||</span>
                   opc == Op_NegF || opc == Op_NegD ||
                   opc == Op_PopCountI) {
          assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
          Node* in = vector_opd(p, 1);
          vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,17 ***</span>
          assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
          if (!opd-&gt;bottom_type()-&gt;isa_int()) {
            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
            return NULL;
          }
<span class="line-removed">-         // Move non constant shift count into vector register.</span>
<span class="line-removed">-         cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (cnt != opd) {</span>
<span class="line-removed">-         _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-removed">-         _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
        }
        return cnt;
      }
      assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
      if (opd-&gt;is_StoreVector()) {
        NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
<span class="line-new-header">--- 2705,15 ---</span>
          assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
          if (!opd-&gt;bottom_type()-&gt;isa_int()) {
            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
            return NULL;
          }
        }
<span class="line-added">+       // Move shift count into vector register.</span>
<span class="line-added">+       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-added">+       _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-added">+       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
        return cnt;
      }
      assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
      if (opd-&gt;is_StoreVector()) {
        NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3293,11 ***</span>
    LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
    for (uint i = 0; i &lt; p-&gt;size(); i++) {
      Node* n = p-&gt;at(i);
      assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
      if (!n-&gt;depends_only_on_test()) {
<span class="line-modified">!       dep = LoadNode::Pinned;</span>
      }
    }
    return dep;
  }
  
<span class="line-new-header">--- 3324,18 ---</span>
    LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
    for (uint i = 0; i &lt; p-&gt;size(); i++) {
      Node* n = p-&gt;at(i);
      assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
      if (!n-&gt;depends_only_on_test()) {
<span class="line-modified">!       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;</span>
<span class="line-added">+           dep != LoadNode::Pinned) {</span>
<span class="line-added">+         // Upgrade to unknown control...</span>
<span class="line-added">+         dep = LoadNode::UnknownControl;</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         // Otherwise, we must pin it.</span>
<span class="line-added">+         dep = LoadNode::Pinned;</span>
<span class="line-added">+       }</span>
      }
    }
    return dep;
  }
  
</pre>
<center><a href="subnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
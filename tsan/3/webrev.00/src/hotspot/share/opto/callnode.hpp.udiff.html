<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/callnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/callnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -61,11 +61,11 @@</span>
  class FastLockNode;
  
  //------------------------------StartNode--------------------------------------
  // The method start node
  class StartNode : public MultiNode {
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    const TypeTuple *_domain;
    StartNode( Node *root, const TypeTuple *domain ) : MultiNode(2), _domain(domain) {
      init_class_id(Class_Start);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,11 +319,11 @@</span>
  //------------------------------SafePointNode----------------------------------
  // A SafePointNode is a subclass of a MultiNode for convenience (and
  // potential code sharing) only - conceptually it is independent of
  // the Node semantics.
  class SafePointNode : public MultiNode {
<span class="udiff-line-modified-removed">-   virtual uint           cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool           cmp( const Node &amp;n ) const;</span>
    virtual uint           size_of() const;       // Size is bigger
  
  public:
    SafePointNode(uint edges, JVMState* jvms,
                  // A plain safepoint advertises no memory effects (NULL):
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -495,11 +495,11 @@</span>
                       // It is relative to the last (youngest) jvms-&gt;_scloff.
    uint _n_fields;    // Number of non-static fields of the scalarized object.
    DEBUG_ONLY(AllocateNode* _alloc;)
  
    virtual uint hash() const ; // { return NO_HASH; }
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
  
    uint first_index() const { return _first_index; }
  
  public:
    SafePointScalarObjectNode(const TypeOopPtr* tp,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -596,11 +596,11 @@</span>
  
    virtual const Type *bottom_type() const;
    virtual const Type* Value(PhaseGVN* phase) const;
    virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
    virtual Node* Identity(PhaseGVN* phase) { return this; }
<span class="udiff-line-modified-removed">-   virtual uint        cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool        cmp( const Node &amp;n ) const;</span>
    virtual uint        size_of() const = 0;
    virtual void        calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
    virtual Node       *match( const ProjNode *proj, const Matcher *m );
    virtual uint        ideal_reg() const { return NotAMachineReg; }
    // Are we guaranteed that this node is a safepoint?  Not true for leaf calls and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -652,11 +652,11 @@</span>
  // convention.  (The &quot;Java&quot; calling convention is the compiler&#39;s calling
  // convention, as opposed to the interpreter&#39;s or that of native C.)
  class CallJavaNode : public CallNode {
    friend class VMStructs;
  protected:
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  
    bool    _optimized_virtual;
    bool    _method_handle_invoke;
    bool    _override_symbolic_info; // Override symbolic call site info from bytecode
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -694,11 +694,11 @@</span>
  //------------------------------CallStaticJavaNode-----------------------------
  // Make a direct subroutine call using Java calling convention (for static
  // calls and optimized virtual calls, plus calls to wrappers for run-time
  // routines); generates static stub.
  class CallStaticJavaNode : public CallJavaNode {
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    CallStaticJavaNode(Compile* C, const TypeFunc* tf, address addr, ciMethod* method, int bci)
      : CallJavaNode(tf, addr, method, bci) {
      init_class_id(Class_CallStaticJava);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -748,11 +748,11 @@</span>
  };
  
  //------------------------------CallDynamicJavaNode----------------------------
  // Make a dispatched call using Java calling convention.
  class CallDynamicJavaNode : public CallJavaNode {
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    CallDynamicJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int vtable_index, int bci ) : CallJavaNode(tf,addr,method,bci), _vtable_index(vtable_index) {
      init_class_id(Class_CallDynamicJava);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -765,11 +765,11 @@</span>
  };
  
  //------------------------------CallRuntimeNode--------------------------------
  // Make a direct subroutine call node into compiled C++ code.
  class CallRuntimeNode : public CallNode {
<span class="udiff-line-modified-removed">-   virtual uint cmp( const Node &amp;n ) const;</span>
<span class="udiff-line-modified-added">+   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
  public:
    CallRuntimeNode(const TypeFunc* tf, address addr, const char* name,
                    const TypePtr* adr_type)
      : CallNode(tf, addr, adr_type)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -934,10 +934,12 @@</span>
    // inserted at exit of its &lt;.init&gt;, memory barrier for new is not necessary.
    // Inovke this method when MemBar at exit of initializer and post-dominate
    // allocation node.
    void compute_MemBar_redundancy(ciMethod* initializer);
    bool is_allocation_MemBar_redundant() { return _is_allocation_MemBar_redundant; }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem);</span>
  };
  
  //------------------------------AllocateArray---------------------------------
  //
  // High-level array allocation
</pre>
<center><a href="callnode.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
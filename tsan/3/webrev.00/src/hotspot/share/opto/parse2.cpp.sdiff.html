<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse3.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/opaquenode.hpp&quot;
  43 #include &quot;opto/parse.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 
  48 #ifndef PRODUCT
  49 extern int explicit_null_checks_inserted,
  50            explicit_null_checks_elided;
  51 #endif
  52 
  53 //---------------------------------array_load----------------------------------
  54 void Parse::array_load(BasicType bt) {
  55   const Type* elemtype = Type::TOP;
  56   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<span class="line-modified">  57   Node* adr = array_addressing(bt, 0, &amp;elemtype);</span>
  58   if (stopped())  return;     // guaranteed null or range check
  59 
  60   pop();                      // index (already used)
  61   Node* array = pop();        // the array itself
  62 
  63   if (elemtype == TypeInt::BOOL) {
  64     bt = T_BOOLEAN;
<span class="line-removed">  65   } else if (bt == T_OBJECT) {</span>
<span class="line-removed">  66     elemtype = _gvn.type(array)-&gt;is_aryptr()-&gt;elem()-&gt;make_oopptr();</span>
  67   }
<span class="line-removed">  68 </span>
  69   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
  70 
  71   Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,
  72                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
  73   if (big_val) {
  74     push_pair(ld);
  75   } else {
  76     push(ld);
  77   }
  78 }
  79 
  80 
  81 //--------------------------------array_store----------------------------------
  82 void Parse::array_store(BasicType bt) {
  83   const Type* elemtype = Type::TOP;
  84   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<span class="line-modified">  85   Node* adr = array_addressing(bt, big_val ? 2 : 1, &amp;elemtype);</span>
  86   if (stopped())  return;     // guaranteed null or range check
  87   if (bt == T_OBJECT) {
  88     array_store_check();
  89   }
  90   Node* val;                  // Oop to store
  91   if (big_val) {
  92     val = pop_pair();
  93   } else {
  94     val = pop();
  95   }
  96   pop();                      // index (already used)
  97   Node* array = pop();        // the array itself
  98 
  99   if (elemtype == TypeInt::BOOL) {
 100     bt = T_BOOLEAN;
<span class="line-removed"> 101   } else if (bt == T_OBJECT) {</span>
<span class="line-removed"> 102     elemtype = _gvn.type(array)-&gt;is_aryptr()-&gt;elem()-&gt;make_oopptr();</span>
 103   }
<span class="line-removed"> 104 </span>
 105   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 106 
 107   access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 108 }
 109 
 110 
 111 //------------------------------array_addressing-------------------------------
 112 // Pull array and index from the stack.  Compute pointer-to-element.
<span class="line-modified"> 113 Node* Parse::array_addressing(BasicType type, int vals, const Type* *result2) {</span>
 114   Node *idx   = peek(0+vals);   // Get from stack without popping
 115   Node *ary   = peek(1+vals);   // in case of exception
 116 
 117   // Null check the array base, with correct stack contents
 118   ary = null_check(ary, T_ARRAY);
 119   // Compile-time detect of null-exception?
 120   if (stopped())  return top();
 121 
 122   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 123   const TypeInt*    sizetype = arytype-&gt;size();
<span class="line-modified"> 124   const Type*       elemtype = arytype-&gt;elem();</span>
 125 
<span class="line-modified"> 126   if (UseUniqueSubclasses &amp;&amp; result2 != NULL) {</span>
 127     const Type* el = elemtype-&gt;make_ptr();
 128     if (el &amp;&amp; el-&gt;isa_instptr()) {
 129       const TypeInstPtr* toop = el-&gt;is_instptr();
 130       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 131         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 132         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 133         elemtype = subklass-&gt;join_speculative(el);
 134       }
 135     }
 136   }
 137 
 138   // Check for big class initializers with all constant offsets
 139   // feeding into a known-size array.
 140   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 141   // See if the highest idx value is less than the lowest array bound,
 142   // and if the idx value cannot be negative:
 143   bool need_range_check = true;
 144   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 145     need_range_check = false;
 146     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
</pre>
<hr />
<pre>
 190         // This creates &quot;tentative&quot; range checks at this point,
 191         // which are not guaranteed to throw exceptions.
 192         // See IfNode::Ideal, is_range_check, adjust_check.
 193         uncommon_trap(Deoptimization::Reason_range_check,
 194                       Deoptimization::Action_make_not_entrant,
 195                       NULL, &quot;range_check&quot;);
 196       } else {
 197         // If we have already recompiled with the range-check-widening
 198         // heroic optimization turned off, then we must really be throwing
 199         // range check exceptions.
 200         builtin_throw(Deoptimization::Reason_range_check, idx);
 201       }
 202     }
 203   }
 204   // Check for always knowing you are throwing a range-check exception
 205   if (stopped())  return top();
 206 
 207   // Make array address computation control dependent to prevent it
 208   // from floating above the range check during loop optimizations.
 209   Node* ptr = array_element_address(ary, idx, type, sizetype, control());
<span class="line-removed"> 210 </span>
<span class="line-removed"> 211   if (result2 != NULL)  *result2 = elemtype;</span>
<span class="line-removed"> 212 </span>
 213   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 214 
 215   return ptr;
 216 }
 217 
 218 
 219 // returns IfNode
 220 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 221   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 222   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 223   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 224   return iff;
 225 }
 226 
 227 // return Region node
 228 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 229   Node *region  = new RegionNode(3); // 2 results
 230   record_for_igvn(region);
 231   region-&gt;init_req(1, iffalse);
 232   region-&gt;init_req(2, iftrue );
</pre>
<hr />
<pre>
 588   }
 589   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
 590 
 591   if (trim_ranges) {
 592     merge_ranges(ranges, rp);
 593   }
 594 
 595   // Safepoint in case backward branch observed
 596   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
 597     add_safepoint();
 598 
 599   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 600 }
 601 
 602 static float if_prob(float taken_cnt, float total_cnt) {
 603   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
 604   if (total_cnt == 0) {
 605     return PROB_FAIR;
 606   }
 607   float p = taken_cnt / total_cnt;
<span class="line-modified"> 608   return MIN2(MAX2(p, PROB_MIN), PROB_MAX);</span>
 609 }
 610 
 611 static float if_cnt(float cnt) {
 612   if (cnt == 0) {
 613     return COUNT_UNKNOWN;
 614   }
 615   return cnt;
 616 }
 617 
 618 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
 619   float total_cnt = 0;
 620   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
 621     total_cnt += sr-&gt;cnt();
 622   }
 623   return total_cnt;
 624 }
 625 
 626 class SwitchRanges : public ResourceObj {
 627 public:
 628   SwitchRange* _lo;
</pre>
<hr />
<pre>
1031       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1032       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1033       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1034     }
1035 
1036 
1037     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1038 
1039     if (mid-&gt;is_singleton()) {
1040       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1041       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1042 
1043       // Special Case:  If there are exactly three ranges, and the high
1044       // and low range each go to the same place, omit the &quot;gt&quot; test,
1045       // since it will not discriminate anything.
1046       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1047 
1048       // if there is a higher range, test for it and process it:
1049       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1050         // two comparisons of same values--should enable 1 test for 2 branches
<span class="line-modified">1051         // Use BoolTest::le instead of BoolTest::gt</span>
1052         float cnt = sum_of_cnts(lo, mid-1);
<span class="line-modified">1053         IfNode *iff_le  = jump_if_fork_int(key_val, test_val, BoolTest::le, if_prob(cnt, total_cnt), if_cnt(cnt));</span>
<span class="line-modified">1054         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_le) );</span>
<span class="line-modified">1055         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_le) );</span>
1056         { PreserveJVMState pjvms(this);
1057           set_control(iffalse);
1058           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1059         }
1060         set_control(iftrue);
1061       }
1062 
1063     } else {
1064       // mid is a range, not a singleton, so treat mid..hi as a unit
1065       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1066       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1067 
1068       // if there is a higher range, test for it and process it:
1069       if (mid == hi) {
1070         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1071       } else {
1072         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1073         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1074         { PreserveJVMState pjvms(this);
1075           set_control(iftrue);
</pre>
<hr />
<pre>
2730       inc_sp(1);
2731       Node* null_ctl = top();
2732       b = null_check_oop(b, &amp;null_ctl, true, true, true);
2733       assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2734       dec_sp(1);
2735     } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
2736                !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2737       inc_sp(1);
2738       b = null_assert(b);
2739       dec_sp(1);
2740     }
2741     c = _gvn.transform( new CmpPNode(b, a) );
2742     do_ifnull(btest, c);
2743     break;
2744 
2745   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
2746   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
2747   handle_if_acmp:
2748     // If this is a backwards branch in the bytecodes, add Safepoint
2749     maybe_add_safepoint(iter().get_dest());
<span class="line-modified">2750     a = access_resolve(pop(), 0);</span>
<span class="line-modified">2751     b = access_resolve(pop(), 0);</span>
2752     c = _gvn.transform( new CmpPNode(b, a) );
2753     c = optimize_cmp_with_klass(c);
2754     do_if(btest, c);
2755     break;
2756 
2757   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
2758   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
2759   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
2760   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
2761   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
2762   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
2763   handle_ifxx:
2764     // If this is a backwards branch in the bytecodes, add Safepoint
2765     maybe_add_safepoint(iter().get_dest());
2766     a = _gvn.intcon(0);
2767     b = pop();
2768     c = _gvn.transform( new CmpINode(b, a) );
2769     do_if(btest, c);
2770     break;
2771 
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/opaquenode.hpp&quot;
  43 #include &quot;opto/parse.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 
  48 #ifndef PRODUCT
  49 extern int explicit_null_checks_inserted,
  50            explicit_null_checks_elided;
  51 #endif
  52 
  53 //---------------------------------array_load----------------------------------
  54 void Parse::array_load(BasicType bt) {
  55   const Type* elemtype = Type::TOP;
  56   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<span class="line-modified">  57   Node* adr = array_addressing(bt, 0, elemtype);</span>
  58   if (stopped())  return;     // guaranteed null or range check
  59 
  60   pop();                      // index (already used)
  61   Node* array = pop();        // the array itself
  62 
  63   if (elemtype == TypeInt::BOOL) {
  64     bt = T_BOOLEAN;


  65   }

  66   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
  67 
  68   Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,
  69                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
  70   if (big_val) {
  71     push_pair(ld);
  72   } else {
  73     push(ld);
  74   }
  75 }
  76 
  77 
  78 //--------------------------------array_store----------------------------------
  79 void Parse::array_store(BasicType bt) {
  80   const Type* elemtype = Type::TOP;
  81   bool big_val = bt == T_DOUBLE || bt == T_LONG;
<span class="line-modified">  82   Node* adr = array_addressing(bt, big_val ? 2 : 1, elemtype);</span>
  83   if (stopped())  return;     // guaranteed null or range check
  84   if (bt == T_OBJECT) {
  85     array_store_check();
  86   }
  87   Node* val;                  // Oop to store
  88   if (big_val) {
  89     val = pop_pair();
  90   } else {
  91     val = pop();
  92   }
  93   pop();                      // index (already used)
  94   Node* array = pop();        // the array itself
  95 
  96   if (elemtype == TypeInt::BOOL) {
  97     bt = T_BOOLEAN;


  98   }

  99   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 100 
 101   access_store_at(array, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 102 }
 103 
 104 
 105 //------------------------------array_addressing-------------------------------
 106 // Pull array and index from the stack.  Compute pointer-to-element.
<span class="line-modified"> 107 Node* Parse::array_addressing(BasicType type, int vals, const Type*&amp; elemtype) {</span>
 108   Node *idx   = peek(0+vals);   // Get from stack without popping
 109   Node *ary   = peek(1+vals);   // in case of exception
 110 
 111   // Null check the array base, with correct stack contents
 112   ary = null_check(ary, T_ARRAY);
 113   // Compile-time detect of null-exception?
 114   if (stopped())  return top();
 115 
 116   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 117   const TypeInt*    sizetype = arytype-&gt;size();
<span class="line-modified"> 118   elemtype = arytype-&gt;elem();</span>
 119 
<span class="line-modified"> 120   if (UseUniqueSubclasses) {</span>
 121     const Type* el = elemtype-&gt;make_ptr();
 122     if (el &amp;&amp; el-&gt;isa_instptr()) {
 123       const TypeInstPtr* toop = el-&gt;is_instptr();
 124       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 125         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 126         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 127         elemtype = subklass-&gt;join_speculative(el);
 128       }
 129     }
 130   }
 131 
 132   // Check for big class initializers with all constant offsets
 133   // feeding into a known-size array.
 134   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 135   // See if the highest idx value is less than the lowest array bound,
 136   // and if the idx value cannot be negative:
 137   bool need_range_check = true;
 138   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 139     need_range_check = false;
 140     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
</pre>
<hr />
<pre>
 184         // This creates &quot;tentative&quot; range checks at this point,
 185         // which are not guaranteed to throw exceptions.
 186         // See IfNode::Ideal, is_range_check, adjust_check.
 187         uncommon_trap(Deoptimization::Reason_range_check,
 188                       Deoptimization::Action_make_not_entrant,
 189                       NULL, &quot;range_check&quot;);
 190       } else {
 191         // If we have already recompiled with the range-check-widening
 192         // heroic optimization turned off, then we must really be throwing
 193         // range check exceptions.
 194         builtin_throw(Deoptimization::Reason_range_check, idx);
 195       }
 196     }
 197   }
 198   // Check for always knowing you are throwing a range-check exception
 199   if (stopped())  return top();
 200 
 201   // Make array address computation control dependent to prevent it
 202   // from floating above the range check during loop optimizations.
 203   Node* ptr = array_element_address(ary, idx, type, sizetype, control());



 204   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 205 
 206   return ptr;
 207 }
 208 
 209 
 210 // returns IfNode
 211 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 212   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 213   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 214   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 215   return iff;
 216 }
 217 
 218 // return Region node
 219 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 220   Node *region  = new RegionNode(3); // 2 results
 221   record_for_igvn(region);
 222   region-&gt;init_req(1, iffalse);
 223   region-&gt;init_req(2, iftrue );
</pre>
<hr />
<pre>
 579   }
 580   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
 581 
 582   if (trim_ranges) {
 583     merge_ranges(ranges, rp);
 584   }
 585 
 586   // Safepoint in case backward branch observed
 587   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
 588     add_safepoint();
 589 
 590   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 591 }
 592 
 593 static float if_prob(float taken_cnt, float total_cnt) {
 594   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
 595   if (total_cnt == 0) {
 596     return PROB_FAIR;
 597   }
 598   float p = taken_cnt / total_cnt;
<span class="line-modified"> 599   return clamp(p, PROB_MIN, PROB_MAX);</span>
 600 }
 601 
 602 static float if_cnt(float cnt) {
 603   if (cnt == 0) {
 604     return COUNT_UNKNOWN;
 605   }
 606   return cnt;
 607 }
 608 
 609 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
 610   float total_cnt = 0;
 611   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
 612     total_cnt += sr-&gt;cnt();
 613   }
 614   return total_cnt;
 615 }
 616 
 617 class SwitchRanges : public ResourceObj {
 618 public:
 619   SwitchRange* _lo;
</pre>
<hr />
<pre>
1022       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1023       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1024       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1025     }
1026 
1027 
1028     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1029 
1030     if (mid-&gt;is_singleton()) {
1031       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1032       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1033 
1034       // Special Case:  If there are exactly three ranges, and the high
1035       // and low range each go to the same place, omit the &quot;gt&quot; test,
1036       // since it will not discriminate anything.
1037       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1038 
1039       // if there is a higher range, test for it and process it:
1040       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1041         // two comparisons of same values--should enable 1 test for 2 branches
<span class="line-modified">1042         // Use BoolTest::lt instead of BoolTest::gt</span>
1043         float cnt = sum_of_cnts(lo, mid-1);
<span class="line-modified">1044         IfNode *iff_lt  = jump_if_fork_int(key_val, test_val, BoolTest::lt, if_prob(cnt, total_cnt), if_cnt(cnt));</span>
<span class="line-modified">1045         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_lt) );</span>
<span class="line-modified">1046         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_lt) );</span>
1047         { PreserveJVMState pjvms(this);
1048           set_control(iffalse);
1049           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1050         }
1051         set_control(iftrue);
1052       }
1053 
1054     } else {
1055       // mid is a range, not a singleton, so treat mid..hi as a unit
1056       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1057       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1058 
1059       // if there is a higher range, test for it and process it:
1060       if (mid == hi) {
1061         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1062       } else {
1063         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1064         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1065         { PreserveJVMState pjvms(this);
1066           set_control(iftrue);
</pre>
<hr />
<pre>
2721       inc_sp(1);
2722       Node* null_ctl = top();
2723       b = null_check_oop(b, &amp;null_ctl, true, true, true);
2724       assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2725       dec_sp(1);
2726     } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
2727                !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2728       inc_sp(1);
2729       b = null_assert(b);
2730       dec_sp(1);
2731     }
2732     c = _gvn.transform( new CmpPNode(b, a) );
2733     do_ifnull(btest, c);
2734     break;
2735 
2736   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
2737   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
2738   handle_if_acmp:
2739     // If this is a backwards branch in the bytecodes, add Safepoint
2740     maybe_add_safepoint(iter().get_dest());
<span class="line-modified">2741     a = pop();</span>
<span class="line-modified">2742     b = pop();</span>
2743     c = _gvn.transform( new CmpPNode(b, a) );
2744     c = optimize_cmp_with_klass(c);
2745     do_if(btest, c);
2746     break;
2747 
2748   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
2749   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
2750   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
2751   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
2752   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
2753   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
2754   handle_ifxx:
2755     // If this is a backwards branch in the bytecodes, add Safepoint
2756     maybe_add_safepoint(iter().get_dest());
2757     a = _gvn.intcon(0);
2758     b = pop();
2759     c = _gvn.transform( new CmpINode(b, a) );
2760     do_if(btest, c);
2761     break;
2762 
</pre>
</td>
</tr>
</table>
<center><a href="parse1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse3.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
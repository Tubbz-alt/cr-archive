<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ifg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/ifnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
<span class="line-modified"> 120   if (r-&gt;is_Loop() &amp;&amp; r-&gt;in(LoopNode::LoopBackControl)-&gt;is_top()) return NULL; // going away anyway</span>
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
</pre>
<hr />
<pre>
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;
<span class="line-removed"> 241   Node* predicate_proj = NULL;</span>
<span class="line-removed"> 242   int nb_predicate_proj = 0;</span>
 243   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 244     if (phi-&gt;in(ii) == con1) {
 245       req_c++;
 246     }
 247     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 248     if (proj != NULL) {
<span class="line-modified"> 249       nb_predicate_proj++;</span>
<span class="line-removed"> 250       predicate_proj = proj;</span>
 251     }
 252   }
 253 
 254   // If all the defs of the phi are the same constant, we already have the desired end state.
 255   // Skip the split that would create empty phi and region nodes.
 256   if((r-&gt;req() - req_c) == 1) {
 257     return NULL;
 258   }
 259 
<span class="line-removed"> 260   if (nb_predicate_proj &gt; 1) {</span>
<span class="line-removed"> 261     // Can happen in case of loop unswitching and when the loop is</span>
<span class="line-removed"> 262     // optimized out: it&#39;s not a loop anymore so we don&#39;t care about</span>
<span class="line-removed"> 263     // predicates.</span>
<span class="line-removed"> 264     assert(!r-&gt;is_Loop(), &quot;this must not be a loop anymore&quot;);</span>
<span class="line-removed"> 265     predicate_proj = NULL;</span>
<span class="line-removed"> 266   }</span>
<span class="line-removed"> 267   Node* predicate_c = NULL;</span>
<span class="line-removed"> 268   Node* predicate_x = NULL;</span>
<span class="line-removed"> 269   bool counted_loop = r-&gt;is_CountedLoop();</span>
<span class="line-removed"> 270   if (counted_loop) {</span>
<span class="line-removed"> 271     // Ignore counted loops for now because the split-if logic does not work</span>
<span class="line-removed"> 272     // in all the cases (for example, with strip mined loops). Also, above</span>
<span class="line-removed"> 273     // checks only pass for already degraded loops without a tripcount phi</span>
<span class="line-removed"> 274     // and these are essentially dead and will go away during igvn.</span>
<span class="line-removed"> 275     return NULL;</span>
<span class="line-removed"> 276   }</span>
<span class="line-removed"> 277 </span>
 278   Node *region_c = new RegionNode(req_c + 1);
 279   Node *phi_c    = con1;
 280   uint  len      = r-&gt;req();
 281   Node *region_x = new RegionNode(len - req_c);
 282   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 283   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 284     if (phi-&gt;in(i) == con1) {
 285       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
<span class="line-removed"> 286       if (r-&gt;in(i) == predicate_proj)</span>
<span class="line-removed"> 287         predicate_c = predicate_proj;</span>
 288     } else {
 289       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 290       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
<span class="line-removed"> 291       if (r-&gt;in(i) == predicate_proj)</span>
<span class="line-removed"> 292         predicate_x = predicate_proj;</span>
 293     }
 294   }
<span class="line-removed"> 295   if (predicate_c != NULL &amp;&amp; (req_c &gt; 1)) {</span>
<span class="line-removed"> 296     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed"> 297     predicate_c = NULL; // Do not clone predicate below merge point</span>
<span class="line-removed"> 298   }</span>
<span class="line-removed"> 299   if (predicate_x != NULL &amp;&amp; ((len - req_c) &gt; 2)) {</span>
<span class="line-removed"> 300     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed"> 301     predicate_x = NULL; // Do not clone predicate below merge point</span>
<span class="line-removed"> 302   }</span>
 303 
 304   // Register the new RegionNodes but do not transform them.  Cannot
 305   // transform until the entire Region/Phi conglomerate has been hacked
 306   // as a single huge transform.
 307   igvn-&gt;register_new_node_with_optimizer( region_c );
 308   igvn-&gt;register_new_node_with_optimizer( region_x );
 309   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 310   // about to get one.  If this only use goes away, then phi_x will look dead.
 311   // However, he will be picking up some more uses down below.
 312   Node *hook = new Node(4);
 313   hook-&gt;init_req(0, phi_x);
 314   hook-&gt;init_req(1, phi_c);
 315   phi_x = phase-&gt;transform( phi_x );
 316 
 317   // Make the compare
 318   Node *cmp_c = phase-&gt;makecon(t);
 319   Node *cmp_x = cmp-&gt;clone();
 320   cmp_x-&gt;set_req(1,phi_x);
 321   cmp_x-&gt;set_req(2,con2);
 322   cmp_x = phase-&gt;transform(cmp_x);
</pre>
<hr />
<pre>
 324   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 325   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 326   // Make the IfNode
 327   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 328   iff_c-&gt;set_req(0, region_c);
 329   iff_c-&gt;set_req(1, b_c);
 330   igvn-&gt;set_type_bottom(iff_c);
 331   igvn-&gt;_worklist.push(iff_c);
 332   hook-&gt;init_req(2, iff_c);
 333 
 334   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 335   iff_x-&gt;set_req(0, region_x);
 336   iff_x-&gt;set_req(1, b_x);
 337   igvn-&gt;set_type_bottom(iff_x);
 338   igvn-&gt;_worklist.push(iff_x);
 339   hook-&gt;init_req(3, iff_x);
 340 
 341   // Make the true/false arms
 342   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 343   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
<span class="line-removed"> 344   if (predicate_c != NULL) {</span>
<span class="line-removed"> 345     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed"> 346     // Clone loop predicates to each path</span>
<span class="line-removed"> 347     iff_c_t = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_t, !counted_loop);</span>
<span class="line-removed"> 348     iff_c_f = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_f, !counted_loop);</span>
<span class="line-removed"> 349   }</span>
 350   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 351   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
<span class="line-removed"> 352   if (predicate_x != NULL) {</span>
<span class="line-removed"> 353     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed"> 354     // Clone loop predicates to each path</span>
<span class="line-removed"> 355     iff_x_t = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_t, !counted_loop);</span>
<span class="line-removed"> 356     iff_x_f = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_f, !counted_loop);</span>
<span class="line-removed"> 357   }</span>
 358 
 359   // Merge the TRUE paths
 360   Node *region_s = new RegionNode(3);
 361   igvn-&gt;_worklist.push(region_s);
 362   region_s-&gt;init_req(1, iff_c_t);
 363   region_s-&gt;init_req(2, iff_x_t);
 364   igvn-&gt;register_new_node_with_optimizer( region_s );
 365 
 366   // Merge the FALSE paths
 367   Node *region_f = new RegionNode(3);
 368   igvn-&gt;_worklist.push(region_f);
 369   region_f-&gt;init_req(1, iff_c_f);
 370   region_f-&gt;init_req(2, iff_x_f);
 371   igvn-&gt;register_new_node_with_optimizer( region_f );
 372 
 373   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 374   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 375   cmp-&gt;set_req(2,NULL);
 376   // Check for all uses of the Phi and give them a new home.
 377   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
</pre>
<hr />
<pre>
 616   if( dom-&gt;is_Root() )
 617     return NULL;
 618 
 619   // Else hit a Region.  Check for a loop header
 620   if( dom-&gt;is_Loop() )
 621     return dom-&gt;in(1);          // Skip up thru loops
 622 
 623   // Check for small diamonds
 624   Node *din1, *din2, *din3, *din4;
 625   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 626       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 627       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 628       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 629       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 630     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 631         (din3 = din3-&gt;in(0)) )
 632       din3 = din3-&gt;in(0);
 633     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 634         (din4 = din4-&gt;in(0)) )
 635       din4 = din4-&gt;in(0);
<span class="line-modified"> 636     if( din3 == din4 &amp;&amp; din3-&gt;is_If() )</span>
 637       return din3;              // Skip around diamonds
 638   }
 639 
 640   // Give up the search at true merges
 641   return NULL;                  // Dead loop?  Or hit root?
 642 }
 643 
 644 
 645 //------------------------------filtered_int_type--------------------------------
 646 // Return a possibly more restrictive type for val based on condition control flow for an if
<span class="line-modified"> 647 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node *val, Node* if_proj) {</span>
 648   assert(if_proj &amp;&amp;
 649          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 650   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 651     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 652     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 653       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 654       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 655         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 656         if (cmp-&gt;in(1) == val) {
 657           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 658           if (cmp2_t != NULL) {
 659             jint lo = cmp2_t-&gt;_lo;
 660             jint hi = cmp2_t-&gt;_hi;
 661             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 662             switch (msk) {
<span class="line-modified"> 663             case BoolTest::ne:</span>









 664               // Can&#39;t refine type
 665               return NULL;

 666             case BoolTest::eq:
 667               return cmp2_t;
 668             case BoolTest::lt:
 669               lo = TypeInt::INT-&gt;_lo;
 670               if (hi - 1 &lt; hi) {
 671                 hi = hi - 1;
 672               }
 673               break;
 674             case BoolTest::le:
 675               lo = TypeInt::INT-&gt;_lo;
 676               break;
 677             case BoolTest::gt:
 678               if (lo + 1 &gt; lo) {
 679                 lo = lo + 1;
 680               }
 681               hi = TypeInt::INT-&gt;_hi;
 682               break;
 683             case BoolTest::ge:
 684               // lo unchanged
 685               hi = TypeInt::INT-&gt;_hi;
</pre>
<hr />
<pre>
 719 //
 720 // Or given an if testing (CmpI n v) check for a dominating if that is
 721 // testing (CmpI n v2), both having one projection leading to an
 722 // uncommon trap. Allow Another independent guard in between to cover
 723 // an explicit range check:
 724 // if (index &lt; 0 || index &gt;= array.length) {
 725 // which may need a null check to guard the LoadRange
 726 //
 727 //                   If
 728 //                  / \
 729 //                 /   \
 730 //                /     \
 731 //              If      unc
 732 //              /\
 733 //             /  \
 734 //            /    \
 735 //           /      unc
 736 //
 737 
 738 // Is the comparison for this If suitable for folding?
<span class="line-modified"> 739 bool IfNode::cmpi_folds(PhaseIterGVN* igvn) {</span>
 740   return in(1) != NULL &amp;&amp;
 741     in(1)-&gt;is_Bool() &amp;&amp;
 742     in(1)-&gt;in(1) != NULL &amp;&amp;
 743     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 744     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 745     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 746     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
<span class="line-modified"> 747      in(1)-&gt;as_Bool()-&gt;_test.is_greater());</span>

 748 }
 749 
 750 // Is a dominating control suitable for folding with this if?
 751 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 752   return ctrl != NULL &amp;&amp;
 753     ctrl-&gt;is_Proj() &amp;&amp;
 754     ctrl-&gt;in(0) != NULL &amp;&amp;
 755     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 756     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
<span class="line-modified"> 757     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn) &amp;&amp;</span>
 758     // Must compare same value
 759     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 760     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 761 }
 762 
 763 // Do this If and the dominating If share a region?
 764 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 765   ProjNode* otherproj = proj-&gt;other_if_proj();
 766   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 767   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 768   success = NULL;
 769   fail = NULL;
 770 
 771   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 772     for (int i = 0; i &lt; 2; i++) {
 773       ProjNode* proj = proj_out(i);
 774       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 775         success = proj;
 776       } else if (fail == NULL) {
 777         fail = proj;
</pre>
<hr />
<pre>
 899   //        this_bool = x {&lt;,&lt;=} b
 900   //                       / \
 901   //  fail = {True,False} /   \ success = {False,True}
 902   //                     /
 903   //
 904   // (Second test guaranteed canonicalized, first one may not have
 905   // been canonicalized yet)
 906   //
 907   // into:
 908   //
 909   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 910   //                       / \
 911   //                 fail /   \ success
 912   //                     /
 913   //
 914 
 915   // Figure out which of the two tests sets the upper bound and which
 916   // sets the lower bound if any.
 917   Node* adjusted_lim = NULL;
 918   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
<span class="line-modified"> 919       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint) {</span>
 920     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 921            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 922     // this test was canonicalized
 923     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 924 
 925     // this_bool = &lt;
 926     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 927     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 928     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 929     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 930     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 931     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 932     // this_bool = &lt;=
 933     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 934     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 935     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 936     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 937     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 938     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 939     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 940     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 941 
 942     if (hi_test == BoolTest::lt) {
 943       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 944         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 945       }
 946     } else {
 947       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 948       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 949         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 950         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 951         cond = BoolTest::lt;
 952       } else {
 953         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 954         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 955         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 956         cond = BoolTest::lt;
 957       }
 958     }
 959   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
<span class="line-modified"> 960              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint) {</span>
 961 
 962     // this_bool = &lt;
 963     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 964     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 965     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 966     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 967     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 968     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 969     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 970     // this_bool = &lt;=
 971     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 972     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 973     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 974     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 975     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 976     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 977     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 978 
 979     swap(lo, hi);
 980     swap(lo_type, hi_type);
</pre>
<hr />
<pre>
 991       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 992         cond = BoolTest::ge;
 993       } else {
 994         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 995         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 996         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 997         cond = BoolTest::ge;
 998       }
 999     } else if (lo_test == BoolTest::le) {
1000       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
1001         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
1002         cond = BoolTest::ge;
1003       } else {
1004         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
1005         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1006         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
1007         cond = BoolTest::ge;
1008       }
1009     }
1010   } else {
<span class="line-modified">1011     const TypeInt* failtype  = filtered_int_type(igvn, n, proj);</span>
1012     if (failtype != NULL) {
1013       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
1014       if (type2 != NULL) {
1015         failtype = failtype-&gt;join(type2)-&gt;is_int();
1016         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
1017           // previous if determines the result of this if so
1018           // replace Bool with constant
1019           igvn-&gt;_worklist.push(in(1));
1020           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
1021           return true;
1022         }
1023       }
1024     }
1025     lo = NULL;
1026     hi = NULL;
1027   }
1028 
1029   if (lo &amp;&amp; hi) {
1030     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
1031     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
</pre>
<hr />
<pre>
1267   Node* c = otherproj-&gt;clone();
1268 
1269   c = igvn-&gt;transform(c);
1270   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1271   new_unc-&gt;set_req(0, c);
1272   new_unc = igvn-&gt;transform(new_unc);
1273   call_proj-&gt;set_req(0, new_unc);
1274   call_proj = igvn-&gt;transform(call_proj);
1275   halt-&gt;set_req(0, call_proj);
1276   halt = igvn-&gt;transform(halt);
1277 
1278   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1279   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1280 }
1281 
1282 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1283   if (Opcode() != Op_If) return NULL;
1284 
1285   if (cmpi_folds(igvn)) {
1286     Node* ctrl = in(0);
<span class="line-modified">1287     if (is_ctrl_folds(ctrl, igvn) &amp;&amp;</span>
<span class="line-removed">1288         ctrl-&gt;outcnt() == 1) {</span>
1289       // A integer comparison immediately dominated by another integer
1290       // comparison
1291       ProjNode* success = NULL;
1292       ProjNode* fail = NULL;
1293       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1294       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1295           // Next call modifies graph so must be last
1296           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1297         return this;
1298       }
1299       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1300           // Next call modifies graph so must be last
1301           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1302         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1303       }
1304       return NULL;
1305     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1306                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1307       ProjNode* success = NULL;
1308       ProjNode* fail = NULL;
</pre>
<hr />
<pre>
1420   // Try to split the IF
1421   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1422   Node *s = split_if(this, igvn);
1423   if (s != NULL)  return s;
1424 
1425   return NodeSentinel;
1426 }
1427 
1428 //------------------------------Ideal------------------------------------------
1429 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1430 // control copies
1431 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1432   Node* res = Ideal_common(phase, can_reshape);
1433   if (res != NodeSentinel) {
1434     return res;
1435   }
1436 
1437   // Check for people making a useless boolean: things like
1438   // if( (x &lt; y ? true : false) ) { ... }
1439   // Replace with if( x &lt; y ) { ... }
<span class="line-modified">1440   Node *bol2 = remove_useless_bool(this, phase);</span>
<span class="line-modified">1441   if( bol2 ) return bol2;</span>
1442 
1443   if (in(0) == NULL) return NULL;     // Dead loop?
1444 
<span class="line-modified">1445   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();</span>
1446   Node* result = fold_compares(igvn);
1447   if (result != NULL) {
1448     return result;
1449   }
1450 
1451   // Scan for an equivalent test
<span class="line-modified">1452   Node *cmp;</span>
<span class="line-modified">1453   int dist = 0;               // Cutoff limit for search</span>
<span class="line-modified">1454   int op = Opcode();</span>
<span class="line-modified">1455   if( op == Op_If &amp;&amp;</span>
<span class="line-modified">1456       (cmp=in(1)-&gt;in(1))-&gt;Opcode() == Op_CmpP ) {</span>
<span class="line-modified">1457     if( cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead</span>
<span class="line-removed">1458         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR ) {</span>
1459       dist = 64;              // Limit for null-pointer scans
<span class="line-removed">1460     } else {</span>
<span class="line-removed">1461       dist = 4;               // Do not bother for random pointer tests</span>
1462     }
<span class="line-removed">1463   } else {</span>
<span class="line-removed">1464     dist = 4;                 // Limit for random junky scans</span>
1465   }
1466 
1467   Node* prev_dom = search_identical(dist);
1468 
<span class="line-modified">1469   if (prev_dom == NULL) {</span>
<span class="line-modified">1470     return NULL;</span>

1471   }
1472 
<span class="line-modified">1473   // Replace dominated IfNode</span>
<span class="line-removed">1474   return dominated_by(prev_dom, igvn);</span>
1475 }
1476 
1477 //------------------------------dominated_by-----------------------------------
1478 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1479 #ifndef PRODUCT
1480   if (TraceIterativeGVN) {
1481     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1482   }
<span class="line-removed">1483   if (VerifyOpto &amp;&amp; !igvn-&gt;allow_progress()) {</span>
<span class="line-removed">1484     // Found an equivalent dominating test,</span>
<span class="line-removed">1485     // we can not guarantee reaching a fix-point for these during iterativeGVN</span>
<span class="line-removed">1486     // since intervening nodes may not change.</span>
<span class="line-removed">1487     return NULL;</span>
<span class="line-removed">1488   }</span>
1489 #endif
1490 
1491   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1492   Node *idom = in(0);
1493   // Need opcode to decide which way &#39;this&#39; test goes
1494   int prev_op = prev_dom-&gt;Opcode();
1495   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1496 
1497   // Loop predicates may have depending checks which should not
1498   // be skipped. For example, range check predicate has two checks
1499   // for lower and upper bounds.
1500   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1501   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1502       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1503     prev_dom = idom;
1504   }
1505 
1506   // Now walk the current IfNode&#39;s projections.
1507   // Loop ends when &#39;this&#39; has no more uses.
1508   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
</pre>
<hr />
<pre>
1557     dist--;
1558     prev_dom = dom;
1559     dom = up_one_dom(dom);
1560     if (!dom) return NULL;
1561   }
1562 
1563   // Check that we did not follow a loop back to ourselves
1564   if (this == dom) {
1565     return NULL;
1566   }
1567 
1568 #ifndef PRODUCT
1569   if (dist &gt; 2) { // Add to count of NULL checks elided
1570     explicit_null_checks_elided++;
1571   }
1572 #endif
1573 
1574   return prev_dom;
1575 }
1576 












































































































1577 //------------------------------Identity---------------------------------------
1578 // If the test is constant &amp; we match, then we are the input Control
1579 Node* IfProjNode::Identity(PhaseGVN* phase) {
1580   // Can only optimize if cannot go the other way
1581   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1582   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1583        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1584        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1585       (!phase-&gt;is_IterGVN() ||
1586        // During IGVN, first wait for the dead branch to be killed.
1587        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1588        // that doesn&#39;t go away because it still has uses and this branch of the
1589        // If) which breaks other optimizations. Node::has_special_unique_user()
1590        // will cause this node to be reprocessed once the dead branch is killed.
1591        in(0)-&gt;outcnt() == 1))) {
1592     // IfNode control
1593     return in(0)-&gt;in(0);
1594   }
1595   // no progress
1596   return this;
</pre>
<hr />
<pre>
1702 
1703   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1704   // Setup to scan up the CFG looking for a dominating test
1705   Node* prev_dom = this;
1706 
1707   // Check for range-check vs other kinds of tests
1708   Node* index1;
1709   Node* range1;
1710   jint offset1;
1711   int flip1 = is_range_check(range1, index1, offset1);
1712   if (flip1) {
1713     Node* dom = in(0);
1714     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1715     // so all checks we inspect post-dominate the top-most check we find.
1716     // If we are going to fail the current check and we reach the top check
1717     // then we are guaranteed to fail, so just start interpreting there.
1718     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1719     // checks.
1720 
1721     // The top 3 range checks seen
<span class="line-modified">1722     const int NRC =3;</span>
1723     RangeCheck prev_checks[NRC];
1724     int nb_checks = 0;
1725 
1726     // Low and high offsets seen so far
1727     jint off_lo = offset1;
1728     jint off_hi = offset1;
1729 
1730     bool found_immediate_dominator = false;
1731 
1732     // Scan for the top checks and collect range of offsets
1733     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1734       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1735           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1736         if (dom == this) return NULL; // dead loop
1737         // See if this is a range check
1738         Node* index2;
1739         Node* range2;
1740         jint offset2;
1741         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1742         // See if this is a _matching_ range check, checking against
</pre>
</td>
<td>
<hr />
<pre>
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
<span class="line-modified"> 120   if (r-&gt;is_Loop()) return NULL;</span>
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
</pre>
<hr />
<pre>
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;


 241   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 242     if (phi-&gt;in(ii) == con1) {
 243       req_c++;
 244     }
 245     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 246     if (proj != NULL) {
<span class="line-modified"> 247       return NULL;</span>

 248     }
 249   }
 250 
 251   // If all the defs of the phi are the same constant, we already have the desired end state.
 252   // Skip the split that would create empty phi and region nodes.
 253   if((r-&gt;req() - req_c) == 1) {
 254     return NULL;
 255   }
 256 


















 257   Node *region_c = new RegionNode(req_c + 1);
 258   Node *phi_c    = con1;
 259   uint  len      = r-&gt;req();
 260   Node *region_x = new RegionNode(len - req_c);
 261   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 262   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 263     if (phi-&gt;in(i) == con1) {
 264       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );


 265     } else {
 266       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 267       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );


 268     }
 269   }








 270 
 271   // Register the new RegionNodes but do not transform them.  Cannot
 272   // transform until the entire Region/Phi conglomerate has been hacked
 273   // as a single huge transform.
 274   igvn-&gt;register_new_node_with_optimizer( region_c );
 275   igvn-&gt;register_new_node_with_optimizer( region_x );
 276   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 277   // about to get one.  If this only use goes away, then phi_x will look dead.
 278   // However, he will be picking up some more uses down below.
 279   Node *hook = new Node(4);
 280   hook-&gt;init_req(0, phi_x);
 281   hook-&gt;init_req(1, phi_c);
 282   phi_x = phase-&gt;transform( phi_x );
 283 
 284   // Make the compare
 285   Node *cmp_c = phase-&gt;makecon(t);
 286   Node *cmp_x = cmp-&gt;clone();
 287   cmp_x-&gt;set_req(1,phi_x);
 288   cmp_x-&gt;set_req(2,con2);
 289   cmp_x = phase-&gt;transform(cmp_x);
</pre>
<hr />
<pre>
 291   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 292   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 293   // Make the IfNode
 294   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 295   iff_c-&gt;set_req(0, region_c);
 296   iff_c-&gt;set_req(1, b_c);
 297   igvn-&gt;set_type_bottom(iff_c);
 298   igvn-&gt;_worklist.push(iff_c);
 299   hook-&gt;init_req(2, iff_c);
 300 
 301   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 302   iff_x-&gt;set_req(0, region_x);
 303   iff_x-&gt;set_req(1, b_x);
 304   igvn-&gt;set_type_bottom(iff_x);
 305   igvn-&gt;_worklist.push(iff_x);
 306   hook-&gt;init_req(3, iff_x);
 307 
 308   // Make the true/false arms
 309   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 310   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));






 311   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 312   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));






 313 
 314   // Merge the TRUE paths
 315   Node *region_s = new RegionNode(3);
 316   igvn-&gt;_worklist.push(region_s);
 317   region_s-&gt;init_req(1, iff_c_t);
 318   region_s-&gt;init_req(2, iff_x_t);
 319   igvn-&gt;register_new_node_with_optimizer( region_s );
 320 
 321   // Merge the FALSE paths
 322   Node *region_f = new RegionNode(3);
 323   igvn-&gt;_worklist.push(region_f);
 324   region_f-&gt;init_req(1, iff_c_f);
 325   region_f-&gt;init_req(2, iff_x_f);
 326   igvn-&gt;register_new_node_with_optimizer( region_f );
 327 
 328   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 329   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 330   cmp-&gt;set_req(2,NULL);
 331   // Check for all uses of the Phi and give them a new home.
 332   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
</pre>
<hr />
<pre>
 571   if( dom-&gt;is_Root() )
 572     return NULL;
 573 
 574   // Else hit a Region.  Check for a loop header
 575   if( dom-&gt;is_Loop() )
 576     return dom-&gt;in(1);          // Skip up thru loops
 577 
 578   // Check for small diamonds
 579   Node *din1, *din2, *din3, *din4;
 580   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 581       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 582       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 583       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 584       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 585     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 586         (din3 = din3-&gt;in(0)) )
 587       din3 = din3-&gt;in(0);
 588     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 589         (din4 = din4-&gt;in(0)) )
 590       din4 = din4-&gt;in(0);
<span class="line-modified"> 591     if (din3 != NULL &amp;&amp; din3 == din4 &amp;&amp; din3-&gt;is_If()) // Regions not degraded to a copy</span>
 592       return din3;              // Skip around diamonds
 593   }
 594 
 595   // Give up the search at true merges
 596   return NULL;                  // Dead loop?  Or hit root?
 597 }
 598 
 599 
 600 //------------------------------filtered_int_type--------------------------------
 601 // Return a possibly more restrictive type for val based on condition control flow for an if
<span class="line-modified"> 602 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {</span>
 603   assert(if_proj &amp;&amp;
 604          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 605   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 606     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 607     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 608       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 609       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 610         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 611         if (cmp-&gt;in(1) == val) {
 612           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 613           if (cmp2_t != NULL) {
 614             jint lo = cmp2_t-&gt;_lo;
 615             jint hi = cmp2_t-&gt;_hi;
 616             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 617             switch (msk) {
<span class="line-modified"> 618             case BoolTest::ne: {</span>
<span class="line-added"> 619               // If val is compared to its lower or upper bound, we can narrow the type</span>
<span class="line-added"> 620               const TypeInt* val_t = gvn-&gt;type(val)-&gt;isa_int();</span>
<span class="line-added"> 621               if (val_t != NULL &amp;&amp; !val_t-&gt;singleton() &amp;&amp; cmp2_t-&gt;is_con()) {</span>
<span class="line-added"> 622                 if (val_t-&gt;_lo == lo) {</span>
<span class="line-added"> 623                   return TypeInt::make(val_t-&gt;_lo + 1, val_t-&gt;_hi, val_t-&gt;_widen);</span>
<span class="line-added"> 624                 } else if (val_t-&gt;_hi == hi) {</span>
<span class="line-added"> 625                   return TypeInt::make(val_t-&gt;_lo, val_t-&gt;_hi - 1, val_t-&gt;_widen);</span>
<span class="line-added"> 626                 }</span>
<span class="line-added"> 627               }</span>
 628               // Can&#39;t refine type
 629               return NULL;
<span class="line-added"> 630             }</span>
 631             case BoolTest::eq:
 632               return cmp2_t;
 633             case BoolTest::lt:
 634               lo = TypeInt::INT-&gt;_lo;
 635               if (hi - 1 &lt; hi) {
 636                 hi = hi - 1;
 637               }
 638               break;
 639             case BoolTest::le:
 640               lo = TypeInt::INT-&gt;_lo;
 641               break;
 642             case BoolTest::gt:
 643               if (lo + 1 &gt; lo) {
 644                 lo = lo + 1;
 645               }
 646               hi = TypeInt::INT-&gt;_hi;
 647               break;
 648             case BoolTest::ge:
 649               // lo unchanged
 650               hi = TypeInt::INT-&gt;_hi;
</pre>
<hr />
<pre>
 684 //
 685 // Or given an if testing (CmpI n v) check for a dominating if that is
 686 // testing (CmpI n v2), both having one projection leading to an
 687 // uncommon trap. Allow Another independent guard in between to cover
 688 // an explicit range check:
 689 // if (index &lt; 0 || index &gt;= array.length) {
 690 // which may need a null check to guard the LoadRange
 691 //
 692 //                   If
 693 //                  / \
 694 //                 /   \
 695 //                /     \
 696 //              If      unc
 697 //              /\
 698 //             /  \
 699 //            /    \
 700 //           /      unc
 701 //
 702 
 703 // Is the comparison for this If suitable for folding?
<span class="line-modified"> 704 bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {</span>
 705   return in(1) != NULL &amp;&amp;
 706     in(1)-&gt;is_Bool() &amp;&amp;
 707     in(1)-&gt;in(1) != NULL &amp;&amp;
 708     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 709     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 710     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 711     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
<span class="line-modified"> 712      in(1)-&gt;as_Bool()-&gt;_test.is_greater() ||</span>
<span class="line-added"> 713      (fold_ne &amp;&amp; in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne));</span>
 714 }
 715 
 716 // Is a dominating control suitable for folding with this if?
 717 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 718   return ctrl != NULL &amp;&amp;
 719     ctrl-&gt;is_Proj() &amp;&amp;
 720     ctrl-&gt;in(0) != NULL &amp;&amp;
 721     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 722     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
<span class="line-modified"> 723     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn, true) &amp;&amp;</span>
 724     // Must compare same value
 725     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 726     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 727 }
 728 
 729 // Do this If and the dominating If share a region?
 730 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 731   ProjNode* otherproj = proj-&gt;other_if_proj();
 732   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 733   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 734   success = NULL;
 735   fail = NULL;
 736 
 737   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 738     for (int i = 0; i &lt; 2; i++) {
 739       ProjNode* proj = proj_out(i);
 740       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 741         success = proj;
 742       } else if (fail == NULL) {
 743         fail = proj;
</pre>
<hr />
<pre>
 865   //        this_bool = x {&lt;,&lt;=} b
 866   //                       / \
 867   //  fail = {True,False} /   \ success = {False,True}
 868   //                     /
 869   //
 870   // (Second test guaranteed canonicalized, first one may not have
 871   // been canonicalized yet)
 872   //
 873   // into:
 874   //
 875   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 876   //                       / \
 877   //                 fail /   \ success
 878   //                     /
 879   //
 880 
 881   // Figure out which of the two tests sets the upper bound and which
 882   // sets the lower bound if any.
 883   Node* adjusted_lim = NULL;
 884   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
<span class="line-modified"> 885       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {</span>
 886     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 887            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 888     // this test was canonicalized
 889     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 890 
 891     // this_bool = &lt;
 892     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 893     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 894     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 895     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 896     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 897     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 898     // this_bool = &lt;=
 899     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 900     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 901     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 902     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 903     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 904     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 905     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 906     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 907 
 908     if (hi_test == BoolTest::lt) {
 909       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 910         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 911       }
 912     } else {
 913       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 914       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 915         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 916         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 917         cond = BoolTest::lt;
 918       } else {
 919         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 920         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 921         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 922         cond = BoolTest::lt;
 923       }
 924     }
 925   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
<span class="line-modified"> 926              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {</span>
 927 
 928     // this_bool = &lt;
 929     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 930     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 931     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 932     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 933     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 934     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 935     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 936     // this_bool = &lt;=
 937     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 938     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 939     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 940     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 941     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 942     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 943     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 944 
 945     swap(lo, hi);
 946     swap(lo_type, hi_type);
</pre>
<hr />
<pre>
 957       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 958         cond = BoolTest::ge;
 959       } else {
 960         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 961         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 962         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 963         cond = BoolTest::ge;
 964       }
 965     } else if (lo_test == BoolTest::le) {
 966       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 967         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 968         cond = BoolTest::ge;
 969       } else {
 970         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 971         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 972         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 973         cond = BoolTest::ge;
 974       }
 975     }
 976   } else {
<span class="line-modified"> 977     const TypeInt* failtype = filtered_int_type(igvn, n, proj);</span>
 978     if (failtype != NULL) {
 979       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
 980       if (type2 != NULL) {
 981         failtype = failtype-&gt;join(type2)-&gt;is_int();
 982         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
 983           // previous if determines the result of this if so
 984           // replace Bool with constant
 985           igvn-&gt;_worklist.push(in(1));
 986           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
 987           return true;
 988         }
 989       }
 990     }
 991     lo = NULL;
 992     hi = NULL;
 993   }
 994 
 995   if (lo &amp;&amp; hi) {
 996     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
 997     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
</pre>
<hr />
<pre>
1233   Node* c = otherproj-&gt;clone();
1234 
1235   c = igvn-&gt;transform(c);
1236   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1237   new_unc-&gt;set_req(0, c);
1238   new_unc = igvn-&gt;transform(new_unc);
1239   call_proj-&gt;set_req(0, new_unc);
1240   call_proj = igvn-&gt;transform(call_proj);
1241   halt-&gt;set_req(0, call_proj);
1242   halt = igvn-&gt;transform(halt);
1243 
1244   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1245   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1246 }
1247 
1248 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1249   if (Opcode() != Op_If) return NULL;
1250 
1251   if (cmpi_folds(igvn)) {
1252     Node* ctrl = in(0);
<span class="line-modified">1253     if (is_ctrl_folds(ctrl, igvn) &amp;&amp; ctrl-&gt;outcnt() == 1) {</span>

1254       // A integer comparison immediately dominated by another integer
1255       // comparison
1256       ProjNode* success = NULL;
1257       ProjNode* fail = NULL;
1258       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1259       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1260           // Next call modifies graph so must be last
1261           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1262         return this;
1263       }
1264       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1265           // Next call modifies graph so must be last
1266           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1267         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1268       }
1269       return NULL;
1270     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1271                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1272       ProjNode* success = NULL;
1273       ProjNode* fail = NULL;
</pre>
<hr />
<pre>
1385   // Try to split the IF
1386   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1387   Node *s = split_if(this, igvn);
1388   if (s != NULL)  return s;
1389 
1390   return NodeSentinel;
1391 }
1392 
1393 //------------------------------Ideal------------------------------------------
1394 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1395 // control copies
1396 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1397   Node* res = Ideal_common(phase, can_reshape);
1398   if (res != NodeSentinel) {
1399     return res;
1400   }
1401 
1402   // Check for people making a useless boolean: things like
1403   // if( (x &lt; y ? true : false) ) { ... }
1404   // Replace with if( x &lt; y ) { ... }
<span class="line-modified">1405   Node* bol2 = remove_useless_bool(this, phase);</span>
<span class="line-modified">1406   if (bol2) return bol2;</span>
1407 
1408   if (in(0) == NULL) return NULL;     // Dead loop?
1409 
<span class="line-modified">1410   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
1411   Node* result = fold_compares(igvn);
1412   if (result != NULL) {
1413     return result;
1414   }
1415 
1416   // Scan for an equivalent test
<span class="line-modified">1417   int dist = 4;               // Cutoff limit for search</span>
<span class="line-modified">1418   if (is_If() &amp;&amp; in(1)-&gt;is_Bool()) {</span>
<span class="line-modified">1419     Node* cmp = in(1)-&gt;in(1);</span>
<span class="line-modified">1420     if (cmp-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-modified">1421         cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead</span>
<span class="line-modified">1422         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>

1423       dist = 64;              // Limit for null-pointer scans


1424     }


1425   }
1426 
1427   Node* prev_dom = search_identical(dist);
1428 
<span class="line-modified">1429   if (prev_dom != NULL) {</span>
<span class="line-modified">1430     // Replace dominated IfNode</span>
<span class="line-added">1431     return dominated_by(prev_dom, igvn);</span>
1432   }
1433 
<span class="line-modified">1434   return simple_subsuming(igvn);</span>

1435 }
1436 
1437 //------------------------------dominated_by-----------------------------------
1438 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1439 #ifndef PRODUCT
1440   if (TraceIterativeGVN) {
1441     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1442   }






1443 #endif
1444 
1445   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1446   Node *idom = in(0);
1447   // Need opcode to decide which way &#39;this&#39; test goes
1448   int prev_op = prev_dom-&gt;Opcode();
1449   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1450 
1451   // Loop predicates may have depending checks which should not
1452   // be skipped. For example, range check predicate has two checks
1453   // for lower and upper bounds.
1454   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1455   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1456       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1457     prev_dom = idom;
1458   }
1459 
1460   // Now walk the current IfNode&#39;s projections.
1461   // Loop ends when &#39;this&#39; has no more uses.
1462   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
</pre>
<hr />
<pre>
1511     dist--;
1512     prev_dom = dom;
1513     dom = up_one_dom(dom);
1514     if (!dom) return NULL;
1515   }
1516 
1517   // Check that we did not follow a loop back to ourselves
1518   if (this == dom) {
1519     return NULL;
1520   }
1521 
1522 #ifndef PRODUCT
1523   if (dist &gt; 2) { // Add to count of NULL checks elided
1524     explicit_null_checks_elided++;
1525   }
1526 #endif
1527 
1528   return prev_dom;
1529 }
1530 
<span class="line-added">1531 </span>
<span class="line-added">1532 static int subsuming_bool_test_encode(Node*);</span>
<span class="line-added">1533 </span>
<span class="line-added">1534 // Check if dominating test is subsuming &#39;this&#39; one.</span>
<span class="line-added">1535 //</span>
<span class="line-added">1536 //              cmp</span>
<span class="line-added">1537 //              / \</span>
<span class="line-added">1538 //     (r1)  bool  \</span>
<span class="line-added">1539 //            /    bool (r2)</span>
<span class="line-added">1540 //    (dom) if       \</span>
<span class="line-added">1541 //            \       )</span>
<span class="line-added">1542 //    (pre)  if[TF]  /</span>
<span class="line-added">1543 //               \  /</span>
<span class="line-added">1544 //                if (this)</span>
<span class="line-added">1545 //   \r1</span>
<span class="line-added">1546 //  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF</span>
<span class="line-added">1547 //  eq    t    f    f    t    f    -    -    f    f    -    -    f</span>
<span class="line-added">1548 //  ne    f    t    t    f    t    -    -    t    t    -    -    t</span>
<span class="line-added">1549 //  lt    f    -    -    f    t    f    -    f    f    -    f    t</span>
<span class="line-added">1550 //  le    t    -    -    t    t    -    t    f    f    t    -    t</span>
<span class="line-added">1551 //  gt    f    -    -    f    f    -    f    t    t    f    -    f</span>
<span class="line-added">1552 //  ge    t    -    -    t    f    t    -    t    t    -    t    f</span>
<span class="line-added">1553 //</span>
<span class="line-added">1554 Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {</span>
<span class="line-added">1555   // Table encoding: N/A (na), True-branch (tb), False-branch (fb).</span>
<span class="line-added">1556   static enum { na, tb, fb } s_short_circuit_map[6][12] = {</span>
<span class="line-added">1557   /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/</span>
<span class="line-added">1558   /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },</span>
<span class="line-added">1559   /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },</span>
<span class="line-added">1560   /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },</span>
<span class="line-added">1561   /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },</span>
<span class="line-added">1562   /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },</span>
<span class="line-added">1563   /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};</span>
<span class="line-added">1564 </span>
<span class="line-added">1565   Node* pre = in(0);</span>
<span class="line-added">1566   if (!pre-&gt;is_IfTrue() &amp;&amp; !pre-&gt;is_IfFalse()) {</span>
<span class="line-added">1567     return NULL;</span>
<span class="line-added">1568   }</span>
<span class="line-added">1569   Node* dom = pre-&gt;in(0);</span>
<span class="line-added">1570   if (!dom-&gt;is_If()) {</span>
<span class="line-added">1571     return NULL;</span>
<span class="line-added">1572   }</span>
<span class="line-added">1573   Node* bol = in(1);</span>
<span class="line-added">1574   if (!bol-&gt;is_Bool()) {</span>
<span class="line-added">1575     return NULL;</span>
<span class="line-added">1576   }</span>
<span class="line-added">1577   Node* cmp = in(1)-&gt;in(1);</span>
<span class="line-added">1578   if (!cmp-&gt;is_Cmp()) {</span>
<span class="line-added">1579     return NULL;</span>
<span class="line-added">1580   }</span>
<span class="line-added">1581 </span>
<span class="line-added">1582   if (!dom-&gt;in(1)-&gt;is_Bool()) {</span>
<span class="line-added">1583     return NULL;</span>
<span class="line-added">1584   }</span>
<span class="line-added">1585   if (dom-&gt;in(1)-&gt;in(1) != cmp) {  // Not same cond?</span>
<span class="line-added">1586     return NULL;</span>
<span class="line-added">1587   }</span>
<span class="line-added">1588 </span>
<span class="line-added">1589   int drel = subsuming_bool_test_encode(dom-&gt;in(1));</span>
<span class="line-added">1590   int trel = subsuming_bool_test_encode(bol);</span>
<span class="line-added">1591   int bout = pre-&gt;is_IfFalse() ? 1 : 0;</span>
<span class="line-added">1592 </span>
<span class="line-added">1593   if (drel &lt; 0 || trel &lt; 0) {</span>
<span class="line-added">1594     return NULL;</span>
<span class="line-added">1595   }</span>
<span class="line-added">1596   int br = s_short_circuit_map[trel][2*drel+bout];</span>
<span class="line-added">1597   if (br == na) {</span>
<span class="line-added">1598     return NULL;</span>
<span class="line-added">1599   }</span>
<span class="line-added">1600 #ifndef PRODUCT</span>
<span class="line-added">1601   if (TraceIterativeGVN) {</span>
<span class="line-added">1602     tty-&gt;print(&quot;   Subsumed IfNode: &quot;); dump();</span>
<span class="line-added">1603   }</span>
<span class="line-added">1604 #endif</span>
<span class="line-added">1605   // Replace condition with constant True(1)/False(0).</span>
<span class="line-added">1606   set_req(1, igvn-&gt;intcon(br == tb ? 1 : 0));</span>
<span class="line-added">1607 </span>
<span class="line-added">1608   if (bol-&gt;outcnt() == 0) {</span>
<span class="line-added">1609     igvn-&gt;remove_dead_node(bol);    // Kill the BoolNode.</span>
<span class="line-added">1610   }</span>
<span class="line-added">1611   return this;</span>
<span class="line-added">1612 }</span>
<span class="line-added">1613 </span>
<span class="line-added">1614 // Map BoolTest to local table encoding. The BoolTest (e)numerals</span>
<span class="line-added">1615 //   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }</span>
<span class="line-added">1616 // are mapped to table indices, while the remaining (e)numerals in BoolTest</span>
<span class="line-added">1617 //   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }</span>
<span class="line-added">1618 // are ignored (these are not modeled in the table).</span>
<span class="line-added">1619 //</span>
<span class="line-added">1620 static int subsuming_bool_test_encode(Node* node) {</span>
<span class="line-added">1621   precond(node-&gt;is_Bool());</span>
<span class="line-added">1622   BoolTest::mask x = node-&gt;as_Bool()-&gt;_test._test;</span>
<span class="line-added">1623   switch (x) {</span>
<span class="line-added">1624     case BoolTest::eq: return 0;</span>
<span class="line-added">1625     case BoolTest::ne: return 1;</span>
<span class="line-added">1626     case BoolTest::lt: return 2;</span>
<span class="line-added">1627     case BoolTest::le: return 3;</span>
<span class="line-added">1628     case BoolTest::gt: return 4;</span>
<span class="line-added">1629     case BoolTest::ge: return 5;</span>
<span class="line-added">1630     case BoolTest::overflow:</span>
<span class="line-added">1631     case BoolTest::no_overflow:</span>
<span class="line-added">1632     case BoolTest::never:</span>
<span class="line-added">1633     case BoolTest::illegal:</span>
<span class="line-added">1634     default:</span>
<span class="line-added">1635       return -1;</span>
<span class="line-added">1636   }</span>
<span class="line-added">1637 }</span>
<span class="line-added">1638 </span>
1639 //------------------------------Identity---------------------------------------
1640 // If the test is constant &amp; we match, then we are the input Control
1641 Node* IfProjNode::Identity(PhaseGVN* phase) {
1642   // Can only optimize if cannot go the other way
1643   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1644   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1645        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1646        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1647       (!phase-&gt;is_IterGVN() ||
1648        // During IGVN, first wait for the dead branch to be killed.
1649        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1650        // that doesn&#39;t go away because it still has uses and this branch of the
1651        // If) which breaks other optimizations. Node::has_special_unique_user()
1652        // will cause this node to be reprocessed once the dead branch is killed.
1653        in(0)-&gt;outcnt() == 1))) {
1654     // IfNode control
1655     return in(0)-&gt;in(0);
1656   }
1657   // no progress
1658   return this;
</pre>
<hr />
<pre>
1764 
1765   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1766   // Setup to scan up the CFG looking for a dominating test
1767   Node* prev_dom = this;
1768 
1769   // Check for range-check vs other kinds of tests
1770   Node* index1;
1771   Node* range1;
1772   jint offset1;
1773   int flip1 = is_range_check(range1, index1, offset1);
1774   if (flip1) {
1775     Node* dom = in(0);
1776     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1777     // so all checks we inspect post-dominate the top-most check we find.
1778     // If we are going to fail the current check and we reach the top check
1779     // then we are guaranteed to fail, so just start interpreting there.
1780     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1781     // checks.
1782 
1783     // The top 3 range checks seen
<span class="line-modified">1784     const int NRC = 3;</span>
1785     RangeCheck prev_checks[NRC];
1786     int nb_checks = 0;
1787 
1788     // Low and high offsets seen so far
1789     jint off_lo = offset1;
1790     jint off_hi = offset1;
1791 
1792     bool found_immediate_dominator = false;
1793 
1794     // Scan for the top checks and collect range of offsets
1795     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1796       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1797           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1798         if (dom == this) return NULL; // dead loop
1799         // See if this is a range check
1800         Node* index2;
1801         Node* range2;
1802         jint offset2;
1803         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1804         // See if this is a _matching_ range check, checking against
</pre>
</td>
</tr>
</table>
<center><a href="ifg.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
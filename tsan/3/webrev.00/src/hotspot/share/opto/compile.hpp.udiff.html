<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="convertnode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -50,13 +50,13 @@</span>
  class Bundle;
  class C2Compiler;
  class CallGenerator;
  class CloneMap;
  class ConnectionGraph;
<span class="udiff-line-added">+ class IdealGraphPrinter;</span>
  class InlineTree;
  class Int_Array;
<span class="udiff-line-removed">- class LoadBarrierNode;</span>
  class Matcher;
  class MachConstantNode;
  class MachConstantBaseNode;
  class MachNode;
  class MachOper;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,15 +91,15 @@</span>
  struct Final_Reshape_Counts;
  
  enum LoopOptsMode {
    LoopOptsDefault,
    LoopOptsNone,
<span class="udiff-line-added">+   LoopOptsMaxUnroll,</span>
    LoopOptsShenandoahExpand,
    LoopOptsShenandoahPostExpand,
    LoopOptsSkipSplitIf,
<span class="udiff-line-modified-removed">-   LoopOptsVerify,</span>
<span class="udiff-line-removed">-   LoopOptsLastRound</span>
<span class="udiff-line-modified-added">+   LoopOptsVerify</span>
  };
  
  typedef unsigned int node_idx_t;
  class NodeCloneInfo {
   private:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -407,17 +407,19 @@</span>
    bool                  _print_assembly;        // True if we should dump assembly code for this compilation
    bool                  _print_inlining;        // True if we should print inlining for this compilation
    bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
  #ifndef PRODUCT
    bool                  _trace_opto_output;
<span class="udiff-line-added">+   bool                  _print_ideal;</span>
    bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
  #endif
    bool                  _has_irreducible_loop;  // Found irreducible loops
    // JSR 292
    bool                  _has_method_handle_invokes; // True if this method has MethodHandle invokes.
    RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
    int                   _loop_opts_cnt;         // loop opts round
<span class="udiff-line-added">+   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry</span>
  
    // Compilation environment.
    Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
    void*                 _barrier_set_state;     // Potential GC barrier state for Compile
    ciEnv*                _env;                   // CI interface
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,11 +476,10 @@</span>
    // Type management
    Arena                 _Compile_types;         // Arena for all types
    Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
    Dict*                 _type_dict;             // Intern table
    CloneMap              _clone_map;             // used for recording history of cloned nodes
<span class="udiff-line-removed">-   void*                 _type_hwm;              // Last allocation (see Type::operator new/delete)</span>
    size_t                _type_last_size;        // Last allocation size (see Type::operator new/delete)
    ciMethod*             _last_tf_m;             // Cache for
    const TypeFunc*       _last_tf;               //  TypeFunc::make
    AliasType**           _alias_types;           // List of alias types seen so far.
    int                   _num_alias_types;       // Logical length of _alias_types
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,10 +511,12 @@</span>
  
     public:
      PrintInliningBuffer()
        : _cg(NULL) { _ss = new stringStream(); }
  
<span class="udiff-line-added">+     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }</span>
<span class="udiff-line-added">+ </span>
      stringStream* ss() const { return _ss; }
      CallGenerator* cg() const { return _cg; }
      void set_cg(CallGenerator* cg) { _cg = cg; }
    };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -531,10 +534,11 @@</span>
    // Remove the speculative part of types and clean up the graph
    void remove_speculative_types(PhaseIterGVN &amp;igvn);
  
    void* _replay_inline_data; // Pointer to data loaded from file
  
<span class="udiff-line-added">+   void print_inlining_stream_free();</span>
    void print_inlining_init();
    void print_inlining_reinit();
    void print_inlining_commit();
    void print_inlining_push();
    PrintInliningBuffer&amp; print_inlining_current();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -576,12 +580,10 @@</span>
    void dump_inline_data(outputStream* out);
  
   private:
    // Matching, CFG layout, allocation, code generation
    PhaseCFG*             _cfg;                   // Results of CFG finding
<span class="udiff-line-removed">-   bool                  _select_24_bit_instr;   // We selected an instruction with a 24-bit result</span>
<span class="udiff-line-removed">-   bool                  _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results</span>
    int                   _java_calls;            // Number of java calls in the method
    int                   _inner_loops;           // Number of inner loops in the method
    Matcher*              _matcher;               // Engine to map ideal to machine instructions
    PhaseRegAlloc*        _regalloc;              // Results of register allocation.
    int                   _frame_slots;           // Size of total frame in stack slots
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -655,10 +657,11 @@</span>
    void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
    int               inlining_incrementally() const { return _inlining_incrementally; }
    void          set_do_cleanup(bool z)          { _do_cleanup = z; }
    int               do_cleanup() const          { return _do_cleanup; }
    void          set_major_progress()            { _major_progress++; }
<span class="udiff-line-added">+   void          restore_major_progress(int progress) { _major_progress += progress; }</span>
    void        clear_major_progress()            { _major_progress = 0; }
    int               max_inline_size() const     { return _max_inline_size; }
    void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
    int               freq_inline_size() const    { return _freq_inline_size; }
    void          set_max_inline_size(int n)      { _max_inline_size = n; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,18 +715,21 @@</span>
    void          set_rtm_state(RTMState s)        { _rtm_state = s; }
    bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
    bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
    uint              max_node_limit() const       { return (uint)_max_node_limit; }
    void          set_max_node_limit(uint n)       { _max_node_limit = n; }
<span class="udiff-line-added">+   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }</span>
<span class="udiff-line-added">+   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }</span>
  
    // check the CompilerOracle for special behaviours for this compile
    bool          method_has_option(const char * option) {
      return method() != NULL &amp;&amp; method()-&gt;has_option(option);
    }
  
  #ifndef PRODUCT
    bool          trace_opto_output() const       { return _trace_opto_output; }
<span class="udiff-line-added">+   bool          print_ideal() const             { return _print_ideal; }</span>
    bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
    void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
    int _in_dump_cnt;  // Required for dumping ir nodes.
  #endif
    bool              has_irreducible_loop() const { return _has_irreducible_loop; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -742,24 +748,37 @@</span>
      }
  #endif
      C-&gt;_latest_stage_start_counter.stamp();
    }
  
<span class="udiff-line-modified-removed">-   void print_method(CompilerPhaseType cpt, int level = 1) {</span>
<span class="udiff-line-modified-added">+   bool should_print(int level = 1) {</span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+     return (_printer &amp;&amp; _printer-&gt;should_print(level));</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {</span>
      EventCompilerPhase event;
      if (event.should_commit()) {
        event.set_starttime(C-&gt;_latest_stage_start_counter);
        event.set_phase((u1) cpt);
        event.set_compileId(C-&gt;_compile_id);
        event.set_phaseLevel(level);
        event.commit();
      }
  
<span class="udiff-line-removed">- </span>
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {</span>
<span class="udiff-line-modified-removed">-       _printer-&gt;print_method(CompilerPhaseTypeHelper::to_string(cpt), level);</span>
<span class="udiff-line-modified-added">+     if (should_print(level)) {</span>
<span class="udiff-line-modified-added">+       char output[1024];</span>
<span class="udiff-line-added">+       if (idx != 0) {</span>
<span class="udiff-line-added">+         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _printer-&gt;print_method(output, level);</span>
      }
  #endif
      C-&gt;_latest_stage_start_counter.stamp();
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -898,13 +917,11 @@</span>
                                                    _recent_alloc_obj = obj;
                                             }
    void         record_dead_node(uint idx)  { if (_dead_node_list.test_set(idx)) return;
                                               _dead_node_count++;
                                             }
<span class="udiff-line-modified-removed">-   bool         is_dead_node(uint idx)      { return _dead_node_list.test(idx) != 0; }</span>
<span class="udiff-line-removed">-   uint         dead_node_count()           { return _dead_node_count; }</span>
<span class="udiff-line-removed">-   void         reset_dead_node_list()      { _dead_node_list.Reset();</span>
<span class="udiff-line-modified-added">+   void         reset_dead_node_list()      { _dead_node_list.reset();</span>
                                               _dead_node_count = 0;
                                             }
    uint          live_nodes() const         {
      int  val = _unique - _dead_node_count;
      assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -957,18 +974,16 @@</span>
    void grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by);
  
    // Type management
    Arena*            type_arena()                { return _type_arena; }
    Dict*             type_dict()                 { return _type_dict; }
<span class="udiff-line-removed">-   void*             type_hwm()                  { return _type_hwm; }</span>
    size_t            type_last_size()            { return _type_last_size; }
    int               num_alias_types()           { return _num_alias_types; }
  
    void          init_type_arena()                       { _type_arena = &amp;_Compile_types; }
    void          set_type_arena(Arena* a)                { _type_arena = a; }
    void          set_type_dict(Dict* d)                  { _type_dict = d; }
<span class="udiff-line-removed">-   void          set_type_hwm(void* p)                   { _type_hwm = p; }</span>
    void          set_type_last_size(size_t sz)           { _type_last_size = sz; }
  
    const TypeFunc* last_tf(ciMethod* m) {
      return (m == _last_tf_m) ? _last_tf : NULL;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1103,12 +1118,10 @@</span>
    bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
    void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
  
    // Matching, CFG layout, allocation, code generation
    PhaseCFG*         cfg()                       { return _cfg; }
<span class="udiff-line-removed">-   bool              select_24_bit_instr() const { return _select_24_bit_instr; }</span>
<span class="udiff-line-removed">-   bool              in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }</span>
    bool              has_java_calls() const      { return _java_calls &gt; 0; }
    int               java_calls() const          { return _java_calls; }
    int               inner_loops() const         { return _inner_loops; }
    Matcher*          matcher()                   { return _matcher; }
    PhaseRegAlloc*    regalloc()                  { return _regalloc; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1136,16 +1149,10 @@</span>
    void          set_matcher(Matcher* m)                 { _matcher = m; }
  //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
    void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
    void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
  
<span class="udiff-line-removed">-   // Remember if this compilation changes hardware mode to 24-bit precision</span>
<span class="udiff-line-removed">-   void set_24_bit_selection_and_mode(bool selection, bool mode) {</span>
<span class="udiff-line-removed">-     _select_24_bit_instr = selection;</span>
<span class="udiff-line-removed">-     _in_24_bit_fp_mode   = mode;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    void  set_java_calls(int z) { _java_calls  = z; }
    void set_inner_loops(int z) { _inner_loops = z; }
  
    // Instruction bits passed off to the VM
    int               code_size()                 { return _method_size; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1169,15 +1176,11 @@</span>
    uint              scratch_emit_size(const Node* n);
    void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }
    bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }
  
    enum ScratchBufferBlob {
<span class="udiff-line-removed">- #if defined(PPC64)</span>
      MAX_inst_size       = 2048,
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     MAX_inst_size       = 1024,</span>
<span class="udiff-line-removed">- #endif</span>
      MAX_locs_size       = 128, // number of relocInfo elements
      MAX_const_size      = 128,
      MAX_stubs_size      = 128
    };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1248,18 +1251,34 @@</span>
                                       ObjectValue* sv );
  
    // Process an OopMap Element while emitting nodes
    void Process_OopMap_Node(MachNode *mach, int code_offset);
  
<span class="udiff-line-added">+   class BufferSizingData {</span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+     int _stub;</span>
<span class="udiff-line-added">+     int _code;</span>
<span class="udiff-line-added">+     int _const;</span>
<span class="udiff-line-added">+     int _reloc;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       BufferSizingData() :</span>
<span class="udiff-line-added">+       _stub(0),</span>
<span class="udiff-line-added">+       _code(0),</span>
<span class="udiff-line-added">+       _const(0),</span>
<span class="udiff-line-added">+       _reloc(0)</span>
<span class="udiff-line-added">+       { };</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
    // Initialize code buffer
<span class="udiff-line-modified-removed">-   CodeBuffer* init_buffer(uint* blk_starts);</span>
<span class="udiff-line-modified-added">+   void        estimate_buffer_size(int&amp; const_req);</span>
<span class="udiff-line-added">+   CodeBuffer* init_buffer(BufferSizingData&amp; buf_sizes);</span>
  
    // Write out basic block data to code buffer
    void fill_buffer(CodeBuffer* cb, uint* blk_starts);
  
    // Determine which variable sized branches can be shortened
<span class="udiff-line-modified-removed">-   void shorten_branches(uint* blk_starts, int&amp; code_size, int&amp; reloc_size, int&amp; stub_size);</span>
<span class="udiff-line-modified-added">+   void shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes);</span>
  
    // Compute the size of first NumberOfLoopInstrToAlign instructions
    // at the head of a loop.
    void compute_loop_first_inst_sizes();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1346,11 +1365,17 @@</span>
  
    // End-of-run dumps.
    static void print_statistics() PRODUCT_RETURN;
  
    // Dump formatted assembly
<span class="udiff-line-modified-removed">-   void dump_asm(int *pcs = NULL, uint pc_limit = 0) PRODUCT_RETURN;</span>
<span class="udiff-line-modified-added">+ #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-added">+   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);</span>
<span class="udiff-line-added">+   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }</span>
<span class="udiff-line-added">+   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }</span>
<span class="udiff-line-added">+ #endif</span>
    void dump_pc(int *pcs, int pc_limit, Node *n);
  
    // Verify ADLC assumptions during startup
    static void adlc_verification() PRODUCT_RETURN;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1373,9 +1398,27 @@</span>
  
    // supporting clone_map
    CloneMap&amp;     clone_map();
    void          set_clone_map(Dict* d);
  
<span class="udiff-line-modified-removed">-   bool is_compiling_clinit_for(ciKlass* k);</span>
<span class="udiff-line-modified-added">+   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);</span>
<span class="udiff-line-added">+   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);</span>
<span class="udiff-line-added">+   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef IA32</span>
<span class="udiff-line-added">+  private:</span>
<span class="udiff-line-added">+   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result</span>
<span class="udiff-line-added">+   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Remember if this compilation changes hardware mode to 24-bit precision.</span>
<span class="udiff-line-added">+   void set_24_bit_selection_and_mode(bool selection, bool mode) {</span>
<span class="udiff-line-added">+     _select_24_bit_instr = selection;</span>
<span class="udiff-line-added">+     _in_24_bit_fp_mode   = mode;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+  public:</span>
<span class="udiff-line-added">+   bool select_24_bit_instr() const { return _select_24_bit_instr; }</span>
<span class="udiff-line-added">+   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }</span>
<span class="udiff-line-added">+ #endif // IA32</span>
  };
  
  #endif // SHARE_OPTO_COMPILE_HPP
</pre>
<center><a href="compile.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="convertnode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
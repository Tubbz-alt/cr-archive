<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,10 ***</span>
<span class="line-new-header">--- 22,12 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;opto/machnode.hpp&quot;
  #include &quot;opto/regalloc.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  
  //=============================================================================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,11 ***</span>
    return 5;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! uint MachOper::cmp( const MachOper &amp;oper ) const {</span>
    ShouldNotCallThis();
    return opcode() == oper.opcode();
  }
  
  //------------------------------hash-------------------------------------------
<span class="line-new-header">--- 93,11 ---</span>
    return 5;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! bool MachOper::cmp( const MachOper &amp;oper ) const {</span>
    ShouldNotCallThis();
    return opcode() == oper.opcode();
  }
  
  //------------------------------hash-------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,11 ***</span>
    return _block_num;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! uint labelOper::cmp( const MachOper &amp;oper ) const {</span>
    return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
  }
  
  //------------------------------hash-------------------------------------------
  // Print any per-operand special info
<span class="line-new-header">--- 106,11 ---</span>
    return _block_num;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! bool labelOper::cmp( const MachOper &amp;oper ) const {</span>
    return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
  }
  
  //------------------------------hash-------------------------------------------
  // Print any per-operand special info
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,11 ***</span>
    return (uint)_method;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! uint methodOper::cmp( const MachOper &amp;oper ) const {</span>
    return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
  }
  
  
  //=============================================================================
<span class="line-new-header">--- 118,11 ---</span>
    return (uint)_method;
  }
  
  //------------------------------cmp--------------------------------------------
  // Print any per-operand special info
<span class="line-modified">! bool methodOper::cmp( const MachOper &amp;oper ) const {</span>
    return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
  }
  
  
  //=============================================================================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,19 ***</span>
      sum += _opnds[i]-&gt;hash();
    return sum+Node::hash();
  }
  
  //-----------------------------cmp---------------------------------------------
<span class="line-modified">! uint MachNode::cmp( const Node &amp;node ) const {</span>
    MachNode&amp; n = *((Node&amp;)node).as_Mach();
    uint no = num_opnds();
<span class="line-modified">!   if( no != n.num_opnds() ) return 0;</span>
<span class="line-modified">!   if( rule() != n.rule() ) return 0;</span>
    for( uint i=0; i&lt;no; i++ )    // All operands must match
      if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
<span class="line-modified">!       return 0;                 // mis-matched operands</span>
<span class="line-modified">!   return 1;                     // match</span>
  }
  
  // Return an equivalent instruction using memory for cisc_operand position
  MachNode *MachNode::cisc_version(int offset) {
    ShouldNotCallThis();
<span class="line-new-header">--- 167,19 ---</span>
      sum += _opnds[i]-&gt;hash();
    return sum+Node::hash();
  }
  
  //-----------------------------cmp---------------------------------------------
<span class="line-modified">! bool MachNode::cmp( const Node &amp;node ) const {</span>
    MachNode&amp; n = *((Node&amp;)node).as_Mach();
    uint no = num_opnds();
<span class="line-modified">!   if( no != n.num_opnds() ) return false;</span>
<span class="line-modified">!   if( rule() != n.rule() ) return false;</span>
    for( uint i=0; i&lt;no; i++ )    // All operands must match
      if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
<span class="line-modified">!       return false;             // mis-matched operands</span>
<span class="line-modified">!   return true;                  // match</span>
  }
  
  // Return an equivalent instruction using memory for cisc_operand position
  MachNode *MachNode::cisc_version(int offset) {
    ShouldNotCallThis();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,23 ***</span>
      // NULL base, any offset means any pointer whatever
      if (offset == Type::OffsetBot) {
        return TypePtr::BOTTOM;
      }
      // %%% make offset be intptr_t
<span class="line-modified">!     assert(!Universe::heap()-&gt;is_in_reserved(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);</span>
      return TypeRawPtr::BOTTOM;
    }
  
    // base of -1 with no particular offset means all of memory
    if (base == NodeSentinel)  return TypePtr::BOTTOM;
  
    const Type* t = base-&gt;bottom_type();
<span class="line-modified">!   if (t-&gt;isa_narrowoop() &amp;&amp; Universe::narrow_oop_shift() == 0) {</span>
      // 32-bit unscaled narrow oop can be the base of any address expression
      t = t-&gt;make_ptr();
    }
<span class="line-modified">!   if (t-&gt;isa_narrowklass() &amp;&amp; Universe::narrow_klass_shift() == 0) {</span>
      // 32-bit unscaled narrow oop can be the base of any address expression
      t = t-&gt;make_ptr();
    }
    if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
      // We cannot assert that the offset does not look oop-ish here.
<span class="line-new-header">--- 346,23 ---</span>
      // NULL base, any offset means any pointer whatever
      if (offset == Type::OffsetBot) {
        return TypePtr::BOTTOM;
      }
      // %%% make offset be intptr_t
<span class="line-modified">!     assert(!Universe::heap()-&gt;is_in(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);</span>
      return TypeRawPtr::BOTTOM;
    }
  
    // base of -1 with no particular offset means all of memory
    if (base == NodeSentinel)  return TypePtr::BOTTOM;
  
    const Type* t = base-&gt;bottom_type();
<span class="line-modified">!   if (t-&gt;isa_narrowoop() &amp;&amp; CompressedOops::shift() == 0) {</span>
      // 32-bit unscaled narrow oop can be the base of any address expression
      t = t-&gt;make_ptr();
    }
<span class="line-modified">!   if (t-&gt;isa_narrowklass() &amp;&amp; CompressedKlassPointers::shift() == 0) {</span>
      // 32-bit unscaled narrow oop can be the base of any address expression
      t = t-&gt;make_ptr();
    }
    if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
      // We cannot assert that the offset does not look oop-ish here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,14 ***</span>
    return tp-&gt;add_offset(offset);
  }
  
  
  //-----------------------------operand_index---------------------------------
<span class="line-modified">! int MachNode::operand_index( uint operand ) const {</span>
<span class="line-modified">!   if( operand &lt; 1 )  return -1;</span>
    assert(operand &lt; num_opnds(), &quot;oob&quot;);
<span class="line-modified">!   if( _opnds[operand]-&gt;num_edges() == 0 )  return -1;</span>
  
    uint skipped   = oper_input_base(); // Sum of leaves skipped so far
    for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
      uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
      skipped += num_edges;
<span class="line-new-header">--- 385,14 ---</span>
    return tp-&gt;add_offset(offset);
  }
  
  
  //-----------------------------operand_index---------------------------------
<span class="line-modified">! int MachNode::operand_index(uint operand) const {</span>
<span class="line-modified">!   if (operand &lt; 1)  return -1;</span>
    assert(operand &lt; num_opnds(), &quot;oob&quot;);
<span class="line-modified">!   if (_opnds[operand]-&gt;num_edges() == 0)  return -1;</span>
  
    uint skipped   = oper_input_base(); // Sum of leaves skipped so far
    for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
      uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
      skipped += num_edges;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,10 ***</span>
<span class="line-new-header">--- 410,24 ---</span>
    }
    if (_opnds[opcnt] != oper) return -1;
    return skipped;
  }
  
<span class="line-added">+ int MachNode::operand_index(Node* def) const {</span>
<span class="line-added">+   uint skipped = oper_input_base(); // Sum of leaves skipped so far</span>
<span class="line-added">+   for (uint opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {</span>
<span class="line-added">+     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand</span>
<span class="line-added">+     for (uint i = 0; i &lt; num_edges; i++) {</span>
<span class="line-added">+       if (in(skipped + i) == def) {</span>
<span class="line-added">+         return opcnt;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     skipped += num_edges;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return -1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //------------------------------peephole---------------------------------------
  // Apply peephole rule(s) to this instruction
  MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {
    return NULL;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,11 ***</span>
  }
  
  
  //=============================================================================
  
<span class="line-modified">! uint MachCallNode::cmp( const Node &amp;n ) const</span>
  { return _tf == ((MachCallNode&amp;)n)._tf; }
  const Type *MachCallNode::bottom_type() const { return tf()-&gt;range(); }
  const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range(); }
  
  #ifndef PRODUCT
<span class="line-new-header">--- 665,11 ---</span>
  }
  
  
  //=============================================================================
  
<span class="line-modified">! bool MachCallNode::cmp( const Node &amp;n ) const</span>
  { return _tf == ((MachCallNode&amp;)n)._tf; }
  const Type *MachCallNode::bottom_type() const { return tf()-&gt;range(); }
  const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range(); }
  
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,11 ***</span>
    return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
  }
  
  //=============================================================================
  uint MachCallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! uint MachCallJavaNode::cmp( const Node &amp;n ) const {</span>
    MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
    return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
           _override_symbolic_info == call._override_symbolic_info;
  }
  #ifndef PRODUCT
<span class="line-new-header">--- 721,11 ---</span>
    return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
  }
  
  //=============================================================================
  uint MachCallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! bool MachCallJavaNode::cmp( const Node &amp;n ) const {</span>
    MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
    return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
           _override_symbolic_info == call._override_symbolic_info;
  }
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,11 ***</span>
    return *debugmask[in(idx)-&gt;ideal_reg()];
  }
  
  //=============================================================================
  uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! uint MachCallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
    MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
    return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
  }
  
  //----------------------------uncommon_trap_request----------------------------
<span class="line-new-header">--- 759,11 ---</span>
    return *debugmask[in(idx)-&gt;ideal_reg()];
  }
  
  //=============================================================================
  uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! bool MachCallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
    MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
    return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
  }
  
  //----------------------------uncommon_trap_request----------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,11 ***</span>
    MachCallJavaNode::dump_spec(st);
  }
  #endif
  //=============================================================================
  uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! uint MachCallRuntimeNode::cmp( const Node &amp;n ) const {</span>
    MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
    return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
  }
  #ifndef PRODUCT
  void MachCallRuntimeNode::dump_spec(outputStream *st) const {
<span class="line-new-header">--- 805,11 ---</span>
    MachCallJavaNode::dump_spec(st);
  }
  #endif
  //=============================================================================
  uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">! bool MachCallRuntimeNode::cmp( const Node &amp;n ) const {</span>
    MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
    return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
  }
  #ifndef PRODUCT
  void MachCallRuntimeNode::dump_spec(outputStream *st) const {
</pre>
<center><a href="loopopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
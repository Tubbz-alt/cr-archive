<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/parseHelper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parse3.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parseHelper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 233,69 ***</span>
    // Result is ignored, we just need the CFG effects.
    gen_checkcast(obj, a_e_klass);
  }
  
  
<span class="line-removed">- void Parse::emit_guard_for_new(ciInstanceKlass* klass) {</span>
<span class="line-removed">-   // Emit guarded new</span>
<span class="line-removed">-   //   if (klass-&gt;_init_thread != current_thread ||</span>
<span class="line-removed">-   //       klass-&gt;_init_state != being_initialized)</span>
<span class="line-removed">-   //      uncommon_trap</span>
<span class="line-removed">-   Node* cur_thread = _gvn.transform( new ThreadLocalNode() );</span>
<span class="line-removed">-   Node* merge = new RegionNode(3);</span>
<span class="line-removed">-   _gvn.set_type(merge, Type::CONTROL);</span>
<span class="line-removed">-   Node* kls = makecon(TypeKlassPtr::make(klass));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* init_thread_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_thread_offset()));</span>
<span class="line-removed">-   Node* adr_node = basic_plus_adr(kls, kls, init_thread_offset);</span>
<span class="line-removed">-   Node* init_thread = make_load(NULL, adr_node, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);</span>
<span class="line-removed">-   Node *tst   = Bool( CmpP( init_thread, cur_thread), BoolTest::eq);</span>
<span class="line-removed">-   IfNode* iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">-   set_control(IfTrue(iff));</span>
<span class="line-removed">-   merge-&gt;set_req(1, IfFalse(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node* init_state_offset = _gvn.MakeConX(in_bytes(InstanceKlass::init_state_offset()));</span>
<span class="line-removed">-   adr_node = basic_plus_adr(kls, kls, init_state_offset);</span>
<span class="line-removed">-   // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler</span>
<span class="line-removed">-   // can generate code to load it as unsigned byte.</span>
<span class="line-removed">-   Node* init_state = make_load(NULL, adr_node, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);</span>
<span class="line-removed">-   Node* being_init = _gvn.intcon(InstanceKlass::being_initialized);</span>
<span class="line-removed">-   tst   = Bool( CmpI( init_state, being_init), BoolTest::eq);</span>
<span class="line-removed">-   iff = create_and_map_if(control(), tst, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-removed">-   set_control(IfTrue(iff));</span>
<span class="line-removed">-   merge-&gt;set_req(2, IfFalse(iff));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PreserveJVMState pjvms(this);</span>
<span class="line-removed">-   record_for_igvn(merge);</span>
<span class="line-removed">-   set_control(merge);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-removed">-                 Deoptimization::Action_reinterpret,</span>
<span class="line-removed">-                 klass);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  //------------------------------do_new-----------------------------------------
  void Parse::do_new() {
    kill_dead_locals();
  
    bool will_link;
    ciInstanceKlass* klass = iter().get_klass(will_link)-&gt;as_instance_klass();
    assert(will_link, &quot;_new: typeflow responsibility&quot;);
  
<span class="line-modified">!   // Should initialize, or throw an InstantiationError?</span>
<span class="line-modified">!   if ((!klass-&gt;is_initialized() &amp;&amp; !klass-&gt;is_being_initialized()) ||</span>
<span class="line-removed">-       klass-&gt;is_abstract() || klass-&gt;is_interface() ||</span>
        klass-&gt;name() == ciSymbol::java_lang_Class() ||
        iter().is_unresolved_klass()) {
<span class="line-modified">!     uncommon_trap(Deoptimization::Reason_uninitialized,</span>
<span class="line-modified">!                   Deoptimization::Action_reinterpret,</span>
                    klass);
      return;
    }
<span class="line-modified">!   if (klass-&gt;is_being_initialized()) {</span>
<span class="line-modified">!     emit_guard_for_new(klass);</span>
    }
  
    Node* kls = makecon(TypeKlassPtr::make(klass));
    Node* obj = new_instance(kls);
  
<span class="line-new-header">--- 233,31 ---</span>
    // Result is ignored, we just need the CFG effects.
    gen_checkcast(obj, a_e_klass);
  }
  
  
  //------------------------------do_new-----------------------------------------
  void Parse::do_new() {
    kill_dead_locals();
  
    bool will_link;
    ciInstanceKlass* klass = iter().get_klass(will_link)-&gt;as_instance_klass();
    assert(will_link, &quot;_new: typeflow responsibility&quot;);
  
<span class="line-modified">!   // Should throw an InstantiationError?</span>
<span class="line-modified">!   if (klass-&gt;is_abstract() || klass-&gt;is_interface() ||</span>
        klass-&gt;name() == ciSymbol::java_lang_Class() ||
        iter().is_unresolved_klass()) {
<span class="line-modified">!     uncommon_trap(Deoptimization::Reason_unhandled,</span>
<span class="line-modified">!                   Deoptimization::Action_none,</span>
                    klass);
      return;
    }
<span class="line-modified">! </span>
<span class="line-modified">!   if (C-&gt;needs_clinit_barrier(klass, method())) {</span>
<span class="line-added">+     clinit_barrier(klass, method());</span>
<span class="line-added">+     if (stopped())  return;</span>
    }
  
    Node* kls = makecon(TypeKlassPtr::make(klass));
    Node* obj = new_instance(kls);
  
</pre>
<center><a href="parse3.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/ifg.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="idealGraphPrinter.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/ifg.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,15 ***</span>
  // Convert triangular matrix to square matrix
  void PhaseIFG::SquareUp() {
    assert( !_is_square, &quot;only on triangular&quot; );
  
    // Simple transpose
<span class="line-modified">!   for( uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified">!     IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!     uint datum;</span>
<span class="line-modified">!     while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">!       _adjs[datum].insert( i );</span>
      }
    }
    _is_square = true;
  }
  
<span class="line-new-header">--- 78,17 ---</span>
  // Convert triangular matrix to square matrix
  void PhaseIFG::SquareUp() {
    assert( !_is_square, &quot;only on triangular&quot; );
  
    // Simple transpose
<span class="line-modified">!   for(uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified">!     if (!_adjs[i].is_empty()) {</span>
<span class="line-modified">!       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!       uint datum;</span>
<span class="line-modified">!       while ((datum = elements.next()) != 0) {</span>
<span class="line-added">+         _adjs[datum].insert(i);</span>
<span class="line-added">+       }</span>
      }
    }
    _is_square = true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,20 ***</span>
    //return _adjs[a].unordered_member(b);
    return _adjs[a].member(b);
  }
  
  // Union edges of B into A
<span class="line-modified">! void PhaseIFG::Union( uint a, uint b ) {</span>
    assert( _is_square, &quot;only on square&quot; );
    IndexSet *A = &amp;_adjs[a];
<span class="line-modified">!   IndexSetIterator b_elements(&amp;_adjs[b]);</span>
<span class="line-modified">!   uint datum;</span>
<span class="line-modified">!   while ((datum = b_elements.next()) != 0) {</span>
<span class="line-modified">!     if(A-&gt;insert(datum)) {</span>
<span class="line-modified">!       _adjs[datum].insert(a);</span>
<span class="line-modified">!       lrgs(a).invalid_degree();</span>
<span class="line-modified">!       lrgs(datum).invalid_degree();</span>
      }
    }
  }
  
  // Yank a Node and all connected edges from the IFG.  Return a
<span class="line-new-header">--- 108,22 ---</span>
    //return _adjs[a].unordered_member(b);
    return _adjs[a].member(b);
  }
  
  // Union edges of B into A
<span class="line-modified">! void PhaseIFG::Union(uint a, uint b) {</span>
    assert( _is_square, &quot;only on square&quot; );
    IndexSet *A = &amp;_adjs[a];
<span class="line-modified">!   if (!_adjs[b].is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator b_elements(&amp;_adjs[b]);</span>
<span class="line-modified">!     uint datum;</span>
<span class="line-modified">!     while ((datum = b_elements.next()) != 0) {</span>
<span class="line-modified">!       if (A-&gt;insert(datum)) {</span>
<span class="line-modified">!         _adjs[datum].insert(a);</span>
<span class="line-modified">!         lrgs(a).invalid_degree();</span>
<span class="line-added">+         lrgs(datum).invalid_degree();</span>
<span class="line-added">+       }</span>
      }
    }
  }
  
  // Yank a Node and all connected edges from the IFG.  Return a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,25 ***</span>
    assert( _is_square, &quot;only on square&quot; );
    assert( !_yanked-&gt;test(a), &quot;&quot; );
    _yanked-&gt;set(a);
  
    // I remove the LRG from all neighbors.
<span class="line-removed">-   IndexSetIterator elements(&amp;_adjs[a]);</span>
    LRG &amp;lrg_a = lrgs(a);
<span class="line-modified">!   uint datum;</span>
<span class="line-modified">!   while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">!     _adjs[datum].remove(a);</span>
<span class="line-modified">!     lrgs(datum).inc_degree( -lrg_a.compute_degree(lrgs(datum)) );</span>
    }
    return neighbors(a);
  }
  
  // Re-insert a yanked Node.
<span class="line-modified">! void PhaseIFG::re_insert( uint a ) {</span>
    assert( _is_square, &quot;only on square&quot; );
    assert( _yanked-&gt;test(a), &quot;&quot; );
<span class="line-modified">!   (*_yanked) &gt;&gt;= a;</span>
  
    IndexSetIterator elements(&amp;_adjs[a]);
    uint datum;
    while ((datum = elements.next()) != 0) {
      _adjs[datum].insert(a);
<span class="line-new-header">--- 132,30 ---</span>
    assert( _is_square, &quot;only on square&quot; );
    assert( !_yanked-&gt;test(a), &quot;&quot; );
    _yanked-&gt;set(a);
  
    // I remove the LRG from all neighbors.
    LRG &amp;lrg_a = lrgs(a);
<span class="line-modified">! </span>
<span class="line-modified">!   if (!_adjs[a].is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator elements(&amp;_adjs[a]);</span>
<span class="line-modified">!     uint datum;</span>
<span class="line-added">+     while ((datum = elements.next()) != 0) {</span>
<span class="line-added">+       _adjs[datum].remove(a);</span>
<span class="line-added">+       lrgs(datum).inc_degree(-lrg_a.compute_degree(lrgs(datum)));</span>
<span class="line-added">+     }</span>
    }
    return neighbors(a);
  }
  
  // Re-insert a yanked Node.
<span class="line-modified">! void PhaseIFG::re_insert(uint a) {</span>
    assert( _is_square, &quot;only on square&quot; );
    assert( _yanked-&gt;test(a), &quot;&quot; );
<span class="line-modified">!   _yanked-&gt;remove(a);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_adjs[a].is_empty()) return;</span>
  
    IndexSetIterator elements(&amp;_adjs[a]);
    uint datum;
    while ((datum = elements.next()) != 0) {
      _adjs[datum].insert(a);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
  // Compute the degree between 2 live ranges.  If both live ranges are
  // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
  // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
  // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
  // this is so.
<span class="line-modified">! int LRG::compute_degree( LRG &amp;l ) const {</span>
    int tmp;
    int num_regs = _num_regs;
    int nregs = l.num_regs();
    tmp =  (_fat_proj || l._fat_proj)     // either is a fat-proj?
      ? (num_regs * nregs)                // then use product
<span class="line-new-header">--- 166,11 ---</span>
  // Compute the degree between 2 live ranges.  If both live ranges are
  // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
  // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
  // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
  // this is so.
<span class="line-modified">! int LRG::compute_degree(LRG &amp;l) const {</span>
    int tmp;
    int num_regs = _num_regs;
    int nregs = l.num_regs();
    tmp =  (_fat_proj || l._fat_proj)     // either is a fat-proj?
      ? (num_regs * nregs)                // then use product
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,18 ***</span>
  // Compute effective degree for this live range.  If both live ranges are
  // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
  // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
  // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
  // this is so.
<span class="line-modified">! int PhaseIFG::effective_degree( uint lidx ) const {</span>
    int eff = 0;
    int num_regs = lrgs(lidx).num_regs();
    int fat_proj = lrgs(lidx)._fat_proj;
<span class="line-removed">-   IndexSet *s = neighbors(lidx);</span>
    IndexSetIterator elements(s);
    uint nidx;
<span class="line-modified">!   while((nidx = elements.next()) != 0) {</span>
      LRG &amp;lrgn = lrgs(nidx);
      int nregs = lrgn.num_regs();
      eff += (fat_proj || lrgn._fat_proj) // either is a fat-proj?
        ? (num_regs * nregs)              // then use product
        : MAX2(num_regs,nregs);           // else use max
<span class="line-new-header">--- 181,19 ---</span>
  // Compute effective degree for this live range.  If both live ranges are
  // aligned-adjacent powers-of-2 then we use the MAX size.  If either is
  // mis-aligned (or for Fat-Projections, not-adjacent) then we have to
  // MULTIPLY the sizes.  Inspect Brigg&#39;s thesis on register pairs to see why
  // this is so.
<span class="line-modified">! int PhaseIFG::effective_degree(uint lidx) const {</span>
<span class="line-added">+   IndexSet *s = neighbors(lidx);</span>
<span class="line-added">+   if (s-&gt;is_empty()) return 0;</span>
    int eff = 0;
    int num_regs = lrgs(lidx).num_regs();
    int fat_proj = lrgs(lidx)._fat_proj;
    IndexSetIterator elements(s);
    uint nidx;
<span class="line-modified">!   while ((nidx = elements.next()) != 0) {</span>
      LRG &amp;lrgn = lrgs(nidx);
      int nregs = lrgn.num_regs();
      eff += (fat_proj || lrgn._fat_proj) // either is a fat-proj?
        ? (num_regs * nregs)              // then use product
        : MAX2(num_regs,nregs);           // else use max
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,39 ***</span>
  
  #ifndef PRODUCT
  void PhaseIFG::dump() const {
    tty-&gt;print_cr(&quot;-- Interference Graph --%s--&quot;,
                  _is_square ? &quot;square&quot; : &quot;triangular&quot; );
<span class="line-modified">!   if( _is_square ) {</span>
<span class="line-modified">!     for( uint i = 0; i &lt; _maxlrg; i++ ) {</span>
<span class="line-modified">!       tty-&gt;print( (*_yanked)[i] ? &quot;XX &quot; : &quot;  &quot;);</span>
        tty-&gt;print(&quot;L%d: { &quot;,i);
<span class="line-modified">!       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!       uint datum;</span>
<span class="line-modified">!       while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">!         tty-&gt;print(&quot;L%d &quot;, datum);</span>
        }
        tty-&gt;print_cr(&quot;}&quot;);
  
      }
      return;
    }
  
    // Triangular
    for( uint i = 0; i &lt; _maxlrg; i++ ) {
      uint j;
<span class="line-modified">!     tty-&gt;print( (*_yanked)[i] ? &quot;XX &quot; : &quot;  &quot;);</span>
      tty-&gt;print(&quot;L%d: { &quot;,i);
      for( j = _maxlrg; j &gt; i; j-- )
        if( test_edge(j - 1,i) ) {
          tty-&gt;print(&quot;L%d &quot;,j - 1);
        }
      tty-&gt;print(&quot;| &quot;);
<span class="line-modified">!     IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!     uint datum;</span>
<span class="line-modified">!     while ((datum = elements.next()) != 0) {</span>
<span class="line-modified">!       tty-&gt;print(&quot;L%d &quot;, datum);</span>
      }
      tty-&gt;print(&quot;}\n&quot;);
    }
    tty-&gt;print(&quot;\n&quot;);
  }
<span class="line-new-header">--- 204,43 ---</span>
  
  #ifndef PRODUCT
  void PhaseIFG::dump() const {
    tty-&gt;print_cr(&quot;-- Interference Graph --%s--&quot;,
                  _is_square ? &quot;square&quot; : &quot;triangular&quot; );
<span class="line-modified">!   if (_is_square) {</span>
<span class="line-modified">!     for (uint i = 0; i &lt; _maxlrg; i++) {</span>
<span class="line-modified">!       tty-&gt;print(_yanked-&gt;test(i) ? &quot;XX &quot; : &quot;  &quot;);</span>
        tty-&gt;print(&quot;L%d: { &quot;,i);
<span class="line-modified">!       if (!_adjs[i].is_empty()) {</span>
<span class="line-modified">!         IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!         uint datum;</span>
<span class="line-modified">!         while ((datum = elements.next()) != 0) {</span>
<span class="line-added">+           tty-&gt;print(&quot;L%d &quot;, datum);</span>
<span class="line-added">+         }</span>
        }
        tty-&gt;print_cr(&quot;}&quot;);
  
      }
      return;
    }
  
    // Triangular
    for( uint i = 0; i &lt; _maxlrg; i++ ) {
      uint j;
<span class="line-modified">!     tty-&gt;print(_yanked-&gt;test(i) ? &quot;XX &quot; : &quot;  &quot;);</span>
      tty-&gt;print(&quot;L%d: { &quot;,i);
      for( j = _maxlrg; j &gt; i; j-- )
        if( test_edge(j - 1,i) ) {
          tty-&gt;print(&quot;L%d &quot;,j - 1);
        }
      tty-&gt;print(&quot;| &quot;);
<span class="line-modified">!     if (!_adjs[i].is_empty()) {</span>
<span class="line-modified">!       IndexSetIterator elements(&amp;_adjs[i]);</span>
<span class="line-modified">!       uint datum;</span>
<span class="line-modified">!       while ((datum = elements.next()) != 0) {</span>
<span class="line-added">+         tty-&gt;print(&quot;L%d &quot;, datum);</span>
<span class="line-added">+       }</span>
      }
      tty-&gt;print(&quot;}\n&quot;);
    }
    tty-&gt;print(&quot;\n&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,22 ***</span>
  }
  
  void PhaseIFG::verify( const PhaseChaitin *pc ) const {
    // IFG is square, sorted and no need for Find
    for( uint i = 0; i &lt; _maxlrg; i++ ) {
<span class="line-modified">!     assert(!((*_yanked)[i]) || !neighbor_cnt(i), &quot;Is removed completely&quot; );</span>
      IndexSet *set = &amp;_adjs[i];
<span class="line-modified">!     IndexSetIterator elements(set);</span>
<span class="line-modified">!     uint idx;</span>
<span class="line-modified">!     uint last = 0;</span>
<span class="line-modified">!     while ((idx = elements.next()) != 0) {</span>
<span class="line-modified">!       assert(idx != i, &quot;Must have empty diagonal&quot;);</span>
<span class="line-modified">!       assert(pc-&gt;_lrg_map.find_const(idx) == idx, &quot;Must not need Find&quot;);</span>
<span class="line-modified">!       assert(_adjs[idx].member(i), &quot;IFG not square&quot;);</span>
<span class="line-modified">!       assert(!(*_yanked)[idx], &quot;No yanked neighbors&quot;);</span>
<span class="line-modified">!       assert(last &lt; idx, &quot;not sorted increasing&quot;);</span>
<span class="line-modified">!       last = idx;</span>
      }
      assert(!lrgs(i)._degree_valid || effective_degree(i) == lrgs(i).degree(), &quot;degree is valid but wrong&quot;);
    }
  }
  #endif
<span class="line-new-header">--- 261,24 ---</span>
  }
  
  void PhaseIFG::verify( const PhaseChaitin *pc ) const {
    // IFG is square, sorted and no need for Find
    for( uint i = 0; i &lt; _maxlrg; i++ ) {
<span class="line-modified">!     assert(!_yanked-&gt;test(i) || !neighbor_cnt(i), &quot;Is removed completely&quot; );</span>
      IndexSet *set = &amp;_adjs[i];
<span class="line-modified">!     if (!set-&gt;is_empty()) {</span>
<span class="line-modified">!       IndexSetIterator elements(set);</span>
<span class="line-modified">!       uint idx;</span>
<span class="line-modified">!       uint last = 0;</span>
<span class="line-modified">!       while ((idx = elements.next()) != 0) {</span>
<span class="line-modified">!         assert(idx != i, &quot;Must have empty diagonal&quot;);</span>
<span class="line-modified">!         assert(pc-&gt;_lrg_map.find_const(idx) == idx, &quot;Must not need Find&quot;);</span>
<span class="line-modified">!         assert(_adjs[idx].member(i), &quot;IFG not square&quot;);</span>
<span class="line-modified">!         assert(!_yanked-&gt;test(idx), &quot;No yanked neighbors&quot;);</span>
<span class="line-modified">!         assert(last &lt; idx, &quot;not sorted increasing&quot;);</span>
<span class="line-added">+         last = idx;</span>
<span class="line-added">+       }</span>
      }
      assert(!lrgs(i)._degree_valid || effective_degree(i) == lrgs(i).degree(), &quot;degree is valid but wrong&quot;);
    }
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,20 ***</span>
   * Interfere this register with everything currently live.
   * Check for interference by checking overlap of regmasks.
   * Only interfere if acceptable register masks overlap.
   */
  void PhaseChaitin::interfere_with_live(uint lid, IndexSet* liveout) {
<span class="line-modified">!   LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">!   const RegMask&amp; rm = lrg.mask();</span>
<span class="line-modified">!   IndexSetIterator elements(liveout);</span>
<span class="line-modified">!   uint interfering_lid = elements.next();</span>
<span class="line-modified">!   while (interfering_lid != 0) {</span>
<span class="line-modified">!     LRG&amp; interfering_lrg = lrgs(interfering_lid);</span>
<span class="line-modified">!     if (rm.overlap(interfering_lrg.mask())) {</span>
<span class="line-modified">!       _ifg-&gt;add_edge(lid, interfering_lid);</span>
      }
<span class="line-removed">-     interfering_lid = elements.next();</span>
    }
  }
  
  // Actually build the interference graph.  Uses virtual registers only, no
  // physical register masks.  This allows me to be very aggressive when
<span class="line-new-header">--- 287,22 ---</span>
   * Interfere this register with everything currently live.
   * Check for interference by checking overlap of regmasks.
   * Only interfere if acceptable register masks overlap.
   */
  void PhaseChaitin::interfere_with_live(uint lid, IndexSet* liveout) {
<span class="line-modified">!   if (!liveout-&gt;is_empty()) {</span>
<span class="line-modified">!     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">!     const RegMask &amp;rm = lrg.mask();</span>
<span class="line-modified">!     IndexSetIterator elements(liveout);</span>
<span class="line-modified">!     uint interfering_lid = elements.next();</span>
<span class="line-modified">!     while (interfering_lid != 0) {</span>
<span class="line-modified">!       LRG&amp; interfering_lrg = lrgs(interfering_lid);</span>
<span class="line-modified">!       if (rm.overlap(interfering_lrg.mask())) {</span>
<span class="line-added">+         _ifg-&gt;add_edge(lid, interfering_lid);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       interfering_lid = elements.next();</span>
      }
    }
  }
  
  // Actually build the interference graph.  Uses virtual registers only, no
  // physical register masks.  This allows me to be very aggressive when
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,10 ***</span>
<span class="line-new-header">--- 397,13 ---</span>
    } // End of forall blocks
  }
  
  #ifdef ASSERT
  uint PhaseChaitin::count_int_pressure(IndexSet* liveout) {
<span class="line-added">+   if (liveout-&gt;is_empty()) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
    IndexSetIterator elements(liveout);
    uint lidx = elements.next();
    uint cnt = 0;
    while (lidx != 0) {
      LRG&amp; lrg = lrgs(lidx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,10 ***</span>
<span class="line-new-header">--- 416,13 ---</span>
    }
    return cnt;
  }
  
  uint PhaseChaitin::count_float_pressure(IndexSet* liveout) {
<span class="line-added">+   if (liveout-&gt;is_empty()) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
    IndexSetIterator elements(liveout);
    uint lidx = elements.next();
    uint cnt = 0;
    while (lidx != 0) {
      LRG&amp; lrg = lrgs(lidx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,17 ***</span>
   * We add the cost for the whole block to the area of the live ranges initially.
   * If a live range gets killed in the block, we&#39;ll subtract the unused part of
   * the block from the area.
   */
  void PhaseChaitin::compute_initial_block_pressure(Block* b, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure, double cost) {
<span class="line-modified">!   IndexSetIterator elements(liveout);</span>
<span class="line-modified">!   uint lid = elements.next();</span>
<span class="line-modified">!   while (lid != 0) {</span>
<span class="line-modified">!     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">!     lrg._area += cost;</span>
<span class="line-modified">!     raise_pressure(b, lrg, int_pressure, float_pressure);</span>
<span class="line-modified">!     lid = elements.next();</span>
    }
    assert(int_pressure.current_pressure() == count_int_pressure(liveout), &quot;the int pressure is incorrect&quot;);
    assert(float_pressure.current_pressure() == count_float_pressure(liveout), &quot;the float pressure is incorrect&quot;);
  }
  
<span class="line-new-header">--- 516,19 ---</span>
   * We add the cost for the whole block to the area of the live ranges initially.
   * If a live range gets killed in the block, we&#39;ll subtract the unused part of
   * the block from the area.
   */
  void PhaseChaitin::compute_initial_block_pressure(Block* b, IndexSet* liveout, Pressure&amp; int_pressure, Pressure&amp; float_pressure, double cost) {
<span class="line-modified">!   if (!liveout-&gt;is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator elements(liveout);</span>
<span class="line-modified">!     uint lid = elements.next();</span>
<span class="line-modified">!     while (lid != 0) {</span>
<span class="line-modified">!       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-modified">!       lrg._area += cost;</span>
<span class="line-modified">!       raise_pressure(b, lrg, int_pressure, float_pressure);</span>
<span class="line-added">+       lid = elements.next();</span>
<span class="line-added">+     }</span>
    }
    assert(int_pressure.current_pressure() == count_int_pressure(liveout), &quot;the int pressure is incorrect&quot;);
    assert(float_pressure.current_pressure() == count_float_pressure(liveout), &quot;the float pressure is incorrect&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 510,17 ***</span>
  * Computes the entry register pressure of a block, looking at all live
  * ranges in the livein. The register pressure is computed for both float
  * and int/pointer registers.
  */
  void PhaseChaitin::compute_entry_block_pressure(Block* b) {
<span class="line-modified">!   IndexSet* livein = _live-&gt;livein(b);</span>
<span class="line-modified">!   IndexSetIterator elements(livein);</span>
<span class="line-modified">!   uint lid = elements.next();</span>
<span class="line-modified">!   while (lid != 0) {</span>
<span class="line-modified">!     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">!     raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-modified">!     lid = elements.next();</span>
    }
    // Now check phis for locally defined inputs
    for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
      Node* n = b-&gt;get_node(j);
      if (n-&gt;is_Phi()) {
<span class="line-new-header">--- 536,19 ---</span>
  * Computes the entry register pressure of a block, looking at all live
  * ranges in the livein. The register pressure is computed for both float
  * and int/pointer registers.
  */
  void PhaseChaitin::compute_entry_block_pressure(Block* b) {
<span class="line-modified">!   IndexSet *livein = _live-&gt;livein(b);</span>
<span class="line-modified">!   if (!livein-&gt;is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator elements(livein);</span>
<span class="line-modified">!     uint lid = elements.next();</span>
<span class="line-modified">!     while (lid != 0) {</span>
<span class="line-modified">!       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-modified">!       raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-added">+       lid = elements.next();</span>
<span class="line-added">+     }</span>
    }
    // Now check phis for locally defined inputs
    for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
      Node* n = b-&gt;get_node(j);
      if (n-&gt;is_Phi()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,19 ***</span>
  * Computes the exit register pressure of a block, looking at all live
  * ranges in the liveout. The register pressure is computed for both float
  * and int/pointer registers.
  */
  void PhaseChaitin::compute_exit_block_pressure(Block* b) {
    IndexSet* livein = _live-&gt;live(b);
<span class="line-removed">-   IndexSetIterator elements(livein);</span>
    _sched_int_pressure.set_current_pressure(0);
    _sched_float_pressure.set_current_pressure(0);
<span class="line-modified">!   uint lid = elements.next();</span>
<span class="line-modified">!   while (lid != 0) {</span>
<span class="line-modified">!     LRG&amp; lrg = lrgs(lid);</span>
<span class="line-modified">!     raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-modified">!     lid = elements.next();</span>
    }
  }
  
  /*
   * Remove dead node if it&#39;s not used.
<span class="line-new-header">--- 572,22 ---</span>
  * Computes the exit register pressure of a block, looking at all live
  * ranges in the liveout. The register pressure is computed for both float
  * and int/pointer registers.
  */
  void PhaseChaitin::compute_exit_block_pressure(Block* b) {
<span class="line-added">+ </span>
    IndexSet* livein = _live-&gt;live(b);
    _sched_int_pressure.set_current_pressure(0);
    _sched_float_pressure.set_current_pressure(0);
<span class="line-modified">!   if (!livein-&gt;is_empty()) {</span>
<span class="line-modified">!     IndexSetIterator elements(livein);</span>
<span class="line-modified">!     uint lid = elements.next();</span>
<span class="line-modified">!     while (lid != 0) {</span>
<span class="line-modified">!       LRG &amp;lrg = lrgs(lid);</span>
<span class="line-added">+       raise_pressure(b, lrg, _sched_int_pressure, _sched_float_pressure);</span>
<span class="line-added">+       lid = elements.next();</span>
<span class="line-added">+     }</span>
    }
  }
  
  /*
   * Remove dead node if it&#39;s not used.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,10 ***</span>
<span class="line-new-header">--- 683,11 ---</span>
  /*
   * The defined value must go in a particular register. Remove that register from
   * all conflicting parties and avoid the interference.
   */
  void PhaseChaitin::remove_bound_register_from_interfering_live_ranges(LRG&amp; lrg, IndexSet* liveout, uint&amp; must_spill) {
<span class="line-added">+   if (liveout-&gt;is_empty()) return;</span>
    // Check for common case
    const RegMask&amp; rm = lrg.mask();
    int r_size = lrg.num_regs();
    // Smear odd bits
    IndexSetIterator elements(liveout);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 831,11 ***</span>
  
      for (uint location = last_inst; location &gt; 0; location--) {
        Node* n = block-&gt;get_node(location);
        uint lid = _lrg_map.live_range_id(n);
  
<span class="line-modified">!       if(lid) {</span>
          LRG&amp; lrg = lrgs(lid);
  
          // A DEF normally costs block frequency; rematerialized values are
          // removed from the DEF sight, so LOWER costs here.
          lrg._cost += n-&gt;rematerialize() ? 0 : block-&gt;_freq;
<span class="line-new-header">--- 863,11 ---</span>
  
      for (uint location = last_inst; location &gt; 0; location--) {
        Node* n = block-&gt;get_node(location);
        uint lid = _lrg_map.live_range_id(n);
  
<span class="line-modified">!       if (lid) {</span>
          LRG&amp; lrg = lrgs(lid);
  
          // A DEF normally costs block frequency; rematerialized values are
          // removed from the DEF sight, so LOWER costs here.
          lrg._cost += n-&gt;rematerialize() ? 0 : block-&gt;_freq;
</pre>
<center><a href="idealGraphPrinter.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ifnode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;


 27 #include &quot;opto/machnode.hpp&quot;
 28 #include &quot;opto/regalloc.hpp&quot;
 29 #include &quot;utilities/vmError.hpp&quot;
 30 
 31 //=============================================================================
 32 // Return the value requested
 33 // result register lookup, corresponding to int_format
 34 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 35   return (int)ra_-&gt;get_encode(node);
 36 }
 37 // input register lookup, corresponding to ext_format
 38 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 39   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 40 }
 41 intptr_t  MachOper::constant() const { return 0x00; }
 42 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 43 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 44 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 45 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 46 TypeOopPtr *MachOper::oop() const { return NULL; }
</pre>
<hr />
<pre>
 76 const RegMask *MachOper::in_RegMask(int index) const {
 77   ShouldNotReachHere();
 78   return NULL;
 79 }
 80 
 81 //------------------------------dump_spec--------------------------------------
 82 // Print any per-operand special info
 83 #ifndef PRODUCT
 84 void MachOper::dump_spec(outputStream *st) const { }
 85 #endif
 86 
 87 //------------------------------hash-------------------------------------------
 88 // Print any per-operand special info
 89 uint MachOper::hash() const {
 90   ShouldNotCallThis();
 91   return 5;
 92 }
 93 
 94 //------------------------------cmp--------------------------------------------
 95 // Print any per-operand special info
<span class="line-modified"> 96 uint MachOper::cmp( const MachOper &amp;oper ) const {</span>
 97   ShouldNotCallThis();
 98   return opcode() == oper.opcode();
 99 }
100 
101 //------------------------------hash-------------------------------------------
102 // Print any per-operand special info
103 uint labelOper::hash() const {
104   return _block_num;
105 }
106 
107 //------------------------------cmp--------------------------------------------
108 // Print any per-operand special info
<span class="line-modified">109 uint labelOper::cmp( const MachOper &amp;oper ) const {</span>
110   return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
111 }
112 
113 //------------------------------hash-------------------------------------------
114 // Print any per-operand special info
115 uint methodOper::hash() const {
116   return (uint)_method;
117 }
118 
119 //------------------------------cmp--------------------------------------------
120 // Print any per-operand special info
<span class="line-modified">121 uint methodOper::cmp( const MachOper &amp;oper ) const {</span>
122   return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
123 }
124 
125 
126 //=============================================================================
127 //------------------------------MachNode---------------------------------------
128 
129 //------------------------------emit-------------------------------------------
130 void MachNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
131   #ifdef ASSERT
132   tty-&gt;print(&quot;missing MachNode emit function: &quot;);
133   dump();
134   #endif
135   ShouldNotCallThis();
136 }
137 
138 //---------------------------postalloc_expand----------------------------------
139 // Expand node after register allocation.
140 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
141 
</pre>
<hr />
<pre>
150 //------------------------------size-------------------------------------------
151 // Helper function that computes size by emitting code
152 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
153   // Emit into a trash buffer and count bytes emitted.
154   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
155   return ra_-&gt;C-&gt;scratch_emit_size(this);
156 }
157 
158 
159 
160 //------------------------------hash-------------------------------------------
161 uint MachNode::hash() const {
162   uint no = num_opnds();
163   uint sum = rule();
164   for( uint i=0; i&lt;no; i++ )
165     sum += _opnds[i]-&gt;hash();
166   return sum+Node::hash();
167 }
168 
169 //-----------------------------cmp---------------------------------------------
<span class="line-modified">170 uint MachNode::cmp( const Node &amp;node ) const {</span>
171   MachNode&amp; n = *((Node&amp;)node).as_Mach();
172   uint no = num_opnds();
<span class="line-modified">173   if( no != n.num_opnds() ) return 0;</span>
<span class="line-modified">174   if( rule() != n.rule() ) return 0;</span>
175   for( uint i=0; i&lt;no; i++ )    // All operands must match
176     if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
<span class="line-modified">177       return 0;                 // mis-matched operands</span>
<span class="line-modified">178   return 1;                     // match</span>
179 }
180 
181 // Return an equivalent instruction using memory for cisc_operand position
182 MachNode *MachNode::cisc_version(int offset) {
183   ShouldNotCallThis();
184   return NULL;
185 }
186 
187 void MachNode::use_cisc_RegMask() {
188   ShouldNotReachHere();
189 }
190 
191 
192 //-----------------------------in_RegMask--------------------------------------
193 const RegMask &amp;MachNode::in_RegMask( uint idx ) const {
194   uint numopnds = num_opnds();        // Virtual call for number of operands
195   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
196   if( idx &lt; skipped ) {
197     assert( ideal_Opcode() == Op_AddP, &quot;expected base ptr here&quot; );
198     assert( idx == 1, &quot;expected base ptr here&quot; );
</pre>
<hr />
<pre>
329   const Node *base = get_base_and_disp(offset, adr_type);
330   if( adr_type != TYPE_PTR_SENTINAL ) {
331     return adr_type;      // get_base_and_disp has the answer
332   }
333 
334   // Direct addressing modes have no base node, simply an indirect
335   // offset, which is always to raw memory.
336   // %%%%% Someday we&#39;d like to allow constant oop offsets which
337   // would let Intel load from static globals in 1 instruction.
338   // Currently Intel requires 2 instructions and a register temp.
339   if (base == NULL) {
340     // NULL base, zero offset means no memory at all (a null pointer!)
341     if (offset == 0) {
342       return NULL;
343     }
344     // NULL base, any offset means any pointer whatever
345     if (offset == Type::OffsetBot) {
346       return TypePtr::BOTTOM;
347     }
348     // %%% make offset be intptr_t
<span class="line-modified">349     assert(!Universe::heap()-&gt;is_in_reserved(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);</span>
350     return TypeRawPtr::BOTTOM;
351   }
352 
353   // base of -1 with no particular offset means all of memory
354   if (base == NodeSentinel)  return TypePtr::BOTTOM;
355 
356   const Type* t = base-&gt;bottom_type();
<span class="line-modified">357   if (t-&gt;isa_narrowoop() &amp;&amp; Universe::narrow_oop_shift() == 0) {</span>
358     // 32-bit unscaled narrow oop can be the base of any address expression
359     t = t-&gt;make_ptr();
360   }
<span class="line-modified">361   if (t-&gt;isa_narrowklass() &amp;&amp; Universe::narrow_klass_shift() == 0) {</span>
362     // 32-bit unscaled narrow oop can be the base of any address expression
363     t = t-&gt;make_ptr();
364   }
365   if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
366     // We cannot assert that the offset does not look oop-ish here.
367     // Depending on the heap layout the cardmark base could land
368     // inside some oopish region.  It definitely does for Win2K.
369     // The sum of cardmark-base plus shift-by-9-oop lands outside
370     // the oop-ish area but we can&#39;t assert for that statically.
371     return TypeRawPtr::BOTTOM;
372   }
373 
374   const TypePtr *tp = t-&gt;isa_ptr();
375 
376   // be conservative if we do not recognize the type
377   if (tp == NULL) {
378     assert(false, &quot;this path may produce not optimal code&quot;);
379     return TypePtr::BOTTOM;
380   }
381   assert(tp-&gt;base() != Type::AnyPtr, &quot;not a bare pointer&quot;);
382 
383   return tp-&gt;add_offset(offset);
384 }
385 
386 
387 //-----------------------------operand_index---------------------------------
<span class="line-modified">388 int MachNode::operand_index( uint operand ) const {</span>
<span class="line-modified">389   if( operand &lt; 1 )  return -1;</span>
390   assert(operand &lt; num_opnds(), &quot;oob&quot;);
<span class="line-modified">391   if( _opnds[operand]-&gt;num_edges() == 0 )  return -1;</span>
392 
393   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
394   for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
395     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
396     skipped += num_edges;
397   }
398   return skipped;
399 }
400 
401 int MachNode::operand_index(const MachOper *oper) const {
402   uint skipped = oper_input_base(); // Sum of leaves skipped so far
403   uint opcnt;
404   for (opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {
405     if (_opnds[opcnt] == oper) break;
406     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
407     skipped += num_edges;
408   }
409   if (_opnds[opcnt] != oper) return -1;
410   return skipped;
411 }
412 














413 //------------------------------peephole---------------------------------------
414 // Apply peephole rule(s) to this instruction
415 MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {
416   return NULL;
417 }
418 
419 //------------------------------add_case_label---------------------------------
420 // Adds the label for the case
421 void MachNode::add_case_label( int index_num, Label* blockLabel) {
422   ShouldNotCallThis();
423 }
424 
425 //------------------------------method_set-------------------------------------
426 // Set the absolute address of a method
427 void MachNode::method_set( intptr_t addr ) {
428   ShouldNotCallThis();
429 }
430 
431 //------------------------------rematerialize----------------------------------
432 bool MachNode::rematerialize() const {
</pre>
<hr />
<pre>
634 //------------------------------Registers--------------------------------------
635 const RegMask &amp;MachSafePointNode::in_RegMask( uint idx ) const {
636   // Values in the domain use the users calling convention, embodied in the
637   // _in_rms array of RegMasks.
638   if( idx &lt; TypeFunc::Parms ) return _in_rms[idx];
639 
640   if (SafePointNode::needs_polling_address_input() &amp;&amp;
641       idx == TypeFunc::Parms &amp;&amp;
642       ideal_Opcode() == Op_SafePoint) {
643     return MachNode::in_RegMask(idx);
644   }
645 
646   // Values outside the domain represent debug info
647   assert(in(idx)-&gt;ideal_reg() != Op_RegFlags, &quot;flags register is not spillable&quot;);
648   return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[in(idx)-&gt;ideal_reg()];
649 }
650 
651 
652 //=============================================================================
653 
<span class="line-modified">654 uint MachCallNode::cmp( const Node &amp;n ) const</span>
655 { return _tf == ((MachCallNode&amp;)n)._tf; }
656 const Type *MachCallNode::bottom_type() const { return tf()-&gt;range(); }
657 const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range(); }
658 
659 #ifndef PRODUCT
660 void MachCallNode::dump_spec(outputStream *st) const {
661   st-&gt;print(&quot;# &quot;);
662   if (tf() != NULL)  tf()-&gt;dump_on(st);
663   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
664   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
665 }
666 #endif
667 
668 bool MachCallNode::return_value_is_used() const {
669   if (tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) {
670     // void return
671     return false;
672   }
673 
674   // find the projection corresponding to the return value
</pre>
<hr />
<pre>
690   return (r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
691           r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
692 }
693 
694 //------------------------------Registers--------------------------------------
695 const RegMask &amp;MachCallNode::in_RegMask(uint idx) const {
696   // Values in the domain use the users calling convention, embodied in the
697   // _in_rms array of RegMasks.
698   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
699     return _in_rms[idx];
700   }
701   if (idx == mach_constant_base_node_input()) {
702     return MachConstantBaseNode::static_out_RegMask();
703   }
704   // Values outside the domain represent debug info
705   return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
706 }
707 
708 //=============================================================================
709 uint MachCallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">710 uint MachCallJavaNode::cmp( const Node &amp;n ) const {</span>
711   MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
712   return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
713          _override_symbolic_info == call._override_symbolic_info;
714 }
715 #ifndef PRODUCT
716 void MachCallJavaNode::dump_spec(outputStream *st) const {
717   if (_method_handle_invoke)
718     st-&gt;print(&quot;MethodHandle &quot;);
719   if (_method) {
720     _method-&gt;print_short_name(st);
721     st-&gt;print(&quot; &quot;);
722   }
723   MachCallNode::dump_spec(st);
724 }
725 #endif
726 
727 //------------------------------Registers--------------------------------------
728 const RegMask &amp;MachCallJavaNode::in_RegMask(uint idx) const {
729   // Values in the domain use the users calling convention, embodied in the
730   // _in_rms array of RegMasks.
731   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
732     return _in_rms[idx];
733   }
734   if (idx == mach_constant_base_node_input()) {
735     return MachConstantBaseNode::static_out_RegMask();
736   }
737   // Values outside the domain represent debug info
738   Matcher* m = Compile::current()-&gt;matcher();
739   // If this call is a MethodHandle invoke we have to use a different
740   // debugmask which does not include the register we use to save the
741   // SP over MH invokes.
742   RegMask** debugmask = _method_handle_invoke ? m-&gt;idealreg2mhdebugmask : m-&gt;idealreg2debugmask;
743   return *debugmask[in(idx)-&gt;ideal_reg()];
744 }
745 
746 //=============================================================================
747 uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">748 uint MachCallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
749   MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
750   return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
751 }
752 
753 //----------------------------uncommon_trap_request----------------------------
754 // If this is an uncommon trap, return the request code, else zero.
755 int MachCallStaticJavaNode::uncommon_trap_request() const {
756   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
757     return CallStaticJavaNode::extract_uncommon_trap_request(this);
758   }
759   return 0;
760 }
761 
762 #ifndef PRODUCT
763 // Helper for summarizing uncommon_trap arguments.
764 void MachCallStaticJavaNode::dump_trap_args(outputStream *st) const {
765   int trap_req = uncommon_trap_request();
766   if (trap_req != 0) {
767     char buf[100];
768     st-&gt;print(&quot;(%s)&quot;,
</pre>
<hr />
<pre>
774 void MachCallStaticJavaNode::dump_spec(outputStream *st) const {
775   st-&gt;print(&quot;Static &quot;);
776   if (_name != NULL) {
777     st-&gt;print(&quot;wrapper for: %s&quot;, _name );
778     dump_trap_args(st);
779     st-&gt;print(&quot; &quot;);
780   }
781   MachCallJavaNode::dump_spec(st);
782 }
783 #endif
784 
785 //=============================================================================
786 #ifndef PRODUCT
787 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
788   st-&gt;print(&quot;Dynamic &quot;);
789   MachCallJavaNode::dump_spec(st);
790 }
791 #endif
792 //=============================================================================
793 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">794 uint MachCallRuntimeNode::cmp( const Node &amp;n ) const {</span>
795   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
796   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
797 }
798 #ifndef PRODUCT
799 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
800   st-&gt;print(&quot;%s &quot;,_name);
801   MachCallNode::dump_spec(st);
802 }
803 #endif
804 //=============================================================================
805 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
806 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
807 // to indicate where the stack-slot-only debug info inputs begin.
808 // There is no other JVM state needed here.
809 JVMState jvms_for_throw(0);
810 JVMState *MachHaltNode::jvms() const {
811   return &amp;jvms_for_throw;
812 }
813 
814 uint MachMemBarNode::size_of() const { return sizeof(*this); }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added"> 27 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 28 #include &quot;oops/compressedOops.hpp&quot;</span>
 29 #include &quot;opto/machnode.hpp&quot;
 30 #include &quot;opto/regalloc.hpp&quot;
 31 #include &quot;utilities/vmError.hpp&quot;
 32 
 33 //=============================================================================
 34 // Return the value requested
 35 // result register lookup, corresponding to int_format
 36 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 37   return (int)ra_-&gt;get_encode(node);
 38 }
 39 // input register lookup, corresponding to ext_format
 40 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 41   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 42 }
 43 intptr_t  MachOper::constant() const { return 0x00; }
 44 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 45 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 46 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 47 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 48 TypeOopPtr *MachOper::oop() const { return NULL; }
</pre>
<hr />
<pre>
 78 const RegMask *MachOper::in_RegMask(int index) const {
 79   ShouldNotReachHere();
 80   return NULL;
 81 }
 82 
 83 //------------------------------dump_spec--------------------------------------
 84 // Print any per-operand special info
 85 #ifndef PRODUCT
 86 void MachOper::dump_spec(outputStream *st) const { }
 87 #endif
 88 
 89 //------------------------------hash-------------------------------------------
 90 // Print any per-operand special info
 91 uint MachOper::hash() const {
 92   ShouldNotCallThis();
 93   return 5;
 94 }
 95 
 96 //------------------------------cmp--------------------------------------------
 97 // Print any per-operand special info
<span class="line-modified"> 98 bool MachOper::cmp( const MachOper &amp;oper ) const {</span>
 99   ShouldNotCallThis();
100   return opcode() == oper.opcode();
101 }
102 
103 //------------------------------hash-------------------------------------------
104 // Print any per-operand special info
105 uint labelOper::hash() const {
106   return _block_num;
107 }
108 
109 //------------------------------cmp--------------------------------------------
110 // Print any per-operand special info
<span class="line-modified">111 bool labelOper::cmp( const MachOper &amp;oper ) const {</span>
112   return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
113 }
114 
115 //------------------------------hash-------------------------------------------
116 // Print any per-operand special info
117 uint methodOper::hash() const {
118   return (uint)_method;
119 }
120 
121 //------------------------------cmp--------------------------------------------
122 // Print any per-operand special info
<span class="line-modified">123 bool methodOper::cmp( const MachOper &amp;oper ) const {</span>
124   return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
125 }
126 
127 
128 //=============================================================================
129 //------------------------------MachNode---------------------------------------
130 
131 //------------------------------emit-------------------------------------------
132 void MachNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
133   #ifdef ASSERT
134   tty-&gt;print(&quot;missing MachNode emit function: &quot;);
135   dump();
136   #endif
137   ShouldNotCallThis();
138 }
139 
140 //---------------------------postalloc_expand----------------------------------
141 // Expand node after register allocation.
142 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
143 
</pre>
<hr />
<pre>
152 //------------------------------size-------------------------------------------
153 // Helper function that computes size by emitting code
154 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
155   // Emit into a trash buffer and count bytes emitted.
156   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
157   return ra_-&gt;C-&gt;scratch_emit_size(this);
158 }
159 
160 
161 
162 //------------------------------hash-------------------------------------------
163 uint MachNode::hash() const {
164   uint no = num_opnds();
165   uint sum = rule();
166   for( uint i=0; i&lt;no; i++ )
167     sum += _opnds[i]-&gt;hash();
168   return sum+Node::hash();
169 }
170 
171 //-----------------------------cmp---------------------------------------------
<span class="line-modified">172 bool MachNode::cmp( const Node &amp;node ) const {</span>
173   MachNode&amp; n = *((Node&amp;)node).as_Mach();
174   uint no = num_opnds();
<span class="line-modified">175   if( no != n.num_opnds() ) return false;</span>
<span class="line-modified">176   if( rule() != n.rule() ) return false;</span>
177   for( uint i=0; i&lt;no; i++ )    // All operands must match
178     if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
<span class="line-modified">179       return false;             // mis-matched operands</span>
<span class="line-modified">180   return true;                  // match</span>
181 }
182 
183 // Return an equivalent instruction using memory for cisc_operand position
184 MachNode *MachNode::cisc_version(int offset) {
185   ShouldNotCallThis();
186   return NULL;
187 }
188 
189 void MachNode::use_cisc_RegMask() {
190   ShouldNotReachHere();
191 }
192 
193 
194 //-----------------------------in_RegMask--------------------------------------
195 const RegMask &amp;MachNode::in_RegMask( uint idx ) const {
196   uint numopnds = num_opnds();        // Virtual call for number of operands
197   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
198   if( idx &lt; skipped ) {
199     assert( ideal_Opcode() == Op_AddP, &quot;expected base ptr here&quot; );
200     assert( idx == 1, &quot;expected base ptr here&quot; );
</pre>
<hr />
<pre>
331   const Node *base = get_base_and_disp(offset, adr_type);
332   if( adr_type != TYPE_PTR_SENTINAL ) {
333     return adr_type;      // get_base_and_disp has the answer
334   }
335 
336   // Direct addressing modes have no base node, simply an indirect
337   // offset, which is always to raw memory.
338   // %%%%% Someday we&#39;d like to allow constant oop offsets which
339   // would let Intel load from static globals in 1 instruction.
340   // Currently Intel requires 2 instructions and a register temp.
341   if (base == NULL) {
342     // NULL base, zero offset means no memory at all (a null pointer!)
343     if (offset == 0) {
344       return NULL;
345     }
346     // NULL base, any offset means any pointer whatever
347     if (offset == Type::OffsetBot) {
348       return TypePtr::BOTTOM;
349     }
350     // %%% make offset be intptr_t
<span class="line-modified">351     assert(!Universe::heap()-&gt;is_in(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);</span>
352     return TypeRawPtr::BOTTOM;
353   }
354 
355   // base of -1 with no particular offset means all of memory
356   if (base == NodeSentinel)  return TypePtr::BOTTOM;
357 
358   const Type* t = base-&gt;bottom_type();
<span class="line-modified">359   if (t-&gt;isa_narrowoop() &amp;&amp; CompressedOops::shift() == 0) {</span>
360     // 32-bit unscaled narrow oop can be the base of any address expression
361     t = t-&gt;make_ptr();
362   }
<span class="line-modified">363   if (t-&gt;isa_narrowklass() &amp;&amp; CompressedKlassPointers::shift() == 0) {</span>
364     // 32-bit unscaled narrow oop can be the base of any address expression
365     t = t-&gt;make_ptr();
366   }
367   if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
368     // We cannot assert that the offset does not look oop-ish here.
369     // Depending on the heap layout the cardmark base could land
370     // inside some oopish region.  It definitely does for Win2K.
371     // The sum of cardmark-base plus shift-by-9-oop lands outside
372     // the oop-ish area but we can&#39;t assert for that statically.
373     return TypeRawPtr::BOTTOM;
374   }
375 
376   const TypePtr *tp = t-&gt;isa_ptr();
377 
378   // be conservative if we do not recognize the type
379   if (tp == NULL) {
380     assert(false, &quot;this path may produce not optimal code&quot;);
381     return TypePtr::BOTTOM;
382   }
383   assert(tp-&gt;base() != Type::AnyPtr, &quot;not a bare pointer&quot;);
384 
385   return tp-&gt;add_offset(offset);
386 }
387 
388 
389 //-----------------------------operand_index---------------------------------
<span class="line-modified">390 int MachNode::operand_index(uint operand) const {</span>
<span class="line-modified">391   if (operand &lt; 1)  return -1;</span>
392   assert(operand &lt; num_opnds(), &quot;oob&quot;);
<span class="line-modified">393   if (_opnds[operand]-&gt;num_edges() == 0)  return -1;</span>
394 
395   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
396   for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
397     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
398     skipped += num_edges;
399   }
400   return skipped;
401 }
402 
403 int MachNode::operand_index(const MachOper *oper) const {
404   uint skipped = oper_input_base(); // Sum of leaves skipped so far
405   uint opcnt;
406   for (opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {
407     if (_opnds[opcnt] == oper) break;
408     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
409     skipped += num_edges;
410   }
411   if (_opnds[opcnt] != oper) return -1;
412   return skipped;
413 }
414 
<span class="line-added">415 int MachNode::operand_index(Node* def) const {</span>
<span class="line-added">416   uint skipped = oper_input_base(); // Sum of leaves skipped so far</span>
<span class="line-added">417   for (uint opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {</span>
<span class="line-added">418     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand</span>
<span class="line-added">419     for (uint i = 0; i &lt; num_edges; i++) {</span>
<span class="line-added">420       if (in(skipped + i) == def) {</span>
<span class="line-added">421         return opcnt;</span>
<span class="line-added">422       }</span>
<span class="line-added">423     }</span>
<span class="line-added">424     skipped += num_edges;</span>
<span class="line-added">425   }</span>
<span class="line-added">426   return -1;</span>
<span class="line-added">427 }</span>
<span class="line-added">428 </span>
429 //------------------------------peephole---------------------------------------
430 // Apply peephole rule(s) to this instruction
431 MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {
432   return NULL;
433 }
434 
435 //------------------------------add_case_label---------------------------------
436 // Adds the label for the case
437 void MachNode::add_case_label( int index_num, Label* blockLabel) {
438   ShouldNotCallThis();
439 }
440 
441 //------------------------------method_set-------------------------------------
442 // Set the absolute address of a method
443 void MachNode::method_set( intptr_t addr ) {
444   ShouldNotCallThis();
445 }
446 
447 //------------------------------rematerialize----------------------------------
448 bool MachNode::rematerialize() const {
</pre>
<hr />
<pre>
650 //------------------------------Registers--------------------------------------
651 const RegMask &amp;MachSafePointNode::in_RegMask( uint idx ) const {
652   // Values in the domain use the users calling convention, embodied in the
653   // _in_rms array of RegMasks.
654   if( idx &lt; TypeFunc::Parms ) return _in_rms[idx];
655 
656   if (SafePointNode::needs_polling_address_input() &amp;&amp;
657       idx == TypeFunc::Parms &amp;&amp;
658       ideal_Opcode() == Op_SafePoint) {
659     return MachNode::in_RegMask(idx);
660   }
661 
662   // Values outside the domain represent debug info
663   assert(in(idx)-&gt;ideal_reg() != Op_RegFlags, &quot;flags register is not spillable&quot;);
664   return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[in(idx)-&gt;ideal_reg()];
665 }
666 
667 
668 //=============================================================================
669 
<span class="line-modified">670 bool MachCallNode::cmp( const Node &amp;n ) const</span>
671 { return _tf == ((MachCallNode&amp;)n)._tf; }
672 const Type *MachCallNode::bottom_type() const { return tf()-&gt;range(); }
673 const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range(); }
674 
675 #ifndef PRODUCT
676 void MachCallNode::dump_spec(outputStream *st) const {
677   st-&gt;print(&quot;# &quot;);
678   if (tf() != NULL)  tf()-&gt;dump_on(st);
679   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
680   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
681 }
682 #endif
683 
684 bool MachCallNode::return_value_is_used() const {
685   if (tf()-&gt;range()-&gt;cnt() == TypeFunc::Parms) {
686     // void return
687     return false;
688   }
689 
690   // find the projection corresponding to the return value
</pre>
<hr />
<pre>
706   return (r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
707           r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
708 }
709 
710 //------------------------------Registers--------------------------------------
711 const RegMask &amp;MachCallNode::in_RegMask(uint idx) const {
712   // Values in the domain use the users calling convention, embodied in the
713   // _in_rms array of RegMasks.
714   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
715     return _in_rms[idx];
716   }
717   if (idx == mach_constant_base_node_input()) {
718     return MachConstantBaseNode::static_out_RegMask();
719   }
720   // Values outside the domain represent debug info
721   return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
722 }
723 
724 //=============================================================================
725 uint MachCallJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">726 bool MachCallJavaNode::cmp( const Node &amp;n ) const {</span>
727   MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
728   return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
729          _override_symbolic_info == call._override_symbolic_info;
730 }
731 #ifndef PRODUCT
732 void MachCallJavaNode::dump_spec(outputStream *st) const {
733   if (_method_handle_invoke)
734     st-&gt;print(&quot;MethodHandle &quot;);
735   if (_method) {
736     _method-&gt;print_short_name(st);
737     st-&gt;print(&quot; &quot;);
738   }
739   MachCallNode::dump_spec(st);
740 }
741 #endif
742 
743 //------------------------------Registers--------------------------------------
744 const RegMask &amp;MachCallJavaNode::in_RegMask(uint idx) const {
745   // Values in the domain use the users calling convention, embodied in the
746   // _in_rms array of RegMasks.
747   if (idx &lt; tf()-&gt;domain()-&gt;cnt()) {
748     return _in_rms[idx];
749   }
750   if (idx == mach_constant_base_node_input()) {
751     return MachConstantBaseNode::static_out_RegMask();
752   }
753   // Values outside the domain represent debug info
754   Matcher* m = Compile::current()-&gt;matcher();
755   // If this call is a MethodHandle invoke we have to use a different
756   // debugmask which does not include the register we use to save the
757   // SP over MH invokes.
758   RegMask** debugmask = _method_handle_invoke ? m-&gt;idealreg2mhdebugmask : m-&gt;idealreg2debugmask;
759   return *debugmask[in(idx)-&gt;ideal_reg()];
760 }
761 
762 //=============================================================================
763 uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
<span class="line-modified">764 bool MachCallStaticJavaNode::cmp( const Node &amp;n ) const {</span>
765   MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
766   return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
767 }
768 
769 //----------------------------uncommon_trap_request----------------------------
770 // If this is an uncommon trap, return the request code, else zero.
771 int MachCallStaticJavaNode::uncommon_trap_request() const {
772   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
773     return CallStaticJavaNode::extract_uncommon_trap_request(this);
774   }
775   return 0;
776 }
777 
778 #ifndef PRODUCT
779 // Helper for summarizing uncommon_trap arguments.
780 void MachCallStaticJavaNode::dump_trap_args(outputStream *st) const {
781   int trap_req = uncommon_trap_request();
782   if (trap_req != 0) {
783     char buf[100];
784     st-&gt;print(&quot;(%s)&quot;,
</pre>
<hr />
<pre>
790 void MachCallStaticJavaNode::dump_spec(outputStream *st) const {
791   st-&gt;print(&quot;Static &quot;);
792   if (_name != NULL) {
793     st-&gt;print(&quot;wrapper for: %s&quot;, _name );
794     dump_trap_args(st);
795     st-&gt;print(&quot; &quot;);
796   }
797   MachCallJavaNode::dump_spec(st);
798 }
799 #endif
800 
801 //=============================================================================
802 #ifndef PRODUCT
803 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
804   st-&gt;print(&quot;Dynamic &quot;);
805   MachCallJavaNode::dump_spec(st);
806 }
807 #endif
808 //=============================================================================
809 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
<span class="line-modified">810 bool MachCallRuntimeNode::cmp( const Node &amp;n ) const {</span>
811   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
812   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
813 }
814 #ifndef PRODUCT
815 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
816   st-&gt;print(&quot;%s &quot;,_name);
817   MachCallNode::dump_spec(st);
818 }
819 #endif
820 //=============================================================================
821 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
822 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
823 // to indicate where the stack-slot-only debug info inputs begin.
824 // There is no other JVM state needed here.
825 JVMState jvms_for_throw(0);
826 JVMState *MachHaltNode::jvms() const {
827   return &amp;jvms_for_throw;
828 }
829 
830 uint MachMemBarNode::size_of() const { return sizeof(*this); }
</pre>
</td>
</tr>
</table>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
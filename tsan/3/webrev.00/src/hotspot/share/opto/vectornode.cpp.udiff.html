<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/vectornode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/vectornode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,10 +23,11 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;opto/connode.hpp&quot;
  #include &quot;opto/vectornode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //------------------------------VectorNode--------------------------------------
  
  // Return the vector operator for the specified scalar operation
  // and vector length.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,12 +69,12 @@</span>
    case Op_SubD:
      assert(bt == T_DOUBLE, &quot;must be&quot;);
      return Op_SubVD;
    case Op_MulI:
      switch (bt) {
<span class="udiff-line-modified-removed">-     case T_BOOLEAN:</span>
<span class="udiff-line-modified-removed">-     case T_BYTE:   return 0;   // Unimplemented</span>
<span class="udiff-line-modified-added">+     case T_BOOLEAN:return 0;</span>
<span class="udiff-line-modified-added">+     case T_BYTE:   return Op_MulVB;</span>
      case T_CHAR:
      case T_SHORT:  return Op_MulVS;
      case T_INT:    return Op_MulVI;
      default:       ShouldNotReachHere(); return 0;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102,10 +103,22 @@</span>
      assert(bt == T_FLOAT, &quot;must be&quot;);
      return Op_DivVF;
    case Op_DivD:
      assert(bt == T_DOUBLE, &quot;must be&quot;);
      return Op_DivVD;
<span class="udiff-line-added">+   case Op_AbsI:</span>
<span class="udiff-line-added">+     switch (bt) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN:</span>
<span class="udiff-line-added">+     case T_CHAR:  return 0; // abs does not make sense for unsigned</span>
<span class="udiff-line-added">+     case T_BYTE:  return Op_AbsVB;</span>
<span class="udiff-line-added">+     case T_SHORT: return Op_AbsVS;</span>
<span class="udiff-line-added">+     case T_INT:   return Op_AbsVI;</span>
<span class="udiff-line-added">+     default: ShouldNotReachHere(); return 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   case Op_AbsL:</span>
<span class="udiff-line-added">+     assert(bt == T_LONG, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     return Op_AbsVL;</span>
    case Op_AbsF:
      assert(bt == T_FLOAT, &quot;must be&quot;);
      return Op_AbsVF;
    case Op_AbsD:
      assert(bt == T_DOUBLE, &quot;must be&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -114,10 +127,13 @@</span>
      assert(bt == T_FLOAT, &quot;must be&quot;);
      return Op_NegVF;
    case Op_NegD:
      assert(bt == T_DOUBLE, &quot;must be&quot;);
      return Op_NegVD;
<span class="udiff-line-added">+   case Op_RoundDoubleMode:</span>
<span class="udiff-line-added">+     assert(bt == T_DOUBLE, &quot;must be&quot;);</span>
<span class="udiff-line-added">+     return Op_RoundDoubleModeV;</span>
    case Op_SqrtF:
      assert(bt == T_FLOAT, &quot;must be&quot;);
      return Op_SqrtVF;
    case Op_SqrtD:
      assert(bt == T_DOUBLE, &quot;must be&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,11 +237,11 @@</span>
  bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {
    if (is_java_primitive(bt) &amp;&amp;
        (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
        Matcher::vector_size_supported(bt, vlen)) {
      int vopc = VectorNode::opcode(opc, bt);
<span class="udiff-line-modified-removed">-     return vopc &gt; 0 &amp;&amp; Matcher::match_rule_supported_vector(vopc, vlen);</span>
<span class="udiff-line-modified-added">+     return vopc &gt; 0 &amp;&amp; Matcher::match_rule_supported_vector(vopc, vlen, bt);</span>
    }
    return false;
  }
  
  bool VectorNode::is_type_transition_short_to_int(Node* n) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,10 +261,17 @@</span>
      return true;
    }
    return false;
  }
  
<span class="udiff-line-added">+ bool VectorNode::is_roundopD(Node *n) {</span>
<span class="udiff-line-added">+   if (n-&gt;Opcode() == Op_RoundDoubleMode) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool VectorNode::is_shift(Node* n) {
    switch (n-&gt;Opcode()) {
    case Op_LShiftI:
    case Op_LShiftL:
    case Op_RShiftI:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -283,12 +306,10 @@</span>
    case Op_LoadB:   case Op_LoadUB:
    case Op_LoadS:   case Op_LoadUS:
    case Op_LoadI:   case Op_LoadL:
    case Op_LoadF:   case Op_LoadD:
    case Op_LoadP:   case Op_LoadN:
<span class="udiff-line-removed">-   case Op_LoadBarrierSlowReg:</span>
<span class="udiff-line-removed">-   case Op_LoadBarrierWeakSlowReg:</span>
      *start = 0;
      *end   = 0; // no vector operands
      break;
    case Op_StoreB:  case Op_StoreC:
    case Op_StoreI:  case Op_StoreL:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,19 +369,24 @@</span>
    case Op_SubVI: return new SubVINode(n1, n2, vt);
    case Op_SubVL: return new SubVLNode(n1, n2, vt);
    case Op_SubVF: return new SubVFNode(n1, n2, vt);
    case Op_SubVD: return new SubVDNode(n1, n2, vt);
  
<span class="udiff-line-added">+   case Op_MulVB: return new MulVBNode(n1, n2, vt);</span>
    case Op_MulVS: return new MulVSNode(n1, n2, vt);
    case Op_MulVI: return new MulVINode(n1, n2, vt);
    case Op_MulVL: return new MulVLNode(n1, n2, vt);
    case Op_MulVF: return new MulVFNode(n1, n2, vt);
    case Op_MulVD: return new MulVDNode(n1, n2, vt);
  
    case Op_DivVF: return new DivVFNode(n1, n2, vt);
    case Op_DivVD: return new DivVDNode(n1, n2, vt);
  
<span class="udiff-line-added">+   case Op_AbsVB: return new AbsVBNode(n1, vt);</span>
<span class="udiff-line-added">+   case Op_AbsVS: return new AbsVSNode(n1, vt);</span>
<span class="udiff-line-added">+   case Op_AbsVI: return new AbsVINode(n1, vt);</span>
<span class="udiff-line-added">+   case Op_AbsVL: return new AbsVLNode(n1, vt);</span>
    case Op_AbsVF: return new AbsVFNode(n1, vt);
    case Op_AbsVD: return new AbsVDNode(n1, vt);
  
    case Op_NegVF: return new NegVFNode(n1, vt);
    case Op_NegVD: return new NegVDNode(n1, vt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -390,10 +416,12 @@</span>
    case Op_XorV: return new XorVNode(n1, n2, vt);
  
    case Op_MinV: return new MinVNode(n1, n2, vt);
    case Op_MaxV: return new MaxVNode(n1, n2, vt);
  
<span class="udiff-line-added">+   case Op_RoundDoubleModeV: return new RoundDoubleModeVNode(n1, n2, vt);</span>
<span class="udiff-line-added">+ </span>
    case Op_MulAddVS2VI: return new MulAddVS2VINode(n1, n2, vt);
    default:
      fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -438,11 +466,11 @@</span>
      return NULL;
    }
  }
  
  VectorNode* VectorNode::shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt) {
<span class="udiff-line-modified-removed">-   assert(VectorNode::is_shift(shift) &amp;&amp; !cnt-&gt;is_Con(), &quot;only variable shift count&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VectorNode::is_shift(shift), &quot;sanity&quot;);</span>
    // Match shift count type with shift vector type.
    const TypeVect* vt = TypeVect::make(bt, vlen);
    switch (shift-&gt;Opcode()) {
    case Op_LShiftI:
    case Op_LShiftL:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,10 +484,42 @@</span>
      fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[shift-&gt;Opcode()]);
      return NULL;
    }
  }
  
<span class="udiff-line-added">+ bool VectorNode::is_vector_shift(int opc) {</span>
<span class="udiff-line-added">+   assert(opc &gt; _last_machine_leaf &amp;&amp; opc &lt; _last_opcode, &quot;invalid opcode&quot;);</span>
<span class="udiff-line-added">+   switch (opc) {</span>
<span class="udiff-line-added">+   case Op_LShiftVB:</span>
<span class="udiff-line-added">+   case Op_LShiftVS:</span>
<span class="udiff-line-added">+   case Op_LShiftVI:</span>
<span class="udiff-line-added">+   case Op_LShiftVL:</span>
<span class="udiff-line-added">+   case Op_RShiftVB:</span>
<span class="udiff-line-added">+   case Op_RShiftVS:</span>
<span class="udiff-line-added">+   case Op_RShiftVI:</span>
<span class="udiff-line-added">+   case Op_RShiftVL:</span>
<span class="udiff-line-added">+   case Op_URShiftVB:</span>
<span class="udiff-line-added">+   case Op_URShiftVS:</span>
<span class="udiff-line-added">+   case Op_URShiftVI:</span>
<span class="udiff-line-added">+   case Op_URShiftVL:</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   default:</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool VectorNode::is_vector_shift_count(int opc) {</span>
<span class="udiff-line-added">+   assert(opc &gt; _last_machine_leaf &amp;&amp; opc &lt; _last_opcode, &quot;invalid opcode&quot;);</span>
<span class="udiff-line-added">+   switch (opc) {</span>
<span class="udiff-line-added">+   case Op_RShiftCntV:</span>
<span class="udiff-line-added">+   case Op_LShiftCntV:</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   default:</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Return initial Pack node. Additional operands added with add_opd() calls.
  PackNode* PackNode::make(Node* s, uint vlen, BasicType bt) {
    const TypeVect* vt = TypeVect::make(bt, vlen);
    switch (bt) {
    case T_BOOLEAN:
</pre>
<center><a href="type.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
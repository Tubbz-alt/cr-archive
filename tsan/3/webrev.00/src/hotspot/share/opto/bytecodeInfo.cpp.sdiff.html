<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/bytecodeInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="buildOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/bytecodeInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 60     // Keep a private copy of the caller_jvms:
 61     _caller_jvms = new (C) JVMState(caller_jvms-&gt;method(), caller_tree-&gt;caller_jvms());
 62     _caller_jvms-&gt;set_bci(caller_jvms-&gt;bci());
 63     assert(!caller_jvms-&gt;should_reexecute(), &quot;there should be no reexecute bytecode with inlining&quot;);
 64   }
 65   assert(_caller_jvms-&gt;same_calls_as(caller_jvms), &quot;consistent JVMS&quot;);
 66   assert((caller_tree == NULL ? 0 : caller_tree-&gt;stack_depth() + 1) == stack_depth(), &quot;correct (redundant) depth parameter&quot;);
 67   assert(caller_bci == this-&gt;caller_bci(), &quot;correct (redundant) bci parameter&quot;);
 68   // Update hierarchical counts, count_inline_bcs() and count_inlines()
 69   InlineTree *caller = (InlineTree *)caller_tree;
 70   for( ; caller != NULL; caller = ((InlineTree *)(caller-&gt;caller_tree())) ) {
 71     caller-&gt;_count_inline_bcs += count_inline_bcs();
 72     NOT_PRODUCT(caller-&gt;_count_inlines++;)
 73   }
 74 }
 75 
 76 /**
 77  *  Return true when EA is ON and a java constructor is called or
 78  *  a super constructor is called from an inlined java constructor.
 79  *  Also return true for boxing methods.


 80  */
 81 static bool is_init_with_ea(ciMethod* callee_method,
 82                             ciMethod* caller_method, Compile* C) {
 83   if (!C-&gt;do_escape_analysis() || !EliminateAllocations) {
 84     return false; // EA is off
 85   }
 86   if (callee_method-&gt;is_initializer()) {
 87     return true; // constuctor
 88   }
 89   if (caller_method-&gt;is_initializer() &amp;&amp;
 90       caller_method != C-&gt;method() &amp;&amp;
 91       caller_method-&gt;holder()-&gt;is_subclass_of(callee_method-&gt;holder())) {
 92     return true; // super constructor is called from inlined constructor
 93   }
 94   if (C-&gt;eliminate_boxing() &amp;&amp; callee_method-&gt;is_boxing_method()) {
 95     return true;
 96   }





 97   return false;
 98 }
 99 
100 /**
101  *  Force inlining unboxing accessor.
102  */
103 static bool is_unboxing_method(ciMethod* callee_method, Compile* C) {
104   return C-&gt;eliminate_boxing() &amp;&amp; callee_method-&gt;is_unboxing_method();
105 }
106 
107 // positive filter: should callee be inlined?
108 bool InlineTree::should_inline(ciMethod* callee_method, ciMethod* caller_method,
109                                int caller_bci, ciCallProfile&amp; profile,
110                                WarmCallInfo* wci_result) {
111   // Allows targeted inlining
112   if (C-&gt;directive()-&gt;should_inline(callee_method)) {
113     *wci_result = *(WarmCallInfo::always_hot());
114     if (C-&gt;print_inlining() &amp;&amp; Verbose) {
115       CompileTask::print_inline_indent(inline_level());
116       tty-&gt;print_cr(&quot;Inlined method is hot: &quot;);
</pre>
<hr />
<pre>
185     if (max_inline_size &gt; default_max_inline_size) {
186       set_msg(&quot;hot method too big&quot;);
187     } else {
188       set_msg(&quot;too big&quot;);
189     }
190     return false;
191   }
192   return true;
193 }
194 
195 
196 // negative filter: should callee NOT be inlined?
197 bool InlineTree::should_not_inline(ciMethod *callee_method,
198                                    ciMethod* caller_method,
199                                    JVMState* jvms,
200                                    WarmCallInfo* wci_result) {
201 
202   const char* fail_msg = NULL;
203 
204   // First check all inlining restrictions which are required for correctness
<span class="line-modified">205   if ( callee_method-&gt;is_abstract()) {</span>
206     fail_msg = &quot;abstract method&quot;; // // note: we allow ik-&gt;is_abstract()
207   } else if (!callee_method-&gt;holder()-&gt;is_initialized() &amp;&amp;
208              // access allowed in the context of static initializer
<span class="line-modified">209              !C-&gt;is_compiling_clinit_for(callee_method-&gt;holder())) {</span>
210     fail_msg = &quot;method holder not initialized&quot;;
<span class="line-modified">211   } else if ( callee_method-&gt;is_native()) {</span>
212     fail_msg = &quot;native method&quot;;
<span class="line-modified">213   } else if ( callee_method-&gt;dont_inline()) {</span>
214     fail_msg = &quot;don&#39;t inline by annotation&quot;;
215   }
216 
217   // one more inlining restriction
218   if (fail_msg == NULL &amp;&amp; callee_method-&gt;has_unloaded_classes_in_signature()) {
219     fail_msg = &quot;unloaded signature classes&quot;;
220   }
221 
222   if (fail_msg != NULL) {
223     set_msg(fail_msg);
224     return true;
225   }
226 
227   // ignore heuristic controls on inlining
228   if (C-&gt;directive()-&gt;should_inline(callee_method)) {
229     set_msg(&quot;force inline by CompileCommand&quot;);
230     return false;
231   }
232 
233   if (C-&gt;directive()-&gt;should_not_inline(callee_method)) {
</pre>
<hr />
<pre>
304       return false;
305     } else {
306       intx counter_high_value;
307       // Tiered compilation uses a different &quot;high value&quot; than non-tiered compilation.
308       // Determine the right value to use.
309       if (TieredCompilation) {
310         counter_high_value = InvocationCounter::count_limit / 2;
311       } else {
312         counter_high_value = CompileThreshold / 2;
313       }
314       if (!callee_method-&gt;was_executed_more_than(MIN2(MinInliningThreshold, counter_high_value))) {
315         set_msg(&quot;executed &lt; MinInliningThreshold times&quot;);
316         return true;
317       }
318     }
319   }
320 
321   return false;
322 }
323 





























324 //-----------------------------try_to_inline-----------------------------------
325 // return true if ok
326 // Relocated from &quot;InliningClosure::try_to_inline&quot;
327 bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,
328                                int caller_bci, JVMState* jvms, ciCallProfile&amp; profile,
329                                WarmCallInfo* wci_result, bool&amp; should_delay) {
330 
331   if (ClipInlining &amp;&amp; (int)count_inline_bcs() &gt;= DesiredMethodLimit) {
332     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
333       set_msg(&quot;size &gt; DesiredMethodLimit&quot;);
334       return false;
335     } else if (!C-&gt;inlining_incrementally()) {
336       should_delay = true;
337     }
338   }
339 
340   _forced_inline = false; // Reset
341   if (!should_inline(callee_method, caller_method, caller_bci, profile,
342                      wci_result)) {
343     return false;
</pre>
<hr />
<pre>
355   // suppress a few checks for accessors and trivial methods
356   if (callee_method-&gt;code_size() &gt; MaxTrivialSize) {
357 
358     // don&#39;t inline into giant methods
359     if (C-&gt;over_inlining_cutoff()) {
360       if ((!callee_method-&gt;force_inline() &amp;&amp; !caller_method-&gt;is_compiled_lambda_form())
361           || !IncrementalInline) {
362         set_msg(&quot;NodeCountInliningCutoff&quot;);
363         return false;
364       } else {
365         should_delay = true;
366       }
367     }
368 
369     if (!UseInterpreter &amp;&amp;
370         is_init_with_ea(callee_method, caller_method, C)) {
371       // Escape Analysis stress testing when running Xcomp:
372       // inline constructors even if they are not reached.
373     } else if (forced_inline()) {
374       // Inlining was forced by CompilerOracle, ciReplay or annotation
<span class="line-modified">375     } else if (profile.count() == 0) {</span>
376       // don&#39;t inline unreached call sites
377        set_msg(&quot;call site not reached&quot;);
378        return false;
379     }
380   }
381 
382   if (!C-&gt;do_inlining() &amp;&amp; InlineAccessors) {
383     set_msg(&quot;not an accessor&quot;);
384     return false;
385   }
386 
387   // Limit inlining depth in case inlining is forced or
388   // _max_inline_level was increased to compensate for lambda forms.
389   if (inline_level() &gt; MaxForceInlineLevel) {
390     set_msg(&quot;MaxForceInlineLevel&quot;);
391     return false;
392   }
393   if (inline_level() &gt; _max_inline_level) {
394     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
395       set_msg(&quot;inlining too deep&quot;);
</pre>
<hr />
<pre>
432     }
433   }
434 
435   int size = callee_method-&gt;code_size_for_inlining();
436 
437   if (ClipInlining &amp;&amp; (int)count_inline_bcs() + size &gt;= DesiredMethodLimit) {
438     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
439       set_msg(&quot;size &gt; DesiredMethodLimit&quot;);
440       return false;
441     } else if (!C-&gt;inlining_incrementally()) {
442       should_delay = true;
443     }
444   }
445 
446   // ok, inline this method
447   return true;
448 }
449 
450 //------------------------------pass_initial_checks----------------------------
451 bool InlineTree::pass_initial_checks(ciMethod* caller_method, int caller_bci, ciMethod* callee_method) {
<span class="line-removed">452   ciInstanceKlass *callee_holder = callee_method ? callee_method-&gt;holder() : NULL;</span>
453   // Check if a callee_method was suggested
<span class="line-modified">454   if( callee_method == NULL )            return false;</span>



455   // Check if klass of callee_method is loaded
<span class="line-modified">456   if( !callee_holder-&gt;is_loaded() )      return false;</span>
<span class="line-modified">457   if( !callee_holder-&gt;is_initialized() &amp;&amp;</span>


458       // access allowed in the context of static initializer
<span class="line-modified">459       !C-&gt;is_compiling_clinit_for(callee_holder)) {</span>
460     return false;
461   }
462   if( !UseInterpreter ) /* running Xcomp */ {
463     // Checks that constant pool&#39;s call site has been visited
464     // stricter than callee_holder-&gt;is_initialized()
465     ciBytecodeStream iter(caller_method);
466     iter.force_bci(caller_bci);
467     Bytecodes::Code call_bc = iter.cur_bc();
468     // An invokedynamic instruction does not have a klass.
469     if (call_bc != Bytecodes::_invokedynamic) {
470       int index = iter.get_index_u2_cpcache();
471       if (!caller_method-&gt;is_klass_loaded(index, true)) {
472         return false;
473       }
474       // Try to do constant pool resolution if running Xcomp
475       if( !caller_method-&gt;check_call(index, call_bc == Bytecodes::_invokestatic) ) {
476         return false;
477       }
478     }
479   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 60     // Keep a private copy of the caller_jvms:
 61     _caller_jvms = new (C) JVMState(caller_jvms-&gt;method(), caller_tree-&gt;caller_jvms());
 62     _caller_jvms-&gt;set_bci(caller_jvms-&gt;bci());
 63     assert(!caller_jvms-&gt;should_reexecute(), &quot;there should be no reexecute bytecode with inlining&quot;);
 64   }
 65   assert(_caller_jvms-&gt;same_calls_as(caller_jvms), &quot;consistent JVMS&quot;);
 66   assert((caller_tree == NULL ? 0 : caller_tree-&gt;stack_depth() + 1) == stack_depth(), &quot;correct (redundant) depth parameter&quot;);
 67   assert(caller_bci == this-&gt;caller_bci(), &quot;correct (redundant) bci parameter&quot;);
 68   // Update hierarchical counts, count_inline_bcs() and count_inlines()
 69   InlineTree *caller = (InlineTree *)caller_tree;
 70   for( ; caller != NULL; caller = ((InlineTree *)(caller-&gt;caller_tree())) ) {
 71     caller-&gt;_count_inline_bcs += count_inline_bcs();
 72     NOT_PRODUCT(caller-&gt;_count_inlines++;)
 73   }
 74 }
 75 
 76 /**
 77  *  Return true when EA is ON and a java constructor is called or
 78  *  a super constructor is called from an inlined java constructor.
 79  *  Also return true for boxing methods.
<span class="line-added"> 80  *  Also return true for methods returning Iterator (including Iterable::iterator())</span>
<span class="line-added"> 81  *  that is essential for forall-loops performance.</span>
 82  */
 83 static bool is_init_with_ea(ciMethod* callee_method,
 84                             ciMethod* caller_method, Compile* C) {
 85   if (!C-&gt;do_escape_analysis() || !EliminateAllocations) {
 86     return false; // EA is off
 87   }
 88   if (callee_method-&gt;is_initializer()) {
 89     return true; // constuctor
 90   }
 91   if (caller_method-&gt;is_initializer() &amp;&amp;
 92       caller_method != C-&gt;method() &amp;&amp;
 93       caller_method-&gt;holder()-&gt;is_subclass_of(callee_method-&gt;holder())) {
 94     return true; // super constructor is called from inlined constructor
 95   }
 96   if (C-&gt;eliminate_boxing() &amp;&amp; callee_method-&gt;is_boxing_method()) {
 97     return true;
 98   }
<span class="line-added"> 99   ciType *retType = callee_method-&gt;signature()-&gt;return_type();</span>
<span class="line-added">100   ciKlass *iter = C-&gt;env()-&gt;Iterator_klass();</span>
<span class="line-added">101   if(retType-&gt;is_loaded() &amp;&amp; iter-&gt;is_loaded() &amp;&amp; retType-&gt;is_subtype_of(iter)) {</span>
<span class="line-added">102     return true;</span>
<span class="line-added">103   }</span>
104   return false;
105 }
106 
107 /**
108  *  Force inlining unboxing accessor.
109  */
110 static bool is_unboxing_method(ciMethod* callee_method, Compile* C) {
111   return C-&gt;eliminate_boxing() &amp;&amp; callee_method-&gt;is_unboxing_method();
112 }
113 
114 // positive filter: should callee be inlined?
115 bool InlineTree::should_inline(ciMethod* callee_method, ciMethod* caller_method,
116                                int caller_bci, ciCallProfile&amp; profile,
117                                WarmCallInfo* wci_result) {
118   // Allows targeted inlining
119   if (C-&gt;directive()-&gt;should_inline(callee_method)) {
120     *wci_result = *(WarmCallInfo::always_hot());
121     if (C-&gt;print_inlining() &amp;&amp; Verbose) {
122       CompileTask::print_inline_indent(inline_level());
123       tty-&gt;print_cr(&quot;Inlined method is hot: &quot;);
</pre>
<hr />
<pre>
192     if (max_inline_size &gt; default_max_inline_size) {
193       set_msg(&quot;hot method too big&quot;);
194     } else {
195       set_msg(&quot;too big&quot;);
196     }
197     return false;
198   }
199   return true;
200 }
201 
202 
203 // negative filter: should callee NOT be inlined?
204 bool InlineTree::should_not_inline(ciMethod *callee_method,
205                                    ciMethod* caller_method,
206                                    JVMState* jvms,
207                                    WarmCallInfo* wci_result) {
208 
209   const char* fail_msg = NULL;
210 
211   // First check all inlining restrictions which are required for correctness
<span class="line-modified">212   if (callee_method-&gt;is_abstract()) {</span>
213     fail_msg = &quot;abstract method&quot;; // // note: we allow ik-&gt;is_abstract()
214   } else if (!callee_method-&gt;holder()-&gt;is_initialized() &amp;&amp;
215              // access allowed in the context of static initializer
<span class="line-modified">216              C-&gt;needs_clinit_barrier(callee_method-&gt;holder(), caller_method)) {</span>
217     fail_msg = &quot;method holder not initialized&quot;;
<span class="line-modified">218   } else if (callee_method-&gt;is_native()) {</span>
219     fail_msg = &quot;native method&quot;;
<span class="line-modified">220   } else if (callee_method-&gt;dont_inline()) {</span>
221     fail_msg = &quot;don&#39;t inline by annotation&quot;;
222   }
223 
224   // one more inlining restriction
225   if (fail_msg == NULL &amp;&amp; callee_method-&gt;has_unloaded_classes_in_signature()) {
226     fail_msg = &quot;unloaded signature classes&quot;;
227   }
228 
229   if (fail_msg != NULL) {
230     set_msg(fail_msg);
231     return true;
232   }
233 
234   // ignore heuristic controls on inlining
235   if (C-&gt;directive()-&gt;should_inline(callee_method)) {
236     set_msg(&quot;force inline by CompileCommand&quot;);
237     return false;
238   }
239 
240   if (C-&gt;directive()-&gt;should_not_inline(callee_method)) {
</pre>
<hr />
<pre>
311       return false;
312     } else {
313       intx counter_high_value;
314       // Tiered compilation uses a different &quot;high value&quot; than non-tiered compilation.
315       // Determine the right value to use.
316       if (TieredCompilation) {
317         counter_high_value = InvocationCounter::count_limit / 2;
318       } else {
319         counter_high_value = CompileThreshold / 2;
320       }
321       if (!callee_method-&gt;was_executed_more_than(MIN2(MinInliningThreshold, counter_high_value))) {
322         set_msg(&quot;executed &lt; MinInliningThreshold times&quot;);
323         return true;
324       }
325     }
326   }
327 
328   return false;
329 }
330 
<span class="line-added">331 bool InlineTree::is_not_reached(ciMethod* callee_method, ciMethod* caller_method, int caller_bci, ciCallProfile&amp; profile) {</span>
<span class="line-added">332   if (!UseInterpreter) {</span>
<span class="line-added">333     return false; // -Xcomp</span>
<span class="line-added">334   }</span>
<span class="line-added">335   if (profile.count() &gt; 0) {</span>
<span class="line-added">336     return false; // reachable according to profile</span>
<span class="line-added">337   }</span>
<span class="line-added">338   if (!callee_method-&gt;was_executed_more_than(0)) {</span>
<span class="line-added">339     return true; // callee was never executed</span>
<span class="line-added">340   }</span>
<span class="line-added">341   if (caller_method-&gt;is_not_reached(caller_bci)) {</span>
<span class="line-added">342     return true; // call site not resolved</span>
<span class="line-added">343   }</span>
<span class="line-added">344   if (profile.count() == -1) {</span>
<span class="line-added">345     return false; // immature profile; optimistically treat as reached</span>
<span class="line-added">346   }</span>
<span class="line-added">347   assert(profile.count() == 0, &quot;sanity&quot;);</span>
<span class="line-added">348 </span>
<span class="line-added">349   // Profile info is scarce.</span>
<span class="line-added">350   // Try to guess: check if the call site belongs to a start block.</span>
<span class="line-added">351   // Call sites in a start block should be reachable if no exception is thrown earlier.</span>
<span class="line-added">352   ciMethodBlocks* caller_blocks = caller_method-&gt;get_method_blocks();</span>
<span class="line-added">353   bool is_start_block = caller_blocks-&gt;block_containing(caller_bci)-&gt;start_bci() == 0;</span>
<span class="line-added">354   if (is_start_block) {</span>
<span class="line-added">355     return false; // treat the call reached as part of start block</span>
<span class="line-added">356   }</span>
<span class="line-added">357   return true; // give up and treat the call site as not reached</span>
<span class="line-added">358 }</span>
<span class="line-added">359 </span>
360 //-----------------------------try_to_inline-----------------------------------
361 // return true if ok
362 // Relocated from &quot;InliningClosure::try_to_inline&quot;
363 bool InlineTree::try_to_inline(ciMethod* callee_method, ciMethod* caller_method,
364                                int caller_bci, JVMState* jvms, ciCallProfile&amp; profile,
365                                WarmCallInfo* wci_result, bool&amp; should_delay) {
366 
367   if (ClipInlining &amp;&amp; (int)count_inline_bcs() &gt;= DesiredMethodLimit) {
368     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
369       set_msg(&quot;size &gt; DesiredMethodLimit&quot;);
370       return false;
371     } else if (!C-&gt;inlining_incrementally()) {
372       should_delay = true;
373     }
374   }
375 
376   _forced_inline = false; // Reset
377   if (!should_inline(callee_method, caller_method, caller_bci, profile,
378                      wci_result)) {
379     return false;
</pre>
<hr />
<pre>
391   // suppress a few checks for accessors and trivial methods
392   if (callee_method-&gt;code_size() &gt; MaxTrivialSize) {
393 
394     // don&#39;t inline into giant methods
395     if (C-&gt;over_inlining_cutoff()) {
396       if ((!callee_method-&gt;force_inline() &amp;&amp; !caller_method-&gt;is_compiled_lambda_form())
397           || !IncrementalInline) {
398         set_msg(&quot;NodeCountInliningCutoff&quot;);
399         return false;
400       } else {
401         should_delay = true;
402       }
403     }
404 
405     if (!UseInterpreter &amp;&amp;
406         is_init_with_ea(callee_method, caller_method, C)) {
407       // Escape Analysis stress testing when running Xcomp:
408       // inline constructors even if they are not reached.
409     } else if (forced_inline()) {
410       // Inlining was forced by CompilerOracle, ciReplay or annotation
<span class="line-modified">411     } else if (is_not_reached(callee_method, caller_method, caller_bci, profile)) {</span>
412       // don&#39;t inline unreached call sites
413        set_msg(&quot;call site not reached&quot;);
414        return false;
415     }
416   }
417 
418   if (!C-&gt;do_inlining() &amp;&amp; InlineAccessors) {
419     set_msg(&quot;not an accessor&quot;);
420     return false;
421   }
422 
423   // Limit inlining depth in case inlining is forced or
424   // _max_inline_level was increased to compensate for lambda forms.
425   if (inline_level() &gt; MaxForceInlineLevel) {
426     set_msg(&quot;MaxForceInlineLevel&quot;);
427     return false;
428   }
429   if (inline_level() &gt; _max_inline_level) {
430     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
431       set_msg(&quot;inlining too deep&quot;);
</pre>
<hr />
<pre>
468     }
469   }
470 
471   int size = callee_method-&gt;code_size_for_inlining();
472 
473   if (ClipInlining &amp;&amp; (int)count_inline_bcs() + size &gt;= DesiredMethodLimit) {
474     if (!callee_method-&gt;force_inline() || !IncrementalInline) {
475       set_msg(&quot;size &gt; DesiredMethodLimit&quot;);
476       return false;
477     } else if (!C-&gt;inlining_incrementally()) {
478       should_delay = true;
479     }
480   }
481 
482   // ok, inline this method
483   return true;
484 }
485 
486 //------------------------------pass_initial_checks----------------------------
487 bool InlineTree::pass_initial_checks(ciMethod* caller_method, int caller_bci, ciMethod* callee_method) {

488   // Check if a callee_method was suggested
<span class="line-modified">489   if (callee_method == NULL) {</span>
<span class="line-added">490     return false;</span>
<span class="line-added">491   }</span>
<span class="line-added">492   ciInstanceKlass *callee_holder = callee_method-&gt;holder();</span>
493   // Check if klass of callee_method is loaded
<span class="line-modified">494   if (!callee_holder-&gt;is_loaded()) {</span>
<span class="line-modified">495     return false;</span>
<span class="line-added">496   }</span>
<span class="line-added">497   if (!callee_holder-&gt;is_initialized() &amp;&amp;</span>
498       // access allowed in the context of static initializer
<span class="line-modified">499       C-&gt;needs_clinit_barrier(callee_holder, caller_method)) {</span>
500     return false;
501   }
502   if( !UseInterpreter ) /* running Xcomp */ {
503     // Checks that constant pool&#39;s call site has been visited
504     // stricter than callee_holder-&gt;is_initialized()
505     ciBytecodeStream iter(caller_method);
506     iter.force_bci(caller_bci);
507     Bytecodes::Code call_bc = iter.cur_bc();
508     // An invokedynamic instruction does not have a klass.
509     if (call_bc != Bytecodes::_invokedynamic) {
510       int index = iter.get_index_u2_cpcache();
511       if (!caller_method-&gt;is_klass_loaded(index, true)) {
512         return false;
513       }
514       // Try to do constant pool resolution if running Xcomp
515       if( !caller_method-&gt;check_call(index, call_bc == Bytecodes::_invokestatic) ) {
516         return false;
517       }
518     }
519   }
</pre>
</td>
</tr>
</table>
<center><a href="buildOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
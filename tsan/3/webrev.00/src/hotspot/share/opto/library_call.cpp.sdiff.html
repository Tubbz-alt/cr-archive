<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="lcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="live.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;

  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;opto/addnode.hpp&quot;
  37 #include &quot;opto/arraycopynode.hpp&quot;
  38 #include &quot;opto/c2compiler.hpp&quot;
  39 #include &quot;opto/callGenerator.hpp&quot;
  40 #include &quot;opto/castnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/convertnode.hpp&quot;
  43 #include &quot;opto/countbitsnode.hpp&quot;
  44 #include &quot;opto/intrinsicnode.hpp&quot;
  45 #include &quot;opto/idealKit.hpp&quot;
  46 #include &quot;opto/mathexactnode.hpp&quot;
  47 #include &quot;opto/movenode.hpp&quot;
  48 #include &quot;opto/mulnode.hpp&quot;
  49 #include &quot;opto/narrowptrnode.hpp&quot;
  50 #include &quot;opto/opaquenode.hpp&quot;
  51 #include &quot;opto/parse.hpp&quot;
  52 #include &quot;opto/runtime.hpp&quot;
  53 #include &quot;opto/rootnode.hpp&quot;
  54 #include &quot;opto/subnode.hpp&quot;
  55 #include &quot;prims/nativeLookup.hpp&quot;
  56 #include &quot;prims/unsafe.hpp&quot;
  57 #include &quot;runtime/objectMonitor.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  60 </span>
  61 
  62 class LibraryIntrinsic : public InlineCallGenerator {
  63   // Extend the set of intrinsics known to the runtime:
  64  public:
  65  private:
  66   bool             _is_virtual;
  67   bool             _does_virtual_dispatch;
  68   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  69   int8_t           _last_predicate; // Last generated predicate
  70   vmIntrinsics::ID _intrinsic_id;
  71 
  72  public:
  73   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  74     : InlineCallGenerator(m),
  75       _is_virtual(is_virtual),
  76       _does_virtual_dispatch(does_virtual_dispatch),
  77       _predicates_count((int8_t)predicates_count),
  78       _last_predicate((int8_t)-1),
  79       _intrinsic_id(id)
  80   {
</pre>
<hr />
<pre>
 210   }
 211   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 212   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 213 
 214   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 215   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 216   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 217   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 218   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 219                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 220   bool inline_string_indexOfChar();
 221   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 222   bool inline_string_toBytesU();
 223   bool inline_string_getCharsU();
 224   bool inline_string_copy(bool compress);
 225   bool inline_string_char_access(bool is_store);
 226   Node* round_double_node(Node* n);
 227   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 228   bool inline_math_native(vmIntrinsics::ID id);
 229   bool inline_math(vmIntrinsics::ID id);

 230   template &lt;typename OverflowOp&gt;
 231   bool inline_math_overflow(Node* arg1, Node* arg2);
 232   void inline_math_mathExact(Node* math, Node* test);
 233   bool inline_math_addExactI(bool is_increment);
 234   bool inline_math_addExactL(bool is_increment);
 235   bool inline_math_multiplyExactI();
 236   bool inline_math_multiplyExactL();
 237   bool inline_math_multiplyHigh();
 238   bool inline_math_negateExactI();
 239   bool inline_math_negateExactL();
 240   bool inline_math_subtractExactI(bool is_decrement);
 241   bool inline_math_subtractExactL(bool is_decrement);
 242   bool inline_min_max(vmIntrinsics::ID id);
 243   bool inline_notify(vmIntrinsics::ID id);
 244   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 245   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 246   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 247   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 248 
 249   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 250   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 251   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 252   static bool klass_needs_init_guard(Node* kls);
 253   bool inline_unsafe_allocate();
 254   bool inline_unsafe_newArray(bool uninitialized);


 255   bool inline_unsafe_copyMemory();
 256   bool inline_native_currentThread();
 257 
 258   bool inline_native_time_funcs(address method, const char* funcName);
 259 #ifdef JFR_HAVE_INTRINSICS
 260   bool inline_native_classID();
 261   bool inline_native_getEventWriter();
 262 #endif
<span class="line-removed"> 263   bool inline_native_isInterrupted();</span>
 264   bool inline_native_Class_query(vmIntrinsics::ID id);
 265   bool inline_native_subtype_check();
 266   bool inline_native_getLength();
 267   bool inline_array_copyOf(bool is_copyOfRange);
 268   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 269   bool inline_preconditions_checkIndex();
 270   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 271   bool inline_native_clone(bool is_virtual);
 272   bool inline_native_Reflection_getCallerClass();
 273   // Helper function for inlining native object hash method
 274   bool inline_native_hashcode(bool is_virtual, bool is_static);
 275   bool inline_native_getClass();
 276 
 277   // Helper functions for inlining arraycopy
 278   bool inline_arraycopy();
 279   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 280                                                 RegionNode* slow_region);
 281   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 282   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 283                                       uint new_idx);
 284 
 285   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 286   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 287   bool inline_unsafe_fence(vmIntrinsics::ID id);
 288   bool inline_onspinwait();
 289   bool inline_fp_conversions(vmIntrinsics::ID id);
 290   bool inline_number_methods(vmIntrinsics::ID id);
 291   bool inline_reference_get();
 292   bool inline_Class_cast();
 293   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 294   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);

 295   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 296   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);

 297   Node* inline_counterMode_AESCrypt_predicate();
 298   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 299   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 300   bool inline_ghash_processBlocks();
 301   bool inline_base64_encodeBlock();
 302   bool inline_sha_implCompress(vmIntrinsics::ID id);
 303   bool inline_digestBase_implCompressMB(int predicate);
 304   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 305                                  bool long_state, address stubAddr, const char *stubName,
 306                                  Node* src_start, Node* ofs, Node* limit);
 307   Node* get_state_from_sha_object(Node *sha_object);
 308   Node* get_state_from_sha5_object(Node *sha_object);
 309   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 310   bool inline_encodeISOArray();
 311   bool inline_updateCRC32();
 312   bool inline_updateBytesCRC32();
 313   bool inline_updateByteBufferCRC32();
 314   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 315   bool inline_updateBytesCRC32C();
 316   bool inline_updateDirectByteBufferCRC32C();
 317   bool inline_updateBytesAdler32();
 318   bool inline_updateByteBufferAdler32();
 319   bool inline_multiplyToLen();
 320   bool inline_hasNegatives();
 321   bool inline_squareToLen();
 322   bool inline_mulAdd();
 323   bool inline_montgomeryMultiply();
 324   bool inline_montgomerySquare();

 325   bool inline_vectorizedMismatch();
 326   bool inline_fma(vmIntrinsics::ID id);
 327   bool inline_character_compare(vmIntrinsics::ID id);
 328   bool inline_fp_min_max(vmIntrinsics::ID id);
 329 
 330   bool inline_profileBoolean();
 331   bool inline_isCompileConstant();
 332   void clear_upper_avx() {
 333 #ifdef X86
 334     if (UseAVX &gt;= 2) {
 335       C-&gt;set_clear_upper_avx(true);
 336     }
 337 #endif
 338   }
 339 };
 340 
 341 //---------------------------make_vm_intrinsic----------------------------
 342 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 343   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 344   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
</pre>
<hr />
<pre>
 512   // Handle symbolic names for otherwise undistinguished boolean switches:
 513   const bool is_store       = true;
 514   const bool is_compress    = true;
 515   const bool is_static      = true;
 516   const bool is_volatile    = true;
 517 
 518   if (!jvms()-&gt;has_method()) {
 519     // Root JVMState has a null method.
 520     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 521     // Insert the memory aliasing node
 522     set_all_memory(reset_memory());
 523   }
 524   assert(merged_memory(), &quot;&quot;);
 525 
 526 
 527   switch (intrinsic_id()) {
 528   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 529   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 530   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 531 



 532   case vmIntrinsics::_dsin:
 533   case vmIntrinsics::_dcos:
 534   case vmIntrinsics::_dtan:
 535   case vmIntrinsics::_dabs:



 536   case vmIntrinsics::_datan2:
 537   case vmIntrinsics::_dsqrt:
 538   case vmIntrinsics::_dexp:
 539   case vmIntrinsics::_dlog:
 540   case vmIntrinsics::_dlog10:
 541   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 542 
 543   case vmIntrinsics::_min:
 544   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 545 
 546   case vmIntrinsics::_notify:
 547   case vmIntrinsics::_notifyAll:
 548     return inline_notify(intrinsic_id());
 549 
 550   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 551   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 552   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 553   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 554   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 555   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
</pre>
<hr />
<pre>
 723   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 724 
 725   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 726   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 727   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 728   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 729 
 730   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 731   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 732   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 733   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 734   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 735 
 736   case vmIntrinsics::_loadFence:
 737   case vmIntrinsics::_storeFence:
 738   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 739 
 740   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 741 
 742   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
<span class="line-removed"> 743   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();</span>
 744 
 745 #ifdef JFR_HAVE_INTRINSICS
 746   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 747   case vmIntrinsics::_getClassId:               return inline_native_classID();
 748   case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 749 #endif
 750   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 751   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);



 752   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 753   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 754   case vmIntrinsics::_getLength:                return inline_native_getLength();
 755   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 756   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 757   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 758   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 759   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 760   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 761 
 762   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 763   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 764 
 765   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 766 
 767   case vmIntrinsics::_isInstance:
 768   case vmIntrinsics::_getModifiers:
 769   case vmIntrinsics::_isInterface:
 770   case vmIntrinsics::_isArray:
 771   case vmIntrinsics::_isPrimitive:
</pre>
<hr />
<pre>
 786   case vmIntrinsics::_bitCount_i:
 787   case vmIntrinsics::_bitCount_l:
 788   case vmIntrinsics::_reverseBytes_i:
 789   case vmIntrinsics::_reverseBytes_l:
 790   case vmIntrinsics::_reverseBytes_s:
 791   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 792 
 793   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 794 
 795   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 796 
 797   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 798 
 799   case vmIntrinsics::_aescrypt_encryptBlock:
 800   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 801 
 802   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 803   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 804     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 805 




 806   case vmIntrinsics::_counterMode_AESCrypt:
 807     return inline_counterMode_AESCrypt(intrinsic_id());
 808 
 809   case vmIntrinsics::_sha_implCompress:
 810   case vmIntrinsics::_sha2_implCompress:
 811   case vmIntrinsics::_sha5_implCompress:
 812     return inline_sha_implCompress(intrinsic_id());
 813 
 814   case vmIntrinsics::_digestBase_implCompressMB:
 815     return inline_digestBase_implCompressMB(predicate);
 816 
 817   case vmIntrinsics::_multiplyToLen:
 818     return inline_multiplyToLen();
 819 
 820   case vmIntrinsics::_squareToLen:
 821     return inline_squareToLen();
 822 
 823   case vmIntrinsics::_mulAdd:
 824     return inline_mulAdd();
 825 
 826   case vmIntrinsics::_montgomeryMultiply:
 827     return inline_montgomeryMultiply();
 828   case vmIntrinsics::_montgomerySquare:
 829     return inline_montgomerySquare();
 830 





 831   case vmIntrinsics::_vectorizedMismatch:
 832     return inline_vectorizedMismatch();
 833 
 834   case vmIntrinsics::_ghash_processBlocks:
 835     return inline_ghash_processBlocks();
 836   case vmIntrinsics::_base64_encodeBlock:
 837     return inline_base64_encodeBlock();
 838 
 839   case vmIntrinsics::_encodeISOArray:
 840   case vmIntrinsics::_encodeByteISOArray:
 841     return inline_encodeISOArray();
 842 
 843   case vmIntrinsics::_updateCRC32:
 844     return inline_updateCRC32();
 845   case vmIntrinsics::_updateBytesCRC32:
 846     return inline_updateBytesCRC32();
 847   case vmIntrinsics::_updateByteBufferCRC32:
 848     return inline_updateByteBufferCRC32();
 849 
 850   case vmIntrinsics::_updateBytesCRC32C:
</pre>
<hr />
<pre>
 891     }
 892 #endif
 893     return false;
 894   }
 895 }
 896 
 897 Node* LibraryCallKit::try_to_predicate(int predicate) {
 898   if (!jvms()-&gt;has_method()) {
 899     // Root JVMState has a null method.
 900     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 901     // Insert the memory aliasing node
 902     set_all_memory(reset_memory());
 903   }
 904   assert(merged_memory(), &quot;&quot;);
 905 
 906   switch (intrinsic_id()) {
 907   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 908     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 909   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 910     return inline_cipherBlockChaining_AESCrypt_predicate(true);




 911   case vmIntrinsics::_counterMode_AESCrypt:
 912     return inline_counterMode_AESCrypt_predicate();
 913   case vmIntrinsics::_digestBase_implCompressMB:
 914     return inline_digestBase_implCompressMB_predicate(predicate);
 915 
 916   default:
 917     // If you get here, it may be that someone has added a new intrinsic
 918     // to the list in vmSymbols.hpp without implementing it here.
 919 #ifndef PRODUCT
 920     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 921       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 922                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 923     }
 924 #endif
 925     Node* slow_ctl = control();
 926     set_control(top()); // No fast path instrinsic
 927     return slow_ctl;
 928   }
 929 }
 930 
</pre>
<hr />
<pre>
1049   // Offset and count must not be negative
1050   generate_negative_guard(offset, bailout);
1051   generate_negative_guard(count, bailout);
1052   // Offset + count must not exceed length of array
1053   generate_limit_guard(offset, count, load_array_length(array), bailout);
1054 
1055   if (bailout-&gt;req() &gt; 1) {
1056     PreserveJVMState pjvms(this);
1057     set_control(_gvn.transform(bailout));
1058     uncommon_trap(Deoptimization::Reason_intrinsic,
1059                   Deoptimization::Action_maybe_recompile);
1060   }
1061 }
1062 
1063 //--------------------------generate_current_thread--------------------
1064 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1065   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1066   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1067   Node* thread = _gvn.transform(new ThreadLocalNode());
1068   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
<span class="line-modified">1069   Node* threadObj = make_load(NULL, p, thread_type, T_OBJECT, MemNode::unordered);</span>
1070   tls_output = thread;
1071   return threadObj;
1072 }
1073 
1074 
1075 //------------------------------make_string_method_node------------------------
1076 // Helper method for String intrinsic functions. This version is called with
1077 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1078 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1079 // containing the lengths of str1 and str2.
1080 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1081   Node* result = NULL;
1082   switch (opcode) {
1083   case Op_StrIndexOf:
1084     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1085                                 str1_start, cnt1, str2_start, cnt2, ae);
1086     break;
1087   case Op_StrComp:
1088     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1089                              str1_start, cnt1, str2_start, cnt2, ae);
</pre>
<hr />
<pre>
1097   default:
1098     ShouldNotReachHere();
1099     return NULL;
1100   }
1101 
1102   // All these intrinsics have checks.
1103   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1104   clear_upper_avx();
1105 
1106   return _gvn.transform(result);
1107 }
1108 
1109 //------------------------------inline_string_compareTo------------------------
1110 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1111   Node* arg1 = argument(0);
1112   Node* arg2 = argument(1);
1113 
1114   arg1 = must_be_not_null(arg1, true);
1115   arg2 = must_be_not_null(arg2, true);
1116 
<span class="line-removed">1117   arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="line-removed">1118   arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="line-removed">1119 </span>
1120   // Get start addr and length of first argument
1121   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1122   Node* arg1_cnt    = load_array_length(arg1);
1123 
1124   // Get start addr and length of second argument
1125   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1126   Node* arg2_cnt    = load_array_length(arg2);
1127 
1128   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1129   set_result(result);
1130   return true;
1131 }
1132 
1133 //------------------------------inline_string_equals------------------------
1134 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1135   Node* arg1 = argument(0);
1136   Node* arg2 = argument(1);
1137 
1138   // paths (plus control) merge
1139   RegionNode* region = new RegionNode(3);
1140   Node* phi = new PhiNode(region, TypeInt::BOOL);
1141 
1142   if (!stopped()) {
1143 
1144     arg1 = must_be_not_null(arg1, true);
1145     arg2 = must_be_not_null(arg2, true);
1146 
<span class="line-removed">1147     arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="line-removed">1148     arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="line-removed">1149 </span>
1150     // Get start addr and length of first argument
1151     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1152     Node* arg1_cnt    = load_array_length(arg1);
1153 
1154     // Get start addr and length of second argument
1155     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1156     Node* arg2_cnt    = load_array_length(arg2);
1157 
1158     // Check for arg1_cnt != arg2_cnt
1159     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1160     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1161     Node* if_ne = generate_slow_guard(bol, NULL);
1162     if (if_ne != NULL) {
1163       phi-&gt;init_req(2, intcon(0));
1164       region-&gt;init_req(2, if_ne);
1165     }
1166 
1167     // Check for count == 0 is done by assembler code for StrEquals.
1168 
1169     if (!stopped()) {
1170       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1171       phi-&gt;init_req(1, equals);
1172       region-&gt;init_req(1, control());
1173     }
1174   }
1175 
1176   // post merge
1177   set_control(_gvn.transform(region));
1178   record_for_igvn(region);
1179 
1180   set_result(_gvn.transform(phi));
1181   return true;
1182 }
1183 
1184 //------------------------------inline_array_equals----------------------------
1185 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1186   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1187   Node* arg1 = argument(0);
1188   Node* arg2 = argument(1);
1189 
<span class="line-removed">1190   arg1 = access_resolve(arg1, ACCESS_READ);</span>
<span class="line-removed">1191   arg2 = access_resolve(arg2, ACCESS_READ);</span>
<span class="line-removed">1192 </span>
1193   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1194   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1195   clear_upper_avx();
1196 
1197   return true;
1198 }
1199 
1200 //------------------------------inline_hasNegatives------------------------------
1201 bool LibraryCallKit::inline_hasNegatives() {
1202   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1203     return false;
1204   }
1205 
1206   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1207   // no receiver since it is static method
1208   Node* ba         = argument(0);
1209   Node* offset     = argument(1);
1210   Node* len        = argument(2);
1211 
1212   ba = must_be_not_null(ba, true);
1213 
1214   // Range checks
1215   generate_string_range_check(ba, offset, len, false);
1216   if (stopped()) {
1217     return true;
1218   }
<span class="line-removed">1219   ba = access_resolve(ba, ACCESS_READ);</span>
1220   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1221   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1222   set_result(_gvn.transform(result));
1223   return true;
1224 }
1225 
1226 bool LibraryCallKit::inline_preconditions_checkIndex() {
1227   Node* index = argument(0);
1228   Node* length = argument(1);
1229   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1230     return false;
1231   }
1232 
1233   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1234   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1235 
1236   {
1237     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1238     uncommon_trap(Deoptimization::Reason_intrinsic,
1239                   Deoptimization::Action_make_not_entrant);
</pre>
<hr />
<pre>
1270   replace_in_map(index, result);
1271   clear_upper_avx();
1272   return true;
1273 }
1274 
1275 //------------------------------inline_string_indexOf------------------------
1276 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1277   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1278     return false;
1279   }
1280   Node* src = argument(0);
1281   Node* tgt = argument(1);
1282 
1283   // Make the merge point
1284   RegionNode* result_rgn = new RegionNode(4);
1285   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1286 
1287   src = must_be_not_null(src, true);
1288   tgt = must_be_not_null(tgt, true);
1289 
<span class="line-removed">1290   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">1291   tgt = access_resolve(tgt, ACCESS_READ);</span>
<span class="line-removed">1292 </span>
1293   // Get start addr and length of source string
1294   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1295   Node* src_count = load_array_length(src);
1296 
1297   // Get start addr and length of substring
1298   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1299   Node* tgt_count = load_array_length(tgt);
1300 
1301   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1302     // Divide src size by 2 if String is UTF16 encoded
1303     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1304   }
1305   if (ae == StrIntrinsicNode::UU) {
1306     // Divide substring size by 2 if String is UTF16 encoded
1307     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1308   }
1309 
1310   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1311   if (result != NULL) {
1312     result_phi-&gt;init_req(3, result);
</pre>
<hr />
<pre>
1320 }
1321 
1322 //-----------------------------inline_string_indexOf-----------------------
1323 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1324   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1325     return false;
1326   }
1327   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1328     return false;
1329   }
1330   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1331   Node* src         = argument(0); // byte[]
1332   Node* src_count   = argument(1); // char count
1333   Node* tgt         = argument(2); // byte[]
1334   Node* tgt_count   = argument(3); // char count
1335   Node* from_index  = argument(4); // char index
1336 
1337   src = must_be_not_null(src, true);
1338   tgt = must_be_not_null(tgt, true);
1339 
<span class="line-removed">1340   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">1341   tgt = access_resolve(tgt, ACCESS_READ);</span>
<span class="line-removed">1342 </span>
1343   // Multiply byte array index by 2 if String is UTF16 encoded
1344   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1345   src_count = _gvn.transform(new SubINode(src_count, from_index));
1346   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1347   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1348 
1349   // Range checks
1350   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1351   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1352   if (stopped()) {
1353     return true;
1354   }
1355 
1356   RegionNode* region = new RegionNode(5);
1357   Node* phi = new PhiNode(region, TypeInt::INT);
1358 
1359   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1360   if (result != NULL) {
1361     // The result is index relative to from_index if substring was found, -1 otherwise.
1362     // Generate code which will fold into cmove.
</pre>
<hr />
<pre>
1409     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1410   }
1411   return NULL;
1412 }
1413 
1414 //-----------------------------inline_string_indexOfChar-----------------------
1415 bool LibraryCallKit::inline_string_indexOfChar() {
1416   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1417     return false;
1418   }
1419   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1420     return false;
1421   }
1422   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1423   Node* src         = argument(0); // byte[]
1424   Node* tgt         = argument(1); // tgt is int ch
1425   Node* from_index  = argument(2);
1426   Node* max         = argument(3);
1427 
1428   src = must_be_not_null(src, true);
<span class="line-removed">1429   src = access_resolve(src, ACCESS_READ);</span>
1430 
1431   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1432   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1433   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1434 
1435   // Range checks
1436   generate_string_range_check(src, src_offset, src_count, true);
1437   if (stopped()) {
1438     return true;
1439   }
1440 
1441   RegionNode* region = new RegionNode(3);
1442   Node* phi = new PhiNode(region, TypeInt::INT);
1443 
1444   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1445   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1446   _gvn.transform(result);
1447 
1448   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1449   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
</pre>
<hr />
<pre>
1500 
1501   src = must_be_not_null(src, true);
1502   dst = must_be_not_null(dst, true);
1503 
1504   // Convert char[] offsets to byte[] offsets
1505   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1506   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1507   if (convert_src) {
1508     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1509   } else if (convert_dst) {
1510     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1511   }
1512 
1513   // Range checks
1514   generate_string_range_check(src, src_offset, length, convert_src);
1515   generate_string_range_check(dst, dst_offset, length, convert_dst);
1516   if (stopped()) {
1517     return true;
1518   }
1519 
<span class="line-removed">1520   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">1521   dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="line-removed">1522 </span>
1523   Node* src_start = array_element_address(src, src_offset, src_elem);
1524   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1525   // &#39;src_start&#39; points to src array + scaled offset
1526   // &#39;dst_start&#39; points to dst array + scaled offset
1527   Node* count = NULL;
1528   if (compress) {
1529     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1530   } else {
1531     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1532   }
1533 
1534   if (alloc != NULL) {
1535     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1536       // &quot;You break it, you buy it.&quot;
1537       InitializeNode* init = alloc-&gt;initialization();
1538       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1539       init-&gt;set_complete_with_arraycopy();
1540       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1541       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1542     }
</pre>
<hr />
<pre>
1593     generate_limit_guard(offset, length, load_array_length(value), bailout);
1594     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1595     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1596 
1597     if (bailout-&gt;req() &gt; 1) {
1598       PreserveJVMState pjvms(this);
1599       set_control(_gvn.transform(bailout));
1600       uncommon_trap(Deoptimization::Reason_intrinsic,
1601                     Deoptimization::Action_maybe_recompile);
1602     }
1603     if (stopped()) {
1604       return true;
1605     }
1606 
1607     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1608     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1609     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1610     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1611 
1612     // Calculate starting addresses.
<span class="line-removed">1613     value = access_resolve(value, ACCESS_READ);</span>
1614     Node* src_start = array_element_address(value, offset, T_CHAR);
1615     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1616 
1617     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1618     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1619     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1620 
1621     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1622     const char* copyfunc_name = &quot;arraycopy&quot;;
1623     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1624     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1625                       OptoRuntime::fast_arraycopy_Type(),
1626                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1627                       src_start, dst_start, ConvI2X(length) XTOP);
1628     // Do not let reads from the cloned object float above the arraycopy.
1629     if (alloc != NULL) {
1630       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1631         // &quot;You break it, you buy it.&quot;
1632         InitializeNode* init = alloc-&gt;initialization();
1633         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
</pre>
<hr />
<pre>
1677 
1678   // Check if a null path was taken unconditionally.
1679   src = null_check(src);
1680   dst = null_check(dst);
1681   if (stopped()) {
1682     return true;
1683   }
1684 
1685   // Get length and convert char[] offset to byte[] offset
1686   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1687   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1688 
1689   // Range checks
1690   generate_string_range_check(src, src_begin, length, true);
1691   generate_string_range_check(dst, dst_begin, length, false);
1692   if (stopped()) {
1693     return true;
1694   }
1695 
1696   if (!stopped()) {
<span class="line-removed">1697     src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">1698     dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="line-removed">1699 </span>
1700     // Calculate starting addresses.
1701     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1702     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1703 
1704     // Check if array addresses are aligned to HeapWordSize
1705     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1706     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1707     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1708                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1709 
1710     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1711     const char* copyfunc_name = &quot;arraycopy&quot;;
1712     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1713     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1714                       OptoRuntime::fast_arraycopy_Type(),
1715                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1716                       src_start, dst_start, ConvI2X(length) XTOP);
1717     // Do not let reads from the cloned object float above the arraycopy.
1718     if (alloc != NULL) {
1719       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
</pre>
<hr />
<pre>
1748 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1749   Node* value  = argument(0);
1750   Node* index  = argument(1);
1751   Node* ch = is_store ? argument(2) : NULL;
1752 
1753   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1754   // correctly requires matched array shapes.
1755   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1756           &quot;sanity: byte[] and char[] bases agree&quot;);
1757   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1758           &quot;sanity: byte[] and char[] scales agree&quot;);
1759 
1760   // Bail when getChar over constants is requested: constant folding would
1761   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1762   // Java method would constant fold nicely instead.
1763   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1764     return false;
1765   }
1766 
1767   value = must_be_not_null(value, true);
<span class="line-removed">1768   value = access_resolve(value, is_store ? ACCESS_WRITE : ACCESS_READ);</span>
1769 
1770   Node* adr = array_element_address(value, index, T_CHAR);
1771   if (adr-&gt;is_top()) {
1772     return false;
1773   }
1774   if (is_store) {
1775     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1776   } else {
1777     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1778     set_result(ch);
1779   }
1780   return true;
1781 }
1782 
1783 //--------------------------round_double_node--------------------------------
1784 // Round a double node if necessary.
1785 Node* LibraryCallKit::round_double_node(Node* n) {
<span class="line-modified">1786   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt;= 1)</span>
<span class="line-modified">1787     n = _gvn.transform(new RoundDoubleNode(0, n));</span>







1788   return n;
1789 }
1790 
1791 //------------------------------inline_math-----------------------------------
1792 // public static double Math.abs(double)
1793 // public static double Math.sqrt(double)
1794 // public static double Math.log(double)
1795 // public static double Math.log10(double)
<span class="line-modified">1796 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {</span>
1797   Node* arg = round_double_node(argument(0));
1798   Node* n = NULL;
1799   switch (id) {
1800   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1801   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;




















1802   default:  fatal_unexpected_iid(id);  break;
1803   }
1804   set_result(_gvn.transform(n));
1805   return true;
1806 }
1807 
1808 //------------------------------runtime_math-----------------------------
1809 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1810   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1811          &quot;must be (DD)D or (D)D type&quot;);
1812 
1813   // Inputs
1814   Node* a = round_double_node(argument(0));
1815   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1816 
1817   const TypePtr* no_memory_effects = NULL;
1818   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1819                                  no_memory_effects,
1820                                  a, top(), b, b ? top() : NULL);
1821   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
</pre>
<hr />
<pre>
1838       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1839       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1840   case vmIntrinsics::_dcos:
1841     return StubRoutines::dcos() != NULL ?
1842       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1843       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1844   case vmIntrinsics::_dtan:
1845     return StubRoutines::dtan() != NULL ?
1846       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1847       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1848   case vmIntrinsics::_dlog:
1849     return StubRoutines::dlog() != NULL ?
1850       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1851       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1852   case vmIntrinsics::_dlog10:
1853     return StubRoutines::dlog10() != NULL ?
1854       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1855       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1856 
1857     // These intrinsics are supported on all hardware
<span class="line-modified">1858   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_math(id) : false;</span>
<span class="line-modified">1859   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_math(id) : false;</span>






1860 
1861   case vmIntrinsics::_dexp:
1862     return StubRoutines::dexp() != NULL ?
1863       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1864       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1865   case vmIntrinsics::_dpow: {
1866     Node* exp = round_double_node(argument(2));
1867     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1868     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1869       // Special case: pow(x, 2.0) =&gt; x * x
1870       Node* base = round_double_node(argument(0));
1871       set_result(_gvn.transform(new MulDNode(base, base)));
1872       return true;
1873     }
1874     return StubRoutines::dpow() != NULL ?
1875       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1876       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1877   }
1878 #undef FN_PTR
1879 
</pre>
<hr />
<pre>
2214           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2215         // According to profiling, this access is always on
2216         // heap. Casting the base to not null and thus avoiding membars
2217         // around the access should allow better optimizations
2218         Node* null_ctl = top();
2219         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2220         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2221         return basic_plus_adr(base, offset);
2222       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2223                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2224         // According to profiling, this access is always off
2225         // heap.
2226         base = null_assert(base);
2227         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2228         offset = MakeConX(0);
2229         return basic_plus_adr(top(), raw_base, offset);
2230       }
2231     }
2232     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2233     // to raw memory access.
<span class="line-removed">2234     base = access_resolve(base, decorators);</span>
2235     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2236     return basic_plus_adr(top(), raw, offset);
2237   } else {
2238     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2239     // We know it&#39;s an on heap access so base can&#39;t be null
2240     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2241       base = must_be_not_null(base, true);
2242     }
2243     return basic_plus_adr(base, offset);
2244   }
2245 }
2246 
2247 //--------------------------inline_number_methods-----------------------------
2248 // inline int     Integer.numberOfLeadingZeros(int)
2249 // inline int        Long.numberOfLeadingZeros(long)
2250 //
2251 // inline int     Integer.numberOfTrailingZeros(int)
2252 // inline int        Long.numberOfTrailingZeros(long)
2253 //
2254 // inline int     Integer.bitCount(int)
</pre>
<hr />
<pre>
2326         return MO_RELAXED;
2327       case Acquire:
2328         return MO_ACQUIRE;
2329       case Release:
2330         return MO_RELEASE;
2331       case Volatile:
2332         return MO_SEQ_CST;
2333       default:
2334         ShouldNotReachHere();
2335         return 0;
2336   }
2337 }
2338 
2339 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2340   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2341   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2342   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2343   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2344   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2345 
<span class="line-modified">2346   if (type == T_OBJECT || type == T_ARRAY) {</span>
2347     decorators |= ON_UNKNOWN_OOP_REF;
2348   }
2349 
2350   if (unaligned) {
2351     decorators |= C2_UNALIGNED;
2352   }
2353 
2354 #ifndef PRODUCT
2355   {
2356     ResourceMark rm;
2357     // Check the signatures.
2358     ciSignature* sig = callee()-&gt;signature();
2359 #ifdef ASSERT
2360     if (!is_store) {
2361       // Object getReference(Object base, int/long offset), etc.
2362       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2363       assert(rtype == type, &quot;getter must return the expected value&quot;);
2364       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);
2365       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2366       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
</pre>
<hr />
<pre>
2383 
2384   // Build address expression.
2385   Node* adr;
2386   Node* heap_base_oop = top();
2387   Node* offset = top();
2388   Node* val;
2389 
2390   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2391   Node* base = argument(1);  // type: oop
2392   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2393   offset = argument(2);  // type: long
2394   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2395   // to be plain byte offsets, which are also the same as those accepted
2396   // by oopDesc::field_addr.
2397   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2398          &quot;fieldOffset must be byte-scaled&quot;);
2399   // 32-bit machines ignore the high half!
2400   offset = ConvL2X(offset);
2401   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2402 
<span class="line-modified">2403   if (_gvn.type(base)-&gt;isa_ptr() != TypePtr::NULL_PTR) {</span>
<span class="line-modified">2404     heap_base_oop = base;</span>
<span class="line-modified">2405   } else if (type == T_OBJECT) {</span>
<span class="line-modified">2406     return false; // off-heap oop accesses are not supported</span>




2407   }
2408 
2409   // Can base be NULL? Otherwise, always on-heap access.
<span class="line-modified">2410   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(heap_base_oop));</span>
2411 
2412   if (!can_access_non_heap) {
2413     decorators |= IN_HEAP;
2414   }
2415 
2416   val = is_store ? argument(4) : NULL;
2417 
<span class="line-modified">2418   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();</span>



2419 
2420   // Try to categorize the address.
2421   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2422   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2423 
2424   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2425       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2426     return false; // not supported
2427   }
2428 
2429   bool mismatched = false;
2430   BasicType bt = alias_type-&gt;basic_type();
2431   if (bt != T_ILLEGAL) {
2432     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2433     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2434       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2435       // Use address type to get the element type.
2436       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2437     }
2438     if (bt == T_ARRAY || bt == T_NARROWOOP) {
</pre>
<hr />
<pre>
2671       newval   = argument(4);  // type: oop, int, or long
2672       break;
2673     }
2674     default:
2675       ShouldNotReachHere();
2676   }
2677 
2678   // Build field offset expression.
2679   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2680   // to be plain byte offsets, which are also the same as those accepted
2681   // by oopDesc::field_addr.
2682   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2683   // 32-bit machines ignore the high half of long offsets
2684   offset = ConvL2X(offset);
2685   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2686   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2687 
2688   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2689   BasicType bt = alias_type-&gt;basic_type();
2690   if (bt != T_ILLEGAL &amp;&amp;
<span class="line-modified">2691       ((bt == T_OBJECT || bt == T_ARRAY) != (type == T_OBJECT))) {</span>
2692     // Don&#39;t intrinsify mismatched object accesses.
2693     return false;
2694   }
2695 
2696   // For CAS, unlike inline_unsafe_access, there seems no point in
2697   // trying to refine types. Just use the coarse types here.
2698   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2699   const Type *value_type = Type::get_const_basic_type(type);
2700 
2701   switch (kind) {
2702     case LS_get_set:
2703     case LS_cmp_exchange: {
2704       if (type == T_OBJECT) {
2705         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2706         if (tjp != NULL) {
2707           value_type = tjp;
2708         }
2709       }
2710       break;
2711     }
2712     case LS_cmp_swap:
2713     case LS_cmp_swap_weak:
2714     case LS_get_add:
2715       break;
2716     default:
2717       ShouldNotReachHere();
2718   }
2719 
2720   // Null check receiver.
2721   receiver = null_check(receiver);
2722   if (stopped()) {
2723     return true;
2724   }
2725 
2726   int alias_idx = C-&gt;get_alias_index(adr_type);
2727 
<span class="line-modified">2728   if (type == T_OBJECT || type == T_ARRAY) {</span>
2729     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2730 
2731     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2732     // could be delayed during Parse (for example, in adjust_map_after_if()).
2733     // Execute transformation here to avoid barrier generation in such case.
2734     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2735       newval = _gvn.makecon(TypePtr::NULL_PTR);
2736 
2737     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2738       // Refine the value to a null constant, when it is known to be null
2739       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2740     }
2741   }
2742 
2743   Node* result = NULL;
2744   switch (kind) {
2745     case LS_cmp_exchange: {
2746       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
2747                                             oldval, newval, value_type, type, decorators);
2748       break;
</pre>
<hr />
<pre>
2794 }
2795 
2796 bool LibraryCallKit::inline_onspinwait() {
2797   insert_mem_bar(Op_OnSpinWait);
2798   return true;
2799 }
2800 
2801 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2802   if (!kls-&gt;is_Con()) {
2803     return true;
2804   }
2805   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2806   if (klsptr == NULL) {
2807     return true;
2808   }
2809   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2810   // don&#39;t need a guard for a klass that is already initialized
2811   return !ik-&gt;is_initialized();
2812 }
2813 

















































2814 //----------------------------inline_unsafe_allocate---------------------------
2815 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
2816 bool LibraryCallKit::inline_unsafe_allocate() {
2817   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2818 
2819   null_check_receiver();  // null-check, then ignore
2820   Node* cls = null_check(argument(1));
2821   if (stopped())  return true;
2822 
2823   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2824   kls = null_check(kls);
2825   if (stopped())  return true;  // argument was like int.class
2826 
2827   Node* test = NULL;
2828   if (LibraryCallKit::klass_needs_init_guard(kls)) {
2829     // Note:  The argument might still be an illegal value like
2830     // Serializable.class or Object[].class.   The runtime will handle it.
2831     // But we must make an explicit check for initialization.
2832     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
2833     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
</pre>
<hr />
<pre>
2923   set_control(jobj_is_not_null);
2924   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
2925                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
2926   result_rgn-&gt;init_req(_normal_path, control());
2927   result_val-&gt;init_req(_normal_path, res);
2928 
2929   set_result(result_rgn, result_val);
2930 
2931   return true;
2932 }
2933 
2934 #endif // JFR_HAVE_INTRINSICS
2935 
2936 //------------------------inline_native_currentThread------------------
2937 bool LibraryCallKit::inline_native_currentThread() {
2938   Node* junk = NULL;
2939   set_result(generate_current_thread(junk));
2940   return true;
2941 }
2942 
<span class="line-removed">2943 //------------------------inline_native_isInterrupted------------------</span>
<span class="line-removed">2944 // private native boolean java.lang.Thread.isInterrupted(boolean ClearInterrupted);</span>
<span class="line-removed">2945 bool LibraryCallKit::inline_native_isInterrupted() {</span>
<span class="line-removed">2946   // Add a fast path to t.isInterrupted(clear_int):</span>
<span class="line-removed">2947   //   (t == Thread.current() &amp;&amp;</span>
<span class="line-removed">2948   //    (!TLS._osthread._interrupted || WINDOWS_ONLY(false) NOT_WINDOWS(!clear_int)))</span>
<span class="line-removed">2949   //   ? TLS._osthread._interrupted : /*slow path:*/ t.isInterrupted(clear_int)</span>
<span class="line-removed">2950   // So, in the common case that the interrupt bit is false,</span>
<span class="line-removed">2951   // we avoid making a call into the VM.  Even if the interrupt bit</span>
<span class="line-removed">2952   // is true, if the clear_int argument is false, we avoid the VM call.</span>
<span class="line-removed">2953   // However, if the receiver is not currentThread, we must call the VM,</span>
<span class="line-removed">2954   // because there must be some locking done around the operation.</span>
<span class="line-removed">2955 </span>
<span class="line-removed">2956   // We only go to the fast case code if we pass two guards.</span>
<span class="line-removed">2957   // Paths which do not pass are accumulated in the slow_region.</span>
<span class="line-removed">2958 </span>
<span class="line-removed">2959   enum {</span>
<span class="line-removed">2960     no_int_result_path   = 1, // t == Thread.current() &amp;&amp; !TLS._osthread._interrupted</span>
<span class="line-removed">2961     no_clear_result_path = 2, // t == Thread.current() &amp;&amp;  TLS._osthread._interrupted &amp;&amp; !clear_int</span>
<span class="line-removed">2962     slow_result_path     = 3, // slow path: t.isInterrupted(clear_int)</span>
<span class="line-removed">2963     PATH_LIMIT</span>
<span class="line-removed">2964   };</span>
<span class="line-removed">2965 </span>
<span class="line-removed">2966   // Ensure that it&#39;s not possible to move the load of TLS._osthread._interrupted flag</span>
<span class="line-removed">2967   // out of the function.</span>
<span class="line-removed">2968   insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-removed">2969 </span>
<span class="line-removed">2970   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);</span>
<span class="line-removed">2971   PhiNode*    result_val = new PhiNode(result_rgn, TypeInt::BOOL);</span>
<span class="line-removed">2972 </span>
<span class="line-removed">2973   RegionNode* slow_region = new RegionNode(1);</span>
<span class="line-removed">2974   record_for_igvn(slow_region);</span>
<span class="line-removed">2975 </span>
<span class="line-removed">2976   // (a) Receiving thread must be the current thread.</span>
<span class="line-removed">2977   Node* rec_thr = argument(0);</span>
<span class="line-removed">2978   Node* tls_ptr = NULL;</span>
<span class="line-removed">2979   Node* cur_thr = generate_current_thread(tls_ptr);</span>
<span class="line-removed">2980 </span>
<span class="line-removed">2981   // Resolve oops to stable for CmpP below.</span>
<span class="line-removed">2982   cur_thr = access_resolve(cur_thr, 0);</span>
<span class="line-removed">2983   rec_thr = access_resolve(rec_thr, 0);</span>
<span class="line-removed">2984 </span>
<span class="line-removed">2985   Node* cmp_thr = _gvn.transform(new CmpPNode(cur_thr, rec_thr));</span>
<span class="line-removed">2986   Node* bol_thr = _gvn.transform(new BoolNode(cmp_thr, BoolTest::ne));</span>
<span class="line-removed">2987 </span>
<span class="line-removed">2988   generate_slow_guard(bol_thr, slow_region);</span>
<span class="line-removed">2989 </span>
<span class="line-removed">2990   // (b) Interrupt bit on TLS must be false.</span>
<span class="line-removed">2991   Node* p = basic_plus_adr(top()/*!oop*/, tls_ptr, in_bytes(JavaThread::osthread_offset()));</span>
<span class="line-removed">2992   Node* osthread = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);</span>
<span class="line-removed">2993   p = basic_plus_adr(top()/*!oop*/, osthread, in_bytes(OSThread::interrupted_offset()));</span>
<span class="line-removed">2994 </span>
<span class="line-removed">2995   // Set the control input on the field _interrupted read to prevent it floating up.</span>
<span class="line-removed">2996   Node* int_bit = make_load(control(), p, TypeInt::BOOL, T_INT, MemNode::unordered);</span>
<span class="line-removed">2997   Node* cmp_bit = _gvn.transform(new CmpINode(int_bit, intcon(0)));</span>
<span class="line-removed">2998   Node* bol_bit = _gvn.transform(new BoolNode(cmp_bit, BoolTest::ne));</span>
<span class="line-removed">2999 </span>
<span class="line-removed">3000   IfNode* iff_bit = create_and_map_if(control(), bol_bit, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);</span>
<span class="line-removed">3001 </span>
<span class="line-removed">3002   // First fast path:  if (!TLS._interrupted) return false;</span>
<span class="line-removed">3003   Node* false_bit = _gvn.transform(new IfFalseNode(iff_bit));</span>
<span class="line-removed">3004   result_rgn-&gt;init_req(no_int_result_path, false_bit);</span>
<span class="line-removed">3005   result_val-&gt;init_req(no_int_result_path, intcon(0));</span>
<span class="line-removed">3006 </span>
<span class="line-removed">3007   // drop through to next case</span>
<span class="line-removed">3008   set_control( _gvn.transform(new IfTrueNode(iff_bit)));</span>
<span class="line-removed">3009 </span>
<span class="line-removed">3010 #ifndef _WINDOWS</span>
<span class="line-removed">3011   // (c) Or, if interrupt bit is set and clear_int is false, use 2nd fast path.</span>
<span class="line-removed">3012   Node* clr_arg = argument(1);</span>
<span class="line-removed">3013   Node* cmp_arg = _gvn.transform(new CmpINode(clr_arg, intcon(0)));</span>
<span class="line-removed">3014   Node* bol_arg = _gvn.transform(new BoolNode(cmp_arg, BoolTest::ne));</span>
<span class="line-removed">3015   IfNode* iff_arg = create_and_map_if(control(), bol_arg, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="line-removed">3016 </span>
<span class="line-removed">3017   // Second fast path:  ... else if (!clear_int) return true;</span>
<span class="line-removed">3018   Node* false_arg = _gvn.transform(new IfFalseNode(iff_arg));</span>
<span class="line-removed">3019   result_rgn-&gt;init_req(no_clear_result_path, false_arg);</span>
<span class="line-removed">3020   result_val-&gt;init_req(no_clear_result_path, intcon(1));</span>
<span class="line-removed">3021 </span>
<span class="line-removed">3022   // drop through to next case</span>
<span class="line-removed">3023   set_control( _gvn.transform(new IfTrueNode(iff_arg)));</span>
<span class="line-removed">3024 #else</span>
<span class="line-removed">3025   // To return true on Windows you must read the _interrupted field</span>
<span class="line-removed">3026   // and check the event state i.e. take the slow path.</span>
<span class="line-removed">3027 #endif // _WINDOWS</span>
<span class="line-removed">3028 </span>
<span class="line-removed">3029   // (d) Otherwise, go to the slow path.</span>
<span class="line-removed">3030   slow_region-&gt;add_req(control());</span>
<span class="line-removed">3031   set_control( _gvn.transform(slow_region));</span>
<span class="line-removed">3032 </span>
<span class="line-removed">3033   if (stopped()) {</span>
<span class="line-removed">3034     // There is no slow path.</span>
<span class="line-removed">3035     result_rgn-&gt;init_req(slow_result_path, top());</span>
<span class="line-removed">3036     result_val-&gt;init_req(slow_result_path, top());</span>
<span class="line-removed">3037   } else {</span>
<span class="line-removed">3038     // non-virtual because it is a private non-static</span>
<span class="line-removed">3039     CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_isInterrupted);</span>
<span class="line-removed">3040 </span>
<span class="line-removed">3041     Node* slow_val = set_results_for_java_call(slow_call);</span>
<span class="line-removed">3042     // this-&gt;control() comes from set_results_for_java_call</span>
<span class="line-removed">3043 </span>
<span class="line-removed">3044     Node* fast_io  = slow_call-&gt;in(TypeFunc::I_O);</span>
<span class="line-removed">3045     Node* fast_mem = slow_call-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed">3046 </span>
<span class="line-removed">3047     // These two phis are pre-filled with copies of of the fast IO and Memory</span>
<span class="line-removed">3048     PhiNode* result_mem  = PhiNode::make(result_rgn, fast_mem, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-removed">3049     PhiNode* result_io   = PhiNode::make(result_rgn, fast_io,  Type::ABIO);</span>
<span class="line-removed">3050 </span>
<span class="line-removed">3051     result_rgn-&gt;init_req(slow_result_path, control());</span>
<span class="line-removed">3052     result_io -&gt;init_req(slow_result_path, i_o());</span>
<span class="line-removed">3053     result_mem-&gt;init_req(slow_result_path, reset_memory());</span>
<span class="line-removed">3054     result_val-&gt;init_req(slow_result_path, slow_val);</span>
<span class="line-removed">3055 </span>
<span class="line-removed">3056     set_all_memory(_gvn.transform(result_mem));</span>
<span class="line-removed">3057     set_i_o(       _gvn.transform(result_io));</span>
<span class="line-removed">3058   }</span>
<span class="line-removed">3059 </span>
<span class="line-removed">3060   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization</span>
<span class="line-removed">3061   set_result(result_rgn, result_val);</span>
<span class="line-removed">3062   return true;</span>
<span class="line-removed">3063 }</span>
<span class="line-removed">3064 </span>
3065 //---------------------------load_mirror_from_klass----------------------------
3066 // Given a klass oop, load its java mirror (a java.lang.Class oop).
3067 Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
3068   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
3069   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3070   // mirror = ((OopHandle)mirror)-&gt;resolve();
3071   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);
3072 }
3073 
3074 //-----------------------load_klass_from_mirror_common-------------------------
3075 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3076 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3077 // and branch to the given path on the region.
3078 // If never_see_null, take an uncommon trap on null, so we can optimistically
3079 // compile for the non-null case.
3080 // If the region is NULL, force never_see_null = true.
3081 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3082                                                     bool never_see_null,
3083                                                     RegionNode* region,
3084                                                     int null_path,
</pre>
<hr />
<pre>
3399   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3400   record_for_igvn(region);
3401 
3402   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3403   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3404   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();
3405 
3406   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3407   int which_arg;
3408   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3409     Node* arg = args[which_arg];
3410     arg = null_check(arg);
3411     if (stopped())  break;
3412     args[which_arg] = arg;
3413 
3414     Node* p = basic_plus_adr(arg, class_klass_offset);
3415     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3416     klasses[which_arg] = _gvn.transform(kls);
3417   }
3418 
<span class="line-removed">3419   // Resolve oops to stable for CmpP below.</span>
<span class="line-removed">3420   args[0] = access_resolve(args[0], 0);</span>
<span class="line-removed">3421   args[1] = access_resolve(args[1], 0);</span>
<span class="line-removed">3422 </span>
3423   // Having loaded both klasses, test each for null.
3424   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3425   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3426     Node* kls = klasses[which_arg];
3427     Node* null_ctl = top();
3428     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3429     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);
3430     region-&gt;init_req(prim_path, null_ctl);
3431     if (stopped())  break;
3432     klasses[which_arg] = kls;
3433   }
3434 
3435   if (!stopped()) {
3436     // now we have two reference types, in klasses[0..1]
3437     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3438     Node* superk = klasses[0];  // the receiver
3439     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3440     // now we have a successful reference subtype check
3441     region-&gt;set_req(_ref_subtype_path, control());
3442   }
</pre>
<hr />
<pre>
3688 
3689     // Bail out if length is negative.
3690     // Without this the new_array would throw
3691     // NegativeArraySizeException but IllegalArgumentException is what
3692     // should be thrown
3693     generate_negative_guard(length, bailout, &amp;length);
3694 
3695     if (bailout-&gt;req() &gt; 1) {
3696       PreserveJVMState pjvms(this);
3697       set_control(_gvn.transform(bailout));
3698       uncommon_trap(Deoptimization::Reason_intrinsic,
3699                     Deoptimization::Action_maybe_recompile);
3700     }
3701 
3702     if (!stopped()) {
3703       // How many elements will we copy from the original?
3704       // The answer is MinI(orig_length - start, length).
3705       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3706       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3707 
<span class="line-removed">3708       original = access_resolve(original, ACCESS_READ);</span>
<span class="line-removed">3709 </span>
3710       // Generate a direct call to the right arraycopy function(s).
3711       // We know the copy is disjoint but we might not know if the
3712       // oop stores need checking.
3713       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
3714       // This will fail a store-check if x contains any non-nulls.
3715 
3716       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3717       // loads/stores but it is legal only if we&#39;re sure the
3718       // Arrays.copyOf would succeed. So we need all input arguments
3719       // to the copyOf to be validated, including that the copy to the
3720       // new array won&#39;t trigger an ArrayStoreException. That subtype
3721       // check can be optimized if we know something on the type of
3722       // the input array from type speculation.
3723       if (_gvn.type(klass_node)-&gt;singleton()) {
3724         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3725         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3726 
3727         int test = C-&gt;static_subtype_check(superk, subk);
3728         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3729           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3730           if (t_original-&gt;speculative_type() != NULL) {
3731             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3732           }
3733         }
3734       }
3735 
3736       bool validated = false;
3737       // Reason_class_check rather than Reason_intrinsic because we
3738       // want to intrinsify even if this traps.
3739       if (!too_many_traps(Deoptimization::Reason_class_check)) {
<span class="line-modified">3740         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),</span>
<span class="line-removed">3741                                                    klass_node);</span>
3742 
3743         if (not_subtype_ctrl != top()) {
3744           PreserveJVMState pjvms(this);
3745           set_control(not_subtype_ctrl);
3746           uncommon_trap(Deoptimization::Reason_class_check,
3747                         Deoptimization::Action_make_not_entrant);
3748           assert(stopped(), &quot;Should be stopped&quot;);
3749         }
3750         validated = true;
3751       }
3752 
3753       if (!stopped()) {
3754         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3755 
3756         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3757                                                 load_object_klass(original), klass_node);
3758         if (!is_copyOfRange) {
3759           ac-&gt;set_copyof(validated);
3760         } else {
3761           ac-&gt;set_copyofrange(validated);
</pre>
<hr />
<pre>
3911   // If this is a virtual call, we generate a funny guard.  We pull out
3912   // the vtable entry corresponding to hashCode() from the target object.
3913   // If the target method which we are calling happens to be the native
3914   // Object hashCode() method, we pass the guard.  We do not need this
3915   // guard for non-virtual calls -- the caller is known to be the native
3916   // Object hashCode().
3917   if (is_virtual) {
3918     // After null check, get the object&#39;s klass.
3919     Node* obj_klass = load_object_klass(obj);
3920     generate_virtual_guard(obj_klass, slow_region);
3921   }
3922 
3923   // Get the header out of the object, use LoadMarkNode when available
3924   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3925   // The control of the load must be NULL. Otherwise, the load can move before
3926   // the null check after castPP removal.
3927   Node* no_ctrl = NULL;
3928   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3929 
3930   // Test the header to see if it is unlocked.
<span class="line-modified">3931   Node *lock_mask      = _gvn.MakeConX(markOopDesc::biased_lock_mask_in_place);</span>
3932   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
<span class="line-modified">3933   Node *unlocked_val   = _gvn.MakeConX(markOopDesc::unlocked_value);</span>
3934   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
3935   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
3936 
3937   generate_slow_guard(test_unlocked, slow_region);
3938 
3939   // Get the hash value and check to see that it has been properly assigned.
3940   // We depend on hash_mask being at most 32 bits and avoid the use of
3941   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
<span class="line-modified">3942   // vm: see markOop.hpp.</span>
<span class="line-modified">3943   Node *hash_mask      = _gvn.intcon(markOopDesc::hash_mask);</span>
<span class="line-modified">3944   Node *hash_shift     = _gvn.intcon(markOopDesc::hash_shift);</span>
3945   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
3946   // This hack lets the hash bits live anywhere in the mark object now, as long
3947   // as the shift drops the relevant bits into the low 32 bits.  Note that
3948   // Java spec says that HashCode is an int so there&#39;s no point in capturing
3949   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
3950   hshifted_header      = ConvX2I(hshifted_header);
3951   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
3952 
<span class="line-modified">3953   Node *no_hash_val    = _gvn.intcon(markOopDesc::no_hash);</span>
3954   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
3955   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
3956 
3957   generate_slow_guard(test_assigned, slow_region);
3958 
3959   Node* init_mem = reset_memory();
3960   // fill in the rest of the null path:
3961   result_io -&gt;init_req(_null_path, i_o());
3962   result_mem-&gt;init_req(_null_path, init_mem);
3963 
3964   result_val-&gt;init_req(_fast_path, hash_val);
3965   result_reg-&gt;init_req(_fast_path, control());
3966   result_io -&gt;init_req(_fast_path, i_o());
3967   result_mem-&gt;init_req(_fast_path, init_mem);
3968 
3969   // Generate code for the slow case.  We make a call to hashCode().
3970   set_control(_gvn.transform(slow_region));
3971   if (!stopped()) {
3972     // No need for PreserveJVMState, because we&#39;re using up the present state.
3973     set_all_memory(init_mem);
</pre>
<hr />
<pre>
4187 }
4188 
4189 //----------------------inline_unsafe_copyMemory-------------------------
4190 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4191 bool LibraryCallKit::inline_unsafe_copyMemory() {
4192   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4193   null_check_receiver();  // null-check receiver
4194   if (stopped())  return true;
4195 
4196   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4197 
4198   Node* src_ptr =         argument(1);   // type: oop
4199   Node* src_off = ConvL2X(argument(2));  // type: long
4200   Node* dst_ptr =         argument(4);   // type: oop
4201   Node* dst_off = ConvL2X(argument(5));  // type: long
4202   Node* size    = ConvL2X(argument(7));  // type: long
4203 
4204   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4205          &quot;fieldOffset must be byte-scaled&quot;);
4206 
<span class="line-removed">4207   src_ptr = access_resolve(src_ptr, ACCESS_READ);</span>
<span class="line-removed">4208   dst_ptr = access_resolve(dst_ptr, ACCESS_WRITE);</span>
4209   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4210   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4211 
4212   // Conservatively insert a memory barrier on all memory slices.
4213   // Do not let writes of the copy source or destination float below the copy.
4214   insert_mem_bar(Op_MemBarCPUOrder);
4215 








4216   // Call it.  Note that the length argument is not scaled.
4217   make_runtime_call(RC_LEAF|RC_NO_FP,
4218                     OptoRuntime::fast_arraycopy_Type(),
4219                     StubRoutines::unsafe_arraycopy(),
4220                     &quot;unsafe_arraycopy&quot;,
4221                     TypeRawPtr::BOTTOM,
4222                     src, dst, size XTOP);
4223 


4224   // Do not let reads of the copy destination float above the copy.
4225   insert_mem_bar(Op_MemBarCPUOrder);
4226 
4227   return true;
4228 }
4229 
4230 //------------------------clone_coping-----------------------------------
4231 // Helper function for inline_native_clone.
4232 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4233   assert(obj_size != NULL, &quot;&quot;);
4234   Node* raw_obj = alloc_obj-&gt;in(1);
4235   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4236 
4237   AllocateNode* alloc = NULL;
4238   if (ReduceBulkZeroing) {
4239     // We will be completely responsible for initializing this object -
4240     // mark Initialize node as complete.
4241     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4242     // The object was just allocated - there should be no any stores!
4243     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4244     // Mark as complete_with_arraycopy so that on AllocateNode
4245     // expansion, we know this AllocateNode is initialized by an array
4246     // copy and a StoreStore barrier exists after the array copy.
4247     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4248   }
4249 
<span class="line-removed">4250   // Copy the fastest available way.</span>
<span class="line-removed">4251   // TODO: generate fields copies for small objects instead.</span>
4252   Node* size = _gvn.transform(obj_size);
<span class="line-removed">4253 </span>
4254   access_clone(obj, alloc_obj, size, is_array);
4255 
4256   // Do not let reads from the cloned object float above the arraycopy.
4257   if (alloc != NULL) {
4258     // Do not let stores that initialize this object be reordered with
4259     // a subsequent store that would make this object accessible by
4260     // other threads.
4261     // Record what AllocateNode this StoreStore protects so that
4262     // escape analysis can go from the MemBarStoreStoreNode to the
4263     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4264     // based on the escape status of the AllocateNode.
4265     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4266   } else {
4267     insert_mem_bar(Op_MemBarCPUOrder);
4268   }
4269 }
4270 
4271 //------------------------inline_native_clone----------------------------
4272 // protected native Object java.lang.Object.clone();
4273 //
</pre>
<hr />
<pre>
4300     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4301 
4302     // If we are going to clone an instance, we need its exact type to
4303     // know the number and types of fields to convert the clone to
4304     // loads/stores. Maybe a speculative type can help us.
4305     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4306         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4307         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {
4308       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4309       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4310           !spec_ik-&gt;has_injected_fields()) {
4311         ciKlass* k = obj_type-&gt;klass();
4312         if (!k-&gt;is_instance_klass() ||
4313             k-&gt;as_instance_klass()-&gt;is_interface() ||
4314             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4315           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4316         }
4317       }
4318     }
4319 
<span class="line-removed">4320     Node* obj_klass = load_object_klass(obj);</span>
<span class="line-removed">4321     const TypeKlassPtr* tklass = _gvn.type(obj_klass)-&gt;isa_klassptr();</span>
<span class="line-removed">4322     const TypeOopPtr*   toop   = ((tklass != NULL)</span>
<span class="line-removed">4323                                 ? tklass-&gt;as_instance_type()</span>
<span class="line-removed">4324                                 : TypeInstPtr::NOTNULL);</span>
<span class="line-removed">4325 </span>
4326     // Conservatively insert a memory barrier on all memory slices.
4327     // Do not let writes into the original float below the clone.
4328     insert_mem_bar(Op_MemBarCPUOrder);
4329 
4330     // paths into result_reg:
4331     enum {
4332       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4333       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4334       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4335       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4336       PATH_LIMIT
4337     };
4338     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4339     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4340     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4341     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4342     record_for_igvn(result_reg);
4343 

4344     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4345     if (array_ctl != NULL) {
4346       // It&#39;s an array.
4347       PreserveJVMState pjvms(this);
4348       set_control(array_ctl);
4349       Node* obj_length = load_array_length(obj);
4350       Node* obj_size  = NULL;
4351       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size);  // no arguments to push
4352 
4353       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4354       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4355         // If it is an oop array, it requires very special treatment,
4356         // because gc barriers are required when accessing the array.
4357         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4358         if (is_obja != NULL) {
4359           PreserveJVMState pjvms2(this);
4360           set_control(is_obja);
<span class="line-removed">4361           obj = access_resolve(obj, ACCESS_READ);</span>
4362           // Generate a direct call to the right arraycopy function(s).
4363           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4364           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
<span class="line-modified">4365           ac-&gt;set_cloneoop();</span>
4366           Node* n = _gvn.transform(ac);
4367           assert(n == ac, &quot;cannot disappear&quot;);
4368           ac-&gt;connect_outputs(this);
4369 
4370           result_reg-&gt;init_req(_objArray_path, control());
4371           result_val-&gt;init_req(_objArray_path, alloc_obj);
4372           result_i_o -&gt;set_req(_objArray_path, i_o());
4373           result_mem -&gt;set_req(_objArray_path, reset_memory());
4374         }
4375       }
4376       // Otherwise, there are no barriers to worry about.
4377       // (We can dispense with card marks if we know the allocation
4378       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4379       //  causes the non-eden paths to take compensating steps to
4380       //  simulate a fresh allocation, so that no further
4381       //  card marks are required in compiled code to initialize
4382       //  the object.)
4383 
4384       if (!stopped()) {
4385         copy_to_clone(obj, alloc_obj, obj_size, true);
</pre>
<hr />
<pre>
4457     set_all_memory( _gvn.transform(result_mem));
4458   } // original reexecute is set back here
4459 
4460   set_result(_gvn.transform(result_val));
4461   return true;
4462 }
4463 
4464 // If we have a tightly coupled allocation, the arraycopy may take care
4465 // of the array initialization. If one of the guards we insert between
4466 // the allocation and the arraycopy causes a deoptimization, an
4467 // unitialized array will escape the compiled method. To prevent that
4468 // we set the JVM state for uncommon traps between the allocation and
4469 // the arraycopy to the state before the allocation so, in case of
4470 // deoptimization, we&#39;ll reexecute the allocation and the
4471 // initialization.
4472 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4473   if (alloc != NULL) {
4474     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4475     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4476 
<span class="line-modified">4477     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;</span>
<span class="line-modified">4478           !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {</span>
4479       // Make sure there&#39;s no store between the allocation and the
4480       // arraycopy otherwise visible side effects could be rexecuted
4481       // in case of deoptimization and cause incorrect execution.
4482       bool no_interfering_store = true;
4483       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4484       if (mem-&gt;is_MergeMem()) {
4485         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4486           Node* n = mms.memory();
4487           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="line-modified">4488             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);</span>
4489             no_interfering_store = false;
4490             break;
4491           }
4492         }
4493       } else {
4494         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4495           Node* n = mms.memory();
4496           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="line-modified">4497             assert(n-&gt;is_Store() || n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;what else?&quot;);</span>
4498             no_interfering_store = false;
4499             break;
4500           }
4501         }
4502       }
4503 
4504       if (no_interfering_store) {
4505         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4506         uint size = alloc-&gt;req();
4507         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4508         old_jvms-&gt;set_map(sfpt);
4509         for (uint i = 0; i &lt; size; i++) {
4510           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4511         }
4512         // re-push array length for deoptimization
4513         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4514         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4515         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4516         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4517         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
</pre>
<hr />
<pre>
4699       if (!has_src) {
4700         src = maybe_cast_profiled_obj(src, src_k, true);
4701         src_type  = _gvn.type(src);
4702         top_src  = src_type-&gt;isa_aryptr();
4703         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4704         src_spec = true;
4705       }
4706       if (!has_dest) {
4707         dest = maybe_cast_profiled_obj(dest, dest_k, true);
4708         dest_type  = _gvn.type(dest);
4709         top_dest  = dest_type-&gt;isa_aryptr();
4710         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4711         dest_spec = true;
4712       }
4713     }
4714   }
4715 
4716   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
4717     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4718     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">4719     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;</span>
<span class="line-modified">4720     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;</span>
4721 
4722     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
4723       // If both arrays are object arrays then having the exact types
4724       // for both will remove the need for a subtype check at runtime
4725       // before the call and may make it possible to pick a faster copy
4726       // routine (without a subtype check on every element)
4727       // Do we have the exact type of src?
4728       bool could_have_src = src_spec;
4729       // Do we have the exact type of dest?
4730       bool could_have_dest = dest_spec;
4731       ciKlass* src_k = top_src-&gt;klass();
4732       ciKlass* dest_k = top_dest-&gt;klass();
4733       if (!src_spec) {
4734         src_k = src_type-&gt;speculative_type_not_null();
4735         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4736           could_have_src = true;
4737         }
4738       }
4739       if (!dest_spec) {
4740         dest_k = dest_type-&gt;speculative_type_not_null();
</pre>
<hr />
<pre>
4788     // (7) src_offset + length must not exceed length of src.
4789     generate_limit_guard(src_offset, length,
4790                          load_array_length(src),
4791                          slow_region);
4792 
4793     // (8) dest_offset + length must not exceed length of dest.
4794     generate_limit_guard(dest_offset, length,
4795                          load_array_length(dest),
4796                          slow_region);
4797 
4798     // (6) length must not be negative.
4799     // This is also checked in generate_arraycopy() during macro expansion, but
4800     // we also have to check it here for the case where the ArrayCopyNode will
4801     // be eliminated by Escape Analysis.
4802     if (EliminateAllocations) {
4803       generate_negative_guard(length, slow_region);
4804       negative_length_guard_generated = true;
4805     }
4806 
4807     // (9) each element of an oop array must be assignable
<span class="line-removed">4808     Node* src_klass  = load_object_klass(src);</span>
4809     Node* dest_klass = load_object_klass(dest);
<span class="line-modified">4810     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);</span>
<span class="line-modified">4811 </span>
<span class="line-modified">4812     if (not_subtype_ctrl != top()) {</span>
<span class="line-modified">4813       PreserveJVMState pjvms(this);</span>
<span class="line-modified">4814       set_control(not_subtype_ctrl);</span>
<span class="line-modified">4815       uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="line-modified">4816                     Deoptimization::Action_make_not_entrant);</span>
<span class="line-modified">4817       assert(stopped(), &quot;Should be stopped&quot;);</span>


4818     }
4819     {
4820       PreserveJVMState pjvms(this);
4821       set_control(_gvn.transform(slow_region));
4822       uncommon_trap(Deoptimization::Reason_intrinsic,
4823                     Deoptimization::Action_make_not_entrant);
4824       assert(stopped(), &quot;Should be stopped&quot;);
4825     }
4826 
4827     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4828     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4829     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4830   }
4831 
4832   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4833 
4834   if (stopped()) {
4835     return true;
4836   }
4837 
<span class="line-modified">4838   Node* new_src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">4839   Node* new_dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="line-removed">4840 </span>
<span class="line-removed">4841   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, new_src, src_offset, new_dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,</span>
4842                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
4843                                           // so the compiler has a chance to eliminate them: during macro expansion,
4844                                           // we have to set their control (CastPP nodes are eliminated).
4845                                           load_object_klass(src), load_object_klass(dest),
4846                                           load_array_length(src), load_array_length(dest));
4847 
4848   ac-&gt;set_arraycopy(validated);
4849 
4850   Node* n = _gvn.transform(ac);
4851   if (n == ac) {
4852     ac-&gt;connect_outputs(this);
4853   } else {
4854     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4855     set_all_memory(n);
4856   }
4857   clear_upper_avx();
4858 
4859 
4860   return true;
4861 }
</pre>
<hr />
<pre>
4877   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
4878     // Bail out if there have been raw-memory effects since the allocation.
4879     // (Example:  There might have been a call or safepoint.)
4880     return NULL;
4881   }
4882   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
4883   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
4884     return NULL;
4885   }
4886 
4887   // There must be no unexpected observers of this allocation.
4888   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
4889     Node* obs = ptr-&gt;fast_out(i);
4890     if (obs != this-&gt;map()) {
4891       return NULL;
4892     }
4893   }
4894 
4895   // This arraycopy must unconditionally follow the allocation of the ptr.
4896   Node* alloc_ctl = ptr-&gt;in(0);
<span class="line-removed">4897   assert(just_allocated_object(alloc_ctl) == ptr, &quot;most recent allo&quot;);</span>
<span class="line-removed">4898 </span>
4899   Node* ctl = control();
4900   while (ctl != alloc_ctl) {
4901     // There may be guards which feed into the slow_region.
4902     // Any other control flow means that we might not get a chance
4903     // to finish initializing the allocated object.
4904     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
4905       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
4906       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
4907       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
4908       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
4909         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
4910         continue;
4911       }
4912       // One more try:  Various low-level checks bottom out in
4913       // uncommon traps.  If the debug-info of the trap omits
4914       // any reference to the allocation, as we&#39;ve already
4915       // observed, then there can be no objection to the trap.
4916       bool found_trap = false;
4917       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4918         Node* obs = not_ctl-&gt;fast_out(j);
</pre>
<hr />
<pre>
4934   // The arraycopy will finish the initialization, and provide
4935   // a new control state to which we will anchor the destination pointer.
4936 
4937   return alloc;
4938 }
4939 
4940 //-------------inline_encodeISOArray-----------------------------------
4941 // encode char[] to byte[] in ISO_8859_1
4942 bool LibraryCallKit::inline_encodeISOArray() {
4943   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
4944   // no receiver since it is static method
4945   Node *src         = argument(0);
4946   Node *src_offset  = argument(1);
4947   Node *dst         = argument(2);
4948   Node *dst_offset  = argument(3);
4949   Node *length      = argument(4);
4950 
4951   src = must_be_not_null(src, true);
4952   dst = must_be_not_null(dst, true);
4953 
<span class="line-removed">4954   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">4955   dst = access_resolve(dst, ACCESS_WRITE);</span>
<span class="line-removed">4956 </span>
4957   const Type* src_type = src-&gt;Value(&amp;_gvn);
4958   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
4959   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
4960   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
4961   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
4962       top_dest == NULL || top_dest-&gt;klass() == NULL) {
4963     // failed array check
4964     return false;
4965   }
4966 
4967   // Figure out the size and type of the elements we will be copying.
4968   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4969   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4970   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
4971     return false;
4972   }
4973 
4974   Node* src_start = array_element_address(src, src_offset, T_CHAR);
4975   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
4976   // &#39;src_start&#39; points to src array + scaled offset
</pre>
<hr />
<pre>
4992   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
4993 
4994   address stubAddr = StubRoutines::multiplyToLen();
4995   if (stubAddr == NULL) {
4996     return false; // Intrinsic&#39;s stub is not implemented on this platform
4997   }
4998   const char* stubName = &quot;multiplyToLen&quot;;
4999 
5000   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
5001 
5002   // no receiver because it is a static method
5003   Node* x    = argument(0);
5004   Node* xlen = argument(1);
5005   Node* y    = argument(2);
5006   Node* ylen = argument(3);
5007   Node* z    = argument(4);
5008 
5009   x = must_be_not_null(x, true);
5010   y = must_be_not_null(y, true);
5011 
<span class="line-removed">5012   x = access_resolve(x, ACCESS_READ);</span>
<span class="line-removed">5013   y = access_resolve(y, ACCESS_READ);</span>
<span class="line-removed">5014   z = access_resolve(z, ACCESS_WRITE);</span>
<span class="line-removed">5015 </span>
5016   const Type* x_type = x-&gt;Value(&amp;_gvn);
5017   const Type* y_type = y-&gt;Value(&amp;_gvn);
5018   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5019   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
5020   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5021       top_y == NULL || top_y-&gt;klass() == NULL) {
5022     // failed array check
5023     return false;
5024   }
5025 
5026   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5027   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5028   if (x_elem != T_INT || y_elem != T_INT) {
5029     return false;
5030   }
5031 
5032   // Set the original stack and the reexecute bit for the interpreter to reexecute
5033   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
5034   // on the return from z array allocation in runtime.
5035   { PreserveReexecuteState preexecs(this);
</pre>
<hr />
<pre>
5104 //-------------inline_squareToLen------------------------------------
5105 bool LibraryCallKit::inline_squareToLen() {
5106   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5107 
5108   address stubAddr = StubRoutines::squareToLen();
5109   if (stubAddr == NULL) {
5110     return false; // Intrinsic&#39;s stub is not implemented on this platform
5111   }
5112   const char* stubName = &quot;squareToLen&quot;;
5113 
5114   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5115 
5116   Node* x    = argument(0);
5117   Node* len  = argument(1);
5118   Node* z    = argument(2);
5119   Node* zlen = argument(3);
5120 
5121   x = must_be_not_null(x, true);
5122   z = must_be_not_null(z, true);
5123 
<span class="line-removed">5124   x = access_resolve(x, ACCESS_READ);</span>
<span class="line-removed">5125   z = access_resolve(z, ACCESS_WRITE);</span>
<span class="line-removed">5126 </span>
5127   const Type* x_type = x-&gt;Value(&amp;_gvn);
5128   const Type* z_type = z-&gt;Value(&amp;_gvn);
5129   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5130   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5131   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5132       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5133     // failed array check
5134     return false;
5135   }
5136 
5137   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5138   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5139   if (x_elem != T_INT || z_elem != T_INT) {
5140     return false;
5141   }
5142 
5143 
5144   Node* x_start = array_element_address(x, intcon(0), x_elem);
5145   Node* z_start = array_element_address(z, intcon(0), z_elem);
5146 
</pre>
<hr />
<pre>
5156 //-------------inline_mulAdd------------------------------------------
5157 bool LibraryCallKit::inline_mulAdd() {
5158   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5159 
5160   address stubAddr = StubRoutines::mulAdd();
5161   if (stubAddr == NULL) {
5162     return false; // Intrinsic&#39;s stub is not implemented on this platform
5163   }
5164   const char* stubName = &quot;mulAdd&quot;;
5165 
5166   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5167 
5168   Node* out      = argument(0);
5169   Node* in       = argument(1);
5170   Node* offset   = argument(2);
5171   Node* len      = argument(3);
5172   Node* k        = argument(4);
5173 
5174   out = must_be_not_null(out, true);
5175 
<span class="line-removed">5176   in = access_resolve(in, ACCESS_READ);</span>
<span class="line-removed">5177   out = access_resolve(out, ACCESS_WRITE);</span>
<span class="line-removed">5178 </span>
5179   const Type* out_type = out-&gt;Value(&amp;_gvn);
5180   const Type* in_type = in-&gt;Value(&amp;_gvn);
5181   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5182   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5183   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5184       top_in == NULL || top_in-&gt;klass() == NULL) {
5185     // failed array check
5186     return false;
5187   }
5188 
5189   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5190   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5191   if (out_elem != T_INT || in_elem != T_INT) {
5192     return false;
5193   }
5194 
5195   Node* outlen = load_array_length(out);
5196   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5197   Node* out_start = array_element_address(out, intcon(0), out_elem);
5198   Node* in_start = array_element_address(in, intcon(0), in_elem);
</pre>
<hr />
<pre>
5208 
5209 //-------------inline_montgomeryMultiply-----------------------------------
5210 bool LibraryCallKit::inline_montgomeryMultiply() {
5211   address stubAddr = StubRoutines::montgomeryMultiply();
5212   if (stubAddr == NULL) {
5213     return false; // Intrinsic&#39;s stub is not implemented on this platform
5214   }
5215 
5216   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5217   const char* stubName = &quot;montgomery_multiply&quot;;
5218 
5219   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5220 
5221   Node* a    = argument(0);
5222   Node* b    = argument(1);
5223   Node* n    = argument(2);
5224   Node* len  = argument(3);
5225   Node* inv  = argument(4);
5226   Node* m    = argument(6);
5227 
<span class="line-removed">5228   a = access_resolve(a, ACCESS_READ);</span>
<span class="line-removed">5229   b = access_resolve(b, ACCESS_READ);</span>
<span class="line-removed">5230   n = access_resolve(n, ACCESS_READ);</span>
<span class="line-removed">5231   m = access_resolve(m, ACCESS_WRITE);</span>
<span class="line-removed">5232 </span>
5233   const Type* a_type = a-&gt;Value(&amp;_gvn);
5234   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5235   const Type* b_type = b-&gt;Value(&amp;_gvn);
5236   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5237   const Type* n_type = a-&gt;Value(&amp;_gvn);
5238   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5239   const Type* m_type = a-&gt;Value(&amp;_gvn);
5240   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5241   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5242       top_b == NULL || top_b-&gt;klass()  == NULL ||
5243       top_n == NULL || top_n-&gt;klass()  == NULL ||
5244       top_m == NULL || top_m-&gt;klass()  == NULL) {
5245     // failed array check
5246     return false;
5247   }
5248 
5249   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5250   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5251   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5252   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
</pre>
<hr />
<pre>
5272   return true;
5273 }
5274 
5275 bool LibraryCallKit::inline_montgomerySquare() {
5276   address stubAddr = StubRoutines::montgomerySquare();
5277   if (stubAddr == NULL) {
5278     return false; // Intrinsic&#39;s stub is not implemented on this platform
5279   }
5280 
5281   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5282   const char* stubName = &quot;montgomery_square&quot;;
5283 
5284   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5285 
5286   Node* a    = argument(0);
5287   Node* n    = argument(1);
5288   Node* len  = argument(2);
5289   Node* inv  = argument(3);
5290   Node* m    = argument(5);
5291 
<span class="line-removed">5292   a = access_resolve(a, ACCESS_READ);</span>
<span class="line-removed">5293   n = access_resolve(n, ACCESS_READ);</span>
<span class="line-removed">5294   m = access_resolve(m, ACCESS_WRITE);</span>
<span class="line-removed">5295 </span>
5296   const Type* a_type = a-&gt;Value(&amp;_gvn);
5297   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5298   const Type* n_type = a-&gt;Value(&amp;_gvn);
5299   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5300   const Type* m_type = a-&gt;Value(&amp;_gvn);
5301   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5302   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5303       top_n == NULL || top_n-&gt;klass()  == NULL ||
5304       top_m == NULL || top_m-&gt;klass()  == NULL) {
5305     // failed array check
5306     return false;
5307   }
5308 
5309   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5310   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5311   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5312   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5313     return false;
5314   }
5315 
5316   // Make the call
5317   {
5318     Node* a_start = array_element_address(a, intcon(0), a_elem);
5319     Node* n_start = array_element_address(n, intcon(0), n_elem);
5320     Node* m_start = array_element_address(m, intcon(0), m_elem);
5321 
5322     Node* call = make_runtime_call(RC_LEAF,
5323                                    OptoRuntime::montgomerySquare_Type(),
5324                                    stubAddr, stubName, TypePtr::BOTTOM,
5325                                    a_start, n_start, len, inv, top(),
5326                                    m_start);
5327     set_result(m);
5328   }
5329 
5330   return true;
5331 }
5332 






















































5333 //-------------inline_vectorizedMismatch------------------------------
5334 bool LibraryCallKit::inline_vectorizedMismatch() {
5335   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5336 
5337   address stubAddr = StubRoutines::vectorizedMismatch();
5338   if (stubAddr == NULL) {
5339     return false; // Intrinsic&#39;s stub is not implemented on this platform
5340   }
5341   const char* stubName = &quot;vectorizedMismatch&quot;;
5342   int size_l = callee()-&gt;signature()-&gt;size();
5343   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5344 
5345   Node* obja = argument(0);
5346   Node* aoffset = argument(1);
5347   Node* objb = argument(3);
5348   Node* boffset = argument(4);
5349   Node* length = argument(6);
5350   Node* scale = argument(7);
5351 
5352   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5353   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5354   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5355   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5356   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5357     top_b == NULL || top_b-&gt;klass() == NULL) {
5358     // failed array check
5359     return false;
5360   }
5361 
5362   Node* call;
5363   jvms()-&gt;set_should_reexecute(true);
5364 
<span class="line-removed">5365   obja = access_resolve(obja, ACCESS_READ);</span>
<span class="line-removed">5366   objb = access_resolve(objb, ACCESS_READ);</span>
5367   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5368   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5369 
5370   call = make_runtime_call(RC_LEAF,
5371     OptoRuntime::vectorizedMismatch_Type(),
5372     stubAddr, stubName, TypePtr::BOTTOM,
5373     obja_adr, objb_adr, length, scale);
5374 
5375   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5376   set_result(result);
5377   return true;
5378 }
5379 
5380 /**
5381  * Calculate CRC32 for byte.
5382  * int java.util.zip.CRC32.update(int crc, int b)
5383  */
5384 bool LibraryCallKit::inline_updateCRC32() {
5385   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5386   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
</pre>
<hr />
<pre>
5423   Node* crc     = argument(0); // type: int
5424   Node* src     = argument(1); // type: oop
5425   Node* offset  = argument(2); // type: int
5426   Node* length  = argument(3); // type: int
5427 
5428   const Type* src_type = src-&gt;Value(&amp;_gvn);
5429   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5430   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5431     // failed array check
5432     return false;
5433   }
5434 
5435   // Figure out the size and type of the elements we will be copying.
5436   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5437   if (src_elem != T_BYTE) {
5438     return false;
5439   }
5440 
5441   // &#39;src_start&#39; points to src array + scaled offset
5442   src = must_be_not_null(src, true);
<span class="line-removed">5443   src = access_resolve(src, ACCESS_READ);</span>
5444   Node* src_start = array_element_address(src, offset, src_elem);
5445 
5446   // We assume that range check is done by caller.
5447   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5448 
5449   // Call the stub.
5450   address stubAddr = StubRoutines::updateBytesCRC32();
5451   const char *stubName = &quot;updateBytesCRC32&quot;;
5452 
5453   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5454                                  stubAddr, stubName, TypePtr::BOTTOM,
5455                                  crc, src_start, length);
5456   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5457   set_result(result);
5458   return true;
5459 }
5460 
5461 /**
5462  * Calculate CRC32 for ByteBuffer.
5463  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
</pre>
<hr />
<pre>
5513   Node* offset  = argument(2); // type: int
5514   Node* end     = argument(3); // type: int
5515 
5516   Node* length = _gvn.transform(new SubINode(end, offset));
5517 
5518   const Type* src_type = src-&gt;Value(&amp;_gvn);
5519   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5520   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5521     // failed array check
5522     return false;
5523   }
5524 
5525   // Figure out the size and type of the elements we will be copying.
5526   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5527   if (src_elem != T_BYTE) {
5528     return false;
5529   }
5530 
5531   // &#39;src_start&#39; points to src array + scaled offset
5532   src = must_be_not_null(src, true);
<span class="line-removed">5533   src = access_resolve(src, ACCESS_READ);</span>
5534   Node* src_start = array_element_address(src, offset, src_elem);
5535 
5536   // static final int[] byteTable in class CRC32C
5537   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5538   table = must_be_not_null(table, true);
<span class="line-removed">5539   table = access_resolve(table, ACCESS_READ);</span>
5540   Node* table_start = array_element_address(table, intcon(0), T_INT);
5541 
5542   // We assume that range check is done by caller.
5543   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5544 
5545   // Call the stub.
5546   address stubAddr = StubRoutines::updateBytesCRC32C();
5547   const char *stubName = &quot;updateBytesCRC32C&quot;;
5548 
5549   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5550                                  stubAddr, stubName, TypePtr::BOTTOM,
5551                                  crc, src_start, length, table_start);
5552   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5553   set_result(result);
5554   return true;
5555 }
5556 
5557 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5558 //
5559 // Calculate CRC32C for DirectByteBuffer.
</pre>
<hr />
<pre>
5564   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5565   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5566   // no receiver since it is a static method
5567   Node* crc     = argument(0); // type: int
5568   Node* src     = argument(1); // type: long
5569   Node* offset  = argument(3); // type: int
5570   Node* end     = argument(4); // type: int
5571 
5572   Node* length = _gvn.transform(new SubINode(end, offset));
5573 
5574   src = ConvL2X(src);  // adjust Java long to machine word
5575   Node* base = _gvn.transform(new CastX2PNode(src));
5576   offset = ConvI2X(offset);
5577 
5578   // &#39;src_start&#39; points to src array + scaled offset
5579   Node* src_start = basic_plus_adr(top(), base, offset);
5580 
5581   // static final int[] byteTable in class CRC32C
5582   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5583   table = must_be_not_null(table, true);
<span class="line-removed">5584   table = access_resolve(table, ACCESS_READ);</span>
5585   Node* table_start = array_element_address(table, intcon(0), T_INT);
5586 
5587   // Call the stub.
5588   address stubAddr = StubRoutines::updateBytesCRC32C();
5589   const char *stubName = &quot;updateBytesCRC32C&quot;;
5590 
5591   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5592                                  stubAddr, stubName, TypePtr::BOTTOM,
5593                                  crc, src_start, length, table_start);
5594   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5595   set_result(result);
5596   return true;
5597 }
5598 
5599 //------------------------------inline_updateBytesAdler32----------------------
5600 //
5601 // Calculate Adler32 checksum for byte[] array.
5602 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5603 //
5604 bool LibraryCallKit::inline_updateBytesAdler32() {
</pre>
<hr />
<pre>
5608   // no receiver since it is static method
5609   Node* crc     = argument(0); // type: int
5610   Node* src     = argument(1); // type: oop
5611   Node* offset  = argument(2); // type: int
5612   Node* length  = argument(3); // type: int
5613 
5614   const Type* src_type = src-&gt;Value(&amp;_gvn);
5615   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5616   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5617     // failed array check
5618     return false;
5619   }
5620 
5621   // Figure out the size and type of the elements we will be copying.
5622   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5623   if (src_elem != T_BYTE) {
5624     return false;
5625   }
5626 
5627   // &#39;src_start&#39; points to src array + scaled offset
<span class="line-removed">5628   src = access_resolve(src, ACCESS_READ);</span>
5629   Node* src_start = array_element_address(src, offset, src_elem);
5630 
5631   // We assume that range check is done by caller.
5632   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5633 
5634   // Call the stub.
5635   address stubAddr = StubRoutines::updateBytesAdler32();
5636   const char *stubName = &quot;updateBytesAdler32&quot;;
5637 
5638   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5639                                  stubAddr, stubName, TypePtr::BOTTOM,
5640                                  crc, src_start, length);
5641   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5642   set_result(result);
5643   return true;
5644 }
5645 
5646 //------------------------------inline_updateByteBufferAdler32---------------
5647 //
5648 // Calculate Adler32 checksum for DirectByteBuffer.
</pre>
<hr />
<pre>
5812     stubName = &quot;aescrypt_encryptBlock&quot;;
5813     break;
5814   case vmIntrinsics::_aescrypt_decryptBlock:
5815     stubAddr = StubRoutines::aescrypt_decryptBlock();
5816     stubName = &quot;aescrypt_decryptBlock&quot;;
5817     break;
5818   default:
5819     break;
5820   }
5821   if (stubAddr == NULL) return false;
5822 
5823   Node* aescrypt_object = argument(0);
5824   Node* src             = argument(1);
5825   Node* src_offset      = argument(2);
5826   Node* dest            = argument(3);
5827   Node* dest_offset     = argument(4);
5828 
5829   src = must_be_not_null(src, true);
5830   dest = must_be_not_null(dest, true);
5831 
<span class="line-removed">5832   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">5833   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="line-removed">5834 </span>
5835   // (1) src and dest are arrays.
5836   const Type* src_type = src-&gt;Value(&amp;_gvn);
5837   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5838   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5839   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5840   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5841 
5842   // for the quick and dirty code we will skip all the checks.
5843   // we are just trying to get the call to be generated.
5844   Node* src_start  = src;
5845   Node* dest_start = dest;
5846   if (src_offset != NULL || dest_offset != NULL) {
5847     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5848     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5849     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5850   }
5851 
5852   // now need to get the start of its expanded key array
5853   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5854   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
</pre>
<hr />
<pre>
5888     break;
5889   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
5890     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
5891     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
5892     break;
5893   default:
5894     break;
5895   }
5896   if (stubAddr == NULL) return false;
5897 
5898   Node* cipherBlockChaining_object = argument(0);
5899   Node* src                        = argument(1);
5900   Node* src_offset                 = argument(2);
5901   Node* len                        = argument(3);
5902   Node* dest                       = argument(4);
5903   Node* dest_offset                = argument(5);
5904 
5905   src = must_be_not_null(src, false);
5906   dest = must_be_not_null(dest, false);
5907 
<span class="line-removed">5908   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">5909   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="line-removed">5910 </span>
5911   // (1) src and dest are arrays.
5912   const Type* src_type = src-&gt;Value(&amp;_gvn);
5913   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5914   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5915   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5916   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
5917           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5918 
5919   // checks are the responsibility of the caller
5920   Node* src_start  = src;
5921   Node* dest_start = dest;
5922   if (src_offset != NULL || dest_offset != NULL) {
5923     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5924     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5925     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5926   }
5927 
5928   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
5929   // (because of the predicated logic executed earlier).
5930   // so we cast it here safely.
</pre>
<hr />
<pre>
5936   // cast it to what we know it will be at runtime
5937   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
5938   assert(tinst != NULL, &quot;CBC obj is null&quot;);
5939   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
5940   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
5941   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
5942 
5943   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
5944   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
5945   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
5946   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
5947   aescrypt_object = _gvn.transform(aescrypt_object);
5948 
5949   // we need to get the start of the aescrypt_object&#39;s expanded key array
5950   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5951   if (k_start == NULL) return false;
5952 
5953   // similarly, get the start address of the r vector
5954   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
5955   if (objRvec == NULL) return false;
<span class="line-removed">5956   objRvec = access_resolve(objRvec, ACCESS_WRITE);</span>
5957   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
5958 
5959   Node* cbcCrypt;
5960   if (Matcher::pass_original_key_for_aes()) {
5961     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5962     // compatibility issues between Java key expansion and SPARC crypto instructions
5963     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5964     if (original_k_start == NULL) return false;
5965 
5966     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
5967     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5968                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5969                                  stubAddr, stubName, TypePtr::BOTTOM,
5970                                  src_start, dest_start, k_start, r_start, len, original_k_start);
5971   } else {
5972     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
5973     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5974                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5975                                  stubAddr, stubName, TypePtr::BOTTOM,
5976                                  src_start, dest_start, k_start, r_start, len);
5977   }
5978 
5979   // return cipher length (int)
5980   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
5981   set_result(retvalue);
5982   return true;
5983 }
5984 
























































































5985 //------------------------------inline_counterMode_AESCrypt-----------------------
5986 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
5987   assert(UseAES, &quot;need AES instruction support&quot;);
5988   if (!UseAESCTRIntrinsics) return false;
5989 
5990   address stubAddr = NULL;
5991   const char *stubName = NULL;
5992   if (id == vmIntrinsics::_counterMode_AESCrypt) {
5993     stubAddr = StubRoutines::counterMode_AESCrypt();
5994     stubName = &quot;counterMode_AESCrypt&quot;;
5995   }
5996   if (stubAddr == NULL) return false;
5997 
5998   Node* counterMode_object = argument(0);
5999   Node* src = argument(1);
6000   Node* src_offset = argument(2);
6001   Node* len = argument(3);
6002   Node* dest = argument(4);
6003   Node* dest_offset = argument(5);
6004 
<span class="line-removed">6005   src = access_resolve(src, ACCESS_READ);</span>
<span class="line-removed">6006   dest = access_resolve(dest, ACCESS_WRITE);</span>
<span class="line-removed">6007   counterMode_object = access_resolve(counterMode_object, ACCESS_WRITE);</span>
<span class="line-removed">6008 </span>
6009   // (1) src and dest are arrays.
6010   const Type* src_type = src-&gt;Value(&amp;_gvn);
6011   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6012   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6013   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6014   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6015          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6016 
6017   // checks are the responsibility of the caller
6018   Node* src_start = src;
6019   Node* dest_start = dest;
6020   if (src_offset != NULL || dest_offset != NULL) {
6021     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6022     src_start = array_element_address(src, src_offset, T_BYTE);
6023     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6024   }
6025 
6026   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6027   // (because of the predicated logic executed earlier).
6028   // so we cast it here safely.
6029   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6030   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6031   if (embeddedCipherObj == NULL) return false;
6032   // cast it to what we know it will be at runtime
6033   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6034   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6035   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6036   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6037   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6038   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6039   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6040   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6041   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6042   aescrypt_object = _gvn.transform(aescrypt_object);
6043   // we need to get the start of the aescrypt_object&#39;s expanded key array
6044   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6045   if (k_start == NULL) return false;
6046   // similarly, get the start address of the r vector
6047   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6048   if (obj_counter == NULL) return false;
<span class="line-removed">6049   obj_counter = access_resolve(obj_counter, ACCESS_WRITE);</span>
6050   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6051 
6052   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6053   if (saved_encCounter == NULL) return false;
<span class="line-removed">6054   saved_encCounter = access_resolve(saved_encCounter, ACCESS_WRITE);</span>
6055   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6056   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6057 
6058   Node* ctrCrypt;
6059   if (Matcher::pass_original_key_for_aes()) {
6060     // no SPARC version for AES/CTR intrinsics now.
6061     return false;
6062   }
6063   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6064   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6065                                OptoRuntime::counterMode_aescrypt_Type(),
6066                                stubAddr, stubName, TypePtr::BOTTOM,
6067                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6068 
6069   // return cipher length (int)
6070   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6071   set_result(retvalue);
6072   return true;
6073 }
6074 
6075 //------------------------------get_key_start_from_aescrypt_object-----------------------
6076 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6077 #if defined(PPC64) || defined(S390)
6078   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6079   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6080   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6081   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6082   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6083   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6084   if (objSessionK == NULL) {
6085     return (Node *) NULL;
6086   }
6087   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6088 #else
6089   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6090 #endif // PPC64
6091   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6092   if (objAESCryptKey == NULL) return (Node *) NULL;
6093 
6094   // now have the array, need to get the start address of the K array
<span class="line-removed">6095   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);</span>
6096   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6097   return k_start;
6098 }
6099 
6100 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6101 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6102   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6103   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6104   if (objAESCryptKey == NULL) return (Node *) NULL;
6105 
6106   // now have the array, need to get the start address of the lastKey array
<span class="line-removed">6107   objAESCryptKey = access_resolve(objAESCryptKey, ACCESS_READ);</span>
6108   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6109   return original_k_start;
6110 }
6111 
6112 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6113 // Return node representing slow path of predicate check.
6114 // the pseudo code we want to emulate with this predicate is:
6115 // for encryption:
6116 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6117 // for decryption:
6118 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6119 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6120 //
6121 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6122   // The receiver was checked for NULL already.
6123   Node* objCBC = argument(0);
6124 
6125   Node* src = argument(1);
6126   Node* dest = argument(4);
6127 
</pre>
<hr />
<pre>
6131   // get AESCrypt klass for instanceOf check
6132   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6133   // will have same classloader as CipherBlockChaining object
6134   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6135   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6136   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6137 
6138   // we want to do an instanceof comparison against the AESCrypt class
6139   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6140   if (!klass_AESCrypt-&gt;is_loaded()) {
6141     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6142     Node* ctrl = control();
6143     set_control(top()); // no regular fast path
6144     return ctrl;
6145   }
6146 
6147   src = must_be_not_null(src, true);
6148   dest = must_be_not_null(dest, true);
6149 
6150   // Resolve oops to stable for CmpP below.
<span class="line-removed">6151   src = access_resolve(src, 0);</span>
<span class="line-removed">6152   dest = access_resolve(dest, 0);</span>
<span class="line-removed">6153 </span>
6154   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6155 
6156   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6157   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6158   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6159 
6160   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6161 
6162   // for encryption, we are done
6163   if (!decrypting)
6164     return instof_false;  // even if it is NULL
6165 
6166   // for decryption, we need to add a further check to avoid
6167   // taking the intrinsic path when cipher and plain are the same
6168   // see the original java code for why.
6169   RegionNode* region = new RegionNode(3);
6170   region-&gt;init_req(1, instof_false);
6171 
6172   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6173   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6174   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6175   region-&gt;init_req(2, src_dest_conjoint);
6176 
6177   record_for_igvn(region);
6178   return _gvn.transform(region);
6179 }
6180 



























































6181 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6182 // Return node representing slow path of predicate check.
6183 // the pseudo code we want to emulate with this predicate is:
6184 // for encryption:
6185 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6186 // for decryption:
6187 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6188 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6189 //
6190 
6191 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6192   // The receiver was checked for NULL already.
6193   Node* objCTR = argument(0);
6194 
6195   // Load embeddedCipher field of CipherBlockChaining object.
6196   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6197 
6198   // get AESCrypt klass for instanceOf check
6199   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6200   // will have same classloader as CipherBlockChaining object
</pre>
<hr />
<pre>
6222 
6223 //------------------------------inline_ghash_processBlocks
6224 bool LibraryCallKit::inline_ghash_processBlocks() {
6225   address stubAddr;
6226   const char *stubName;
6227   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6228 
6229   stubAddr = StubRoutines::ghash_processBlocks();
6230   stubName = &quot;ghash_processBlocks&quot;;
6231 
6232   Node* data           = argument(0);
6233   Node* offset         = argument(1);
6234   Node* len            = argument(2);
6235   Node* state          = argument(3);
6236   Node* subkeyH        = argument(4);
6237 
6238   state = must_be_not_null(state, true);
6239   subkeyH = must_be_not_null(subkeyH, true);
6240   data = must_be_not_null(data, true);
6241 
<span class="line-removed">6242   state = access_resolve(state, ACCESS_WRITE);</span>
<span class="line-removed">6243   subkeyH = access_resolve(subkeyH, ACCESS_READ);</span>
<span class="line-removed">6244   data = access_resolve(data, ACCESS_READ);</span>
<span class="line-removed">6245 </span>
6246   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6247   assert(state_start, &quot;state is NULL&quot;);
6248   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6249   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6250   Node* data_start  = array_element_address(data, offset, T_BYTE);
6251   assert(data_start, &quot;data is NULL&quot;);
6252 
6253   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6254                                   OptoRuntime::ghash_processBlocks_Type(),
6255                                   stubAddr, stubName, TypePtr::BOTTOM,
6256                                   state_start, subkeyH_start, data_start, len);
6257   return true;
6258 }
6259 
6260 bool LibraryCallKit::inline_base64_encodeBlock() {
6261   address stubAddr;
6262   const char *stubName;
6263   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6264   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6265   stubAddr = StubRoutines::base64_encodeBlock();
6266   stubName = &quot;encodeBlock&quot;;
6267 
6268   if (!stubAddr) return false;
6269   Node* base64obj = argument(0);
6270   Node* src = argument(1);
6271   Node* offset = argument(2);
6272   Node* len = argument(3);
6273   Node* dest = argument(4);
6274   Node* dp = argument(5);
6275   Node* isURL = argument(6);
6276 
6277   src = must_be_not_null(src, true);
<span class="line-removed">6278   src = access_resolve(src, ACCESS_READ);</span>
6279   dest = must_be_not_null(dest, true);
<span class="line-removed">6280   dest = access_resolve(dest, ACCESS_WRITE);</span>
6281 
6282   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6283   assert(src_start, &quot;source array is NULL&quot;);
6284   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6285   assert(dest_start, &quot;destination array is NULL&quot;);
6286 
6287   Node* base64 = make_runtime_call(RC_LEAF,
6288                                    OptoRuntime::base64_encodeBlock_Type(),
6289                                    stubAddr, stubName, TypePtr::BOTTOM,
6290                                    src_start, offset, len, dest_start, dp, isURL);
6291   return true;
6292 }
6293 
6294 //------------------------------inline_sha_implCompress-----------------------
6295 //
6296 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6297 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6298 //
6299 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6300 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
</pre>
<hr />
<pre>
6305 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6306   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6307 
6308   Node* sha_obj = argument(0);
6309   Node* src     = argument(1); // type oop
6310   Node* ofs     = argument(2); // type int
6311 
6312   const Type* src_type = src-&gt;Value(&amp;_gvn);
6313   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6314   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6315     // failed array check
6316     return false;
6317   }
6318   // Figure out the size and type of the elements we will be copying.
6319   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6320   if (src_elem != T_BYTE) {
6321     return false;
6322   }
6323   // &#39;src_start&#39; points to src array + offset
6324   src = must_be_not_null(src, true);
<span class="line-removed">6325   src = access_resolve(src, ACCESS_READ);</span>
6326   Node* src_start = array_element_address(src, ofs, src_elem);
6327   Node* state = NULL;
6328   address stubAddr;
6329   const char *stubName;
6330 
6331   switch(id) {
6332   case vmIntrinsics::_sha_implCompress:
6333     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6334     state = get_state_from_sha_object(sha_obj);
6335     stubAddr = StubRoutines::sha1_implCompress();
6336     stubName = &quot;sha1_implCompress&quot;;
6337     break;
6338   case vmIntrinsics::_sha2_implCompress:
6339     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6340     state = get_state_from_sha_object(sha_obj);
6341     stubAddr = StubRoutines::sha256_implCompress();
6342     stubName = &quot;sha256_implCompress&quot;;
6343     break;
6344   case vmIntrinsics::_sha5_implCompress:
6345     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6346     state = get_state_from_sha5_object(sha_obj);
6347     stubAddr = StubRoutines::sha512_implCompress();
6348     stubName = &quot;sha512_implCompress&quot;;
6349     break;
6350   default:
6351     fatal_unexpected_iid(id);
6352     return false;
6353   }
6354   if (state == NULL) return false;
6355 



6356   // Call the stub.
6357   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6358                                  stubAddr, stubName, TypePtr::BOTTOM,
6359                                  src_start, state);
6360 
6361   return true;
6362 }
6363 
6364 //------------------------------inline_digestBase_implCompressMB-----------------------
6365 //
6366 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6367 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6368 //
6369 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6370   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6371          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6372   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6373   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6374 
6375   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6376   Node* src            = argument(1); // byte[] array
6377   Node* ofs            = argument(2); // type int
6378   Node* limit          = argument(3); // type int
6379 
6380   const Type* src_type = src-&gt;Value(&amp;_gvn);
6381   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6382   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6383     // failed array check
6384     return false;
6385   }
6386   // Figure out the size and type of the elements we will be copying.
6387   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6388   if (src_elem != T_BYTE) {
6389     return false;
6390   }
6391   // &#39;src_start&#39; points to src array + offset
6392   src = must_be_not_null(src, false);
<span class="line-removed">6393   src = access_resolve(src, ACCESS_READ);</span>
6394   Node* src_start = array_element_address(src, ofs, src_elem);
6395 
6396   const char* klass_SHA_name = NULL;
6397   const char* stub_name = NULL;
6398   address     stub_addr = NULL;
6399   bool        long_state = false;
6400 
6401   switch (predicate) {
6402   case 0:
6403     if (UseSHA1Intrinsics) {
6404       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6405       stub_name = &quot;sha1_implCompressMB&quot;;
6406       stub_addr = StubRoutines::sha1_implCompressMB();
6407     }
6408     break;
6409   case 1:
6410     if (UseSHA256Intrinsics) {
6411       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6412       stub_name = &quot;sha256_implCompressMB&quot;;
6413       stub_addr = StubRoutines::sha256_implCompressMB();
6414     }
6415     break;
6416   case 2:
6417     if (UseSHA512Intrinsics) {
6418       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6419       stub_name = &quot;sha512_implCompressMB&quot;;
6420       stub_addr = StubRoutines::sha512_implCompressMB();
6421       long_state = true;
6422     }
6423     break;
6424   default:
6425     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6426   }
6427   if (klass_SHA_name != NULL) {



6428     // get DigestBase klass to lookup for SHA klass
6429     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6430     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6431     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6432 
6433     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6434     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6435     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6436     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6437   }
6438   return false;
6439 }
6440 //------------------------------inline_sha_implCompressMB-----------------------
6441 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6442                                                bool long_state, address stubAddr, const char *stubName,
6443                                                Node* src_start, Node* ofs, Node* limit) {
6444   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6445   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6446   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6447   sha_obj = _gvn.transform(sha_obj);
</pre>
<hr />
<pre>
6456 
6457   // Call the stub.
6458   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6459                                  OptoRuntime::digestBase_implCompressMB_Type(),
6460                                  stubAddr, stubName, TypePtr::BOTTOM,
6461                                  src_start, state, ofs, limit);
6462   // return ofs (int)
6463   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6464   set_result(result);
6465 
6466   return true;
6467 }
6468 
6469 //------------------------------get_state_from_sha_object-----------------------
6470 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6471   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6472   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6473   if (sha_state == NULL) return (Node *) NULL;
6474 
6475   // now have the array, need to get the start address of the state array
<span class="line-removed">6476   sha_state = access_resolve(sha_state, ACCESS_WRITE);</span>
6477   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6478   return state;
6479 }
6480 
6481 //------------------------------get_state_from_sha5_object-----------------------
6482 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6483   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6484   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6485   if (sha_state == NULL) return (Node *) NULL;
6486 
6487   // now have the array, need to get the start address of the state array
<span class="line-removed">6488   sha_state = access_resolve(sha_state, ACCESS_WRITE);</span>
6489   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6490   return state;
6491 }
6492 
6493 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6494 // Return node representing slow path of predicate check.
6495 // the pseudo code we want to emulate with this predicate is:
6496 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6497 //
6498 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6499   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6500          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6501   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6502 
6503   // The receiver was checked for NULL already.
6504   Node* digestBaseObj = argument(0);
6505 
6506   // get DigestBase klass for instanceOf check
6507   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6508   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
</pre>
<hr />
<pre>
6646   Node *a = NULL;
6647   Node *b = NULL;
6648   Node *n = NULL;
6649   switch (id) {
6650   case vmIntrinsics::_maxF:
6651   case vmIntrinsics::_minF:
6652     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
6653     a = argument(0);
6654     b = argument(1);
6655     break;
6656   case vmIntrinsics::_maxD:
6657   case vmIntrinsics::_minD:
6658     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
6659     a = round_double_node(argument(0));
6660     b = round_double_node(argument(2));
6661     break;
6662   default:
6663     fatal_unexpected_iid(id);
6664     break;
6665   }
<span class="line-removed">6666   if (a-&gt;is_Con() || b-&gt;is_Con()) {</span>
<span class="line-removed">6667     return false;</span>
<span class="line-removed">6668   }</span>
6669   switch (id) {
6670   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
6671   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
6672   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
6673   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
6674   default:  fatal_unexpected_iid(id);  break;
6675   }
6676   set_result(_gvn.transform(n));
6677   return true;
6678 }
6679 
6680 bool LibraryCallKit::inline_profileBoolean() {
6681   Node* counts = argument(1);
6682   const TypeAryPtr* ary = NULL;
6683   ciArray* aobj = NULL;
6684   if (counts-&gt;is_Con()
6685       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
6686       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
6687       &amp;&amp; (aobj-&gt;length() == 2)) {
6688     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  35 #include &quot;oops/klass.inline.hpp&quot;</span>
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;opto/addnode.hpp&quot;
  38 #include &quot;opto/arraycopynode.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callGenerator.hpp&quot;
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/intrinsicnode.hpp&quot;
  46 #include &quot;opto/idealKit.hpp&quot;
  47 #include &quot;opto/mathexactnode.hpp&quot;
  48 #include &quot;opto/movenode.hpp&quot;
  49 #include &quot;opto/mulnode.hpp&quot;
  50 #include &quot;opto/narrowptrnode.hpp&quot;
  51 #include &quot;opto/opaquenode.hpp&quot;
  52 #include &quot;opto/parse.hpp&quot;
  53 #include &quot;opto/runtime.hpp&quot;
  54 #include &quot;opto/rootnode.hpp&quot;
  55 #include &quot;opto/subnode.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;prims/unsafe.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  61 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  62 
  63 class LibraryIntrinsic : public InlineCallGenerator {
  64   // Extend the set of intrinsics known to the runtime:
  65  public:
  66  private:
  67   bool             _is_virtual;
  68   bool             _does_virtual_dispatch;
  69   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  70   int8_t           _last_predicate; // Last generated predicate
  71   vmIntrinsics::ID _intrinsic_id;
  72 
  73  public:
  74   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  75     : InlineCallGenerator(m),
  76       _is_virtual(is_virtual),
  77       _does_virtual_dispatch(does_virtual_dispatch),
  78       _predicates_count((int8_t)predicates_count),
  79       _last_predicate((int8_t)-1),
  80       _intrinsic_id(id)
  81   {
</pre>
<hr />
<pre>
 211   }
 212   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 213   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 214 
 215   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 216   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 217   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 218   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 219   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 220                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 221   bool inline_string_indexOfChar();
 222   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 223   bool inline_string_toBytesU();
 224   bool inline_string_getCharsU();
 225   bool inline_string_copy(bool compress);
 226   bool inline_string_char_access(bool is_store);
 227   Node* round_double_node(Node* n);
 228   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 229   bool inline_math_native(vmIntrinsics::ID id);
 230   bool inline_math(vmIntrinsics::ID id);
<span class="line-added"> 231   bool inline_double_math(vmIntrinsics::ID id);</span>
 232   template &lt;typename OverflowOp&gt;
 233   bool inline_math_overflow(Node* arg1, Node* arg2);
 234   void inline_math_mathExact(Node* math, Node* test);
 235   bool inline_math_addExactI(bool is_increment);
 236   bool inline_math_addExactL(bool is_increment);
 237   bool inline_math_multiplyExactI();
 238   bool inline_math_multiplyExactL();
 239   bool inline_math_multiplyHigh();
 240   bool inline_math_negateExactI();
 241   bool inline_math_negateExactL();
 242   bool inline_math_subtractExactI(bool is_decrement);
 243   bool inline_math_subtractExactL(bool is_decrement);
 244   bool inline_min_max(vmIntrinsics::ID id);
 245   bool inline_notify(vmIntrinsics::ID id);
 246   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 247   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 248   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 249   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 250 
 251   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 252   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 253   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 254   static bool klass_needs_init_guard(Node* kls);
 255   bool inline_unsafe_allocate();
 256   bool inline_unsafe_newArray(bool uninitialized);
<span class="line-added"> 257   bool inline_unsafe_writeback0();</span>
<span class="line-added"> 258   bool inline_unsafe_writebackSync0(bool is_pre);</span>
 259   bool inline_unsafe_copyMemory();
 260   bool inline_native_currentThread();
 261 
 262   bool inline_native_time_funcs(address method, const char* funcName);
 263 #ifdef JFR_HAVE_INTRINSICS
 264   bool inline_native_classID();
 265   bool inline_native_getEventWriter();
 266 #endif

 267   bool inline_native_Class_query(vmIntrinsics::ID id);
 268   bool inline_native_subtype_check();
 269   bool inline_native_getLength();
 270   bool inline_array_copyOf(bool is_copyOfRange);
 271   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 272   bool inline_preconditions_checkIndex();
 273   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 274   bool inline_native_clone(bool is_virtual);
 275   bool inline_native_Reflection_getCallerClass();
 276   // Helper function for inlining native object hash method
 277   bool inline_native_hashcode(bool is_virtual, bool is_static);
 278   bool inline_native_getClass();
 279 
 280   // Helper functions for inlining arraycopy
 281   bool inline_arraycopy();
 282   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 283                                                 RegionNode* slow_region);
 284   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 285   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 286                                       uint new_idx);
 287 
 288   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 289   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 290   bool inline_unsafe_fence(vmIntrinsics::ID id);
 291   bool inline_onspinwait();
 292   bool inline_fp_conversions(vmIntrinsics::ID id);
 293   bool inline_number_methods(vmIntrinsics::ID id);
 294   bool inline_reference_get();
 295   bool inline_Class_cast();
 296   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 297   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
<span class="line-added"> 298   bool inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id);</span>
 299   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 300   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
<span class="line-added"> 301   Node* inline_electronicCodeBook_AESCrypt_predicate(bool decrypting);</span>
 302   Node* inline_counterMode_AESCrypt_predicate();
 303   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 304   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 305   bool inline_ghash_processBlocks();
 306   bool inline_base64_encodeBlock();
 307   bool inline_sha_implCompress(vmIntrinsics::ID id);
 308   bool inline_digestBase_implCompressMB(int predicate);
 309   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 310                                  bool long_state, address stubAddr, const char *stubName,
 311                                  Node* src_start, Node* ofs, Node* limit);
 312   Node* get_state_from_sha_object(Node *sha_object);
 313   Node* get_state_from_sha5_object(Node *sha_object);
 314   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 315   bool inline_encodeISOArray();
 316   bool inline_updateCRC32();
 317   bool inline_updateBytesCRC32();
 318   bool inline_updateByteBufferCRC32();
 319   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 320   bool inline_updateBytesCRC32C();
 321   bool inline_updateDirectByteBufferCRC32C();
 322   bool inline_updateBytesAdler32();
 323   bool inline_updateByteBufferAdler32();
 324   bool inline_multiplyToLen();
 325   bool inline_hasNegatives();
 326   bool inline_squareToLen();
 327   bool inline_mulAdd();
 328   bool inline_montgomeryMultiply();
 329   bool inline_montgomerySquare();
<span class="line-added"> 330   bool inline_bigIntegerShift(bool isRightShift);</span>
 331   bool inline_vectorizedMismatch();
 332   bool inline_fma(vmIntrinsics::ID id);
 333   bool inline_character_compare(vmIntrinsics::ID id);
 334   bool inline_fp_min_max(vmIntrinsics::ID id);
 335 
 336   bool inline_profileBoolean();
 337   bool inline_isCompileConstant();
 338   void clear_upper_avx() {
 339 #ifdef X86
 340     if (UseAVX &gt;= 2) {
 341       C-&gt;set_clear_upper_avx(true);
 342     }
 343 #endif
 344   }
 345 };
 346 
 347 //---------------------------make_vm_intrinsic----------------------------
 348 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 349   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 350   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
</pre>
<hr />
<pre>
 518   // Handle symbolic names for otherwise undistinguished boolean switches:
 519   const bool is_store       = true;
 520   const bool is_compress    = true;
 521   const bool is_static      = true;
 522   const bool is_volatile    = true;
 523 
 524   if (!jvms()-&gt;has_method()) {
 525     // Root JVMState has a null method.
 526     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 527     // Insert the memory aliasing node
 528     set_all_memory(reset_memory());
 529   }
 530   assert(merged_memory(), &quot;&quot;);
 531 
 532 
 533   switch (intrinsic_id()) {
 534   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 535   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 536   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 537 
<span class="line-added"> 538   case vmIntrinsics::_ceil:</span>
<span class="line-added"> 539   case vmIntrinsics::_floor:</span>
<span class="line-added"> 540   case vmIntrinsics::_rint:</span>
 541   case vmIntrinsics::_dsin:
 542   case vmIntrinsics::_dcos:
 543   case vmIntrinsics::_dtan:
 544   case vmIntrinsics::_dabs:
<span class="line-added"> 545   case vmIntrinsics::_fabs:</span>
<span class="line-added"> 546   case vmIntrinsics::_iabs:</span>
<span class="line-added"> 547   case vmIntrinsics::_labs:</span>
 548   case vmIntrinsics::_datan2:
 549   case vmIntrinsics::_dsqrt:
 550   case vmIntrinsics::_dexp:
 551   case vmIntrinsics::_dlog:
 552   case vmIntrinsics::_dlog10:
 553   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 554 
 555   case vmIntrinsics::_min:
 556   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 557 
 558   case vmIntrinsics::_notify:
 559   case vmIntrinsics::_notifyAll:
 560     return inline_notify(intrinsic_id());
 561 
 562   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 563   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 564   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 565   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 566   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 567   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
</pre>
<hr />
<pre>
 735   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 736 
 737   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 738   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 739   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 740   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 741 
 742   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 743   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 744   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 745   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 746   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 747 
 748   case vmIntrinsics::_loadFence:
 749   case vmIntrinsics::_storeFence:
 750   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 751 
 752   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 753 
 754   case vmIntrinsics::_currentThread:            return inline_native_currentThread();

 755 
 756 #ifdef JFR_HAVE_INTRINSICS
 757   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 758   case vmIntrinsics::_getClassId:               return inline_native_classID();
 759   case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 760 #endif
 761   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 762   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
<span class="line-added"> 763   case vmIntrinsics::_writeback0:               return inline_unsafe_writeback0();</span>
<span class="line-added"> 764   case vmIntrinsics::_writebackPreSync0:        return inline_unsafe_writebackSync0(true);</span>
<span class="line-added"> 765   case vmIntrinsics::_writebackPostSync0:       return inline_unsafe_writebackSync0(false);</span>
 766   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 767   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 768   case vmIntrinsics::_getLength:                return inline_native_getLength();
 769   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 770   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 771   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 772   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 773   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 774   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 775 
 776   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 777   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 778 
 779   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 780 
 781   case vmIntrinsics::_isInstance:
 782   case vmIntrinsics::_getModifiers:
 783   case vmIntrinsics::_isInterface:
 784   case vmIntrinsics::_isArray:
 785   case vmIntrinsics::_isPrimitive:
</pre>
<hr />
<pre>
 800   case vmIntrinsics::_bitCount_i:
 801   case vmIntrinsics::_bitCount_l:
 802   case vmIntrinsics::_reverseBytes_i:
 803   case vmIntrinsics::_reverseBytes_l:
 804   case vmIntrinsics::_reverseBytes_s:
 805   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 806 
 807   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 808 
 809   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 810 
 811   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 812 
 813   case vmIntrinsics::_aescrypt_encryptBlock:
 814   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 815 
 816   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 817   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 818     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 819 
<span class="line-added"> 820   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="line-added"> 821   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="line-added"> 822     return inline_electronicCodeBook_AESCrypt(intrinsic_id());</span>
<span class="line-added"> 823 </span>
 824   case vmIntrinsics::_counterMode_AESCrypt:
 825     return inline_counterMode_AESCrypt(intrinsic_id());
 826 
 827   case vmIntrinsics::_sha_implCompress:
 828   case vmIntrinsics::_sha2_implCompress:
 829   case vmIntrinsics::_sha5_implCompress:
 830     return inline_sha_implCompress(intrinsic_id());
 831 
 832   case vmIntrinsics::_digestBase_implCompressMB:
 833     return inline_digestBase_implCompressMB(predicate);
 834 
 835   case vmIntrinsics::_multiplyToLen:
 836     return inline_multiplyToLen();
 837 
 838   case vmIntrinsics::_squareToLen:
 839     return inline_squareToLen();
 840 
 841   case vmIntrinsics::_mulAdd:
 842     return inline_mulAdd();
 843 
 844   case vmIntrinsics::_montgomeryMultiply:
 845     return inline_montgomeryMultiply();
 846   case vmIntrinsics::_montgomerySquare:
 847     return inline_montgomerySquare();
 848 
<span class="line-added"> 849   case vmIntrinsics::_bigIntegerRightShiftWorker:</span>
<span class="line-added"> 850     return inline_bigIntegerShift(true);</span>
<span class="line-added"> 851   case vmIntrinsics::_bigIntegerLeftShiftWorker:</span>
<span class="line-added"> 852     return inline_bigIntegerShift(false);</span>
<span class="line-added"> 853 </span>
 854   case vmIntrinsics::_vectorizedMismatch:
 855     return inline_vectorizedMismatch();
 856 
 857   case vmIntrinsics::_ghash_processBlocks:
 858     return inline_ghash_processBlocks();
 859   case vmIntrinsics::_base64_encodeBlock:
 860     return inline_base64_encodeBlock();
 861 
 862   case vmIntrinsics::_encodeISOArray:
 863   case vmIntrinsics::_encodeByteISOArray:
 864     return inline_encodeISOArray();
 865 
 866   case vmIntrinsics::_updateCRC32:
 867     return inline_updateCRC32();
 868   case vmIntrinsics::_updateBytesCRC32:
 869     return inline_updateBytesCRC32();
 870   case vmIntrinsics::_updateByteBufferCRC32:
 871     return inline_updateByteBufferCRC32();
 872 
 873   case vmIntrinsics::_updateBytesCRC32C:
</pre>
<hr />
<pre>
 914     }
 915 #endif
 916     return false;
 917   }
 918 }
 919 
 920 Node* LibraryCallKit::try_to_predicate(int predicate) {
 921   if (!jvms()-&gt;has_method()) {
 922     // Root JVMState has a null method.
 923     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 924     // Insert the memory aliasing node
 925     set_all_memory(reset_memory());
 926   }
 927   assert(merged_memory(), &quot;&quot;);
 928 
 929   switch (intrinsic_id()) {
 930   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 931     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 932   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 933     return inline_cipherBlockChaining_AESCrypt_predicate(true);
<span class="line-added"> 934   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="line-added"> 935     return inline_electronicCodeBook_AESCrypt_predicate(false);</span>
<span class="line-added"> 936   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="line-added"> 937     return inline_electronicCodeBook_AESCrypt_predicate(true);</span>
 938   case vmIntrinsics::_counterMode_AESCrypt:
 939     return inline_counterMode_AESCrypt_predicate();
 940   case vmIntrinsics::_digestBase_implCompressMB:
 941     return inline_digestBase_implCompressMB_predicate(predicate);
 942 
 943   default:
 944     // If you get here, it may be that someone has added a new intrinsic
 945     // to the list in vmSymbols.hpp without implementing it here.
 946 #ifndef PRODUCT
 947     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 948       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 949                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 950     }
 951 #endif
 952     Node* slow_ctl = control();
 953     set_control(top()); // No fast path instrinsic
 954     return slow_ctl;
 955   }
 956 }
 957 
</pre>
<hr />
<pre>
1076   // Offset and count must not be negative
1077   generate_negative_guard(offset, bailout);
1078   generate_negative_guard(count, bailout);
1079   // Offset + count must not exceed length of array
1080   generate_limit_guard(offset, count, load_array_length(array), bailout);
1081 
1082   if (bailout-&gt;req() &gt; 1) {
1083     PreserveJVMState pjvms(this);
1084     set_control(_gvn.transform(bailout));
1085     uncommon_trap(Deoptimization::Reason_intrinsic,
1086                   Deoptimization::Action_maybe_recompile);
1087   }
1088 }
1089 
1090 //--------------------------generate_current_thread--------------------
1091 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1092   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1093   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1094   Node* thread = _gvn.transform(new ThreadLocalNode());
1095   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
<span class="line-modified">1096   Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p-&gt;bottom_type()-&gt;is_ptr(), thread_type, T_OBJECT, MemNode::unordered));</span>
1097   tls_output = thread;
1098   return threadObj;
1099 }
1100 
1101 
1102 //------------------------------make_string_method_node------------------------
1103 // Helper method for String intrinsic functions. This version is called with
1104 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1105 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1106 // containing the lengths of str1 and str2.
1107 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1108   Node* result = NULL;
1109   switch (opcode) {
1110   case Op_StrIndexOf:
1111     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1112                                 str1_start, cnt1, str2_start, cnt2, ae);
1113     break;
1114   case Op_StrComp:
1115     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1116                              str1_start, cnt1, str2_start, cnt2, ae);
</pre>
<hr />
<pre>
1124   default:
1125     ShouldNotReachHere();
1126     return NULL;
1127   }
1128 
1129   // All these intrinsics have checks.
1130   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1131   clear_upper_avx();
1132 
1133   return _gvn.transform(result);
1134 }
1135 
1136 //------------------------------inline_string_compareTo------------------------
1137 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1138   Node* arg1 = argument(0);
1139   Node* arg2 = argument(1);
1140 
1141   arg1 = must_be_not_null(arg1, true);
1142   arg2 = must_be_not_null(arg2, true);
1143 



1144   // Get start addr and length of first argument
1145   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1146   Node* arg1_cnt    = load_array_length(arg1);
1147 
1148   // Get start addr and length of second argument
1149   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1150   Node* arg2_cnt    = load_array_length(arg2);
1151 
1152   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1153   set_result(result);
1154   return true;
1155 }
1156 
1157 //------------------------------inline_string_equals------------------------
1158 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1159   Node* arg1 = argument(0);
1160   Node* arg2 = argument(1);
1161 
1162   // paths (plus control) merge
1163   RegionNode* region = new RegionNode(3);
1164   Node* phi = new PhiNode(region, TypeInt::BOOL);
1165 
1166   if (!stopped()) {
1167 
1168     arg1 = must_be_not_null(arg1, true);
1169     arg2 = must_be_not_null(arg2, true);
1170 



1171     // Get start addr and length of first argument
1172     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1173     Node* arg1_cnt    = load_array_length(arg1);
1174 
1175     // Get start addr and length of second argument
1176     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1177     Node* arg2_cnt    = load_array_length(arg2);
1178 
1179     // Check for arg1_cnt != arg2_cnt
1180     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1181     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1182     Node* if_ne = generate_slow_guard(bol, NULL);
1183     if (if_ne != NULL) {
1184       phi-&gt;init_req(2, intcon(0));
1185       region-&gt;init_req(2, if_ne);
1186     }
1187 
1188     // Check for count == 0 is done by assembler code for StrEquals.
1189 
1190     if (!stopped()) {
1191       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1192       phi-&gt;init_req(1, equals);
1193       region-&gt;init_req(1, control());
1194     }
1195   }
1196 
1197   // post merge
1198   set_control(_gvn.transform(region));
1199   record_for_igvn(region);
1200 
1201   set_result(_gvn.transform(phi));
1202   return true;
1203 }
1204 
1205 //------------------------------inline_array_equals----------------------------
1206 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1207   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1208   Node* arg1 = argument(0);
1209   Node* arg2 = argument(1);
1210 



1211   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1212   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1213   clear_upper_avx();
1214 
1215   return true;
1216 }
1217 
1218 //------------------------------inline_hasNegatives------------------------------
1219 bool LibraryCallKit::inline_hasNegatives() {
1220   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1221     return false;
1222   }
1223 
1224   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1225   // no receiver since it is static method
1226   Node* ba         = argument(0);
1227   Node* offset     = argument(1);
1228   Node* len        = argument(2);
1229 
1230   ba = must_be_not_null(ba, true);
1231 
1232   // Range checks
1233   generate_string_range_check(ba, offset, len, false);
1234   if (stopped()) {
1235     return true;
1236   }

1237   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1238   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1239   set_result(_gvn.transform(result));
1240   return true;
1241 }
1242 
1243 bool LibraryCallKit::inline_preconditions_checkIndex() {
1244   Node* index = argument(0);
1245   Node* length = argument(1);
1246   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1247     return false;
1248   }
1249 
1250   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1251   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1252 
1253   {
1254     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1255     uncommon_trap(Deoptimization::Reason_intrinsic,
1256                   Deoptimization::Action_make_not_entrant);
</pre>
<hr />
<pre>
1287   replace_in_map(index, result);
1288   clear_upper_avx();
1289   return true;
1290 }
1291 
1292 //------------------------------inline_string_indexOf------------------------
1293 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1294   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1295     return false;
1296   }
1297   Node* src = argument(0);
1298   Node* tgt = argument(1);
1299 
1300   // Make the merge point
1301   RegionNode* result_rgn = new RegionNode(4);
1302   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1303 
1304   src = must_be_not_null(src, true);
1305   tgt = must_be_not_null(tgt, true);
1306 



1307   // Get start addr and length of source string
1308   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1309   Node* src_count = load_array_length(src);
1310 
1311   // Get start addr and length of substring
1312   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1313   Node* tgt_count = load_array_length(tgt);
1314 
1315   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1316     // Divide src size by 2 if String is UTF16 encoded
1317     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1318   }
1319   if (ae == StrIntrinsicNode::UU) {
1320     // Divide substring size by 2 if String is UTF16 encoded
1321     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1322   }
1323 
1324   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1325   if (result != NULL) {
1326     result_phi-&gt;init_req(3, result);
</pre>
<hr />
<pre>
1334 }
1335 
1336 //-----------------------------inline_string_indexOf-----------------------
1337 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1338   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1339     return false;
1340   }
1341   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1342     return false;
1343   }
1344   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1345   Node* src         = argument(0); // byte[]
1346   Node* src_count   = argument(1); // char count
1347   Node* tgt         = argument(2); // byte[]
1348   Node* tgt_count   = argument(3); // char count
1349   Node* from_index  = argument(4); // char index
1350 
1351   src = must_be_not_null(src, true);
1352   tgt = must_be_not_null(tgt, true);
1353 



1354   // Multiply byte array index by 2 if String is UTF16 encoded
1355   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1356   src_count = _gvn.transform(new SubINode(src_count, from_index));
1357   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1358   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1359 
1360   // Range checks
1361   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1362   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1363   if (stopped()) {
1364     return true;
1365   }
1366 
1367   RegionNode* region = new RegionNode(5);
1368   Node* phi = new PhiNode(region, TypeInt::INT);
1369 
1370   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1371   if (result != NULL) {
1372     // The result is index relative to from_index if substring was found, -1 otherwise.
1373     // Generate code which will fold into cmove.
</pre>
<hr />
<pre>
1420     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1421   }
1422   return NULL;
1423 }
1424 
1425 //-----------------------------inline_string_indexOfChar-----------------------
1426 bool LibraryCallKit::inline_string_indexOfChar() {
1427   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1428     return false;
1429   }
1430   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1431     return false;
1432   }
1433   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1434   Node* src         = argument(0); // byte[]
1435   Node* tgt         = argument(1); // tgt is int ch
1436   Node* from_index  = argument(2);
1437   Node* max         = argument(3);
1438 
1439   src = must_be_not_null(src, true);

1440 
1441   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1442   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1443   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1444 
1445   // Range checks
1446   generate_string_range_check(src, src_offset, src_count, true);
1447   if (stopped()) {
1448     return true;
1449   }
1450 
1451   RegionNode* region = new RegionNode(3);
1452   Node* phi = new PhiNode(region, TypeInt::INT);
1453 
1454   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1455   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1456   _gvn.transform(result);
1457 
1458   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1459   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
</pre>
<hr />
<pre>
1510 
1511   src = must_be_not_null(src, true);
1512   dst = must_be_not_null(dst, true);
1513 
1514   // Convert char[] offsets to byte[] offsets
1515   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1516   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1517   if (convert_src) {
1518     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1519   } else if (convert_dst) {
1520     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1521   }
1522 
1523   // Range checks
1524   generate_string_range_check(src, src_offset, length, convert_src);
1525   generate_string_range_check(dst, dst_offset, length, convert_dst);
1526   if (stopped()) {
1527     return true;
1528   }
1529 



1530   Node* src_start = array_element_address(src, src_offset, src_elem);
1531   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1532   // &#39;src_start&#39; points to src array + scaled offset
1533   // &#39;dst_start&#39; points to dst array + scaled offset
1534   Node* count = NULL;
1535   if (compress) {
1536     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1537   } else {
1538     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1539   }
1540 
1541   if (alloc != NULL) {
1542     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1543       // &quot;You break it, you buy it.&quot;
1544       InitializeNode* init = alloc-&gt;initialization();
1545       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1546       init-&gt;set_complete_with_arraycopy();
1547       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1548       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1549     }
</pre>
<hr />
<pre>
1600     generate_limit_guard(offset, length, load_array_length(value), bailout);
1601     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1602     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1603 
1604     if (bailout-&gt;req() &gt; 1) {
1605       PreserveJVMState pjvms(this);
1606       set_control(_gvn.transform(bailout));
1607       uncommon_trap(Deoptimization::Reason_intrinsic,
1608                     Deoptimization::Action_maybe_recompile);
1609     }
1610     if (stopped()) {
1611       return true;
1612     }
1613 
1614     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1615     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1616     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1617     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1618 
1619     // Calculate starting addresses.

1620     Node* src_start = array_element_address(value, offset, T_CHAR);
1621     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1622 
1623     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1624     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1625     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1626 
1627     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1628     const char* copyfunc_name = &quot;arraycopy&quot;;
1629     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1630     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1631                       OptoRuntime::fast_arraycopy_Type(),
1632                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1633                       src_start, dst_start, ConvI2X(length) XTOP);
1634     // Do not let reads from the cloned object float above the arraycopy.
1635     if (alloc != NULL) {
1636       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1637         // &quot;You break it, you buy it.&quot;
1638         InitializeNode* init = alloc-&gt;initialization();
1639         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
</pre>
<hr />
<pre>
1683 
1684   // Check if a null path was taken unconditionally.
1685   src = null_check(src);
1686   dst = null_check(dst);
1687   if (stopped()) {
1688     return true;
1689   }
1690 
1691   // Get length and convert char[] offset to byte[] offset
1692   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1693   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1694 
1695   // Range checks
1696   generate_string_range_check(src, src_begin, length, true);
1697   generate_string_range_check(dst, dst_begin, length, false);
1698   if (stopped()) {
1699     return true;
1700   }
1701 
1702   if (!stopped()) {



1703     // Calculate starting addresses.
1704     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1705     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1706 
1707     // Check if array addresses are aligned to HeapWordSize
1708     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1709     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1710     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1711                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1712 
1713     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1714     const char* copyfunc_name = &quot;arraycopy&quot;;
1715     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1716     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1717                       OptoRuntime::fast_arraycopy_Type(),
1718                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1719                       src_start, dst_start, ConvI2X(length) XTOP);
1720     // Do not let reads from the cloned object float above the arraycopy.
1721     if (alloc != NULL) {
1722       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
</pre>
<hr />
<pre>
1751 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1752   Node* value  = argument(0);
1753   Node* index  = argument(1);
1754   Node* ch = is_store ? argument(2) : NULL;
1755 
1756   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1757   // correctly requires matched array shapes.
1758   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1759           &quot;sanity: byte[] and char[] bases agree&quot;);
1760   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1761           &quot;sanity: byte[] and char[] scales agree&quot;);
1762 
1763   // Bail when getChar over constants is requested: constant folding would
1764   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1765   // Java method would constant fold nicely instead.
1766   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1767     return false;
1768   }
1769 
1770   value = must_be_not_null(value, true);

1771 
1772   Node* adr = array_element_address(value, index, T_CHAR);
1773   if (adr-&gt;is_top()) {
1774     return false;
1775   }
1776   if (is_store) {
1777     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1778   } else {
1779     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1780     set_result(ch);
1781   }
1782   return true;
1783 }
1784 
1785 //--------------------------round_double_node--------------------------------
1786 // Round a double node if necessary.
1787 Node* LibraryCallKit::round_double_node(Node* n) {
<span class="line-modified">1788   if (Matcher::strict_fp_requires_explicit_rounding) {</span>
<span class="line-modified">1789 #ifdef IA32</span>
<span class="line-added">1790     if (UseSSE &lt; 2) {</span>
<span class="line-added">1791       n = _gvn.transform(new RoundDoubleNode(NULL, n));</span>
<span class="line-added">1792     }</span>
<span class="line-added">1793 #else</span>
<span class="line-added">1794     Unimplemented();</span>
<span class="line-added">1795 #endif // IA32</span>
<span class="line-added">1796   }</span>
1797   return n;
1798 }
1799 
1800 //------------------------------inline_math-----------------------------------
1801 // public static double Math.abs(double)
1802 // public static double Math.sqrt(double)
1803 // public static double Math.log(double)
1804 // public static double Math.log10(double)
<span class="line-modified">1805 bool LibraryCallKit::inline_double_math(vmIntrinsics::ID id) {</span>
1806   Node* arg = round_double_node(argument(0));
1807   Node* n = NULL;
1808   switch (id) {
1809   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1810   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
<span class="line-added">1811   case vmIntrinsics::_ceil:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_ceil); break;</span>
<span class="line-added">1812   case vmIntrinsics::_floor:  n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_floor); break;</span>
<span class="line-added">1813   case vmIntrinsics::_rint:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_rint); break;</span>
<span class="line-added">1814   default:  fatal_unexpected_iid(id);  break;</span>
<span class="line-added">1815   }</span>
<span class="line-added">1816   set_result(_gvn.transform(n));</span>
<span class="line-added">1817   return true;</span>
<span class="line-added">1818 }</span>
<span class="line-added">1819 </span>
<span class="line-added">1820 //------------------------------inline_math-----------------------------------</span>
<span class="line-added">1821 // public static float Math.abs(float)</span>
<span class="line-added">1822 // public static int Math.abs(int)</span>
<span class="line-added">1823 // public static long Math.abs(long)</span>
<span class="line-added">1824 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {</span>
<span class="line-added">1825   Node* arg = argument(0);</span>
<span class="line-added">1826   Node* n = NULL;</span>
<span class="line-added">1827   switch (id) {</span>
<span class="line-added">1828   case vmIntrinsics::_fabs:   n = new AbsFNode(                arg);  break;</span>
<span class="line-added">1829   case vmIntrinsics::_iabs:   n = new AbsINode(                arg);  break;</span>
<span class="line-added">1830   case vmIntrinsics::_labs:   n = new AbsLNode(                arg);  break;</span>
1831   default:  fatal_unexpected_iid(id);  break;
1832   }
1833   set_result(_gvn.transform(n));
1834   return true;
1835 }
1836 
1837 //------------------------------runtime_math-----------------------------
1838 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1839   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1840          &quot;must be (DD)D or (D)D type&quot;);
1841 
1842   // Inputs
1843   Node* a = round_double_node(argument(0));
1844   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1845 
1846   const TypePtr* no_memory_effects = NULL;
1847   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1848                                  no_memory_effects,
1849                                  a, top(), b, b ? top() : NULL);
1850   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
</pre>
<hr />
<pre>
1867       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1868       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1869   case vmIntrinsics::_dcos:
1870     return StubRoutines::dcos() != NULL ?
1871       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1872       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1873   case vmIntrinsics::_dtan:
1874     return StubRoutines::dtan() != NULL ?
1875       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1876       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1877   case vmIntrinsics::_dlog:
1878     return StubRoutines::dlog() != NULL ?
1879       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1880       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1881   case vmIntrinsics::_dlog10:
1882     return StubRoutines::dlog10() != NULL ?
1883       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1884       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1885 
1886     // These intrinsics are supported on all hardware
<span class="line-modified">1887   case vmIntrinsics::_ceil:</span>
<span class="line-modified">1888   case vmIntrinsics::_floor:</span>
<span class="line-added">1889   case vmIntrinsics::_rint:   return Matcher::match_rule_supported(Op_RoundDoubleMode) ? inline_double_math(id) : false;</span>
<span class="line-added">1890   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_double_math(id) : false;</span>
<span class="line-added">1891   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_double_math(id) : false;</span>
<span class="line-added">1892   case vmIntrinsics::_fabs:   return Matcher::match_rule_supported(Op_AbsF)   ? inline_math(id) : false;</span>
<span class="line-added">1893   case vmIntrinsics::_iabs:   return Matcher::match_rule_supported(Op_AbsI)   ? inline_math(id) : false;</span>
<span class="line-added">1894   case vmIntrinsics::_labs:   return Matcher::match_rule_supported(Op_AbsL)   ? inline_math(id) : false;</span>
1895 
1896   case vmIntrinsics::_dexp:
1897     return StubRoutines::dexp() != NULL ?
1898       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1899       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1900   case vmIntrinsics::_dpow: {
1901     Node* exp = round_double_node(argument(2));
1902     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1903     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1904       // Special case: pow(x, 2.0) =&gt; x * x
1905       Node* base = round_double_node(argument(0));
1906       set_result(_gvn.transform(new MulDNode(base, base)));
1907       return true;
1908     }
1909     return StubRoutines::dpow() != NULL ?
1910       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1911       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1912   }
1913 #undef FN_PTR
1914 
</pre>
<hr />
<pre>
2249           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2250         // According to profiling, this access is always on
2251         // heap. Casting the base to not null and thus avoiding membars
2252         // around the access should allow better optimizations
2253         Node* null_ctl = top();
2254         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2255         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2256         return basic_plus_adr(base, offset);
2257       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2258                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2259         // According to profiling, this access is always off
2260         // heap.
2261         base = null_assert(base);
2262         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2263         offset = MakeConX(0);
2264         return basic_plus_adr(top(), raw_base, offset);
2265       }
2266     }
2267     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2268     // to raw memory access.

2269     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2270     return basic_plus_adr(top(), raw, offset);
2271   } else {
2272     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2273     // We know it&#39;s an on heap access so base can&#39;t be null
2274     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2275       base = must_be_not_null(base, true);
2276     }
2277     return basic_plus_adr(base, offset);
2278   }
2279 }
2280 
2281 //--------------------------inline_number_methods-----------------------------
2282 // inline int     Integer.numberOfLeadingZeros(int)
2283 // inline int        Long.numberOfLeadingZeros(long)
2284 //
2285 // inline int     Integer.numberOfTrailingZeros(int)
2286 // inline int        Long.numberOfTrailingZeros(long)
2287 //
2288 // inline int     Integer.bitCount(int)
</pre>
<hr />
<pre>
2360         return MO_RELAXED;
2361       case Acquire:
2362         return MO_ACQUIRE;
2363       case Release:
2364         return MO_RELEASE;
2365       case Volatile:
2366         return MO_SEQ_CST;
2367       default:
2368         ShouldNotReachHere();
2369         return 0;
2370   }
2371 }
2372 
2373 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2374   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2375   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2376   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2377   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2378   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2379 
<span class="line-modified">2380   if (is_reference_type(type)) {</span>
2381     decorators |= ON_UNKNOWN_OOP_REF;
2382   }
2383 
2384   if (unaligned) {
2385     decorators |= C2_UNALIGNED;
2386   }
2387 
2388 #ifndef PRODUCT
2389   {
2390     ResourceMark rm;
2391     // Check the signatures.
2392     ciSignature* sig = callee()-&gt;signature();
2393 #ifdef ASSERT
2394     if (!is_store) {
2395       // Object getReference(Object base, int/long offset), etc.
2396       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2397       assert(rtype == type, &quot;getter must return the expected value&quot;);
2398       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);
2399       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2400       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
</pre>
<hr />
<pre>
2417 
2418   // Build address expression.
2419   Node* adr;
2420   Node* heap_base_oop = top();
2421   Node* offset = top();
2422   Node* val;
2423 
2424   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2425   Node* base = argument(1);  // type: oop
2426   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2427   offset = argument(2);  // type: long
2428   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2429   // to be plain byte offsets, which are also the same as those accepted
2430   // by oopDesc::field_addr.
2431   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2432          &quot;fieldOffset must be byte-scaled&quot;);
2433   // 32-bit machines ignore the high half!
2434   offset = ConvL2X(offset);
2435   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2436 
<span class="line-modified">2437   if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {</span>
<span class="line-modified">2438     if (type != T_OBJECT) {</span>
<span class="line-modified">2439       decorators |= IN_NATIVE; // off-heap primitive access</span>
<span class="line-modified">2440     } else {</span>
<span class="line-added">2441       return false; // off-heap oop accesses are not supported</span>
<span class="line-added">2442     }</span>
<span class="line-added">2443   } else {</span>
<span class="line-added">2444     heap_base_oop = base; // on-heap or mixed access</span>
2445   }
2446 
2447   // Can base be NULL? Otherwise, always on-heap access.
<span class="line-modified">2448   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base));</span>
2449 
2450   if (!can_access_non_heap) {
2451     decorators |= IN_HEAP;
2452   }
2453 
2454   val = is_store ? argument(4) : NULL;
2455 
<span class="line-modified">2456   const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();</span>
<span class="line-added">2457   if (adr_type == TypePtr::NULL_PTR) {</span>
<span class="line-added">2458     return false; // off-heap access with zero address</span>
<span class="line-added">2459   }</span>
2460 
2461   // Try to categorize the address.
2462   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2463   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2464 
2465   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2466       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2467     return false; // not supported
2468   }
2469 
2470   bool mismatched = false;
2471   BasicType bt = alias_type-&gt;basic_type();
2472   if (bt != T_ILLEGAL) {
2473     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2474     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2475       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2476       // Use address type to get the element type.
2477       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2478     }
2479     if (bt == T_ARRAY || bt == T_NARROWOOP) {
</pre>
<hr />
<pre>
2712       newval   = argument(4);  // type: oop, int, or long
2713       break;
2714     }
2715     default:
2716       ShouldNotReachHere();
2717   }
2718 
2719   // Build field offset expression.
2720   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2721   // to be plain byte offsets, which are also the same as those accepted
2722   // by oopDesc::field_addr.
2723   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2724   // 32-bit machines ignore the high half of long offsets
2725   offset = ConvL2X(offset);
2726   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2727   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2728 
2729   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2730   BasicType bt = alias_type-&gt;basic_type();
2731   if (bt != T_ILLEGAL &amp;&amp;
<span class="line-modified">2732       (is_reference_type(bt) != (type == T_OBJECT))) {</span>
2733     // Don&#39;t intrinsify mismatched object accesses.
2734     return false;
2735   }
2736 
2737   // For CAS, unlike inline_unsafe_access, there seems no point in
2738   // trying to refine types. Just use the coarse types here.
2739   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2740   const Type *value_type = Type::get_const_basic_type(type);
2741 
2742   switch (kind) {
2743     case LS_get_set:
2744     case LS_cmp_exchange: {
2745       if (type == T_OBJECT) {
2746         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2747         if (tjp != NULL) {
2748           value_type = tjp;
2749         }
2750       }
2751       break;
2752     }
2753     case LS_cmp_swap:
2754     case LS_cmp_swap_weak:
2755     case LS_get_add:
2756       break;
2757     default:
2758       ShouldNotReachHere();
2759   }
2760 
2761   // Null check receiver.
2762   receiver = null_check(receiver);
2763   if (stopped()) {
2764     return true;
2765   }
2766 
2767   int alias_idx = C-&gt;get_alias_index(adr_type);
2768 
<span class="line-modified">2769   if (is_reference_type(type)) {</span>
2770     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2771 
2772     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2773     // could be delayed during Parse (for example, in adjust_map_after_if()).
2774     // Execute transformation here to avoid barrier generation in such case.
2775     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2776       newval = _gvn.makecon(TypePtr::NULL_PTR);
2777 
2778     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2779       // Refine the value to a null constant, when it is known to be null
2780       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2781     }
2782   }
2783 
2784   Node* result = NULL;
2785   switch (kind) {
2786     case LS_cmp_exchange: {
2787       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
2788                                             oldval, newval, value_type, type, decorators);
2789       break;
</pre>
<hr />
<pre>
2835 }
2836 
2837 bool LibraryCallKit::inline_onspinwait() {
2838   insert_mem_bar(Op_OnSpinWait);
2839   return true;
2840 }
2841 
2842 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2843   if (!kls-&gt;is_Con()) {
2844     return true;
2845   }
2846   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2847   if (klsptr == NULL) {
2848     return true;
2849   }
2850   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2851   // don&#39;t need a guard for a klass that is already initialized
2852   return !ik-&gt;is_initialized();
2853 }
2854 
<span class="line-added">2855 //----------------------------inline_unsafe_writeback0-------------------------</span>
<span class="line-added">2856 // public native void Unsafe.writeback0(long address)</span>
<span class="line-added">2857 bool LibraryCallKit::inline_unsafe_writeback0() {</span>
<span class="line-added">2858   if (!Matcher::has_match_rule(Op_CacheWB)) {</span>
<span class="line-added">2859     return false;</span>
<span class="line-added">2860   }</span>
<span class="line-added">2861 #ifndef PRODUCT</span>
<span class="line-added">2862   assert(Matcher::has_match_rule(Op_CacheWBPreSync), &quot;found match rule for CacheWB but not CacheWBPreSync&quot;);</span>
<span class="line-added">2863   assert(Matcher::has_match_rule(Op_CacheWBPostSync), &quot;found match rule for CacheWB but not CacheWBPostSync&quot;);</span>
<span class="line-added">2864   ciSignature* sig = callee()-&gt;signature();</span>
<span class="line-added">2865   assert(sig-&gt;type_at(0)-&gt;basic_type() == T_LONG, &quot;Unsafe_writeback0 address is long!&quot;);</span>
<span class="line-added">2866 #endif</span>
<span class="line-added">2867   null_check_receiver();  // null-check, then ignore</span>
<span class="line-added">2868   Node *addr = argument(1);</span>
<span class="line-added">2869   addr = new CastX2PNode(addr);</span>
<span class="line-added">2870   addr = _gvn.transform(addr);</span>
<span class="line-added">2871   Node *flush = new CacheWBNode(control(), memory(TypeRawPtr::BOTTOM), addr);</span>
<span class="line-added">2872   flush = _gvn.transform(flush);</span>
<span class="line-added">2873   set_memory(flush, TypeRawPtr::BOTTOM);</span>
<span class="line-added">2874   return true;</span>
<span class="line-added">2875 }</span>
<span class="line-added">2876 </span>
<span class="line-added">2877 //----------------------------inline_unsafe_writeback0-------------------------</span>
<span class="line-added">2878 // public native void Unsafe.writeback0(long address)</span>
<span class="line-added">2879 bool LibraryCallKit::inline_unsafe_writebackSync0(bool is_pre) {</span>
<span class="line-added">2880   if (is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPreSync)) {</span>
<span class="line-added">2881     return false;</span>
<span class="line-added">2882   }</span>
<span class="line-added">2883   if (!is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPostSync)) {</span>
<span class="line-added">2884     return false;</span>
<span class="line-added">2885   }</span>
<span class="line-added">2886 #ifndef PRODUCT</span>
<span class="line-added">2887   assert(Matcher::has_match_rule(Op_CacheWB),</span>
<span class="line-added">2888          (is_pre ? &quot;found match rule for CacheWBPreSync but not CacheWB&quot;</span>
<span class="line-added">2889                 : &quot;found match rule for CacheWBPostSync but not CacheWB&quot;));</span>
<span class="line-added">2890 </span>
<span class="line-added">2891 #endif</span>
<span class="line-added">2892   null_check_receiver();  // null-check, then ignore</span>
<span class="line-added">2893   Node *sync;</span>
<span class="line-added">2894   if (is_pre) {</span>
<span class="line-added">2895     sync = new CacheWBPreSyncNode(control(), memory(TypeRawPtr::BOTTOM));</span>
<span class="line-added">2896   } else {</span>
<span class="line-added">2897     sync = new CacheWBPostSyncNode(control(), memory(TypeRawPtr::BOTTOM));</span>
<span class="line-added">2898   }</span>
<span class="line-added">2899   sync = _gvn.transform(sync);</span>
<span class="line-added">2900   set_memory(sync, TypeRawPtr::BOTTOM);</span>
<span class="line-added">2901   return true;</span>
<span class="line-added">2902 }</span>
<span class="line-added">2903 </span>
2904 //----------------------------inline_unsafe_allocate---------------------------
2905 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
2906 bool LibraryCallKit::inline_unsafe_allocate() {
2907   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2908 
2909   null_check_receiver();  // null-check, then ignore
2910   Node* cls = null_check(argument(1));
2911   if (stopped())  return true;
2912 
2913   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2914   kls = null_check(kls);
2915   if (stopped())  return true;  // argument was like int.class
2916 
2917   Node* test = NULL;
2918   if (LibraryCallKit::klass_needs_init_guard(kls)) {
2919     // Note:  The argument might still be an illegal value like
2920     // Serializable.class or Object[].class.   The runtime will handle it.
2921     // But we must make an explicit check for initialization.
2922     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
2923     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
</pre>
<hr />
<pre>
3013   set_control(jobj_is_not_null);
3014   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
3015                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
3016   result_rgn-&gt;init_req(_normal_path, control());
3017   result_val-&gt;init_req(_normal_path, res);
3018 
3019   set_result(result_rgn, result_val);
3020 
3021   return true;
3022 }
3023 
3024 #endif // JFR_HAVE_INTRINSICS
3025 
3026 //------------------------inline_native_currentThread------------------
3027 bool LibraryCallKit::inline_native_currentThread() {
3028   Node* junk = NULL;
3029   set_result(generate_current_thread(junk));
3030   return true;
3031 }
3032 


























































































































3033 //---------------------------load_mirror_from_klass----------------------------
3034 // Given a klass oop, load its java mirror (a java.lang.Class oop).
3035 Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
3036   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
3037   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3038   // mirror = ((OopHandle)mirror)-&gt;resolve();
3039   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);
3040 }
3041 
3042 //-----------------------load_klass_from_mirror_common-------------------------
3043 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3044 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3045 // and branch to the given path on the region.
3046 // If never_see_null, take an uncommon trap on null, so we can optimistically
3047 // compile for the non-null case.
3048 // If the region is NULL, force never_see_null = true.
3049 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3050                                                     bool never_see_null,
3051                                                     RegionNode* region,
3052                                                     int null_path,
</pre>
<hr />
<pre>
3367   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3368   record_for_igvn(region);
3369 
3370   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3371   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3372   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();
3373 
3374   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3375   int which_arg;
3376   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3377     Node* arg = args[which_arg];
3378     arg = null_check(arg);
3379     if (stopped())  break;
3380     args[which_arg] = arg;
3381 
3382     Node* p = basic_plus_adr(arg, class_klass_offset);
3383     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3384     klasses[which_arg] = _gvn.transform(kls);
3385   }
3386 




3387   // Having loaded both klasses, test each for null.
3388   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3389   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3390     Node* kls = klasses[which_arg];
3391     Node* null_ctl = top();
3392     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3393     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);
3394     region-&gt;init_req(prim_path, null_ctl);
3395     if (stopped())  break;
3396     klasses[which_arg] = kls;
3397   }
3398 
3399   if (!stopped()) {
3400     // now we have two reference types, in klasses[0..1]
3401     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3402     Node* superk = klasses[0];  // the receiver
3403     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3404     // now we have a successful reference subtype check
3405     region-&gt;set_req(_ref_subtype_path, control());
3406   }
</pre>
<hr />
<pre>
3652 
3653     // Bail out if length is negative.
3654     // Without this the new_array would throw
3655     // NegativeArraySizeException but IllegalArgumentException is what
3656     // should be thrown
3657     generate_negative_guard(length, bailout, &amp;length);
3658 
3659     if (bailout-&gt;req() &gt; 1) {
3660       PreserveJVMState pjvms(this);
3661       set_control(_gvn.transform(bailout));
3662       uncommon_trap(Deoptimization::Reason_intrinsic,
3663                     Deoptimization::Action_maybe_recompile);
3664     }
3665 
3666     if (!stopped()) {
3667       // How many elements will we copy from the original?
3668       // The answer is MinI(orig_length - start, length).
3669       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3670       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3671 


3672       // Generate a direct call to the right arraycopy function(s).
3673       // We know the copy is disjoint but we might not know if the
3674       // oop stores need checking.
3675       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
3676       // This will fail a store-check if x contains any non-nulls.
3677 
3678       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3679       // loads/stores but it is legal only if we&#39;re sure the
3680       // Arrays.copyOf would succeed. So we need all input arguments
3681       // to the copyOf to be validated, including that the copy to the
3682       // new array won&#39;t trigger an ArrayStoreException. That subtype
3683       // check can be optimized if we know something on the type of
3684       // the input array from type speculation.
3685       if (_gvn.type(klass_node)-&gt;singleton()) {
3686         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3687         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3688 
3689         int test = C-&gt;static_subtype_check(superk, subk);
3690         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3691           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3692           if (t_original-&gt;speculative_type() != NULL) {
3693             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3694           }
3695         }
3696       }
3697 
3698       bool validated = false;
3699       // Reason_class_check rather than Reason_intrinsic because we
3700       // want to intrinsify even if this traps.
3701       if (!too_many_traps(Deoptimization::Reason_class_check)) {
<span class="line-modified">3702         Node* not_subtype_ctrl = gen_subtype_check(original, klass_node);</span>

3703 
3704         if (not_subtype_ctrl != top()) {
3705           PreserveJVMState pjvms(this);
3706           set_control(not_subtype_ctrl);
3707           uncommon_trap(Deoptimization::Reason_class_check,
3708                         Deoptimization::Action_make_not_entrant);
3709           assert(stopped(), &quot;Should be stopped&quot;);
3710         }
3711         validated = true;
3712       }
3713 
3714       if (!stopped()) {
3715         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3716 
3717         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3718                                                 load_object_klass(original), klass_node);
3719         if (!is_copyOfRange) {
3720           ac-&gt;set_copyof(validated);
3721         } else {
3722           ac-&gt;set_copyofrange(validated);
</pre>
<hr />
<pre>
3872   // If this is a virtual call, we generate a funny guard.  We pull out
3873   // the vtable entry corresponding to hashCode() from the target object.
3874   // If the target method which we are calling happens to be the native
3875   // Object hashCode() method, we pass the guard.  We do not need this
3876   // guard for non-virtual calls -- the caller is known to be the native
3877   // Object hashCode().
3878   if (is_virtual) {
3879     // After null check, get the object&#39;s klass.
3880     Node* obj_klass = load_object_klass(obj);
3881     generate_virtual_guard(obj_klass, slow_region);
3882   }
3883 
3884   // Get the header out of the object, use LoadMarkNode when available
3885   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3886   // The control of the load must be NULL. Otherwise, the load can move before
3887   // the null check after castPP removal.
3888   Node* no_ctrl = NULL;
3889   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3890 
3891   // Test the header to see if it is unlocked.
<span class="line-modified">3892   Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);</span>
3893   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
<span class="line-modified">3894   Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);</span>
3895   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
3896   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
3897 
3898   generate_slow_guard(test_unlocked, slow_region);
3899 
3900   // Get the hash value and check to see that it has been properly assigned.
3901   // We depend on hash_mask being at most 32 bits and avoid the use of
3902   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
<span class="line-modified">3903   // vm: see markWord.hpp.</span>
<span class="line-modified">3904   Node *hash_mask      = _gvn.intcon(markWord::hash_mask);</span>
<span class="line-modified">3905   Node *hash_shift     = _gvn.intcon(markWord::hash_shift);</span>
3906   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
3907   // This hack lets the hash bits live anywhere in the mark object now, as long
3908   // as the shift drops the relevant bits into the low 32 bits.  Note that
3909   // Java spec says that HashCode is an int so there&#39;s no point in capturing
3910   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
3911   hshifted_header      = ConvX2I(hshifted_header);
3912   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
3913 
<span class="line-modified">3914   Node *no_hash_val    = _gvn.intcon(markWord::no_hash);</span>
3915   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
3916   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
3917 
3918   generate_slow_guard(test_assigned, slow_region);
3919 
3920   Node* init_mem = reset_memory();
3921   // fill in the rest of the null path:
3922   result_io -&gt;init_req(_null_path, i_o());
3923   result_mem-&gt;init_req(_null_path, init_mem);
3924 
3925   result_val-&gt;init_req(_fast_path, hash_val);
3926   result_reg-&gt;init_req(_fast_path, control());
3927   result_io -&gt;init_req(_fast_path, i_o());
3928   result_mem-&gt;init_req(_fast_path, init_mem);
3929 
3930   // Generate code for the slow case.  We make a call to hashCode().
3931   set_control(_gvn.transform(slow_region));
3932   if (!stopped()) {
3933     // No need for PreserveJVMState, because we&#39;re using up the present state.
3934     set_all_memory(init_mem);
</pre>
<hr />
<pre>
4148 }
4149 
4150 //----------------------inline_unsafe_copyMemory-------------------------
4151 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4152 bool LibraryCallKit::inline_unsafe_copyMemory() {
4153   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4154   null_check_receiver();  // null-check receiver
4155   if (stopped())  return true;
4156 
4157   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4158 
4159   Node* src_ptr =         argument(1);   // type: oop
4160   Node* src_off = ConvL2X(argument(2));  // type: long
4161   Node* dst_ptr =         argument(4);   // type: oop
4162   Node* dst_off = ConvL2X(argument(5));  // type: long
4163   Node* size    = ConvL2X(argument(7));  // type: long
4164 
4165   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4166          &quot;fieldOffset must be byte-scaled&quot;);
4167 


4168   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4169   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4170 
4171   // Conservatively insert a memory barrier on all memory slices.
4172   // Do not let writes of the copy source or destination float below the copy.
4173   insert_mem_bar(Op_MemBarCPUOrder);
4174 
<span class="line-added">4175   Node* thread = _gvn.transform(new ThreadLocalNode());</span>
<span class="line-added">4176   Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));</span>
<span class="line-added">4177   BasicType doing_unsafe_access_bt = T_BYTE;</span>
<span class="line-added">4178   assert((sizeof(bool) * CHAR_BIT) == 8, &quot;not implemented&quot;);</span>
<span class="line-added">4179 </span>
<span class="line-added">4180   // update volatile field</span>
<span class="line-added">4181   store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="line-added">4182 </span>
4183   // Call it.  Note that the length argument is not scaled.
4184   make_runtime_call(RC_LEAF|RC_NO_FP,
4185                     OptoRuntime::fast_arraycopy_Type(),
4186                     StubRoutines::unsafe_arraycopy(),
4187                     &quot;unsafe_arraycopy&quot;,
4188                     TypeRawPtr::BOTTOM,
4189                     src, dst, size XTOP);
4190 
<span class="line-added">4191   store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);</span>
<span class="line-added">4192 </span>
4193   // Do not let reads of the copy destination float above the copy.
4194   insert_mem_bar(Op_MemBarCPUOrder);
4195 
4196   return true;
4197 }
4198 
4199 //------------------------clone_coping-----------------------------------
4200 // Helper function for inline_native_clone.
4201 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4202   assert(obj_size != NULL, &quot;&quot;);
4203   Node* raw_obj = alloc_obj-&gt;in(1);
4204   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4205 
4206   AllocateNode* alloc = NULL;
4207   if (ReduceBulkZeroing) {
4208     // We will be completely responsible for initializing this object -
4209     // mark Initialize node as complete.
4210     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4211     // The object was just allocated - there should be no any stores!
4212     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4213     // Mark as complete_with_arraycopy so that on AllocateNode
4214     // expansion, we know this AllocateNode is initialized by an array
4215     // copy and a StoreStore barrier exists after the array copy.
4216     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4217   }
4218 


4219   Node* size = _gvn.transform(obj_size);

4220   access_clone(obj, alloc_obj, size, is_array);
4221 
4222   // Do not let reads from the cloned object float above the arraycopy.
4223   if (alloc != NULL) {
4224     // Do not let stores that initialize this object be reordered with
4225     // a subsequent store that would make this object accessible by
4226     // other threads.
4227     // Record what AllocateNode this StoreStore protects so that
4228     // escape analysis can go from the MemBarStoreStoreNode to the
4229     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4230     // based on the escape status of the AllocateNode.
4231     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4232   } else {
4233     insert_mem_bar(Op_MemBarCPUOrder);
4234   }
4235 }
4236 
4237 //------------------------inline_native_clone----------------------------
4238 // protected native Object java.lang.Object.clone();
4239 //
</pre>
<hr />
<pre>
4266     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4267 
4268     // If we are going to clone an instance, we need its exact type to
4269     // know the number and types of fields to convert the clone to
4270     // loads/stores. Maybe a speculative type can help us.
4271     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4272         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4273         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {
4274       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4275       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4276           !spec_ik-&gt;has_injected_fields()) {
4277         ciKlass* k = obj_type-&gt;klass();
4278         if (!k-&gt;is_instance_klass() ||
4279             k-&gt;as_instance_klass()-&gt;is_interface() ||
4280             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4281           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4282         }
4283       }
4284     }
4285 






4286     // Conservatively insert a memory barrier on all memory slices.
4287     // Do not let writes into the original float below the clone.
4288     insert_mem_bar(Op_MemBarCPUOrder);
4289 
4290     // paths into result_reg:
4291     enum {
4292       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4293       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4294       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4295       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4296       PATH_LIMIT
4297     };
4298     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4299     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4300     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4301     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4302     record_for_igvn(result_reg);
4303 
<span class="line-added">4304     Node* obj_klass = load_object_klass(obj);</span>
4305     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4306     if (array_ctl != NULL) {
4307       // It&#39;s an array.
4308       PreserveJVMState pjvms(this);
4309       set_control(array_ctl);
4310       Node* obj_length = load_array_length(obj);
4311       Node* obj_size  = NULL;
4312       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size);  // no arguments to push
4313 
4314       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4315       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4316         // If it is an oop array, it requires very special treatment,
4317         // because gc barriers are required when accessing the array.
4318         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4319         if (is_obja != NULL) {
4320           PreserveJVMState pjvms2(this);
4321           set_control(is_obja);

4322           // Generate a direct call to the right arraycopy function(s).
4323           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4324           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
<span class="line-modified">4325           ac-&gt;set_clone_oop_array();</span>
4326           Node* n = _gvn.transform(ac);
4327           assert(n == ac, &quot;cannot disappear&quot;);
4328           ac-&gt;connect_outputs(this);
4329 
4330           result_reg-&gt;init_req(_objArray_path, control());
4331           result_val-&gt;init_req(_objArray_path, alloc_obj);
4332           result_i_o -&gt;set_req(_objArray_path, i_o());
4333           result_mem -&gt;set_req(_objArray_path, reset_memory());
4334         }
4335       }
4336       // Otherwise, there are no barriers to worry about.
4337       // (We can dispense with card marks if we know the allocation
4338       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4339       //  causes the non-eden paths to take compensating steps to
4340       //  simulate a fresh allocation, so that no further
4341       //  card marks are required in compiled code to initialize
4342       //  the object.)
4343 
4344       if (!stopped()) {
4345         copy_to_clone(obj, alloc_obj, obj_size, true);
</pre>
<hr />
<pre>
4417     set_all_memory( _gvn.transform(result_mem));
4418   } // original reexecute is set back here
4419 
4420   set_result(_gvn.transform(result_val));
4421   return true;
4422 }
4423 
4424 // If we have a tightly coupled allocation, the arraycopy may take care
4425 // of the array initialization. If one of the guards we insert between
4426 // the allocation and the arraycopy causes a deoptimization, an
4427 // unitialized array will escape the compiled method. To prevent that
4428 // we set the JVM state for uncommon traps between the allocation and
4429 // the arraycopy to the state before the allocation so, in case of
4430 // deoptimization, we&#39;ll reexecute the allocation and the
4431 // initialization.
4432 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4433   if (alloc != NULL) {
4434     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4435     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4436 
<span class="line-modified">4437     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;</span>
<span class="line-modified">4438         !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {</span>
4439       // Make sure there&#39;s no store between the allocation and the
4440       // arraycopy otherwise visible side effects could be rexecuted
4441       // in case of deoptimization and cause incorrect execution.
4442       bool no_interfering_store = true;
4443       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4444       if (mem-&gt;is_MergeMem()) {
4445         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4446           Node* n = mms.memory();
4447           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="line-modified">4448             assert(n-&gt;is_Store(), &quot;what else?&quot;);</span>
4449             no_interfering_store = false;
4450             break;
4451           }
4452         }
4453       } else {
4454         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4455           Node* n = mms.memory();
4456           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
<span class="line-modified">4457             assert(n-&gt;is_Store(), &quot;what else?&quot;);</span>
4458             no_interfering_store = false;
4459             break;
4460           }
4461         }
4462       }
4463 
4464       if (no_interfering_store) {
4465         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4466         uint size = alloc-&gt;req();
4467         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4468         old_jvms-&gt;set_map(sfpt);
4469         for (uint i = 0; i &lt; size; i++) {
4470           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4471         }
4472         // re-push array length for deoptimization
4473         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4474         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4475         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4476         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4477         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
</pre>
<hr />
<pre>
4659       if (!has_src) {
4660         src = maybe_cast_profiled_obj(src, src_k, true);
4661         src_type  = _gvn.type(src);
4662         top_src  = src_type-&gt;isa_aryptr();
4663         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4664         src_spec = true;
4665       }
4666       if (!has_dest) {
4667         dest = maybe_cast_profiled_obj(dest, dest_k, true);
4668         dest_type  = _gvn.type(dest);
4669         top_dest  = dest_type-&gt;isa_aryptr();
4670         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4671         dest_spec = true;
4672       }
4673     }
4674   }
4675 
4676   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
4677     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4678     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">4679     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="line-modified">4680     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
4681 
4682     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
4683       // If both arrays are object arrays then having the exact types
4684       // for both will remove the need for a subtype check at runtime
4685       // before the call and may make it possible to pick a faster copy
4686       // routine (without a subtype check on every element)
4687       // Do we have the exact type of src?
4688       bool could_have_src = src_spec;
4689       // Do we have the exact type of dest?
4690       bool could_have_dest = dest_spec;
4691       ciKlass* src_k = top_src-&gt;klass();
4692       ciKlass* dest_k = top_dest-&gt;klass();
4693       if (!src_spec) {
4694         src_k = src_type-&gt;speculative_type_not_null();
4695         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4696           could_have_src = true;
4697         }
4698       }
4699       if (!dest_spec) {
4700         dest_k = dest_type-&gt;speculative_type_not_null();
</pre>
<hr />
<pre>
4748     // (7) src_offset + length must not exceed length of src.
4749     generate_limit_guard(src_offset, length,
4750                          load_array_length(src),
4751                          slow_region);
4752 
4753     // (8) dest_offset + length must not exceed length of dest.
4754     generate_limit_guard(dest_offset, length,
4755                          load_array_length(dest),
4756                          slow_region);
4757 
4758     // (6) length must not be negative.
4759     // This is also checked in generate_arraycopy() during macro expansion, but
4760     // we also have to check it here for the case where the ArrayCopyNode will
4761     // be eliminated by Escape Analysis.
4762     if (EliminateAllocations) {
4763       generate_negative_guard(length, slow_region);
4764       negative_length_guard_generated = true;
4765     }
4766 
4767     // (9) each element of an oop array must be assignable

4768     Node* dest_klass = load_object_klass(dest);
<span class="line-modified">4769     if (src != dest) {</span>
<span class="line-modified">4770       Node* not_subtype_ctrl = gen_subtype_check(src, dest_klass);</span>
<span class="line-modified">4771 </span>
<span class="line-modified">4772       if (not_subtype_ctrl != top()) {</span>
<span class="line-modified">4773         PreserveJVMState pjvms(this);</span>
<span class="line-modified">4774         set_control(not_subtype_ctrl);</span>
<span class="line-modified">4775         uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="line-modified">4776                       Deoptimization::Action_make_not_entrant);</span>
<span class="line-added">4777         assert(stopped(), &quot;Should be stopped&quot;);</span>
<span class="line-added">4778       }</span>
4779     }
4780     {
4781       PreserveJVMState pjvms(this);
4782       set_control(_gvn.transform(slow_region));
4783       uncommon_trap(Deoptimization::Reason_intrinsic,
4784                     Deoptimization::Action_make_not_entrant);
4785       assert(stopped(), &quot;Should be stopped&quot;);
4786     }
4787 
4788     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4789     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4790     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4791   }
4792 
4793   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4794 
4795   if (stopped()) {
4796     return true;
4797   }
4798 
<span class="line-modified">4799   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,</span>



4800                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
4801                                           // so the compiler has a chance to eliminate them: during macro expansion,
4802                                           // we have to set their control (CastPP nodes are eliminated).
4803                                           load_object_klass(src), load_object_klass(dest),
4804                                           load_array_length(src), load_array_length(dest));
4805 
4806   ac-&gt;set_arraycopy(validated);
4807 
4808   Node* n = _gvn.transform(ac);
4809   if (n == ac) {
4810     ac-&gt;connect_outputs(this);
4811   } else {
4812     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4813     set_all_memory(n);
4814   }
4815   clear_upper_avx();
4816 
4817 
4818   return true;
4819 }
</pre>
<hr />
<pre>
4835   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
4836     // Bail out if there have been raw-memory effects since the allocation.
4837     // (Example:  There might have been a call or safepoint.)
4838     return NULL;
4839   }
4840   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
4841   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
4842     return NULL;
4843   }
4844 
4845   // There must be no unexpected observers of this allocation.
4846   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
4847     Node* obs = ptr-&gt;fast_out(i);
4848     if (obs != this-&gt;map()) {
4849       return NULL;
4850     }
4851   }
4852 
4853   // This arraycopy must unconditionally follow the allocation of the ptr.
4854   Node* alloc_ctl = ptr-&gt;in(0);


4855   Node* ctl = control();
4856   while (ctl != alloc_ctl) {
4857     // There may be guards which feed into the slow_region.
4858     // Any other control flow means that we might not get a chance
4859     // to finish initializing the allocated object.
4860     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
4861       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
4862       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
4863       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
4864       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
4865         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
4866         continue;
4867       }
4868       // One more try:  Various low-level checks bottom out in
4869       // uncommon traps.  If the debug-info of the trap omits
4870       // any reference to the allocation, as we&#39;ve already
4871       // observed, then there can be no objection to the trap.
4872       bool found_trap = false;
4873       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4874         Node* obs = not_ctl-&gt;fast_out(j);
</pre>
<hr />
<pre>
4890   // The arraycopy will finish the initialization, and provide
4891   // a new control state to which we will anchor the destination pointer.
4892 
4893   return alloc;
4894 }
4895 
4896 //-------------inline_encodeISOArray-----------------------------------
4897 // encode char[] to byte[] in ISO_8859_1
4898 bool LibraryCallKit::inline_encodeISOArray() {
4899   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
4900   // no receiver since it is static method
4901   Node *src         = argument(0);
4902   Node *src_offset  = argument(1);
4903   Node *dst         = argument(2);
4904   Node *dst_offset  = argument(3);
4905   Node *length      = argument(4);
4906 
4907   src = must_be_not_null(src, true);
4908   dst = must_be_not_null(dst, true);
4909 



4910   const Type* src_type = src-&gt;Value(&amp;_gvn);
4911   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
4912   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
4913   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
4914   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
4915       top_dest == NULL || top_dest-&gt;klass() == NULL) {
4916     // failed array check
4917     return false;
4918   }
4919 
4920   // Figure out the size and type of the elements we will be copying.
4921   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4922   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4923   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
4924     return false;
4925   }
4926 
4927   Node* src_start = array_element_address(src, src_offset, T_CHAR);
4928   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
4929   // &#39;src_start&#39; points to src array + scaled offset
</pre>
<hr />
<pre>
4945   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
4946 
4947   address stubAddr = StubRoutines::multiplyToLen();
4948   if (stubAddr == NULL) {
4949     return false; // Intrinsic&#39;s stub is not implemented on this platform
4950   }
4951   const char* stubName = &quot;multiplyToLen&quot;;
4952 
4953   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
4954 
4955   // no receiver because it is a static method
4956   Node* x    = argument(0);
4957   Node* xlen = argument(1);
4958   Node* y    = argument(2);
4959   Node* ylen = argument(3);
4960   Node* z    = argument(4);
4961 
4962   x = must_be_not_null(x, true);
4963   y = must_be_not_null(y, true);
4964 




4965   const Type* x_type = x-&gt;Value(&amp;_gvn);
4966   const Type* y_type = y-&gt;Value(&amp;_gvn);
4967   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
4968   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
4969   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
4970       top_y == NULL || top_y-&gt;klass() == NULL) {
4971     // failed array check
4972     return false;
4973   }
4974 
4975   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4976   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4977   if (x_elem != T_INT || y_elem != T_INT) {
4978     return false;
4979   }
4980 
4981   // Set the original stack and the reexecute bit for the interpreter to reexecute
4982   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
4983   // on the return from z array allocation in runtime.
4984   { PreserveReexecuteState preexecs(this);
</pre>
<hr />
<pre>
5053 //-------------inline_squareToLen------------------------------------
5054 bool LibraryCallKit::inline_squareToLen() {
5055   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5056 
5057   address stubAddr = StubRoutines::squareToLen();
5058   if (stubAddr == NULL) {
5059     return false; // Intrinsic&#39;s stub is not implemented on this platform
5060   }
5061   const char* stubName = &quot;squareToLen&quot;;
5062 
5063   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5064 
5065   Node* x    = argument(0);
5066   Node* len  = argument(1);
5067   Node* z    = argument(2);
5068   Node* zlen = argument(3);
5069 
5070   x = must_be_not_null(x, true);
5071   z = must_be_not_null(z, true);
5072 



5073   const Type* x_type = x-&gt;Value(&amp;_gvn);
5074   const Type* z_type = z-&gt;Value(&amp;_gvn);
5075   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5076   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5077   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5078       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5079     // failed array check
5080     return false;
5081   }
5082 
5083   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5084   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5085   if (x_elem != T_INT || z_elem != T_INT) {
5086     return false;
5087   }
5088 
5089 
5090   Node* x_start = array_element_address(x, intcon(0), x_elem);
5091   Node* z_start = array_element_address(z, intcon(0), z_elem);
5092 
</pre>
<hr />
<pre>
5102 //-------------inline_mulAdd------------------------------------------
5103 bool LibraryCallKit::inline_mulAdd() {
5104   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5105 
5106   address stubAddr = StubRoutines::mulAdd();
5107   if (stubAddr == NULL) {
5108     return false; // Intrinsic&#39;s stub is not implemented on this platform
5109   }
5110   const char* stubName = &quot;mulAdd&quot;;
5111 
5112   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5113 
5114   Node* out      = argument(0);
5115   Node* in       = argument(1);
5116   Node* offset   = argument(2);
5117   Node* len      = argument(3);
5118   Node* k        = argument(4);
5119 
5120   out = must_be_not_null(out, true);
5121 



5122   const Type* out_type = out-&gt;Value(&amp;_gvn);
5123   const Type* in_type = in-&gt;Value(&amp;_gvn);
5124   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5125   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5126   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5127       top_in == NULL || top_in-&gt;klass() == NULL) {
5128     // failed array check
5129     return false;
5130   }
5131 
5132   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5133   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5134   if (out_elem != T_INT || in_elem != T_INT) {
5135     return false;
5136   }
5137 
5138   Node* outlen = load_array_length(out);
5139   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5140   Node* out_start = array_element_address(out, intcon(0), out_elem);
5141   Node* in_start = array_element_address(in, intcon(0), in_elem);
</pre>
<hr />
<pre>
5151 
5152 //-------------inline_montgomeryMultiply-----------------------------------
5153 bool LibraryCallKit::inline_montgomeryMultiply() {
5154   address stubAddr = StubRoutines::montgomeryMultiply();
5155   if (stubAddr == NULL) {
5156     return false; // Intrinsic&#39;s stub is not implemented on this platform
5157   }
5158 
5159   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5160   const char* stubName = &quot;montgomery_multiply&quot;;
5161 
5162   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5163 
5164   Node* a    = argument(0);
5165   Node* b    = argument(1);
5166   Node* n    = argument(2);
5167   Node* len  = argument(3);
5168   Node* inv  = argument(4);
5169   Node* m    = argument(6);
5170 





5171   const Type* a_type = a-&gt;Value(&amp;_gvn);
5172   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5173   const Type* b_type = b-&gt;Value(&amp;_gvn);
5174   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5175   const Type* n_type = a-&gt;Value(&amp;_gvn);
5176   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5177   const Type* m_type = a-&gt;Value(&amp;_gvn);
5178   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5179   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5180       top_b == NULL || top_b-&gt;klass()  == NULL ||
5181       top_n == NULL || top_n-&gt;klass()  == NULL ||
5182       top_m == NULL || top_m-&gt;klass()  == NULL) {
5183     // failed array check
5184     return false;
5185   }
5186 
5187   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5188   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5189   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5190   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
</pre>
<hr />
<pre>
5210   return true;
5211 }
5212 
5213 bool LibraryCallKit::inline_montgomerySquare() {
5214   address stubAddr = StubRoutines::montgomerySquare();
5215   if (stubAddr == NULL) {
5216     return false; // Intrinsic&#39;s stub is not implemented on this platform
5217   }
5218 
5219   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5220   const char* stubName = &quot;montgomery_square&quot;;
5221 
5222   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5223 
5224   Node* a    = argument(0);
5225   Node* n    = argument(1);
5226   Node* len  = argument(2);
5227   Node* inv  = argument(3);
5228   Node* m    = argument(5);
5229 




5230   const Type* a_type = a-&gt;Value(&amp;_gvn);
5231   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5232   const Type* n_type = a-&gt;Value(&amp;_gvn);
5233   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5234   const Type* m_type = a-&gt;Value(&amp;_gvn);
5235   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5236   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5237       top_n == NULL || top_n-&gt;klass()  == NULL ||
5238       top_m == NULL || top_m-&gt;klass()  == NULL) {
5239     // failed array check
5240     return false;
5241   }
5242 
5243   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5244   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5245   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5246   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5247     return false;
5248   }
5249 
5250   // Make the call
5251   {
5252     Node* a_start = array_element_address(a, intcon(0), a_elem);
5253     Node* n_start = array_element_address(n, intcon(0), n_elem);
5254     Node* m_start = array_element_address(m, intcon(0), m_elem);
5255 
5256     Node* call = make_runtime_call(RC_LEAF,
5257                                    OptoRuntime::montgomerySquare_Type(),
5258                                    stubAddr, stubName, TypePtr::BOTTOM,
5259                                    a_start, n_start, len, inv, top(),
5260                                    m_start);
5261     set_result(m);
5262   }
5263 
5264   return true;
5265 }
5266 
<span class="line-added">5267 bool LibraryCallKit::inline_bigIntegerShift(bool isRightShift) {</span>
<span class="line-added">5268   address stubAddr = NULL;</span>
<span class="line-added">5269   const char* stubName = NULL;</span>
<span class="line-added">5270 </span>
<span class="line-added">5271   stubAddr = isRightShift? StubRoutines::bigIntegerRightShift(): StubRoutines::bigIntegerLeftShift();</span>
<span class="line-added">5272   if (stubAddr == NULL) {</span>
<span class="line-added">5273     return false; // Intrinsic&#39;s stub is not implemented on this platform</span>
<span class="line-added">5274   }</span>
<span class="line-added">5275 </span>
<span class="line-added">5276   stubName = isRightShift? &quot;bigIntegerRightShiftWorker&quot; : &quot;bigIntegerLeftShiftWorker&quot;;</span>
<span class="line-added">5277 </span>
<span class="line-added">5278   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;expected 5 arguments&quot;);</span>
<span class="line-added">5279 </span>
<span class="line-added">5280   Node* newArr = argument(0);</span>
<span class="line-added">5281   Node* oldArr = argument(1);</span>
<span class="line-added">5282   Node* newIdx = argument(2);</span>
<span class="line-added">5283   Node* shiftCount = argument(3);</span>
<span class="line-added">5284   Node* numIter = argument(4);</span>
<span class="line-added">5285 </span>
<span class="line-added">5286   const Type* newArr_type = newArr-&gt;Value(&amp;_gvn);</span>
<span class="line-added">5287   const TypeAryPtr* top_newArr = newArr_type-&gt;isa_aryptr();</span>
<span class="line-added">5288   const Type* oldArr_type = oldArr-&gt;Value(&amp;_gvn);</span>
<span class="line-added">5289   const TypeAryPtr* top_oldArr = oldArr_type-&gt;isa_aryptr();</span>
<span class="line-added">5290   if (top_newArr == NULL || top_newArr-&gt;klass() == NULL || top_oldArr == NULL</span>
<span class="line-added">5291       || top_oldArr-&gt;klass() == NULL) {</span>
<span class="line-added">5292     return false;</span>
<span class="line-added">5293   }</span>
<span class="line-added">5294 </span>
<span class="line-added">5295   BasicType newArr_elem = newArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>
<span class="line-added">5296   BasicType oldArr_elem = oldArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>
<span class="line-added">5297   if (newArr_elem != T_INT || oldArr_elem != T_INT) {</span>
<span class="line-added">5298     return false;</span>
<span class="line-added">5299   }</span>
<span class="line-added">5300 </span>
<span class="line-added">5301   // Make the call</span>
<span class="line-added">5302   {</span>
<span class="line-added">5303     Node* newArr_start = array_element_address(newArr, intcon(0), newArr_elem);</span>
<span class="line-added">5304     Node* oldArr_start = array_element_address(oldArr, intcon(0), oldArr_elem);</span>
<span class="line-added">5305 </span>
<span class="line-added">5306     Node* call = make_runtime_call(RC_LEAF,</span>
<span class="line-added">5307                                    OptoRuntime::bigIntegerShift_Type(),</span>
<span class="line-added">5308                                    stubAddr,</span>
<span class="line-added">5309                                    stubName,</span>
<span class="line-added">5310                                    TypePtr::BOTTOM,</span>
<span class="line-added">5311                                    newArr_start,</span>
<span class="line-added">5312                                    oldArr_start,</span>
<span class="line-added">5313                                    newIdx,</span>
<span class="line-added">5314                                    shiftCount,</span>
<span class="line-added">5315                                    numIter);</span>
<span class="line-added">5316   }</span>
<span class="line-added">5317 </span>
<span class="line-added">5318   return true;</span>
<span class="line-added">5319 }</span>
<span class="line-added">5320 </span>
5321 //-------------inline_vectorizedMismatch------------------------------
5322 bool LibraryCallKit::inline_vectorizedMismatch() {
5323   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5324 
5325   address stubAddr = StubRoutines::vectorizedMismatch();
5326   if (stubAddr == NULL) {
5327     return false; // Intrinsic&#39;s stub is not implemented on this platform
5328   }
5329   const char* stubName = &quot;vectorizedMismatch&quot;;
5330   int size_l = callee()-&gt;signature()-&gt;size();
5331   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5332 
5333   Node* obja = argument(0);
5334   Node* aoffset = argument(1);
5335   Node* objb = argument(3);
5336   Node* boffset = argument(4);
5337   Node* length = argument(6);
5338   Node* scale = argument(7);
5339 
5340   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5341   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5342   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5343   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5344   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5345     top_b == NULL || top_b-&gt;klass() == NULL) {
5346     // failed array check
5347     return false;
5348   }
5349 
5350   Node* call;
5351   jvms()-&gt;set_should_reexecute(true);
5352 


5353   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5354   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5355 
5356   call = make_runtime_call(RC_LEAF,
5357     OptoRuntime::vectorizedMismatch_Type(),
5358     stubAddr, stubName, TypePtr::BOTTOM,
5359     obja_adr, objb_adr, length, scale);
5360 
5361   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5362   set_result(result);
5363   return true;
5364 }
5365 
5366 /**
5367  * Calculate CRC32 for byte.
5368  * int java.util.zip.CRC32.update(int crc, int b)
5369  */
5370 bool LibraryCallKit::inline_updateCRC32() {
5371   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5372   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
</pre>
<hr />
<pre>
5409   Node* crc     = argument(0); // type: int
5410   Node* src     = argument(1); // type: oop
5411   Node* offset  = argument(2); // type: int
5412   Node* length  = argument(3); // type: int
5413 
5414   const Type* src_type = src-&gt;Value(&amp;_gvn);
5415   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5416   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5417     // failed array check
5418     return false;
5419   }
5420 
5421   // Figure out the size and type of the elements we will be copying.
5422   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5423   if (src_elem != T_BYTE) {
5424     return false;
5425   }
5426 
5427   // &#39;src_start&#39; points to src array + scaled offset
5428   src = must_be_not_null(src, true);

5429   Node* src_start = array_element_address(src, offset, src_elem);
5430 
5431   // We assume that range check is done by caller.
5432   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5433 
5434   // Call the stub.
5435   address stubAddr = StubRoutines::updateBytesCRC32();
5436   const char *stubName = &quot;updateBytesCRC32&quot;;
5437 
5438   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5439                                  stubAddr, stubName, TypePtr::BOTTOM,
5440                                  crc, src_start, length);
5441   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5442   set_result(result);
5443   return true;
5444 }
5445 
5446 /**
5447  * Calculate CRC32 for ByteBuffer.
5448  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
</pre>
<hr />
<pre>
5498   Node* offset  = argument(2); // type: int
5499   Node* end     = argument(3); // type: int
5500 
5501   Node* length = _gvn.transform(new SubINode(end, offset));
5502 
5503   const Type* src_type = src-&gt;Value(&amp;_gvn);
5504   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5505   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5506     // failed array check
5507     return false;
5508   }
5509 
5510   // Figure out the size and type of the elements we will be copying.
5511   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5512   if (src_elem != T_BYTE) {
5513     return false;
5514   }
5515 
5516   // &#39;src_start&#39; points to src array + scaled offset
5517   src = must_be_not_null(src, true);

5518   Node* src_start = array_element_address(src, offset, src_elem);
5519 
5520   // static final int[] byteTable in class CRC32C
5521   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5522   table = must_be_not_null(table, true);

5523   Node* table_start = array_element_address(table, intcon(0), T_INT);
5524 
5525   // We assume that range check is done by caller.
5526   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5527 
5528   // Call the stub.
5529   address stubAddr = StubRoutines::updateBytesCRC32C();
5530   const char *stubName = &quot;updateBytesCRC32C&quot;;
5531 
5532   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5533                                  stubAddr, stubName, TypePtr::BOTTOM,
5534                                  crc, src_start, length, table_start);
5535   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5536   set_result(result);
5537   return true;
5538 }
5539 
5540 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5541 //
5542 // Calculate CRC32C for DirectByteBuffer.
</pre>
<hr />
<pre>
5547   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5548   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5549   // no receiver since it is a static method
5550   Node* crc     = argument(0); // type: int
5551   Node* src     = argument(1); // type: long
5552   Node* offset  = argument(3); // type: int
5553   Node* end     = argument(4); // type: int
5554 
5555   Node* length = _gvn.transform(new SubINode(end, offset));
5556 
5557   src = ConvL2X(src);  // adjust Java long to machine word
5558   Node* base = _gvn.transform(new CastX2PNode(src));
5559   offset = ConvI2X(offset);
5560 
5561   // &#39;src_start&#39; points to src array + scaled offset
5562   Node* src_start = basic_plus_adr(top(), base, offset);
5563 
5564   // static final int[] byteTable in class CRC32C
5565   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5566   table = must_be_not_null(table, true);

5567   Node* table_start = array_element_address(table, intcon(0), T_INT);
5568 
5569   // Call the stub.
5570   address stubAddr = StubRoutines::updateBytesCRC32C();
5571   const char *stubName = &quot;updateBytesCRC32C&quot;;
5572 
5573   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5574                                  stubAddr, stubName, TypePtr::BOTTOM,
5575                                  crc, src_start, length, table_start);
5576   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5577   set_result(result);
5578   return true;
5579 }
5580 
5581 //------------------------------inline_updateBytesAdler32----------------------
5582 //
5583 // Calculate Adler32 checksum for byte[] array.
5584 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5585 //
5586 bool LibraryCallKit::inline_updateBytesAdler32() {
</pre>
<hr />
<pre>
5590   // no receiver since it is static method
5591   Node* crc     = argument(0); // type: int
5592   Node* src     = argument(1); // type: oop
5593   Node* offset  = argument(2); // type: int
5594   Node* length  = argument(3); // type: int
5595 
5596   const Type* src_type = src-&gt;Value(&amp;_gvn);
5597   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5598   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5599     // failed array check
5600     return false;
5601   }
5602 
5603   // Figure out the size and type of the elements we will be copying.
5604   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5605   if (src_elem != T_BYTE) {
5606     return false;
5607   }
5608 
5609   // &#39;src_start&#39; points to src array + scaled offset

5610   Node* src_start = array_element_address(src, offset, src_elem);
5611 
5612   // We assume that range check is done by caller.
5613   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5614 
5615   // Call the stub.
5616   address stubAddr = StubRoutines::updateBytesAdler32();
5617   const char *stubName = &quot;updateBytesAdler32&quot;;
5618 
5619   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5620                                  stubAddr, stubName, TypePtr::BOTTOM,
5621                                  crc, src_start, length);
5622   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5623   set_result(result);
5624   return true;
5625 }
5626 
5627 //------------------------------inline_updateByteBufferAdler32---------------
5628 //
5629 // Calculate Adler32 checksum for DirectByteBuffer.
</pre>
<hr />
<pre>
5793     stubName = &quot;aescrypt_encryptBlock&quot;;
5794     break;
5795   case vmIntrinsics::_aescrypt_decryptBlock:
5796     stubAddr = StubRoutines::aescrypt_decryptBlock();
5797     stubName = &quot;aescrypt_decryptBlock&quot;;
5798     break;
5799   default:
5800     break;
5801   }
5802   if (stubAddr == NULL) return false;
5803 
5804   Node* aescrypt_object = argument(0);
5805   Node* src             = argument(1);
5806   Node* src_offset      = argument(2);
5807   Node* dest            = argument(3);
5808   Node* dest_offset     = argument(4);
5809 
5810   src = must_be_not_null(src, true);
5811   dest = must_be_not_null(dest, true);
5812 



5813   // (1) src and dest are arrays.
5814   const Type* src_type = src-&gt;Value(&amp;_gvn);
5815   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5816   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5817   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5818   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5819 
5820   // for the quick and dirty code we will skip all the checks.
5821   // we are just trying to get the call to be generated.
5822   Node* src_start  = src;
5823   Node* dest_start = dest;
5824   if (src_offset != NULL || dest_offset != NULL) {
5825     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5826     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5827     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5828   }
5829 
5830   // now need to get the start of its expanded key array
5831   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5832   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
</pre>
<hr />
<pre>
5866     break;
5867   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
5868     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
5869     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
5870     break;
5871   default:
5872     break;
5873   }
5874   if (stubAddr == NULL) return false;
5875 
5876   Node* cipherBlockChaining_object = argument(0);
5877   Node* src                        = argument(1);
5878   Node* src_offset                 = argument(2);
5879   Node* len                        = argument(3);
5880   Node* dest                       = argument(4);
5881   Node* dest_offset                = argument(5);
5882 
5883   src = must_be_not_null(src, false);
5884   dest = must_be_not_null(dest, false);
5885 



5886   // (1) src and dest are arrays.
5887   const Type* src_type = src-&gt;Value(&amp;_gvn);
5888   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5889   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5890   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5891   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
5892           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5893 
5894   // checks are the responsibility of the caller
5895   Node* src_start  = src;
5896   Node* dest_start = dest;
5897   if (src_offset != NULL || dest_offset != NULL) {
5898     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5899     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5900     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5901   }
5902 
5903   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
5904   // (because of the predicated logic executed earlier).
5905   // so we cast it here safely.
</pre>
<hr />
<pre>
5911   // cast it to what we know it will be at runtime
5912   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
5913   assert(tinst != NULL, &quot;CBC obj is null&quot;);
5914   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
5915   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
5916   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
5917 
5918   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
5919   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
5920   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
5921   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
5922   aescrypt_object = _gvn.transform(aescrypt_object);
5923 
5924   // we need to get the start of the aescrypt_object&#39;s expanded key array
5925   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5926   if (k_start == NULL) return false;
5927 
5928   // similarly, get the start address of the r vector
5929   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
5930   if (objRvec == NULL) return false;

5931   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
5932 
5933   Node* cbcCrypt;
5934   if (Matcher::pass_original_key_for_aes()) {
5935     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5936     // compatibility issues between Java key expansion and SPARC crypto instructions
5937     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5938     if (original_k_start == NULL) return false;
5939 
5940     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
5941     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5942                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5943                                  stubAddr, stubName, TypePtr::BOTTOM,
5944                                  src_start, dest_start, k_start, r_start, len, original_k_start);
5945   } else {
5946     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
5947     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5948                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5949                                  stubAddr, stubName, TypePtr::BOTTOM,
5950                                  src_start, dest_start, k_start, r_start, len);
5951   }
5952 
5953   // return cipher length (int)
5954   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
5955   set_result(retvalue);
5956   return true;
5957 }
5958 
<span class="line-added">5959 //------------------------------inline_electronicCodeBook_AESCrypt-----------------------</span>
<span class="line-added">5960 bool LibraryCallKit::inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id) {</span>
<span class="line-added">5961   address stubAddr = NULL;</span>
<span class="line-added">5962   const char *stubName = NULL;</span>
<span class="line-added">5963 </span>
<span class="line-added">5964   assert(UseAES, &quot;need AES instruction support&quot;);</span>
<span class="line-added">5965 </span>
<span class="line-added">5966   switch (id) {</span>
<span class="line-added">5967   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:</span>
<span class="line-added">5968     stubAddr = StubRoutines::electronicCodeBook_encryptAESCrypt();</span>
<span class="line-added">5969     stubName = &quot;electronicCodeBook_encryptAESCrypt&quot;;</span>
<span class="line-added">5970     break;</span>
<span class="line-added">5971   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:</span>
<span class="line-added">5972     stubAddr = StubRoutines::electronicCodeBook_decryptAESCrypt();</span>
<span class="line-added">5973     stubName = &quot;electronicCodeBook_decryptAESCrypt&quot;;</span>
<span class="line-added">5974     break;</span>
<span class="line-added">5975   default:</span>
<span class="line-added">5976     break;</span>
<span class="line-added">5977   }</span>
<span class="line-added">5978 </span>
<span class="line-added">5979   if (stubAddr == NULL) return false;</span>
<span class="line-added">5980 </span>
<span class="line-added">5981   Node* electronicCodeBook_object = argument(0);</span>
<span class="line-added">5982   Node* src                       = argument(1);</span>
<span class="line-added">5983   Node* src_offset                = argument(2);</span>
<span class="line-added">5984   Node* len                       = argument(3);</span>
<span class="line-added">5985   Node* dest                      = argument(4);</span>
<span class="line-added">5986   Node* dest_offset               = argument(5);</span>
<span class="line-added">5987 </span>
<span class="line-added">5988   // (1) src and dest are arrays.</span>
<span class="line-added">5989   const Type* src_type = src-&gt;Value(&amp;_gvn);</span>
<span class="line-added">5990   const Type* dest_type = dest-&gt;Value(&amp;_gvn);</span>
<span class="line-added">5991   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();</span>
<span class="line-added">5992   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();</span>
<span class="line-added">5993   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL</span>
<span class="line-added">5994          &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);</span>
<span class="line-added">5995 </span>
<span class="line-added">5996   // checks are the responsibility of the caller</span>
<span class="line-added">5997   Node* src_start = src;</span>
<span class="line-added">5998   Node* dest_start = dest;</span>
<span class="line-added">5999   if (src_offset != NULL || dest_offset != NULL) {</span>
<span class="line-added">6000     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);</span>
<span class="line-added">6001     src_start = array_element_address(src, src_offset, T_BYTE);</span>
<span class="line-added">6002     dest_start = array_element_address(dest, dest_offset, T_BYTE);</span>
<span class="line-added">6003   }</span>
<span class="line-added">6004 </span>
<span class="line-added">6005   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object</span>
<span class="line-added">6006   // (because of the predicated logic executed earlier).</span>
<span class="line-added">6007   // so we cast it here safely.</span>
<span class="line-added">6008   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java</span>
<span class="line-added">6009 </span>
<span class="line-added">6010   Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);</span>
<span class="line-added">6011   if (embeddedCipherObj == NULL) return false;</span>
<span class="line-added">6012 </span>
<span class="line-added">6013   // cast it to what we know it will be at runtime</span>
<span class="line-added">6014   const TypeInstPtr* tinst = _gvn.type(electronicCodeBook_object)-&gt;isa_instptr();</span>
<span class="line-added">6015   assert(tinst != NULL, &quot;ECB obj is null&quot;);</span>
<span class="line-added">6016   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECB obj is not loaded&quot;);</span>
<span class="line-added">6017   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));</span>
<span class="line-added">6018   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);</span>
<span class="line-added">6019 </span>
<span class="line-added">6020   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();</span>
<span class="line-added">6021   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);</span>
<span class="line-added">6022   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();</span>
<span class="line-added">6023   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);</span>
<span class="line-added">6024   aescrypt_object = _gvn.transform(aescrypt_object);</span>
<span class="line-added">6025 </span>
<span class="line-added">6026   // we need to get the start of the aescrypt_object&#39;s expanded key array</span>
<span class="line-added">6027   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);</span>
<span class="line-added">6028   if (k_start == NULL) return false;</span>
<span class="line-added">6029 </span>
<span class="line-added">6030   Node* ecbCrypt;</span>
<span class="line-added">6031   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="line-added">6032     // no SPARC version for AES/ECB intrinsics now.</span>
<span class="line-added">6033     return false;</span>
<span class="line-added">6034   }</span>
<span class="line-added">6035   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len</span>
<span class="line-added">6036   ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,</span>
<span class="line-added">6037                                OptoRuntime::electronicCodeBook_aescrypt_Type(),</span>
<span class="line-added">6038                                stubAddr, stubName, TypePtr::BOTTOM,</span>
<span class="line-added">6039                                src_start, dest_start, k_start, len);</span>
<span class="line-added">6040 </span>
<span class="line-added">6041   // return cipher length (int)</span>
<span class="line-added">6042   Node* retvalue = _gvn.transform(new ProjNode(ecbCrypt, TypeFunc::Parms));</span>
<span class="line-added">6043   set_result(retvalue);</span>
<span class="line-added">6044   return true;</span>
<span class="line-added">6045 }</span>
<span class="line-added">6046 </span>
6047 //------------------------------inline_counterMode_AESCrypt-----------------------
6048 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
6049   assert(UseAES, &quot;need AES instruction support&quot;);
6050   if (!UseAESCTRIntrinsics) return false;
6051 
6052   address stubAddr = NULL;
6053   const char *stubName = NULL;
6054   if (id == vmIntrinsics::_counterMode_AESCrypt) {
6055     stubAddr = StubRoutines::counterMode_AESCrypt();
6056     stubName = &quot;counterMode_AESCrypt&quot;;
6057   }
6058   if (stubAddr == NULL) return false;
6059 
6060   Node* counterMode_object = argument(0);
6061   Node* src = argument(1);
6062   Node* src_offset = argument(2);
6063   Node* len = argument(3);
6064   Node* dest = argument(4);
6065   Node* dest_offset = argument(5);
6066 




6067   // (1) src and dest are arrays.
6068   const Type* src_type = src-&gt;Value(&amp;_gvn);
6069   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6070   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6071   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6072   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6073          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6074 
6075   // checks are the responsibility of the caller
6076   Node* src_start = src;
6077   Node* dest_start = dest;
6078   if (src_offset != NULL || dest_offset != NULL) {
6079     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6080     src_start = array_element_address(src, src_offset, T_BYTE);
6081     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6082   }
6083 
6084   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6085   // (because of the predicated logic executed earlier).
6086   // so we cast it here safely.
6087   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6088   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6089   if (embeddedCipherObj == NULL) return false;
6090   // cast it to what we know it will be at runtime
6091   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6092   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6093   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6094   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6095   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6096   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6097   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6098   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6099   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6100   aescrypt_object = _gvn.transform(aescrypt_object);
6101   // we need to get the start of the aescrypt_object&#39;s expanded key array
6102   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6103   if (k_start == NULL) return false;
6104   // similarly, get the start address of the r vector
6105   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6106   if (obj_counter == NULL) return false;

6107   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6108 
6109   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6110   if (saved_encCounter == NULL) return false;

6111   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6112   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6113 
6114   Node* ctrCrypt;
6115   if (Matcher::pass_original_key_for_aes()) {
6116     // no SPARC version for AES/CTR intrinsics now.
6117     return false;
6118   }
6119   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6120   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6121                                OptoRuntime::counterMode_aescrypt_Type(),
6122                                stubAddr, stubName, TypePtr::BOTTOM,
6123                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6124 
6125   // return cipher length (int)
6126   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6127   set_result(retvalue);
6128   return true;
6129 }
6130 
6131 //------------------------------get_key_start_from_aescrypt_object-----------------------
6132 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6133 #if defined(PPC64) || defined(S390)
6134   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6135   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6136   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6137   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6138   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6139   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6140   if (objSessionK == NULL) {
6141     return (Node *) NULL;
6142   }
6143   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6144 #else
6145   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6146 #endif // PPC64
6147   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6148   if (objAESCryptKey == NULL) return (Node *) NULL;
6149 
6150   // now have the array, need to get the start address of the K array

6151   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6152   return k_start;
6153 }
6154 
6155 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6156 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6157   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6158   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6159   if (objAESCryptKey == NULL) return (Node *) NULL;
6160 
6161   // now have the array, need to get the start address of the lastKey array

6162   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6163   return original_k_start;
6164 }
6165 
6166 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6167 // Return node representing slow path of predicate check.
6168 // the pseudo code we want to emulate with this predicate is:
6169 // for encryption:
6170 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6171 // for decryption:
6172 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6173 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6174 //
6175 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6176   // The receiver was checked for NULL already.
6177   Node* objCBC = argument(0);
6178 
6179   Node* src = argument(1);
6180   Node* dest = argument(4);
6181 
</pre>
<hr />
<pre>
6185   // get AESCrypt klass for instanceOf check
6186   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6187   // will have same classloader as CipherBlockChaining object
6188   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6189   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6190   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6191 
6192   // we want to do an instanceof comparison against the AESCrypt class
6193   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6194   if (!klass_AESCrypt-&gt;is_loaded()) {
6195     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6196     Node* ctrl = control();
6197     set_control(top()); // no regular fast path
6198     return ctrl;
6199   }
6200 
6201   src = must_be_not_null(src, true);
6202   dest = must_be_not_null(dest, true);
6203 
6204   // Resolve oops to stable for CmpP below.



6205   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6206 
6207   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6208   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6209   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6210 
6211   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6212 
6213   // for encryption, we are done
6214   if (!decrypting)
6215     return instof_false;  // even if it is NULL
6216 
6217   // for decryption, we need to add a further check to avoid
6218   // taking the intrinsic path when cipher and plain are the same
6219   // see the original java code for why.
6220   RegionNode* region = new RegionNode(3);
6221   region-&gt;init_req(1, instof_false);
6222 
6223   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6224   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6225   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6226   region-&gt;init_req(2, src_dest_conjoint);
6227 
6228   record_for_igvn(region);
6229   return _gvn.transform(region);
6230 }
6231 
<span class="line-added">6232 //----------------------------inline_electronicCodeBook_AESCrypt_predicate----------------------------</span>
<span class="line-added">6233 // Return node representing slow path of predicate check.</span>
<span class="line-added">6234 // the pseudo code we want to emulate with this predicate is:</span>
<span class="line-added">6235 // for encryption:</span>
<span class="line-added">6236 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath</span>
<span class="line-added">6237 // for decryption:</span>
<span class="line-added">6238 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath</span>
<span class="line-added">6239 //    note cipher==plain is more conservative than the original java code but that&#39;s OK</span>
<span class="line-added">6240 //</span>
<span class="line-added">6241 Node* LibraryCallKit::inline_electronicCodeBook_AESCrypt_predicate(bool decrypting) {</span>
<span class="line-added">6242   // The receiver was checked for NULL already.</span>
<span class="line-added">6243   Node* objECB = argument(0);</span>
<span class="line-added">6244 </span>
<span class="line-added">6245   // Load embeddedCipher field of ElectronicCodeBook object.</span>
<span class="line-added">6246   Node* embeddedCipherObj = load_field_from_object(objECB, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);</span>
<span class="line-added">6247 </span>
<span class="line-added">6248   // get AESCrypt klass for instanceOf check</span>
<span class="line-added">6249   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point</span>
<span class="line-added">6250   // will have same classloader as ElectronicCodeBook object</span>
<span class="line-added">6251   const TypeInstPtr* tinst = _gvn.type(objECB)-&gt;isa_instptr();</span>
<span class="line-added">6252   assert(tinst != NULL, &quot;ECBobj is null&quot;);</span>
<span class="line-added">6253   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECBobj is not loaded&quot;);</span>
<span class="line-added">6254 </span>
<span class="line-added">6255   // we want to do an instanceof comparison against the AESCrypt class</span>
<span class="line-added">6256   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));</span>
<span class="line-added">6257   if (!klass_AESCrypt-&gt;is_loaded()) {</span>
<span class="line-added">6258     // if AESCrypt is not even loaded, we never take the intrinsic fast path</span>
<span class="line-added">6259     Node* ctrl = control();</span>
<span class="line-added">6260     set_control(top()); // no regular fast path</span>
<span class="line-added">6261     return ctrl;</span>
<span class="line-added">6262   }</span>
<span class="line-added">6263   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();</span>
<span class="line-added">6264 </span>
<span class="line-added">6265   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));</span>
<span class="line-added">6266   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));</span>
<span class="line-added">6267   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));</span>
<span class="line-added">6268 </span>
<span class="line-added">6269   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);</span>
<span class="line-added">6270 </span>
<span class="line-added">6271   // for encryption, we are done</span>
<span class="line-added">6272   if (!decrypting)</span>
<span class="line-added">6273     return instof_false;  // even if it is NULL</span>
<span class="line-added">6274 </span>
<span class="line-added">6275   // for decryption, we need to add a further check to avoid</span>
<span class="line-added">6276   // taking the intrinsic path when cipher and plain are the same</span>
<span class="line-added">6277   // see the original java code for why.</span>
<span class="line-added">6278   RegionNode* region = new RegionNode(3);</span>
<span class="line-added">6279   region-&gt;init_req(1, instof_false);</span>
<span class="line-added">6280   Node* src = argument(1);</span>
<span class="line-added">6281   Node* dest = argument(4);</span>
<span class="line-added">6282   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));</span>
<span class="line-added">6283   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));</span>
<span class="line-added">6284   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);</span>
<span class="line-added">6285   region-&gt;init_req(2, src_dest_conjoint);</span>
<span class="line-added">6286 </span>
<span class="line-added">6287   record_for_igvn(region);</span>
<span class="line-added">6288   return _gvn.transform(region);</span>
<span class="line-added">6289 }</span>
<span class="line-added">6290 </span>
6291 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6292 // Return node representing slow path of predicate check.
6293 // the pseudo code we want to emulate with this predicate is:
6294 // for encryption:
6295 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6296 // for decryption:
6297 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6298 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6299 //
6300 
6301 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6302   // The receiver was checked for NULL already.
6303   Node* objCTR = argument(0);
6304 
6305   // Load embeddedCipher field of CipherBlockChaining object.
6306   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6307 
6308   // get AESCrypt klass for instanceOf check
6309   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6310   // will have same classloader as CipherBlockChaining object
</pre>
<hr />
<pre>
6332 
6333 //------------------------------inline_ghash_processBlocks
6334 bool LibraryCallKit::inline_ghash_processBlocks() {
6335   address stubAddr;
6336   const char *stubName;
6337   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6338 
6339   stubAddr = StubRoutines::ghash_processBlocks();
6340   stubName = &quot;ghash_processBlocks&quot;;
6341 
6342   Node* data           = argument(0);
6343   Node* offset         = argument(1);
6344   Node* len            = argument(2);
6345   Node* state          = argument(3);
6346   Node* subkeyH        = argument(4);
6347 
6348   state = must_be_not_null(state, true);
6349   subkeyH = must_be_not_null(subkeyH, true);
6350   data = must_be_not_null(data, true);
6351 




6352   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6353   assert(state_start, &quot;state is NULL&quot;);
6354   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6355   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6356   Node* data_start  = array_element_address(data, offset, T_BYTE);
6357   assert(data_start, &quot;data is NULL&quot;);
6358 
6359   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6360                                   OptoRuntime::ghash_processBlocks_Type(),
6361                                   stubAddr, stubName, TypePtr::BOTTOM,
6362                                   state_start, subkeyH_start, data_start, len);
6363   return true;
6364 }
6365 
6366 bool LibraryCallKit::inline_base64_encodeBlock() {
6367   address stubAddr;
6368   const char *stubName;
6369   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6370   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6371   stubAddr = StubRoutines::base64_encodeBlock();
6372   stubName = &quot;encodeBlock&quot;;
6373 
6374   if (!stubAddr) return false;
6375   Node* base64obj = argument(0);
6376   Node* src = argument(1);
6377   Node* offset = argument(2);
6378   Node* len = argument(3);
6379   Node* dest = argument(4);
6380   Node* dp = argument(5);
6381   Node* isURL = argument(6);
6382 
6383   src = must_be_not_null(src, true);

6384   dest = must_be_not_null(dest, true);

6385 
6386   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6387   assert(src_start, &quot;source array is NULL&quot;);
6388   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6389   assert(dest_start, &quot;destination array is NULL&quot;);
6390 
6391   Node* base64 = make_runtime_call(RC_LEAF,
6392                                    OptoRuntime::base64_encodeBlock_Type(),
6393                                    stubAddr, stubName, TypePtr::BOTTOM,
6394                                    src_start, offset, len, dest_start, dp, isURL);
6395   return true;
6396 }
6397 
6398 //------------------------------inline_sha_implCompress-----------------------
6399 //
6400 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6401 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6402 //
6403 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6404 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
</pre>
<hr />
<pre>
6409 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6410   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6411 
6412   Node* sha_obj = argument(0);
6413   Node* src     = argument(1); // type oop
6414   Node* ofs     = argument(2); // type int
6415 
6416   const Type* src_type = src-&gt;Value(&amp;_gvn);
6417   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6418   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6419     // failed array check
6420     return false;
6421   }
6422   // Figure out the size and type of the elements we will be copying.
6423   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6424   if (src_elem != T_BYTE) {
6425     return false;
6426   }
6427   // &#39;src_start&#39; points to src array + offset
6428   src = must_be_not_null(src, true);

6429   Node* src_start = array_element_address(src, ofs, src_elem);
6430   Node* state = NULL;
6431   address stubAddr;
6432   const char *stubName;
6433 
6434   switch(id) {
6435   case vmIntrinsics::_sha_implCompress:
6436     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6437     state = get_state_from_sha_object(sha_obj);
6438     stubAddr = StubRoutines::sha1_implCompress();
6439     stubName = &quot;sha1_implCompress&quot;;
6440     break;
6441   case vmIntrinsics::_sha2_implCompress:
6442     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6443     state = get_state_from_sha_object(sha_obj);
6444     stubAddr = StubRoutines::sha256_implCompress();
6445     stubName = &quot;sha256_implCompress&quot;;
6446     break;
6447   case vmIntrinsics::_sha5_implCompress:
6448     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6449     state = get_state_from_sha5_object(sha_obj);
6450     stubAddr = StubRoutines::sha512_implCompress();
6451     stubName = &quot;sha512_implCompress&quot;;
6452     break;
6453   default:
6454     fatal_unexpected_iid(id);
6455     return false;
6456   }
6457   if (state == NULL) return false;
6458 
<span class="line-added">6459   assert(stubAddr != NULL, &quot;Stub is generated&quot;);</span>
<span class="line-added">6460   if (stubAddr == NULL) return false;</span>
<span class="line-added">6461 </span>
6462   // Call the stub.
6463   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6464                                  stubAddr, stubName, TypePtr::BOTTOM,
6465                                  src_start, state);
6466 
6467   return true;
6468 }
6469 
6470 //------------------------------inline_digestBase_implCompressMB-----------------------
6471 //
6472 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6473 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6474 //
6475 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6476   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6477          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6478   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6479   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6480 
6481   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6482   Node* src            = argument(1); // byte[] array
6483   Node* ofs            = argument(2); // type int
6484   Node* limit          = argument(3); // type int
6485 
6486   const Type* src_type = src-&gt;Value(&amp;_gvn);
6487   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6488   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6489     // failed array check
6490     return false;
6491   }
6492   // Figure out the size and type of the elements we will be copying.
6493   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6494   if (src_elem != T_BYTE) {
6495     return false;
6496   }
6497   // &#39;src_start&#39; points to src array + offset
6498   src = must_be_not_null(src, false);

6499   Node* src_start = array_element_address(src, ofs, src_elem);
6500 
6501   const char* klass_SHA_name = NULL;
6502   const char* stub_name = NULL;
6503   address     stub_addr = NULL;
6504   bool        long_state = false;
6505 
6506   switch (predicate) {
6507   case 0:
6508     if (UseSHA1Intrinsics) {
6509       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6510       stub_name = &quot;sha1_implCompressMB&quot;;
6511       stub_addr = StubRoutines::sha1_implCompressMB();
6512     }
6513     break;
6514   case 1:
6515     if (UseSHA256Intrinsics) {
6516       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6517       stub_name = &quot;sha256_implCompressMB&quot;;
6518       stub_addr = StubRoutines::sha256_implCompressMB();
6519     }
6520     break;
6521   case 2:
6522     if (UseSHA512Intrinsics) {
6523       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6524       stub_name = &quot;sha512_implCompressMB&quot;;
6525       stub_addr = StubRoutines::sha512_implCompressMB();
6526       long_state = true;
6527     }
6528     break;
6529   default:
6530     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6531   }
6532   if (klass_SHA_name != NULL) {
<span class="line-added">6533     assert(stub_addr != NULL, &quot;Stub is generated&quot;);</span>
<span class="line-added">6534     if (stub_addr == NULL) return false;</span>
<span class="line-added">6535 </span>
6536     // get DigestBase klass to lookup for SHA klass
6537     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6538     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6539     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6540 
6541     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6542     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6543     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6544     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6545   }
6546   return false;
6547 }
6548 //------------------------------inline_sha_implCompressMB-----------------------
6549 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6550                                                bool long_state, address stubAddr, const char *stubName,
6551                                                Node* src_start, Node* ofs, Node* limit) {
6552   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6553   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6554   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6555   sha_obj = _gvn.transform(sha_obj);
</pre>
<hr />
<pre>
6564 
6565   // Call the stub.
6566   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6567                                  OptoRuntime::digestBase_implCompressMB_Type(),
6568                                  stubAddr, stubName, TypePtr::BOTTOM,
6569                                  src_start, state, ofs, limit);
6570   // return ofs (int)
6571   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6572   set_result(result);
6573 
6574   return true;
6575 }
6576 
6577 //------------------------------get_state_from_sha_object-----------------------
6578 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6579   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6580   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6581   if (sha_state == NULL) return (Node *) NULL;
6582 
6583   // now have the array, need to get the start address of the state array

6584   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6585   return state;
6586 }
6587 
6588 //------------------------------get_state_from_sha5_object-----------------------
6589 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6590   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6591   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6592   if (sha_state == NULL) return (Node *) NULL;
6593 
6594   // now have the array, need to get the start address of the state array

6595   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6596   return state;
6597 }
6598 
6599 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6600 // Return node representing slow path of predicate check.
6601 // the pseudo code we want to emulate with this predicate is:
6602 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6603 //
6604 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6605   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6606          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6607   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6608 
6609   // The receiver was checked for NULL already.
6610   Node* digestBaseObj = argument(0);
6611 
6612   // get DigestBase klass for instanceOf check
6613   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6614   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
</pre>
<hr />
<pre>
6752   Node *a = NULL;
6753   Node *b = NULL;
6754   Node *n = NULL;
6755   switch (id) {
6756   case vmIntrinsics::_maxF:
6757   case vmIntrinsics::_minF:
6758     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
6759     a = argument(0);
6760     b = argument(1);
6761     break;
6762   case vmIntrinsics::_maxD:
6763   case vmIntrinsics::_minD:
6764     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
6765     a = round_double_node(argument(0));
6766     b = round_double_node(argument(2));
6767     break;
6768   default:
6769     fatal_unexpected_iid(id);
6770     break;
6771   }



6772   switch (id) {
6773   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
6774   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
6775   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
6776   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
6777   default:  fatal_unexpected_iid(id);  break;
6778   }
6779   set_result(_gvn.transform(n));
6780   return true;
6781 }
6782 
6783 bool LibraryCallKit::inline_profileBoolean() {
6784   Node* counts = argument(1);
6785   const TypeAryPtr* ary = NULL;
6786   ciArray* aobj = NULL;
6787   if (counts-&gt;is_Con()
6788       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
6789       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
6790       &amp;&amp; (aobj-&gt;length() == 2)) {
6791     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
</pre>
</td>
</tr>
</table>
<center><a href="lcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="live.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
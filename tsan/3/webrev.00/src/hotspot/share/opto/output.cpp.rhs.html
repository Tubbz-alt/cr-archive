<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  34 #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-added">  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;</span>
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;
  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  49 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  50 #include &quot;utilities/xmlstream.hpp&quot;
  51 
  52 #ifndef PRODUCT
  53 #define DEBUG_ARG(x) , x
  54 #else
  55 #define DEBUG_ARG(x)
  56 #endif
  57 
  58 // Convert Nodes to instruction bits and pass off to the VM
  59 void Compile::Output() {
  60   // RootNode goes
  61   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );
  62 
  63   // The number of new nodes (mostly MachNop) is proportional to
  64   // the number of java calls and inner loops which are aligned.
  65   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  66                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  67                            &quot;out of nodes before code generation&quot; ) ) {
  68     return;
  69   }
  70   // Make sure I can find the Start Node
  71   Block *entry = _cfg-&gt;get_block(1);
  72   Block *broot = _cfg-&gt;get_root_block();
  73 
  74   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  75 
  76   // Replace StartNode with prolog
  77   MachPrologNode *prolog = new MachPrologNode();
  78   entry-&gt;map_node(prolog, 0);
  79   _cfg-&gt;map_node_to_block(prolog, entry);
  80   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block
  81 
  82   // Virtual methods need an unverified entry point
  83 
  84   if( is_osr_compilation() ) {
  85     if( PoisonOSREntry ) {
  86       // TODO: Should use a ShouldNotReachHereNode...
  87       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );
  88     }
  89   } else {
  90     if( _method &amp;&amp; !_method-&gt;flags().is_static() ) {
  91       // Insert unvalidated entry point
  92       _cfg-&gt;insert( broot, 0, new MachUEPNode() );
  93     }
  94 
  95   }
  96 
  97   // Break before main entry point
  98   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||
  99       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||
 100       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||
 101       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {
 102     // checking for _method means that OptoBreakpoint does not apply to
 103     // runtime stubs or frame converters
 104     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );
 105   }
 106 
 107   // Insert epilogs before every return
 108   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
 109     Block* block = _cfg-&gt;get_block(i);
 110     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?
 111       Node* m = block-&gt;end();
 112       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 113         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 114         block-&gt;add_inst(epilog);
 115         _cfg-&gt;map_node_to_block(epilog, block);
 116       }
 117     }
 118   }
 119 
<a name="4" id="anc4"></a><span class="line-added"> 120   // Keeper of sizing aspects</span>
<span class="line-added"> 121   BufferSizingData buf_sizes = BufferSizingData();</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123   // Initialize code buffer</span>
<span class="line-added"> 124   estimate_buffer_size(buf_sizes._const);</span>
<span class="line-added"> 125   if (failing()) return;</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   // Pre-compute the length of blocks and replace</span>
<span class="line-added"> 128   // long branches with short if machine supports it.</span>
<span class="line-added"> 129   // Must be done before ScheduleAndBundle due to SPARC delay slots</span>
 130   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);
 131   blk_starts[0] = 0;
<a name="5" id="anc5"></a><span class="line-added"> 132   shorten_branches(blk_starts, buf_sizes);</span>
 133 
<a name="6" id="anc6"></a><span class="line-modified"> 134   ScheduleAndBundle();</span>
<span class="line-modified"> 135   if (failing()) {</span>


 136     return;
 137   }
 138 
<a name="7" id="anc7"></a><span class="line-modified"> 139   // Late barrier analysis must be done after schedule and bundle</span>
<span class="line-modified"> 140   // Otherwise liveness based spilling will fail</span>
<span class="line-modified"> 141   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified"> 142   bs-&gt;late_barrier_analysis();</span>













 143 
<a name="8" id="anc8"></a><span class="line-modified"> 144   // Complete sizing of codebuffer</span>
<span class="line-added"> 145   CodeBuffer* cb = init_buffer(buf_sizes);</span>
<span class="line-added"> 146   if (cb == NULL || failing()) {</span>
 147     return;
 148   }
 149 
 150   BuildOopMaps();
 151 
 152   if (failing())  {
 153     return;
 154   }
 155 
 156   fill_buffer(cb, blk_starts);
 157 }
 158 
 159 bool Compile::need_stack_bang(int frame_size_in_bytes) const {
 160   // Determine if we need to generate a stack overflow check.
 161   // Do it if the method is not a stub function and
 162   // has java calls or has frame size &gt; vm_page_size/8.
 163   // The debug VM checks that deoptimization doesn&#39;t trigger an
 164   // unexpected stack overflow (compiled method stack banging should
 165   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 166   // a debug VM.
 167   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;
 168           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3
 169            DEBUG_ONLY(|| true)));
 170 }
 171 
 172 bool Compile::need_register_stack_bang() const {
 173   // Determine if we need to generate a register stack overflow check.
 174   // This is only used on architectures which have split register
 175   // and memory stacks (ie. IA64).
 176   // Bang if the method is not a stub function and has java calls
 177   return (stub_function() == NULL &amp;&amp; has_java_calls());
 178 }
 179 
 180 
 181 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 182 // of a loop. When aligning a loop we need to provide enough instructions
 183 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 184 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 185 // By default, the size is set to 999999 by Block&#39;s constructor so that
 186 // a loop will be aligned if the size is not reset here.
 187 //
 188 // Note: Mach instructions could contain several HW instructions
 189 // so the size is estimated only.
 190 //
 191 void Compile::compute_loop_first_inst_sizes() {
 192   // The next condition is used to gate the loop alignment optimization.
 193   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 194   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 195   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 196   // equal to 11 bytes which is the largest address NOP instruction.
 197   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
 198     uint last_block = _cfg-&gt;number_of_blocks() - 1;
 199     for (uint i = 1; i &lt;= last_block; i++) {
 200       Block* block = _cfg-&gt;get_block(i);
 201       // Check the first loop&#39;s block which requires an alignment.
 202       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 203         uint sum_size = 0;
 204         uint inst_cnt = NumberOfLoopInstrToAlign;
 205         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 206 
 207         // Check subsequent fallthrough blocks if the loop&#39;s first
 208         // block(s) does not have enough instructions.
 209         Block *nb = block;
 210         while(inst_cnt &gt; 0 &amp;&amp;
 211               i &lt; last_block &amp;&amp;
 212               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;
 213               !nb-&gt;has_successor(block)) {
 214           i++;
 215           nb = _cfg-&gt;get_block(i);
 216           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 217         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 218 
 219         block-&gt;set_first_inst_size(sum_size);
 220       } // f( b-&gt;head()-&gt;is_Loop() )
 221     } // for( i &lt;= last_block )
 222   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 223 }
 224 
 225 // The architecture description provides short branch variants for some long
 226 // branch instructions. Replace eligible long branches with short branches.
<a name="9" id="anc9"></a><span class="line-modified"> 227 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 228   // Compute size of each block, method size, and relocation information size
 229   uint nblocks  = _cfg-&gt;number_of_blocks();
 230 
 231   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 232   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 233   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 234 
 235   // Collect worst case block paddings
 236   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 237   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 238 
 239   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 240   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 241 
 242   bool has_short_branch_candidate = false;
 243 
 244   // Initialize the sizes to 0
<a name="10" id="anc10"></a><span class="line-modified"> 245   int code_size  = 0;          // Size in bytes of generated code</span>
<span class="line-modified"> 246   int stub_size  = 0;          // Size in bytes of all stub entries</span>
 247   // Size in bytes of all relocation entries, including those in local stubs.
 248   // Start with 2-bytes of reloc info for the unvalidated entry point
<a name="11" id="anc11"></a><span class="line-modified"> 249   int reloc_size = 1;          // Number of relocation entries</span>
 250 
 251   // Make three passes.  The first computes pessimistic blk_starts,
 252   // relative jmp_offset and reloc_size information.  The second performs
 253   // short branch substitution using the pessimistic sizing.  The
 254   // third inserts nops where needed.
 255 
 256   // Step one, perform a pessimistic sizing pass.
 257   uint last_call_adr = max_juint;
 258   uint last_avoid_back_to_back_adr = max_juint;
 259   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);
 260   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 261     Block* block = _cfg-&gt;get_block(i);
 262 
 263     // During short branch replacement, we store the relative (to blk_starts)
 264     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 265     // This is so that we do not need to recompute sizes of all nodes when
 266     // we compute correct blk_starts in our next sizing pass.
 267     jmp_offset[i] = 0;
 268     jmp_size[i]   = 0;
 269     jmp_nidx[i]   = -1;
 270     DEBUG_ONLY( jmp_target[i] = 0; )
 271     DEBUG_ONLY( jmp_rule[i]   = 0; )
 272 
 273     // Sum all instruction sizes to compute block size
 274     uint last_inst = block-&gt;number_of_nodes();
 275     uint blk_size = 0;
 276     for (uint j = 0; j &lt; last_inst; j++) {
 277       Node* nj = block-&gt;get_node(j);
 278       // Handle machine instruction nodes
 279       if (nj-&gt;is_Mach()) {
 280         MachNode *mach = nj-&gt;as_Mach();
 281         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
 282         reloc_size += mach-&gt;reloc();
 283         if (mach-&gt;is_MachCall()) {
 284           // add size information for trampoline stub
 285           // class CallStubImpl is platform-specific and defined in the *.ad files.
 286           stub_size  += CallStubImpl::size_call_trampoline();
 287           reloc_size += CallStubImpl::reloc_call_trampoline();
 288 
 289           MachCallNode *mcall = mach-&gt;as_MachCall();
 290           // This destination address is NOT PC-relative
 291 
 292           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 293 
 294           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 295             stub_size  += CompiledStaticCall::to_interp_stub_size();
 296             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 297 #if INCLUDE_AOT
 298             stub_size  += CompiledStaticCall::to_aot_stub_size();
 299             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 300 #endif
 301           }
 302         } else if (mach-&gt;is_MachSafePoint()) {
 303           // If call/safepoint are adjacent, account for possible
 304           // nop to disambiguate the two safepoints.
 305           // ScheduleAndBundle() can rearrange nodes in a block,
 306           // check for all offsets inside this block.
 307           if (last_call_adr &gt;= blk_starts[i]) {
 308             blk_size += nop_size;
 309           }
 310         }
 311         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 312           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 313           // ScheduleAndBundle() can rearrange nodes in a block,
 314           // check for all offsets inside this block.
 315           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 316             blk_size += nop_size;
 317           }
 318         }
 319         if (mach-&gt;may_be_short_branch()) {
 320           if (!nj-&gt;is_MachBranch()) {
 321 #ifndef PRODUCT
 322             nj-&gt;dump(3);
 323 #endif
 324             Unimplemented();
 325           }
 326           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 327           jmp_offset[i] = blk_size;
 328           jmp_size[i]   = nj-&gt;size(_regalloc);
 329           jmp_nidx[i]   = j;
 330           has_short_branch_candidate = true;
 331         }
 332       }
 333       blk_size += nj-&gt;size(_regalloc);
 334       // Remember end of call offset
 335       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 336         last_call_adr = blk_starts[i]+blk_size;
 337       }
 338       // Remember end of avoid_back_to_back offset
 339       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 340         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 341       }
 342     }
 343 
 344     // When the next block starts a loop, we may insert pad NOP
 345     // instructions.  Since we cannot know our future alignment,
 346     // assume the worst.
 347     if (i &lt; nblocks - 1) {
 348       Block* nb = _cfg-&gt;get_block(i + 1);
 349       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 350       if (max_loop_pad &gt; 0) {
 351         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 352         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 353         // If either is the last instruction in this block, bump by
 354         // max_loop_pad in lock-step with blk_size, so sizing
 355         // calculations in subsequent blocks still can conservatively
 356         // detect that it may the last instruction in this block.
 357         if (last_call_adr == blk_starts[i]+blk_size) {
 358           last_call_adr += max_loop_pad;
 359         }
 360         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 361           last_avoid_back_to_back_adr += max_loop_pad;
 362         }
 363         blk_size += max_loop_pad;
 364         block_worst_case_pad[i + 1] = max_loop_pad;
 365       }
 366     }
 367 
 368     // Save block size; update total method size
 369     blk_starts[i+1] = blk_starts[i]+blk_size;
 370   }
 371 
 372   // Step two, replace eligible long jumps.
 373   bool progress = true;
 374   uint last_may_be_short_branch_adr = max_juint;
 375   while (has_short_branch_candidate &amp;&amp; progress) {
 376     progress = false;
 377     has_short_branch_candidate = false;
 378     int adjust_block_start = 0;
 379     for (uint i = 0; i &lt; nblocks; i++) {
 380       Block* block = _cfg-&gt;get_block(i);
 381       int idx = jmp_nidx[i];
 382       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 383       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 384 #ifdef ASSERT
 385         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 386         int j;
 387         // Find the branch; ignore trailing NOPs.
 388         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 389           Node* n = block-&gt;get_node(j);
 390           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 391             break;
 392         }
 393         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 394 #endif
 395         int br_size = jmp_size[i];
 396         int br_offs = blk_starts[i] + jmp_offset[i];
 397 
 398         // This requires the TRUE branch target be in succs[0]
 399         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 400         int offset = blk_starts[bnum] - br_offs;
 401         if (bnum &gt; i) { // adjust following block&#39;s offset
 402           offset -= adjust_block_start;
 403         }
 404 
 405         // This block can be a loop header, account for the padding
 406         // in the previous block.
 407         int block_padding = block_worst_case_pad[i];
 408         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 409         // In the following code a nop could be inserted before
 410         // the branch which will increase the backward distance.
 411         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 412         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 413 
 414         if (needs_padding &amp;&amp; offset &lt;= 0)
 415           offset -= nop_size;
 416 
 417         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
 418           // We&#39;ve got a winner.  Replace this branch.
 419           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 420 
 421           // Update the jmp_size.
 422           int new_size = replacement-&gt;size(_regalloc);
 423           int diff     = br_size - new_size;
 424           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 425           // Conservatively take into account padding between
 426           // avoid_back_to_back branches. Previous branch could be
 427           // converted into avoid_back_to_back branch during next
 428           // rounds.
 429           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 430             jmp_offset[i] += nop_size;
 431             diff -= nop_size;
 432           }
 433           adjust_block_start += diff;
 434           block-&gt;map_node(replacement, idx);
 435           mach-&gt;subsume_by(replacement, C);
 436           mach = replacement;
 437           progress = true;
 438 
 439           jmp_size[i] = new_size;
 440           DEBUG_ONLY( jmp_target[i] = bnum; );
 441           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 442         } else {
 443           // The jump distance is not short, try again during next iteration.
 444           has_short_branch_candidate = true;
 445         }
 446       } // (mach-&gt;may_be_short_branch())
 447       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 448                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 449         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 450       }
 451       blk_starts[i+1] -= adjust_block_start;
 452     }
 453   }
 454 
 455 #ifdef ASSERT
 456   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 457     if (jmp_target[i] != 0) {
 458       int br_size = jmp_size[i];
 459       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
 460       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
 461         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 462       }
 463       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);
 464     }
 465   }
 466 #endif
 467 
 468   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 469   // after ScheduleAndBundle().
 470 
 471   // ------------------
 472   // Compute size for code buffer
 473   code_size = blk_starts[nblocks];
 474 
 475   // Relocation records
 476   reloc_size += 1;              // Relo entry for exception handler
 477 
 478   // Adjust reloc_size to number of record of relocation info
 479   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 480   // a relocation index.
 481   // The CodeBuffer will expand the locs array if this estimate is too low.
 482   reloc_size *= 10 / sizeof(relocInfo);
<a name="12" id="anc12"></a><span class="line-added"> 483 </span>
<span class="line-added"> 484   buf_sizes._reloc = reloc_size;</span>
<span class="line-added"> 485   buf_sizes._code  = code_size;</span>
<span class="line-added"> 486   buf_sizes._stub  = stub_size;</span>
 487 }
 488 
 489 //------------------------------FillLocArray-----------------------------------
 490 // Create a bit of debug info and append it to the array.  The mapping is from
 491 // Java local or expression stack to constant, register or stack-slot.  For
 492 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 493 // entry has been taken care of and caller should skip it).
 494 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 495   // This should never have accepted Bad before
 496   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 497   return (OptoReg::is_reg(regnum))
<a name="13" id="anc13"></a><span class="line-modified"> 498          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )</span>
<span class="line-modified"> 499          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));</span>
 500 }
 501 
 502 
 503 ObjectValue*
 504 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
 505   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 506     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 507     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 508     if (sv-&gt;id() == id) {
 509       return sv;
 510     }
 511   }
 512   // Otherwise..
 513   return NULL;
 514 }
 515 
 516 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
 517                                      ObjectValue* sv ) {
 518   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 519   objs-&gt;append(sv);
 520 }
 521 
 522 
 523 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
 524                             GrowableArray&lt;ScopeValue*&gt; *array,
 525                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 526   assert( local, &quot;use _top instead of null&quot; );
 527   if (array-&gt;length() != idx) {
 528     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 529     // Old functionality:
 530     //   return
 531     // New functionality:
 532     //   Assert if the local is not top. In product mode let the new node
 533     //   override the old entry.
 534     assert(local == top(), &quot;LocArray collision&quot;);
 535     if (local == top()) {
 536       return;
 537     }
 538     array-&gt;pop();
 539   }
 540   const Type *t = local-&gt;bottom_type();
 541 
 542   // Is it a safepoint scalar object node?
 543   if (local-&gt;is_SafePointScalarObject()) {
 544     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 545 
 546     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 547     if (sv == NULL) {
 548       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 549       assert(cik-&gt;is_instance_klass() ||
 550              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 551       sv = new ObjectValue(spobj-&gt;_idx,
 552                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 553       Compile::set_sv_for_object_node(objs, sv);
 554 
 555       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 556       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 557         Node* fld_node = sfpt-&gt;in(first_ind+i);
 558         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 559       }
 560     }
 561     array-&gt;append(sv);
 562     return;
 563   }
 564 
 565   // Grab the register number for the local
 566   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);
 567   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 568     // Record the double as two float registers.
 569     // The register mask for such a value always specifies two adjacent
 570     // float registers, with the lower register number even.
 571     // Normally, the allocation of high and low words to these registers
 572     // is irrelevant, because nearly all operations on register pairs
 573     // (e.g., StoreD) treat them as a single unit.
 574     // Here, we assume in addition that the words in these two registers
 575     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 576     // within the interpreter) such that the lower-numbered register
 577     // is written to the lower memory address.  This may seem like
 578     // a machine dependency, but it is not--it is a requirement on
 579     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 580     // even/odd double-register pair to which a double may be allocated,
 581     // the word in the even single-register is stored to the first
 582     // memory word.  (Note that register numbers are completely
 583     // arbitrary, and are not tied to any machine-level encodings.)
 584 #ifdef _LP64
 585     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 586       array-&gt;append(new ConstantIntValue((jint)0));
 587       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));
 588     } else if ( t-&gt;base() == Type::Long ) {
 589       array-&gt;append(new ConstantIntValue((jint)0));
 590       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 591     } else if ( t-&gt;base() == Type::RawPtr ) {
 592       // jsr/ret return address which must be restored into a the full
 593       // width 64-bit stack slot.
 594       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 595     }
 596 #else //_LP64
 597 #ifdef SPARC
 598     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 599       // For SPARC we have to swap high and low words for
 600       // long values stored in a single-register (g0-g7).
 601       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 602       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 603     } else
 604 #endif //SPARC
 605     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 606       // Repack the double/long as two jints.
 607       // The convention the interpreter uses is that the second local
 608       // holds the first raw word of the native double representation.
 609       // This is actually reasonable, since locals and stack arrays
 610       // grow downwards in all implementations.
 611       // (If, on some machine, the interpreter&#39;s Java locals or stack
 612       // were to grow upwards, the embedded doubles would be word-swapped.)
 613       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 614       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 615     }
 616 #endif //_LP64
 617     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
<a name="14" id="anc14"></a><span class="line-modified"> 618              OptoReg::is_reg(regnum) ) {</span>
 619       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()
<a name="15" id="anc15"></a><span class="line-modified"> 620                                                       ? Location::float_in_dbl : Location::normal ));</span>
 621     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
 622       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long
<a name="16" id="anc16"></a><span class="line-modified"> 623                                                       ? Location::int_in_long : Location::normal ));</span>
 624     } else if( t-&gt;base() == Type::NarrowOop ) {
 625       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));
 626     } else {
 627       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));
 628     }
 629     return;
 630   }
 631 
 632   // No register.  It must be constant data.
 633   switch (t-&gt;base()) {
<a name="17" id="anc17"></a><span class="line-modified"> 634     case Type::Half:              // Second half of a double</span>
<span class="line-modified"> 635       ShouldNotReachHere();       // Caller should skip 2nd halves</span>
<span class="line-modified"> 636       break;</span>
<span class="line-modified"> 637     case Type::AnyPtr:</span>








 638       array-&gt;append(new ConstantOopWriteValue(NULL));
<a name="18" id="anc18"></a><span class="line-modified"> 639       break;</span>
<span class="line-modified"> 640     case Type::AryPtr:</span>
<span class="line-modified"> 641     case Type::InstPtr:          // fall through</span>
<span class="line-modified"> 642       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="line-modified"> 643       break;</span>
<span class="line-modified"> 644     case Type::NarrowOop:</span>
<span class="line-modified"> 645       if (t == TypeNarrowOop::NULL_PTR) {</span>
<span class="line-modified"> 646         array-&gt;append(new ConstantOopWriteValue(NULL));</span>
<span class="line-modified"> 647       } else {</span>
<span class="line-modified"> 648         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));</span>
<span class="line-added"> 649       }</span>
<span class="line-added"> 650       break;</span>
<span class="line-added"> 651     case Type::Int:</span>
<span class="line-added"> 652       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));</span>
<span class="line-added"> 653       break;</span>
<span class="line-added"> 654     case Type::RawPtr:</span>
<span class="line-added"> 655       // A return address (T_ADDRESS).</span>
<span class="line-added"> 656       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);</span>
 657 #ifdef _LP64
<a name="19" id="anc19"></a><span class="line-modified"> 658       // Must be restored to the full-width 64-bit stack slot.</span>
<span class="line-modified"> 659       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));</span>
 660 #else
<a name="20" id="anc20"></a><span class="line-modified"> 661       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));</span>
 662 #endif
<a name="21" id="anc21"></a><span class="line-modified"> 663       break;</span>
<span class="line-modified"> 664     case Type::FloatCon: {</span>
<span class="line-modified"> 665       float f = t-&gt;is_float_constant()-&gt;getf();</span>
<span class="line-modified"> 666       array-&gt;append(new ConstantIntValue(jint_cast(f)));</span>
<span class="line-modified"> 667       break;</span>
<span class="line-modified"> 668     }</span>
<span class="line-modified"> 669     case Type::DoubleCon: {</span>
<span class="line-modified"> 670       jdouble d = t-&gt;is_double_constant()-&gt;getd();</span>
 671 #ifdef _LP64
<a name="22" id="anc22"></a><span class="line-modified"> 672       array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="line-modified"> 673       array-&gt;append(new ConstantDoubleValue(d));</span>
 674 #else
<a name="23" id="anc23"></a><span class="line-modified"> 675       // Repack the double as two jints.</span>
 676     // The convention the interpreter uses is that the second local
 677     // holds the first raw word of the native double representation.
 678     // This is actually reasonable, since locals and stack arrays
 679     // grow downwards in all implementations.
 680     // (If, on some machine, the interpreter&#39;s Java locals or stack
 681     // were to grow upwards, the embedded doubles would be word-swapped.)
 682     jlong_accessor acc;
 683     acc.long_value = jlong_cast(d);
 684     array-&gt;append(new ConstantIntValue(acc.words[1]));
 685     array-&gt;append(new ConstantIntValue(acc.words[0]));
 686 #endif
<a name="24" id="anc24"></a><span class="line-modified"> 687       break;</span>
<span class="line-modified"> 688     }</span>
<span class="line-modified"> 689     case Type::Long: {</span>
<span class="line-modified"> 690       jlong d = t-&gt;is_long()-&gt;get_con();</span>
 691 #ifdef _LP64
<a name="25" id="anc25"></a><span class="line-modified"> 692       array-&gt;append(new ConstantIntValue((jint)0));</span>
<span class="line-modified"> 693       array-&gt;append(new ConstantLongValue(d));</span>
 694 #else
<a name="26" id="anc26"></a><span class="line-modified"> 695       // Repack the long as two jints.</span>
 696     // The convention the interpreter uses is that the second local
 697     // holds the first raw word of the native double representation.
 698     // This is actually reasonable, since locals and stack arrays
 699     // grow downwards in all implementations.
 700     // (If, on some machine, the interpreter&#39;s Java locals or stack
 701     // were to grow upwards, the embedded doubles would be word-swapped.)
 702     jlong_accessor acc;
 703     acc.long_value = d;
 704     array-&gt;append(new ConstantIntValue(acc.words[1]));
 705     array-&gt;append(new ConstantIntValue(acc.words[0]));
 706 #endif
<a name="27" id="anc27"></a><span class="line-modified"> 707       break;</span>
<span class="line-modified"> 708     }</span>
<span class="line-modified"> 709     case Type::Top:               // Add an illegal value here</span>
<span class="line-modified"> 710       array-&gt;append(new LocationValue(Location()));</span>
<span class="line-modified"> 711       break;</span>
<span class="line-modified"> 712     default:</span>
<span class="line-modified"> 713       ShouldNotReachHere();</span>
<span class="line-modified"> 714       break;</span>
 715   }
 716 }
 717 
 718 // Determine if this node starts a bundle
 719 bool Compile::starts_bundle(const Node *n) const {
 720   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 721           _node_bundling_base[n-&gt;_idx].starts_bundle());
 722 }
 723 
 724 //--------------------------Process_OopMap_Node--------------------------------
 725 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {
 726 
 727   // Handle special safepoint nodes for synchronization
 728   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 729   MachCallNode      *mcall;
 730 
 731   int safepoint_pc_offset = current_offset;
 732   bool is_method_handle_invoke = false;
 733   bool return_oop = false;
 734 
 735   // Add the safepoint in the DebugInfoRecorder
 736   if( !mach-&gt;is_MachCall() ) {
 737     mcall = NULL;
 738     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);
 739   } else {
 740     mcall = mach-&gt;as_MachCall();
 741 
 742     // Is the call a MethodHandle call?
 743     if (mcall-&gt;is_MachCallJava()) {
 744       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
 745         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);
 746         is_method_handle_invoke = true;
 747       }
 748     }
 749 
 750     // Check if a call returns an object.
 751     if (mcall-&gt;returns_pointer()) {
 752       return_oop = true;
 753     }
 754     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
 755     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);
 756   }
 757 
 758   // Loop over the JVMState list to add scope information
 759   // Do not skip safepoints with a NULL method, they need monitor info
 760   JVMState* youngest_jvms = sfn-&gt;jvms();
 761   int max_depth = youngest_jvms-&gt;depth();
 762 
 763   // Allocate the object pool for scalar-replaced objects -- the map from
 764   // small-integer keys (which can be recorded in the local and ostack
 765   // arrays) to descriptions of the object state.
 766   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 767 
 768   // Visit scopes from oldest to youngest.
 769   for (int depth = 1; depth &lt;= max_depth; depth++) {
 770     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 771     int idx;
 772     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 773     // Safepoints that do not have method() set only provide oop-map and monitor info
 774     // to support GC; these do not support deoptimization.
 775     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
 776     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
 777     int num_mon  = jvms-&gt;nof_monitors();
 778     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
 779            &quot;JVMS local count must match that of the method&quot;);
 780 
 781     // Add Local and Expression Stack Information
 782 
 783     // Insert locals into the locarray
 784     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
 785     for( idx = 0; idx &lt; num_locs; idx++ ) {
 786       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
 787     }
 788 
 789     // Insert expression stack entries into the exparray
 790     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
 791     for( idx = 0; idx &lt; num_exps; idx++ ) {
 792       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
 793     }
 794 
 795     // Add in mappings of the monitors
 796     assert( !method ||
 797             !method-&gt;is_synchronized() ||
 798             method-&gt;is_native() ||
 799             num_mon &gt; 0 ||
 800             !GenerateSynchronizationCode,
 801             &quot;monitors must always exist for synchronized methods&quot;);
 802 
 803     // Build the growable array of ScopeValues for exp stack
 804     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 805 
 806     // Loop over monitors and insert into array
 807     for (idx = 0; idx &lt; num_mon; idx++) {
 808       // Grab the node that defines this monitor
 809       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 810       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 811 
 812       // Create ScopeValue for object
 813       ScopeValue *scval = NULL;
 814 
 815       if (obj_node-&gt;is_SafePointScalarObject()) {
 816         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
 817         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 818         if (scval == NULL) {
 819           const Type *t = spobj-&gt;bottom_type();
 820           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 821           assert(cik-&gt;is_instance_klass() ||
 822                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 823           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 824                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 825           Compile::set_sv_for_object_node(objs, sv);
 826 
 827           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 828           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 829             Node* fld_node = sfn-&gt;in(first_ind+i);
 830             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 831           }
 832           scval = sv;
 833         }
 834       } else if (!obj_node-&gt;is_Con()) {
 835         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);
 836         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
 837           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );
 838         } else {
 839           scval = new_loc_value( _regalloc, obj_reg, Location::oop );
 840         }
 841       } else {
 842         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 843         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 844       }
 845 
 846       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
 847       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));
 848       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 849       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 850     }
 851 
 852     // We dump the object pool first, since deoptimization reads it in first.
 853     debug_info()-&gt;dump_object_pool(objs);
 854 
 855     // Build first class objects to pass to scope
 856     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);
 857     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);
 858     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);
 859 
 860     // Make method available for all Safepoints
 861     ciMethod* scope_method = method ? method : _method;
 862     // Describe the scope here
 863     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 864     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 865     // Now we can describe the scope.
 866     methodHandle null_mh;
 867     bool rethrow_exception = false;
 868     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);
 869   } // End jvms loop
 870 
 871   // Mark the end of the scope set.
 872   debug_info()-&gt;end_safepoint(safepoint_pc_offset);
 873 }
 874 
 875 
 876 
 877 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 878 class NonSafepointEmitter {
<a name="28" id="anc28"></a><span class="line-modified"> 879     Compile*  C;</span>
<span class="line-modified"> 880     JVMState* _pending_jvms;</span>
<span class="line-modified"> 881     int       _pending_offset;</span>
 882 
<a name="29" id="anc29"></a><span class="line-modified"> 883     void emit_non_safepoint();</span>
 884 
 885  public:
<a name="30" id="anc30"></a><span class="line-modified"> 886     NonSafepointEmitter(Compile* compile) {</span>
<span class="line-modified"> 887       this-&gt;C = compile;</span>
<span class="line-modified"> 888       _pending_jvms = NULL;</span>
<span class="line-modified"> 889       _pending_offset = 0;</span>
<span class="line-modified"> 890     }</span>
 891 
<a name="31" id="anc31"></a><span class="line-modified"> 892     void observe_instruction(Node* n, int pc_offset) {</span>
<span class="line-modified"> 893       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;</span>
 894 
<a name="32" id="anc32"></a><span class="line-modified"> 895       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);</span>
<span class="line-modified"> 896       if (nn == NULL || nn-&gt;jvms() == NULL)  return;</span>





 897       if (_pending_jvms != NULL &amp;&amp;
<a name="33" id="anc33"></a><span class="line-modified"> 898           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {</span>
<span class="line-modified"> 899         // Repeated JVMS?  Stretch it up here.</span>





 900         _pending_offset = pc_offset;
<a name="34" id="anc34"></a><span class="line-added"> 901       } else {</span>
<span class="line-added"> 902         if (_pending_jvms != NULL &amp;&amp;</span>
<span class="line-added"> 903             _pending_offset &lt; pc_offset) {</span>
<span class="line-added"> 904           emit_non_safepoint();</span>
<span class="line-added"> 905         }</span>
<span class="line-added"> 906         _pending_jvms = NULL;</span>
<span class="line-added"> 907         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {</span>
<span class="line-added"> 908           // This is the only way _pending_jvms can become non-NULL:</span>
<span class="line-added"> 909           _pending_jvms = nn-&gt;jvms();</span>
<span class="line-added"> 910           _pending_offset = pc_offset;</span>
<span class="line-added"> 911         }</span>
 912       }
 913     }
<a name="35" id="anc35"></a>
 914 
<a name="36" id="anc36"></a><span class="line-modified"> 915     // Stay out of the way of real safepoints:</span>
<span class="line-modified"> 916     void observe_safepoint(JVMState* jvms, int pc_offset) {</span>
<span class="line-modified"> 917       if (_pending_jvms != NULL &amp;&amp;</span>
<span class="line-modified"> 918           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;</span>
<span class="line-modified"> 919           _pending_offset &lt; pc_offset) {</span>
<span class="line-modified"> 920         emit_non_safepoint();</span>
<span class="line-added"> 921       }</span>
<span class="line-added"> 922       _pending_jvms = NULL;</span>
 923     }
<a name="37" id="anc37"></a>

 924 
<a name="38" id="anc38"></a><span class="line-modified"> 925     void flush_at_end() {</span>
<span class="line-modified"> 926       if (_pending_jvms != NULL) {</span>
<span class="line-modified"> 927         emit_non_safepoint();</span>
<span class="line-added"> 928       }</span>
<span class="line-added"> 929       _pending_jvms = NULL;</span>
 930     }
<a name="39" id="anc39"></a>

 931 };
 932 
 933 void NonSafepointEmitter::emit_non_safepoint() {
 934   JVMState* youngest_jvms = _pending_jvms;
 935   int       pc_offset     = _pending_offset;
 936 
 937   // Clear it now:
 938   _pending_jvms = NULL;
 939 
 940   DebugInformationRecorder* debug_info = C-&gt;debug_info();
 941   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
 942 
 943   debug_info-&gt;add_non_safepoint(pc_offset);
 944   int max_depth = youngest_jvms-&gt;depth();
 945 
 946   // Visit scopes from oldest to youngest.
 947   for (int depth = 1; depth &lt;= max_depth; depth++) {
 948     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 949     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 950     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
 951     methodHandle null_mh;
 952     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
 953   }
 954 
 955   // Mark the end of the scope set.
 956   debug_info-&gt;end_non_safepoint(pc_offset);
 957 }
 958 
 959 //------------------------------init_buffer------------------------------------
<a name="40" id="anc40"></a><span class="line-modified"> 960 void Compile::estimate_buffer_size(int&amp; const_req) {</span>
 961 
 962   // Set the initially allocated size
<a name="41" id="anc41"></a><span class="line-modified"> 963   const_req = initial_const_capacity;</span>



 964 
<a name="42" id="anc42"></a>
 965   // The extra spacing after the code is necessary on some platforms.
 966   // Sometimes we need to patch in a jump after the last instruction,
 967   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
 968 
 969   // Compute the byte offset where we can store the deopt pc.
 970   if (fixed_slots() != 0) {
 971     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
 972   }
 973 
 974   // Compute prolog code size
 975   _method_size = 0;
<a name="43" id="anc43"></a><span class="line-modified"> 976   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
 977 #if defined(IA64) &amp;&amp; !defined(AIX)
 978   if (save_argument_registers()) {
 979     // 4815101: this is a stub with implicit and unknown precision fp args.
 980     // The usual spill mechanism can only generate stfd&#39;s in this case, which
 981     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
 982     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
 983     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
 984     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
 985     //
 986     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
 987     // get rid of this hack and have SpillCopy generate stfspill/ldffill
 988     // instead of stfd/stfs/ldfd/ldfs.
 989     _frame_slots += 8*(16/BytesPerInt);
 990   }
 991 #endif
 992   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
 993 
 994   if (has_mach_constant_base_node()) {
 995     uint add_size = 0;
 996     // Fill the constant table.
 997     // Note:  This must happen before shorten_branches.
 998     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
 999       Block* b = _cfg-&gt;get_block(i);
1000 
1001       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1002         Node* n = b-&gt;get_node(j);
1003 
1004         // If the node is a MachConstantNode evaluate the constant
1005         // value section.
1006         if (n-&gt;is_MachConstant()) {
1007           MachConstantNode* machcon = n-&gt;as_MachConstant();
1008           machcon-&gt;eval_constant(C);
1009         } else if (n-&gt;is_Mach()) {
1010           // On Power there are more nodes that issue constants.
1011           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1012         }
1013       }
1014     }
1015 
1016     // Calculate the offsets of the constants and the size of the
1017     // constant table (including the padding to the next section).
1018     constant_table().calculate_offsets_and_size();
1019     const_req = constant_table().size() + add_size;
1020   }
1021 
1022   // Initialize the space for the BufferBlob used to find and verify
1023   // instruction size in MachNode::emit_size()
1024   init_scratch_buffer_blob(const_req);
<a name="44" id="anc44"></a><span class="line-modified">1025 }</span>
1026 
<a name="45" id="anc45"></a><span class="line-modified">1027 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
<span class="line-modified">1028 </span>
<span class="line-modified">1029   int stub_req  = buf_sizes._stub;</span>
<span class="line-added">1030   int code_req  = buf_sizes._code;</span>
<span class="line-added">1031   int const_req = buf_sizes._const;</span>
<span class="line-added">1032 </span>
<span class="line-added">1033   int pad_req   = NativeCall::instruction_size;</span>
<span class="line-added">1034 </span>
<span class="line-added">1035   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">1036   stub_req += bs-&gt;estimate_stub_size();</span>
1037 
1038   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1039   // class HandlerImpl is platform-specific and defined in the *.ad files.
1040   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1041   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1042   stub_req += MAX_stubs_size;   // ensure per-stub margin
1043   code_req += MAX_inst_size;    // ensure per-instruction margin
1044 
1045   if (StressCodeBuffers)
1046     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1047 
1048   int total_req =
<a name="46" id="anc46"></a><span class="line-modified">1049           const_req +</span>
<span class="line-modified">1050           code_req +</span>
<span class="line-modified">1051           pad_req +</span>
<span class="line-modified">1052           stub_req +</span>
<span class="line-modified">1053           exception_handler_req +</span>
<span class="line-modified">1054           deopt_handler_req;               // deopt handler</span>
1055 
1056   if (has_method_handle_invokes())
1057     total_req += deopt_handler_req;  // deopt MH handler
1058 
1059   CodeBuffer* cb = code_buffer();
<a name="47" id="anc47"></a><span class="line-modified">1060   cb-&gt;initialize(total_req, buf_sizes._reloc);</span>
1061 
1062   // Have we run out of code space?
1063   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1064     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1065     return NULL;
1066   }
1067   // Configure the code buffer.
1068   cb-&gt;initialize_consts_size(const_req);
1069   cb-&gt;initialize_stubs_size(stub_req);
1070   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());
1071 
1072   // fill in the nop array for bundling computations
1073   MachNode *_nop_list[Bundle::_nop_count];
1074   Bundle::initialize_nops(_nop_list);
1075 
1076   return cb;
1077 }
1078 
1079 //------------------------------fill_buffer------------------------------------
1080 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
1081   // blk_starts[] contains offsets calculated during short branches processing,
1082   // offsets should not be increased during following steps.
1083 
1084   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1085   // of a loop. It is used to determine the padding for loop alignment.
1086   compute_loop_first_inst_sizes();
1087 
1088   // Create oopmap set.
1089   _oop_map_set = new OopMapSet();
1090 
1091   // !!!!! This preserves old handling of oopmaps for now
1092   debug_info()-&gt;set_oopmaps(_oop_map_set);
1093 
1094   uint nblocks  = _cfg-&gt;number_of_blocks();
1095   // Count and start of implicit null check instructions
1096   uint inct_cnt = 0;
1097   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1098 
1099   // Count and start of calls
1100   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1101 
1102   uint  return_offset = 0;
1103   int nop_size = (new MachNopNode())-&gt;size(_regalloc);
1104 
1105   int previous_offset = 0;
1106   int current_offset  = 0;
1107   int last_call_offset = -1;
1108   int last_avoid_back_to_back_offset = -1;
1109 #ifdef ASSERT
1110   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1111   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1112   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1113   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1114 #endif
1115 
1116   // Create an array of unused labels, one for each basic block, if printing is enabled
<a name="48" id="anc48"></a><span class="line-modified">1117 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
1118   int *node_offsets      = NULL;
1119   uint node_offset_limit = unique();
1120 
<a name="49" id="anc49"></a><span class="line-modified">1121   if (print_assembly()) {</span>
<span class="line-modified">1122     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);</span>
<span class="line-added">1123   }</span>
<span class="line-added">1124   if (node_offsets != NULL) {</span>
<span class="line-added">1125     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.</span>
<span class="line-added">1126     memset(node_offsets, 0, node_offset_limit*sizeof(int));</span>
<span class="line-added">1127   }</span>
1128 #endif
1129 
1130   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily
1131 
1132   // Emit the constant table.
1133   if (has_mach_constant_base_node()) {
1134     constant_table().emit(*cb);
1135   }
1136 
1137   // Create an array of labels, one for each basic block
1138   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1139   for (uint i=0; i &lt;= nblocks; i++) {
1140     blk_labels[i].init();
1141   }
1142 
1143   // ------------------
1144   // Now fill in the code buffer
1145   Node *delay_slot = NULL;
1146 
1147   for (uint i = 0; i &lt; nblocks; i++) {
1148     Block* block = _cfg-&gt;get_block(i);
1149     Node* head = block-&gt;head();
1150 
1151     // If this block needs to start aligned (i.e, can be reached other
1152     // than by falling-thru from the previous block), then force the
1153     // start of a new bundle.
1154     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1155       cb-&gt;flush_bundle(true);
1156     }
1157 
1158 #ifdef ASSERT
1159     if (!block-&gt;is_connector()) {
1160       stringStream st;
1161       block-&gt;dump_head(_cfg, &amp;st);
1162       MacroAssembler(cb).block_comment(st.as_string());
1163     }
1164     jmp_target[i] = 0;
1165     jmp_offset[i] = 0;
1166     jmp_size[i]   = 0;
1167     jmp_rule[i]   = 0;
1168 #endif
1169     int blk_offset = current_offset;
1170 
1171     // Define the label at the beginning of the basic block
1172     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1173 
1174     uint last_inst = block-&gt;number_of_nodes();
1175 
1176     // Emit block normally, except for last instruction.
1177     // Emit means &quot;dump code bits into code buffer&quot;.
1178     for (uint j = 0; j&lt;last_inst; j++) {
1179 
1180       // Get the node
1181       Node* n = block-&gt;get_node(j);
1182 
1183       // See if delay slots are supported
1184       if (valid_bundle_info(n) &amp;&amp;
1185           node_bundling(n)-&gt;used_in_unconditional_delay()) {
1186         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
1187         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);
1188 
1189         delay_slot = n;
1190         continue;
1191       }
1192 
1193       // If this starts a new instruction group, then flush the current one
1194       // (but allow split bundles)
1195       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1196         cb-&gt;flush_bundle(false);
1197 
1198       // Special handling for SafePoint/Call Nodes
1199       bool is_mcall = false;
1200       if (n-&gt;is_Mach()) {
1201         MachNode *mach = n-&gt;as_Mach();
1202         is_mcall = n-&gt;is_MachCall();
1203         bool is_sfn = n-&gt;is_MachSafePoint();
1204 
1205         // If this requires all previous instructions be flushed, then do so
1206         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1207           cb-&gt;flush_bundle(true);
1208           current_offset = cb-&gt;insts_size();
1209         }
1210 
1211         // A padding may be needed again since a previous instruction
1212         // could be moved to delay slot.
1213 
1214         // align the instruction if necessary
1215         int padding = mach-&gt;compute_padding(current_offset);
1216         // Make sure safepoint node for polling is distinct from a call&#39;s
1217         // return by adding a nop if needed.
1218         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1219           padding = nop_size;
1220         }
1221         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1222             current_offset == last_avoid_back_to_back_offset) {
1223           // Avoid back to back some instructions.
1224           padding = nop_size;
1225         }
1226 
1227         if (padding &gt; 0) {
1228           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1229           int nops_cnt = padding / nop_size;
1230           MachNode *nop = new MachNopNode(nops_cnt);
1231           block-&gt;insert_node(nop, j++);
1232           last_inst++;
1233           _cfg-&gt;map_node_to_block(nop, block);
1234           // Ensure enough space.
1235           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1236           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1237             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1238             return;
1239           }
1240           nop-&gt;emit(*cb, _regalloc);
1241           cb-&gt;flush_bundle(true);
1242           current_offset = cb-&gt;insts_size();
1243         }
1244 
1245         // Remember the start of the last call in a basic block
1246         if (is_mcall) {
1247           MachCallNode *mcall = mach-&gt;as_MachCall();
1248 
1249           // This destination address is NOT PC-relative
1250           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1251 
1252           // Save the return address
1253           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1254 
1255           if (mcall-&gt;is_MachCallLeaf()) {
1256             is_mcall = false;
1257             is_sfn = false;
1258           }
1259         }
1260 
1261         // sfn will be valid whenever mcall is valid now because of inheritance
1262         if (is_sfn || is_mcall) {
1263 
1264           // Handle special safepoint nodes for synchronization
1265           if (!is_mcall) {
1266             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1267             // !!!!! Stubs only need an oopmap right now, so bail out
1268             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1269               // Write the oopmap directly to the code blob??!!
1270               continue;
1271             }
1272           } // End synchronization
1273 
1274           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1275                                            current_offset);
1276           Process_OopMap_Node(mach, current_offset);
1277         } // End if safepoint
1278 
<a name="50" id="anc50"></a><span class="line-modified">1279           // If this is a null check, then add the start of the previous instruction to the list</span>
1280         else if( mach-&gt;is_MachNullCheck() ) {
1281           inct_starts[inct_cnt++] = previous_offset;
1282         }
1283 
<a name="51" id="anc51"></a><span class="line-modified">1284           // If this is a branch, then fill in the label with the target BB&#39;s label</span>
1285         else if (mach-&gt;is_MachBranch()) {
1286           // This requires the TRUE branch target be in succs[0]
1287           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1288 
1289           // Try to replace long branch if delay slot is not used,
1290           // it is mostly for back branches since forward branch&#39;s
1291           // distance is not updated yet.
1292           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
1293                                     node_bundling(n)-&gt;use_unconditional_delay();
1294           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
<a name="52" id="anc52"></a><span class="line-modified">1295             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);</span>
<span class="line-modified">1296             int br_size = n-&gt;size(_regalloc);</span>
1297             int offset = blk_starts[block_num] - current_offset;
1298             if (block_num &gt;= i) {
1299               // Current and following block&#39;s offset are not
1300               // finalized yet, adjust distance by the difference
1301               // between calculated and final offsets of current block.
1302               offset -= (blk_starts[i] - blk_offset);
1303             }
1304             // In the following code a nop could be inserted before
1305             // the branch which will increase the backward distance.
1306             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1307             if (needs_padding &amp;&amp; offset &lt;= 0)
1308               offset -= nop_size;
1309 
1310             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
1311               // We&#39;ve got a winner.  Replace this branch.
1312               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1313 
1314               // Update the jmp_size.
1315               int new_size = replacement-&gt;size(_regalloc);
1316               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1317               // Insert padding between avoid_back_to_back branches.
1318               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1319                 MachNode *nop = new MachNopNode();
1320                 block-&gt;insert_node(nop, j++);
1321                 _cfg-&gt;map_node_to_block(nop, block);
1322                 last_inst++;
1323                 nop-&gt;emit(*cb, _regalloc);
1324                 cb-&gt;flush_bundle(true);
1325                 current_offset = cb-&gt;insts_size();
1326               }
1327 #ifdef ASSERT
1328               jmp_target[i] = block_num;
1329               jmp_offset[i] = current_offset - blk_offset;
1330               jmp_size[i]   = new_size;
1331               jmp_rule[i]   = mach-&gt;rule();
1332 #endif
1333               block-&gt;map_node(replacement, j);
1334               mach-&gt;subsume_by(replacement, C);
1335               n    = replacement;
1336               mach = replacement;
1337             }
1338           }
1339           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1340         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1341           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1342             Block* succs_block = block-&gt;_succs[h];
1343             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1344               Node* jpn = succs_block-&gt;pred(j);
1345               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1346                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1347                 Label *blkLabel = &amp;blk_labels[block_num];
1348                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1349               }
1350             }
1351           }
1352         }
1353 #ifdef ASSERT
<a name="53" id="anc53"></a><span class="line-modified">1354           // Check that oop-store precedes the card-mark</span>
1355         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1356           uint storeCM_idx = j;
1357           int count = 0;
1358           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1359             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1360             if (oop_store == NULL) continue;
1361             count++;
1362             uint i4;
1363             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1364               if (block-&gt;get_node(i4) == oop_store) {
1365                 break;
1366               }
1367             }
1368             // Note: This test can provide a false failure if other precedence
1369             // edges have been added to the storeCMNode.
1370             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1371           }
1372           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1373         }
1374 #endif
1375         else if (!n-&gt;is_Proj()) {
1376           // Remember the beginning of the previous instruction, in case
1377           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1378           // Intel all the time, with add-to-memory kind of opcodes.
1379           previous_offset = current_offset;
1380         }
1381 
1382         // Not an else-if!
1383         // If this is a trap based cmp then add its offset to the list.
1384         if (mach-&gt;is_TrapBasedCheckNode()) {
1385           inct_starts[inct_cnt++] = current_offset;
1386         }
1387       }
1388 
1389       // Verify that there is sufficient space remaining
1390       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1391       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1392         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1393         return;
1394       }
1395 
1396       // Save the offset for the listing
<a name="54" id="anc54"></a><span class="line-modified">1397 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-modified">1398       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {</span>
1399         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
<a name="55" id="anc55"></a><span class="line-added">1400       }</span>
1401 #endif
1402 
1403       // &quot;Normal&quot; instruction case
1404       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1405       n-&gt;emit(*cb, _regalloc);
1406       current_offset  = cb-&gt;insts_size();
1407 
1408       // Above we only verified that there is enough space in the instruction section.
1409       // However, the instruction may emit stubs that cause code buffer expansion.
1410       // Bail out here if expansion failed due to a lack of code cache space.
1411       if (failing()) {
1412         return;
1413       }
1414 
1415 #ifdef ASSERT
1416       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {
1417         n-&gt;dump();
1418         assert(false, &quot;wrong size of mach node&quot;);
1419       }
1420 #endif
1421       non_safepoints.observe_instruction(n, current_offset);
1422 
1423       // mcall is last &quot;call&quot; that can be a safepoint
1424       // record it so we can see if a poll will directly follow it
1425       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1426       // see  5010568. This can be slightly inaccurate but conservative
1427       // in the case that return address is not actually at current_offset.
1428       // This is a small price to pay.
1429 
1430       if (is_mcall) {
1431         last_call_offset = current_offset;
1432       }
1433 
1434       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1435         // Avoid back to back some instructions.
1436         last_avoid_back_to_back_offset = current_offset;
1437       }
1438 
1439       // See if this instruction has a delay slot
1440       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1441         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1442 
1443         // Back up 1 instruction
1444         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1445 
1446         // Save the offset for the listing
<a name="56" id="anc56"></a><span class="line-modified">1447 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-modified">1448         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {</span>
1449           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
<a name="57" id="anc57"></a><span class="line-added">1450         }</span>
1451 #endif
1452 
1453         // Support a SafePoint in the delay slot
1454         if (delay_slot-&gt;is_MachSafePoint()) {
1455           MachNode *mach = delay_slot-&gt;as_Mach();
1456           // !!!!! Stubs only need an oopmap right now, so bail out
1457           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1458             // Write the oopmap directly to the code blob??!!
1459             delay_slot = NULL;
1460             continue;
1461           }
1462 
1463           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1464           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1465                                            adjusted_offset);
1466           // Generate an OopMap entry
1467           Process_OopMap_Node(mach, adjusted_offset);
1468         }
1469 
1470         // Insert the delay slot instruction
1471         delay_slot-&gt;emit(*cb, _regalloc);
1472 
1473         // Don&#39;t reuse it
1474         delay_slot = NULL;
1475       }
1476 
1477     } // End for all instructions in block
1478 
1479     // If the next block is the top of a loop, pad this block out to align
1480     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1481     if (i &lt; nblocks-1) {
1482       Block *nb = _cfg-&gt;get_block(i + 1);
1483       int padding = nb-&gt;alignment_padding(current_offset);
1484       if( padding &gt; 0 ) {
1485         MachNode *nop = new MachNopNode(padding / nop_size);
1486         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
1487         _cfg-&gt;map_node_to_block(nop, block);
1488         nop-&gt;emit(*cb, _regalloc);
1489         current_offset = cb-&gt;insts_size();
1490       }
1491     }
1492     // Verify that the distance for generated before forward
1493     // short branches is still valid.
1494     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1495 
1496     // Save new block start offset
1497     blk_starts[i] = blk_offset;
1498   } // End of for all blocks
1499   blk_starts[nblocks] = current_offset;
1500 
1501   non_safepoints.flush_at_end();
1502 
1503   // Offset too large?
1504   if (failing())  return;
1505 
1506   // Define a pseudo-label at the end of the code
1507   MacroAssembler(cb).bind( blk_labels[nblocks] );
1508 
1509   // Compute the size of the first block
1510   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1511 
1512 #ifdef ASSERT
1513   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1514     if (jmp_target[i] != 0) {
1515       int br_size = jmp_size[i];
1516       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
1517       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
1518         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1519         assert(false, &quot;Displacement too large for short jmp&quot;);
1520       }
1521     }
1522   }
1523 #endif
1524 
<a name="58" id="anc58"></a><span class="line-added">1525   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">1526   bs-&gt;emit_stubs(*cb);</span>
<span class="line-added">1527   if (failing())  return;</span>
<span class="line-added">1528 </span>
1529 #ifndef PRODUCT
1530   // Information on the size of the method, without the extraneous code
1531   Scheduling::increment_method_size(cb-&gt;insts_size());
1532 #endif
1533 
1534   // ------------------
1535   // Fill in exception table entries.
1536   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1537 
1538   // Only java methods have exception handlers and deopt handlers
1539   // class HandlerImpl is platform-specific and defined in the *.ad files.
1540   if (_method) {
1541     // Emit the exception handler code.
1542     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
1543     if (failing()) {
1544       return; // CodeBuffer::expand failed
1545     }
1546     // Emit the deopt handler code.
1547     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1548 
1549     // Emit the MethodHandle deopt handler code (if required).
1550     if (has_method_handle_invokes() &amp;&amp; !failing()) {
1551       // We can use the same code as for the normal deopt handler, we
1552       // just need a different entry point address.
1553       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1554     }
1555   }
1556 
1557   // One last check for failed CodeBuffer::expand:
1558   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1559     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1560     return;
1561   }
1562 
<a name="59" id="anc59"></a><span class="line-modified">1563 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-added">1564   if (print_assembly()) {</span>
<span class="line-added">1565     tty-&gt;cr();</span>
<span class="line-added">1566     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);</span>
<span class="line-added">1567   }</span>
<span class="line-added">1568 #endif</span>
<span class="line-added">1569 </span>
<span class="line-added">1570 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
1571   // Dump the assembly code, including basic-block numbers
1572   if (print_assembly()) {
1573     ttyLocker ttyl;  // keep the following output all in one block
1574     if (!VMThread::should_terminate()) {  // test this under the tty lock
1575       // This output goes directly to the tty, not the compiler log.
1576       // To enable tools to match it up with the compilation activity,
1577       // be sure to tag this tty output with the compile ID.
1578       if (xtty != NULL) {
1579         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),
1580                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
1581                    &quot;&quot;);
1582       }
1583       if (method() != NULL) {
<a name="60" id="anc60"></a><span class="line-added">1584         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
1585         method()-&gt;print_metadata();
1586       } else if (stub_name() != NULL) {
<a name="61" id="anc61"></a><span class="line-modified">1587         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
1588       }
<a name="62" id="anc62"></a><span class="line-added">1589       tty-&gt;cr();</span>
<span class="line-added">1590       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
1591       dump_asm(node_offsets, node_offset_limit);
<a name="63" id="anc63"></a><span class="line-added">1592       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);</span>
1593       if (xtty != NULL) {
1594         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1595         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1596         // thread safe
1597         ttyLocker ttyl2;
1598         xtty-&gt;tail(&quot;opto_assembly&quot;);
1599       }
1600     }
1601   }
1602 #endif
<a name="64" id="anc64"></a>
1603 }
1604 
1605 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
1606   _inc_table.set_size(cnt);
1607 
1608   uint inct_cnt = 0;
1609   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1610     Block* block = _cfg-&gt;get_block(i);
1611     Node *n = NULL;
1612     int j;
1613 
1614     // Find the branch; ignore trailing NOPs.
1615     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1616       n = block-&gt;get_node(j);
1617       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1618         break;
1619       }
1620     }
1621 
1622     // If we didn&#39;t find anything, continue
1623     if (j &lt; 0) {
1624       continue;
1625     }
1626 
1627     // Compute ExceptionHandlerTable subtable entry and add it
1628     // (skip empty blocks)
1629     if (n-&gt;is_Catch()) {
1630 
1631       // Get the offset of the return from the call
1632       uint call_return = call_returns[block-&gt;_pre_order];
1633 #ifdef ASSERT
1634       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1635       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1636       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1637 #endif
1638       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1639       int nof_succs = block-&gt;_num_succs;
1640       // allocate space
1641       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1642       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1643       // iterate through all successors
1644       for (int j = 0; j &lt; nof_succs; j++) {
1645         Block* s = block-&gt;_succs[j];
1646         bool found_p = false;
1647         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1648           Node* pk = s-&gt;pred(k);
1649           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1650             const CatchProjNode* p = pk-&gt;as_CatchProj();
1651             found_p = true;
1652             // add the corresponding handler bci &amp; pco information
1653             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1654               // p leads to an exception handler (and is not fall through)
1655               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);
1656               // no duplicates, please
1657               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1658                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1659                 handler_bcis.append(p-&gt;handler_bci());
1660                 handler_pcos.append(blk_labels[block_num].loc_pos());
1661               }
1662             }
1663           }
1664         }
1665         assert(found_p, &quot;no matching predecessor found&quot;);
1666         // Note:  Due to empty block removal, one block may have
1667         // several CatchProj inputs, from the same Catch.
1668       }
1669 
1670       // Set the offset of the return from the call
1671       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1672       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1673       continue;
1674     }
1675 
1676     // Handle implicit null exception table updates
1677     if (n-&gt;is_MachNullCheck()) {
1678       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1679       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1680       continue;
1681     }
1682     // Handle implicit exception table updates: trap instructions.
1683     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1684       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1685       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1686       continue;
1687     }
1688   } // End of for all blocks fill in exception table entries
1689 }
1690 
1691 // Static Variables
1692 #ifndef PRODUCT
1693 uint Scheduling::_total_nop_size = 0;
1694 uint Scheduling::_total_method_size = 0;
1695 uint Scheduling::_total_branches = 0;
1696 uint Scheduling::_total_unconditional_delays = 0;
1697 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1698 #endif
1699 
1700 // Initializer for class Scheduling
1701 
1702 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
<a name="65" id="anc65"></a><span class="line-modified">1703         : _arena(arena),</span>
<span class="line-modified">1704           _cfg(compile.cfg()),</span>
<span class="line-modified">1705           _regalloc(compile.regalloc()),</span>
<span class="line-modified">1706           _scheduled(arena),</span>
<span class="line-modified">1707           _available(arena),</span>
<span class="line-modified">1708           _reg_node(arena),</span>
<span class="line-modified">1709           _pinch_free_list(arena),</span>
<span class="line-modified">1710           _next_node(NULL),</span>
<span class="line-modified">1711           _bundle_instr_count(0),</span>
<span class="line-modified">1712           _bundle_cycle_number(0),</span>
<span class="line-modified">1713           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])</span>
1714 #ifndef PRODUCT
<a name="66" id="anc66"></a><span class="line-modified">1715         , _branches(0)</span>
<span class="line-modified">1716         , _unconditional_delays(0)</span>
1717 #endif
1718 {
1719   // Create a MachNopNode
1720   _nop = new MachNopNode();
1721 
1722   // Now that the nops are in the array, save the count
1723   // (but allow entries for the nops)
1724   _node_bundling_limit = compile.unique();
1725   uint node_max = _regalloc-&gt;node_regs_max_index();
1726 
1727   compile.set_node_bundling_limit(_node_bundling_limit);
1728 
1729   // This one is persistent within the Compile class
1730   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1731 
1732   // Allocate space for fixed-size arrays
1733   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1734   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1735   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1736 
1737   // Clear the arrays
1738   for (uint i = 0; i &lt; node_max; i++) {
1739     ::new (&amp;_node_bundling_base[i]) Bundle();
1740   }
1741   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1742   memset(_uses,               0, node_max * sizeof(short));
1743   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1744 
1745   // Clear the bundling information
1746   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1747 
1748   // Get the last node
1749   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
1750 
1751   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
1752 }
1753 
1754 #ifndef PRODUCT
1755 // Scheduling destructor
1756 Scheduling::~Scheduling() {
1757   _total_branches             += _branches;
1758   _total_unconditional_delays += _unconditional_delays;
1759 }
1760 #endif
1761 
1762 // Step ahead &quot;i&quot; cycles
1763 void Scheduling::step(uint i) {
1764 
1765   Bundle *bundle = node_bundling(_next_node);
1766   bundle-&gt;set_starts_bundle();
1767 
1768   // Update the bundle record, but leave the flags information alone
1769   if (_bundle_instr_count &gt; 0) {
1770     bundle-&gt;set_instr_count(_bundle_instr_count);
1771     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1772   }
1773 
1774   // Update the state information
1775   _bundle_instr_count = 0;
1776   _bundle_cycle_number += i;
1777   _bundle_use.step(i);
1778 }
1779 
1780 void Scheduling::step_and_clear() {
1781   Bundle *bundle = node_bundling(_next_node);
1782   bundle-&gt;set_starts_bundle();
1783 
1784   // Update the bundle record
1785   if (_bundle_instr_count &gt; 0) {
1786     bundle-&gt;set_instr_count(_bundle_instr_count);
1787     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1788 
1789     _bundle_cycle_number += 1;
1790   }
1791 
1792   // Clear the bundling information
1793   _bundle_instr_count = 0;
1794   _bundle_use.reset();
1795 
1796   memcpy(_bundle_use_elements,
<a name="67" id="anc67"></a><span class="line-modified">1797          Pipeline_Use::elaborated_elements,</span>
<span class="line-modified">1798          sizeof(Pipeline_Use::elaborated_elements));</span>
1799 }
1800 
1801 // Perform instruction scheduling and bundling over the sequence of
1802 // instructions in backwards order.
1803 void Compile::ScheduleAndBundle() {
1804 
1805   // Don&#39;t optimize this if it isn&#39;t a method
1806   if (!_method)
1807     return;
1808 
1809   // Don&#39;t optimize this if scheduling is disabled
1810   if (!do_scheduling())
1811     return;
1812 
1813   // Scheduling code works only with pairs (16 bytes) maximum.
1814   if (max_vector_size() &gt; 16)
1815     return;
1816 
1817   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);
1818 
1819   // Create a data structure for all the scheduling information
1820   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);
1821 
1822   // Walk backwards over each basic block, computing the needed alignment
1823   // Walk over all the basic blocks
1824   scheduling.DoScheduling();
<a name="68" id="anc68"></a><span class="line-added">1825 </span>
<span class="line-added">1826 #ifndef PRODUCT</span>
<span class="line-added">1827   if (trace_opto_output()) {</span>
<span class="line-added">1828     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);</span>
<span class="line-added">1829     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-added">1830       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);</span>
<span class="line-added">1831       Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-added">1832       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-added">1833         Node* n = block-&gt;get_node(j);</span>
<span class="line-added">1834         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
<span class="line-added">1835         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);</span>
<span class="line-added">1836         n-&gt;dump();</span>
<span class="line-added">1837       }</span>
<span class="line-added">1838     }</span>
<span class="line-added">1839   }</span>
<span class="line-added">1840 #endif</span>
1841 }
1842 
1843 // Compute the latency of all the instructions.  This is fairly simple,
1844 // because we already have a legal ordering.  Walk over the instructions
1845 // from first to last, and compute the latency of the instruction based
1846 // on the latency of the preceding instruction(s).
1847 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1848 #ifndef PRODUCT
1849   if (_cfg-&gt;C-&gt;trace_opto_output())
1850     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1851 #endif
1852 
1853   // Walk over all the schedulable instructions
1854   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
1855 
1856     // This is a kludge, forcing all latency calculations to start at 1.
1857     // Used to allow latency 0 to force an instruction to the beginning
1858     // of the bb
1859     uint latency = 1;
1860     Node *use = bb-&gt;get_node(j);
1861     uint nlen = use-&gt;len();
1862 
1863     // Walk over all the inputs
1864     for ( uint k=0; k &lt; nlen; k++ ) {
1865       Node *def = use-&gt;in(k);
1866       if (!def)
1867         continue;
1868 
1869       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
1870       if (latency &lt; l)
1871         latency = l;
1872     }
1873 
1874     _node_latency[use-&gt;_idx] = latency;
1875 
1876 #ifndef PRODUCT
1877     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1878       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
1879       use-&gt;dump();
1880     }
1881 #endif
1882   }
1883 
1884 #ifndef PRODUCT
1885   if (_cfg-&gt;C-&gt;trace_opto_output())
1886     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
1887 #endif
1888 
1889 } // end ComputeLocalLatenciesForward
1890 
1891 // See if this node fits into the present instruction bundle
1892 bool Scheduling::NodeFitsInBundle(Node *n) {
1893   uint n_idx = n-&gt;_idx;
1894 
1895   // If this is the unconditional delay instruction, then it fits
1896   if (n == _unconditional_delay_slot) {
1897 #ifndef PRODUCT
1898     if (_cfg-&gt;C-&gt;trace_opto_output())
1899       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
1900 #endif
1901     return (true);
1902   }
1903 
1904   // If the node cannot be scheduled this cycle, skip it
1905   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
1906 #ifndef PRODUCT
1907     if (_cfg-&gt;C-&gt;trace_opto_output())
1908       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
<a name="69" id="anc69"></a><span class="line-modified">1909                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);</span>
1910 #endif
1911     return (false);
1912   }
1913 
1914   const Pipeline *node_pipeline = n-&gt;pipeline();
1915 
1916   uint instruction_count = node_pipeline-&gt;instructionCount();
1917   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
1918     instruction_count = 0;
1919   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
1920     instruction_count++;
1921 
1922   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
1923 #ifndef PRODUCT
1924     if (_cfg-&gt;C-&gt;trace_opto_output())
1925       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
<a name="70" id="anc70"></a><span class="line-modified">1926                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);</span>
1927 #endif
1928     return (false);
1929   }
1930 
1931   // Don&#39;t allow non-machine nodes to be handled this way
1932   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
1933     return (false);
1934 
1935   // See if there is any overlap
1936   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
1937 
1938   if (delay &gt; 0) {
1939 #ifndef PRODUCT
1940     if (_cfg-&gt;C-&gt;trace_opto_output())
1941       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
1942 #endif
1943     return false;
1944   }
1945 
1946 #ifndef PRODUCT
1947   if (_cfg-&gt;C-&gt;trace_opto_output())
1948     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
1949 #endif
1950 
1951   return true;
1952 }
1953 
1954 Node * Scheduling::ChooseNodeToBundle() {
1955   uint siz = _available.size();
1956 
1957   if (siz == 0) {
1958 
1959 #ifndef PRODUCT
1960     if (_cfg-&gt;C-&gt;trace_opto_output())
1961       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
1962 #endif
1963     return (NULL);
1964   }
1965 
1966   // Fast path, if only 1 instruction in the bundle
1967   if (siz == 1) {
1968 #ifndef PRODUCT
1969     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1970       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
1971       _available[0]-&gt;dump();
1972     }
1973 #endif
1974     return (_available[0]);
1975   }
1976 
1977   // Don&#39;t bother, if the bundle is already full
1978   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
1979     for ( uint i = 0; i &lt; siz; i++ ) {
1980       Node *n = _available[i];
1981 
1982       // Skip projections, we&#39;ll handle them another way
1983       if (n-&gt;is_Proj())
1984         continue;
1985 
1986       // This presupposed that instructions are inserted into the
1987       // available list in a legality order; i.e. instructions that
1988       // must be inserted first are at the head of the list
1989       if (NodeFitsInBundle(n)) {
1990 #ifndef PRODUCT
1991         if (_cfg-&gt;C-&gt;trace_opto_output()) {
1992           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
1993           n-&gt;dump();
1994         }
1995 #endif
1996         return (n);
1997       }
1998     }
1999   }
2000 
2001   // Nothing fits in this bundle, choose the highest priority
2002 #ifndef PRODUCT
2003   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2004     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2005     _available[0]-&gt;dump();
2006   }
2007 #endif
2008 
2009   return _available[0];
2010 }
2011 
2012 void Scheduling::AddNodeToAvailableList(Node *n) {
2013   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2014 #ifndef PRODUCT
2015   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2016     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2017     n-&gt;dump();
2018   }
2019 #endif
2020 
2021   int latency = _current_latency[n-&gt;_idx];
2022 
2023   // Insert in latency order (insertion sort)
2024   uint i;
2025   for ( i=0; i &lt; _available.size(); i++ )
2026     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2027       break;
2028 
2029   // Special Check for compares following branches
2030   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2031     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2032     Node *last = _scheduled[0];
2033     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2034         ( op == Op_CmpI ||
2035           op == Op_CmpU ||
2036           op == Op_CmpUL ||
2037           op == Op_CmpP ||
2038           op == Op_CmpF ||
2039           op == Op_CmpD ||
2040           op == Op_CmpL ) ) {
2041 
2042       // Recalculate position, moving to front of same latency
2043       for ( i=0 ; i &lt; _available.size(); i++ )
2044         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2045           break;
2046     }
2047   }
2048 
2049   // Insert the node in the available list
2050   _available.insert(i, n);
2051 
2052 #ifndef PRODUCT
2053   if (_cfg-&gt;C-&gt;trace_opto_output())
2054     dump_available();
2055 #endif
2056 }
2057 
2058 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2059   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2060     Node *def = n-&gt;in(i);
2061     if (!def) continue;
2062     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2063       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2064 
2065     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2066       continue;
2067     }
2068 
2069     // Compute the latency
2070     uint l = _bundle_cycle_number + n-&gt;latency(i);
2071     if (_current_latency[def-&gt;_idx] &lt; l)
2072       _current_latency[def-&gt;_idx] = l;
2073 
2074     // If this does not have uses then schedule it
2075     if ((--_uses[def-&gt;_idx]) == 0)
2076       AddNodeToAvailableList(def);
2077   }
2078 }
2079 
2080 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2081 #ifndef PRODUCT
2082   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2083     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2084     n-&gt;dump();
2085   }
2086 #endif
2087 
2088   // Remove this from the available list
2089   uint i;
2090   for (i = 0; i &lt; _available.size(); i++)
2091     if (_available[i] == n)
2092       break;
2093   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2094   _available.remove(i);
2095 
2096   // See if this fits in the current bundle
2097   const Pipeline *node_pipeline = n-&gt;pipeline();
2098   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2099 
2100   // Check for instructions to be placed in the delay slot. We
2101   // do this before we actually schedule the current instruction,
2102   // because the delay slot follows the current instruction.
2103   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2104       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2105       !_unconditional_delay_slot) {
2106 
2107     uint siz = _available.size();
2108 
2109     // Conditional branches can support an instruction that
2110     // is unconditionally executed and not dependent by the
2111     // branch, OR a conditionally executed instruction if
2112     // the branch is taken.  In practice, this means that
2113     // the first instruction at the branch target is
2114     // copied to the delay slot, and the branch goes to
2115     // the instruction after that at the branch target
2116     if ( n-&gt;is_MachBranch() ) {
2117 
2118       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2119       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2120 
2121 #ifndef PRODUCT
2122       _branches++;
2123 #endif
2124 
2125       // At least 1 instruction is on the available list
2126       // that is not dependent on the branch
2127       for (uint i = 0; i &lt; siz; i++) {
2128         Node *d = _available[i];
2129         const Pipeline *avail_pipeline = d-&gt;pipeline();
2130 
2131         // Don&#39;t allow safepoints in the branch shadow, that will
2132         // cause a number of difficulties
2133         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
<a name="71" id="anc71"></a><span class="line-modified">2134              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;</span>
<span class="line-modified">2135              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;</span>
<span class="line-modified">2136              Pipeline::instr_has_unit_size() &amp;&amp;</span>
<span class="line-modified">2137              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;</span>
<span class="line-modified">2138              NodeFitsInBundle(d) &amp;&amp;</span>
<span class="line-modified">2139              !node_bundling(d)-&gt;used_in_delay()) {</span>
2140 
2141           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2142             // A node that fits in the delay slot was found, so we need to
2143             // set the appropriate bits in the bundle pipeline information so
2144             // that it correctly indicates resource usage.  Later, when we
2145             // attempt to add this instruction to the bundle, we will skip
2146             // setting the resource usage.
2147             _unconditional_delay_slot = d;
2148             node_bundling(n)-&gt;set_use_unconditional_delay();
2149             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2150             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2151             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2152             _next_node = d;
2153             ++_bundle_instr_count;
2154 #ifndef PRODUCT
2155             _unconditional_delays++;
2156 #endif
2157             break;
2158           }
2159         }
2160       }
2161     }
2162 
2163     // No delay slot, add a nop to the usage
2164     if (!_unconditional_delay_slot) {
2165       // See if adding an instruction in the delay slot will overflow
2166       // the bundle.
2167       if (!NodeFitsInBundle(_nop)) {
2168 #ifndef PRODUCT
2169         if (_cfg-&gt;C-&gt;trace_opto_output())
2170           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2171 #endif
2172         step(1);
2173       }
2174 
2175       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2176       _next_node = _nop;
2177       ++_bundle_instr_count;
2178     }
2179 
2180     // See if the instruction in the delay slot requires a
2181     // step of the bundles
2182     if (!NodeFitsInBundle(n)) {
2183 #ifndef PRODUCT
<a name="72" id="anc72"></a><span class="line-modified">2184       if (_cfg-&gt;C-&gt;trace_opto_output())</span>
<span class="line-modified">2185         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);</span>
2186 #endif
<a name="73" id="anc73"></a><span class="line-modified">2187       // Update the state information</span>
<span class="line-modified">2188       _bundle_instr_count = 0;</span>
<span class="line-modified">2189       _bundle_cycle_number += 1;</span>
<span class="line-modified">2190       _bundle_use.step(1);</span>
2191     }
2192   }
2193 
2194   // Get the number of instructions
2195   uint instruction_count = node_pipeline-&gt;instructionCount();
2196   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2197     instruction_count = 0;
2198 
2199   // Compute the latency information
2200   uint delay = 0;
2201 
2202   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2203     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2204     if (relative_latency &lt; 0)
2205       relative_latency = 0;
2206 
2207     delay = _bundle_use.full_latency(relative_latency, node_usage);
2208 
2209     // Does not fit in this bundle, start a new one
2210     if (delay &gt; 0) {
2211       step(delay);
2212 
2213 #ifndef PRODUCT
2214       if (_cfg-&gt;C-&gt;trace_opto_output())
2215         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2216 #endif
2217     }
2218   }
2219 
2220   // If this was placed in the delay slot, ignore it
2221   if (n != _unconditional_delay_slot) {
2222 
2223     if (delay == 0) {
2224       if (node_pipeline-&gt;hasMultipleBundles()) {
2225 #ifndef PRODUCT
2226         if (_cfg-&gt;C-&gt;trace_opto_output())
2227           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2228 #endif
2229         step(1);
2230       }
2231 
2232       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2233 #ifndef PRODUCT
2234         if (_cfg-&gt;C-&gt;trace_opto_output())
2235           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
<a name="74" id="anc74"></a><span class="line-modified">2236                      instruction_count + _bundle_instr_count,</span>
<span class="line-modified">2237                      Pipeline::_max_instrs_per_cycle);</span>
2238 #endif
2239         step(1);
2240       }
2241     }
2242 
2243     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2244       _bundle_instr_count++;
2245 
2246     // Set the node&#39;s latency
2247     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2248 
2249     // Now merge the functional unit information
2250     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2251       _bundle_use.add_usage(node_usage);
2252 
2253     // Increment the number of instructions in this bundle
2254     _bundle_instr_count += instruction_count;
2255 
2256     // Remember this node for later
2257     if (n-&gt;is_Mach())
2258       _next_node = n;
2259   }
2260 
2261   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2262   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2263   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2264   // into the block.  All other scheduled nodes get put in the schedule here.
2265   int op = n-&gt;Opcode();
2266   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2267       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2268        // not an unallocated boxlock
2269        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2270 
2271     // Push any trailing projections
2272     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2273       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2274         Node *foi = n-&gt;fast_out(i);
2275         if( foi-&gt;is_Proj() )
2276           _scheduled.push(foi);
2277       }
2278     }
2279 
2280     // Put the instruction in the schedule list
2281     _scheduled.push(n);
2282   }
2283 
2284 #ifndef PRODUCT
2285   if (_cfg-&gt;C-&gt;trace_opto_output())
2286     dump_available();
2287 #endif
2288 
2289   // Walk all the definitions, decrementing use counts, and
2290   // if a definition has a 0 use count, place it in the available list.
2291   DecrementUseCounts(n,bb);
2292 }
2293 
2294 // This method sets the use count within a basic block.  We will ignore all
2295 // uses outside the current basic block.  As we are doing a backwards walk,
2296 // any node we reach that has a use count of 0 may be scheduled.  This also
2297 // avoids the problem of cyclic references from phi nodes, as long as phi
2298 // nodes are at the front of the basic block.  This method also initializes
2299 // the available list to the set of instructions that have no uses within this
2300 // basic block.
2301 void Scheduling::ComputeUseCount(const Block *bb) {
2302 #ifndef PRODUCT
2303   if (_cfg-&gt;C-&gt;trace_opto_output())
2304     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2305 #endif
2306 
2307   // Clear the list of available and scheduled instructions, just in case
2308   _available.clear();
2309   _scheduled.clear();
2310 
2311   // No delay slot specified
2312   _unconditional_delay_slot = NULL;
2313 
2314 #ifdef ASSERT
2315   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2316     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2317 #endif
2318 
2319   // Force the _uses count to never go to zero for unscheduable pieces
2320   // of the block
2321   for( uint k = 0; k &lt; _bb_start; k++ )
2322     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2323   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2324     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2325 
2326   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2327   // branch projections at end or the block header instructions.
2328   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2329     Node *n = bb-&gt;get_node(j);
2330     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2331 
2332     // Account for all uses
2333     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2334       Node *inp = n-&gt;in(k);
2335       if (!inp) continue;
2336       assert(inp != n, &quot;no cycles allowed&quot; );
2337       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2338         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2339           inp = inp-&gt;in(0);
2340         }
2341         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2342       }
2343     }
2344 
2345     // If this instruction has a 0 use count, then it is available
2346     if (!_uses[n-&gt;_idx]) {
2347       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2348       AddNodeToAvailableList(n);
2349     }
2350 
2351 #ifndef PRODUCT
2352     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2353       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2354       n-&gt;dump();
2355     }
2356 #endif
2357   }
2358 
2359 #ifndef PRODUCT
2360   if (_cfg-&gt;C-&gt;trace_opto_output())
2361     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2362 #endif
2363 }
2364 
2365 // This routine performs scheduling on each basic block in reverse order,
2366 // using instruction latencies and taking into account function unit
2367 // availability.
2368 void Scheduling::DoScheduling() {
2369 #ifndef PRODUCT
2370   if (_cfg-&gt;C-&gt;trace_opto_output())
2371     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2372 #endif
2373 
2374   Block *succ_bb = NULL;
2375   Block *bb;
2376 
2377   // Walk over all the basic blocks in reverse order
2378   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2379     bb = _cfg-&gt;get_block(i);
2380 
2381 #ifndef PRODUCT
2382     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2383       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2384       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2385         bb-&gt;get_node(j)-&gt;dump();
2386       }
2387     }
2388 #endif
2389 
2390     // On the head node, skip processing
2391     if (bb == _cfg-&gt;get_root_block()) {
2392       continue;
2393     }
2394 
2395     // Skip empty, connector blocks
2396     if (bb-&gt;is_connector())
2397       continue;
2398 
2399     // If the following block is not the sole successor of
2400     // this one, then reset the pipeline information
2401     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2402 #ifndef PRODUCT
2403       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2404         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2405                    _next_node-&gt;_idx, _bundle_instr_count);
2406       }
2407 #endif
2408       step_and_clear();
2409     }
2410 
2411     // Leave untouched the starting instruction, any Phis, a CreateEx node
2412     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2413     _bb_end = bb-&gt;number_of_nodes()-1;
2414     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2415       Node *n = bb-&gt;get_node(_bb_start);
2416       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2417       // Also, MachIdealNodes do not get scheduled
2418       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2419       MachNode *mach = n-&gt;as_Mach();
2420       int iop = mach-&gt;ideal_Opcode();
2421       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2422       if( iop == Op_Con ) continue;      // Do not schedule Top
2423       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2424           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2425           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2426         continue;
2427       break;                    // Funny loop structure to be sure...
2428     }
2429     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2430     // might schedule.  _bb_end points just after last schedulable inst.  We
2431     // normally schedule conditional branches (despite them being forced last
2432     // in the block), because they have delay slots we can fill.  Calls all
2433     // have their delay slots filled in the template expansions, so we don&#39;t
2434     // bother scheduling them.
2435     Node *last = bb-&gt;get_node(_bb_end);
2436     // Ignore trailing NOPs.
2437     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2438            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2439       last = bb-&gt;get_node(--_bb_end);
2440     }
2441     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2442     if( last-&gt;is_Catch() ||
<a name="75" id="anc75"></a><span class="line-modified">2443         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {</span>
<span class="line-modified">2444       // There might be a prior call.  Skip it.</span>
<span class="line-modified">2445       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());</span>



2446     } else if( last-&gt;is_MachNullCheck() ) {
2447       // Backup so the last null-checked memory instruction is
2448       // outside the schedulable range. Skip over the nullcheck,
2449       // projection, and the memory nodes.
2450       Node *mem = last-&gt;in(1);
2451       do {
2452         _bb_end--;
2453       } while (mem != bb-&gt;get_node(_bb_end));
2454     } else {
2455       // Set _bb_end to point after last schedulable inst.
2456       _bb_end++;
2457     }
2458 
2459     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2460 
2461     // Compute the register antidependencies for the basic block
2462     ComputeRegisterAntidependencies(bb);
2463     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points
2464 
2465     // Compute intra-bb latencies for the nodes
2466     ComputeLocalLatenciesForward(bb);
2467 
2468     // Compute the usage within the block, and set the list of all nodes
2469     // in the block that have no uses within the block.
2470     ComputeUseCount(bb);
2471 
2472     // Schedule the remaining instructions in the block
2473     while ( _available.size() &gt; 0 ) {
2474       Node *n = ChooseNodeToBundle();
2475       guarantee(n != NULL, &quot;no nodes available&quot;);
2476       AddNodeToBundle(n,bb);
2477     }
2478 
2479     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2480 #ifdef ASSERT
2481     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2482       Node *n = bb-&gt;get_node(l);
2483       uint m;
2484       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2485         if( _scheduled[m] == n )
2486           break;
2487       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2488     }
2489 #endif
2490 
2491     // Now copy the instructions (in reverse order) back to the block
2492     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2493       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2494 
2495 #ifndef PRODUCT
2496     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2497       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2498       uint current = 0;
2499       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2500         Node *n = bb-&gt;get_node(j);
2501         if( valid_bundle_info(n) ) {
2502           Bundle *bundle = node_bundling(n);
2503           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2504             tty-&gt;print(&quot;*** Bundle: &quot;);
2505             bundle-&gt;dump();
2506           }
2507           n-&gt;dump();
2508         }
2509       }
2510     }
2511 #endif
2512 #ifdef ASSERT
<a name="76" id="anc76"></a><span class="line-modified">2513     verify_good_schedule(bb,&quot;after block local scheduling&quot;);</span>
2514 #endif
2515   }
2516 
2517 #ifndef PRODUCT
2518   if (_cfg-&gt;C-&gt;trace_opto_output())
2519     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2520 #endif
2521 
2522   // Record final node-bundling array location
2523   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);
2524 
2525 } // end DoScheduling
2526 
2527 // Verify that no live-range used in the block is killed in the block by a
2528 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2529 
2530 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2531 static bool edge_from_to( Node *from, Node *to ) {
2532   for( uint i=0; i&lt;from-&gt;len(); i++ )
2533     if( from-&gt;in(i) == to )
2534       return true;
2535   return false;
2536 }
2537 
2538 #ifdef ASSERT
2539 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2540   // Check for bad kills
2541   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2542     Node *prior_use = _reg_node[def];
2543     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2544       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2545       n-&gt;dump();
2546       tty-&gt;print_cr(&quot;...&quot;);
2547       prior_use-&gt;dump();
2548       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2549     }
2550     _reg_node.map(def,NULL); // Kill live USEs
2551   }
2552 }
2553 
2554 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2555 
2556   // Zap to something reasonable for the verify code
2557   _reg_node.clear();
2558 
2559   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2560   // kill a live value (other than the one it&#39;s supposed to).  Add each
2561   // USE to the live set.
2562   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2563     Node *n = b-&gt;get_node(i);
2564     int n_op = n-&gt;Opcode();
2565     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2566       // Fat-proj kills a slew of registers
2567       RegMask rm = n-&gt;out_RegMask();// Make local copy
2568       while( rm.is_NotEmpty() ) {
2569         OptoReg::Name kill = rm.find_first_elem();
2570         rm.Remove(kill);
2571         verify_do_def( n, kill, msg );
2572       }
2573     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2574       // Get DEF&#39;d registers the normal way
2575       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2576       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2577     }
2578 
2579     // Now make all USEs live
2580     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2581       Node *def = n-&gt;in(i);
2582       assert(def != 0, &quot;input edge required&quot;);
2583       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2584       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2585       if( OptoReg::is_valid(reg_lo) ) {
2586         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2587         _reg_node.map(reg_lo,n);
2588       }
2589       if( OptoReg::is_valid(reg_hi) ) {
2590         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2591         _reg_node.map(reg_hi,n);
2592       }
2593     }
2594 
2595   }
2596 
2597   // Zap to something reasonable for the Antidependence code
2598   _reg_node.clear();
2599 }
2600 #endif
2601 
2602 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2603 static void add_prec_edge_from_to( Node *from, Node *to ) {
2604   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2605     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2606     from = from-&gt;in(0);
2607   }
2608   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2609       !edge_from_to( from, to ) ) // Avoid duplicate edge
2610     from-&gt;add_prec(to);
2611 }
2612 
2613 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2614   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2615     return;
2616 
2617   Node *pinch = _reg_node[def_reg]; // Get pinch point
2618   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2619       is_def ) {    // Check for a true def (not a kill)
2620     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2621     return;
2622   }
2623 
2624   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2625   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2626 
2627   // After some number of kills there _may_ be a later def
2628   Node *later_def = NULL;
2629 
2630   // Finding a kill requires a real pinch-point.
2631   // Check for not already having a pinch-point.
2632   // Pinch points are Op_Node&#39;s.
2633   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2634     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2635     if ( _pinch_free_list.size() &gt; 0) {
2636       pinch = _pinch_free_list.pop();
2637     } else {
2638       pinch = new Node(1); // Pinch point to-be
2639     }
2640     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2641       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2642       return;
2643     }
2644     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2645     _reg_node.map(def_reg,pinch); // Record pinch-point
2646     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.
2647     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
2648       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call
2649       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2650       later_def = NULL;           // and no later def
2651     }
2652     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2653   } else {                        // Else have valid pinch point
2654     if( pinch-&gt;in(0) )            // If there is a later-def
2655       later_def = pinch-&gt;in(0);   // Get it
2656   }
2657 
2658   // Add output-dependence edge from later def to kill
2659   if( later_def )               // If there is some original def
2660     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2661 
2662   // See if current kill is also a use, and so is forced to be the pinch-point.
2663   if( pinch-&gt;Opcode() == Op_Node ) {
2664     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2665     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2666       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2667           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2668         // Yes, found a use/kill pinch-point
2669         pinch-&gt;set_req(0,NULL);  //
2670         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2671         pinch = kill;
2672         _reg_node.map(def_reg,pinch);
2673         return;
2674       }
2675     }
2676   }
2677 
2678   // Add edge from kill to pinch-point
2679   add_prec_edge_from_to(kill,pinch);
2680 }
2681 
2682 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2683   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2684     return;
2685   Node *pinch = _reg_node[use_reg]; // Get pinch point
2686   // Check for no later def_reg/kill in block
2687   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2688       // Use has to be block-local as well
2689       _cfg-&gt;get_block_for_node(use) == b) {
2690     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2691         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2692       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2693       // Insert the pinch-point in the block just after the last use
2694       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2695       _bb_end++;                // Increase size scheduled region in block
2696     }
2697 
2698     add_prec_edge_from_to(pinch,use);
2699   }
2700 }
2701 
2702 // We insert antidependences between the reads and following write of
2703 // allocated registers to prevent illegal code motion. Hopefully, the
2704 // number of added references should be fairly small, especially as we
2705 // are only adding references within the current basic block.
2706 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2707 
2708 #ifdef ASSERT
2709   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2710 #endif
2711 
2712   // A valid schedule, for each register independently, is an endless cycle
2713   // of: a def, then some uses (connected to the def by true dependencies),
2714   // then some kills (defs with no uses), finally the cycle repeats with a new
2715   // def.  The uses are allowed to float relative to each other, as are the
2716   // kills.  No use is allowed to slide past a kill (or def).  This requires
2717   // antidependencies between all uses of a single def and all kills that
2718   // follow, up to the next def.  More edges are redundant, because later defs
2719   // &amp; kills are already serialized with true or antidependencies.  To keep
2720   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2721   // one use or more than one kill/def.
2722 
2723   // We add dependencies in one bottom-up pass.
2724 
2725   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2726 
2727   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2728   // register.  If not, we record the DEF/KILL in _reg_node, the
2729   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2730   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2731   // We put edges from the prior and current DEF/KILLs to the pinch point.
2732   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2733   // we merely add an edge from the current DEF/KILL to the pinch point.
2734 
2735   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2736   // put an edge from the pinch point to the USE.
2737 
2738   // To be expedient, the _reg_node array is pre-allocated for the whole
2739   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2740   // or a valid def/kill/pinch-point, or a leftover node from some prior
2741   // block.  Leftover node from some prior block is treated like a NULL (no
2742   // prior def, so no anti-dependence needed).  Valid def is distinguished by
2743   // it being in the current block.
2744   bool fat_proj_seen = false;
2745   uint last_safept = _bb_end-1;
2746   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
2747   Node* last_safept_node = end_node;
2748   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
2749     Node *n = b-&gt;get_node(i);
2750     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
2751     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2752       // Fat-proj kills a slew of registers
2753       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
2754       // hence the is_def flag.
2755       fat_proj_seen = true;
2756       RegMask rm = n-&gt;out_RegMask();// Make local copy
2757       while( rm.is_NotEmpty() ) {
2758         OptoReg::Name kill = rm.find_first_elem();
2759         rm.Remove(kill);
2760         anti_do_def( b, n, kill, is_def );
2761       }
2762     } else {
2763       // Get DEF&#39;d registers the normal way
2764       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
2765       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
2766     }
2767 
2768     // Kill projections on a branch should appear to occur on the
2769     // branch, not afterwards, so grab the masks from the projections
2770     // and process them.
2771     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
2772       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2773         Node* use = n-&gt;fast_out(i);
2774         if (use-&gt;is_Proj()) {
2775           RegMask rm = use-&gt;out_RegMask();// Make local copy
2776           while( rm.is_NotEmpty() ) {
2777             OptoReg::Name kill = rm.find_first_elem();
2778             rm.Remove(kill);
2779             anti_do_def( b, n, kill, false );
2780           }
2781         }
2782       }
2783     }
2784 
2785     // Check each register used by this instruction for a following DEF/KILL
2786     // that must occur afterward and requires an anti-dependence edge.
2787     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
2788       Node *def = n-&gt;in(j);
2789       if( def ) {
2790         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
2791         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
2792         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
2793       }
2794     }
2795     // Do not allow defs of new derived values to float above GC
2796     // points unless the base is definitely available at the GC point.
2797 
2798     Node *m = b-&gt;get_node(i);
2799 
2800     // Add precedence edge from following safepoint to use of derived pointer
2801     if( last_safept_node != end_node &amp;&amp;
2802         m != last_safept_node) {
2803       for (uint k = 1; k &lt; m-&gt;req(); k++) {
2804         const Type *t = m-&gt;in(k)-&gt;bottom_type();
2805         if( t-&gt;isa_oop_ptr() &amp;&amp;
2806             t-&gt;is_ptr()-&gt;offset() != 0 ) {
2807           last_safept_node-&gt;add_prec( m );
2808           break;
2809         }
2810       }
2811     }
2812 
2813     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
2814       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
2815       if( b-&gt;get_node(last_safept) != last_safept_node ) {
2816         last_safept = b-&gt;find_node(last_safept_node);
2817       }
2818       for( uint j=last_safept; j &gt; i; j-- ) {
2819         Node *mach = b-&gt;get_node(j);
2820         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
2821           mach-&gt;add_prec( n );
2822       }
2823       last_safept = i;
2824       last_safept_node = m;
2825     }
2826   }
2827 
2828   if (fat_proj_seen) {
2829     // Garbage collect pinch nodes that were not consumed.
2830     // They are usually created by a fat kill MachProj for a call.
2831     garbage_collect_pinch_nodes();
2832   }
2833 }
2834 
2835 // Garbage collect pinch nodes for reuse by other blocks.
2836 //
2837 // The block scheduler&#39;s insertion of anti-dependence
2838 // edges creates many pinch nodes when the block contains
2839 // 2 or more Calls.  A pinch node is used to prevent a
2840 // combinatorial explosion of edges.  If a set of kills for a
2841 // register is anti-dependent on a set of uses (or defs), rather
2842 // than adding an edge in the graph between each pair of kill
2843 // and use (or def), a pinch is inserted between them:
2844 //
2845 //            use1   use2  use3
2846 //                \   |   /
2847 //                 \  |  /
2848 //                  pinch
2849 //                 /  |  \
2850 //                /   |   \
2851 //            kill1 kill2 kill3
2852 //
2853 // One pinch node is created per register killed when
2854 // the second call is encountered during a backwards pass
2855 // over the block.  Most of these pinch nodes are never
2856 // wired into the graph because the register is never
2857 // used or def&#39;ed in the block.
2858 //
2859 void Scheduling::garbage_collect_pinch_nodes() {
2860 #ifndef PRODUCT
<a name="77" id="anc77"></a><span class="line-modified">2861   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);</span>
<span class="line-modified">2862 #endif</span>
<span class="line-modified">2863   int trace_cnt = 0;</span>
<span class="line-modified">2864   for (uint k = 0; k &lt; _reg_node.Size(); k++) {</span>
<span class="line-modified">2865     Node* pinch = _reg_node[k];</span>
<span class="line-modified">2866     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;</span>
<span class="line-modified">2867         // no predecence input edges</span>
<span class="line-modified">2868         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {</span>
<span class="line-modified">2869       cleanup_pinch(pinch);</span>
<span class="line-modified">2870       _pinch_free_list.push(pinch);</span>
<span class="line-modified">2871       _reg_node.map(k, NULL);</span>
2872 #ifndef PRODUCT
<a name="78" id="anc78"></a><span class="line-modified">2873       if (_cfg-&gt;C-&gt;trace_opto_output()) {</span>
<span class="line-modified">2874         trace_cnt++;</span>
<span class="line-modified">2875         if (trace_cnt &gt; 40) {</span>
<span class="line-modified">2876           tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-modified">2877           trace_cnt = 0;</span>


2878         }
<a name="79" id="anc79"></a><span class="line-modified">2879         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);</span>
2880       }
<a name="80" id="anc80"></a><span class="line-added">2881 #endif</span>
2882     }
<a name="81" id="anc81"></a><span class="line-added">2883   }</span>
2884 #ifndef PRODUCT
<a name="82" id="anc82"></a><span class="line-modified">2885   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);</span>
2886 #endif
2887 }
2888 
2889 // Clean up a pinch node for reuse.
2890 void Scheduling::cleanup_pinch( Node *pinch ) {
2891   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
2892 
2893   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
2894     Node* use = pinch-&gt;last_out(i);
2895     uint uses_found = 0;
2896     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
2897       if (use-&gt;in(j) == pinch) {
2898         use-&gt;rm_prec(j);
2899         uses_found++;
2900       }
2901     }
2902     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
2903     i -= uses_found;    // we deleted 1 or more copies of this edge
2904   }
2905   // May have a later_def entry
2906   pinch-&gt;set_req(0, NULL);
2907 }
2908 
2909 #ifndef PRODUCT
2910 
2911 void Scheduling::dump_available() const {
2912   tty-&gt;print(&quot;#Availist  &quot;);
2913   for (uint i = 0; i &lt; _available.size(); i++)
2914     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
2915   tty-&gt;cr();
2916 }
2917 
2918 // Print Scheduling Statistics
2919 void Scheduling::print_statistics() {
2920   // Print the size added by nops for bundling
2921   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
<a name="83" id="anc83"></a><span class="line-modified">2922              _total_nop_size, _total_method_size);</span>
2923   if (_total_method_size &gt; 0)
2924     tty-&gt;print(&quot;, for %.2f%%&quot;,
<a name="84" id="anc84"></a><span class="line-modified">2925                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);</span>
2926   tty-&gt;print(&quot;\n&quot;);
2927 
2928   // Print the number of branch shadows filled
2929   if (Pipeline::_branch_has_delay_slot) {
2930     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
<a name="85" id="anc85"></a><span class="line-modified">2931                _total_branches, _total_unconditional_delays);</span>
2932     if (_total_branches &gt; 0)
2933       tty-&gt;print(&quot;, for %.2f%%&quot;,
<a name="86" id="anc86"></a><span class="line-modified">2934                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);</span>
2935     tty-&gt;print(&quot;\n&quot;);
2936   }
2937 
2938   uint total_instructions = 0, total_bundles = 0;
2939 
2940   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
2941     uint bundle_count   = _total_instructions_per_bundle[i];
2942     total_instructions += bundle_count * i;
2943     total_bundles      += bundle_count;
2944   }
2945 
2946   if (total_bundles &gt; 0)
2947     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
<a name="87" id="anc87"></a><span class="line-modified">2948                ((double)total_instructions) / ((double)total_bundles));</span>
2949 }
2950 #endif
<a name="88" id="anc88"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="88" type="hidden" />
</body>
</html>
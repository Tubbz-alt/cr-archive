<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="locknode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopPredicate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 299,77 ***</span>
  // Interface from PhaseIdealLoop
  Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
    return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);
  }
  
<span class="line-removed">- void PhaseIdealLoop::clone_loop_predicates_fix_mem(ProjNode* dom_proj , ProjNode* proj,</span>
<span class="line-removed">-                                                    PhaseIdealLoop* loop_phase,</span>
<span class="line-removed">-                                                    PhaseIterGVN* igvn) {</span>
<span class="line-removed">-   Compile* C = NULL;</span>
<span class="line-removed">-   if (loop_phase != NULL) {</span>
<span class="line-removed">-     igvn = &amp;loop_phase-&gt;igvn();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   C = igvn-&gt;C;</span>
<span class="line-removed">-   ProjNode* other_dom_proj = dom_proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-dom_proj-&gt;_con);</span>
<span class="line-removed">-   Node* dom_r = other_dom_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed">-   if (dom_r-&gt;is_Region()) {</span>
<span class="line-removed">-     assert(dom_r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;unc expected&quot;);</span>
<span class="line-removed">-     ProjNode* other_proj = proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-proj-&gt;_con);</span>
<span class="line-removed">-     Node* r = other_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed">-     assert(r-&gt;is_Region() &amp;&amp; r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;cloned predicate should have caused region to be added&quot;);</span>
<span class="line-removed">-     for (DUIterator_Fast imax, i = dom_r-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">-       Node* dom_use = dom_r-&gt;fast_out(i);</span>
<span class="line-removed">-       if (dom_use-&gt;is_Phi() &amp;&amp; dom_use-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">-         assert(dom_use-&gt;in(0) == dom_r, &quot;&quot;);</span>
<span class="line-removed">-         Node* phi = NULL;</span>
<span class="line-removed">-         for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">-           Node* use = r-&gt;fast_out(j);</span>
<span class="line-removed">-           if (use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">-               use-&gt;adr_type() == dom_use-&gt;adr_type()) {</span>
<span class="line-removed">-             assert(use-&gt;in(0) == r, &quot;&quot;);</span>
<span class="line-removed">-             assert(phi == NULL, &quot;only one phi&quot;);</span>
<span class="line-removed">-             phi = use;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (phi == NULL) {</span>
<span class="line-removed">-           const TypePtr* adr_type = dom_use-&gt;adr_type();</span>
<span class="line-removed">-           int alias = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed">-           Node* call = r-&gt;unique_ctrl_out();</span>
<span class="line-removed">-           Node* mem = call-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed">-           MergeMemNode* mm = NULL;</span>
<span class="line-removed">-           if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed">-             mm = mem-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-removed">-             if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed">-               mem = mem-&gt;as_MergeMem()-&gt;base_memory();</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-               mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             mm = MergeMemNode::make(mem);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           phi = PhiNode::make(r, mem, Type::MEMORY, adr_type);</span>
<span class="line-removed">-           if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed">-             mm-&gt;set_base_memory(phi);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             mm-&gt;set_memory_at(alias, phi);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (loop_phase != NULL) {</span>
<span class="line-removed">-             loop_phase-&gt;register_new_node(mm, r);</span>
<span class="line-removed">-             loop_phase-&gt;register_new_node(phi, r);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             igvn-&gt;register_new_node_with_optimizer(mm);</span>
<span class="line-removed">-             igvn-&gt;register_new_node_with_optimizer(phi);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           igvn-&gt;replace_input_of(call, TypeFunc::Memory, mm);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         igvn-&gt;replace_input_of(phi, r-&gt;find_edge(other_proj), dom_use-&gt;in(dom_r-&gt;find_edge(other_dom_proj)));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // Clone loop predicates to cloned loops (peeled, unswitched, split_if).
  Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,
                                              bool clone_limit_check,
                                              PhaseIdealLoop* loop_phase,
                                              PhaseIterGVN* igvn) {
<span class="line-new-header">--- 299,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,28 ***</span>
    if (UseLoopPredicate) {
      predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
    }
    if (predicate_proj != NULL) { // right pattern that can be used by loop predication
      // clone predicate
<span class="line-modified">!     ProjNode* proj = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified">!                                      Deoptimization::Reason_predicate,</span>
<span class="line-modified">!                                      loop_phase, igvn);</span>
<span class="line-modified">!     assert(proj != NULL, &quot;IfTrue or IfFalse after clone predicate&quot;);</span>
<span class="line-removed">-     new_entry = proj;</span>
      if (TraceLoopPredicate) {
        tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
        debug_only( new_entry-&gt;in(0)-&gt;dump(); );
      }
<span class="line-removed">-     if (profile_predicate_proj != NULL) {</span>
<span class="line-removed">-       // A node that produces memory may be out of loop and depend on</span>
<span class="line-removed">-       // a profiled predicates. In that case the memory state at the</span>
<span class="line-removed">-       // end of profiled predicates and at the end of predicates are</span>
<span class="line-removed">-       // not the same. The cloned predicates are dominated by the</span>
<span class="line-removed">-       // profiled predicates but may have the wrong memory</span>
<span class="line-removed">-       // state. Update it.</span>
<span class="line-removed">-       clone_loop_predicates_fix_mem(profile_predicate_proj, proj, loop_phase, igvn);</span>
<span class="line-removed">-     }</span>
    }
    if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
      // clone predicate
      new_entry = clone_predicate(profile_predicate_proj, new_entry,
                                  Deoptimization::Reason_profile_predicate,
<span class="line-new-header">--- 331,18 ---</span>
    if (UseLoopPredicate) {
      predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
    }
    if (predicate_proj != NULL) { // right pattern that can be used by loop predication
      // clone predicate
<span class="line-modified">!     new_entry = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified">!                                 Deoptimization::Reason_predicate,</span>
<span class="line-modified">!                                 loop_phase, igvn);</span>
<span class="line-modified">!     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);</span>
      if (TraceLoopPredicate) {
        tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
        debug_only( new_entry-&gt;in(0)-&gt;dump(); );
      }
    }
    if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
      // clone predicate
      new_entry = clone_predicate(profile_predicate_proj, new_entry,
                                  Deoptimization::Reason_profile_predicate,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,13 ***</span>
    // the possibility to push n onto the stack for further processing.
    void visit(Node* use, Node* n) {
      if (_lpt-&gt;is_invariant(n)) { // known invariant
        _invariant.set(n-&gt;_idx);
      } else if (!n-&gt;is_CFG()) {
<span class="line-removed">-       if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
        Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
        Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
        if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
          _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
        }
<span class="line-new-header">--- 457,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,11 ***</span>
    BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
    register_new_node(bol, ctrl);
  
    if (TraceLoopPredicate) {
      predString-&gt;print_cr(&quot;&lt;u range&quot;);
<span class="line-modified">!     tty-&gt;print(&quot;%s&quot;, predString-&gt;as_string());</span>
    }
    return bol;
  }
  
  // Should loop predication look not only in the path from tail to head
<span class="line-new-header">--- 799,12 ---</span>
    BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
    register_new_node(bol, ctrl);
  
    if (TraceLoopPredicate) {
      predString-&gt;print_cr(&quot;&lt;u range&quot;);
<span class="line-modified">!     tty-&gt;print(&quot;%s&quot;, predString-&gt;base());</span>
<span class="line-added">+     predString-&gt;~stringStream();</span>
    }
    return bol;
  }
  
  // Should loop predication look not only in the path from tail to head
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1459,11 ***</span>
          hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
        }
      } // end while
    }
  
<span class="line-removed">-   Node_List if_proj_list_freq(area);</span>
    if (follow_branches) {
      PathFrequency pf(loop-&gt;_head, this);
  
      // Some projections were skipped by regular predicates because of
      // an early loop exit. Try them with profile data.
<span class="line-new-header">--- 1380,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1477,10 ***</span>
<span class="line-new-header">--- 1397,11 ---</span>
      }
  
      // And look into all branches
      Node_Stack stack(0);
      VectorSet seen(Thread::current()-&gt;resource_area());
<span class="line-added">+     Node_List if_proj_list_freq(area);</span>
      while (regions.size() &gt; 0) {
        Node* c = regions.pop();
        loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
      }
  
</pre>
<center><a href="locknode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
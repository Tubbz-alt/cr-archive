<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/c2_globals.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_C2_GLOBALS_HPP
 26 #define SHARE_OPTO_C2_GLOBALS_HPP
 27 
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;runtime/globals.hpp&quot;</span>
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 #include CPU_HEADER(c2_globals)
 32 #include OS_HEADER(c2_globals)
 33 
 34 //
 35 // Defines all globals flags used by the server compiler.
 36 //
 37 
 38 #define C2_FLAGS(develop, \
 39                  develop_pd, \
 40                  product, \
 41                  product_pd, \
 42                  diagnostic, \
 43                  diagnostic_pd, \
 44                  experimental, \
 45                  notproduct, \
 46                  range, \
<a name="3" id="anc3"></a><span class="line-modified"> 47                  constraint, \</span>
<span class="line-removed"> 48                  writeable) \</span>
 49                                                                             \
 50   diagnostic(bool, StressLCM, false,                                        \
 51           &quot;Randomize instruction scheduling in LCM&quot;)                        \
 52                                                                             \
 53   diagnostic(bool, StressGCM, false,                                        \
 54           &quot;Randomize instruction scheduling in GCM&quot;)                        \
 55                                                                             \
 56   develop(bool, StressMethodHandleLinkerInlining, false,                    \
 57           &quot;Stress inlining through method handle linkers&quot;)                  \
 58                                                                             \
 59   develop(intx, OptoPrologueNops, 0,                                        \
 60           &quot;Insert this many extra nop instructions &quot;                        \
 61           &quot;in the prologue of every nmethod&quot;)                               \
 62           range(0, 128)                                                     \
 63                                                                             \
 64   product_pd(intx, InteriorEntryAlignment,                                  \
 65           &quot;Code alignment for interior entry points &quot;                       \
 66           &quot;in generated code (in bytes)&quot;)                                   \
 67           constraint(InteriorEntryAlignmentConstraintFunc, AfterErgo)       \
 68                                                                             \
 69   product(intx, MaxLoopPad, (OptoLoopAlignment-1),                          \
 70           &quot;Align a loop if padding size in bytes is less or equal to this &quot; \
 71           &quot;value&quot;)                                                          \
 72           range(0, max_jint)                                                \
 73                                                                             \
 74   product(intx, MaxVectorSize, 64,                                          \
 75           &quot;Max vector size in bytes, &quot;                                      \
 76           &quot;actual size could be less depending on elements type&quot;)           \
 77           range(0, max_jint)                                                \
 78                                                                             \
 79   product(bool, AlignVector, true,                                          \
 80           &quot;Perform vector store/load alignment in loop&quot;)                    \
 81                                                                             \
 82   product(intx, NumberOfLoopInstrToAlign, 4,                                \
 83           &quot;Number of first instructions in a loop to align&quot;)                \
 84           range(0, max_jint)                                                \
 85                                                                             \
 86   notproduct(intx, IndexSetWatch, 0,                                        \
 87           &quot;Trace all operations on this IndexSet (-1 means all, 0 none)&quot;)   \
 88           range(-1, 0)                                                      \
 89                                                                             \
 90   develop(intx, OptoNodeListSize, 4,                                        \
 91           &quot;Starting allocation size of Node_List data structures&quot;)          \
 92           range(0, max_jint)                                                \
 93                                                                             \
 94   develop(intx, OptoBlockListSize, 8,                                       \
 95           &quot;Starting allocation size of Block_List data structures&quot;)         \
 96           range(0, max_jint)                                                \
 97                                                                             \
 98   develop(intx, OptoPeepholeAt, -1,                                         \
 99           &quot;Apply peephole optimizations to this peephole rule&quot;)             \
100                                                                             \
101   notproduct(bool, PrintIdeal, false,                                       \
102           &quot;Print ideal graph before code generation&quot;)                       \
103                                                                             \
104   notproduct(bool, PrintOpto, false,                                        \
105           &quot;Print compiler2 attempts&quot;)                                       \
106                                                                             \
107   notproduct(bool, PrintOptoInlining, false,                                \
108           &quot;Print compiler2 inlining decisions&quot;)                             \
109                                                                             \
<a name="4" id="anc4"></a><span class="line-removed">110   notproduct(bool, VerifyOpto, false,                                       \</span>
<span class="line-removed">111           &quot;Apply more time consuming verification during compilation&quot;)      \</span>
<span class="line-removed">112                                                                             \</span>
113   notproduct(bool, VerifyIdealNodeCount, false,                             \
114           &quot;Verify that tracked dead ideal node count is accurate&quot;)          \
115                                                                             \
116   notproduct(bool, PrintIdealNodeCount, false,                              \
117           &quot;Print liveness counts of ideal nodes&quot;)                           \
118                                                                             \
119   notproduct(bool, VerifyOptoOopOffsets, false,                             \
120           &quot;Check types of base addresses in field references&quot;)              \
121                                                                             \
122   develop(bool, IdealizedNumerics, false,                                   \
123           &quot;Check performance difference allowing FP &quot;                       \
124           &quot;associativity and commutativity...&quot;)                             \
125                                                                             \
126   diagnostic_pd(bool, IdealizeClearArrayNode,                               \
127           &quot;Replace ClearArrayNode by subgraph of basic operations.&quot;)        \
128                                                                             \
129   develop(bool, OptoBreakpoint, false,                                      \
130           &quot;insert breakpoint at method entry&quot;)                              \
131                                                                             \
132   notproduct(bool, OptoBreakpointOSR, false,                                \
133           &quot;insert breakpoint at osr method entry&quot;)                          \
134                                                                             \
135   notproduct(intx, BreakAtNode, 0,                                          \
136           &quot;Break at construction of this Node (either _idx or _debug_idx)&quot;) \
137                                                                             \
138   notproduct(bool, OptoBreakpointC2R, false,                                \
139           &quot;insert breakpoint at runtime stub entry&quot;)                        \
140                                                                             \
141   notproduct(bool, OptoNoExecute, false,                                    \
142           &quot;Attempt to parse and compile but do not execute generated code&quot;) \
143                                                                             \
144   notproduct(bool, PrintOptoStatistics, false,                              \
145           &quot;Print New compiler statistics&quot;)                                  \
146                                                                             \
147   diagnostic(bool, PrintOptoAssembly, false,                                \
148           &quot;Print New compiler assembly output&quot;)                             \
149                                                                             \
150   develop_pd(bool, OptoPeephole,                                            \
151           &quot;Apply peephole optimizations after register allocation&quot;)         \
152                                                                             \
153   develop(bool, OptoRemoveUseless, true,                                    \
154           &quot;Remove useless nodes after parsing&quot;)                             \
155                                                                             \
156   notproduct(bool, PrintFrameConverterAssembly, false,                      \
157           &quot;Print New compiler assembly output for frame converters&quot;)        \
158                                                                             \
159   notproduct(bool, PrintParseStatistics, false,                             \
160           &quot;Print nodes, transforms and new values made per bytecode parsed&quot;)\
161                                                                             \
162   notproduct(bool, PrintOptoPeephole, false,                                \
163           &quot;Print New compiler peephole replacements&quot;)                       \
164                                                                             \
165   develop(bool, PrintCFGBlockFreq, false,                                   \
166           &quot;Print CFG block freqencies&quot;)                                     \
167                                                                             \
168   develop(bool, TraceOptoParse, false,                                      \
169           &quot;Trace bytecode parse and control-flow merge&quot;)                    \
170                                                                             \
171   product_pd(intx,  LoopUnrollLimit,                                        \
172           &quot;Unroll loop bodies with node count less than this&quot;)              \
173           range(0, max_jint / 4)                                            \
174                                                                             \
175   product_pd(intx, LoopPercentProfileLimit,                                 \
176              &quot;Unroll loop bodies with % node count of profile limit&quot;)       \
177              range(10, 100)                                                 \
178                                                                             \
179   product(intx,  LoopMaxUnroll, 16,                                         \
180           &quot;Maximum number of unrolls for main loop&quot;)                        \
181           range(0, max_jint)                                                \
182                                                                             \
183   product_pd(bool,  SuperWordLoopUnrollAnalysis,                            \
184            &quot;Map number of unrolls for main loop via &quot;                       \
185            &quot;Superword Level Parallelism analysis&quot;)                          \
186                                                                             \
187   experimental(bool, PostLoopMultiversioning, false,                        \
188            &quot;Multi versioned post loops to eliminate range checks&quot;)          \
189                                                                             \
190   notproduct(bool, TraceSuperWordLoopUnrollAnalysis, false,                 \
191           &quot;Trace what Superword Level Parallelism analysis applies&quot;)        \
192                                                                             \
193   product(intx,  LoopUnrollMin, 4,                                          \
194           &quot;Minimum number of unroll loop bodies before checking progress&quot;   \
195           &quot;of rounds of unroll,optimize,..&quot;)                                \
196           range(0, max_jint)                                                \
197                                                                             \
198   product(bool, UseSubwordForMaxVector, true,                               \
199           &quot;Use Subword Analysis to set maximum vector size&quot;)                \
200                                                                             \
201   product(bool, UseVectorCmov, false,                                       \
202           &quot;Use Vectorized Cmov&quot;)                                            \
203                                                                             \
204   develop(intx, UnrollLimitForProfileCheck, 1,                              \
205           &quot;Don&#39;t use profile_trip_cnt() to restrict unrolling until &quot;       \
206           &quot;unrolling would push the number of unrolled iterations above &quot;   \
207           &quot;UnrollLimitForProfileCheck. A higher value allows more &quot;         \
208           &quot;unrolling. Zero acts as a very large value.&quot; )                   \
209           range(0, max_intx)                                                \
210                                                                             \
211   product(intx, MultiArrayExpandLimit, 6,                                   \
212           &quot;Maximum number of individual allocations in an inline-expanded &quot; \
213           &quot;multianewarray instruction&quot;)                                     \
214           range(0, max_jint)                                                \
215                                                                             \
216   notproduct(bool, TraceProfileTripCount, false,                            \
217           &quot;Trace profile loop trip count information&quot;)                      \
218                                                                             \
219   product(bool, UseCountedLoopSafepoints, false,                            \
220           &quot;Force counted loops to keep a safepoint&quot;)                        \
221                                                                             \
222   product(bool, UseLoopPredicate, true,                                     \
223           &quot;Generate a predicate to select fast/slow loop versions&quot;)         \
224                                                                             \
225   develop(bool, TraceLoopPredicate, false,                                  \
226           &quot;Trace generation of loop predicates&quot;)                            \
227                                                                             \
228   develop(bool, TraceLoopOpts, false,                                       \
229           &quot;Trace executed loop optimizations&quot;)                              \
230                                                                             \
231   develop(bool, TraceLoopLimitCheck, false,                                 \
232           &quot;Trace generation of loop limits checks&quot;)                         \
233                                                                             \
234   develop(bool, TraceRangeLimitCheck, false,                                \
235           &quot;Trace additional overflow checks in RCE&quot;)                        \
236                                                                             \
237   /* OptimizeFill not yet supported on PowerPC. */                          \
238   product(bool, OptimizeFill, true PPC64_ONLY(&amp;&amp; false),                    \
239           &quot;convert fill/copy loops into intrinsic&quot;)                         \
240                                                                             \
241   develop(bool, TraceOptimizeFill, false,                                   \
242           &quot;print detailed information about fill conversion&quot;)               \
243                                                                             \
244   develop(bool, OptoCoalesce, true,                                         \
245           &quot;Use Conservative Copy Coalescing in the Register Allocator&quot;)     \
246                                                                             \
247   develop(bool, UseUniqueSubclasses, true,                                  \
248           &quot;Narrow an abstract reference to the unique concrete subclass&quot;)   \
249                                                                             \
250   develop(bool, UseExactTypes, true,                                        \
251           &quot;Use exact types to eliminate array store checks and v-calls&quot;)    \
252                                                                             \
253   product(intx, TrackedInitializationLimit, 50,                             \
254           &quot;When initializing fields, track up to this many words&quot;)          \
255           range(0, 65535)                                                   \
256                                                                             \
257   product(bool, ReduceFieldZeroing, true,                                   \
258           &quot;When initializing fields, try to avoid needless zeroing&quot;)        \
259                                                                             \
260   product(bool, ReduceInitialCardMarks, true,                               \
261           &quot;When initializing fields, try to avoid needless card marks&quot;)     \
262                                                                             \
263   product(bool, ReduceBulkZeroing, true,                                    \
264           &quot;When bulk-initializing, try to avoid needless zeroing&quot;)          \
265                                                                             \
266   product(bool, UseFPUForSpilling, false,                                   \
267           &quot;Spill integer registers to FPU instead of stack when possible&quot;)  \
268                                                                             \
269   develop_pd(intx, RegisterCostAreaRatio,                                   \
270           &quot;Spill selection in reg allocator: scale area by (X/64K) before &quot; \
271           &quot;adding cost&quot;)                                                    \
272                                                                             \
273   develop_pd(bool, UseCISCSpill,                                            \
274           &quot;Use ADLC supplied cisc instructions during allocation&quot;)          \
275                                                                             \
276   notproduct(bool, VerifyGraphEdges , false,                                \
277           &quot;Verify Bi-directional Edges&quot;)                                    \
278                                                                             \
279   notproduct(bool, VerifyDUIterators, true,                                 \
280           &quot;Verify the safety of all iterations of Bi-directional Edges&quot;)    \
281                                                                             \
282   notproduct(bool, VerifyHashTableKeys, true,                               \
283           &quot;Verify the immutability of keys in the VN hash tables&quot;)          \
284                                                                             \
285   notproduct(bool, VerifyRegisterAllocator , false,                         \
286           &quot;Verify Register Allocator&quot;)                                      \
287                                                                             \
288   develop_pd(intx, FLOATPRESSURE,                                           \
289           &quot;Number of float LRG&#39;s that constitute high register pressure&quot;)   \
290           range(0, max_jint)                                                \
291                                                                             \
292   develop_pd(intx, INTPRESSURE,                                             \
293           &quot;Number of integer LRG&#39;s that constitute high register pressure&quot;) \
294           range(0, max_jint)                                                \
295                                                                             \
296   notproduct(bool, TraceOptoPipelining, false,                              \
297           &quot;Trace pipelining information&quot;)                                   \
298                                                                             \
299   notproduct(bool, TraceOptoOutput, false,                                  \
300           &quot;Trace pipelining information&quot;)                                   \
301                                                                             \
302   product_pd(bool, OptoScheduling,                                          \
303           &quot;Instruction Scheduling after register allocation&quot;)               \
304                                                                             \
305   product_pd(bool, OptoRegScheduling,                                       \
306           &quot;Instruction Scheduling before register allocation for pressure&quot;) \
307                                                                             \
308   product(bool, PartialPeelLoop, true,                                      \
309           &quot;Partial peel (rotate) loops&quot;)                                    \
310                                                                             \
311   product(intx, PartialPeelNewPhiDelta, 0,                                  \
312           &quot;Additional phis that can be created by partial peeling&quot;)         \
313           range(0, max_jint)                                                \
314                                                                             \
315   notproduct(bool, TracePartialPeeling, false,                              \
316           &quot;Trace partial peeling (loop rotation) information&quot;)              \
317                                                                             \
318   product(bool, PartialPeelAtUnsignedTests, true,                           \
319           &quot;Partial peel at unsigned tests if no signed test exists&quot;)        \
320                                                                             \
321   product(bool, ReassociateInvariants, true,                                \
322           &quot;Enable reassociation of expressions with loop invariants.&quot;)      \
323                                                                             \
324   product(bool, LoopUnswitching, true,                                      \
325           &quot;Enable loop unswitching (a form of invariant test hoisting)&quot;)    \
326                                                                             \
327   notproduct(bool, TraceLoopUnswitching, false,                             \
328           &quot;Trace loop unswitching&quot;)                                         \
329                                                                             \
330   product(bool, AllowVectorizeOnDemand, true,                               \
331           &quot;Globally supress vectorization set in VectorizeMethod&quot;)          \
332                                                                             \
333   product(bool, UseSuperWord, true,                                         \
334           &quot;Transform scalar operations into superword operations&quot;)          \
335                                                                             \
336   develop(bool, SuperWordRTDepCheck, false,                                 \
337           &quot;Enable runtime dependency checks.&quot;)                              \
338                                                                             \
339   product(bool, SuperWordReductions, true,                                  \
340           &quot;Enable reductions support in superword.&quot;)                        \
341                                                                             \
342   product(bool, UseCMoveUnconditionally, false,                             \
343           &quot;Use CMove (scalar and vector) ignoring profitability test.&quot;)     \
344                                                                             \
345   product(bool, DoReserveCopyInSuperWord, true,                             \
346           &quot;Create reserve copy of graph in SuperWord.&quot;)                     \
347                                                                             \
348   notproduct(bool, TraceSuperWord, false,                                   \
349           &quot;Trace superword transforms&quot;)                                     \
350                                                                             \
351   notproduct(bool, TraceNewVectors, false,                                  \
352           &quot;Trace creation of Vector nodes&quot;)                                 \
353                                                                             \
354   product_pd(bool, OptoBundling,                                            \
355           &quot;Generate nops to fill i-cache lines&quot;)                            \
356                                                                             \
357   product_pd(intx, ConditionalMoveLimit,                                    \
358           &quot;Limit of ops to make speculative when using CMOVE&quot;)              \
359           range(0, max_jint)                                                \
360                                                                             \
361   /* Set BranchOnRegister == false. See 4965987. */                         \
362   product(bool, BranchOnRegister, false,                                    \
363           &quot;Use Sparc V9 branch-on-register opcodes&quot;)                        \
364                                                                             \
365   develop(bool, SparcV9RegsHiBitsZero, true,                                \
366           &quot;Assume Sparc V9 I&amp;L registers on V8+ systems are zero-extended&quot;) \
367                                                                             \
368   product(bool, UseRDPCForConstantTableBase, false,                         \
369           &quot;Use Sparc RDPC instruction for the constant table base.&quot;)        \
370                                                                             \
371   notproduct(bool, PrintIdealGraph, false,                                  \
372           &quot;Print ideal graph to XML file / network interface. &quot;             \
373           &quot;By default attempts to connect to the visualizer on a socket.&quot;)  \
374                                                                             \
375   notproduct(intx, PrintIdealGraphLevel, 0,                                 \
376           &quot;Level of detail of the ideal graph printout. &quot;                   \
377           &quot;System-wide value, 0=nothing is printed, 4=all details printed. &quot;\
378           &quot;Level of detail of printouts can be set on a per-method level &quot;  \
379           &quot;as well by using CompileCommand=option.&quot;)                        \
380           range(0, 4)                                                       \
381                                                                             \
382   notproduct(intx, PrintIdealGraphPort, 4444,                               \
383           &quot;Ideal graph printer to network port&quot;)                            \
384           range(0, SHRT_MAX)                                                \
385                                                                             \
386   notproduct(ccstr, PrintIdealGraphAddress, &quot;127.0.0.1&quot;,                    \
387           &quot;IP address to connect to visualizer&quot;)                            \
388                                                                             \
389   notproduct(ccstr, PrintIdealGraphFile, NULL,                              \
390           &quot;File to dump ideal graph to.  If set overrides the &quot;             \
391           &quot;use of the network&quot;)                                             \
392                                                                             \
393   product(bool, UseBimorphicInlining, true,                                 \
394           &quot;Profiling based inlining for two receivers&quot;)                     \
395                                                                             \
396   product(bool, UseOnlyInlinedBimorphic, true,                              \
397           &quot;Don&#39;t use BimorphicInlining if can&#39;t inline a second method&quot;)    \
398                                                                             \
399   product(bool, InsertMemBarAfterArraycopy, true,                           \
400           &quot;Insert memory barrier after arraycopy call&quot;)                     \
401                                                                             \
402   develop(bool, SubsumeLoads, true,                                         \
403           &quot;Attempt to compile while subsuming loads into machine &quot;          \
404           &quot;instructions.&quot;)                                                  \
405                                                                             \
406   develop(bool, StressRecompilation, false,                                 \
407           &quot;Recompile each compiled method without subsuming loads &quot;         \
408           &quot;or escape analysis.&quot;)                                            \
409                                                                             \
410   develop(intx, ImplicitNullCheckThreshold, 3,                              \
411           &quot;Don&#39;t do implicit null checks if NPE&#39;s in a method exceeds &quot;     \
412           &quot;limit&quot;)                                                          \
413           range(0, max_jint)                                                \
414                                                                             \
415   product(intx, LoopOptsCount, 43,                                          \
416           &quot;Set level of loop optimization for tier 1 compiles&quot;)             \
417           range(5, 43)                                                      \
418                                                                             \
419   /* controls for heat-based inlining */                                    \
420                                                                             \
421   develop(intx, NodeCountInliningCutoff, 18000,                             \
422           &quot;If parser node generation exceeds limit stop inlining&quot;)          \
423           range(0, max_jint)                                                \
424                                                                             \
425   develop(intx, NodeCountInliningStep, 1000,                                \
426           &quot;Target size of warm calls inlined between optimization passes&quot;)  \
427           range(0, max_jint)                                                \
428                                                                             \
429   develop(bool, InlineWarmCalls, false,                                     \
430           &quot;Use a heat-based priority queue to govern inlining&quot;)             \
431                                                                             \
432   /* Max values must not exceed WarmCallInfo::MAX_VALUE(). */               \
433   develop(intx, HotCallCountThreshold, 999999,                              \
434           &quot;large numbers of calls (per method invocation) force hotness&quot;)   \
435           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
436                                                                             \
437   develop(intx, HotCallProfitThreshold, 999999,                             \
438           &quot;highly profitable inlining opportunities force hotness&quot;)         \
439           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
440                                                                             \
441   develop(intx, HotCallTrivialWork, -1,                                     \
442           &quot;trivial execution time (no larger than this) forces hotness&quot;)    \
443           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
444                                                                             \
445   develop(intx, HotCallTrivialSize, -1,                                     \
446           &quot;trivial methods (no larger than this) force calls to be hot&quot;)    \
447           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
448                                                                             \
449   develop(intx, WarmCallMinCount, -1,                                       \
450           &quot;number of calls (per method invocation) to enable inlining&quot;)     \
451           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
452                                                                             \
453   develop(intx, WarmCallMinProfit, -1,                                      \
454           &quot;number of calls (per method invocation) to enable inlining&quot;)     \
455           range(-1, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))     \
456                                                                             \
457   develop(intx, WarmCallMaxWork, 999999,                                    \
458           &quot;execution time of the largest inlinable method&quot;)                 \
459           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
460                                                                             \
461   develop(intx, WarmCallMaxSize, 999999,                                    \
462           &quot;size of the largest inlinable method&quot;)                           \
463           range(0, ((intx)MIN2((int64_t)max_intx,(int64_t)(+1.0e10))))      \
464                                                                             \
465   product(intx, MaxNodeLimit, 80000,                                        \
466           &quot;Maximum number of nodes&quot;)                                        \
467           range(1000, max_jint / 3)                                         \
468                                                                             \
469   product(intx, NodeLimitFudgeFactor, 2000,                                 \
470           &quot;Fudge Factor for certain optimizations&quot;)                         \
471           constraint(NodeLimitFudgeFactorConstraintFunc, AfterErgo)         \
472                                                                             \
473   product(bool, UseJumpTables, true,                                        \
474           &quot;Use JumpTables instead of a binary search tree for switches&quot;)    \
475                                                                             \
476   product(bool, UseDivMod, true,                                            \
477           &quot;Use combined DivMod instruction if available&quot;)                   \
478                                                                             \
479   product_pd(intx, MinJumpTableSize,                                        \
480           &quot;Minimum number of targets in a generated jump table&quot;)            \
481           range(0, max_intx)                                                \
482                                                                             \
483   product(intx, MaxJumpTableSize, 65000,                                    \
484           &quot;Maximum number of targets in a generated jump table&quot;)            \
485           range(0, max_intx)                                                \
486                                                                             \
487   product(intx, MaxJumpTableSparseness, 5,                                  \
488           &quot;Maximum sparseness for jumptables&quot;)                              \
489           range(0, max_intx / 4)                                            \
490                                                                             \
491   product(bool, EliminateLocks, true,                                       \
492           &quot;Coarsen locks when possible&quot;)                                    \
493                                                                             \
494   product(bool, EliminateNestedLocks, true,                                 \
495           &quot;Eliminate nested locks of the same object when possible&quot;)        \
496                                                                             \
497   notproduct(bool, PrintLockStatistics, false,                              \
498           &quot;Print precise statistics on the dynamic lock usage&quot;)             \
499                                                                             \
500   diagnostic(bool, PrintPreciseBiasedLockingStatistics, false,              \
501           &quot;Print per-lock-site statistics of biased locking in JVM&quot;)        \
502                                                                             \
503   diagnostic(bool, PrintPreciseRTMLockingStatistics, false,                 \
504           &quot;Print per-lock-site statistics of rtm locking in JVM&quot;)           \
505                                                                             \
506   notproduct(bool, PrintEliminateLocks, false,                              \
507           &quot;Print out when locks are eliminated&quot;)                            \
508                                                                             \
509   product(bool, EliminateAutoBox, true,                                     \
510           &quot;Control optimizations for autobox elimination&quot;)                  \
511                                                                             \
512   product(intx, AutoBoxCacheMax, 128,                                       \
513           &quot;Sets max value cached by the java.lang.Integer autobox cache&quot;)   \
514           range(0, max_jint)                                                \
515                                                                             \
<a name="5" id="anc5"></a><span class="line-modified">516   experimental(bool, AggressiveUnboxing, true,                              \</span>
517           &quot;Control optimizations for aggressive boxing elimination&quot;)        \
518                                                                             \
519   develop(bool, TracePostallocExpand, false, &quot;Trace expanding nodes after&quot;  \
520           &quot; register allocation.&quot;)                                          \
521                                                                             \
522   product(bool, DoEscapeAnalysis, true,                                     \
523           &quot;Perform escape analysis&quot;)                                        \
524                                                                             \
525   product(double, EscapeAnalysisTimeout, 20. DEBUG_ONLY(+40.),              \
526           &quot;Abort EA when it reaches time limit (in sec)&quot;)                   \
527           range(0, DBL_MAX)                                                 \
528                                                                             \
529   develop(bool, ExitEscapeAnalysisOnTimeout, true,                          \
530           &quot;Exit or throw assert in EA when it reaches time limit&quot;)          \
531                                                                             \
532   notproduct(bool, PrintEscapeAnalysis, false,                              \
533           &quot;Print the results of escape analysis&quot;)                           \
534                                                                             \
535   product(bool, EliminateAllocations, true,                                 \
536           &quot;Use escape analysis to eliminate allocations&quot;)                   \
537                                                                             \
538   notproduct(bool, PrintEliminateAllocations, false,                        \
539           &quot;Print out when allocations are eliminated&quot;)                      \
540                                                                             \
541   product(intx, EliminateAllocationArraySizeLimit, 64,                      \
542           &quot;Array size (number of elements) limit for scalar replacement&quot;)   \
543           range(0, max_jint)                                                \
544                                                                             \
545   product(bool, OptimizePtrCompare, true,                                   \
546           &quot;Use escape analysis to optimize pointers compare&quot;)               \
547                                                                             \
548   notproduct(bool, PrintOptimizePtrCompare, false,                          \
549           &quot;Print information about optimized pointers compare&quot;)             \
550                                                                             \
551   notproduct(bool, VerifyConnectionGraph , true,                            \
552           &quot;Verify Connection Graph construction in Escape Analysis&quot;)        \
553                                                                             \
554   product(bool, UseOptoBiasInlining, true,                                  \
555           &quot;Generate biased locking code in C2 ideal graph&quot;)                 \
556                                                                             \
557   product(bool, OptimizeStringConcat, true,                                 \
558           &quot;Optimize the construction of Strings by StringBuilder&quot;)          \
559                                                                             \
560   notproduct(bool, PrintOptimizeStringConcat, false,                        \
561           &quot;Print information about transformations performed on Strings&quot;)   \
562                                                                             \
563   product(intx, ValueSearchLimit, 1000,                                     \
564           &quot;Recursion limit in PhaseMacroExpand::value_from_mem_phi&quot;)        \
565           range(0, max_jint)                                                \
566                                                                             \
567   product(intx, MaxLabelRootDepth, 1100,                                    \
568           &quot;Maximum times call Label_Root to prevent stack overflow&quot;)        \
569           range(100, max_jint)                                              \
570                                                                             \
571   diagnostic(intx, DominatorSearchLimit, 1000,                              \
572           &quot;Iterations limit in Node::dominates&quot;)                            \
573           range(0, max_jint)                                                \
574                                                                             \
575   product(bool, BlockLayoutByFrequency, true,                               \
576           &quot;Use edge frequencies to drive block ordering&quot;)                   \
577                                                                             \
578   product(intx, BlockLayoutMinDiamondPercentage, 20,                        \
579           &quot;Miniumum %% of a successor (predecessor) for which block &quot;       \
580           &quot;layout a will allow a fork (join) in a single chain&quot;)            \
581           range(0, 100)                                                     \
582                                                                             \
583   product(bool, BlockLayoutRotateLoops, true,                               \
584           &quot;Allow back branches to be fall throughs in the block layout&quot;)    \
585                                                                             \
586   diagnostic(bool, InlineReflectionGetCallerClass, true,                    \
587           &quot;inline sun.reflect.Reflection.getCallerClass(), known to be &quot;    \
588           &quot;part of base library DLL&quot;)                                       \
589                                                                             \
590   diagnostic(bool, InlineObjectCopy, true,                                  \
591           &quot;inline Object.clone and Arrays.copyOf[Range] intrinsics&quot;)        \
592                                                                             \
593   diagnostic(bool, SpecialStringCompareTo, true,                            \
594           &quot;special version of string compareTo&quot;)                            \
595                                                                             \
596   diagnostic(bool, SpecialStringIndexOf, true,                              \
597           &quot;special version of string indexOf&quot;)                              \
598                                                                             \
599   diagnostic(bool, SpecialStringEquals, true,                               \
600           &quot;special version of string equals&quot;)                               \
601                                                                             \
602   diagnostic(bool, SpecialArraysEquals, true,                               \
603           &quot;special version of Arrays.equals(char[],char[])&quot;)                \
604                                                                             \
605   diagnostic(bool, SpecialEncodeISOArray, true,                             \
606           &quot;special version of ISO_8859_1$Encoder.encodeISOArray&quot;)           \
607                                                                             \
608   develop(bool, BailoutToInterpreterForThrows, false,                       \
609           &quot;Compiled methods which throws/catches exceptions will be &quot;       \
610           &quot;deopt and intp.&quot;)                                                \
611                                                                             \
612   develop(bool, ConvertCmpD2CmpF, true,                                     \
613           &quot;Convert cmpD to cmpF when one input is constant in float range&quot;) \
614                                                                             \
615   develop(bool, ConvertFloat2IntClipping, true,                             \
616           &quot;Convert float2int clipping idiom to integer clipping&quot;)           \
617                                                                             \
<a name="6" id="anc6"></a><span class="line-removed">618   develop(bool, Use24BitFPMode, true,                                       \</span>
<span class="line-removed">619           &quot;Set 24-bit FPU mode on a per-compile basis &quot;)                    \</span>
<span class="line-removed">620                                                                             \</span>
<span class="line-removed">621   develop(bool, Use24BitFP, true,                                           \</span>
<span class="line-removed">622           &quot;use FP instructions that produce 24-bit precise results&quot;)        \</span>
<span class="line-removed">623                                                                             \</span>
624   develop(bool, MonomorphicArrayCheck, true,                                \
625           &quot;Uncommon-trap array store checks that require full type check&quot;)  \
626                                                                             \
627   notproduct(bool, TracePhaseCCP, false,                                    \
628           &quot;Print progress during Conditional Constant Propagation&quot;)         \
629                                                                             \
630   develop(bool, PrintDominators, false,                                     \
631           &quot;Print out dominator trees for GVN&quot;)                              \
632                                                                             \
633   diagnostic(bool, TraceSpilling, false,                                    \
634           &quot;Trace spilling&quot;)                                                 \
635                                                                             \
636   diagnostic(bool, TraceTypeProfile, false,                                 \
637           &quot;Trace type profile&quot;)                                             \
638                                                                             \
639   develop(bool, PoisonOSREntry, true,                                       \
640            &quot;Detect abnormal calls to OSR code&quot;)                             \
641                                                                             \
642   develop(bool, SoftMatchFailure, trueInProduct,                            \
643           &quot;If the DFA fails to match a node, print a message and bail out&quot;) \
644                                                                             \
645   develop(bool, InlineAccessors, true,                                      \
646           &quot;inline accessor methods (get/set)&quot;)                              \
647                                                                             \
648   product(intx, TypeProfileMajorReceiverPercent, 90,                        \
649           &quot;% of major receiver type to all profiled receivers&quot;)             \
650           range(0, 100)                                                     \
651                                                                             \
652   diagnostic(bool, PrintIntrinsics, false,                                  \
653           &quot;prints attempted and successful inlining of intrinsics&quot;)         \
654                                                                             \
655   develop(bool, StressReflectiveCode, false,                                \
656           &quot;Use inexact types at allocations, etc., to test reflection&quot;)     \
657                                                                             \
658   diagnostic(bool, DebugInlinedCalls, true,                                 \
659          &quot;If false, restricts profiled locations to the root method only&quot;)  \
660                                                                             \
661   notproduct(bool, VerifyLoopOptimizations, false,                          \
662           &quot;verify major loop optimizations&quot;)                                \
663                                                                             \
664   diagnostic(bool, ProfileDynamicTypes, true,                               \
665           &quot;do extra type profiling and use it more aggressively&quot;)           \
666                                                                             \
667   develop(bool, TraceIterativeGVN, false,                                   \
668           &quot;Print progress during Iterative Global Value Numbering&quot;)         \
669                                                                             \
670   develop(bool, VerifyIterativeGVN, false,                                  \
671           &quot;Verify Def-Use modifications during sparse Iterative Global &quot;    \
672           &quot;Value Numbering&quot;)                                                \
673                                                                             \
674   notproduct(bool, TraceCISCSpill, false,                                   \
675           &quot;Trace allocators use of cisc spillable instructions&quot;)            \
676                                                                             \
677   product(bool, SplitIfBlocks, true,                                        \
678           &quot;Clone compares and control flow through merge points to fold &quot;   \
679           &quot;some branches&quot;)                                                  \
680                                                                             \
681   develop(intx, FreqCountInvocations,  1,                                   \
682           &quot;Scaling factor for branch frequencies (deprecated)&quot;)             \
683           range(1, max_intx)                                                \
684                                                                             \
685   product(intx, AliasLevel,     3,                                          \
686           &quot;0 for no aliasing, 1 for oop/field/static/array split, &quot;         \
687           &quot;2 for class split, 3 for unique instances&quot;)                      \
688           range(0, 3)                                                       \
689           constraint(AliasLevelConstraintFunc,AfterErgo)                    \
690                                                                             \
691   develop(bool, VerifyAliases, false,                                       \
692           &quot;perform extra checks on the results of alias analysis&quot;)          \
693                                                                             \
694   product(bool, IncrementalInline, true,                                    \
695           &quot;do post parse inlining&quot;)                                         \
696                                                                             \
697   develop(bool, AlwaysIncrementalInline, false,                             \
698           &quot;do all inlining incrementally&quot;)                                  \
699                                                                             \
700   product(intx, LiveNodeCountInliningCutoff, 40000,                         \
701           &quot;max number of live nodes in a method&quot;)                           \
702           range(0, max_juint / 8)                                           \
703                                                                             \
704   diagnostic(bool, OptimizeExpensiveOps, true,                              \
705           &quot;Find best control for expensive operations&quot;)                     \
706                                                                             \
707   diagnostic(bool, UseMathExactIntrinsics, true,                            \
708           &quot;Enables intrinsification of various java.lang.Math functions&quot;)   \
709                                                                             \
710   diagnostic(bool, UseCharacterCompareIntrinsics, false,                    \
711           &quot;Enables intrinsification of java.lang.Character functions&quot;)      \
712                                                                             \
713   diagnostic(bool, UseMultiplyToLenIntrinsic, false,                        \
714           &quot;Enables intrinsification of BigInteger.multiplyToLen()&quot;)         \
715                                                                             \
716   diagnostic(bool, UseSquareToLenIntrinsic, false,                          \
717           &quot;Enables intrinsification of BigInteger.squareToLen()&quot;)           \
718                                                                             \
719   diagnostic(bool, UseMulAddIntrinsic, false,                               \
720           &quot;Enables intrinsification of BigInteger.mulAdd()&quot;)                \
721                                                                             \
722   diagnostic(bool, UseMontgomeryMultiplyIntrinsic, false,                   \
723           &quot;Enables intrinsification of BigInteger.montgomeryMultiply()&quot;)    \
724                                                                             \
725   diagnostic(bool, UseMontgomerySquareIntrinsic, false,                     \
726           &quot;Enables intrinsification of BigInteger.montgomerySquare()&quot;)      \
727                                                                             \
728   product(bool, UseTypeSpeculation, true,                                   \
729           &quot;Speculatively propagate types from profiles&quot;)                    \
730                                                                             \
731   diagnostic(bool, UseInlineDepthForSpeculativeTypes, true,                 \
732           &quot;Carry inline depth of profile point with speculative type &quot;      \
733           &quot;and give priority to profiling from lower inline depth&quot;)         \
734                                                                             \
735   product_pd(bool, TrapBasedRangeChecks,                                    \
736           &quot;Generate code for range checks that uses a cmp and trap &quot;        \
737           &quot;instruction raising SIGTRAP. Used on PPC64.&quot;)                    \
738                                                                             \
739   product(intx, ArrayCopyLoadStoreMaxElem, 8,                               \
740           &quot;Maximum number of arraycopy elements inlined as a sequence of&quot;   \
741           &quot;loads/stores&quot;)                                                   \
742           range(0, max_intx)                                                \
743                                                                             \
744   develop(bool, StressArrayCopyMacroNode, false,                            \
745           &quot;Perform ArrayCopy load/store replacement during IGVN only&quot;)      \
746                                                                             \
747   develop(bool, RenumberLiveNodes, true,                                    \
748           &quot;Renumber live nodes&quot;)                                            \
749                                                                             \
750   product(uintx, LoopStripMiningIter, 0,                                    \
751           &quot;Number of iterations in strip mined loop&quot;)                       \
752           range(0, max_juint)                                               \
753                                                                             \
754   product(uintx, LoopStripMiningIterShortLoop, 0,                           \
755           &quot;Loop with fewer iterations are not strip mined&quot;)                 \
756           range(0, max_juint)                                               \
757                                                                             \
758   product(bool, UseProfiledLoopPredicate, true,                             \
<a name="7" id="anc7"></a><span class="line-modified">759           &quot;move predicates out of loops based on profiling data&quot;)           \</span>
<span class="line-modified">760 </span>
<span class="line-modified">761 C2_FLAGS(DECLARE_DEVELOPER_FLAG, \</span>
<span class="line-modified">762          DECLARE_PD_DEVELOPER_FLAG, \</span>
<span class="line-removed">763          DECLARE_PRODUCT_FLAG, \</span>
<span class="line-removed">764          DECLARE_PD_PRODUCT_FLAG, \</span>
<span class="line-removed">765          DECLARE_DIAGNOSTIC_FLAG, \</span>
<span class="line-removed">766          DECLARE_PD_DIAGNOSTIC_FLAG, \</span>
<span class="line-removed">767          DECLARE_EXPERIMENTAL_FLAG, \</span>
<span class="line-removed">768          DECLARE_NOTPRODUCT_FLAG, \</span>
<span class="line-removed">769          IGNORE_RANGE, \</span>
<span class="line-removed">770          IGNORE_CONSTRAINT, \</span>
<span class="line-removed">771          IGNORE_WRITEABLE)</span>
772 
773 #endif // SHARE_OPTO_C2_GLOBALS_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
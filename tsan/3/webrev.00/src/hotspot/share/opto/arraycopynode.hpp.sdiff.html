<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/arraycopynode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arraycopynode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="block.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_ARRAYCOPYNODE_HPP
 26 #define SHARE_OPTO_ARRAYCOPYNODE_HPP
 27 
 28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 29 #include &quot;opto/callnode.hpp&quot;
 30 
 31 class GraphKit;
 32 
 33 class ArrayCopyNode : public CallNode {
 34 private:
 35 
 36   // What kind of arraycopy variant is this?
 37   enum {
 38     None,            // not set yet
 39     ArrayCopy,       // System.arraycopy()
<span class="line-modified"> 40     CloneBasic,      // A clone that can be copied by 64 bit chunks</span>
<span class="line-modified"> 41     CloneOop,        // An oop array clone</span>


 42     CopyOf,          // Arrays.copyOf()
 43     CopyOfRange      // Arrays.copyOfRange()
 44   } _kind;
 45 
 46 #ifndef PRODUCT
 47   static const char* _kind_names[CopyOfRange+1];
 48 #endif
 49   // Is the alloc obtained with
 50   // AllocateArrayNode::Ideal_array_allocation() tightly coupled
 51   // (arraycopy follows immediately the allocation)?
 52   // We cache the result of LibraryCallKit::tightly_coupled_allocation
 53   // here because it&#39;s much easier to find whether there&#39;s a tightly
 54   // couple allocation at parse time than at macro expansion time. At
 55   // macro expansion time, for every use of the allocation node we
 56   // would need to figure out whether it happens after the arraycopy (and
 57   // can be ignored) or between the allocation and the arraycopy. At
 58   // parse time, it&#39;s straightforward because whatever happens after
 59   // the arraycopy is not parsed yet so doesn&#39;t exist when
 60   // LibraryCallKit::tightly_coupled_allocation() is called.
 61   bool _alloc_tightly_coupled;
</pre>
<hr />
<pre>
 71     fields[DestPos]   = TypeInt::INT;
 72     fields[Length]    = TypeInt::INT;
 73     fields[SrcLen]    = TypeInt::INT;
 74     fields[DestLen]   = TypeInt::INT;
 75     fields[SrcKlass]  = TypeKlassPtr::BOTTOM;
 76     fields[DestKlass] = TypeKlassPtr::BOTTOM;
 77     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 78 
 79     // create result type (range)
 80     fields = TypeTuple::fields(0);
 81 
 82     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 83 
 84     return TypeFunc::make(domain, range);
 85   }
 86 
 87   ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard);
 88 
 89   intptr_t get_length_if_constant(PhaseGVN *phase) const;
 90   int get_count(PhaseGVN *phase) const;
<span class="line-modified"> 91   static const TypePtr* get_address_type(PhaseGVN *phase, Node* n);</span>
 92 
 93   Node* try_clone_instance(PhaseGVN *phase, bool can_reshape, int count);
 94   bool prepare_array_copy(PhaseGVN *phase, bool can_reshape,
 95                           Node*&amp; adr_src, Node*&amp; base_src, Node*&amp; adr_dest, Node*&amp; base_dest,
 96                           BasicType&amp; copy_type, const Type*&amp; value_type, bool&amp; disjoint_bases);
 97   void array_copy_test_overlap(PhaseGVN *phase, bool can_reshape,
 98                                bool disjoint_bases, int count,
 99                                Node*&amp; forward_ctl, Node*&amp; backward_ctl);
100   Node* array_copy_forward(PhaseGVN *phase, bool can_reshape, Node*&amp; ctl,
101                            MergeMemNode* mm,
102                            const TypePtr* atp_src, const TypePtr* atp_dest,
103                            Node* adr_src, Node* base_src, Node* adr_dest, Node* base_dest,
104                            BasicType copy_type, const Type* value_type, int count);
105   Node* array_copy_backward(PhaseGVN *phase, bool can_reshape, Node*&amp; ctl,
106                             MergeMemNode* mm,
107                             const TypePtr* atp_src, const TypePtr* atp_dest,
108                             Node* adr_src, Node* base_src, Node* adr_dest, Node* base_dest,
109                             BasicType copy_type, const Type* value_type, int count);
110   bool finish_transform(PhaseGVN *phase, bool can_reshape,
111                         Node* ctl, Node *mem);
</pre>
<hr />
<pre>
129     ParmLimit
130   };
131 
132   // Results from escape analysis for non escaping inputs
133   const TypeOopPtr* _src_type;
134   const TypeOopPtr* _dest_type;
135 
136   static ArrayCopyNode* make(GraphKit* kit, bool may_throw,
137                              Node* src, Node* src_offset,
138                              Node* dest,  Node* dest_offset,
139                              Node* length,
140                              bool alloc_tightly_coupled,
141                              bool has_negative_length_guard,
142                              Node* src_klass = NULL, Node* dest_klass = NULL,
143                              Node* src_length = NULL, Node* dest_length = NULL);
144 
145   void connect_outputs(GraphKit* kit);
146 
147   bool is_arraycopy()             const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == ArrayCopy; }
148   bool is_arraycopy_validated()   const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == ArrayCopy &amp;&amp; _arguments_validated; }
<span class="line-modified">149   bool is_clonebasic()            const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneBasic; }</span>
<span class="line-modified">150   bool is_cloneoop()              const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneOop; }</span>





151   bool is_copyof()                const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOf; }
152   bool is_copyof_validated()      const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOf &amp;&amp; _arguments_validated; }
153   bool is_copyofrange()           const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOfRange; }
154   bool is_copyofrange_validated() const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOfRange &amp;&amp; _arguments_validated; }
155 
156   void set_arraycopy(bool validated)   { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = ArrayCopy; _arguments_validated = validated; }
<span class="line-modified">157   void set_clonebasic()                { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CloneBasic; }</span>
<span class="line-modified">158   void set_cloneoop()                  { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CloneOop; }</span>

159   void set_copyof(bool validated)      { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CopyOf; _arguments_validated = validated; }
160   void set_copyofrange(bool validated) { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CopyOfRange; _arguments_validated = validated; }
161 
162   virtual int Opcode() const;
163   virtual uint size_of() const; // Size is bigger
164   virtual bool guaranteed_safepoint()  { return false; }
165   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
166 
167   virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);
168 
169   bool is_alloc_tightly_coupled() const { return _alloc_tightly_coupled; }
170 
171   bool has_negative_length_guard() const { return _has_negative_length_guard; }
172 
173   static bool may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*&amp; ac);
174   bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const;
175 
176 #ifndef PRODUCT
177   virtual void dump_spec(outputStream *st) const;
178   virtual void dump_compact_spec(outputStream* st) const;
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_ARRAYCOPYNODE_HPP
 26 #define SHARE_OPTO_ARRAYCOPYNODE_HPP
 27 
 28 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 29 #include &quot;opto/callnode.hpp&quot;
 30 
 31 class GraphKit;
 32 
 33 class ArrayCopyNode : public CallNode {
 34 private:
 35 
 36   // What kind of arraycopy variant is this?
 37   enum {
 38     None,            // not set yet
 39     ArrayCopy,       // System.arraycopy()
<span class="line-modified"> 40     CloneInst,       // A clone of instances</span>
<span class="line-modified"> 41     CloneArray,      // A clone of arrays that don&#39;t require a barrier</span>
<span class="line-added"> 42                      // - depends on GC - some need to treat oop arrays separately</span>
<span class="line-added"> 43     CloneOopArray,   // An oop array clone that requires GC barriers</span>
 44     CopyOf,          // Arrays.copyOf()
 45     CopyOfRange      // Arrays.copyOfRange()
 46   } _kind;
 47 
 48 #ifndef PRODUCT
 49   static const char* _kind_names[CopyOfRange+1];
 50 #endif
 51   // Is the alloc obtained with
 52   // AllocateArrayNode::Ideal_array_allocation() tightly coupled
 53   // (arraycopy follows immediately the allocation)?
 54   // We cache the result of LibraryCallKit::tightly_coupled_allocation
 55   // here because it&#39;s much easier to find whether there&#39;s a tightly
 56   // couple allocation at parse time than at macro expansion time. At
 57   // macro expansion time, for every use of the allocation node we
 58   // would need to figure out whether it happens after the arraycopy (and
 59   // can be ignored) or between the allocation and the arraycopy. At
 60   // parse time, it&#39;s straightforward because whatever happens after
 61   // the arraycopy is not parsed yet so doesn&#39;t exist when
 62   // LibraryCallKit::tightly_coupled_allocation() is called.
 63   bool _alloc_tightly_coupled;
</pre>
<hr />
<pre>
 73     fields[DestPos]   = TypeInt::INT;
 74     fields[Length]    = TypeInt::INT;
 75     fields[SrcLen]    = TypeInt::INT;
 76     fields[DestLen]   = TypeInt::INT;
 77     fields[SrcKlass]  = TypeKlassPtr::BOTTOM;
 78     fields[DestKlass] = TypeKlassPtr::BOTTOM;
 79     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 80 
 81     // create result type (range)
 82     fields = TypeTuple::fields(0);
 83 
 84     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 85 
 86     return TypeFunc::make(domain, range);
 87   }
 88 
 89   ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard);
 90 
 91   intptr_t get_length_if_constant(PhaseGVN *phase) const;
 92   int get_count(PhaseGVN *phase) const;
<span class="line-modified"> 93   static const TypePtr* get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n);</span>
 94 
 95   Node* try_clone_instance(PhaseGVN *phase, bool can_reshape, int count);
 96   bool prepare_array_copy(PhaseGVN *phase, bool can_reshape,
 97                           Node*&amp; adr_src, Node*&amp; base_src, Node*&amp; adr_dest, Node*&amp; base_dest,
 98                           BasicType&amp; copy_type, const Type*&amp; value_type, bool&amp; disjoint_bases);
 99   void array_copy_test_overlap(PhaseGVN *phase, bool can_reshape,
100                                bool disjoint_bases, int count,
101                                Node*&amp; forward_ctl, Node*&amp; backward_ctl);
102   Node* array_copy_forward(PhaseGVN *phase, bool can_reshape, Node*&amp; ctl,
103                            MergeMemNode* mm,
104                            const TypePtr* atp_src, const TypePtr* atp_dest,
105                            Node* adr_src, Node* base_src, Node* adr_dest, Node* base_dest,
106                            BasicType copy_type, const Type* value_type, int count);
107   Node* array_copy_backward(PhaseGVN *phase, bool can_reshape, Node*&amp; ctl,
108                             MergeMemNode* mm,
109                             const TypePtr* atp_src, const TypePtr* atp_dest,
110                             Node* adr_src, Node* base_src, Node* adr_dest, Node* base_dest,
111                             BasicType copy_type, const Type* value_type, int count);
112   bool finish_transform(PhaseGVN *phase, bool can_reshape,
113                         Node* ctl, Node *mem);
</pre>
<hr />
<pre>
131     ParmLimit
132   };
133 
134   // Results from escape analysis for non escaping inputs
135   const TypeOopPtr* _src_type;
136   const TypeOopPtr* _dest_type;
137 
138   static ArrayCopyNode* make(GraphKit* kit, bool may_throw,
139                              Node* src, Node* src_offset,
140                              Node* dest,  Node* dest_offset,
141                              Node* length,
142                              bool alloc_tightly_coupled,
143                              bool has_negative_length_guard,
144                              Node* src_klass = NULL, Node* dest_klass = NULL,
145                              Node* src_length = NULL, Node* dest_length = NULL);
146 
147   void connect_outputs(GraphKit* kit);
148 
149   bool is_arraycopy()             const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == ArrayCopy; }
150   bool is_arraycopy_validated()   const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == ArrayCopy &amp;&amp; _arguments_validated; }
<span class="line-modified">151   bool is_clone_inst()            const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneInst; }</span>
<span class="line-modified">152   // is_clone_array - true for all arrays when using GCs that has no barriers</span>
<span class="line-added">153   bool is_clone_array()           const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneArray; }</span>
<span class="line-added">154   // is_clone_oop_array is used when oop arrays need GC barriers</span>
<span class="line-added">155   bool is_clone_oop_array()       const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneOopArray; }</span>
<span class="line-added">156   // is_clonebasic - is true for any type of clone that doesn&#39;t need a barrier.</span>
<span class="line-added">157   bool is_clonebasic()            const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CloneInst || _kind == CloneArray; }</span>
158   bool is_copyof()                const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOf; }
159   bool is_copyof_validated()      const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOf &amp;&amp; _arguments_validated; }
160   bool is_copyofrange()           const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOfRange; }
161   bool is_copyofrange_validated() const  { assert(_kind != None, &quot;should bet set&quot;); return _kind == CopyOfRange &amp;&amp; _arguments_validated; }
162 
163   void set_arraycopy(bool validated)   { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = ArrayCopy; _arguments_validated = validated; }
<span class="line-modified">164   void set_clone_inst()                { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CloneInst; }</span>
<span class="line-modified">165   void set_clone_array()               { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CloneArray; }</span>
<span class="line-added">166   void set_clone_oop_array()           { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CloneOopArray; }</span>
167   void set_copyof(bool validated)      { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CopyOf; _arguments_validated = validated; }
168   void set_copyofrange(bool validated) { assert(_kind == None, &quot;shouldn&#39;t bet set yet&quot;); _kind = CopyOfRange; _arguments_validated = validated; }
169 
170   virtual int Opcode() const;
171   virtual uint size_of() const; // Size is bigger
172   virtual bool guaranteed_safepoint()  { return false; }
173   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
174 
175   virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);
176 
177   bool is_alloc_tightly_coupled() const { return _alloc_tightly_coupled; }
178 
179   bool has_negative_length_guard() const { return _has_negative_length_guard; }
180 
181   static bool may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*&amp; ac);
182   bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const;
183 
184 #ifndef PRODUCT
185   virtual void dump_spec(outputStream *st) const;
186   virtual void dump_compact_spec(outputStream* st) const;
</pre>
</td>
</tr>
</table>
<center><a href="arraycopynode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="block.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
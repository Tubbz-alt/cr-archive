<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/phaseX.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/block.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/idealGraphPrinter.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/phaseX.hpp&quot;
  39 #include &quot;opto/regalloc.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;utilities/macros.hpp&quot;
  42 
  43 //=============================================================================
  44 #define NODE_HASH_MINIMUM_SIZE    255
  45 //------------------------------NodeHash---------------------------------------
  46 NodeHash::NodeHash(uint est_max_size) :
  47   _a(Thread::current()-&gt;resource_area()),
  48   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  49   _inserts(0), _insert_limit( insert_limit() ),
  50   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) // (Node**)_a-&gt;Amalloc(_max * sizeof(Node*)) ),
  51 #ifndef PRODUCT
  52   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  53   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  54    _total_inserts(0), _total_insert_probes(0)
  55 #endif
  56 {
  57   // _sentinel must be in the current node space
  58   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  59   memset(_table,0,sizeof(Node*)*_max);
  60 }
  61 
  62 //------------------------------NodeHash---------------------------------------
  63 NodeHash::NodeHash(Arena *arena, uint est_max_size) :
  64   _a(arena),
  65   _max( round_up(est_max_size &lt; NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),
  66   _inserts(0), _insert_limit( insert_limit() ),
  67   _table( NEW_ARENA_ARRAY( _a , Node* , _max ) )
  68 #ifndef PRODUCT
  69   , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),
  70   _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),
  71    _total_inserts(0), _total_insert_probes(0)
  72 #endif
  73 {
  74   // _sentinel must be in the current node space
  75   _sentinel = new ProjNode(NULL, TypeFunc::Control);
  76   memset(_table,0,sizeof(Node*)*_max);
  77 }
  78 
  79 //------------------------------NodeHash---------------------------------------
  80 NodeHash::NodeHash(NodeHash *nh) {
  81   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  82   // just copy in all the fields
  83   *this = *nh;
  84   // nh-&gt;_sentinel must be in the current node space
  85 }
  86 
  87 void NodeHash::replace_with(NodeHash *nh) {
  88   debug_only(_table = (Node**)badAddress);   // interact correctly w/ operator=
  89   // just copy in all the fields
  90   *this = *nh;
  91   // nh-&gt;_sentinel must be in the current node space
  92 }
  93 
  94 //------------------------------hash_find--------------------------------------
  95 // Find in hash table
  96 Node *NodeHash::hash_find( const Node *n ) {
  97   // ((Node*)n)-&gt;set_hash( n-&gt;hash() );
  98   uint hash = n-&gt;hash();
  99   if (hash == Node::NO_HASH) {
 100     NOT_PRODUCT( _lookup_misses++ );
 101     return NULL;
 102   }
 103   uint key = hash &amp; (_max-1);
 104   uint stride = key | 0x01;
 105   NOT_PRODUCT( _look_probes++ );
 106   Node *k = _table[key];        // Get hashed value
 107   if( !k ) {                    // ?Miss?
 108     NOT_PRODUCT( _lookup_misses++ );
 109     return NULL;                // Miss!
 110   }
 111 
 112   int op = n-&gt;Opcode();
 113   uint req = n-&gt;req();
 114   while( 1 ) {                  // While probing hash table
 115     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 116         k-&gt;Opcode() == op ) {   // Same Opcode
 117       for( uint i=0; i&lt;req; i++ )
 118         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 119           goto collision;       // &quot;goto&quot; is a speed hack...
 120       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 121         NOT_PRODUCT( _lookup_hits++ );
 122         return k;               // Hit!
 123       }
 124     }
 125   collision:
 126     NOT_PRODUCT( _look_probes++ );
 127     key = (key + stride/*7*/) &amp; (_max-1); // Stride through table with relative prime
 128     k = _table[key];            // Get hashed value
 129     if( !k ) {                  // ?Miss?
 130       NOT_PRODUCT( _lookup_misses++ );
 131       return NULL;              // Miss!
 132     }
 133   }
 134   ShouldNotReachHere();
 135   return NULL;
 136 }
 137 
 138 //------------------------------hash_find_insert-------------------------------
 139 // Find in hash table, insert if not already present
 140 // Used to preserve unique entries in hash table
 141 Node *NodeHash::hash_find_insert( Node *n ) {
 142   // n-&gt;set_hash( );
 143   uint hash = n-&gt;hash();
 144   if (hash == Node::NO_HASH) {
 145     NOT_PRODUCT( _lookup_misses++ );
 146     return NULL;
 147   }
 148   uint key = hash &amp; (_max-1);
 149   uint stride = key | 0x01;     // stride must be relatively prime to table siz
 150   uint first_sentinel = 0;      // replace a sentinel if seen.
 151   NOT_PRODUCT( _look_probes++ );
 152   Node *k = _table[key];        // Get hashed value
 153   if( !k ) {                    // ?Miss?
 154     NOT_PRODUCT( _lookup_misses++ );
 155     _table[key] = n;            // Insert into table!
 156     debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 157     check_grow();               // Grow table if insert hit limit
 158     return NULL;                // Miss!
 159   }
 160   else if( k == _sentinel ) {
 161     first_sentinel = key;      // Can insert here
 162   }
 163 
 164   int op = n-&gt;Opcode();
 165   uint req = n-&gt;req();
 166   while( 1 ) {                  // While probing hash table
 167     if( k-&gt;req() == req &amp;&amp;      // Same count of inputs
 168         k-&gt;Opcode() == op ) {   // Same Opcode
 169       for( uint i=0; i&lt;req; i++ )
 170         if( n-&gt;in(i)!=k-&gt;in(i)) // Different inputs?
 171           goto collision;       // &quot;goto&quot; is a speed hack...
 172       if( n-&gt;cmp(*k) ) {        // Check for any special bits
 173         NOT_PRODUCT( _lookup_hits++ );
 174         return k;               // Hit!
 175       }
 176     }
 177   collision:
 178     NOT_PRODUCT( _look_probes++ );
 179     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 180     k = _table[key];            // Get hashed value
 181     if( !k ) {                  // ?Miss?
 182       NOT_PRODUCT( _lookup_misses++ );
 183       key = (first_sentinel == 0) ? key : first_sentinel; // ?saw sentinel?
 184       _table[key] = n;          // Insert into table!
 185       debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 186       check_grow();             // Grow table if insert hit limit
 187       return NULL;              // Miss!
 188     }
 189     else if( first_sentinel == 0 &amp;&amp; k == _sentinel ) {
 190       first_sentinel = key;    // Can insert here
 191     }
 192 
 193   }
 194   ShouldNotReachHere();
 195   return NULL;
 196 }
 197 
 198 //------------------------------hash_insert------------------------------------
 199 // Insert into hash table
 200 void NodeHash::hash_insert( Node *n ) {
 201   // // &quot;conflict&quot; comments -- print nodes that conflict
 202   // bool conflict = false;
 203   // n-&gt;set_hash();
 204   uint hash = n-&gt;hash();
 205   if (hash == Node::NO_HASH) {
 206     return;
 207   }
 208   check_grow();
 209   uint key = hash &amp; (_max-1);
 210   uint stride = key | 0x01;
 211 
 212   while( 1 ) {                  // While probing hash table
 213     NOT_PRODUCT( _insert_probes++ );
 214     Node *k = _table[key];      // Get hashed value
 215     if( !k || (k == _sentinel) ) break;       // Found a slot
 216     assert( k != n, &quot;already inserted&quot; );
 217     // if( PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose ) { tty-&gt;print(&quot;  conflict: &quot;); k-&gt;dump(); conflict = true; }
 218     key = (key + stride) &amp; (_max-1); // Stride through table w/ relative prime
 219   }
 220   _table[key] = n;              // Insert into table!
 221   debug_only(n-&gt;enter_hash_lock()); // Lock down the node while in the table.
 222   // if( conflict ) { n-&gt;dump(); }
 223 }
 224 
 225 //------------------------------hash_delete------------------------------------
 226 // Replace in hash table with sentinel
 227 bool NodeHash::hash_delete( const Node *n ) {
 228   Node *k;
 229   uint hash = n-&gt;hash();
 230   if (hash == Node::NO_HASH) {
 231     NOT_PRODUCT( _delete_misses++ );
 232     return false;
 233   }
 234   uint key = hash &amp; (_max-1);
 235   uint stride = key | 0x01;
 236   debug_only( uint counter = 0; );
 237   for( ; /* (k != NULL) &amp;&amp; (k != _sentinel) */; ) {
 238     debug_only( counter++ );
 239     NOT_PRODUCT( _delete_probes++ );
 240     k = _table[key];            // Get hashed value
 241     if( !k ) {                  // Miss?
 242       NOT_PRODUCT( _delete_misses++ );
 243 #ifdef ASSERT
 244       if( VerifyOpto ) {
 245         for( uint i=0; i &lt; _max; i++ )
 246           assert( _table[i] != n, &quot;changed edges with rehashing&quot; );
 247       }
 248 #endif
 249       return false;             // Miss! Not in chain
 250     }
 251     else if( n == k ) {
 252       NOT_PRODUCT( _delete_hits++ );
 253       _table[key] = _sentinel;  // Hit! Label as deleted entry
 254       debug_only(((Node*)n)-&gt;exit_hash_lock()); // Unlock the node upon removal from table.
 255       return true;
 256     }
 257     else {
 258       // collision: move through table with prime offset
 259       key = (key + stride/*7*/) &amp; (_max-1);
 260       assert( counter &lt;= _insert_limit, &quot;Cycle in hash-table&quot;);
 261     }
 262   }
 263   ShouldNotReachHere();
 264   return false;
 265 }
 266 
 267 //------------------------------round_up---------------------------------------
 268 // Round up to nearest power of 2
 269 uint NodeHash::round_up( uint x ) {
 270   x += (x&gt;&gt;2);                  // Add 25% slop
 271   if( x &lt;16 ) return 16;        // Small stuff
 272   uint i=16;
 273   while( i &lt; x ) i &lt;&lt;= 1;       // Double to fit
 274   return i;                     // Return hash table size
 275 }
 276 
 277 //------------------------------grow-------------------------------------------
 278 // Grow _table to next power of 2 and insert old entries
 279 void  NodeHash::grow() {
 280   // Record old state
 281   uint   old_max   = _max;
 282   Node **old_table = _table;
 283   // Construct new table with twice the space
 284 #ifndef PRODUCT
 285   _grows++;
 286   _total_inserts       += _inserts;
 287   _total_insert_probes += _insert_probes;
 288   _insert_probes   = 0;
 289 #endif
 290   _inserts         = 0;
 291   _max     = _max &lt;&lt; 1;
 292   _table   = NEW_ARENA_ARRAY( _a , Node* , _max ); // (Node**)_a-&gt;Amalloc( _max * sizeof(Node*) );
 293   memset(_table,0,sizeof(Node*)*_max);
 294   _insert_limit = insert_limit();
 295   // Insert old entries into the new table
 296   for( uint i = 0; i &lt; old_max; i++ ) {
 297     Node *m = *old_table++;
 298     if( !m || m == _sentinel ) continue;
 299     debug_only(m-&gt;exit_hash_lock()); // Unlock the node upon removal from old table.
 300     hash_insert(m);
 301   }
 302 }
 303 
 304 //------------------------------clear------------------------------------------
 305 // Clear all entries in _table to NULL but keep storage
 306 void  NodeHash::clear() {
 307 #ifdef ASSERT
 308   // Unlock all nodes upon removal from table.
 309   for (uint i = 0; i &lt; _max; i++) {
 310     Node* n = _table[i];
 311     if (!n || n == _sentinel)  continue;
 312     n-&gt;exit_hash_lock();
 313   }
 314 #endif
 315 
 316   memset( _table, 0, _max * sizeof(Node*) );
 317 }
 318 
 319 //-----------------------remove_useless_nodes----------------------------------
 320 // Remove useless nodes from value table,
 321 // implementation does not depend on hash function
 322 void NodeHash::remove_useless_nodes(VectorSet &amp;useful) {
 323 
 324   // Dead nodes in the hash table inherited from GVN should not replace
 325   // existing nodes, remove dead nodes.
 326   uint max = size();
 327   Node *sentinel_node = sentinel();
 328   for( uint i = 0; i &lt; max; ++i ) {
 329     Node *n = at(i);
 330     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; !useful.test(n-&gt;_idx)) {
 331       debug_only(n-&gt;exit_hash_lock()); // Unlock the node when removed
 332       _table[i] = sentinel_node;       // Replace with placeholder
 333     }
 334   }
 335 }
 336 
 337 
 338 void NodeHash::check_no_speculative_types() {
 339 #ifdef ASSERT
 340   uint max = size();
 341   Node *sentinel_node = sentinel();
 342   for (uint i = 0; i &lt; max; ++i) {
 343     Node *n = at(i);
 344     if(n != NULL &amp;&amp; n != sentinel_node &amp;&amp; n-&gt;is_Type() &amp;&amp; n-&gt;outcnt() &gt; 0) {
 345       TypeNode* tn = n-&gt;as_Type();
 346       const Type* t = tn-&gt;type();
 347       const Type* t_no_spec = t-&gt;remove_speculative();
 348       assert(t == t_no_spec, &quot;dead node in hash table or missed node during speculative cleanup&quot;);
 349     }
 350   }
 351 #endif
 352 }
 353 
 354 #ifndef PRODUCT
 355 //------------------------------dump-------------------------------------------
 356 // Dump statistics for the hash table
 357 void NodeHash::dump() {
 358   _total_inserts       += _inserts;
 359   _total_insert_probes += _insert_probes;
 360   if (PrintCompilation &amp;&amp; PrintOptoStatistics &amp;&amp; Verbose &amp;&amp; (_inserts &gt; 0)) {
 361     if (WizardMode) {
 362       for (uint i=0; i&lt;_max; i++) {
 363         if (_table[i])
 364           tty-&gt;print(&quot;%d/%d/%d &quot;,i,_table[i]-&gt;hash()&amp;(_max-1),_table[i]-&gt;_idx);
 365       }
 366     }
 367     tty-&gt;print(&quot;\nGVN Hash stats:  %d grows to %d max_size\n&quot;, _grows, _max);
 368     tty-&gt;print(&quot;  %d/%d (%8.1f%% full)\n&quot;, _inserts, _max, (double)_inserts/_max*100.0);
 369     tty-&gt;print(&quot;  %dp/(%dh+%dm) (%8.2f probes/lookup)\n&quot;, _look_probes, _lookup_hits, _lookup_misses, (double)_look_probes/(_lookup_hits+_lookup_misses));
 370     tty-&gt;print(&quot;  %dp/%di (%8.2f probes/insert)\n&quot;, _total_insert_probes, _total_inserts, (double)_total_insert_probes/_total_inserts);
 371     // sentinels increase lookup cost, but not insert cost
 372     assert((_lookup_misses+_lookup_hits)*4+100 &gt;= _look_probes, &quot;bad hash function&quot;);
 373     assert( _inserts+(_inserts&gt;&gt;3) &lt; _max, &quot;table too full&quot; );
 374     assert( _inserts*3+100 &gt;= _insert_probes, &quot;bad hash function&quot; );
 375   }
 376 }
 377 
 378 Node *NodeHash::find_index(uint idx) { // For debugging
 379   // Find an entry by its index value
 380   for( uint i = 0; i &lt; _max; i++ ) {
 381     Node *m = _table[i];
 382     if( !m || m == _sentinel ) continue;
 383     if( m-&gt;_idx == (uint)idx ) return m;
 384   }
 385   return NULL;
 386 }
 387 #endif
 388 
 389 #ifdef ASSERT
 390 NodeHash::~NodeHash() {
 391   // Unlock all nodes upon destruction of table.
 392   if (_table != (Node**)badAddress)  clear();
 393 }
 394 
 395 void NodeHash::operator=(const NodeHash&amp; nh) {
 396   // Unlock all nodes upon replacement of table.
 397   if (&amp;nh == this)  return;
 398   if (_table != (Node**)badAddress)  clear();
 399   memcpy((void*)this, (void*)&amp;nh, sizeof(*this));
 400   // Do not increment hash_lock counts again.
 401   // Instead, be sure we never again use the source table.
 402   ((NodeHash*)&amp;nh)-&gt;_table = (Node**)badAddress;
 403 }
 404 
 405 
 406 #endif
 407 
 408 
 409 //=============================================================================
 410 //------------------------------PhaseRemoveUseless-----------------------------
 411 // 1) Use a breadthfirst walk to collect useful nodes reachable from root.
 412 PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List *worklist, PhaseNumber phase_num) : Phase(phase_num),
 413   _useful(Thread::current()-&gt;resource_area()) {
 414 
 415   // Implementation requires &#39;UseLoopSafepoints == true&#39; and an edge from root
 416   // to each SafePointNode at a backward branch.  Inserted in add_safepoint().
 417   if( !UseLoopSafepoints || !OptoRemoveUseless ) return;
 418 
 419   // Identify nodes that are reachable from below, useful.
 420   C-&gt;identify_useful_nodes(_useful);
 421   // Update dead node list
 422   C-&gt;update_dead_node_list(_useful);
 423 
 424   // Remove all useless nodes from PhaseValues&#39; recorded types
 425   // Must be done before disconnecting nodes to preserve hash-table-invariant
 426   gvn-&gt;remove_useless_nodes(_useful.member_set());
 427 
 428   // Remove all useless nodes from future worklist
 429   worklist-&gt;remove_useless_nodes(_useful.member_set());
 430 
 431   // Disconnect &#39;useless&#39; nodes that are adjacent to useful nodes
 432   C-&gt;remove_useless_nodes(_useful);
 433 }
 434 
 435 //=============================================================================
 436 //------------------------------PhaseRenumberLive------------------------------
 437 // First, remove useless nodes (equivalent to identifying live nodes).
 438 // Then, renumber live nodes.
 439 //
 440 // The set of live nodes is returned by PhaseRemoveUseless in the _useful structure.
 441 // If the number of live nodes is &#39;x&#39; (where &#39;x&#39; == _useful.size()), then the
 442 // PhaseRenumberLive updates the node ID of each node (the _idx field) with a unique
 443 // value in the range [0, x).
 444 //
 445 // At the end of the PhaseRenumberLive phase, the compiler&#39;s count of unique nodes is
 446 // updated to &#39;x&#39; and the list of dead nodes is reset (as there are no dead nodes).
 447 //
 448 // The PhaseRenumberLive phase updates two data structures with the new node IDs.
 449 // (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be
 450 // processed. A new worklist (with the updated node IDs) is returned in &#39;new_worklist&#39;.
 451 // (2) Type information (the field PhaseGVN::_types) maps type information to each
 452 // node ID. The mapping is updated to use the new node IDs as well. Updated type
 453 // information is returned in PhaseGVN::_types.
 454 //
 455 // The PhaseRenumberLive phase does not preserve the order of elements in the worklist.
 456 //
 457 // Other data structures used by the compiler are not updated. The hash table for value
 458 // numbering (the field PhaseGVN::_table) is not updated because computing the hash
 459 // values is not based on node IDs. The field PhaseGVN::_nodes is not updated either
 460 // because it is empty wherever PhaseRenumberLive is used.
 461 PhaseRenumberLive::PhaseRenumberLive(PhaseGVN* gvn,
 462                                      Unique_Node_List* worklist, Unique_Node_List* new_worklist,
 463                                      PhaseNumber phase_num) :
 464   PhaseRemoveUseless(gvn, worklist, Remove_Useless_And_Renumber_Live),
 465   _new_type_array(C-&gt;comp_arena()),
 466   _old2new_map(C-&gt;unique(), C-&gt;unique(), -1),
 467   _delayed(Thread::current()-&gt;resource_area()),
 468   _is_pass_finished(false),
 469   _live_node_count(C-&gt;live_nodes())
 470 {
 471   assert(RenumberLiveNodes, &quot;RenumberLiveNodes must be set to true for node renumbering to take place&quot;);
 472   assert(C-&gt;live_nodes() == _useful.size(), &quot;the number of live nodes must match the number of useful nodes&quot;);
 473   assert(gvn-&gt;nodes_size() == 0, &quot;GVN must not contain any nodes at this point&quot;);
 474   assert(_delayed.size() == 0, &quot;should be empty&quot;);
 475 
 476   uint worklist_size = worklist-&gt;size();
 477 
 478   // Iterate over the set of live nodes.
 479   for (uint current_idx = 0; current_idx &lt; _useful.size(); current_idx++) {
 480     Node* n = _useful.at(current_idx);
 481 
 482     bool in_worklist = false;
 483     if (worklist-&gt;member(n)) {
 484       in_worklist = true;
 485     }
 486 
 487     const Type* type = gvn-&gt;type_or_null(n);
 488     _new_type_array.map(current_idx, type);
 489 
 490     assert(_old2new_map.at(n-&gt;_idx) == -1, &quot;already seen&quot;);
 491     _old2new_map.at_put(n-&gt;_idx, current_idx);
 492 
 493     n-&gt;set_idx(current_idx); // Update node ID.
 494 
 495     if (in_worklist) {
 496       new_worklist-&gt;push(n);
 497     }
 498 
 499     if (update_embedded_ids(n) &lt; 0) {
 500       _delayed.push(n); // has embedded IDs; handle later
 501     }
 502   }
 503 
 504   assert(worklist_size == new_worklist-&gt;size(), &quot;the new worklist must have the same size as the original worklist&quot;);
 505   assert(_live_node_count == _useful.size(), &quot;all live nodes must be processed&quot;);
 506 
 507   _is_pass_finished = true; // pass finished; safe to process delayed updates
 508 
 509   while (_delayed.size() &gt; 0) {
 510     Node* n = _delayed.pop();
 511     int no_of_updates = update_embedded_ids(n);
 512     assert(no_of_updates &gt; 0, &quot;should be updated&quot;);
 513   }
 514 
 515   // Replace the compiler&#39;s type information with the updated type information.
 516   gvn-&gt;replace_types(_new_type_array);
 517 
 518   // Update the unique node count of the compilation to the number of currently live nodes.
 519   C-&gt;set_unique(_live_node_count);
 520 
 521   // Set the dead node count to 0 and reset dead node list.
 522   C-&gt;reset_dead_node_list();
 523 }
 524 
 525 int PhaseRenumberLive::new_index(int old_idx) {
 526   assert(_is_pass_finished, &quot;not finished&quot;);
 527   if (_old2new_map.at(old_idx) == -1) { // absent
 528     // Allocate a placeholder to preserve uniqueness
 529     _old2new_map.at_put(old_idx, _live_node_count);
 530     _live_node_count++;
 531   }
 532   return _old2new_map.at(old_idx);
 533 }
 534 
 535 int PhaseRenumberLive::update_embedded_ids(Node* n) {
 536   int no_of_updates = 0;
 537   if (n-&gt;is_Phi()) {
 538     PhiNode* phi = n-&gt;as_Phi();
 539     if (phi-&gt;_inst_id != -1) {
 540       if (!_is_pass_finished) {
 541         return -1; // delay
 542       }
 543       int new_idx = new_index(phi-&gt;_inst_id);
 544       assert(new_idx != -1, &quot;&quot;);
 545       phi-&gt;_inst_id = new_idx;
 546       no_of_updates++;
 547     }
 548     if (phi-&gt;_inst_mem_id != -1) {
 549       if (!_is_pass_finished) {
 550         return -1; // delay
 551       }
 552       int new_idx = new_index(phi-&gt;_inst_mem_id);
 553       assert(new_idx != -1, &quot;&quot;);
 554       phi-&gt;_inst_mem_id = new_idx;
 555       no_of_updates++;
 556     }
 557   }
 558 
 559   const Type* type = _new_type_array.fast_lookup(n-&gt;_idx);
 560   if (type != NULL &amp;&amp; type-&gt;isa_oopptr() &amp;&amp; type-&gt;is_oopptr()-&gt;is_known_instance()) {
 561     if (!_is_pass_finished) {
 562         return -1; // delay
 563     }
 564     int old_idx = type-&gt;is_oopptr()-&gt;instance_id();
 565     int new_idx = new_index(old_idx);
 566     const Type* new_type = type-&gt;is_oopptr()-&gt;with_instance_id(new_idx);
 567     _new_type_array.map(n-&gt;_idx, new_type);
 568     no_of_updates++;
 569   }
 570 
 571   return no_of_updates;
 572 }
 573 
 574 //=============================================================================
 575 //------------------------------PhaseTransform---------------------------------
 576 PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),
 577   _arena(Thread::current()-&gt;resource_area()),
 578   _nodes(_arena),
 579   _types(_arena)
 580 {
 581   init_con_caches();
 582 #ifndef PRODUCT
 583   clear_progress();
 584   clear_transforms();
 585   set_allow_progress(true);
 586 #endif
 587   // Force allocation for currently existing nodes
 588   _types.map(C-&gt;unique(), NULL);
 589 }
 590 
 591 //------------------------------PhaseTransform---------------------------------
 592 PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),
 593   _arena(arena),
 594   _nodes(arena),
 595   _types(arena)
 596 {
 597   init_con_caches();
 598 #ifndef PRODUCT
 599   clear_progress();
 600   clear_transforms();
 601   set_allow_progress(true);
 602 #endif
 603   // Force allocation for currently existing nodes
 604   _types.map(C-&gt;unique(), NULL);
 605 }
 606 
 607 //------------------------------PhaseTransform---------------------------------
 608 // Initialize with previously generated type information
 609 PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),
 610   _arena(pt-&gt;_arena),
 611   _nodes(pt-&gt;_nodes),
 612   _types(pt-&gt;_types)
 613 {
 614   init_con_caches();
 615 #ifndef PRODUCT
 616   clear_progress();
 617   clear_transforms();
 618   set_allow_progress(true);
 619 #endif
 620 }
 621 
 622 void PhaseTransform::init_con_caches() {
 623   memset(_icons,0,sizeof(_icons));
 624   memset(_lcons,0,sizeof(_lcons));
 625   memset(_zcons,0,sizeof(_zcons));
 626 }
 627 
 628 
 629 //--------------------------------find_int_type--------------------------------
 630 const TypeInt* PhaseTransform::find_int_type(Node* n) {
 631   if (n == NULL)  return NULL;
 632   // Call type_or_null(n) to determine node&#39;s type since we might be in
 633   // parse phase and call n-&gt;Value() may return wrong type.
 634   // (For example, a phi node at the beginning of loop parsing is not ready.)
 635   const Type* t = type_or_null(n);
 636   if (t == NULL)  return NULL;
 637   return t-&gt;isa_int();
 638 }
 639 
 640 
 641 //-------------------------------find_long_type--------------------------------
 642 const TypeLong* PhaseTransform::find_long_type(Node* n) {
 643   if (n == NULL)  return NULL;
 644   // (See comment above on type_or_null.)
 645   const Type* t = type_or_null(n);
 646   if (t == NULL)  return NULL;
 647   return t-&gt;isa_long();
 648 }
 649 
 650 
 651 #ifndef PRODUCT
 652 void PhaseTransform::dump_old2new_map() const {
 653   _nodes.dump();
 654 }
 655 
 656 void PhaseTransform::dump_new( uint nidx ) const {
 657   for( uint i=0; i&lt;_nodes.Size(); i++ )
 658     if( _nodes[i] &amp;&amp; _nodes[i]-&gt;_idx == nidx ) {
 659       _nodes[i]-&gt;dump();
 660       tty-&gt;cr();
 661       tty-&gt;print_cr(&quot;Old index= %d&quot;,i);
 662       return;
 663     }
 664   tty-&gt;print_cr(&quot;Node %d not found in the new indices&quot;, nidx);
 665 }
 666 
 667 //------------------------------dump_types-------------------------------------
 668 void PhaseTransform::dump_types( ) const {
 669   _types.dump();
 670 }
 671 
 672 //------------------------------dump_nodes_and_types---------------------------
 673 void PhaseTransform::dump_nodes_and_types(const Node *root, uint depth, bool only_ctrl) {
 674   VectorSet visited(Thread::current()-&gt;resource_area());
 675   dump_nodes_and_types_recur( root, depth, only_ctrl, visited );
 676 }
 677 
 678 //------------------------------dump_nodes_and_types_recur---------------------
 679 void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &amp;visited) {
 680   if( !n ) return;
 681   if( depth == 0 ) return;
 682   if( visited.test_set(n-&gt;_idx) ) return;
 683   for( uint i=0; i&lt;n-&gt;len(); i++ ) {
 684     if( only_ctrl &amp;&amp; !(n-&gt;is_Region()) &amp;&amp; i != TypeFunc::Control ) continue;
 685     dump_nodes_and_types_recur( n-&gt;in(i), depth-1, only_ctrl, visited );
 686   }
 687   n-&gt;dump();
 688   if (type_or_null(n) != NULL) {
 689     tty-&gt;print(&quot;      &quot;); type(n)-&gt;dump(); tty-&gt;cr();
 690   }
 691 }
 692 
 693 #endif
 694 
 695 
 696 //=============================================================================
 697 //------------------------------PhaseValues------------------------------------
 698 // Set minimum table size to &quot;255&quot;
 699 PhaseValues::PhaseValues( Arena *arena, uint est_max_size ) : PhaseTransform(arena, GVN), _table(arena, est_max_size) {
 700   NOT_PRODUCT( clear_new_values(); )
 701 }
 702 
 703 //------------------------------PhaseValues------------------------------------
 704 // Set minimum table size to &quot;255&quot;
 705 PhaseValues::PhaseValues( PhaseValues *ptv ) : PhaseTransform( ptv, GVN ),
 706   _table(&amp;ptv-&gt;_table) {
 707   NOT_PRODUCT( clear_new_values(); )
 708 }
 709 
 710 //------------------------------PhaseValues------------------------------------
 711 // Used by +VerifyOpto.  Clear out hash table but copy _types array.
 712 PhaseValues::PhaseValues( PhaseValues *ptv, const char *dummy ) : PhaseTransform( ptv, GVN ),
 713   _table(ptv-&gt;arena(),ptv-&gt;_table.size()) {
 714   NOT_PRODUCT( clear_new_values(); )
 715 }
 716 
 717 //------------------------------~PhaseValues-----------------------------------
 718 #ifndef PRODUCT
 719 PhaseValues::~PhaseValues() {
 720   _table.dump();
 721 
 722   // Statistics for value progress and efficiency
 723   if( PrintCompilation &amp;&amp; Verbose &amp;&amp; WizardMode ) {
 724     tty-&gt;print(&quot;\n%sValues: %d nodes ---&gt; %d/%d (%d)&quot;,
 725       is_IterGVN() ? &quot;Iter&quot; : &quot;    &quot;, C-&gt;unique(), made_progress(), made_transforms(), made_new_values());
 726     if( made_transforms() != 0 ) {
 727       tty-&gt;print_cr(&quot;  ratio %f&quot;, made_progress()/(float)made_transforms() );
 728     } else {
 729       tty-&gt;cr();
 730     }
 731   }
 732 }
 733 #endif
 734 
 735 //------------------------------makecon----------------------------------------
 736 ConNode* PhaseTransform::makecon(const Type *t) {
 737   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 738   assert(!t-&gt;empty() || t == Type::TOP, &quot;must not be vacuous range&quot;);
 739   switch (t-&gt;base()) {  // fast paths
 740   case Type::Half:
 741   case Type::Top:  return (ConNode*) C-&gt;top();
 742   case Type::Int:  return intcon( t-&gt;is_int()-&gt;get_con() );
 743   case Type::Long: return longcon( t-&gt;is_long()-&gt;get_con() );
 744   default:         break;
 745   }
 746   if (t-&gt;is_zero_type())
 747     return zerocon(t-&gt;basic_type());
 748   return uncached_makecon(t);
 749 }
 750 
 751 //--------------------------uncached_makecon-----------------------------------
 752 // Make an idealized constant - one of ConINode, ConPNode, etc.
 753 ConNode* PhaseValues::uncached_makecon(const Type *t) {
 754   assert(t-&gt;singleton(), &quot;must be a constant&quot;);
 755   ConNode* x = ConNode::make(t);
 756   ConNode* k = (ConNode*)hash_find_insert(x); // Value numbering
 757   if (k == NULL) {
 758     set_type(x, t);             // Missed, provide type mapping
 759     GrowableArray&lt;Node_Notes*&gt;* nna = C-&gt;node_note_array();
 760     if (nna != NULL) {
 761       Node_Notes* loc = C-&gt;locate_node_notes(nna, x-&gt;_idx, true);
 762       loc-&gt;clear(); // do not put debug info on constants
 763     }
 764   } else {
 765     x-&gt;destruct();              // Hit, destroy duplicate constant
 766     x = k;                      // use existing constant
 767   }
 768   return x;
 769 }
 770 
 771 //------------------------------intcon-----------------------------------------
 772 // Fast integer constant.  Same as &quot;transform(new ConINode(TypeInt::make(i)))&quot;
 773 ConINode* PhaseTransform::intcon(jint i) {
 774   // Small integer?  Check cache! Check that cached node is not dead
 775   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max) {
 776     ConINode* icon = _icons[i-_icon_min];
 777     if (icon != NULL &amp;&amp; icon-&gt;in(TypeFunc::Control) != NULL)
 778       return icon;
 779   }
 780   ConINode* icon = (ConINode*) uncached_makecon(TypeInt::make(i));
 781   assert(icon-&gt;is_Con(), &quot;&quot;);
 782   if (i &gt;= _icon_min &amp;&amp; i &lt;= _icon_max)
 783     _icons[i-_icon_min] = icon;   // Cache small integers
 784   return icon;
 785 }
 786 
 787 //------------------------------longcon----------------------------------------
 788 // Fast long constant.
 789 ConLNode* PhaseTransform::longcon(jlong l) {
 790   // Small integer?  Check cache! Check that cached node is not dead
 791   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max) {
 792     ConLNode* lcon = _lcons[l-_lcon_min];
 793     if (lcon != NULL &amp;&amp; lcon-&gt;in(TypeFunc::Control) != NULL)
 794       return lcon;
 795   }
 796   ConLNode* lcon = (ConLNode*) uncached_makecon(TypeLong::make(l));
 797   assert(lcon-&gt;is_Con(), &quot;&quot;);
 798   if (l &gt;= _lcon_min &amp;&amp; l &lt;= _lcon_max)
 799     _lcons[l-_lcon_min] = lcon;      // Cache small integers
 800   return lcon;
 801 }
 802 
 803 //------------------------------zerocon-----------------------------------------
 804 // Fast zero or null constant. Same as &quot;transform(ConNode::make(Type::get_zero_type(bt)))&quot;
 805 ConNode* PhaseTransform::zerocon(BasicType bt) {
 806   assert((uint)bt &lt;= _zcon_max, &quot;domain check&quot;);
 807   ConNode* zcon = _zcons[bt];
 808   if (zcon != NULL &amp;&amp; zcon-&gt;in(TypeFunc::Control) != NULL)
 809     return zcon;
 810   zcon = (ConNode*) uncached_makecon(Type::get_zero_type(bt));
 811   _zcons[bt] = zcon;
 812   return zcon;
 813 }
 814 
 815 
 816 
 817 //=============================================================================
 818 Node* PhaseGVN::apply_ideal(Node* k, bool can_reshape) {
 819   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ideal_node(this, k, can_reshape);
 820   if (i == NULL) {
 821     i = k-&gt;Ideal(this, can_reshape);
 822   }
 823   return i;
 824 }
 825 
 826 Node* PhaseGVN::apply_identity(Node* k) {
 827   Node* i = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;identity_node(this, k);
 828   if (i == k) {
 829     i = k-&gt;Identity(this);
 830   }
 831   return i;
 832 }
 833 
 834 //------------------------------transform--------------------------------------
 835 // Return a node which computes the same function as this node, but in a
 836 // faster or cheaper fashion.
 837 Node *PhaseGVN::transform( Node *n ) {
 838   return transform_no_reclaim(n);
 839 }
 840 
 841 //------------------------------transform--------------------------------------
 842 // Return a node which computes the same function as this node, but
 843 // in a faster or cheaper fashion.
 844 Node *PhaseGVN::transform_no_reclaim( Node *n ) {
 845   NOT_PRODUCT( set_transforms(); )
 846 
 847   // Apply the Ideal call in a loop until it no longer applies
 848   Node *k = n;
 849   NOT_PRODUCT( uint loop_count = 0; )
 850   while( 1 ) {
 851     Node *i = apply_ideal(k, /*can_reshape=*/false);
 852     if( !i ) break;
 853     assert( i-&gt;_idx &gt;= k-&gt;_idx, &quot;Idealize should return new nodes, use Identity to return old nodes&quot; );
 854     k = i;
 855     assert(loop_count++ &lt; K, &quot;infinite loop in PhaseGVN::transform&quot;);
 856   }
 857   NOT_PRODUCT( if( loop_count != 0 ) { set_progress(); } )
 858 
 859 
 860   // If brand new node, make space in type array.
 861   ensure_type_or_null(k);
 862 
 863   // Since I just called &#39;Value&#39; to compute the set of run-time values
 864   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
 865   // cache Value.  Later requests for the local phase-&gt;type of this Node can
 866   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
 867   const Type *t = k-&gt;Value(this); // Get runtime Value set
 868   assert(t != NULL, &quot;value sanity&quot;);
 869   if (type_or_null(k) != t) {
 870 #ifndef PRODUCT
 871     // Do not count initial visit to node as a transformation
 872     if (type_or_null(k) == NULL) {
 873       inc_new_values();
 874       set_progress();
 875     }
 876 #endif
 877     set_type(k, t);
 878     // If k is a TypeNode, capture any more-precise type permanently into Node
 879     k-&gt;raise_bottom_type(t);
 880   }
 881 
 882   if( t-&gt;singleton() &amp;&amp; !k-&gt;is_Con() ) {
 883     NOT_PRODUCT( set_progress(); )
 884     return makecon(t);          // Turn into a constant
 885   }
 886 
 887   // Now check for Identities
 888   Node *i = apply_identity(k);  // Look for a nearby replacement
 889   if( i != k ) {                // Found? Return replacement!
 890     NOT_PRODUCT( set_progress(); )
 891     return i;
 892   }
 893 
 894   // Global Value Numbering
 895   i = hash_find_insert(k);      // Insert if new
 896   if( i &amp;&amp; (i != k) ) {
 897     // Return the pre-existing node
 898     NOT_PRODUCT( set_progress(); )
 899     return i;
 900   }
 901 
 902   // Return Idealized original
 903   return k;
 904 }
 905 
 906 bool PhaseGVN::is_dominator_helper(Node *d, Node *n, bool linear_only) {
 907   if (d-&gt;is_top() || n-&gt;is_top()) {
 908     return false;
 909   }
 910   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
 911   int i = 0;
 912   while (d != n) {
 913     n = IfNode::up_one_dom(n, linear_only);
 914     i++;
 915     if (n == NULL || i &gt;= 10) {
 916       return false;
 917     }
 918   }
 919   return true;
 920 }
 921 
 922 #ifdef ASSERT
 923 //------------------------------dead_loop_check--------------------------------
 924 // Check for a simple dead loop when a data node references itself directly
 925 // or through an other data node excluding cons and phis.
 926 void PhaseGVN::dead_loop_check( Node *n ) {
 927   // Phi may reference itself in a loop
 928   if (n != NULL &amp;&amp; !n-&gt;is_dead_loop_safe() &amp;&amp; !n-&gt;is_CFG()) {
 929     // Do 2 levels check and only data inputs.
 930     bool no_dead_loop = true;
 931     uint cnt = n-&gt;req();
 932     for (uint i = 1; i &lt; cnt &amp;&amp; no_dead_loop; i++) {
 933       Node *in = n-&gt;in(i);
 934       if (in == n) {
 935         no_dead_loop = false;
 936       } else if (in != NULL &amp;&amp; !in-&gt;is_dead_loop_safe()) {
 937         uint icnt = in-&gt;req();
 938         for (uint j = 1; j &lt; icnt &amp;&amp; no_dead_loop; j++) {
 939           if (in-&gt;in(j) == n || in-&gt;in(j) == in)
 940             no_dead_loop = false;
 941         }
 942       }
 943     }
 944     if (!no_dead_loop) n-&gt;dump(3);
 945     assert(no_dead_loop, &quot;dead loop detected&quot;);
 946   }
 947 }
 948 #endif
 949 
 950 //=============================================================================
 951 //------------------------------PhaseIterGVN-----------------------------------
 952 // Initialize hash table to fresh and clean for +VerifyOpto
 953 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ) : PhaseGVN(igvn,dummy),
 954                                                                       _delay_transform(false),
 955                                                                       _stack(C-&gt;live_nodes() &gt;&gt; 1),
 956                                                                       _worklist( ) {
 957 }
 958 
 959 //------------------------------PhaseIterGVN-----------------------------------
 960 // Initialize with previous PhaseIterGVN info; used by PhaseCCP
 961 PhaseIterGVN::PhaseIterGVN( PhaseIterGVN *igvn ) : PhaseGVN(igvn),
 962                                                    _delay_transform(igvn-&gt;_delay_transform),
 963                                                    _stack( igvn-&gt;_stack ),
 964                                                    _worklist( igvn-&gt;_worklist )
 965 {
 966 }
 967 
 968 //------------------------------PhaseIterGVN-----------------------------------
 969 // Initialize with previous PhaseGVN info from Parser
 970 PhaseIterGVN::PhaseIterGVN( PhaseGVN *gvn ) : PhaseGVN(gvn),
 971                                               _delay_transform(false),
 972 // TODO: Before incremental inlining it was allocated only once and it was fine. Now that
 973 //       the constructor is used in incremental inlining, this consumes too much memory:
 974 //                                            _stack(C-&gt;live_nodes() &gt;&gt; 1),
 975 //       So, as a band-aid, we replace this by:
 976                                               _stack(C-&gt;comp_arena(), 32),
 977                                               _worklist(*C-&gt;for_igvn())
 978 {
 979   uint max;
 980 
 981   // Dead nodes in the hash table inherited from GVN were not treated as
 982   // roots during def-use info creation; hence they represent an invisible
 983   // use.  Clear them out.
 984   max = _table.size();
 985   for( uint i = 0; i &lt; max; ++i ) {
 986     Node *n = _table.at(i);
 987     if(n != NULL &amp;&amp; n != _table.sentinel() &amp;&amp; n-&gt;outcnt() == 0) {
 988       if( n-&gt;is_top() ) continue;
 989       assert( false, &quot;Parse::remove_useless_nodes missed this node&quot;);
 990       hash_delete(n);
 991     }
 992   }
 993 
 994   // Any Phis or Regions on the worklist probably had uses that could not
 995   // make more progress because the uses were made while the Phis and Regions
 996   // were in half-built states.  Put all uses of Phis and Regions on worklist.
 997   max = _worklist.size();
 998   for( uint j = 0; j &lt; max; j++ ) {
 999     Node *n = _worklist.at(j);
1000     uint uop = n-&gt;Opcode();
1001     if( uop == Op_Phi || uop == Op_Region ||
1002         n-&gt;is_Type() ||
1003         n-&gt;is_Mem() )
1004       add_users_to_worklist(n);
1005   }
1006 
1007   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1008   bs-&gt;add_users_to_worklist(&amp;_worklist);
1009 }
1010 
1011 /**
1012  * Initialize worklist for each node.
1013  */
1014 void PhaseIterGVN::init_worklist(Node* first) {
1015   Unique_Node_List to_process;
1016   to_process.push(first);
1017 
1018   while (to_process.size() &gt; 0) {
1019     Node* n = to_process.pop();
1020     if (!_worklist.member(n)) {
1021       _worklist.push(n);
1022 
1023       uint cnt = n-&gt;req();
1024       for(uint i = 0; i &lt; cnt; i++) {
1025         Node* m = n-&gt;in(i);
1026         if (m != NULL) {
1027           to_process.push(m);
1028         }
1029       }
1030     }
1031   }
1032 }
1033 
1034 #ifndef PRODUCT
1035 void PhaseIterGVN::verify_step(Node* n) {
1036   if (VerifyIterativeGVN) {
1037     _verify_window[_verify_counter % _verify_window_size] = n;
1038     ++_verify_counter;
1039     ResourceMark rm;
1040     ResourceArea* area = Thread::current()-&gt;resource_area();
1041     VectorSet old_space(area), new_space(area);
1042     if (C-&gt;unique() &lt; 1000 ||
1043         0 == _verify_counter % (C-&gt;unique() &lt; 10000 ? 10 : 100)) {
1044       ++_verify_full_passes;
1045       Node::verify_recur(C-&gt;root(), -1, old_space, new_space);
1046     }
1047     const int verify_depth = 4;
1048     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1049       Node* n = _verify_window[i];
1050       if ( n == NULL )  continue;
1051       if( n-&gt;in(0) == NodeSentinel ) {  // xform_idom
1052         _verify_window[i] = n-&gt;in(1);
1053         --i; continue;
1054       }
1055       // Typical fanout is 1-2, so this call visits about 6 nodes.
1056       Node::verify_recur(n, verify_depth, old_space, new_space);
1057     }
1058   }
1059 }
1060 
1061 void PhaseIterGVN::trace_PhaseIterGVN(Node* n, Node* nn, const Type* oldtype) {
1062   if (TraceIterativeGVN) {
1063     uint wlsize = _worklist.size();
1064     const Type* newtype = type_or_null(n);
1065     if (nn != n) {
1066       // print old node
1067       tty-&gt;print(&quot;&lt; &quot;);
1068       if (oldtype != newtype &amp;&amp; oldtype != NULL) {
1069         oldtype-&gt;dump();
1070       }
1071       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1072       tty-&gt;print(&quot;&lt;&quot;);
1073       n-&gt;dump();
1074     }
1075     if (oldtype != newtype || nn != n) {
1076       // print new node and/or new type
1077       if (oldtype == NULL) {
1078         tty-&gt;print(&quot;* &quot;);
1079       } else if (nn != n) {
1080         tty-&gt;print(&quot;&gt; &quot;);
1081       } else {
1082         tty-&gt;print(&quot;= &quot;);
1083       }
1084       if (newtype == NULL) {
1085         tty-&gt;print(&quot;null&quot;);
1086       } else {
1087         newtype-&gt;dump();
1088       }
1089       do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1090       nn-&gt;dump();
1091     }
1092     if (Verbose &amp;&amp; wlsize &lt; _worklist.size()) {
1093       tty-&gt;print(&quot;  Push {&quot;);
1094       while (wlsize != _worklist.size()) {
1095         Node* pushed = _worklist.at(wlsize++);
1096         tty-&gt;print(&quot; %d&quot;, pushed-&gt;_idx);
1097       }
1098       tty-&gt;print_cr(&quot; }&quot;);
1099     }
1100     if (nn != n) {
1101       // ignore n, it might be subsumed
1102       verify_step((Node*) NULL);
1103     }
1104   }
1105 }
1106 
1107 void PhaseIterGVN::init_verifyPhaseIterGVN() {
1108   _verify_counter = 0;
1109   _verify_full_passes = 0;
1110   for (int i = 0; i &lt; _verify_window_size; i++) {
1111     _verify_window[i] = NULL;
1112   }
1113 #ifdef ASSERT
1114   // Verify that all modified nodes are on _worklist
1115   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1116   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1117     Node* n = modified_list-&gt;pop();
1118     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con() &amp;&amp; !_worklist.member(n)) {
1119       n-&gt;dump();
1120       assert(false, &quot;modified node is not on IGVN._worklist&quot;);
1121     }
1122   }
1123 #endif
1124 }
1125 
1126 void PhaseIterGVN::verify_PhaseIterGVN() {
1127 #ifdef ASSERT
1128   // Verify nodes with changed inputs.
1129   Unique_Node_List* modified_list = C-&gt;modified_nodes();
1130   while (modified_list != NULL &amp;&amp; modified_list-&gt;size()) {
1131     Node* n = modified_list-&gt;pop();
1132     if (n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) { // skip dead and Con nodes
1133       n-&gt;dump();
1134       assert(false, &quot;modified node was not processed by IGVN.transform_old()&quot;);
1135     }
1136   }
1137 #endif
1138 
1139   C-&gt;verify_graph_edges();
1140   if( VerifyOpto &amp;&amp; allow_progress() ) {
1141     // Must turn off allow_progress to enable assert and break recursion
1142     C-&gt;root()-&gt;verify();
1143     { // Check if any progress was missed using IterGVN
1144       // Def-Use info enables transformations not attempted in wash-pass
1145       // e.g. Region/Phi cleanup, ...
1146       // Null-check elision -- may not have reached fixpoint
1147       //                       do not propagate to dominated nodes
1148       ResourceMark rm;
1149       PhaseIterGVN igvn2(this,&quot;Verify&quot;); // Fresh and clean!
1150       // Fill worklist completely
1151       igvn2.init_worklist(C-&gt;root());
1152 
1153       igvn2.set_allow_progress(false);
1154       igvn2.optimize();
1155       igvn2.set_allow_progress(true);
1156     }
1157   }
1158   if (VerifyIterativeGVN &amp;&amp; PrintOpto) {
1159     if (_verify_counter == _verify_full_passes) {
1160       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms and verify passes&quot;,
1161                     (int) _verify_full_passes);
1162     } else {
1163       tty-&gt;print_cr(&quot;VerifyIterativeGVN: %d transforms, %d full verify passes&quot;,
1164                   (int) _verify_counter, (int) _verify_full_passes);
1165     }
1166   }
1167 
1168 #ifdef ASSERT
1169   while (modified_list-&gt;size()) {
1170     Node* n = modified_list-&gt;pop();
1171     n-&gt;dump();
1172     assert(false, &quot;VerifyIterativeGVN: new modified node was added&quot;);
1173   }
1174 #endif
1175 }
1176 #endif /* PRODUCT */
1177 
1178 #ifdef ASSERT
1179 /**
1180  * Dumps information that can help to debug the problem. A debug
1181  * build fails with an assert.
1182  */
1183 void PhaseIterGVN::dump_infinite_loop_info(Node* n) {
1184   n-&gt;dump(4);
1185   _worklist.dump();
1186   assert(false, &quot;infinite loop in PhaseIterGVN::optimize&quot;);
1187 }
1188 
1189 /**
1190  * Prints out information about IGVN if the &#39;verbose&#39; option is used.
1191  */
1192 void PhaseIterGVN::trace_PhaseIterGVN_verbose(Node* n, int num_processed) {
1193   if (TraceIterativeGVN &amp;&amp; Verbose) {
1194     tty-&gt;print(&quot;  Pop &quot;);
1195     n-&gt;dump();
1196     if ((num_processed % 100) == 0) {
1197       _worklist.print_set();
1198     }
1199   }
1200 }
1201 #endif /* ASSERT */
1202 
1203 void PhaseIterGVN::optimize() {
1204   DEBUG_ONLY(uint num_processed  = 0;)
1205   NOT_PRODUCT(init_verifyPhaseIterGVN();)
1206 
1207   uint loop_count = 0;
1208   // Pull from worklist and transform the node. If the node has changed,
1209   // update edge info and put uses on worklist.
1210   while(_worklist.size()) {
1211     if (C-&gt;check_node_count(NodeLimitFudgeFactor * 2, &quot;Out of nodes&quot;)) {
1212       return;
1213     }
1214     Node* n  = _worklist.pop();
1215     if (++loop_count &gt;= K * C-&gt;live_nodes()) {
1216       DEBUG_ONLY(dump_infinite_loop_info(n);)
1217       C-&gt;record_method_not_compilable(&quot;infinite loop in PhaseIterGVN::optimize&quot;);
1218       return;
1219     }
1220     DEBUG_ONLY(trace_PhaseIterGVN_verbose(n, num_processed++);)
1221     if (n-&gt;outcnt() != 0) {
1222       NOT_PRODUCT(const Type* oldtype = type_or_null(n));
1223       // Do the transformation
1224       Node* nn = transform_old(n);
1225       NOT_PRODUCT(trace_PhaseIterGVN(n, nn, oldtype);)
1226     } else if (!n-&gt;is_top()) {
1227       remove_dead_node(n);
1228     }
1229   }
1230   NOT_PRODUCT(verify_PhaseIterGVN();)
1231 }
1232 
1233 
1234 /**
1235  * Register a new node with the optimizer.  Update the types array, the def-use
1236  * info.  Put on worklist.
1237  */
1238 Node* PhaseIterGVN::register_new_node_with_optimizer(Node* n, Node* orig) {
1239   set_type_bottom(n);
1240   _worklist.push(n);
1241   if (orig != NULL)  C-&gt;copy_node_notes_to(n, orig);
1242   return n;
1243 }
1244 
1245 //------------------------------transform--------------------------------------
1246 // Non-recursive: idealize Node &#39;n&#39; with respect to its inputs and its value
1247 Node *PhaseIterGVN::transform( Node *n ) {
1248   if (_delay_transform) {
1249     // Register the node but don&#39;t optimize for now
1250     register_new_node_with_optimizer(n);
1251     return n;
1252   }
1253 
1254   // If brand new node, make space in type array, and give it a type.
1255   ensure_type_or_null(n);
1256   if (type_or_null(n) == NULL) {
1257     set_type_bottom(n);
1258   }
1259 
1260   return transform_old(n);
1261 }
1262 
1263 Node *PhaseIterGVN::transform_old(Node* n) {
1264   DEBUG_ONLY(uint loop_count = 0;);
1265   NOT_PRODUCT(set_transforms());
1266 
1267   // Remove &#39;n&#39; from hash table in case it gets modified
1268   _table.hash_delete(n);
1269   if (VerifyIterativeGVN) {
1270    assert(!_table.find_index(n-&gt;_idx), &quot;found duplicate entry in table&quot;);
1271   }
1272 
1273   // Apply the Ideal call in a loop until it no longer applies
1274   Node* k = n;
1275   DEBUG_ONLY(dead_loop_check(k);)
1276   DEBUG_ONLY(bool is_new = (k-&gt;outcnt() == 0);)
1277   C-&gt;remove_modified_node(k);
1278   Node* i = apply_ideal(k, /*can_reshape=*/true);
1279   assert(i != k || is_new || i-&gt;outcnt() &gt; 0, &quot;don&#39;t return dead nodes&quot;);
1280 #ifndef PRODUCT
1281   verify_step(k);
1282   if (i &amp;&amp; VerifyOpto ) {
1283     if (!allow_progress()) {
1284       if (i-&gt;is_Add() &amp;&amp; (i-&gt;outcnt() == 1)) {
1285         // Switched input to left side because this is the only use
1286       } else if (i-&gt;is_If() &amp;&amp; (i-&gt;in(0) == NULL)) {
1287         // This IF is dead because it is dominated by an equivalent IF When
1288         // dominating if changed, info is not propagated sparsely to &#39;this&#39;
1289         // Propagating this info further will spuriously identify other
1290         // progress.
1291         return i;
1292       } else
1293         set_progress();
1294     } else {
1295       set_progress();
1296     }
1297   }
1298 #endif
1299 
1300   while (i != NULL) {
1301 #ifdef ASSERT
1302     if (loop_count &gt;= K) {
1303       dump_infinite_loop_info(i);
1304     }
1305     loop_count++;
1306 #endif
1307     assert((i-&gt;_idx &gt;= k-&gt;_idx) || i-&gt;is_top(), &quot;Idealize should return new nodes, use Identity to return old nodes&quot;);
1308     // Made a change; put users of original Node on worklist
1309     add_users_to_worklist(k);
1310     // Replacing root of transform tree?
1311     if (k != i) {
1312       // Make users of old Node now use new.
1313       subsume_node(k, i);
1314       k = i;
1315     }
1316     DEBUG_ONLY(dead_loop_check(k);)
1317     // Try idealizing again
1318     DEBUG_ONLY(is_new = (k-&gt;outcnt() == 0);)
1319     C-&gt;remove_modified_node(k);
1320     i = apply_ideal(k, /*can_reshape=*/true);
1321     assert(i != k || is_new || (i-&gt;outcnt() &gt; 0), &quot;don&#39;t return dead nodes&quot;);
1322 #ifndef PRODUCT
1323     verify_step(k);
1324     if (i &amp;&amp; VerifyOpto) {
1325       set_progress();
1326     }
1327 #endif
1328   }
1329 
1330   // If brand new node, make space in type array.
1331   ensure_type_or_null(k);
1332 
1333   // See what kind of values &#39;k&#39; takes on at runtime
1334   const Type* t = k-&gt;Value(this);
1335   assert(t != NULL, &quot;value sanity&quot;);
1336 
1337   // Since I just called &#39;Value&#39; to compute the set of run-time values
1338   // for this Node, and &#39;Value&#39; is non-local (and therefore expensive) I&#39;ll
1339   // cache Value.  Later requests for the local phase-&gt;type of this Node can
1340   // use the cached Value instead of suffering with &#39;bottom_type&#39;.
1341   if (type_or_null(k) != t) {
1342 #ifndef PRODUCT
1343     inc_new_values();
1344     set_progress();
1345 #endif
1346     set_type(k, t);
1347     // If k is a TypeNode, capture any more-precise type permanently into Node
1348     k-&gt;raise_bottom_type(t);
1349     // Move users of node to worklist
1350     add_users_to_worklist(k);
1351   }
1352   // If &#39;k&#39; computes a constant, replace it with a constant
1353   if (t-&gt;singleton() &amp;&amp; !k-&gt;is_Con()) {
1354     NOT_PRODUCT(set_progress();)
1355     Node* con = makecon(t);     // Make a constant
1356     add_users_to_worklist(k);
1357     subsume_node(k, con);       // Everybody using k now uses con
1358     return con;
1359   }
1360 
1361   // Now check for Identities
1362   i = apply_identity(k);      // Look for a nearby replacement
1363   if (i != k) {                // Found? Return replacement!
1364     NOT_PRODUCT(set_progress();)
1365     add_users_to_worklist(k);
1366     subsume_node(k, i);       // Everybody using k now uses i
1367     return i;
1368   }
1369 
1370   // Global Value Numbering
1371   i = hash_find_insert(k);      // Check for pre-existing node
1372   if (i &amp;&amp; (i != k)) {
1373     // Return the pre-existing node if it isn&#39;t dead
1374     NOT_PRODUCT(set_progress();)
1375     add_users_to_worklist(k);
1376     subsume_node(k, i);       // Everybody using k now uses i
1377     return i;
1378   }
1379 
1380   // Return Idealized original
1381   return k;
1382 }
1383 
1384 //---------------------------------saturate------------------------------------
1385 const Type* PhaseIterGVN::saturate(const Type* new_type, const Type* old_type,
1386                                    const Type* limit_type) const {
1387   return new_type-&gt;narrow(old_type);
1388 }
1389 
1390 //------------------------------remove_globally_dead_node----------------------
1391 // Kill a globally dead Node.  All uses are also globally dead and are
1392 // aggressively trimmed.
1393 void PhaseIterGVN::remove_globally_dead_node( Node *dead ) {
1394   enum DeleteProgress {
1395     PROCESS_INPUTS,
1396     PROCESS_OUTPUTS
1397   };
1398   assert(_stack.is_empty(), &quot;not empty&quot;);
1399   _stack.push(dead, PROCESS_INPUTS);
1400 
1401   while (_stack.is_nonempty()) {
1402     dead = _stack.node();
1403     if (dead-&gt;Opcode() == Op_SafePoint) {
1404       dead-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1405     }
1406     uint progress_state = _stack.index();
1407     assert(dead != C-&gt;root(), &quot;killing root, eh?&quot;);
1408     assert(!dead-&gt;is_top(), &quot;add check for top when pushing&quot;);
1409     NOT_PRODUCT( set_progress(); )
1410     if (progress_state == PROCESS_INPUTS) {
1411       // After following inputs, continue to outputs
1412       _stack.set_index(PROCESS_OUTPUTS);
1413       if (!dead-&gt;is_Con()) { // Don&#39;t kill cons but uses
1414         bool recurse = false;
1415         // Remove from hash table
1416         _table.hash_delete( dead );
1417         // Smash all inputs to &#39;dead&#39;, isolating him completely
1418         for (uint i = 0; i &lt; dead-&gt;req(); i++) {
1419           Node *in = dead-&gt;in(i);
1420           if (in != NULL &amp;&amp; in != C-&gt;top()) {  // Points to something?
1421             int nrep = dead-&gt;replace_edge(in, NULL);  // Kill edges
1422             assert((nrep &gt; 0), &quot;sanity&quot;);
1423             if (in-&gt;outcnt() == 0) { // Made input go dead?
1424               _stack.push(in, PROCESS_INPUTS); // Recursively remove
1425               recurse = true;
1426             } else if (in-&gt;outcnt() == 1 &amp;&amp;
1427                        in-&gt;has_special_unique_user()) {
1428               _worklist.push(in-&gt;unique_out());
1429             } else if (in-&gt;outcnt() &lt;= 2 &amp;&amp; dead-&gt;is_Phi()) {
1430               if (in-&gt;Opcode() == Op_Region) {
1431                 _worklist.push(in);
1432               } else if (in-&gt;is_Store()) {
1433                 DUIterator_Fast imax, i = in-&gt;fast_outs(imax);
1434                 _worklist.push(in-&gt;fast_out(i));
1435                 i++;
1436                 if (in-&gt;outcnt() == 2) {
1437                   _worklist.push(in-&gt;fast_out(i));
1438                   i++;
1439                 }
1440                 assert(!(i &lt; imax), &quot;sanity&quot;);
1441               }
1442             } else {
1443               BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(this, in);
1444             }
1445             if (ReduceFieldZeroing &amp;&amp; dead-&gt;is_Load() &amp;&amp; i == MemNode::Memory &amp;&amp;
1446                 in-&gt;is_Proj() &amp;&amp; in-&gt;in(0) != NULL &amp;&amp; in-&gt;in(0)-&gt;is_Initialize()) {
1447               // A Load that directly follows an InitializeNode is
1448               // going away. The Stores that follow are candidates
1449               // again to be captured by the InitializeNode.
1450               for (DUIterator_Fast jmax, j = in-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1451                 Node *n = in-&gt;fast_out(j);
1452                 if (n-&gt;is_Store()) {
1453                   _worklist.push(n);
1454                 }
1455               }
1456             }
1457           } // if (in != NULL &amp;&amp; in != C-&gt;top())
1458         } // for (uint i = 0; i &lt; dead-&gt;req(); i++)
1459         if (recurse) {
1460           continue;
1461         }
1462       } // if (!dead-&gt;is_Con())
1463     } // if (progress_state == PROCESS_INPUTS)
1464 
1465     // Aggressively kill globally dead uses
1466     // (Rather than pushing all the outs at once, we push one at a time,
1467     // plus the parent to resume later, because of the indefinite number
1468     // of edge deletions per loop trip.)
1469     if (dead-&gt;outcnt() &gt; 0) {
1470       // Recursively remove output edges
1471       _stack.push(dead-&gt;raw_out(0), PROCESS_INPUTS);
1472     } else {
1473       // Finished disconnecting all input and output edges.
1474       _stack.pop();
1475       // Remove dead node from iterative worklist
1476       _worklist.remove(dead);
1477       C-&gt;remove_modified_node(dead);
1478       // Constant node that has no out-edges and has only one in-edge from
1479       // root is usually dead. However, sometimes reshaping walk makes
1480       // it reachable by adding use edges. So, we will NOT count Con nodes
1481       // as dead to be conservative about the dead node count at any
1482       // given time.
1483       if (!dead-&gt;is_Con()) {
1484         C-&gt;record_dead_node(dead-&gt;_idx);
1485       }
1486       if (dead-&gt;is_macro()) {
1487         C-&gt;remove_macro_node(dead);
1488       }
1489       if (dead-&gt;is_expensive()) {
1490         C-&gt;remove_expensive_node(dead);
1491       }
1492       CastIINode* cast = dead-&gt;isa_CastII();
1493       if (cast != NULL &amp;&amp; cast-&gt;has_range_check()) {
1494         C-&gt;remove_range_check_cast(cast);
1495       }
1496       if (dead-&gt;Opcode() == Op_Opaque4) {
1497         C-&gt;remove_opaque4_node(dead);
1498       }
1499       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1500       bs-&gt;unregister_potential_barrier_node(dead);
1501     }
1502   } // while (_stack.is_nonempty())
1503 }
1504 
1505 //------------------------------subsume_node-----------------------------------
1506 // Remove users from node &#39;old&#39; and add them to node &#39;nn&#39;.
1507 void PhaseIterGVN::subsume_node( Node *old, Node *nn ) {
1508   if (old-&gt;Opcode() == Op_SafePoint) {
1509     old-&gt;as_SafePoint()-&gt;disconnect_from_root(this);
1510   }
1511   assert( old != hash_find(old), &quot;should already been removed&quot; );
1512   assert( old != C-&gt;top(), &quot;cannot subsume top node&quot;);
1513   // Copy debug or profile information to the new version:
1514   C-&gt;copy_node_notes_to(nn, old);
1515   // Move users of node &#39;old&#39; to node &#39;nn&#39;
1516   for (DUIterator_Last imin, i = old-&gt;last_outs(imin); i &gt;= imin; ) {
1517     Node* use = old-&gt;last_out(i);  // for each use...
1518     // use might need re-hashing (but it won&#39;t if it&#39;s a new node)
1519     rehash_node_delayed(use);
1520     // Update use-def info as well
1521     // We remove all occurrences of old within use-&gt;in,
1522     // so as to avoid rehashing any node more than once.
1523     // The hash table probe swamps any outer loop overhead.
1524     uint num_edges = 0;
1525     for (uint jmax = use-&gt;len(), j = 0; j &lt; jmax; j++) {
1526       if (use-&gt;in(j) == old) {
1527         use-&gt;set_req(j, nn);
1528         ++num_edges;
1529       }
1530     }
1531     i -= num_edges;    // we deleted 1 or more copies of this edge
1532   }
1533 
1534   // Search for instance field data PhiNodes in the same region pointing to the old
1535   // memory PhiNode and update their instance memory ids to point to the new node.
1536   if (old-&gt;is_Phi() &amp;&amp; old-&gt;as_Phi()-&gt;type()-&gt;has_memory() &amp;&amp; old-&gt;in(0) != NULL) {
1537     Node* region = old-&gt;in(0);
1538     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
1539       PhiNode* phi = region-&gt;fast_out(i)-&gt;isa_Phi();
1540       if (phi != NULL &amp;&amp; phi-&gt;inst_mem_id() == (int)old-&gt;_idx) {
1541         phi-&gt;set_inst_mem_id((int)nn-&gt;_idx);
1542       }
1543     }
1544   }
1545 
1546   // Smash all inputs to &#39;old&#39;, isolating him completely
1547   Node *temp = new Node(1);
1548   temp-&gt;init_req(0,nn);     // Add a use to nn to prevent him from dying
1549   remove_dead_node( old );
1550   temp-&gt;del_req(0);         // Yank bogus edge
1551 #ifndef PRODUCT
1552   if( VerifyIterativeGVN ) {
1553     for ( int i = 0; i &lt; _verify_window_size; i++ ) {
1554       if ( _verify_window[i] == old )
1555         _verify_window[i] = nn;
1556     }
1557   }
1558 #endif
1559   _worklist.remove(temp);   // this can be necessary
1560   temp-&gt;destruct();         // reuse the _idx of this little guy
1561 }
1562 
1563 //------------------------------add_users_to_worklist--------------------------
1564 void PhaseIterGVN::add_users_to_worklist0( Node *n ) {
1565   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1566     _worklist.push(n-&gt;fast_out(i));  // Push on worklist
1567   }
1568 }
1569 
1570 // Return counted loop Phi if as a counted loop exit condition, cmp
1571 // compares the the induction variable with n
1572 static PhiNode* countedloop_phi_from_cmp(CmpINode* cmp, Node* n) {
1573   for (DUIterator_Fast imax, i = cmp-&gt;fast_outs(imax); i &lt; imax; i++) {
1574     Node* bol = cmp-&gt;fast_out(i);
1575     for (DUIterator_Fast i2max, i2 = bol-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1576       Node* iff = bol-&gt;fast_out(i2);
1577       if (iff-&gt;is_CountedLoopEnd()) {
1578         CountedLoopEndNode* cle = iff-&gt;as_CountedLoopEnd();
1579         if (cle-&gt;limit() == n) {
1580           PhiNode* phi = cle-&gt;phi();
1581           if (phi != NULL) {
1582             return phi;
1583           }
1584         }
1585       }
1586     }
1587   }
1588   return NULL;
1589 }
1590 
1591 void PhaseIterGVN::add_users_to_worklist( Node *n ) {
1592   add_users_to_worklist0(n);
1593 
1594   // Move users of node to worklist
1595   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1596     Node* use = n-&gt;fast_out(i); // Get use
1597 
1598     if( use-&gt;is_Multi() ||      // Multi-definer?  Push projs on worklist
1599         use-&gt;is_Store() )       // Enable store/load same address
1600       add_users_to_worklist0(use);
1601 
1602     // If we changed the receiver type to a call, we need to revisit
1603     // the Catch following the call.  It&#39;s looking for a non-NULL
1604     // receiver to know when to enable the regular fall-through path
1605     // in addition to the NullPtrException path.
1606     if (use-&gt;is_CallDynamicJava() &amp;&amp; n == use-&gt;in(TypeFunc::Parms)) {
1607       Node* p = use-&gt;as_CallDynamicJava()-&gt;proj_out_or_null(TypeFunc::Control);
1608       if (p != NULL) {
1609         add_users_to_worklist0(p);
1610       }
1611     }
1612 
1613     uint use_op = use-&gt;Opcode();
1614     if(use-&gt;is_Cmp()) {       // Enable CMP/BOOL optimization
1615       add_users_to_worklist(use); // Put Bool on worklist
1616       if (use-&gt;outcnt() &gt; 0) {
1617         Node* bol = use-&gt;raw_out(0);
1618         if (bol-&gt;outcnt() &gt; 0) {
1619           Node* iff = bol-&gt;raw_out(0);
1620           if (iff-&gt;outcnt() == 2) {
1621             // Look for the &#39;is_x2logic&#39; pattern: &quot;x ? : 0 : 1&quot; and put the
1622             // phi merging either 0 or 1 onto the worklist
1623             Node* ifproj0 = iff-&gt;raw_out(0);
1624             Node* ifproj1 = iff-&gt;raw_out(1);
1625             if (ifproj0-&gt;outcnt() &gt; 0 &amp;&amp; ifproj1-&gt;outcnt() &gt; 0) {
1626               Node* region0 = ifproj0-&gt;raw_out(0);
1627               Node* region1 = ifproj1-&gt;raw_out(0);
1628               if( region0 == region1 )
1629                 add_users_to_worklist0(region0);
1630             }
1631           }
1632         }
1633       }
1634       if (use_op == Op_CmpI) {
1635         Node* phi = countedloop_phi_from_cmp((CmpINode*)use, n);
1636         if (phi != NULL) {
1637           // If an opaque node feeds into the limit condition of a
1638           // CountedLoop, we need to process the Phi node for the
1639           // induction variable when the opaque node is removed:
1640           // the range of values taken by the Phi is now known and
1641           // so its type is also known.
1642           _worklist.push(phi);
1643         }
1644         Node* in1 = use-&gt;in(1);
1645         for (uint i = 0; i &lt; in1-&gt;outcnt(); i++) {
1646           if (in1-&gt;raw_out(i)-&gt;Opcode() == Op_CastII) {
1647             Node* castii = in1-&gt;raw_out(i);
1648             if (castii-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0) != NULL &amp;&amp; castii-&gt;in(0)-&gt;in(0)-&gt;is_If()) {
1649               Node* ifnode = castii-&gt;in(0)-&gt;in(0);
1650               if (ifnode-&gt;in(1) != NULL &amp;&amp; ifnode-&gt;in(1)-&gt;is_Bool() &amp;&amp; ifnode-&gt;in(1)-&gt;in(1) == use) {
1651                 // Reprocess a CastII node that may depend on an
1652                 // opaque node value when the opaque node is
1653                 // removed. In case it carries a dependency we can do
1654                 // a better job of computing its type.
1655                 _worklist.push(castii);
1656               }
1657             }
1658           }
1659         }
1660       }
1661     }
1662 
1663     // If changed Cast input, check Phi users for simple cycles
1664     if (use-&gt;is_ConstraintCast()) {
1665       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1666         Node* u = use-&gt;fast_out(i2);
1667         if (u-&gt;is_Phi())
1668           _worklist.push(u);
1669       }
1670     }
1671     // If changed LShift inputs, check RShift users for useless sign-ext
1672     if( use_op == Op_LShiftI ) {
1673       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1674         Node* u = use-&gt;fast_out(i2);
1675         if (u-&gt;Opcode() == Op_RShiftI)
1676           _worklist.push(u);
1677       }
1678     }
1679     // If changed AddI/SubI inputs, check CmpU for range check optimization.
1680     if (use_op == Op_AddI || use_op == Op_SubI) {
1681       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1682         Node* u = use-&gt;fast_out(i2);
1683         if (u-&gt;is_Cmp() &amp;&amp; (u-&gt;Opcode() == Op_CmpU)) {
1684           _worklist.push(u);
1685         }
1686       }
1687     }
1688     // If changed AddP inputs, check Stores for loop invariant
1689     if( use_op == Op_AddP ) {
1690       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1691         Node* u = use-&gt;fast_out(i2);
1692         if (u-&gt;is_Mem())
1693           _worklist.push(u);
1694       }
1695     }
1696     // If changed initialization activity, check dependent Stores
1697     if (use_op == Op_Allocate || use_op == Op_AllocateArray) {
1698       InitializeNode* init = use-&gt;as_Allocate()-&gt;initialization();
1699       if (init != NULL) {
1700         Node* imem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1701         if (imem != NULL)  add_users_to_worklist0(imem);
1702       }
1703     }
1704     if (use_op == Op_Initialize) {
1705       Node* imem = use-&gt;as_Initialize()-&gt;proj_out_or_null(TypeFunc::Memory);
1706       if (imem != NULL)  add_users_to_worklist0(imem);
1707     }
1708     // Loading the java mirror from a Klass requires two loads and the type
1709     // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1710     //   LoadBarrier?(LoadP(LoadP(AddP(foo:Klass, #java_mirror))))
1711     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1712     bool has_load_barriers = bs-&gt;has_load_barriers();
1713 
1714     if (use_op == Op_LoadP &amp;&amp; use-&gt;bottom_type()-&gt;isa_rawptr()) {
1715       for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1716         Node* u = use-&gt;fast_out(i2);
1717         const Type* ut = u-&gt;bottom_type();
1718         if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr()) {
1719           if (has_load_barriers) {
1720             // Search for load barriers behind the load
1721             for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1722               Node* b = u-&gt;fast_out(i3);
1723               if (bs-&gt;is_gc_barrier_node(b)) {
1724                 _worklist.push(b);
1725               }
1726             }
1727           }
1728           _worklist.push(u);
1729         }
1730       }
1731     }
1732 
1733     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;igvn_add_users_to_worklist(this, use);
1734   }
1735 }
1736 
1737 /**
1738  * Remove the speculative part of all types that we know of
1739  */
1740 void PhaseIterGVN::remove_speculative_types()  {
1741   assert(UseTypeSpeculation, &quot;speculation is off&quot;);
1742   for (uint i = 0; i &lt; _types.Size(); i++)  {
1743     const Type* t = _types.fast_lookup(i);
1744     if (t != NULL) {
1745       _types.map(i, t-&gt;remove_speculative());
1746     }
1747   }
1748   _table.check_no_speculative_types();
1749 }
1750 
1751 //=============================================================================
1752 #ifndef PRODUCT
1753 uint PhaseCCP::_total_invokes   = 0;
1754 uint PhaseCCP::_total_constants = 0;
1755 #endif
1756 //------------------------------PhaseCCP---------------------------------------
1757 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
1758 PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {
1759   NOT_PRODUCT( clear_constants(); )
1760   assert( _worklist.size() == 0, &quot;&quot; );
1761   // Clear out _nodes from IterGVN.  Must be clear to transform call.
1762   _nodes.clear();               // Clear out from IterGVN
1763   analyze();
1764 }
1765 
1766 #ifndef PRODUCT
1767 //------------------------------~PhaseCCP--------------------------------------
1768 PhaseCCP::~PhaseCCP() {
1769   inc_invokes();
1770   _total_constants += count_constants();
1771 }
1772 #endif
1773 
1774 
1775 #ifdef ASSERT
1776 static bool ccp_type_widens(const Type* t, const Type* t0) {
1777   assert(t-&gt;meet(t0) == t, &quot;Not monotonic&quot;);
1778   switch (t-&gt;base() == t0-&gt;base() ? t-&gt;base() : Type::Top) {
1779   case Type::Int:
1780     assert(t0-&gt;isa_int()-&gt;_widen &lt;= t-&gt;isa_int()-&gt;_widen, &quot;widen increases&quot;);
1781     break;
1782   case Type::Long:
1783     assert(t0-&gt;isa_long()-&gt;_widen &lt;= t-&gt;isa_long()-&gt;_widen, &quot;widen increases&quot;);
1784     break;
1785   default:
1786     break;
1787   }
1788   return true;
1789 }
1790 #endif //ASSERT
1791 
1792 //------------------------------analyze----------------------------------------
1793 void PhaseCCP::analyze() {
1794   // Initialize all types to TOP, optimistic analysis
1795   for (int i = C-&gt;unique() - 1; i &gt;= 0; i--)  {
1796     _types.map(i,Type::TOP);
1797   }
1798 
1799   // Push root onto worklist
1800   Unique_Node_List worklist;
1801   worklist.push(C-&gt;root());
1802 
1803   // Pull from worklist; compute new value; push changes out.
1804   // This loop is the meat of CCP.
1805   while( worklist.size() ) {
1806     Node *n = worklist.pop();
1807     const Type *t = n-&gt;Value(this);
1808     if (t != type(n)) {
1809       assert(ccp_type_widens(t, type(n)), &quot;ccp type must widen&quot;);
1810 #ifndef PRODUCT
1811       if( TracePhaseCCP ) {
1812         t-&gt;dump();
1813         do { tty-&gt;print(&quot;\t&quot;); } while (tty-&gt;position() &lt; 16);
1814         n-&gt;dump();
1815       }
1816 #endif
1817       set_type(n, t);
1818       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1819         Node* m = n-&gt;fast_out(i);   // Get user
1820         if (m-&gt;is_Region()) {  // New path to Region?  Must recheck Phis too
1821           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1822             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1823             if (p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1824               worklist.push(p); // Propagate change to user
1825             }
1826           }
1827         }
1828         // If we changed the receiver type to a call, we need to revisit
1829         // the Catch following the call.  It&#39;s looking for a non-NULL
1830         // receiver to know when to enable the regular fall-through path
1831         // in addition to the NullPtrException path
1832         if (m-&gt;is_Call()) {
1833           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1834             Node* p = m-&gt;fast_out(i2);  // Propagate changes to uses
1835             if (p-&gt;is_Proj() &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Control &amp;&amp; p-&gt;outcnt() == 1) {
1836               worklist.push(p-&gt;unique_out());
1837             }
1838           }
1839         }
1840         if (m-&gt;bottom_type() != type(m)) { // If not already bottomed out
1841           worklist.push(m);     // Propagate change to user
1842         }
1843 
1844         // CmpU nodes can get their type information from two nodes up in the
1845         // graph (instead of from the nodes immediately above). Make sure they
1846         // are added to the worklist if nodes they depend on are updated, since
1847         // they could be missed and get wrong types otherwise.
1848         uint m_op = m-&gt;Opcode();
1849         if (m_op == Op_AddI || m_op == Op_SubI) {
1850           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1851             Node* p = m-&gt;fast_out(i2); // Propagate changes to uses
1852             if (p-&gt;Opcode() == Op_CmpU) {
1853               // Got a CmpU which might need the new type information from node n.
1854               if(p-&gt;bottom_type() != type(p)) { // If not already bottomed out
1855                 worklist.push(p); // Propagate change to user
1856               }
1857             }
1858           }
1859         }
1860         // If n is used in a counted loop exit condition then the type
1861         // of the counted loop&#39;s Phi depends on the type of n. See
1862         // PhiNode::Value().
1863         if (m_op == Op_CmpI) {
1864           PhiNode* phi = countedloop_phi_from_cmp((CmpINode*)m, n);
1865           if (phi != NULL) {
1866             worklist.push(phi);
1867           }
1868         }
1869         // Loading the java mirror from a Klass requires two loads and the type
1870         // of the mirror load depends on the type of &#39;n&#39;. See LoadNode::Value().
1871         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1872         bool has_load_barriers = bs-&gt;has_load_barriers();
1873 
1874         if (m_op == Op_LoadP &amp;&amp; m-&gt;bottom_type()-&gt;isa_rawptr()) {
1875           for (DUIterator_Fast i2max, i2 = m-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1876             Node* u = m-&gt;fast_out(i2);
1877             const Type* ut = u-&gt;bottom_type();
1878             if (u-&gt;Opcode() == Op_LoadP &amp;&amp; ut-&gt;isa_instptr() &amp;&amp; ut != type(u)) {
1879               if (has_load_barriers) {
1880                 // Search for load barriers behind the load
1881                 for (DUIterator_Fast i3max, i3 = u-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1882                   Node* b = u-&gt;fast_out(i3);
1883                   if (bs-&gt;is_gc_barrier_node(b)) {
1884                     worklist.push(b);
1885                   }
1886                 }
1887               }
1888               worklist.push(u);
1889             }
1890           }
1891         }
1892 
1893         BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;ccp_analyze(this, worklist, m);
1894       }
1895     }
1896   }
1897 }
1898 
1899 //------------------------------do_transform-----------------------------------
1900 // Top level driver for the recursive transformer
1901 void PhaseCCP::do_transform() {
1902   // Correct leaves of new-space Nodes; they point to old-space.
1903   C-&gt;set_root( transform(C-&gt;root())-&gt;as_Root() );
1904   assert( C-&gt;top(),  &quot;missing TOP node&quot; );
1905   assert( C-&gt;root(), &quot;missing root&quot; );
1906 }
1907 
1908 //------------------------------transform--------------------------------------
1909 // Given a Node in old-space, clone him into new-space.
1910 // Convert any of his old-space children into new-space children.
1911 Node *PhaseCCP::transform( Node *n ) {
1912   Node *new_node = _nodes[n-&gt;_idx]; // Check for transformed node
1913   if( new_node != NULL )
1914     return new_node;                // Been there, done that, return old answer
1915   new_node = transform_once(n);     // Check for constant
1916   _nodes.map( n-&gt;_idx, new_node );  // Flag as having been cloned
1917 
1918   // Allocate stack of size _nodes.Size()/2 to avoid frequent realloc
1919   GrowableArray &lt;Node *&gt; trstack(C-&gt;live_nodes() &gt;&gt; 1);
1920 
1921   trstack.push(new_node);           // Process children of cloned node
1922   while ( trstack.is_nonempty() ) {
1923     Node *clone = trstack.pop();
1924     uint cnt = clone-&gt;req();
1925     for( uint i = 0; i &lt; cnt; i++ ) {          // For all inputs do
1926       Node *input = clone-&gt;in(i);
1927       if( input != NULL ) {                    // Ignore NULLs
1928         Node *new_input = _nodes[input-&gt;_idx]; // Check for cloned input node
1929         if( new_input == NULL ) {
1930           new_input = transform_once(input);   // Check for constant
1931           _nodes.map( input-&gt;_idx, new_input );// Flag as having been cloned
1932           trstack.push(new_input);
1933         }
1934         assert( new_input == clone-&gt;in(i), &quot;insanity check&quot;);
1935       }
1936     }
1937   }
1938   return new_node;
1939 }
1940 
1941 
1942 //------------------------------transform_once---------------------------------
1943 // For PhaseCCP, transformation is IDENTITY unless Node computed a constant.
1944 Node *PhaseCCP::transform_once( Node *n ) {
1945   const Type *t = type(n);
1946   // Constant?  Use constant Node instead
1947   if( t-&gt;singleton() ) {
1948     Node *nn = n;               // Default is to return the original constant
1949     if( t == Type::TOP ) {
1950       // cache my top node on the Compile instance
1951       if( C-&gt;cached_top_node() == NULL || C-&gt;cached_top_node()-&gt;in(0) == NULL ) {
1952         C-&gt;set_cached_top_node(ConNode::make(Type::TOP));
1953         set_type(C-&gt;top(), Type::TOP);
1954       }
1955       nn = C-&gt;top();
1956     }
1957     if( !n-&gt;is_Con() ) {
1958       if( t != Type::TOP ) {
1959         nn = makecon(t);        // ConNode::make(t);
1960         NOT_PRODUCT( inc_constants(); )
1961       } else if( n-&gt;is_Region() ) { // Unreachable region
1962         // Note: nn == C-&gt;top()
1963         n-&gt;set_req(0, NULL);        // Cut selfreference
1964         bool progress = true;
1965         uint max = n-&gt;outcnt();
1966         DUIterator i;
1967         while (progress) {
1968           progress = false;
1969           // Eagerly remove dead phis to avoid phis copies creation.
1970           for (i = n-&gt;outs(); n-&gt;has_out(i); i++) {
1971             Node* m = n-&gt;out(i);
1972             if (m-&gt;is_Phi()) {
1973               assert(type(m) == Type::TOP, &quot;Unreachable region should not have live phis.&quot;);
1974               replace_node(m, nn);
1975               if (max != n-&gt;outcnt()) {
1976                 progress = true;
1977                 i = n-&gt;refresh_out_pos(i);
1978                 max = n-&gt;outcnt();
1979               }
1980             }
1981           }
1982         }
1983       }
1984       replace_node(n,nn);       // Update DefUse edges for new constant
1985     }
1986     return nn;
1987   }
1988 
1989   // If x is a TypeNode, capture any more-precise type permanently into Node
1990   if (t != n-&gt;bottom_type()) {
1991     hash_delete(n);             // changing bottom type may force a rehash
1992     n-&gt;raise_bottom_type(t);
1993     _worklist.push(n);          // n re-enters the hash table via the worklist
1994   }
1995 
1996   // TEMPORARY fix to ensure that 2nd GVN pass eliminates NULL checks
1997   switch( n-&gt;Opcode() ) {
1998   case Op_FastLock:      // Revisit FastLocks for lock coarsening
1999   case Op_If:
2000   case Op_CountedLoopEnd:
2001   case Op_Region:
2002   case Op_Loop:
2003   case Op_CountedLoop:
2004   case Op_Conv2B:
2005   case Op_Opaque1:
2006   case Op_Opaque2:
2007     _worklist.push(n);
2008     break;
2009   default:
2010     break;
2011   }
2012 
2013   return  n;
2014 }
2015 
2016 //---------------------------------saturate------------------------------------
2017 const Type* PhaseCCP::saturate(const Type* new_type, const Type* old_type,
2018                                const Type* limit_type) const {
2019   const Type* wide_type = new_type-&gt;widen(old_type, limit_type);
2020   if (wide_type != new_type) {          // did we widen?
2021     // If so, we may have widened beyond the limit type.  Clip it back down.
2022     new_type = wide_type-&gt;filter(limit_type);
2023   }
2024   return new_type;
2025 }
2026 
2027 //------------------------------print_statistics-------------------------------
2028 #ifndef PRODUCT
2029 void PhaseCCP::print_statistics() {
2030   tty-&gt;print_cr(&quot;CCP: %d  constants found: %d&quot;, _total_invokes, _total_constants);
2031 }
2032 #endif
2033 
2034 
2035 //=============================================================================
2036 #ifndef PRODUCT
2037 uint PhasePeephole::_total_peepholes = 0;
2038 #endif
2039 //------------------------------PhasePeephole----------------------------------
2040 // Conditional Constant Propagation, ala Wegman &amp; Zadeck
2041 PhasePeephole::PhasePeephole( PhaseRegAlloc *regalloc, PhaseCFG &amp;cfg )
2042   : PhaseTransform(Peephole), _regalloc(regalloc), _cfg(cfg) {
2043   NOT_PRODUCT( clear_peepholes(); )
2044 }
2045 
2046 #ifndef PRODUCT
2047 //------------------------------~PhasePeephole---------------------------------
2048 PhasePeephole::~PhasePeephole() {
2049   _total_peepholes += count_peepholes();
2050 }
2051 #endif
2052 
2053 //------------------------------transform--------------------------------------
2054 Node *PhasePeephole::transform( Node *n ) {
2055   ShouldNotCallThis();
2056   return NULL;
2057 }
2058 
2059 //------------------------------do_transform-----------------------------------
2060 void PhasePeephole::do_transform() {
2061   bool method_name_not_printed = true;
2062 
2063   // Examine each basic block
2064   for (uint block_number = 1; block_number &lt; _cfg.number_of_blocks(); ++block_number) {
2065     Block* block = _cfg.get_block(block_number);
2066     bool block_not_printed = true;
2067 
2068     // and each instruction within a block
2069     uint end_index = block-&gt;number_of_nodes();
2070     // block-&gt;end_idx() not valid after PhaseRegAlloc
2071     for( uint instruction_index = 1; instruction_index &lt; end_index; ++instruction_index ) {
2072       Node     *n = block-&gt;get_node(instruction_index);
2073       if( n-&gt;is_Mach() ) {
2074         MachNode *m = n-&gt;as_Mach();
2075         int deleted_count = 0;
2076         // check for peephole opportunities
2077         MachNode *m2 = m-&gt;peephole(block, instruction_index, _regalloc, deleted_count);
2078         if( m2 != NULL ) {
2079 #ifndef PRODUCT
2080           if( PrintOptoPeephole ) {
2081             // Print method, first time only
2082             if( C-&gt;method() &amp;&amp; method_name_not_printed ) {
2083               C-&gt;method()-&gt;print_short_name(); tty-&gt;cr();
2084               method_name_not_printed = false;
2085             }
2086             // Print this block
2087             if( Verbose &amp;&amp; block_not_printed) {
2088               tty-&gt;print_cr(&quot;in block&quot;);
2089               block-&gt;dump();
2090               block_not_printed = false;
2091             }
2092             // Print instructions being deleted
2093             for( int i = (deleted_count - 1); i &gt;= 0; --i ) {
2094               block-&gt;get_node(instruction_index-i)-&gt;as_Mach()-&gt;format(_regalloc); tty-&gt;cr();
2095             }
2096             tty-&gt;print_cr(&quot;replaced with&quot;);
2097             // Print new instruction
2098             m2-&gt;format(_regalloc);
2099             tty-&gt;print(&quot;\n\n&quot;);
2100           }
2101 #endif
2102           // Remove old nodes from basic block and update instruction_index
2103           // (old nodes still exist and may have edges pointing to them
2104           //  as register allocation info is stored in the allocator using
2105           //  the node index to live range mappings.)
2106           uint safe_instruction_index = (instruction_index - deleted_count);
2107           for( ; (instruction_index &gt; safe_instruction_index); --instruction_index ) {
2108             block-&gt;remove_node( instruction_index );
2109           }
2110           // install new node after safe_instruction_index
2111           block-&gt;insert_node(m2, safe_instruction_index + 1);
2112           end_index = block-&gt;number_of_nodes() - 1; // Recompute new block size
2113           NOT_PRODUCT( inc_peepholes(); )
2114         }
2115       }
2116     }
2117   }
2118 }
2119 
2120 //------------------------------print_statistics-------------------------------
2121 #ifndef PRODUCT
2122 void PhasePeephole::print_statistics() {
2123   tty-&gt;print_cr(&quot;Peephole: peephole rules applied: %d&quot;,  _total_peepholes);
2124 }
2125 #endif
2126 
2127 
2128 //=============================================================================
2129 //------------------------------set_req_X--------------------------------------
2130 void Node::set_req_X( uint i, Node *n, PhaseIterGVN *igvn ) {
2131   assert( is_not_dead(n), &quot;can not use dead node&quot;);
2132   assert( igvn-&gt;hash_find(this) != this, &quot;Need to remove from hash before changing edges&quot; );
2133   Node *old = in(i);
2134   set_req(i, n);
2135 
2136   // old goes dead?
2137   if( old ) {
2138     switch (old-&gt;outcnt()) {
2139     case 0:
2140       // Put into the worklist to kill later. We do not kill it now because the
2141       // recursive kill will delete the current node (this) if dead-loop exists
2142       if (!old-&gt;is_top())
2143         igvn-&gt;_worklist.push( old );
2144       break;
2145     case 1:
2146       if( old-&gt;is_Store() || old-&gt;has_special_unique_user() )
2147         igvn-&gt;add_users_to_worklist( old );
2148       break;
2149     case 2:
2150       if( old-&gt;is_Store() )
2151         igvn-&gt;add_users_to_worklist( old );
2152       if( old-&gt;Opcode() == Op_Region )
2153         igvn-&gt;_worklist.push(old);
2154       break;
2155     case 3:
2156       if( old-&gt;Opcode() == Op_Region ) {
2157         igvn-&gt;_worklist.push(old);
2158         igvn-&gt;add_users_to_worklist( old );
2159       }
2160       break;
2161     default:
2162       break;
2163     }
2164 
2165     BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;enqueue_useful_gc_barrier(igvn, old);
2166   }
2167 
2168 }
2169 
2170 //-------------------------------replace_by-----------------------------------
2171 // Using def-use info, replace one node for another.  Follow the def-use info
2172 // to all users of the OLD node.  Then make all uses point to the NEW node.
2173 void Node::replace_by(Node *new_node) {
2174   assert(!is_top(), &quot;top node has no DU info&quot;);
2175   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; ) {
2176     Node* use = last_out(i);
2177     uint uses_found = 0;
2178     for (uint j = 0; j &lt; use-&gt;len(); j++) {
2179       if (use-&gt;in(j) == this) {
2180         if (j &lt; use-&gt;req())
2181               use-&gt;set_req(j, new_node);
2182         else  use-&gt;set_prec(j, new_node);
2183         uses_found++;
2184       }
2185     }
2186     i -= uses_found;    // we deleted 1 or more copies of this edge
2187   }
2188 }
2189 
2190 //=============================================================================
2191 //-----------------------------------------------------------------------------
2192 void Type_Array::grow( uint i ) {
2193   if( !_max ) {
2194     _max = 1;
2195     _types = (const Type**)_a-&gt;Amalloc( _max * sizeof(Type*) );
2196     _types[0] = NULL;
2197   }
2198   uint old = _max;
2199   while( i &gt;= _max ) _max &lt;&lt;= 1;        // Double to fit
2200   _types = (const Type**)_a-&gt;Arealloc( _types, old*sizeof(Type*),_max*sizeof(Type*));
2201   memset( &amp;_types[old], 0, (_max-old)*sizeof(Type*) );
2202 }
2203 
2204 //------------------------------dump-------------------------------------------
2205 #ifndef PRODUCT
2206 void Type_Array::dump() const {
2207   uint max = Size();
2208   for( uint i = 0; i &lt; max; i++ ) {
2209     if( _types[i] != NULL ) {
2210       tty-&gt;print(&quot;  %d\t== &quot;, i); _types[i]-&gt;dump(); tty-&gt;cr();
2211     }
2212   }
2213 }
2214 #endif
    </pre>
  </body>
</html>
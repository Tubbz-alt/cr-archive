<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/node.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="opaquenode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,10 ***</span>
<span class="line-new-header">--- 50,11 ---</span>
  class CallLeafNode;
  class CallNode;
  class CallRuntimeNode;
  class CallStaticJavaNode;
  class CastIINode;
<span class="line-added">+ class CastLLNode;</span>
  class CatchNode;
  class CatchProjNode;
  class CheckCastPPNode;
  class ClearArrayNode;
  class CmpNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,23 ***</span>
  class EncodeNarrowPtrNode;
  class EncodePNode;
  class EncodePKlassNode;
  class FastLockNode;
  class FastUnlockNode;
  class IfNode;
  class IfProjNode;
  class IfFalseNode;
  class IfTrueNode;
  class InitializeNode;
  class JVMState;
  class JumpNode;
  class JumpProjNode;
  class LoadNode;
<span class="line-removed">- class LoadBarrierNode;</span>
<span class="line-removed">- class LoadBarrierSlowRegNode;</span>
<span class="line-removed">- class LoadBarrierWeakSlowRegNode;</span>
  class LoadStoreNode;
  class LockNode;
  class LoopNode;
  class MachBranchNode;
  class MachCallDynamicJavaNode;
  class MachCallJavaNode;
<span class="line-new-header">--- 71,22 ---</span>
  class EncodeNarrowPtrNode;
  class EncodePNode;
  class EncodePKlassNode;
  class FastLockNode;
  class FastUnlockNode;
<span class="line-added">+ class HaltNode;</span>
  class IfNode;
  class IfProjNode;
  class IfFalseNode;
  class IfTrueNode;
  class InitializeNode;
  class JVMState;
  class JumpNode;
  class JumpProjNode;
  class LoadNode;
  class LoadStoreNode;
<span class="line-added">+ class LoadStoreConditionalNode;</span>
  class LockNode;
  class LoopNode;
  class MachBranchNode;
  class MachCallDynamicJavaNode;
  class MachCallJavaNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,15 ***</span>
  class RegMask;
  class RegionNode;
  class RootNode;
  class SafePointNode;
  class SafePointScalarObjectNode;
<span class="line-removed">- class ShenandoahBarrierNode;</span>
  class StartNode;
  class State;
  class StoreNode;
  class SubNode;
  class Type;
  class TypeNode;
  class UnlockNode;
  class VectorNode;
  class LoadVectorNode;
<span class="line-new-header">--- 140,15 ---</span>
  class RegMask;
  class RegionNode;
  class RootNode;
  class SafePointNode;
  class SafePointScalarObjectNode;
  class StartNode;
  class State;
  class StoreNode;
  class SubNode;
<span class="line-added">+ class SubTypeCheckNode;</span>
  class Type;
  class TypeNode;
  class UnlockNode;
  class VectorNode;
  class LoadVectorNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,10 ***</span>
<span class="line-new-header">--- 391,11 ---</span>
    }
  
  #ifdef ASSERT
    bool is_dead() const;
  #define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)-&gt;is_dead()))
<span class="line-added">+   bool is_reachable_from_root() const;</span>
  #endif
    // Check whether node has become unreachable
    bool is_unreachable(PhaseIterGVN &amp;igvn) const;
  
    // Set a required input edge, also updates corresponding output edge
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,25 ***</span>
    }
    // Reaffirm invariants for is_top.  (Only from Compile::set_cached_top_node.)
    void setup_is_top();
  
    // Strip away casting.  (It is depth-limited.)
<span class="line-modified">!   Node* uncast() const;</span>
    // Return whether two Nodes are equivalent, after stripping casting.
<span class="line-modified">!   bool eqv_uncast(const Node* n) const {</span>
<span class="line-modified">!     return (this-&gt;uncast() == n-&gt;uncast());</span>
    }
  
    // Find out of current node that matches opcode.
    Node* find_out_with(int opcode);
    // Return true if the current node has an out that matches opcode.
    bool has_out_with(int opcode);
    // Return true if the current node has an out that matches any of the opcodes.
    bool has_out_with(int opcode1, int opcode2, int opcode3, int opcode4);
  
  private:
<span class="line-modified">!   static Node* uncast_helper(const Node* n);</span>
  
    // Add an output edge to the end of the list
    void add_out( Node *n ) {
      if (is_top())  return;
      if( _outcnt == _outmax ) out_grow(_outcnt);
<span class="line-new-header">--- 456,25 ---</span>
    }
    // Reaffirm invariants for is_top.  (Only from Compile::set_cached_top_node.)
    void setup_is_top();
  
    // Strip away casting.  (It is depth-limited.)
<span class="line-modified">!   Node* uncast(bool keep_deps = false) const;</span>
    // Return whether two Nodes are equivalent, after stripping casting.
<span class="line-modified">!   bool eqv_uncast(const Node* n, bool keep_deps = false) const {</span>
<span class="line-modified">!     return (this-&gt;uncast(keep_deps) == n-&gt;uncast(keep_deps));</span>
    }
  
    // Find out of current node that matches opcode.
    Node* find_out_with(int opcode);
    // Return true if the current node has an out that matches opcode.
    bool has_out_with(int opcode);
    // Return true if the current node has an out that matches any of the opcodes.
    bool has_out_with(int opcode1, int opcode2, int opcode3, int opcode4);
  
  private:
<span class="line-modified">!   static Node* uncast_helper(const Node* n, bool keep_deps);</span>
  
    // Add an output edge to the end of the list
    void add_out( Node *n ) {
      if (is_top())  return;
      if( _outcnt == _outmax ) out_grow(_outcnt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,11 ***</span>
          DEFINE_CLASS_ID(NeverBranch, MultiBranch, 2)
        DEFINE_CLASS_ID(Start,       Multi, 2)
        DEFINE_CLASS_ID(MemBar,      Multi, 3)
          DEFINE_CLASS_ID(Initialize,       MemBar, 0)
          DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)
<span class="line-removed">-       DEFINE_CLASS_ID(LoadBarrier, Multi, 4)</span>
  
      DEFINE_CLASS_ID(Mach,  Node, 1)
        DEFINE_CLASS_ID(MachReturn, Mach, 0)
          DEFINE_CLASS_ID(MachSafePoint, MachReturn, 0)
            DEFINE_CLASS_ID(MachCall, MachSafePoint, 0)
<span class="line-new-header">--- 639,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,20 ***</span>
  
      DEFINE_CLASS_ID(Type,  Node, 2)
        DEFINE_CLASS_ID(Phi,   Type, 0)
        DEFINE_CLASS_ID(ConstraintCast, Type, 1)
          DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
<span class="line-modified">!         DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 1)</span>
        DEFINE_CLASS_ID(CMove, Type, 3)
        DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
        DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
          DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
          DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
        DEFINE_CLASS_ID(EncodeNarrowPtr, Type, 6)
          DEFINE_CLASS_ID(EncodeP, EncodeNarrowPtr, 0)
          DEFINE_CLASS_ID(EncodePKlass, EncodeNarrowPtr, 1)
<span class="line-removed">-       DEFINE_CLASS_ID(ShenandoahBarrier, Type, 7)</span>
  
      DEFINE_CLASS_ID(Proj,  Node, 3)
        DEFINE_CLASS_ID(CatchProj, Proj, 0)
        DEFINE_CLASS_ID(JumpProj,  Proj, 1)
        DEFINE_CLASS_ID(IfProj,    Proj, 2)
<span class="line-new-header">--- 665,20 ---</span>
  
      DEFINE_CLASS_ID(Type,  Node, 2)
        DEFINE_CLASS_ID(Phi,   Type, 0)
        DEFINE_CLASS_ID(ConstraintCast, Type, 1)
          DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
<span class="line-modified">!         DEFINE_CLASS_ID(CastLL, ConstraintCast, 1)</span>
<span class="line-added">+         DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 2)</span>
        DEFINE_CLASS_ID(CMove, Type, 3)
        DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
        DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
          DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
          DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
        DEFINE_CLASS_ID(EncodeNarrowPtr, Type, 6)
          DEFINE_CLASS_ID(EncodeP, EncodeNarrowPtr, 0)
          DEFINE_CLASS_ID(EncodePKlass, EncodeNarrowPtr, 1)
  
      DEFINE_CLASS_ID(Proj,  Node, 3)
        DEFINE_CLASS_ID(CatchProj, Proj, 0)
        DEFINE_CLASS_ID(JumpProj,  Proj, 1)
        DEFINE_CLASS_ID(IfProj,    Proj, 2)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 688,12 ***</span>
        DEFINE_CLASS_ID(MachProj,  Proj, 5)
  
      DEFINE_CLASS_ID(Mem,   Node, 4)
        DEFINE_CLASS_ID(Load,  Mem, 0)
          DEFINE_CLASS_ID(LoadVector,  Load, 0)
<span class="line-removed">-           DEFINE_CLASS_ID(LoadBarrierSlowReg, Load, 1)</span>
<span class="line-removed">-           DEFINE_CLASS_ID(LoadBarrierWeakSlowReg, Load, 2)</span>
        DEFINE_CLASS_ID(Store, Mem, 1)
          DEFINE_CLASS_ID(StoreVector, Store, 0)
        DEFINE_CLASS_ID(LoadStore, Mem, 2)
          DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
            DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
<span class="line-new-header">--- 688,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,21 ***</span>
  
      DEFINE_CLASS_ID(Sub,   Node, 6)
        DEFINE_CLASS_ID(Cmp,   Sub, 0)
          DEFINE_CLASS_ID(FastLock,   Cmp, 0)
          DEFINE_CLASS_ID(FastUnlock, Cmp, 1)
  
      DEFINE_CLASS_ID(MergeMem, Node, 7)
      DEFINE_CLASS_ID(Bool,     Node, 8)
      DEFINE_CLASS_ID(AddP,     Node, 9)
      DEFINE_CLASS_ID(BoxLock,  Node, 10)
      DEFINE_CLASS_ID(Add,      Node, 11)
      DEFINE_CLASS_ID(Mul,      Node, 12)
      DEFINE_CLASS_ID(Vector,   Node, 13)
      DEFINE_CLASS_ID(ClearArray, Node, 14)
  
<span class="line-modified">!     _max_classes  = ClassMask_ClearArray</span>
    };
    #undef DEFINE_CLASS_ID
  
    // Flags are sorted by usage frequency.
    enum NodeFlags {
<span class="line-new-header">--- 705,23 ---</span>
  
      DEFINE_CLASS_ID(Sub,   Node, 6)
        DEFINE_CLASS_ID(Cmp,   Sub, 0)
          DEFINE_CLASS_ID(FastLock,   Cmp, 0)
          DEFINE_CLASS_ID(FastUnlock, Cmp, 1)
<span class="line-added">+         DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)</span>
  
      DEFINE_CLASS_ID(MergeMem, Node, 7)
      DEFINE_CLASS_ID(Bool,     Node, 8)
      DEFINE_CLASS_ID(AddP,     Node, 9)
      DEFINE_CLASS_ID(BoxLock,  Node, 10)
      DEFINE_CLASS_ID(Add,      Node, 11)
      DEFINE_CLASS_ID(Mul,      Node, 12)
      DEFINE_CLASS_ID(Vector,   Node, 13)
      DEFINE_CLASS_ID(ClearArray, Node, 14)
<span class="line-added">+     DEFINE_CLASS_ID(Halt, Node, 15)</span>
  
<span class="line-modified">!     _max_classes  = ClassMask_Halt</span>
    };
    #undef DEFINE_CLASS_ID
  
    // Flags are sorted by usage frequency.
    enum NodeFlags {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,11 ***</span>
    jushort _flags;
  
  protected:
    // These methods should be called from constructors only.
    void init_class_id(jushort c) {
<span class="line-removed">-     assert(c &lt;= _max_classes, &quot;invalid node class&quot;);</span>
      _class_id = c; // cast out const
    }
    void init_flags(jushort fl) {
      assert(fl &lt;= _max_flags, &quot;invalid node flag&quot;);
      _flags |= fl;
<span class="line-new-header">--- 748,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 806,10 ***</span>
<span class="line-new-header">--- 805,11 ---</span>
    DEFINE_CLASS_QUERY(CallStaticJava)
    DEFINE_CLASS_QUERY(Catch)
    DEFINE_CLASS_QUERY(CatchProj)
    DEFINE_CLASS_QUERY(CheckCastPP)
    DEFINE_CLASS_QUERY(CastII)
<span class="line-added">+   DEFINE_CLASS_QUERY(CastLL)</span>
    DEFINE_CLASS_QUERY(ConstraintCast)
    DEFINE_CLASS_QUERY(ClearArray)
    DEFINE_CLASS_QUERY(CMove)
    DEFINE_CLASS_QUERY(Cmp)
    DEFINE_CLASS_QUERY(CountedLoop)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,23 ***</span>
    DEFINE_CLASS_QUERY(EncodeNarrowPtr)
    DEFINE_CLASS_QUERY(EncodeP)
    DEFINE_CLASS_QUERY(EncodePKlass)
    DEFINE_CLASS_QUERY(FastLock)
    DEFINE_CLASS_QUERY(FastUnlock)
    DEFINE_CLASS_QUERY(If)
    DEFINE_CLASS_QUERY(RangeCheck)
    DEFINE_CLASS_QUERY(IfProj)
    DEFINE_CLASS_QUERY(IfFalse)
    DEFINE_CLASS_QUERY(IfTrue)
    DEFINE_CLASS_QUERY(Initialize)
    DEFINE_CLASS_QUERY(Jump)
    DEFINE_CLASS_QUERY(JumpProj)
    DEFINE_CLASS_QUERY(Load)
    DEFINE_CLASS_QUERY(LoadStore)
<span class="line-modified">!   DEFINE_CLASS_QUERY(LoadBarrier)</span>
<span class="line-removed">-   DEFINE_CLASS_QUERY(LoadBarrierSlowReg)</span>
<span class="line-removed">-   DEFINE_CLASS_QUERY(LoadBarrierWeakSlowReg)</span>
    DEFINE_CLASS_QUERY(Lock)
    DEFINE_CLASS_QUERY(Loop)
    DEFINE_CLASS_QUERY(Mach)
    DEFINE_CLASS_QUERY(MachBranch)
    DEFINE_CLASS_QUERY(MachCall)
<span class="line-new-header">--- 820,22 ---</span>
    DEFINE_CLASS_QUERY(EncodeNarrowPtr)
    DEFINE_CLASS_QUERY(EncodeP)
    DEFINE_CLASS_QUERY(EncodePKlass)
    DEFINE_CLASS_QUERY(FastLock)
    DEFINE_CLASS_QUERY(FastUnlock)
<span class="line-added">+   DEFINE_CLASS_QUERY(Halt)</span>
    DEFINE_CLASS_QUERY(If)
    DEFINE_CLASS_QUERY(RangeCheck)
    DEFINE_CLASS_QUERY(IfProj)
    DEFINE_CLASS_QUERY(IfFalse)
    DEFINE_CLASS_QUERY(IfTrue)
    DEFINE_CLASS_QUERY(Initialize)
    DEFINE_CLASS_QUERY(Jump)
    DEFINE_CLASS_QUERY(JumpProj)
    DEFINE_CLASS_QUERY(Load)
    DEFINE_CLASS_QUERY(LoadStore)
<span class="line-modified">!   DEFINE_CLASS_QUERY(LoadStoreConditional)</span>
    DEFINE_CLASS_QUERY(Lock)
    DEFINE_CLASS_QUERY(Loop)
    DEFINE_CLASS_QUERY(Mach)
    DEFINE_CLASS_QUERY(MachBranch)
    DEFINE_CLASS_QUERY(MachCall)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 873,14 ***</span>
    DEFINE_CLASS_QUERY(Proj)
    DEFINE_CLASS_QUERY(Region)
    DEFINE_CLASS_QUERY(Root)
    DEFINE_CLASS_QUERY(SafePoint)
    DEFINE_CLASS_QUERY(SafePointScalarObject)
<span class="line-removed">-   DEFINE_CLASS_QUERY(ShenandoahBarrier)</span>
    DEFINE_CLASS_QUERY(Start)
    DEFINE_CLASS_QUERY(Store)
    DEFINE_CLASS_QUERY(Sub)
    DEFINE_CLASS_QUERY(Type)
    DEFINE_CLASS_QUERY(Vector)
    DEFINE_CLASS_QUERY(LoadVector)
    DEFINE_CLASS_QUERY(StoreVector)
    DEFINE_CLASS_QUERY(Unlock)
<span class="line-new-header">--- 872,14 ---</span>
    DEFINE_CLASS_QUERY(Proj)
    DEFINE_CLASS_QUERY(Region)
    DEFINE_CLASS_QUERY(Root)
    DEFINE_CLASS_QUERY(SafePoint)
    DEFINE_CLASS_QUERY(SafePointScalarObject)
    DEFINE_CLASS_QUERY(Start)
    DEFINE_CLASS_QUERY(Store)
    DEFINE_CLASS_QUERY(Sub)
<span class="line-added">+   DEFINE_CLASS_QUERY(SubTypeCheck)</span>
    DEFINE_CLASS_QUERY(Type)
    DEFINE_CLASS_QUERY(Vector)
    DEFINE_CLASS_QUERY(LoadVector)
    DEFINE_CLASS_QUERY(StoreVector)
    DEFINE_CLASS_QUERY(Unlock)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 999,22 ***</span>
  
    // If the hash function returns the special sentinel value NO_HASH,
    // the node is guaranteed never to compare equal to any other node.
    // If we accidentally generate a hash with value NO_HASH the node
    // won&#39;t go into the table and we&#39;ll lose a little optimization.
<span class="line-modified">!   enum { NO_HASH = 0 };</span>
    virtual uint hash() const;
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
  
    // Operation appears to be iteratively computed (such as an induction variable)
    // It is possible for this operation to return false for a loop-varying
    // value, if it appears (by local graph inspection) to be computed by a simple conditional.
    bool is_iteratively_computed();
  
<span class="line-modified">!   // Determine if a node is Counted loop induction variable.</span>
<span class="line-modified">!   // The method is defined in loopnode.cpp.</span>
<span class="line-modified">!   const Node* is_loop_iv() const;</span>
  
    // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
    // be found; Otherwise return NULL;
    Node* find_similar(int opc);
  
<span class="line-new-header">--- 998,22 ---</span>
  
    // If the hash function returns the special sentinel value NO_HASH,
    // the node is guaranteed never to compare equal to any other node.
    // If we accidentally generate a hash with value NO_HASH the node
    // won&#39;t go into the table and we&#39;ll lose a little optimization.
<span class="line-modified">!   static const uint NO_HASH = 0;</span>
    virtual uint hash() const;
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
  
    // Operation appears to be iteratively computed (such as an induction variable)
    // It is possible for this operation to return false for a loop-varying
    // value, if it appears (by local graph inspection) to be computed by a simple conditional.
    bool is_iteratively_computed();
  
<span class="line-modified">!   // Determine if a node is a counted loop induction variable.</span>
<span class="line-modified">!   // NOTE: The method is defined in &quot;loopnode.cpp&quot;.</span>
<span class="line-modified">!   bool is_cloop_ind_var() const;</span>
  
    // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
    // be found; Otherwise return NULL;
    Node* find_similar(int opc);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1523,39 ***</span>
    Unique_Node_List() : Node_List(), _in_worklist(Thread::current()-&gt;resource_area()), _clock_index(0) {}
    Unique_Node_List(Arena *a) : Node_List(a), _in_worklist(a), _clock_index(0) {}
  
    void remove( Node *n );
    bool member( Node *n ) { return _in_worklist.test(n-&gt;_idx) != 0; }
<span class="line-modified">!   VectorSet &amp;member_set(){ return _in_worklist; }</span>
  
<span class="line-modified">!   void push( Node *b ) {</span>
      if( !_in_worklist.test_set(b-&gt;_idx) )
        Node_List::push(b);
    }
    Node *pop() {
      if( _clock_index &gt;= size() ) _clock_index = 0;
      Node *b = at(_clock_index);
      map( _clock_index, Node_List::pop());
      if (size() != 0) _clock_index++; // Always start from 0
<span class="line-modified">!     _in_worklist &gt;&gt;= b-&gt;_idx;</span>
      return b;
    }
<span class="line-modified">!   Node *remove( uint i ) {</span>
      Node *b = Node_List::at(i);
<span class="line-modified">!     _in_worklist &gt;&gt;= b-&gt;_idx;</span>
      map(i,Node_List::pop());
      return b;
    }
<span class="line-modified">!   void yank( Node *n ) { _in_worklist &gt;&gt;= n-&gt;_idx; Node_List::yank(n); }</span>
    void  clear() {
<span class="line-modified">!     _in_worklist.Clear();        // Discards storage but grows automatically</span>
      Node_List::clear();
      _clock_index = 0;
    }
  
    // Used after parsing to remove useless nodes before Iterative GVN
<span class="line-modified">!   void remove_useless_nodes(VectorSet &amp;useful);</span>
  
  #ifndef PRODUCT
    void print_set() const { _in_worklist.print(); }
  #endif
  };
<span class="line-new-header">--- 1522,42 ---</span>
    Unique_Node_List() : Node_List(), _in_worklist(Thread::current()-&gt;resource_area()), _clock_index(0) {}
    Unique_Node_List(Arena *a) : Node_List(a), _in_worklist(a), _clock_index(0) {}
  
    void remove( Node *n );
    bool member( Node *n ) { return _in_worklist.test(n-&gt;_idx) != 0; }
<span class="line-modified">!   VectorSet&amp; member_set(){ return _in_worklist; }</span>
  
<span class="line-modified">!   void push(Node* b) {</span>
      if( !_in_worklist.test_set(b-&gt;_idx) )
        Node_List::push(b);
    }
    Node *pop() {
      if( _clock_index &gt;= size() ) _clock_index = 0;
      Node *b = at(_clock_index);
      map( _clock_index, Node_List::pop());
      if (size() != 0) _clock_index++; // Always start from 0
<span class="line-modified">!     _in_worklist.remove(b-&gt;_idx);</span>
      return b;
    }
<span class="line-modified">!   Node *remove(uint i) {</span>
      Node *b = Node_List::at(i);
<span class="line-modified">!     _in_worklist.remove(b-&gt;_idx);</span>
      map(i,Node_List::pop());
      return b;
    }
<span class="line-modified">!   void yank(Node *n) {</span>
<span class="line-added">+     _in_worklist.remove(n-&gt;_idx);</span>
<span class="line-added">+     Node_List::yank(n);</span>
<span class="line-added">+   }</span>
    void  clear() {
<span class="line-modified">!     _in_worklist.clear();        // Discards storage but grows automatically</span>
      Node_List::clear();
      _clock_index = 0;
    }
  
    // Used after parsing to remove useless nodes before Iterative GVN
<span class="line-modified">!   void remove_useless_nodes(VectorSet&amp; useful);</span>
  
  #ifndef PRODUCT
    void print_set() const { _in_worklist.print(); }
  #endif
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1716,11 ***</span>
  //------------------------------TypeNode---------------------------------------
  // Node with a Type constant.
  class TypeNode : public Node {
  protected:
    virtual uint hash() const;    // Check the type
<span class="line-modified">!   virtual uint cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
    const Type* const _type;
  public:
    void set_type(const Type* t) {
      assert(t != NULL, &quot;sanity&quot;);
<span class="line-new-header">--- 1718,11 ---</span>
  //------------------------------TypeNode---------------------------------------
  // Node with a Type constant.
  class TypeNode : public Node {
  protected:
    virtual uint hash() const;    // Check the type
<span class="line-modified">!   virtual bool cmp( const Node &amp;n ) const;</span>
    virtual uint size_of() const; // Size is bigger
    const Type* const _type;
  public:
    void set_type(const Type* t) {
      assert(t != NULL, &quot;sanity&quot;);
</pre>
<center><a href="node.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="opaquenode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
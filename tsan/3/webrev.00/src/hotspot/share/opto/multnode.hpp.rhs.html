<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/multnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_MULTNODE_HPP
 26 #define SHARE_OPTO_MULTNODE_HPP
 27 
 28 #include &quot;opto/node.hpp&quot;
 29 
 30 class Matcher;
 31 class ProjNode;
 32 
 33 //------------------------------MultiNode--------------------------------------
 34 // This class defines a MultiNode, a Node which produces many values.  The
 35 // values are wrapped up in a tuple Type, i.e. a TypeTuple.
 36 class MultiNode : public Node {
 37 public:
 38   MultiNode( uint required ) : Node(required) {
 39     init_class_id(Class_Multi);
 40   }
 41   virtual int Opcode() const;
 42   virtual const Type *bottom_type() const = 0;
 43   virtual bool       is_CFG() const { return true; }
 44   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 45   virtual bool depends_only_on_test() const { return false; }
 46   virtual const RegMask &amp;out_RegMask() const;
 47   virtual Node *match( const ProjNode *proj, const Matcher *m );
 48   virtual uint ideal_reg() const { return NotAMachineReg; }
 49   ProjNode* proj_out(uint which_proj) const; // Get a named projection
 50   ProjNode* proj_out_or_null(uint which_proj) const;
 51 
 52 };
 53 
 54 //------------------------------ProjNode---------------------------------------
 55 // This class defines a Projection node.  Projections project a single element
 56 // out of a tuple (or Signature) type.  Only MultiNodes produce TypeTuple
 57 // results.
 58 class ProjNode : public Node {
 59 protected:
 60   virtual uint hash() const;
<a name="1" id="anc1"></a><span class="line-modified"> 61   virtual bool cmp( const Node &amp;n ) const;</span>
 62   virtual uint size_of() const;
 63   void check_con() const;       // Called from constructor.
 64   const Type* proj_type(const Type* t) const;
 65 
 66 public:
 67   ProjNode( Node *src, uint con, bool io_use = false )
 68     : Node( src ), _con(con), _is_io_use(io_use)
 69   {
 70     init_class_id(Class_Proj);
 71     // Optimistic setting. Need additional checks in Node::is_dead_loop_safe().
 72     if (con != TypeFunc::Memory || src-&gt;is_Start())
 73       init_flags(Flag_is_dead_loop_safe);
 74     debug_only(check_con());
 75   }
 76   const uint _con;              // The field in the tuple we are projecting
 77   const bool _is_io_use;        // Used to distinguish between the projections
 78                                 // used on the control and io paths from a macro node
 79   virtual int Opcode() const;
 80   virtual bool      is_CFG() const;
 81   virtual bool depends_only_on_test() const { return false; }
 82   virtual const Type *bottom_type() const;
 83   virtual const TypePtr *adr_type() const;
 84   virtual bool pinned() const;
 85   virtual const Type* Value(PhaseGVN* phase) const;
 86   virtual uint ideal_reg() const;
 87   virtual const RegMask &amp;out_RegMask() const;
 88 
 89 #ifndef PRODUCT
 90   virtual void dump_spec(outputStream *st) const;
 91   virtual void dump_compact_spec(outputStream *st) const;
 92 #endif
 93 
 94   // Return uncommon trap call node if proj is for &quot;proj-&gt;[region-&gt;..]call_uct&quot;
 95   // NULL otherwise
 96   CallStaticJavaNode* is_uncommon_trap_proj(Deoptimization::DeoptReason reason);
 97   // Return uncommon trap call node for    &quot;if(test)-&gt; proj -&gt; ...
 98   //                                                 |
 99   //                                                 V
100   //                                             other_proj-&gt;[region-&gt;..]call_uct&quot;
101   // NULL otherwise
102   CallStaticJavaNode* is_uncommon_trap_if_pattern(Deoptimization::DeoptReason reason);
103 
104   // Return other proj node when this is a If proj node
105   ProjNode* other_if_proj() const;
106 };
107 
108 #endif // SHARE_OPTO_MULTNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
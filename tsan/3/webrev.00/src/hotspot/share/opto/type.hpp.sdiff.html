<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169 
 170 protected:
 171   // Each class of type is also identified by its base.
 172   const TYPES _base;            // Enum of Types type
 173 
 174   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 175   // ~Type();                   // Use fast deallocation
 176   const Type *hashcons();       // Hash-cons the type
 177   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 178   const Type *join_helper(const Type *t, bool include_speculative) const {
 179     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 180   }
 181 
 182 public:
 183 
 184   inline void* operator new( size_t x ) throw() {
 185     Compile* compile = Compile::current();
 186     compile-&gt;set_type_last_size(x);
<span class="line-modified"> 187     void *temp = compile-&gt;type_arena()-&gt;Amalloc_D(x);</span>
<span class="line-removed"> 188     compile-&gt;set_type_hwm(temp);</span>
<span class="line-removed"> 189     return temp;</span>
 190   }
 191   inline void operator delete( void* ptr ) {
 192     Compile* compile = Compile::current();
 193     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 194   }
 195 
 196   // Initialize the type system for a particular compilation.
 197   static void Initialize(Compile* compile);
 198 
 199   // Initialize the types shared by all compilations.
 200   static void Initialize_shared(Compile* compile);
 201 
 202   TYPES base() const {
 203     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 204     return _base;
 205   }
 206 
 207   // Create a new hash-consd type
 208   static const Type *make(enum TYPES);
 209   // Test for equivalence of types
</pre>
<hr />
<pre>
 275 
 276   bool is_ptr_to_boxing_obj() const;
 277 
 278 
 279   // Convenience access
 280   float getf() const;
 281   double getd() const;
 282 
 283   const TypeInt    *is_int() const;
 284   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 285   const TypeLong   *is_long() const;
 286   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 287   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 288   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 289   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 290   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 291   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 292   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 293   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 294   const TypeAry    *is_ary() const;              // Array, NOT array pointer

 295   const TypeVect   *is_vect() const;             // Vector
 296   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 297   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 298   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 299   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 300   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 301   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 302   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 303   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 304   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 305   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 306   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 307   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 308   const TypeInstPtr  *is_instptr() const;        // Instance
 309   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 310   const TypeAryPtr   *is_aryptr() const;         // Array oop
 311 
 312   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 313   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 314   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
</pre>
<hr />
<pre>
 439                                                       int stable_dimension,
 440                                                       BasicType loadbt,
 441                                                       bool is_unsigned_load);
 442 
 443   // Speculative type helper methods. See TypePtr.
 444   virtual const TypePtr* speculative() const                                  { return NULL; }
 445   virtual ciKlass* speculative_type() const                                   { return NULL; }
 446   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 447   virtual bool speculative_maybe_null() const                                 { return true; }
 448   virtual bool speculative_always_null() const                                { return true; }
 449   virtual const Type* remove_speculative() const                              { return this; }
 450   virtual const Type* cleanup_speculative() const                             { return this; }
 451   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 452   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 453   const Type* maybe_remove_speculative(bool include_speculative) const;
 454 
 455   virtual bool maybe_null() const { return true; }
 456 
 457 private:
 458   // support arrays
<span class="line-removed"> 459   static const BasicType _basic_type[];</span>
 460   static const Type*        _zero_type[T_CONFLICT+1];
 461   static const Type* _const_basic_type[T_CONFLICT+1];
 462 };
 463 
 464 //------------------------------TypeF------------------------------------------
 465 // Class of Float-Constant Types.
 466 class TypeF : public Type {
 467   TypeF( float f ) : Type(FloatCon), _f(f) {};
 468 public:
 469   virtual bool eq( const Type *t ) const;
 470   virtual int  hash() const;             // Type specific hashing
 471   virtual bool singleton(void) const;    // TRUE if type is a singleton
 472   virtual bool empty(void) const;        // TRUE if type is vacuous
 473 public:
 474   const float _f;               // Float constant
 475 
 476   static const TypeF *make(float f);
 477 
 478   virtual bool        is_finite() const;  // Has a finite value
 479   virtual bool        is_nan()    const;  // Is not a number (NaN)
</pre>
<hr />
<pre>
1015   virtual ciKlass* klass() const { return _klass;     }
1016   bool klass_is_exact()    const { return _klass_is_exact; }
1017 
1018   // Returns true if this pointer points at memory which contains a
1019   // compressed oop references.
1020   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1021   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1022   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1023   bool is_known_instance()       const { return _instance_id &gt; 0; }
1024   int  instance_id()             const { return _instance_id; }
1025   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1026 
1027   virtual intptr_t get_con() const;
1028 
1029   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1030 
1031   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1032 
1033   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1034 
<span class="line-removed">1035   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1036 </span>
1037   // corresponding pointer to klass, for a given instance
1038   const TypeKlassPtr* as_klass_type() const;
1039 
1040   virtual const TypePtr *add_offset( intptr_t offset ) const;
1041 
1042   // Speculative type helper methods.
1043   virtual const Type* remove_speculative() const;
1044   virtual const Type* cleanup_speculative() const;
1045   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1046   virtual const TypePtr* with_inline_depth(int depth) const;
1047 
1048   virtual const TypePtr* with_instance_id(int instance_id) const;
1049 
1050   virtual const Type *xdual() const;    // Compute dual right now.
1051   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1052   virtual const Type *xmeet_helper(const Type *t) const;
1053 
1054   // Convenience common pre-built type.
1055   static const TypeOopPtr *BOTTOM;
1056 #ifndef PRODUCT
</pre>
<hr />
<pre>
1101   // Make a pointer to an oop.
1102   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1103                                  int instance_id = InstanceBot,
1104                                  const TypePtr* speculative = NULL,
1105                                  int inline_depth = InlineDepthBottom);
1106 
1107   /** Create constant type for a constant boxed value */
1108   const Type* get_const_boxed_value() const;
1109 
1110   // If this is a java.lang.Class constant, return the type for it or NULL.
1111   // Pass to Type::get_const_type to turn it to a type, which will usually
1112   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1113   ciType* java_mirror_type() const;
1114 
1115   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1116 
1117   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1118 
1119   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1120 
<span class="line-removed">1121   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1122 </span>
1123   virtual const TypePtr *add_offset( intptr_t offset ) const;
1124 
1125   // Speculative type helper methods.
1126   virtual const Type* remove_speculative() const;
1127   virtual const TypePtr* with_inline_depth(int depth) const;
1128   virtual const TypePtr* with_instance_id(int instance_id) const;
1129 
1130   // the core of the computation of the meet of 2 types
1131   virtual const Type *xmeet_helper(const Type *t) const;
1132   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1133   virtual const Type *xdual() const;    // Compute dual right now.
1134 
1135   // Convenience common pre-built types.
1136   static const TypeInstPtr *NOTNULL;
1137   static const TypeInstPtr *BOTTOM;
1138   static const TypeInstPtr *MIRROR;
1139   static const TypeInstPtr *MARK;
1140   static const TypeInstPtr *KLASS;
1141 #ifndef PRODUCT
1142   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
</pre>
<hr />
<pre>
1187 
1188   bool is_autobox_cache() const { return _is_autobox_cache; }
1189 
1190   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1191                                 int instance_id = InstanceBot,
1192                                 const TypePtr* speculative = NULL,
1193                                 int inline_depth = InlineDepthBottom);
1194   // Constant pointer to array
1195   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1196                                 int instance_id = InstanceBot,
1197                                 const TypePtr* speculative = NULL,
1198                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1199 
1200   // Return a &#39;ptr&#39; version of this type
1201   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1202 
1203   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1204 
1205   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1206 
<span class="line-removed">1207   virtual const TypeOopPtr *cast_to_nonconst() const;</span>
<span class="line-removed">1208 </span>
1209   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1210   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1211 
1212   virtual bool empty(void) const;        // TRUE if type is vacuous
1213   virtual const TypePtr *add_offset( intptr_t offset ) const;
1214 
1215   // Speculative type helper methods.
1216   virtual const Type* remove_speculative() const;
1217   virtual const TypePtr* with_inline_depth(int depth) const;
1218   virtual const TypePtr* with_instance_id(int instance_id) const;
1219 
1220   // the core of the computation of the meet of 2 types
1221   virtual const Type *xmeet_helper(const Type *t) const;
1222   virtual const Type *xdual() const;    // Compute dual right now.
1223 
1224   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1225   int stable_dimension() const;
1226 
1227   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1228 


1229   // Convenience common pre-built types.
1230   static const TypeAryPtr *RANGE;
1231   static const TypeAryPtr *OOPS;
1232   static const TypeAryPtr *NARROWOOPS;
1233   static const TypeAryPtr *BYTES;
1234   static const TypeAryPtr *SHORTS;
1235   static const TypeAryPtr *CHARS;
1236   static const TypeAryPtr *INTS;
1237   static const TypeAryPtr *LONGS;
1238   static const TypeAryPtr *FLOATS;
1239   static const TypeAryPtr *DOUBLES;
1240   // selects one of the above:
1241   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1242     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1243     return _array_body_type[elem];
1244   }
1245   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1246   // sharpen the type of an int which is used as an array size
1247 #ifdef ASSERT
1248   // One type is interface, the other is oop
</pre>
<hr />
<pre>
1600 
1601 inline const TypeD *Type::is_double_constant() const {
1602   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1603   return (TypeD*)this;
1604 }
1605 
1606 inline const TypeD *Type::isa_double_constant() const {
1607   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1608 }
1609 
1610 inline const TypeTuple *Type::is_tuple() const {
1611   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1612   return (TypeTuple*)this;
1613 }
1614 
1615 inline const TypeAry *Type::is_ary() const {
1616   assert( _base == Array , &quot;Not an Array&quot; );
1617   return (TypeAry*)this;
1618 }
1619 




1620 inline const TypeVect *Type::is_vect() const {
1621   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1622   return (TypeVect*)this;
1623 }
1624 
1625 inline const TypeVect *Type::isa_vect() const {
1626   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1627 }
1628 
1629 inline const TypePtr *Type::is_ptr() const {
1630   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1631   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1632   return (TypePtr*)this;
1633 }
1634 
1635 inline const TypePtr *Type::isa_ptr() const {
1636   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1637   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1638 }
1639 
</pre>
<hr />
<pre>
1776 #define CmpXNode     CmpLNode
1777 #define SubXNode     SubLNode
1778 #define LShiftXNode  LShiftLNode
1779 // For object size computation:
1780 #define AddXNode     AddLNode
1781 #define RShiftXNode  RShiftLNode
1782 // For card marks and hashcodes
1783 #define URShiftXNode URShiftLNode
1784 // UseOptoBiasInlining
1785 #define XorXNode     XorLNode
1786 #define StoreXConditionalNode StoreLConditionalNode
1787 #define LoadXNode    LoadLNode
1788 #define StoreXNode   StoreLNode
1789 // Opcodes
1790 #define Op_LShiftX   Op_LShiftL
1791 #define Op_AndX      Op_AndL
1792 #define Op_AddX      Op_AddL
1793 #define Op_SubX      Op_SubL
1794 #define Op_XorX      Op_XorL
1795 #define Op_URShiftX  Op_URShiftL

1796 // conversions
1797 #define ConvI2X(x)   ConvI2L(x)
1798 #define ConvL2X(x)   (x)
1799 #define ConvX2I(x)   ConvL2I(x)
1800 #define ConvX2L(x)   (x)
1801 #define ConvX2UL(x)  (x)
1802 
1803 #else
1804 
1805 // For type queries and asserts
1806 #define is_intptr_t  is_int
1807 #define isa_intptr_t isa_int
1808 #define find_intptr_t_type find_int_type
1809 #define find_intptr_t_con  find_int_con
1810 #define TypeX        TypeInt
1811 #define Type_X       Type::Int
1812 #define TypeX_X      TypeInt::INT
1813 #define TypeX_ZERO   TypeInt::ZERO
1814 // For &#39;ideal_reg&#39; machine registers
1815 #define Op_RegX      Op_RegI
</pre>
<hr />
<pre>
1823 #define CmpXNode     CmpINode
1824 #define SubXNode     SubINode
1825 #define LShiftXNode  LShiftINode
1826 // For object size computation:
1827 #define AddXNode     AddINode
1828 #define RShiftXNode  RShiftINode
1829 // For card marks and hashcodes
1830 #define URShiftXNode URShiftINode
1831 // UseOptoBiasInlining
1832 #define XorXNode     XorINode
1833 #define StoreXConditionalNode StoreIConditionalNode
1834 #define LoadXNode    LoadINode
1835 #define StoreXNode   StoreINode
1836 // Opcodes
1837 #define Op_LShiftX   Op_LShiftI
1838 #define Op_AndX      Op_AndI
1839 #define Op_AddX      Op_AddI
1840 #define Op_SubX      Op_SubI
1841 #define Op_XorX      Op_XorI
1842 #define Op_URShiftX  Op_URShiftI

1843 // conversions
1844 #define ConvI2X(x)   (x)
1845 #define ConvL2X(x)   ConvL2I(x)
1846 #define ConvX2I(x)   (x)
1847 #define ConvX2L(x)   ConvI2L(x)
1848 #define ConvX2UL(x)  ConvI2UL(x)
1849 
1850 #endif
1851 
1852 #endif // SHARE_OPTO_TYPE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169 
 170 protected:
 171   // Each class of type is also identified by its base.
 172   const TYPES _base;            // Enum of Types type
 173 
 174   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 175   // ~Type();                   // Use fast deallocation
 176   const Type *hashcons();       // Hash-cons the type
 177   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 178   const Type *join_helper(const Type *t, bool include_speculative) const {
 179     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 180   }
 181 
 182 public:
 183 
 184   inline void* operator new( size_t x ) throw() {
 185     Compile* compile = Compile::current();
 186     compile-&gt;set_type_last_size(x);
<span class="line-modified"> 187     return compile-&gt;type_arena()-&gt;Amalloc_D(x);</span>


 188   }
 189   inline void operator delete( void* ptr ) {
 190     Compile* compile = Compile::current();
 191     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 192   }
 193 
 194   // Initialize the type system for a particular compilation.
 195   static void Initialize(Compile* compile);
 196 
 197   // Initialize the types shared by all compilations.
 198   static void Initialize_shared(Compile* compile);
 199 
 200   TYPES base() const {
 201     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 202     return _base;
 203   }
 204 
 205   // Create a new hash-consd type
 206   static const Type *make(enum TYPES);
 207   // Test for equivalence of types
</pre>
<hr />
<pre>
 273 
 274   bool is_ptr_to_boxing_obj() const;
 275 
 276 
 277   // Convenience access
 278   float getf() const;
 279   double getd() const;
 280 
 281   const TypeInt    *is_int() const;
 282   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 283   const TypeLong   *is_long() const;
 284   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 285   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 286   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 287   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 288   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 289   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 290   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 291   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 292   const TypeAry    *is_ary() const;              // Array, NOT array pointer
<span class="line-added"> 293   const TypeAry    *isa_ary() const;             // Returns NULL of not ary</span>
 294   const TypeVect   *is_vect() const;             // Vector
 295   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 296   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 297   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 298   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 299   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 300   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 301   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 302   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 303   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 304   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 305   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 306   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 307   const TypeInstPtr  *is_instptr() const;        // Instance
 308   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 309   const TypeAryPtr   *is_aryptr() const;         // Array oop
 310 
 311   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 312   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 313   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
</pre>
<hr />
<pre>
 438                                                       int stable_dimension,
 439                                                       BasicType loadbt,
 440                                                       bool is_unsigned_load);
 441 
 442   // Speculative type helper methods. See TypePtr.
 443   virtual const TypePtr* speculative() const                                  { return NULL; }
 444   virtual ciKlass* speculative_type() const                                   { return NULL; }
 445   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 446   virtual bool speculative_maybe_null() const                                 { return true; }
 447   virtual bool speculative_always_null() const                                { return true; }
 448   virtual const Type* remove_speculative() const                              { return this; }
 449   virtual const Type* cleanup_speculative() const                             { return this; }
 450   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 451   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 452   const Type* maybe_remove_speculative(bool include_speculative) const;
 453 
 454   virtual bool maybe_null() const { return true; }
 455 
 456 private:
 457   // support arrays

 458   static const Type*        _zero_type[T_CONFLICT+1];
 459   static const Type* _const_basic_type[T_CONFLICT+1];
 460 };
 461 
 462 //------------------------------TypeF------------------------------------------
 463 // Class of Float-Constant Types.
 464 class TypeF : public Type {
 465   TypeF( float f ) : Type(FloatCon), _f(f) {};
 466 public:
 467   virtual bool eq( const Type *t ) const;
 468   virtual int  hash() const;             // Type specific hashing
 469   virtual bool singleton(void) const;    // TRUE if type is a singleton
 470   virtual bool empty(void) const;        // TRUE if type is vacuous
 471 public:
 472   const float _f;               // Float constant
 473 
 474   static const TypeF *make(float f);
 475 
 476   virtual bool        is_finite() const;  // Has a finite value
 477   virtual bool        is_nan()    const;  // Is not a number (NaN)
</pre>
<hr />
<pre>
1013   virtual ciKlass* klass() const { return _klass;     }
1014   bool klass_is_exact()    const { return _klass_is_exact; }
1015 
1016   // Returns true if this pointer points at memory which contains a
1017   // compressed oop references.
1018   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1019   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1020   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1021   bool is_known_instance()       const { return _instance_id &gt; 0; }
1022   int  instance_id()             const { return _instance_id; }
1023   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1024 
1025   virtual intptr_t get_con() const;
1026 
1027   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1028 
1029   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1030 
1031   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1032 


1033   // corresponding pointer to klass, for a given instance
1034   const TypeKlassPtr* as_klass_type() const;
1035 
1036   virtual const TypePtr *add_offset( intptr_t offset ) const;
1037 
1038   // Speculative type helper methods.
1039   virtual const Type* remove_speculative() const;
1040   virtual const Type* cleanup_speculative() const;
1041   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1042   virtual const TypePtr* with_inline_depth(int depth) const;
1043 
1044   virtual const TypePtr* with_instance_id(int instance_id) const;
1045 
1046   virtual const Type *xdual() const;    // Compute dual right now.
1047   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1048   virtual const Type *xmeet_helper(const Type *t) const;
1049 
1050   // Convenience common pre-built type.
1051   static const TypeOopPtr *BOTTOM;
1052 #ifndef PRODUCT
</pre>
<hr />
<pre>
1097   // Make a pointer to an oop.
1098   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1099                                  int instance_id = InstanceBot,
1100                                  const TypePtr* speculative = NULL,
1101                                  int inline_depth = InlineDepthBottom);
1102 
1103   /** Create constant type for a constant boxed value */
1104   const Type* get_const_boxed_value() const;
1105 
1106   // If this is a java.lang.Class constant, return the type for it or NULL.
1107   // Pass to Type::get_const_type to turn it to a type, which will usually
1108   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1109   ciType* java_mirror_type() const;
1110 
1111   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1112 
1113   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1114 
1115   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1116 


1117   virtual const TypePtr *add_offset( intptr_t offset ) const;
1118 
1119   // Speculative type helper methods.
1120   virtual const Type* remove_speculative() const;
1121   virtual const TypePtr* with_inline_depth(int depth) const;
1122   virtual const TypePtr* with_instance_id(int instance_id) const;
1123 
1124   // the core of the computation of the meet of 2 types
1125   virtual const Type *xmeet_helper(const Type *t) const;
1126   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1127   virtual const Type *xdual() const;    // Compute dual right now.
1128 
1129   // Convenience common pre-built types.
1130   static const TypeInstPtr *NOTNULL;
1131   static const TypeInstPtr *BOTTOM;
1132   static const TypeInstPtr *MIRROR;
1133   static const TypeInstPtr *MARK;
1134   static const TypeInstPtr *KLASS;
1135 #ifndef PRODUCT
1136   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
</pre>
<hr />
<pre>
1181 
1182   bool is_autobox_cache() const { return _is_autobox_cache; }
1183 
1184   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1185                                 int instance_id = InstanceBot,
1186                                 const TypePtr* speculative = NULL,
1187                                 int inline_depth = InlineDepthBottom);
1188   // Constant pointer to array
1189   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1190                                 int instance_id = InstanceBot,
1191                                 const TypePtr* speculative = NULL,
1192                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1193 
1194   // Return a &#39;ptr&#39; version of this type
1195   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1196 
1197   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1198 
1199   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1200 


1201   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1202   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1203 
1204   virtual bool empty(void) const;        // TRUE if type is vacuous
1205   virtual const TypePtr *add_offset( intptr_t offset ) const;
1206 
1207   // Speculative type helper methods.
1208   virtual const Type* remove_speculative() const;
1209   virtual const TypePtr* with_inline_depth(int depth) const;
1210   virtual const TypePtr* with_instance_id(int instance_id) const;
1211 
1212   // the core of the computation of the meet of 2 types
1213   virtual const Type *xmeet_helper(const Type *t) const;
1214   virtual const Type *xdual() const;    // Compute dual right now.
1215 
1216   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1217   int stable_dimension() const;
1218 
1219   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1220 
<span class="line-added">1221   static jint max_array_length(BasicType etype) ;</span>
<span class="line-added">1222 </span>
1223   // Convenience common pre-built types.
1224   static const TypeAryPtr *RANGE;
1225   static const TypeAryPtr *OOPS;
1226   static const TypeAryPtr *NARROWOOPS;
1227   static const TypeAryPtr *BYTES;
1228   static const TypeAryPtr *SHORTS;
1229   static const TypeAryPtr *CHARS;
1230   static const TypeAryPtr *INTS;
1231   static const TypeAryPtr *LONGS;
1232   static const TypeAryPtr *FLOATS;
1233   static const TypeAryPtr *DOUBLES;
1234   // selects one of the above:
1235   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1236     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1237     return _array_body_type[elem];
1238   }
1239   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1240   // sharpen the type of an int which is used as an array size
1241 #ifdef ASSERT
1242   // One type is interface, the other is oop
</pre>
<hr />
<pre>
1594 
1595 inline const TypeD *Type::is_double_constant() const {
1596   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1597   return (TypeD*)this;
1598 }
1599 
1600 inline const TypeD *Type::isa_double_constant() const {
1601   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1602 }
1603 
1604 inline const TypeTuple *Type::is_tuple() const {
1605   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1606   return (TypeTuple*)this;
1607 }
1608 
1609 inline const TypeAry *Type::is_ary() const {
1610   assert( _base == Array , &quot;Not an Array&quot; );
1611   return (TypeAry*)this;
1612 }
1613 
<span class="line-added">1614 inline const TypeAry *Type::isa_ary() const {</span>
<span class="line-added">1615   return ((_base == Array) ? (TypeAry*)this : NULL);</span>
<span class="line-added">1616 }</span>
<span class="line-added">1617 </span>
1618 inline const TypeVect *Type::is_vect() const {
1619   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1620   return (TypeVect*)this;
1621 }
1622 
1623 inline const TypeVect *Type::isa_vect() const {
1624   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1625 }
1626 
1627 inline const TypePtr *Type::is_ptr() const {
1628   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1629   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1630   return (TypePtr*)this;
1631 }
1632 
1633 inline const TypePtr *Type::isa_ptr() const {
1634   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1635   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1636 }
1637 
</pre>
<hr />
<pre>
1774 #define CmpXNode     CmpLNode
1775 #define SubXNode     SubLNode
1776 #define LShiftXNode  LShiftLNode
1777 // For object size computation:
1778 #define AddXNode     AddLNode
1779 #define RShiftXNode  RShiftLNode
1780 // For card marks and hashcodes
1781 #define URShiftXNode URShiftLNode
1782 // UseOptoBiasInlining
1783 #define XorXNode     XorLNode
1784 #define StoreXConditionalNode StoreLConditionalNode
1785 #define LoadXNode    LoadLNode
1786 #define StoreXNode   StoreLNode
1787 // Opcodes
1788 #define Op_LShiftX   Op_LShiftL
1789 #define Op_AndX      Op_AndL
1790 #define Op_AddX      Op_AddL
1791 #define Op_SubX      Op_SubL
1792 #define Op_XorX      Op_XorL
1793 #define Op_URShiftX  Op_URShiftL
<span class="line-added">1794 #define Op_LoadX     Op_LoadL</span>
1795 // conversions
1796 #define ConvI2X(x)   ConvI2L(x)
1797 #define ConvL2X(x)   (x)
1798 #define ConvX2I(x)   ConvL2I(x)
1799 #define ConvX2L(x)   (x)
1800 #define ConvX2UL(x)  (x)
1801 
1802 #else
1803 
1804 // For type queries and asserts
1805 #define is_intptr_t  is_int
1806 #define isa_intptr_t isa_int
1807 #define find_intptr_t_type find_int_type
1808 #define find_intptr_t_con  find_int_con
1809 #define TypeX        TypeInt
1810 #define Type_X       Type::Int
1811 #define TypeX_X      TypeInt::INT
1812 #define TypeX_ZERO   TypeInt::ZERO
1813 // For &#39;ideal_reg&#39; machine registers
1814 #define Op_RegX      Op_RegI
</pre>
<hr />
<pre>
1822 #define CmpXNode     CmpINode
1823 #define SubXNode     SubINode
1824 #define LShiftXNode  LShiftINode
1825 // For object size computation:
1826 #define AddXNode     AddINode
1827 #define RShiftXNode  RShiftINode
1828 // For card marks and hashcodes
1829 #define URShiftXNode URShiftINode
1830 // UseOptoBiasInlining
1831 #define XorXNode     XorINode
1832 #define StoreXConditionalNode StoreIConditionalNode
1833 #define LoadXNode    LoadINode
1834 #define StoreXNode   StoreINode
1835 // Opcodes
1836 #define Op_LShiftX   Op_LShiftI
1837 #define Op_AndX      Op_AndI
1838 #define Op_AddX      Op_AddI
1839 #define Op_SubX      Op_SubI
1840 #define Op_XorX      Op_XorI
1841 #define Op_URShiftX  Op_URShiftI
<span class="line-added">1842 #define Op_LoadX     Op_LoadI</span>
1843 // conversions
1844 #define ConvI2X(x)   (x)
1845 #define ConvL2X(x)   ConvL2I(x)
1846 #define ConvX2I(x)   (x)
1847 #define ConvX2L(x)   ConvI2L(x)
1848 #define ConvX2UL(x)  ConvI2UL(x)
1849 
1850 #endif
1851 
1852 #endif // SHARE_OPTO_TYPE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
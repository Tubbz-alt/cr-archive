<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciTypeFlow.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/connode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/runtime.hpp&quot;
  36 #include &quot;opto/rootnode.hpp&quot;
  37 #include &quot;opto/subnode.hpp&quot;
  38 
  39 // Portions of code courtesy of Clifford Click
  40 
  41 // Optimization - Graph Style
  42 
  43 
  44 #ifndef PRODUCT
  45 extern int explicit_null_checks_elided;
  46 #endif
  47 
  48 //=============================================================================
  49 //------------------------------Value------------------------------------------
  50 // Return a tuple for whichever arm of the IF is reachable
  51 const Type* IfNode::Value(PhaseGVN* phase) const {
  52   if( !in(0) ) return Type::TOP;
  53   if( phase-&gt;type(in(0)) == Type::TOP )
  54     return Type::TOP;
  55   const Type *t = phase-&gt;type(in(1));
  56   if( t == Type::TOP )          // data is undefined
  57     return TypeTuple::IFNEITHER; // unreachable altogether
  58   if( t == TypeInt::ZERO )      // zero, or false
  59     return TypeTuple::IFFALSE;  // only false branch is reachable
  60   if( t == TypeInt::ONE )       // 1, or true
  61     return TypeTuple::IFTRUE;   // only true branch is reachable
  62   assert( t == TypeInt::BOOL, &quot;expected boolean type&quot; );
  63 
  64   return TypeTuple::IFBOTH;     // No progress
  65 }
  66 
  67 const RegMask &amp;IfNode::out_RegMask() const {
  68   return RegMask::Empty;
  69 }
  70 
  71 //------------------------------split_if---------------------------------------
  72 // Look for places where we merge constants, then test on the merged value.
  73 // If the IF test will be constant folded on the path with the constant, we
  74 // win by splitting the IF to before the merge point.
  75 static Node* split_if(IfNode *iff, PhaseIterGVN *igvn) {
  76   // I could be a lot more general here, but I&#39;m trying to squeeze this
  77   // in before the Christmas &#39;98 break so I&#39;m gonna be kinda restrictive
  78   // on the patterns I accept.  CNC
  79 
  80   // Look for a compare of a constant and a merged value
  81   Node *i1 = iff-&gt;in(1);
  82   if( !i1-&gt;is_Bool() ) return NULL;
  83   BoolNode *b = i1-&gt;as_Bool();
  84   Node *cmp = b-&gt;in(1);
  85   if( !cmp-&gt;is_Cmp() ) return NULL;
  86   i1 = cmp-&gt;in(1);
  87   if( i1 == NULL || !i1-&gt;is_Phi() ) return NULL;
  88   PhiNode *phi = i1-&gt;as_Phi();
  89   if( phi-&gt;is_copy() ) return NULL;
  90   Node *con2 = cmp-&gt;in(2);
  91   if( !con2-&gt;is_Con() ) return NULL;
  92   // See that the merge point contains some constants
  93   Node *con1=NULL;
  94   uint i4;
  95   for( i4 = 1; i4 &lt; phi-&gt;req(); i4++ ) {
  96     con1 = phi-&gt;in(i4);
  97     if( !con1 ) return NULL;    // Do not optimize partially collapsed merges
  98     if( con1-&gt;is_Con() ) break; // Found a constant
  99     // Also allow null-vs-not-null checks
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
 120   if (r-&gt;is_Loop() &amp;&amp; r-&gt;in(LoopNode::LoopBackControl)-&gt;is_top()) return NULL; // going away anyway
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
 141       }*/
 142       return NULL;
 143     }
 144     if( u != phi ) {
 145       // CNC - do not allow any other merged value
 146       //tty-&gt;print_cr(&quot;Merging another value&quot;);
 147       //u-&gt;dump(2);
 148       return NULL;
 149     }
 150     // Make sure we can account for all Phi uses
 151     for (DUIterator_Fast kmax, k = u-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 152       Node* v = u-&gt;fast_out(k); // User of the phi
 153       // CNC - Allow only really simple patterns.
 154       // In particular I disallow AddP of the Phi, a fairly common pattern
 155       if (v == cmp) continue;  // The compare is OK
 156       if (v-&gt;is_ConstraintCast()) {
 157         // If the cast is derived from data flow edges, it may not have a control edge.
 158         // If so, it should be safe to split. But follow-up code can not deal with
 159         // this (l. 359). So skip.
 160         if (v-&gt;in(0) == NULL) {
 161           return NULL;
 162         }
 163         if (v-&gt;in(0)-&gt;in(0) == iff) {
 164           continue;               // CastPP/II of the IfNode is OK
 165         }
 166       }
 167       // Disabled following code because I cannot tell if exactly one
 168       // path dominates without a real dominator check. CNC 9/9/1999
 169       //uint vop = v-&gt;Opcode();
 170       //if( vop == Op_Phi ) {     // Phi from another merge point might be OK
 171       //  Node *r = v-&gt;in(0);     // Get controlling point
 172       //  if( !r ) return NULL;   // Degraded to a copy
 173       //  // Find exactly one path in (either True or False doms, but not IFF)
 174       //  int cnt = 0;
 175       //  for( uint i = 1; i &lt; r-&gt;req(); i++ )
 176       //    if( r-&gt;in(i) &amp;&amp; r-&gt;in(i)-&gt;in(0) == iff )
 177       //      cnt++;
 178       //  if( cnt == 1 ) continue; // Exactly one of True or False guards Phi
 179       //}
 180       if( !v-&gt;is_Call() ) {
 181         /*
 182         if( v-&gt;Opcode() == Op_AddP ) {
 183           tty-&gt;print_cr(&quot;Phi has AddP use&quot;);
 184         } else if( v-&gt;Opcode() == Op_CastPP ) {
 185           tty-&gt;print_cr(&quot;Phi has CastPP use&quot;);
 186         } else if( v-&gt;Opcode() == Op_CastII ) {
 187           tty-&gt;print_cr(&quot;Phi has CastII use&quot;);
 188         } else {
 189           tty-&gt;print_cr(&quot;Phi has use I cant be bothered with&quot;);
 190         }
 191         */
 192       }
 193       return NULL;
 194 
 195       /* CNC - Cut out all the fancy acceptance tests
 196       // Can we clone this use when doing the transformation?
 197       // If all uses are from Phis at this merge or constants, then YES.
 198       if( !v-&gt;in(0) &amp;&amp; v != cmp ) {
 199         tty-&gt;print_cr(&quot;Phi has free-floating use&quot;);
 200         v-&gt;dump(2);
 201         return NULL;
 202       }
 203       for( uint l = 1; l &lt; v-&gt;req(); l++ ) {
 204         if( (!v-&gt;in(l)-&gt;is_Phi() || v-&gt;in(l)-&gt;in(0) != r) &amp;&amp;
 205             !v-&gt;in(l)-&gt;is_Con() ) {
 206           tty-&gt;print_cr(&quot;Phi has use&quot;);
 207           v-&gt;dump(2);
 208           return NULL;
 209         } // End of if Phi-use input is neither Phi nor Constant
 210       } // End of for all inputs to Phi-use
 211       */
 212     } // End of for all uses of Phi
 213   } // End of for all uses of Region
 214 
 215   // Only do this if the IF node is in a sane state
 216   if (iff-&gt;outcnt() != 2)
 217     return NULL;
 218 
 219   // Got a hit!  Do the Mondo Hack!
 220   //
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;
 241   Node* predicate_proj = NULL;
 242   int nb_predicate_proj = 0;
 243   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 244     if (phi-&gt;in(ii) == con1) {
 245       req_c++;
 246     }
 247     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 248     if (proj != NULL) {
 249       nb_predicate_proj++;
 250       predicate_proj = proj;
 251     }
 252   }
 253 
 254   // If all the defs of the phi are the same constant, we already have the desired end state.
 255   // Skip the split that would create empty phi and region nodes.
 256   if((r-&gt;req() - req_c) == 1) {
 257     return NULL;
 258   }
 259 
 260   if (nb_predicate_proj &gt; 1) {
 261     // Can happen in case of loop unswitching and when the loop is
 262     // optimized out: it&#39;s not a loop anymore so we don&#39;t care about
 263     // predicates.
 264     assert(!r-&gt;is_Loop(), &quot;this must not be a loop anymore&quot;);
 265     predicate_proj = NULL;
 266   }
 267   Node* predicate_c = NULL;
 268   Node* predicate_x = NULL;
 269   bool counted_loop = r-&gt;is_CountedLoop();
 270   if (counted_loop) {
 271     // Ignore counted loops for now because the split-if logic does not work
 272     // in all the cases (for example, with strip mined loops). Also, above
 273     // checks only pass for already degraded loops without a tripcount phi
 274     // and these are essentially dead and will go away during igvn.
 275     return NULL;
 276   }
 277 
 278   Node *region_c = new RegionNode(req_c + 1);
 279   Node *phi_c    = con1;
 280   uint  len      = r-&gt;req();
 281   Node *region_x = new RegionNode(len - req_c);
 282   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 283   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 284     if (phi-&gt;in(i) == con1) {
 285       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
 286       if (r-&gt;in(i) == predicate_proj)
 287         predicate_c = predicate_proj;
 288     } else {
 289       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 290       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
 291       if (r-&gt;in(i) == predicate_proj)
 292         predicate_x = predicate_proj;
 293     }
 294   }
 295   if (predicate_c != NULL &amp;&amp; (req_c &gt; 1)) {
 296     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);
 297     predicate_c = NULL; // Do not clone predicate below merge point
 298   }
 299   if (predicate_x != NULL &amp;&amp; ((len - req_c) &gt; 2)) {
 300     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);
 301     predicate_x = NULL; // Do not clone predicate below merge point
 302   }
 303 
 304   // Register the new RegionNodes but do not transform them.  Cannot
 305   // transform until the entire Region/Phi conglomerate has been hacked
 306   // as a single huge transform.
 307   igvn-&gt;register_new_node_with_optimizer( region_c );
 308   igvn-&gt;register_new_node_with_optimizer( region_x );
 309   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 310   // about to get one.  If this only use goes away, then phi_x will look dead.
 311   // However, he will be picking up some more uses down below.
 312   Node *hook = new Node(4);
 313   hook-&gt;init_req(0, phi_x);
 314   hook-&gt;init_req(1, phi_c);
 315   phi_x = phase-&gt;transform( phi_x );
 316 
 317   // Make the compare
 318   Node *cmp_c = phase-&gt;makecon(t);
 319   Node *cmp_x = cmp-&gt;clone();
 320   cmp_x-&gt;set_req(1,phi_x);
 321   cmp_x-&gt;set_req(2,con2);
 322   cmp_x = phase-&gt;transform(cmp_x);
 323   // Make the bool
 324   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 325   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 326   // Make the IfNode
 327   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 328   iff_c-&gt;set_req(0, region_c);
 329   iff_c-&gt;set_req(1, b_c);
 330   igvn-&gt;set_type_bottom(iff_c);
 331   igvn-&gt;_worklist.push(iff_c);
 332   hook-&gt;init_req(2, iff_c);
 333 
 334   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 335   iff_x-&gt;set_req(0, region_x);
 336   iff_x-&gt;set_req(1, b_x);
 337   igvn-&gt;set_type_bottom(iff_x);
 338   igvn-&gt;_worklist.push(iff_x);
 339   hook-&gt;init_req(3, iff_x);
 340 
 341   // Make the true/false arms
 342   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 343   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
 344   if (predicate_c != NULL) {
 345     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);
 346     // Clone loop predicates to each path
 347     iff_c_t = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_t, !counted_loop);
 348     iff_c_f = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_f, !counted_loop);
 349   }
 350   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 351   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
 352   if (predicate_x != NULL) {
 353     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);
 354     // Clone loop predicates to each path
 355     iff_x_t = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_t, !counted_loop);
 356     iff_x_f = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_f, !counted_loop);
 357   }
 358 
 359   // Merge the TRUE paths
 360   Node *region_s = new RegionNode(3);
 361   igvn-&gt;_worklist.push(region_s);
 362   region_s-&gt;init_req(1, iff_c_t);
 363   region_s-&gt;init_req(2, iff_x_t);
 364   igvn-&gt;register_new_node_with_optimizer( region_s );
 365 
 366   // Merge the FALSE paths
 367   Node *region_f = new RegionNode(3);
 368   igvn-&gt;_worklist.push(region_f);
 369   region_f-&gt;init_req(1, iff_c_f);
 370   region_f-&gt;init_req(2, iff_x_f);
 371   igvn-&gt;register_new_node_with_optimizer( region_f );
 372 
 373   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 374   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 375   cmp-&gt;set_req(2,NULL);
 376   // Check for all uses of the Phi and give them a new home.
 377   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
 378   Node *phi_s = NULL;     // do not construct unless needed
 379   Node *phi_f = NULL;     // do not construct unless needed
 380   for (DUIterator_Last i2min, i2 = phi-&gt;last_outs(i2min); i2 &gt;= i2min; --i2) {
 381     Node* v = phi-&gt;last_out(i2);// User of the phi
 382     igvn-&gt;rehash_node_delayed(v); // Have to fixup other Phi users
 383     uint vop = v-&gt;Opcode();
 384     Node *proj = NULL;
 385     if( vop == Op_Phi ) {       // Remote merge point
 386       Node *r = v-&gt;in(0);
 387       for (uint i3 = 1; i3 &lt; r-&gt;req(); i3++)
 388         if (r-&gt;in(i3) &amp;&amp; r-&gt;in(i3)-&gt;in(0) == iff) {
 389           proj = r-&gt;in(i3);
 390           break;
 391         }
 392     } else if( v-&gt;is_ConstraintCast() ) {
 393       proj = v-&gt;in(0);          // Controlling projection
 394     } else {
 395       assert( 0, &quot;do not know how to handle this guy&quot; );
 396     }
 397     guarantee(proj != NULL, &quot;sanity&quot;);
 398 
 399     Node *proj_path_data, *proj_path_ctrl;
 400     if( proj-&gt;Opcode() == Op_IfTrue ) {
 401       if( phi_s == NULL ) {
 402         // Only construct phi_s if needed, otherwise provides
 403         // interfering use.
 404         phi_s = PhiNode::make_blank(region_s,phi);
 405         phi_s-&gt;init_req( 1, phi_c );
 406         phi_s-&gt;init_req( 2, phi_x );
 407         hook-&gt;add_req(phi_s);
 408         phi_s = phase-&gt;transform(phi_s);
 409       }
 410       proj_path_data = phi_s;
 411       proj_path_ctrl = region_s;
 412     } else {
 413       if( phi_f == NULL ) {
 414         // Only construct phi_f if needed, otherwise provides
 415         // interfering use.
 416         phi_f = PhiNode::make_blank(region_f,phi);
 417         phi_f-&gt;init_req( 1, phi_c );
 418         phi_f-&gt;init_req( 2, phi_x );
 419         hook-&gt;add_req(phi_f);
 420         phi_f = phase-&gt;transform(phi_f);
 421       }
 422       proj_path_data = phi_f;
 423       proj_path_ctrl = region_f;
 424     }
 425 
 426     // Fixup &#39;v&#39; for for the split
 427     if( vop == Op_Phi ) {       // Remote merge point
 428       uint i;
 429       for( i = 1; i &lt; v-&gt;req(); i++ )
 430         if( v-&gt;in(i) == phi )
 431           break;
 432       v-&gt;set_req(i, proj_path_data );
 433     } else if( v-&gt;is_ConstraintCast() ) {
 434       v-&gt;set_req(0, proj_path_ctrl );
 435       v-&gt;set_req(1, proj_path_data );
 436     } else
 437       ShouldNotReachHere();
 438   }
 439 
 440   // Now replace the original iff&#39;s True/False with region_s/region_t.
 441   // This makes the original iff go dead.
 442   for (DUIterator_Last i3min, i3 = iff-&gt;last_outs(i3min); i3 &gt;= i3min; --i3) {
 443     Node* p = iff-&gt;last_out(i3);
 444     assert( p-&gt;Opcode() == Op_IfTrue || p-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
 445     Node *u = (p-&gt;Opcode() == Op_IfTrue) ? region_s : region_f;
 446     // Replace p with u
 447     igvn-&gt;add_users_to_worklist(p);
 448     for (DUIterator_Last lmin, l = p-&gt;last_outs(lmin); l &gt;= lmin;) {
 449       Node* x = p-&gt;last_out(l);
 450       igvn-&gt;hash_delete(x);
 451       uint uses_found = 0;
 452       for( uint j = 0; j &lt; x-&gt;req(); j++ ) {
 453         if( x-&gt;in(j) == p ) {
 454           x-&gt;set_req(j, u);
 455           uses_found++;
 456         }
 457       }
 458       l -= uses_found;    // we deleted 1 or more copies of this edge
 459     }
 460     igvn-&gt;remove_dead_node(p);
 461   }
 462 
 463   // Force the original merge dead
 464   igvn-&gt;hash_delete(r);
 465   // First, remove region&#39;s dead users.
 466   for (DUIterator_Last lmin, l = r-&gt;last_outs(lmin); l &gt;= lmin;) {
 467     Node* u = r-&gt;last_out(l);
 468     if( u == r ) {
 469       r-&gt;set_req(0, NULL);
 470     } else {
 471       assert(u-&gt;outcnt() == 0, &quot;only dead users&quot;);
 472       igvn-&gt;remove_dead_node(u);
 473     }
 474     l -= 1;
 475   }
 476   igvn-&gt;remove_dead_node(r);
 477 
 478   // Now remove the bogus extra edges used to keep things alive
 479   igvn-&gt;remove_dead_node( hook );
 480 
 481   // Must return either the original node (now dead) or a new node
 482   // (Do not return a top here, since that would break the uniqueness of top.)
 483   return new ConINode(TypeInt::ZERO);
 484 }
 485 
 486 // if this IfNode follows a range check pattern return the projection
 487 // for the failed path
 488 ProjNode* IfNode::range_check_trap_proj(int&amp; flip_test, Node*&amp; l, Node*&amp; r) {
 489   if (outcnt() != 2) {
 490     return NULL;
 491   }
 492   Node* b = in(1);
 493   if (b == NULL || !b-&gt;is_Bool())  return NULL;
 494   BoolNode* bn = b-&gt;as_Bool();
 495   Node* cmp = bn-&gt;in(1);
 496   if (cmp == NULL)  return NULL;
 497   if (cmp-&gt;Opcode() != Op_CmpU)  return NULL;
 498 
 499   l = cmp-&gt;in(1);
 500   r = cmp-&gt;in(2);
 501   flip_test = 1;
 502   if (bn-&gt;_test._test == BoolTest::le) {
 503     l = cmp-&gt;in(2);
 504     r = cmp-&gt;in(1);
 505     flip_test = 2;
 506   } else if (bn-&gt;_test._test != BoolTest::lt) {
 507     return NULL;
 508   }
 509   if (l-&gt;is_top())  return NULL;   // Top input means dead test
 510   if (r-&gt;Opcode() != Op_LoadRange &amp;&amp; !is_RangeCheck())  return NULL;
 511 
 512   // We have recognized one of these forms:
 513   //  Flip 1:  If (Bool[&lt;] CmpU(l, LoadRange)) ...
 514   //  Flip 2:  If (Bool[&lt;=] CmpU(LoadRange, l)) ...
 515 
 516   ProjNode* iftrap = proj_out_or_null(flip_test == 2 ? true : false);
 517   return iftrap;
 518 }
 519 
 520 
 521 //------------------------------is_range_check---------------------------------
 522 // Return 0 if not a range check.  Return 1 if a range check and set index and
 523 // offset.  Return 2 if we had to negate the test.  Index is NULL if the check
 524 // is versus a constant.
 525 int RangeCheckNode::is_range_check(Node* &amp;range, Node* &amp;index, jint &amp;offset) {
 526   int flip_test = 0;
 527   Node* l = NULL;
 528   Node* r = NULL;
 529   ProjNode* iftrap = range_check_trap_proj(flip_test, l, r);
 530 
 531   if (iftrap == NULL) {
 532     return 0;
 533   }
 534 
 535   // Make sure it&#39;s a real range check by requiring an uncommon trap
 536   // along the OOB path.  Otherwise, it&#39;s possible that the user wrote
 537   // something which optimized to look like a range check but behaves
 538   // in some other way.
 539   if (iftrap-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {
 540     return 0;
 541   }
 542 
 543   // Look for index+offset form
 544   Node* ind = l;
 545   jint  off = 0;
 546   if (l-&gt;is_top()) {
 547     return 0;
 548   } else if (l-&gt;Opcode() == Op_AddI) {
 549     if ((off = l-&gt;in(1)-&gt;find_int_con(0)) != 0) {
 550       ind = l-&gt;in(2)-&gt;uncast();
 551     } else if ((off = l-&gt;in(2)-&gt;find_int_con(0)) != 0) {
 552       ind = l-&gt;in(1)-&gt;uncast();
 553     }
 554   } else if ((off = l-&gt;find_int_con(-1)) &gt;= 0) {
 555     // constant offset with no variable index
 556     ind = NULL;
 557   } else {
 558     // variable index with no constant offset (or dead negative index)
 559     off = 0;
 560   }
 561 
 562   // Return all the values:
 563   index  = ind;
 564   offset = off;
 565   range  = r;
 566   return flip_test;
 567 }
 568 
 569 //------------------------------adjust_check-----------------------------------
 570 // Adjust (widen) a prior range check
 571 static void adjust_check(Node* proj, Node* range, Node* index,
 572                          int flip, jint off_lo, PhaseIterGVN* igvn) {
 573   PhaseGVN *gvn = igvn;
 574   // Break apart the old check
 575   Node *iff = proj-&gt;in(0);
 576   Node *bol = iff-&gt;in(1);
 577   if( bol-&gt;is_top() ) return;   // In case a partially dead range check appears
 578   // bail (or bomb[ASSERT/DEBUG]) if NOT projection--&gt;IfNode--&gt;BoolNode
 579   DEBUG_ONLY( if( !bol-&gt;is_Bool() ) { proj-&gt;dump(3); fatal(&quot;Expect projection--&gt;IfNode--&gt;BoolNode&quot;); } )
 580   if( !bol-&gt;is_Bool() ) return;
 581 
 582   Node *cmp = bol-&gt;in(1);
 583   // Compute a new check
 584   Node *new_add = gvn-&gt;intcon(off_lo);
 585   if( index ) {
 586     new_add = off_lo ? gvn-&gt;transform(new AddINode( index, new_add )) : index;
 587   }
 588   Node *new_cmp = (flip == 1)
 589     ? new CmpUNode( new_add, range )
 590     : new CmpUNode( range, new_add );
 591   new_cmp = gvn-&gt;transform(new_cmp);
 592   // See if no need to adjust the existing check
 593   if( new_cmp == cmp ) return;
 594   // Else, adjust existing check
 595   Node *new_bol = gvn-&gt;transform( new BoolNode( new_cmp, bol-&gt;as_Bool()-&gt;_test._test ) );
 596   igvn-&gt;rehash_node_delayed( iff );
 597   iff-&gt;set_req_X( 1, new_bol, igvn );
 598 }
 599 
 600 //------------------------------up_one_dom-------------------------------------
 601 // Walk up the dominator tree one step.  Return NULL at root or true
 602 // complex merges.  Skips through small diamonds.
 603 Node* IfNode::up_one_dom(Node *curr, bool linear_only) {
 604   Node *dom = curr-&gt;in(0);
 605   if( !dom )                    // Found a Region degraded to a copy?
 606     return curr-&gt;nonnull_req(); // Skip thru it
 607 
 608   if( curr != dom )             // Normal walk up one step?
 609     return dom;
 610 
 611   // Use linear_only if we are still parsing, since we cannot
 612   // trust the regions to be fully filled in.
 613   if (linear_only)
 614     return NULL;
 615 
 616   if( dom-&gt;is_Root() )
 617     return NULL;
 618 
 619   // Else hit a Region.  Check for a loop header
 620   if( dom-&gt;is_Loop() )
 621     return dom-&gt;in(1);          // Skip up thru loops
 622 
 623   // Check for small diamonds
 624   Node *din1, *din2, *din3, *din4;
 625   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 626       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 627       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 628       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 629       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 630     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 631         (din3 = din3-&gt;in(0)) )
 632       din3 = din3-&gt;in(0);
 633     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 634         (din4 = din4-&gt;in(0)) )
 635       din4 = din4-&gt;in(0);
 636     if( din3 == din4 &amp;&amp; din3-&gt;is_If() )
 637       return din3;              // Skip around diamonds
 638   }
 639 
 640   // Give up the search at true merges
 641   return NULL;                  // Dead loop?  Or hit root?
 642 }
 643 
 644 
 645 //------------------------------filtered_int_type--------------------------------
 646 // Return a possibly more restrictive type for val based on condition control flow for an if
 647 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node *val, Node* if_proj) {
 648   assert(if_proj &amp;&amp;
 649          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 650   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 651     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 652     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 653       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 654       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 655         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 656         if (cmp-&gt;in(1) == val) {
 657           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 658           if (cmp2_t != NULL) {
 659             jint lo = cmp2_t-&gt;_lo;
 660             jint hi = cmp2_t-&gt;_hi;
 661             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 662             switch (msk) {
 663             case BoolTest::ne:
 664               // Can&#39;t refine type
 665               return NULL;
 666             case BoolTest::eq:
 667               return cmp2_t;
 668             case BoolTest::lt:
 669               lo = TypeInt::INT-&gt;_lo;
 670               if (hi - 1 &lt; hi) {
 671                 hi = hi - 1;
 672               }
 673               break;
 674             case BoolTest::le:
 675               lo = TypeInt::INT-&gt;_lo;
 676               break;
 677             case BoolTest::gt:
 678               if (lo + 1 &gt; lo) {
 679                 lo = lo + 1;
 680               }
 681               hi = TypeInt::INT-&gt;_hi;
 682               break;
 683             case BoolTest::ge:
 684               // lo unchanged
 685               hi = TypeInt::INT-&gt;_hi;
 686               break;
 687             default:
 688               break;
 689             }
 690             const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t-&gt;_widen);
 691             return rtn_t;
 692           }
 693         }
 694       }
 695     }
 696   }
 697   return NULL;
 698 }
 699 
 700 //------------------------------fold_compares----------------------------
 701 // See if a pair of CmpIs can be converted into a CmpU.  In some cases
 702 // the direction of this if is determined by the preceding if so it
 703 // can be eliminate entirely.
 704 //
 705 // Given an if testing (CmpI n v) check for an immediately control
 706 // dependent if that is testing (CmpI n v2) and has one projection
 707 // leading to this if and the other projection leading to a region
 708 // that merges one of this ifs control projections.
 709 //
 710 //                   If
 711 //                  / |
 712 //                 /  |
 713 //                /   |
 714 //              If    |
 715 //              /\    |
 716 //             /  \   |
 717 //            /    \  |
 718 //           /    Region
 719 //
 720 // Or given an if testing (CmpI n v) check for a dominating if that is
 721 // testing (CmpI n v2), both having one projection leading to an
 722 // uncommon trap. Allow Another independent guard in between to cover
 723 // an explicit range check:
 724 // if (index &lt; 0 || index &gt;= array.length) {
 725 // which may need a null check to guard the LoadRange
 726 //
 727 //                   If
 728 //                  / \
 729 //                 /   \
 730 //                /     \
 731 //              If      unc
 732 //              /\
 733 //             /  \
 734 //            /    \
 735 //           /      unc
 736 //
 737 
 738 // Is the comparison for this If suitable for folding?
 739 bool IfNode::cmpi_folds(PhaseIterGVN* igvn) {
 740   return in(1) != NULL &amp;&amp;
 741     in(1)-&gt;is_Bool() &amp;&amp;
 742     in(1)-&gt;in(1) != NULL &amp;&amp;
 743     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 744     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 745     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 746     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
 747      in(1)-&gt;as_Bool()-&gt;_test.is_greater());
 748 }
 749 
 750 // Is a dominating control suitable for folding with this if?
 751 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 752   return ctrl != NULL &amp;&amp;
 753     ctrl-&gt;is_Proj() &amp;&amp;
 754     ctrl-&gt;in(0) != NULL &amp;&amp;
 755     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 756     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
 757     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn) &amp;&amp;
 758     // Must compare same value
 759     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 760     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 761 }
 762 
 763 // Do this If and the dominating If share a region?
 764 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 765   ProjNode* otherproj = proj-&gt;other_if_proj();
 766   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 767   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 768   success = NULL;
 769   fail = NULL;
 770 
 771   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 772     for (int i = 0; i &lt; 2; i++) {
 773       ProjNode* proj = proj_out(i);
 774       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 775         success = proj;
 776       } else if (fail == NULL) {
 777         fail = proj;
 778       } else {
 779         success = fail = NULL;
 780       }
 781     }
 782   }
 783   return success != NULL &amp;&amp; fail != NULL;
 784 }
 785 
 786 bool IfNode::is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc) {
 787   // Different methods and methods containing jsrs are not supported.
 788   ciMethod* method = unc-&gt;jvms()-&gt;method();
 789   ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 790   if (method != dom_method || method-&gt;has_jsrs()) {
 791     return false;
 792   }
 793   // Check that both traps are in the same activation of the method (instead
 794   // of two activations being inlined through different call sites) by verifying
 795   // that the call stacks are equal for both JVMStates.
 796   JVMState* dom_caller = dom_unc-&gt;jvms()-&gt;caller();
 797   JVMState* caller = unc-&gt;jvms()-&gt;caller();
 798   if ((dom_caller == NULL) != (caller == NULL)) {
 799     // The current method must either be inlined into both dom_caller and
 800     // caller or must not be inlined at all (top method). Bail out otherwise.
 801     return false;
 802   } else if (dom_caller != NULL &amp;&amp; !dom_caller-&gt;same_calls_as(caller)) {
 803     return false;
 804   }
 805   // Check that the bci of the dominating uncommon trap dominates the bci
 806   // of the dominated uncommon trap. Otherwise we may not re-execute
 807   // the dominated check after deoptimization from the merged uncommon trap.
 808   ciTypeFlow* flow = dom_method-&gt;get_flow_analysis();
 809   int bci = unc-&gt;jvms()-&gt;bci();
 810   int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 811   if (!flow-&gt;is_dominated_by(bci, dom_bci)) {
 812     return false;
 813   }
 814 
 815   return true;
 816 }
 817 
 818 // Return projection that leads to an uncommon trap if any
 819 ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*&amp; call) const {
 820   for (int i = 0; i &lt; 2; i++) {
 821     call = proj_out(i)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 822     if (call != NULL) {
 823       return proj_out(i);
 824     }
 825   }
 826   return NULL;
 827 }
 828 
 829 // Do this If and the dominating If both branch out to an uncommon trap
 830 bool IfNode::has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn) {
 831   ProjNode* otherproj = proj-&gt;other_if_proj();
 832   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 833 
 834   if (otherproj-&gt;outcnt() == 1 &amp;&amp; dom_unc != NULL) {
 835     // We need to re-execute the folded Ifs after deoptimization from the merged traps
 836     if (!dom_unc-&gt;jvms()-&gt;should_reexecute()) {
 837       return false;
 838     }
 839 
 840     CallStaticJavaNode* unc = NULL;
 841     ProjNode* unc_proj = uncommon_trap_proj(unc);
 842     if (unc_proj != NULL &amp;&amp; unc_proj-&gt;outcnt() == 1) {
 843       if (dom_unc == unc) {
 844         // Allow the uncommon trap to be shared through a region
 845         RegionNode* r = unc-&gt;in(0)-&gt;as_Region();
 846         if (r-&gt;outcnt() != 2 || r-&gt;req() != 3 || r-&gt;find_edge(otherproj) == -1 || r-&gt;find_edge(unc_proj) == -1) {
 847           return false;
 848         }
 849         assert(r-&gt;has_phi() == NULL, &quot;simple region shouldn&#39;t have a phi&quot;);
 850       } else if (dom_unc-&gt;in(0) != otherproj || unc-&gt;in(0) != unc_proj) {
 851         return false;
 852       }
 853 
 854       if (!is_dominator_unc(dom_unc, unc)) {
 855         return false;
 856       }
 857 
 858       // See merge_uncommon_traps: the reason of the uncommon trap
 859       // will be changed and the state of the dominating If will be
 860       // used. Checked that we didn&#39;t apply this transformation in a
 861       // previous compilation and it didn&#39;t cause too many traps
 862       ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 863       int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 864       if (!igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_unstable_fused_if) &amp;&amp;
 865           !igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check)) {
 866         success = unc_proj;
 867         fail = unc_proj-&gt;other_if_proj();
 868         return true;
 869       }
 870     }
 871   }
 872   return false;
 873 }
 874 
 875 // Check that the 2 CmpI can be folded into as single CmpU and proceed with the folding
 876 bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
 877   Node* this_cmp = in(1)-&gt;in(1);
 878   BoolNode* this_bool = in(1)-&gt;as_Bool();
 879   IfNode* dom_iff = proj-&gt;in(0)-&gt;as_If();
 880   BoolNode* dom_bool = dom_iff-&gt;in(1)-&gt;as_Bool();
 881   Node* lo = dom_iff-&gt;in(1)-&gt;in(1)-&gt;in(2);
 882   Node* hi = this_cmp-&gt;in(2);
 883   Node* n = this_cmp-&gt;in(1);
 884   ProjNode* otherproj = proj-&gt;other_if_proj();
 885 
 886   const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);
 887   const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);
 888 
 889   BoolTest::mask lo_test = dom_bool-&gt;_test._test;
 890   BoolTest::mask hi_test = this_bool-&gt;_test._test;
 891   BoolTest::mask cond = hi_test;
 892 
 893   // convert:
 894   //
 895   //          dom_bool = x {&lt;,&lt;=,&gt;,&gt;=} a
 896   //                           / \
 897   //     proj = {True,False}  /   \ otherproj = {False,True}
 898   //                         /
 899   //        this_bool = x {&lt;,&lt;=} b
 900   //                       / \
 901   //  fail = {True,False} /   \ success = {False,True}
 902   //                     /
 903   //
 904   // (Second test guaranteed canonicalized, first one may not have
 905   // been canonicalized yet)
 906   //
 907   // into:
 908   //
 909   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 910   //                       / \
 911   //                 fail /   \ success
 912   //                     /
 913   //
 914 
 915   // Figure out which of the two tests sets the upper bound and which
 916   // sets the lower bound if any.
 917   Node* adjusted_lim = NULL;
 918   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
 919       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint) {
 920     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 921            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 922     // this test was canonicalized
 923     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 924 
 925     // this_bool = &lt;
 926     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 927     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 928     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 929     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 930     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 931     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 932     // this_bool = &lt;=
 933     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 934     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 935     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 936     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 937     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 938     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 939     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 940     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 941 
 942     if (hi_test == BoolTest::lt) {
 943       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 944         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 945       }
 946     } else {
 947       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 948       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 949         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 950         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 951         cond = BoolTest::lt;
 952       } else {
 953         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 954         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 955         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 956         cond = BoolTest::lt;
 957       }
 958     }
 959   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
 960              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint) {
 961 
 962     // this_bool = &lt;
 963     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 964     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 965     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 966     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 967     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 968     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 969     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 970     // this_bool = &lt;=
 971     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 972     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 973     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 974     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 975     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 976     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 977     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 978 
 979     swap(lo, hi);
 980     swap(lo_type, hi_type);
 981     swap(lo_test, hi_test);
 982 
 983     assert((dom_bool-&gt;_test.is_less() &amp;&amp; proj-&gt;_con) ||
 984            (dom_bool-&gt;_test.is_greater() &amp;&amp; !proj-&gt;_con), &quot;incorrect test&quot;);
 985     // this test was canonicalized
 986     assert(this_bool-&gt;_test.is_less() &amp;&amp; !fail-&gt;_con, &quot;incorrect test&quot;);
 987 
 988     cond = (hi_test == BoolTest::le || hi_test == BoolTest::gt) ? BoolTest::gt : BoolTest::ge;
 989 
 990     if (lo_test == BoolTest::lt) {
 991       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 992         cond = BoolTest::ge;
 993       } else {
 994         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 995         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 996         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 997         cond = BoolTest::ge;
 998       }
 999     } else if (lo_test == BoolTest::le) {
1000       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
1001         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
1002         cond = BoolTest::ge;
1003       } else {
1004         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
1005         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1006         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
1007         cond = BoolTest::ge;
1008       }
1009     }
1010   } else {
1011     const TypeInt* failtype  = filtered_int_type(igvn, n, proj);
1012     if (failtype != NULL) {
1013       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
1014       if (type2 != NULL) {
1015         failtype = failtype-&gt;join(type2)-&gt;is_int();
1016         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
1017           // previous if determines the result of this if so
1018           // replace Bool with constant
1019           igvn-&gt;_worklist.push(in(1));
1020           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
1021           return true;
1022         }
1023       }
1024     }
1025     lo = NULL;
1026     hi = NULL;
1027   }
1028 
1029   if (lo &amp;&amp; hi) {
1030     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
1031     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
1032     if (adjusted_lim == NULL) {
1033       adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1034     }
1035     Node* newcmp = igvn-&gt;transform(new CmpUNode(adjusted_val, adjusted_lim));
1036     Node* newbool = igvn-&gt;transform(new BoolNode(newcmp, cond));
1037 
1038     igvn-&gt;replace_input_of(dom_iff, 1, igvn-&gt;intcon(proj-&gt;_con));
1039     igvn-&gt;_worklist.push(in(1));
1040     igvn-&gt;replace_input_of(this, 1, newbool);
1041 
1042     return true;
1043   }
1044   return false;
1045 }
1046 
1047 // Merge the branches that trap for this If and the dominating If into
1048 // a single region that branches to the uncommon trap for the
1049 // dominating If
1050 Node* IfNode::merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
1051   Node* res = this;
1052   assert(success-&gt;in(0) == this, &quot;bad projection&quot;);
1053 
1054   ProjNode* otherproj = proj-&gt;other_if_proj();
1055 
1056   CallStaticJavaNode* unc = success-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1057   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1058 
1059   if (unc != dom_unc) {
1060     Node* r = new RegionNode(3);
1061 
1062     r-&gt;set_req(1, otherproj);
1063     r-&gt;set_req(2, success);
1064     r = igvn-&gt;transform(r);
1065     assert(r-&gt;is_Region(), &quot;can&#39;t go away&quot;);
1066 
1067     // Make both If trap at the state of the first If: once the CmpI
1068     // nodes are merged, if we trap we don&#39;t know which of the CmpI
1069     // nodes would have caused the trap so we have to restart
1070     // execution at the first one
1071     igvn-&gt;replace_input_of(dom_unc, 0, r);
1072     igvn-&gt;replace_input_of(unc, 0, igvn-&gt;C-&gt;top());
1073   }
1074   int trap_request = dom_unc-&gt;uncommon_trap_request();
1075   Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1076   Deoptimization::DeoptAction action = Deoptimization::trap_request_action(trap_request);
1077 
1078   int flip_test = 0;
1079   Node* l = NULL;
1080   Node* r = NULL;
1081 
1082   if (success-&gt;in(0)-&gt;as_If()-&gt;range_check_trap_proj(flip_test, l, r) != NULL) {
1083     // If this looks like a range check, change the trap to
1084     // Reason_range_check so the compiler recognizes it as a range
1085     // check and applies the corresponding optimizations
1086     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_range_check, action);
1087 
1088     improve_address_types(l, r, fail, igvn);
1089 
1090     res = igvn-&gt;transform(new RangeCheckNode(in(0), in(1), _prob, _fcnt));
1091   } else if (unc != dom_unc) {
1092     // If we trap we won&#39;t know what CmpI would have caused the trap
1093     // so use a special trap reason to mark this pair of CmpI nodes as
1094     // bad candidate for folding. On recompilation we won&#39;t fold them
1095     // and we may trap again but this time we&#39;ll know what branch
1096     // traps
1097     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_unstable_fused_if, action);
1098   }
1099   igvn-&gt;replace_input_of(dom_unc, TypeFunc::Parms, igvn-&gt;intcon(trap_request));
1100   return res;
1101 }
1102 
1103 // If we are turning 2 CmpI nodes into a CmpU that follows the pattern
1104 // of a rangecheck on index i, on 64 bit the compares may be followed
1105 // by memory accesses using i as index. In that case, the CmpU tells
1106 // us something about the values taken by i that can help the compiler
1107 // (see Compile::conv_I2X_index())
1108 void IfNode::improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn) {
1109 #ifdef _LP64
1110   ResourceMark rm;
1111   Node_Stack stack(2);
1112 
1113   assert(r-&gt;Opcode() == Op_LoadRange, &quot;unexpected range check&quot;);
1114   const TypeInt* array_size = igvn-&gt;type(r)-&gt;is_int();
1115 
1116   stack.push(l, 0);
1117 
1118   while(stack.size() &gt; 0) {
1119     Node* n = stack.node();
1120     uint start = stack.index();
1121 
1122     uint i = start;
1123     for (; i &lt; n-&gt;outcnt(); i++) {
1124       Node* use = n-&gt;raw_out(i);
1125       if (stack.size() == 1) {
1126         if (use-&gt;Opcode() == Op_ConvI2L) {
1127           const TypeLong* bounds = use-&gt;as_Type()-&gt;type()-&gt;is_long();
1128           if (bounds-&gt;_lo &lt;= array_size-&gt;_lo &amp;&amp; bounds-&gt;_hi &gt;= array_size-&gt;_hi &amp;&amp;
1129               (bounds-&gt;_lo != array_size-&gt;_lo || bounds-&gt;_hi != array_size-&gt;_hi)) {
1130             stack.set_index(i+1);
1131             stack.push(use, 0);
1132             break;
1133           }
1134         }
1135       } else if (use-&gt;is_Mem()) {
1136         Node* ctrl = use-&gt;in(0);
1137         for (int i = 0; i &lt; 10 &amp;&amp; ctrl != NULL &amp;&amp; ctrl != fail; i++) {
1138           ctrl = up_one_dom(ctrl);
1139         }
1140         if (ctrl == fail) {
1141           Node* init_n = stack.node_at(1);
1142           assert(init_n-&gt;Opcode() == Op_ConvI2L, &quot;unexpected first node&quot;);
1143           // Create a new narrow ConvI2L node that is dependent on the range check
1144           Node* new_n = igvn-&gt;C-&gt;conv_I2X_index(igvn, l, array_size, fail);
1145 
1146           // The type of the ConvI2L may be widen and so the new
1147           // ConvI2L may not be better than an existing ConvI2L
1148           if (new_n != init_n) {
1149             for (uint j = 2; j &lt; stack.size(); j++) {
1150               Node* n = stack.node_at(j);
1151               Node* clone = n-&gt;clone();
1152               int rep = clone-&gt;replace_edge(init_n, new_n);
1153               assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1154               clone = igvn-&gt;transform(clone);
1155               init_n = n;
1156               new_n = clone;
1157             }
1158             igvn-&gt;hash_delete(use);
1159             int rep = use-&gt;replace_edge(init_n, new_n);
1160             assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1161             igvn-&gt;transform(use);
1162             if (init_n-&gt;outcnt() == 0) {
1163               igvn-&gt;_worklist.push(init_n);
1164             }
1165           }
1166         }
1167       } else if (use-&gt;in(0) == NULL &amp;&amp; (igvn-&gt;type(use)-&gt;isa_long() ||
1168                                         igvn-&gt;type(use)-&gt;isa_ptr())) {
1169         stack.set_index(i+1);
1170         stack.push(use, 0);
1171         break;
1172       }
1173     }
1174     if (i == n-&gt;outcnt()) {
1175       stack.pop();
1176     }
1177   }
1178 #endif
1179 }
1180 
1181 bool IfNode::is_cmp_with_loadrange(ProjNode* proj) {
1182   if (in(1) != NULL &amp;&amp;
1183       in(1)-&gt;in(1) != NULL &amp;&amp;
1184       in(1)-&gt;in(1)-&gt;in(2) != NULL) {
1185     Node* other = in(1)-&gt;in(1)-&gt;in(2);
1186     if (other-&gt;Opcode() == Op_LoadRange &amp;&amp;
1187         ((other-&gt;in(0) != NULL &amp;&amp; other-&gt;in(0) == proj) ||
1188          (other-&gt;in(0) == NULL &amp;&amp;
1189           other-&gt;in(2) != NULL &amp;&amp;
1190           other-&gt;in(2)-&gt;is_AddP() &amp;&amp;
1191           other-&gt;in(2)-&gt;in(1) != NULL &amp;&amp;
1192           other-&gt;in(2)-&gt;in(1)-&gt;Opcode() == Op_CastPP &amp;&amp;
1193           other-&gt;in(2)-&gt;in(1)-&gt;in(0) == proj))) {
1194       return true;
1195     }
1196   }
1197   return false;
1198 }
1199 
1200 bool IfNode::is_null_check(ProjNode* proj, PhaseIterGVN* igvn) {
1201   Node* other = in(1)-&gt;in(1)-&gt;in(2);
1202   if (other-&gt;in(MemNode::Address) != NULL &amp;&amp;
1203       proj-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1204       proj-&gt;in(0)-&gt;in(1)-&gt;is_Bool() &amp;&amp;
1205       proj-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
1206       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1207       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
1208       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == other-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;uncast() &amp;&amp;
1209       igvn-&gt;type(proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)) == TypePtr::NULL_PTR) {
1210     return true;
1211   }
1212   return false;
1213 }
1214 
1215 // Check that the If that is in between the 2 integer comparisons has
1216 // no side effect
1217 bool IfNode::is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn) {
1218   if (proj == NULL) {
1219     return false;
1220   }
1221   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1222   if (unc != NULL &amp;&amp; proj-&gt;outcnt() &lt;= 2) {
1223     if (proj-&gt;outcnt() == 1 ||
1224         // Allow simple null check from LoadRange
1225         (is_cmp_with_loadrange(proj) &amp;&amp; is_null_check(proj, igvn))) {
1226       CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1227       CallStaticJavaNode* dom_unc = proj-&gt;in(0)-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1228       assert(dom_unc != NULL, &quot;is_uncommon_trap_if_pattern returned NULL&quot;);
1229 
1230       // reroute_side_effect_free_unc changes the state of this
1231       // uncommon trap to restart execution at the previous
1232       // CmpI. Check that this change in a previous compilation didn&#39;t
1233       // cause too many traps.
1234       int trap_request = unc-&gt;uncommon_trap_request();
1235       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1236 
1237       if (igvn-&gt;C-&gt;too_many_traps(dom_unc-&gt;jvms()-&gt;method(), dom_unc-&gt;jvms()-&gt;bci(), reason)) {
1238         return false;
1239       }
1240 
1241       if (!is_dominator_unc(dom_unc, unc)) {
1242         return false;
1243       }
1244 
1245       return true;
1246     }
1247   }
1248   return false;
1249 }
1250 
1251 // Make the If between the 2 integer comparisons trap at the state of
1252 // the first If: the last CmpI is the one replaced by a CmpU and the
1253 // first CmpI is eliminated, so the test between the 2 CmpI nodes
1254 // won&#39;t be guarded by the first CmpI anymore. It can trap in cases
1255 // where the first CmpI would have prevented it from executing: on a
1256 // trap, we need to restart execution at the state of the first CmpI
1257 void IfNode::reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn) {
1258   CallStaticJavaNode* dom_unc = dom_proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1259   ProjNode* otherproj = proj-&gt;other_if_proj();
1260   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1261   Node* call_proj = dom_unc-&gt;unique_ctrl_out();
1262   Node* halt = call_proj-&gt;unique_ctrl_out();
1263 
1264   Node* new_unc = dom_unc-&gt;clone();
1265   call_proj = call_proj-&gt;clone();
1266   halt = halt-&gt;clone();
1267   Node* c = otherproj-&gt;clone();
1268 
1269   c = igvn-&gt;transform(c);
1270   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1271   new_unc-&gt;set_req(0, c);
1272   new_unc = igvn-&gt;transform(new_unc);
1273   call_proj-&gt;set_req(0, new_unc);
1274   call_proj = igvn-&gt;transform(call_proj);
1275   halt-&gt;set_req(0, call_proj);
1276   halt = igvn-&gt;transform(halt);
1277 
1278   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1279   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1280 }
1281 
1282 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1283   if (Opcode() != Op_If) return NULL;
1284 
1285   if (cmpi_folds(igvn)) {
1286     Node* ctrl = in(0);
1287     if (is_ctrl_folds(ctrl, igvn) &amp;&amp;
1288         ctrl-&gt;outcnt() == 1) {
1289       // A integer comparison immediately dominated by another integer
1290       // comparison
1291       ProjNode* success = NULL;
1292       ProjNode* fail = NULL;
1293       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1294       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1295           // Next call modifies graph so must be last
1296           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1297         return this;
1298       }
1299       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1300           // Next call modifies graph so must be last
1301           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1302         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1303       }
1304       return NULL;
1305     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1306                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1307       ProjNode* success = NULL;
1308       ProjNode* fail = NULL;
1309       Node* dom = ctrl-&gt;in(0)-&gt;in(0);
1310       ProjNode* dom_cmp = dom-&gt;isa_Proj();
1311       ProjNode* other_cmp = ctrl-&gt;isa_Proj();
1312 
1313       // Check if it&#39;s an integer comparison dominated by another
1314       // integer comparison with another test in between
1315       if (is_ctrl_folds(dom, igvn) &amp;&amp;
1316           has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1317           is_side_effect_free_test(other_cmp, igvn) &amp;&amp;
1318           // Next call modifies graph so must be last
1319           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1320         reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);
1321         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1322       }
1323     }
1324   }
1325   return NULL;
1326 }
1327 
1328 //------------------------------remove_useless_bool----------------------------
1329 // Check for people making a useless boolean: things like
1330 // if( (x &lt; y ? true : false) ) { ... }
1331 // Replace with if( x &lt; y ) { ... }
1332 static Node *remove_useless_bool(IfNode *iff, PhaseGVN *phase) {
1333   Node *i1 = iff-&gt;in(1);
1334   if( !i1-&gt;is_Bool() ) return NULL;
1335   BoolNode *bol = i1-&gt;as_Bool();
1336 
1337   Node *cmp = bol-&gt;in(1);
1338   if( cmp-&gt;Opcode() != Op_CmpI ) return NULL;
1339 
1340   // Must be comparing against a bool
1341   const Type *cmp2_t = phase-&gt;type( cmp-&gt;in(2) );
1342   if( cmp2_t != TypeInt::ZERO &amp;&amp;
1343       cmp2_t != TypeInt::ONE )
1344     return NULL;
1345 
1346   // Find a prior merge point merging the boolean
1347   i1 = cmp-&gt;in(1);
1348   if( !i1-&gt;is_Phi() ) return NULL;
1349   PhiNode *phi = i1-&gt;as_Phi();
1350   if( phase-&gt;type( phi ) != TypeInt::BOOL )
1351     return NULL;
1352 
1353   // Check for diamond pattern
1354   int true_path = phi-&gt;is_diamond_phi();
1355   if( true_path == 0 ) return NULL;
1356 
1357   // Make sure that iff and the control of the phi are different. This
1358   // should really only happen for dead control flow since it requires
1359   // an illegal cycle.
1360   if (phi-&gt;in(0)-&gt;in(1)-&gt;in(0) == iff) return NULL;
1361 
1362   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1363   BoolNode *bol2 = phi-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
1364 
1365   // Now get the &#39;sense&#39; of the test correct so we can plug in
1366   // either iff2-&gt;in(1) or its complement.
1367   int flip = 0;
1368   if( bol-&gt;_test._test == BoolTest::ne ) flip = 1-flip;
1369   else if( bol-&gt;_test._test != BoolTest::eq ) return NULL;
1370   if( cmp2_t == TypeInt::ZERO ) flip = 1-flip;
1371 
1372   const Type *phi1_t = phase-&gt;type( phi-&gt;in(1) );
1373   const Type *phi2_t = phase-&gt;type( phi-&gt;in(2) );
1374   // Check for Phi(0,1) and flip
1375   if( phi1_t == TypeInt::ZERO ) {
1376     if( phi2_t != TypeInt::ONE ) return NULL;
1377     flip = 1-flip;
1378   } else {
1379     // Check for Phi(1,0)
1380     if( phi1_t != TypeInt::ONE  ) return NULL;
1381     if( phi2_t != TypeInt::ZERO ) return NULL;
1382   }
1383   if( true_path == 2 ) {
1384     flip = 1-flip;
1385   }
1386 
1387   Node* new_bol = (flip ? phase-&gt;transform( bol2-&gt;negate(phase) ) : bol2);
1388   assert(new_bol != iff-&gt;in(1), &quot;must make progress&quot;);
1389   iff-&gt;set_req(1, new_bol);
1390   // Intervening diamond probably goes dead
1391   phase-&gt;C-&gt;set_major_progress();
1392   return iff;
1393 }
1394 
1395 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff);
1396 
1397 struct RangeCheck {
1398   Node* ctl;
1399   jint off;
1400 };
1401 
1402 Node* IfNode::Ideal_common(PhaseGVN *phase, bool can_reshape) {
1403   if (remove_dead_region(phase, can_reshape))  return this;
1404   // No Def-Use info?
1405   if (!can_reshape)  return NULL;
1406 
1407   // Don&#39;t bother trying to transform a dead if
1408   if (in(0)-&gt;is_top())  return NULL;
1409   // Don&#39;t bother trying to transform an if with a dead test
1410   if (in(1)-&gt;is_top())  return NULL;
1411   // Another variation of a dead test
1412   if (in(1)-&gt;is_Con())  return NULL;
1413   // Another variation of a dead if
1414   if (outcnt() &lt; 2)  return NULL;
1415 
1416   // Canonicalize the test.
1417   Node* idt_if = idealize_test(phase, this);
1418   if (idt_if != NULL)  return idt_if;
1419 
1420   // Try to split the IF
1421   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1422   Node *s = split_if(this, igvn);
1423   if (s != NULL)  return s;
1424 
1425   return NodeSentinel;
1426 }
1427 
1428 //------------------------------Ideal------------------------------------------
1429 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1430 // control copies
1431 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1432   Node* res = Ideal_common(phase, can_reshape);
1433   if (res != NodeSentinel) {
1434     return res;
1435   }
1436 
1437   // Check for people making a useless boolean: things like
1438   // if( (x &lt; y ? true : false) ) { ... }
1439   // Replace with if( x &lt; y ) { ... }
1440   Node *bol2 = remove_useless_bool(this, phase);
1441   if( bol2 ) return bol2;
1442 
1443   if (in(0) == NULL) return NULL;     // Dead loop?
1444 
1445   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1446   Node* result = fold_compares(igvn);
1447   if (result != NULL) {
1448     return result;
1449   }
1450 
1451   // Scan for an equivalent test
1452   Node *cmp;
1453   int dist = 0;               // Cutoff limit for search
1454   int op = Opcode();
1455   if( op == Op_If &amp;&amp;
1456       (cmp=in(1)-&gt;in(1))-&gt;Opcode() == Op_CmpP ) {
1457     if( cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead
1458         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR ) {
1459       dist = 64;              // Limit for null-pointer scans
1460     } else {
1461       dist = 4;               // Do not bother for random pointer tests
1462     }
1463   } else {
1464     dist = 4;                 // Limit for random junky scans
1465   }
1466 
1467   Node* prev_dom = search_identical(dist);
1468 
1469   if (prev_dom == NULL) {
1470     return NULL;
1471   }
1472 
1473   // Replace dominated IfNode
1474   return dominated_by(prev_dom, igvn);
1475 }
1476 
1477 //------------------------------dominated_by-----------------------------------
1478 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1479 #ifndef PRODUCT
1480   if (TraceIterativeGVN) {
1481     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1482   }
1483   if (VerifyOpto &amp;&amp; !igvn-&gt;allow_progress()) {
1484     // Found an equivalent dominating test,
1485     // we can not guarantee reaching a fix-point for these during iterativeGVN
1486     // since intervening nodes may not change.
1487     return NULL;
1488   }
1489 #endif
1490 
1491   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1492   Node *idom = in(0);
1493   // Need opcode to decide which way &#39;this&#39; test goes
1494   int prev_op = prev_dom-&gt;Opcode();
1495   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1496 
1497   // Loop predicates may have depending checks which should not
1498   // be skipped. For example, range check predicate has two checks
1499   // for lower and upper bounds.
1500   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1501   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1502       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1503     prev_dom = idom;
1504   }
1505 
1506   // Now walk the current IfNode&#39;s projections.
1507   // Loop ends when &#39;this&#39; has no more uses.
1508   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
1509     Node *ifp = last_out(i);     // Get IfTrue/IfFalse
1510     igvn-&gt;add_users_to_worklist(ifp);
1511     // Check which projection it is and set target.
1512     // Data-target is either the dominating projection of the same type
1513     // or TOP if the dominating projection is of opposite type.
1514     // Data-target will be used as the new control edge for the non-CFG
1515     // nodes like Casts and Loads.
1516     Node *data_target = (ifp-&gt;Opcode() == prev_op) ? prev_dom : top;
1517     // Control-target is just the If&#39;s immediate dominator or TOP.
1518     Node *ctrl_target = (ifp-&gt;Opcode() == prev_op) ?     idom : top;
1519 
1520     // For each child of an IfTrue/IfFalse projection, reroute.
1521     // Loop ends when projection has no more uses.
1522     for (DUIterator_Last jmin, j = ifp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
1523       Node* s = ifp-&gt;last_out(j);   // Get child of IfTrue/IfFalse
1524       if( !s-&gt;depends_only_on_test() ) {
1525         // Find the control input matching this def-use edge.
1526         // For Regions it may not be in slot 0.
1527         uint l;
1528         for( l = 0; s-&gt;in(l) != ifp; l++ ) { }
1529         igvn-&gt;replace_input_of(s, l, ctrl_target);
1530       } else {                      // Else, for control producers,
1531         igvn-&gt;replace_input_of(s, 0, data_target); // Move child to data-target
1532       }
1533     } // End for each child of a projection
1534 
1535     igvn-&gt;remove_dead_node(ifp);
1536   } // End for each IfTrue/IfFalse child of If
1537 
1538   // Kill the IfNode
1539   igvn-&gt;remove_dead_node(this);
1540 
1541   // Must return either the original node (now dead) or a new node
1542   // (Do not return a top here, since that would break the uniqueness of top.)
1543   return new ConINode(TypeInt::ZERO);
1544 }
1545 
1546 Node* IfNode::search_identical(int dist) {
1547   // Setup to scan up the CFG looking for a dominating test
1548   Node* dom = in(0);
1549   Node* prev_dom = this;
1550   int op = Opcode();
1551   // Search up the dominator tree for an If with an identical test
1552   while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1553          dom-&gt;in(1)    != in(1) ||  // Not same input 1?
1554          prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1555     if (dist &lt; 0) return NULL;
1556 
1557     dist--;
1558     prev_dom = dom;
1559     dom = up_one_dom(dom);
1560     if (!dom) return NULL;
1561   }
1562 
1563   // Check that we did not follow a loop back to ourselves
1564   if (this == dom) {
1565     return NULL;
1566   }
1567 
1568 #ifndef PRODUCT
1569   if (dist &gt; 2) { // Add to count of NULL checks elided
1570     explicit_null_checks_elided++;
1571   }
1572 #endif
1573 
1574   return prev_dom;
1575 }
1576 
1577 //------------------------------Identity---------------------------------------
1578 // If the test is constant &amp; we match, then we are the input Control
1579 Node* IfProjNode::Identity(PhaseGVN* phase) {
1580   // Can only optimize if cannot go the other way
1581   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1582   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1583        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1584        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1585       (!phase-&gt;is_IterGVN() ||
1586        // During IGVN, first wait for the dead branch to be killed.
1587        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1588        // that doesn&#39;t go away because it still has uses and this branch of the
1589        // If) which breaks other optimizations. Node::has_special_unique_user()
1590        // will cause this node to be reprocessed once the dead branch is killed.
1591        in(0)-&gt;outcnt() == 1))) {
1592     // IfNode control
1593     return in(0)-&gt;in(0);
1594   }
1595   // no progress
1596   return this;
1597 }
1598 
1599 #ifndef PRODUCT
1600 //-------------------------------related---------------------------------------
1601 // An IfProjNode&#39;s related node set consists of its input (an IfNode) including
1602 // the IfNode&#39;s condition, plus all of its outputs at level 1. In compact mode,
1603 // the restrictions for IfNode apply (see IfNode::rel).
1604 void IfProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1605   Node* ifNode = this-&gt;in(0);
1606   in_rel-&gt;append(ifNode);
1607   if (compact) {
1608     ifNode-&gt;collect_nodes(in_rel, 3, false, true);
1609   } else {
1610     ifNode-&gt;collect_nodes_in_all_data(in_rel, false);
1611   }
1612   this-&gt;collect_nodes(out_rel, -1, false, false);
1613 }
1614 
1615 //------------------------------dump_spec--------------------------------------
1616 void IfNode::dump_spec(outputStream *st) const {
1617   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob,_fcnt);
1618 }
1619 
1620 //-------------------------------related---------------------------------------
1621 // For an IfNode, the set of related output nodes is just the output nodes till
1622 // depth 2, i.e, the IfTrue/IfFalse projection nodes plus the nodes they refer.
1623 // The related input nodes contain no control nodes, but all data nodes
1624 // pertaining to the condition. In compact mode, the input nodes are collected
1625 // up to a depth of 3.
1626 void IfNode::related(GrowableArray &lt;Node *&gt; *in_rel, GrowableArray &lt;Node *&gt; *out_rel, bool compact) const {
1627   if (compact) {
1628     this-&gt;collect_nodes(in_rel, 3, false, true);
1629   } else {
1630     this-&gt;collect_nodes_in_all_data(in_rel, false);
1631   }
1632   this-&gt;collect_nodes(out_rel, -2, false, false);
1633 }
1634 #endif
1635 
1636 //------------------------------idealize_test----------------------------------
1637 // Try to canonicalize tests better.  Peek at the Cmp/Bool/If sequence and
1638 // come up with a canonical sequence.  Bools getting &#39;eq&#39;, &#39;gt&#39; and &#39;ge&#39; forms
1639 // converted to &#39;ne&#39;, &#39;le&#39; and &#39;lt&#39; forms.  IfTrue/IfFalse get swapped as
1640 // needed.
1641 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff) {
1642   assert(iff-&gt;in(0) != NULL, &quot;If must be live&quot;);
1643 
1644   if (iff-&gt;outcnt() != 2)  return NULL; // Malformed projections.
1645   Node* old_if_f = iff-&gt;proj_out(false);
1646   Node* old_if_t = iff-&gt;proj_out(true);
1647 
1648   // CountedLoopEnds want the back-control test to be TRUE, irregardless of
1649   // whether they are testing a &#39;gt&#39; or &#39;lt&#39; condition.  The &#39;gt&#39; condition
1650   // happens in count-down loops
1651   if (iff-&gt;is_CountedLoopEnd())  return NULL;
1652   if (!iff-&gt;in(1)-&gt;is_Bool())  return NULL; // Happens for partially optimized IF tests
1653   BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
1654   BoolTest bt = b-&gt;_test;
1655   // Test already in good order?
1656   if( bt.is_canonical() )
1657     return NULL;
1658 
1659   // Flip test to be canonical.  Requires flipping the IfFalse/IfTrue and
1660   // cloning the IfNode.
1661   Node* new_b = phase-&gt;transform( new BoolNode(b-&gt;in(1), bt.negate()) );
1662   if( !new_b-&gt;is_Bool() ) return NULL;
1663   b = new_b-&gt;as_Bool();
1664 
1665   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1666   assert( igvn, &quot;Test is not canonical in parser?&quot; );
1667 
1668   // The IF node never really changes, but it needs to be cloned
1669   iff = iff-&gt;clone()-&gt;as_If();
1670   iff-&gt;set_req(1, b);
1671   iff-&gt;_prob = 1.0-iff-&gt;_prob;
1672 
1673   Node *prior = igvn-&gt;hash_find_insert(iff);
1674   if( prior ) {
1675     igvn-&gt;remove_dead_node(iff);
1676     iff = (IfNode*)prior;
1677   } else {
1678     // Cannot call transform on it just yet
1679     igvn-&gt;set_type_bottom(iff);
1680   }
1681   igvn-&gt;_worklist.push(iff);
1682 
1683   // Now handle projections.  Cloning not required.
1684   Node* new_if_f = (Node*)(new IfFalseNode( iff ));
1685   Node* new_if_t = (Node*)(new IfTrueNode ( iff ));
1686 
1687   igvn-&gt;register_new_node_with_optimizer(new_if_f);
1688   igvn-&gt;register_new_node_with_optimizer(new_if_t);
1689   // Flip test, so flip trailing control
1690   igvn-&gt;replace_node(old_if_f, new_if_t);
1691   igvn-&gt;replace_node(old_if_t, new_if_f);
1692 
1693   // Progress
1694   return iff;
1695 }
1696 
1697 Node* RangeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1698   Node* res = Ideal_common(phase, can_reshape);
1699   if (res != NodeSentinel) {
1700     return res;
1701   }
1702 
1703   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1704   // Setup to scan up the CFG looking for a dominating test
1705   Node* prev_dom = this;
1706 
1707   // Check for range-check vs other kinds of tests
1708   Node* index1;
1709   Node* range1;
1710   jint offset1;
1711   int flip1 = is_range_check(range1, index1, offset1);
1712   if (flip1) {
1713     Node* dom = in(0);
1714     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1715     // so all checks we inspect post-dominate the top-most check we find.
1716     // If we are going to fail the current check and we reach the top check
1717     // then we are guaranteed to fail, so just start interpreting there.
1718     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1719     // checks.
1720 
1721     // The top 3 range checks seen
1722     const int NRC =3;
1723     RangeCheck prev_checks[NRC];
1724     int nb_checks = 0;
1725 
1726     // Low and high offsets seen so far
1727     jint off_lo = offset1;
1728     jint off_hi = offset1;
1729 
1730     bool found_immediate_dominator = false;
1731 
1732     // Scan for the top checks and collect range of offsets
1733     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1734       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1735           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1736         if (dom == this) return NULL; // dead loop
1737         // See if this is a range check
1738         Node* index2;
1739         Node* range2;
1740         jint offset2;
1741         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1742         // See if this is a _matching_ range check, checking against
1743         // the same array bounds.
1744         if (flip2 == flip1 &amp;&amp; range2 == range1 &amp;&amp; index2 == index1 &amp;&amp;
1745             dom-&gt;outcnt() == 2) {
1746           if (nb_checks == 0 &amp;&amp; dom-&gt;in(1) == in(1)) {
1747             // Found an immediately dominating test at the same offset.
1748             // This kind of back-to-back test can be eliminated locally,
1749             // and there is no need to search further for dominating tests.
1750             assert(offset2 == offset1, &quot;Same test but different offsets&quot;);
1751             found_immediate_dominator = true;
1752             break;
1753           }
1754           // Gather expanded bounds
1755           off_lo = MIN2(off_lo,offset2);
1756           off_hi = MAX2(off_hi,offset2);
1757           // Record top NRC range checks
1758           prev_checks[nb_checks%NRC].ctl = prev_dom;
1759           prev_checks[nb_checks%NRC].off = offset2;
1760           nb_checks++;
1761         }
1762       }
1763       prev_dom = dom;
1764       dom = up_one_dom(dom);
1765       if (!dom) break;
1766     }
1767 
1768     if (!found_immediate_dominator) {
1769       // Attempt to widen the dominating range check to cover some later
1770       // ones.  Since range checks &quot;fail&quot; by uncommon-trapping to the
1771       // interpreter, widening a check can make us speculatively enter
1772       // the interpreter.  If we see range-check deopt&#39;s, do not widen!
1773       if (!phase-&gt;C-&gt;allow_range_check_smearing())  return NULL;
1774 
1775       // Didn&#39;t find prior covering check, so cannot remove anything.
1776       if (nb_checks == 0) {
1777         return NULL;
1778       }
1779       // Constant indices only need to check the upper bound.
1780       // Non-constant indices must check both low and high.
1781       int chk0 = (nb_checks - 1) % NRC;
1782       if (index1) {
1783         if (nb_checks == 1) {
1784           return NULL;
1785         } else {
1786           // If the top range check&#39;s constant is the min or max of
1787           // all constants we widen the next one to cover the whole
1788           // range of constants.
1789           RangeCheck rc0 = prev_checks[chk0];
1790           int chk1 = (nb_checks - 2) % NRC;
1791           RangeCheck rc1 = prev_checks[chk1];
1792           if (rc0.off == off_lo) {
1793             adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1794             prev_dom = rc1.ctl;
1795           } else if (rc0.off == off_hi) {
1796             adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1797             prev_dom = rc1.ctl;
1798           } else {
1799             // If the top test&#39;s constant is not the min or max of all
1800             // constants, we need 3 range checks. We must leave the
1801             // top test unchanged because widening it would allow the
1802             // accesses it protects to successfully read/write out of
1803             // bounds.
1804             if (nb_checks == 2) {
1805               return NULL;
1806             }
1807             int chk2 = (nb_checks - 3) % NRC;
1808             RangeCheck rc2 = prev_checks[chk2];
1809             // The top range check a+i covers interval: -a &lt;= i &lt; length-a
1810             // The second range check b+i covers interval: -b &lt;= i &lt; length-b
1811             if (rc1.off &lt;= rc0.off) {
1812               // if b &lt;= a, we change the second range check to:
1813               // -min_of_all_constants &lt;= i &lt; length-min_of_all_constants
1814               // Together top and second range checks now cover:
1815               // -min_of_all_constants &lt;= i &lt; length-a
1816               // which is more restrictive than -b &lt;= i &lt; length-b:
1817               // -b &lt;= -min_of_all_constants &lt;= i &lt; length-a &lt;= length-b
1818               // The third check is then changed to:
1819               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1820               // so 2nd and 3rd checks restrict allowed values of i to:
1821               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1822               adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1823               adjust_check(rc2.ctl, range1, index1, flip1, off_hi, igvn);
1824             } else {
1825               // if b &gt; a, we change the second range check to:
1826               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1827               // Together top and second range checks now cover:
1828               // -a &lt;= i &lt; length-max_of_all_constants
1829               // which is more restrictive than -b &lt;= i &lt; length-b:
1830               // -b &lt; -a &lt;= i &lt; length-max_of_all_constants &lt;= length-b
1831               // The third check is then changed to:
1832               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1833               // so 2nd and 3rd checks restrict allowed values of i to:
1834               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1835               adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1836               adjust_check(rc2.ctl, range1, index1, flip1, off_lo, igvn);
1837             }
1838             prev_dom = rc2.ctl;
1839           }
1840         }
1841       } else {
1842         RangeCheck rc0 = prev_checks[chk0];
1843         // &#39;Widen&#39; the offset of the 1st and only covering check
1844         adjust_check(rc0.ctl, range1, index1, flip1, off_hi, igvn);
1845         // Test is now covered by prior checks, dominate it out
1846         prev_dom = rc0.ctl;
1847       }
1848     }
1849   } else {
1850     prev_dom = search_identical(4);
1851 
1852     if (prev_dom == NULL) {
1853       return NULL;
1854     }
1855   }
1856 
1857   // Replace dominated IfNode
1858   return dominated_by(prev_dom, igvn);
1859 }
    </pre>
  </body>
</html>
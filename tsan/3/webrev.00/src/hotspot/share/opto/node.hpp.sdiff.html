<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="opaquenode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 
  36 
  37 class AbstractLockNode;
  38 class AddNode;
  39 class AddPNode;
  40 class AliasInfo;
  41 class AllocateArrayNode;
  42 class AllocateNode;
  43 class ArrayCopyNode;
  44 class Block;
  45 class BoolNode;
  46 class BoxLockNode;
  47 class CMoveNode;
  48 class CallDynamicJavaNode;
  49 class CallJavaNode;
  50 class CallLeafNode;
  51 class CallNode;
  52 class CallRuntimeNode;
  53 class CallStaticJavaNode;
  54 class CastIINode;

  55 class CatchNode;
  56 class CatchProjNode;
  57 class CheckCastPPNode;
  58 class ClearArrayNode;
  59 class CmpNode;
  60 class CodeBuffer;
  61 class ConstraintCastNode;
  62 class ConNode;
  63 class CompareAndSwapNode;
  64 class CompareAndExchangeNode;
  65 class CountedLoopNode;
  66 class CountedLoopEndNode;
  67 class DecodeNarrowPtrNode;
  68 class DecodeNNode;
  69 class DecodeNKlassNode;
  70 class EncodeNarrowPtrNode;
  71 class EncodePNode;
  72 class EncodePKlassNode;
  73 class FastLockNode;
  74 class FastUnlockNode;

  75 class IfNode;
  76 class IfProjNode;
  77 class IfFalseNode;
  78 class IfTrueNode;
  79 class InitializeNode;
  80 class JVMState;
  81 class JumpNode;
  82 class JumpProjNode;
  83 class LoadNode;
<span class="line-removed">  84 class LoadBarrierNode;</span>
<span class="line-removed">  85 class LoadBarrierSlowRegNode;</span>
<span class="line-removed">  86 class LoadBarrierWeakSlowRegNode;</span>
  87 class LoadStoreNode;

  88 class LockNode;
  89 class LoopNode;
  90 class MachBranchNode;
  91 class MachCallDynamicJavaNode;
  92 class MachCallJavaNode;
  93 class MachCallLeafNode;
  94 class MachCallNode;
  95 class MachCallRuntimeNode;
  96 class MachCallStaticJavaNode;
  97 class MachConstantBaseNode;
  98 class MachConstantNode;
  99 class MachGotoNode;
 100 class MachIfNode;
 101 class MachJumpNode;
 102 class MachNode;
 103 class MachNullCheckNode;
 104 class MachProjNode;
 105 class MachReturnNode;
 106 class MachSafePointNode;
 107 class MachSpillCopyNode;
</pre>
<hr />
<pre>
 125 class Node_Stack;
 126 class NullCheckNode;
 127 class OopMap;
 128 class ParmNode;
 129 class PCTableNode;
 130 class PhaseCCP;
 131 class PhaseGVN;
 132 class PhaseIterGVN;
 133 class PhaseRegAlloc;
 134 class PhaseTransform;
 135 class PhaseValues;
 136 class PhiNode;
 137 class Pipeline;
 138 class ProjNode;
 139 class RangeCheckNode;
 140 class RegMask;
 141 class RegionNode;
 142 class RootNode;
 143 class SafePointNode;
 144 class SafePointScalarObjectNode;
<span class="line-removed"> 145 class ShenandoahBarrierNode;</span>
 146 class StartNode;
 147 class State;
 148 class StoreNode;
 149 class SubNode;

 150 class Type;
 151 class TypeNode;
 152 class UnlockNode;
 153 class VectorNode;
 154 class LoadVectorNode;
 155 class StoreVectorNode;
 156 class VectorSet;
 157 typedef void (*NFunc)(Node&amp;,void*);
 158 extern &quot;C&quot; {
 159   typedef int (*C_sort_func_t)(const void *, const void *);
 160 }
 161 
 162 // The type of all node counts and indexes.
 163 // It must hold at least 16 bits, but must also be fast to load and store.
 164 // This type, if less than 32 bits, could limit the number of possible nodes.
 165 // (To make this type platform-specific, move to globalDefinitions_xxx.hpp.)
 166 typedef unsigned int node_idx_t;
 167 
 168 
 169 #ifndef OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 376   // Use this accessor sparingly.  We are going trying to use iterators instead.
 377   Node* raw_out(uint i) const { assert(i &lt; _outcnt,&quot;oob&quot;); return _out[i]; }
 378   // Return the unique out edge.
 379   Node* unique_out() const { assert(_outcnt==1,&quot;not unique&quot;); return _out[0]; }
 380   // Delete out edge at position &#39;i&#39; by moving last out edge to position &#39;i&#39;
 381   void  raw_del_out(uint i) {
 382     assert(i &lt; _outcnt,&quot;oob&quot;);
 383     assert(_outcnt &gt; 0,&quot;oob&quot;);
 384     #if OPTO_DU_ITERATOR_ASSERT
 385     // Record that a change happened here.
 386     debug_only(_last_del = _out[i]; ++_del_tick);
 387     #endif
 388     _out[i] = _out[--_outcnt];
 389     // Smash the old edge so it can&#39;t be used accidentally.
 390     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 391   }
 392 
 393 #ifdef ASSERT
 394   bool is_dead() const;
 395 #define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)-&gt;is_dead()))

 396 #endif
 397   // Check whether node has become unreachable
 398   bool is_unreachable(PhaseIterGVN &amp;igvn) const;
 399 
 400   // Set a required input edge, also updates corresponding output edge
 401   void add_req( Node *n ); // Append a NEW required input
 402   void add_req( Node *n0, Node *n1 ) {
 403     add_req(n0); add_req(n1); }
 404   void add_req( Node *n0, Node *n1, Node *n2 ) {
 405     add_req(n0); add_req(n1); add_req(n2); }
 406   void add_req_batch( Node* n, uint m ); // Append m NEW required inputs (all n).
 407   void del_req( uint idx ); // Delete required edge &amp; compact
 408   void del_req_ordered( uint idx ); // Delete required edge &amp; compact with preserved order
 409   void ins_req( uint i, Node *n ); // Insert a NEW required input
 410   void set_req( uint i, Node *n ) {
 411     assert( is_not_dead(n), &quot;can not use dead node&quot;);
 412     assert( i &lt; _cnt, &quot;oob: i=%d, _cnt=%d&quot;, i, _cnt);
 413     assert( !VerifyHashTableKeys || _hash_lock == 0,
 414             &quot;remove node from hash table before modifying it&quot;);
 415     Node** p = &amp;_in[i];    // cache this._in, across the del_out call
</pre>
<hr />
<pre>
 440         break;
 441       }
 442     }
 443     return -1;
 444   }
 445   int replace_edge(Node* old, Node* neww);
 446   int replace_edges_in_range(Node* old, Node* neww, int start, int end);
 447   // NULL out all inputs to eliminate incoming Def-Use edges.
 448   // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 449   int  disconnect_inputs(Node *n, Compile *c);
 450 
 451   // Quickly, return true if and only if I am Compile::current()-&gt;top().
 452   bool is_top() const {
 453     assert((this == (Node*) Compile::current()-&gt;top()) == (_out == NULL), &quot;&quot;);
 454     return (_out == NULL);
 455   }
 456   // Reaffirm invariants for is_top.  (Only from Compile::set_cached_top_node.)
 457   void setup_is_top();
 458 
 459   // Strip away casting.  (It is depth-limited.)
<span class="line-modified"> 460   Node* uncast() const;</span>
 461   // Return whether two Nodes are equivalent, after stripping casting.
<span class="line-modified"> 462   bool eqv_uncast(const Node* n) const {</span>
<span class="line-modified"> 463     return (this-&gt;uncast() == n-&gt;uncast());</span>
 464   }
 465 
 466   // Find out of current node that matches opcode.
 467   Node* find_out_with(int opcode);
 468   // Return true if the current node has an out that matches opcode.
 469   bool has_out_with(int opcode);
 470   // Return true if the current node has an out that matches any of the opcodes.
 471   bool has_out_with(int opcode1, int opcode2, int opcode3, int opcode4);
 472 
 473 private:
<span class="line-modified"> 474   static Node* uncast_helper(const Node* n);</span>
 475 
 476   // Add an output edge to the end of the list
 477   void add_out( Node *n ) {
 478     if (is_top())  return;
 479     if( _outcnt == _outmax ) out_grow(_outcnt);
 480     _out[_outcnt++] = n;
 481   }
 482   // Delete an output edge
 483   void del_out( Node *n ) {
 484     if (is_top())  return;
 485     Node** outp = &amp;_out[_outcnt];
 486     // Find and remove n
 487     do {
 488       assert(outp &gt; _out, &quot;Missing Def-Use edge&quot;);
 489     } while (*--outp != n);
 490     *outp = _out[--_outcnt];
 491     // Smash the old edge so it can&#39;t be used accidentally.
 492     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 493     // Record that a change happened here.
 494     #if OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 623             DEFINE_CLASS_ID(CallLeaf,         CallRuntime, 0)
 624           DEFINE_CLASS_ID(Allocate,         Call, 2)
 625             DEFINE_CLASS_ID(AllocateArray,    Allocate, 0)
 626           DEFINE_CLASS_ID(AbstractLock,     Call, 3)
 627             DEFINE_CLASS_ID(Lock,             AbstractLock, 0)
 628             DEFINE_CLASS_ID(Unlock,           AbstractLock, 1)
 629           DEFINE_CLASS_ID(ArrayCopy,        Call, 4)
 630       DEFINE_CLASS_ID(MultiBranch, Multi, 1)
 631         DEFINE_CLASS_ID(PCTable,     MultiBranch, 0)
 632           DEFINE_CLASS_ID(Catch,       PCTable, 0)
 633           DEFINE_CLASS_ID(Jump,        PCTable, 1)
 634         DEFINE_CLASS_ID(If,          MultiBranch, 1)
 635           DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)
 636           DEFINE_CLASS_ID(RangeCheck,             If, 1)
 637           DEFINE_CLASS_ID(OuterStripMinedLoopEnd, If, 2)
 638         DEFINE_CLASS_ID(NeverBranch, MultiBranch, 2)
 639       DEFINE_CLASS_ID(Start,       Multi, 2)
 640       DEFINE_CLASS_ID(MemBar,      Multi, 3)
 641         DEFINE_CLASS_ID(Initialize,       MemBar, 0)
 642         DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)
<span class="line-removed"> 643       DEFINE_CLASS_ID(LoadBarrier, Multi, 4)</span>
 644 
 645     DEFINE_CLASS_ID(Mach,  Node, 1)
 646       DEFINE_CLASS_ID(MachReturn, Mach, 0)
 647         DEFINE_CLASS_ID(MachSafePoint, MachReturn, 0)
 648           DEFINE_CLASS_ID(MachCall, MachSafePoint, 0)
 649             DEFINE_CLASS_ID(MachCallJava,         MachCall, 0)
 650               DEFINE_CLASS_ID(MachCallStaticJava,   MachCallJava, 0)
 651               DEFINE_CLASS_ID(MachCallDynamicJava,  MachCallJava, 1)
 652             DEFINE_CLASS_ID(MachCallRuntime,      MachCall, 1)
 653               DEFINE_CLASS_ID(MachCallLeaf,         MachCallRuntime, 0)
 654       DEFINE_CLASS_ID(MachBranch, Mach, 1)
 655         DEFINE_CLASS_ID(MachIf,         MachBranch, 0)
 656         DEFINE_CLASS_ID(MachGoto,       MachBranch, 1)
 657         DEFINE_CLASS_ID(MachNullCheck,  MachBranch, 2)
 658       DEFINE_CLASS_ID(MachSpillCopy,    Mach, 2)
 659       DEFINE_CLASS_ID(MachTemp,         Mach, 3)
 660       DEFINE_CLASS_ID(MachConstantBase, Mach, 4)
 661       DEFINE_CLASS_ID(MachConstant,     Mach, 5)
 662         DEFINE_CLASS_ID(MachJump,       MachConstant, 0)
 663       DEFINE_CLASS_ID(MachMerge,        Mach, 6)
 664       DEFINE_CLASS_ID(MachMemBar,       Mach, 7)
 665 
 666     DEFINE_CLASS_ID(Type,  Node, 2)
 667       DEFINE_CLASS_ID(Phi,   Type, 0)
 668       DEFINE_CLASS_ID(ConstraintCast, Type, 1)
 669         DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
<span class="line-modified"> 670         DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 1)</span>

 671       DEFINE_CLASS_ID(CMove, Type, 3)
 672       DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
 673       DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
 674         DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
 675         DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
 676       DEFINE_CLASS_ID(EncodeNarrowPtr, Type, 6)
 677         DEFINE_CLASS_ID(EncodeP, EncodeNarrowPtr, 0)
 678         DEFINE_CLASS_ID(EncodePKlass, EncodeNarrowPtr, 1)
<span class="line-removed"> 679       DEFINE_CLASS_ID(ShenandoahBarrier, Type, 7)</span>
 680 
 681     DEFINE_CLASS_ID(Proj,  Node, 3)
 682       DEFINE_CLASS_ID(CatchProj, Proj, 0)
 683       DEFINE_CLASS_ID(JumpProj,  Proj, 1)
 684       DEFINE_CLASS_ID(IfProj,    Proj, 2)
 685         DEFINE_CLASS_ID(IfTrue,    IfProj, 0)
 686         DEFINE_CLASS_ID(IfFalse,   IfProj, 1)
 687       DEFINE_CLASS_ID(Parm,      Proj, 4)
 688       DEFINE_CLASS_ID(MachProj,  Proj, 5)
 689 
 690     DEFINE_CLASS_ID(Mem,   Node, 4)
 691       DEFINE_CLASS_ID(Load,  Mem, 0)
 692         DEFINE_CLASS_ID(LoadVector,  Load, 0)
<span class="line-removed"> 693           DEFINE_CLASS_ID(LoadBarrierSlowReg, Load, 1)</span>
<span class="line-removed"> 694           DEFINE_CLASS_ID(LoadBarrierWeakSlowReg, Load, 2)</span>
 695       DEFINE_CLASS_ID(Store, Mem, 1)
 696         DEFINE_CLASS_ID(StoreVector, Store, 0)
 697       DEFINE_CLASS_ID(LoadStore, Mem, 2)
 698         DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
 699           DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
 700         DEFINE_CLASS_ID(CompareAndExchangeNode, LoadStore, 1)
 701 
 702     DEFINE_CLASS_ID(Region, Node, 5)
 703       DEFINE_CLASS_ID(Loop, Region, 0)
 704         DEFINE_CLASS_ID(Root,                Loop, 0)
 705         DEFINE_CLASS_ID(CountedLoop,         Loop, 1)
 706         DEFINE_CLASS_ID(OuterStripMinedLoop, Loop, 2)
 707 
 708     DEFINE_CLASS_ID(Sub,   Node, 6)
 709       DEFINE_CLASS_ID(Cmp,   Sub, 0)
 710         DEFINE_CLASS_ID(FastLock,   Cmp, 0)
 711         DEFINE_CLASS_ID(FastUnlock, Cmp, 1)

 712 
 713     DEFINE_CLASS_ID(MergeMem, Node, 7)
 714     DEFINE_CLASS_ID(Bool,     Node, 8)
 715     DEFINE_CLASS_ID(AddP,     Node, 9)
 716     DEFINE_CLASS_ID(BoxLock,  Node, 10)
 717     DEFINE_CLASS_ID(Add,      Node, 11)
 718     DEFINE_CLASS_ID(Mul,      Node, 12)
 719     DEFINE_CLASS_ID(Vector,   Node, 13)
 720     DEFINE_CLASS_ID(ClearArray, Node, 14)

 721 
<span class="line-modified"> 722     _max_classes  = ClassMask_ClearArray</span>
 723   };
 724   #undef DEFINE_CLASS_ID
 725 
 726   // Flags are sorted by usage frequency.
 727   enum NodeFlags {
 728     Flag_is_Copy                     = 0x01, // should be first bit to avoid shift
 729     Flag_rematerialize               = Flag_is_Copy &lt;&lt; 1,
 730     Flag_needs_anti_dependence_check = Flag_rematerialize &lt;&lt; 1,
 731     Flag_is_macro                    = Flag_needs_anti_dependence_check &lt;&lt; 1,
 732     Flag_is_Con                      = Flag_is_macro &lt;&lt; 1,
 733     Flag_is_cisc_alternate           = Flag_is_Con &lt;&lt; 1,
 734     Flag_is_dead_loop_safe           = Flag_is_cisc_alternate &lt;&lt; 1,
 735     Flag_may_be_short_branch         = Flag_is_dead_loop_safe &lt;&lt; 1,
 736     Flag_avoid_back_to_back_before   = Flag_may_be_short_branch &lt;&lt; 1,
 737     Flag_avoid_back_to_back_after    = Flag_avoid_back_to_back_before &lt;&lt; 1,
 738     Flag_has_call                    = Flag_avoid_back_to_back_after &lt;&lt; 1,
 739     Flag_is_reduction                = Flag_has_call &lt;&lt; 1,
 740     Flag_is_scheduled                = Flag_is_reduction &lt;&lt; 1,
 741     Flag_has_vector_mask_set         = Flag_is_scheduled &lt;&lt; 1,
 742     Flag_is_expensive                = Flag_has_vector_mask_set &lt;&lt; 1,
 743     _max_flags = (Flag_is_expensive &lt;&lt; 1) - 1 // allow flags combination
 744   };
 745 
 746 private:
 747   jushort _class_id;
 748   jushort _flags;
 749 
 750 protected:
 751   // These methods should be called from constructors only.
 752   void init_class_id(jushort c) {
<span class="line-removed"> 753     assert(c &lt;= _max_classes, &quot;invalid node class&quot;);</span>
 754     _class_id = c; // cast out const
 755   }
 756   void init_flags(jushort fl) {
 757     assert(fl &lt;= _max_flags, &quot;invalid node flag&quot;);
 758     _flags |= fl;
 759   }
 760   void clear_flag(jushort fl) {
 761     assert(fl &lt;= _max_flags, &quot;invalid node flag&quot;);
 762     _flags &amp;= ~fl;
 763   }
 764 
 765 public:
 766   const jushort class_id() const { return _class_id; }
 767 
 768   const jushort flags() const { return _flags; }
 769 
 770   void add_flag(jushort fl) { init_flags(fl); }
 771 
 772   void remove_flag(jushort fl) { clear_flag(fl); }
 773 
</pre>
<hr />
<pre>
 791   }
 792 
 793   DEFINE_CLASS_QUERY(AbstractLock)
 794   DEFINE_CLASS_QUERY(Add)
 795   DEFINE_CLASS_QUERY(AddP)
 796   DEFINE_CLASS_QUERY(Allocate)
 797   DEFINE_CLASS_QUERY(AllocateArray)
 798   DEFINE_CLASS_QUERY(ArrayCopy)
 799   DEFINE_CLASS_QUERY(Bool)
 800   DEFINE_CLASS_QUERY(BoxLock)
 801   DEFINE_CLASS_QUERY(Call)
 802   DEFINE_CLASS_QUERY(CallDynamicJava)
 803   DEFINE_CLASS_QUERY(CallJava)
 804   DEFINE_CLASS_QUERY(CallLeaf)
 805   DEFINE_CLASS_QUERY(CallRuntime)
 806   DEFINE_CLASS_QUERY(CallStaticJava)
 807   DEFINE_CLASS_QUERY(Catch)
 808   DEFINE_CLASS_QUERY(CatchProj)
 809   DEFINE_CLASS_QUERY(CheckCastPP)
 810   DEFINE_CLASS_QUERY(CastII)

 811   DEFINE_CLASS_QUERY(ConstraintCast)
 812   DEFINE_CLASS_QUERY(ClearArray)
 813   DEFINE_CLASS_QUERY(CMove)
 814   DEFINE_CLASS_QUERY(Cmp)
 815   DEFINE_CLASS_QUERY(CountedLoop)
 816   DEFINE_CLASS_QUERY(CountedLoopEnd)
 817   DEFINE_CLASS_QUERY(DecodeNarrowPtr)
 818   DEFINE_CLASS_QUERY(DecodeN)
 819   DEFINE_CLASS_QUERY(DecodeNKlass)
 820   DEFINE_CLASS_QUERY(EncodeNarrowPtr)
 821   DEFINE_CLASS_QUERY(EncodeP)
 822   DEFINE_CLASS_QUERY(EncodePKlass)
 823   DEFINE_CLASS_QUERY(FastLock)
 824   DEFINE_CLASS_QUERY(FastUnlock)

 825   DEFINE_CLASS_QUERY(If)
 826   DEFINE_CLASS_QUERY(RangeCheck)
 827   DEFINE_CLASS_QUERY(IfProj)
 828   DEFINE_CLASS_QUERY(IfFalse)
 829   DEFINE_CLASS_QUERY(IfTrue)
 830   DEFINE_CLASS_QUERY(Initialize)
 831   DEFINE_CLASS_QUERY(Jump)
 832   DEFINE_CLASS_QUERY(JumpProj)
 833   DEFINE_CLASS_QUERY(Load)
 834   DEFINE_CLASS_QUERY(LoadStore)
<span class="line-modified"> 835   DEFINE_CLASS_QUERY(LoadBarrier)</span>
<span class="line-removed"> 836   DEFINE_CLASS_QUERY(LoadBarrierSlowReg)</span>
<span class="line-removed"> 837   DEFINE_CLASS_QUERY(LoadBarrierWeakSlowReg)</span>
 838   DEFINE_CLASS_QUERY(Lock)
 839   DEFINE_CLASS_QUERY(Loop)
 840   DEFINE_CLASS_QUERY(Mach)
 841   DEFINE_CLASS_QUERY(MachBranch)
 842   DEFINE_CLASS_QUERY(MachCall)
 843   DEFINE_CLASS_QUERY(MachCallDynamicJava)
 844   DEFINE_CLASS_QUERY(MachCallJava)
 845   DEFINE_CLASS_QUERY(MachCallLeaf)
 846   DEFINE_CLASS_QUERY(MachCallRuntime)
 847   DEFINE_CLASS_QUERY(MachCallStaticJava)
 848   DEFINE_CLASS_QUERY(MachConstantBase)
 849   DEFINE_CLASS_QUERY(MachConstant)
 850   DEFINE_CLASS_QUERY(MachGoto)
 851   DEFINE_CLASS_QUERY(MachIf)
 852   DEFINE_CLASS_QUERY(MachJump)
 853   DEFINE_CLASS_QUERY(MachNullCheck)
 854   DEFINE_CLASS_QUERY(MachProj)
 855   DEFINE_CLASS_QUERY(MachReturn)
 856   DEFINE_CLASS_QUERY(MachSafePoint)
 857   DEFINE_CLASS_QUERY(MachSpillCopy)
 858   DEFINE_CLASS_QUERY(MachTemp)
 859   DEFINE_CLASS_QUERY(MachMemBar)
 860   DEFINE_CLASS_QUERY(MachMerge)
 861   DEFINE_CLASS_QUERY(Mem)
 862   DEFINE_CLASS_QUERY(MemBar)
 863   DEFINE_CLASS_QUERY(MemBarStoreStore)
 864   DEFINE_CLASS_QUERY(MergeMem)
 865   DEFINE_CLASS_QUERY(Mul)
 866   DEFINE_CLASS_QUERY(Multi)
 867   DEFINE_CLASS_QUERY(MultiBranch)
 868   DEFINE_CLASS_QUERY(OuterStripMinedLoop)
 869   DEFINE_CLASS_QUERY(OuterStripMinedLoopEnd)
 870   DEFINE_CLASS_QUERY(Parm)
 871   DEFINE_CLASS_QUERY(PCTable)
 872   DEFINE_CLASS_QUERY(Phi)
 873   DEFINE_CLASS_QUERY(Proj)
 874   DEFINE_CLASS_QUERY(Region)
 875   DEFINE_CLASS_QUERY(Root)
 876   DEFINE_CLASS_QUERY(SafePoint)
 877   DEFINE_CLASS_QUERY(SafePointScalarObject)
<span class="line-removed"> 878   DEFINE_CLASS_QUERY(ShenandoahBarrier)</span>
 879   DEFINE_CLASS_QUERY(Start)
 880   DEFINE_CLASS_QUERY(Store)
 881   DEFINE_CLASS_QUERY(Sub)

 882   DEFINE_CLASS_QUERY(Type)
 883   DEFINE_CLASS_QUERY(Vector)
 884   DEFINE_CLASS_QUERY(LoadVector)
 885   DEFINE_CLASS_QUERY(StoreVector)
 886   DEFINE_CLASS_QUERY(Unlock)
 887 
 888   #undef DEFINE_CLASS_QUERY
 889 
 890   // duplicate of is_MachSpillCopy()
 891   bool is_SpillCopy () const {
 892     return ((_class_id &amp; ClassMask_MachSpillCopy) == Class_MachSpillCopy);
 893   }
 894 
 895   bool is_Con () const { return (_flags &amp; Flag_is_Con) != 0; }
 896   // The data node which is safe to leave in dead loop during IGVN optimization.
 897   bool is_dead_loop_safe() const {
 898     return is_Phi() || (is_Proj() &amp;&amp; in(0) == NULL) ||
 899            ((_flags &amp; (Flag_is_dead_loop_safe | Flag_is_Con)) != 0 &amp;&amp;
 900             (!is_Proj() || !in(0)-&gt;is_Allocate()));
 901   }
</pre>
<hr />
<pre>
 984   // Check if &#39;this&#39; node dominates or equal to &#39;sub&#39;.
 985   bool dominates(Node* sub, Node_List &amp;nlist);
 986 
 987 protected:
 988   bool remove_dead_region(PhaseGVN *phase, bool can_reshape);
 989 public:
 990 
 991   // See if there is valid pipeline info
 992   static  const Pipeline *pipeline_class();
 993   virtual const Pipeline *pipeline() const;
 994 
 995   // Compute the latency from the def to this instruction of the ith input node
 996   uint latency(uint i);
 997 
 998   // Hash &amp; compare functions, for pessimistic value numbering
 999 
1000   // If the hash function returns the special sentinel value NO_HASH,
1001   // the node is guaranteed never to compare equal to any other node.
1002   // If we accidentally generate a hash with value NO_HASH the node
1003   // won&#39;t go into the table and we&#39;ll lose a little optimization.
<span class="line-modified">1004   enum { NO_HASH = 0 };</span>
1005   virtual uint hash() const;
<span class="line-modified">1006   virtual uint cmp( const Node &amp;n ) const;</span>
1007 
1008   // Operation appears to be iteratively computed (such as an induction variable)
1009   // It is possible for this operation to return false for a loop-varying
1010   // value, if it appears (by local graph inspection) to be computed by a simple conditional.
1011   bool is_iteratively_computed();
1012 
<span class="line-modified">1013   // Determine if a node is Counted loop induction variable.</span>
<span class="line-modified">1014   // The method is defined in loopnode.cpp.</span>
<span class="line-modified">1015   const Node* is_loop_iv() const;</span>
1016 
1017   // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
1018   // be found; Otherwise return NULL;
1019   Node* find_similar(int opc);
1020 
1021   // Return the unique control out if only one. Null if none or more than one.
1022   Node* unique_ctrl_out() const;
1023 
1024   // Set control or add control as precedence edge
1025   void ensure_control_or_add_prec(Node* c);
1026 
1027 //----------------- Code Generation
1028 
1029   // Ideal register class for Matching.  Zero means unmatched instruction
1030   // (these are cloned instead of converted to machine nodes).
1031   virtual uint ideal_reg() const;
1032 
1033   static const uint NotAMachineReg;   // must be &gt; max. machine register
1034 
1035   // Do we Match on this edge index or not?  Generally false for Control
</pre>
<hr />
<pre>
1508   void yank( Node *n );         // Find and remove
1509   Node *pop() { return _nodes[--_cnt]; }
1510   Node *rpop() { Node *b = _nodes[0]; _nodes[0]=_nodes[--_cnt]; return b;}
1511   void clear() { _cnt = 0; Node_Array::clear(); } // retain storage
1512   uint size() const { return _cnt; }
1513   void dump() const;
1514   void dump_simple() const;
1515 };
1516 
1517 //------------------------------Unique_Node_List-------------------------------
1518 class Unique_Node_List : public Node_List {
1519   friend class VMStructs;
1520   VectorSet _in_worklist;
1521   uint _clock_index;            // Index in list where to pop from next
1522 public:
1523   Unique_Node_List() : Node_List(), _in_worklist(Thread::current()-&gt;resource_area()), _clock_index(0) {}
1524   Unique_Node_List(Arena *a) : Node_List(a), _in_worklist(a), _clock_index(0) {}
1525 
1526   void remove( Node *n );
1527   bool member( Node *n ) { return _in_worklist.test(n-&gt;_idx) != 0; }
<span class="line-modified">1528   VectorSet &amp;member_set(){ return _in_worklist; }</span>
1529 
<span class="line-modified">1530   void push( Node *b ) {</span>
1531     if( !_in_worklist.test_set(b-&gt;_idx) )
1532       Node_List::push(b);
1533   }
1534   Node *pop() {
1535     if( _clock_index &gt;= size() ) _clock_index = 0;
1536     Node *b = at(_clock_index);
1537     map( _clock_index, Node_List::pop());
1538     if (size() != 0) _clock_index++; // Always start from 0
<span class="line-modified">1539     _in_worklist &gt;&gt;= b-&gt;_idx;</span>
1540     return b;
1541   }
<span class="line-modified">1542   Node *remove( uint i ) {</span>
1543     Node *b = Node_List::at(i);
<span class="line-modified">1544     _in_worklist &gt;&gt;= b-&gt;_idx;</span>
1545     map(i,Node_List::pop());
1546     return b;
1547   }
<span class="line-modified">1548   void yank( Node *n ) { _in_worklist &gt;&gt;= n-&gt;_idx; Node_List::yank(n); }</span>



1549   void  clear() {
<span class="line-modified">1550     _in_worklist.Clear();        // Discards storage but grows automatically</span>
1551     Node_List::clear();
1552     _clock_index = 0;
1553   }
1554 
1555   // Used after parsing to remove useless nodes before Iterative GVN
<span class="line-modified">1556   void remove_useless_nodes(VectorSet &amp;useful);</span>
1557 
1558 #ifndef PRODUCT
1559   void print_set() const { _in_worklist.print(); }
1560 #endif
1561 };
1562 
1563 // Inline definition of Compile::record_for_igvn must be deferred to this point.
1564 inline void Compile::record_for_igvn(Node* n) {
1565   _for_igvn-&gt;push(n);
1566 }
1567 
1568 //------------------------------Node_Stack-------------------------------------
1569 class Node_Stack {
1570   friend class VMStructs;
1571 protected:
1572   struct INode {
1573     Node *node; // Processed node
1574     uint  indx; // Index of next node&#39;s child
1575   };
1576   INode *_inode_top; // tos, stack grows up
</pre>
<hr />
<pre>
1701   if (arr == NULL) return NULL;
1702   // (Every element of arr is a sub-array of length _node_notes_block_size.)
1703   return arr-&gt;at(block_idx) + (idx &amp; (_node_notes_block_size-1));
1704 }
1705 
1706 inline bool
1707 Compile::set_node_notes_at(int idx, Node_Notes* value) {
1708   if (value == NULL || value-&gt;is_clear())
1709     return false;  // nothing to write =&gt; write nothing
1710   Node_Notes* loc = locate_node_notes(_node_note_array, idx, true);
1711   assert(loc != NULL, &quot;&quot;);
1712   return loc-&gt;update_from(value);
1713 }
1714 
1715 
1716 //------------------------------TypeNode---------------------------------------
1717 // Node with a Type constant.
1718 class TypeNode : public Node {
1719 protected:
1720   virtual uint hash() const;    // Check the type
<span class="line-modified">1721   virtual uint cmp( const Node &amp;n ) const;</span>
1722   virtual uint size_of() const; // Size is bigger
1723   const Type* const _type;
1724 public:
1725   void set_type(const Type* t) {
1726     assert(t != NULL, &quot;sanity&quot;);
1727     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
1728     *(const Type**)&amp;_type = t;   // cast away const-ness
1729     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
1730     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
1731   }
1732   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
1733   TypeNode( const Type *t, uint required ) : Node(required), _type(t) {
1734     init_class_id(Class_Type);
1735   }
1736   virtual const Type* Value(PhaseGVN* phase) const;
1737   virtual const Type *bottom_type() const;
1738   virtual       uint  ideal_reg() const;
1739 #ifndef PRODUCT
1740   virtual void dump_spec(outputStream *st) const;
1741   virtual void dump_compact_spec(outputStream *st) const;
</pre>
</td>
<td>
<hr />
<pre>
  35 
  36 
  37 class AbstractLockNode;
  38 class AddNode;
  39 class AddPNode;
  40 class AliasInfo;
  41 class AllocateArrayNode;
  42 class AllocateNode;
  43 class ArrayCopyNode;
  44 class Block;
  45 class BoolNode;
  46 class BoxLockNode;
  47 class CMoveNode;
  48 class CallDynamicJavaNode;
  49 class CallJavaNode;
  50 class CallLeafNode;
  51 class CallNode;
  52 class CallRuntimeNode;
  53 class CallStaticJavaNode;
  54 class CastIINode;
<span class="line-added">  55 class CastLLNode;</span>
  56 class CatchNode;
  57 class CatchProjNode;
  58 class CheckCastPPNode;
  59 class ClearArrayNode;
  60 class CmpNode;
  61 class CodeBuffer;
  62 class ConstraintCastNode;
  63 class ConNode;
  64 class CompareAndSwapNode;
  65 class CompareAndExchangeNode;
  66 class CountedLoopNode;
  67 class CountedLoopEndNode;
  68 class DecodeNarrowPtrNode;
  69 class DecodeNNode;
  70 class DecodeNKlassNode;
  71 class EncodeNarrowPtrNode;
  72 class EncodePNode;
  73 class EncodePKlassNode;
  74 class FastLockNode;
  75 class FastUnlockNode;
<span class="line-added">  76 class HaltNode;</span>
  77 class IfNode;
  78 class IfProjNode;
  79 class IfFalseNode;
  80 class IfTrueNode;
  81 class InitializeNode;
  82 class JVMState;
  83 class JumpNode;
  84 class JumpProjNode;
  85 class LoadNode;



  86 class LoadStoreNode;
<span class="line-added">  87 class LoadStoreConditionalNode;</span>
  88 class LockNode;
  89 class LoopNode;
  90 class MachBranchNode;
  91 class MachCallDynamicJavaNode;
  92 class MachCallJavaNode;
  93 class MachCallLeafNode;
  94 class MachCallNode;
  95 class MachCallRuntimeNode;
  96 class MachCallStaticJavaNode;
  97 class MachConstantBaseNode;
  98 class MachConstantNode;
  99 class MachGotoNode;
 100 class MachIfNode;
 101 class MachJumpNode;
 102 class MachNode;
 103 class MachNullCheckNode;
 104 class MachProjNode;
 105 class MachReturnNode;
 106 class MachSafePointNode;
 107 class MachSpillCopyNode;
</pre>
<hr />
<pre>
 125 class Node_Stack;
 126 class NullCheckNode;
 127 class OopMap;
 128 class ParmNode;
 129 class PCTableNode;
 130 class PhaseCCP;
 131 class PhaseGVN;
 132 class PhaseIterGVN;
 133 class PhaseRegAlloc;
 134 class PhaseTransform;
 135 class PhaseValues;
 136 class PhiNode;
 137 class Pipeline;
 138 class ProjNode;
 139 class RangeCheckNode;
 140 class RegMask;
 141 class RegionNode;
 142 class RootNode;
 143 class SafePointNode;
 144 class SafePointScalarObjectNode;

 145 class StartNode;
 146 class State;
 147 class StoreNode;
 148 class SubNode;
<span class="line-added"> 149 class SubTypeCheckNode;</span>
 150 class Type;
 151 class TypeNode;
 152 class UnlockNode;
 153 class VectorNode;
 154 class LoadVectorNode;
 155 class StoreVectorNode;
 156 class VectorSet;
 157 typedef void (*NFunc)(Node&amp;,void*);
 158 extern &quot;C&quot; {
 159   typedef int (*C_sort_func_t)(const void *, const void *);
 160 }
 161 
 162 // The type of all node counts and indexes.
 163 // It must hold at least 16 bits, but must also be fast to load and store.
 164 // This type, if less than 32 bits, could limit the number of possible nodes.
 165 // (To make this type platform-specific, move to globalDefinitions_xxx.hpp.)
 166 typedef unsigned int node_idx_t;
 167 
 168 
 169 #ifndef OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 376   // Use this accessor sparingly.  We are going trying to use iterators instead.
 377   Node* raw_out(uint i) const { assert(i &lt; _outcnt,&quot;oob&quot;); return _out[i]; }
 378   // Return the unique out edge.
 379   Node* unique_out() const { assert(_outcnt==1,&quot;not unique&quot;); return _out[0]; }
 380   // Delete out edge at position &#39;i&#39; by moving last out edge to position &#39;i&#39;
 381   void  raw_del_out(uint i) {
 382     assert(i &lt; _outcnt,&quot;oob&quot;);
 383     assert(_outcnt &gt; 0,&quot;oob&quot;);
 384     #if OPTO_DU_ITERATOR_ASSERT
 385     // Record that a change happened here.
 386     debug_only(_last_del = _out[i]; ++_del_tick);
 387     #endif
 388     _out[i] = _out[--_outcnt];
 389     // Smash the old edge so it can&#39;t be used accidentally.
 390     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 391   }
 392 
 393 #ifdef ASSERT
 394   bool is_dead() const;
 395 #define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)-&gt;is_dead()))
<span class="line-added"> 396   bool is_reachable_from_root() const;</span>
 397 #endif
 398   // Check whether node has become unreachable
 399   bool is_unreachable(PhaseIterGVN &amp;igvn) const;
 400 
 401   // Set a required input edge, also updates corresponding output edge
 402   void add_req( Node *n ); // Append a NEW required input
 403   void add_req( Node *n0, Node *n1 ) {
 404     add_req(n0); add_req(n1); }
 405   void add_req( Node *n0, Node *n1, Node *n2 ) {
 406     add_req(n0); add_req(n1); add_req(n2); }
 407   void add_req_batch( Node* n, uint m ); // Append m NEW required inputs (all n).
 408   void del_req( uint idx ); // Delete required edge &amp; compact
 409   void del_req_ordered( uint idx ); // Delete required edge &amp; compact with preserved order
 410   void ins_req( uint i, Node *n ); // Insert a NEW required input
 411   void set_req( uint i, Node *n ) {
 412     assert( is_not_dead(n), &quot;can not use dead node&quot;);
 413     assert( i &lt; _cnt, &quot;oob: i=%d, _cnt=%d&quot;, i, _cnt);
 414     assert( !VerifyHashTableKeys || _hash_lock == 0,
 415             &quot;remove node from hash table before modifying it&quot;);
 416     Node** p = &amp;_in[i];    // cache this._in, across the del_out call
</pre>
<hr />
<pre>
 441         break;
 442       }
 443     }
 444     return -1;
 445   }
 446   int replace_edge(Node* old, Node* neww);
 447   int replace_edges_in_range(Node* old, Node* neww, int start, int end);
 448   // NULL out all inputs to eliminate incoming Def-Use edges.
 449   // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 450   int  disconnect_inputs(Node *n, Compile *c);
 451 
 452   // Quickly, return true if and only if I am Compile::current()-&gt;top().
 453   bool is_top() const {
 454     assert((this == (Node*) Compile::current()-&gt;top()) == (_out == NULL), &quot;&quot;);
 455     return (_out == NULL);
 456   }
 457   // Reaffirm invariants for is_top.  (Only from Compile::set_cached_top_node.)
 458   void setup_is_top();
 459 
 460   // Strip away casting.  (It is depth-limited.)
<span class="line-modified"> 461   Node* uncast(bool keep_deps = false) const;</span>
 462   // Return whether two Nodes are equivalent, after stripping casting.
<span class="line-modified"> 463   bool eqv_uncast(const Node* n, bool keep_deps = false) const {</span>
<span class="line-modified"> 464     return (this-&gt;uncast(keep_deps) == n-&gt;uncast(keep_deps));</span>
 465   }
 466 
 467   // Find out of current node that matches opcode.
 468   Node* find_out_with(int opcode);
 469   // Return true if the current node has an out that matches opcode.
 470   bool has_out_with(int opcode);
 471   // Return true if the current node has an out that matches any of the opcodes.
 472   bool has_out_with(int opcode1, int opcode2, int opcode3, int opcode4);
 473 
 474 private:
<span class="line-modified"> 475   static Node* uncast_helper(const Node* n, bool keep_deps);</span>
 476 
 477   // Add an output edge to the end of the list
 478   void add_out( Node *n ) {
 479     if (is_top())  return;
 480     if( _outcnt == _outmax ) out_grow(_outcnt);
 481     _out[_outcnt++] = n;
 482   }
 483   // Delete an output edge
 484   void del_out( Node *n ) {
 485     if (is_top())  return;
 486     Node** outp = &amp;_out[_outcnt];
 487     // Find and remove n
 488     do {
 489       assert(outp &gt; _out, &quot;Missing Def-Use edge&quot;);
 490     } while (*--outp != n);
 491     *outp = _out[--_outcnt];
 492     // Smash the old edge so it can&#39;t be used accidentally.
 493     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 494     // Record that a change happened here.
 495     #if OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 624             DEFINE_CLASS_ID(CallLeaf,         CallRuntime, 0)
 625           DEFINE_CLASS_ID(Allocate,         Call, 2)
 626             DEFINE_CLASS_ID(AllocateArray,    Allocate, 0)
 627           DEFINE_CLASS_ID(AbstractLock,     Call, 3)
 628             DEFINE_CLASS_ID(Lock,             AbstractLock, 0)
 629             DEFINE_CLASS_ID(Unlock,           AbstractLock, 1)
 630           DEFINE_CLASS_ID(ArrayCopy,        Call, 4)
 631       DEFINE_CLASS_ID(MultiBranch, Multi, 1)
 632         DEFINE_CLASS_ID(PCTable,     MultiBranch, 0)
 633           DEFINE_CLASS_ID(Catch,       PCTable, 0)
 634           DEFINE_CLASS_ID(Jump,        PCTable, 1)
 635         DEFINE_CLASS_ID(If,          MultiBranch, 1)
 636           DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)
 637           DEFINE_CLASS_ID(RangeCheck,             If, 1)
 638           DEFINE_CLASS_ID(OuterStripMinedLoopEnd, If, 2)
 639         DEFINE_CLASS_ID(NeverBranch, MultiBranch, 2)
 640       DEFINE_CLASS_ID(Start,       Multi, 2)
 641       DEFINE_CLASS_ID(MemBar,      Multi, 3)
 642         DEFINE_CLASS_ID(Initialize,       MemBar, 0)
 643         DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)

 644 
 645     DEFINE_CLASS_ID(Mach,  Node, 1)
 646       DEFINE_CLASS_ID(MachReturn, Mach, 0)
 647         DEFINE_CLASS_ID(MachSafePoint, MachReturn, 0)
 648           DEFINE_CLASS_ID(MachCall, MachSafePoint, 0)
 649             DEFINE_CLASS_ID(MachCallJava,         MachCall, 0)
 650               DEFINE_CLASS_ID(MachCallStaticJava,   MachCallJava, 0)
 651               DEFINE_CLASS_ID(MachCallDynamicJava,  MachCallJava, 1)
 652             DEFINE_CLASS_ID(MachCallRuntime,      MachCall, 1)
 653               DEFINE_CLASS_ID(MachCallLeaf,         MachCallRuntime, 0)
 654       DEFINE_CLASS_ID(MachBranch, Mach, 1)
 655         DEFINE_CLASS_ID(MachIf,         MachBranch, 0)
 656         DEFINE_CLASS_ID(MachGoto,       MachBranch, 1)
 657         DEFINE_CLASS_ID(MachNullCheck,  MachBranch, 2)
 658       DEFINE_CLASS_ID(MachSpillCopy,    Mach, 2)
 659       DEFINE_CLASS_ID(MachTemp,         Mach, 3)
 660       DEFINE_CLASS_ID(MachConstantBase, Mach, 4)
 661       DEFINE_CLASS_ID(MachConstant,     Mach, 5)
 662         DEFINE_CLASS_ID(MachJump,       MachConstant, 0)
 663       DEFINE_CLASS_ID(MachMerge,        Mach, 6)
 664       DEFINE_CLASS_ID(MachMemBar,       Mach, 7)
 665 
 666     DEFINE_CLASS_ID(Type,  Node, 2)
 667       DEFINE_CLASS_ID(Phi,   Type, 0)
 668       DEFINE_CLASS_ID(ConstraintCast, Type, 1)
 669         DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
<span class="line-modified"> 670         DEFINE_CLASS_ID(CastLL, ConstraintCast, 1)</span>
<span class="line-added"> 671         DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 2)</span>
 672       DEFINE_CLASS_ID(CMove, Type, 3)
 673       DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
 674       DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
 675         DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
 676         DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
 677       DEFINE_CLASS_ID(EncodeNarrowPtr, Type, 6)
 678         DEFINE_CLASS_ID(EncodeP, EncodeNarrowPtr, 0)
 679         DEFINE_CLASS_ID(EncodePKlass, EncodeNarrowPtr, 1)

 680 
 681     DEFINE_CLASS_ID(Proj,  Node, 3)
 682       DEFINE_CLASS_ID(CatchProj, Proj, 0)
 683       DEFINE_CLASS_ID(JumpProj,  Proj, 1)
 684       DEFINE_CLASS_ID(IfProj,    Proj, 2)
 685         DEFINE_CLASS_ID(IfTrue,    IfProj, 0)
 686         DEFINE_CLASS_ID(IfFalse,   IfProj, 1)
 687       DEFINE_CLASS_ID(Parm,      Proj, 4)
 688       DEFINE_CLASS_ID(MachProj,  Proj, 5)
 689 
 690     DEFINE_CLASS_ID(Mem,   Node, 4)
 691       DEFINE_CLASS_ID(Load,  Mem, 0)
 692         DEFINE_CLASS_ID(LoadVector,  Load, 0)


 693       DEFINE_CLASS_ID(Store, Mem, 1)
 694         DEFINE_CLASS_ID(StoreVector, Store, 0)
 695       DEFINE_CLASS_ID(LoadStore, Mem, 2)
 696         DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
 697           DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
 698         DEFINE_CLASS_ID(CompareAndExchangeNode, LoadStore, 1)
 699 
 700     DEFINE_CLASS_ID(Region, Node, 5)
 701       DEFINE_CLASS_ID(Loop, Region, 0)
 702         DEFINE_CLASS_ID(Root,                Loop, 0)
 703         DEFINE_CLASS_ID(CountedLoop,         Loop, 1)
 704         DEFINE_CLASS_ID(OuterStripMinedLoop, Loop, 2)
 705 
 706     DEFINE_CLASS_ID(Sub,   Node, 6)
 707       DEFINE_CLASS_ID(Cmp,   Sub, 0)
 708         DEFINE_CLASS_ID(FastLock,   Cmp, 0)
 709         DEFINE_CLASS_ID(FastUnlock, Cmp, 1)
<span class="line-added"> 710         DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)</span>
 711 
 712     DEFINE_CLASS_ID(MergeMem, Node, 7)
 713     DEFINE_CLASS_ID(Bool,     Node, 8)
 714     DEFINE_CLASS_ID(AddP,     Node, 9)
 715     DEFINE_CLASS_ID(BoxLock,  Node, 10)
 716     DEFINE_CLASS_ID(Add,      Node, 11)
 717     DEFINE_CLASS_ID(Mul,      Node, 12)
 718     DEFINE_CLASS_ID(Vector,   Node, 13)
 719     DEFINE_CLASS_ID(ClearArray, Node, 14)
<span class="line-added"> 720     DEFINE_CLASS_ID(Halt, Node, 15)</span>
 721 
<span class="line-modified"> 722     _max_classes  = ClassMask_Halt</span>
 723   };
 724   #undef DEFINE_CLASS_ID
 725 
 726   // Flags are sorted by usage frequency.
 727   enum NodeFlags {
 728     Flag_is_Copy                     = 0x01, // should be first bit to avoid shift
 729     Flag_rematerialize               = Flag_is_Copy &lt;&lt; 1,
 730     Flag_needs_anti_dependence_check = Flag_rematerialize &lt;&lt; 1,
 731     Flag_is_macro                    = Flag_needs_anti_dependence_check &lt;&lt; 1,
 732     Flag_is_Con                      = Flag_is_macro &lt;&lt; 1,
 733     Flag_is_cisc_alternate           = Flag_is_Con &lt;&lt; 1,
 734     Flag_is_dead_loop_safe           = Flag_is_cisc_alternate &lt;&lt; 1,
 735     Flag_may_be_short_branch         = Flag_is_dead_loop_safe &lt;&lt; 1,
 736     Flag_avoid_back_to_back_before   = Flag_may_be_short_branch &lt;&lt; 1,
 737     Flag_avoid_back_to_back_after    = Flag_avoid_back_to_back_before &lt;&lt; 1,
 738     Flag_has_call                    = Flag_avoid_back_to_back_after &lt;&lt; 1,
 739     Flag_is_reduction                = Flag_has_call &lt;&lt; 1,
 740     Flag_is_scheduled                = Flag_is_reduction &lt;&lt; 1,
 741     Flag_has_vector_mask_set         = Flag_is_scheduled &lt;&lt; 1,
 742     Flag_is_expensive                = Flag_has_vector_mask_set &lt;&lt; 1,
 743     _max_flags = (Flag_is_expensive &lt;&lt; 1) - 1 // allow flags combination
 744   };
 745 
 746 private:
 747   jushort _class_id;
 748   jushort _flags;
 749 
 750 protected:
 751   // These methods should be called from constructors only.
 752   void init_class_id(jushort c) {

 753     _class_id = c; // cast out const
 754   }
 755   void init_flags(jushort fl) {
 756     assert(fl &lt;= _max_flags, &quot;invalid node flag&quot;);
 757     _flags |= fl;
 758   }
 759   void clear_flag(jushort fl) {
 760     assert(fl &lt;= _max_flags, &quot;invalid node flag&quot;);
 761     _flags &amp;= ~fl;
 762   }
 763 
 764 public:
 765   const jushort class_id() const { return _class_id; }
 766 
 767   const jushort flags() const { return _flags; }
 768 
 769   void add_flag(jushort fl) { init_flags(fl); }
 770 
 771   void remove_flag(jushort fl) { clear_flag(fl); }
 772 
</pre>
<hr />
<pre>
 790   }
 791 
 792   DEFINE_CLASS_QUERY(AbstractLock)
 793   DEFINE_CLASS_QUERY(Add)
 794   DEFINE_CLASS_QUERY(AddP)
 795   DEFINE_CLASS_QUERY(Allocate)
 796   DEFINE_CLASS_QUERY(AllocateArray)
 797   DEFINE_CLASS_QUERY(ArrayCopy)
 798   DEFINE_CLASS_QUERY(Bool)
 799   DEFINE_CLASS_QUERY(BoxLock)
 800   DEFINE_CLASS_QUERY(Call)
 801   DEFINE_CLASS_QUERY(CallDynamicJava)
 802   DEFINE_CLASS_QUERY(CallJava)
 803   DEFINE_CLASS_QUERY(CallLeaf)
 804   DEFINE_CLASS_QUERY(CallRuntime)
 805   DEFINE_CLASS_QUERY(CallStaticJava)
 806   DEFINE_CLASS_QUERY(Catch)
 807   DEFINE_CLASS_QUERY(CatchProj)
 808   DEFINE_CLASS_QUERY(CheckCastPP)
 809   DEFINE_CLASS_QUERY(CastII)
<span class="line-added"> 810   DEFINE_CLASS_QUERY(CastLL)</span>
 811   DEFINE_CLASS_QUERY(ConstraintCast)
 812   DEFINE_CLASS_QUERY(ClearArray)
 813   DEFINE_CLASS_QUERY(CMove)
 814   DEFINE_CLASS_QUERY(Cmp)
 815   DEFINE_CLASS_QUERY(CountedLoop)
 816   DEFINE_CLASS_QUERY(CountedLoopEnd)
 817   DEFINE_CLASS_QUERY(DecodeNarrowPtr)
 818   DEFINE_CLASS_QUERY(DecodeN)
 819   DEFINE_CLASS_QUERY(DecodeNKlass)
 820   DEFINE_CLASS_QUERY(EncodeNarrowPtr)
 821   DEFINE_CLASS_QUERY(EncodeP)
 822   DEFINE_CLASS_QUERY(EncodePKlass)
 823   DEFINE_CLASS_QUERY(FastLock)
 824   DEFINE_CLASS_QUERY(FastUnlock)
<span class="line-added"> 825   DEFINE_CLASS_QUERY(Halt)</span>
 826   DEFINE_CLASS_QUERY(If)
 827   DEFINE_CLASS_QUERY(RangeCheck)
 828   DEFINE_CLASS_QUERY(IfProj)
 829   DEFINE_CLASS_QUERY(IfFalse)
 830   DEFINE_CLASS_QUERY(IfTrue)
 831   DEFINE_CLASS_QUERY(Initialize)
 832   DEFINE_CLASS_QUERY(Jump)
 833   DEFINE_CLASS_QUERY(JumpProj)
 834   DEFINE_CLASS_QUERY(Load)
 835   DEFINE_CLASS_QUERY(LoadStore)
<span class="line-modified"> 836   DEFINE_CLASS_QUERY(LoadStoreConditional)</span>


 837   DEFINE_CLASS_QUERY(Lock)
 838   DEFINE_CLASS_QUERY(Loop)
 839   DEFINE_CLASS_QUERY(Mach)
 840   DEFINE_CLASS_QUERY(MachBranch)
 841   DEFINE_CLASS_QUERY(MachCall)
 842   DEFINE_CLASS_QUERY(MachCallDynamicJava)
 843   DEFINE_CLASS_QUERY(MachCallJava)
 844   DEFINE_CLASS_QUERY(MachCallLeaf)
 845   DEFINE_CLASS_QUERY(MachCallRuntime)
 846   DEFINE_CLASS_QUERY(MachCallStaticJava)
 847   DEFINE_CLASS_QUERY(MachConstantBase)
 848   DEFINE_CLASS_QUERY(MachConstant)
 849   DEFINE_CLASS_QUERY(MachGoto)
 850   DEFINE_CLASS_QUERY(MachIf)
 851   DEFINE_CLASS_QUERY(MachJump)
 852   DEFINE_CLASS_QUERY(MachNullCheck)
 853   DEFINE_CLASS_QUERY(MachProj)
 854   DEFINE_CLASS_QUERY(MachReturn)
 855   DEFINE_CLASS_QUERY(MachSafePoint)
 856   DEFINE_CLASS_QUERY(MachSpillCopy)
 857   DEFINE_CLASS_QUERY(MachTemp)
 858   DEFINE_CLASS_QUERY(MachMemBar)
 859   DEFINE_CLASS_QUERY(MachMerge)
 860   DEFINE_CLASS_QUERY(Mem)
 861   DEFINE_CLASS_QUERY(MemBar)
 862   DEFINE_CLASS_QUERY(MemBarStoreStore)
 863   DEFINE_CLASS_QUERY(MergeMem)
 864   DEFINE_CLASS_QUERY(Mul)
 865   DEFINE_CLASS_QUERY(Multi)
 866   DEFINE_CLASS_QUERY(MultiBranch)
 867   DEFINE_CLASS_QUERY(OuterStripMinedLoop)
 868   DEFINE_CLASS_QUERY(OuterStripMinedLoopEnd)
 869   DEFINE_CLASS_QUERY(Parm)
 870   DEFINE_CLASS_QUERY(PCTable)
 871   DEFINE_CLASS_QUERY(Phi)
 872   DEFINE_CLASS_QUERY(Proj)
 873   DEFINE_CLASS_QUERY(Region)
 874   DEFINE_CLASS_QUERY(Root)
 875   DEFINE_CLASS_QUERY(SafePoint)
 876   DEFINE_CLASS_QUERY(SafePointScalarObject)

 877   DEFINE_CLASS_QUERY(Start)
 878   DEFINE_CLASS_QUERY(Store)
 879   DEFINE_CLASS_QUERY(Sub)
<span class="line-added"> 880   DEFINE_CLASS_QUERY(SubTypeCheck)</span>
 881   DEFINE_CLASS_QUERY(Type)
 882   DEFINE_CLASS_QUERY(Vector)
 883   DEFINE_CLASS_QUERY(LoadVector)
 884   DEFINE_CLASS_QUERY(StoreVector)
 885   DEFINE_CLASS_QUERY(Unlock)
 886 
 887   #undef DEFINE_CLASS_QUERY
 888 
 889   // duplicate of is_MachSpillCopy()
 890   bool is_SpillCopy () const {
 891     return ((_class_id &amp; ClassMask_MachSpillCopy) == Class_MachSpillCopy);
 892   }
 893 
 894   bool is_Con () const { return (_flags &amp; Flag_is_Con) != 0; }
 895   // The data node which is safe to leave in dead loop during IGVN optimization.
 896   bool is_dead_loop_safe() const {
 897     return is_Phi() || (is_Proj() &amp;&amp; in(0) == NULL) ||
 898            ((_flags &amp; (Flag_is_dead_loop_safe | Flag_is_Con)) != 0 &amp;&amp;
 899             (!is_Proj() || !in(0)-&gt;is_Allocate()));
 900   }
</pre>
<hr />
<pre>
 983   // Check if &#39;this&#39; node dominates or equal to &#39;sub&#39;.
 984   bool dominates(Node* sub, Node_List &amp;nlist);
 985 
 986 protected:
 987   bool remove_dead_region(PhaseGVN *phase, bool can_reshape);
 988 public:
 989 
 990   // See if there is valid pipeline info
 991   static  const Pipeline *pipeline_class();
 992   virtual const Pipeline *pipeline() const;
 993 
 994   // Compute the latency from the def to this instruction of the ith input node
 995   uint latency(uint i);
 996 
 997   // Hash &amp; compare functions, for pessimistic value numbering
 998 
 999   // If the hash function returns the special sentinel value NO_HASH,
1000   // the node is guaranteed never to compare equal to any other node.
1001   // If we accidentally generate a hash with value NO_HASH the node
1002   // won&#39;t go into the table and we&#39;ll lose a little optimization.
<span class="line-modified">1003   static const uint NO_HASH = 0;</span>
1004   virtual uint hash() const;
<span class="line-modified">1005   virtual bool cmp( const Node &amp;n ) const;</span>
1006 
1007   // Operation appears to be iteratively computed (such as an induction variable)
1008   // It is possible for this operation to return false for a loop-varying
1009   // value, if it appears (by local graph inspection) to be computed by a simple conditional.
1010   bool is_iteratively_computed();
1011 
<span class="line-modified">1012   // Determine if a node is a counted loop induction variable.</span>
<span class="line-modified">1013   // NOTE: The method is defined in &quot;loopnode.cpp&quot;.</span>
<span class="line-modified">1014   bool is_cloop_ind_var() const;</span>
1015 
1016   // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
1017   // be found; Otherwise return NULL;
1018   Node* find_similar(int opc);
1019 
1020   // Return the unique control out if only one. Null if none or more than one.
1021   Node* unique_ctrl_out() const;
1022 
1023   // Set control or add control as precedence edge
1024   void ensure_control_or_add_prec(Node* c);
1025 
1026 //----------------- Code Generation
1027 
1028   // Ideal register class for Matching.  Zero means unmatched instruction
1029   // (these are cloned instead of converted to machine nodes).
1030   virtual uint ideal_reg() const;
1031 
1032   static const uint NotAMachineReg;   // must be &gt; max. machine register
1033 
1034   // Do we Match on this edge index or not?  Generally false for Control
</pre>
<hr />
<pre>
1507   void yank( Node *n );         // Find and remove
1508   Node *pop() { return _nodes[--_cnt]; }
1509   Node *rpop() { Node *b = _nodes[0]; _nodes[0]=_nodes[--_cnt]; return b;}
1510   void clear() { _cnt = 0; Node_Array::clear(); } // retain storage
1511   uint size() const { return _cnt; }
1512   void dump() const;
1513   void dump_simple() const;
1514 };
1515 
1516 //------------------------------Unique_Node_List-------------------------------
1517 class Unique_Node_List : public Node_List {
1518   friend class VMStructs;
1519   VectorSet _in_worklist;
1520   uint _clock_index;            // Index in list where to pop from next
1521 public:
1522   Unique_Node_List() : Node_List(), _in_worklist(Thread::current()-&gt;resource_area()), _clock_index(0) {}
1523   Unique_Node_List(Arena *a) : Node_List(a), _in_worklist(a), _clock_index(0) {}
1524 
1525   void remove( Node *n );
1526   bool member( Node *n ) { return _in_worklist.test(n-&gt;_idx) != 0; }
<span class="line-modified">1527   VectorSet&amp; member_set(){ return _in_worklist; }</span>
1528 
<span class="line-modified">1529   void push(Node* b) {</span>
1530     if( !_in_worklist.test_set(b-&gt;_idx) )
1531       Node_List::push(b);
1532   }
1533   Node *pop() {
1534     if( _clock_index &gt;= size() ) _clock_index = 0;
1535     Node *b = at(_clock_index);
1536     map( _clock_index, Node_List::pop());
1537     if (size() != 0) _clock_index++; // Always start from 0
<span class="line-modified">1538     _in_worklist.remove(b-&gt;_idx);</span>
1539     return b;
1540   }
<span class="line-modified">1541   Node *remove(uint i) {</span>
1542     Node *b = Node_List::at(i);
<span class="line-modified">1543     _in_worklist.remove(b-&gt;_idx);</span>
1544     map(i,Node_List::pop());
1545     return b;
1546   }
<span class="line-modified">1547   void yank(Node *n) {</span>
<span class="line-added">1548     _in_worklist.remove(n-&gt;_idx);</span>
<span class="line-added">1549     Node_List::yank(n);</span>
<span class="line-added">1550   }</span>
1551   void  clear() {
<span class="line-modified">1552     _in_worklist.clear();        // Discards storage but grows automatically</span>
1553     Node_List::clear();
1554     _clock_index = 0;
1555   }
1556 
1557   // Used after parsing to remove useless nodes before Iterative GVN
<span class="line-modified">1558   void remove_useless_nodes(VectorSet&amp; useful);</span>
1559 
1560 #ifndef PRODUCT
1561   void print_set() const { _in_worklist.print(); }
1562 #endif
1563 };
1564 
1565 // Inline definition of Compile::record_for_igvn must be deferred to this point.
1566 inline void Compile::record_for_igvn(Node* n) {
1567   _for_igvn-&gt;push(n);
1568 }
1569 
1570 //------------------------------Node_Stack-------------------------------------
1571 class Node_Stack {
1572   friend class VMStructs;
1573 protected:
1574   struct INode {
1575     Node *node; // Processed node
1576     uint  indx; // Index of next node&#39;s child
1577   };
1578   INode *_inode_top; // tos, stack grows up
</pre>
<hr />
<pre>
1703   if (arr == NULL) return NULL;
1704   // (Every element of arr is a sub-array of length _node_notes_block_size.)
1705   return arr-&gt;at(block_idx) + (idx &amp; (_node_notes_block_size-1));
1706 }
1707 
1708 inline bool
1709 Compile::set_node_notes_at(int idx, Node_Notes* value) {
1710   if (value == NULL || value-&gt;is_clear())
1711     return false;  // nothing to write =&gt; write nothing
1712   Node_Notes* loc = locate_node_notes(_node_note_array, idx, true);
1713   assert(loc != NULL, &quot;&quot;);
1714   return loc-&gt;update_from(value);
1715 }
1716 
1717 
1718 //------------------------------TypeNode---------------------------------------
1719 // Node with a Type constant.
1720 class TypeNode : public Node {
1721 protected:
1722   virtual uint hash() const;    // Check the type
<span class="line-modified">1723   virtual bool cmp( const Node &amp;n ) const;</span>
1724   virtual uint size_of() const; // Size is bigger
1725   const Type* const _type;
1726 public:
1727   void set_type(const Type* t) {
1728     assert(t != NULL, &quot;sanity&quot;);
1729     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
1730     *(const Type**)&amp;_type = t;   // cast away const-ness
1731     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
1732     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
1733   }
1734   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
1735   TypeNode( const Type *t, uint required ) : Node(required), _type(t) {
1736     init_class_id(Class_Type);
1737   }
1738   virtual const Type* Value(PhaseGVN* phase) const;
1739   virtual const Type *bottom_type() const;
1740   virtual       uint  ideal_reg() const;
1741 #ifndef PRODUCT
1742   virtual void dump_spec(outputStream *st) const;
1743   virtual void dump_compact_spec(outputStream *st) const;
</pre>
</td>
</tr>
</table>
<center><a href="node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="opaquenode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
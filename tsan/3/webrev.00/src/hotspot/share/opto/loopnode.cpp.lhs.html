<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.inline.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/callnode.hpp&quot;
  35 #include &quot;opto/connode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/mulnode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/superword.hpp&quot;
<a name="2" id="anc2"></a>
  43 
  44 //=============================================================================
<a name="3" id="anc3"></a><span class="line-modified">  45 //------------------------------is_loop_iv-------------------------------------</span>
<span class="line-modified">  46 // Determine if a node is Counted loop induction variable.</span>
<span class="line-modified">  47 // The method is declared in node.hpp.</span>
<span class="line-modified">  48 const Node* Node::is_loop_iv() const {</span>
<span class="line-modified">  49   if (this-&gt;is_Phi() &amp;&amp; !this-&gt;as_Phi()-&gt;is_copy() &amp;&amp;</span>
<span class="line-modified">  50       this-&gt;as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;</span>
<span class="line-modified">  51       this-&gt;as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this) {</span>
<span class="line-removed">  52     return this;</span>
<span class="line-removed">  53   } else {</span>
<span class="line-removed">  54     return NULL;</span>
<span class="line-removed">  55   }</span>
  56 }
  57 
  58 //=============================================================================
  59 //------------------------------dump_spec--------------------------------------
  60 // Dump special per-node info
  61 #ifndef PRODUCT
  62 void LoopNode::dump_spec(outputStream *st) const {
  63   if (is_inner_loop()) st-&gt;print( &quot;inner &quot; );
  64   if (is_partial_peel_loop()) st-&gt;print( &quot;partial_peel &quot; );
  65   if (partial_peel_has_failed()) st-&gt;print( &quot;partial_peel_failed &quot; );
  66 }
  67 #endif
  68 
  69 //------------------------------is_valid_counted_loop-------------------------
  70 bool LoopNode::is_valid_counted_loop() const {
  71   if (is_CountedLoop()) {
  72     CountedLoopNode*    l  = as_CountedLoop();
  73     CountedLoopEndNode* le = l-&gt;loopexit_or_null();
  74     if (le != NULL &amp;&amp;
  75         le-&gt;proj_out_or_null(1 /* true */) == l-&gt;in(LoopNode::LoopBackControl)) {
  76       Node* phi  = l-&gt;phi();
  77       Node* exit = le-&gt;proj_out_or_null(0 /* false */);
  78       if (exit != NULL &amp;&amp; exit-&gt;Opcode() == Op_IfFalse &amp;&amp;
  79           phi != NULL &amp;&amp; phi-&gt;is_Phi() &amp;&amp;
  80           phi-&gt;in(LoopNode::LoopBackControl) == l-&gt;incr() &amp;&amp;
  81           le-&gt;loopnode() == l &amp;&amp; le-&gt;stride_is_con()) {
  82         return true;
  83       }
  84     }
  85   }
  86   return false;
  87 }
  88 
  89 //------------------------------get_early_ctrl---------------------------------
  90 // Compute earliest legal control
  91 Node *PhaseIdealLoop::get_early_ctrl( Node *n ) {
  92   assert( !n-&gt;is_Phi() &amp;&amp; !n-&gt;is_CFG(), &quot;this code only handles data nodes&quot; );
  93   uint i;
  94   Node *early;
  95   if (n-&gt;in(0) &amp;&amp; !n-&gt;is_expensive()) {
  96     early = n-&gt;in(0);
  97     if (!early-&gt;is_CFG()) // Might be a non-CFG multi-def
  98       early = get_ctrl(early);        // So treat input as a straight data input
  99     i = 1;
 100   } else {
 101     early = get_ctrl(n-&gt;in(1));
 102     i = 2;
 103   }
 104   uint e_d = dom_depth(early);
 105   assert( early, &quot;&quot; );
 106   for (; i &lt; n-&gt;req(); i++) {
 107     Node *cin = get_ctrl(n-&gt;in(i));
 108     assert( cin, &quot;&quot; );
 109     // Keep deepest dominator depth
 110     uint c_d = dom_depth(cin);
 111     if (c_d &gt; e_d) {           // Deeper guy?
 112       early = cin;              // Keep deepest found so far
 113       e_d = c_d;
 114     } else if (c_d == e_d &amp;&amp;    // Same depth?
 115                early != cin) { // If not equal, must use slower algorithm
 116       // If same depth but not equal, one _must_ dominate the other
 117       // and we want the deeper (i.e., dominated) guy.
 118       Node *n1 = early;
 119       Node *n2 = cin;
 120       while (1) {
 121         n1 = idom(n1);          // Walk up until break cycle
 122         n2 = idom(n2);
 123         if (n1 == cin ||        // Walked early up to cin
 124             dom_depth(n2) &lt; c_d)
 125           break;                // early is deeper; keep him
 126         if (n2 == early ||      // Walked cin up to early
 127             dom_depth(n1) &lt; c_d) {
 128           early = cin;          // cin is deeper; keep him
 129           break;
 130         }
 131       }
 132       e_d = dom_depth(early);   // Reset depth register cache
 133     }
 134   }
 135 
 136   // Return earliest legal location
 137   assert(early == find_non_split_ctrl(early), &quot;unexpected early control&quot;);
 138 
 139   if (n-&gt;is_expensive() &amp;&amp; !_verify_only &amp;&amp; !_verify_me) {
 140     assert(n-&gt;in(0), &quot;should have control input&quot;);
 141     early = get_early_ctrl_for_expensive(n, early);
 142   }
 143 
 144   return early;
 145 }
 146 
 147 //------------------------------get_early_ctrl_for_expensive---------------------------------
 148 // Move node up the dominator tree as high as legal while still beneficial
 149 Node *PhaseIdealLoop::get_early_ctrl_for_expensive(Node *n, Node* earliest) {
 150   assert(n-&gt;in(0) &amp;&amp; n-&gt;is_expensive(), &quot;expensive node with control input here&quot;);
 151   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
 152 
 153   Node* ctl = n-&gt;in(0);
 154   assert(ctl-&gt;is_CFG(), &quot;expensive input 0 must be cfg&quot;);
 155   uint min_dom_depth = dom_depth(earliest);
 156 #ifdef ASSERT
 157   if (!is_dominator(ctl, earliest) &amp;&amp; !is_dominator(earliest, ctl)) {
 158     dump_bad_graph(&quot;Bad graph detected in get_early_ctrl_for_expensive&quot;, n, earliest, ctl);
 159     assert(false, &quot;Bad graph detected in get_early_ctrl_for_expensive&quot;);
 160   }
 161 #endif
 162   if (dom_depth(ctl) &lt; min_dom_depth) {
 163     return earliest;
 164   }
 165 
 166   while (1) {
 167     Node *next = ctl;
 168     // Moving the node out of a loop on the projection of a If
 169     // confuses loop predication. So once we hit a Loop in a If branch
 170     // that doesn&#39;t branch to an UNC, we stop. The code that process
 171     // expensive nodes will notice the loop and skip over it to try to
 172     // move the node further up.
 173     if (ctl-&gt;is_CountedLoop() &amp;&amp; ctl-&gt;in(1) != NULL &amp;&amp; ctl-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ctl-&gt;in(1)-&gt;in(0)-&gt;is_If()) {
 174       if (!ctl-&gt;in(1)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {
 175         break;
 176       }
 177       next = idom(ctl-&gt;in(1)-&gt;in(0));
 178     } else if (ctl-&gt;is_Proj()) {
 179       // We only move it up along a projection if the projection is
 180       // the single control projection for its parent: same code path,
 181       // if it&#39;s a If with UNC or fallthrough of a call.
 182       Node* parent_ctl = ctl-&gt;in(0);
 183       if (parent_ctl == NULL) {
 184         break;
 185       } else if (parent_ctl-&gt;is_CountedLoopEnd() &amp;&amp; parent_ctl-&gt;as_CountedLoopEnd()-&gt;loopnode() != NULL) {
 186         next = parent_ctl-&gt;as_CountedLoopEnd()-&gt;loopnode()-&gt;init_control();
 187       } else if (parent_ctl-&gt;is_If()) {
 188         if (!ctl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {
 189           break;
 190         }
 191         assert(idom(ctl) == parent_ctl, &quot;strange&quot;);
 192         next = idom(parent_ctl);
 193       } else if (ctl-&gt;is_CatchProj()) {
 194         if (ctl-&gt;as_Proj()-&gt;_con != CatchProjNode::fall_through_index) {
 195           break;
 196         }
 197         assert(parent_ctl-&gt;in(0)-&gt;in(0)-&gt;is_Call(), &quot;strange graph&quot;);
 198         next = parent_ctl-&gt;in(0)-&gt;in(0)-&gt;in(0);
 199       } else {
 200         // Check if parent control has a single projection (this
 201         // control is the only possible successor of the parent
 202         // control). If so, we can try to move the node above the
 203         // parent control.
 204         int nb_ctl_proj = 0;
 205         for (DUIterator_Fast imax, i = parent_ctl-&gt;fast_outs(imax); i &lt; imax; i++) {
 206           Node *p = parent_ctl-&gt;fast_out(i);
 207           if (p-&gt;is_Proj() &amp;&amp; p-&gt;is_CFG()) {
 208             nb_ctl_proj++;
 209             if (nb_ctl_proj &gt; 1) {
 210               break;
 211             }
 212           }
 213         }
 214 
 215         if (nb_ctl_proj &gt; 1) {
 216           break;
 217         }
 218         assert(parent_ctl-&gt;is_Start() || parent_ctl-&gt;is_MemBar() || parent_ctl-&gt;is_Call() ||
 219                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(parent_ctl), &quot;unexpected node&quot;);
 220         assert(idom(ctl) == parent_ctl, &quot;strange&quot;);
 221         next = idom(parent_ctl);
 222       }
 223     } else {
 224       next = idom(ctl);
 225     }
 226     if (next-&gt;is_Root() || next-&gt;is_Start() || dom_depth(next) &lt; min_dom_depth) {
 227       break;
 228     }
 229     ctl = next;
 230   }
 231 
 232   if (ctl != n-&gt;in(0)) {
 233     _igvn.replace_input_of(n, 0, ctl);
 234     _igvn.hash_insert(n);
 235   }
 236 
 237   return ctl;
 238 }
 239 
 240 
 241 //------------------------------set_early_ctrl---------------------------------
 242 // Set earliest legal control
 243 void PhaseIdealLoop::set_early_ctrl( Node *n ) {
 244   Node *early = get_early_ctrl(n);
 245 
 246   // Record earliest legal location
 247   set_ctrl(n, early);
 248 }
 249 
 250 //------------------------------set_subtree_ctrl-------------------------------
 251 // set missing _ctrl entries on new nodes
 252 void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {
 253   // Already set?  Get out.
 254   if( _nodes[n-&gt;_idx] ) return;
 255   // Recursively set _nodes array to indicate where the Node goes
 256   uint i;
 257   for( i = 0; i &lt; n-&gt;req(); ++i ) {
 258     Node *m = n-&gt;in(i);
 259     if( m &amp;&amp; m != C-&gt;root() )
 260       set_subtree_ctrl( m );
 261   }
 262 
 263   // Fixup self
 264   set_early_ctrl( n );
 265 }
 266 
 267 // Create a skeleton strip mined outer loop: a Loop head before the
 268 // inner strip mined loop, a safepoint and an exit condition guarded
 269 // by an opaque node after the inner strip mined loop with a backedge
 270 // to the loop head. The inner strip mined loop is left as it is. Only
 271 // once loop optimizations are over, do we adjust the inner loop exit
 272 // condition to limit its number of iterations, set the outer loop
 273 // exit condition and add Phis to the outer loop head. Some loop
 274 // optimizations that operate on the inner strip mined loop need to be
 275 // aware of the outer strip mined loop: loop unswitching needs to
 276 // clone the outer loop as well as the inner, unrolling needs to only
 277 // clone the inner loop etc. No optimizations need to change the outer
 278 // strip mined loop as it is only a skeleton.
 279 IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
 280                                                              IdealLoopTree* loop, float cl_prob, float le_fcnt,
 281                                                              Node*&amp; entry_control, Node*&amp; iffalse) {
 282   Node* outer_test = _igvn.intcon(0);
 283   set_ctrl(outer_test, C-&gt;root());
 284   Node *orig = iffalse;
 285   iffalse = iffalse-&gt;clone();
 286   _igvn.register_new_node_with_optimizer(iffalse);
 287   set_idom(iffalse, idom(orig), dom_depth(orig));
 288 
 289   IfNode *outer_le = new OuterStripMinedLoopEndNode(iffalse, outer_test, cl_prob, le_fcnt);
 290   Node *outer_ift = new IfTrueNode (outer_le);
 291   Node* outer_iff = orig;
 292   _igvn.replace_input_of(outer_iff, 0, outer_le);
 293 
 294   LoopNode *outer_l = new OuterStripMinedLoopNode(C, init_control, outer_ift);
 295   entry_control = outer_l;
 296 
 297   IdealLoopTree* outer_ilt = new IdealLoopTree(this, outer_l, outer_ift);
 298   IdealLoopTree* parent = loop-&gt;_parent;
 299   IdealLoopTree* sibling = parent-&gt;_child;
 300   if (sibling == loop) {
 301     parent-&gt;_child = outer_ilt;
 302   } else {
 303     while (sibling-&gt;_next != loop) {
 304       sibling = sibling-&gt;_next;
 305     }
 306     sibling-&gt;_next = outer_ilt;
 307   }
 308   outer_ilt-&gt;_next = loop-&gt;_next;
 309   outer_ilt-&gt;_parent = parent;
 310   outer_ilt-&gt;_child = loop;
 311   outer_ilt-&gt;_nest = loop-&gt;_nest;
 312   loop-&gt;_parent = outer_ilt;
 313   loop-&gt;_next = NULL;
 314   loop-&gt;_nest++;
 315 
 316   set_loop(iffalse, outer_ilt);
 317   register_control(outer_le, outer_ilt, iffalse);
 318   register_control(outer_ift, outer_ilt, outer_le);
 319   set_idom(outer_iff, outer_le, dom_depth(outer_le));
 320   _igvn.register_new_node_with_optimizer(outer_l);
 321   set_loop(outer_l, outer_ilt);
 322   set_idom(outer_l, init_control, dom_depth(init_control)+1);
 323 
 324   return outer_ilt;
 325 }
 326 
 327 void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {
 328   Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,
 329                                                          Deoptimization::Reason_loop_limit_check,
 330                                                          Op_If);
 331   Node* iff = new_predicate_proj-&gt;in(0);
 332   assert(iff-&gt;Opcode() == Op_If, &quot;bad graph shape&quot;);
 333   Node* conv = iff-&gt;in(1);
 334   assert(conv-&gt;Opcode() == Op_Conv2B, &quot;bad graph shape&quot;);
 335   Node* opaq = conv-&gt;in(1);
 336   assert(opaq-&gt;Opcode() == Op_Opaque1, &quot;bad graph shape&quot;);
 337   cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);
 338   bol = _igvn.register_new_node_with_optimizer(bol);
 339   set_subtree_ctrl(bol);
 340   _igvn.replace_input_of(iff, 1, bol);
 341 
 342 #ifndef PRODUCT
 343   // report that the loop predication has been actually performed
 344   // for this loop
 345   if (TraceLoopLimitCheck) {
 346     tty-&gt;print_cr(&quot;Counted Loop Limit Check generated:&quot;);
 347     debug_only( bol-&gt;dump(2); )
 348   }
 349 #endif
 350 }
 351 
 352 //------------------------------is_counted_loop--------------------------------
 353 bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&amp; loop) {
 354   PhaseGVN *gvn = &amp;_igvn;
 355 
 356   // Counted loop head must be a good RegionNode with only 3 not NULL
 357   // control input edges: Self, Entry, LoopBack.
 358   if (x-&gt;in(LoopNode::Self) == NULL || x-&gt;req() != 3 || loop-&gt;_irreducible) {
 359     return false;
 360   }
 361   Node *init_control = x-&gt;in(LoopNode::EntryControl);
 362   Node *back_control = x-&gt;in(LoopNode::LoopBackControl);
 363   if (init_control == NULL || back_control == NULL)    // Partially dead
 364     return false;
 365   // Must also check for TOP when looking for a dead loop
 366   if (init_control-&gt;is_top() || back_control-&gt;is_top())
 367     return false;
 368 
 369   // Allow funny placement of Safepoint
 370   if (back_control-&gt;Opcode() == Op_SafePoint) {
 371     if (LoopStripMiningIter != 0) {
 372       // Leaving the safepoint on the backedge and creating a
 373       // CountedLoop will confuse optimizations. We can&#39;t move the
 374       // safepoint around because its jvm state wouldn&#39;t match a new
 375       // location. Give up on that loop.
 376       return false;
 377     }
 378     back_control = back_control-&gt;in(TypeFunc::Control);
 379   }
 380 
 381   // Controlling test for loop
 382   Node *iftrue = back_control;
 383   uint iftrue_op = iftrue-&gt;Opcode();
 384   if (iftrue_op != Op_IfTrue &amp;&amp;
 385       iftrue_op != Op_IfFalse)
 386     // I have a weird back-control.  Probably the loop-exit test is in
 387     // the middle of the loop and I am looking at some trailing control-flow
 388     // merge point.  To fix this I would have to partially peel the loop.
 389     return false; // Obscure back-control
 390 
 391   // Get boolean guarding loop-back test
 392   Node *iff = iftrue-&gt;in(0);
 393   if (get_loop(iff) != loop || !iff-&gt;in(1)-&gt;is_Bool())
 394     return false;
 395   BoolNode *test = iff-&gt;in(1)-&gt;as_Bool();
 396   BoolTest::mask bt = test-&gt;_test._test;
 397   float cl_prob = iff-&gt;as_If()-&gt;_prob;
 398   if (iftrue_op == Op_IfFalse) {
 399     bt = BoolTest(bt).negate();
 400     cl_prob = 1.0 - cl_prob;
 401   }
 402   // Get backedge compare
 403   Node *cmp = test-&gt;in(1);
 404   int cmp_op = cmp-&gt;Opcode();
 405   if (cmp_op != Op_CmpI)
 406     return false;                // Avoid pointer &amp; float compares
 407 
 408   // Find the trip-counter increment &amp; limit.  Limit must be loop invariant.
 409   Node *incr  = cmp-&gt;in(1);
 410   Node *limit = cmp-&gt;in(2);
 411 
 412   // ---------
 413   // need &#39;loop()&#39; test to tell if limit is loop invariant
 414   // ---------
 415 
 416   if (!is_member(loop, get_ctrl(incr))) { // Swapped trip counter and limit?
 417     Node *tmp = incr;            // Then reverse order into the CmpI
 418     incr = limit;
 419     limit = tmp;
 420     bt = BoolTest(bt).commute(); // And commute the exit test
 421   }
 422   if (is_member(loop, get_ctrl(limit))) // Limit must be loop-invariant
 423     return false;
 424   if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant
 425     return false;
 426 
 427   Node* phi_incr = NULL;
 428   // Trip-counter increment must be commutative &amp; associative.
 429   if (incr-&gt;Opcode() == Op_CastII) {
 430     incr = incr-&gt;in(1);
 431   }
 432   if (incr-&gt;is_Phi()) {
 433     if (incr-&gt;as_Phi()-&gt;region() != x || incr-&gt;req() != 3)
 434       return false; // Not simple trip counter expression
 435     phi_incr = incr;
 436     incr = phi_incr-&gt;in(LoopNode::LoopBackControl); // Assume incr is on backedge of Phi
 437     if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant
 438       return false;
 439   }
 440 
 441   Node* trunc1 = NULL;
 442   Node* trunc2 = NULL;
 443   const TypeInt* iv_trunc_t = NULL;
 444   Node* orig_incr = incr;
 445   if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &amp;trunc1, &amp;trunc2, &amp;iv_trunc_t))) {
 446     return false; // Funny increment opcode
 447   }
 448   assert(incr-&gt;Opcode() == Op_AddI, &quot;wrong increment code&quot;);
 449 
 450   const TypeInt* limit_t = gvn-&gt;type(limit)-&gt;is_int();
 451   if (trunc1 != NULL) {
 452     // When there is a truncation, we must be sure that after the truncation
 453     // the trip counter will end up higher than the limit, otherwise we are looking
 454     // at an endless loop. Can happen with range checks.
 455 
 456     // Example:
 457     // int i = 0;
 458     // while (true)
 459     //    sum + = array[i];
 460     //    i++;
 461     //    i = i &amp;&amp; 0x7fff;
 462     //  }
 463     //
 464     // If the array is shorter than 0x8000 this exits through a AIOOB
 465     //  - Counted loop transformation is ok
 466     // If the array is longer then this is an endless loop
 467     //  - No transformation can be done.
 468 
 469     const TypeInt* incr_t = gvn-&gt;type(orig_incr)-&gt;is_int();
 470     if (limit_t-&gt;_hi &gt; incr_t-&gt;_hi) {
 471       // if the limit can have a higher value than the increment (before the phi)
 472       return false;
 473     }
 474   }
 475 
 476   // Get merge point
 477   Node *xphi = incr-&gt;in(1);
 478   Node *stride = incr-&gt;in(2);
 479   if (!stride-&gt;is_Con()) {     // Oops, swap these
 480     if (!xphi-&gt;is_Con())       // Is the other guy a constant?
 481       return false;             // Nope, unknown stride, bail out
 482     Node *tmp = xphi;           // &#39;incr&#39; is commutative, so ok to swap
 483     xphi = stride;
 484     stride = tmp;
 485   }
 486   if (xphi-&gt;Opcode() == Op_CastII) {
 487     xphi = xphi-&gt;in(1);
 488   }
 489   // Stride must be constant
 490   int stride_con = stride-&gt;get_int();
 491   if (stride_con == 0)
 492     return false; // missed some peephole opt
 493 
 494   if (!xphi-&gt;is_Phi())
 495     return false; // Too much math on the trip counter
 496   if (phi_incr != NULL &amp;&amp; phi_incr != xphi)
 497     return false;
 498   PhiNode *phi = xphi-&gt;as_Phi();
 499 
 500   // Phi must be of loop header; backedge must wrap to increment
 501   if (phi-&gt;region() != x)
 502     return false;
 503   if ((trunc1 == NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != incr) ||
 504       (trunc1 != NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != trunc1)) {
 505     return false;
 506   }
 507   Node *init_trip = phi-&gt;in(LoopNode::EntryControl);
 508 
 509   // If iv trunc type is smaller than int, check for possible wrap.
 510   if (!TypeInt::INT-&gt;higher_equal(iv_trunc_t)) {
 511     assert(trunc1 != NULL, &quot;must have found some truncation&quot;);
 512 
 513     // Get a better type for the phi (filtered thru if&#39;s)
 514     const TypeInt* phi_ft = filtered_type(phi);
 515 
 516     // Can iv take on a value that will wrap?
 517     //
 518     // Ensure iv&#39;s limit is not within &quot;stride&quot; of the wrap value.
 519     //
 520     // Example for &quot;short&quot; type
 521     //    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)
 522     //    If the stride is +10, then the last value of the induction
 523     //    variable before the increment (phi_ft-&gt;_hi) must be
 524     //    &lt;= 32767 - 10 and (phi_ft-&gt;_lo) must be &gt;= -32768 to
 525     //    ensure no truncation occurs after the increment.
 526 
 527     if (stride_con &gt; 0) {
 528       if (iv_trunc_t-&gt;_hi - phi_ft-&gt;_hi &lt; stride_con ||
 529           iv_trunc_t-&gt;_lo &gt; phi_ft-&gt;_lo) {
 530         return false;  // truncation may occur
 531       }
 532     } else if (stride_con &lt; 0) {
 533       if (iv_trunc_t-&gt;_lo - phi_ft-&gt;_lo &gt; stride_con ||
 534           iv_trunc_t-&gt;_hi &lt; phi_ft-&gt;_hi) {
 535         return false;  // truncation may occur
 536       }
 537     }
 538     // No possibility of wrap so truncation can be discarded
 539     // Promote iv type to Int
 540   } else {
 541     assert(trunc1 == NULL &amp;&amp; trunc2 == NULL, &quot;no truncation for int&quot;);
 542   }
 543 
 544   // If the condition is inverted and we will be rolling
 545   // through MININT to MAXINT, then bail out.
 546   if (bt == BoolTest::eq || // Bail out, but this loop trips at most twice!
 547       // Odd stride
 548       (bt == BoolTest::ne &amp;&amp; stride_con != 1 &amp;&amp; stride_con != -1) ||
 549       // Count down loop rolls through MAXINT
 550       ((bt == BoolTest::le || bt == BoolTest::lt) &amp;&amp; stride_con &lt; 0) ||
 551       // Count up loop rolls through MININT
 552       ((bt == BoolTest::ge || bt == BoolTest::gt) &amp;&amp; stride_con &gt; 0)) {
 553     return false; // Bail out
 554   }
 555 
 556   const TypeInt* init_t = gvn-&gt;type(init_trip)-&gt;is_int();
 557 
 558   if (stride_con &gt; 0) {
 559     jlong init_p = (jlong)init_t-&gt;_lo + stride_con;
 560     if (init_p &gt; (jlong)max_jint || init_p &gt; (jlong)limit_t-&gt;_hi)
 561       return false; // cyclic loop or this loop trips only once
 562   } else {
 563     jlong init_p = (jlong)init_t-&gt;_hi + stride_con;
 564     if (init_p &lt; (jlong)min_jint || init_p &lt; (jlong)limit_t-&gt;_lo)
 565       return false; // cyclic loop or this loop trips only once
 566   }
 567 
 568   if (phi_incr != NULL &amp;&amp; bt != BoolTest::ne) {
 569     // check if there is a possiblity of IV overflowing after the first increment
 570     if (stride_con &gt; 0) {
 571       if (init_t-&gt;_hi &gt; max_jint - stride_con) {
 572         return false;
 573       }
 574     } else {
 575       if (init_t-&gt;_lo &lt; min_jint - stride_con) {
 576         return false;
 577       }
 578     }
 579   }
 580 
 581   // =================================================
 582   // ---- SUCCESS!   Found A Trip-Counted Loop!  -----
 583   //
 584   assert(x-&gt;Opcode() == Op_Loop, &quot;regular loops only&quot;);
 585   C-&gt;print_method(PHASE_BEFORE_CLOOPS, 3);
 586 
 587   Node *hook = new Node(6);
 588 
 589   // ===================================================
 590   // Generate loop limit check to avoid integer overflow
 591   // in cases like next (cyclic loops):
 592   //
 593   // for (i=0; i &lt;= max_jint; i++) {}
 594   // for (i=0; i &lt;  max_jint; i+=2) {}
 595   //
 596   //
 597   // Limit check predicate depends on the loop test:
 598   //
 599   // for(;i != limit; i++)       --&gt; limit &lt;= (max_jint)
 600   // for(;i &lt;  limit; i+=stride) --&gt; limit &lt;= (max_jint - stride + 1)
 601   // for(;i &lt;= limit; i+=stride) --&gt; limit &lt;= (max_jint - stride    )
 602   //
 603 
 604   // Check if limit is excluded to do more precise int overflow check.
 605   bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);
 606   int stride_m  = stride_con - (incl_limit ? 0 : (stride_con &gt; 0 ? 1 : -1));
 607 
 608   // If compare points directly to the phi we need to adjust
 609   // the compare so that it points to the incr. Limit have
 610   // to be adjusted to keep trip count the same and the
 611   // adjusted limit should be checked for int overflow.
 612   if (phi_incr != NULL) {
 613     stride_m  += stride_con;
 614   }
 615 
 616   if (limit-&gt;is_Con()) {
 617     int limit_con = limit-&gt;get_int();
 618     if ((stride_con &gt; 0 &amp;&amp; limit_con &gt; (max_jint - stride_m)) ||
 619         (stride_con &lt; 0 &amp;&amp; limit_con &lt; (min_jint - stride_m))) {
 620       // Bailout: it could be integer overflow.
 621       return false;
 622     }
 623   } else if ((stride_con &gt; 0 &amp;&amp; limit_t-&gt;_hi &lt;= (max_jint - stride_m)) ||
 624              (stride_con &lt; 0 &amp;&amp; limit_t-&gt;_lo &gt;= (min_jint - stride_m))) {
 625       // Limit&#39;s type may satisfy the condition, for example,
 626       // when it is an array length.
 627   } else {
 628     // Generate loop&#39;s limit check.
 629     // Loop limit check predicate should be near the loop.
 630     ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 631     if (!limit_check_proj) {
 632       // The limit check predicate is not generated if this method trapped here before.
 633 #ifdef ASSERT
 634       if (TraceLoopLimitCheck) {
 635         tty-&gt;print(&quot;missing loop limit check:&quot;);
 636         loop-&gt;dump_head();
 637         x-&gt;dump(1);
 638       }
 639 #endif
 640       return false;
 641     }
 642 
 643     IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 644 
 645     if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0))) {
 646       return false;
 647     }
 648 
 649     Node* cmp_limit;
 650     Node* bol;
 651 
 652     if (stride_con &gt; 0) {
 653       cmp_limit = new CmpINode(limit, _igvn.intcon(max_jint - stride_m));
 654       bol = new BoolNode(cmp_limit, BoolTest::le);
 655     } else {
 656       cmp_limit = new CmpINode(limit, _igvn.intcon(min_jint - stride_m));
 657       bol = new BoolNode(cmp_limit, BoolTest::ge);
 658     }
 659 
 660     insert_loop_limit_check(limit_check_proj, cmp_limit, bol);
 661   }
 662 
 663   // Now we need to canonicalize loop condition.
 664   if (bt == BoolTest::ne) {
 665     assert(stride_con == 1 || stride_con == -1, &quot;simple increment only&quot;);
 666     if (stride_con &gt; 0 &amp;&amp; init_t-&gt;_hi &lt; limit_t-&gt;_lo) {
 667       // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 668       bt = BoolTest::lt;
 669     } else if (stride_con &lt; 0 &amp;&amp; init_t-&gt;_lo &gt; limit_t-&gt;_hi) {
 670       // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 671       bt = BoolTest::gt;
 672     } else {
 673       ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 674       if (!limit_check_proj) {
 675         // The limit check predicate is not generated if this method trapped here before.
 676 #ifdef ASSERT
 677         if (TraceLoopLimitCheck) {
 678           tty-&gt;print(&quot;missing loop limit check:&quot;);
 679           loop-&gt;dump_head();
 680           x-&gt;dump(1);
 681         }
 682 #endif
 683         return false;
 684       }
 685       IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 686 
 687       if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0)) ||
 688           !is_dominator(get_ctrl(init_trip), check_iff-&gt;in(0))) {
 689         return false;
 690       }
 691 
 692       Node* cmp_limit;
 693       Node* bol;
 694 
 695       if (stride_con &gt; 0) {
 696         cmp_limit = new CmpINode(init_trip, limit);
 697         bol = new BoolNode(cmp_limit, BoolTest::lt);
 698       } else {
 699         cmp_limit = new CmpINode(init_trip, limit);
 700         bol = new BoolNode(cmp_limit, BoolTest::gt);
 701       }
 702 
 703       insert_loop_limit_check(limit_check_proj, cmp_limit, bol);
 704 
 705       if (stride_con &gt; 0) {
 706         // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 707         bt = BoolTest::lt;
 708       } else if (stride_con &lt; 0) {
 709         // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 710         bt = BoolTest::gt;
 711       }
 712     }
 713   }
 714 
 715   if (phi_incr != NULL) {
 716     // If compare points directly to the phi we need to adjust
 717     // the compare so that it points to the incr. Limit have
 718     // to be adjusted to keep trip count the same and we
 719     // should avoid int overflow.
 720     //
 721     //   i = init; do {} while(i++ &lt; limit);
 722     // is converted to
 723     //   i = init; do {} while(++i &lt; limit+1);
 724     //
 725     limit = gvn-&gt;transform(new AddINode(limit, stride));
 726   }
 727 
 728   if (incl_limit) {
 729     // The limit check guaranties that &#39;limit &lt;= (max_jint - stride)&#39; so
 730     // we can convert &#39;i &lt;= limit&#39; to &#39;i &lt; limit+1&#39; since stride != 0.
 731     //
 732     Node* one = (stride_con &gt; 0) ? gvn-&gt;intcon( 1) : gvn-&gt;intcon(-1);
 733     limit = gvn-&gt;transform(new AddINode(limit, one));
 734     if (bt == BoolTest::le)
 735       bt = BoolTest::lt;
 736     else if (bt == BoolTest::ge)
 737       bt = BoolTest::gt;
 738     else
 739       ShouldNotReachHere();
 740   }
 741   set_subtree_ctrl( limit );
 742 
 743   if (LoopStripMiningIter == 0) {
 744     // Check for SafePoint on backedge and remove
 745     Node *sfpt = x-&gt;in(LoopNode::LoopBackControl);
 746     if (sfpt-&gt;Opcode() == Op_SafePoint &amp;&amp; is_deleteable_safept(sfpt)) {
 747       lazy_replace( sfpt, iftrue );
 748       if (loop-&gt;_safepts != NULL) {
 749         loop-&gt;_safepts-&gt;yank(sfpt);
 750       }
 751       loop-&gt;_tail = iftrue;
 752     }
 753   }
 754 
 755   // Build a canonical trip test.
 756   // Clone code, as old values may be in use.
 757   incr = incr-&gt;clone();
 758   incr-&gt;set_req(1,phi);
 759   incr-&gt;set_req(2,stride);
 760   incr = _igvn.register_new_node_with_optimizer(incr);
 761   set_early_ctrl( incr );
 762   _igvn.rehash_node_delayed(phi);
 763   phi-&gt;set_req_X( LoopNode::LoopBackControl, incr, &amp;_igvn );
 764 
 765   // If phi type is more restrictive than Int, raise to
 766   // Int to prevent (almost) infinite recursion in igvn
 767   // which can only handle integer types for constants or minint..maxint.
 768   if (!TypeInt::INT-&gt;higher_equal(phi-&gt;bottom_type())) {
 769     Node* nphi = PhiNode::make(phi-&gt;in(0), phi-&gt;in(LoopNode::EntryControl), TypeInt::INT);
 770     nphi-&gt;set_req(LoopNode::LoopBackControl, phi-&gt;in(LoopNode::LoopBackControl));
 771     nphi = _igvn.register_new_node_with_optimizer(nphi);
 772     set_ctrl(nphi, get_ctrl(phi));
 773     _igvn.replace_node(phi, nphi);
 774     phi = nphi-&gt;as_Phi();
 775   }
 776   cmp = cmp-&gt;clone();
 777   cmp-&gt;set_req(1,incr);
 778   cmp-&gt;set_req(2,limit);
 779   cmp = _igvn.register_new_node_with_optimizer(cmp);
 780   set_ctrl(cmp, iff-&gt;in(0));
 781 
 782   test = test-&gt;clone()-&gt;as_Bool();
 783   (*(BoolTest*)&amp;test-&gt;_test)._test = bt;
 784   test-&gt;set_req(1,cmp);
 785   _igvn.register_new_node_with_optimizer(test);
 786   set_ctrl(test, iff-&gt;in(0));
 787 
 788   // Replace the old IfNode with a new LoopEndNode
 789   Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff-&gt;in(0), test, cl_prob, iff-&gt;as_If()-&gt;_fcnt ));
 790   IfNode *le = lex-&gt;as_If();
 791   uint dd = dom_depth(iff);
 792   set_idom(le, le-&gt;in(0), dd); // Update dominance for loop exit
 793   set_loop(le, loop);
 794 
 795   // Get the loop-exit control
 796   Node *iffalse = iff-&gt;as_If()-&gt;proj_out(!(iftrue_op == Op_IfTrue));
 797 
 798   // Need to swap loop-exit and loop-back control?
 799   if (iftrue_op == Op_IfFalse) {
 800     Node *ift2=_igvn.register_new_node_with_optimizer(new IfTrueNode (le));
 801     Node *iff2=_igvn.register_new_node_with_optimizer(new IfFalseNode(le));
 802 
 803     loop-&gt;_tail = back_control = ift2;
 804     set_loop(ift2, loop);
 805     set_loop(iff2, get_loop(iffalse));
 806 
 807     // Lazy update of &#39;get_ctrl&#39; mechanism.
 808     lazy_replace(iffalse, iff2);
 809     lazy_replace(iftrue,  ift2);
 810 
 811     // Swap names
 812     iffalse = iff2;
 813     iftrue  = ift2;
 814   } else {
 815     _igvn.rehash_node_delayed(iffalse);
 816     _igvn.rehash_node_delayed(iftrue);
 817     iffalse-&gt;set_req_X( 0, le, &amp;_igvn );
 818     iftrue -&gt;set_req_X( 0, le, &amp;_igvn );
 819   }
 820 
 821   set_idom(iftrue,  le, dd+1);
 822   set_idom(iffalse, le, dd+1);
 823   assert(iff-&gt;outcnt() == 0, &quot;should be dead now&quot;);
 824   lazy_replace( iff, le ); // fix &#39;get_ctrl&#39;
 825 
 826   Node *sfpt2 = le-&gt;in(0);
 827 
 828   Node* entry_control = init_control;
 829   bool strip_mine_loop = LoopStripMiningIter &gt; 1 &amp;&amp; loop-&gt;_child == NULL &amp;&amp;
 830     sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; !loop-&gt;_has_call;
 831   IdealLoopTree* outer_ilt = NULL;
 832   if (strip_mine_loop) {
 833     outer_ilt = create_outer_strip_mined_loop(test, cmp, init_control, loop,
 834                                               cl_prob, le-&gt;_fcnt, entry_control,
 835                                               iffalse);
 836   }
 837 
 838   // Now setup a new CountedLoopNode to replace the existing LoopNode
 839   CountedLoopNode *l = new CountedLoopNode(entry_control, back_control);
 840   l-&gt;set_unswitch_count(x-&gt;as_Loop()-&gt;unswitch_count()); // Preserve
 841   // The following assert is approximately true, and defines the intention
 842   // of can_be_counted_loop.  It fails, however, because phase-&gt;type
 843   // is not yet initialized for this loop and its parts.
 844   //assert(l-&gt;can_be_counted_loop(this), &quot;sanity&quot;);
 845   _igvn.register_new_node_with_optimizer(l);
 846   set_loop(l, loop);
 847   loop-&gt;_head = l;
 848   // Fix all data nodes placed at the old loop head.
 849   // Uses the lazy-update mechanism of &#39;get_ctrl&#39;.
 850   lazy_replace( x, l );
 851   set_idom(l, entry_control, dom_depth(entry_control) + 1);
 852 
 853   if (LoopStripMiningIter == 0 || strip_mine_loop) {
 854     // Check for immediately preceding SafePoint and remove
 855     if (sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {
 856       if (strip_mine_loop) {
 857         Node* outer_le = outer_ilt-&gt;_tail-&gt;in(0);
 858         Node* sfpt = sfpt2-&gt;clone();
 859         sfpt-&gt;set_req(0, iffalse);
 860         outer_le-&gt;set_req(0, sfpt);
 861         register_control(sfpt, outer_ilt, iffalse);
 862         set_idom(outer_le, sfpt, dom_depth(sfpt));
 863       }
 864       lazy_replace( sfpt2, sfpt2-&gt;in(TypeFunc::Control));
 865       if (loop-&gt;_safepts != NULL) {
 866         loop-&gt;_safepts-&gt;yank(sfpt2);
 867       }
 868     }
 869   }
 870 
 871   // Free up intermediate goo
 872   _igvn.remove_dead_node(hook);
 873 
 874 #ifdef ASSERT
 875   assert(l-&gt;is_valid_counted_loop(), &quot;counted loop shape is messed up&quot;);
 876   assert(l == loop-&gt;_head &amp;&amp; l-&gt;phi() == phi &amp;&amp; l-&gt;loopexit_or_null() == lex, &quot;&quot; );
 877 #endif
 878 #ifndef PRODUCT
 879   if (TraceLoopOpts) {
 880     tty-&gt;print(&quot;Counted      &quot;);
 881     loop-&gt;dump_head();
 882   }
 883 #endif
 884 
 885   C-&gt;print_method(PHASE_AFTER_CLOOPS, 3);
 886 
 887   // Capture bounds of the loop in the induction variable Phi before
 888   // subsequent transformation (iteration splitting) obscures the
 889   // bounds
 890   l-&gt;phi()-&gt;as_Phi()-&gt;set_type(l-&gt;phi()-&gt;Value(&amp;_igvn));
 891 
 892   if (strip_mine_loop) {
 893     l-&gt;mark_strip_mined();
 894     l-&gt;verify_strip_mined(1);
 895     outer_ilt-&gt;_head-&gt;as_Loop()-&gt;verify_strip_mined(1);
 896     loop = outer_ilt;
 897   }
 898 
 899   return true;
 900 }
 901 
 902 //----------------------exact_limit-------------------------------------------
 903 Node* PhaseIdealLoop::exact_limit( IdealLoopTree *loop ) {
 904   assert(loop-&gt;_head-&gt;is_CountedLoop(), &quot;&quot;);
 905   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
 906   assert(cl-&gt;is_valid_counted_loop(), &quot;&quot;);
 907 
 908   if (ABS(cl-&gt;stride_con()) == 1 ||
 909       cl-&gt;limit()-&gt;Opcode() == Op_LoopLimit) {
 910     // Old code has exact limit (it could be incorrect in case of int overflow).
 911     // Loop limit is exact with stride == 1. And loop may already have exact limit.
 912     return cl-&gt;limit();
 913   }
 914   Node *limit = NULL;
 915 #ifdef ASSERT
 916   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 917   assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
 918 #endif
 919   if (cl-&gt;has_exact_trip_count()) {
 920     // Simple case: loop has constant boundaries.
 921     // Use jlongs to avoid integer overflow.
 922     int stride_con = cl-&gt;stride_con();
 923     jlong  init_con = cl-&gt;init_trip()-&gt;get_int();
 924     jlong limit_con = cl-&gt;limit()-&gt;get_int();
 925     julong trip_cnt = cl-&gt;trip_count();
 926     jlong final_con = init_con + trip_cnt*stride_con;
 927     int final_int = (int)final_con;
 928     // The final value should be in integer range since the loop
 929     // is counted and the limit was checked for overflow.
 930     assert(final_con == (jlong)final_int, &quot;final value should be integer&quot;);
 931     limit = _igvn.intcon(final_int);
 932   } else {
 933     // Create new LoopLimit node to get exact limit (final iv value).
 934     limit = new LoopLimitNode(C, cl-&gt;init_trip(), cl-&gt;limit(), cl-&gt;stride());
 935     register_new_node(limit, cl-&gt;in(LoopNode::EntryControl));
 936   }
 937   assert(limit != NULL, &quot;sanity&quot;);
 938   return limit;
 939 }
 940 
 941 //------------------------------Ideal------------------------------------------
 942 // Return a node which is more &quot;ideal&quot; than the current node.
 943 // Attempt to convert into a counted-loop.
 944 Node *LoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 945   if (!can_be_counted_loop(phase) &amp;&amp; !is_OuterStripMinedLoop()) {
 946     phase-&gt;C-&gt;set_major_progress();
 947   }
 948   return RegionNode::Ideal(phase, can_reshape);
 949 }
 950 
<a name="4" id="anc4"></a><span class="line-removed"> 951 void LoopNode::verify_strip_mined(int expect_skeleton) const {</span>
 952 #ifdef ASSERT
<a name="5" id="anc5"></a>
 953   const OuterStripMinedLoopNode* outer = NULL;
 954   const CountedLoopNode* inner = NULL;
 955   if (is_strip_mined()) {
<a name="6" id="anc6"></a>


 956     assert(is_CountedLoop(), &quot;no Loop should be marked strip mined&quot;);
 957     inner = as_CountedLoop();
 958     outer = inner-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop();
 959   } else if (is_OuterStripMinedLoop()) {
 960     outer = this-&gt;as_OuterStripMinedLoop();
 961     inner = outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop();
<a name="7" id="anc7"></a>
 962     assert(!is_strip_mined(), &quot;outer loop shouldn&#39;t be marked strip mined&quot;);
 963   }
 964   if (inner != NULL || outer != NULL) {
 965     assert(inner != NULL &amp;&amp; outer != NULL, &quot;missing loop in strip mined nest&quot;);
 966     Node* outer_tail = outer-&gt;in(LoopNode::LoopBackControl);
 967     Node* outer_le = outer_tail-&gt;in(0);
 968     assert(outer_le-&gt;Opcode() == Op_OuterStripMinedLoopEnd, &quot;tail of outer loop should be an If&quot;);
 969     Node* sfpt = outer_le-&gt;in(0);
 970     assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;where&#39;s the safepoint?&quot;);
 971     Node* inner_out = sfpt-&gt;in(0);
 972     if (inner_out-&gt;outcnt() != 1) {
 973       ResourceMark rm;
 974       Unique_Node_List wq;
 975 
 976       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
 977         Node* u = inner_out-&gt;fast_out(i);
 978         if (u == sfpt) {
 979           continue;
 980         }
 981         wq.clear();
 982         wq.push(u);
 983         bool found_sfpt = false;
 984         for (uint next = 0; next &lt; wq.size() &amp;&amp; !found_sfpt; next++) {
<a name="8" id="anc8"></a><span class="line-modified"> 985           Node *n = wq.at(next);</span>
 986           for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !found_sfpt; i++) {
 987             Node* u = n-&gt;fast_out(i);
 988             if (u == sfpt) {
 989               found_sfpt = true;
 990             }
 991             if (!u-&gt;is_CFG()) {
 992               wq.push(u);
 993             }
 994           }
 995         }
 996         assert(found_sfpt, &quot;no node in loop that&#39;s not input to safepoint&quot;);
 997       }
 998     }
<a name="9" id="anc9"></a>
 999     CountedLoopEndNode* cle = inner_out-&gt;in(0)-&gt;as_CountedLoopEnd();
1000     assert(cle == inner-&gt;loopexit_or_null(), &quot;mismatch&quot;);
1001     bool has_skeleton = outer_le-&gt;in(1)-&gt;bottom_type()-&gt;singleton() &amp;&amp; outer_le-&gt;in(1)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0;
1002     if (has_skeleton) {
1003       assert(expect_skeleton == 1 || expect_skeleton == -1, &quot;unexpected skeleton node&quot;);
1004       assert(outer-&gt;outcnt() == 2, &quot;only phis&quot;);
1005     } else {
1006       assert(expect_skeleton == 0 || expect_skeleton == -1, &quot;no skeleton node?&quot;);
1007       uint phis = 0;
1008       for (DUIterator_Fast imax, i = inner-&gt;fast_outs(imax); i &lt; imax; i++) {
1009         Node* u = inner-&gt;fast_out(i);
1010         if (u-&gt;is_Phi()) {
1011           phis++;
1012         }
1013       }
1014       for (DUIterator_Fast imax, i = outer-&gt;fast_outs(imax); i &lt; imax; i++) {
1015         Node* u = outer-&gt;fast_out(i);
1016         assert(u == outer || u == inner || u-&gt;is_Phi(), &quot;nothing between inner and outer loop&quot;);
1017       }
1018       uint stores = 0;
1019       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1020         Node* u = inner_out-&gt;fast_out(i);
1021         if (u-&gt;is_Store()) {
1022           stores++;
1023         }
1024       }
1025       assert(outer-&gt;outcnt() &gt;= phis + 2 &amp;&amp; outer-&gt;outcnt() &lt;= phis + 2 + stores + 1, &quot;only phis&quot;);
1026     }
1027     assert(sfpt-&gt;outcnt() == 1, &quot;no data node&quot;);
1028     assert(outer_tail-&gt;outcnt() == 1 || !has_skeleton, &quot;no data node&quot;);
1029   }
<a name="10" id="anc10"></a><span class="line-removed">1030 #endif</span>
1031 }
<a name="11" id="anc11"></a>
1032 
1033 //=============================================================================
1034 //------------------------------Ideal------------------------------------------
1035 // Return a node which is more &quot;ideal&quot; than the current node.
1036 // Attempt to convert into a counted-loop.
1037 Node *CountedLoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1038   return RegionNode::Ideal(phase, can_reshape);
1039 }
1040 
1041 //------------------------------dump_spec--------------------------------------
1042 // Dump special per-node info
1043 #ifndef PRODUCT
1044 void CountedLoopNode::dump_spec(outputStream *st) const {
1045   LoopNode::dump_spec(st);
1046   if (stride_is_con()) {
1047     st-&gt;print(&quot;stride: %d &quot;,stride_con());
1048   }
1049   if (is_pre_loop ()) st-&gt;print(&quot;pre of N%d&quot; , _main_idx);
1050   if (is_main_loop()) st-&gt;print(&quot;main of N%d&quot;, _idx);
1051   if (is_post_loop()) st-&gt;print(&quot;post of N%d&quot;, _main_idx);
1052   if (is_strip_mined()) st-&gt;print(&quot; strip mined&quot;);
1053 }
1054 #endif
1055 
1056 //=============================================================================
1057 int CountedLoopEndNode::stride_con() const {
1058   return stride()-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1059 }
1060 
1061 //=============================================================================
1062 //------------------------------Value-----------------------------------------
1063 const Type* LoopLimitNode::Value(PhaseGVN* phase) const {
1064   const Type* init_t   = phase-&gt;type(in(Init));
1065   const Type* limit_t  = phase-&gt;type(in(Limit));
1066   const Type* stride_t = phase-&gt;type(in(Stride));
1067   // Either input is TOP ==&gt; the result is TOP
1068   if (init_t   == Type::TOP) return Type::TOP;
1069   if (limit_t  == Type::TOP) return Type::TOP;
1070   if (stride_t == Type::TOP) return Type::TOP;
1071 
1072   int stride_con = stride_t-&gt;is_int()-&gt;get_con();
1073   if (stride_con == 1)
1074     return NULL;  // Identity
1075 
1076   if (init_t-&gt;is_int()-&gt;is_con() &amp;&amp; limit_t-&gt;is_int()-&gt;is_con()) {
1077     // Use jlongs to avoid integer overflow.
1078     jlong init_con   =  init_t-&gt;is_int()-&gt;get_con();
1079     jlong limit_con  = limit_t-&gt;is_int()-&gt;get_con();
1080     int  stride_m   = stride_con - (stride_con &gt; 0 ? 1 : -1);
1081     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
1082     jlong final_con  = init_con + stride_con*trip_count;
1083     int final_int = (int)final_con;
1084     // The final value should be in integer range since the loop
1085     // is counted and the limit was checked for overflow.
1086     assert(final_con == (jlong)final_int, &quot;final value should be integer&quot;);
1087     return TypeInt::make(final_int);
1088   }
1089 
1090   return bottom_type(); // TypeInt::INT
1091 }
1092 
1093 //------------------------------Ideal------------------------------------------
1094 // Return a node which is more &quot;ideal&quot; than the current node.
1095 Node *LoopLimitNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1096   if (phase-&gt;type(in(Init))   == Type::TOP ||
1097       phase-&gt;type(in(Limit))  == Type::TOP ||
1098       phase-&gt;type(in(Stride)) == Type::TOP)
1099     return NULL;  // Dead
1100 
1101   int stride_con = phase-&gt;type(in(Stride))-&gt;is_int()-&gt;get_con();
1102   if (stride_con == 1)
1103     return NULL;  // Identity
1104 
1105   if (in(Init)-&gt;is_Con() &amp;&amp; in(Limit)-&gt;is_Con())
1106     return NULL;  // Value
1107 
1108   // Delay following optimizations until all loop optimizations
1109   // done to keep Ideal graph simple.
1110   if (!can_reshape || phase-&gt;C-&gt;major_progress())
1111     return NULL;
1112 
1113   const TypeInt* init_t  = phase-&gt;type(in(Init) )-&gt;is_int();
1114   const TypeInt* limit_t = phase-&gt;type(in(Limit))-&gt;is_int();
1115   int stride_p;
1116   jlong lim, ini;
1117   julong max;
1118   if (stride_con &gt; 0) {
1119     stride_p = stride_con;
1120     lim = limit_t-&gt;_hi;
1121     ini = init_t-&gt;_lo;
1122     max = (julong)max_jint;
1123   } else {
1124     stride_p = -stride_con;
1125     lim = init_t-&gt;_hi;
1126     ini = limit_t-&gt;_lo;
1127     max = (julong)min_jint;
1128   }
1129   julong range = lim - ini + stride_p;
1130   if (range &lt;= max) {
1131     // Convert to integer expression if it is not overflow.
1132     Node* stride_m = phase-&gt;intcon(stride_con - (stride_con &gt; 0 ? 1 : -1));
1133     Node *range = phase-&gt;transform(new SubINode(in(Limit), in(Init)));
1134     Node *bias  = phase-&gt;transform(new AddINode(range, stride_m));
1135     Node *trip  = phase-&gt;transform(new DivINode(0, bias, in(Stride)));
1136     Node *span  = phase-&gt;transform(new MulINode(trip, in(Stride)));
1137     return new AddINode(span, in(Init)); // exact limit
1138   }
1139 
1140   if (is_power_of_2(stride_p) ||                // divisor is 2^n
1141       !Matcher::has_match_rule(Op_LoopLimit)) { // or no specialized Mach node?
1142     // Convert to long expression to avoid integer overflow
1143     // and let igvn optimizer convert this division.
1144     //
1145     Node*   init   = phase-&gt;transform( new ConvI2LNode(in(Init)));
1146     Node*  limit   = phase-&gt;transform( new ConvI2LNode(in(Limit)));
1147     Node* stride   = phase-&gt;longcon(stride_con);
1148     Node* stride_m = phase-&gt;longcon(stride_con - (stride_con &gt; 0 ? 1 : -1));
1149 
1150     Node *range = phase-&gt;transform(new SubLNode(limit, init));
1151     Node *bias  = phase-&gt;transform(new AddLNode(range, stride_m));
1152     Node *span;
1153     if (stride_con &gt; 0 &amp;&amp; is_power_of_2(stride_p)) {
1154       // bias &gt;= 0 if stride &gt;0, so if stride is 2^n we can use &amp;(-stride)
1155       // and avoid generating rounding for division. Zero trip guard should
1156       // guarantee that init &lt; limit but sometimes the guard is missing and
1157       // we can get situation when init &gt; limit. Note, for the empty loop
1158       // optimization zero trip guard is generated explicitly which leaves
1159       // only RCE predicate where exact limit is used and the predicate
1160       // will simply fail forcing recompilation.
1161       Node* neg_stride   = phase-&gt;longcon(-stride_con);
1162       span = phase-&gt;transform(new AndLNode(bias, neg_stride));
1163     } else {
1164       Node *trip  = phase-&gt;transform(new DivLNode(0, bias, stride));
1165       span = phase-&gt;transform(new MulLNode(trip, stride));
1166     }
1167     // Convert back to int
1168     Node *span_int = phase-&gt;transform(new ConvL2INode(span));
1169     return new AddINode(span_int, in(Init)); // exact limit
1170   }
1171 
1172   return NULL;    // No progress
1173 }
1174 
1175 //------------------------------Identity---------------------------------------
1176 // If stride == 1 return limit node.
1177 Node* LoopLimitNode::Identity(PhaseGVN* phase) {
1178   int stride_con = phase-&gt;type(in(Stride))-&gt;is_int()-&gt;get_con();
1179   if (stride_con == 1 || stride_con == -1)
1180     return in(Limit);
1181   return this;
1182 }
1183 
1184 //=============================================================================
1185 //----------------------match_incr_with_optional_truncation--------------------
1186 // Match increment with optional truncation:
1187 // CHAR: (i+1)&amp;0x7fff, BYTE: ((i+1)&lt;&lt;8)&gt;&gt;8, or SHORT: ((i+1)&lt;&lt;16)&gt;&gt;16
1188 // Return NULL for failure. Success returns the increment node.
1189 Node* CountedLoopNode::match_incr_with_optional_truncation(
1190                       Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type) {
1191   // Quick cutouts:
1192   if (expr == NULL || expr-&gt;req() != 3)  return NULL;
1193 
1194   Node *t1 = NULL;
1195   Node *t2 = NULL;
1196   const TypeInt* trunc_t = TypeInt::INT;
1197   Node* n1 = expr;
1198   int   n1op = n1-&gt;Opcode();
1199 
1200   // Try to strip (n1 &amp; M) or (n1 &lt;&lt; N &gt;&gt; N) from n1.
1201   if (n1op == Op_AndI &amp;&amp;
1202       n1-&gt;in(2)-&gt;is_Con() &amp;&amp;
1203       n1-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0x7fff) {
1204     // %%% This check should match any mask of 2**K-1.
1205     t1 = n1;
1206     n1 = t1-&gt;in(1);
1207     n1op = n1-&gt;Opcode();
1208     trunc_t = TypeInt::CHAR;
1209   } else if (n1op == Op_RShiftI &amp;&amp;
1210              n1-&gt;in(1) != NULL &amp;&amp;
1211              n1-&gt;in(1)-&gt;Opcode() == Op_LShiftI &amp;&amp;
1212              n1-&gt;in(2) == n1-&gt;in(1)-&gt;in(2) &amp;&amp;
1213              n1-&gt;in(2)-&gt;is_Con()) {
1214     jint shift = n1-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1215     // %%% This check should match any shift in [1..31].
1216     if (shift == 16 || shift == 8) {
1217       t1 = n1;
1218       t2 = t1-&gt;in(1);
1219       n1 = t2-&gt;in(1);
1220       n1op = n1-&gt;Opcode();
1221       if (shift == 16) {
1222         trunc_t = TypeInt::SHORT;
1223       } else if (shift == 8) {
1224         trunc_t = TypeInt::BYTE;
1225       }
1226     }
1227   }
1228 
1229   // If (maybe after stripping) it is an AddI, we won:
1230   if (n1op == Op_AddI) {
1231     *trunc1 = t1;
1232     *trunc2 = t2;
1233     *trunc_type = trunc_t;
1234     return n1;
1235   }
1236 
1237   // failed
1238   return NULL;
1239 }
1240 
1241 LoopNode* CountedLoopNode::skip_strip_mined(int expect_skeleton) {
<a name="12" id="anc12"></a><span class="line-modified">1242   if (is_strip_mined()) {</span>
1243     verify_strip_mined(expect_skeleton);
1244     return in(EntryControl)-&gt;as_Loop();
1245   }
1246   return this;
1247 }
1248 
1249 OuterStripMinedLoopNode* CountedLoopNode::outer_loop() const {
1250   assert(is_strip_mined(), &quot;not a strip mined loop&quot;);
1251   Node* c = in(EntryControl);
1252   if (c == NULL || c-&gt;is_top() || !c-&gt;is_OuterStripMinedLoop()) {
1253     return NULL;
1254   }
1255   return c-&gt;as_OuterStripMinedLoop();
1256 }
1257 
1258 IfTrueNode* OuterStripMinedLoopNode::outer_loop_tail() const {
1259   Node* c = in(LoopBackControl);
1260   if (c == NULL || c-&gt;is_top()) {
1261     return NULL;
1262   }
1263   return c-&gt;as_IfTrue();
1264 }
1265 
1266 IfTrueNode* CountedLoopNode::outer_loop_tail() const {
1267   LoopNode* l = outer_loop();
1268   if (l == NULL) {
1269     return NULL;
1270   }
1271   return l-&gt;outer_loop_tail();
1272 }
1273 
1274 OuterStripMinedLoopEndNode* OuterStripMinedLoopNode::outer_loop_end() const {
1275   IfTrueNode* proj = outer_loop_tail();
1276   if (proj == NULL) {
1277     return NULL;
1278   }
1279   Node* c = proj-&gt;in(0);
1280   if (c == NULL || c-&gt;is_top() || c-&gt;outcnt() != 2) {
1281     return NULL;
1282   }
1283   return c-&gt;as_OuterStripMinedLoopEnd();
1284 }
1285 
1286 OuterStripMinedLoopEndNode* CountedLoopNode::outer_loop_end() const {
1287   LoopNode* l = outer_loop();
1288   if (l == NULL) {
1289     return NULL;
1290   }
1291   return l-&gt;outer_loop_end();
1292 }
1293 
1294 IfFalseNode* OuterStripMinedLoopNode::outer_loop_exit() const {
1295   IfNode* le = outer_loop_end();
1296   if (le == NULL) {
1297     return NULL;
1298   }
1299   Node* c = le-&gt;proj_out_or_null(false);
1300   if (c == NULL) {
1301     return NULL;
1302   }
1303   return c-&gt;as_IfFalse();
1304 }
1305 
1306 IfFalseNode* CountedLoopNode::outer_loop_exit() const {
1307   LoopNode* l = outer_loop();
1308   if (l == NULL) {
1309     return NULL;
1310   }
1311   return l-&gt;outer_loop_exit();
1312 }
1313 
1314 SafePointNode* OuterStripMinedLoopNode::outer_safepoint() const {
1315   IfNode* le = outer_loop_end();
1316   if (le == NULL) {
1317     return NULL;
1318   }
1319   Node* c = le-&gt;in(0);
1320   if (c == NULL || c-&gt;is_top()) {
1321     return NULL;
1322   }
1323   assert(c-&gt;Opcode() == Op_SafePoint, &quot;broken outer loop&quot;);
1324   return c-&gt;as_SafePoint();
1325 }
1326 
1327 SafePointNode* CountedLoopNode::outer_safepoint() const {
1328   LoopNode* l = outer_loop();
1329   if (l == NULL) {
1330     return NULL;
1331   }
1332   return l-&gt;outer_safepoint();
1333 }
1334 
1335 Node* CountedLoopNode::skip_predicates_from_entry(Node* ctrl) {
1336     while (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_If() &amp;&amp;
1337            ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(1-ctrl-&gt;as_Proj()-&gt;_con)-&gt;outcnt() == 1 &amp;&amp;
1338            ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(1-ctrl-&gt;as_Proj()-&gt;_con)-&gt;unique_out()-&gt;Opcode() == Op_Halt) {
1339       ctrl = ctrl-&gt;in(0)-&gt;in(0);
1340     }
1341 
1342     return ctrl;
1343   }
1344 
1345 Node* CountedLoopNode::skip_predicates() {
1346   if (is_main_loop()) {
1347     Node* ctrl = skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1348 
1349     return skip_predicates_from_entry(ctrl);
1350   }
1351   return in(LoopNode::EntryControl);
1352 }
1353 
1354 void OuterStripMinedLoopNode::adjust_strip_mined_loop(PhaseIterGVN* igvn) {
1355   // Look for the outer &amp; inner strip mined loop, reduce number of
1356   // iterations of the inner loop, set exit condition of outer loop,
1357   // construct required phi nodes for outer loop.
1358   CountedLoopNode* inner_cl = unique_ctrl_out()-&gt;as_CountedLoop();
1359   assert(inner_cl-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
1360   Node* inner_iv_phi = inner_cl-&gt;phi();
1361   if (inner_iv_phi == NULL) {
1362     IfNode* outer_le = outer_loop_end();
1363     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1364     igvn-&gt;replace_node(outer_le, iff);
1365     inner_cl-&gt;clear_strip_mined();
1366     return;
1367   }
1368   CountedLoopEndNode* inner_cle = inner_cl-&gt;loopexit();
1369 
1370   int stride = inner_cl-&gt;stride_con();
1371   jlong scaled_iters_long = ((jlong)LoopStripMiningIter) * ABS(stride);
1372   int scaled_iters = (int)scaled_iters_long;
1373   int short_scaled_iters = LoopStripMiningIterShortLoop* ABS(stride);
1374   const TypeInt* inner_iv_t = igvn-&gt;type(inner_iv_phi)-&gt;is_int();
1375   jlong iter_estimate = (jlong)inner_iv_t-&gt;_hi - (jlong)inner_iv_t-&gt;_lo;
1376   assert(iter_estimate &gt; 0, &quot;broken&quot;);
1377   if ((jlong)scaled_iters != scaled_iters_long || iter_estimate &lt;= short_scaled_iters) {
1378     // Remove outer loop and safepoint (too few iterations)
1379     Node* outer_sfpt = outer_safepoint();
1380     Node* outer_out = outer_loop_exit();
1381     igvn-&gt;replace_node(outer_out, outer_sfpt-&gt;in(0));
1382     igvn-&gt;replace_input_of(outer_sfpt, 0, igvn-&gt;C-&gt;top());
1383     inner_cl-&gt;clear_strip_mined();
1384     return;
1385   }
1386   if (iter_estimate &lt;= scaled_iters_long) {
1387     // We would only go through one iteration of
1388     // the outer loop: drop the outer loop but
1389     // keep the safepoint so we don&#39;t run for
1390     // too long without a safepoint
1391     IfNode* outer_le = outer_loop_end();
1392     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1393     igvn-&gt;replace_node(outer_le, iff);
1394     inner_cl-&gt;clear_strip_mined();
1395     return;
1396   }
1397 
1398   Node* cle_tail = inner_cle-&gt;proj_out(true);
1399   ResourceMark rm;
1400   Node_List old_new;
1401   if (cle_tail-&gt;outcnt() &gt; 1) {
1402     // Look for nodes on backedge of inner loop and clone them
1403     Unique_Node_List backedge_nodes;
1404     for (DUIterator_Fast imax, i = cle_tail-&gt;fast_outs(imax); i &lt; imax; i++) {
1405       Node* u = cle_tail-&gt;fast_out(i);
1406       if (u != inner_cl) {
1407         assert(!u-&gt;is_CFG(), &quot;control flow on the backedge?&quot;);
1408         backedge_nodes.push(u);
1409       }
1410     }
1411     uint last = igvn-&gt;C-&gt;unique();
1412     for (uint next = 0; next &lt; backedge_nodes.size(); next++) {
1413       Node* n = backedge_nodes.at(next);
1414       old_new.map(n-&gt;_idx, n-&gt;clone());
1415       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1416         Node* u = n-&gt;fast_out(i);
1417         assert(!u-&gt;is_CFG(), &quot;broken&quot;);
1418         if (u-&gt;_idx &gt;= last) {
1419           continue;
1420         }
1421         if (!u-&gt;is_Phi()) {
1422           backedge_nodes.push(u);
1423         } else {
1424           assert(u-&gt;in(0) == inner_cl, &quot;strange phi on the backedge&quot;);
1425         }
1426       }
1427     }
1428     // Put the clones on the outer loop backedge
1429     Node* le_tail = outer_loop_tail();
1430     for (uint next = 0; next &lt; backedge_nodes.size(); next++) {
1431       Node *n = old_new[backedge_nodes.at(next)-&gt;_idx];
1432       for (uint i = 1; i &lt; n-&gt;req(); i++) {
1433         if (n-&gt;in(i) != NULL &amp;&amp; old_new[n-&gt;in(i)-&gt;_idx] != NULL) {
1434           n-&gt;set_req(i, old_new[n-&gt;in(i)-&gt;_idx]);
1435         }
1436       }
1437       if (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0) == cle_tail) {
1438         n-&gt;set_req(0, le_tail);
1439       }
1440       igvn-&gt;register_new_node_with_optimizer(n);
1441     }
1442   }
1443 
1444   Node* iv_phi = NULL;
1445   // Make a clone of each phi in the inner loop
1446   // for the outer loop
1447   for (uint i = 0; i &lt; inner_cl-&gt;outcnt(); i++) {
1448     Node* u = inner_cl-&gt;raw_out(i);
1449     if (u-&gt;is_Phi()) {
1450       assert(u-&gt;in(0) == inner_cl, &quot;inconsistent&quot;);
1451       Node* phi = u-&gt;clone();
1452       phi-&gt;set_req(0, this);
1453       Node* be = old_new[phi-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
1454       if (be != NULL) {
1455         phi-&gt;set_req(LoopNode::LoopBackControl, be);
1456       }
1457       phi = igvn-&gt;transform(phi);
1458       igvn-&gt;replace_input_of(u, LoopNode::EntryControl, phi);
1459       if (u == inner_iv_phi) {
1460         iv_phi = phi;
1461       }
1462     }
1463   }
1464   Node* cle_out = inner_cle-&gt;proj_out(false);
1465   if (cle_out-&gt;outcnt() &gt; 1) {
1466     // Look for chains of stores that were sunk
1467     // out of the inner loop and are in the outer loop
1468     for (DUIterator_Fast imax, i = cle_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1469       Node* u = cle_out-&gt;fast_out(i);
1470       if (u-&gt;is_Store()) {
1471         Node* first = u;
1472         for(;;) {
1473           Node* next = first-&gt;in(MemNode::Memory);
1474           if (!next-&gt;is_Store() || next-&gt;in(0) != cle_out) {
1475             break;
1476           }
1477           first = next;
1478         }
1479         Node* last = u;
1480         for(;;) {
1481           Node* next = NULL;
1482           for (DUIterator_Fast jmax, j = last-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1483             Node* uu = last-&gt;fast_out(j);
1484             if (uu-&gt;is_Store() &amp;&amp; uu-&gt;in(0) == cle_out) {
1485               assert(next == NULL, &quot;only one in the outer loop&quot;);
1486               next = uu;
1487             }
1488           }
1489           if (next == NULL) {
1490             break;
1491           }
1492           last = next;
1493         }
1494         Node* phi = NULL;
1495         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
1496           Node* uu = fast_out(j);
1497           if (uu-&gt;is_Phi()) {
1498             Node* be = uu-&gt;in(LoopNode::LoopBackControl);
1499             if (be-&gt;is_Store() &amp;&amp; old_new[be-&gt;_idx] != NULL) {
1500               assert(false, &quot;store on the backedge + sunk stores: unsupported&quot;);
1501               // drop outer loop
1502               IfNode* outer_le = outer_loop_end();
1503               Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1504               igvn-&gt;replace_node(outer_le, iff);
1505               inner_cl-&gt;clear_strip_mined();
1506               return;
1507             }
1508             if (be == last || be == first-&gt;in(MemNode::Memory)) {
1509               assert(phi == NULL, &quot;only one phi&quot;);
1510               phi = uu;
1511             }
1512           }
1513         }
1514 #ifdef ASSERT
1515         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
1516           Node* uu = fast_out(j);
1517           if (uu-&gt;is_Phi() &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY) {
1518             if (uu-&gt;adr_type() == igvn-&gt;C-&gt;get_adr_type(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type()))) {
1519               assert(phi == uu, &quot;what&#39;s that phi?&quot;);
1520             } else if (uu-&gt;adr_type() == TypePtr::BOTTOM) {
1521               Node* n = uu-&gt;in(LoopNode::LoopBackControl);
1522               uint limit = igvn-&gt;C-&gt;live_nodes();
1523               uint i = 0;
1524               while (n != uu) {
1525                 i++;
1526                 assert(i &lt; limit, &quot;infinite loop&quot;);
1527                 if (n-&gt;is_Proj()) {
1528                   n = n-&gt;in(0);
1529                 } else if (n-&gt;is_SafePoint() || n-&gt;is_MemBar()) {
1530                   n = n-&gt;in(TypeFunc::Memory);
1531                 } else if (n-&gt;is_Phi()) {
1532                   n = n-&gt;in(1);
1533                 } else if (n-&gt;is_MergeMem()) {
1534                   n = n-&gt;as_MergeMem()-&gt;memory_at(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type()));
1535                 } else if (n-&gt;is_Store() || n-&gt;is_LoadStore() || n-&gt;is_ClearArray()) {
1536                   n = n-&gt;in(MemNode::Memory);
1537                 } else {
1538                   n-&gt;dump();
1539                   ShouldNotReachHere();
1540                 }
1541               }
1542             }
1543           }
1544         }
1545 #endif
1546         if (phi == NULL) {
1547           // If the an entire chains was sunk, the
1548           // inner loop has no phi for that memory
1549           // slice, create one for the outer loop
1550           phi = PhiNode::make(this, first-&gt;in(MemNode::Memory), Type::MEMORY,
1551                               igvn-&gt;C-&gt;get_adr_type(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type())));
1552           phi-&gt;set_req(LoopNode::LoopBackControl, last);
1553           phi = igvn-&gt;transform(phi);
1554           igvn-&gt;replace_input_of(first, MemNode::Memory, phi);
1555         } else {
1556           // Or fix the outer loop fix to include
1557           // that chain of stores.
1558           Node* be = phi-&gt;in(LoopNode::LoopBackControl);
1559           assert(!(be-&gt;is_Store() &amp;&amp; old_new[be-&gt;_idx] != NULL), &quot;store on the backedge + sunk stores: unsupported&quot;);
1560           if (be == first-&gt;in(MemNode::Memory)) {
1561             if (be == phi-&gt;in(LoopNode::LoopBackControl)) {
1562               igvn-&gt;replace_input_of(phi, LoopNode::LoopBackControl, last);
1563             } else {
1564               igvn-&gt;replace_input_of(be, MemNode::Memory, last);
1565             }
1566           } else {
1567 #ifdef ASSERT
1568             if (be == phi-&gt;in(LoopNode::LoopBackControl)) {
1569               assert(phi-&gt;in(LoopNode::LoopBackControl) == last, &quot;&quot;);
1570             } else {
1571               assert(be-&gt;in(MemNode::Memory) == last, &quot;&quot;);
1572             }
1573 #endif
1574           }
1575         }
1576       }
1577     }
1578   }
1579 
1580   if (iv_phi != NULL) {
1581     // Now adjust the inner loop&#39;s exit condition
1582     Node* limit = inner_cl-&gt;limit();
1583     Node* sub = NULL;
1584     if (stride &gt; 0) {
1585       sub = igvn-&gt;transform(new SubINode(limit, iv_phi));
1586     } else {
1587       sub = igvn-&gt;transform(new SubINode(iv_phi, limit));
1588     }
1589     Node* min = igvn-&gt;transform(new MinINode(sub, igvn-&gt;intcon(scaled_iters)));
1590     Node* new_limit = NULL;
1591     if (stride &gt; 0) {
1592       new_limit = igvn-&gt;transform(new AddINode(min, iv_phi));
1593     } else {
1594       new_limit = igvn-&gt;transform(new SubINode(iv_phi, min));
1595     }
1596     Node* inner_cmp = inner_cle-&gt;cmp_node();
1597     Node* inner_bol = inner_cle-&gt;in(CountedLoopEndNode::TestValue);
1598     Node* outer_bol = inner_bol;
1599     // cmp node for inner loop may be shared
1600     inner_cmp = inner_cmp-&gt;clone();
1601     inner_cmp-&gt;set_req(2, new_limit);
1602     inner_bol = inner_bol-&gt;clone();
1603     inner_bol-&gt;set_req(1, igvn-&gt;transform(inner_cmp));
1604     igvn-&gt;replace_input_of(inner_cle, CountedLoopEndNode::TestValue, igvn-&gt;transform(inner_bol));
1605     // Set the outer loop&#39;s exit condition too
1606     igvn-&gt;replace_input_of(outer_loop_end(), 1, outer_bol);
1607   } else {
1608     assert(false, &quot;should be able to adjust outer loop&quot;);
1609     IfNode* outer_le = outer_loop_end();
1610     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1611     igvn-&gt;replace_node(outer_le, iff);
1612     inner_cl-&gt;clear_strip_mined();
1613   }
1614 }
1615 
1616 const Type* OuterStripMinedLoopEndNode::Value(PhaseGVN* phase) const {
1617   if (!in(0)) return Type::TOP;
1618   if (phase-&gt;type(in(0)) == Type::TOP)
1619     return Type::TOP;
1620 
1621   return TypeTuple::IFBOTH;
1622 }
1623 
1624 Node *OuterStripMinedLoopEndNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1625   if (remove_dead_region(phase, can_reshape))  return this;
1626 
1627   return NULL;
1628 }
1629 
1630 //------------------------------filtered_type--------------------------------
1631 // Return a type based on condition control flow
1632 // A successful return will be a type that is restricted due
1633 // to a series of dominating if-tests, such as:
1634 //    if (i &lt; 10) {
1635 //       if (i &gt; 0) {
1636 //          here: &quot;i&quot; type is [1..10)
1637 //       }
1638 //    }
1639 // or a control flow merge
1640 //    if (i &lt; 10) {
1641 //       do {
1642 //          phi( , ) -- at top of loop type is [min_int..10)
1643 //         i = ?
1644 //       } while ( i &lt; 10)
1645 //
1646 const TypeInt* PhaseIdealLoop::filtered_type( Node *n, Node* n_ctrl) {
1647   assert(n &amp;&amp; n-&gt;bottom_type()-&gt;is_int(), &quot;must be int&quot;);
1648   const TypeInt* filtered_t = NULL;
1649   if (!n-&gt;is_Phi()) {
1650     assert(n_ctrl != NULL || n_ctrl == C-&gt;top(), &quot;valid control&quot;);
1651     filtered_t = filtered_type_from_dominators(n, n_ctrl);
1652 
1653   } else {
1654     Node* phi    = n-&gt;as_Phi();
1655     Node* region = phi-&gt;in(0);
1656     assert(n_ctrl == NULL || n_ctrl == region, &quot;ctrl parameter must be region&quot;);
1657     if (region &amp;&amp; region != C-&gt;top()) {
1658       for (uint i = 1; i &lt; phi-&gt;req(); i++) {
1659         Node* val   = phi-&gt;in(i);
1660         Node* use_c = region-&gt;in(i);
1661         const TypeInt* val_t = filtered_type_from_dominators(val, use_c);
1662         if (val_t != NULL) {
1663           if (filtered_t == NULL) {
1664             filtered_t = val_t;
1665           } else {
1666             filtered_t = filtered_t-&gt;meet(val_t)-&gt;is_int();
1667           }
1668         }
1669       }
1670     }
1671   }
1672   const TypeInt* n_t = _igvn.type(n)-&gt;is_int();
1673   if (filtered_t != NULL) {
1674     n_t = n_t-&gt;join(filtered_t)-&gt;is_int();
1675   }
1676   return n_t;
1677 }
1678 
1679 
1680 //------------------------------filtered_type_from_dominators--------------------------------
1681 // Return a possibly more restrictive type for val based on condition control flow of dominators
1682 const TypeInt* PhaseIdealLoop::filtered_type_from_dominators( Node* val, Node *use_ctrl) {
1683   if (val-&gt;is_Con()) {
1684      return val-&gt;bottom_type()-&gt;is_int();
1685   }
1686   uint if_limit = 10; // Max number of dominating if&#39;s visited
1687   const TypeInt* rtn_t = NULL;
1688 
1689   if (use_ctrl &amp;&amp; use_ctrl != C-&gt;top()) {
1690     Node* val_ctrl = get_ctrl(val);
1691     uint val_dom_depth = dom_depth(val_ctrl);
1692     Node* pred = use_ctrl;
1693     uint if_cnt = 0;
1694     while (if_cnt &lt; if_limit) {
1695       if ((pred-&gt;Opcode() == Op_IfTrue || pred-&gt;Opcode() == Op_IfFalse)) {
1696         if_cnt++;
1697         const TypeInt* if_t = IfNode::filtered_int_type(&amp;_igvn, val, pred);
1698         if (if_t != NULL) {
1699           if (rtn_t == NULL) {
1700             rtn_t = if_t;
1701           } else {
1702             rtn_t = rtn_t-&gt;join(if_t)-&gt;is_int();
1703           }
1704         }
1705       }
1706       pred = idom(pred);
1707       if (pred == NULL || pred == C-&gt;top()) {
1708         break;
1709       }
1710       // Stop if going beyond definition block of val
1711       if (dom_depth(pred) &lt; val_dom_depth) {
1712         break;
1713       }
1714     }
1715   }
1716   return rtn_t;
1717 }
1718 
1719 
1720 //------------------------------dump_spec--------------------------------------
1721 // Dump special per-node info
1722 #ifndef PRODUCT
1723 void CountedLoopEndNode::dump_spec(outputStream *st) const {
1724   if( in(TestValue) != NULL &amp;&amp; in(TestValue)-&gt;is_Bool() ) {
1725     BoolTest bt( test_trip()); // Added this for g++.
1726 
1727     st-&gt;print(&quot;[&quot;);
1728     bt.dump_on(st);
1729     st-&gt;print(&quot;]&quot;);
1730   }
1731   st-&gt;print(&quot; &quot;);
1732   IfNode::dump_spec(st);
1733 }
1734 #endif
1735 
1736 //=============================================================================
1737 //------------------------------is_member--------------------------------------
1738 // Is &#39;l&#39; a member of &#39;this&#39;?
1739 bool IdealLoopTree::is_member(const IdealLoopTree *l) const {
1740   while( l-&gt;_nest &gt; _nest ) l = l-&gt;_parent;
1741   return l == this;
1742 }
1743 
1744 //------------------------------set_nest---------------------------------------
1745 // Set loop tree nesting depth.  Accumulate _has_call bits.
1746 int IdealLoopTree::set_nest( uint depth ) {
1747   _nest = depth;
1748   int bits = _has_call;
1749   if( _child ) bits |= _child-&gt;set_nest(depth+1);
1750   if( bits ) _has_call = 1;
1751   if( _next  ) bits |= _next -&gt;set_nest(depth  );
1752   return bits;
1753 }
1754 
1755 //------------------------------split_fall_in----------------------------------
1756 // Split out multiple fall-in edges from the loop header.  Move them to a
1757 // private RegionNode before the loop.  This becomes the loop landing pad.
1758 void IdealLoopTree::split_fall_in( PhaseIdealLoop *phase, int fall_in_cnt ) {
1759   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1760   uint i;
1761 
1762   // Make a new RegionNode to be the landing pad.
1763   Node *landing_pad = new RegionNode( fall_in_cnt+1 );
1764   phase-&gt;set_loop(landing_pad,_parent);
1765   // Gather all the fall-in control paths into the landing pad
1766   uint icnt = fall_in_cnt;
1767   uint oreq = _head-&gt;req();
1768   for( i = oreq-1; i&gt;0; i-- )
1769     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) )
1770       landing_pad-&gt;set_req(icnt--,_head-&gt;in(i));
1771 
1772   // Peel off PhiNode edges as well
1773   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1774     Node *oj = _head-&gt;fast_out(j);
1775     if( oj-&gt;is_Phi() ) {
1776       PhiNode* old_phi = oj-&gt;as_Phi();
1777       assert( old_phi-&gt;region() == _head, &quot;&quot; );
1778       igvn.hash_delete(old_phi);   // Yank from hash before hacking edges
1779       Node *p = PhiNode::make_blank(landing_pad, old_phi);
1780       uint icnt = fall_in_cnt;
1781       for( i = oreq-1; i&gt;0; i-- ) {
1782         if( !phase-&gt;is_member( this, _head-&gt;in(i) ) ) {
1783           p-&gt;init_req(icnt--, old_phi-&gt;in(i));
1784           // Go ahead and clean out old edges from old phi
1785           old_phi-&gt;del_req(i);
1786         }
1787       }
1788       // Search for CSE&#39;s here, because ZKM.jar does a lot of
1789       // loop hackery and we need to be a little incremental
1790       // with the CSE to avoid O(N^2) node blow-up.
1791       Node *p2 = igvn.hash_find_insert(p); // Look for a CSE
1792       if( p2 ) {                // Found CSE
1793         p-&gt;destruct();          // Recover useless new node
1794         p = p2;                 // Use old node
1795       } else {
1796         igvn.register_new_node_with_optimizer(p, old_phi);
1797       }
1798       // Make old Phi refer to new Phi.
1799       old_phi-&gt;add_req(p);
1800       // Check for the special case of making the old phi useless and
1801       // disappear it.  In JavaGrande I have a case where this useless
1802       // Phi is the loop limit and prevents recognizing a CountedLoop
1803       // which in turn prevents removing an empty loop.
<a name="13" id="anc13"></a><span class="line-modified">1804       Node *id_old_phi = igvn.apply_identity(old_phi);</span>
1805       if( id_old_phi != old_phi ) { // Found a simple identity?
1806         // Note that I cannot call &#39;replace_node&#39; here, because
1807         // that will yank the edge from old_phi to the Region and
1808         // I&#39;m mid-iteration over the Region&#39;s uses.
1809         for (DUIterator_Last imin, i = old_phi-&gt;last_outs(imin); i &gt;= imin; ) {
1810           Node* use = old_phi-&gt;last_out(i);
1811           igvn.rehash_node_delayed(use);
1812           uint uses_found = 0;
1813           for (uint j = 0; j &lt; use-&gt;len(); j++) {
1814             if (use-&gt;in(j) == old_phi) {
1815               if (j &lt; use-&gt;req()) use-&gt;set_req (j, id_old_phi);
1816               else                use-&gt;set_prec(j, id_old_phi);
1817               uses_found++;
1818             }
1819           }
1820           i -= uses_found;    // we deleted 1 or more copies of this edge
1821         }
1822       }
1823       igvn._worklist.push(old_phi);
1824     }
1825   }
1826   // Finally clean out the fall-in edges from the RegionNode
1827   for( i = oreq-1; i&gt;0; i-- ) {
1828     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) ) {
1829       _head-&gt;del_req(i);
1830     }
1831   }
1832   igvn.rehash_node_delayed(_head);
1833   // Transform landing pad
1834   igvn.register_new_node_with_optimizer(landing_pad, _head);
1835   // Insert landing pad into the header
1836   _head-&gt;add_req(landing_pad);
1837 }
1838 
1839 //------------------------------split_outer_loop-------------------------------
1840 // Split out the outermost loop from this shared header.
1841 void IdealLoopTree::split_outer_loop( PhaseIdealLoop *phase ) {
1842   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1843 
1844   // Find index of outermost loop; it should also be my tail.
1845   uint outer_idx = 1;
1846   while( _head-&gt;in(outer_idx) != _tail ) outer_idx++;
1847 
1848   // Make a LoopNode for the outermost loop.
1849   Node *ctl = _head-&gt;in(LoopNode::EntryControl);
1850   Node *outer = new LoopNode( ctl, _head-&gt;in(outer_idx) );
1851   outer = igvn.register_new_node_with_optimizer(outer, _head);
1852   phase-&gt;set_created_loop_node();
1853 
1854   // Outermost loop falls into &#39;_head&#39; loop
1855   _head-&gt;set_req(LoopNode::EntryControl, outer);
1856   _head-&gt;del_req(outer_idx);
1857   // Split all the Phis up between &#39;_head&#39; loop and &#39;outer&#39; loop.
1858   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1859     Node *out = _head-&gt;fast_out(j);
1860     if( out-&gt;is_Phi() ) {
1861       PhiNode *old_phi = out-&gt;as_Phi();
1862       assert( old_phi-&gt;region() == _head, &quot;&quot; );
1863       Node *phi = PhiNode::make_blank(outer, old_phi);
1864       phi-&gt;init_req(LoopNode::EntryControl,    old_phi-&gt;in(LoopNode::EntryControl));
1865       phi-&gt;init_req(LoopNode::LoopBackControl, old_phi-&gt;in(outer_idx));
1866       phi = igvn.register_new_node_with_optimizer(phi, old_phi);
1867       // Make old Phi point to new Phi on the fall-in path
1868       igvn.replace_input_of(old_phi, LoopNode::EntryControl, phi);
1869       old_phi-&gt;del_req(outer_idx);
1870     }
1871   }
1872 
1873   // Use the new loop head instead of the old shared one
1874   _head = outer;
1875   phase-&gt;set_loop(_head, this);
1876 }
1877 
1878 //------------------------------fix_parent-------------------------------------
1879 static void fix_parent( IdealLoopTree *loop, IdealLoopTree *parent ) {
1880   loop-&gt;_parent = parent;
1881   if( loop-&gt;_child ) fix_parent( loop-&gt;_child, loop   );
1882   if( loop-&gt;_next  ) fix_parent( loop-&gt;_next , parent );
1883 }
1884 
1885 //------------------------------estimate_path_freq-----------------------------
1886 static float estimate_path_freq( Node *n ) {
1887   // Try to extract some path frequency info
1888   IfNode *iff;
1889   for( int i = 0; i &lt; 50; i++ ) { // Skip through a bunch of uncommon tests
1890     uint nop = n-&gt;Opcode();
1891     if( nop == Op_SafePoint ) {   // Skip any safepoint
1892       n = n-&gt;in(0);
1893       continue;
1894     }
1895     if( nop == Op_CatchProj ) {   // Get count from a prior call
1896       // Assume call does not always throw exceptions: means the call-site
1897       // count is also the frequency of the fall-through path.
1898       assert( n-&gt;is_CatchProj(), &quot;&quot; );
1899       if( ((CatchProjNode*)n)-&gt;_con != CatchProjNode::fall_through_index )
1900         return 0.0f;            // Assume call exception path is rare
1901       Node *call = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
1902       assert( call-&gt;is_Call(), &quot;expect a call here&quot; );
1903       const JVMState *jvms = ((CallNode*)call)-&gt;jvms();
1904       ciMethodData* methodData = jvms-&gt;method()-&gt;method_data();
1905       if (!methodData-&gt;is_mature())  return 0.0f; // No call-site data
1906       ciProfileData* data = methodData-&gt;bci_to_data(jvms-&gt;bci());
1907       if ((data == NULL) || !data-&gt;is_CounterData()) {
1908         // no call profile available, try call&#39;s control input
1909         n = n-&gt;in(0);
1910         continue;
1911       }
1912       return data-&gt;as_CounterData()-&gt;count()/FreqCountInvocations;
1913     }
1914     // See if there&#39;s a gating IF test
1915     Node *n_c = n-&gt;in(0);
1916     if( !n_c-&gt;is_If() ) break;       // No estimate available
1917     iff = n_c-&gt;as_If();
1918     if( iff-&gt;_fcnt != COUNT_UNKNOWN )   // Have a valid count?
1919       // Compute how much count comes on this path
1920       return ((nop == Op_IfTrue) ? iff-&gt;_prob : 1.0f - iff-&gt;_prob) * iff-&gt;_fcnt;
1921     // Have no count info.  Skip dull uncommon-trap like branches.
1922     if( (nop == Op_IfTrue  &amp;&amp; iff-&gt;_prob &lt; PROB_LIKELY_MAG(5)) ||
1923         (nop == Op_IfFalse &amp;&amp; iff-&gt;_prob &gt; PROB_UNLIKELY_MAG(5)) )
1924       break;
1925     // Skip through never-taken branch; look for a real loop exit.
1926     n = iff-&gt;in(0);
1927   }
1928   return 0.0f;                  // No estimate available
1929 }
1930 
1931 //------------------------------merge_many_backedges---------------------------
1932 // Merge all the backedges from the shared header into a private Region.
1933 // Feed that region as the one backedge to this loop.
1934 void IdealLoopTree::merge_many_backedges( PhaseIdealLoop *phase ) {
1935   uint i;
1936 
1937   // Scan for the top 2 hottest backedges
1938   float hotcnt = 0.0f;
1939   float warmcnt = 0.0f;
1940   uint hot_idx = 0;
1941   // Loop starts at 2 because slot 1 is the fall-in path
1942   for( i = 2; i &lt; _head-&gt;req(); i++ ) {
1943     float cnt = estimate_path_freq(_head-&gt;in(i));
1944     if( cnt &gt; hotcnt ) {       // Grab hottest path
1945       warmcnt = hotcnt;
1946       hotcnt = cnt;
1947       hot_idx = i;
1948     } else if( cnt &gt; warmcnt ) { // And 2nd hottest path
1949       warmcnt = cnt;
1950     }
1951   }
1952 
1953   // See if the hottest backedge is worthy of being an inner loop
1954   // by being much hotter than the next hottest backedge.
1955   if( hotcnt &lt;= 0.0001 ||
1956       hotcnt &lt; 2.0*warmcnt ) hot_idx = 0;// No hot backedge
1957 
1958   // Peel out the backedges into a private merge point; peel
1959   // them all except optionally hot_idx.
1960   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1961 
1962   Node *hot_tail = NULL;
1963   // Make a Region for the merge point
1964   Node *r = new RegionNode(1);
1965   for( i = 2; i &lt; _head-&gt;req(); i++ ) {
1966     if( i != hot_idx )
1967       r-&gt;add_req( _head-&gt;in(i) );
1968     else hot_tail = _head-&gt;in(i);
1969   }
1970   igvn.register_new_node_with_optimizer(r, _head);
1971   // Plug region into end of loop _head, followed by hot_tail
1972   while( _head-&gt;req() &gt; 3 ) _head-&gt;del_req( _head-&gt;req()-1 );
1973   igvn.replace_input_of(_head, 2, r);
1974   if( hot_idx ) _head-&gt;add_req(hot_tail);
1975 
1976   // Split all the Phis up between &#39;_head&#39; loop and the Region &#39;r&#39;
1977   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1978     Node *out = _head-&gt;fast_out(j);
1979     if( out-&gt;is_Phi() ) {
1980       PhiNode* n = out-&gt;as_Phi();
1981       igvn.hash_delete(n);      // Delete from hash before hacking edges
1982       Node *hot_phi = NULL;
1983       Node *phi = new PhiNode(r, n-&gt;type(), n-&gt;adr_type());
1984       // Check all inputs for the ones to peel out
1985       uint j = 1;
1986       for( uint i = 2; i &lt; n-&gt;req(); i++ ) {
1987         if( i != hot_idx )
1988           phi-&gt;set_req( j++, n-&gt;in(i) );
1989         else hot_phi = n-&gt;in(i);
1990       }
1991       // Register the phi but do not transform until whole place transforms
1992       igvn.register_new_node_with_optimizer(phi, n);
1993       // Add the merge phi to the old Phi
1994       while( n-&gt;req() &gt; 3 ) n-&gt;del_req( n-&gt;req()-1 );
1995       igvn.replace_input_of(n, 2, phi);
1996       if( hot_idx ) n-&gt;add_req(hot_phi);
1997     }
1998   }
1999 
2000 
2001   // Insert a new IdealLoopTree inserted below me.  Turn it into a clone
2002   // of self loop tree.  Turn self into a loop headed by _head and with
2003   // tail being the new merge point.
2004   IdealLoopTree *ilt = new IdealLoopTree( phase, _head, _tail );
2005   phase-&gt;set_loop(_tail,ilt);   // Adjust tail
2006   _tail = r;                    // Self&#39;s tail is new merge point
2007   phase-&gt;set_loop(r,this);
2008   ilt-&gt;_child = _child;         // New guy has my children
2009   _child = ilt;                 // Self has new guy as only child
2010   ilt-&gt;_parent = this;          // new guy has self for parent
2011   ilt-&gt;_nest = _nest;           // Same nesting depth (for now)
2012 
2013   // Starting with &#39;ilt&#39;, look for child loop trees using the same shared
2014   // header.  Flatten these out; they will no longer be loops in the end.
2015   IdealLoopTree **pilt = &amp;_child;
2016   while( ilt ) {
2017     if( ilt-&gt;_head == _head ) {
2018       uint i;
2019       for( i = 2; i &lt; _head-&gt;req(); i++ )
2020         if( _head-&gt;in(i) == ilt-&gt;_tail )
2021           break;                // Still a loop
2022       if( i == _head-&gt;req() ) { // No longer a loop
2023         // Flatten ilt.  Hang ilt&#39;s &quot;_next&quot; list from the end of
2024         // ilt&#39;s &#39;_child&#39; list.  Move the ilt&#39;s _child up to replace ilt.
2025         IdealLoopTree **cp = &amp;ilt-&gt;_child;
2026         while( *cp ) cp = &amp;(*cp)-&gt;_next;   // Find end of child list
2027         *cp = ilt-&gt;_next;       // Hang next list at end of child list
2028         *pilt = ilt-&gt;_child;    // Move child up to replace ilt
2029         ilt-&gt;_head = NULL;      // Flag as a loop UNIONED into parent
2030         ilt = ilt-&gt;_child;      // Repeat using new ilt
2031         continue;               // do not advance over ilt-&gt;_child
2032       }
2033       assert( ilt-&gt;_tail == hot_tail, &quot;expected to only find the hot inner loop here&quot; );
2034       phase-&gt;set_loop(_head,ilt);
2035     }
2036     pilt = &amp;ilt-&gt;_child;        // Advance to next
2037     ilt = *pilt;
2038   }
2039 
2040   if( _child ) fix_parent( _child, this );
2041 }
2042 
2043 //------------------------------beautify_loops---------------------------------
2044 // Split shared headers and insert loop landing pads.
2045 // Insert a LoopNode to replace the RegionNode.
2046 // Return TRUE if loop tree is structurally changed.
2047 bool IdealLoopTree::beautify_loops( PhaseIdealLoop *phase ) {
2048   bool result = false;
2049   // Cache parts in locals for easy
2050   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
2051 
2052   igvn.hash_delete(_head);      // Yank from hash before hacking edges
2053 
2054   // Check for multiple fall-in paths.  Peel off a landing pad if need be.
2055   int fall_in_cnt = 0;
2056   for( uint i = 1; i &lt; _head-&gt;req(); i++ )
2057     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) )
2058       fall_in_cnt++;
2059   assert( fall_in_cnt, &quot;at least 1 fall-in path&quot; );
2060   if( fall_in_cnt &gt; 1 )         // Need a loop landing pad to merge fall-ins
2061     split_fall_in( phase, fall_in_cnt );
2062 
2063   // Swap inputs to the _head and all Phis to move the fall-in edge to
2064   // the left.
2065   fall_in_cnt = 1;
2066   while( phase-&gt;is_member( this, _head-&gt;in(fall_in_cnt) ) )
2067     fall_in_cnt++;
2068   if( fall_in_cnt &gt; 1 ) {
2069     // Since I am just swapping inputs I do not need to update def-use info
2070     Node *tmp = _head-&gt;in(1);
2071     igvn.rehash_node_delayed(_head);
2072     _head-&gt;set_req( 1, _head-&gt;in(fall_in_cnt) );
2073     _head-&gt;set_req( fall_in_cnt, tmp );
2074     // Swap also all Phis
2075     for (DUIterator_Fast imax, i = _head-&gt;fast_outs(imax); i &lt; imax; i++) {
2076       Node* phi = _head-&gt;fast_out(i);
2077       if( phi-&gt;is_Phi() ) {
2078         igvn.rehash_node_delayed(phi); // Yank from hash before hacking edges
2079         tmp = phi-&gt;in(1);
2080         phi-&gt;set_req( 1, phi-&gt;in(fall_in_cnt) );
2081         phi-&gt;set_req( fall_in_cnt, tmp );
2082       }
2083     }
2084   }
2085   assert( !phase-&gt;is_member( this, _head-&gt;in(1) ), &quot;left edge is fall-in&quot; );
2086   assert(  phase-&gt;is_member( this, _head-&gt;in(2) ), &quot;right edge is loop&quot; );
2087 
2088   // If I am a shared header (multiple backedges), peel off the many
2089   // backedges into a private merge point and use the merge point as
2090   // the one true backedge.
2091   if( _head-&gt;req() &gt; 3 ) {
2092     // Merge the many backedges into a single backedge but leave
2093     // the hottest backedge as separate edge for the following peel.
2094     merge_many_backedges( phase );
2095     result = true;
2096   }
2097 
2098   // If I have one hot backedge, peel off myself loop.
2099   // I better be the outermost loop.
2100   if (_head-&gt;req() &gt; 3 &amp;&amp; !_irreducible) {
2101     split_outer_loop( phase );
2102     result = true;
2103 
2104   } else if (!_head-&gt;is_Loop() &amp;&amp; !_irreducible) {
2105     // Make a new LoopNode to replace the old loop head
2106     Node *l = new LoopNode( _head-&gt;in(1), _head-&gt;in(2) );
2107     l = igvn.register_new_node_with_optimizer(l, _head);
2108     phase-&gt;set_created_loop_node();
2109     // Go ahead and replace _head
2110     phase-&gt;_igvn.replace_node( _head, l );
2111     _head = l;
2112     phase-&gt;set_loop(_head, this);
2113   }
2114 
2115   // Now recursively beautify nested loops
2116   if( _child ) result |= _child-&gt;beautify_loops( phase );
2117   if( _next  ) result |= _next -&gt;beautify_loops( phase );
2118   return result;
2119 }
2120 
2121 //------------------------------allpaths_check_safepts----------------------------
2122 // Allpaths backwards scan from loop tail, terminating each path at first safepoint
2123 // encountered.  Helper for check_safepts.
2124 void IdealLoopTree::allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2125   assert(stack.size() == 0, &quot;empty stack&quot;);
2126   stack.push(_tail);
<a name="14" id="anc14"></a><span class="line-modified">2127   visited.Clear();</span>
2128   visited.set(_tail-&gt;_idx);
2129   while (stack.size() &gt; 0) {
2130     Node* n = stack.pop();
2131     if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2132       // Terminate this path
2133     } else if (n-&gt;Opcode() == Op_SafePoint) {
2134       if (_phase-&gt;get_loop(n) != this) {
2135         if (_required_safept == NULL) _required_safept = new Node_List();
2136         _required_safept-&gt;push(n);  // save the one closest to the tail
2137       }
2138       // Terminate this path
2139     } else {
2140       uint start = n-&gt;is_Region() ? 1 : 0;
2141       uint end   = n-&gt;is_Region() &amp;&amp; !n-&gt;is_Loop() ? n-&gt;req() : start + 1;
2142       for (uint i = start; i &lt; end; i++) {
2143         Node* in = n-&gt;in(i);
2144         assert(in-&gt;is_CFG(), &quot;must be&quot;);
2145         if (!visited.test_set(in-&gt;_idx) &amp;&amp; is_member(_phase-&gt;get_loop(in))) {
2146           stack.push(in);
2147         }
2148       }
2149     }
2150   }
2151 }
2152 
2153 //------------------------------check_safepts----------------------------
2154 // Given dominators, try to find loops with calls that must always be
2155 // executed (call dominates loop tail).  These loops do not need non-call
2156 // safepoints (ncsfpt).
2157 //
2158 // A complication is that a safepoint in a inner loop may be needed
2159 // by an outer loop. In the following, the inner loop sees it has a
2160 // call (block 3) on every path from the head (block 2) to the
2161 // backedge (arc 3-&gt;2).  So it deletes the ncsfpt (non-call safepoint)
2162 // in block 2, _but_ this leaves the outer loop without a safepoint.
2163 //
2164 //          entry  0
2165 //                 |
2166 //                 v
2167 // outer 1,2    +-&gt;1
2168 //              |  |
2169 //              |  v
2170 //              |  2&lt;---+  ncsfpt in 2
2171 //              |_/|\   |
2172 //                 | v  |
2173 // inner 2,3      /  3  |  call in 3
2174 //               /   |  |
2175 //              v    +--+
2176 //        exit  4
2177 //
2178 //
2179 // This method creates a list (_required_safept) of ncsfpt nodes that must
2180 // be protected is created for each loop. When a ncsfpt maybe deleted, it
2181 // is first looked for in the lists for the outer loops of the current loop.
2182 //
2183 // The insights into the problem:
2184 //  A) counted loops are okay
2185 //  B) innermost loops are okay (only an inner loop can delete
2186 //     a ncsfpt needed by an outer loop)
2187 //  C) a loop is immune from an inner loop deleting a safepoint
2188 //     if the loop has a call on the idom-path
2189 //  D) a loop is also immune if it has a ncsfpt (non-call safepoint) on the
2190 //     idom-path that is not in a nested loop
2191 //  E) otherwise, an ncsfpt on the idom-path that is nested in an inner
2192 //     loop needs to be prevented from deletion by an inner loop
2193 //
2194 // There are two analyses:
2195 //  1) The first, and cheaper one, scans the loop body from
2196 //     tail to head following the idom (immediate dominator)
2197 //     chain, looking for the cases (C,D,E) above.
2198 //     Since inner loops are scanned before outer loops, there is summary
2199 //     information about inner loops.  Inner loops can be skipped over
2200 //     when the tail of an inner loop is encountered.
2201 //
2202 //  2) The second, invoked if the first fails to find a call or ncsfpt on
2203 //     the idom path (which is rare), scans all predecessor control paths
2204 //     from the tail to the head, terminating a path when a call or sfpt
2205 //     is encountered, to find the ncsfpt&#39;s that are closest to the tail.
2206 //
2207 void IdealLoopTree::check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2208   // Bottom up traversal
2209   IdealLoopTree* ch = _child;
2210   if (_child) _child-&gt;check_safepts(visited, stack);
2211   if (_next)  _next -&gt;check_safepts(visited, stack);
2212 
2213   if (!_head-&gt;is_CountedLoop() &amp;&amp; !_has_sfpt &amp;&amp; _parent != NULL &amp;&amp; !_irreducible) {
2214     bool  has_call         = false; // call on dom-path
2215     bool  has_local_ncsfpt = false; // ncsfpt on dom-path at this loop depth
2216     Node* nonlocal_ncsfpt  = NULL;  // ncsfpt on dom-path at a deeper depth
2217     // Scan the dom-path nodes from tail to head
2218     for (Node* n = tail(); n != _head; n = _phase-&gt;idom(n)) {
2219       if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2220         has_call = true;
2221         _has_sfpt = 1;          // Then no need for a safept!
2222         break;
2223       } else if (n-&gt;Opcode() == Op_SafePoint) {
2224         if (_phase-&gt;get_loop(n) == this) {
2225           has_local_ncsfpt = true;
2226           break;
2227         }
2228         if (nonlocal_ncsfpt == NULL) {
2229           nonlocal_ncsfpt = n; // save the one closest to the tail
2230         }
2231       } else {
2232         IdealLoopTree* nlpt = _phase-&gt;get_loop(n);
2233         if (this != nlpt) {
2234           // If at an inner loop tail, see if the inner loop has already
2235           // recorded seeing a call on the dom-path (and stop.)  If not,
2236           // jump to the head of the inner loop.
2237           assert(is_member(nlpt), &quot;nested loop&quot;);
2238           Node* tail = nlpt-&gt;_tail;
2239           if (tail-&gt;in(0)-&gt;is_If()) tail = tail-&gt;in(0);
2240           if (n == tail) {
2241             // If inner loop has call on dom-path, so does outer loop
2242             if (nlpt-&gt;_has_sfpt) {
2243               has_call = true;
2244               _has_sfpt = 1;
2245               break;
2246             }
2247             // Skip to head of inner loop
2248             assert(_phase-&gt;is_dominator(_head, nlpt-&gt;_head), &quot;inner head dominated by outer head&quot;);
2249             n = nlpt-&gt;_head;
2250           }
2251         }
2252       }
2253     }
2254     // Record safept&#39;s that this loop needs preserved when an
2255     // inner loop attempts to delete it&#39;s safepoints.
2256     if (_child != NULL &amp;&amp; !has_call &amp;&amp; !has_local_ncsfpt) {
2257       if (nonlocal_ncsfpt != NULL) {
2258         if (_required_safept == NULL) _required_safept = new Node_List();
2259         _required_safept-&gt;push(nonlocal_ncsfpt);
2260       } else {
2261         // Failed to find a suitable safept on the dom-path.  Now use
2262         // an all paths walk from tail to head, looking for safepoints to preserve.
2263         allpaths_check_safepts(visited, stack);
2264       }
2265     }
2266   }
2267 }
2268 
2269 //---------------------------is_deleteable_safept----------------------------
2270 // Is safept not required by an outer loop?
2271 bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) {
2272   assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;&quot;);
2273   IdealLoopTree* lp = get_loop(sfpt)-&gt;_parent;
2274   while (lp != NULL) {
2275     Node_List* sfpts = lp-&gt;_required_safept;
2276     if (sfpts != NULL) {
2277       for (uint i = 0; i &lt; sfpts-&gt;size(); i++) {
2278         if (sfpt == sfpts-&gt;at(i))
2279           return false;
2280       }
2281     }
2282     lp = lp-&gt;_parent;
2283   }
2284   return true;
2285 }
2286 
2287 //---------------------------replace_parallel_iv-------------------------------
2288 // Replace parallel induction variable (parallel to trip counter)
2289 void PhaseIdealLoop::replace_parallel_iv(IdealLoopTree *loop) {
2290   assert(loop-&gt;_head-&gt;is_CountedLoop(), &quot;&quot;);
2291   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2292   if (!cl-&gt;is_valid_counted_loop())
2293     return;         // skip malformed counted loop
2294   Node *incr = cl-&gt;incr();
2295   if (incr == NULL)
2296     return;         // Dead loop?
2297   Node *init = cl-&gt;init_trip();
2298   Node *phi  = cl-&gt;phi();
2299   int stride_con = cl-&gt;stride_con();
2300 
2301   // Visit all children, looking for Phis
2302   for (DUIterator i = cl-&gt;outs(); cl-&gt;has_out(i); i++) {
2303     Node *out = cl-&gt;out(i);
2304     // Look for other phis (secondary IVs). Skip dead ones
2305     if (!out-&gt;is_Phi() || out == phi || !has_node(out))
2306       continue;
2307     PhiNode* phi2 = out-&gt;as_Phi();
2308     Node *incr2 = phi2-&gt;in( LoopNode::LoopBackControl );
2309     // Look for induction variables of the form:  X += constant
2310     if (phi2-&gt;region() != loop-&gt;_head ||
2311         incr2-&gt;req() != 3 ||
2312         incr2-&gt;in(1) != phi2 ||
2313         incr2 == incr ||
2314         incr2-&gt;Opcode() != Op_AddI ||
2315         !incr2-&gt;in(2)-&gt;is_Con())
2316       continue;
2317 
2318     // Check for parallel induction variable (parallel to trip counter)
2319     // via an affine function.  In particular, count-down loops with
2320     // count-up array indices are common. We only RCE references off
2321     // the trip-counter, so we need to convert all these to trip-counter
2322     // expressions.
2323     Node *init2 = phi2-&gt;in( LoopNode::EntryControl );
2324     int stride_con2 = incr2-&gt;in(2)-&gt;get_int();
2325 
2326     // The ratio of the two strides cannot be represented as an int
2327     // if stride_con2 is min_int and stride_con is -1.
2328     if (stride_con2 == min_jint &amp;&amp; stride_con == -1) {
2329       continue;
2330     }
2331 
2332     // The general case here gets a little tricky.  We want to find the
2333     // GCD of all possible parallel IV&#39;s and make a new IV using this
2334     // GCD for the loop.  Then all possible IVs are simple multiples of
2335     // the GCD.  In practice, this will cover very few extra loops.
2336     // Instead we require &#39;stride_con2&#39; to be a multiple of &#39;stride_con&#39;,
2337     // where +/-1 is the common case, but other integer multiples are
2338     // also easy to handle.
2339     int ratio_con = stride_con2/stride_con;
2340 
2341     if ((ratio_con * stride_con) == stride_con2) { // Check for exact
2342 #ifndef PRODUCT
2343       if (TraceLoopOpts) {
2344         tty-&gt;print(&quot;Parallel IV: %d &quot;, phi2-&gt;_idx);
2345         loop-&gt;dump_head();
2346       }
2347 #endif
2348       // Convert to using the trip counter.  The parallel induction
2349       // variable differs from the trip counter by a loop-invariant
2350       // amount, the difference between their respective initial values.
2351       // It is scaled by the &#39;ratio_con&#39;.
2352       Node* ratio = _igvn.intcon(ratio_con);
2353       set_ctrl(ratio, C-&gt;root());
2354       Node* ratio_init = new MulINode(init, ratio);
2355       _igvn.register_new_node_with_optimizer(ratio_init, init);
2356       set_early_ctrl(ratio_init);
2357       Node* diff = new SubINode(init2, ratio_init);
2358       _igvn.register_new_node_with_optimizer(diff, init2);
2359       set_early_ctrl(diff);
2360       Node* ratio_idx = new MulINode(phi, ratio);
2361       _igvn.register_new_node_with_optimizer(ratio_idx, phi);
2362       set_ctrl(ratio_idx, cl);
2363       Node* add = new AddINode(ratio_idx, diff);
2364       _igvn.register_new_node_with_optimizer(add);
2365       set_ctrl(add, cl);
2366       _igvn.replace_node( phi2, add );
2367       // Sometimes an induction variable is unused
2368       if (add-&gt;outcnt() == 0) {
2369         _igvn.remove_dead_node(add);
2370       }
2371       --i; // deleted this phi; rescan starting with next position
2372       continue;
2373     }
2374   }
2375 }
2376 
2377 void IdealLoopTree::remove_safepoints(PhaseIdealLoop* phase, bool keep_one) {
2378   Node* keep = NULL;
2379   if (keep_one) {
2380     // Look for a safepoint on the idom-path.
2381     for (Node* i = tail(); i != _head; i = phase-&gt;idom(i)) {
2382       if (i-&gt;Opcode() == Op_SafePoint &amp;&amp; phase-&gt;get_loop(i) == this) {
2383         keep = i;
2384         break; // Found one
2385       }
2386     }
2387   }
2388 
2389   // Don&#39;t remove any safepoints if it is requested to keep a single safepoint and
2390   // no safepoint was found on idom-path. It is not safe to remove any safepoint
2391   // in this case since there&#39;s no safepoint dominating all paths in the loop body.
2392   bool prune = !keep_one || keep != NULL;
2393 
2394   // Delete other safepoints in this loop.
2395   Node_List* sfpts = _safepts;
2396   if (prune &amp;&amp; sfpts != NULL) {
2397     assert(keep == NULL || keep-&gt;Opcode() == Op_SafePoint, &quot;not safepoint&quot;);
2398     for (uint i = 0; i &lt; sfpts-&gt;size(); i++) {
2399       Node* n = sfpts-&gt;at(i);
2400       assert(phase-&gt;get_loop(n) == this, &quot;&quot;);
2401       if (n != keep &amp;&amp; phase-&gt;is_deleteable_safept(n)) {
2402         phase-&gt;lazy_replace(n, n-&gt;in(TypeFunc::Control));
2403       }
2404     }
2405   }
2406 }
2407 
2408 //------------------------------counted_loop-----------------------------------
2409 // Convert to counted loops where possible
2410 void IdealLoopTree::counted_loop( PhaseIdealLoop *phase ) {
2411 
2412   // For grins, set the inner-loop flag here
2413   if (!_child) {
2414     if (_head-&gt;is_Loop()) _head-&gt;as_Loop()-&gt;set_inner_loop();
2415   }
2416 
2417   IdealLoopTree* loop = this;
2418   if (_head-&gt;is_CountedLoop() ||
2419       phase-&gt;is_counted_loop(_head, loop)) {
2420 
2421     if (LoopStripMiningIter == 0 || (LoopStripMiningIter &gt; 1 &amp;&amp; _child == NULL)) {
2422       // Indicate we do not need a safepoint here
2423       _has_sfpt = 1;
2424     }
2425 
2426     // Remove safepoints
2427     bool keep_one_sfpt = !(_has_call || _has_sfpt);
2428     remove_safepoints(phase, keep_one_sfpt);
2429 
2430     // Look for induction variables
2431     phase-&gt;replace_parallel_iv(this);
2432 
2433   } else if (_parent != NULL &amp;&amp; !_irreducible) {
2434     // Not a counted loop. Keep one safepoint.
2435     bool keep_one_sfpt = true;
2436     remove_safepoints(phase, keep_one_sfpt);
2437   }
2438 
2439   // Recursively
2440   assert(loop-&gt;_child != this || (loop-&gt;_head-&gt;as_Loop()-&gt;is_OuterStripMinedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_strip_mined()), &quot;what kind of loop was added?&quot;);
2441   assert(loop-&gt;_child != this || (loop-&gt;_child-&gt;_child == NULL &amp;&amp; loop-&gt;_child-&gt;_next == NULL), &quot;would miss some loops&quot;);
2442   if (loop-&gt;_child &amp;&amp; loop-&gt;_child != this) loop-&gt;_child-&gt;counted_loop(phase);
2443   if (loop-&gt;_next)  loop-&gt;_next -&gt;counted_loop(phase);
2444 }
2445 
<a name="15" id="anc15"></a>




















































































2446 #ifndef PRODUCT
2447 //------------------------------dump_head--------------------------------------
2448 // Dump 1 liner for loop header info
<a name="16" id="anc16"></a><span class="line-modified">2449 void IdealLoopTree::dump_head( ) const {</span>
<span class="line-modified">2450   for (uint i=0; i&lt;_nest; i++)</span>
<span class="line-modified">2451     tty-&gt;print(&quot;  &quot;);</span>
<span class="line-removed">2452   tty-&gt;print(&quot;Loop: N%d/N%d &quot;,_head-&gt;_idx,_tail-&gt;_idx);</span>
2453   if (_irreducible) tty-&gt;print(&quot; IRREDUCIBLE&quot;);
2454   Node* entry = _head-&gt;is_Loop() ? _head-&gt;as_Loop()-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl) : _head-&gt;in(LoopNode::EntryControl);
2455   Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
2456   if (predicate != NULL ) {
2457     tty-&gt;print(&quot; limit_check&quot;);
2458     entry = PhaseIdealLoop::skip_loop_predicates(entry);
2459   }
2460   if (UseLoopPredicate) {
2461     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
2462     if (entry != NULL) {
2463       tty-&gt;print(&quot; predicated&quot;);
2464       entry = PhaseIdealLoop::skip_loop_predicates(entry);
2465     }
2466   }
2467   if (UseProfiledLoopPredicate) {
2468     entry = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
2469     if (entry != NULL) {
2470       tty-&gt;print(&quot; profile_predicated&quot;);
2471     }
2472   }
2473   if (_head-&gt;is_CountedLoop()) {
2474     CountedLoopNode *cl = _head-&gt;as_CountedLoop();
2475     tty-&gt;print(&quot; counted&quot;);
2476 
2477     Node* init_n = cl-&gt;init_trip();
2478     if (init_n  != NULL &amp;&amp;  init_n-&gt;is_Con())
2479       tty-&gt;print(&quot; [%d,&quot;, cl-&gt;init_trip()-&gt;get_int());
2480     else
2481       tty-&gt;print(&quot; [int,&quot;);
2482     Node* limit_n = cl-&gt;limit();
2483     if (limit_n  != NULL &amp;&amp;  limit_n-&gt;is_Con())
2484       tty-&gt;print(&quot;%d),&quot;, cl-&gt;limit()-&gt;get_int());
2485     else
2486       tty-&gt;print(&quot;int),&quot;);
2487     int stride_con  = cl-&gt;stride_con();
2488     if (stride_con &gt; 0) tty-&gt;print(&quot;+&quot;);
2489     tty-&gt;print(&quot;%d&quot;, stride_con);
2490 
2491     tty-&gt;print(&quot; (%0.f iters) &quot;, cl-&gt;profile_trip_cnt());
2492 
2493     if (cl-&gt;is_pre_loop ()) tty-&gt;print(&quot; pre&quot; );
2494     if (cl-&gt;is_main_loop()) tty-&gt;print(&quot; main&quot;);
2495     if (cl-&gt;is_post_loop()) tty-&gt;print(&quot; post&quot;);
2496     if (cl-&gt;is_vectorized_loop()) tty-&gt;print(&quot; vector&quot;);
2497     if (cl-&gt;range_checks_present()) tty-&gt;print(&quot; rc &quot;);
2498     if (cl-&gt;is_multiversioned()) tty-&gt;print(&quot; multi &quot;);
2499   }
2500   if (_has_call) tty-&gt;print(&quot; has_call&quot;);
2501   if (_has_sfpt) tty-&gt;print(&quot; has_sfpt&quot;);
2502   if (_rce_candidate) tty-&gt;print(&quot; rce&quot;);
2503   if (_safepts != NULL &amp;&amp; _safepts-&gt;size() &gt; 0) {
2504     tty-&gt;print(&quot; sfpts={&quot;); _safepts-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2505   }
2506   if (_required_safept != NULL &amp;&amp; _required_safept-&gt;size() &gt; 0) {
2507     tty-&gt;print(&quot; req={&quot;); _required_safept-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2508   }
2509   if (Verbose) {
2510     tty-&gt;print(&quot; body={&quot;); _body.dump_simple(); tty-&gt;print(&quot; }&quot;);
2511   }
2512   if (_head-&gt;is_Loop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
2513     tty-&gt;print(&quot; strip_mined&quot;);
2514   }
2515   tty-&gt;cr();
2516 }
2517 
2518 //------------------------------dump-------------------------------------------
2519 // Dump loops by loop tree
<a name="17" id="anc17"></a><span class="line-modified">2520 void IdealLoopTree::dump( ) const {</span>
2521   dump_head();
2522   if (_child) _child-&gt;dump();
2523   if (_next)  _next -&gt;dump();
2524 }
2525 
2526 #endif
2527 
2528 static void log_loop_tree(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {
2529   if (loop == root) {
2530     if (loop-&gt;_child != NULL) {
2531       log-&gt;begin_head(&quot;loop_tree&quot;);
2532       log-&gt;end_head();
2533       if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2534       log-&gt;tail(&quot;loop_tree&quot;);
2535       assert(loop-&gt;_next == NULL, &quot;what?&quot;);
2536     }
2537   } else {
2538     Node* head = loop-&gt;_head;
2539     log-&gt;begin_head(&quot;loop&quot;);
2540     log-&gt;print(&quot; idx=&#39;%d&#39; &quot;, head-&gt;_idx);
2541     if (loop-&gt;_irreducible) log-&gt;print(&quot;irreducible=&#39;1&#39; &quot;);
2542     if (head-&gt;is_Loop()) {
2543       if (head-&gt;as_Loop()-&gt;is_inner_loop()) log-&gt;print(&quot;inner_loop=&#39;1&#39; &quot;);
2544       if (head-&gt;as_Loop()-&gt;is_partial_peel_loop()) log-&gt;print(&quot;partial_peel_loop=&#39;1&#39; &quot;);
2545     }
2546     if (head-&gt;is_CountedLoop()) {
2547       CountedLoopNode* cl = head-&gt;as_CountedLoop();
2548       if (cl-&gt;is_pre_loop())  log-&gt;print(&quot;pre_loop=&#39;%d&#39; &quot;,  cl-&gt;main_idx());
2549       if (cl-&gt;is_main_loop()) log-&gt;print(&quot;main_loop=&#39;%d&#39; &quot;, cl-&gt;_idx);
2550       if (cl-&gt;is_post_loop()) log-&gt;print(&quot;post_loop=&#39;%d&#39; &quot;,  cl-&gt;main_idx());
2551     }
2552     log-&gt;end_head();
2553     if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2554     log-&gt;tail(&quot;loop&quot;);
2555     if( loop-&gt;_next  ) log_loop_tree(root, loop-&gt;_next, log);
2556   }
2557 }
2558 
2559 //---------------------collect_potentially_useful_predicates-----------------------
2560 // Helper function to collect potentially useful predicates to prevent them from
2561 // being eliminated by PhaseIdealLoop::eliminate_useless_predicates
2562 void PhaseIdealLoop::collect_potentially_useful_predicates(
2563                          IdealLoopTree * loop, Unique_Node_List &amp;useful_predicates) {
2564   if (loop-&gt;_child) { // child
2565     collect_potentially_useful_predicates(loop-&gt;_child, useful_predicates);
2566   }
2567 
2568   // self (only loops that we can apply loop predication may use their predicates)
2569   if (loop-&gt;_head-&gt;is_Loop() &amp;&amp;
2570       !loop-&gt;_irreducible    &amp;&amp;
2571       !loop-&gt;tail()-&gt;is_top()) {
2572     LoopNode* lpn = loop-&gt;_head-&gt;as_Loop();
2573     Node* entry = lpn-&gt;in(LoopNode::EntryControl);
2574     Node* predicate_proj = find_predicate(entry); // loop_limit_check first
2575     if (predicate_proj != NULL ) { // right pattern that can be used by loop predication
2576       assert(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
2577       useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one
2578       entry = skip_loop_predicates(entry);
2579     }
2580     predicate_proj = find_predicate(entry); // Predicate
2581     if (predicate_proj != NULL ) {
2582       useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one
2583       entry = skip_loop_predicates(entry);
2584     }
2585     if (UseProfiledLoopPredicate) {
2586       predicate_proj = find_predicate(entry); // Predicate
2587       if (predicate_proj != NULL ) {
2588         useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one
2589       }
2590     }
2591   }
2592 
2593   if (loop-&gt;_next) { // sibling
2594     collect_potentially_useful_predicates(loop-&gt;_next, useful_predicates);
2595   }
2596 }
2597 
2598 //------------------------eliminate_useless_predicates-----------------------------
2599 // Eliminate all inserted predicates if they could not be used by loop predication.
2600 // Note: it will also eliminates loop limits check predicate since it also uses
2601 // Opaque1 node (see Parse::add_predicate()).
2602 void PhaseIdealLoop::eliminate_useless_predicates() {
2603   if (C-&gt;predicate_count() == 0)
2604     return; // no predicate left
2605 
2606   Unique_Node_List useful_predicates; // to store useful predicates
2607   if (C-&gt;has_loops()) {
2608     collect_potentially_useful_predicates(_ltree_root-&gt;_child, useful_predicates);
2609   }
2610 
2611   for (int i = C-&gt;predicate_count(); i &gt; 0; i--) {
2612      Node * n = C-&gt;predicate_opaque1_node(i-1);
2613      assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
2614      if (!useful_predicates.member(n)) { // not in the useful list
2615        _igvn.replace_node(n, n-&gt;in(1));
2616      }
2617   }
2618 }
2619 
2620 //------------------------process_expensive_nodes-----------------------------
2621 // Expensive nodes have their control input set to prevent the GVN
2622 // from commoning them and as a result forcing the resulting node to
2623 // be in a more frequent path. Use CFG information here, to change the
2624 // control inputs so that some expensive nodes can be commoned while
2625 // not executed more frequently.
2626 bool PhaseIdealLoop::process_expensive_nodes() {
2627   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
2628 
2629   // Sort nodes to bring similar nodes together
2630   C-&gt;sort_expensive_nodes();
2631 
2632   bool progress = false;
2633 
2634   for (int i = 0; i &lt; C-&gt;expensive_count(); ) {
2635     Node* n = C-&gt;expensive_node(i);
2636     int start = i;
2637     // Find nodes similar to n
2638     i++;
2639     for (; i &lt; C-&gt;expensive_count() &amp;&amp; Compile::cmp_expensive_nodes(n, C-&gt;expensive_node(i)) == 0; i++);
2640     int end = i;
2641     // And compare them two by two
2642     for (int j = start; j &lt; end; j++) {
2643       Node* n1 = C-&gt;expensive_node(j);
2644       if (is_node_unreachable(n1)) {
2645         continue;
2646       }
2647       for (int k = j+1; k &lt; end; k++) {
2648         Node* n2 = C-&gt;expensive_node(k);
2649         if (is_node_unreachable(n2)) {
2650           continue;
2651         }
2652 
2653         assert(n1 != n2, &quot;should be pair of nodes&quot;);
2654 
2655         Node* c1 = n1-&gt;in(0);
2656         Node* c2 = n2-&gt;in(0);
2657 
2658         Node* parent_c1 = c1;
2659         Node* parent_c2 = c2;
2660 
2661         // The call to get_early_ctrl_for_expensive() moves the
2662         // expensive nodes up but stops at loops that are in a if
2663         // branch. See whether we can exit the loop and move above the
2664         // If.
2665         if (c1-&gt;is_Loop()) {
2666           parent_c1 = c1-&gt;in(1);
2667         }
2668         if (c2-&gt;is_Loop()) {
2669           parent_c2 = c2-&gt;in(1);
2670         }
2671 
2672         if (parent_c1 == parent_c2) {
2673           _igvn._worklist.push(n1);
2674           _igvn._worklist.push(n2);
2675           continue;
2676         }
2677 
2678         // Look for identical expensive node up the dominator chain.
2679         if (is_dominator(c1, c2)) {
2680           c2 = c1;
2681         } else if (is_dominator(c2, c1)) {
2682           c1 = c2;
2683         } else if (parent_c1-&gt;is_Proj() &amp;&amp; parent_c1-&gt;in(0)-&gt;is_If() &amp;&amp;
2684                    parent_c2-&gt;is_Proj() &amp;&amp; parent_c1-&gt;in(0) == parent_c2-&gt;in(0)) {
2685           // Both branches have the same expensive node so move it up
2686           // before the if.
2687           c1 = c2 = idom(parent_c1-&gt;in(0));
2688         }
2689         // Do the actual moves
2690         if (n1-&gt;in(0) != c1) {
2691           _igvn.hash_delete(n1);
2692           n1-&gt;set_req(0, c1);
2693           _igvn.hash_insert(n1);
2694           _igvn._worklist.push(n1);
2695           progress = true;
2696         }
2697         if (n2-&gt;in(0) != c2) {
2698           _igvn.hash_delete(n2);
2699           n2-&gt;set_req(0, c2);
2700           _igvn.hash_insert(n2);
2701           _igvn._worklist.push(n2);
2702           progress = true;
2703         }
2704       }
2705     }
2706   }
2707 
2708   return progress;
2709 }
2710 
2711 
2712 //=============================================================================
2713 //----------------------------build_and_optimize-------------------------------
2714 // Create a PhaseLoop.  Build the ideal Loop tree.  Map each Ideal Node to
2715 // its corresponding LoopNode.  If &#39;optimize&#39; is true, do some loop cleanups.
2716 void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {
<a name="18" id="anc18"></a><span class="line-modified">2717   bool do_split_ifs = (mode == LoopOptsDefault || mode == LoopOptsLastRound);</span>
2718   bool skip_loop_opts = (mode == LoopOptsNone);
2719 
2720   int old_progress = C-&gt;major_progress();
2721   uint orig_worklist_size = _igvn._worklist.size();
2722 
2723   // Reset major-progress flag for the driver&#39;s heuristics
2724   C-&gt;clear_major_progress();
2725 
2726 #ifndef PRODUCT
2727   // Capture for later assert
2728   uint unique = C-&gt;unique();
2729   _loop_invokes++;
2730   _loop_work += unique;
2731 #endif
2732 
2733   // True if the method has at least 1 irreducible loop
2734   _has_irreducible_loops = false;
2735 
2736   _created_loop_node = false;
2737 
2738   Arena *a = Thread::current()-&gt;resource_area();
2739   VectorSet visited(a);
2740   // Pre-grow the mapping from Nodes to IdealLoopTrees.
2741   _nodes.map(C-&gt;unique(), NULL);
2742   memset(_nodes.adr(), 0, wordSize * C-&gt;unique());
2743 
2744   // Pre-build the top-level outermost loop tree entry
2745   _ltree_root = new IdealLoopTree( this, C-&gt;root(), C-&gt;root() );
2746   // Do not need a safepoint at the top level
2747   _ltree_root-&gt;_has_sfpt = 1;
2748 
2749   // Initialize Dominators.
2750   // Checked in clone_loop_predicate() during beautify_loops().
2751   _idom_size = 0;
2752   _idom      = NULL;
2753   _dom_depth = NULL;
2754   _dom_stk   = NULL;
2755 
2756   // Empty pre-order array
2757   allocate_preorders();
2758 
2759   // Build a loop tree on the fly.  Build a mapping from CFG nodes to
2760   // IdealLoopTree entries.  Data nodes are NOT walked.
2761   build_loop_tree();
2762   // Check for bailout, and return
2763   if (C-&gt;failing()) {
2764     return;
2765   }
2766 
2767   // No loops after all
2768   if( !_ltree_root-&gt;_child &amp;&amp; !_verify_only ) C-&gt;set_has_loops(false);
2769 
2770   // There should always be an outer loop containing the Root and Return nodes.
2771   // If not, we have a degenerate empty program.  Bail out in this case.
2772   if (!has_node(C-&gt;root())) {
2773     if (!_verify_only) {
2774       C-&gt;clear_major_progress();
2775       C-&gt;record_method_not_compilable(&quot;empty program detected during loop optimization&quot;);
2776     }
2777     return;
2778   }
2779 
2780   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2781   // Nothing to do, so get out
2782   bool stop_early = !C-&gt;has_loops() &amp;&amp; !skip_loop_opts &amp;&amp; !do_split_ifs &amp;&amp; !_verify_me &amp;&amp; !_verify_only &amp;&amp;
2783     !bs-&gt;is_gc_specific_loop_opts_pass(mode);
2784   bool do_expensive_nodes = C-&gt;should_optimize_expensive_nodes(_igvn);
2785   bool strip_mined_loops_expanded = bs-&gt;strip_mined_loops_expanded(mode);
2786   if (stop_early &amp;&amp; !do_expensive_nodes) {
2787     _igvn.optimize();           // Cleanup NeverBranches
2788     return;
2789   }
2790 
2791   // Set loop nesting depth
2792   _ltree_root-&gt;set_nest( 0 );
2793 
2794   // Split shared headers and insert loop landing pads.
2795   // Do not bother doing this on the Root loop of course.
2796   if( !_verify_me &amp;&amp; !_verify_only &amp;&amp; _ltree_root-&gt;_child ) {
2797     C-&gt;print_method(PHASE_BEFORE_BEAUTIFY_LOOPS, 3);
2798     if( _ltree_root-&gt;_child-&gt;beautify_loops( this ) ) {
2799       // Re-build loop tree!
2800       _ltree_root-&gt;_child = NULL;
2801       _nodes.clear();
2802       reallocate_preorders();
2803       build_loop_tree();
2804       // Check for bailout, and return
2805       if (C-&gt;failing()) {
2806         return;
2807       }
2808       // Reset loop nesting depth
2809       _ltree_root-&gt;set_nest( 0 );
2810 
2811       C-&gt;print_method(PHASE_AFTER_BEAUTIFY_LOOPS, 3);
2812     }
2813   }
2814 
2815   // Build Dominators for elision of NULL checks &amp; loop finding.
2816   // Since nodes do not have a slot for immediate dominator, make
2817   // a persistent side array for that info indexed on node-&gt;_idx.
2818   _idom_size = C-&gt;unique();
2819   _idom      = NEW_RESOURCE_ARRAY( Node*, _idom_size );
2820   _dom_depth = NEW_RESOURCE_ARRAY( uint,  _idom_size );
2821   _dom_stk   = NULL; // Allocated on demand in recompute_dom_depth
2822   memset( _dom_depth, 0, _idom_size * sizeof(uint) );
2823 
2824   Dominators();
2825 
2826   if (!_verify_only) {
2827     // As a side effect, Dominators removed any unreachable CFG paths
2828     // into RegionNodes.  It doesn&#39;t do this test against Root, so
2829     // we do it here.
2830     for( uint i = 1; i &lt; C-&gt;root()-&gt;req(); i++ ) {
2831       if( !_nodes[C-&gt;root()-&gt;in(i)-&gt;_idx] ) {    // Dead path into Root?
2832         _igvn.delete_input_of(C-&gt;root(), i);
2833         i--;                      // Rerun same iteration on compressed edges
2834       }
2835     }
2836 
2837     // Given dominators, try to find inner loops with calls that must
2838     // always be executed (call dominates loop tail).  These loops do
2839     // not need a separate safepoint.
2840     Node_List cisstack(a);
2841     _ltree_root-&gt;check_safepts(visited, cisstack);
2842   }
2843 
2844   // Walk the DATA nodes and place into loops.  Find earliest control
2845   // node.  For CFG nodes, the _nodes array starts out and remains
2846   // holding the associated IdealLoopTree pointer.  For DATA nodes, the
2847   // _nodes array holds the earliest legal controlling CFG node.
2848 
2849   // Allocate stack with enough space to avoid frequent realloc
2850   int stack_size = (C-&gt;live_nodes() &gt;&gt; 1) + 16; // (live_nodes&gt;&gt;1)+16 from Java2D stats
2851   Node_Stack nstack( a, stack_size );
2852 
<a name="19" id="anc19"></a><span class="line-modified">2853   visited.Clear();</span>
2854   Node_List worklist(a);
2855   // Don&#39;t need C-&gt;root() on worklist since
2856   // it will be processed among C-&gt;top() inputs
<a name="20" id="anc20"></a><span class="line-modified">2857   worklist.push( C-&gt;top() );</span>
<span class="line-modified">2858   visited.set( C-&gt;top()-&gt;_idx ); // Set C-&gt;top() as visited now</span>
2859   build_loop_early( visited, worklist, nstack );
2860 
2861   // Given early legal placement, try finding counted loops.  This placement
2862   // is good enough to discover most loop invariants.
2863   if (!_verify_me &amp;&amp; !_verify_only &amp;&amp; !strip_mined_loops_expanded) {
2864     _ltree_root-&gt;counted_loop( this );
2865   }
2866 
2867   // Find latest loop placement.  Find ideal loop placement.
<a name="21" id="anc21"></a><span class="line-modified">2868   visited.Clear();</span>
2869   init_dom_lca_tags();
2870   // Need C-&gt;root() on worklist when processing outs
<a name="22" id="anc22"></a><span class="line-modified">2871   worklist.push( C-&gt;root() );</span>
2872   NOT_PRODUCT( C-&gt;verify_graph_edges(); )
<a name="23" id="anc23"></a><span class="line-modified">2873   worklist.push( C-&gt;top() );</span>
2874   build_loop_late( visited, worklist, nstack );
2875 
2876   if (_verify_only) {
<a name="24" id="anc24"></a><span class="line-modified">2877     // restore major progress flag</span>
<span class="line-removed">2878     for (int i = 0; i &lt; old_progress; i++)</span>
<span class="line-removed">2879       C-&gt;set_major_progress();</span>
2880     assert(C-&gt;unique() == unique, &quot;verification mode made Nodes? ? ?&quot;);
2881     assert(_igvn._worklist.size() == orig_worklist_size, &quot;shouldn&#39;t push anything&quot;);
2882     return;
2883   }
2884 
2885   // clear out the dead code after build_loop_late
2886   while (_deadlist.size()) {
2887     _igvn.remove_globally_dead_node(_deadlist.pop());
2888   }
2889 
2890   if (stop_early) {
2891     assert(do_expensive_nodes, &quot;why are we here?&quot;);
2892     if (process_expensive_nodes()) {
2893       // If we made some progress when processing expensive nodes then
2894       // the IGVN may modify the graph in a way that will allow us to
2895       // make some more progress: we need to try processing expensive
2896       // nodes again.
2897       C-&gt;set_major_progress();
2898     }
2899     _igvn.optimize();
2900     return;
2901   }
2902 
2903   // Some parser-inserted loop predicates could never be used by loop
2904   // predication or they were moved away from loop during some optimizations.
2905   // For example, peeling. Eliminate them before next loop optimizations.
2906   eliminate_useless_predicates();
2907 
2908 #ifndef PRODUCT
2909   C-&gt;verify_graph_edges();
2910   if (_verify_me) {             // Nested verify pass?
2911     // Check to see if the verify mode is broken
2912     assert(C-&gt;unique() == unique, &quot;non-optimize mode made Nodes? ? ?&quot;);
2913     return;
2914   }
<a name="25" id="anc25"></a><span class="line-modified">2915   if(VerifyLoopOptimizations) verify();</span>
<span class="line-modified">2916   if(TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {</span>
2917     _ltree_root-&gt;dump();
2918   }
2919 #endif
2920 
2921   if (skip_loop_opts) {
2922     // restore major progress flag
<a name="26" id="anc26"></a><span class="line-modified">2923     for (int i = 0; i &lt; old_progress; i++) {</span>
<span class="line-removed">2924       C-&gt;set_major_progress();</span>
<span class="line-removed">2925     }</span>
2926 
2927     // Cleanup any modified bits
2928     _igvn.optimize();
2929 
2930     if (C-&gt;log() != NULL) {
2931       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
2932     }
2933     return;
2934   }
2935 
<a name="27" id="anc27"></a>


























2936   if (bs-&gt;optimize_loops(this, mode, visited, nstack, worklist)) {
2937     _igvn.optimize();
2938     if (C-&gt;log() != NULL) {
2939       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
2940     }
2941     return;
2942   }
2943 
2944   if (ReassociateInvariants) {
2945     // Reassociate invariants and prep for split_thru_phi
2946     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
2947       IdealLoopTree* lpt = iter.current();
2948       bool is_counted = lpt-&gt;is_counted();
<a name="28" id="anc28"></a><span class="line-modified">2949       if (!is_counted || !lpt-&gt;is_inner()) continue;</span>
2950 
2951       // check for vectorized loops, any reassociation of invariants was already done
<a name="29" id="anc29"></a><span class="line-modified">2952       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;do_unroll_only()) continue;</span>
<span class="line-modified">2953 </span>
<span class="line-modified">2954       lpt-&gt;reassociate_invariants(this);</span>
<span class="line-modified">2955 </span>


2956       // Because RCE opportunities can be masked by split_thru_phi,
2957       // look for RCE candidates and inhibit split_thru_phi
2958       // on just their loop-phi&#39;s for this pass of loop opts
2959       if (SplitIfBlocks &amp;&amp; do_split_ifs) {
<a name="30" id="anc30"></a>
2960         if (lpt-&gt;policy_range_check(this)) {
2961           lpt-&gt;_rce_candidate = 1; // = true
2962         }
2963       }
2964     }
2965   }
2966 
2967   // Check for aggressive application of split-if and other transforms
2968   // that require basic-block info (like cloning through Phi&#39;s)
2969   if( SplitIfBlocks &amp;&amp; do_split_ifs ) {
<a name="31" id="anc31"></a><span class="line-modified">2970     visited.Clear();</span>
<span class="line-modified">2971     split_if_with_blocks( visited, nstack, mode == LoopOptsLastRound );</span>
2972     NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );
<a name="32" id="anc32"></a><span class="line-removed">2973     if (mode == LoopOptsLastRound) {</span>
<span class="line-removed">2974       C-&gt;set_major_progress();</span>
<span class="line-removed">2975     }</span>
2976   }
2977 
2978   if (!C-&gt;major_progress() &amp;&amp; do_expensive_nodes &amp;&amp; process_expensive_nodes()) {
2979     C-&gt;set_major_progress();
2980   }
2981 
2982   // Perform loop predication before iteration splitting
2983   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
2984     _ltree_root-&gt;_child-&gt;loop_predication(this);
2985   }
2986 
2987   if (OptimizeFill &amp;&amp; UseLoopPredicate &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
2988     if (do_intrinsify_fill()) {
2989       C-&gt;set_major_progress();
2990     }
2991   }
2992 
2993   // Perform iteration-splitting on inner loops.  Split iterations to avoid
2994   // range checks or one-shot null checks.
2995 
2996   // If split-if&#39;s didn&#39;t hack the graph too bad (no CFG changes)
2997   // then do loop opts.
2998   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
2999     memset( worklist.adr(), 0, worklist.Size()*sizeof(Node*) );
3000     _ltree_root-&gt;_child-&gt;iteration_split( this, worklist );
3001     // No verify after peeling!  GCM has hoisted code out of the loop.
3002     // After peeling, the hoisted code could sink inside the peeled area.
3003     // The peeling code does not try to recompute the best location for
3004     // all the code before the peeled area, so the verify pass will always
3005     // complain about it.
3006   }
3007   // Do verify graph edges in any case
3008   NOT_PRODUCT( C-&gt;verify_graph_edges(); );
3009 
3010   if (!do_split_ifs) {
3011     // We saw major progress in Split-If to get here.  We forced a
3012     // pass with unrolling and not split-if, however more split-if&#39;s
3013     // might make progress.  If the unrolling didn&#39;t make progress
3014     // then the major-progress flag got cleared and we won&#39;t try
3015     // another round of Split-If.  In particular the ever-common
3016     // instance-of/check-cast pattern requires at least 2 rounds of
3017     // Split-If to clear out.
3018     C-&gt;set_major_progress();
3019   }
3020 
3021   // Repeat loop optimizations if new loops were seen
3022   if (created_loop_node()) {
3023     C-&gt;set_major_progress();
3024   }
3025 
3026   // Keep loop predicates and perform optimizations with them
3027   // until no more loop optimizations could be done.
3028   // After that switch predicates off and do more loop optimizations.
3029   if (!C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
3030      C-&gt;cleanup_loop_predicates(_igvn);
3031      if (TraceLoopOpts) {
3032        tty-&gt;print_cr(&quot;PredicatesOff&quot;);
3033      }
3034      C-&gt;set_major_progress();
3035   }
3036 
3037   // Convert scalar to superword operations at the end of all loop opts.
3038   if (UseSuperWord &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
3039     // SuperWord transform
3040     SuperWord sw(this);
3041     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3042       IdealLoopTree* lpt = iter.current();
3043       if (lpt-&gt;is_counted()) {
3044         CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
3045 
3046         if (PostLoopMultiversioning &amp;&amp; cl-&gt;is_rce_post_loop() &amp;&amp; !cl-&gt;is_vectorized_loop()) {
3047           // Check that the rce&#39;d post loop is encountered first, multiversion after all
3048           // major main loop optimization are concluded
3049           if (!C-&gt;major_progress()) {
3050             IdealLoopTree *lpt_next = lpt-&gt;_next;
3051             if (lpt_next &amp;&amp; lpt_next-&gt;is_counted()) {
3052               CountedLoopNode *cl = lpt_next-&gt;_head-&gt;as_CountedLoop();
3053               has_range_checks(lpt_next);
3054               if (cl-&gt;is_post_loop() &amp;&amp; cl-&gt;range_checks_present()) {
3055                 if (!cl-&gt;is_multiversioned()) {
3056                   if (multi_version_post_loops(lpt, lpt_next) == false) {
3057                     // Cause the rce loop to be optimized away if we fail
3058                     cl-&gt;mark_is_multiversioned();
3059                     cl-&gt;set_slp_max_unroll(0);
3060                     poison_rce_post_loop(lpt);
3061                   }
3062                 }
3063               }
3064             }
3065             sw.transform_loop(lpt, true);
3066           }
3067         } else if (cl-&gt;is_main_loop()) {
3068           sw.transform_loop(lpt, true);
3069         }
3070       }
3071     }
3072   }
3073 
3074   // Cleanup any modified bits
3075   _igvn.optimize();
3076 
3077   // disable assert until issue with split_flow_path is resolved (6742111)
3078   // assert(!_has_irreducible_loops || C-&gt;parsed_irreducible_loop() || C-&gt;is_osr_compilation(),
3079   //        &quot;shouldn&#39;t introduce irreducible loops&quot;);
3080 
3081   if (C-&gt;log() != NULL) {
3082     log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3083   }
3084 }
3085 
3086 #ifndef PRODUCT
3087 //------------------------------print_statistics-------------------------------
3088 int PhaseIdealLoop::_loop_invokes=0;// Count of PhaseIdealLoop invokes
3089 int PhaseIdealLoop::_loop_work=0; // Sum of PhaseIdealLoop x unique
3090 void PhaseIdealLoop::print_statistics() {
3091   tty-&gt;print_cr(&quot;PhaseIdealLoop=%d, sum _unique=%d&quot;, _loop_invokes, _loop_work);
3092 }
3093 
3094 //------------------------------verify-----------------------------------------
3095 // Build a verify-only PhaseIdealLoop, and see that it agrees with me.
3096 static int fail;                // debug only, so its multi-thread dont care
3097 void PhaseIdealLoop::verify() const {
3098   int old_progress = C-&gt;major_progress();
3099   ResourceMark rm;
3100   PhaseIdealLoop loop_verify( _igvn, this );
3101   VectorSet visited(Thread::current()-&gt;resource_area());
3102 
3103   fail = 0;
3104   verify_compare( C-&gt;root(), &amp;loop_verify, visited );
3105   assert( fail == 0, &quot;verify loops failed&quot; );
3106   // Verify loop structure is the same
3107   _ltree_root-&gt;verify_tree(loop_verify._ltree_root, NULL);
3108   // Reset major-progress.  It was cleared by creating a verify version of
3109   // PhaseIdealLoop.
<a name="33" id="anc33"></a><span class="line-modified">3110   for( int i=0; i&lt;old_progress; i++ )</span>
<span class="line-removed">3111     C-&gt;set_major_progress();</span>
3112 }
3113 
3114 //------------------------------verify_compare---------------------------------
3115 // Make sure me and the given PhaseIdealLoop agree on key data structures
3116 void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const {
3117   if( !n ) return;
3118   if( visited.test_set( n-&gt;_idx ) ) return;
3119   if( !_nodes[n-&gt;_idx] ) {      // Unreachable
3120     assert( !loop_verify-&gt;_nodes[n-&gt;_idx], &quot;both should be unreachable&quot; );
3121     return;
3122   }
3123 
3124   uint i;
3125   for( i = 0; i &lt; n-&gt;req(); i++ )
3126     verify_compare( n-&gt;in(i), loop_verify, visited );
3127 
3128   // Check the &#39;_nodes&#39; block/loop structure
3129   i = n-&gt;_idx;
3130   if( has_ctrl(n) ) {           // We have control; verify has loop or ctrl
3131     if( _nodes[i] != loop_verify-&gt;_nodes[i] &amp;&amp;
3132         get_ctrl_no_update(n) != loop_verify-&gt;get_ctrl_no_update(n) ) {
3133       tty-&gt;print(&quot;Mismatched control setting for: &quot;);
3134       n-&gt;dump();
3135       if( fail++ &gt; 10 ) return;
3136       Node *c = get_ctrl_no_update(n);
3137       tty-&gt;print(&quot;We have it as: &quot;);
3138       if( c-&gt;in(0) ) c-&gt;dump();
3139         else tty-&gt;print_cr(&quot;N%d&quot;,c-&gt;_idx);
3140       tty-&gt;print(&quot;Verify thinks: &quot;);
3141       if( loop_verify-&gt;has_ctrl(n) )
3142         loop_verify-&gt;get_ctrl_no_update(n)-&gt;dump();
3143       else
3144         loop_verify-&gt;get_loop_idx(n)-&gt;dump();
3145       tty-&gt;cr();
3146     }
3147   } else {                    // We have a loop
3148     IdealLoopTree *us = get_loop_idx(n);
3149     if( loop_verify-&gt;has_ctrl(n) ) {
3150       tty-&gt;print(&quot;Mismatched loop setting for: &quot;);
3151       n-&gt;dump();
3152       if( fail++ &gt; 10 ) return;
3153       tty-&gt;print(&quot;We have it as: &quot;);
3154       us-&gt;dump();
3155       tty-&gt;print(&quot;Verify thinks: &quot;);
3156       loop_verify-&gt;get_ctrl_no_update(n)-&gt;dump();
3157       tty-&gt;cr();
3158     } else if (!C-&gt;major_progress()) {
3159       // Loop selection can be messed up if we did a major progress
3160       // operation, like split-if.  Do not verify in that case.
3161       IdealLoopTree *them = loop_verify-&gt;get_loop_idx(n);
3162       if( us-&gt;_head != them-&gt;_head ||  us-&gt;_tail != them-&gt;_tail ) {
3163         tty-&gt;print(&quot;Unequals loops for: &quot;);
3164         n-&gt;dump();
3165         if( fail++ &gt; 10 ) return;
3166         tty-&gt;print(&quot;We have it as: &quot;);
3167         us-&gt;dump();
3168         tty-&gt;print(&quot;Verify thinks: &quot;);
3169         them-&gt;dump();
3170         tty-&gt;cr();
3171       }
3172     }
3173   }
3174 
3175   // Check for immediate dominators being equal
3176   if( i &gt;= _idom_size ) {
3177     if( !n-&gt;is_CFG() ) return;
3178     tty-&gt;print(&quot;CFG Node with no idom: &quot;);
3179     n-&gt;dump();
3180     return;
3181   }
3182   if( !n-&gt;is_CFG() ) return;
3183   if( n == C-&gt;root() ) return; // No IDOM here
3184 
3185   assert(n-&gt;_idx == i, &quot;sanity&quot;);
3186   Node *id = idom_no_update(n);
3187   if( id != loop_verify-&gt;idom_no_update(n) ) {
3188     tty-&gt;print(&quot;Unequals idoms for: &quot;);
3189     n-&gt;dump();
3190     if( fail++ &gt; 10 ) return;
3191     tty-&gt;print(&quot;We have it as: &quot;);
3192     id-&gt;dump();
3193     tty-&gt;print(&quot;Verify thinks: &quot;);
3194     loop_verify-&gt;idom_no_update(n)-&gt;dump();
3195     tty-&gt;cr();
3196   }
3197 
3198 }
3199 
3200 //------------------------------verify_tree------------------------------------
3201 // Verify that tree structures match.  Because the CFG can change, siblings
3202 // within the loop tree can be reordered.  We attempt to deal with that by
3203 // reordering the verify&#39;s loop tree if possible.
3204 void IdealLoopTree::verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const {
3205   assert( _parent == parent, &quot;Badly formed loop tree&quot; );
3206 
3207   // Siblings not in same order?  Attempt to re-order.
3208   if( _head != loop-&gt;_head ) {
3209     // Find _next pointer to update
3210     IdealLoopTree **pp = &amp;loop-&gt;_parent-&gt;_child;
3211     while( *pp != loop )
3212       pp = &amp;((*pp)-&gt;_next);
3213     // Find proper sibling to be next
3214     IdealLoopTree **nn = &amp;loop-&gt;_next;
3215     while( (*nn) &amp;&amp; (*nn)-&gt;_head != _head )
3216       nn = &amp;((*nn)-&gt;_next);
3217 
3218     // Check for no match.
3219     if( !(*nn) ) {
3220       // Annoyingly, irreducible loops can pick different headers
3221       // after a major_progress operation, so the rest of the loop
3222       // tree cannot be matched.
3223       if (_irreducible &amp;&amp; Compile::current()-&gt;major_progress())  return;
3224       assert( 0, &quot;failed to match loop tree&quot; );
3225     }
3226 
3227     // Move (*nn) to (*pp)
3228     IdealLoopTree *hit = *nn;
3229     *nn = hit-&gt;_next;
3230     hit-&gt;_next = loop;
3231     *pp = loop;
3232     loop = hit;
3233     // Now try again to verify
3234   }
3235 
3236   assert( _head  == loop-&gt;_head , &quot;mismatched loop head&quot; );
3237   Node *tail = _tail;           // Inline a non-updating version of
3238   while( !tail-&gt;in(0) )         // the &#39;tail()&#39; call.
3239     tail = tail-&gt;in(1);
3240   assert( tail == loop-&gt;_tail, &quot;mismatched loop tail&quot; );
3241 
3242   // Counted loops that are guarded should be able to find their guards
3243   if( _head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_main_loop() ) {
3244     CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3245     Node *init = cl-&gt;init_trip();
3246     Node *ctrl = cl-&gt;in(LoopNode::EntryControl);
3247     assert( ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
3248     Node *iff  = ctrl-&gt;in(0);
3249     assert( iff-&gt;Opcode() == Op_If, &quot;&quot; );
3250     Node *bol  = iff-&gt;in(1);
3251     assert( bol-&gt;Opcode() == Op_Bool, &quot;&quot; );
3252     Node *cmp  = bol-&gt;in(1);
3253     assert( cmp-&gt;Opcode() == Op_CmpI, &quot;&quot; );
3254     Node *add  = cmp-&gt;in(1);
3255     Node *opaq;
3256     if( add-&gt;Opcode() == Op_Opaque1 ) {
3257       opaq = add;
3258     } else {
3259       assert( add-&gt;Opcode() == Op_AddI || add-&gt;Opcode() == Op_ConI , &quot;&quot; );
3260       assert( add == init, &quot;&quot; );
3261       opaq = cmp-&gt;in(2);
3262     }
3263     assert( opaq-&gt;Opcode() == Op_Opaque1, &quot;&quot; );
3264 
3265   }
3266 
3267   if (_child != NULL)  _child-&gt;verify_tree(loop-&gt;_child, this);
3268   if (_next  != NULL)  _next -&gt;verify_tree(loop-&gt;_next,  parent);
3269   // Innermost loops need to verify loop bodies,
3270   // but only if no &#39;major_progress&#39;
3271   int fail = 0;
3272   if (!Compile::current()-&gt;major_progress() &amp;&amp; _child == NULL) {
3273     for( uint i = 0; i &lt; _body.size(); i++ ) {
3274       Node *n = _body.at(i);
3275       if (n-&gt;outcnt() == 0)  continue; // Ignore dead
3276       uint j;
3277       for( j = 0; j &lt; loop-&gt;_body.size(); j++ )
3278         if( loop-&gt;_body.at(j) == n )
3279           break;
3280       if( j == loop-&gt;_body.size() ) { // Not found in loop body
3281         // Last ditch effort to avoid assertion: Its possible that we
3282         // have some users (so outcnt not zero) but are still dead.
3283         // Try to find from root.
3284         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3285           fail++;
3286           tty-&gt;print(&quot;We have that verify does not: &quot;);
3287           n-&gt;dump();
3288         }
3289       }
3290     }
3291     for( uint i2 = 0; i2 &lt; loop-&gt;_body.size(); i2++ ) {
3292       Node *n = loop-&gt;_body.at(i2);
3293       if (n-&gt;outcnt() == 0)  continue; // Ignore dead
3294       uint j;
3295       for( j = 0; j &lt; _body.size(); j++ )
3296         if( _body.at(j) == n )
3297           break;
3298       if( j == _body.size() ) { // Not found in loop body
3299         // Last ditch effort to avoid assertion: Its possible that we
3300         // have some users (so outcnt not zero) but are still dead.
3301         // Try to find from root.
3302         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3303           fail++;
3304           tty-&gt;print(&quot;Verify has that we do not: &quot;);
3305           n-&gt;dump();
3306         }
3307       }
3308     }
3309     assert( !fail, &quot;loop body mismatch&quot; );
3310   }
3311 }
3312 
3313 #endif
3314 
3315 //------------------------------set_idom---------------------------------------
3316 void PhaseIdealLoop::set_idom(Node* d, Node* n, uint dom_depth) {
3317   uint idx = d-&gt;_idx;
3318   if (idx &gt;= _idom_size) {
<a name="34" id="anc34"></a><span class="line-modified">3319     uint newsize = _idom_size&lt;&lt;1;</span>
<span class="line-removed">3320     while( idx &gt;= newsize ) {</span>
<span class="line-removed">3321       newsize &lt;&lt;= 1;</span>
<span class="line-removed">3322     }</span>
3323     _idom      = REALLOC_RESOURCE_ARRAY( Node*,     _idom,_idom_size,newsize);
3324     _dom_depth = REALLOC_RESOURCE_ARRAY( uint, _dom_depth,_idom_size,newsize);
3325     memset( _dom_depth + _idom_size, 0, (newsize - _idom_size) * sizeof(uint) );
3326     _idom_size = newsize;
3327   }
3328   _idom[idx] = n;
3329   _dom_depth[idx] = dom_depth;
3330 }
3331 
3332 //------------------------------recompute_dom_depth---------------------------------------
3333 // The dominator tree is constructed with only parent pointers.
3334 // This recomputes the depth in the tree by first tagging all
3335 // nodes as &quot;no depth yet&quot; marker.  The next pass then runs up
3336 // the dom tree from each node marked &quot;no depth yet&quot;, and computes
3337 // the depth on the way back down.
3338 void PhaseIdealLoop::recompute_dom_depth() {
3339   uint no_depth_marker = C-&gt;unique();
3340   uint i;
3341   // Initialize depth to &quot;no depth yet&quot; and realize all lazy updates
3342   for (i = 0; i &lt; _idom_size; i++) {
3343     // Only indices with a _dom_depth has a Node* or NULL (otherwise uninitalized).
3344     if (_dom_depth[i] &gt; 0 &amp;&amp; _idom[i] != NULL) {
3345       _dom_depth[i] = no_depth_marker;
3346 
3347       // heal _idom if it has a fwd mapping in _nodes
3348       if (_idom[i]-&gt;in(0) == NULL) {
3349         idom(i);
3350       }
3351     }
3352   }
3353   if (_dom_stk == NULL) {
3354     uint init_size = C-&gt;live_nodes() / 100; // Guess that 1/100 is a reasonable initial size.
3355     if (init_size &lt; 10) init_size = 10;
3356     _dom_stk = new GrowableArray&lt;uint&gt;(init_size);
3357   }
3358   // Compute new depth for each node.
3359   for (i = 0; i &lt; _idom_size; i++) {
3360     uint j = i;
3361     // Run up the dom tree to find a node with a depth
3362     while (_dom_depth[j] == no_depth_marker) {
3363       _dom_stk-&gt;push(j);
3364       j = _idom[j]-&gt;_idx;
3365     }
3366     // Compute the depth on the way back down this tree branch
3367     uint dd = _dom_depth[j] + 1;
3368     while (_dom_stk-&gt;length() &gt; 0) {
3369       uint j = _dom_stk-&gt;pop();
3370       _dom_depth[j] = dd;
3371       dd++;
3372     }
3373   }
3374 }
3375 
3376 //------------------------------sort-------------------------------------------
3377 // Insert &#39;loop&#39; into the existing loop tree.  &#39;innermost&#39; is a leaf of the
3378 // loop tree, not the root.
3379 IdealLoopTree *PhaseIdealLoop::sort( IdealLoopTree *loop, IdealLoopTree *innermost ) {
3380   if( !innermost ) return loop; // New innermost loop
3381 
3382   int loop_preorder = get_preorder(loop-&gt;_head); // Cache pre-order number
3383   assert( loop_preorder, &quot;not yet post-walked loop&quot; );
3384   IdealLoopTree **pp = &amp;innermost;      // Pointer to previous next-pointer
3385   IdealLoopTree *l = *pp;               // Do I go before or after &#39;l&#39;?
3386 
3387   // Insert at start of list
3388   while( l ) {                  // Insertion sort based on pre-order
3389     if( l == loop ) return innermost; // Already on list!
3390     int l_preorder = get_preorder(l-&gt;_head); // Cache pre-order number
3391     assert( l_preorder, &quot;not yet post-walked l&quot; );
3392     // Check header pre-order number to figure proper nesting
3393     if( loop_preorder &gt; l_preorder )
3394       break;                    // End of insertion
3395     // If headers tie (e.g., shared headers) check tail pre-order numbers.
3396     // Since I split shared headers, you&#39;d think this could not happen.
3397     // BUT: I must first do the preorder numbering before I can discover I
3398     // have shared headers, so the split headers all get the same preorder
3399     // number as the RegionNode they split from.
3400     if( loop_preorder == l_preorder &amp;&amp;
3401         get_preorder(loop-&gt;_tail) &lt; get_preorder(l-&gt;_tail) )
3402       break;                    // Also check for shared headers (same pre#)
3403     pp = &amp;l-&gt;_parent;           // Chain up list
3404     l = *pp;
3405   }
3406   // Link into list
3407   // Point predecessor to me
3408   *pp = loop;
3409   // Point me to successor
3410   IdealLoopTree *p = loop-&gt;_parent;
3411   loop-&gt;_parent = l;            // Point me to successor
3412   if( p ) sort( p, innermost ); // Insert my parents into list as well
3413   return innermost;
3414 }
3415 
3416 //------------------------------build_loop_tree--------------------------------
3417 // I use a modified Vick/Tarjan algorithm.  I need pre- and a post- visit
3418 // bits.  The _nodes[] array is mapped by Node index and holds a NULL for
3419 // not-yet-pre-walked, pre-order # for pre-but-not-post-walked and holds the
3420 // tightest enclosing IdealLoopTree for post-walked.
3421 //
3422 // During my forward walk I do a short 1-layer lookahead to see if I can find
3423 // a loop backedge with that doesn&#39;t have any work on the backedge.  This
3424 // helps me construct nested loops with shared headers better.
3425 //
3426 // Once I&#39;ve done the forward recursion, I do the post-work.  For each child
3427 // I check to see if there is a backedge.  Backedges define a loop!  I
3428 // insert an IdealLoopTree at the target of the backedge.
3429 //
3430 // During the post-work I also check to see if I have several children
3431 // belonging to different loops.  If so, then this Node is a decision point
3432 // where control flow can choose to change loop nests.  It is at this
3433 // decision point where I can figure out how loops are nested.  At this
3434 // time I can properly order the different loop nests from my children.
3435 // Note that there may not be any backedges at the decision point!
3436 //
3437 // Since the decision point can be far removed from the backedges, I can&#39;t
3438 // order my loops at the time I discover them.  Thus at the decision point
3439 // I need to inspect loop header pre-order numbers to properly nest my
3440 // loops.  This means I need to sort my childrens&#39; loops by pre-order.
3441 // The sort is of size number-of-control-children, which generally limits
3442 // it to size 2 (i.e., I just choose between my 2 target loops).
3443 void PhaseIdealLoop::build_loop_tree() {
3444   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
3445   GrowableArray &lt;Node *&gt; bltstack(C-&gt;live_nodes() &gt;&gt; 1);
3446   Node *n = C-&gt;root();
3447   bltstack.push(n);
3448   int pre_order = 1;
3449   int stack_size;
3450 
3451   while ( ( stack_size = bltstack.length() ) != 0 ) {
3452     n = bltstack.top(); // Leave node on stack
3453     if ( !is_visited(n) ) {
3454       // ---- Pre-pass Work ----
3455       // Pre-walked but not post-walked nodes need a pre_order number.
3456 
3457       set_preorder_visited( n, pre_order ); // set as visited
3458 
3459       // ---- Scan over children ----
3460       // Scan first over control projections that lead to loop headers.
3461       // This helps us find inner-to-outer loops with shared headers better.
3462 
3463       // Scan children&#39;s children for loop headers.
3464       for ( int i = n-&gt;outcnt() - 1; i &gt;= 0; --i ) {
3465         Node* m = n-&gt;raw_out(i);       // Child
3466         if( m-&gt;is_CFG() &amp;&amp; !is_visited(m) ) { // Only for CFG children
3467           // Scan over children&#39;s children to find loop
3468           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3469             Node* l = m-&gt;fast_out(j);
3470             if( is_visited(l) &amp;&amp;       // Been visited?
3471                 !is_postvisited(l) &amp;&amp;  // But not post-visited
3472                 get_preorder(l) &lt; pre_order ) { // And smaller pre-order
3473               // Found!  Scan the DFS down this path before doing other paths
3474               bltstack.push(m);
3475               break;
3476             }
3477           }
3478         }
3479       }
3480       pre_order++;
3481     }
3482     else if ( !is_postvisited(n) ) {
3483       // Note: build_loop_tree_impl() adds out edges on rare occasions,
3484       // such as com.sun.rsasign.am::a.
3485       // For non-recursive version, first, process current children.
3486       // On next iteration, check if additional children were added.
3487       for ( int k = n-&gt;outcnt() - 1; k &gt;= 0; --k ) {
3488         Node* u = n-&gt;raw_out(k);
3489         if ( u-&gt;is_CFG() &amp;&amp; !is_visited(u) ) {
3490           bltstack.push(u);
3491         }
3492       }
3493       if ( bltstack.length() == stack_size ) {
3494         // There were no additional children, post visit node now
3495         (void)bltstack.pop(); // Remove node from stack
3496         pre_order = build_loop_tree_impl( n, pre_order );
3497         // Check for bailout
3498         if (C-&gt;failing()) {
3499           return;
3500         }
3501         // Check to grow _preorders[] array for the case when
3502         // build_loop_tree_impl() adds new nodes.
3503         check_grow_preorders();
3504       }
3505     }
3506     else {
3507       (void)bltstack.pop(); // Remove post-visited node from stack
3508     }
3509   }
3510 }
3511 
3512 //------------------------------build_loop_tree_impl---------------------------
3513 int PhaseIdealLoop::build_loop_tree_impl( Node *n, int pre_order ) {
3514   // ---- Post-pass Work ----
3515   // Pre-walked but not post-walked nodes need a pre_order number.
3516 
3517   // Tightest enclosing loop for this Node
3518   IdealLoopTree *innermost = NULL;
3519 
3520   // For all children, see if any edge is a backedge.  If so, make a loop
3521   // for it.  Then find the tightest enclosing loop for the self Node.
3522   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3523     Node* m = n-&gt;fast_out(i);   // Child
3524     if( n == m ) continue;      // Ignore control self-cycles
3525     if( !m-&gt;is_CFG() ) continue;// Ignore non-CFG edges
3526 
3527     IdealLoopTree *l;           // Child&#39;s loop
3528     if( !is_postvisited(m) ) {  // Child visited but not post-visited?
3529       // Found a backedge
3530       assert( get_preorder(m) &lt; pre_order, &quot;should be backedge&quot; );
3531       // Check for the RootNode, which is already a LoopNode and is allowed
3532       // to have multiple &quot;backedges&quot;.
3533       if( m == C-&gt;root()) {     // Found the root?
3534         l = _ltree_root;        // Root is the outermost LoopNode
3535       } else {                  // Else found a nested loop
3536         // Insert a LoopNode to mark this loop.
3537         l = new IdealLoopTree(this, m, n);
3538       } // End of Else found a nested loop
3539       if( !has_loop(m) )        // If &#39;m&#39; does not already have a loop set
3540         set_loop(m, l);         // Set loop header to loop now
3541 
3542     } else {                    // Else not a nested loop
3543       if( !_nodes[m-&gt;_idx] ) continue; // Dead code has no loop
3544       l = get_loop(m);          // Get previously determined loop
3545       // If successor is header of a loop (nest), move up-loop till it
3546       // is a member of some outer enclosing loop.  Since there are no
3547       // shared headers (I&#39;ve split them already) I only need to go up
3548       // at most 1 level.
3549       while( l &amp;&amp; l-&gt;_head == m ) // Successor heads loop?
3550         l = l-&gt;_parent;         // Move up 1 for me
3551       // If this loop is not properly parented, then this loop
3552       // has no exit path out, i.e. its an infinite loop.
3553       if( !l ) {
3554         // Make loop &quot;reachable&quot; from root so the CFG is reachable.  Basically
3555         // insert a bogus loop exit that is never taken.  &#39;m&#39;, the loop head,
3556         // points to &#39;n&#39;, one (of possibly many) fall-in paths.  There may be
3557         // many backedges as well.
3558 
3559         // Here I set the loop to be the root loop.  I could have, after
3560         // inserting a bogus loop exit, restarted the recursion and found my
3561         // new loop exit.  This would make the infinite loop a first-class
3562         // loop and it would then get properly optimized.  What&#39;s the use of
3563         // optimizing an infinite loop?
3564         l = _ltree_root;        // Oops, found infinite loop
3565 
3566         if (!_verify_only) {
3567           // Insert the NeverBranch between &#39;m&#39; and it&#39;s control user.
3568           NeverBranchNode *iff = new NeverBranchNode( m );
3569           _igvn.register_new_node_with_optimizer(iff);
3570           set_loop(iff, l);
3571           Node *if_t = new CProjNode( iff, 0 );
3572           _igvn.register_new_node_with_optimizer(if_t);
3573           set_loop(if_t, l);
3574 
3575           Node* cfg = NULL;       // Find the One True Control User of m
3576           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3577             Node* x = m-&gt;fast_out(j);
3578             if (x-&gt;is_CFG() &amp;&amp; x != m &amp;&amp; x != iff)
3579               { cfg = x; break; }
3580           }
3581           assert(cfg != NULL, &quot;must find the control user of m&quot;);
3582           uint k = 0;             // Probably cfg-&gt;in(0)
3583           while( cfg-&gt;in(k) != m ) k++; // But check incase cfg is a Region
3584           cfg-&gt;set_req( k, if_t ); // Now point to NeverBranch
3585           _igvn._worklist.push(cfg);
3586 
3587           // Now create the never-taken loop exit
3588           Node *if_f = new CProjNode( iff, 1 );
3589           _igvn.register_new_node_with_optimizer(if_f);
3590           set_loop(if_f, l);
3591           // Find frame ptr for Halt.  Relies on the optimizer
3592           // V-N&#39;ing.  Easier and quicker than searching through
3593           // the program structure.
3594           Node *frame = new ParmNode( C-&gt;start(), TypeFunc::FramePtr );
3595           _igvn.register_new_node_with_optimizer(frame);
3596           // Halt &amp; Catch Fire
<a name="35" id="anc35"></a><span class="line-modified">3597           Node *halt = new HaltNode( if_f, frame );</span>
3598           _igvn.register_new_node_with_optimizer(halt);
3599           set_loop(halt, l);
3600           C-&gt;root()-&gt;add_req(halt);
3601         }
3602         set_loop(C-&gt;root(), _ltree_root);
3603       }
3604     }
3605     // Weeny check for irreducible.  This child was already visited (this
3606     // IS the post-work phase).  Is this child&#39;s loop header post-visited
3607     // as well?  If so, then I found another entry into the loop.
3608     if (!_verify_only) {
3609       while( is_postvisited(l-&gt;_head) ) {
3610         // found irreducible
3611         l-&gt;_irreducible = 1; // = true
3612         l = l-&gt;_parent;
3613         _has_irreducible_loops = true;
3614         // Check for bad CFG here to prevent crash, and bailout of compile
3615         if (l == NULL) {
3616           C-&gt;record_method_not_compilable(&quot;unhandled CFG detected during loop optimization&quot;);
3617           return pre_order;
3618         }
3619       }
3620       C-&gt;set_has_irreducible_loop(_has_irreducible_loops);
3621     }
3622 
3623     // This Node might be a decision point for loops.  It is only if
3624     // it&#39;s children belong to several different loops.  The sort call
3625     // does a trivial amount of work if there is only 1 child or all
3626     // children belong to the same loop.  If however, the children
3627     // belong to different loops, the sort call will properly set the
3628     // _parent pointers to show how the loops nest.
3629     //
3630     // In any case, it returns the tightest enclosing loop.
3631     innermost = sort( l, innermost );
3632   }
3633 
3634   // Def-use info will have some dead stuff; dead stuff will have no
3635   // loop decided on.
3636 
3637   // Am I a loop header?  If so fix up my parent&#39;s child and next ptrs.
3638   if( innermost &amp;&amp; innermost-&gt;_head == n ) {
3639     assert( get_loop(n) == innermost, &quot;&quot; );
3640     IdealLoopTree *p = innermost-&gt;_parent;
3641     IdealLoopTree *l = innermost;
3642     while( p &amp;&amp; l-&gt;_head == n ) {
3643       l-&gt;_next = p-&gt;_child;     // Put self on parents &#39;next child&#39;
3644       p-&gt;_child = l;            // Make self as first child of parent
3645       l = p;                    // Now walk up the parent chain
3646       p = l-&gt;_parent;
3647     }
3648   } else {
3649     // Note that it is possible for a LoopNode to reach here, if the
3650     // backedge has been made unreachable (hence the LoopNode no longer
3651     // denotes a Loop, and will eventually be removed).
3652 
3653     // Record tightest enclosing loop for self.  Mark as post-visited.
3654     set_loop(n, innermost);
3655     // Also record has_call flag early on
3656     if( innermost ) {
3657       if( n-&gt;is_Call() &amp;&amp; !n-&gt;is_CallLeaf() &amp;&amp; !n-&gt;is_macro() ) {
3658         // Do not count uncommon calls
3659         if( !n-&gt;is_CallStaticJava() || !n-&gt;as_CallStaticJava()-&gt;_name ) {
3660           Node *iff = n-&gt;in(0)-&gt;in(0);
3661           // No any calls for vectorized loops.
3662           if( UseSuperWord || !iff-&gt;is_If() ||
3663               (n-&gt;in(0)-&gt;Opcode() == Op_IfFalse &amp;&amp;
3664                (1.0 - iff-&gt;as_If()-&gt;_prob) &gt;= 0.01) ||
3665               (iff-&gt;as_If()-&gt;_prob &gt;= 0.01) )
3666             innermost-&gt;_has_call = 1;
3667         }
3668       } else if( n-&gt;is_Allocate() &amp;&amp; n-&gt;as_Allocate()-&gt;_is_scalar_replaceable ) {
3669         // Disable loop optimizations if the loop has a scalar replaceable
3670         // allocation. This disabling may cause a potential performance lost
3671         // if the allocation is not eliminated for some reason.
3672         innermost-&gt;_allow_optimizations = false;
3673         innermost-&gt;_has_call = 1; // = true
3674       } else if (n-&gt;Opcode() == Op_SafePoint) {
3675         // Record all safepoints in this loop.
3676         if (innermost-&gt;_safepts == NULL) innermost-&gt;_safepts = new Node_List();
3677         innermost-&gt;_safepts-&gt;push(n);
3678       }
3679     }
3680   }
3681 
3682   // Flag as post-visited now
3683   set_postvisited(n);
3684   return pre_order;
3685 }
3686 
3687 
3688 //------------------------------build_loop_early-------------------------------
3689 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
3690 // First pass computes the earliest controlling node possible.  This is the
3691 // controlling input with the deepest dominating depth.
3692 void PhaseIdealLoop::build_loop_early( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack ) {
3693   while (worklist.size() != 0) {
3694     // Use local variables nstack_top_n &amp; nstack_top_i to cache values
3695     // on nstack&#39;s top.
3696     Node *nstack_top_n = worklist.pop();
3697     uint  nstack_top_i = 0;
3698 //while_nstack_nonempty:
3699     while (true) {
3700       // Get parent node and next input&#39;s index from stack&#39;s top.
3701       Node  *n = nstack_top_n;
3702       uint   i = nstack_top_i;
3703       uint cnt = n-&gt;req(); // Count of inputs
3704       if (i == 0) {        // Pre-process the node.
3705         if( has_node(n) &amp;&amp;            // Have either loop or control already?
3706             !has_ctrl(n) ) {          // Have loop picked out already?
3707           // During &quot;merge_many_backedges&quot; we fold up several nested loops
3708           // into a single loop.  This makes the members of the original
3709           // loop bodies pointing to dead loops; they need to move up
3710           // to the new UNION&#39;d larger loop.  I set the _head field of these
3711           // dead loops to NULL and the _parent field points to the owning
3712           // loop.  Shades of UNION-FIND algorithm.
3713           IdealLoopTree *ilt;
3714           while( !(ilt = get_loop(n))-&gt;_head ) {
3715             // Normally I would use a set_loop here.  But in this one special
3716             // case, it is legal (and expected) to change what loop a Node
3717             // belongs to.
3718             _nodes.map(n-&gt;_idx, (Node*)(ilt-&gt;_parent) );
3719           }
3720           // Remove safepoints ONLY if I&#39;ve already seen I don&#39;t need one.
3721           // (the old code here would yank a 2nd safepoint after seeing a
3722           // first one, even though the 1st did not dominate in the loop body
3723           // and thus could be avoided indefinitely)
3724           if( !_verify_only &amp;&amp; !_verify_me &amp;&amp; ilt-&gt;_has_sfpt &amp;&amp; n-&gt;Opcode() == Op_SafePoint &amp;&amp;
3725               is_deleteable_safept(n)) {
3726             Node *in = n-&gt;in(TypeFunc::Control);
3727             lazy_replace(n,in);       // Pull safepoint now
3728             if (ilt-&gt;_safepts != NULL) {
3729               ilt-&gt;_safepts-&gt;yank(n);
3730             }
3731             // Carry on with the recursion &quot;as if&quot; we are walking
3732             // only the control input
3733             if( !visited.test_set( in-&gt;_idx ) ) {
3734               worklist.push(in);      // Visit this guy later, using worklist
3735             }
3736             // Get next node from nstack:
3737             // - skip n&#39;s inputs processing by setting i &gt; cnt;
3738             // - we also will not call set_early_ctrl(n) since
3739             //   has_node(n) == true (see the condition above).
3740             i = cnt + 1;
3741           }
3742         }
3743       } // if (i == 0)
3744 
3745       // Visit all inputs
3746       bool done = true;       // Assume all n&#39;s inputs will be processed
3747       while (i &lt; cnt) {
3748         Node *in = n-&gt;in(i);
3749         ++i;
3750         if (in == NULL) continue;
3751         if (in-&gt;pinned() &amp;&amp; !in-&gt;is_CFG())
3752           set_ctrl(in, in-&gt;in(0));
3753         int is_visited = visited.test_set( in-&gt;_idx );
3754         if (!has_node(in)) {  // No controlling input yet?
3755           assert( !in-&gt;is_CFG(), &quot;CFG Node with no controlling input?&quot; );
3756           assert( !is_visited, &quot;visit only once&quot; );
3757           nstack.push(n, i);  // Save parent node and next input&#39;s index.
3758           nstack_top_n = in;  // Process current input now.
3759           nstack_top_i = 0;
3760           done = false;       // Not all n&#39;s inputs processed.
3761           break; // continue while_nstack_nonempty;
3762         } else if (!is_visited) {
3763           // This guy has a location picked out for him, but has not yet
3764           // been visited.  Happens to all CFG nodes, for instance.
3765           // Visit him using the worklist instead of recursion, to break
3766           // cycles.  Since he has a location already we do not need to
3767           // find his location before proceeding with the current Node.
3768           worklist.push(in);  // Visit this guy later, using worklist
3769         }
3770       }
3771       if (done) {
3772         // All of n&#39;s inputs have been processed, complete post-processing.
3773 
3774         // Compute earliest point this Node can go.
3775         // CFG, Phi, pinned nodes already know their controlling input.
3776         if (!has_node(n)) {
3777           // Record earliest legal location
3778           set_early_ctrl( n );
3779         }
3780         if (nstack.is_empty()) {
3781           // Finished all nodes on stack.
3782           // Process next node on the worklist.
3783           break;
3784         }
3785         // Get saved parent node and next input&#39;s index.
3786         nstack_top_n = nstack.node();
3787         nstack_top_i = nstack.index();
3788         nstack.pop();
3789       }
3790     } // while (true)
3791   }
3792 }
3793 
3794 //------------------------------dom_lca_internal--------------------------------
3795 // Pair-wise LCA
3796 Node *PhaseIdealLoop::dom_lca_internal( Node *n1, Node *n2 ) const {
3797   if( !n1 ) return n2;          // Handle NULL original LCA
3798   assert( n1-&gt;is_CFG(), &quot;&quot; );
3799   assert( n2-&gt;is_CFG(), &quot;&quot; );
3800   // find LCA of all uses
3801   uint d1 = dom_depth(n1);
3802   uint d2 = dom_depth(n2);
3803   while (n1 != n2) {
3804     if (d1 &gt; d2) {
3805       n1 =      idom(n1);
3806       d1 = dom_depth(n1);
3807     } else if (d1 &lt; d2) {
3808       n2 =      idom(n2);
3809       d2 = dom_depth(n2);
3810     } else {
3811       // Here d1 == d2.  Due to edits of the dominator-tree, sections
3812       // of the tree might have the same depth.  These sections have
3813       // to be searched more carefully.
3814 
3815       // Scan up all the n1&#39;s with equal depth, looking for n2.
3816       Node *t1 = idom(n1);
3817       while (dom_depth(t1) == d1) {
3818         if (t1 == n2)  return n2;
3819         t1 = idom(t1);
3820       }
3821       // Scan up all the n2&#39;s with equal depth, looking for n1.
3822       Node *t2 = idom(n2);
3823       while (dom_depth(t2) == d2) {
3824         if (t2 == n1)  return n1;
3825         t2 = idom(t2);
3826       }
3827       // Move up to a new dominator-depth value as well as up the dom-tree.
3828       n1 = t1;
3829       n2 = t2;
3830       d1 = dom_depth(n1);
3831       d2 = dom_depth(n2);
3832     }
3833   }
3834   return n1;
3835 }
3836 
3837 //------------------------------compute_idom-----------------------------------
3838 // Locally compute IDOM using dom_lca call.  Correct only if the incoming
3839 // IDOMs are correct.
3840 Node *PhaseIdealLoop::compute_idom( Node *region ) const {
3841   assert( region-&gt;is_Region(), &quot;&quot; );
3842   Node *LCA = NULL;
3843   for( uint i = 1; i &lt; region-&gt;req(); i++ ) {
3844     if( region-&gt;in(i) != C-&gt;top() )
3845       LCA = dom_lca( LCA, region-&gt;in(i) );
3846   }
3847   return LCA;
3848 }
3849 
3850 bool PhaseIdealLoop::verify_dominance(Node* n, Node* use, Node* LCA, Node* early) {
3851   bool had_error = false;
3852 #ifdef ASSERT
3853   if (early != C-&gt;root()) {
3854     // Make sure that there&#39;s a dominance path from LCA to early
3855     Node* d = LCA;
3856     while (d != early) {
3857       if (d == C-&gt;root()) {
3858         dump_bad_graph(&quot;Bad graph detected in compute_lca_of_uses&quot;, n, early, LCA);
3859         tty-&gt;print_cr(&quot;*** Use %d isn&#39;t dominated by def %d ***&quot;, use-&gt;_idx, n-&gt;_idx);
3860         had_error = true;
3861         break;
3862       }
3863       d = idom(d);
3864     }
3865   }
3866 #endif
3867   return had_error;
3868 }
3869 
3870 
3871 Node* PhaseIdealLoop::compute_lca_of_uses(Node* n, Node* early, bool verify) {
3872   // Compute LCA over list of uses
3873   bool had_error = false;
3874   Node *LCA = NULL;
3875   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; LCA != early; i++) {
3876     Node* c = n-&gt;fast_out(i);
3877     if (_nodes[c-&gt;_idx] == NULL)
3878       continue;                 // Skip the occasional dead node
3879     if( c-&gt;is_Phi() ) {         // For Phis, we must land above on the path
3880       for( uint j=1; j&lt;c-&gt;req(); j++ ) {// For all inputs
3881         if( c-&gt;in(j) == n ) {   // Found matching input?
3882           Node *use = c-&gt;in(0)-&gt;in(j);
3883           if (_verify_only &amp;&amp; use-&gt;is_top()) continue;
3884           LCA = dom_lca_for_get_late_ctrl( LCA, use, n );
3885           if (verify) had_error = verify_dominance(n, use, LCA, early) || had_error;
3886         }
3887       }
3888     } else {
3889       // For CFG data-users, use is in the block just prior
3890       Node *use = has_ctrl(c) ? get_ctrl(c) : c-&gt;in(0);
3891       LCA = dom_lca_for_get_late_ctrl( LCA, use, n );
3892       if (verify) had_error = verify_dominance(n, use, LCA, early) || had_error;
3893     }
3894   }
3895   assert(!had_error, &quot;bad dominance&quot;);
3896   return LCA;
3897 }
3898 
3899 // Check the shape of the graph at the loop entry. In some cases,
3900 // the shape of the graph does not match the shape outlined below.
3901 // That is caused by the Opaque1 node &quot;protecting&quot; the shape of
3902 // the graph being removed by, for example, the IGVN performed
3903 // in PhaseIdealLoop::build_and_optimize().
3904 //
3905 // After the Opaque1 node has been removed, optimizations (e.g., split-if,
3906 // loop unswitching, and IGVN, or a combination of them) can freely change
3907 // the graph&#39;s shape. As a result, the graph shape outlined below cannot
3908 // be guaranteed anymore.
3909 bool PhaseIdealLoop::is_canonical_loop_entry(CountedLoopNode* cl) {
3910   if (!cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop()) {
3911     return false;
3912   }
3913   Node* ctrl = cl-&gt;skip_predicates();
3914 
3915   if (ctrl == NULL || (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse())) {
3916     return false;
3917   }
3918   Node* iffm = ctrl-&gt;in(0);
3919   if (iffm == NULL || !iffm-&gt;is_If()) {
3920     return false;
3921   }
3922   Node* bolzm = iffm-&gt;in(1);
3923   if (bolzm == NULL || !bolzm-&gt;is_Bool()) {
3924     return false;
3925   }
3926   Node* cmpzm = bolzm-&gt;in(1);
3927   if (cmpzm == NULL || !cmpzm-&gt;is_Cmp()) {
3928     return false;
3929   }
3930   // compares can get conditionally flipped
3931   bool found_opaque = false;
3932   for (uint i = 1; i &lt; cmpzm-&gt;req(); i++) {
3933     Node* opnd = cmpzm-&gt;in(i);
3934     if (opnd &amp;&amp; opnd-&gt;Opcode() == Op_Opaque1) {
3935       found_opaque = true;
3936       break;
3937     }
3938   }
3939   if (!found_opaque) {
3940     return false;
3941   }
3942   return true;
3943 }
3944 
3945 //------------------------------get_late_ctrl----------------------------------
3946 // Compute latest legal control.
3947 Node *PhaseIdealLoop::get_late_ctrl( Node *n, Node *early ) {
3948   assert(early != NULL, &quot;early control should not be NULL&quot;);
3949 
3950   Node* LCA = compute_lca_of_uses(n, early);
3951 #ifdef ASSERT
3952   if (LCA == C-&gt;root() &amp;&amp; LCA != early) {
3953     // def doesn&#39;t dominate uses so print some useful debugging output
3954     compute_lca_of_uses(n, early, true);
3955   }
3956 #endif
3957 
3958   // if this is a load, check for anti-dependent stores
3959   // We use a conservative algorithm to identify potential interfering
3960   // instructions and for rescheduling the load.  The users of the memory
3961   // input of this load are examined.  Any use which is not a load and is
3962   // dominated by early is considered a potentially interfering store.
3963   // This can produce false positives.
3964   if (n-&gt;is_Load() &amp;&amp; LCA != early) {
<a name="36" id="anc36"></a><span class="line-modified">3965     Node_List worklist;</span>

3966 
<a name="37" id="anc37"></a><span class="line-modified">3967     Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="line-modified">3968     for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">3969       Node* s = mem-&gt;fast_out(i);</span>
<span class="line-modified">3970       worklist.push(s);</span>
<span class="line-modified">3971     }</span>
<span class="line-modified">3972     while(worklist.size() != 0 &amp;&amp; LCA != early) {</span>
<span class="line-modified">3973       Node* s = worklist.pop();</span>
<span class="line-modified">3974       if (s-&gt;is_Load() || s-&gt;is_ShenandoahBarrier() || s-&gt;Opcode() == Op_SafePoint ||</span>
<span class="line-modified">3975           (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {</span>
<span class="line-modified">3976         continue;</span>
<span class="line-modified">3977       } else if (s-&gt;is_MergeMem()) {</span>
<span class="line-modified">3978         for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">3979           Node* s1 = s-&gt;fast_out(i);</span>
<span class="line-modified">3980           worklist.push(s1);</span>
<span class="line-modified">3981         }</span>
<span class="line-modified">3982       } else {</span>
<span class="line-modified">3983         Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);</span>
<span class="line-modified">3984         assert(sctrl != NULL || s-&gt;outcnt() == 0, &quot;must have control&quot;);</span>
<span class="line-modified">3985         if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; is_dominator(early, sctrl)) {</span>
<span class="line-modified">3986           LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);</span>



3987         }
3988       }
3989     }
3990   }
3991 
3992   assert(LCA == find_non_split_ctrl(LCA), &quot;unexpected late control&quot;);
3993   return LCA;
3994 }
3995 
3996 // true if CFG node d dominates CFG node n
3997 bool PhaseIdealLoop::is_dominator(Node *d, Node *n) {
3998   if (d == n)
3999     return true;
4000   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
4001   uint dd = dom_depth(d);
4002   while (dom_depth(n) &gt;= dd) {
4003     if (n == d)
4004       return true;
4005     n = idom(n);
4006   }
4007   return false;
4008 }
4009 
4010 //------------------------------dom_lca_for_get_late_ctrl_internal-------------
4011 // Pair-wise LCA with tags.
4012 // Tag each index with the node &#39;tag&#39; currently being processed
4013 // before advancing up the dominator chain using idom().
4014 // Later calls that find a match to &#39;tag&#39; know that this path has already
4015 // been considered in the current LCA (which is input &#39;n1&#39; by convention).
4016 // Since get_late_ctrl() is only called once for each node, the tag array
4017 // does not need to be cleared between calls to get_late_ctrl().
4018 // Algorithm trades a larger constant factor for better asymptotic behavior
4019 //
4020 Node *PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal( Node *n1, Node *n2, Node *tag ) {
4021   uint d1 = dom_depth(n1);
4022   uint d2 = dom_depth(n2);
4023 
4024   do {
4025     if (d1 &gt; d2) {
4026       // current lca is deeper than n2
4027       _dom_lca_tags.map(n1-&gt;_idx, tag);
4028       n1 =      idom(n1);
4029       d1 = dom_depth(n1);
4030     } else if (d1 &lt; d2) {
4031       // n2 is deeper than current lca
4032       Node *memo = _dom_lca_tags[n2-&gt;_idx];
4033       if( memo == tag ) {
4034         return n1;    // Return the current LCA
4035       }
4036       _dom_lca_tags.map(n2-&gt;_idx, tag);
4037       n2 =      idom(n2);
4038       d2 = dom_depth(n2);
4039     } else {
4040       // Here d1 == d2.  Due to edits of the dominator-tree, sections
4041       // of the tree might have the same depth.  These sections have
4042       // to be searched more carefully.
4043 
4044       // Scan up all the n1&#39;s with equal depth, looking for n2.
4045       _dom_lca_tags.map(n1-&gt;_idx, tag);
4046       Node *t1 = idom(n1);
4047       while (dom_depth(t1) == d1) {
4048         if (t1 == n2)  return n2;
4049         _dom_lca_tags.map(t1-&gt;_idx, tag);
4050         t1 = idom(t1);
4051       }
4052       // Scan up all the n2&#39;s with equal depth, looking for n1.
4053       _dom_lca_tags.map(n2-&gt;_idx, tag);
4054       Node *t2 = idom(n2);
4055       while (dom_depth(t2) == d2) {
4056         if (t2 == n1)  return n1;
4057         _dom_lca_tags.map(t2-&gt;_idx, tag);
4058         t2 = idom(t2);
4059       }
4060       // Move up to a new dominator-depth value as well as up the dom-tree.
4061       n1 = t1;
4062       n2 = t2;
4063       d1 = dom_depth(n1);
4064       d2 = dom_depth(n2);
4065     }
4066   } while (n1 != n2);
4067   return n1;
4068 }
4069 
4070 //------------------------------init_dom_lca_tags------------------------------
4071 // Tag could be a node&#39;s integer index, 32bits instead of 64bits in some cases
4072 // Intended use does not involve any growth for the array, so it could
4073 // be of fixed size.
4074 void PhaseIdealLoop::init_dom_lca_tags() {
4075   uint limit = C-&gt;unique() + 1;
4076   _dom_lca_tags.map( limit, NULL );
4077 #ifdef ASSERT
4078   for( uint i = 0; i &lt; limit; ++i ) {
4079     assert(_dom_lca_tags[i] == NULL, &quot;Must be distinct from each node pointer&quot;);
4080   }
4081 #endif // ASSERT
4082 }
4083 
4084 //------------------------------clear_dom_lca_tags------------------------------
4085 // Tag could be a node&#39;s integer index, 32bits instead of 64bits in some cases
4086 // Intended use does not involve any growth for the array, so it could
4087 // be of fixed size.
4088 void PhaseIdealLoop::clear_dom_lca_tags() {
4089   uint limit = C-&gt;unique() + 1;
4090   _dom_lca_tags.map( limit, NULL );
4091   _dom_lca_tags.clear();
4092 #ifdef ASSERT
4093   for( uint i = 0; i &lt; limit; ++i ) {
4094     assert(_dom_lca_tags[i] == NULL, &quot;Must be distinct from each node pointer&quot;);
4095   }
4096 #endif // ASSERT
4097 }
4098 
4099 //------------------------------build_loop_late--------------------------------
4100 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4101 // Second pass finds latest legal placement, and ideal loop placement.
4102 void PhaseIdealLoop::build_loop_late( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack ) {
4103   while (worklist.size() != 0) {
4104     Node *n = worklist.pop();
4105     // Only visit once
4106     if (visited.test_set(n-&gt;_idx)) continue;
4107     uint cnt = n-&gt;outcnt();
4108     uint   i = 0;
4109     while (true) {
4110       assert( _nodes[n-&gt;_idx], &quot;no dead nodes&quot; );
4111       // Visit all children
4112       if (i &lt; cnt) {
4113         Node* use = n-&gt;raw_out(i);
4114         ++i;
4115         // Check for dead uses.  Aggressively prune such junk.  It might be
4116         // dead in the global sense, but still have local uses so I cannot
4117         // easily call &#39;remove_dead_node&#39;.
4118         if( _nodes[use-&gt;_idx] != NULL || use-&gt;is_top() ) { // Not dead?
4119           // Due to cycles, we might not hit the same fixed point in the verify
4120           // pass as we do in the regular pass.  Instead, visit such phis as
4121           // simple uses of the loop head.
4122           if( use-&gt;in(0) &amp;&amp; (use-&gt;is_CFG() || use-&gt;is_Phi()) ) {
4123             if( !visited.test(use-&gt;_idx) )
4124               worklist.push(use);
4125           } else if( !visited.test_set(use-&gt;_idx) ) {
4126             nstack.push(n, i); // Save parent and next use&#39;s index.
4127             n   = use;         // Process all children of current use.
4128             cnt = use-&gt;outcnt();
4129             i   = 0;
4130           }
4131         } else {
4132           // Do not visit around the backedge of loops via data edges.
4133           // push dead code onto a worklist
4134           _deadlist.push(use);
4135         }
4136       } else {
4137         // All of n&#39;s children have been processed, complete post-processing.
4138         build_loop_late_post(n);
4139         if (nstack.is_empty()) {
4140           // Finished all nodes on stack.
4141           // Process next node on the worklist.
4142           break;
4143         }
4144         // Get saved parent node and next use&#39;s index. Visit the rest of uses.
4145         n   = nstack.node();
4146         cnt = n-&gt;outcnt();
4147         i   = nstack.index();
4148         nstack.pop();
4149       }
4150     }
4151   }
4152 }
4153 
4154 // Verify that no data node is scheduled in the outer loop of a strip
4155 // mined loop.
4156 void PhaseIdealLoop::verify_strip_mined_scheduling(Node *n, Node* least) {
4157 #ifdef ASSERT
4158   if (get_loop(least)-&gt;_nest == 0) {
4159     return;
4160   }
4161   IdealLoopTree* loop = get_loop(least);
4162   Node* head = loop-&gt;_head;
4163   if (head-&gt;is_OuterStripMinedLoop() &amp;&amp;
4164       // Verification can&#39;t be applied to fully built strip mined loops
4165       head-&gt;as_Loop()-&gt;outer_loop_end()-&gt;in(1)-&gt;find_int_con(-1) == 0) {
4166     Node* sfpt = head-&gt;as_Loop()-&gt;outer_safepoint();
4167     ResourceMark rm;
4168     Unique_Node_List wq;
4169     wq.push(sfpt);
4170     for (uint i = 0; i &lt; wq.size(); i++) {
4171       Node *m = wq.at(i);
4172       for (uint i = 1; i &lt; m-&gt;req(); i++) {
4173         Node* nn = m-&gt;in(i);
4174         if (nn == n) {
4175           return;
4176         }
4177         if (nn != NULL &amp;&amp; has_ctrl(nn) &amp;&amp; get_loop(get_ctrl(nn)) == loop) {
4178           wq.push(nn);
4179         }
4180       }
4181     }
4182     ShouldNotReachHere();
4183   }
4184 #endif
4185 }
4186 
4187 
4188 //------------------------------build_loop_late_post---------------------------
4189 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4190 // Second pass finds latest legal placement, and ideal loop placement.
4191 void PhaseIdealLoop::build_loop_late_post(Node *n) {
<a name="38" id="anc38"></a><span class="line-removed">4192   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">4193 </span>
<span class="line-removed">4194   if (bs-&gt;build_loop_late_post(this, n)) {</span>
<span class="line-removed">4195     return;</span>
<span class="line-removed">4196   }</span>
<span class="line-removed">4197 </span>
4198   build_loop_late_post_work(n, true);
4199 }
4200 
4201 void PhaseIdealLoop::build_loop_late_post_work(Node *n, bool pinned) {
4202 
4203   if (n-&gt;req() == 2 &amp;&amp; (n-&gt;Opcode() == Op_ConvI2L || n-&gt;Opcode() == Op_CastII) &amp;&amp; !C-&gt;major_progress() &amp;&amp; !_verify_only) {
4204     _igvn._worklist.push(n);  // Maybe we&#39;ll normalize it, if no more loops.
4205   }
4206 
4207 #ifdef ASSERT
4208   if (_verify_only &amp;&amp; !n-&gt;is_CFG()) {
4209     // Check def-use domination.
4210     compute_lca_of_uses(n, get_ctrl(n), true /* verify */);
4211   }
4212 #endif
4213 
4214   // CFG and pinned nodes already handled
4215   if( n-&gt;in(0) ) {
4216     if( n-&gt;in(0)-&gt;is_top() ) return; // Dead?
4217 
4218     // We&#39;d like +VerifyLoopOptimizations to not believe that Mod&#39;s/Loads
4219     // _must_ be pinned (they have to observe their control edge of course).
4220     // Unlike Stores (which modify an unallocable resource, the memory
4221     // state), Mods/Loads can float around.  So free them up.
4222     switch( n-&gt;Opcode() ) {
4223     case Op_DivI:
4224     case Op_DivF:
4225     case Op_DivD:
4226     case Op_ModI:
4227     case Op_ModF:
4228     case Op_ModD:
4229     case Op_LoadB:              // Same with Loads; they can sink
4230     case Op_LoadUB:             // during loop optimizations.
4231     case Op_LoadUS:
4232     case Op_LoadD:
4233     case Op_LoadF:
4234     case Op_LoadI:
4235     case Op_LoadKlass:
4236     case Op_LoadNKlass:
4237     case Op_LoadL:
4238     case Op_LoadS:
4239     case Op_LoadP:
<a name="39" id="anc39"></a><span class="line-removed">4240     case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">4241     case Op_LoadBarrierWeakSlowReg:</span>
4242     case Op_LoadN:
4243     case Op_LoadRange:
4244     case Op_LoadD_unaligned:
4245     case Op_LoadL_unaligned:
4246     case Op_StrComp:            // Does a bunch of load-like effects
4247     case Op_StrEquals:
4248     case Op_StrIndexOf:
4249     case Op_StrIndexOfChar:
4250     case Op_AryEq:
4251     case Op_HasNegatives:
4252       pinned = false;
4253     }
<a name="40" id="anc40"></a>


4254     if( pinned ) {
4255       IdealLoopTree *chosen_loop = get_loop(n-&gt;is_CFG() ? n : get_ctrl(n));
4256       if( !chosen_loop-&gt;_child )       // Inner loop?
4257         chosen_loop-&gt;_body.push(n); // Collect inner loops
4258       return;
4259     }
4260   } else {                      // No slot zero
4261     if( n-&gt;is_CFG() ) {         // CFG with no slot 0 is dead
4262       _nodes.map(n-&gt;_idx,0);    // No block setting, it&#39;s globally dead
4263       return;
4264     }
4265     assert(!n-&gt;is_CFG() || n-&gt;outcnt() == 0, &quot;&quot;);
4266   }
4267 
4268   // Do I have a &quot;safe range&quot; I can select over?
4269   Node *early = get_ctrl(n);// Early location already computed
4270 
4271   // Compute latest point this Node can go
4272   Node *LCA = get_late_ctrl( n, early );
4273   // LCA is NULL due to uses being dead
4274   if( LCA == NULL ) {
4275 #ifdef ASSERT
4276     for (DUIterator i1 = n-&gt;outs(); n-&gt;has_out(i1); i1++) {
4277       assert( _nodes[n-&gt;out(i1)-&gt;_idx] == NULL, &quot;all uses must also be dead&quot;);
4278     }
4279 #endif
4280     _nodes.map(n-&gt;_idx, 0);     // This node is useless
4281     _deadlist.push(n);
4282     return;
4283   }
4284   assert(LCA != NULL &amp;&amp; !LCA-&gt;is_top(), &quot;no dead nodes&quot;);
4285 
4286   Node *legal = LCA;            // Walk &#39;legal&#39; up the IDOM chain
4287   Node *least = legal;          // Best legal position so far
4288   while( early != legal ) {     // While not at earliest legal
4289 #ifdef ASSERT
4290     if (legal-&gt;is_Start() &amp;&amp; !early-&gt;is_Root()) {
4291       // Bad graph. Print idom path and fail.
4292       dump_bad_graph(&quot;Bad graph detected in build_loop_late&quot;, n, early, LCA);
4293       assert(false, &quot;Bad graph detected in build_loop_late&quot;);
4294     }
4295 #endif
4296     // Find least loop nesting depth
4297     legal = idom(legal);        // Bump up the IDOM tree
4298     // Check for lower nesting depth
4299     if( get_loop(legal)-&gt;_nest &lt; get_loop(least)-&gt;_nest )
4300       least = legal;
4301   }
4302   assert(early == legal || legal != C-&gt;root(), &quot;bad dominance of inputs&quot;);
4303 
4304   // Try not to place code on a loop entry projection
4305   // which can inhibit range check elimination.
4306   if (least != early) {
4307     Node* ctrl_out = least-&gt;unique_ctrl_out();
4308     if (ctrl_out &amp;&amp; ctrl_out-&gt;is_Loop() &amp;&amp;
4309         least == ctrl_out-&gt;in(LoopNode::EntryControl)) {
4310       // Move the node above predicates as far up as possible so a
4311       // following pass of loop predication doesn&#39;t hoist a predicate
4312       // that depends on it above that node.
4313       Node* new_ctrl = least;
4314       for (;;) {
4315         if (!new_ctrl-&gt;is_Proj()) {
4316           break;
4317         }
4318         CallStaticJavaNode* call = new_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
4319         if (call == NULL) {
4320           break;
4321         }
4322         int req = call-&gt;uncommon_trap_request();
4323         Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);
4324         if (trap_reason != Deoptimization::Reason_loop_limit_check &amp;&amp;
4325             trap_reason != Deoptimization::Reason_predicate &amp;&amp;
4326             trap_reason != Deoptimization::Reason_profile_predicate) {
4327           break;
4328         }
4329         Node* c = new_ctrl-&gt;in(0)-&gt;in(0);
4330         if (is_dominator(c, early) &amp;&amp; c != early) {
4331           break;
4332         }
4333         new_ctrl = c;
4334       }
4335       least = new_ctrl;
4336     }
4337   }
4338 
4339 #ifdef ASSERT
4340   // If verifying, verify that &#39;verify_me&#39; has a legal location
4341   // and choose it as our location.
4342   if( _verify_me ) {
4343     Node *v_ctrl = _verify_me-&gt;get_ctrl_no_update(n);
4344     Node *legal = LCA;
4345     while( early != legal ) {   // While not at earliest legal
4346       if( legal == v_ctrl ) break;  // Check for prior good location
4347       legal = idom(legal)      ;// Bump up the IDOM tree
4348     }
4349     // Check for prior good location
4350     if( legal == v_ctrl ) least = legal; // Keep prior if found
4351   }
4352 #endif
4353 
4354   // Assign discovered &quot;here or above&quot; point
4355   least = find_non_split_ctrl(least);
4356   verify_strip_mined_scheduling(n, least);
4357   set_ctrl(n, least);
4358 
4359   // Collect inner loop bodies
4360   IdealLoopTree *chosen_loop = get_loop(least);
4361   if( !chosen_loop-&gt;_child )   // Inner loop?
4362     chosen_loop-&gt;_body.push(n);// Collect inner loops
4363 }
4364 
4365 #ifdef ASSERT
4366 void PhaseIdealLoop::dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA) {
4367   tty-&gt;print_cr(&quot;%s&quot;, msg);
4368   tty-&gt;print(&quot;n: &quot;); n-&gt;dump();
4369   tty-&gt;print(&quot;early(n): &quot;); early-&gt;dump();
4370   if (n-&gt;in(0) != NULL  &amp;&amp; !n-&gt;in(0)-&gt;is_top() &amp;&amp;
4371       n-&gt;in(0) != early &amp;&amp; !n-&gt;in(0)-&gt;is_Root()) {
4372     tty-&gt;print(&quot;n-&gt;in(0): &quot;); n-&gt;in(0)-&gt;dump();
4373   }
4374   for (uint i = 1; i &lt; n-&gt;req(); i++) {
4375     Node* in1 = n-&gt;in(i);
4376     if (in1 != NULL &amp;&amp; in1 != n &amp;&amp; !in1-&gt;is_top()) {
4377       tty-&gt;print(&quot;n-&gt;in(%d): &quot;, i); in1-&gt;dump();
4378       Node* in1_early = get_ctrl(in1);
4379       tty-&gt;print(&quot;early(n-&gt;in(%d)): &quot;, i); in1_early-&gt;dump();
4380       if (in1-&gt;in(0) != NULL     &amp;&amp; !in1-&gt;in(0)-&gt;is_top() &amp;&amp;
4381           in1-&gt;in(0) != in1_early &amp;&amp; !in1-&gt;in(0)-&gt;is_Root()) {
4382         tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(0): &quot;, i); in1-&gt;in(0)-&gt;dump();
4383       }
4384       for (uint j = 1; j &lt; in1-&gt;req(); j++) {
4385         Node* in2 = in1-&gt;in(j);
4386         if (in2 != NULL &amp;&amp; in2 != n &amp;&amp; in2 != in1 &amp;&amp; !in2-&gt;is_top()) {
4387           tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(%d): &quot;, i, j); in2-&gt;dump();
4388           Node* in2_early = get_ctrl(in2);
4389           tty-&gt;print(&quot;early(n-&gt;in(%d)-&gt;in(%d)): &quot;, i, j); in2_early-&gt;dump();
4390           if (in2-&gt;in(0) != NULL     &amp;&amp; !in2-&gt;in(0)-&gt;is_top() &amp;&amp;
4391               in2-&gt;in(0) != in2_early &amp;&amp; !in2-&gt;in(0)-&gt;is_Root()) {
4392             tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(%d)-&gt;in(0): &quot;, i, j); in2-&gt;in(0)-&gt;dump();
4393           }
4394         }
4395       }
4396     }
4397   }
4398   tty-&gt;cr();
4399   tty-&gt;print(&quot;LCA(n): &quot;); LCA-&gt;dump();
4400   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
4401     Node* u1 = n-&gt;raw_out(i);
4402     if (u1 == n)
4403       continue;
4404     tty-&gt;print(&quot;n-&gt;out(%d): &quot;, i); u1-&gt;dump();
4405     if (u1-&gt;is_CFG()) {
4406       for (uint j = 0; j &lt; u1-&gt;outcnt(); j++) {
4407         Node* u2 = u1-&gt;raw_out(j);
4408         if (u2 != u1 &amp;&amp; u2 != n &amp;&amp; u2-&gt;is_CFG()) {
4409           tty-&gt;print(&quot;n-&gt;out(%d)-&gt;out(%d): &quot;, i, j); u2-&gt;dump();
4410         }
4411       }
4412     } else {
4413       Node* u1_later = get_ctrl(u1);
4414       tty-&gt;print(&quot;later(n-&gt;out(%d)): &quot;, i); u1_later-&gt;dump();
4415       if (u1-&gt;in(0) != NULL     &amp;&amp; !u1-&gt;in(0)-&gt;is_top() &amp;&amp;
4416           u1-&gt;in(0) != u1_later &amp;&amp; !u1-&gt;in(0)-&gt;is_Root()) {
4417         tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u1-&gt;in(0)-&gt;dump();
4418       }
4419       for (uint j = 0; j &lt; u1-&gt;outcnt(); j++) {
4420         Node* u2 = u1-&gt;raw_out(j);
4421         if (u2 == n || u2 == u1)
4422           continue;
4423         tty-&gt;print(&quot;n-&gt;out(%d)-&gt;out(%d): &quot;, i, j); u2-&gt;dump();
4424         if (!u2-&gt;is_CFG()) {
4425           Node* u2_later = get_ctrl(u2);
4426           tty-&gt;print(&quot;later(n-&gt;out(%d)-&gt;out(%d)): &quot;, i, j); u2_later-&gt;dump();
4427           if (u2-&gt;in(0) != NULL     &amp;&amp; !u2-&gt;in(0)-&gt;is_top() &amp;&amp;
4428               u2-&gt;in(0) != u2_later &amp;&amp; !u2-&gt;in(0)-&gt;is_Root()) {
4429             tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u2-&gt;in(0)-&gt;dump();
4430           }
4431         }
4432       }
4433     }
4434   }
4435   tty-&gt;cr();
4436   int ct = 0;
4437   Node *dbg_legal = LCA;
4438   while(!dbg_legal-&gt;is_Start() &amp;&amp; ct &lt; 100) {
4439     tty-&gt;print(&quot;idom[%d] &quot;,ct); dbg_legal-&gt;dump();
4440     ct++;
4441     dbg_legal = idom(dbg_legal);
4442   }
4443   tty-&gt;cr();
4444 }
4445 #endif
4446 
4447 #ifndef PRODUCT
4448 //------------------------------dump-------------------------------------------
<a name="41" id="anc41"></a><span class="line-modified">4449 void PhaseIdealLoop::dump( ) const {</span>
4450   ResourceMark rm;
4451   Arena* arena = Thread::current()-&gt;resource_area();
4452   Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
4453   Node_List rpo_list;
4454   VectorSet visited(arena);
4455   visited.set(C-&gt;top()-&gt;_idx);
<a name="42" id="anc42"></a><span class="line-modified">4456   rpo( C-&gt;root(), stack, visited, rpo_list );</span>
4457   // Dump root loop indexed by last element in PO order
<a name="43" id="anc43"></a><span class="line-modified">4458   dump( _ltree_root, rpo_list.size(), rpo_list );</span>
4459 }
4460 
<a name="44" id="anc44"></a><span class="line-modified">4461 void PhaseIdealLoop::dump( IdealLoopTree *loop, uint idx, Node_List &amp;rpo_list ) const {</span>
4462   loop-&gt;dump_head();
4463 
4464   // Now scan for CFG nodes in the same loop
<a name="45" id="anc45"></a><span class="line-modified">4465   for( uint j=idx; j &gt; 0;  j-- ) {</span>
<span class="line-modified">4466     Node *n = rpo_list[j-1];</span>
<span class="line-modified">4467     if( !_nodes[n-&gt;_idx] )      // Skip dead nodes</span>
4468       continue;
<a name="46" id="anc46"></a><span class="line-modified">4469     if( get_loop(n) != loop ) { // Wrong loop nest</span>
<span class="line-modified">4470       if( get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?</span>
<span class="line-modified">4471           get_loop(n)-&gt;_parent == loop )</span>
<span class="line-modified">4472         dump(get_loop(n),rpo_list.size(),rpo_list);     // Print it nested-ly</span>

4473       continue;
4474     }
4475 
4476     // Dump controlling node
<a name="47" id="anc47"></a><span class="line-modified">4477     for( uint x = 0; x &lt; loop-&gt;_nest; x++ )</span>
<span class="line-removed">4478       tty-&gt;print(&quot;  &quot;);</span>
4479     tty-&gt;print(&quot;C&quot;);
<a name="48" id="anc48"></a><span class="line-modified">4480     if( n == C-&gt;root() ) {</span>
4481       n-&gt;dump();
4482     } else {
4483       Node* cached_idom   = idom_no_update(n);
<a name="49" id="anc49"></a><span class="line-modified">4484       Node *computed_idom = n-&gt;in(0);</span>
<span class="line-modified">4485       if( n-&gt;is_Region() ) {</span>
4486         computed_idom = compute_idom(n);
4487         // computed_idom() will return n-&gt;in(0) when idom(n) is an IfNode (or
4488         // any MultiBranch ctrl node), so apply a similar transform to
4489         // the cached idom returned from idom_no_update.
4490         cached_idom = find_non_split_ctrl(cached_idom);
4491       }
<a name="50" id="anc50"></a><span class="line-modified">4492       tty-&gt;print(&quot; ID:%d&quot;,computed_idom-&gt;_idx);</span>
4493       n-&gt;dump();
<a name="51" id="anc51"></a><span class="line-modified">4494       if( cached_idom != computed_idom ) {</span>
4495         tty-&gt;print_cr(&quot;*** BROKEN IDOM!  Computed as: %d, cached as: %d&quot;,
4496                       computed_idom-&gt;_idx, cached_idom-&gt;_idx);
4497       }
4498     }
4499     // Dump nodes it controls
<a name="52" id="anc52"></a><span class="line-modified">4500     for( uint k = 0; k &lt; _nodes.Size(); k++ ) {</span>
4501       // (k &lt; C-&gt;unique() &amp;&amp; get_ctrl(find(k)) == n)
4502       if (k &lt; C-&gt;unique() &amp;&amp; _nodes[k] == (Node*)((intptr_t)n + 1)) {
<a name="53" id="anc53"></a><span class="line-modified">4503         Node *m = C-&gt;root()-&gt;find(k);</span>
<span class="line-modified">4504         if( m &amp;&amp; m-&gt;outcnt() &gt; 0 ) {</span>
4505           if (!(has_ctrl(m) &amp;&amp; get_ctrl_no_update(m) == n)) {
4506             tty-&gt;print_cr(&quot;*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p&quot;,
4507                           _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);
4508           }
<a name="54" id="anc54"></a><span class="line-modified">4509           for( uint j = 0; j &lt; loop-&gt;_nest; j++ )</span>
<span class="line-removed">4510             tty-&gt;print(&quot;  &quot;);</span>
<span class="line-removed">4511           tty-&gt;print(&quot; &quot;);</span>
4512           m-&gt;dump();
4513         }
4514       }
4515     }
4516   }
4517 }
4518 #endif
4519 
4520 // Collect a R-P-O for the whole CFG.
4521 // Result list is in post-order (scan backwards for RPO)
<a name="55" id="anc55"></a><span class="line-modified">4522 void PhaseIdealLoop::rpo( Node *start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list ) const {</span>
4523   stk.push(start, 0);
4524   visited.set(start-&gt;_idx);
4525 
4526   while (stk.is_nonempty()) {
4527     Node* m   = stk.node();
4528     uint  idx = stk.index();
4529     if (idx &lt; m-&gt;outcnt()) {
4530       stk.set_index(idx + 1);
4531       Node* n = m-&gt;raw_out(idx);
4532       if (n-&gt;is_CFG() &amp;&amp; !visited.test_set(n-&gt;_idx)) {
4533         stk.push(n, 0);
4534       }
4535     } else {
4536       rpo_list.push(m);
4537       stk.pop();
4538     }
4539   }
4540 }
4541 
4542 
4543 //=============================================================================
<a name="56" id="anc56"></a><span class="line-modified">4544 //------------------------------LoopTreeIterator-----------------------------------</span>
4545 
4546 // Advance to next loop tree using a preorder, left-to-right traversal.
4547 void LoopTreeIterator::next() {
4548   assert(!done(), &quot;must not be done.&quot;);
4549   if (_curnt-&gt;_child != NULL) {
4550     _curnt = _curnt-&gt;_child;
4551   } else if (_curnt-&gt;_next != NULL) {
4552     _curnt = _curnt-&gt;_next;
4553   } else {
4554     while (_curnt != _root &amp;&amp; _curnt-&gt;_next == NULL) {
4555       _curnt = _curnt-&gt;_parent;
4556     }
4557     if (_curnt == _root) {
4558       _curnt = NULL;
4559       assert(done(), &quot;must be done.&quot;);
4560     } else {
4561       assert(_curnt-&gt;_next != NULL, &quot;must be more to do&quot;);
4562       _curnt = _curnt-&gt;_next;
4563     }
4564   }
4565 }
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>
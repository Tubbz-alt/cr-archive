<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cfgnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/chaitin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1152 
1153   while( 1 ) {                  // Repeat till simplified it all
1154     // May want to explore simplifying lo_degree before _lo_stk_degree.
1155     // This might result in more spills coloring into registers during
1156     // Select().
1157     while( _lo_degree || _lo_stk_degree ) {
1158       // If possible, pull from lo_stk first
1159       uint lo;
1160       if( _lo_degree ) {
1161         lo = _lo_degree;
1162         _lo_degree = lrgs(lo)._next;
1163       } else {
1164         lo = _lo_stk_degree;
1165         _lo_stk_degree = lrgs(lo)._next;
1166       }
1167 
1168       // Put the simplified guy on the simplified list.
1169       lrgs(lo)._next = _simplified;
1170       _simplified = lo;
1171       // If this guy is &quot;at risk&quot; then mark his current neighbors
<span class="line-modified">1172       if( lrgs(lo)._at_risk ) {</span>
1173         IndexSetIterator elements(_ifg-&gt;neighbors(lo));
1174         uint datum;
1175         while ((datum = elements.next()) != 0) {
1176           lrgs(datum)._risk_bias = lo;
1177         }
1178       }
1179 
1180       // Yank this guy from the IFG.
<span class="line-modified">1181       IndexSet *adj = _ifg-&gt;remove_node( lo );</span>



1182 
1183       // If any neighbors&#39; degrees fall below their number of
1184       // allowed registers, then put that neighbor on the low degree
1185       // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
1186       // unchanged by this action.  Thus the two are equal at most once,
1187       // so LRGs hit the lo-degree worklist at most once.
1188       IndexSetIterator elements(adj);
1189       uint neighbor;
1190       while ((neighbor = elements.next()) != 0) {
1191         LRG *n = &amp;lrgs(neighbor);
1192 #ifdef ASSERT
<span class="line-modified">1193         if( VerifyOpto || VerifyRegisterAllocator ) {</span>
1194           assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
1195         }
1196 #endif
1197 
1198         // Check for just becoming of-low-degree just counting registers.
1199         // _must_spill live ranges are already on the low degree list.
<span class="line-modified">1200         if( n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill ) {</span>
<span class="line-modified">1201           assert(!(*_ifg-&gt;_yanked)[neighbor],&quot;Cannot move to lo degree twice&quot;);</span>
1202           // Pull from hi-degree list
1203           uint prev = n-&gt;_prev;
1204           uint next = n-&gt;_next;
<span class="line-modified">1205           if( prev ) lrgs(prev)._next = next;</span>
<span class="line-modified">1206           else _hi_degree = next;</span>



1207           lrgs(next)._prev = prev;
1208           n-&gt;_next = _lo_degree;
1209           _lo_degree = neighbor;
1210         }
1211       }
1212     } // End of while lo-degree/lo_stk_degree worklist not empty
1213 
1214     // Check for got everything: is hi-degree list empty?
<span class="line-modified">1215     if( !_hi_degree ) break;</span>
1216 
1217     // Time to pick a potential spill guy
1218     uint lo_score = _hi_degree;
1219     double score = lrgs(lo_score).score();
1220     double area = lrgs(lo_score)._area;
1221     double cost = lrgs(lo_score)._cost;
1222     bool bound = lrgs(lo_score)._is_bound;
1223 
1224     // Find cheapest guy
1225     debug_only( int lo_no_simplify=0; );
<span class="line-modified">1226     for( uint i = _hi_degree; i; i = lrgs(i)._next ) {</span>
<span class="line-modified">1227       assert( !(*_ifg-&gt;_yanked)[i], &quot;&quot; );</span>
1228       // It&#39;s just vaguely possible to move hi-degree to lo-degree without
1229       // going through a just-lo-degree stage: If you remove a double from
1230       // a float live range it&#39;s degree will drop by 2 and you can skip the
1231       // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
1232       // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
1233       if( lrgs(i).lo_degree() ) {
1234         lo_score = i;
1235         break;
1236       }
1237       debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );
1238       double iscore = lrgs(i).score();
1239       double iarea = lrgs(i)._area;
1240       double icost = lrgs(i)._cost;
1241       bool ibound = lrgs(i)._is_bound;
1242 
1243       // Compare cost/area of i vs cost/area of lo_score.  Smaller cost/area
1244       // wins.  Ties happen because all live ranges in question have spilled
1245       // a few times before and the spill-score adds a huge number which
1246       // washes out the low order bits.  We are choosing the lesser of 2
1247       // evils; in this case pick largest area to spill.
1248       // Ties also happen when live ranges are defined and used only inside
1249       // one block. In which case their area is 0 and score set to max.
1250       // In such case choose bound live range over unbound to free registers
1251       // or with smaller cost to spill.
<span class="line-modified">1252       if( iscore &lt; score ||</span>
1253           (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
1254           (iscore == score &amp;&amp; iarea == area &amp;&amp;
1255            ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
1256         lo_score = i;
1257         score = iscore;
1258         area = iarea;
1259         cost = icost;
1260         bound = ibound;
1261       }
1262     }
1263     LRG *lo_lrg = &amp;lrgs(lo_score);
1264     // The live range we choose for spilling is either hi-degree, or very
1265     // rarely it can be low-degree.  If we choose a hi-degree live range
1266     // there better not be any lo-degree choices.
1267     assert( lo_lrg-&gt;lo_degree() || !lo_no_simplify, &quot;Live range was lo-degree before coalesce; should simplify&quot; );
1268 
1269     // Pull from hi-degree list
1270     uint prev = lo_lrg-&gt;_prev;
1271     uint next = lo_lrg-&gt;_next;
1272     if( prev ) lrgs(prev)._next = next;
</pre>
<hr />
<pre>
1297     // The &#39;lrg&#39; already has cleared-to-set register mask (done in Select()
1298     // before calling choose_color()). Passing mask.Member(reg) check above
1299     // indicates that the size (num_regs) of &#39;reg&#39; set is less or equal to
1300     // &#39;lrg&#39; set size.
1301     // For set size 1 any register which is member of &#39;lrg&#39; mask is legal.
1302     if (lrg.num_regs()==1)
1303       return true;
1304     // For larger sets only an aligned register with the same set size is legal.
1305     int mask = lrg.num_regs()-1;
1306     if ((reg&amp;mask) == mask)
1307       return true;
1308   }
1309   return false;
1310 }
1311 
1312 // Choose a color using the biasing heuristic
1313 OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
1314 
1315   // Check for &quot;at_risk&quot; LRG&#39;s
1316   uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<span class="line-modified">1317   if( risk_lrg != 0 ) {</span>
1318     // Walk the colored neighbors of the &quot;at_risk&quot; candidate
1319     // Choose a color which is both legal and already taken by a neighbor
1320     // of the &quot;at_risk&quot; candidate in order to improve the chances of the
1321     // &quot;at_risk&quot; candidate of coloring
1322     IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
1323     uint datum;
1324     while ((datum = elements.next()) != 0) {
1325       OptoReg::Name reg = lrgs(datum).reg();
1326       // If this LRG&#39;s register is legal for us, choose it
1327       if (is_legal_reg(lrg, reg, chunk))
1328         return reg;
1329     }
1330   }
1331 
1332   uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<span class="line-modified">1333   if( copy_lrg != 0 ) {</span>
1334     // If he has a color,
<span class="line-modified">1335     if( !(*(_ifg-&gt;_yanked))[copy_lrg] ) {</span>
1336       OptoReg::Name reg = lrgs(copy_lrg).reg();
1337       //  And it is legal for you,
1338       if (is_legal_reg(lrg, reg, chunk))
1339         return reg;
1340     } else if( chunk == 0 ) {
1341       // Choose a color which is legal for him
1342       RegMask tempmask = lrg.mask();
1343       tempmask.AND(lrgs(copy_lrg).mask());
1344       tempmask.clear_to_sets(lrg.num_regs());
1345       OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());
1346       if (OptoReg::is_valid(reg))
1347         return reg;
1348     }
1349   }
1350 
1351   // If no bias info exists, just go with the register selection ordering
1352   if (lrg._is_vector || lrg.num_regs() == 2) {
1353     // Find an aligned set
1354     return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);
1355   }
</pre>
<hr />
<pre>
1415       lrg-&gt;dump();
1416     }
1417 #endif
1418 
1419     // Re-insert into the IFG
1420     _ifg-&gt;re_insert(lidx);
1421     if( !lrg-&gt;alive() ) continue;
1422     // capture allstackedness flag before mask is hacked
1423     const int is_allstack = lrg-&gt;mask().is_AllStack();
1424 
1425     // Yeah, yeah, yeah, I know, I know.  I can refactor this
1426     // to avoid the GOTO, although the refactored code will not
1427     // be much clearer.  We arrive here IFF we have a stack-based
1428     // live range that cannot color in the current chunk, and it
1429     // has to move into the next free stack chunk.
1430     int chunk = 0;              // Current chunk is first chunk
1431     retry_next_chunk:
1432 
1433     // Remove neighbor colors
1434     IndexSet *s = _ifg-&gt;neighbors(lidx);
<span class="line-removed">1435 </span>
1436     debug_only(RegMask orig_mask = lrg-&gt;mask();)
<span class="line-modified">1437     IndexSetIterator elements(s);</span>
<span class="line-modified">1438     uint neighbor;</span>
<span class="line-modified">1439     while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">1440       // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">1441       // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">1442       // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">1443       // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">1444       // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">1445       // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">1446       LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">1447       OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-modified">1448       // Only subtract masks in the same chunk</span>
<span class="line-modified">1449       if( nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE ) {</span>


1450 #ifndef PRODUCT
<span class="line-modified">1451         uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">1452         RegMask rm = lrg-&gt;mask();</span>
1453 #endif
<span class="line-modified">1454         lrg-&gt;SUBTRACT(nlrg.mask());</span>
1455 #ifndef PRODUCT
<span class="line-modified">1456         if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">1457           ttyLocker ttyl;</span>
<span class="line-modified">1458           tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">1459           rm.dump();</span>
<span class="line-modified">1460           tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">1461           nlrg.mask().dump();</span>
<span class="line-modified">1462           tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">1463           rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">1464           rm.dump();</span>
<span class="line-modified">1465           tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">1466           lrg-&gt;mask().dump();</span>
<span class="line-modified">1467           tty-&gt;cr();</span>
<span class="line-modified">1468         }</span>
1469 #endif

1470       }
1471     }
1472     //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
1473     // Aligned pairs need aligned masks
1474     assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1475     if (lrg-&gt;num_regs() &gt; 1 &amp;&amp; !lrg-&gt;_fat_proj) {
1476       lrg-&gt;clear_to_sets();
1477     }
1478 
1479     // Check if a color is available and if so pick the color
1480     OptoReg::Name reg = choose_color( *lrg, chunk );
1481 #ifdef SPARC
1482     debug_only(lrg-&gt;compute_set_mask_size());
1483     assert(lrg-&gt;num_regs() &lt; 2 || lrg-&gt;is_bound() || is_even(reg-1), &quot;allocate all doubles aligned&quot;);
1484 #endif
1485 
1486     //---------------
1487     // If we fail to color and the AllStack flag is set, trigger
1488     // a chunk-rollover event
1489     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) &amp;&amp; is_allstack) {
</pre>
<hr />
<pre>
1810         }
1811       }
1812 
1813       // Get value being defined
1814       uint lidx = _lrg_map.live_range_id(n);
1815       // Ignore the occasional brand-new live range
1816       if (lidx &amp;&amp; lidx &lt; _lrg_map.max_lrg_id()) {
1817         // Remove from live-out set
1818         liveout.remove(lidx);
1819 
1820         // Copies do not define a new value and so do not interfere.
1821         // Remove the copies source from the liveout set before interfering.
1822         uint idx = n-&gt;is_Copy();
1823         if (idx) {
1824           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1825         }
1826       }
1827 
1828       // Found a safepoint?
1829       JVMState *jvms = n-&gt;jvms();
<span class="line-modified">1830       if( jvms ) {</span>
1831         // Now scan for a live derived pointer
1832         IndexSetIterator elements(&amp;liveout);
1833         uint neighbor;
1834         while ((neighbor = elements.next()) != 0) {
1835           // Find reaching DEF for base and derived values
1836           // This works because we are still in SSA during this call.
1837           Node *derived = lrgs(neighbor)._def;
1838           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1839           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1840                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1841           // If its an OOP with a non-zero offset, then it is derived.
1842           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {
1843             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1844             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1845             // Add reaching DEFs of derived pointer and base pointer as a
1846             // pair of inputs
1847             n-&gt;add_req(derived);
1848             n-&gt;add_req(base);
1849 
1850             // See if the base pointer is already live to this point.
</pre>
<hr />
<pre>
2067   tty-&gt;print(&quot;Simplified: &quot;);
2068   for( uint i = _simplified; i; i = lrgs(i)._next )
2069     tty-&gt;print(&quot;L%d &quot;,i);
2070   tty-&gt;cr();
2071 }
2072 
2073 static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {
2074   if ((int)reg &lt; 0)
2075     sprintf(buf, &quot;&lt;OptoReg::%d&gt;&quot;, (int)reg);
2076   else if (OptoReg::is_reg(reg))
2077     strcpy(buf, Matcher::regName[reg]);
2078   else
2079     sprintf(buf,&quot;%s + #%d&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
2080             pc-&gt;reg2offset(reg));
2081   return buf+strlen(buf);
2082 }
2083 
2084 // Dump a register name into a buffer.  Be intelligent if we get called
2085 // before allocation is complete.
2086 char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<span class="line-modified">2087   if( this == NULL ) {          // Not got anything?</span>
<span class="line-removed">2088     sprintf(buf,&quot;N%d&quot;,n-&gt;_idx); // Then use Node index</span>
<span class="line-removed">2089   } else if( _node_regs ) {</span>
2090     // Post allocation, use direct mappings, no LRG info available
2091     print_reg( get_reg_first(n), this, buf );
2092   } else {
2093     uint lidx = _lrg_map.find_const(n); // Grab LRG number
2094     if( !_ifg ) {
2095       sprintf(buf,&quot;L%d&quot;,lidx);  // No register binding yet
2096     } else if( !lidx ) {        // Special, not allocated value
2097       strcpy(buf,&quot;Special&quot;);
2098     } else {
2099       if (lrgs(lidx)._is_vector) {
2100         if (lrgs(lidx).mask().is_bound_set(lrgs(lidx).num_regs()))
2101           print_reg( lrgs(lidx).reg(), this, buf ); // a bound machine register
2102         else
2103           sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2104       } else if( (lrgs(lidx).num_regs() == 1)
2105                  ? lrgs(lidx).mask().is_bound1()
2106                  : lrgs(lidx).mask().is_bound_pair() ) {
2107         // Hah!  We have a bound machine register
2108         print_reg( lrgs(lidx).reg(), this, buf );
2109       } else {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1152 
1153   while( 1 ) {                  // Repeat till simplified it all
1154     // May want to explore simplifying lo_degree before _lo_stk_degree.
1155     // This might result in more spills coloring into registers during
1156     // Select().
1157     while( _lo_degree || _lo_stk_degree ) {
1158       // If possible, pull from lo_stk first
1159       uint lo;
1160       if( _lo_degree ) {
1161         lo = _lo_degree;
1162         _lo_degree = lrgs(lo)._next;
1163       } else {
1164         lo = _lo_stk_degree;
1165         _lo_stk_degree = lrgs(lo)._next;
1166       }
1167 
1168       // Put the simplified guy on the simplified list.
1169       lrgs(lo)._next = _simplified;
1170       _simplified = lo;
1171       // If this guy is &quot;at risk&quot; then mark his current neighbors
<span class="line-modified">1172       if (lrgs(lo)._at_risk &amp;&amp; !_ifg-&gt;neighbors(lo)-&gt;is_empty()) {</span>
1173         IndexSetIterator elements(_ifg-&gt;neighbors(lo));
1174         uint datum;
1175         while ((datum = elements.next()) != 0) {
1176           lrgs(datum)._risk_bias = lo;
1177         }
1178       }
1179 
1180       // Yank this guy from the IFG.
<span class="line-modified">1181       IndexSet *adj = _ifg-&gt;remove_node(lo);</span>
<span class="line-added">1182       if (adj-&gt;is_empty()) {</span>
<span class="line-added">1183         continue;</span>
<span class="line-added">1184       }</span>
1185 
1186       // If any neighbors&#39; degrees fall below their number of
1187       // allowed registers, then put that neighbor on the low degree
1188       // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
1189       // unchanged by this action.  Thus the two are equal at most once,
1190       // so LRGs hit the lo-degree worklist at most once.
1191       IndexSetIterator elements(adj);
1192       uint neighbor;
1193       while ((neighbor = elements.next()) != 0) {
1194         LRG *n = &amp;lrgs(neighbor);
1195 #ifdef ASSERT
<span class="line-modified">1196         if (VerifyRegisterAllocator) {</span>
1197           assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
1198         }
1199 #endif
1200 
1201         // Check for just becoming of-low-degree just counting registers.
1202         // _must_spill live ranges are already on the low degree list.
<span class="line-modified">1203         if (n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill) {</span>
<span class="line-modified">1204           assert(!_ifg-&gt;_yanked-&gt;test(neighbor), &quot;Cannot move to lo degree twice&quot;);</span>
1205           // Pull from hi-degree list
1206           uint prev = n-&gt;_prev;
1207           uint next = n-&gt;_next;
<span class="line-modified">1208           if (prev) {</span>
<span class="line-modified">1209             lrgs(prev)._next = next;</span>
<span class="line-added">1210           } else {</span>
<span class="line-added">1211             _hi_degree = next;</span>
<span class="line-added">1212           }</span>
1213           lrgs(next)._prev = prev;
1214           n-&gt;_next = _lo_degree;
1215           _lo_degree = neighbor;
1216         }
1217       }
1218     } // End of while lo-degree/lo_stk_degree worklist not empty
1219 
1220     // Check for got everything: is hi-degree list empty?
<span class="line-modified">1221     if (!_hi_degree) break;</span>
1222 
1223     // Time to pick a potential spill guy
1224     uint lo_score = _hi_degree;
1225     double score = lrgs(lo_score).score();
1226     double area = lrgs(lo_score)._area;
1227     double cost = lrgs(lo_score)._cost;
1228     bool bound = lrgs(lo_score)._is_bound;
1229 
1230     // Find cheapest guy
1231     debug_only( int lo_no_simplify=0; );
<span class="line-modified">1232     for (uint i = _hi_degree; i; i = lrgs(i)._next) {</span>
<span class="line-modified">1233       assert(!_ifg-&gt;_yanked-&gt;test(i), &quot;&quot;);</span>
1234       // It&#39;s just vaguely possible to move hi-degree to lo-degree without
1235       // going through a just-lo-degree stage: If you remove a double from
1236       // a float live range it&#39;s degree will drop by 2 and you can skip the
1237       // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
1238       // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
1239       if( lrgs(i).lo_degree() ) {
1240         lo_score = i;
1241         break;
1242       }
1243       debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );
1244       double iscore = lrgs(i).score();
1245       double iarea = lrgs(i)._area;
1246       double icost = lrgs(i)._cost;
1247       bool ibound = lrgs(i)._is_bound;
1248 
1249       // Compare cost/area of i vs cost/area of lo_score.  Smaller cost/area
1250       // wins.  Ties happen because all live ranges in question have spilled
1251       // a few times before and the spill-score adds a huge number which
1252       // washes out the low order bits.  We are choosing the lesser of 2
1253       // evils; in this case pick largest area to spill.
1254       // Ties also happen when live ranges are defined and used only inside
1255       // one block. In which case their area is 0 and score set to max.
1256       // In such case choose bound live range over unbound to free registers
1257       // or with smaller cost to spill.
<span class="line-modified">1258       if ( iscore &lt; score ||</span>
1259           (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
1260           (iscore == score &amp;&amp; iarea == area &amp;&amp;
1261            ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
1262         lo_score = i;
1263         score = iscore;
1264         area = iarea;
1265         cost = icost;
1266         bound = ibound;
1267       }
1268     }
1269     LRG *lo_lrg = &amp;lrgs(lo_score);
1270     // The live range we choose for spilling is either hi-degree, or very
1271     // rarely it can be low-degree.  If we choose a hi-degree live range
1272     // there better not be any lo-degree choices.
1273     assert( lo_lrg-&gt;lo_degree() || !lo_no_simplify, &quot;Live range was lo-degree before coalesce; should simplify&quot; );
1274 
1275     // Pull from hi-degree list
1276     uint prev = lo_lrg-&gt;_prev;
1277     uint next = lo_lrg-&gt;_next;
1278     if( prev ) lrgs(prev)._next = next;
</pre>
<hr />
<pre>
1303     // The &#39;lrg&#39; already has cleared-to-set register mask (done in Select()
1304     // before calling choose_color()). Passing mask.Member(reg) check above
1305     // indicates that the size (num_regs) of &#39;reg&#39; set is less or equal to
1306     // &#39;lrg&#39; set size.
1307     // For set size 1 any register which is member of &#39;lrg&#39; mask is legal.
1308     if (lrg.num_regs()==1)
1309       return true;
1310     // For larger sets only an aligned register with the same set size is legal.
1311     int mask = lrg.num_regs()-1;
1312     if ((reg&amp;mask) == mask)
1313       return true;
1314   }
1315   return false;
1316 }
1317 
1318 // Choose a color using the biasing heuristic
1319 OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
1320 
1321   // Check for &quot;at_risk&quot; LRG&#39;s
1322   uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<span class="line-modified">1323   if (risk_lrg != 0 &amp;&amp; !_ifg-&gt;neighbors(risk_lrg)-&gt;is_empty()) {</span>
1324     // Walk the colored neighbors of the &quot;at_risk&quot; candidate
1325     // Choose a color which is both legal and already taken by a neighbor
1326     // of the &quot;at_risk&quot; candidate in order to improve the chances of the
1327     // &quot;at_risk&quot; candidate of coloring
1328     IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
1329     uint datum;
1330     while ((datum = elements.next()) != 0) {
1331       OptoReg::Name reg = lrgs(datum).reg();
1332       // If this LRG&#39;s register is legal for us, choose it
1333       if (is_legal_reg(lrg, reg, chunk))
1334         return reg;
1335     }
1336   }
1337 
1338   uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<span class="line-modified">1339   if (copy_lrg != 0) {</span>
1340     // If he has a color,
<span class="line-modified">1341     if(!_ifg-&gt;_yanked-&gt;test(copy_lrg)) {</span>
1342       OptoReg::Name reg = lrgs(copy_lrg).reg();
1343       //  And it is legal for you,
1344       if (is_legal_reg(lrg, reg, chunk))
1345         return reg;
1346     } else if( chunk == 0 ) {
1347       // Choose a color which is legal for him
1348       RegMask tempmask = lrg.mask();
1349       tempmask.AND(lrgs(copy_lrg).mask());
1350       tempmask.clear_to_sets(lrg.num_regs());
1351       OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());
1352       if (OptoReg::is_valid(reg))
1353         return reg;
1354     }
1355   }
1356 
1357   // If no bias info exists, just go with the register selection ordering
1358   if (lrg._is_vector || lrg.num_regs() == 2) {
1359     // Find an aligned set
1360     return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);
1361   }
</pre>
<hr />
<pre>
1421       lrg-&gt;dump();
1422     }
1423 #endif
1424 
1425     // Re-insert into the IFG
1426     _ifg-&gt;re_insert(lidx);
1427     if( !lrg-&gt;alive() ) continue;
1428     // capture allstackedness flag before mask is hacked
1429     const int is_allstack = lrg-&gt;mask().is_AllStack();
1430 
1431     // Yeah, yeah, yeah, I know, I know.  I can refactor this
1432     // to avoid the GOTO, although the refactored code will not
1433     // be much clearer.  We arrive here IFF we have a stack-based
1434     // live range that cannot color in the current chunk, and it
1435     // has to move into the next free stack chunk.
1436     int chunk = 0;              // Current chunk is first chunk
1437     retry_next_chunk:
1438 
1439     // Remove neighbor colors
1440     IndexSet *s = _ifg-&gt;neighbors(lidx);

1441     debug_only(RegMask orig_mask = lrg-&gt;mask();)
<span class="line-modified">1442 </span>
<span class="line-modified">1443     if (!s-&gt;is_empty()) {</span>
<span class="line-modified">1444       IndexSetIterator elements(s);</span>
<span class="line-modified">1445       uint neighbor;</span>
<span class="line-modified">1446       while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">1447         // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">1448         // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">1449         // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">1450         // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">1451         // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">1452         // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">1453         LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">1454         OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-added">1455         // Only subtract masks in the same chunk</span>
<span class="line-added">1456         if (nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE) {</span>
1457 #ifndef PRODUCT
<span class="line-modified">1458           uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">1459           RegMask rm = lrg-&gt;mask();</span>
1460 #endif
<span class="line-modified">1461           lrg-&gt;SUBTRACT(nlrg.mask());</span>
1462 #ifndef PRODUCT
<span class="line-modified">1463           if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">1464             ttyLocker ttyl;</span>
<span class="line-modified">1465             tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">1466             rm.dump();</span>
<span class="line-modified">1467             tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">1468             nlrg.mask().dump();</span>
<span class="line-modified">1469             tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">1470             rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">1471             rm.dump();</span>
<span class="line-modified">1472             tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">1473             lrg-&gt;mask().dump();</span>
<span class="line-modified">1474             tty-&gt;cr();</span>
<span class="line-modified">1475           }</span>
1476 #endif
<span class="line-added">1477         }</span>
1478       }
1479     }
1480     //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
1481     // Aligned pairs need aligned masks
1482     assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1483     if (lrg-&gt;num_regs() &gt; 1 &amp;&amp; !lrg-&gt;_fat_proj) {
1484       lrg-&gt;clear_to_sets();
1485     }
1486 
1487     // Check if a color is available and if so pick the color
1488     OptoReg::Name reg = choose_color( *lrg, chunk );
1489 #ifdef SPARC
1490     debug_only(lrg-&gt;compute_set_mask_size());
1491     assert(lrg-&gt;num_regs() &lt; 2 || lrg-&gt;is_bound() || is_even(reg-1), &quot;allocate all doubles aligned&quot;);
1492 #endif
1493 
1494     //---------------
1495     // If we fail to color and the AllStack flag is set, trigger
1496     // a chunk-rollover event
1497     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) &amp;&amp; is_allstack) {
</pre>
<hr />
<pre>
1818         }
1819       }
1820 
1821       // Get value being defined
1822       uint lidx = _lrg_map.live_range_id(n);
1823       // Ignore the occasional brand-new live range
1824       if (lidx &amp;&amp; lidx &lt; _lrg_map.max_lrg_id()) {
1825         // Remove from live-out set
1826         liveout.remove(lidx);
1827 
1828         // Copies do not define a new value and so do not interfere.
1829         // Remove the copies source from the liveout set before interfering.
1830         uint idx = n-&gt;is_Copy();
1831         if (idx) {
1832           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1833         }
1834       }
1835 
1836       // Found a safepoint?
1837       JVMState *jvms = n-&gt;jvms();
<span class="line-modified">1838       if (jvms &amp;&amp; !liveout.is_empty()) {</span>
1839         // Now scan for a live derived pointer
1840         IndexSetIterator elements(&amp;liveout);
1841         uint neighbor;
1842         while ((neighbor = elements.next()) != 0) {
1843           // Find reaching DEF for base and derived values
1844           // This works because we are still in SSA during this call.
1845           Node *derived = lrgs(neighbor)._def;
1846           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1847           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1848                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1849           // If its an OOP with a non-zero offset, then it is derived.
1850           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {
1851             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1852             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1853             // Add reaching DEFs of derived pointer and base pointer as a
1854             // pair of inputs
1855             n-&gt;add_req(derived);
1856             n-&gt;add_req(base);
1857 
1858             // See if the base pointer is already live to this point.
</pre>
<hr />
<pre>
2075   tty-&gt;print(&quot;Simplified: &quot;);
2076   for( uint i = _simplified; i; i = lrgs(i)._next )
2077     tty-&gt;print(&quot;L%d &quot;,i);
2078   tty-&gt;cr();
2079 }
2080 
2081 static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {
2082   if ((int)reg &lt; 0)
2083     sprintf(buf, &quot;&lt;OptoReg::%d&gt;&quot;, (int)reg);
2084   else if (OptoReg::is_reg(reg))
2085     strcpy(buf, Matcher::regName[reg]);
2086   else
2087     sprintf(buf,&quot;%s + #%d&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
2088             pc-&gt;reg2offset(reg));
2089   return buf+strlen(buf);
2090 }
2091 
2092 // Dump a register name into a buffer.  Be intelligent if we get called
2093 // before allocation is complete.
2094 char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<span class="line-modified">2095   if( _node_regs ) {</span>


2096     // Post allocation, use direct mappings, no LRG info available
2097     print_reg( get_reg_first(n), this, buf );
2098   } else {
2099     uint lidx = _lrg_map.find_const(n); // Grab LRG number
2100     if( !_ifg ) {
2101       sprintf(buf,&quot;L%d&quot;,lidx);  // No register binding yet
2102     } else if( !lidx ) {        // Special, not allocated value
2103       strcpy(buf,&quot;Special&quot;);
2104     } else {
2105       if (lrgs(lidx)._is_vector) {
2106         if (lrgs(lidx).mask().is_bound_set(lrgs(lidx).num_regs()))
2107           print_reg( lrgs(lidx).reg(), this, buf ); // a bound machine register
2108         else
2109           sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2110       } else if( (lrgs(lidx).num_regs() == 1)
2111                  ? lrgs(lidx).mask().is_bound1()
2112                  : lrgs(lidx).mask().is_bound_pair() ) {
2113         // Hah!  We have a bound machine register
2114         print_reg( lrgs(lidx).reg(), this, buf );
2115       } else {
</pre>
</td>
</tr>
</table>
<center><a href="cfgnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/indexSet.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="indexSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="lcm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/indexSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
173   static void reset_memory(Compile* compile, Arena *arena) {
174     compile-&gt;set_indexSet_free_block_list(NULL);
175     compile-&gt;set_indexSet_arena(arena);
176 
177    // This should probably be done in a static initializer
178    _empty_block.clear();
179   }
180 
181  private:
182   friend class BitBlock;
183   // A distinguished BitBlock which always remains empty.  When a new IndexSet is
184   // created, all of its top level BitBlock pointers are initialized to point to
185   // this.
186   static BitBlock _empty_block;
187 
188   //-------------------------- Members ------------------------------------------
189 
190   // The number of elements in the set
191   uint      _count;
192 



193   // Our top level array of bitvector segments
194   BitBlock **_blocks;
195 
196   BitBlock  *_preallocated_block_list[preallocated_block_list_size];
197 
198   // The number of top level array entries in use
199   uint       _max_blocks;
200 
201   // Our assertions need to know the maximum number allowed in the set
202 #ifdef ASSERT
203   uint       _max_elements;
204 #endif
205 
206   // The next IndexSet on the free list (not used at same time as count)
207   IndexSet *_next;
208 
209  public:
210   //-------------------------- Free list operations ------------------------------
211   // Individual IndexSets can be placed on a free list.  This is done in PhaseLive.
212 
213   IndexSet *next() {
<span class="line-removed">214 #ifdef ASSERT</span>
<span class="line-removed">215     if( VerifyOpto ) {</span>
<span class="line-removed">216       check_watch(&quot;removed from free list?&quot;, ((_next == NULL) ? 0 : _next-&gt;_serial_number));</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218 #endif</span>
219     return _next;
220   }
221 
222   void set_next(IndexSet *next) {
<span class="line-removed">223 #ifdef ASSERT</span>
<span class="line-removed">224     if( VerifyOpto ) {</span>
<span class="line-removed">225       check_watch(&quot;put on free list?&quot;, ((next == NULL) ? 0 : next-&gt;_serial_number));</span>
<span class="line-removed">226     }</span>
<span class="line-removed">227 #endif</span>
228     _next = next;
229   }
230 
231  private:
232   //-------------------------- Utility methods -----------------------------------
233 
234   // Get the block which holds element
235   BitBlock *get_block_containing(uint element) const {
236     assert(element &lt; _max_elements, &quot;element out of bounds&quot;);
237     return _blocks[get_block_index(element)];
238   }
239 
240   // Set a block in the top level array
241   void set_block(uint index, BitBlock *block) {
<span class="line-removed">242 #ifdef ASSERT</span>
<span class="line-removed">243     if( VerifyOpto )</span>
<span class="line-removed">244       check_watch(&quot;set block&quot;, index);</span>
<span class="line-removed">245 #endif</span>
246     _blocks[index] = block;
247   }
248 
249   // Get a BitBlock from the free list
250   BitBlock *alloc_block();
251 
252   // Get a BitBlock from the free list and place it in the top level array
253   BitBlock *alloc_block_containing(uint element);
254 
255   // Free a block from the top level array, placing it on the free BitBlock list
256   void free_block(uint i);
257 
258  public:
259   //-------------------------- Primitive set operations --------------------------
260 
261   void clear() {
<span class="line-removed">262 #ifdef ASSERT</span>
<span class="line-removed">263     if( VerifyOpto )</span>
<span class="line-removed">264       check_watch(&quot;clear&quot;);</span>
<span class="line-removed">265 #endif</span>
266     _count = 0;
<span class="line-modified">267     for (uint i = 0; i &lt; _max_blocks; i++) {</span>
268       BitBlock *block = _blocks[i];
269       if (block != &amp;_empty_block) {
270         free_block(i);
271       }
272     }

273   }
274 
275   uint count() const { return _count; }
276 
277   bool is_empty() const { return _count == 0; }
278 
279   bool member(uint element) const {
280     return get_block_containing(element)-&gt;member(element);
281   }
282 
283   bool insert(uint element) {
<span class="line-removed">284 #ifdef ASSERT</span>
<span class="line-removed">285     if( VerifyOpto )</span>
<span class="line-removed">286       check_watch(&quot;insert&quot;, element);</span>
<span class="line-removed">287 #endif</span>
288     if (element == 0) {
289       return 0;
290     }
291     BitBlock *block = get_block_containing(element);
292     if (block == &amp;_empty_block) {
293       block = alloc_block_containing(element);
294     }
295     bool present = block-&gt;insert(element);
296     if (!present) {
297       _count++;
298     }
299     return !present;
300   }
301 
302   bool remove(uint element) {
<span class="line-removed">303 #ifdef ASSERT</span>
<span class="line-removed">304     if( VerifyOpto )</span>
<span class="line-removed">305       check_watch(&quot;remove&quot;, element);</span>
<span class="line-removed">306 #endif</span>
<span class="line-removed">307 </span>
308     BitBlock *block = get_block_containing(element);
309     bool present = block-&gt;remove(element);
310     if (present) {
311       _count--;
312     }
313     return present;
314   }
315 
316   //-------------------------- Compound set operations ------------------------
317   // Compute the union of all elements of one and two which interfere
318   // with the RegMask mask.  If the degree of the union becomes
319   // exceeds fail_degree, the union bails out.  The underlying set is
320   // cleared before the union is performed.
321   uint lrg_union(uint lr1, uint lr2,
322                  const uint fail_degree,
323                  const class PhaseIFG *ifg,
324                  const RegMask &amp;mask);
325 
326 
327   //------------------------- Construction, initialization -----------------------
</pre>
<hr />
<pre>
390 #endif
391 };
392 
393 
394 //-------------------------------- class IndexSetIterator --------------------
395 // An iterator for IndexSets.
396 
397 class IndexSetIterator {
398  friend class IndexSet;
399 
400  private:
401   // The current word we are inspecting
402   uint32_t              _current;
403 
404   // What element number are we currently on?
405   uint                  _value;
406 
407   // The index of the next word we will inspect
408   uint                  _next_word;
409 
<span class="line-removed">410   // A pointer to the contents of the current block</span>
<span class="line-removed">411   uint32_t             *_words;</span>
<span class="line-removed">412 </span>
413   // The index of the next block we will inspect
414   uint                  _next_block;
415 
<span class="line-removed">416   // A pointer to the blocks in our set</span>
<span class="line-removed">417   IndexSet::BitBlock **_blocks;</span>
<span class="line-removed">418 </span>
419   // The number of blocks in the set
420   uint                  _max_blocks;
421 






422   // If the iterator was created from a non-const set, we replace
423   // non-canonical empty blocks with the _empty_block pointer.  If
424   // _set is NULL, we do no replacement.
425   IndexSet            *_set;
426 
427   // Advance to the next non-empty word and return the next
428   // element in the set.
429   uint advance_and_next();
430 
431  public:
432 
433   // If an iterator is built from a constant set then empty blocks
434   // are not canonicalized.
<span class="line-modified">435   IndexSetIterator(IndexSet *set);</span>
<span class="line-modified">436   IndexSetIterator(const IndexSet *set);</span>












































437 
438   // Return the next element of the set.  Return 0 when done.
439   uint next() {
<span class="line-modified">440     uint current = _current;</span>
<span class="line-modified">441     if (current != 0) {</span>
<span class="line-modified">442       uint advance = count_trailing_zeros(current);</span>
<span class="line-removed">443       assert(((current &gt;&gt; advance) &amp; 0x1) == 1, &quot;sanity&quot;);</span>
<span class="line-removed">444       _current = (current &gt;&gt; advance) - 1;</span>
<span class="line-removed">445       _value += advance;</span>
<span class="line-removed">446       return _value;</span>
<span class="line-removed">447     } else {</span>
448       return advance_and_next();


449     }
450   }

451 };
452 
453 #endif // SHARE_OPTO_INDEXSET_HPP
</pre>
</td>
<td>
<hr />
<pre>
173   static void reset_memory(Compile* compile, Arena *arena) {
174     compile-&gt;set_indexSet_free_block_list(NULL);
175     compile-&gt;set_indexSet_arena(arena);
176 
177    // This should probably be done in a static initializer
178    _empty_block.clear();
179   }
180 
181  private:
182   friend class BitBlock;
183   // A distinguished BitBlock which always remains empty.  When a new IndexSet is
184   // created, all of its top level BitBlock pointers are initialized to point to
185   // this.
186   static BitBlock _empty_block;
187 
188   //-------------------------- Members ------------------------------------------
189 
190   // The number of elements in the set
191   uint      _count;
192 
<span class="line-added">193   // The current upper limit of blocks that has been allocated and might be in use</span>
<span class="line-added">194   uint      _current_block_limit;</span>
<span class="line-added">195 </span>
196   // Our top level array of bitvector segments
197   BitBlock **_blocks;
198 
199   BitBlock  *_preallocated_block_list[preallocated_block_list_size];
200 
201   // The number of top level array entries in use
202   uint       _max_blocks;
203 
204   // Our assertions need to know the maximum number allowed in the set
205 #ifdef ASSERT
206   uint       _max_elements;
207 #endif
208 
209   // The next IndexSet on the free list (not used at same time as count)
210   IndexSet *_next;
211 
212  public:
213   //-------------------------- Free list operations ------------------------------
214   // Individual IndexSets can be placed on a free list.  This is done in PhaseLive.
215 
216   IndexSet *next() {





217     return _next;
218   }
219 
220   void set_next(IndexSet *next) {





221     _next = next;
222   }
223 
224  private:
225   //-------------------------- Utility methods -----------------------------------
226 
227   // Get the block which holds element
228   BitBlock *get_block_containing(uint element) const {
229     assert(element &lt; _max_elements, &quot;element out of bounds&quot;);
230     return _blocks[get_block_index(element)];
231   }
232 
233   // Set a block in the top level array
234   void set_block(uint index, BitBlock *block) {




235     _blocks[index] = block;
236   }
237 
238   // Get a BitBlock from the free list
239   BitBlock *alloc_block();
240 
241   // Get a BitBlock from the free list and place it in the top level array
242   BitBlock *alloc_block_containing(uint element);
243 
244   // Free a block from the top level array, placing it on the free BitBlock list
245   void free_block(uint i);
246 
247  public:
248   //-------------------------- Primitive set operations --------------------------
249 
250   void clear() {




251     _count = 0;
<span class="line-modified">252     for (uint i = 0; i &lt; _current_block_limit; i++) {</span>
253       BitBlock *block = _blocks[i];
254       if (block != &amp;_empty_block) {
255         free_block(i);
256       }
257     }
<span class="line-added">258     _current_block_limit = 0;</span>
259   }
260 
261   uint count() const { return _count; }
262 
263   bool is_empty() const { return _count == 0; }
264 
265   bool member(uint element) const {
266     return get_block_containing(element)-&gt;member(element);
267   }
268 
269   bool insert(uint element) {




270     if (element == 0) {
271       return 0;
272     }
273     BitBlock *block = get_block_containing(element);
274     if (block == &amp;_empty_block) {
275       block = alloc_block_containing(element);
276     }
277     bool present = block-&gt;insert(element);
278     if (!present) {
279       _count++;
280     }
281     return !present;
282   }
283 
284   bool remove(uint element) {





285     BitBlock *block = get_block_containing(element);
286     bool present = block-&gt;remove(element);
287     if (present) {
288       _count--;
289     }
290     return present;
291   }
292 
293   //-------------------------- Compound set operations ------------------------
294   // Compute the union of all elements of one and two which interfere
295   // with the RegMask mask.  If the degree of the union becomes
296   // exceeds fail_degree, the union bails out.  The underlying set is
297   // cleared before the union is performed.
298   uint lrg_union(uint lr1, uint lr2,
299                  const uint fail_degree,
300                  const class PhaseIFG *ifg,
301                  const RegMask &amp;mask);
302 
303 
304   //------------------------- Construction, initialization -----------------------
</pre>
<hr />
<pre>
367 #endif
368 };
369 
370 
371 //-------------------------------- class IndexSetIterator --------------------
372 // An iterator for IndexSets.
373 
374 class IndexSetIterator {
375  friend class IndexSet;
376 
377  private:
378   // The current word we are inspecting
379   uint32_t              _current;
380 
381   // What element number are we currently on?
382   uint                  _value;
383 
384   // The index of the next word we will inspect
385   uint                  _next_word;
386 



387   // The index of the next block we will inspect
388   uint                  _next_block;
389 



390   // The number of blocks in the set
391   uint                  _max_blocks;
392 
<span class="line-added">393   // A pointer to the contents of the current block</span>
<span class="line-added">394   uint32_t             *_words;</span>
<span class="line-added">395 </span>
<span class="line-added">396   // A pointer to the blocks in our set</span>
<span class="line-added">397   IndexSet::BitBlock **_blocks;</span>
<span class="line-added">398 </span>
399   // If the iterator was created from a non-const set, we replace
400   // non-canonical empty blocks with the _empty_block pointer.  If
401   // _set is NULL, we do no replacement.
402   IndexSet            *_set;
403 
404   // Advance to the next non-empty word and return the next
405   // element in the set.
406   uint advance_and_next();
407 
408  public:
409 
410   // If an iterator is built from a constant set then empty blocks
411   // are not canonicalized.
<span class="line-modified">412   IndexSetIterator(IndexSet *set) :</span>
<span class="line-modified">413     _current(0),</span>
<span class="line-added">414     _value(0),</span>
<span class="line-added">415     _next_word(IndexSet::words_per_block),</span>
<span class="line-added">416     _next_block(0),</span>
<span class="line-added">417     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="line-added">418     _words(NULL),</span>
<span class="line-added">419     _blocks(set-&gt;_blocks),</span>
<span class="line-added">420     _set(set) {</span>
<span class="line-added">421   #ifdef ASSERT</span>
<span class="line-added">422     if (CollectIndexSetStatistics) {</span>
<span class="line-added">423       set-&gt;tally_iteration_statistics();</span>
<span class="line-added">424     }</span>
<span class="line-added">425     set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());</span>
<span class="line-added">426   #endif</span>
<span class="line-added">427   }</span>
<span class="line-added">428 </span>
<span class="line-added">429   IndexSetIterator(const IndexSet *set) :</span>
<span class="line-added">430     _current(0),</span>
<span class="line-added">431     _value(0),</span>
<span class="line-added">432     _next_word(IndexSet::words_per_block),</span>
<span class="line-added">433     _next_block(0),</span>
<span class="line-added">434     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="line-added">435     _words(NULL),</span>
<span class="line-added">436     _blocks(set-&gt;_blocks),</span>
<span class="line-added">437     _set(NULL)</span>
<span class="line-added">438   {</span>
<span class="line-added">439   #ifdef ASSERT</span>
<span class="line-added">440     if (CollectIndexSetStatistics) {</span>
<span class="line-added">441       set-&gt;tally_iteration_statistics();</span>
<span class="line-added">442     }</span>
<span class="line-added">443     // We don&#39;t call check_watch from here to avoid bad recursion.</span>
<span class="line-added">444     //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());</span>
<span class="line-added">445   #endif</span>
<span class="line-added">446   }</span>
<span class="line-added">447 </span>
<span class="line-added">448   // Return the next element of the set.</span>
<span class="line-added">449   uint next_value() {</span>
<span class="line-added">450     uint current = _current;</span>
<span class="line-added">451     assert(current != 0, &quot;sanity&quot;);</span>
<span class="line-added">452     uint advance = count_trailing_zeros(current);</span>
<span class="line-added">453     assert(((current &gt;&gt; advance) &amp; 0x1) == 1, &quot;sanity&quot;);</span>
<span class="line-added">454     _current = (current &gt;&gt; advance) - 1;</span>
<span class="line-added">455     _value += advance;</span>
<span class="line-added">456     return _value;</span>
<span class="line-added">457   }</span>
458 
459   // Return the next element of the set.  Return 0 when done.
460   uint next() {
<span class="line-modified">461     if (_current != 0) {</span>
<span class="line-modified">462       return next_value();</span>
<span class="line-modified">463     } else if (_next_word &lt; IndexSet::words_per_block || _next_block &lt; _max_blocks) {</span>





464       return advance_and_next();
<span class="line-added">465     } else {</span>
<span class="line-added">466       return 0;</span>
467     }
468   }
<span class="line-added">469 </span>
470 };
471 
472 #endif // SHARE_OPTO_INDEXSET_HPP
</pre>
</td>
</tr>
</table>
<center><a href="indexSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="lcm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
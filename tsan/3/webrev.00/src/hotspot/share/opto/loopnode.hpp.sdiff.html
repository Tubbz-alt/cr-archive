<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_LOOPNODE_HPP
  26 #define SHARE_OPTO_LOOPNODE_HPP
  27 
  28 #include &quot;opto/cfgnode.hpp&quot;
  29 #include &quot;opto/multnode.hpp&quot;
  30 #include &quot;opto/phaseX.hpp&quot;
  31 #include &quot;opto/subnode.hpp&quot;
  32 #include &quot;opto/type.hpp&quot;
  33 
  34 class CmpNode;
  35 class CountedLoopEndNode;
  36 class CountedLoopNode;
  37 class IdealLoopTree;
  38 class LoopNode;
  39 class Node;
  40 class OuterStripMinedLoopEndNode;
<span class="line-removed">  41 class ShenandoahBarrierNode;</span>
<span class="line-removed">  42 class ShenandoahWriteBarrierNode;</span>
  43 class PathFrequency;
  44 class PhaseIdealLoop;
  45 class CountedLoopReserveKit;
  46 class VectorSet;
  47 class Invariance;
  48 struct small_cache;
  49 
  50 //
  51 //                  I D E A L I Z E D   L O O P S
  52 //
  53 // Idealized loops are the set of loops I perform more interesting
  54 // transformations on, beyond simple hoisting.
  55 
  56 //------------------------------LoopNode---------------------------------------
  57 // Simple loop header.  Fall in path on left, loop-back path on right.
  58 class LoopNode : public RegionNode {
  59   // Size is bigger to hold the flags.  However, the flags do not change
  60   // the semantics so it does not appear in the hash &amp; cmp functions.
  61   virtual uint size_of() const { return sizeof(*this); }
  62 protected:
</pre>
<hr />
<pre>
 137   LoopNode(Node *entry, Node *backedge)
 138     : RegionNode(3), _loop_flags(0), _unswitch_count(0),
 139       _postloop_flags(0), _profile_trip_cnt(COUNT_UNKNOWN)  {
 140     init_class_id(Class_Loop);
 141     init_req(EntryControl, entry);
 142     init_req(LoopBackControl, backedge);
 143   }
 144 
 145   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 146   virtual int Opcode() const;
 147   bool can_be_counted_loop(PhaseTransform* phase) const {
 148     return req() == 3 &amp;&amp; in(0) != NULL &amp;&amp;
 149       in(1) != NULL &amp;&amp; phase-&gt;type(in(1)) != Type::TOP &amp;&amp;
 150       in(2) != NULL &amp;&amp; phase-&gt;type(in(2)) != Type::TOP;
 151   }
 152   bool is_valid_counted_loop() const;
 153 #ifndef PRODUCT
 154   virtual void dump_spec(outputStream *st) const;
 155 #endif
 156 
<span class="line-modified"> 157   void verify_strip_mined(int expect_skeleton) const;</span>
 158   virtual LoopNode* skip_strip_mined(int expect_skeleton = 1) { return this; }
 159   virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }
 160   virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }
 161   virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }
 162   virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }
 163 };
 164 
 165 //------------------------------Counted Loops----------------------------------
 166 // Counted loops are all trip-counted loops, with exactly 1 trip-counter exit
 167 // path (and maybe some other exit paths).  The trip-counter exit is always
 168 // last in the loop.  The trip-counter have to stride by a constant;
 169 // the exit value is also loop invariant.
 170 
 171 // CountedLoopNodes and CountedLoopEndNodes come in matched pairs.  The
 172 // CountedLoopNode has the incoming loop control and the loop-back-control
 173 // which is always the IfTrue before the matching CountedLoopEndNode.  The
 174 // CountedLoopEndNode has an incoming control (possibly not the
 175 // CountedLoopNode if there is control flow in the loop), the post-increment
 176 // trip-counter value, and the limit.  The trip-counter value is always of
 177 // the form (Op old-trip-counter stride).  The old-trip-counter is produced
</pre>
<hr />
<pre>
 249   // A following &#39;post&#39; loop will run any remaining iterations.  Used
 250   // during Range Check Elimination, the &#39;post&#39; loop will do any final
 251   // iterations with full checks.  Also used by Loop Unrolling, where
 252   // the &#39;post&#39; loop will do any epilog iterations needed.  Basically,
 253   // a &#39;post&#39; loop can not profitably be further unrolled or RCE&#39;d.
 254 
 255   // A preceding &#39;pre&#39; loop will run at least 1 iteration (to do peeling),
 256   // it may do under-flow checks for RCE and may do alignment iterations
 257   // so the following main loop &#39;knows&#39; that it is striding down cache
 258   // lines.
 259 
 260   // A &#39;main&#39; loop that is ONLY unrolled or peeled, never RCE&#39;d or
 261   // Aligned, may be missing it&#39;s pre-loop.
 262   bool is_normal_loop   () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Normal; }
 263   bool is_pre_loop      () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Pre;    }
 264   bool is_main_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Main;   }
 265   bool is_post_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Post;   }
 266   bool is_reduction_loop() const { return (_loop_flags&amp;HasReductions) == HasReductions; }
 267   bool was_slp_analyzed () const { return (_loop_flags&amp;WasSlpAnalyzed) == WasSlpAnalyzed; }
 268   bool has_passed_slp   () const { return (_loop_flags&amp;PassedSlpAnalysis) == PassedSlpAnalysis; }
<span class="line-modified"> 269   bool do_unroll_only      () const { return (_loop_flags&amp;DoUnrollOnly) == DoUnrollOnly; }</span>
 270   bool is_main_no_pre_loop() const { return _loop_flags &amp; MainHasNoPreLoop; }
 271   bool has_atomic_post_loop  () const { return (_loop_flags &amp; HasAtomicPostLoop) == HasAtomicPostLoop; }
 272   void set_main_no_pre_loop() { _loop_flags |= MainHasNoPreLoop; }
 273 
 274   int main_idx() const { return _main_idx; }
 275 
 276 
 277   void set_pre_loop  (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Pre ; _main_idx = main-&gt;_idx; }
 278   void set_main_loop (                     ) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Main;                         }
 279   void set_post_loop (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Post; _main_idx = main-&gt;_idx; }
 280   void set_normal_loop(                    ) { _loop_flags &amp;= ~PreMainPostFlagsMask; }
 281 
 282   void set_trip_count(uint tc) { _trip_count = tc; }
 283   uint trip_count()            { return _trip_count; }
 284 
 285   bool has_exact_trip_count() const { return (_loop_flags &amp; HasExactTripCount) != 0; }
 286   void set_exact_trip_count(uint tc) {
 287     _trip_count = tc;
 288     _loop_flags |= HasExactTripCount;
 289   }
</pre>
<hr />
<pre>
 355     // The CountedLoopNode that goes with this CountedLoopEndNode may
 356     // have been optimized out by the IGVN so be cautious with the
 357     // pattern matching on the graph
 358     PhiNode* iv_phi = phi();
 359     if (iv_phi == NULL) {
 360       return NULL;
 361     }
 362     Node *ln = iv_phi-&gt;in(0);
 363     if (ln-&gt;is_CountedLoop() &amp;&amp; ln-&gt;as_CountedLoop()-&gt;loopexit_or_null() == this) {
 364       return (CountedLoopNode*)ln;
 365     }
 366     return NULL;
 367   }
 368 
 369 #ifndef PRODUCT
 370   virtual void dump_spec(outputStream *st) const;
 371 #endif
 372 };
 373 
 374 
<span class="line-modified"> 375 inline CountedLoopEndNode *CountedLoopNode::loopexit_or_null() const {</span>
<span class="line-modified"> 376   Node *bc = back_control();</span>
<span class="line-modified"> 377   if( bc == NULL ) return NULL;</span>
<span class="line-modified"> 378   Node *le = bc-&gt;in(0);</span>
<span class="line-modified"> 379   if( le-&gt;Opcode() != Op_CountedLoopEnd )</span>
<span class="line-modified"> 380     return NULL;</span>
<span class="line-modified"> 381   return (CountedLoopEndNode*)le;</span>
 382 }
<span class="line-modified"> 383 inline CountedLoopEndNode *CountedLoopNode::loopexit() const {</span>

 384   CountedLoopEndNode* cle = loopexit_or_null();
 385   assert(cle != NULL, &quot;loopexit is NULL&quot;);
 386   return cle;
 387 }
<span class="line-modified"> 388 inline Node *CountedLoopNode::init_trip() const { return loopexit_or_null() ? loopexit()-&gt;init_trip() : NULL; }</span>
<span class="line-modified"> 389 inline Node *CountedLoopNode::stride() const { return loopexit_or_null() ? loopexit()-&gt;stride() : NULL; }</span>
<span class="line-modified"> 390 inline int CountedLoopNode::stride_con() const { return loopexit_or_null() ? loopexit()-&gt;stride_con() : 0; }</span>
<span class="line-modified"> 391 inline bool CountedLoopNode::stride_is_con() const { return loopexit_or_null() &amp;&amp; loopexit()-&gt;stride_is_con(); }</span>
<span class="line-modified"> 392 inline Node *CountedLoopNode::limit() const { return loopexit_or_null() ? loopexit()-&gt;limit() : NULL; }</span>
<span class="line-modified"> 393 inline Node *CountedLoopNode::incr() const { return loopexit_or_null() ? loopexit()-&gt;incr() : NULL; }</span>
<span class="line-modified"> 394 inline Node *CountedLoopNode::phi() const { return loopexit_or_null() ? loopexit()-&gt;phi() : NULL; }</span>






















 395 
 396 //------------------------------LoopLimitNode-----------------------------
 397 // Counted Loop limit node which represents exact final iterator value:
 398 // trip_count = (limit - init_trip + stride - 1)/stride
 399 // final_value= trip_count * stride + init_trip.
 400 // Use HW instructions to calculate it when it can overflow in integer.
 401 // Note, final_value should fit into integer since counted loop has
 402 // limit check: limit &lt;= max_int-stride.
 403 class LoopLimitNode : public Node {
 404   enum { Init=1, Limit=2, Stride=3 };
 405  public:
 406   LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(0,init,limit,stride) {
 407     // Put it on the Macro nodes list to optimize during macro nodes expansion.
 408     init_flags(Flag_is_macro);
 409     C-&gt;add_macro_node(this);
 410   }
 411   virtual int Opcode() const;
 412   virtual const Type *bottom_type() const { return TypeInt::INT; }
 413   virtual uint ideal_reg() const { return Op_RegI; }
 414   virtual const Type* Value(PhaseGVN* phase) const;
</pre>
<hr />
<pre>
 441 public:
 442   OuterStripMinedLoopEndNode(Node *control, Node *test, float prob, float cnt)
 443     : IfNode(control, test, prob, cnt) {
 444     init_class_id(Class_OuterStripMinedLoopEnd);
 445   }
 446 
 447   virtual int Opcode() const;
 448 
 449   virtual const Type* Value(PhaseGVN* phase) const;
 450   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 451 };
 452 
 453 // -----------------------------IdealLoopTree----------------------------------
 454 class IdealLoopTree : public ResourceObj {
 455 public:
 456   IdealLoopTree *_parent;       // Parent in loop tree
 457   IdealLoopTree *_next;         // Next sibling in loop tree
 458   IdealLoopTree *_child;        // First child in loop tree
 459 
 460   // The head-tail backedge defines the loop.
<span class="line-modified"> 461   // If tail is NULL then this loop has multiple backedges as part of the</span>
<span class="line-modified"> 462   // same loop.  During cleanup I&#39;ll peel off the multiple backedges; merge</span>
<span class="line-modified"> 463   // them at the loop bottom and flow 1 real backedge into the loop.</span>
 464   Node *_head;                  // Head of loop
 465   Node *_tail;                  // Tail of loop
 466   inline Node *tail();          // Handle lazy update of _tail field
 467   PhaseIdealLoop* _phase;
 468   int _local_loop_unroll_limit;
 469   int _local_loop_unroll_factor;
 470 
 471   Node_List _body;              // Loop body for inner loops
 472 
 473   uint8_t _nest;                // Nesting depth
 474   uint8_t _irreducible:1,       // True if irreducible
 475           _has_call:1,          // True if has call safepoint
 476           _has_sfpt:1,          // True if has non-call safepoint
 477           _rce_candidate:1;     // True if candidate for range check elimination
 478 
 479   Node_List* _safepts;          // List of safepoints in this loop
 480   Node_List* _required_safept;  // A inner loop cannot delete these safepts;
 481   bool  _allow_optimizations;   // Allow loop optimizations
 482 
 483   IdealLoopTree( PhaseIdealLoop* phase, Node *head, Node *tail )
 484     : _parent(0), _next(0), _child(0),
 485       _head(head), _tail(tail),
 486       _phase(phase),
 487       _local_loop_unroll_limit(0), _local_loop_unroll_factor(0),
 488       _nest(0), _irreducible(0), _has_call(0), _has_sfpt(0), _rce_candidate(0),
 489       _safepts(NULL),
 490       _required_safept(NULL),
 491       _allow_optimizations(true)
<span class="line-modified"> 492   { }</span>



 493 
 494   // Is &#39;l&#39; a member of &#39;this&#39;?
 495   bool is_member(const IdealLoopTree *l) const; // Test for nested membership
 496 
 497   // Set loop nesting depth.  Accumulate has_call bits.
 498   int set_nest( uint depth );
 499 
 500   // Split out multiple fall-in edges from the loop header.  Move them to a
 501   // private RegionNode before the loop.  This becomes the loop landing pad.
 502   void split_fall_in( PhaseIdealLoop *phase, int fall_in_cnt );
 503 
 504   // Split out the outermost loop from this shared header.
 505   void split_outer_loop( PhaseIdealLoop *phase );
 506 
 507   // Merge all the backedges from the shared header into a private Region.
 508   // Feed that region as the one backedge to this loop.
 509   void merge_many_backedges( PhaseIdealLoop *phase );
 510 
 511   // Split shared headers and insert loop landing pads.
 512   // Insert a LoopNode to replace the RegionNode.
</pre>
<hr />
<pre>
 543 
 544   // Check for Node being a loop-breaking test
 545   Node *is_loop_exit(Node *iff) const;
 546 
 547   // Remove simplistic dead code from loop body
 548   void DCE_loop_body();
 549 
 550   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
 551   // Replace with a 1-in-10 exit guess.
 552   void adjust_loop_exit_prob( PhaseIdealLoop *phase );
 553 
 554   // Return TRUE or FALSE if the loop should never be RCE&#39;d or aligned.
 555   // Useful for unrolling loops with NO array accesses.
 556   bool policy_peel_only( PhaseIdealLoop *phase ) const;
 557 
 558   // Return TRUE or FALSE if the loop should be unswitched -- clone
 559   // loop with an invariant test
 560   bool policy_unswitching( PhaseIdealLoop *phase ) const;
 561 
 562   // Micro-benchmark spamming.  Remove empty loops.
<span class="line-modified"> 563   bool policy_do_remove_empty_loop( PhaseIdealLoop *phase );</span>
 564 
 565   // Convert one iteration loop into normal code.
<span class="line-modified"> 566   bool policy_do_one_iteration_loop( PhaseIdealLoop *phase );</span>




 567 
<span class="line-modified"> 568   // Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can</span>
<span class="line-removed"> 569   // make some loop-invariant test (usually a null-check) happen before the</span>
<span class="line-removed"> 570   // loop.</span>
<span class="line-removed"> 571   bool policy_peeling( PhaseIdealLoop *phase ) const;</span>
 572 
 573   // Return TRUE or FALSE if the loop should be maximally unrolled. Stash any
 574   // known trip count in the counted loop node.
<span class="line-modified"> 575   bool policy_maximally_unroll( PhaseIdealLoop *phase ) const;</span>
 576 
<span class="line-modified"> 577   // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if</span>
<span class="line-modified"> 578   // the loop is a CountedLoop and the body is small enough.</span>
 579   bool policy_unroll(PhaseIdealLoop *phase);
 580 
 581   // Loop analyses to map to a maximal superword unrolling for vectorization.
 582   void policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct);
 583 
 584   // Return TRUE or FALSE if the loop should be range-check-eliminated.
 585   // Gather a list of IF tests that are dominated by iteration splitting;
 586   // also gather the end of the first split and the start of the 2nd split.
 587   bool policy_range_check( PhaseIdealLoop *phase ) const;
 588 
 589   // Return TRUE or FALSE if the loop should be cache-line aligned.
 590   // Gather the expression that does the alignment.  Note that only
 591   // one array base can be aligned in a loop (unless the VM guarantees
 592   // mutual alignment).  Note that if we vectorize short memory ops
 593   // into longer memory ops, we may want to increase alignment.
 594   bool policy_align( PhaseIdealLoop *phase ) const;
 595 
 596   // Return TRUE if &quot;iff&quot; is a range check.
 597   bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const;
 598 





 599   // Compute loop trip count if possible
 600   void compute_trip_count(PhaseIdealLoop* phase);
 601 
 602   // Compute loop trip count from profile data
 603   float compute_profile_trip_cnt_helper(Node* n);
 604   void compute_profile_trip_cnt( PhaseIdealLoop *phase );
 605 
 606   // Reassociate invariant expressions.
 607   void reassociate_invariants(PhaseIdealLoop *phase);
 608   // Reassociate invariant add and subtract expressions.
 609   Node* reassociate_add_sub(Node* n1, PhaseIdealLoop *phase);
 610   // Return nonzero index of invariant operand if invariant and variant
 611   // are combined with an Add or Sub. Helper for reassociate_invariants.
 612   int is_invariant_addition(Node* n, PhaseIdealLoop *phase);
 613 
 614   // Return true if n is invariant
 615   bool is_invariant(Node* n) const;
 616 
 617   // Put loop body on igvn work list
 618   void record_for_igvn();
 619 
<span class="line-modified"> 620   bool is_loop()    { return !_irreducible &amp;&amp; _tail &amp;&amp; !_tail-&gt;is_top(); }</span>
<span class="line-modified"> 621   bool is_inner()   { return is_loop() &amp;&amp; _child == NULL; }</span>
<span class="line-modified"> 622   bool is_counted() { return is_loop() &amp;&amp; _head != NULL &amp;&amp; _head-&gt;is_CountedLoop(); }</span>


 623 
 624   void remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase);
 625 
 626 #ifndef PRODUCT
<span class="line-modified"> 627   void dump_head( ) const;      // Dump loop head only</span>
 628   void dump() const;            // Dump this loop recursively
 629   void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;
 630 #endif
 631 





 632 };
 633 
 634 // -----------------------------PhaseIdealLoop---------------------------------
<span class="line-modified"> 635 // Computes the mapping from Nodes to IdealLoopTrees.  Organizes IdealLoopTrees into a</span>
<span class="line-modified"> 636 // loop tree.  Drives the loop-based transformations on the ideal graph.</span>
 637 class PhaseIdealLoop : public PhaseTransform {
 638   friend class IdealLoopTree;
 639   friend class SuperWord;
 640   friend class CountedLoopReserveKit;
<span class="line-modified"> 641   friend class ShenandoahBarrierNode;</span>
<span class="line-modified"> 642   friend class ShenandoahWriteBarrierNode;</span>
 643 
 644   // Pre-computed def-use info
 645   PhaseIterGVN &amp;_igvn;
 646 
 647   // Head of loop tree
<span class="line-modified"> 648   IdealLoopTree *_ltree_root;</span>
 649 
 650   // Array of pre-order numbers, plus post-visited bit.
 651   // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
 652   // ODD for post-visited.  Other bits are the pre-order number.
 653   uint *_preorders;
 654   uint _max_preorder;
 655 
 656   const PhaseIdealLoop* _verify_me;
 657   bool _verify_only;
 658 
 659   // Allocate _preorders[] array
 660   void allocate_preorders() {
 661     _max_preorder = C-&gt;unique()+8;
 662     _preorders = NEW_RESOURCE_ARRAY(uint, _max_preorder);
 663     memset(_preorders, 0, sizeof(uint) * _max_preorder);
 664   }
 665 
 666   // Allocate _preorders[] array
 667   void reallocate_preorders() {
 668     if ( _max_preorder &lt; C-&gt;unique() ) {
</pre>
<hr />
<pre>
 717   // Helper for debugging bad dominance relationships
 718   bool verify_dominance(Node* n, Node* use, Node* LCA, Node* early);
 719 
 720   Node* compute_lca_of_uses(Node* n, Node* early, bool verify = false);
 721 
 722   // Inline wrapper for frequent cases:
 723   // 1) only one use
 724   // 2) a use is the same as the current LCA passed as &#39;n1&#39;
 725   Node *dom_lca_for_get_late_ctrl( Node *lca, Node *n, Node *tag ) {
 726     assert( n-&gt;is_CFG(), &quot;&quot; );
 727     // Fast-path NULL lca
 728     if( lca != NULL &amp;&amp; lca != n ) {
 729       assert( lca-&gt;is_CFG(), &quot;&quot; );
 730       // find LCA of all uses
 731       n = dom_lca_for_get_late_ctrl_internal( lca, n, tag );
 732     }
 733     return find_non_split_ctrl(n);
 734   }
 735   Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
 736 
<span class="line-modified"> 737   // Helper function for directing control inputs away from CFG split</span>
<span class="line-removed"> 738   // points.</span>
 739   Node *find_non_split_ctrl( Node *ctrl ) const {
 740     if (ctrl != NULL) {
 741       if (ctrl-&gt;is_MultiBranch()) {
 742         ctrl = ctrl-&gt;in(0);
 743       }
 744       assert(ctrl-&gt;is_CFG(), &quot;CFG&quot;);
 745     }
 746     return ctrl;
 747   }
 748 
 749   Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);
 750   void duplicate_predicates_helper(Node* predicate, Node* start, Node* end, IdealLoopTree* outer_loop,
 751                                    LoopNode* outer_main_head, uint dd_main_head);
 752   void duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end, IdealLoopTree* outer_loop,
 753                             LoopNode* outer_main_head, uint dd_main_head);
 754   Node* clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
 755                                   Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);
 756   bool skeleton_predicate_has_opaque(IfNode* iff);
 757   void update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);
 758   void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);
</pre>
<hr />
<pre>
 778     assert( ctrl-&gt;in(0), &quot;cannot set dead control node&quot; );
 779     assert( ctrl == find_non_split_ctrl(ctrl), &quot;must set legal crtl&quot; );
 780     _nodes.map( n-&gt;_idx, (Node*)((intptr_t)ctrl + 1) );
 781   }
 782   // Set control and update loop membership
 783   void set_ctrl_and_loop(Node* n, Node* ctrl) {
 784     IdealLoopTree* old_loop = get_loop(get_ctrl(n));
 785     IdealLoopTree* new_loop = get_loop(ctrl);
 786     if (old_loop != new_loop) {
 787       if (old_loop-&gt;_child == NULL) old_loop-&gt;_body.yank(n);
 788       if (new_loop-&gt;_child == NULL) new_loop-&gt;_body.push(n);
 789     }
 790     set_ctrl(n, ctrl);
 791   }
 792   // Control nodes can be replaced or subsumed.  During this pass they
 793   // get their replacement Node in slot 1.  Instead of updating the block
 794   // location of all Nodes in the subsumed block, we lazily do it.  As we
 795   // pull such a subsumed block out of the array, we write back the final
 796   // correct block.
 797   Node *get_ctrl( Node *i ) {

 798     assert(has_node(i), &quot;&quot;);
 799     Node *n = get_ctrl_no_update(i);
 800     _nodes.map( i-&gt;_idx, (Node*)((intptr_t)n + 1) );
 801     assert(has_node(i) &amp;&amp; has_ctrl(i), &quot;&quot;);
 802     assert(n == find_non_split_ctrl(n), &quot;must return legal ctrl&quot; );
 803     return n;
 804   }
 805   // true if CFG node d dominates CFG node n
 806   bool is_dominator(Node *d, Node *n);
 807   // return get_ctrl for a data node and self(n) for a CFG node
 808   Node* ctrl_or_self(Node* n) {
 809     if (has_ctrl(n))
 810       return get_ctrl(n);
 811     else {
 812       assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
 813       return n;
 814     }
 815   }
 816 
 817   Node *get_ctrl_no_update_helper(Node *i) const {
</pre>
<hr />
<pre>
 869   // Place Data nodes in some loop nest
 870   void build_loop_early( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 871   void build_loop_late ( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 872   void build_loop_late_post_work(Node* n, bool pinned);
 873   void build_loop_late_post(Node* n);
 874   void verify_strip_mined_scheduling(Node *n, Node* least);
 875 
 876   // Array of immediate dominance info for each CFG node indexed by node idx
 877 private:
 878   uint _idom_size;
 879   Node **_idom;                  // Array of immediate dominators
 880   uint *_dom_depth;              // Used for fast LCA test
 881   GrowableArray&lt;uint&gt;* _dom_stk; // For recomputation of dom depth
 882 
 883   // Perform verification that the graph is valid.
 884   PhaseIdealLoop( PhaseIterGVN &amp;igvn) :
 885     PhaseTransform(Ideal_Loop),
 886     _igvn(igvn),
 887     _verify_me(NULL),
 888     _verify_only(true),
<span class="line-modified"> 889     _dom_lca_tags(arena()) { // Thread::resource_area</span>

 890     build_and_optimize(LoopOptsVerify);
 891   }
 892 
 893   // build the loop tree and perform any requested optimizations
 894   void build_and_optimize(LoopOptsMode mode);
 895 
 896   // Dominators for the sea of nodes
 897   void Dominators();
 898 
 899   // Compute the Ideal Node to Loop mapping
 900   PhaseIdealLoop(PhaseIterGVN &amp;igvn, LoopOptsMode mode) :
 901     PhaseTransform(Ideal_Loop),
 902     _igvn(igvn),
 903     _verify_me(NULL),
 904     _verify_only(false),
<span class="line-modified"> 905     _dom_lca_tags(arena()) { // Thread::resource_area</span>

 906     build_and_optimize(mode);
 907   }
 908 
 909   // Verify that verify_me made the same decisions as a fresh run.
 910   PhaseIdealLoop(PhaseIterGVN &amp;igvn, const PhaseIdealLoop *verify_me) :
 911     PhaseTransform(Ideal_Loop),
 912     _igvn(igvn),
 913     _verify_me(verify_me),
 914     _verify_only(false),
<span class="line-modified"> 915     _dom_lca_tags(arena()) { // Thread::resource_area</span>

 916     build_and_optimize(LoopOptsVerify);
 917   }
 918 
 919 public:
 920   Node* idom_no_update(Node* d) const {
 921     return idom_no_update(d-&gt;_idx);
 922   }
 923 
 924   Node* idom_no_update(uint didx) const {
 925     assert(didx &lt; _idom_size, &quot;oob&quot;);
 926     Node* n = _idom[didx];
 927     assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 928     while (n-&gt;in(0) == NULL) { // Skip dead CFG nodes
 929       n = (Node*)(((intptr_t)_nodes[n-&gt;_idx]) &amp; ~1);
 930       assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 931     }
 932     return n;
 933   }
 934 
 935   Node *idom(Node* d) const {
</pre>
<hr />
<pre>
 967   // Build and verify the loop tree without modifying the graph.  This
 968   // is useful to verify that all inputs properly dominate their uses.
 969   static void verify(PhaseIterGVN&amp; igvn) {
 970 #ifdef ASSERT
 971     ResourceMark rm;
 972     PhaseIdealLoop v(igvn);
 973 #endif
 974   }
 975 
 976   // Recommended way to use PhaseIdealLoop.
 977   // Run PhaseIdealLoop in some mode and allocates a local scope for memory allocations.
 978   static void optimize(PhaseIterGVN &amp;igvn, LoopOptsMode mode) {
 979     ResourceMark rm;
 980     PhaseIdealLoop v(igvn, mode);
 981   }
 982 
 983   // True if the method has at least 1 irreducible loop
 984   bool _has_irreducible_loops;
 985 
 986   // Per-Node transform
<span class="line-modified"> 987   virtual Node *transform( Node *a_node ) { return 0; }</span>
 988 
<span class="line-modified"> 989   bool is_counted_loop(Node* x, IdealLoopTree*&amp; loop);</span>
 990   IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
 991                                                IdealLoopTree* loop, float cl_prob, float le_fcnt,
 992                                                Node*&amp; entry_control, Node*&amp; iffalse);
 993 
 994   Node* exact_limit( IdealLoopTree *loop );
 995 
 996   // Return a post-walked LoopNode
 997   IdealLoopTree *get_loop( Node *n ) const {
 998     // Dead nodes have no loop, so return the top level loop instead
 999     if (!has_node(n))  return _ltree_root;
1000     assert(!has_ctrl(n), &quot;&quot;);
1001     return (IdealLoopTree*)_nodes[n-&gt;_idx];
1002   }
1003 
<span class="line-modified">1004   IdealLoopTree *ltree_root() const { return _ltree_root; }</span>
1005 
1006   // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
1007   int is_member( const IdealLoopTree *loop, Node *n ) const {
1008     return loop-&gt;is_member(get_loop(n)); }
1009 
1010   // This is the basic building block of the loop optimizations.  It clones an
1011   // entire loop body.  It makes an old_new loop body mapping; with this
1012   // mapping you can find the new-loop equivalent to an old-loop node.  All
1013   // new-loop nodes are exactly equal to their old-loop counterparts, all
1014   // edges are the same.  All exits from the old-loop now have a RegionNode
1015   // that merges the equivalent new-loop path.  This is true even for the
1016   // normal &quot;loop-exit&quot; condition.  All uses of loop-invariant old-loop values
1017   // now come from (one or more) Phis that merge their new-loop equivalents.
1018   // Parameter side_by_side_idom:
1019   //   When side_by_size_idom is NULL, the dominator tree is constructed for
1020   //      the clone loop to dominate the original.  Used in construction of
1021   //      pre-main-post loop sequence.
1022   //   When nonnull, the clone and original are side-by-side, both are
1023   //      dominated by the passed in side_by_side_idom node.  Used in
1024   //      construction of unswitched loops.
</pre>
<hr />
<pre>
1081   void mark_reductions( IdealLoopTree *loop );
1082 
1083   // Return true if exp is a constant times an induction var
1084   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1085 
1086   // Return true if exp is a scaled induction var plus (or minus) constant
1087   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1088 
1089   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
1090   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
1091                                         Deoptimization::DeoptReason reason,
1092                                         int opcode);
1093   void register_control(Node* n, IdealLoopTree *loop, Node* pred);
1094 
1095   // Clone loop predicates to cloned loops (peeled, unswitched)
1096   static ProjNode* clone_predicate(ProjNode* predicate_proj, Node* new_entry,
1097                                    Deoptimization::DeoptReason reason,
1098                                    PhaseIdealLoop* loop_phase,
1099                                    PhaseIterGVN* igvn);
1100 
<span class="line-removed">1101   static void clone_loop_predicates_fix_mem(ProjNode* dom_proj , ProjNode* proj,</span>
<span class="line-removed">1102                                             PhaseIdealLoop* loop_phase,</span>
<span class="line-removed">1103                                             PhaseIterGVN* igvn);</span>
<span class="line-removed">1104 </span>
1105   static Node* clone_loop_predicates(Node* old_entry, Node* new_entry,
1106                                          bool clone_limit_check,
1107                                          PhaseIdealLoop* loop_phase,
1108                                          PhaseIterGVN* igvn);
1109   Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check);
1110 
1111   static Node* skip_all_loop_predicates(Node* entry);
1112   static Node* skip_loop_predicates(Node* entry);
1113 
1114   // Find a good location to insert a predicate
1115   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1116   // Find a predicate
1117   static Node* find_predicate(Node* entry);
1118   // Construct a range check for a predicate if
1119   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1120                          int scale, Node* offset,
1121                          Node* init, Node* limit, jint stride,
1122                          Node* range, bool upper, bool &amp;overflow);
1123 
1124   // Implementation of the loop predication to promote checks outside the loop
</pre>
<hr />
<pre>
1257 
1258   // Rework addressing expressions to get the most loop-invariant stuff
1259   // moved out.  We&#39;d like to do all associative operators, but it&#39;s especially
1260   // important (common) to do address expressions.
1261   Node *remix_address_expressions( Node *n );
1262 
1263   // Convert add to muladd to generate MuladdS2I under certain criteria
1264   Node * convert_add_to_muladd(Node * n);
1265 
1266   // Attempt to use a conditional move instead of a phi/branch
1267   Node *conditional_move( Node *n );
1268 
1269   // Reorganize offset computations to lower register pressure.
1270   // Mostly prevent loop-fallout uses of the pre-incremented trip counter
1271   // (which are then alive with the post-incremented trip counter
1272   // forcing an extra register move)
1273   void reorg_offsets( IdealLoopTree *loop );
1274 
1275   // Check for aggressive application of &#39;split-if&#39; optimization,
1276   // using basic block level info.
<span class="line-modified">1277   void  split_if_with_blocks     ( VectorSet &amp;visited, Node_Stack &amp;nstack, bool last_round );</span>
1278   Node *split_if_with_blocks_pre ( Node *n );
<span class="line-modified">1279   void  split_if_with_blocks_post( Node *n, bool last_round );</span>
1280   Node *has_local_phi_input( Node *n );
1281   // Mark an IfNode as being dominated by a prior test,
1282   // without actually altering the CFG (and hence IDOM info).
1283   void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );
1284 
1285   // Split Node &#39;n&#39; through merge point
1286   Node *split_thru_region( Node *n, Node *region );
1287   // Split Node &#39;n&#39; through merge point if there is enough win.
1288   Node *split_thru_phi( Node *n, Node *region, int policy );
1289   // Found an If getting its condition-code input from a Phi in the
1290   // same block.  Split thru the Region.
1291   void do_split_if( Node *iff );
1292 
<span class="line-modified">1293   // Conversion of fill/copy patterns into intrisic versions</span>
1294   bool do_intrinsify_fill();
1295   bool intrinsify_fill(IdealLoopTree* lpt);
1296   bool match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
1297                        Node*&amp; shift, Node*&amp; offset);
1298 
1299 private:
1300   // Return a type based on condition control flow
1301   const TypeInt* filtered_type( Node *n, Node* n_ctrl);
1302   const TypeInt* filtered_type( Node *n ) { return filtered_type(n, NULL); }
1303  // Helpers for filtered type
1304   const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);
1305 
1306   // Helper functions
1307   Node *spinup( Node *iff, Node *new_false, Node *new_true, Node *region, Node *phi, small_cache *cache );
1308   Node *find_use_block( Node *use, Node *def, Node *old_false, Node *new_false, Node *old_true, Node *new_true );
1309   void handle_use( Node *use, Node *def, small_cache *cache, Node *region_dom, Node *new_false, Node *new_true, Node *old_false, Node *old_true );
1310   bool split_up( Node *n, Node *blk1, Node *blk2 );
1311   void sink_use( Node *use, Node *post_loop );
1312   Node *place_near_use( Node *useblock ) const;
1313   Node* try_move_store_before_loop(Node* n, Node *n_ctrl);
1314   void try_move_store_after_loop(Node* n);
1315   bool identical_backtoback_ifs(Node *n);
1316   bool can_split_if(Node *n_ctrl);
1317 
1318   // Determine if a method is too big for a/another round of split-if, based on
1319   // a magic (approximate) ratio derived from the equally magic constant 35000,
1320   // previously used for this purpose (but without relating to the node limit).
1321   bool must_throttle_split_if() {
1322     uint threshold = C-&gt;max_node_limit() * 2 / 5;
1323     return C-&gt;live_nodes() &gt; threshold;
1324   }
1325 






























































1326   bool _created_loop_node;

1327 public:
1328   void set_created_loop_node() { _created_loop_node = true; }
1329   bool created_loop_node()     { return _created_loop_node; }
<span class="line-modified">1330   void register_new_node( Node *n, Node *blk );</span>
1331 
1332 #ifdef ASSERT
1333   void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
1334 #endif
1335 
1336 #ifndef PRODUCT
<span class="line-modified">1337   void dump( ) const;</span>
<span class="line-modified">1338   void dump( IdealLoopTree *loop, uint rpo_idx, Node_List &amp;rpo_list ) const;</span>
1339   void verify() const;          // Major slow  :-)
<span class="line-modified">1340   void verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const;</span>
<span class="line-modified">1341   IdealLoopTree *get_loop_idx(Node* n) const {</span>
1342     // Dead nodes have no loop, so return the top level loop instead
1343     return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
1344   }
1345   // Print some stats
1346   static void print_statistics();
1347   static int _loop_invokes;     // Count of PhaseIdealLoop invokes
1348   static int _loop_work;        // Sum of PhaseIdealLoop x _unique
1349 #endif
<span class="line-modified">1350   void rpo( Node *start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list ) const;</span>

1351 };
1352 














































1353 // This kit may be used for making of a reserved copy of a loop before this loop
1354 //  goes under non-reversible changes.
1355 //
1356 // Function create_reserve() creates a reserved copy (clone) of the loop.
1357 // The reserved copy is created by calling
1358 // PhaseIdealLoop::create_reserve_version_of_loop - see there how
1359 // the original and reserved loops are connected in the outer graph.
1360 // If create_reserve succeeded, it returns &#39;true&#39; and _has_reserved is set to &#39;true&#39;.
1361 //
1362 // By default the reserved copy (clone) of the loop is created as dead code - it is
1363 // dominated in the outer loop by this node chain:
1364 //   intcon(1)-&gt;If-&gt;IfFalse-&gt;reserved_copy.
1365 // The original loop is dominated by the the same node chain but IfTrue projection:
1366 //   intcon(0)-&gt;If-&gt;IfTrue-&gt;original_loop.
1367 //
1368 // In this implementation of CountedLoopReserveKit the ctor includes create_reserve()
1369 // and the dtor, checks _use_new value.
1370 // If _use_new == false, it &quot;switches&quot; control to reserved copy of the loop
1371 // by simple replacing of node intcon(1) with node intcon(0).
1372 //
</pre>
<hr />
<pre>
1396     PhaseIdealLoop* _phase;
1397     IdealLoopTree*  _lpt;
1398     LoopNode*       _lp;
1399     IfNode*         _iff;
1400     LoopNode*       _lp_reserved;
1401     bool            _has_reserved;
1402     bool            _use_new;
1403     const bool      _active; //may be set to false in ctor, then the object is dummy
1404 
1405   public:
1406     CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active);
1407     ~CountedLoopReserveKit();
1408     void use_new()                {_use_new = true;}
1409     void set_iff(IfNode* x)       {_iff = x;}
1410     bool has_reserved()     const { return _active &amp;&amp; _has_reserved;}
1411   private:
1412     bool create_reserve();
1413 };// class CountedLoopReserveKit
1414 
1415 inline Node* IdealLoopTree::tail() {
<span class="line-modified">1416 // Handle lazy update of _tail field</span>
<span class="line-modified">1417   Node *n = _tail;</span>
<span class="line-modified">1418   //while( !n-&gt;in(0) )  // Skip dead CFG nodes</span>
<span class="line-modified">1419     //n = n-&gt;in(1);</span>
<span class="line-modified">1420   if (n-&gt;in(0) == NULL)</span>
<span class="line-removed">1421     n = _phase-&gt;get_ctrl(n);</span>
<span class="line-removed">1422   _tail = n;</span>
<span class="line-removed">1423   return n;</span>
1424 }
1425 
1426 
1427 // Iterate over the loop tree using a preorder, left-to-right traversal.
1428 //
1429 // Example that visits all counted loops from within PhaseIdealLoop
1430 //
1431 //  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
1432 //   IdealLoopTree* lpt = iter.current();
1433 //   if (!lpt-&gt;is_counted()) continue;
1434 //   ...
1435 class LoopTreeIterator : public StackObj {
1436 private:
1437   IdealLoopTree* _root;
1438   IdealLoopTree* _curnt;
1439 
1440 public:
1441   LoopTreeIterator(IdealLoopTree* root) : _root(root), _curnt(root) {}
1442 
1443   bool done() { return _curnt == NULL; }       // Finished iterating?
</pre>
</td>
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_LOOPNODE_HPP
  26 #define SHARE_OPTO_LOOPNODE_HPP
  27 
  28 #include &quot;opto/cfgnode.hpp&quot;
  29 #include &quot;opto/multnode.hpp&quot;
  30 #include &quot;opto/phaseX.hpp&quot;
  31 #include &quot;opto/subnode.hpp&quot;
  32 #include &quot;opto/type.hpp&quot;
  33 
  34 class CmpNode;
  35 class CountedLoopEndNode;
  36 class CountedLoopNode;
  37 class IdealLoopTree;
  38 class LoopNode;
  39 class Node;
  40 class OuterStripMinedLoopEndNode;


  41 class PathFrequency;
  42 class PhaseIdealLoop;
  43 class CountedLoopReserveKit;
  44 class VectorSet;
  45 class Invariance;
  46 struct small_cache;
  47 
  48 //
  49 //                  I D E A L I Z E D   L O O P S
  50 //
  51 // Idealized loops are the set of loops I perform more interesting
  52 // transformations on, beyond simple hoisting.
  53 
  54 //------------------------------LoopNode---------------------------------------
  55 // Simple loop header.  Fall in path on left, loop-back path on right.
  56 class LoopNode : public RegionNode {
  57   // Size is bigger to hold the flags.  However, the flags do not change
  58   // the semantics so it does not appear in the hash &amp; cmp functions.
  59   virtual uint size_of() const { return sizeof(*this); }
  60 protected:
</pre>
<hr />
<pre>
 135   LoopNode(Node *entry, Node *backedge)
 136     : RegionNode(3), _loop_flags(0), _unswitch_count(0),
 137       _postloop_flags(0), _profile_trip_cnt(COUNT_UNKNOWN)  {
 138     init_class_id(Class_Loop);
 139     init_req(EntryControl, entry);
 140     init_req(LoopBackControl, backedge);
 141   }
 142 
 143   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 144   virtual int Opcode() const;
 145   bool can_be_counted_loop(PhaseTransform* phase) const {
 146     return req() == 3 &amp;&amp; in(0) != NULL &amp;&amp;
 147       in(1) != NULL &amp;&amp; phase-&gt;type(in(1)) != Type::TOP &amp;&amp;
 148       in(2) != NULL &amp;&amp; phase-&gt;type(in(2)) != Type::TOP;
 149   }
 150   bool is_valid_counted_loop() const;
 151 #ifndef PRODUCT
 152   virtual void dump_spec(outputStream *st) const;
 153 #endif
 154 
<span class="line-modified"> 155   void verify_strip_mined(int expect_skeleton) const NOT_DEBUG_RETURN;</span>
 156   virtual LoopNode* skip_strip_mined(int expect_skeleton = 1) { return this; }
 157   virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }
 158   virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }
 159   virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }
 160   virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }
 161 };
 162 
 163 //------------------------------Counted Loops----------------------------------
 164 // Counted loops are all trip-counted loops, with exactly 1 trip-counter exit
 165 // path (and maybe some other exit paths).  The trip-counter exit is always
 166 // last in the loop.  The trip-counter have to stride by a constant;
 167 // the exit value is also loop invariant.
 168 
 169 // CountedLoopNodes and CountedLoopEndNodes come in matched pairs.  The
 170 // CountedLoopNode has the incoming loop control and the loop-back-control
 171 // which is always the IfTrue before the matching CountedLoopEndNode.  The
 172 // CountedLoopEndNode has an incoming control (possibly not the
 173 // CountedLoopNode if there is control flow in the loop), the post-increment
 174 // trip-counter value, and the limit.  The trip-counter value is always of
 175 // the form (Op old-trip-counter stride).  The old-trip-counter is produced
</pre>
<hr />
<pre>
 247   // A following &#39;post&#39; loop will run any remaining iterations.  Used
 248   // during Range Check Elimination, the &#39;post&#39; loop will do any final
 249   // iterations with full checks.  Also used by Loop Unrolling, where
 250   // the &#39;post&#39; loop will do any epilog iterations needed.  Basically,
 251   // a &#39;post&#39; loop can not profitably be further unrolled or RCE&#39;d.
 252 
 253   // A preceding &#39;pre&#39; loop will run at least 1 iteration (to do peeling),
 254   // it may do under-flow checks for RCE and may do alignment iterations
 255   // so the following main loop &#39;knows&#39; that it is striding down cache
 256   // lines.
 257 
 258   // A &#39;main&#39; loop that is ONLY unrolled or peeled, never RCE&#39;d or
 259   // Aligned, may be missing it&#39;s pre-loop.
 260   bool is_normal_loop   () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Normal; }
 261   bool is_pre_loop      () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Pre;    }
 262   bool is_main_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Main;   }
 263   bool is_post_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Post;   }
 264   bool is_reduction_loop() const { return (_loop_flags&amp;HasReductions) == HasReductions; }
 265   bool was_slp_analyzed () const { return (_loop_flags&amp;WasSlpAnalyzed) == WasSlpAnalyzed; }
 266   bool has_passed_slp   () const { return (_loop_flags&amp;PassedSlpAnalysis) == PassedSlpAnalysis; }
<span class="line-modified"> 267   bool is_unroll_only   () const { return (_loop_flags&amp;DoUnrollOnly) == DoUnrollOnly; }</span>
 268   bool is_main_no_pre_loop() const { return _loop_flags &amp; MainHasNoPreLoop; }
 269   bool has_atomic_post_loop  () const { return (_loop_flags &amp; HasAtomicPostLoop) == HasAtomicPostLoop; }
 270   void set_main_no_pre_loop() { _loop_flags |= MainHasNoPreLoop; }
 271 
 272   int main_idx() const { return _main_idx; }
 273 
 274 
 275   void set_pre_loop  (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Pre ; _main_idx = main-&gt;_idx; }
 276   void set_main_loop (                     ) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Main;                         }
 277   void set_post_loop (CountedLoopNode *main) { assert(is_normal_loop(),&quot;&quot;); _loop_flags |= Post; _main_idx = main-&gt;_idx; }
 278   void set_normal_loop(                    ) { _loop_flags &amp;= ~PreMainPostFlagsMask; }
 279 
 280   void set_trip_count(uint tc) { _trip_count = tc; }
 281   uint trip_count()            { return _trip_count; }
 282 
 283   bool has_exact_trip_count() const { return (_loop_flags &amp; HasExactTripCount) != 0; }
 284   void set_exact_trip_count(uint tc) {
 285     _trip_count = tc;
 286     _loop_flags |= HasExactTripCount;
 287   }
</pre>
<hr />
<pre>
 353     // The CountedLoopNode that goes with this CountedLoopEndNode may
 354     // have been optimized out by the IGVN so be cautious with the
 355     // pattern matching on the graph
 356     PhiNode* iv_phi = phi();
 357     if (iv_phi == NULL) {
 358       return NULL;
 359     }
 360     Node *ln = iv_phi-&gt;in(0);
 361     if (ln-&gt;is_CountedLoop() &amp;&amp; ln-&gt;as_CountedLoop()-&gt;loopexit_or_null() == this) {
 362       return (CountedLoopNode*)ln;
 363     }
 364     return NULL;
 365   }
 366 
 367 #ifndef PRODUCT
 368   virtual void dump_spec(outputStream *st) const;
 369 #endif
 370 };
 371 
 372 
<span class="line-modified"> 373 inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {</span>
<span class="line-modified"> 374   Node* bctrl = back_control();</span>
<span class="line-modified"> 375   if (bctrl == NULL) return NULL;</span>
<span class="line-modified"> 376 </span>
<span class="line-modified"> 377   Node* lexit = bctrl-&gt;in(0);</span>
<span class="line-modified"> 378   return (CountedLoopEndNode*)</span>
<span class="line-modified"> 379       (lexit-&gt;Opcode() == Op_CountedLoopEnd ? lexit : NULL);</span>
 380 }
<span class="line-modified"> 381 </span>
<span class="line-added"> 382 inline CountedLoopEndNode* CountedLoopNode::loopexit() const {</span>
 383   CountedLoopEndNode* cle = loopexit_or_null();
 384   assert(cle != NULL, &quot;loopexit is NULL&quot;);
 385   return cle;
 386 }
<span class="line-modified"> 387 </span>
<span class="line-modified"> 388 inline Node* CountedLoopNode::init_trip() const {</span>
<span class="line-modified"> 389   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-modified"> 390   return cle != NULL ? cle-&gt;init_trip() : NULL;</span>
<span class="line-modified"> 391 }</span>
<span class="line-modified"> 392 inline Node* CountedLoopNode::stride() const {</span>
<span class="line-modified"> 393   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 394   return cle != NULL ? cle-&gt;stride() : NULL;</span>
<span class="line-added"> 395 }</span>
<span class="line-added"> 396 inline int CountedLoopNode::stride_con() const {</span>
<span class="line-added"> 397   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 398   return cle != NULL ? cle-&gt;stride_con() : 0;</span>
<span class="line-added"> 399 }</span>
<span class="line-added"> 400 inline bool CountedLoopNode::stride_is_con() const {</span>
<span class="line-added"> 401   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 402   return cle != NULL &amp;&amp; cle-&gt;stride_is_con();</span>
<span class="line-added"> 403 }</span>
<span class="line-added"> 404 inline Node* CountedLoopNode::limit() const {</span>
<span class="line-added"> 405   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 406   return cle != NULL ? cle-&gt;limit() : NULL;</span>
<span class="line-added"> 407 }</span>
<span class="line-added"> 408 inline Node* CountedLoopNode::incr() const {</span>
<span class="line-added"> 409   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 410   return cle != NULL ? cle-&gt;incr() : NULL;</span>
<span class="line-added"> 411 }</span>
<span class="line-added"> 412 inline Node* CountedLoopNode::phi() const {</span>
<span class="line-added"> 413   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added"> 414   return cle != NULL ? cle-&gt;phi() : NULL;</span>
<span class="line-added"> 415 }</span>
 416 
 417 //------------------------------LoopLimitNode-----------------------------
 418 // Counted Loop limit node which represents exact final iterator value:
 419 // trip_count = (limit - init_trip + stride - 1)/stride
 420 // final_value= trip_count * stride + init_trip.
 421 // Use HW instructions to calculate it when it can overflow in integer.
 422 // Note, final_value should fit into integer since counted loop has
 423 // limit check: limit &lt;= max_int-stride.
 424 class LoopLimitNode : public Node {
 425   enum { Init=1, Limit=2, Stride=3 };
 426  public:
 427   LoopLimitNode( Compile* C, Node *init, Node *limit, Node *stride ) : Node(0,init,limit,stride) {
 428     // Put it on the Macro nodes list to optimize during macro nodes expansion.
 429     init_flags(Flag_is_macro);
 430     C-&gt;add_macro_node(this);
 431   }
 432   virtual int Opcode() const;
 433   virtual const Type *bottom_type() const { return TypeInt::INT; }
 434   virtual uint ideal_reg() const { return Op_RegI; }
 435   virtual const Type* Value(PhaseGVN* phase) const;
</pre>
<hr />
<pre>
 462 public:
 463   OuterStripMinedLoopEndNode(Node *control, Node *test, float prob, float cnt)
 464     : IfNode(control, test, prob, cnt) {
 465     init_class_id(Class_OuterStripMinedLoopEnd);
 466   }
 467 
 468   virtual int Opcode() const;
 469 
 470   virtual const Type* Value(PhaseGVN* phase) const;
 471   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 472 };
 473 
 474 // -----------------------------IdealLoopTree----------------------------------
 475 class IdealLoopTree : public ResourceObj {
 476 public:
 477   IdealLoopTree *_parent;       // Parent in loop tree
 478   IdealLoopTree *_next;         // Next sibling in loop tree
 479   IdealLoopTree *_child;        // First child in loop tree
 480 
 481   // The head-tail backedge defines the loop.
<span class="line-modified"> 482   // If a loop has multiple backedges, this is addressed during cleanup where</span>
<span class="line-modified"> 483   // we peel off the multiple backedges,  merging all edges at the bottom and</span>
<span class="line-modified"> 484   // ensuring that one proper backedge flow into the loop.</span>
 485   Node *_head;                  // Head of loop
 486   Node *_tail;                  // Tail of loop
 487   inline Node *tail();          // Handle lazy update of _tail field
 488   PhaseIdealLoop* _phase;
 489   int _local_loop_unroll_limit;
 490   int _local_loop_unroll_factor;
 491 
 492   Node_List _body;              // Loop body for inner loops
 493 
 494   uint8_t _nest;                // Nesting depth
 495   uint8_t _irreducible:1,       // True if irreducible
 496           _has_call:1,          // True if has call safepoint
 497           _has_sfpt:1,          // True if has non-call safepoint
 498           _rce_candidate:1;     // True if candidate for range check elimination
 499 
 500   Node_List* _safepts;          // List of safepoints in this loop
 501   Node_List* _required_safept;  // A inner loop cannot delete these safepts;
 502   bool  _allow_optimizations;   // Allow loop optimizations
 503 
 504   IdealLoopTree( PhaseIdealLoop* phase, Node *head, Node *tail )
 505     : _parent(0), _next(0), _child(0),
 506       _head(head), _tail(tail),
 507       _phase(phase),
 508       _local_loop_unroll_limit(0), _local_loop_unroll_factor(0),
 509       _nest(0), _irreducible(0), _has_call(0), _has_sfpt(0), _rce_candidate(0),
 510       _safepts(NULL),
 511       _required_safept(NULL),
 512       _allow_optimizations(true)
<span class="line-modified"> 513   {</span>
<span class="line-added"> 514     precond(_head != NULL);</span>
<span class="line-added"> 515     precond(_tail != NULL);</span>
<span class="line-added"> 516   }</span>
 517 
 518   // Is &#39;l&#39; a member of &#39;this&#39;?
 519   bool is_member(const IdealLoopTree *l) const; // Test for nested membership
 520 
 521   // Set loop nesting depth.  Accumulate has_call bits.
 522   int set_nest( uint depth );
 523 
 524   // Split out multiple fall-in edges from the loop header.  Move them to a
 525   // private RegionNode before the loop.  This becomes the loop landing pad.
 526   void split_fall_in( PhaseIdealLoop *phase, int fall_in_cnt );
 527 
 528   // Split out the outermost loop from this shared header.
 529   void split_outer_loop( PhaseIdealLoop *phase );
 530 
 531   // Merge all the backedges from the shared header into a private Region.
 532   // Feed that region as the one backedge to this loop.
 533   void merge_many_backedges( PhaseIdealLoop *phase );
 534 
 535   // Split shared headers and insert loop landing pads.
 536   // Insert a LoopNode to replace the RegionNode.
</pre>
<hr />
<pre>
 567 
 568   // Check for Node being a loop-breaking test
 569   Node *is_loop_exit(Node *iff) const;
 570 
 571   // Remove simplistic dead code from loop body
 572   void DCE_loop_body();
 573 
 574   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
 575   // Replace with a 1-in-10 exit guess.
 576   void adjust_loop_exit_prob( PhaseIdealLoop *phase );
 577 
 578   // Return TRUE or FALSE if the loop should never be RCE&#39;d or aligned.
 579   // Useful for unrolling loops with NO array accesses.
 580   bool policy_peel_only( PhaseIdealLoop *phase ) const;
 581 
 582   // Return TRUE or FALSE if the loop should be unswitched -- clone
 583   // loop with an invariant test
 584   bool policy_unswitching( PhaseIdealLoop *phase ) const;
 585 
 586   // Micro-benchmark spamming.  Remove empty loops.
<span class="line-modified"> 587   bool do_remove_empty_loop( PhaseIdealLoop *phase );</span>
 588 
 589   // Convert one iteration loop into normal code.
<span class="line-modified"> 590   bool do_one_iteration_loop( PhaseIdealLoop *phase );</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592   // Return TRUE or FALSE if the loop should be peeled or not. Peel if we can</span>
<span class="line-added"> 593   // move some loop-invariant test (usually a null-check) before the loop.</span>
<span class="line-added"> 594   bool policy_peeling(PhaseIdealLoop *phase);</span>
 595 
<span class="line-modified"> 596   uint estimate_peeling(PhaseIdealLoop *phase);</span>



 597 
 598   // Return TRUE or FALSE if the loop should be maximally unrolled. Stash any
 599   // known trip count in the counted loop node.
<span class="line-modified"> 600   bool policy_maximally_unroll(PhaseIdealLoop *phase) const;</span>
 601 
<span class="line-modified"> 602   // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll</span>
<span class="line-modified"> 603   // if the loop is a counted loop and the loop body is small enough.</span>
 604   bool policy_unroll(PhaseIdealLoop *phase);
 605 
 606   // Loop analyses to map to a maximal superword unrolling for vectorization.
 607   void policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct);
 608 
 609   // Return TRUE or FALSE if the loop should be range-check-eliminated.
 610   // Gather a list of IF tests that are dominated by iteration splitting;
 611   // also gather the end of the first split and the start of the 2nd split.
 612   bool policy_range_check( PhaseIdealLoop *phase ) const;
 613 
 614   // Return TRUE or FALSE if the loop should be cache-line aligned.
 615   // Gather the expression that does the alignment.  Note that only
 616   // one array base can be aligned in a loop (unless the VM guarantees
 617   // mutual alignment).  Note that if we vectorize short memory ops
 618   // into longer memory ops, we may want to increase alignment.
 619   bool policy_align( PhaseIdealLoop *phase ) const;
 620 
 621   // Return TRUE if &quot;iff&quot; is a range check.
 622   bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const;
 623 
<span class="line-added"> 624   // Estimate the number of nodes required when cloning a loop (body).</span>
<span class="line-added"> 625   uint est_loop_clone_sz(uint factor) const;</span>
<span class="line-added"> 626   // Estimate the number of nodes required when unrolling a loop (body).</span>
<span class="line-added"> 627   uint est_loop_unroll_sz(uint factor) const;</span>
<span class="line-added"> 628 </span>
 629   // Compute loop trip count if possible
 630   void compute_trip_count(PhaseIdealLoop* phase);
 631 
 632   // Compute loop trip count from profile data
 633   float compute_profile_trip_cnt_helper(Node* n);
 634   void compute_profile_trip_cnt( PhaseIdealLoop *phase );
 635 
 636   // Reassociate invariant expressions.
 637   void reassociate_invariants(PhaseIdealLoop *phase);
 638   // Reassociate invariant add and subtract expressions.
 639   Node* reassociate_add_sub(Node* n1, PhaseIdealLoop *phase);
 640   // Return nonzero index of invariant operand if invariant and variant
 641   // are combined with an Add or Sub. Helper for reassociate_invariants.
 642   int is_invariant_addition(Node* n, PhaseIdealLoop *phase);
 643 
 644   // Return true if n is invariant
 645   bool is_invariant(Node* n) const;
 646 
 647   // Put loop body on igvn work list
 648   void record_for_igvn();
 649 
<span class="line-modified"> 650   bool is_root() { return _parent == NULL; }</span>
<span class="line-modified"> 651   // A proper/reducible loop w/o any (occasional) dead back-edge.</span>
<span class="line-modified"> 652   bool is_loop() { return !_irreducible &amp;&amp; !tail()-&gt;is_top(); }</span>
<span class="line-added"> 653   bool is_counted()   { return is_loop() &amp;&amp; _head-&gt;is_CountedLoop(); }</span>
<span class="line-added"> 654   bool is_innermost() { return is_loop() &amp;&amp; _child == NULL; }</span>
 655 
 656   void remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase);
 657 
 658 #ifndef PRODUCT
<span class="line-modified"> 659   void dump_head() const;       // Dump loop head only</span>
 660   void dump() const;            // Dump this loop recursively
 661   void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;
 662 #endif
 663 
<span class="line-added"> 664  private:</span>
<span class="line-added"> 665   enum { EMPTY_LOOP_SIZE = 7 }; // Number of nodes in an empty loop.</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667   // Estimate the number of nodes resulting from control and data flow merge.</span>
<span class="line-added"> 668   uint est_loop_flow_merge_sz() const;</span>
 669 };
 670 
 671 // -----------------------------PhaseIdealLoop---------------------------------
<span class="line-modified"> 672 // Computes the mapping from Nodes to IdealLoopTrees. Organizes IdealLoopTrees</span>
<span class="line-modified"> 673 // into a loop tree. Drives the loop-based transformations on the ideal graph.</span>
 674 class PhaseIdealLoop : public PhaseTransform {
 675   friend class IdealLoopTree;
 676   friend class SuperWord;
 677   friend class CountedLoopReserveKit;
<span class="line-modified"> 678   friend class ShenandoahBarrierC2Support;</span>
<span class="line-modified"> 679   friend class AutoNodeBudget;</span>
 680 
 681   // Pre-computed def-use info
 682   PhaseIterGVN &amp;_igvn;
 683 
 684   // Head of loop tree
<span class="line-modified"> 685   IdealLoopTree* _ltree_root;</span>
 686 
 687   // Array of pre-order numbers, plus post-visited bit.
 688   // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
 689   // ODD for post-visited.  Other bits are the pre-order number.
 690   uint *_preorders;
 691   uint _max_preorder;
 692 
 693   const PhaseIdealLoop* _verify_me;
 694   bool _verify_only;
 695 
 696   // Allocate _preorders[] array
 697   void allocate_preorders() {
 698     _max_preorder = C-&gt;unique()+8;
 699     _preorders = NEW_RESOURCE_ARRAY(uint, _max_preorder);
 700     memset(_preorders, 0, sizeof(uint) * _max_preorder);
 701   }
 702 
 703   // Allocate _preorders[] array
 704   void reallocate_preorders() {
 705     if ( _max_preorder &lt; C-&gt;unique() ) {
</pre>
<hr />
<pre>
 754   // Helper for debugging bad dominance relationships
 755   bool verify_dominance(Node* n, Node* use, Node* LCA, Node* early);
 756 
 757   Node* compute_lca_of_uses(Node* n, Node* early, bool verify = false);
 758 
 759   // Inline wrapper for frequent cases:
 760   // 1) only one use
 761   // 2) a use is the same as the current LCA passed as &#39;n1&#39;
 762   Node *dom_lca_for_get_late_ctrl( Node *lca, Node *n, Node *tag ) {
 763     assert( n-&gt;is_CFG(), &quot;&quot; );
 764     // Fast-path NULL lca
 765     if( lca != NULL &amp;&amp; lca != n ) {
 766       assert( lca-&gt;is_CFG(), &quot;&quot; );
 767       // find LCA of all uses
 768       n = dom_lca_for_get_late_ctrl_internal( lca, n, tag );
 769     }
 770     return find_non_split_ctrl(n);
 771   }
 772   Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
 773 
<span class="line-modified"> 774   // Helper function for directing control inputs away from CFG split points.</span>

 775   Node *find_non_split_ctrl( Node *ctrl ) const {
 776     if (ctrl != NULL) {
 777       if (ctrl-&gt;is_MultiBranch()) {
 778         ctrl = ctrl-&gt;in(0);
 779       }
 780       assert(ctrl-&gt;is_CFG(), &quot;CFG&quot;);
 781     }
 782     return ctrl;
 783   }
 784 
 785   Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);
 786   void duplicate_predicates_helper(Node* predicate, Node* start, Node* end, IdealLoopTree* outer_loop,
 787                                    LoopNode* outer_main_head, uint dd_main_head);
 788   void duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end, IdealLoopTree* outer_loop,
 789                             LoopNode* outer_main_head, uint dd_main_head);
 790   Node* clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
 791                                   Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj);
 792   bool skeleton_predicate_has_opaque(IfNode* iff);
 793   void update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);
 794   void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);
</pre>
<hr />
<pre>
 814     assert( ctrl-&gt;in(0), &quot;cannot set dead control node&quot; );
 815     assert( ctrl == find_non_split_ctrl(ctrl), &quot;must set legal crtl&quot; );
 816     _nodes.map( n-&gt;_idx, (Node*)((intptr_t)ctrl + 1) );
 817   }
 818   // Set control and update loop membership
 819   void set_ctrl_and_loop(Node* n, Node* ctrl) {
 820     IdealLoopTree* old_loop = get_loop(get_ctrl(n));
 821     IdealLoopTree* new_loop = get_loop(ctrl);
 822     if (old_loop != new_loop) {
 823       if (old_loop-&gt;_child == NULL) old_loop-&gt;_body.yank(n);
 824       if (new_loop-&gt;_child == NULL) new_loop-&gt;_body.push(n);
 825     }
 826     set_ctrl(n, ctrl);
 827   }
 828   // Control nodes can be replaced or subsumed.  During this pass they
 829   // get their replacement Node in slot 1.  Instead of updating the block
 830   // location of all Nodes in the subsumed block, we lazily do it.  As we
 831   // pull such a subsumed block out of the array, we write back the final
 832   // correct block.
 833   Node *get_ctrl( Node *i ) {
<span class="line-added"> 834 </span>
 835     assert(has_node(i), &quot;&quot;);
 836     Node *n = get_ctrl_no_update(i);
 837     _nodes.map( i-&gt;_idx, (Node*)((intptr_t)n + 1) );
 838     assert(has_node(i) &amp;&amp; has_ctrl(i), &quot;&quot;);
 839     assert(n == find_non_split_ctrl(n), &quot;must return legal ctrl&quot; );
 840     return n;
 841   }
 842   // true if CFG node d dominates CFG node n
 843   bool is_dominator(Node *d, Node *n);
 844   // return get_ctrl for a data node and self(n) for a CFG node
 845   Node* ctrl_or_self(Node* n) {
 846     if (has_ctrl(n))
 847       return get_ctrl(n);
 848     else {
 849       assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
 850       return n;
 851     }
 852   }
 853 
 854   Node *get_ctrl_no_update_helper(Node *i) const {
</pre>
<hr />
<pre>
 906   // Place Data nodes in some loop nest
 907   void build_loop_early( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 908   void build_loop_late ( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack );
 909   void build_loop_late_post_work(Node* n, bool pinned);
 910   void build_loop_late_post(Node* n);
 911   void verify_strip_mined_scheduling(Node *n, Node* least);
 912 
 913   // Array of immediate dominance info for each CFG node indexed by node idx
 914 private:
 915   uint _idom_size;
 916   Node **_idom;                  // Array of immediate dominators
 917   uint *_dom_depth;              // Used for fast LCA test
 918   GrowableArray&lt;uint&gt;* _dom_stk; // For recomputation of dom depth
 919 
 920   // Perform verification that the graph is valid.
 921   PhaseIdealLoop( PhaseIterGVN &amp;igvn) :
 922     PhaseTransform(Ideal_Loop),
 923     _igvn(igvn),
 924     _verify_me(NULL),
 925     _verify_only(true),
<span class="line-modified"> 926     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added"> 927     _nodes_required(UINT_MAX) {</span>
 928     build_and_optimize(LoopOptsVerify);
 929   }
 930 
 931   // build the loop tree and perform any requested optimizations
 932   void build_and_optimize(LoopOptsMode mode);
 933 
 934   // Dominators for the sea of nodes
 935   void Dominators();
 936 
 937   // Compute the Ideal Node to Loop mapping
 938   PhaseIdealLoop(PhaseIterGVN &amp;igvn, LoopOptsMode mode) :
 939     PhaseTransform(Ideal_Loop),
 940     _igvn(igvn),
 941     _verify_me(NULL),
 942     _verify_only(false),
<span class="line-modified"> 943     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added"> 944     _nodes_required(UINT_MAX) {</span>
 945     build_and_optimize(mode);
 946   }
 947 
 948   // Verify that verify_me made the same decisions as a fresh run.
 949   PhaseIdealLoop(PhaseIterGVN &amp;igvn, const PhaseIdealLoop *verify_me) :
 950     PhaseTransform(Ideal_Loop),
 951     _igvn(igvn),
 952     _verify_me(verify_me),
 953     _verify_only(false),
<span class="line-modified"> 954     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added"> 955     _nodes_required(UINT_MAX) {</span>
 956     build_and_optimize(LoopOptsVerify);
 957   }
 958 
 959 public:
 960   Node* idom_no_update(Node* d) const {
 961     return idom_no_update(d-&gt;_idx);
 962   }
 963 
 964   Node* idom_no_update(uint didx) const {
 965     assert(didx &lt; _idom_size, &quot;oob&quot;);
 966     Node* n = _idom[didx];
 967     assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 968     while (n-&gt;in(0) == NULL) { // Skip dead CFG nodes
 969       n = (Node*)(((intptr_t)_nodes[n-&gt;_idx]) &amp; ~1);
 970       assert(n != NULL,&quot;Bad immediate dominator info.&quot;);
 971     }
 972     return n;
 973   }
 974 
 975   Node *idom(Node* d) const {
</pre>
<hr />
<pre>
1007   // Build and verify the loop tree without modifying the graph.  This
1008   // is useful to verify that all inputs properly dominate their uses.
1009   static void verify(PhaseIterGVN&amp; igvn) {
1010 #ifdef ASSERT
1011     ResourceMark rm;
1012     PhaseIdealLoop v(igvn);
1013 #endif
1014   }
1015 
1016   // Recommended way to use PhaseIdealLoop.
1017   // Run PhaseIdealLoop in some mode and allocates a local scope for memory allocations.
1018   static void optimize(PhaseIterGVN &amp;igvn, LoopOptsMode mode) {
1019     ResourceMark rm;
1020     PhaseIdealLoop v(igvn, mode);
1021   }
1022 
1023   // True if the method has at least 1 irreducible loop
1024   bool _has_irreducible_loops;
1025 
1026   // Per-Node transform
<span class="line-modified">1027   virtual Node* transform(Node* n) { return 0; }</span>
1028 
<span class="line-modified">1029   bool is_counted_loop(Node* n, IdealLoopTree* &amp;loop);</span>
1030   IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
1031                                                IdealLoopTree* loop, float cl_prob, float le_fcnt,
1032                                                Node*&amp; entry_control, Node*&amp; iffalse);
1033 
1034   Node* exact_limit( IdealLoopTree *loop );
1035 
1036   // Return a post-walked LoopNode
1037   IdealLoopTree *get_loop( Node *n ) const {
1038     // Dead nodes have no loop, so return the top level loop instead
1039     if (!has_node(n))  return _ltree_root;
1040     assert(!has_ctrl(n), &quot;&quot;);
1041     return (IdealLoopTree*)_nodes[n-&gt;_idx];
1042   }
1043 
<span class="line-modified">1044   IdealLoopTree* ltree_root() const { return _ltree_root; }</span>
1045 
1046   // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
1047   int is_member( const IdealLoopTree *loop, Node *n ) const {
1048     return loop-&gt;is_member(get_loop(n)); }
1049 
1050   // This is the basic building block of the loop optimizations.  It clones an
1051   // entire loop body.  It makes an old_new loop body mapping; with this
1052   // mapping you can find the new-loop equivalent to an old-loop node.  All
1053   // new-loop nodes are exactly equal to their old-loop counterparts, all
1054   // edges are the same.  All exits from the old-loop now have a RegionNode
1055   // that merges the equivalent new-loop path.  This is true even for the
1056   // normal &quot;loop-exit&quot; condition.  All uses of loop-invariant old-loop values
1057   // now come from (one or more) Phis that merge their new-loop equivalents.
1058   // Parameter side_by_side_idom:
1059   //   When side_by_size_idom is NULL, the dominator tree is constructed for
1060   //      the clone loop to dominate the original.  Used in construction of
1061   //      pre-main-post loop sequence.
1062   //   When nonnull, the clone and original are side-by-side, both are
1063   //      dominated by the passed in side_by_side_idom node.  Used in
1064   //      construction of unswitched loops.
</pre>
<hr />
<pre>
1121   void mark_reductions( IdealLoopTree *loop );
1122 
1123   // Return true if exp is a constant times an induction var
1124   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1125 
1126   // Return true if exp is a scaled induction var plus (or minus) constant
1127   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1128 
1129   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
1130   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
1131                                         Deoptimization::DeoptReason reason,
1132                                         int opcode);
1133   void register_control(Node* n, IdealLoopTree *loop, Node* pred);
1134 
1135   // Clone loop predicates to cloned loops (peeled, unswitched)
1136   static ProjNode* clone_predicate(ProjNode* predicate_proj, Node* new_entry,
1137                                    Deoptimization::DeoptReason reason,
1138                                    PhaseIdealLoop* loop_phase,
1139                                    PhaseIterGVN* igvn);
1140 




1141   static Node* clone_loop_predicates(Node* old_entry, Node* new_entry,
1142                                          bool clone_limit_check,
1143                                          PhaseIdealLoop* loop_phase,
1144                                          PhaseIterGVN* igvn);
1145   Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check);
1146 
1147   static Node* skip_all_loop_predicates(Node* entry);
1148   static Node* skip_loop_predicates(Node* entry);
1149 
1150   // Find a good location to insert a predicate
1151   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1152   // Find a predicate
1153   static Node* find_predicate(Node* entry);
1154   // Construct a range check for a predicate if
1155   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1156                          int scale, Node* offset,
1157                          Node* init, Node* limit, jint stride,
1158                          Node* range, bool upper, bool &amp;overflow);
1159 
1160   // Implementation of the loop predication to promote checks outside the loop
</pre>
<hr />
<pre>
1293 
1294   // Rework addressing expressions to get the most loop-invariant stuff
1295   // moved out.  We&#39;d like to do all associative operators, but it&#39;s especially
1296   // important (common) to do address expressions.
1297   Node *remix_address_expressions( Node *n );
1298 
1299   // Convert add to muladd to generate MuladdS2I under certain criteria
1300   Node * convert_add_to_muladd(Node * n);
1301 
1302   // Attempt to use a conditional move instead of a phi/branch
1303   Node *conditional_move( Node *n );
1304 
1305   // Reorganize offset computations to lower register pressure.
1306   // Mostly prevent loop-fallout uses of the pre-incremented trip counter
1307   // (which are then alive with the post-incremented trip counter
1308   // forcing an extra register move)
1309   void reorg_offsets( IdealLoopTree *loop );
1310 
1311   // Check for aggressive application of &#39;split-if&#39; optimization,
1312   // using basic block level info.
<span class="line-modified">1313   void  split_if_with_blocks     ( VectorSet &amp;visited, Node_Stack &amp;nstack);</span>
1314   Node *split_if_with_blocks_pre ( Node *n );
<span class="line-modified">1315   void  split_if_with_blocks_post( Node *n );</span>
1316   Node *has_local_phi_input( Node *n );
1317   // Mark an IfNode as being dominated by a prior test,
1318   // without actually altering the CFG (and hence IDOM info).
1319   void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );
1320 
1321   // Split Node &#39;n&#39; through merge point
1322   Node *split_thru_region( Node *n, Node *region );
1323   // Split Node &#39;n&#39; through merge point if there is enough win.
1324   Node *split_thru_phi( Node *n, Node *region, int policy );
1325   // Found an If getting its condition-code input from a Phi in the
1326   // same block.  Split thru the Region.
1327   void do_split_if( Node *iff );
1328 
<span class="line-modified">1329   // Conversion of fill/copy patterns into intrinsic versions</span>
1330   bool do_intrinsify_fill();
1331   bool intrinsify_fill(IdealLoopTree* lpt);
1332   bool match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
1333                        Node*&amp; shift, Node*&amp; offset);
1334 
1335 private:
1336   // Return a type based on condition control flow
1337   const TypeInt* filtered_type( Node *n, Node* n_ctrl);
1338   const TypeInt* filtered_type( Node *n ) { return filtered_type(n, NULL); }
1339  // Helpers for filtered type
1340   const TypeInt* filtered_type_from_dominators( Node* val, Node *val_ctrl);
1341 
1342   // Helper functions
1343   Node *spinup( Node *iff, Node *new_false, Node *new_true, Node *region, Node *phi, small_cache *cache );
1344   Node *find_use_block( Node *use, Node *def, Node *old_false, Node *new_false, Node *old_true, Node *new_true );
1345   void handle_use( Node *use, Node *def, small_cache *cache, Node *region_dom, Node *new_false, Node *new_true, Node *old_false, Node *old_true );
1346   bool split_up( Node *n, Node *blk1, Node *blk2 );
1347   void sink_use( Node *use, Node *post_loop );
1348   Node *place_near_use( Node *useblock ) const;
1349   Node* try_move_store_before_loop(Node* n, Node *n_ctrl);
1350   void try_move_store_after_loop(Node* n);
1351   bool identical_backtoback_ifs(Node *n);
1352   bool can_split_if(Node *n_ctrl);
1353 
1354   // Determine if a method is too big for a/another round of split-if, based on
1355   // a magic (approximate) ratio derived from the equally magic constant 35000,
1356   // previously used for this purpose (but without relating to the node limit).
1357   bool must_throttle_split_if() {
1358     uint threshold = C-&gt;max_node_limit() * 2 / 5;
1359     return C-&gt;live_nodes() &gt; threshold;
1360   }
1361 
<span class="line-added">1362   // A simplistic node request tracking mechanism, where</span>
<span class="line-added">1363   //   = UINT_MAX   Request not valid or made final.</span>
<span class="line-added">1364   //   &lt; UINT_MAX   Nodes currently requested (estimate).</span>
<span class="line-added">1365   uint _nodes_required;</span>
<span class="line-added">1366 </span>
<span class="line-added">1367   enum { REQUIRE_MIN = 70 };</span>
<span class="line-added">1368 </span>
<span class="line-added">1369   uint nodes_required() const { return _nodes_required; }</span>
<span class="line-added">1370 </span>
<span class="line-added">1371   // Given the _currently_  available number of nodes, check  whether there is</span>
<span class="line-added">1372   // &quot;room&quot; for an additional request or not, considering the already required</span>
<span class="line-added">1373   // number of  nodes.  Return TRUE if  the new request is  exceeding the node</span>
<span class="line-added">1374   // budget limit, otherwise return FALSE.  Note that this interpretation will</span>
<span class="line-added">1375   // act pessimistic on  additional requests when new nodes  have already been</span>
<span class="line-added">1376   // generated since the &#39;begin&#39;.  This behaviour fits with the intention that</span>
<span class="line-added">1377   // node estimates/requests should be made upfront.</span>
<span class="line-added">1378   bool exceeding_node_budget(uint required = 0) {</span>
<span class="line-added">1379     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(), &quot;sanity&quot;);</span>
<span class="line-added">1380     uint available = C-&gt;max_node_limit() - C-&gt;live_nodes();</span>
<span class="line-added">1381     return available &lt; required + _nodes_required + REQUIRE_MIN;</span>
<span class="line-added">1382   }</span>
<span class="line-added">1383 </span>
<span class="line-added">1384   uint require_nodes(uint require, uint minreq = REQUIRE_MIN) {</span>
<span class="line-added">1385     precond(require &gt; 0);</span>
<span class="line-added">1386     _nodes_required += MAX2(require, minreq);</span>
<span class="line-added">1387     return _nodes_required;</span>
<span class="line-added">1388   }</span>
<span class="line-added">1389 </span>
<span class="line-added">1390   bool may_require_nodes(uint require, uint minreq = REQUIRE_MIN) {</span>
<span class="line-added">1391     return !exceeding_node_budget(require) &amp;&amp; require_nodes(require, minreq) &gt; 0;</span>
<span class="line-added">1392   }</span>
<span class="line-added">1393 </span>
<span class="line-added">1394   uint require_nodes_begin() {</span>
<span class="line-added">1395     assert(_nodes_required == UINT_MAX, &quot;Bad state (begin).&quot;);</span>
<span class="line-added">1396     _nodes_required = 0;</span>
<span class="line-added">1397     return C-&gt;live_nodes();</span>
<span class="line-added">1398   }</span>
<span class="line-added">1399 </span>
<span class="line-added">1400   // When a node request is final,  optionally check that the requested number</span>
<span class="line-added">1401   // of nodes was  reasonably correct with respect to the  number of new nodes</span>
<span class="line-added">1402   // introduced since the last &#39;begin&#39;. Always check that we have not exceeded</span>
<span class="line-added">1403   // the maximum node limit.</span>
<span class="line-added">1404   void require_nodes_final(uint live_at_begin, bool check_estimate) {</span>
<span class="line-added">1405     assert(_nodes_required &lt; UINT_MAX, &quot;Bad state (final).&quot;);</span>
<span class="line-added">1406 </span>
<span class="line-added">1407     if (check_estimate) {</span>
<span class="line-added">1408       // Assert that the node budget request was not off by too much (x2).</span>
<span class="line-added">1409       // Should this be the case we _surely_ need to improve the estimates</span>
<span class="line-added">1410       // used in our budget calculations.</span>
<span class="line-added">1411       assert(C-&gt;live_nodes() - live_at_begin &lt;= 2 * _nodes_required,</span>
<span class="line-added">1412              &quot;Bad node estimate: actual = %d &gt;&gt; request = %d&quot;,</span>
<span class="line-added">1413              C-&gt;live_nodes() - live_at_begin, _nodes_required);</span>
<span class="line-added">1414     }</span>
<span class="line-added">1415     // Assert that we have stayed within the node budget limit.</span>
<span class="line-added">1416     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(),</span>
<span class="line-added">1417            &quot;Exceeding node budget limit: %d + %d &gt; %d (request = %d)&quot;,</span>
<span class="line-added">1418            C-&gt;live_nodes() - live_at_begin, live_at_begin,</span>
<span class="line-added">1419            C-&gt;max_node_limit(), _nodes_required);</span>
<span class="line-added">1420 </span>
<span class="line-added">1421     _nodes_required = UINT_MAX;</span>
<span class="line-added">1422   }</span>
<span class="line-added">1423 </span>
1424   bool _created_loop_node;
<span class="line-added">1425 </span>
1426 public:
1427   void set_created_loop_node() { _created_loop_node = true; }
1428   bool created_loop_node()     { return _created_loop_node; }
<span class="line-modified">1429   void register_new_node(Node* n, Node* blk);</span>
1430 
1431 #ifdef ASSERT
1432   void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
1433 #endif
1434 
1435 #ifndef PRODUCT
<span class="line-modified">1436   void dump() const;</span>
<span class="line-modified">1437   void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &amp;rpo_list) const;</span>
1438   void verify() const;          // Major slow  :-)
<span class="line-modified">1439   void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &amp;visited) const;</span>
<span class="line-modified">1440   IdealLoopTree* get_loop_idx(Node* n) const {</span>
1441     // Dead nodes have no loop, so return the top level loop instead
1442     return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
1443   }
1444   // Print some stats
1445   static void print_statistics();
1446   static int _loop_invokes;     // Count of PhaseIdealLoop invokes
1447   static int _loop_work;        // Sum of PhaseIdealLoop x _unique
1448 #endif
<span class="line-modified">1449 </span>
<span class="line-added">1450   void rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const;</span>
1451 };
1452 
<span class="line-added">1453 </span>
<span class="line-added">1454 class AutoNodeBudget : public StackObj</span>
<span class="line-added">1455 {</span>
<span class="line-added">1456 public:</span>
<span class="line-added">1457   enum budget_check_t { BUDGET_CHECK, NO_BUDGET_CHECK };</span>
<span class="line-added">1458 </span>
<span class="line-added">1459   AutoNodeBudget(PhaseIdealLoop* phase, budget_check_t chk = BUDGET_CHECK)</span>
<span class="line-added">1460     : _phase(phase),</span>
<span class="line-added">1461       _check_at_final(chk == BUDGET_CHECK),</span>
<span class="line-added">1462       _nodes_at_begin(0)</span>
<span class="line-added">1463   {</span>
<span class="line-added">1464     precond(_phase != NULL);</span>
<span class="line-added">1465 </span>
<span class="line-added">1466     _nodes_at_begin = _phase-&gt;require_nodes_begin();</span>
<span class="line-added">1467   }</span>
<span class="line-added">1468 </span>
<span class="line-added">1469   ~AutoNodeBudget() {</span>
<span class="line-added">1470 #ifndef PRODUCT</span>
<span class="line-added">1471     if (TraceLoopOpts) {</span>
<span class="line-added">1472       uint request = _phase-&gt;nodes_required();</span>
<span class="line-added">1473       uint delta   = _phase-&gt;C-&gt;live_nodes() - _nodes_at_begin;</span>
<span class="line-added">1474 </span>
<span class="line-added">1475       if (request &lt; delta) {</span>
<span class="line-added">1476         tty-&gt;print_cr(&quot;Exceeding node budget: %d &lt; %d&quot;, request, delta);</span>
<span class="line-added">1477       } else {</span>
<span class="line-added">1478         uint const REQUIRE_MIN = PhaseIdealLoop::REQUIRE_MIN;</span>
<span class="line-added">1479         // Identify the worst estimates as &quot;poor&quot; ones.</span>
<span class="line-added">1480         if (request &gt; REQUIRE_MIN &amp;&amp; delta &gt; 0) {</span>
<span class="line-added">1481           if ((delta &gt;  REQUIRE_MIN &amp;&amp; request &gt;  3 * delta) ||</span>
<span class="line-added">1482               (delta &lt;= REQUIRE_MIN &amp;&amp; request &gt; 10 * delta)) {</span>
<span class="line-added">1483             tty-&gt;print_cr(&quot;Poor node estimate: %d &gt;&gt; %d&quot;, request, delta);</span>
<span class="line-added">1484           }</span>
<span class="line-added">1485         }</span>
<span class="line-added">1486       }</span>
<span class="line-added">1487     }</span>
<span class="line-added">1488 #endif // PRODUCT</span>
<span class="line-added">1489     _phase-&gt;require_nodes_final(_nodes_at_begin, _check_at_final);</span>
<span class="line-added">1490   }</span>
<span class="line-added">1491 </span>
<span class="line-added">1492 private:</span>
<span class="line-added">1493   PhaseIdealLoop* _phase;</span>
<span class="line-added">1494   bool _check_at_final;</span>
<span class="line-added">1495   uint _nodes_at_begin;</span>
<span class="line-added">1496 };</span>
<span class="line-added">1497 </span>
<span class="line-added">1498 </span>
1499 // This kit may be used for making of a reserved copy of a loop before this loop
1500 //  goes under non-reversible changes.
1501 //
1502 // Function create_reserve() creates a reserved copy (clone) of the loop.
1503 // The reserved copy is created by calling
1504 // PhaseIdealLoop::create_reserve_version_of_loop - see there how
1505 // the original and reserved loops are connected in the outer graph.
1506 // If create_reserve succeeded, it returns &#39;true&#39; and _has_reserved is set to &#39;true&#39;.
1507 //
1508 // By default the reserved copy (clone) of the loop is created as dead code - it is
1509 // dominated in the outer loop by this node chain:
1510 //   intcon(1)-&gt;If-&gt;IfFalse-&gt;reserved_copy.
1511 // The original loop is dominated by the the same node chain but IfTrue projection:
1512 //   intcon(0)-&gt;If-&gt;IfTrue-&gt;original_loop.
1513 //
1514 // In this implementation of CountedLoopReserveKit the ctor includes create_reserve()
1515 // and the dtor, checks _use_new value.
1516 // If _use_new == false, it &quot;switches&quot; control to reserved copy of the loop
1517 // by simple replacing of node intcon(1) with node intcon(0).
1518 //
</pre>
<hr />
<pre>
1542     PhaseIdealLoop* _phase;
1543     IdealLoopTree*  _lpt;
1544     LoopNode*       _lp;
1545     IfNode*         _iff;
1546     LoopNode*       _lp_reserved;
1547     bool            _has_reserved;
1548     bool            _use_new;
1549     const bool      _active; //may be set to false in ctor, then the object is dummy
1550 
1551   public:
1552     CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active);
1553     ~CountedLoopReserveKit();
1554     void use_new()                {_use_new = true;}
1555     void set_iff(IfNode* x)       {_iff = x;}
1556     bool has_reserved()     const { return _active &amp;&amp; _has_reserved;}
1557   private:
1558     bool create_reserve();
1559 };// class CountedLoopReserveKit
1560 
1561 inline Node* IdealLoopTree::tail() {
<span class="line-modified">1562   // Handle lazy update of _tail field.</span>
<span class="line-modified">1563   if (_tail-&gt;in(0) == NULL) {</span>
<span class="line-modified">1564     _tail = _phase-&gt;get_ctrl(_tail);</span>
<span class="line-modified">1565   }</span>
<span class="line-modified">1566   return _tail;</span>



1567 }
1568 
1569 
1570 // Iterate over the loop tree using a preorder, left-to-right traversal.
1571 //
1572 // Example that visits all counted loops from within PhaseIdealLoop
1573 //
1574 //  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
1575 //   IdealLoopTree* lpt = iter.current();
1576 //   if (!lpt-&gt;is_counted()) continue;
1577 //   ...
1578 class LoopTreeIterator : public StackObj {
1579 private:
1580   IdealLoopTree* _root;
1581   IdealLoopTree* _curnt;
1582 
1583 public:
1584   LoopTreeIterator(IdealLoopTree* root) : _root(root), _curnt(root) {}
1585 
1586   bool done() { return _curnt == NULL; }       // Finished iterating?
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/opto/cfgnode.cpp b/src/hotspot/share/opto/cfgnode.cpp
--- a/src/hotspot/share/opto/cfgnode.cpp
+++ b/src/hotspot/share/opto/cfgnode.cpp
@@ -881,11 +881,11 @@
 // note that these functions assume that the _adr_type field is flattened
 uint PhiNode::hash() const {
   const Type* at = _adr_type;
   return TypeNode::hash() + (at ? at->hash() : 0);
 }
-uint PhiNode::cmp( const Node &n ) const {
+bool PhiNode::cmp( const Node &n ) const {
   return TypeNode::cmp(n) && _adr_type == ((PhiNode&)n)._adr_type;
 }
 static inline
 const TypePtr* flatten_phi_adr_type(const TypePtr* at) {
   if (at == NULL || at == TypePtr::BOTTOM)  return at;
@@ -1447,14 +1447,11 @@
   } else if( b->_test._test == BoolTest::eq ) {
     flipped = 1-flipped;
   } else return NULL;
 
   // Build int->bool conversion
-  Node *in1 = cmp->in(1);
-  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
-  in1 = bs->step_over_gc_barrier(in1);
-  Node *n = new Conv2BNode(in1);
+  Node *n = new Conv2BNode(cmp->in(1));
   if( flipped )
     n = new XorINode( phase->transform(n), phase->intcon(1) );
 
   return n;
 }
@@ -1876,16 +1873,17 @@
     if (uncasted) {
       // Add cast nodes between the phi to be removed and its unique input.
       // Wait until after parsing for the type information to propagate from the casts.
       assert(can_reshape, "Invalid during parsing");
       const Type* phi_type = bottom_type();
-      assert(phi_type->isa_int() || phi_type->isa_ptr(), "bad phi type");
-      // Add casts to carry the control dependency of the Phi that is
-      // going away
+      assert(phi_type->isa_int() || phi_type->isa_long() || phi_type->isa_ptr(), "bad phi type");
+      // Add casts to carry the control dependency of the Phi that is going away
       Node* cast = NULL;
       if (phi_type->isa_int()) {
         cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);
+      } else if (phi_type->isa_long()) {
+        cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);
       } else {
         const Type* uin_type = phase->type(uin);
         if (!phi_type->isa_oopptr() && !uin_type->isa_oopptr()) {
           cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
         } else {
@@ -1990,38 +1988,57 @@
     if (opt != NULL)  return opt;
   }
 
   if (in(1) != NULL && in(1)->Opcode() == Op_AddP && can_reshape) {
     // Try to undo Phi of AddP:
-    // (Phi (AddP base base y) (AddP base2 base2 y))
+    // (Phi (AddP base address offset) (AddP base2 address2 offset2))
     // becomes:
     // newbase := (Phi base base2)
-    // (AddP newbase newbase y)
+    // newaddress := (Phi address address2)
+    // newoffset := (Phi offset offset2)
+    // (AddP newbase newaddress newoffset)
     //
     // This occurs as a result of unsuccessful split_thru_phi and
     // interferes with taking advantage of addressing modes. See the
     // clone_shift_expressions code in matcher.cpp
     Node* addp = in(1);
-    const Type* type = addp->in(AddPNode::Base)->bottom_type();
-    Node* y = addp->in(AddPNode::Offset);
-    if (y != NULL && addp->in(AddPNode::Base) == addp->in(AddPNode::Address)) {
+    Node* base = addp->in(AddPNode::Base);
+    Node* address = addp->in(AddPNode::Address);
+    Node* offset = addp->in(AddPNode::Offset);
+    if (base != NULL && address != NULL && offset != NULL &&
+        !base->is_top() && !address->is_top() && !offset->is_top()) {
+      const Type* base_type = base->bottom_type();
+      const Type* address_type = address->bottom_type();
       // make sure that all the inputs are similar to the first one,
       // i.e. AddP with base == address and same offset as first AddP
       bool doit = true;
       for (uint i = 2; i < req(); i++) {
         if (in(i) == NULL ||
             in(i)->Opcode() != Op_AddP ||
-            in(i)->in(AddPNode::Base) != in(i)->in(AddPNode::Address) ||
-            in(i)->in(AddPNode::Offset) != y) {
+            in(i)->in(AddPNode::Base) == NULL ||
+            in(i)->in(AddPNode::Address) == NULL ||
+            in(i)->in(AddPNode::Offset) == NULL ||
+            in(i)->in(AddPNode::Base)->is_top() ||
+            in(i)->in(AddPNode::Address)->is_top() ||
+            in(i)->in(AddPNode::Offset)->is_top()) {
           doit = false;
           break;
         }
+        if (in(i)->in(AddPNode::Offset) != base) {
+          base = NULL;
+        }
+        if (in(i)->in(AddPNode::Offset) != offset) {
+          offset = NULL;
+        }
+        if (in(i)->in(AddPNode::Address) != address) {
+          address = NULL;
+        }
         // Accumulate type for resulting Phi
-        type = type->meet_speculative(in(i)->in(AddPNode::Base)->bottom_type());
+        base_type = base_type->meet_speculative(in(i)->in(AddPNode::Base)->bottom_type());
+        address_type = address_type->meet_speculative(in(i)->in(AddPNode::Base)->bottom_type());
       }
-      Node* base = NULL;
-      if (doit) {
+      if (doit && base == NULL) {
         // Check for neighboring AddP nodes in a tree.
         // If they have a base, use that it.
         for (DUIterator_Fast kmax, k = this->fast_outs(kmax); k < kmax; k++) {
           Node* u = this->fast_out(k);
           if (u->is_AddP()) {
@@ -2035,17 +2052,31 @@
           }
         }
       }
       if (doit) {
         if (base == NULL) {
-          base = new PhiNode(in(0), type, NULL);
+          base = new PhiNode(in(0), base_type, NULL);
           for (uint i = 1; i < req(); i++) {
             base->init_req(i, in(i)->in(AddPNode::Base));
           }
           phase->is_IterGVN()->register_new_node_with_optimizer(base);
         }
-        return new AddPNode(base, base, y);
+        if (address == NULL) {
+          address = new PhiNode(in(0), address_type, NULL);
+          for (uint i = 1; i < req(); i++) {
+            address->init_req(i, in(i)->in(AddPNode::Address));
+          }
+          phase->is_IterGVN()->register_new_node_with_optimizer(address);
+        }
+        if (offset == NULL) {
+          offset = new PhiNode(in(0), TypeX_X, NULL);
+          for (uint i = 1; i < req(); i++) {
+            offset->init_req(i, in(i)->in(AddPNode::Offset));
+          }
+          phase->is_IterGVN()->register_new_node_with_optimizer(offset);
+        }
+        return new AddPNode(base, address, offset);
       }
     }
   }
 
   // Split phis through memory merges, so that the memory merges will go away.
@@ -2351,11 +2382,11 @@
 
 
 //=============================================================================
 
 uint PCTableNode::hash() const { return Node::hash() + _size; }
-uint PCTableNode::cmp( const Node &n ) const
+bool PCTableNode::cmp( const Node &n ) const
 { return _size == ((PCTableNode&)n)._size; }
 
 const Type *PCTableNode::bottom_type() const {
   const Type** f = TypeTuple::fields(_size);
   for( uint i = 0; i < _size; i++ ) f[i] = Type::CONTROL;
@@ -2381,11 +2412,11 @@
 //=============================================================================
 uint JumpProjNode::hash() const {
   return Node::hash() + _dest_bci;
 }
 
-uint JumpProjNode::cmp( const Node &n ) const {
+bool JumpProjNode::cmp( const Node &n ) const {
   return ProjNode::cmp(n) &&
     _dest_bci == ((JumpProjNode&)n)._dest_bci;
 }
 
 #ifndef PRODUCT
@@ -2444,11 +2475,11 @@
 uint CatchProjNode::hash() const {
   return Node::hash() + _handler_bci;
 }
 
 
-uint CatchProjNode::cmp( const Node &n ) const {
+bool CatchProjNode::cmp( const Node &n ) const {
   return ProjNode::cmp(n) &&
     _handler_bci == ((CatchProjNode&)n)._handler_bci;
 }
 
 

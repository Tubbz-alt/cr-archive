<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/subnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/subnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
283   enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9 };
284   mask _test;
285   BoolTest( mask btm ) : _test(btm) {}
286   const Type *cc2logical( const Type *CC ) const;
287   // Commute the test.  I use a small table lookup.  The table is created as
288   // a simple char array where each element is the ASCII version of a &#39;mask&#39;
289   // enum from above.
290   mask commute( ) const { return mask(&quot;032147658&quot;[_test]-&#39;0&#39;); }
291   mask negate( ) const { return mask(_test^4); }
292   bool is_canonical( ) const { return (_test == BoolTest::ne || _test == BoolTest::lt || _test == BoolTest::le || _test == BoolTest::overflow); }
293   bool is_less( )  const { return _test == BoolTest::lt || _test == BoolTest::le; }
294   bool is_greater( ) const { return _test == BoolTest::gt || _test == BoolTest::ge; }
295   void dump_on(outputStream *st) const;
296   mask merge(BoolTest other) const;
297 };
298 
299 //------------------------------BoolNode---------------------------------------
300 // A Node to convert a Condition Codes to a Logical result.
301 class BoolNode : public Node {
302   virtual uint hash() const;
<span class="line-modified">303   virtual uint cmp( const Node &amp;n ) const;</span>
304   virtual uint size_of() const;
305 
306   // Try to optimize signed integer comparison
307   Node* fold_cmpI(PhaseGVN* phase, SubNode* cmp, Node* cmp1, int cmp_op,
308                   int cmp1_op, const TypeInt* cmp2_type);
309 public:
310   const BoolTest _test;
311   BoolNode( Node *cc, BoolTest::mask t): Node(0,cc), _test(t) {
312     init_class_id(Class_Bool);
313   }
314   // Convert an arbitrary int value to a Bool or other suitable predicate.
315   static Node* make_predicate(Node* test_value, PhaseGVN* phase);
316   // Convert self back to an integer value.
317   Node* as_int_value(PhaseGVN* phase);
318   // Invert sense of self, returning new Bool.
319   BoolNode* negate(PhaseGVN* phase);
320   virtual int Opcode() const;
321   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
322   virtual const Type* Value(PhaseGVN* phase) const;
323   virtual const Type *bottom_type() const { return TypeInt::BOOL; }
</pre>
<hr />
<pre>
333 
334 //------------------------------AbsNode----------------------------------------
335 // Abstract class for absolute value.  Mostly used to get a handy wrapper
336 // for finding this pattern in the graph.
337 class AbsNode : public Node {
338 public:
339   AbsNode( Node *value ) : Node(0,value) {}
340 };
341 
342 //------------------------------AbsINode---------------------------------------
343 // Absolute value an integer.  Since a naive graph involves control flow, we
344 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
345 class AbsINode : public AbsNode {
346 public:
347   AbsINode( Node *in1 ) : AbsNode(in1) {}
348   virtual int Opcode() const;
349   const Type *bottom_type() const { return TypeInt::INT; }
350   virtual uint ideal_reg() const { return Op_RegI; }
351 };
352 











353 //------------------------------AbsFNode---------------------------------------
354 // Absolute value a float, a common float-point idiom with a cheap hardware
355 // implemention on most chips.  Since a naive graph involves control flow, we
356 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
357 class AbsFNode : public AbsNode {
358 public:
359   AbsFNode( Node *in1 ) : AbsNode(in1) {}
360   virtual int Opcode() const;
361   const Type *bottom_type() const { return Type::FLOAT; }
362   virtual uint ideal_reg() const { return Op_RegF; }
363 };
364 
365 //------------------------------AbsDNode---------------------------------------
366 // Absolute value a double, a common float-point idiom with a cheap hardware
367 // implemention on most chips.  Since a naive graph involves control flow, we
368 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
369 class AbsDNode : public AbsNode {
370 public:
371   AbsDNode( Node *in1 ) : AbsNode(in1) {}
372   virtual int Opcode() const;
</pre>
</td>
<td>
<hr />
<pre>
283   enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9 };
284   mask _test;
285   BoolTest( mask btm ) : _test(btm) {}
286   const Type *cc2logical( const Type *CC ) const;
287   // Commute the test.  I use a small table lookup.  The table is created as
288   // a simple char array where each element is the ASCII version of a &#39;mask&#39;
289   // enum from above.
290   mask commute( ) const { return mask(&quot;032147658&quot;[_test]-&#39;0&#39;); }
291   mask negate( ) const { return mask(_test^4); }
292   bool is_canonical( ) const { return (_test == BoolTest::ne || _test == BoolTest::lt || _test == BoolTest::le || _test == BoolTest::overflow); }
293   bool is_less( )  const { return _test == BoolTest::lt || _test == BoolTest::le; }
294   bool is_greater( ) const { return _test == BoolTest::gt || _test == BoolTest::ge; }
295   void dump_on(outputStream *st) const;
296   mask merge(BoolTest other) const;
297 };
298 
299 //------------------------------BoolNode---------------------------------------
300 // A Node to convert a Condition Codes to a Logical result.
301 class BoolNode : public Node {
302   virtual uint hash() const;
<span class="line-modified">303   virtual bool cmp( const Node &amp;n ) const;</span>
304   virtual uint size_of() const;
305 
306   // Try to optimize signed integer comparison
307   Node* fold_cmpI(PhaseGVN* phase, SubNode* cmp, Node* cmp1, int cmp_op,
308                   int cmp1_op, const TypeInt* cmp2_type);
309 public:
310   const BoolTest _test;
311   BoolNode( Node *cc, BoolTest::mask t): Node(0,cc), _test(t) {
312     init_class_id(Class_Bool);
313   }
314   // Convert an arbitrary int value to a Bool or other suitable predicate.
315   static Node* make_predicate(Node* test_value, PhaseGVN* phase);
316   // Convert self back to an integer value.
317   Node* as_int_value(PhaseGVN* phase);
318   // Invert sense of self, returning new Bool.
319   BoolNode* negate(PhaseGVN* phase);
320   virtual int Opcode() const;
321   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
322   virtual const Type* Value(PhaseGVN* phase) const;
323   virtual const Type *bottom_type() const { return TypeInt::BOOL; }
</pre>
<hr />
<pre>
333 
334 //------------------------------AbsNode----------------------------------------
335 // Abstract class for absolute value.  Mostly used to get a handy wrapper
336 // for finding this pattern in the graph.
337 class AbsNode : public Node {
338 public:
339   AbsNode( Node *value ) : Node(0,value) {}
340 };
341 
342 //------------------------------AbsINode---------------------------------------
343 // Absolute value an integer.  Since a naive graph involves control flow, we
344 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
345 class AbsINode : public AbsNode {
346 public:
347   AbsINode( Node *in1 ) : AbsNode(in1) {}
348   virtual int Opcode() const;
349   const Type *bottom_type() const { return TypeInt::INT; }
350   virtual uint ideal_reg() const { return Op_RegI; }
351 };
352 
<span class="line-added">353 //------------------------------AbsLNode---------------------------------------</span>
<span class="line-added">354 // Absolute value a long.  Since a naive graph involves control flow, we</span>
<span class="line-added">355 // &quot;match&quot; it in the ideal world (so the control flow can be removed).</span>
<span class="line-added">356 class AbsLNode : public AbsNode {</span>
<span class="line-added">357 public:</span>
<span class="line-added">358   AbsLNode( Node *in1 ) : AbsNode(in1) {}</span>
<span class="line-added">359   virtual int Opcode() const;</span>
<span class="line-added">360   const Type *bottom_type() const { return TypeLong::LONG; }</span>
<span class="line-added">361   virtual uint ideal_reg() const { return Op_RegL; }</span>
<span class="line-added">362 };</span>
<span class="line-added">363 </span>
364 //------------------------------AbsFNode---------------------------------------
365 // Absolute value a float, a common float-point idiom with a cheap hardware
366 // implemention on most chips.  Since a naive graph involves control flow, we
367 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
368 class AbsFNode : public AbsNode {
369 public:
370   AbsFNode( Node *in1 ) : AbsNode(in1) {}
371   virtual int Opcode() const;
372   const Type *bottom_type() const { return Type::FLOAT; }
373   virtual uint ideal_reg() const { return Op_RegF; }
374 };
375 
376 //------------------------------AbsDNode---------------------------------------
377 // Absolute value a double, a common float-point idiom with a cheap hardware
378 // implemention on most chips.  Since a naive graph involves control flow, we
379 // &quot;match&quot; it in the ideal world (so the control flow can be removed).
380 class AbsDNode : public AbsNode {
381 public:
382   AbsDNode( Node *in1 ) : AbsNode(in1) {}
383   virtual int Opcode() const;
</pre>
</td>
</tr>
</table>
<center><a href="subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="superword.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
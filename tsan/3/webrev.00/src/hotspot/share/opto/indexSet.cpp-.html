<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/indexSet.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;opto/chaitin.hpp&quot;
 28 #include &quot;opto/compile.hpp&quot;
 29 #include &quot;opto/indexSet.hpp&quot;
 30 #include &quot;opto/regmask.hpp&quot;
 31 
 32 // This file defines the IndexSet class, a set of sparse integer indices.
 33 // This data structure is used by the compiler in its liveness analysis and
 34 // during register allocation.  It also defines an iterator for this class.
 35 
 36 //-------------------------------- Initializations ------------------------------
 37 
 38 IndexSet::BitBlock  IndexSet::_empty_block     = IndexSet::BitBlock();
 39 
 40 #ifdef ASSERT
 41 // Initialize statistics counters
 42 julong IndexSet::_alloc_new = 0;
 43 julong IndexSet::_alloc_total = 0;
 44 
 45 julong IndexSet::_total_bits = 0;
 46 julong IndexSet::_total_used_blocks = 0;
 47 julong IndexSet::_total_unused_blocks = 0;
 48 
 49 // Per set, or all sets operation tracing
 50 int IndexSet::_serial_count = 1;
 51 #endif
 52 
 53 //---------------------------- IndexSet::populate_free_list() -----------------------------
 54 // Populate the free BitBlock list with a batch of BitBlocks.  The BitBlocks
 55 // are 32 bit aligned.
 56 
 57 void IndexSet::populate_free_list() {
 58   Compile *compile = Compile::current();
 59   BitBlock *free = (BitBlock*)compile-&gt;indexSet_free_block_list();
 60 
 61   char *mem = (char*)arena()-&gt;Amalloc_4(sizeof(BitBlock) *
 62                                         bitblock_alloc_chunk_size + 32);
 63 
 64   // Align the pointer to a 32 bit boundary.
 65   BitBlock *new_blocks = (BitBlock*)(((uintptr_t)mem + 32) &amp; ~0x001F);
 66 
 67   // Add the new blocks to the free list.
 68   for (int i = 0; i &lt; bitblock_alloc_chunk_size; i++) {
 69     new_blocks-&gt;set_next(free);
 70     free = new_blocks;
 71     new_blocks++;
 72   }
 73 
 74   compile-&gt;set_indexSet_free_block_list(free);
 75 
 76 #ifdef ASSERT
 77   if (CollectIndexSetStatistics) {
 78     inc_stat_counter(&amp;_alloc_new, bitblock_alloc_chunk_size);
 79   }
 80 #endif
 81 }
 82 
 83 
 84 //---------------------------- IndexSet::alloc_block() ------------------------
 85 // Allocate a BitBlock from the free list.  If the free list is empty,
 86 // prime it.
 87 
 88 IndexSet::BitBlock *IndexSet::alloc_block() {
 89 #ifdef ASSERT
 90   if (CollectIndexSetStatistics) {
 91     inc_stat_counter(&amp;_alloc_total, 1);
 92   }
 93 #endif
 94   Compile *compile = Compile::current();
 95   BitBlock* free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 96   if (free_list == NULL) {
 97     populate_free_list();
 98     free_list = (BitBlock*)compile-&gt;indexSet_free_block_list();
 99   }
100   BitBlock *block = free_list;
101   compile-&gt;set_indexSet_free_block_list(block-&gt;next());
102 
103   block-&gt;clear();
104   return block;
105 }
106 
107 //---------------------------- IndexSet::alloc_block_containing() -------------
108 // Allocate a new BitBlock and put it into the position in the _blocks array
109 // corresponding to element.
110 
111 IndexSet::BitBlock *IndexSet::alloc_block_containing(uint element) {
112   BitBlock *block = alloc_block();
113   uint bi = get_block_index(element);
114   _blocks[bi] = block;
115   return block;
116 }
117 
118 //---------------------------- IndexSet::free_block() -------------------------
119 // Add a BitBlock to the free list.
120 
121 void IndexSet::free_block(uint i) {
122   debug_only(check_watch(&quot;free block&quot;, i));
123   assert(i &lt; _max_blocks, &quot;block index too large&quot;);
124   BitBlock *block = _blocks[i];
125   assert(block != &amp;_empty_block, &quot;cannot free the empty block&quot;);
126   block-&gt;set_next((IndexSet::BitBlock*)Compile::current()-&gt;indexSet_free_block_list());
127   Compile::current()-&gt;set_indexSet_free_block_list(block);
128   set_block(i,&amp;_empty_block);
129 }
130 
131 //------------------------------lrg_union--------------------------------------
132 // Compute the union of all elements of one and two which interfere with
133 // the RegMask mask.  If the degree of the union becomes exceeds
134 // fail_degree, the union bails out.  The underlying set is cleared before
135 // the union is performed.
136 
137 uint IndexSet::lrg_union(uint lr1, uint lr2,
138                          const uint fail_degree,
139                          const PhaseIFG *ifg,
140                          const RegMask &amp;mask ) {
141   IndexSet *one = ifg-&gt;neighbors(lr1);
142   IndexSet *two = ifg-&gt;neighbors(lr2);
143   LRG &amp;lrg1 = ifg-&gt;lrgs(lr1);
144   LRG &amp;lrg2 = ifg-&gt;lrgs(lr2);
145 #ifdef ASSERT
146   assert(_max_elements == one-&gt;_max_elements, &quot;max element mismatch&quot;);
147   check_watch(&quot;union destination&quot;);
148   one-&gt;check_watch(&quot;union source&quot;);
149   two-&gt;check_watch(&quot;union source&quot;);
150 #endif
151 
152   // Compute the degree of the combined live-range.  The combined
153   // live-range has the union of the original live-ranges&#39; neighbors set as
154   // well as the neighbors of all intermediate copies, minus those neighbors
155   // that can not use the intersected allowed-register-set.
156 
157   // Copy the larger set.  Insert the smaller set into the larger.
158   if (two-&gt;count() &gt; one-&gt;count()) {
159     IndexSet *temp = one;
160     one = two;
161     two = temp;
162   }
163 
164   clear();
165 
166   // Used to compute degree of register-only interferences.  Infinite-stack
167   // neighbors do not alter colorability, as they can always color to some
168   // other color.  (A variant of the Briggs assertion)
169   uint reg_degree = 0;
170 
171   uint element;
172   // Load up the combined interference set with the neighbors of one
173   IndexSetIterator elements(one);
174   while ((element = elements.next()) != 0) {
175     LRG &amp;lrg = ifg-&gt;lrgs(element);
176     if (mask.overlap(lrg.mask())) {
177       insert(element);
178       if( !lrg.mask().is_AllStack() ) {
179         reg_degree += lrg1.compute_degree(lrg);
180         if( reg_degree &gt;= fail_degree ) return reg_degree;
181       } else {
182         // !!!!! Danger!  No update to reg_degree despite having a neighbor.
183         // A variant of the Briggs assertion.
184         // Not needed if I simplify during coalesce, ala George/Appel.
185         assert( lrg.lo_degree(), &quot;&quot; );
186       }
187     }
188   }
189   // Add neighbors of two as well
190   IndexSetIterator elements2(two);
191   while ((element = elements2.next()) != 0) {
192     LRG &amp;lrg = ifg-&gt;lrgs(element);
193     if (mask.overlap(lrg.mask())) {
194       if (insert(element)) {
195         if( !lrg.mask().is_AllStack() ) {
196           reg_degree += lrg2.compute_degree(lrg);
197           if( reg_degree &gt;= fail_degree ) return reg_degree;
198         } else {
199           // !!!!! Danger!  No update to reg_degree despite having a neighbor.
200           // A variant of the Briggs assertion.
201           // Not needed if I simplify during coalesce, ala George/Appel.
202           assert( lrg.lo_degree(), &quot;&quot; );
203         }
204       }
205     }
206   }
207 
208   return reg_degree;
209 }
210 
211 //---------------------------- IndexSet() -----------------------------
212 // A deep copy constructor.  This is used when you need a scratch copy of this set.
213 
214 IndexSet::IndexSet (IndexSet *set) {
215 #ifdef ASSERT
216   _serial_number = _serial_count++;
217   set-&gt;check_watch(&quot;copied&quot;, _serial_number);
218   check_watch(&quot;initialized by copy&quot;, set-&gt;_serial_number);
219   _max_elements = set-&gt;_max_elements;
220 #endif
221   _count = set-&gt;_count;
222   _max_blocks = set-&gt;_max_blocks;
223   if (_max_blocks &lt;= preallocated_block_list_size) {
224     _blocks = _preallocated_block_list;
225   } else {
226     _blocks =
227       (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock**) * _max_blocks);
228   }
229   for (uint i = 0; i &lt; _max_blocks; i++) {
230     BitBlock *block = set-&gt;_blocks[i];
231     if (block == &amp;_empty_block) {
232       set_block(i, &amp;_empty_block);
233     } else {
234       BitBlock *new_block = alloc_block();
235       memcpy(new_block-&gt;words(), block-&gt;words(), sizeof(uint32_t) * words_per_block);
236       set_block(i, new_block);
237     }
238   }
239 }
240 
241 //---------------------------- IndexSet::initialize() -----------------------------
242 // Prepare an IndexSet for use.
243 
244 void IndexSet::initialize(uint max_elements) {
245 #ifdef ASSERT
246   _serial_number = _serial_count++;
247   check_watch(&quot;initialized&quot;, max_elements);
248   _max_elements = max_elements;
249 #endif
250   _count = 0;
251   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
252 
253   if (_max_blocks &lt;= preallocated_block_list_size) {
254     _blocks = _preallocated_block_list;
255   } else {
256     _blocks = (IndexSet::BitBlock**) arena()-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
257   }
258   for (uint i = 0; i &lt; _max_blocks; i++) {
259     set_block(i, &amp;_empty_block);
260   }
261 }
262 
263 //---------------------------- IndexSet::initialize()------------------------------
264 // Prepare an IndexSet for use.  If it needs to allocate its _blocks array, it does
265 // so from the Arena passed as a parameter.  BitBlock allocation is still done from
266 // the static Arena which was set with reset_memory().
267 
268 void IndexSet::initialize(uint max_elements, Arena *arena) {
269 #ifdef ASSERT
270   _serial_number = _serial_count++;
271   check_watch(&quot;initialized2&quot;, max_elements);
272   _max_elements = max_elements;
273 #endif // ASSERT
274   _count = 0;
275   _max_blocks = (max_elements + bits_per_block - 1) / bits_per_block;
276 
277   if (_max_blocks &lt;= preallocated_block_list_size) {
278     _blocks = _preallocated_block_list;
279   } else {
280     _blocks = (IndexSet::BitBlock**) arena-&gt;Amalloc_4(sizeof(IndexSet::BitBlock*) * _max_blocks);
281   }
282   for (uint i = 0; i &lt; _max_blocks; i++) {
283     set_block(i, &amp;_empty_block);
284   }
285 }
286 
287 //---------------------------- IndexSet::swap() -----------------------------
288 // Exchange two IndexSets.
289 
290 void IndexSet::swap(IndexSet *set) {
291 #ifdef ASSERT
292   assert(_max_elements == set-&gt;_max_elements, &quot;must have same universe size to swap&quot;);
293   check_watch(&quot;swap&quot;, set-&gt;_serial_number);
294   set-&gt;check_watch(&quot;swap&quot;, _serial_number);
295 #endif
296 
297   for (uint i = 0; i &lt; _max_blocks; i++) {
298     BitBlock *temp = _blocks[i];
299     set_block(i, set-&gt;_blocks[i]);
300     set-&gt;set_block(i, temp);
301   }
302   uint temp = _count;
303   _count = set-&gt;_count;
304   set-&gt;_count = temp;
305 }
306 
307 //---------------------------- IndexSet::dump() -----------------------------
308 // Print this set.  Used for debugging.
309 
310 #ifndef PRODUCT
311 void IndexSet::dump() const {
312   IndexSetIterator elements(this);
313 
314   tty-&gt;print(&quot;{&quot;);
315   uint i;
316   while ((i = elements.next()) != 0) {
317     tty-&gt;print(&quot;L%d &quot;, i);
318   }
319   tty-&gt;print_cr(&quot;}&quot;);
320 }
321 #endif
322 
323 #ifdef ASSERT
324 //---------------------------- IndexSet::tally_iteration_statistics() -----------------------------
325 // Update block/bit counts to reflect that this set has been iterated over.
326 
327 void IndexSet::tally_iteration_statistics() const {
328   inc_stat_counter(&amp;_total_bits, count());
329 
330   for (uint i = 0; i &lt; _max_blocks; i++) {
331     if (_blocks[i] != &amp;_empty_block) {
332       inc_stat_counter(&amp;_total_used_blocks, 1);
333     } else {
334       inc_stat_counter(&amp;_total_unused_blocks, 1);
335     }
336   }
337 }
338 
339 //---------------------------- IndexSet::print_statistics() -----------------------------
340 // Print statistics about IndexSet usage.
341 
342 void IndexSet::print_statistics() {
343   julong total_blocks = _total_used_blocks + _total_unused_blocks;
344   tty-&gt;print_cr (&quot;Accumulated IndexSet usage statistics:&quot;);
345   tty-&gt;print_cr (&quot;--------------------------------------&quot;);
346   tty-&gt;print_cr (&quot;  Iteration:&quot;);
347   tty-&gt;print_cr (&quot;    blocks visited: &quot; UINT64_FORMAT, total_blocks);
348   tty-&gt;print_cr (&quot;    blocks empty: %4.2f%%&quot;, 100.0*(double)_total_unused_blocks/total_blocks);
349   tty-&gt;print_cr (&quot;    bit density (bits/used blocks): %4.2f&quot;, (double)_total_bits/_total_used_blocks);
350   tty-&gt;print_cr (&quot;    bit density (bits/all blocks): %4.2f&quot;, (double)_total_bits/total_blocks);
351   tty-&gt;print_cr (&quot;  Allocation:&quot;);
352   tty-&gt;print_cr (&quot;    blocks allocated: &quot; UINT64_FORMAT, _alloc_new);
353   tty-&gt;print_cr (&quot;    blocks used/reused: &quot; UINT64_FORMAT, _alloc_total);
354 }
355 
356 //---------------------------- IndexSet::verify() -----------------------------
357 // Expensive test of IndexSet sanity.  Ensure that the count agrees with the
358 // number of bits in the blocks.  Make sure the iterator is seeing all elements
359 // of the set.  Meant for use during development.
360 
361 void IndexSet::verify() const {
362   assert(!member(0), &quot;zero cannot be a member&quot;);
363   uint count = 0;
364   uint i;
365   for (i = 1; i &lt; _max_elements; i++) {
366     if (member(i)) {
367       count++;
368       assert(count &lt;= _count, &quot;_count is messed up&quot;);
369     }
370   }
371 
372   IndexSetIterator elements(this);
373   count = 0;
374   while ((i = elements.next()) != 0) {
375     count++;
376     assert(member(i), &quot;returned a non member&quot;);
377     assert(count &lt;= _count, &quot;iterator returned wrong number of elements&quot;);
378   }
379 }
380 #endif
381 
382 //---------------------------- IndexSetIterator() -----------------------------
383 // Create an iterator for a set.  If empty blocks are detected when iterating
384 // over the set, these blocks are replaced.
385 
386 IndexSetIterator::IndexSetIterator(IndexSet *set) {
387 #ifdef ASSERT
388   if (CollectIndexSetStatistics) {
389     set-&gt;tally_iteration_statistics();
390   }
391   set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());
392 #endif
393   if (set-&gt;is_empty()) {
394     _current = 0;
395     _next_word = IndexSet::words_per_block;
396     _next_block = 1;
397     _max_blocks = 1;
398 
399     // We don&#39;t need the following values when we iterate over an empty set.
400     // The commented out code is left here to document that the omission
401     // is intentional.
402     //
403     //_value = 0;
404     //_words = NULL;
405     //_blocks = NULL;
406     //_set = NULL;
407   } else {
408     _current = 0;
409     _value = 0;
410     _next_block = 0;
411     _next_word = IndexSet::words_per_block;
412 
413     _max_blocks = set-&gt;_max_blocks;
414     _words = NULL;
415     _blocks = set-&gt;_blocks;
416     _set = set;
417   }
418 }
419 
420 //---------------------------- IndexSetIterator(const) -----------------------------
421 // Iterate over a constant IndexSet.
422 
423 IndexSetIterator::IndexSetIterator(const IndexSet *set) {
424 #ifdef ASSERT
425   if (CollectIndexSetStatistics) {
426     set-&gt;tally_iteration_statistics();
427   }
428   // We don&#39;t call check_watch from here to avoid bad recursion.
429   //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());
430 #endif
431   if (set-&gt;is_empty()) {
432     _current = 0;
433     _next_word = IndexSet::words_per_block;
434     _next_block = 1;
435     _max_blocks = 1;
436 
437     // We don&#39;t need the following values when we iterate over an empty set.
438     // The commented out code is left here to document that the omission
439     // is intentional.
440     //
441     //_value = 0;
442     //_words = NULL;
443     //_blocks = NULL;
444     //_set = NULL;
445   } else {
446     _current = 0;
447     _value = 0;
448     _next_block = 0;
449     _next_word = IndexSet::words_per_block;
450 
451     _max_blocks = set-&gt;_max_blocks;
452     _words = NULL;
453     _blocks = set-&gt;_blocks;
454     _set = NULL;
455   }
456 }
457 
458 //---------------------------- List16Iterator::advance_and_next() -----------------------------
459 // Advance to the next non-empty word in the set being iterated over.  Return the next element
460 // if there is one.  If we are done, return 0.  This method is called from the next() method
461 // when it gets done with a word.
462 
463 uint IndexSetIterator::advance_and_next() {
464   // See if there is another non-empty word in the current block.
465   for (uint wi = _next_word; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
466     if (_words[wi] != 0) {
467       // Found a non-empty word.
468       _value = ((_next_block - 1) * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
469       _current = _words[wi];
470 
471       _next_word = wi+1;
472 
473       return next();
474     }
475   }
476 
477   // We ran out of words in the current block.  Advance to next non-empty block.
478   for (uint bi = _next_block; bi &lt; _max_blocks; bi++) {
479     if (_blocks[bi] != &amp;IndexSet::_empty_block) {
480       // Found a non-empty block.
481 
482       _words = _blocks[bi]-&gt;words();
483       for (uint wi = 0; wi &lt; (unsigned)IndexSet::words_per_block; wi++) {
484         if (_words[wi] != 0) {
485           // Found a non-empty word.
486           _value = (bi * IndexSet::bits_per_block) + (wi * IndexSet::bits_per_word);
487           _current = _words[wi];
488 
489           _next_block = bi+1;
490           _next_word = wi+1;
491 
492           return next();
493         }
494       }
495 
496       // All of the words in the block were empty.  Replace
497       // the block with the empty block.
498       if (_set) {
499         _set-&gt;free_block(bi);
500       }
501     }
502   }
503 
504   // These assignments make redundant calls to next on a finished iterator
505   // faster.  Probably not necessary.
506   _next_block = _max_blocks;
507   _next_word = IndexSet::words_per_block;
508 
509   // No more words.
510   return 0;
511 }
    </pre>
  </body>
</html>
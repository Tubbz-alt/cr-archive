<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/addnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="addnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/addnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
238 //------------------------------MinINode---------------------------------------
239 // MINimum of 2 integers.  Included with the ADD nodes because it inherits
240 // all the behavior of addition on a ring.
241 class MinINode : public MaxNode {
242 public:
243   MinINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}
244   virtual int Opcode() const;
245   virtual const Type *add_ring( const Type *, const Type * ) const;
246   virtual const Type *add_id() const { return TypeInt::make(max_jint); }
247   virtual const Type *bottom_type() const { return TypeInt::INT; }
248   virtual uint ideal_reg() const { return Op_RegI; }
249   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
250 };
251 
252 //------------------------------MaxFNode---------------------------------------
253 // Maximum of 2 floats.
254 class MaxFNode : public MaxNode {
255 public:
256   MaxFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
257   virtual int Opcode() const;
<span class="line-modified">258   virtual const Type *add_ring(const Type*, const Type*) const { return Type::FLOAT; }</span>
259   virtual const Type *add_id() const { return TypeF::NEG_INF; }
260   virtual const Type *bottom_type() const { return Type::FLOAT; }
261   virtual uint ideal_reg() const { return Op_RegF; }
262 };
263 
264 //------------------------------MinFNode---------------------------------------
265 // Minimum of 2 floats.
266 class MinFNode : public MaxNode {
267 public:
268   MinFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
269   virtual int Opcode() const;
<span class="line-modified">270   virtual const Type *add_ring(const Type*, const Type*) const { return Type::FLOAT; }</span>
271   virtual const Type *add_id() const { return TypeF::POS_INF; }
272   virtual const Type *bottom_type() const { return Type::FLOAT; }
273   virtual uint ideal_reg() const { return Op_RegF; }
274 };
275 
276 //------------------------------MaxDNode---------------------------------------
277 // Maximum of 2 doubles.
278 class MaxDNode : public MaxNode {
279 public:
280   MaxDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
281   virtual int Opcode() const;
<span class="line-modified">282   virtual const Type *add_ring(const Type*, const Type*) const { return Type::DOUBLE; }</span>
283   virtual const Type *add_id() const { return TypeD::NEG_INF; }
284   virtual const Type *bottom_type() const { return Type::DOUBLE; }
285   virtual uint ideal_reg() const { return Op_RegD; }
286 };
287 
288 //------------------------------MinDNode---------------------------------------
289 // Minimum of 2 doubles.
290 class MinDNode : public MaxNode {
291 public:
292   MinDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
293   virtual int Opcode() const;
<span class="line-modified">294   virtual const Type *add_ring(const Type*, const Type*) const { return Type::DOUBLE; }</span>
295   virtual const Type *add_id() const { return TypeD::POS_INF; }
296   virtual const Type *bottom_type() const { return Type::DOUBLE; }
297   virtual uint ideal_reg() const { return Op_RegD; }
298 };
299 
300 #endif // SHARE_OPTO_ADDNODE_HPP
</pre>
</td>
<td>
<hr />
<pre>
238 //------------------------------MinINode---------------------------------------
239 // MINimum of 2 integers.  Included with the ADD nodes because it inherits
240 // all the behavior of addition on a ring.
241 class MinINode : public MaxNode {
242 public:
243   MinINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}
244   virtual int Opcode() const;
245   virtual const Type *add_ring( const Type *, const Type * ) const;
246   virtual const Type *add_id() const { return TypeInt::make(max_jint); }
247   virtual const Type *bottom_type() const { return TypeInt::INT; }
248   virtual uint ideal_reg() const { return Op_RegI; }
249   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
250 };
251 
252 //------------------------------MaxFNode---------------------------------------
253 // Maximum of 2 floats.
254 class MaxFNode : public MaxNode {
255 public:
256   MaxFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
257   virtual int Opcode() const;
<span class="line-modified">258   virtual const Type *add_ring(const Type*, const Type*) const;</span>
259   virtual const Type *add_id() const { return TypeF::NEG_INF; }
260   virtual const Type *bottom_type() const { return Type::FLOAT; }
261   virtual uint ideal_reg() const { return Op_RegF; }
262 };
263 
264 //------------------------------MinFNode---------------------------------------
265 // Minimum of 2 floats.
266 class MinFNode : public MaxNode {
267 public:
268   MinFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
269   virtual int Opcode() const;
<span class="line-modified">270   virtual const Type *add_ring(const Type*, const Type*) const;</span>
271   virtual const Type *add_id() const { return TypeF::POS_INF; }
272   virtual const Type *bottom_type() const { return Type::FLOAT; }
273   virtual uint ideal_reg() const { return Op_RegF; }
274 };
275 
276 //------------------------------MaxDNode---------------------------------------
277 // Maximum of 2 doubles.
278 class MaxDNode : public MaxNode {
279 public:
280   MaxDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
281   virtual int Opcode() const;
<span class="line-modified">282   virtual const Type *add_ring(const Type*, const Type*) const;</span>
283   virtual const Type *add_id() const { return TypeD::NEG_INF; }
284   virtual const Type *bottom_type() const { return Type::DOUBLE; }
285   virtual uint ideal_reg() const { return Op_RegD; }
286 };
287 
288 //------------------------------MinDNode---------------------------------------
289 // Minimum of 2 doubles.
290 class MinDNode : public MaxNode {
291 public:
292   MinDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}
293   virtual int Opcode() const;
<span class="line-modified">294   virtual const Type *add_ring(const Type*, const Type*) const;</span>
295   virtual const Type *add_id() const { return TypeD::POS_INF; }
296   virtual const Type *bottom_type() const { return Type::DOUBLE; }
297   virtual uint ideal_reg() const { return Op_RegD; }
298 };
299 
300 #endif // SHARE_OPTO_ADDNODE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="addnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
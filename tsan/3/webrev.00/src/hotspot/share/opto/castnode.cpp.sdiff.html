<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/castnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="callnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/castnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 }
 47 
 48 //------------------------------Value------------------------------------------
 49 // Take &#39;join&#39; of input and cast-up type
 50 const Type* ConstraintCastNode::Value(PhaseGVN* phase) const {
 51   if (in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP) return Type::TOP;
 52   const Type* ft = phase-&gt;type(in(1))-&gt;filter_speculative(_type);
 53 
 54 #ifdef ASSERT
 55   // Previous versions of this function had some special case logic,
 56   // which is no longer necessary.  Make sure of the required effects.
 57   switch (Opcode()) {
 58     case Op_CastII:
 59     {
 60       const Type* t1 = phase-&gt;type(in(1));
 61       if( t1 == Type::TOP )  assert(ft == Type::TOP, &quot;special case #1&quot;);
 62       const Type* rt = t1-&gt;join_speculative(_type);
 63       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);
 64       break;
 65     }








 66     case Op_CastPP:
 67     if (phase-&gt;type(in(1)) == TypePtr::NULL_PTR &amp;&amp;
 68         _type-&gt;isa_ptr() &amp;&amp; _type-&gt;is_ptr()-&gt;_ptr == TypePtr::NotNull)
 69     assert(ft == Type::TOP, &quot;special case #3&quot;);
 70     break;
 71   }
 72 #endif //ASSERT
 73 
 74   return ft;
 75 }
 76 
 77 //------------------------------Ideal------------------------------------------
 78 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
 79 // control copies
 80 Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 81   return (in(0) &amp;&amp; remove_dead_region(phase, can_reshape)) ? this : NULL;
 82 }
 83 
<span class="line-modified"> 84 uint ConstraintCastNode::cmp(const Node &amp;n) const {</span>
 85   return TypeNode::cmp(n) &amp;&amp; ((ConstraintCastNode&amp;)n)._carry_dependency == _carry_dependency;
 86 }
 87 
 88 uint ConstraintCastNode::size_of() const {
 89   return sizeof(*this);
 90 }
 91 
 92 Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, bool carry_dependency) {
 93   switch(opcode) {
 94   case Op_CastII: {
 95     Node* cast = new CastIINode(n, t, carry_dependency);
 96     cast-&gt;set_req(0, c);
 97     return cast;
 98   }





 99   case Op_CastPP: {
100     Node* cast = new CastPPNode(n, t, carry_dependency);
101     cast-&gt;set_req(0, c);
102     return cast;
103   }
104   case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, carry_dependency);
105   default:
106     fatal(&quot;Bad opcode %d&quot;, opcode);
107   }
108   return NULL;
109 }
110 
111 TypeNode* ConstraintCastNode::dominating_cast(PhaseGVN* gvn, PhaseTransform* pt) const {
112   Node* val = in(1);
113   Node* ctl = in(0);
114   int opc = Opcode();
115   if (ctl == NULL) {
116     return NULL;
117   }
118   // Range check CastIIs may all end up under a single range check and
</pre>
<hr />
<pre>
245         // Keep a range assertion of &gt;=0.
246         lo1 = 0;        hi1 = max_jint;
247       } else if (hi1 &lt; 0) {
248         // Keep a range assertion of &lt;0.
249         lo1 = min_jint; hi1 = -1;
250       } else {
251         lo1 = min_jint; hi1 = max_jint;
252       }
253       const TypeInt* wtype = TypeInt::make(MAX2(in_type-&gt;_lo, lo1),
254                                            MIN2(in_type-&gt;_hi, hi1),
255                                            MAX2((int)in_type-&gt;_widen, w1));
256       if (wtype != type()) {
257         set_type(wtype);
258         return this;
259       }
260     }
261   }
262   return NULL;
263 }
264 
<span class="line-modified">265 uint CastIINode::cmp(const Node &amp;n) const {</span>
266   return ConstraintCastNode::cmp(n) &amp;&amp; ((CastIINode&amp;)n)._range_check_dependency == _range_check_dependency;
267 }
268 
269 uint CastIINode::size_of() const {
270   return sizeof(*this);
271 }
272 
273 #ifndef PRODUCT
274 void CastIINode::dump_spec(outputStream* st) const {
275   ConstraintCastNode::dump_spec(st);
276   if (_range_check_dependency) {
277     st-&gt;print(&quot; range check dependency&quot;);
278   }
279 }
280 #endif
281 







































282 //=============================================================================
283 //------------------------------Identity---------------------------------------
284 // If input is already higher or equal to cast type, then this is an identity.
285 Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
286   Node* dom = dominating_cast(phase, phase);
287   if (dom != NULL) {
288     return dom;
289   }
290   if (_carry_dependency) {
291     return this;
292   }
293   // Toned down to rescue meeting at a Phi 3 different oops all implementing
294   // the same interface.
295   return (phase-&gt;type(in(1)) == phase-&gt;type(this)) ? in(1) : this;
296 }
297 
298 //------------------------------Value------------------------------------------
299 // Take &#39;join&#39; of input and cast-up type, unless working with an Interface
300 const Type* CheckCastPPNode::Value(PhaseGVN* phase) const {
301   if( in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
</pre>
</td>
<td>
<hr />
<pre>
 46 }
 47 
 48 //------------------------------Value------------------------------------------
 49 // Take &#39;join&#39; of input and cast-up type
 50 const Type* ConstraintCastNode::Value(PhaseGVN* phase) const {
 51   if (in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP) return Type::TOP;
 52   const Type* ft = phase-&gt;type(in(1))-&gt;filter_speculative(_type);
 53 
 54 #ifdef ASSERT
 55   // Previous versions of this function had some special case logic,
 56   // which is no longer necessary.  Make sure of the required effects.
 57   switch (Opcode()) {
 58     case Op_CastII:
 59     {
 60       const Type* t1 = phase-&gt;type(in(1));
 61       if( t1 == Type::TOP )  assert(ft == Type::TOP, &quot;special case #1&quot;);
 62       const Type* rt = t1-&gt;join_speculative(_type);
 63       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);
 64       break;
 65     }
<span class="line-added"> 66     case Op_CastLL:</span>
<span class="line-added"> 67     {</span>
<span class="line-added"> 68       const Type* t1 = phase-&gt;type(in(1));</span>
<span class="line-added"> 69       if (t1 == Type::TOP)   assert(ft == Type::TOP, &quot;special case #1&quot;);</span>
<span class="line-added"> 70       const Type* rt = t1-&gt;join_speculative(_type);</span>
<span class="line-added"> 71       if (rt-&gt;empty())       assert(ft == Type::TOP, &quot;special case #2&quot;);</span>
<span class="line-added"> 72       break;</span>
<span class="line-added"> 73     }</span>
 74     case Op_CastPP:
 75     if (phase-&gt;type(in(1)) == TypePtr::NULL_PTR &amp;&amp;
 76         _type-&gt;isa_ptr() &amp;&amp; _type-&gt;is_ptr()-&gt;_ptr == TypePtr::NotNull)
 77     assert(ft == Type::TOP, &quot;special case #3&quot;);
 78     break;
 79   }
 80 #endif //ASSERT
 81 
 82   return ft;
 83 }
 84 
 85 //------------------------------Ideal------------------------------------------
 86 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
 87 // control copies
 88 Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 89   return (in(0) &amp;&amp; remove_dead_region(phase, can_reshape)) ? this : NULL;
 90 }
 91 
<span class="line-modified"> 92 bool ConstraintCastNode::cmp(const Node &amp;n) const {</span>
 93   return TypeNode::cmp(n) &amp;&amp; ((ConstraintCastNode&amp;)n)._carry_dependency == _carry_dependency;
 94 }
 95 
 96 uint ConstraintCastNode::size_of() const {
 97   return sizeof(*this);
 98 }
 99 
100 Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, bool carry_dependency) {
101   switch(opcode) {
102   case Op_CastII: {
103     Node* cast = new CastIINode(n, t, carry_dependency);
104     cast-&gt;set_req(0, c);
105     return cast;
106   }
<span class="line-added">107   case Op_CastLL: {</span>
<span class="line-added">108     Node* cast = new CastLLNode(n, t, carry_dependency);</span>
<span class="line-added">109     cast-&gt;set_req(0, c);</span>
<span class="line-added">110     return cast;</span>
<span class="line-added">111   }</span>
112   case Op_CastPP: {
113     Node* cast = new CastPPNode(n, t, carry_dependency);
114     cast-&gt;set_req(0, c);
115     return cast;
116   }
117   case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, carry_dependency);
118   default:
119     fatal(&quot;Bad opcode %d&quot;, opcode);
120   }
121   return NULL;
122 }
123 
124 TypeNode* ConstraintCastNode::dominating_cast(PhaseGVN* gvn, PhaseTransform* pt) const {
125   Node* val = in(1);
126   Node* ctl = in(0);
127   int opc = Opcode();
128   if (ctl == NULL) {
129     return NULL;
130   }
131   // Range check CastIIs may all end up under a single range check and
</pre>
<hr />
<pre>
258         // Keep a range assertion of &gt;=0.
259         lo1 = 0;        hi1 = max_jint;
260       } else if (hi1 &lt; 0) {
261         // Keep a range assertion of &lt;0.
262         lo1 = min_jint; hi1 = -1;
263       } else {
264         lo1 = min_jint; hi1 = max_jint;
265       }
266       const TypeInt* wtype = TypeInt::make(MAX2(in_type-&gt;_lo, lo1),
267                                            MIN2(in_type-&gt;_hi, hi1),
268                                            MAX2((int)in_type-&gt;_widen, w1));
269       if (wtype != type()) {
270         set_type(wtype);
271         return this;
272       }
273     }
274   }
275   return NULL;
276 }
277 
<span class="line-modified">278 bool CastIINode::cmp(const Node &amp;n) const {</span>
279   return ConstraintCastNode::cmp(n) &amp;&amp; ((CastIINode&amp;)n)._range_check_dependency == _range_check_dependency;
280 }
281 
282 uint CastIINode::size_of() const {
283   return sizeof(*this);
284 }
285 
286 #ifndef PRODUCT
287 void CastIINode::dump_spec(outputStream* st) const {
288   ConstraintCastNode::dump_spec(st);
289   if (_range_check_dependency) {
290     st-&gt;print(&quot; range check dependency&quot;);
291   }
292 }
293 #endif
294 
<span class="line-added">295 Node* CastLLNode::Ideal(PhaseGVN* phase, bool can_reshape) {</span>
<span class="line-added">296   Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);</span>
<span class="line-added">297   if (progress != NULL) {</span>
<span class="line-added">298     return progress;</span>
<span class="line-added">299   }</span>
<span class="line-added">300 </span>
<span class="line-added">301   // Same as in CastIINode::Ideal but for TypeLong instead of TypeInt</span>
<span class="line-added">302   if (can_reshape &amp;&amp; !phase-&gt;C-&gt;major_progress()) {</span>
<span class="line-added">303     const TypeLong* this_type = this-&gt;type()-&gt;is_long();</span>
<span class="line-added">304     const TypeLong* in_type = phase-&gt;type(in(1))-&gt;isa_long();</span>
<span class="line-added">305     if (in_type != NULL &amp;&amp; this_type != NULL &amp;&amp;</span>
<span class="line-added">306         (in_type-&gt;_lo != this_type-&gt;_lo ||</span>
<span class="line-added">307          in_type-&gt;_hi != this_type-&gt;_hi)) {</span>
<span class="line-added">308       jlong lo1 = this_type-&gt;_lo;</span>
<span class="line-added">309       jlong hi1 = this_type-&gt;_hi;</span>
<span class="line-added">310       int w1  = this_type-&gt;_widen;</span>
<span class="line-added">311 </span>
<span class="line-added">312       if (lo1 &gt;= 0) {</span>
<span class="line-added">313         // Keep a range assertion of &gt;=0.</span>
<span class="line-added">314         lo1 = 0;         hi1 = max_jlong;</span>
<span class="line-added">315       } else if (hi1 &lt; 0) {</span>
<span class="line-added">316         // Keep a range assertion of &lt;0.</span>
<span class="line-added">317         lo1 = min_jlong; hi1 = -1;</span>
<span class="line-added">318       } else {</span>
<span class="line-added">319         lo1 = min_jlong; hi1 = max_jlong;</span>
<span class="line-added">320       }</span>
<span class="line-added">321       const TypeLong* wtype = TypeLong::make(MAX2(in_type-&gt;_lo, lo1),</span>
<span class="line-added">322                                              MIN2(in_type-&gt;_hi, hi1),</span>
<span class="line-added">323                                              MAX2((int)in_type-&gt;_widen, w1));</span>
<span class="line-added">324       if (wtype != type()) {</span>
<span class="line-added">325         set_type(wtype);</span>
<span class="line-added">326         return this;</span>
<span class="line-added">327       }</span>
<span class="line-added">328     }</span>
<span class="line-added">329   }</span>
<span class="line-added">330   return NULL;</span>
<span class="line-added">331 }</span>
<span class="line-added">332 </span>
<span class="line-added">333 </span>
334 //=============================================================================
335 //------------------------------Identity---------------------------------------
336 // If input is already higher or equal to cast type, then this is an identity.
337 Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
338   Node* dom = dominating_cast(phase, phase);
339   if (dom != NULL) {
340     return dom;
341   }
342   if (_carry_dependency) {
343     return this;
344   }
345   // Toned down to rescue meeting at a Phi 3 different oops all implementing
346   // the same interface.
347   return (phase-&gt;type(in(1)) == phase-&gt;type(this)) ? in(1) : this;
348 }
349 
350 //------------------------------Value------------------------------------------
351 // Take &#39;join&#39; of input and cast-up type, unless working with an Interface
352 const Type* CheckCastPPNode::Value(PhaseGVN* phase) const {
353   if( in(0) &amp;&amp; phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
</pre>
</td>
</tr>
</table>
<center><a href="callnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="castnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
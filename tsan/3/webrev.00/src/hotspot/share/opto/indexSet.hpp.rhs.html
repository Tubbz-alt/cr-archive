<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/indexSet.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OPTO_INDEXSET_HPP
 26 #define SHARE_OPTO_INDEXSET_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;opto/compile.hpp&quot;
 31 #include &quot;opto/regmask.hpp&quot;
 32 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 33 
 34 // This file defines the IndexSet class, a set of sparse integer indices.
 35 // This data structure is used by the compiler in its liveness analysis and
 36 // during register allocation.
 37 
 38 //-------------------------------- class IndexSet ----------------------------
 39 // An IndexSet is a piece-wise bitvector.  At the top level, we have an array
 40 // of pointers to bitvector chunks called BitBlocks.  Each BitBlock has a fixed
 41 // size and is allocated from a shared free list.  The bits which are set in
 42 // each BitBlock correspond to the elements of the set.
 43 
 44 class IndexSet : public ResourceObj {
 45  friend class IndexSetIterator;
 46 
 47  public:
 48   // When we allocate an IndexSet, it starts off with an array of top level block
 49   // pointers of a set length.  This size is intended to be large enough for the
 50   // majority of IndexSets.  In the cases when this size is not large enough,
 51   // a separately allocated array is used.
 52 
 53   // The length of the preallocated top level block array
 54   enum { preallocated_block_list_size = 16 };
 55 
 56   // Elements of a IndexSet get decomposed into three fields.  The highest order
 57   // bits are the block index, which tell which high level block holds the element.
 58   // Within that block, the word index indicates which word holds the element.
 59   // Finally, the bit index determines which single bit within that word indicates
 60   // membership of the element in the set.
 61 
 62   // The lengths of the index bitfields
 63   enum { bit_index_length = 5,
 64          word_index_length = 3,
 65          block_index_length = 8 // not used
 66   };
 67 
 68   // Derived constants used for manipulating the index bitfields
 69   enum {
 70          bit_index_offset = 0, // not used
 71          word_index_offset = bit_index_length,
 72          block_index_offset = bit_index_length + word_index_length,
 73 
 74          bits_per_word = 1 &lt;&lt; bit_index_length,
 75          words_per_block = 1 &lt;&lt; word_index_length,
 76          bits_per_block = bits_per_word * words_per_block,
 77 
 78          bit_index_mask = right_n_bits(bit_index_length),
 79          word_index_mask = right_n_bits(word_index_length)
 80   };
 81 
 82   // These routines are used for extracting the block, word, and bit index
 83   // from an element.
 84   static uint get_block_index(uint element) {
 85     return element &gt;&gt; block_index_offset;
 86   }
 87   static uint get_word_index(uint element) {
 88     return mask_bits(element &gt;&gt; word_index_offset,word_index_mask);
 89   }
 90   static uint get_bit_index(uint element) {
 91     return mask_bits(element,bit_index_mask);
 92   }
 93 
 94   //------------------------------ class BitBlock ----------------------------
 95   // The BitBlock class is a segment of a bitvector set.
 96 
 97   class BitBlock : public ResourceObj {
 98    friend class IndexSetIterator;
 99    friend class IndexSet;
100 
101    private:
102     // All of BitBlocks fields and methods are declared private.  We limit
103     // access to IndexSet and IndexSetIterator.
104 
105     // A BitBlock is composed of some number of 32 bit words.  When a BitBlock
106     // is not in use by any IndexSet, it is stored on a free list.  The next field
107     // is used by IndexSet to mainting this free list.
108 
109     union {
110       uint32_t _words[words_per_block];
111       BitBlock *_next;
112     } _data;
113 
114     // accessors
115     uint32_t* words() { return _data._words; }
116     void set_next(BitBlock *next) { _data._next = next; }
117     BitBlock *next() { return _data._next; }
118 
119     // Operations.  A BitBlock supports four simple operations,
120     // clear(), member(), insert(), and remove().  These methods do
121     // not assume that the block index has been masked out.
122 
123     void clear() {
124       memset(words(), 0, sizeof(uint32_t) * words_per_block);
125     }
126 
127     bool member(uint element) {
128       uint word_index = IndexSet::get_word_index(element);
129       uint bit_index = IndexSet::get_bit_index(element);
130 
131       return ((words()[word_index] &amp; (uint32_t)(0x1 &lt;&lt; bit_index)) != 0);
132     }
133 
134     bool insert(uint element) {
135       uint word_index = IndexSet::get_word_index(element);
136       uint bit_index = IndexSet::get_bit_index(element);
137 
138       uint32_t bit = (0x1 &lt;&lt; bit_index);
139       uint32_t before = words()[word_index];
140       words()[word_index] = before | bit;
141       return ((before &amp; bit) != 0);
142     }
143 
144     bool remove(uint element) {
145       uint word_index = IndexSet::get_word_index(element);
146       uint bit_index = IndexSet::get_bit_index(element);
147 
148       uint32_t bit = (0x1 &lt;&lt; bit_index);
149       uint32_t before = words()[word_index];
150       words()[word_index] = before &amp; ~bit;
151       return ((before &amp; bit) != 0);
152     }
153   };
154 
155   //-------------------------- BitBlock allocation ---------------------------
156  private:
157 
158   // All IndexSets share an arena from which they allocate BitBlocks.  Unused
159   // BitBlocks are placed on a free list.
160 
161   // The number of BitBlocks to allocate at a time
162   enum { bitblock_alloc_chunk_size = 50 };
163 
164   static Arena *arena() { return Compile::current()-&gt;indexSet_arena(); }
165 
166   static void populate_free_list();
167 
168  public:
169 
170   // Invalidate the current free BitBlock list and begin allocation
171   // from a new arena.  It is essential that this method is called whenever
172   // the Arena being used for BitBlock allocation is reset.
173   static void reset_memory(Compile* compile, Arena *arena) {
174     compile-&gt;set_indexSet_free_block_list(NULL);
175     compile-&gt;set_indexSet_arena(arena);
176 
177    // This should probably be done in a static initializer
178    _empty_block.clear();
179   }
180 
181  private:
182   friend class BitBlock;
183   // A distinguished BitBlock which always remains empty.  When a new IndexSet is
184   // created, all of its top level BitBlock pointers are initialized to point to
185   // this.
186   static BitBlock _empty_block;
187 
188   //-------------------------- Members ------------------------------------------
189 
190   // The number of elements in the set
191   uint      _count;
192 
<a name="1" id="anc1"></a><span class="line-added">193   // The current upper limit of blocks that has been allocated and might be in use</span>
<span class="line-added">194   uint      _current_block_limit;</span>
<span class="line-added">195 </span>
196   // Our top level array of bitvector segments
197   BitBlock **_blocks;
198 
199   BitBlock  *_preallocated_block_list[preallocated_block_list_size];
200 
201   // The number of top level array entries in use
202   uint       _max_blocks;
203 
204   // Our assertions need to know the maximum number allowed in the set
205 #ifdef ASSERT
206   uint       _max_elements;
207 #endif
208 
209   // The next IndexSet on the free list (not used at same time as count)
210   IndexSet *_next;
211 
212  public:
213   //-------------------------- Free list operations ------------------------------
214   // Individual IndexSets can be placed on a free list.  This is done in PhaseLive.
215 
216   IndexSet *next() {
<a name="2" id="anc2"></a>




217     return _next;
218   }
219 
220   void set_next(IndexSet *next) {
<a name="3" id="anc3"></a>




221     _next = next;
222   }
223 
224  private:
225   //-------------------------- Utility methods -----------------------------------
226 
227   // Get the block which holds element
228   BitBlock *get_block_containing(uint element) const {
229     assert(element &lt; _max_elements, &quot;element out of bounds&quot;);
230     return _blocks[get_block_index(element)];
231   }
232 
233   // Set a block in the top level array
234   void set_block(uint index, BitBlock *block) {
<a name="4" id="anc4"></a>



235     _blocks[index] = block;
236   }
237 
238   // Get a BitBlock from the free list
239   BitBlock *alloc_block();
240 
241   // Get a BitBlock from the free list and place it in the top level array
242   BitBlock *alloc_block_containing(uint element);
243 
244   // Free a block from the top level array, placing it on the free BitBlock list
245   void free_block(uint i);
246 
247  public:
248   //-------------------------- Primitive set operations --------------------------
249 
250   void clear() {
<a name="5" id="anc5"></a>



251     _count = 0;
<a name="6" id="anc6"></a><span class="line-modified">252     for (uint i = 0; i &lt; _current_block_limit; i++) {</span>
253       BitBlock *block = _blocks[i];
254       if (block != &amp;_empty_block) {
255         free_block(i);
256       }
257     }
<a name="7" id="anc7"></a><span class="line-added">258     _current_block_limit = 0;</span>
259   }
260 
261   uint count() const { return _count; }
262 
263   bool is_empty() const { return _count == 0; }
264 
265   bool member(uint element) const {
266     return get_block_containing(element)-&gt;member(element);
267   }
268 
269   bool insert(uint element) {
<a name="8" id="anc8"></a>



270     if (element == 0) {
271       return 0;
272     }
273     BitBlock *block = get_block_containing(element);
274     if (block == &amp;_empty_block) {
275       block = alloc_block_containing(element);
276     }
277     bool present = block-&gt;insert(element);
278     if (!present) {
279       _count++;
280     }
281     return !present;
282   }
283 
284   bool remove(uint element) {
<a name="9" id="anc9"></a>




285     BitBlock *block = get_block_containing(element);
286     bool present = block-&gt;remove(element);
287     if (present) {
288       _count--;
289     }
290     return present;
291   }
292 
293   //-------------------------- Compound set operations ------------------------
294   // Compute the union of all elements of one and two which interfere
295   // with the RegMask mask.  If the degree of the union becomes
296   // exceeds fail_degree, the union bails out.  The underlying set is
297   // cleared before the union is performed.
298   uint lrg_union(uint lr1, uint lr2,
299                  const uint fail_degree,
300                  const class PhaseIFG *ifg,
301                  const RegMask &amp;mask);
302 
303 
304   //------------------------- Construction, initialization -----------------------
305 
306   IndexSet() {}
307 
308   // This constructor is used for making a deep copy of a IndexSet.
309   IndexSet(IndexSet *set);
310 
311   // Perform initialization on a IndexSet
312   void initialize(uint max_element);
313 
314   // Initialize a IndexSet.  If the top level BitBlock array needs to be
315   // allocated, do it from the proffered arena.  BitBlocks are still allocated
316   // from the static Arena member.
317   void initialize(uint max_element, Arena *arena);
318 
319   // Exchange two sets
320   void swap(IndexSet *set);
321 
322   //-------------------------- Debugging and statistics --------------------------
323 
324 #ifndef PRODUCT
325   // Output a IndexSet for debugging
326   void dump() const;
327 #endif
328 
329 #ifdef ASSERT
330   void tally_iteration_statistics() const;
331 
332   // BitBlock allocation statistics
333   static julong _alloc_new;
334   static julong _alloc_total;
335 
336   // Block density statistics
337   static julong _total_bits;
338   static julong _total_used_blocks;
339   static julong _total_unused_blocks;
340 
341   // Sanity tests
342   void verify() const;
343 
344   static int _serial_count;
345   int        _serial_number;
346 
347   // Check to see if the serial number of the current set is the one we&#39;re tracing.
348   // If it is, print a message.
349   void check_watch(const char *operation, uint operand) const {
350     if (IndexSetWatch != 0) {
351       if (IndexSetWatch == -1 || _serial_number == IndexSetWatch) {
352         tty-&gt;print_cr(&quot;IndexSet %d : %s ( %d )&quot;, _serial_number, operation, operand);
353       }
354     }
355   }
356   void check_watch(const char *operation) const {
357     if (IndexSetWatch != 0) {
358       if (IndexSetWatch == -1 || _serial_number == IndexSetWatch) {
359         tty-&gt;print_cr(&quot;IndexSet %d : %s&quot;, _serial_number, operation);
360       }
361     }
362   }
363 
364  public:
365   static void print_statistics();
366 
367 #endif
368 };
369 
370 
371 //-------------------------------- class IndexSetIterator --------------------
372 // An iterator for IndexSets.
373 
374 class IndexSetIterator {
375  friend class IndexSet;
376 
377  private:
378   // The current word we are inspecting
379   uint32_t              _current;
380 
381   // What element number are we currently on?
382   uint                  _value;
383 
384   // The index of the next word we will inspect
385   uint                  _next_word;
386 
<a name="10" id="anc10"></a>


387   // The index of the next block we will inspect
388   uint                  _next_block;
389 
<a name="11" id="anc11"></a>


390   // The number of blocks in the set
391   uint                  _max_blocks;
392 
<a name="12" id="anc12"></a><span class="line-added">393   // A pointer to the contents of the current block</span>
<span class="line-added">394   uint32_t             *_words;</span>
<span class="line-added">395 </span>
<span class="line-added">396   // A pointer to the blocks in our set</span>
<span class="line-added">397   IndexSet::BitBlock **_blocks;</span>
<span class="line-added">398 </span>
399   // If the iterator was created from a non-const set, we replace
400   // non-canonical empty blocks with the _empty_block pointer.  If
401   // _set is NULL, we do no replacement.
402   IndexSet            *_set;
403 
404   // Advance to the next non-empty word and return the next
405   // element in the set.
406   uint advance_and_next();
407 
408  public:
409 
410   // If an iterator is built from a constant set then empty blocks
411   // are not canonicalized.
<a name="13" id="anc13"></a><span class="line-modified">412   IndexSetIterator(IndexSet *set) :</span>
<span class="line-modified">413     _current(0),</span>
<span class="line-added">414     _value(0),</span>
<span class="line-added">415     _next_word(IndexSet::words_per_block),</span>
<span class="line-added">416     _next_block(0),</span>
<span class="line-added">417     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="line-added">418     _words(NULL),</span>
<span class="line-added">419     _blocks(set-&gt;_blocks),</span>
<span class="line-added">420     _set(set) {</span>
<span class="line-added">421   #ifdef ASSERT</span>
<span class="line-added">422     if (CollectIndexSetStatistics) {</span>
<span class="line-added">423       set-&gt;tally_iteration_statistics();</span>
<span class="line-added">424     }</span>
<span class="line-added">425     set-&gt;check_watch(&quot;traversed&quot;, set-&gt;count());</span>
<span class="line-added">426   #endif</span>
<span class="line-added">427   }</span>
<span class="line-added">428 </span>
<span class="line-added">429   IndexSetIterator(const IndexSet *set) :</span>
<span class="line-added">430     _current(0),</span>
<span class="line-added">431     _value(0),</span>
<span class="line-added">432     _next_word(IndexSet::words_per_block),</span>
<span class="line-added">433     _next_block(0),</span>
<span class="line-added">434     _max_blocks(set-&gt;is_empty() ? 0 : set-&gt;_current_block_limit),</span>
<span class="line-added">435     _words(NULL),</span>
<span class="line-added">436     _blocks(set-&gt;_blocks),</span>
<span class="line-added">437     _set(NULL)</span>
<span class="line-added">438   {</span>
<span class="line-added">439   #ifdef ASSERT</span>
<span class="line-added">440     if (CollectIndexSetStatistics) {</span>
<span class="line-added">441       set-&gt;tally_iteration_statistics();</span>
<span class="line-added">442     }</span>
<span class="line-added">443     // We don&#39;t call check_watch from here to avoid bad recursion.</span>
<span class="line-added">444     //   set-&gt;check_watch(&quot;traversed const&quot;, set-&gt;count());</span>
<span class="line-added">445   #endif</span>
<span class="line-added">446   }</span>
<span class="line-added">447 </span>
<span class="line-added">448   // Return the next element of the set.</span>
<span class="line-added">449   uint next_value() {</span>
<span class="line-added">450     uint current = _current;</span>
<span class="line-added">451     assert(current != 0, &quot;sanity&quot;);</span>
<span class="line-added">452     uint advance = count_trailing_zeros(current);</span>
<span class="line-added">453     assert(((current &gt;&gt; advance) &amp; 0x1) == 1, &quot;sanity&quot;);</span>
<span class="line-added">454     _current = (current &gt;&gt; advance) - 1;</span>
<span class="line-added">455     _value += advance;</span>
<span class="line-added">456     return _value;</span>
<span class="line-added">457   }</span>
458 
459   // Return the next element of the set.  Return 0 when done.
460   uint next() {
<a name="14" id="anc14"></a><span class="line-modified">461     if (_current != 0) {</span>
<span class="line-modified">462       return next_value();</span>
<span class="line-modified">463     } else if (_next_word &lt; IndexSet::words_per_block || _next_block &lt; _max_blocks) {</span>





464       return advance_and_next();
<a name="15" id="anc15"></a><span class="line-added">465     } else {</span>
<span class="line-added">466       return 0;</span>
467     }
468   }
<a name="16" id="anc16"></a><span class="line-added">469 </span>
470 };
471 
472 #endif // SHARE_OPTO_INDEXSET_HPP
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
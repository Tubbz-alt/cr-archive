diff a/src/hotspot/share/opto/machnode.hpp b/src/hotspot/share/opto/machnode.hpp
--- a/src/hotspot/share/opto/machnode.hpp
+++ b/src/hotspot/share/opto/machnode.hpp
@@ -159,11 +159,11 @@
   // Return the method's address
   virtual intptr_t  method() const;
 
   // Hash and compare over operands are currently identical
   virtual uint  hash() const;
-  virtual uint  cmp( const MachOper &oper ) const;
+  virtual bool  cmp( const MachOper &oper ) const;
 
   // Virtual clone, since I do not know how big the MachOper is.
   virtual MachOper *clone() const = 0;
 
   // Return ideal Type from simple operands.  Fail for complex operands.
@@ -195,11 +195,11 @@
 //------------------------------MachNode---------------------------------------
 // Base type for all machine specific nodes.  All node classes generated by the
 // ADLC inherit from this class.
 class MachNode : public Node {
 public:
-  MachNode() : Node((uint)0), _num_opnds(0), _opnds(NULL) {
+  MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {
     init_class_id(Class_Mach);
   }
   // Required boilerplate
   virtual uint size_of() const { return sizeof(MachNode); }
   virtual int  Opcode() const;          // Always equal to MachNode
@@ -209,10 +209,13 @@
   virtual uint oper_input_base() const { return 1; }
   // Position of constant base node in node's inputs. -1 if
   // no constant base node input.
   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 
+  uint8_t barrier_data() const { return _barrier; }
+  void set_barrier_data(uint data) { _barrier = data; }
+
   // Copy inputs and operands to new node of instruction.
   // Called from cisc_version() and short_branch_version().
   // !!!! The method's body is defined in ad_<arch>.cpp file.
   void fill_new_machnode(MachNode *n) const;
 
@@ -238,10 +241,11 @@
   bool has_call() const { return (flags() & Flag_has_call) != 0; }
 
   // First index in _in[] corresponding to operand, or -1 if there is none
   int  operand_index(uint operand) const;
   int  operand_index(const MachOper *oper) const;
+  int  operand_index(Node* m) const;
 
   // Register class input is expected in
   virtual const RegMask &in_RegMask(uint) const;
 
   // cisc-spillable instructions redefine for use by in_RegMask
@@ -253,10 +257,13 @@
   // same singleton regiser (e.g., Intel IDIV which binds AX to be
   // both an input and an output).  It is nessecary when the input and
   // output have choices - but they must use the same choice.
   virtual uint two_adr( ) const { return 0; }
 
+  // The GC might require some barrier metadata for machine code emission.
+  uint8_t _barrier;
+
   // Array of complex operand pointers.  Each corresponds to zero or
   // more leafs.  Must be set by MachNode constructor to point to an
   // internal array of MachOpers.  The MachOper array is sized by
   // specific MachNodes described in the ADL.
   uint _num_opnds;
@@ -290,20 +297,27 @@
   // Return number of words used for double constants in this instruction
   virtual int   ins_num_consts() const { return 0; }
 
   // Hash and compare over operands.  Used to do GVN on machine Nodes.
   virtual uint  hash() const;
-  virtual uint  cmp( const Node &n ) const;
+  virtual bool  cmp( const Node &n ) const;
 
   // Expand method for MachNode, replaces nodes representing pseudo
   // instructions with a set of nodes which represent real machine
   // instructions and compute the same value.
   virtual MachNode *Expand( State *, Node_List &proj_list, Node* mem ) { return this; }
 
   // Bottom_type call; value comes from operand0
   virtual const class Type *bottom_type() const { return _opnds[0]->type(); }
-  virtual uint ideal_reg() const { const Type *t = _opnds[0]->type(); return t == TypeInt::CC ? Op_RegFlags : t->ideal_reg(); }
+  virtual uint ideal_reg() const {
+    const Type *t = _opnds[0]->type();
+    if (t == TypeInt::CC) {
+      return Op_RegFlags;
+    } else {
+      return t->ideal_reg();
+    }
+  }
 
   // If this is a memory op, return the base pointer and fixed offset.
   // If there are no such, return NULL.  If there are multiple addresses
   // or the address is indeterminate (rare cases) then return (Node*)-1,
   // which serves as node bottom.
@@ -859,11 +873,11 @@
 //------------------------------MachCallNode----------------------------------
 // Machine-specific versions of subroutine calls
 class MachCallNode : public MachSafePointNode {
 protected:
   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const = 0; // Size is bigger
 public:
   const TypeFunc *_tf;        // Function type
   address      _entry_point;  // Address of the method being called
   float        _cnt;          // Estimate of number of times called
@@ -902,11 +916,11 @@
 
 //------------------------------MachCallJavaNode------------------------------
 // "Base" class for machine-specific versions of subroutine calls
 class MachCallJavaNode : public MachCallNode {
 protected:
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   ciMethod* _method;                 // Method being direct called
   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
   int       _bci;                    // Byte Code index of call byte code
@@ -935,11 +949,11 @@
 };
 
 //------------------------------MachCallStaticJavaNode------------------------
 // Machine-specific versions of monomorphic subroutine calls
 class MachCallStaticJavaNode : public MachCallJavaNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   const char *_name;            // Runtime wrapper name
   MachCallStaticJavaNode() : MachCallJavaNode() {
     init_class_id(Class_MachCallStaticJava);
@@ -971,11 +985,11 @@
 };
 
 //------------------------------MachCallRuntimeNode----------------------------
 // Machine-specific versions of subroutine calls
 class MachCallRuntimeNode : public MachCallNode {
-  virtual uint cmp( const Node &n ) const;
+  virtual bool cmp( const Node &n ) const;
   virtual uint size_of() const; // Size is bigger
 public:
   const char *_name;            // Printable name, if _method is NULL
   MachCallRuntimeNode() : MachCallNode() {
     init_class_id(Class_MachCallRuntime);
@@ -995,10 +1009,11 @@
 
 //------------------------------MachHaltNode-----------------------------------
 // Machine-specific versions of halt nodes
 class MachHaltNode : public MachReturnNode {
 public:
+  const char* _halt_reason;
   virtual JVMState* jvms() const;
 };
 
 class MachMemBarNode : public MachNode {
   virtual uint size_of() const; // Size is bigger
@@ -1064,11 +1079,11 @@
   virtual Label *label() const { assert(_label != NULL, "need Label"); return _label; }
 
   virtual uint           opcode() const;
 
   virtual uint           hash()   const;
-  virtual uint           cmp( const MachOper &oper ) const;
+  virtual bool           cmp( const MachOper &oper ) const;
 #ifndef PRODUCT
   virtual const char    *Name()   const { return "Label";}
 
   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
@@ -1091,11 +1106,11 @@
   virtual intptr_t method() const { return _method; }
 
   virtual uint           opcode() const;
 
   virtual uint           hash()   const;
-  virtual uint           cmp( const MachOper &oper ) const;
+  virtual bool           cmp( const MachOper &oper ) const;
 #ifndef PRODUCT
   virtual const char    *Name()   const { return "Method";}
 
   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }

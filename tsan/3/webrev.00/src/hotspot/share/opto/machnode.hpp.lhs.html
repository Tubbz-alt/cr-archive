<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MACHNODE_HPP
  26 #define SHARE_OPTO_MACHNODE_HPP
  27 
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/matcher.hpp&quot;
  30 #include &quot;opto/multnode.hpp&quot;
  31 #include &quot;opto/node.hpp&quot;
  32 #include &quot;opto/regmask.hpp&quot;
  33 
  34 class BiasedLockingCounters;
  35 class BufferBlob;
  36 class CodeBuffer;
  37 class JVMState;
  38 class MachCallDynamicJavaNode;
  39 class MachCallJavaNode;
  40 class MachCallLeafNode;
  41 class MachCallNode;
  42 class MachCallRuntimeNode;
  43 class MachCallStaticJavaNode;
  44 class MachEpilogNode;
  45 class MachIfNode;
  46 class MachNullCheckNode;
  47 class MachOper;
  48 class MachProjNode;
  49 class MachPrologNode;
  50 class MachReturnNode;
  51 class MachSafePointNode;
  52 class MachSpillCopyNode;
  53 class Matcher;
  54 class PhaseRegAlloc;
  55 class RegMask;
  56 class RTMLockingCounters;
  57 class State;
  58 
  59 //---------------------------MachOper------------------------------------------
  60 class MachOper : public ResourceObj {
  61 public:
  62   // Allocate right next to the MachNodes in the same arena
  63   void *operator new(size_t x) throw() {
  64     Compile* C = Compile::current();
  65     return C-&gt;node_arena()-&gt;Amalloc_D(x);
  66   }
  67 
  68   // Opcode
  69   virtual uint opcode() const = 0;
  70 
  71   // Number of input edges.
  72   // Generally at least 1
  73   virtual uint num_edges() const { return 1; }
  74   // Array of Register masks
  75   virtual const RegMask *in_RegMask(int index) const;
  76 
  77   // Methods to output the encoding of the operand
  78 
  79   // Negate conditional branches.  Error for non-branch Nodes
  80   virtual void negate();
  81 
  82   // Return the value requested
  83   // result register lookup, corresponding to int_format
  84   virtual int  reg(PhaseRegAlloc *ra_, const Node *node)   const;
  85   // input register lookup, corresponding to ext_format
  86   virtual int  reg(PhaseRegAlloc *ra_, const Node *node, int idx)   const;
  87 
  88   // helpers for MacroAssembler generation from ADLC
  89   Register  as_Register(PhaseRegAlloc *ra_, const Node *node)   const {
  90     return ::as_Register(reg(ra_, node));
  91   }
  92   Register  as_Register(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
  93     return ::as_Register(reg(ra_, node, idx));
  94   }
  95   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node)   const {
  96     return ::as_FloatRegister(reg(ra_, node));
  97   }
  98   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
  99     return ::as_FloatRegister(reg(ra_, node, idx));
 100   }
 101 
 102 #if defined(IA32) || defined(AMD64)
 103   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node)   const {
 104     return ::as_XMMRegister(reg(ra_, node));
 105   }
 106   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 107     return ::as_XMMRegister(reg(ra_, node, idx));
 108   }
 109 #endif
 110   // CondRegister reg converter
 111 #if defined(PPC64)
 112   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node) const {
 113     return ::as_ConditionRegister(reg(ra_, node));
 114   }
 115   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 116     return ::as_ConditionRegister(reg(ra_, node, idx));
 117   }
 118   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {
 119     return ::as_VectorRegister(reg(ra_, node));
 120   }
 121   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 122     return ::as_VectorRegister(reg(ra_, node, idx));
 123   }
 124   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node) const {
 125     return ::as_VectorSRegister(reg(ra_, node));
 126   }
 127   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 128     return ::as_VectorSRegister(reg(ra_, node, idx));
 129   }
 130 #endif
 131 
 132   virtual intptr_t  constant() const;
 133   virtual relocInfo::relocType constant_reloc() const;
 134   virtual jdouble constantD() const;
 135   virtual jfloat  constantF() const;
 136   virtual jlong   constantL() const;
 137   virtual TypeOopPtr *oop() const;
 138   virtual int  ccode() const;
 139   // A zero, default, indicates this value is not needed.
 140   // May need to lookup the base register, as done in int_ and ext_format
 141   virtual int  base (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 142   virtual int  index(PhaseRegAlloc *ra_, const Node *node, int idx) const;
 143   virtual int  scale() const;
 144   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 145   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 146   // Check for PC-Relative displacement
 147   virtual relocInfo::relocType disp_reloc() const;
 148   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 149   virtual int  base_position()  const;  // base edge position, or -1
 150   virtual int  index_position() const;  // index edge position, or -1
 151 
 152   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 153   // Only returns non-null value for i486.ad&#39;s indOffset32X
 154   virtual const TypePtr *disp_as_type() const { return NULL; }
 155 
 156   // Return the label
 157   virtual Label *label() const;
 158 
 159   // Return the method&#39;s address
 160   virtual intptr_t  method() const;
 161 
 162   // Hash and compare over operands are currently identical
 163   virtual uint  hash() const;
<a name="1" id="anc1"></a><span class="line-modified"> 164   virtual uint  cmp( const MachOper &amp;oper ) const;</span>
 165 
 166   // Virtual clone, since I do not know how big the MachOper is.
 167   virtual MachOper *clone() const = 0;
 168 
 169   // Return ideal Type from simple operands.  Fail for complex operands.
 170   virtual const Type *type() const;
 171 
 172   // Set an integer offset if we have one, or error otherwise
 173   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 174 
 175 #ifndef PRODUCT
 176   // Return name of operand
 177   virtual const char    *Name() const { return &quot;???&quot;;}
 178 
 179   // Methods to output the text version of the operand
 180   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 181   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 182 
 183   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 184 
 185   // Check whether o is a valid oper.
 186   static bool notAnOper(const MachOper *o) {
 187     if (o == NULL)                   return true;
 188     if (((intptr_t)o &amp; 1) != 0)      return true;
 189     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 190     return false;
 191   }
 192 #endif // !PRODUCT
 193 };
 194 
 195 //------------------------------MachNode---------------------------------------
 196 // Base type for all machine specific nodes.  All node classes generated by the
 197 // ADLC inherit from this class.
 198 class MachNode : public Node {
 199 public:
<a name="2" id="anc2"></a><span class="line-modified"> 200   MachNode() : Node((uint)0), _num_opnds(0), _opnds(NULL) {</span>
 201     init_class_id(Class_Mach);
 202   }
 203   // Required boilerplate
 204   virtual uint size_of() const { return sizeof(MachNode); }
 205   virtual int  Opcode() const;          // Always equal to MachNode
 206   virtual uint rule() const = 0;        // Machine-specific opcode
 207   // Number of inputs which come before the first operand.
 208   // Generally at least 1, to skip the Control input
 209   virtual uint oper_input_base() const { return 1; }
 210   // Position of constant base node in node&#39;s inputs. -1 if
 211   // no constant base node input.
 212   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 213 
<a name="3" id="anc3"></a>


 214   // Copy inputs and operands to new node of instruction.
 215   // Called from cisc_version() and short_branch_version().
 216   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 217   void fill_new_machnode(MachNode *n) const;
 218 
 219   // Return an equivalent instruction using memory for cisc_operand position
 220   virtual MachNode *cisc_version(int offset);
 221   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 222   virtual void use_cisc_RegMask();
 223 
 224   // Support for short branches
 225   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 226 
 227   // Avoid back to back some instructions on some CPUs.
 228   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 229                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 230                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 231                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 232 
 233   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 234     return (flags() &amp; flag_value) == flag_value;
 235   }
 236 
 237   // instruction implemented with a call
 238   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 239 
 240   // First index in _in[] corresponding to operand, or -1 if there is none
 241   int  operand_index(uint operand) const;
 242   int  operand_index(const MachOper *oper) const;
<a name="4" id="anc4"></a>
 243 
 244   // Register class input is expected in
 245   virtual const RegMask &amp;in_RegMask(uint) const;
 246 
 247   // cisc-spillable instructions redefine for use by in_RegMask
 248   virtual const RegMask *cisc_RegMask() const { return NULL; }
 249 
 250   // If this instruction is a 2-address instruction, then return the
 251   // index of the input which must match the output.  Not nessecary
 252   // for instructions which bind the input and output register to the
 253   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 254   // both an input and an output).  It is nessecary when the input and
 255   // output have choices - but they must use the same choice.
 256   virtual uint two_adr( ) const { return 0; }
 257 
<a name="5" id="anc5"></a>


 258   // Array of complex operand pointers.  Each corresponds to zero or
 259   // more leafs.  Must be set by MachNode constructor to point to an
 260   // internal array of MachOpers.  The MachOper array is sized by
 261   // specific MachNodes described in the ADL.
 262   uint _num_opnds;
 263   MachOper **_opnds;
 264   uint  num_opnds() const { return _num_opnds; }
 265 
 266   // Emit bytes into cbuf
 267   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 268   // Expand node after register allocation.
 269   // Node is replaced by several nodes in the postalloc expand phase.
 270   // Corresponding methods are generated for nodes if they specify
 271   // postalloc_expand. See block.cpp for more documentation.
 272   virtual bool requires_postalloc_expand() const { return false; }
 273   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 274   // Size of instruction in bytes
 275   virtual uint  size(PhaseRegAlloc *ra_) const;
 276   // Helper function that computes size by emitting code
 277   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 278 
 279   // Return the alignment required (in units of relocInfo::addr_unit())
 280   // for this instruction (must be a power of 2)
 281   virtual int   alignment_required() const { return 1; }
 282 
 283   // Return the padding (in bytes) to be emitted before this
 284   // instruction to properly align it.
 285   virtual int   compute_padding(int current_offset) const { return 0; }
 286 
 287   // Return number of relocatable values contained in this instruction
 288   virtual int   reloc() const { return 0; }
 289 
 290   // Return number of words used for double constants in this instruction
 291   virtual int   ins_num_consts() const { return 0; }
 292 
 293   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 294   virtual uint  hash() const;
<a name="6" id="anc6"></a><span class="line-modified"> 295   virtual uint  cmp( const Node &amp;n ) const;</span>
 296 
 297   // Expand method for MachNode, replaces nodes representing pseudo
 298   // instructions with a set of nodes which represent real machine
 299   // instructions and compute the same value.
 300   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 301 
 302   // Bottom_type call; value comes from operand0
 303   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
<a name="7" id="anc7"></a><span class="line-modified"> 304   virtual uint ideal_reg() const { const Type *t = _opnds[0]-&gt;type(); return t == TypeInt::CC ? Op_RegFlags : t-&gt;ideal_reg(); }</span>







 305 
 306   // If this is a memory op, return the base pointer and fixed offset.
 307   // If there are no such, return NULL.  If there are multiple addresses
 308   // or the address is indeterminate (rare cases) then return (Node*)-1,
 309   // which serves as node bottom.
 310   // If the offset is not statically determined, set it to Type::OffsetBot.
 311   // This method is free to ignore stack slots if that helps.
 312   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 313   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 314   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 315 
 316   // Helper for get_base_and_disp: find the base and index input nodes.
 317   // Returns the MachOper as determined by memory_operand(), for use, if
 318   // needed by the caller. If (MachOper *)-1 is returned, base and index
 319   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 320   // index are set to NULL.
 321   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 322 
 323   // Helper for memory_inputs:  Which operand carries the necessary info?
 324   // By default, returns NULL, which means there is no such operand.
 325   // If it returns (MachOper*)-1, this means there are multiple memories.
 326   virtual const MachOper* memory_operand() const { return NULL; }
 327 
 328   // Call &quot;get_base_and_disp&quot; to decide which category of memory is used here.
 329   virtual const class TypePtr *adr_type() const;
 330 
 331   // Apply peephole rule(s) to this instruction
 332   virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);
 333 
 334   // Top-level ideal Opcode matched
 335   virtual int ideal_Opcode()     const { return Op_Node; }
 336 
 337   // Adds the label for the case
 338   virtual void add_case_label( int switch_val, Label* blockLabel);
 339 
 340   // Set the absolute address for methods
 341   virtual void method_set( intptr_t addr );
 342 
 343   // Should we clone rather than spill this instruction?
 344   bool rematerialize() const;
 345 
 346   // Get the pipeline info
 347   static const Pipeline *pipeline_class();
 348   virtual const Pipeline *pipeline() const;
 349 
 350   // Returns true if this node is a check that can be implemented with a trap.
 351   virtual bool is_TrapBasedCheckNode() const { return false; }
 352 
 353 #ifndef PRODUCT
 354   virtual const char *Name() const = 0; // Machine-specific name
 355   virtual void dump_spec(outputStream *st) const; // Print per-node info
 356   void         dump_format(PhaseRegAlloc *ra, outputStream *st) const; // access to virtual
 357 #endif
 358 };
 359 
 360 //------------------------------MachIdealNode----------------------------
 361 // Machine specific versions of nodes that must be defined by user.
 362 // These are not converted by matcher from ideal nodes to machine nodes
 363 // but are inserted into the code by the compiler.
 364 class MachIdealNode : public MachNode {
 365 public:
 366   MachIdealNode( ) {}
 367 
 368   // Define the following defaults for non-matched machine nodes
 369   virtual uint oper_input_base() const { return 0; }
 370   virtual uint rule()            const { return 9999999; }
 371   virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }
 372 };
 373 
 374 //------------------------------MachTypeNode----------------------------
 375 // Machine Nodes that need to retain a known Type.
 376 class MachTypeNode : public MachNode {
 377   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 378 public:
 379   MachTypeNode( ) {}
 380   const Type *_bottom_type;
 381 
 382   virtual const class Type *bottom_type() const { return _bottom_type; }
 383 #ifndef PRODUCT
 384   virtual void dump_spec(outputStream *st) const;
 385 #endif
 386 };
 387 
 388 //------------------------------MachBreakpointNode----------------------------
 389 // Machine breakpoint or interrupt Node
 390 class MachBreakpointNode : public MachIdealNode {
 391 public:
 392   MachBreakpointNode( ) {}
 393   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 394   virtual uint size(PhaseRegAlloc *ra_) const;
 395 
 396 #ifndef PRODUCT
 397   virtual const char *Name() const { return &quot;Breakpoint&quot;; }
 398   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 399 #endif
 400 };
 401 
 402 //------------------------------MachConstantBaseNode--------------------------
 403 // Machine node that represents the base address of the constant table.
 404 class MachConstantBaseNode : public MachIdealNode {
 405 public:
 406   static const RegMask&amp; _out_RegMask;  // We need the out_RegMask statically in MachConstantNode::in_RegMask().
 407 
 408 public:
 409   MachConstantBaseNode() : MachIdealNode() {
 410     init_class_id(Class_MachConstantBase);
 411   }
 412   virtual const class Type* bottom_type() const { return TypeRawPtr::NOTNULL; }
 413   virtual uint ideal_reg() const { return Op_RegP; }
 414   virtual uint oper_input_base() const { return 1; }
 415 
 416   virtual bool requires_postalloc_expand() const;
 417   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 418 
 419   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 420   virtual uint size(PhaseRegAlloc* ra_) const;
 421   virtual bool pinned() const { return UseRDPCForConstantTableBase; }
 422 
 423   static const RegMask&amp; static_out_RegMask() { return _out_RegMask; }
 424   virtual const RegMask&amp; out_RegMask() const { return static_out_RegMask(); }
 425 
 426 #ifndef PRODUCT
 427   virtual const char* Name() const { return &quot;MachConstantBaseNode&quot;; }
 428   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 429 #endif
 430 };
 431 
 432 //------------------------------MachConstantNode-------------------------------
 433 // Machine node that holds a constant which is stored in the constant table.
 434 class MachConstantNode : public MachTypeNode {
 435 protected:
 436   Compile::Constant _constant;  // This node&#39;s constant.
 437 
 438 public:
 439   MachConstantNode() : MachTypeNode() {
 440     init_class_id(Class_MachConstant);
 441   }
 442 
 443   virtual void eval_constant(Compile* C) {
 444 #ifdef ASSERT
 445     tty-&gt;print(&quot;missing MachConstantNode eval_constant function: &quot;);
 446     dump();
 447 #endif
 448     ShouldNotCallThis();
 449   }
 450 
 451   virtual const RegMask &amp;in_RegMask(uint idx) const {
 452     if (idx == mach_constant_base_node_input())
 453       return MachConstantBaseNode::static_out_RegMask();
 454     return MachNode::in_RegMask(idx);
 455   }
 456 
 457   // Input edge of MachConstantBaseNode.
 458   virtual uint mach_constant_base_node_input() const { return req() - 1; }
 459 
 460   int  constant_offset();
 461   int  constant_offset() const { return ((MachConstantNode*) this)-&gt;constant_offset(); }
 462   // Unchecked version to avoid assertions in debug output.
 463   int  constant_offset_unchecked() const;
 464 };
 465 
 466 //------------------------------MachUEPNode-----------------------------------
 467 // Machine Unvalidated Entry Point Node
 468 class MachUEPNode : public MachIdealNode {
 469 public:
 470   MachUEPNode( ) {}
 471   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 472   virtual uint size(PhaseRegAlloc *ra_) const;
 473 
 474 #ifndef PRODUCT
 475   virtual const char *Name() const { return &quot;Unvalidated-Entry-Point&quot;; }
 476   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 477 #endif
 478 };
 479 
 480 //------------------------------MachPrologNode--------------------------------
 481 // Machine function Prolog Node
 482 class MachPrologNode : public MachIdealNode {
 483 public:
 484   MachPrologNode( ) {}
 485   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 486   virtual uint size(PhaseRegAlloc *ra_) const;
 487   virtual int reloc() const;
 488 
 489 #ifndef PRODUCT
 490   virtual const char *Name() const { return &quot;Prolog&quot;; }
 491   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 492 #endif
 493 };
 494 
 495 //------------------------------MachEpilogNode--------------------------------
 496 // Machine function Epilog Node
 497 class MachEpilogNode : public MachIdealNode {
 498 public:
 499   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 500   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 501   virtual uint size(PhaseRegAlloc *ra_) const;
 502   virtual int reloc() const;
 503   virtual const Pipeline *pipeline() const;
 504 
 505 private:
 506   bool _do_polling;
 507 
 508 public:
 509   bool do_polling() const { return _do_polling; }
 510 
 511   // Offset of safepoint from the beginning of the node
 512   int safepoint_offset() const;
 513 
 514 #ifndef PRODUCT
 515   virtual const char *Name() const { return &quot;Epilog&quot;; }
 516   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 517 #endif
 518 };
 519 
 520 //------------------------------MachNopNode-----------------------------------
 521 // Machine function Nop Node
 522 class MachNopNode : public MachIdealNode {
 523 private:
 524   int _count;
 525 public:
 526   MachNopNode( ) : _count(1) {}
 527   MachNopNode( int count ) : _count(count) {}
 528   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 529   virtual uint size(PhaseRegAlloc *ra_) const;
 530 
 531   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 532 
 533   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
 534   virtual const Pipeline *pipeline() const;
 535 #ifndef PRODUCT
 536   virtual const char *Name() const { return &quot;Nop&quot;; }
 537   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 538   virtual void dump_spec(outputStream *st) const { } // No per-operand info
 539 #endif
 540 };
 541 
 542 //------------------------------MachSpillCopyNode------------------------------
 543 // Machine SpillCopy Node.  Copies 1 or 2 words from any location to any
 544 // location (stack or register).
 545 class MachSpillCopyNode : public MachIdealNode {
 546 public:
 547   enum SpillType {
 548     TwoAddress,                        // Inserted when coalescing of a two-address-instruction node and its input fails
 549     PhiInput,                          // Inserted when coalescing of a phi node and its input fails
 550     DebugUse,                          // Inserted as debug info spills to safepoints in non-frequent blocks
 551     LoopPhiInput,                      // Pre-split compares of loop-phis
 552     Definition,                        // An lrg marked as spilled will be spilled to memory right after its definition,
 553                                        // if in high pressure region or the lrg is bound
 554     RegToReg,                          // A register to register move
 555     RegToMem,                          // A register to memory move
 556     MemToReg,                          // A memory to register move
 557     PhiLocationDifferToInputLocation,  // When coalescing phi nodes in PhaseChaitin::Split(), a move spill is inserted if
 558                                        // the phi and its input resides at different locations (i.e. reg or mem)
 559     BasePointerToMem,                  // Spill base pointer to memory at safepoint
 560     InputToRematerialization,          // When rematerializing a node we stretch the inputs live ranges, and they might be
 561                                        // stretched beyond a new definition point, therefore we split out new copies instead
 562     CallUse,                           // Spill use at a call
 563     Bound                              // An lrg marked as spill that is bound and needs to be spilled at a use
 564   };
 565 private:
 566   const RegMask *_in;           // RegMask for input
 567   const RegMask *_out;          // RegMask for output
 568   const Type *_type;
 569   const SpillType _spill_type;
 570 public:
 571   MachSpillCopyNode(SpillType spill_type, Node *n, const RegMask &amp;in, const RegMask &amp;out ) :
 572     MachIdealNode(), _in(&amp;in), _out(&amp;out), _type(n-&gt;bottom_type()), _spill_type(spill_type) {
 573     init_class_id(Class_MachSpillCopy);
 574     init_flags(Flag_is_Copy);
 575     add_req(NULL);
 576     add_req(n);
 577   }
 578   virtual uint size_of() const { return sizeof(*this); }
 579   void set_out_RegMask(const RegMask &amp;out) { _out = &amp;out; }
 580   void set_in_RegMask(const RegMask &amp;in) { _in = &amp;in; }
 581   virtual const RegMask &amp;out_RegMask() const { return *_out; }
 582   virtual const RegMask &amp;in_RegMask(uint) const { return *_in; }
 583   virtual const class Type *bottom_type() const { return _type; }
 584   virtual uint ideal_reg() const { return _type-&gt;ideal_reg(); }
 585   virtual uint oper_input_base() const { return 1; }
 586   uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;
 587 
 588   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 589   virtual uint size(PhaseRegAlloc *ra_) const;
 590 
 591 
 592 #ifndef PRODUCT
 593   static const char *spill_type(SpillType st) {
 594     switch (st) {
 595       case TwoAddress:
 596         return &quot;TwoAddressSpillCopy&quot;;
 597       case PhiInput:
 598         return &quot;PhiInputSpillCopy&quot;;
 599       case DebugUse:
 600         return &quot;DebugUseSpillCopy&quot;;
 601       case LoopPhiInput:
 602         return &quot;LoopPhiInputSpillCopy&quot;;
 603       case Definition:
 604         return &quot;DefinitionSpillCopy&quot;;
 605       case RegToReg:
 606         return &quot;RegToRegSpillCopy&quot;;
 607       case RegToMem:
 608         return &quot;RegToMemSpillCopy&quot;;
 609       case MemToReg:
 610         return &quot;MemToRegSpillCopy&quot;;
 611       case PhiLocationDifferToInputLocation:
 612         return &quot;PhiLocationDifferToInputLocationSpillCopy&quot;;
 613       case BasePointerToMem:
 614         return &quot;BasePointerToMemSpillCopy&quot;;
 615       case InputToRematerialization:
 616         return &quot;InputToRematerializationSpillCopy&quot;;
 617       case CallUse:
 618         return &quot;CallUseSpillCopy&quot;;
 619       case Bound:
 620         return &quot;BoundSpillCopy&quot;;
 621       default:
 622         assert(false, &quot;Must have valid spill type&quot;);
 623         return &quot;MachSpillCopy&quot;;
 624     }
 625   }
 626 
 627   virtual const char *Name() const {
 628     return spill_type(_spill_type);
 629   }
 630 
 631   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 632 #endif
 633 };
 634 
 635 // MachMergeNode is similar to a PhiNode in a sense it merges multiple values,
 636 // however it doesn&#39;t have a control input and is more like a MergeMem.
 637 // It is inserted after the register allocation is done to ensure that nodes use single
 638 // definition of a multidef lrg in a block.
 639 class MachMergeNode : public MachIdealNode {
 640 public:
 641   MachMergeNode(Node *n1) {
 642     init_class_id(Class_MachMerge);
 643     add_req(NULL);
 644     add_req(n1);
 645   }
 646   virtual const RegMask &amp;out_RegMask() const { return in(1)-&gt;out_RegMask(); }
 647   virtual const RegMask &amp;in_RegMask(uint idx) const { return in(1)-&gt;in_RegMask(idx); }
 648   virtual const class Type *bottom_type() const { return in(1)-&gt;bottom_type(); }
 649   virtual uint ideal_reg() const { return bottom_type()-&gt;ideal_reg(); }
 650   virtual uint oper_input_base() const { return 1; }
 651   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const { }
 652   virtual uint size(PhaseRegAlloc *ra_) const { return 0; }
 653 #ifndef PRODUCT
 654   virtual const char *Name() const { return &quot;MachMerge&quot;; }
 655 #endif
 656 };
 657 
 658 //------------------------------MachBranchNode--------------------------------
 659 // Abstract machine branch Node
 660 class MachBranchNode : public MachIdealNode {
 661 public:
 662   MachBranchNode() : MachIdealNode() {
 663     init_class_id(Class_MachBranch);
 664   }
 665   virtual void label_set(Label* label, uint block_num) = 0;
 666   virtual void save_label(Label** label, uint* block_num) = 0;
 667 
 668   // Support for short branches
 669   virtual MachNode *short_branch_version() { return NULL; }
 670 
 671   virtual bool pinned() const { return true; };
 672 };
 673 
 674 //------------------------------MachNullChkNode--------------------------------
 675 // Machine-dependent null-pointer-check Node.  Points a real MachNode that is
 676 // also some kind of memory op.  Turns the indicated MachNode into a
 677 // conditional branch with good latency on the ptr-not-null path and awful
 678 // latency on the pointer-is-null path.
 679 
 680 class MachNullCheckNode : public MachBranchNode {
 681 public:
 682   const uint _vidx;             // Index of memop being tested
 683   MachNullCheckNode( Node *ctrl, Node *memop, uint vidx ) : MachBranchNode(), _vidx(vidx) {
 684     init_class_id(Class_MachNullCheck);
 685     add_req(ctrl);
 686     add_req(memop);
 687   }
 688   virtual uint size_of() const { return sizeof(*this); }
 689 
 690   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 691   virtual void label_set(Label* label, uint block_num);
 692   virtual void save_label(Label** label, uint* block_num);
 693   virtual void negate() { }
 694   virtual const class Type *bottom_type() const { return TypeTuple::IFBOTH; }
 695   virtual uint ideal_reg() const { return NotAMachineReg; }
 696   virtual const RegMask &amp;in_RegMask(uint) const;
 697   virtual const RegMask &amp;out_RegMask() const { return RegMask::Empty; }
 698 #ifndef PRODUCT
 699   virtual const char *Name() const { return &quot;NullCheck&quot;; }
 700   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 701 #endif
 702 };
 703 
 704 //------------------------------MachProjNode----------------------------------
 705 // Machine-dependent Ideal projections (how is that for an oxymoron).  Really
 706 // just MachNodes made by the Ideal world that replicate simple projections
 707 // but with machine-dependent input &amp; output register masks.  Generally
 708 // produced as part of calling conventions.  Normally I make MachNodes as part
 709 // of the Matcher process, but the Matcher is ill suited to issues involving
 710 // frame handling, so frame handling is all done in the Ideal world with
 711 // occasional callbacks to the machine model for important info.
 712 class MachProjNode : public ProjNode {
 713 public:
 714   MachProjNode( Node *multi, uint con, const RegMask &amp;out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {
 715     init_class_id(Class_MachProj);
 716   }
 717   RegMask _rout;
 718   const uint  _ideal_reg;
 719   enum projType {
 720     unmatched_proj = 0,         // Projs for Control, I/O, memory not matched
 721     fat_proj       = 999        // Projs killing many regs, defined by _rout
 722   };
 723   virtual int   Opcode() const;
 724   virtual const Type *bottom_type() const;
 725   virtual const TypePtr *adr_type() const;
 726   virtual const RegMask &amp;in_RegMask(uint) const { return RegMask::Empty; }
 727   virtual const RegMask &amp;out_RegMask() const { return _rout; }
 728   virtual uint  ideal_reg() const { return _ideal_reg; }
 729   // Need size_of() for virtual ProjNode::clone()
 730   virtual uint  size_of() const { return sizeof(MachProjNode); }
 731 #ifndef PRODUCT
 732   virtual void dump_spec(outputStream *st) const;
 733 #endif
 734 };
 735 
 736 //------------------------------MachIfNode-------------------------------------
 737 // Machine-specific versions of IfNodes
 738 class MachIfNode : public MachBranchNode {
 739   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 740 public:
 741   float _prob;                  // Probability branch goes either way
 742   float _fcnt;                  // Frequency counter
 743   MachIfNode() : MachBranchNode() {
 744     init_class_id(Class_MachIf);
 745   }
 746   // Negate conditional branches.
 747   virtual void negate() = 0;
 748 #ifndef PRODUCT
 749   virtual void dump_spec(outputStream *st) const;
 750 #endif
 751 };
 752 
 753 //------------------------------MachJumpNode-----------------------------------
 754 // Machine-specific versions of JumpNodes
 755 class MachJumpNode : public MachConstantNode {
 756 public:
 757   float* _probs;
 758   MachJumpNode() : MachConstantNode() {
 759     init_class_id(Class_MachJump);
 760   }
 761 };
 762 
 763 //------------------------------MachGotoNode-----------------------------------
 764 // Machine-specific versions of GotoNodes
 765 class MachGotoNode : public MachBranchNode {
 766 public:
 767   MachGotoNode() : MachBranchNode() {
 768     init_class_id(Class_MachGoto);
 769   }
 770 };
 771 
 772 //------------------------------MachFastLockNode-------------------------------------
 773 // Machine-specific versions of FastLockNodes
 774 class MachFastLockNode : public MachNode {
 775   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 776 public:
 777   BiasedLockingCounters*        _counters;
 778   RTMLockingCounters*       _rtm_counters; // RTM lock counters for inflated locks
 779   RTMLockingCounters* _stack_rtm_counters; // RTM lock counters for stack locks
 780   MachFastLockNode() : MachNode() {}
 781 };
 782 
 783 //------------------------------MachReturnNode--------------------------------
 784 // Machine-specific versions of subroutine returns
 785 class MachReturnNode : public MachNode {
 786   virtual uint size_of() const; // Size is bigger
 787 public:
 788   RegMask *_in_rms;             // Input register masks, set during allocation
 789   ReallocMark _nesting;         // assertion check for reallocations
 790   const TypePtr* _adr_type;     // memory effects of call or return
 791   MachReturnNode() : MachNode() {
 792     init_class_id(Class_MachReturn);
 793     _adr_type = TypePtr::BOTTOM; // the default: all of memory
 794   }
 795 
 796   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
 797 
 798   virtual const RegMask &amp;in_RegMask(uint) const;
 799   virtual bool pinned() const { return true; };
 800   virtual const TypePtr *adr_type() const;
 801 };
 802 
 803 //------------------------------MachSafePointNode-----------------------------
 804 // Machine-specific versions of safepoints
 805 class MachSafePointNode : public MachReturnNode {
 806 public:
 807   OopMap*         _oop_map;     // Array of OopMap info (8-bit char) for GC
 808   JVMState*       _jvms;        // Pointer to list of JVM State Objects
 809   uint            _jvmadj;      // Extra delta to jvms indexes (mach. args)
 810   OopMap*         oop_map() const { return _oop_map; }
 811   void            set_oop_map(OopMap* om) { _oop_map = om; }
 812 
 813   MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0) {
 814     init_class_id(Class_MachSafePoint);
 815   }
 816 
 817   virtual JVMState* jvms() const { return _jvms; }
 818   void set_jvms(JVMState* s) {
 819     _jvms = s;
 820   }
 821   virtual const Type    *bottom_type() const;
 822 
 823   virtual const RegMask &amp;in_RegMask(uint) const;
 824 
 825   // Functionality from old debug nodes
 826   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 827   Node *frameptr () const { return in(TypeFunc::FramePtr); }
 828 
 829   Node *local(const JVMState* jvms, uint idx) const {
 830     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 831     return in(_jvmadj + jvms-&gt;locoff() + idx);
 832   }
 833   Node *stack(const JVMState* jvms, uint idx) const {
 834     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 835     return in(_jvmadj + jvms-&gt;stkoff() + idx);
 836  }
 837   Node *monitor_obj(const JVMState* jvms, uint idx) const {
 838     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 839     return in(_jvmadj + jvms-&gt;monitor_obj_offset(idx));
 840   }
 841   Node *monitor_box(const JVMState* jvms, uint idx) const {
 842     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 843     return in(_jvmadj + jvms-&gt;monitor_box_offset(idx));
 844   }
 845   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 846     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 847     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 848   }
 849   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 850     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 851     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 852   }
 853   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 854     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 855     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 856   }
 857 };
 858 
 859 //------------------------------MachCallNode----------------------------------
 860 // Machine-specific versions of subroutine calls
 861 class MachCallNode : public MachSafePointNode {
 862 protected:
 863   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
<a name="8" id="anc8"></a><span class="line-modified"> 864   virtual uint cmp( const Node &amp;n ) const;</span>
 865   virtual uint size_of() const = 0; // Size is bigger
 866 public:
 867   const TypeFunc *_tf;        // Function type
 868   address      _entry_point;  // Address of the method being called
 869   float        _cnt;          // Estimate of number of times called
 870   uint         _argsize;      // Size of argument block on stack
 871 
 872   const TypeFunc* tf()        const { return _tf; }
 873   const address entry_point() const { return _entry_point; }
 874   const float   cnt()         const { return _cnt; }
 875   uint argsize()              const { return _argsize; }
 876 
 877   void set_tf(const TypeFunc* tf) { _tf = tf; }
 878   void set_entry_point(address p) { _entry_point = p; }
 879   void set_cnt(float c)           { _cnt = c; }
 880   void set_argsize(int s)         { _argsize = s; }
 881 
 882   MachCallNode() : MachSafePointNode() {
 883     init_class_id(Class_MachCall);
 884   }
 885 
 886   virtual const Type *bottom_type() const;
 887   virtual bool  pinned() const { return false; }
 888   virtual const Type* Value(PhaseGVN* phase) const;
 889   virtual const RegMask &amp;in_RegMask(uint) const;
 890   virtual int ret_addr_offset() { return 0; }
 891 
 892   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 893   bool return_value_is_used() const;
 894 
 895   // Similar to cousin class CallNode::returns_pointer
 896   bool returns_pointer() const;
 897 
 898 #ifndef PRODUCT
 899   virtual void dump_spec(outputStream *st) const;
 900 #endif
 901 };
 902 
 903 //------------------------------MachCallJavaNode------------------------------
 904 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 905 class MachCallJavaNode : public MachCallNode {
 906 protected:
<a name="9" id="anc9"></a><span class="line-modified"> 907   virtual uint cmp( const Node &amp;n ) const;</span>
 908   virtual uint size_of() const; // Size is bigger
 909 public:
 910   ciMethod* _method;                 // Method being direct called
 911   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 912   int       _bci;                    // Byte Code index of call byte code
 913   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 914   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 915   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 916     init_class_id(Class_MachCallJava);
 917   }
 918 
 919   virtual const RegMask &amp;in_RegMask(uint) const;
 920 
 921   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 922     if (_override_symbolic_info) {
 923       // Attach corresponding Method* to the call site, so VM can use it during resolution
 924       // instead of querying symbolic info from bytecode.
 925       assert(_method != NULL, &quot;method should be set&quot;);
 926       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 927       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 928     }
 929     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 930   }
 931 
 932 #ifndef PRODUCT
 933   virtual void dump_spec(outputStream *st) const;
 934 #endif
 935 };
 936 
 937 //------------------------------MachCallStaticJavaNode------------------------
 938 // Machine-specific versions of monomorphic subroutine calls
 939 class MachCallStaticJavaNode : public MachCallJavaNode {
<a name="10" id="anc10"></a><span class="line-modified"> 940   virtual uint cmp( const Node &amp;n ) const;</span>
 941   virtual uint size_of() const; // Size is bigger
 942 public:
 943   const char *_name;            // Runtime wrapper name
 944   MachCallStaticJavaNode() : MachCallJavaNode() {
 945     init_class_id(Class_MachCallStaticJava);
 946   }
 947 
 948   // If this is an uncommon trap, return the request code, else zero.
 949   int uncommon_trap_request() const;
 950 
 951   virtual int ret_addr_offset();
 952 #ifndef PRODUCT
 953   virtual void dump_spec(outputStream *st) const;
 954   void dump_trap_args(outputStream *st) const;
 955 #endif
 956 };
 957 
 958 //------------------------------MachCallDynamicJavaNode------------------------
 959 // Machine-specific versions of possibly megamorphic subroutine calls
 960 class MachCallDynamicJavaNode : public MachCallJavaNode {
 961 public:
 962   int _vtable_index;
 963   MachCallDynamicJavaNode() : MachCallJavaNode() {
 964     init_class_id(Class_MachCallDynamicJava);
 965     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
 966   }
 967   virtual int ret_addr_offset();
 968 #ifndef PRODUCT
 969   virtual void dump_spec(outputStream *st) const;
 970 #endif
 971 };
 972 
 973 //------------------------------MachCallRuntimeNode----------------------------
 974 // Machine-specific versions of subroutine calls
 975 class MachCallRuntimeNode : public MachCallNode {
<a name="11" id="anc11"></a><span class="line-modified"> 976   virtual uint cmp( const Node &amp;n ) const;</span>
 977   virtual uint size_of() const; // Size is bigger
 978 public:
 979   const char *_name;            // Printable name, if _method is NULL
 980   MachCallRuntimeNode() : MachCallNode() {
 981     init_class_id(Class_MachCallRuntime);
 982   }
 983   virtual int ret_addr_offset();
 984 #ifndef PRODUCT
 985   virtual void dump_spec(outputStream *st) const;
 986 #endif
 987 };
 988 
 989 class MachCallLeafNode: public MachCallRuntimeNode {
 990 public:
 991   MachCallLeafNode() : MachCallRuntimeNode() {
 992     init_class_id(Class_MachCallLeaf);
 993   }
 994 };
 995 
 996 //------------------------------MachHaltNode-----------------------------------
 997 // Machine-specific versions of halt nodes
 998 class MachHaltNode : public MachReturnNode {
 999 public:
<a name="12" id="anc12"></a>
1000   virtual JVMState* jvms() const;
1001 };
1002 
1003 class MachMemBarNode : public MachNode {
1004   virtual uint size_of() const; // Size is bigger
1005 public:
1006   const TypePtr* _adr_type;     // memory effects
1007   MachMemBarNode() : MachNode() {
1008     init_class_id(Class_MachMemBar);
1009     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1010   }
1011 
1012   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1013   virtual const TypePtr *adr_type() const;
1014 };
1015 
1016 
1017 //------------------------------MachTempNode-----------------------------------
1018 // Node used by the adlc to construct inputs to represent temporary registers
1019 class MachTempNode : public MachNode {
1020 private:
1021   MachOper *_opnd_array[1];
1022 
1023 public:
1024   virtual const RegMask &amp;out_RegMask() const { return *_opnds[0]-&gt;in_RegMask(0); }
1025   virtual uint rule() const { return 9999999; }
1026   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1027 
1028   MachTempNode(MachOper* oper) {
1029     init_class_id(Class_MachTemp);
1030     _num_opnds = 1;
1031     _opnds = _opnd_array;
1032     add_req(NULL);
1033     _opnds[0] = oper;
1034   }
1035   virtual uint size_of() const { return sizeof(MachTempNode); }
1036 
1037 #ifndef PRODUCT
1038   virtual void format(PhaseRegAlloc *, outputStream *st ) const {}
1039   virtual const char *Name() const { return &quot;MachTemp&quot;;}
1040 #endif
1041 };
1042 
1043 
1044 
1045 //------------------------------labelOper--------------------------------------
1046 // Machine-independent version of label operand
1047 class labelOper : public MachOper {
1048 private:
1049   virtual uint           num_edges() const { return 0; }
1050 public:
1051   // Supported for fixed size branches
1052   Label* _label;                // Label for branch(es)
1053 
1054   uint _block_num;
1055 
1056   labelOper() : _label(0), _block_num(0) {}
1057 
1058   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1059 
1060   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1061 
1062   virtual MachOper *clone() const;
1063 
1064   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1065 
1066   virtual uint           opcode() const;
1067 
1068   virtual uint           hash()   const;
<a name="13" id="anc13"></a><span class="line-modified">1069   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
1070 #ifndef PRODUCT
1071   virtual const char    *Name()   const { return &quot;Label&quot;;}
1072 
1073   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1074   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1075 #endif
1076 };
1077 
1078 
1079 //------------------------------methodOper--------------------------------------
1080 // Machine-independent version of method operand
1081 class methodOper : public MachOper {
1082 private:
1083   virtual uint           num_edges() const { return 0; }
1084 public:
1085   intptr_t _method;             // Address of method
1086   methodOper() :   _method(0) {}
1087   methodOper(intptr_t method) : _method(method)  {}
1088 
1089   virtual MachOper *clone() const;
1090 
1091   virtual intptr_t method() const { return _method; }
1092 
1093   virtual uint           opcode() const;
1094 
1095   virtual uint           hash()   const;
<a name="14" id="anc14"></a><span class="line-modified">1096   virtual uint           cmp( const MachOper &amp;oper ) const;</span>
1097 #ifndef PRODUCT
1098   virtual const char    *Name()   const { return &quot;Method&quot;;}
1099 
1100   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1101   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1102 #endif
1103 };
1104 
1105 #endif // SHARE_OPTO_MACHNODE_HPP
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/phaseX.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="phaseX.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/phaseX.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -89,11 +89,11 @@</span>
    Node  *at(uint table_index) {
      assert(table_index &lt; _max, &quot;Must be within table&quot;);
      return _table[table_index];
    }
  
<span class="udiff-line-modified-removed">-   void   remove_useless_nodes(VectorSet &amp;useful); // replace with sentinel</span>
<span class="udiff-line-modified-added">+   void   remove_useless_nodes(VectorSet&amp; useful); // replace with sentinel</span>
    void   replace_with(NodeHash* nh);
    void   check_no_speculative_types(); // Check no speculative part for type nodes in table
  
    Node  *sentinel() { return _sentinel; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -375,11 +375,10 @@</span>
    NodeHash  _table;             // Hash table for value-numbering
  
  public:
    PhaseValues( Arena *arena, uint est_max_size );
    PhaseValues( PhaseValues *pt );
<span class="udiff-line-removed">-   PhaseValues( PhaseValues *ptv, const char *dummy );</span>
    NOT_PRODUCT( ~PhaseValues(); )
    virtual PhaseIterGVN *is_IterGVN() { return 0; }
  
    // Some Ideal and other transforms delete --&gt; modify --&gt; insert values
    bool   hash_delete(Node *n)     { return _table.hash_delete(n); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -416,11 +415,10 @@</span>
    bool is_dominator_helper(Node *d, Node *n, bool linear_only);
  
  public:
    PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}
    PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}
<span class="udiff-line-removed">-   PhaseGVN( PhaseGVN *gvn, const char *dummy ) : PhaseValues( gvn, dummy ) {}</span>
  
    // Return a node which computes the same function as this node, but
    // in a faster or cheaper fashion.
    Node  *transform( Node *n );
    Node  *transform_no_reclaim( Node *n );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -436,13 +434,10 @@</span>
    bool is_dominator(Node *d, Node *n) { return is_dominator_helper(d, n, true); }
  
    // Helper to call Node::Ideal() and BarrierSetC2::ideal_node().
    Node* apply_ideal(Node* i, bool can_reshape);
  
<span class="udiff-line-removed">-   // Helper to call Node::Identity() and BarrierSetC2::identity_node().</span>
<span class="udiff-line-removed">-   Node* apply_identity(Node* n);</span>
<span class="udiff-line-removed">- </span>
    // Check for a simple dead loop when a data node references itself.
    DEBUG_ONLY(void dead_loop_check(Node *n);)
  };
  
  //------------------------------PhaseIterGVN-----------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -472,11 +467,10 @@</span>
    // improvement, such that it would take many (&gt;&gt;10) steps to reach 2**32.
  
  public:
    PhaseIterGVN( PhaseIterGVN *igvn ); // Used by CCP constructor
    PhaseIterGVN( PhaseGVN *gvn ); // Used after Parser
<span class="udiff-line-removed">-   PhaseIterGVN( PhaseIterGVN *igvn, const char *dummy ); // Used after +VerifyOpto</span>
  
    // Idealize new Node &#39;n&#39; with respect to its inputs and its value
    virtual Node *transform( Node *a_node );
    virtual void record_for_igvn(Node *n) { }
  
</pre>
<center><a href="phaseX.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="phasetype.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
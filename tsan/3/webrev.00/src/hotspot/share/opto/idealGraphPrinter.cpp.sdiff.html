<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/idealGraphPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/idealGraphPrinter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
333   }
334 
335   tail(PROPERTIES_ELEMENT);
336 
337   _should_send_method = true;
338   this-&gt;_current_method = method;
339 
340   _xml-&gt;flush();
341 }
342 
343 // Has to be called whenever a method has finished compilation
344 void IdealGraphPrinter::end_method() {
345 
346   nmethod* method = (nmethod*)this-&gt;_current_method-&gt;code();
347 
348   tail(GROUP_ELEMENT);
349   _current_method = NULL;
350   _xml-&gt;flush();
351 }
352 
<span class="line-removed">353 // Print indent</span>
<span class="line-removed">354 void IdealGraphPrinter::print_indent() {</span>
<span class="line-removed">355   tty-&gt;print_cr(&quot;printing indent %d&quot;, _depth);</span>
<span class="line-removed">356   for (int i = 0; i &lt; _depth; i++) {</span>
<span class="line-removed">357     _xml-&gt;print(&quot;%s&quot;, INDENT);</span>
<span class="line-removed">358   }</span>
<span class="line-removed">359 }</span>
<span class="line-removed">360 </span>
361 bool IdealGraphPrinter::traverse_outs() {
362   return _traverse_outs;
363 }
364 
365 void IdealGraphPrinter::set_traverse_outs(bool b) {
366   _traverse_outs = b;
367 }
368 
369 void IdealGraphPrinter::visit_node(Node *n, bool edges, VectorSet* temp_set) {
370 
371   if (edges) {
372 
373     // Output edge
374     node_idx_t dest_id = n-&gt;_idx;
375     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
376       if ( n-&gt;in(i) ) {
377         Node *source = n-&gt;in(i);
378         begin_elem(EDGE_ELEMENT);
379         print_attr(FROM_PROPERTY, source-&gt;_idx);
380         print_attr(TO_PROPERTY, dest_id);
</pre>
<hr />
<pre>
575     if (caller != NULL) {
576       stringStream bciStream;
577       ciMethod* last = NULL;
578       int last_bci;
579       while(caller) {
580         if (caller-&gt;has_method()) {
581           last = caller-&gt;method();
582           last_bci = caller-&gt;bci();
583         }
584         bciStream.print(&quot;%d &quot;, caller-&gt;bci());
585         caller = caller-&gt;caller();
586       }
587       print_prop(&quot;bci&quot;, bciStream.as_string());
588       if (last != NULL &amp;&amp; last-&gt;has_linenumber_table() &amp;&amp; last_bci &gt;= 0) {
589         print_prop(&quot;line&quot;, last-&gt;line_number_from_bci(last_bci));
590       }
591     }
592 
593 #ifdef ASSERT
594     if (node-&gt;debug_orig() != NULL) {
<span class="line-modified">595       temp_set-&gt;Clear();</span>
596       stringStream dorigStream;
597       Node* dorig = node-&gt;debug_orig();
598       while (dorig &amp;&amp; temp_set-&gt;test_set(dorig-&gt;_idx)) {
599         dorigStream.print(&quot;%d &quot;, dorig-&gt;_idx);
600       }
601       print_prop(&quot;debug_orig&quot;, dorigStream.as_string());
602     }
603 #endif
604 
605     if (_chaitin &amp;&amp; _chaitin != (PhaseChaitin *)((intptr_t)0xdeadbeef)) {
606       buffer[0] = 0;
607       _chaitin-&gt;dump_register(node, buffer);
608       print_prop(&quot;reg&quot;, buffer);
609       uint lrg_id = 0;
610       if (node-&gt;_idx &lt; _chaitin-&gt;_lrg_map.size()) {
611         lrg_id = _chaitin-&gt;_lrg_map.live_range_id(node);
612       }
613       print_prop(&quot;lrg&quot;, lrg_id);
614     }
615 
</pre>
<hr />
<pre>
646 
647     if (_traverse_outs) {
648       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
649         Node* p = n-&gt;out(i);
650         if (!visited.test_set(p-&gt;_idx)) {
651           nodeStack.push(p);
652         }
653       }
654     }
655 
656     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
657       if ( n-&gt;in(i) ) {
658         if (!visited.test_set(n-&gt;in(i)-&gt;_idx)) {
659           nodeStack.push(n-&gt;in(i));
660         }
661       }
662     }
663   }
664 }
665 
<span class="line-modified">666 void IdealGraphPrinter::print_method(const char *name, int level, bool clear_nodes) {</span>
<span class="line-modified">667   print(name, (Node *)C-&gt;root(), level, clear_nodes);</span>


668 }
669 
670 // Print current ideal graph
<span class="line-modified">671 void IdealGraphPrinter::print(const char *name, Node *node, int level, bool clear_nodes) {</span>
672 
<span class="line-modified">673   if (!_current_method || !_should_send_method || !should_print(level)) return;</span>
674 
675   // Warning, unsafe cast?
676   _chaitin = (PhaseChaitin *)C-&gt;regalloc();
677 
678   begin_head(GRAPH_ELEMENT);
679   print_attr(GRAPH_NAME_PROPERTY, (const char *)name);
680   end_head();
681 
682   VectorSet temp_set(Thread::current()-&gt;resource_area());
683 
684   head(NODES_ELEMENT);
685   walk_nodes(node, false, &amp;temp_set);
686   tail(NODES_ELEMENT);
687 
688   head(EDGES_ELEMENT);
689   walk_nodes(node, true, &amp;temp_set);
690   tail(EDGES_ELEMENT);
691   if (C-&gt;cfg() != NULL) {
692     head(CONTROL_FLOW_ELEMENT);
693     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
</pre>
</td>
<td>
<hr />
<pre>
333   }
334 
335   tail(PROPERTIES_ELEMENT);
336 
337   _should_send_method = true;
338   this-&gt;_current_method = method;
339 
340   _xml-&gt;flush();
341 }
342 
343 // Has to be called whenever a method has finished compilation
344 void IdealGraphPrinter::end_method() {
345 
346   nmethod* method = (nmethod*)this-&gt;_current_method-&gt;code();
347 
348   tail(GROUP_ELEMENT);
349   _current_method = NULL;
350   _xml-&gt;flush();
351 }
352 








353 bool IdealGraphPrinter::traverse_outs() {
354   return _traverse_outs;
355 }
356 
357 void IdealGraphPrinter::set_traverse_outs(bool b) {
358   _traverse_outs = b;
359 }
360 
361 void IdealGraphPrinter::visit_node(Node *n, bool edges, VectorSet* temp_set) {
362 
363   if (edges) {
364 
365     // Output edge
366     node_idx_t dest_id = n-&gt;_idx;
367     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
368       if ( n-&gt;in(i) ) {
369         Node *source = n-&gt;in(i);
370         begin_elem(EDGE_ELEMENT);
371         print_attr(FROM_PROPERTY, source-&gt;_idx);
372         print_attr(TO_PROPERTY, dest_id);
</pre>
<hr />
<pre>
567     if (caller != NULL) {
568       stringStream bciStream;
569       ciMethod* last = NULL;
570       int last_bci;
571       while(caller) {
572         if (caller-&gt;has_method()) {
573           last = caller-&gt;method();
574           last_bci = caller-&gt;bci();
575         }
576         bciStream.print(&quot;%d &quot;, caller-&gt;bci());
577         caller = caller-&gt;caller();
578       }
579       print_prop(&quot;bci&quot;, bciStream.as_string());
580       if (last != NULL &amp;&amp; last-&gt;has_linenumber_table() &amp;&amp; last_bci &gt;= 0) {
581         print_prop(&quot;line&quot;, last-&gt;line_number_from_bci(last_bci));
582       }
583     }
584 
585 #ifdef ASSERT
586     if (node-&gt;debug_orig() != NULL) {
<span class="line-modified">587       temp_set-&gt;clear();</span>
588       stringStream dorigStream;
589       Node* dorig = node-&gt;debug_orig();
590       while (dorig &amp;&amp; temp_set-&gt;test_set(dorig-&gt;_idx)) {
591         dorigStream.print(&quot;%d &quot;, dorig-&gt;_idx);
592       }
593       print_prop(&quot;debug_orig&quot;, dorigStream.as_string());
594     }
595 #endif
596 
597     if (_chaitin &amp;&amp; _chaitin != (PhaseChaitin *)((intptr_t)0xdeadbeef)) {
598       buffer[0] = 0;
599       _chaitin-&gt;dump_register(node, buffer);
600       print_prop(&quot;reg&quot;, buffer);
601       uint lrg_id = 0;
602       if (node-&gt;_idx &lt; _chaitin-&gt;_lrg_map.size()) {
603         lrg_id = _chaitin-&gt;_lrg_map.live_range_id(node);
604       }
605       print_prop(&quot;lrg&quot;, lrg_id);
606     }
607 
</pre>
<hr />
<pre>
638 
639     if (_traverse_outs) {
640       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
641         Node* p = n-&gt;out(i);
642         if (!visited.test_set(p-&gt;_idx)) {
643           nodeStack.push(p);
644         }
645       }
646     }
647 
648     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
649       if ( n-&gt;in(i) ) {
650         if (!visited.test_set(n-&gt;in(i)-&gt;_idx)) {
651           nodeStack.push(n-&gt;in(i));
652         }
653       }
654     }
655   }
656 }
657 
<span class="line-modified">658 void IdealGraphPrinter::print_method(const char *name, int level) {</span>
<span class="line-modified">659   if (should_print(level)) {</span>
<span class="line-added">660     print(name, (Node *) C-&gt;root());</span>
<span class="line-added">661   }</span>
662 }
663 
664 // Print current ideal graph
<span class="line-modified">665 void IdealGraphPrinter::print(const char *name, Node *node) {</span>
666 
<span class="line-modified">667   if (!_current_method || !_should_send_method || node == NULL) return;</span>
668 
669   // Warning, unsafe cast?
670   _chaitin = (PhaseChaitin *)C-&gt;regalloc();
671 
672   begin_head(GRAPH_ELEMENT);
673   print_attr(GRAPH_NAME_PROPERTY, (const char *)name);
674   end_head();
675 
676   VectorSet temp_set(Thread::current()-&gt;resource_area());
677 
678   head(NODES_ELEMENT);
679   walk_nodes(node, false, &amp;temp_set);
680   tail(NODES_ELEMENT);
681 
682   head(EDGES_ELEMENT);
683   walk_nodes(node, true, &amp;temp_set);
684   tail(EDGES_ELEMENT);
685   if (C-&gt;cfg() != NULL) {
686     head(CONTROL_FLOW_ELEMENT);
687     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
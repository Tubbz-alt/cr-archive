<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;opto/loopnode.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/connode.hpp&quot;
  30 #include &quot;opto/convertnode.hpp&quot;
  31 #include &quot;opto/loopnode.hpp&quot;
  32 #include &quot;opto/matcher.hpp&quot;
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/opaquenode.hpp&quot;
  35 #include &quot;opto/rootnode.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &lt;fenv.h&gt;
  38 #include &lt;math.h&gt;
  39 
  40 /*
  41  * The general idea of Loop Predication is to insert a predicate on the entry
  42  * path to a loop, and raise a uncommon trap if the check of the condition fails.
  43  * The condition checks are promoted from inside the loop body, and thus
  44  * the checks inside the loop could be eliminated. Currently, loop predication
  45  * optimization has been applied to remove array range check and loop invariant
  46  * checks (such as null checks).
  47 */
  48 
  49 //-------------------------------register_control-------------------------
  50 void PhaseIdealLoop::register_control(Node* n, IdealLoopTree *loop, Node* pred) {
  51   assert(n-&gt;is_CFG(), &quot;must be control node&quot;);
  52   _igvn.register_new_node_with_optimizer(n);
  53   loop-&gt;_body.push(n);
  54   set_loop(n, loop);
  55   // When called from beautify_loops() idom is not constructed yet.
  56   if (_idom != NULL) {
  57     set_idom(n, pred, dom_depth(pred));
  58   }
  59 }
  60 
  61 //------------------------------create_new_if_for_predicate------------------------
  62 // create a new if above the uct_if_pattern for the predicate to be promoted.
  63 //
  64 //          before                                after
  65 //        ----------                           ----------
  66 //           ctrl                                 ctrl
  67 //            |                                     |
  68 //            |                                     |
  69 //            v                                     v
  70 //           iff                                 new_iff
  71 //          /    \                                /      \
  72 //         /      \                              /        \
  73 //        v        v                            v          v
  74 //  uncommon_proj cont_proj                   if_uct     if_cont
  75 // \      |        |                           |          |
  76 //  \     |        |                           |          |
  77 //   v    v        v                           |          v
  78 //     rgn       loop                          |         iff
  79 //      |                                      |        /     \
  80 //      |                                      |       /       \
  81 //      v                                      |      v         v
  82 // uncommon_trap                               | uncommon_proj cont_proj
  83 //                                           \  \    |           |
  84 //                                            \  \   |           |
  85 //                                             v  v  v           v
  86 //                                               rgn           loop
  87 //                                                |
  88 //                                                |
  89 //                                                v
  90 //                                           uncommon_trap
  91 //
  92 //
  93 // We will create a region to guard the uct call if there is no one there.
  94 // The true projection (if_cont) of the new_iff is returned.
  95 // This code is also used to clone predicates to cloned loops.
  96 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
  97                                                       Deoptimization::DeoptReason reason,
  98                                                       int opcode) {
  99   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 100   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 101 
 102   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 103   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 104   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 105 
 106   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 107   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 108     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 109     CallNode* call = rgn-&gt;as_Call();
 110     IdealLoopTree* loop = get_loop(call);
 111     rgn = new RegionNode(1);
 112     rgn-&gt;add_req(uncommon_proj);
 113     register_control(rgn, loop, uncommon_proj);
 114     _igvn.replace_input_of(call, 0, rgn);
 115     // When called from beautify_loops() idom is not constructed yet.
 116     if (_idom != NULL) {
 117       set_idom(call, rgn, dom_depth(rgn));
 118     }
 119     for (DUIterator_Fast imax, i = uncommon_proj-&gt;fast_outs(imax); i &lt; imax; i++) {
 120       Node* n = uncommon_proj-&gt;fast_out(i);
 121       if (n-&gt;is_Load() || n-&gt;is_Store()) {
 122         _igvn.replace_input_of(n, 0, rgn);
 123         --i; --imax;
 124       }
 125     }
 126   } else {
 127     // Find region&#39;s edge corresponding to uncommon_proj
 128     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 129       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 130     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 131   }
 132 
 133   Node* entry = iff-&gt;in(0);
 134   if (new_entry != NULL) {
 135     // Clonning the predicate to new location.
 136     entry = new_entry;
 137   }
 138   // Create new_iff
 139   IdealLoopTree* lp = get_loop(entry);
 140   IfNode* new_iff = NULL;
 141   if (opcode == Op_If) {
 142     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 143   } else {
 144     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 145     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 146   }
 147   register_control(new_iff, lp, entry);
 148   Node *if_cont = new IfTrueNode(new_iff);
 149   Node *if_uct  = new IfFalseNode(new_iff);
 150   if (cont_proj-&gt;is_IfFalse()) {
 151     // Swap
 152     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 153   }
 154   register_control(if_cont, lp, new_iff);
 155   register_control(if_uct, get_loop(rgn), new_iff);
 156 
 157   // if_uct to rgn
 158   _igvn.hash_delete(rgn);
 159   rgn-&gt;add_req(if_uct);
 160   // When called from beautify_loops() idom is not constructed yet.
 161   if (_idom != NULL) {
 162     Node* ridom = idom(rgn);
 163     Node* nrdom = dom_lca_internal(ridom, new_iff);
 164     set_idom(rgn, nrdom, dom_depth(rgn));
 165   }
 166 
 167   // If rgn has phis add new edges which has the same
 168   // value as on original uncommon_proj pass.
 169   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 170   bool has_phi = false;
 171   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 172     Node* use = rgn-&gt;fast_out(i);
 173     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 174       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 175       _igvn.rehash_node_delayed(use);
 176       use-&gt;add_req(use-&gt;in(proj_index));
 177       has_phi = true;
 178     }
 179   }
 180   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 181 
 182   if (new_entry == NULL) {
 183     // Attach if_cont to iff
 184     _igvn.replace_input_of(iff, 0, if_cont);
 185     if (_idom != NULL) {
 186       set_idom(iff, if_cont, dom_depth(iff));
 187     }
 188   }
 189   return if_cont-&gt;as_Proj();
 190 }
 191 
 192 //------------------------------create_new_if_for_predicate------------------------
 193 // Create a new if below new_entry for the predicate to be cloned (IGVN optimization)
 194 ProjNode* PhaseIterGVN::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
 195                                                     Deoptimization::DeoptReason reason,
 196                                                     int opcode) {
 197   assert(new_entry != 0, &quot;only used for clone predicate&quot;);
 198   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 199   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 200 
 201   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 202   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 203   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 204 
 205   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 206   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 207     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 208     CallNode* call = rgn-&gt;as_Call();
 209     rgn = new RegionNode(1);
 210     register_new_node_with_optimizer(rgn);
 211     rgn-&gt;add_req(uncommon_proj);
 212     replace_input_of(call, 0, rgn);
 213   } else {
 214     // Find region&#39;s edge corresponding to uncommon_proj
 215     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 216       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 217     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 218   }
 219 
 220   // Create new_iff in new location.
 221   IfNode* new_iff = NULL;
 222   if (opcode == Op_If) {
 223     new_iff = new IfNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 224   } else {
 225     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 226     new_iff = new RangeCheckNode(new_entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 227   }
 228 
 229   register_new_node_with_optimizer(new_iff);
 230   Node *if_cont = new IfTrueNode(new_iff);
 231   Node *if_uct  = new IfFalseNode(new_iff);
 232   if (cont_proj-&gt;is_IfFalse()) {
 233     // Swap
 234     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 235   }
 236   register_new_node_with_optimizer(if_cont);
 237   register_new_node_with_optimizer(if_uct);
 238 
 239   // if_uct to rgn
 240   hash_delete(rgn);
 241   rgn-&gt;add_req(if_uct);
 242 
 243   // If rgn has phis add corresponding new edges which has the same
 244   // value as on original uncommon_proj pass.
 245   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 246   bool has_phi = false;
 247   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 248     Node* use = rgn-&gt;fast_out(i);
 249     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 250       rehash_node_delayed(use);
 251       use-&gt;add_req(use-&gt;in(proj_index));
 252       has_phi = true;
 253     }
 254   }
 255   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 256 
 257   return if_cont-&gt;as_Proj();
 258 }
 259 
 260 //--------------------------clone_predicate-----------------------
 261 ProjNode* PhaseIdealLoop::clone_predicate(ProjNode* predicate_proj, Node* new_entry,
 262                                           Deoptimization::DeoptReason reason,
 263                                           PhaseIdealLoop* loop_phase,
 264                                           PhaseIterGVN* igvn) {
 265   ProjNode* new_predicate_proj;
 266   if (loop_phase != NULL) {
 267     new_predicate_proj = loop_phase-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 268   } else {
 269     new_predicate_proj =       igvn-&gt;create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 270   }
 271   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 272   Node* ctrl  = iff-&gt;in(0);
 273 
 274   // Match original condition since predicate&#39;s projections could be swapped.
 275   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
 276   Node* opq = new Opaque1Node(igvn-&gt;C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));
 277   igvn-&gt;C-&gt;add_predicate_opaq(opq);
 278 
 279   Node* bol = new Conv2BNode(opq);
 280   if (loop_phase != NULL) {
 281     loop_phase-&gt;register_new_node(opq, ctrl);
 282     loop_phase-&gt;register_new_node(bol, ctrl);
 283   } else {
 284     igvn-&gt;register_new_node_with_optimizer(opq);
 285     igvn-&gt;register_new_node_with_optimizer(bol);
 286   }
 287   igvn-&gt;hash_delete(iff);
 288   iff-&gt;set_req(1, bol);
 289   return new_predicate_proj;
 290 }
 291 
 292 
 293 //--------------------------clone_loop_predicates-----------------------
 294 // Interface from IGVN
 295 Node* PhaseIterGVN::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 296   return PhaseIdealLoop::clone_loop_predicates(old_entry, new_entry, clone_limit_check, NULL, this);
 297 }
 298 
 299 // Interface from PhaseIdealLoop
 300 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 301   return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);
 302 }
 303 
<a name="1" id="anc1"></a><span class="line-removed"> 304 void PhaseIdealLoop::clone_loop_predicates_fix_mem(ProjNode* dom_proj , ProjNode* proj,</span>
<span class="line-removed"> 305                                                    PhaseIdealLoop* loop_phase,</span>
<span class="line-removed"> 306                                                    PhaseIterGVN* igvn) {</span>
<span class="line-removed"> 307   Compile* C = NULL;</span>
<span class="line-removed"> 308   if (loop_phase != NULL) {</span>
<span class="line-removed"> 309     igvn = &amp;loop_phase-&gt;igvn();</span>
<span class="line-removed"> 310   }</span>
<span class="line-removed"> 311   C = igvn-&gt;C;</span>
<span class="line-removed"> 312   ProjNode* other_dom_proj = dom_proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-dom_proj-&gt;_con);</span>
<span class="line-removed"> 313   Node* dom_r = other_dom_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 314   if (dom_r-&gt;is_Region()) {</span>
<span class="line-removed"> 315     assert(dom_r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;unc expected&quot;);</span>
<span class="line-removed"> 316     ProjNode* other_proj = proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-proj-&gt;_con);</span>
<span class="line-removed"> 317     Node* r = other_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 318     assert(r-&gt;is_Region() &amp;&amp; r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;cloned predicate should have caused region to be added&quot;);</span>
<span class="line-removed"> 319     for (DUIterator_Fast imax, i = dom_r-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 320       Node* dom_use = dom_r-&gt;fast_out(i);</span>
<span class="line-removed"> 321       if (dom_use-&gt;is_Phi() &amp;&amp; dom_use-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed"> 322         assert(dom_use-&gt;in(0) == dom_r, &quot;&quot;);</span>
<span class="line-removed"> 323         Node* phi = NULL;</span>
<span class="line-removed"> 324         for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed"> 325           Node* use = r-&gt;fast_out(j);</span>
<span class="line-removed"> 326           if (use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed"> 327               use-&gt;adr_type() == dom_use-&gt;adr_type()) {</span>
<span class="line-removed"> 328             assert(use-&gt;in(0) == r, &quot;&quot;);</span>
<span class="line-removed"> 329             assert(phi == NULL, &quot;only one phi&quot;);</span>
<span class="line-removed"> 330             phi = use;</span>
<span class="line-removed"> 331           }</span>
<span class="line-removed"> 332         }</span>
<span class="line-removed"> 333         if (phi == NULL) {</span>
<span class="line-removed"> 334           const TypePtr* adr_type = dom_use-&gt;adr_type();</span>
<span class="line-removed"> 335           int alias = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 336           Node* call = r-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 337           Node* mem = call-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 338           MergeMemNode* mm = NULL;</span>
<span class="line-removed"> 339           if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 340             mm = mem-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-removed"> 341             if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed"> 342               mem = mem-&gt;as_MergeMem()-&gt;base_memory();</span>
<span class="line-removed"> 343             } else {</span>
<span class="line-removed"> 344               mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="line-removed"> 345             }</span>
<span class="line-removed"> 346           } else {</span>
<span class="line-removed"> 347             mm = MergeMemNode::make(mem);</span>
<span class="line-removed"> 348           }</span>
<span class="line-removed"> 349           phi = PhiNode::make(r, mem, Type::MEMORY, adr_type);</span>
<span class="line-removed"> 350           if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed"> 351             mm-&gt;set_base_memory(phi);</span>
<span class="line-removed"> 352           } else {</span>
<span class="line-removed"> 353             mm-&gt;set_memory_at(alias, phi);</span>
<span class="line-removed"> 354           }</span>
<span class="line-removed"> 355           if (loop_phase != NULL) {</span>
<span class="line-removed"> 356             loop_phase-&gt;register_new_node(mm, r);</span>
<span class="line-removed"> 357             loop_phase-&gt;register_new_node(phi, r);</span>
<span class="line-removed"> 358           } else {</span>
<span class="line-removed"> 359             igvn-&gt;register_new_node_with_optimizer(mm);</span>
<span class="line-removed"> 360             igvn-&gt;register_new_node_with_optimizer(phi);</span>
<span class="line-removed"> 361           }</span>
<span class="line-removed"> 362           igvn-&gt;replace_input_of(call, TypeFunc::Memory, mm);</span>
<span class="line-removed"> 363         }</span>
<span class="line-removed"> 364         igvn-&gt;replace_input_of(phi, r-&gt;find_edge(other_proj), dom_use-&gt;in(dom_r-&gt;find_edge(other_dom_proj)));</span>
<span class="line-removed"> 365       }</span>
<span class="line-removed"> 366     }</span>
<span class="line-removed"> 367   }</span>
<span class="line-removed"> 368 }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370 </span>
 371 // Clone loop predicates to cloned loops (peeled, unswitched, split_if).
 372 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,
 373                                             bool clone_limit_check,
 374                                             PhaseIdealLoop* loop_phase,
 375                                             PhaseIterGVN* igvn) {
 376 #ifdef ASSERT
 377   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 378     if (new_entry != NULL)
 379       new_entry-&gt;dump();
 380     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 381   }
 382 #endif
 383   // Search original predicates
 384   Node* entry = old_entry;
 385   ProjNode* limit_check_proj = NULL;
 386   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 387   if (limit_check_proj != NULL) {
 388     entry = skip_loop_predicates(entry);
 389   }
 390   ProjNode* profile_predicate_proj = NULL;
 391   ProjNode* predicate_proj = NULL;
 392   if (UseProfiledLoopPredicate) {
 393     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 394     if (profile_predicate_proj != NULL) {
 395       entry = skip_loop_predicates(entry);
 396     }
 397   }
 398   if (UseLoopPredicate) {
 399     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 400   }
 401   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 402     // clone predicate
<a name="2" id="anc2"></a><span class="line-modified"> 403     ProjNode* proj = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified"> 404                                      Deoptimization::Reason_predicate,</span>
<span class="line-modified"> 405                                      loop_phase, igvn);</span>
<span class="line-modified"> 406     assert(proj != NULL, &quot;IfTrue or IfFalse after clone predicate&quot;);</span>
<span class="line-removed"> 407     new_entry = proj;</span>
 408     if (TraceLoopPredicate) {
 409       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 410       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 411     }
<a name="3" id="anc3"></a><span class="line-removed"> 412     if (profile_predicate_proj != NULL) {</span>
<span class="line-removed"> 413       // A node that produces memory may be out of loop and depend on</span>
<span class="line-removed"> 414       // a profiled predicates. In that case the memory state at the</span>
<span class="line-removed"> 415       // end of profiled predicates and at the end of predicates are</span>
<span class="line-removed"> 416       // not the same. The cloned predicates are dominated by the</span>
<span class="line-removed"> 417       // profiled predicates but may have the wrong memory</span>
<span class="line-removed"> 418       // state. Update it.</span>
<span class="line-removed"> 419       clone_loop_predicates_fix_mem(profile_predicate_proj, proj, loop_phase, igvn);</span>
<span class="line-removed"> 420     }</span>
 421   }
 422   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 423     // clone predicate
 424     new_entry = clone_predicate(profile_predicate_proj, new_entry,
 425                                 Deoptimization::Reason_profile_predicate,
 426                                 loop_phase, igvn);
 427     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 428     if (TraceLoopPredicate) {
 429       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 430       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 431     }
 432   }
 433   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 434     // Clone loop limit check last to insert it before loop.
 435     // Don&#39;t clone a limit check which was already finalized
 436     // for this counted loop (only one limit check is needed).
 437     new_entry = clone_predicate(limit_check_proj, new_entry,
 438                                 Deoptimization::Reason_loop_limit_check,
 439                                 loop_phase, igvn);
 440     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 441     if (TraceLoopLimitCheck) {
 442       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 443       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 444     }
 445   }
 446   return new_entry;
 447 }
 448 
 449 //--------------------------skip_loop_predicates------------------------------
 450 // Skip related predicates.
 451 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 452   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 453   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 454   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 455   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 456   entry = entry-&gt;in(0)-&gt;in(0);
 457   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 458     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 459     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 460       break;
 461     entry = entry-&gt;in(0)-&gt;in(0);
 462   }
 463   return entry;
 464 }
 465 
 466 Node* PhaseIdealLoop::skip_all_loop_predicates(Node* entry) {
 467   Node* predicate = NULL;
 468   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 469   if (predicate != NULL) {
 470     entry = skip_loop_predicates(entry);
 471   }
 472   if (UseProfiledLoopPredicate) {
 473     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 474     if (predicate != NULL) { // right pattern that can be used by loop predication
 475       entry = skip_loop_predicates(entry);
 476     }
 477   }
 478   if (UseLoopPredicate) {
 479     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 480     if (predicate != NULL) { // right pattern that can be used by loop predication
 481       entry = skip_loop_predicates(entry);
 482     }
 483   }
 484   return entry;
 485 }
 486 
 487 //--------------------------find_predicate_insertion_point-------------------
 488 // Find a good location to insert a predicate
 489 ProjNode* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {
 490   if (start_c == NULL || !start_c-&gt;is_Proj())
 491     return NULL;
 492   if (start_c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(reason)) {
 493     return start_c-&gt;as_Proj();
 494   }
 495   return NULL;
 496 }
 497 
 498 //--------------------------find_predicate------------------------------------
 499 // Find a predicate
 500 Node* PhaseIdealLoop::find_predicate(Node* entry) {
 501   Node* predicate = NULL;
 502   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 503   if (predicate != NULL) { // right pattern that can be used by loop predication
 504     return entry;
 505   }
 506   if (UseLoopPredicate) {
 507     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 508     if (predicate != NULL) { // right pattern that can be used by loop predication
 509       return entry;
 510     }
 511   }
 512   if (UseProfiledLoopPredicate) {
 513     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 514     if (predicate != NULL) { // right pattern that can be used by loop predication
 515       return entry;
 516     }
 517   }
 518   return NULL;
 519 }
 520 
 521 //------------------------------Invariance-----------------------------------
 522 // Helper class for loop_predication_impl to compute invariance on the fly and
 523 // clone invariants.
 524 class Invariance : public StackObj {
 525   VectorSet _visited, _invariant;
 526   Node_Stack _stack;
 527   VectorSet _clone_visited;
 528   Node_List _old_new; // map of old to new (clone)
 529   IdealLoopTree* _lpt;
 530   PhaseIdealLoop* _phase;
 531 
 532   // Helper function to set up the invariance for invariance computation
 533   // If n is a known invariant, set up directly. Otherwise, look up the
 534   // the possibility to push n onto the stack for further processing.
 535   void visit(Node* use, Node* n) {
 536     if (_lpt-&gt;is_invariant(n)) { // known invariant
 537       _invariant.set(n-&gt;_idx);
 538     } else if (!n-&gt;is_CFG()) {
<a name="4" id="anc4"></a><span class="line-removed"> 539       if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 540         return;</span>
<span class="line-removed"> 541       }</span>
 542       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 543       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 544       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 545         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 546       }
 547     }
 548   }
 549 
 550   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 551   // on the fly
 552   void compute_invariance(Node* n) {
 553     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 554     visit(n, n);
 555     while (_stack.is_nonempty()) {
 556       Node*  n = _stack.node();
 557       uint idx = _stack.index();
 558       if (idx == n-&gt;req()) { // all inputs are processed
 559         _stack.pop();
 560         // n is invariant if it&#39;s inputs are all invariant
 561         bool all_inputs_invariant = true;
 562         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 563           Node* in = n-&gt;in(i);
 564           if (in == NULL) continue;
 565           assert(_visited.test(in-&gt;_idx), &quot;must have visited input&quot;);
 566           if (!_invariant.test(in-&gt;_idx)) { // bad guy
 567             all_inputs_invariant = false;
 568             break;
 569           }
 570         }
 571         if (all_inputs_invariant) {
 572           // If n&#39;s control is a predicate that was moved out of the
 573           // loop, it was marked invariant but n is only invariant if
 574           // it depends only on that test. Otherwise, unless that test
 575           // is out of the loop, it&#39;s not invariant.
 576           if (n-&gt;is_CFG() || n-&gt;depends_only_on_test() || n-&gt;in(0) == NULL || !_phase-&gt;is_member(_lpt, n-&gt;in(0))) {
 577             _invariant.set(n-&gt;_idx); // I am a invariant too
 578           }
 579         }
 580       } else { // process next input
 581         _stack.set_index(idx + 1);
 582         Node* m = n-&gt;in(idx);
 583         if (m != NULL &amp;&amp; !_visited.test_set(m-&gt;_idx)) {
 584           visit(n, m);
 585         }
 586       }
 587     }
 588   }
 589 
 590   // Helper function to set up _old_new map for clone_nodes.
 591   // If n is a known invariant, set up directly (&quot;clone&quot; of n == n).
 592   // Otherwise, push n onto the stack for real cloning.
 593   void clone_visit(Node* n) {
 594     assert(_invariant.test(n-&gt;_idx), &quot;must be invariant&quot;);
 595     if (_lpt-&gt;is_invariant(n)) { // known invariant
 596       _old_new.map(n-&gt;_idx, n);
 597     } else { // to be cloned
 598       assert(!n-&gt;is_CFG(), &quot;should not see CFG here&quot;);
 599       _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 600     }
 601   }
 602 
 603   // Clone &quot;n&quot; and (possibly) all its inputs recursively
 604   void clone_nodes(Node* n, Node* ctrl) {
 605     clone_visit(n);
 606     while (_stack.is_nonempty()) {
 607       Node*  n = _stack.node();
 608       uint idx = _stack.index();
 609       if (idx == n-&gt;req()) { // all inputs processed, clone n!
 610         _stack.pop();
 611         // clone invariant node
 612         Node* n_cl = n-&gt;clone();
 613         _old_new.map(n-&gt;_idx, n_cl);
 614         _phase-&gt;register_new_node(n_cl, ctrl);
 615         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 616           Node* in = n_cl-&gt;in(i);
 617           if (in == NULL) continue;
 618           n_cl-&gt;set_req(i, _old_new[in-&gt;_idx]);
 619         }
 620       } else { // process next input
 621         _stack.set_index(idx + 1);
 622         Node* m = n-&gt;in(idx);
 623         if (m != NULL &amp;&amp; !_clone_visited.test_set(m-&gt;_idx)) {
 624           clone_visit(m); // visit the input
 625         }
 626       }
 627     }
 628   }
 629 
 630  public:
 631   Invariance(Arena* area, IdealLoopTree* lpt) :
 632     _visited(area), _invariant(area),
 633     _stack(area, 10 /* guess */),
 634     _clone_visited(area), _old_new(area),
 635     _lpt(lpt), _phase(lpt-&gt;_phase)
 636   {
 637     LoopNode* head = _lpt-&gt;_head-&gt;as_Loop();
 638     Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
 639     if (entry-&gt;outcnt() != 1) {
 640       // If a node is pinned between the predicates and the loop
 641       // entry, we won&#39;t be able to move any node in the loop that
 642       // depends on it above it in a predicate. Mark all those nodes
 643       // as non loop invariatnt.
 644       Unique_Node_List wq;
 645       wq.push(entry);
 646       for (uint next = 0; next &lt; wq.size(); ++next) {
 647         Node *n = wq.at(next);
 648         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 649           Node* u = n-&gt;fast_out(i);
 650           if (!u-&gt;is_CFG()) {
 651             Node* c = _phase-&gt;get_ctrl(u);
 652             if (_lpt-&gt;is_member(_phase-&gt;get_loop(c)) || _phase-&gt;is_dominator(c, head)) {
 653               _visited.set(u-&gt;_idx);
 654               wq.push(u);
 655             }
 656           }
 657         }
 658       }
 659     }
 660   }
 661 
 662   // Map old to n for invariance computation and clone
 663   void map_ctrl(Node* old, Node* n) {
 664     assert(old-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must be&quot;);
 665     _old_new.map(old-&gt;_idx, n); // &quot;clone&quot; of old is n
 666     _invariant.set(old-&gt;_idx);  // old is invariant
 667     _clone_visited.set(old-&gt;_idx);
 668   }
 669 
 670   // Driver function to compute invariance
 671   bool is_invariant(Node* n) {
 672     if (!_visited.test_set(n-&gt;_idx))
 673       compute_invariance(n);
 674     return (_invariant.test(n-&gt;_idx) != 0);
 675   }
 676 
 677   // Driver function to clone invariant
 678   Node* clone(Node* n, Node* ctrl) {
 679     assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);
 680     assert(_invariant.test(n-&gt;_idx), &quot;must be an invariant&quot;);
 681     if (!_clone_visited.test(n-&gt;_idx))
 682       clone_nodes(n, ctrl);
 683     return _old_new[n-&gt;_idx];
 684   }
 685 };
 686 
 687 //------------------------------is_range_check_if -----------------------------------
 688 // Returns true if the predicate of iff is in &quot;scale*iv + offset u&lt; load_range(ptr)&quot; format
 689 // Note: this function is particularly designed for loop predication. We require load_range
 690 //       and offset to be loop invariant computed on the fly by &quot;invar&quot;
 691 bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const {
 692   if (!is_loop_exit(iff)) {
 693     return false;
 694   }
 695   if (!iff-&gt;in(1)-&gt;is_Bool()) {
 696     return false;
 697   }
 698   const BoolNode *bol = iff-&gt;in(1)-&gt;as_Bool();
 699   if (bol-&gt;_test._test != BoolTest::lt) {
 700     return false;
 701   }
 702   if (!bol-&gt;in(1)-&gt;is_Cmp()) {
 703     return false;
 704   }
 705   const CmpNode *cmp = bol-&gt;in(1)-&gt;as_Cmp();
 706   if (cmp-&gt;Opcode() != Op_CmpU) {
 707     return false;
 708   }
 709   Node* range = cmp-&gt;in(2);
 710   if (range-&gt;Opcode() != Op_LoadRange &amp;&amp; !iff-&gt;is_RangeCheck()) {
 711     const TypeInt* tint = phase-&gt;_igvn.type(range)-&gt;isa_int();
 712     if (tint == NULL || tint-&gt;empty() || tint-&gt;_lo &lt; 0) {
 713       // Allow predication on positive values that aren&#39;t LoadRanges.
 714       // This allows optimization of loops where the length of the
 715       // array is a known value and doesn&#39;t need to be loaded back
 716       // from the array.
 717       return false;
 718     }
 719   }
 720   if (!invar.is_invariant(range)) {
 721     return false;
 722   }
 723   Node *iv     = _head-&gt;as_CountedLoop()-&gt;phi();
 724   int   scale  = 0;
 725   Node *offset = NULL;
 726   if (!phase-&gt;is_scaled_iv_plus_offset(cmp-&gt;in(1), iv, &amp;scale, &amp;offset)) {
 727     return false;
 728   }
 729   if (offset &amp;&amp; !invar.is_invariant(offset)) { // offset must be invariant
 730     return false;
 731   }
 732   return true;
 733 }
 734 
 735 //------------------------------rc_predicate-----------------------------------
 736 // Create a range check predicate
 737 //
 738 // for (i = init; i &lt; limit; i += stride) {
 739 //    a[scale*i+offset]
 740 // }
 741 //
 742 // Compute max(scale*i + offset) for init &lt;= i &lt; limit and build the predicate
 743 // as &quot;max(scale*i + offset) u&lt; a.length&quot;.
 744 //
 745 // There are two cases for max(scale*i + offset):
 746 // (1) stride*scale &gt; 0
 747 //   max(scale*i + offset) = scale*(limit-stride) + offset
 748 // (2) stride*scale &lt; 0
 749 //   max(scale*i + offset) = scale*init + offset
 750 BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,
 751                                        int scale, Node* offset,
 752                                        Node* init, Node* limit, jint stride,
 753                                        Node* range, bool upper, bool &amp;overflow) {
 754   jint con_limit  = (limit != NULL &amp;&amp; limit-&gt;is_Con())  ? limit-&gt;get_int()  : 0;
 755   jint con_init   = init-&gt;is_Con()   ? init-&gt;get_int()   : 0;
 756   jint con_offset = offset-&gt;is_Con() ? offset-&gt;get_int() : 0;
 757 
 758   stringStream* predString = NULL;
 759   if (TraceLoopPredicate) {
 760     predString = new stringStream();
 761     predString-&gt;print(&quot;rc_predicate &quot;);
 762   }
 763 
 764   overflow = false;
 765   Node* max_idx_expr = NULL;
 766   const TypeInt* idx_type = TypeInt::INT;
 767   if ((stride &gt; 0) == (scale &gt; 0) == upper) {
 768     guarantee(limit != NULL, &quot;sanity&quot;);
 769     if (TraceLoopPredicate) {
 770       if (limit-&gt;is_Con()) {
 771         predString-&gt;print(&quot;(%d &quot;, con_limit);
 772       } else {
 773         predString-&gt;print(&quot;(limit &quot;);
 774       }
 775       predString-&gt;print(&quot;- %d) &quot;, stride);
 776     }
 777     // Check if (limit - stride) may overflow
 778     const TypeInt* limit_type = _igvn.type(limit)-&gt;isa_int();
 779     jint limit_lo = limit_type-&gt;_lo;
 780     jint limit_hi = limit_type-&gt;_hi;
 781     if ((stride &gt; 0 &amp;&amp; (java_subtract(limit_lo, stride) &lt; limit_lo)) ||
 782         (stride &lt; 0 &amp;&amp; (java_subtract(limit_hi, stride) &gt; limit_hi))) {
 783       // No overflow possible
 784       ConINode* con_stride = _igvn.intcon(stride);
 785       set_ctrl(con_stride, C-&gt;root());
 786       max_idx_expr = new SubINode(limit, con_stride);
 787       idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type-&gt;_widen);
 788     } else {
 789       // May overflow
 790       overflow = true;
 791       limit = new ConvI2LNode(limit);
 792       register_new_node(limit, ctrl);
 793       ConLNode* con_stride = _igvn.longcon(stride);
 794       set_ctrl(con_stride, C-&gt;root());
 795       max_idx_expr = new SubLNode(limit, con_stride);
 796     }
 797     register_new_node(max_idx_expr, ctrl);
 798   } else {
 799     if (TraceLoopPredicate) {
 800       if (init-&gt;is_Con()) {
 801         predString-&gt;print(&quot;%d &quot;, con_init);
 802       } else {
 803         predString-&gt;print(&quot;init &quot;);
 804       }
 805     }
 806     idx_type = _igvn.type(init)-&gt;isa_int();
 807     max_idx_expr = init;
 808   }
 809 
 810   if (scale != 1) {
 811     ConNode* con_scale = _igvn.intcon(scale);
 812     set_ctrl(con_scale, C-&gt;root());
 813     if (TraceLoopPredicate) {
 814       predString-&gt;print(&quot;* %d &quot;, scale);
 815     }
 816     // Check if (scale * max_idx_expr) may overflow
 817     const TypeInt* scale_type = TypeInt::make(scale);
 818     MulINode* mul = new MulINode(max_idx_expr, con_scale);
 819     idx_type = (TypeInt*)mul-&gt;mul_ring(idx_type, scale_type);
 820     if (overflow || TypeInt::INT-&gt;higher_equal(idx_type)) {
 821       // May overflow
 822       mul-&gt;destruct();
 823       if (!overflow) {
 824         max_idx_expr = new ConvI2LNode(max_idx_expr);
 825         register_new_node(max_idx_expr, ctrl);
 826       }
 827       overflow = true;
 828       con_scale = _igvn.longcon(scale);
 829       set_ctrl(con_scale, C-&gt;root());
 830       max_idx_expr = new MulLNode(max_idx_expr, con_scale);
 831     } else {
 832       // No overflow possible
 833       max_idx_expr = mul;
 834     }
 835     register_new_node(max_idx_expr, ctrl);
 836   }
 837 
 838   if (offset &amp;&amp; (!offset-&gt;is_Con() || con_offset != 0)){
 839     if (TraceLoopPredicate) {
 840       if (offset-&gt;is_Con()) {
 841         predString-&gt;print(&quot;+ %d &quot;, con_offset);
 842       } else {
 843         predString-&gt;print(&quot;+ offset&quot;);
 844       }
 845     }
 846     // Check if (max_idx_expr + offset) may overflow
 847     const TypeInt* offset_type = _igvn.type(offset)-&gt;isa_int();
 848     jint lo = java_add(idx_type-&gt;_lo, offset_type-&gt;_lo);
 849     jint hi = java_add(idx_type-&gt;_hi, offset_type-&gt;_hi);
 850     if (overflow || (lo &gt; hi) ||
 851         ((idx_type-&gt;_lo &amp; offset_type-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0) ||
 852         ((~(idx_type-&gt;_hi | offset_type-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0)) {
 853       // May overflow
 854       if (!overflow) {
 855         max_idx_expr = new ConvI2LNode(max_idx_expr);
 856         register_new_node(max_idx_expr, ctrl);
 857       }
 858       overflow = true;
 859       offset = new ConvI2LNode(offset);
 860       register_new_node(offset, ctrl);
 861       max_idx_expr = new AddLNode(max_idx_expr, offset);
 862     } else {
 863       // No overflow possible
 864       max_idx_expr = new AddINode(max_idx_expr, offset);
 865     }
 866     register_new_node(max_idx_expr, ctrl);
 867   }
 868 
 869   CmpNode* cmp = NULL;
 870   if (overflow) {
 871     // Integer expressions may overflow, do long comparison
 872     range = new ConvI2LNode(range);
 873     register_new_node(range, ctrl);
 874     cmp = new CmpULNode(max_idx_expr, range);
 875   } else {
 876     cmp = new CmpUNode(max_idx_expr, range);
 877   }
 878   register_new_node(cmp, ctrl);
 879   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 880   register_new_node(bol, ctrl);
 881 
 882   if (TraceLoopPredicate) {
 883     predString-&gt;print_cr(&quot;&lt;u range&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 884     tty-&gt;print(&quot;%s&quot;, predString-&gt;as_string());</span>

 885   }
 886   return bol;
 887 }
 888 
 889 // Should loop predication look not only in the path from tail to head
 890 // but also in branches of the loop body?
 891 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 892   if (!UseProfiledLoopPredicate) {
 893     return false;
 894   }
 895 
 896   if (predicate_proj == NULL) {
 897     return false;
 898   }
 899 
 900   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 901   bool follow_branches = true;
 902   IdealLoopTree* l = loop-&gt;_child;
 903   // For leaf loops and loops with a single inner loop
 904   while (l != NULL &amp;&amp; follow_branches) {
 905     IdealLoopTree* child = l;
 906     if (child-&gt;_child != NULL &amp;&amp;
 907         child-&gt;_head-&gt;is_OuterStripMinedLoop()) {
 908       assert(child-&gt;_child-&gt;_next == NULL, &quot;only one inner loop for strip mined loop&quot;);
 909       assert(child-&gt;_child-&gt;_head-&gt;is_CountedLoop() &amp;&amp; child-&gt;_child-&gt;_head-&gt;as_CountedLoop()-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
 910       child = child-&gt;_child;
 911     }
 912     if (child-&gt;_child != NULL || child-&gt;_irreducible) {
 913       follow_branches = false;
 914     }
 915     l = l-&gt;_next;
 916   }
 917   if (follow_branches) {
 918     loop-&gt;compute_profile_trip_cnt(this);
 919     if (head-&gt;is_profile_trip_failed()) {
 920       follow_branches = false;
 921     } else {
 922       loop_trip_cnt = head-&gt;profile_trip_cnt();
 923       if (head-&gt;is_CountedLoop()) {
 924         CountedLoopNode* cl = head-&gt;as_CountedLoop();
 925         if (cl-&gt;phi() != NULL) {
 926           const TypeInt* t = _igvn.type(cl-&gt;phi())-&gt;is_int();
 927           float worst_case_trip_cnt = ((float)t-&gt;_hi - t-&gt;_lo) / ABS(cl-&gt;stride_con());
 928           if (worst_case_trip_cnt &lt; loop_trip_cnt) {
 929             loop_trip_cnt = worst_case_trip_cnt;
 930           }
 931         }
 932       }
 933     }
 934   }
 935   return follow_branches;
 936 }
 937 
 938 // Compute probability of reaching some CFG node from a fixed
 939 // dominating CFG node
 940 class PathFrequency {
 941 private:
 942   Node* _dom; // frequencies are computed relative to this node
 943   Node_Stack _stack;
 944   GrowableArray&lt;float&gt; _freqs_stack; // keep track of intermediate result at regions
 945   GrowableArray&lt;float&gt; _freqs; // cache frequencies
 946   PhaseIdealLoop* _phase;
 947 
 948   void set_rounding(int mode) {
 949     // fesetround is broken on windows
 950     NOT_WINDOWS(fesetround(mode);)
 951   }
 952 
 953   void check_frequency(float f) {
 954     NOT_WINDOWS(assert(f &lt;= 1 &amp;&amp; f &gt;= 0, &quot;Incorrect frequency&quot;);)
 955   }
 956 
 957 public:
 958   PathFrequency(Node* dom, PhaseIdealLoop* phase)
 959     : _dom(dom), _stack(0), _phase(phase) {
 960   }
 961 
 962   float to(Node* n) {
 963     // post order walk on the CFG graph from n to _dom
 964     set_rounding(FE_TOWARDZERO); // make sure rounding doesn&#39;t push frequency above 1
 965     IdealLoopTree* loop = _phase-&gt;get_loop(_dom);
 966     Node* c = n;
 967     for (;;) {
 968       assert(_phase-&gt;get_loop(c) == loop, &quot;have to be in the same loop&quot;);
 969       if (c == _dom || _freqs.at_grow(c-&gt;_idx, -1) &gt;= 0) {
 970         float f = c == _dom ? 1 : _freqs.at(c-&gt;_idx);
 971         Node* prev = c;
 972         while (_stack.size() &gt; 0 &amp;&amp; prev == c) {
 973           Node* n = _stack.node();
 974           if (!n-&gt;is_Region()) {
 975             if (_phase-&gt;get_loop(n) != _phase-&gt;get_loop(n-&gt;in(0))) {
 976               // Found an inner loop: compute frequency of reaching this
 977               // exit from the loop head by looking at the number of
 978               // times each loop exit was taken
 979               IdealLoopTree* inner_loop = _phase-&gt;get_loop(n-&gt;in(0));
 980               LoopNode* inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 981               assert(_phase-&gt;get_loop(n) == loop, &quot;only 1 inner loop&quot;);
 982               if (inner_head-&gt;is_OuterStripMinedLoop()) {
 983                 inner_head-&gt;verify_strip_mined(1);
 984                 if (n-&gt;in(0) == inner_head-&gt;in(LoopNode::LoopBackControl)-&gt;in(0)) {
 985                   n = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
 986                 }
 987                 inner_loop = inner_loop-&gt;_child;
 988                 inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 989                 inner_head-&gt;verify_strip_mined(1);
 990               }
 991               set_rounding(FE_UPWARD);  // make sure rounding doesn&#39;t push frequency above 1
 992               float loop_exit_cnt = 0.0f;
 993               for (uint i = 0; i &lt; inner_loop-&gt;_body.size(); i++) {
 994                 Node *n = inner_loop-&gt;_body[i];
 995                 float c = inner_loop-&gt;compute_profile_trip_cnt_helper(n);
 996                 loop_exit_cnt += c;
 997               }
 998               set_rounding(FE_TOWARDZERO);
 999               float cnt = -1;
1000               if (n-&gt;in(0)-&gt;is_If()) {
1001                 IfNode* iff = n-&gt;in(0)-&gt;as_If();
1002                 float p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
1003                 if (n-&gt;Opcode() == Op_IfFalse) {
1004                   p = 1 - p;
1005                 }
1006                 if (p &gt; PROB_MIN) {
1007                   cnt = p * iff-&gt;_fcnt;
1008                 } else {
1009                   cnt = 0;
1010                 }
1011               } else {
1012                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
1013                 JumpNode* jmp = n-&gt;in(0)-&gt;as_Jump();
1014                 float p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
1015                 cnt = p * jmp-&gt;_fcnt;
1016               }
1017               float this_exit_f = cnt &gt; 0 ? cnt / loop_exit_cnt : 0;
1018               check_frequency(this_exit_f);
1019               f = f * this_exit_f;
1020               check_frequency(f);
1021             } else {
1022               float p = -1;
1023               if (n-&gt;in(0)-&gt;is_If()) {
1024                 p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
1025                 if (n-&gt;Opcode() == Op_IfFalse) {
1026                   p = 1 - p;
1027                 }
1028               } else {
1029                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
1030                 p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
1031               }
1032               f = f * p;
1033               check_frequency(f);
1034             }
1035             _freqs.at_put_grow(n-&gt;_idx, (float)f, -1);
1036             _stack.pop();
1037           } else {
1038             float prev_f = _freqs_stack.pop();
1039             float new_f = f;
1040             f = new_f + prev_f;
1041             check_frequency(f);
1042             uint i = _stack.index();
1043             if (i &lt; n-&gt;req()) {
1044               c = n-&gt;in(i);
1045               _stack.set_index(i+1);
1046               _freqs_stack.push(f);
1047             } else {
1048               _freqs.at_put_grow(n-&gt;_idx, f, -1);
1049               _stack.pop();
1050             }
1051           }
1052         }
1053         if (_stack.size() == 0) {
1054           set_rounding(FE_TONEAREST);
1055           check_frequency(f);
1056           return f;
1057         }
1058       } else if (c-&gt;is_Loop()) {
1059         ShouldNotReachHere();
1060         c = c-&gt;in(LoopNode::EntryControl);
1061       } else if (c-&gt;is_Region()) {
1062         _freqs_stack.push(0);
1063         _stack.push(c, 2);
1064         c = c-&gt;in(1);
1065       } else {
1066         if (c-&gt;is_IfProj()) {
1067           IfNode* iff = c-&gt;in(0)-&gt;as_If();
1068           if (iff-&gt;_prob == PROB_UNKNOWN) {
1069             // assume never taken
1070             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1071           } else if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(iff)) {
1072             if (iff-&gt;_fcnt == COUNT_UNKNOWN) {
1073               // assume never taken
1074               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1075             } else {
1076               // skip over loop
1077               _stack.push(c, 1);
1078               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1079             }
1080           } else {
1081             _stack.push(c, 1);
1082             c = iff;
1083           }
1084         } else if (c-&gt;is_JumpProj()) {
1085           JumpNode* jmp = c-&gt;in(0)-&gt;as_Jump();
1086           if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(jmp)) {
1087             if (jmp-&gt;_fcnt == COUNT_UNKNOWN) {
1088               // assume never taken
1089               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1090             } else {
1091               // skip over loop
1092               _stack.push(c, 1);
1093               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1094             }
1095           } else {
1096             _stack.push(c, 1);
1097             c = jmp;
1098           }
1099         } else if (c-&gt;Opcode() == Op_CatchProj &amp;&amp;
1100                    c-&gt;in(0)-&gt;Opcode() == Op_Catch &amp;&amp;
1101                    c-&gt;in(0)-&gt;in(0)-&gt;is_Proj() &amp;&amp;
1102                    c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
1103           // assume exceptions are never thrown
1104           uint con = c-&gt;as_Proj()-&gt;_con;
1105           if (con == CatchProjNode::fall_through_index) {
1106             Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;in(0);
1107             if (_phase-&gt;get_loop(call) != _phase-&gt;get_loop(c)) {
1108               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1109             } else {
1110               c = call;
1111             }
1112           } else {
1113             assert(con &gt;= CatchProjNode::catch_all_index, &quot;what else?&quot;);
1114             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1115           }
1116         } else if (c-&gt;unique_ctrl_out() == NULL &amp;&amp; !c-&gt;is_If() &amp;&amp; !c-&gt;is_Jump()) {
1117           ShouldNotReachHere();
1118         } else {
1119           c = c-&gt;in(0);
1120         }
1121       }
1122     }
1123     ShouldNotReachHere();
1124     return -1;
1125   }
1126 };
1127 
1128 void PhaseIdealLoop::loop_predication_follow_branches(Node *n, IdealLoopTree *loop, float loop_trip_cnt,
1129                                                       PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1130                                                       Node_List&amp; if_proj_list) {
1131   assert(n-&gt;is_Region(), &quot;start from a region&quot;);
1132   Node* tail = loop-&gt;tail();
1133   stack.push(n, 1);
1134   do {
1135     Node* c = stack.node();
1136     assert(c-&gt;is_Region() || c-&gt;is_IfProj(), &quot;only region here&quot;);
1137     uint i = stack.index();
1138 
1139     if (i &lt; c-&gt;req()) {
1140       stack.set_index(i+1);
1141       Node* in = c-&gt;in(i);
1142       while (!is_dominator(in, tail) &amp;&amp; !seen.test_set(in-&gt;_idx)) {
1143         IdealLoopTree* in_loop = get_loop(in);
1144         if (in_loop != loop) {
1145           in = in_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1146         } else if (in-&gt;is_Region()) {
1147           stack.push(in, 1);
1148           break;
1149         } else if (in-&gt;is_IfProj() &amp;&amp;
1150                    in-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1151                    (in-&gt;in(0)-&gt;Opcode() == Op_If ||
1152                     in-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) {
1153           if (pf.to(in) * loop_trip_cnt &gt;= 1) {
1154             stack.push(in, 1);
1155           }
1156           in = in-&gt;in(0);
1157         } else {
1158           in = in-&gt;in(0);
1159         }
1160       }
1161     } else {
1162       if (c-&gt;is_IfProj()) {
1163         if_proj_list.push(c);
1164       }
1165       stack.pop();
1166     }
1167 
1168   } while (stack.size() &gt; 0);
1169 }
1170 
1171 
1172 bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1173                                                   CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1174                                                   Deoptimization::DeoptReason reason) {
1175   // Following are changed to nonnull when a predicate can be hoisted
1176   ProjNode* new_predicate_proj = NULL;
1177   IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1178   Node*     test = iff-&gt;in(1);
1179   if (!test-&gt;is_Bool()){ //Conv2B, ...
1180     return false;
1181   }
1182   BoolNode* bol = test-&gt;as_Bool();
1183   if (invar.is_invariant(bol)) {
1184     // Invariant test
1185     new_predicate_proj = create_new_if_for_predicate(predicate_proj, NULL,
1186                                                      reason,
1187                                                      iff-&gt;Opcode());
1188     Node* ctrl = new_predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1189     BoolNode* new_predicate_bol = invar.clone(bol, ctrl)-&gt;as_Bool();
1190 
1191     // Negate test if necessary
1192     bool negated = false;
1193     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1194       new_predicate_bol = new BoolNode(new_predicate_bol-&gt;in(1), new_predicate_bol-&gt;_test.negate());
1195       register_new_node(new_predicate_bol, ctrl);
1196       negated = true;
1197     }
1198     IfNode* new_predicate_iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
1199     _igvn.hash_delete(new_predicate_iff);
1200     new_predicate_iff-&gt;set_req(1, new_predicate_bol);
1201 #ifndef PRODUCT
1202     if (TraceLoopPredicate) {
1203       tty-&gt;print(&quot;Predicate invariant if%s: %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, new_predicate_iff-&gt;_idx);
1204       loop-&gt;dump_head();
1205     } else if (TraceLoopOpts) {
1206       tty-&gt;print(&quot;Predicate IC &quot;);
1207       loop-&gt;dump_head();
1208     }
1209 #endif
1210   } else if (cl != NULL &amp;&amp; loop-&gt;is_range_check_if(iff, this, invar)) {
1211     // Range check for counted loops
1212     const Node*    cmp    = bol-&gt;in(1)-&gt;as_Cmp();
1213     Node*          idx    = cmp-&gt;in(1);
1214     assert(!invar.is_invariant(idx), &quot;index is variant&quot;);
1215     Node* rng = cmp-&gt;in(2);
1216     assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;);
1217     assert(invar.is_invariant(rng), &quot;range must be invariant&quot;);
1218     int scale    = 1;
1219     Node* offset = zero;
1220     bool ok = is_scaled_iv_plus_offset(idx, cl-&gt;phi(), &amp;scale, &amp;offset);
1221     assert(ok, &quot;must be index expression&quot;);
1222 
1223     Node* init    = cl-&gt;init_trip();
1224     // Limit is not exact.
1225     // Calculate exact limit here.
1226     // Note, counted loop&#39;s test is &#39;&lt;&#39; or &#39;&gt;&#39;.
1227     Node* limit   = exact_limit(loop);
1228     int  stride   = cl-&gt;stride()-&gt;get_int();
1229 
1230     // Build if&#39;s for the upper and lower bound tests.  The
1231     // lower_bound test will dominate the upper bound test and all
1232     // cloned or created nodes will use the lower bound test as
1233     // their declared control.
1234 
1235     // Perform cloning to keep Invariance state correct since the
1236     // late schedule will place invariant things in the loop.
1237     Node *ctrl = predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1238     rng = invar.clone(rng, ctrl);
1239     if (offset &amp;&amp; offset != zero) {
1240       assert(invar.is_invariant(offset), &quot;offset must be loop invariant&quot;);
1241       offset = invar.clone(offset, ctrl);
1242     }
1243     // If predicate expressions may overflow in the integer range, longs are used.
1244     bool overflow = false;
1245 
1246     // Test the lower bound
1247     BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);
1248     // Negate test if necessary
1249     bool negated = false;
1250     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1251       lower_bound_bol = new BoolNode(lower_bound_bol-&gt;in(1), lower_bound_bol-&gt;_test.negate());
1252       register_new_node(lower_bound_bol, ctrl);
1253       negated = true;
1254     }
1255     ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1256     IfNode* lower_bound_iff = lower_bound_proj-&gt;in(0)-&gt;as_If();
1257     _igvn.hash_delete(lower_bound_iff);
1258     lower_bound_iff-&gt;set_req(1, lower_bound_bol);
1259     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;lower bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1260 
1261     // Test the upper bound
1262     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1263     negated = false;
1264     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1265       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1266       register_new_node(upper_bound_bol, ctrl);
1267       negated = true;
1268     }
1269     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1270     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1271     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1272     _igvn.hash_delete(upper_bound_iff);
1273     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1274     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1275 
1276     // Fall through into rest of the clean up code which will move
1277     // any dependent nodes onto the upper bound test.
1278     new_predicate_proj = upper_bound_proj;
1279 
1280     if (iff-&gt;is_RangeCheck()) {
1281       new_predicate_proj = insert_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);
1282     }
1283 
1284 #ifndef PRODUCT
1285     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1286       tty-&gt;print(&quot;Predicate RC &quot;);
1287       loop-&gt;dump_head();
1288     }
1289 #endif
1290   } else {
1291     // Loop variant check (for example, range check in non-counted loop)
1292     // with uncommon trap.
1293     return false;
1294   }
1295   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1296   // Success - attach condition (new_predicate_bol) to predicate if
1297   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1298 
1299   // Eliminate the old If in the loop body
1300   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1301 
1302   C-&gt;set_major_progress();
1303   return true;
1304 }
1305 
1306 
1307 // After pre/main/post loops are created, we&#39;ll put a copy of some
1308 // range checks between the pre and main loop to validate the value
1309 // of the main loop induction variable. Make a copy of the predicates
1310 // here with an opaque node as a place holder for the value (will be
1311 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
1312 ProjNode* PhaseIdealLoop::insert_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,
1313                                                     ProjNode* proj, ProjNode *predicate_proj,
1314                                                     ProjNode* upper_bound_proj,
1315                                                     int scale, Node* offset,
1316                                                     Node* init, Node* limit, jint stride,
1317                                                     Node* rng, bool &amp;overflow,
1318                                                     Deoptimization::DeoptReason reason) {
1319   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1320   Node* opaque_init = new Opaque1Node(C, init);
1321   register_new_node(opaque_init, upper_bound_proj);
1322   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1323   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1324   register_new_node(opaque_bol, upper_bound_proj);
1325   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1326   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1327   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1328   return new_proj;
1329 }
1330 
1331 //------------------------------ loop_predication_impl--------------------------
1332 // Insert loop predicates for null checks and range checks
1333 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1334   if (!UseLoopPredicate) return false;
1335 
1336   if (!loop-&gt;_head-&gt;is_Loop()) {
1337     // Could be a simple region when irreducible loops are present.
1338     return false;
1339   }
1340   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
1341 
1342   if (head-&gt;unique_ctrl_out()-&gt;Opcode() == Op_NeverBranch) {
1343     // do nothing for infinite loops
1344     return false;
1345   }
1346 
1347   if (head-&gt;is_OuterStripMinedLoop()) {
1348     return false;
1349   }
1350 
1351   CountedLoopNode *cl = NULL;
1352   if (head-&gt;is_valid_counted_loop()) {
1353     cl = head-&gt;as_CountedLoop();
1354     // do nothing for iteration-splitted loops
1355     if (!cl-&gt;is_normal_loop()) return false;
1356     // Avoid RCE if Counted loop&#39;s test is &#39;!=&#39;.
1357     BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
1358     if (bt != BoolTest::lt &amp;&amp; bt != BoolTest::gt)
1359       cl = NULL;
1360   }
1361 
1362   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1363   ProjNode *loop_limit_proj = NULL;
1364   ProjNode *predicate_proj = NULL;
1365   ProjNode *profile_predicate_proj = NULL;
1366   // Loop limit check predicate should be near the loop.
1367   loop_limit_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1368   if (loop_limit_proj != NULL) {
1369     entry = skip_loop_predicates(loop_limit_proj);
1370   }
1371   bool has_profile_predicates = false;
1372   profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1373   if (profile_predicate_proj != NULL) {
1374     Node* n = skip_loop_predicates(entry);
1375     // Check if predicates were already added to the profile predicate
1376     // block
1377     if (n != entry-&gt;in(0)-&gt;in(0) || n-&gt;outcnt() != 1) {
1378       has_profile_predicates = true;
1379     }
1380     entry = n;
1381   }
1382   predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1383 
1384   float loop_trip_cnt = -1;
1385   bool follow_branches = loop_predication_should_follow_branches(loop, profile_predicate_proj, loop_trip_cnt);
1386   assert(!follow_branches || loop_trip_cnt &gt;= 0, &quot;negative trip count?&quot;);
1387 
1388   if (predicate_proj == NULL &amp;&amp; !follow_branches) {
1389 #ifndef PRODUCT
1390     if (TraceLoopPredicate) {
1391       tty-&gt;print(&quot;missing predicate:&quot;);
1392       loop-&gt;dump_head();
1393       head-&gt;dump(1);
1394     }
1395 #endif
1396     return false;
1397   }
1398   ConNode* zero = _igvn.intcon(0);
1399   set_ctrl(zero, C-&gt;root());
1400 
1401   ResourceArea *area = Thread::current()-&gt;resource_area();
1402   Invariance invar(area, loop);
1403 
1404   // Create list of if-projs such that a newer proj dominates all older
1405   // projs in the list, and they all dominate loop-&gt;tail()
1406   Node_List if_proj_list(area);
1407   Node_List regions(area);
1408   Node *current_proj = loop-&gt;tail(); //start from tail
1409 
1410 
1411   Node_List controls(area);
1412   while (current_proj != head) {
1413     if (loop == get_loop(current_proj) &amp;&amp; // still in the loop ?
1414         current_proj-&gt;is_Proj()        &amp;&amp; // is a projection  ?
1415         (current_proj-&gt;in(0)-&gt;Opcode() == Op_If ||
1416          current_proj-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) { // is a if projection ?
1417       if_proj_list.push(current_proj);
1418     }
1419     if (follow_branches &amp;&amp;
1420         current_proj-&gt;Opcode() == Op_Region &amp;&amp;
1421         loop == get_loop(current_proj)) {
1422       regions.push(current_proj);
1423     }
1424     current_proj = idom(current_proj);
1425   }
1426 
1427   bool hoisted = false; // true if at least one proj is promoted
1428 
1429   if (!has_profile_predicates) {
1430     while (if_proj_list.size() &gt; 0) {
1431       Node* n = if_proj_list.pop();
1432 
1433       ProjNode* proj = n-&gt;as_Proj();
1434       IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1435 
1436       CallStaticJavaNode* call = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1437       if (call == NULL) {
1438         if (loop-&gt;is_loop_exit(iff)) {
1439           // stop processing the remaining projs in the list because the execution of them
1440           // depends on the condition of &quot;iff&quot; (iff-&gt;in(1)).
1441           break;
1442         } else {
1443           // Both arms are inside the loop. There are two cases:
1444           // (1) there is one backward branch. In this case, any remaining proj
1445           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1446           //     does not determine the execution the remining projs directly, and we
1447           //     can safely continue.
1448           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1449           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1450           continue;
1451         }
1452       }
1453       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1454       if (reason == Deoptimization::Reason_predicate) {
1455         break;
1456       }
1457 
1458       if (predicate_proj != NULL) {
1459         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1460       }
1461     } // end while
1462   }
1463 
<a name="6" id="anc6"></a><span class="line-removed">1464   Node_List if_proj_list_freq(area);</span>
1465   if (follow_branches) {
1466     PathFrequency pf(loop-&gt;_head, this);
1467 
1468     // Some projections were skipped by regular predicates because of
1469     // an early loop exit. Try them with profile data.
1470     while (if_proj_list.size() &gt; 0) {
1471       Node* proj = if_proj_list.pop();
1472       float f = pf.to(proj);
1473       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1474           f * loop_trip_cnt &gt;= 1) {
1475         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1476       }
1477     }
1478 
1479     // And look into all branches
1480     Node_Stack stack(0);
1481     VectorSet seen(Thread::current()-&gt;resource_area());
<a name="7" id="anc7"></a>
1482     while (regions.size() &gt; 0) {
1483       Node* c = regions.pop();
1484       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1485     }
1486 
1487     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1488       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1489       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1490     }
1491   }
1492 
1493 #ifndef PRODUCT
1494   // report that the loop predication has been actually performed
1495   // for this loop
1496   if (TraceLoopPredicate &amp;&amp; hoisted) {
1497     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1498     loop-&gt;dump_head();
1499   }
1500 #endif
1501 
1502   head-&gt;verify_strip_mined(1);
1503 
1504   return hoisted;
1505 }
1506 
1507 //------------------------------loop_predication--------------------------------
1508 // driver routine for loop predication optimization
1509 bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {
1510   bool hoisted = false;
1511   // Recursively promote predicates
1512   if (_child) {
1513     hoisted = _child-&gt;loop_predication( phase);
1514   }
1515 
1516   // self
1517   if (!_irreducible &amp;&amp; !tail()-&gt;is_top()) {
1518     hoisted |= phase-&gt;loop_predication_impl(this);
1519   }
1520 
1521   if (_next) { //sibling
1522     hoisted |= _next-&gt;loop_predication( phase);
1523   }
1524 
1525   return hoisted;
1526 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
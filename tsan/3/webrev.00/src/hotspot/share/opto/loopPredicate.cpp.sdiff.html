<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="locknode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopPredicate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 284     igvn-&gt;register_new_node_with_optimizer(opq);
 285     igvn-&gt;register_new_node_with_optimizer(bol);
 286   }
 287   igvn-&gt;hash_delete(iff);
 288   iff-&gt;set_req(1, bol);
 289   return new_predicate_proj;
 290 }
 291 
 292 
 293 //--------------------------clone_loop_predicates-----------------------
 294 // Interface from IGVN
 295 Node* PhaseIterGVN::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 296   return PhaseIdealLoop::clone_loop_predicates(old_entry, new_entry, clone_limit_check, NULL, this);
 297 }
 298 
 299 // Interface from PhaseIdealLoop
 300 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 301   return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);
 302 }
 303 
<span class="line-removed"> 304 void PhaseIdealLoop::clone_loop_predicates_fix_mem(ProjNode* dom_proj , ProjNode* proj,</span>
<span class="line-removed"> 305                                                    PhaseIdealLoop* loop_phase,</span>
<span class="line-removed"> 306                                                    PhaseIterGVN* igvn) {</span>
<span class="line-removed"> 307   Compile* C = NULL;</span>
<span class="line-removed"> 308   if (loop_phase != NULL) {</span>
<span class="line-removed"> 309     igvn = &amp;loop_phase-&gt;igvn();</span>
<span class="line-removed"> 310   }</span>
<span class="line-removed"> 311   C = igvn-&gt;C;</span>
<span class="line-removed"> 312   ProjNode* other_dom_proj = dom_proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-dom_proj-&gt;_con);</span>
<span class="line-removed"> 313   Node* dom_r = other_dom_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 314   if (dom_r-&gt;is_Region()) {</span>
<span class="line-removed"> 315     assert(dom_r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;unc expected&quot;);</span>
<span class="line-removed"> 316     ProjNode* other_proj = proj-&gt;in(0)-&gt;as_Multi()-&gt;proj_out(1-proj-&gt;_con);</span>
<span class="line-removed"> 317     Node* r = other_proj-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 318     assert(r-&gt;is_Region() &amp;&amp; r-&gt;unique_ctrl_out()-&gt;is_Call(), &quot;cloned predicate should have caused region to be added&quot;);</span>
<span class="line-removed"> 319     for (DUIterator_Fast imax, i = dom_r-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed"> 320       Node* dom_use = dom_r-&gt;fast_out(i);</span>
<span class="line-removed"> 321       if (dom_use-&gt;is_Phi() &amp;&amp; dom_use-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed"> 322         assert(dom_use-&gt;in(0) == dom_r, &quot;&quot;);</span>
<span class="line-removed"> 323         Node* phi = NULL;</span>
<span class="line-removed"> 324         for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed"> 325           Node* use = r-&gt;fast_out(j);</span>
<span class="line-removed"> 326           if (use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed"> 327               use-&gt;adr_type() == dom_use-&gt;adr_type()) {</span>
<span class="line-removed"> 328             assert(use-&gt;in(0) == r, &quot;&quot;);</span>
<span class="line-removed"> 329             assert(phi == NULL, &quot;only one phi&quot;);</span>
<span class="line-removed"> 330             phi = use;</span>
<span class="line-removed"> 331           }</span>
<span class="line-removed"> 332         }</span>
<span class="line-removed"> 333         if (phi == NULL) {</span>
<span class="line-removed"> 334           const TypePtr* adr_type = dom_use-&gt;adr_type();</span>
<span class="line-removed"> 335           int alias = C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 336           Node* call = r-&gt;unique_ctrl_out();</span>
<span class="line-removed"> 337           Node* mem = call-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 338           MergeMemNode* mm = NULL;</span>
<span class="line-removed"> 339           if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 340             mm = mem-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-removed"> 341             if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed"> 342               mem = mem-&gt;as_MergeMem()-&gt;base_memory();</span>
<span class="line-removed"> 343             } else {</span>
<span class="line-removed"> 344               mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="line-removed"> 345             }</span>
<span class="line-removed"> 346           } else {</span>
<span class="line-removed"> 347             mm = MergeMemNode::make(mem);</span>
<span class="line-removed"> 348           }</span>
<span class="line-removed"> 349           phi = PhiNode::make(r, mem, Type::MEMORY, adr_type);</span>
<span class="line-removed"> 350           if (adr_type == TypePtr::BOTTOM) {</span>
<span class="line-removed"> 351             mm-&gt;set_base_memory(phi);</span>
<span class="line-removed"> 352           } else {</span>
<span class="line-removed"> 353             mm-&gt;set_memory_at(alias, phi);</span>
<span class="line-removed"> 354           }</span>
<span class="line-removed"> 355           if (loop_phase != NULL) {</span>
<span class="line-removed"> 356             loop_phase-&gt;register_new_node(mm, r);</span>
<span class="line-removed"> 357             loop_phase-&gt;register_new_node(phi, r);</span>
<span class="line-removed"> 358           } else {</span>
<span class="line-removed"> 359             igvn-&gt;register_new_node_with_optimizer(mm);</span>
<span class="line-removed"> 360             igvn-&gt;register_new_node_with_optimizer(phi);</span>
<span class="line-removed"> 361           }</span>
<span class="line-removed"> 362           igvn-&gt;replace_input_of(call, TypeFunc::Memory, mm);</span>
<span class="line-removed"> 363         }</span>
<span class="line-removed"> 364         igvn-&gt;replace_input_of(phi, r-&gt;find_edge(other_proj), dom_use-&gt;in(dom_r-&gt;find_edge(other_dom_proj)));</span>
<span class="line-removed"> 365       }</span>
<span class="line-removed"> 366     }</span>
<span class="line-removed"> 367   }</span>
<span class="line-removed"> 368 }</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370 </span>
 371 // Clone loop predicates to cloned loops (peeled, unswitched, split_if).
 372 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,
 373                                             bool clone_limit_check,
 374                                             PhaseIdealLoop* loop_phase,
 375                                             PhaseIterGVN* igvn) {
 376 #ifdef ASSERT
 377   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 378     if (new_entry != NULL)
 379       new_entry-&gt;dump();
 380     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 381   }
 382 #endif
 383   // Search original predicates
 384   Node* entry = old_entry;
 385   ProjNode* limit_check_proj = NULL;
 386   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 387   if (limit_check_proj != NULL) {
 388     entry = skip_loop_predicates(entry);
 389   }
 390   ProjNode* profile_predicate_proj = NULL;
 391   ProjNode* predicate_proj = NULL;
 392   if (UseProfiledLoopPredicate) {
 393     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 394     if (profile_predicate_proj != NULL) {
 395       entry = skip_loop_predicates(entry);
 396     }
 397   }
 398   if (UseLoopPredicate) {
 399     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 400   }
 401   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 402     // clone predicate
<span class="line-modified"> 403     ProjNode* proj = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified"> 404                                      Deoptimization::Reason_predicate,</span>
<span class="line-modified"> 405                                      loop_phase, igvn);</span>
<span class="line-modified"> 406     assert(proj != NULL, &quot;IfTrue or IfFalse after clone predicate&quot;);</span>
<span class="line-removed"> 407     new_entry = proj;</span>
 408     if (TraceLoopPredicate) {
 409       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 410       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 411     }
<span class="line-removed"> 412     if (profile_predicate_proj != NULL) {</span>
<span class="line-removed"> 413       // A node that produces memory may be out of loop and depend on</span>
<span class="line-removed"> 414       // a profiled predicates. In that case the memory state at the</span>
<span class="line-removed"> 415       // end of profiled predicates and at the end of predicates are</span>
<span class="line-removed"> 416       // not the same. The cloned predicates are dominated by the</span>
<span class="line-removed"> 417       // profiled predicates but may have the wrong memory</span>
<span class="line-removed"> 418       // state. Update it.</span>
<span class="line-removed"> 419       clone_loop_predicates_fix_mem(profile_predicate_proj, proj, loop_phase, igvn);</span>
<span class="line-removed"> 420     }</span>
 421   }
 422   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 423     // clone predicate
 424     new_entry = clone_predicate(profile_predicate_proj, new_entry,
 425                                 Deoptimization::Reason_profile_predicate,
 426                                 loop_phase, igvn);
 427     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 428     if (TraceLoopPredicate) {
 429       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 430       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 431     }
 432   }
 433   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 434     // Clone loop limit check last to insert it before loop.
 435     // Don&#39;t clone a limit check which was already finalized
 436     // for this counted loop (only one limit check is needed).
 437     new_entry = clone_predicate(limit_check_proj, new_entry,
 438                                 Deoptimization::Reason_loop_limit_check,
 439                                 loop_phase, igvn);
 440     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
</pre>
<hr />
<pre>
 519 }
 520 
 521 //------------------------------Invariance-----------------------------------
 522 // Helper class for loop_predication_impl to compute invariance on the fly and
 523 // clone invariants.
 524 class Invariance : public StackObj {
 525   VectorSet _visited, _invariant;
 526   Node_Stack _stack;
 527   VectorSet _clone_visited;
 528   Node_List _old_new; // map of old to new (clone)
 529   IdealLoopTree* _lpt;
 530   PhaseIdealLoop* _phase;
 531 
 532   // Helper function to set up the invariance for invariance computation
 533   // If n is a known invariant, set up directly. Otherwise, look up the
 534   // the possibility to push n onto the stack for further processing.
 535   void visit(Node* use, Node* n) {
 536     if (_lpt-&gt;is_invariant(n)) { // known invariant
 537       _invariant.set(n-&gt;_idx);
 538     } else if (!n-&gt;is_CFG()) {
<span class="line-removed"> 539       if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 540         return;</span>
<span class="line-removed"> 541       }</span>
 542       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 543       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 544       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 545         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 546       }
 547     }
 548   }
 549 
 550   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 551   // on the fly
 552   void compute_invariance(Node* n) {
 553     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 554     visit(n, n);
 555     while (_stack.is_nonempty()) {
 556       Node*  n = _stack.node();
 557       uint idx = _stack.index();
 558       if (idx == n-&gt;req()) { // all inputs are processed
 559         _stack.pop();
 560         // n is invariant if it&#39;s inputs are all invariant
 561         bool all_inputs_invariant = true;
</pre>
<hr />
<pre>
 864       max_idx_expr = new AddINode(max_idx_expr, offset);
 865     }
 866     register_new_node(max_idx_expr, ctrl);
 867   }
 868 
 869   CmpNode* cmp = NULL;
 870   if (overflow) {
 871     // Integer expressions may overflow, do long comparison
 872     range = new ConvI2LNode(range);
 873     register_new_node(range, ctrl);
 874     cmp = new CmpULNode(max_idx_expr, range);
 875   } else {
 876     cmp = new CmpUNode(max_idx_expr, range);
 877   }
 878   register_new_node(cmp, ctrl);
 879   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 880   register_new_node(bol, ctrl);
 881 
 882   if (TraceLoopPredicate) {
 883     predString-&gt;print_cr(&quot;&lt;u range&quot;);
<span class="line-modified"> 884     tty-&gt;print(&quot;%s&quot;, predString-&gt;as_string());</span>

 885   }
 886   return bol;
 887 }
 888 
 889 // Should loop predication look not only in the path from tail to head
 890 // but also in branches of the loop body?
 891 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 892   if (!UseProfiledLoopPredicate) {
 893     return false;
 894   }
 895 
 896   if (predicate_proj == NULL) {
 897     return false;
 898   }
 899 
 900   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 901   bool follow_branches = true;
 902   IdealLoopTree* l = loop-&gt;_child;
 903   // For leaf loops and loops with a single inner loop
 904   while (l != NULL &amp;&amp; follow_branches) {
</pre>
<hr />
<pre>
1444           // (1) there is one backward branch. In this case, any remaining proj
1445           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1446           //     does not determine the execution the remining projs directly, and we
1447           //     can safely continue.
1448           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1449           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1450           continue;
1451         }
1452       }
1453       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1454       if (reason == Deoptimization::Reason_predicate) {
1455         break;
1456       }
1457 
1458       if (predicate_proj != NULL) {
1459         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1460       }
1461     } // end while
1462   }
1463 
<span class="line-removed">1464   Node_List if_proj_list_freq(area);</span>
1465   if (follow_branches) {
1466     PathFrequency pf(loop-&gt;_head, this);
1467 
1468     // Some projections were skipped by regular predicates because of
1469     // an early loop exit. Try them with profile data.
1470     while (if_proj_list.size() &gt; 0) {
1471       Node* proj = if_proj_list.pop();
1472       float f = pf.to(proj);
1473       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1474           f * loop_trip_cnt &gt;= 1) {
1475         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1476       }
1477     }
1478 
1479     // And look into all branches
1480     Node_Stack stack(0);
1481     VectorSet seen(Thread::current()-&gt;resource_area());

1482     while (regions.size() &gt; 0) {
1483       Node* c = regions.pop();
1484       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1485     }
1486 
1487     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1488       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1489       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1490     }
1491   }
1492 
1493 #ifndef PRODUCT
1494   // report that the loop predication has been actually performed
1495   // for this loop
1496   if (TraceLoopPredicate &amp;&amp; hoisted) {
1497     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1498     loop-&gt;dump_head();
1499   }
1500 #endif
1501 
</pre>
</td>
<td>
<hr />
<pre>
 284     igvn-&gt;register_new_node_with_optimizer(opq);
 285     igvn-&gt;register_new_node_with_optimizer(bol);
 286   }
 287   igvn-&gt;hash_delete(iff);
 288   iff-&gt;set_req(1, bol);
 289   return new_predicate_proj;
 290 }
 291 
 292 
 293 //--------------------------clone_loop_predicates-----------------------
 294 // Interface from IGVN
 295 Node* PhaseIterGVN::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 296   return PhaseIdealLoop::clone_loop_predicates(old_entry, new_entry, clone_limit_check, NULL, this);
 297 }
 298 
 299 // Interface from PhaseIdealLoop
 300 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check) {
 301   return clone_loop_predicates(old_entry, new_entry, clone_limit_check, this, &amp;this-&gt;_igvn);
 302 }
 303 



































































 304 // Clone loop predicates to cloned loops (peeled, unswitched, split_if).
 305 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry,
 306                                             bool clone_limit_check,
 307                                             PhaseIdealLoop* loop_phase,
 308                                             PhaseIterGVN* igvn) {
 309 #ifdef ASSERT
 310   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 311     if (new_entry != NULL)
 312       new_entry-&gt;dump();
 313     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 314   }
 315 #endif
 316   // Search original predicates
 317   Node* entry = old_entry;
 318   ProjNode* limit_check_proj = NULL;
 319   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 320   if (limit_check_proj != NULL) {
 321     entry = skip_loop_predicates(entry);
 322   }
 323   ProjNode* profile_predicate_proj = NULL;
 324   ProjNode* predicate_proj = NULL;
 325   if (UseProfiledLoopPredicate) {
 326     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 327     if (profile_predicate_proj != NULL) {
 328       entry = skip_loop_predicates(entry);
 329     }
 330   }
 331   if (UseLoopPredicate) {
 332     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 333   }
 334   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 335     // clone predicate
<span class="line-modified"> 336     new_entry = clone_predicate(predicate_proj, new_entry,</span>
<span class="line-modified"> 337                                 Deoptimization::Reason_predicate,</span>
<span class="line-modified"> 338                                 loop_phase, igvn);</span>
<span class="line-modified"> 339     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);</span>

 340     if (TraceLoopPredicate) {
 341       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 342       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 343     }









 344   }
 345   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 346     // clone predicate
 347     new_entry = clone_predicate(profile_predicate_proj, new_entry,
 348                                 Deoptimization::Reason_profile_predicate,
 349                                 loop_phase, igvn);
 350     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 351     if (TraceLoopPredicate) {
 352       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 353       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 354     }
 355   }
 356   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 357     // Clone loop limit check last to insert it before loop.
 358     // Don&#39;t clone a limit check which was already finalized
 359     // for this counted loop (only one limit check is needed).
 360     new_entry = clone_predicate(limit_check_proj, new_entry,
 361                                 Deoptimization::Reason_loop_limit_check,
 362                                 loop_phase, igvn);
 363     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
</pre>
<hr />
<pre>
 442 }
 443 
 444 //------------------------------Invariance-----------------------------------
 445 // Helper class for loop_predication_impl to compute invariance on the fly and
 446 // clone invariants.
 447 class Invariance : public StackObj {
 448   VectorSet _visited, _invariant;
 449   Node_Stack _stack;
 450   VectorSet _clone_visited;
 451   Node_List _old_new; // map of old to new (clone)
 452   IdealLoopTree* _lpt;
 453   PhaseIdealLoop* _phase;
 454 
 455   // Helper function to set up the invariance for invariance computation
 456   // If n is a known invariant, set up directly. Otherwise, look up the
 457   // the possibility to push n onto the stack for further processing.
 458   void visit(Node* use, Node* n) {
 459     if (_lpt-&gt;is_invariant(n)) { // known invariant
 460       _invariant.set(n-&gt;_idx);
 461     } else if (!n-&gt;is_CFG()) {



 462       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 463       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 464       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 465         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 466       }
 467     }
 468   }
 469 
 470   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 471   // on the fly
 472   void compute_invariance(Node* n) {
 473     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 474     visit(n, n);
 475     while (_stack.is_nonempty()) {
 476       Node*  n = _stack.node();
 477       uint idx = _stack.index();
 478       if (idx == n-&gt;req()) { // all inputs are processed
 479         _stack.pop();
 480         // n is invariant if it&#39;s inputs are all invariant
 481         bool all_inputs_invariant = true;
</pre>
<hr />
<pre>
 784       max_idx_expr = new AddINode(max_idx_expr, offset);
 785     }
 786     register_new_node(max_idx_expr, ctrl);
 787   }
 788 
 789   CmpNode* cmp = NULL;
 790   if (overflow) {
 791     // Integer expressions may overflow, do long comparison
 792     range = new ConvI2LNode(range);
 793     register_new_node(range, ctrl);
 794     cmp = new CmpULNode(max_idx_expr, range);
 795   } else {
 796     cmp = new CmpUNode(max_idx_expr, range);
 797   }
 798   register_new_node(cmp, ctrl);
 799   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 800   register_new_node(bol, ctrl);
 801 
 802   if (TraceLoopPredicate) {
 803     predString-&gt;print_cr(&quot;&lt;u range&quot;);
<span class="line-modified"> 804     tty-&gt;print(&quot;%s&quot;, predString-&gt;base());</span>
<span class="line-added"> 805     predString-&gt;~stringStream();</span>
 806   }
 807   return bol;
 808 }
 809 
 810 // Should loop predication look not only in the path from tail to head
 811 // but also in branches of the loop body?
 812 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 813   if (!UseProfiledLoopPredicate) {
 814     return false;
 815   }
 816 
 817   if (predicate_proj == NULL) {
 818     return false;
 819   }
 820 
 821   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 822   bool follow_branches = true;
 823   IdealLoopTree* l = loop-&gt;_child;
 824   // For leaf loops and loops with a single inner loop
 825   while (l != NULL &amp;&amp; follow_branches) {
</pre>
<hr />
<pre>
1365           // (1) there is one backward branch. In this case, any remaining proj
1366           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1367           //     does not determine the execution the remining projs directly, and we
1368           //     can safely continue.
1369           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1370           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1371           continue;
1372         }
1373       }
1374       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1375       if (reason == Deoptimization::Reason_predicate) {
1376         break;
1377       }
1378 
1379       if (predicate_proj != NULL) {
1380         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1381       }
1382     } // end while
1383   }
1384 

1385   if (follow_branches) {
1386     PathFrequency pf(loop-&gt;_head, this);
1387 
1388     // Some projections were skipped by regular predicates because of
1389     // an early loop exit. Try them with profile data.
1390     while (if_proj_list.size() &gt; 0) {
1391       Node* proj = if_proj_list.pop();
1392       float f = pf.to(proj);
1393       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1394           f * loop_trip_cnt &gt;= 1) {
1395         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1396       }
1397     }
1398 
1399     // And look into all branches
1400     Node_Stack stack(0);
1401     VectorSet seen(Thread::current()-&gt;resource_area());
<span class="line-added">1402     Node_List if_proj_list_freq(area);</span>
1403     while (regions.size() &gt; 0) {
1404       Node* c = regions.pop();
1405       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1406     }
1407 
1408     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1409       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1410       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1411     }
1412   }
1413 
1414 #ifndef PRODUCT
1415   // report that the loop predication has been actually performed
1416   // for this loop
1417   if (TraceLoopPredicate &amp;&amp; hoisted) {
1418     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1419     loop-&gt;dump_head();
1420   }
1421 #endif
1422 
</pre>
</td>
</tr>
</table>
<center><a href="locknode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopTransform.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
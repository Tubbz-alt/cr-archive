diff a/src/hotspot/share/opto/callnode.cpp b/src/hotspot/share/opto/callnode.cpp
--- a/src/hotspot/share/opto/callnode.cpp
+++ b/src/hotspot/share/opto/callnode.cpp
@@ -40,18 +40,19 @@
 #include "opto/parse.hpp"
 #include "opto/regalloc.hpp"
 #include "opto/regmask.hpp"
 #include "opto/rootnode.hpp"
 #include "opto/runtime.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // Portions of code courtesy of Clifford Click
 
 // Optimization - Graph Style
 
 //=============================================================================
 uint StartNode::size_of() const { return sizeof(*this); }
-uint StartNode::cmp( const Node &n ) const
+bool StartNode::cmp( const Node &n ) const
 { return _domain == ((StartNode&)n)._domain; }
 const Type *StartNode::bottom_type() const { return _domain; }
 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
 #ifndef PRODUCT
 void StartNode::dump_spec(outputStream *st) const { st->print(" #"); _domain->dump_on(st);}
@@ -664,11 +665,11 @@
   }
   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 }
 
 //=============================================================================
-uint CallNode::cmp( const Node &n ) const
+bool CallNode::cmp( const Node &n ) const
 { return _tf == ((CallNode&)n)._tf && _jvms == ((CallNode&)n)._jvms; }
 #ifndef PRODUCT
 void CallNode::dump_req(outputStream *st) const {
   // Dump the required inputs, enclosed in '(' and ')'
   uint i;                       // Exit value of loop
@@ -960,11 +961,11 @@
   return false;
 }
 
 //=============================================================================
 uint CallJavaNode::size_of() const { return sizeof(*this); }
-uint CallJavaNode::cmp( const Node &n ) const {
+bool CallJavaNode::cmp( const Node &n ) const {
   CallJavaNode &call = (CallJavaNode&)n;
   return CallNode::cmp(call) && _method == call._method &&
          _override_symbolic_info == call._override_symbolic_info;
 }
 #ifdef ASSERT
@@ -997,11 +998,11 @@
 }
 #endif
 
 //=============================================================================
 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
-uint CallStaticJavaNode::cmp( const Node &n ) const {
+bool CallStaticJavaNode::cmp( const Node &n ) const {
   CallStaticJavaNode &call = (CallStaticJavaNode&)n;
   return CallJavaNode::cmp(call);
 }
 
 //----------------------------uncommon_trap_request----------------------------
@@ -1054,11 +1055,11 @@
 }
 #endif
 
 //=============================================================================
 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
-uint CallDynamicJavaNode::cmp( const Node &n ) const {
+bool CallDynamicJavaNode::cmp( const Node &n ) const {
   CallDynamicJavaNode &call = (CallDynamicJavaNode&)n;
   return CallJavaNode::cmp(call);
 }
 #ifndef PRODUCT
 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
@@ -1067,11 +1068,11 @@
 }
 #endif
 
 //=============================================================================
 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
-uint CallRuntimeNode::cmp( const Node &n ) const {
+bool CallRuntimeNode::cmp( const Node &n ) const {
   CallRuntimeNode &call = (CallRuntimeNode&)n;
   return CallNode::cmp(call) && !strcmp(_name,call._name);
 }
 #ifndef PRODUCT
 void CallRuntimeNode::dump_spec(outputStream *st) const {
@@ -1116,11 +1117,11 @@
   }
   set_req(loc, c);
 }
 
 uint SafePointNode::size_of() const { return sizeof(*this); }
-uint SafePointNode::cmp( const Node &n ) const {
+bool SafePointNode::cmp( const Node &n ) const {
   return (&n == this);          // Always fail except on self
 }
 
 //-------------------------set_next_exception----------------------------------
 void SafePointNode::set_next_exception(SafePointNode* n) {
@@ -1312,11 +1313,11 @@
   init_class_id(Class_SafePointScalarObject);
 }
 
 // Do not allow value-numbering for SafePointScalarObject node.
 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
-uint SafePointScalarObjectNode::cmp( const Node &n ) const {
+bool SafePointScalarObjectNode::cmp( const Node &n ) const {
   return (&n == this); // Always fail except on self
 }
 
 uint SafePointScalarObjectNode::ideal_reg() const {
   return 0; // No matching to machine instruction
@@ -1395,10 +1396,22 @@
   // Allocation node is first parameter in its initializer
   if (analyzer->is_arg_stack(0) || analyzer->is_arg_local(0)) {
     _is_allocation_MemBar_redundant = true;
   }
 }
+Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {
+  Node* mark_node = NULL;
+  // For now only enable fast locking for non-array types
+  if (UseBiasedLocking && Opcode() == Op_Allocate) {
+    Node* klass_node = in(AllocateNode::KlassNode);
+    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));
+    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);
+  } else {
+    mark_node = phase->MakeConX(markWord::prototype().value());
+  }
+  return mark_node;
+}
 
 //=============================================================================
 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
   if (remove_dead_region(phase, can_reshape))  return this;
   // Don't bother trying to transform a dead node
@@ -1429,11 +1442,11 @@
         igvn->register_new_node_with_optimizer(nproj);
 
         Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );
         frame = phase->transform(frame);
         // Halt & Catch Fire
-        Node *halt = new HaltNode( nproj, frame );
+        Node* halt = new HaltNode(nproj, frame, "unexpected negative array length");
         phase->C->root()->add_req(halt);
         phase->transform(halt);
 
         igvn->replace_node(catchproj, phase->C->top());
         return this;
@@ -2082,6 +2095,5 @@
     return dest_alias == t_oop_alias;
   }
 
   return true;
 }
-

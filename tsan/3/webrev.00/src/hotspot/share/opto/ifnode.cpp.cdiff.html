<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ifg.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/ifnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 115,11 ***</span>
    if( !t-&gt;singleton() ) return NULL;
  
    // No intervening control, like a simple Call
    Node *r = iff-&gt;in(0);
    if( !r-&gt;is_Region() ) return NULL;
<span class="line-modified">!   if (r-&gt;is_Loop() &amp;&amp; r-&gt;in(LoopNode::LoopBackControl)-&gt;is_top()) return NULL; // going away anyway</span>
    if( phi-&gt;region() != r ) return NULL;
    // No other users of the cmp/bool
    if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
      //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
      return NULL;
<span class="line-new-header">--- 115,11 ---</span>
    if( !t-&gt;singleton() ) return NULL;
  
    // No intervening control, like a simple Call
    Node *r = iff-&gt;in(0);
    if( !r-&gt;is_Region() ) return NULL;
<span class="line-modified">!   if (r-&gt;is_Loop()) return NULL;</span>
    if( phi-&gt;region() != r ) return NULL;
    // No other users of the cmp/bool
    if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
      //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
      return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,72 ***</span>
    // likely 2 or more) will promptly constant fold away.
    PhaseGVN *phase = igvn;
  
    // Make a region merging constants and a region merging the rest
    uint req_c = 0;
<span class="line-removed">-   Node* predicate_proj = NULL;</span>
<span class="line-removed">-   int nb_predicate_proj = 0;</span>
    for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
      if (phi-&gt;in(ii) == con1) {
        req_c++;
      }
      Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
      if (proj != NULL) {
<span class="line-modified">!       nb_predicate_proj++;</span>
<span class="line-removed">-       predicate_proj = proj;</span>
      }
    }
  
    // If all the defs of the phi are the same constant, we already have the desired end state.
    // Skip the split that would create empty phi and region nodes.
    if((r-&gt;req() - req_c) == 1) {
      return NULL;
    }
  
<span class="line-removed">-   if (nb_predicate_proj &gt; 1) {</span>
<span class="line-removed">-     // Can happen in case of loop unswitching and when the loop is</span>
<span class="line-removed">-     // optimized out: it&#39;s not a loop anymore so we don&#39;t care about</span>
<span class="line-removed">-     // predicates.</span>
<span class="line-removed">-     assert(!r-&gt;is_Loop(), &quot;this must not be a loop anymore&quot;);</span>
<span class="line-removed">-     predicate_proj = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   Node* predicate_c = NULL;</span>
<span class="line-removed">-   Node* predicate_x = NULL;</span>
<span class="line-removed">-   bool counted_loop = r-&gt;is_CountedLoop();</span>
<span class="line-removed">-   if (counted_loop) {</span>
<span class="line-removed">-     // Ignore counted loops for now because the split-if logic does not work</span>
<span class="line-removed">-     // in all the cases (for example, with strip mined loops). Also, above</span>
<span class="line-removed">-     // checks only pass for already degraded loops without a tripcount phi</span>
<span class="line-removed">-     // and these are essentially dead and will go away during igvn.</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    Node *region_c = new RegionNode(req_c + 1);
    Node *phi_c    = con1;
    uint  len      = r-&gt;req();
    Node *region_x = new RegionNode(len - req_c);
    Node *phi_x    = PhiNode::make_blank(region_x, phi);
    for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
      if (phi-&gt;in(i) == con1) {
        region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
<span class="line-removed">-       if (r-&gt;in(i) == predicate_proj)</span>
<span class="line-removed">-         predicate_c = predicate_proj;</span>
      } else {
        region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
        phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
<span class="line-removed">-       if (r-&gt;in(i) == predicate_proj)</span>
<span class="line-removed">-         predicate_x = predicate_proj;</span>
      }
    }
<span class="line-removed">-   if (predicate_c != NULL &amp;&amp; (req_c &gt; 1)) {</span>
<span class="line-removed">-     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed">-     predicate_c = NULL; // Do not clone predicate below merge point</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (predicate_x != NULL &amp;&amp; ((len - req_c) &gt; 2)) {</span>
<span class="line-removed">-     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed">-     predicate_x = NULL; // Do not clone predicate below merge point</span>
<span class="line-removed">-   }</span>
  
    // Register the new RegionNodes but do not transform them.  Cannot
    // transform until the entire Region/Phi conglomerate has been hacked
    // as a single huge transform.
    igvn-&gt;register_new_node_with_optimizer( region_c );
<span class="line-new-header">--- 236,39 ---</span>
    // likely 2 or more) will promptly constant fold away.
    PhaseGVN *phase = igvn;
  
    // Make a region merging constants and a region merging the rest
    uint req_c = 0;
    for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
      if (phi-&gt;in(ii) == con1) {
        req_c++;
      }
      Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
      if (proj != NULL) {
<span class="line-modified">!       return NULL;</span>
      }
    }
  
    // If all the defs of the phi are the same constant, we already have the desired end state.
    // Skip the split that would create empty phi and region nodes.
    if((r-&gt;req() - req_c) == 1) {
      return NULL;
    }
  
    Node *region_c = new RegionNode(req_c + 1);
    Node *phi_c    = con1;
    uint  len      = r-&gt;req();
    Node *region_x = new RegionNode(len - req_c);
    Node *phi_x    = PhiNode::make_blank(region_x, phi);
    for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
      if (phi-&gt;in(i) == con1) {
        region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
      } else {
        region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
        phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
      }
    }
  
    // Register the new RegionNodes but do not transform them.  Cannot
    // transform until the entire Region/Phi conglomerate has been hacked
    // as a single huge transform.
    igvn-&gt;register_new_node_with_optimizer( region_c );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,24 ***</span>
    hook-&gt;init_req(3, iff_x);
  
    // Make the true/false arms
    Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
    Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
<span class="line-removed">-   if (predicate_c != NULL) {</span>
<span class="line-removed">-     assert(predicate_x == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed">-     // Clone loop predicates to each path</span>
<span class="line-removed">-     iff_c_t = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_t, !counted_loop);</span>
<span class="line-removed">-     iff_c_f = igvn-&gt;clone_loop_predicates(predicate_c, iff_c_f, !counted_loop);</span>
<span class="line-removed">-   }</span>
    Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
    Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
<span class="line-removed">-   if (predicate_x != NULL) {</span>
<span class="line-removed">-     assert(predicate_c == NULL, &quot;only one predicate entry expected&quot;);</span>
<span class="line-removed">-     // Clone loop predicates to each path</span>
<span class="line-removed">-     iff_x_t = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_t, !counted_loop);</span>
<span class="line-removed">-     iff_x_f = igvn-&gt;clone_loop_predicates(predicate_x, iff_x_f, !counted_loop);</span>
<span class="line-removed">-   }</span>
  
    // Merge the TRUE paths
    Node *region_s = new RegionNode(3);
    igvn-&gt;_worklist.push(region_s);
    region_s-&gt;init_req(1, iff_c_t);
<span class="line-new-header">--- 306,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,22 ***</span>
          (din3 = din3-&gt;in(0)) )
        din3 = din3-&gt;in(0);
      if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
          (din4 = din4-&gt;in(0)) )
        din4 = din4-&gt;in(0);
<span class="line-modified">!     if( din3 == din4 &amp;&amp; din3-&gt;is_If() )</span>
        return din3;              // Skip around diamonds
    }
  
    // Give up the search at true merges
    return NULL;                  // Dead loop?  Or hit root?
  }
  
  
  //------------------------------filtered_int_type--------------------------------
  // Return a possibly more restrictive type for val based on condition control flow for an if
<span class="line-modified">! const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node *val, Node* if_proj) {</span>
    assert(if_proj &amp;&amp;
           (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
    if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
      IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
      if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
<span class="line-new-header">--- 586,22 ---</span>
          (din3 = din3-&gt;in(0)) )
        din3 = din3-&gt;in(0);
      if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
          (din4 = din4-&gt;in(0)) )
        din4 = din4-&gt;in(0);
<span class="line-modified">!     if (din3 != NULL &amp;&amp; din3 == din4 &amp;&amp; din3-&gt;is_If()) // Regions not degraded to a copy</span>
        return din3;              // Skip around diamonds
    }
  
    // Give up the search at true merges
    return NULL;                  // Dead loop?  Or hit root?
  }
  
  
  //------------------------------filtered_int_type--------------------------------
  // Return a possibly more restrictive type for val based on condition control flow for an if
<span class="line-modified">! const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {</span>
    assert(if_proj &amp;&amp;
           (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
    if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
      IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
      if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,13 ***</span>
            if (cmp2_t != NULL) {
              jint lo = cmp2_t-&gt;_lo;
              jint hi = cmp2_t-&gt;_hi;
              BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
              switch (msk) {
<span class="line-modified">!             case BoolTest::ne:</span>
                // Can&#39;t refine type
                return NULL;
              case BoolTest::eq:
                return cmp2_t;
              case BoolTest::lt:
                lo = TypeInt::INT-&gt;_lo;
                if (hi - 1 &lt; hi) {
<span class="line-new-header">--- 613,23 ---</span>
            if (cmp2_t != NULL) {
              jint lo = cmp2_t-&gt;_lo;
              jint hi = cmp2_t-&gt;_hi;
              BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
              switch (msk) {
<span class="line-modified">!             case BoolTest::ne: {</span>
<span class="line-added">+               // If val is compared to its lower or upper bound, we can narrow the type</span>
<span class="line-added">+               const TypeInt* val_t = gvn-&gt;type(val)-&gt;isa_int();</span>
<span class="line-added">+               if (val_t != NULL &amp;&amp; !val_t-&gt;singleton() &amp;&amp; cmp2_t-&gt;is_con()) {</span>
<span class="line-added">+                 if (val_t-&gt;_lo == lo) {</span>
<span class="line-added">+                   return TypeInt::make(val_t-&gt;_lo + 1, val_t-&gt;_hi, val_t-&gt;_widen);</span>
<span class="line-added">+                 } else if (val_t-&gt;_hi == hi) {</span>
<span class="line-added">+                   return TypeInt::make(val_t-&gt;_lo, val_t-&gt;_hi - 1, val_t-&gt;_widen);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+               }</span>
                // Can&#39;t refine type
                return NULL;
<span class="line-added">+             }</span>
              case BoolTest::eq:
                return cmp2_t;
              case BoolTest::lt:
                lo = TypeInt::INT-&gt;_lo;
                if (hi - 1 &lt; hi) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,29 ***</span>
  //            /    \
  //           /      unc
  //
  
  // Is the comparison for this If suitable for folding?
<span class="line-modified">! bool IfNode::cmpi_folds(PhaseIterGVN* igvn) {</span>
    return in(1) != NULL &amp;&amp;
      in(1)-&gt;is_Bool() &amp;&amp;
      in(1)-&gt;in(1) != NULL &amp;&amp;
      in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
      in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
      in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
      (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
<span class="line-modified">!      in(1)-&gt;as_Bool()-&gt;_test.is_greater());</span>
  }
  
  // Is a dominating control suitable for folding with this if?
  bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
    return ctrl != NULL &amp;&amp;
      ctrl-&gt;is_Proj() &amp;&amp;
      ctrl-&gt;in(0) != NULL &amp;&amp;
      ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
      ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
<span class="line-modified">!     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn) &amp;&amp;</span>
      // Must compare same value
      ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
      ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
  }
  
<span class="line-new-header">--- 699,30 ---</span>
  //            /    \
  //           /      unc
  //
  
  // Is the comparison for this If suitable for folding?
<span class="line-modified">! bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {</span>
    return in(1) != NULL &amp;&amp;
      in(1)-&gt;is_Bool() &amp;&amp;
      in(1)-&gt;in(1) != NULL &amp;&amp;
      in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
      in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
      in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
      (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
<span class="line-modified">!      in(1)-&gt;as_Bool()-&gt;_test.is_greater() ||</span>
<span class="line-added">+      (fold_ne &amp;&amp; in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne));</span>
  }
  
  // Is a dominating control suitable for folding with this if?
  bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
    return ctrl != NULL &amp;&amp;
      ctrl-&gt;is_Proj() &amp;&amp;
      ctrl-&gt;in(0) != NULL &amp;&amp;
      ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
      ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
<span class="line-modified">!     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn, true) &amp;&amp;</span>
      // Must compare same value
      ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
      ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 914,11 ***</span>
  
    // Figure out which of the two tests sets the upper bound and which
    // sets the lower bound if any.
    Node* adjusted_lim = NULL;
    if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
<span class="line-modified">!       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint) {</span>
      assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
             (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
      // this test was canonicalized
      assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
  
<span class="line-new-header">--- 880,11 ---</span>
  
    // Figure out which of the two tests sets the upper bound and which
    // sets the lower bound if any.
    Node* adjusted_lim = NULL;
    if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
<span class="line-modified">!       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {</span>
      assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
             (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
      // this test was canonicalized
      assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,11 ***</span>
          lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
          cond = BoolTest::lt;
        }
      }
    } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
<span class="line-modified">!              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint) {</span>
  
      // this_bool = &lt;
      //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
      //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
      //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
<span class="line-new-header">--- 921,11 ---</span>
          lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
          cond = BoolTest::lt;
        }
      }
    } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
<span class="line-modified">!              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {</span>
  
      // this_bool = &lt;
      //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
      //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
      //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,11 ***</span>
          lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
          cond = BoolTest::ge;
        }
      }
    } else {
<span class="line-modified">!     const TypeInt* failtype  = filtered_int_type(igvn, n, proj);</span>
      if (failtype != NULL) {
        const TypeInt* type2 = filtered_int_type(igvn, n, fail);
        if (type2 != NULL) {
          failtype = failtype-&gt;join(type2)-&gt;is_int();
          if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
<span class="line-new-header">--- 972,11 ---</span>
          lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
          cond = BoolTest::ge;
        }
      }
    } else {
<span class="line-modified">!     const TypeInt* failtype = filtered_int_type(igvn, n, proj);</span>
      if (failtype != NULL) {
        const TypeInt* type2 = filtered_int_type(igvn, n, fail);
        if (type2 != NULL) {
          failtype = failtype-&gt;join(type2)-&gt;is_int();
          if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1282,12 ***</span>
  Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
    if (Opcode() != Op_If) return NULL;
  
    if (cmpi_folds(igvn)) {
      Node* ctrl = in(0);
<span class="line-modified">!     if (is_ctrl_folds(ctrl, igvn) &amp;&amp;</span>
<span class="line-removed">-         ctrl-&gt;outcnt() == 1) {</span>
        // A integer comparison immediately dominated by another integer
        // comparison
        ProjNode* success = NULL;
        ProjNode* fail = NULL;
        ProjNode* dom_cmp = ctrl-&gt;as_Proj();
<span class="line-new-header">--- 1248,11 ---</span>
  Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
    if (Opcode() != Op_If) return NULL;
  
    if (cmpi_folds(igvn)) {
      Node* ctrl = in(0);
<span class="line-modified">!     if (is_ctrl_folds(ctrl, igvn) &amp;&amp; ctrl-&gt;outcnt() == 1) {</span>
        // A integer comparison immediately dominated by another integer
        // comparison
        ProjNode* success = NULL;
        ProjNode* fail = NULL;
        ProjNode* dom_cmp = ctrl-&gt;as_Proj();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,59 ***</span>
    }
  
    // Check for people making a useless boolean: things like
    // if( (x &lt; y ? true : false) ) { ... }
    // Replace with if( x &lt; y ) { ... }
<span class="line-modified">!   Node *bol2 = remove_useless_bool(this, phase);</span>
<span class="line-modified">!   if( bol2 ) return bol2;</span>
  
    if (in(0) == NULL) return NULL;     // Dead loop?
  
<span class="line-modified">!   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();</span>
    Node* result = fold_compares(igvn);
    if (result != NULL) {
      return result;
    }
  
    // Scan for an equivalent test
<span class="line-modified">!   Node *cmp;</span>
<span class="line-modified">!   int dist = 0;               // Cutoff limit for search</span>
<span class="line-modified">!   int op = Opcode();</span>
<span class="line-modified">!   if( op == Op_If &amp;&amp;</span>
<span class="line-modified">!       (cmp=in(1)-&gt;in(1))-&gt;Opcode() == Op_CmpP ) {</span>
<span class="line-modified">!     if( cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead</span>
<span class="line-removed">-         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR ) {</span>
        dist = 64;              // Limit for null-pointer scans
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       dist = 4;               // Do not bother for random pointer tests</span>
      }
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     dist = 4;                 // Limit for random junky scans</span>
    }
  
    Node* prev_dom = search_identical(dist);
  
<span class="line-modified">!   if (prev_dom == NULL) {</span>
<span class="line-modified">!     return NULL;</span>
    }
  
<span class="line-modified">!   // Replace dominated IfNode</span>
<span class="line-removed">-   return dominated_by(prev_dom, igvn);</span>
  }
  
  //------------------------------dominated_by-----------------------------------
  Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
  #ifndef PRODUCT
    if (TraceIterativeGVN) {
      tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
    }
<span class="line-removed">-   if (VerifyOpto &amp;&amp; !igvn-&gt;allow_progress()) {</span>
<span class="line-removed">-     // Found an equivalent dominating test,</span>
<span class="line-removed">-     // we can not guarantee reaching a fix-point for these during iterativeGVN</span>
<span class="line-removed">-     // since intervening nodes may not change.</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
  #endif
  
    igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
    Node *idom = in(0);
    // Need opcode to decide which way &#39;this&#39; test goes
<span class="line-new-header">--- 1400,48 ---</span>
    }
  
    // Check for people making a useless boolean: things like
    // if( (x &lt; y ? true : false) ) { ... }
    // Replace with if( x &lt; y ) { ... }
<span class="line-modified">!   Node* bol2 = remove_useless_bool(this, phase);</span>
<span class="line-modified">!   if (bol2) return bol2;</span>
  
    if (in(0) == NULL) return NULL;     // Dead loop?
  
<span class="line-modified">!   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
    Node* result = fold_compares(igvn);
    if (result != NULL) {
      return result;
    }
  
    // Scan for an equivalent test
<span class="line-modified">!   int dist = 4;               // Cutoff limit for search</span>
<span class="line-modified">!   if (is_If() &amp;&amp; in(1)-&gt;is_Bool()) {</span>
<span class="line-modified">!     Node* cmp = in(1)-&gt;in(1);</span>
<span class="line-modified">!     if (cmp-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-modified">!         cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead</span>
<span class="line-modified">!         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
        dist = 64;              // Limit for null-pointer scans
      }
    }
  
    Node* prev_dom = search_identical(dist);
  
<span class="line-modified">!   if (prev_dom != NULL) {</span>
<span class="line-modified">!     // Replace dominated IfNode</span>
<span class="line-added">+     return dominated_by(prev_dom, igvn);</span>
    }
  
<span class="line-modified">!   return simple_subsuming(igvn);</span>
  }
  
  //------------------------------dominated_by-----------------------------------
  Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
  #ifndef PRODUCT
    if (TraceIterativeGVN) {
      tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
    }
  #endif
  
    igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
    Node *idom = in(0);
    // Need opcode to decide which way &#39;this&#39; test goes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1572,10 ***</span>
<span class="line-new-header">--- 1526,118 ---</span>
  #endif
  
    return prev_dom;
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ static int subsuming_bool_test_encode(Node*);</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Check if dominating test is subsuming &#39;this&#39; one.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ //              cmp</span>
<span class="line-added">+ //              / \</span>
<span class="line-added">+ //     (r1)  bool  \</span>
<span class="line-added">+ //            /    bool (r2)</span>
<span class="line-added">+ //    (dom) if       \</span>
<span class="line-added">+ //            \       )</span>
<span class="line-added">+ //    (pre)  if[TF]  /</span>
<span class="line-added">+ //               \  /</span>
<span class="line-added">+ //                if (this)</span>
<span class="line-added">+ //   \r1</span>
<span class="line-added">+ //  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF</span>
<span class="line-added">+ //  eq    t    f    f    t    f    -    -    f    f    -    -    f</span>
<span class="line-added">+ //  ne    f    t    t    f    t    -    -    t    t    -    -    t</span>
<span class="line-added">+ //  lt    f    -    -    f    t    f    -    f    f    -    f    t</span>
<span class="line-added">+ //  le    t    -    -    t    t    -    t    f    f    t    -    t</span>
<span class="line-added">+ //  gt    f    -    -    f    f    -    f    t    t    f    -    f</span>
<span class="line-added">+ //  ge    t    -    -    t    f    t    -    t    t    -    t    f</span>
<span class="line-added">+ //</span>
<span class="line-added">+ Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {</span>
<span class="line-added">+   // Table encoding: N/A (na), True-branch (tb), False-branch (fb).</span>
<span class="line-added">+   static enum { na, tb, fb } s_short_circuit_map[6][12] = {</span>
<span class="line-added">+   /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/</span>
<span class="line-added">+   /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },</span>
<span class="line-added">+   /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },</span>
<span class="line-added">+   /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },</span>
<span class="line-added">+   /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },</span>
<span class="line-added">+   /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },</span>
<span class="line-added">+   /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};</span>
<span class="line-added">+ </span>
<span class="line-added">+   Node* pre = in(0);</span>
<span class="line-added">+   if (!pre-&gt;is_IfTrue() &amp;&amp; !pre-&gt;is_IfFalse()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Node* dom = pre-&gt;in(0);</span>
<span class="line-added">+   if (!dom-&gt;is_If()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Node* bol = in(1);</span>
<span class="line-added">+   if (!bol-&gt;is_Bool()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Node* cmp = in(1)-&gt;in(1);</span>
<span class="line-added">+   if (!cmp-&gt;is_Cmp()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!dom-&gt;in(1)-&gt;is_Bool()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (dom-&gt;in(1)-&gt;in(1) != cmp) {  // Not same cond?</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int drel = subsuming_bool_test_encode(dom-&gt;in(1));</span>
<span class="line-added">+   int trel = subsuming_bool_test_encode(bol);</span>
<span class="line-added">+   int bout = pre-&gt;is_IfFalse() ? 1 : 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (drel &lt; 0 || trel &lt; 0) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int br = s_short_circuit_map[trel][2*drel+bout];</span>
<span class="line-added">+   if (br == na) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+   if (TraceIterativeGVN) {</span>
<span class="line-added">+     tty-&gt;print(&quot;   Subsumed IfNode: &quot;); dump();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   // Replace condition with constant True(1)/False(0).</span>
<span class="line-added">+   set_req(1, igvn-&gt;intcon(br == tb ? 1 : 0));</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (bol-&gt;outcnt() == 0) {</span>
<span class="line-added">+     igvn-&gt;remove_dead_node(bol);    // Kill the BoolNode.</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return this;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Map BoolTest to local table encoding. The BoolTest (e)numerals</span>
<span class="line-added">+ //   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }</span>
<span class="line-added">+ // are mapped to table indices, while the remaining (e)numerals in BoolTest</span>
<span class="line-added">+ //   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }</span>
<span class="line-added">+ // are ignored (these are not modeled in the table).</span>
<span class="line-added">+ //</span>
<span class="line-added">+ static int subsuming_bool_test_encode(Node* node) {</span>
<span class="line-added">+   precond(node-&gt;is_Bool());</span>
<span class="line-added">+   BoolTest::mask x = node-&gt;as_Bool()-&gt;_test._test;</span>
<span class="line-added">+   switch (x) {</span>
<span class="line-added">+     case BoolTest::eq: return 0;</span>
<span class="line-added">+     case BoolTest::ne: return 1;</span>
<span class="line-added">+     case BoolTest::lt: return 2;</span>
<span class="line-added">+     case BoolTest::le: return 3;</span>
<span class="line-added">+     case BoolTest::gt: return 4;</span>
<span class="line-added">+     case BoolTest::ge: return 5;</span>
<span class="line-added">+     case BoolTest::overflow:</span>
<span class="line-added">+     case BoolTest::no_overflow:</span>
<span class="line-added">+     case BoolTest::never:</span>
<span class="line-added">+     case BoolTest::illegal:</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //------------------------------Identity---------------------------------------
  // If the test is constant &amp; we match, then we are the input Control
  Node* IfProjNode::Identity(PhaseGVN* phase) {
    // Can only optimize if cannot go the other way
    const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1717,11 ***</span>
      // then we are guaranteed to fail, so just start interpreting there.
      // We &#39;expand&#39; the top 3 range checks to include all post-dominating
      // checks.
  
      // The top 3 range checks seen
<span class="line-modified">!     const int NRC =3;</span>
      RangeCheck prev_checks[NRC];
      int nb_checks = 0;
  
      // Low and high offsets seen so far
      jint off_lo = offset1;
<span class="line-new-header">--- 1779,11 ---</span>
      // then we are guaranteed to fail, so just start interpreting there.
      // We &#39;expand&#39; the top 3 range checks to include all post-dominating
      // checks.
  
      // The top 3 range checks seen
<span class="line-modified">!     const int NRC = 3;</span>
      RangeCheck prev_checks[NRC];
      int nb_checks = 0;
  
      // Low and high offsets seen so far
      jint off_lo = offset1;
</pre>
<center><a href="ifg.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="indexSet.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
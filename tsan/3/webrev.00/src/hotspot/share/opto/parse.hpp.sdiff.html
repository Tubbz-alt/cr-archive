<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71              int max_inline_level);
 72   InlineTree *build_inline_tree_for_callee(ciMethod* callee_method,
 73                                            JVMState* caller_jvms,
 74                                            int caller_bci);
 75   bool        try_to_inline(ciMethod* callee_method,
 76                             ciMethod* caller_method,
 77                             int caller_bci,
 78                             JVMState* jvms,
 79                             ciCallProfile&amp; profile,
 80                             WarmCallInfo* wci_result,
 81                             bool&amp; should_delay);
 82   bool        should_inline(ciMethod* callee_method,
 83                             ciMethod* caller_method,
 84                             int caller_bci,
 85                             ciCallProfile&amp; profile,
 86                             WarmCallInfo* wci_result);
 87   bool        should_not_inline(ciMethod* callee_method,
 88                                 ciMethod* caller_method,
 89                                 JVMState* jvms,
 90                                 WarmCallInfo* wci_result);




 91   void        print_inlining(ciMethod* callee_method, int caller_bci,
 92                              ciMethod* caller_method, bool success) const;
 93 
 94   InlineTree* caller_tree()       const { return _caller_tree;  }
 95   InlineTree* callee_at(int bci, ciMethod* m) const;
 96   int         inline_level()      const { return stack_depth(); }
 97   int         stack_depth()       const { return _caller_jvms ? _caller_jvms-&gt;depth() : 0; }
 98   const char* msg()               const { return _msg; }
 99   void        set_msg(const char* msg)  { _msg = msg; }
100 public:
101   static const char* check_can_parse(ciMethod* callee);
102 
103   static InlineTree* build_inline_tree_root();
104   static InlineTree* find_subtree_from_root(InlineTree* root, JVMState* jvms, ciMethod* callee);
105 
106   // For temporary (stack-allocated, stateless) ilts:
107   InlineTree(Compile* c, ciMethod* callee_method, JVMState* caller_jvms, float site_invoke_ratio, int max_inline_level);
108 
109   // See if it is OK to inline.
110   // The receiver is the inline tree for the caller.
</pre>
<hr />
<pre>
459   // Merge the current mapping into an exception handler.
460   void merge_exception(int target_bci);
461   // Helper: Merge the current mapping into the given basic block
462   void merge_common(Block* target, int pnum);
463   // Helper functions for merging individual cells.
464   PhiNode *ensure_phi(       int idx, bool nocreate = false);
465   PhiNode *ensure_memory_phi(int idx, bool nocreate = false);
466   // Helper to merge the current memory state into the given basic block
467   void merge_memory_edges(MergeMemNode* n, int pnum, bool nophi);
468 
469   // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
470   void do_one_bytecode();
471 
472   // helper function to generate array store check
473   void array_store_check();
474   // Helper function to generate array load
475   void array_load(BasicType etype);
476   // Helper function to generate array store
477   void array_store(BasicType etype);
478   // Helper function to compute array addressing
<span class="line-modified">479   Node* array_addressing(BasicType type, int vals, const Type* *result2=NULL);</span>


480 
481   void rtm_deopt();
482 
483   // Pass current map to exits
484   void return_current(Node* value);
485 
486   // Register finalizers on return from Object.&lt;init&gt;
487   void call_register_finalizer();
488 
489   // Insert a compiler safepoint into the graph
490   void add_safepoint();
491 
492   // Insert a compiler safepoint into the graph, if there is a back-branch.
493   void maybe_add_safepoint(int target_bci) {
494     if (UseLoopSafepoints &amp;&amp; target_bci &lt;= bci()) {
495       add_safepoint();
496     }
497   }
498 
499   // Note:  Intrinsic generation routines may be found in library_call.cpp.
</pre>
<hr />
<pre>
509 
510   // Helper functions for type checking bytecodes:
511   void  do_checkcast();
512   void  do_instanceof();
513 
514   // Helper functions for shifting &amp; arithmetic
515   void modf();
516   void modd();
517   void l2f();
518 
519   void do_irem();
520 
521   // implementation of _get* and _put* bytecodes
522   void do_getstatic() { do_field_access(true,  false); }
523   void do_getfield () { do_field_access(true,  true); }
524   void do_putstatic() { do_field_access(false, false); }
525   void do_putfield () { do_field_access(false, true); }
526 
527   // common code for making initial checks and forming addresses
528   void do_field_access(bool is_get, bool is_field);
<span class="line-removed">529   bool static_field_ok_in_clinit(ciField *field, ciMethod *method);</span>
530 
531   // common code for actually performing the load or store
532   void do_get_xxx(Node* obj, ciField* field, bool is_field);
533   void do_put_xxx(Node* obj, ciField* field, bool is_field);
534 
535   // implementation of object creation bytecodes
<span class="line-removed">536   void emit_guard_for_new(ciInstanceKlass* klass);</span>
537   void do_new();
538   void do_newarray(BasicType elemtype);
539   void do_anewarray();
540   void do_multianewarray();
541   Node* expand_multianewarray(ciArrayKlass* array_klass, Node* *lengths, int ndimensions, int nargs);
542 
543   // implementation of jsr/ret
544   void do_jsr();
545   void do_ret();
546 
547   float   dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test);
548   float   branch_prediction(float &amp;cnt, BoolTest::mask btest, int target_bci, Node* test);
549   bool    seems_never_taken(float prob) const;
550   bool    path_is_suitable_for_uncommon_trap(float prob) const;
551   bool    seems_stable_comparison() const;
552 
553   void    do_ifnull(BoolTest::mask btest, Node* c);
554   void    do_if(BoolTest::mask btest, Node* c);
555   int     repush_if_args();
556   void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,
</pre>
</td>
<td>
<hr />
<pre>
 71              int max_inline_level);
 72   InlineTree *build_inline_tree_for_callee(ciMethod* callee_method,
 73                                            JVMState* caller_jvms,
 74                                            int caller_bci);
 75   bool        try_to_inline(ciMethod* callee_method,
 76                             ciMethod* caller_method,
 77                             int caller_bci,
 78                             JVMState* jvms,
 79                             ciCallProfile&amp; profile,
 80                             WarmCallInfo* wci_result,
 81                             bool&amp; should_delay);
 82   bool        should_inline(ciMethod* callee_method,
 83                             ciMethod* caller_method,
 84                             int caller_bci,
 85                             ciCallProfile&amp; profile,
 86                             WarmCallInfo* wci_result);
 87   bool        should_not_inline(ciMethod* callee_method,
 88                                 ciMethod* caller_method,
 89                                 JVMState* jvms,
 90                                 WarmCallInfo* wci_result);
<span class="line-added"> 91   bool        is_not_reached(ciMethod* callee_method,</span>
<span class="line-added"> 92                              ciMethod* caller_method,</span>
<span class="line-added"> 93                              int caller_bci,</span>
<span class="line-added"> 94                              ciCallProfile&amp; profile);</span>
 95   void        print_inlining(ciMethod* callee_method, int caller_bci,
 96                              ciMethod* caller_method, bool success) const;
 97 
 98   InlineTree* caller_tree()       const { return _caller_tree;  }
 99   InlineTree* callee_at(int bci, ciMethod* m) const;
100   int         inline_level()      const { return stack_depth(); }
101   int         stack_depth()       const { return _caller_jvms ? _caller_jvms-&gt;depth() : 0; }
102   const char* msg()               const { return _msg; }
103   void        set_msg(const char* msg)  { _msg = msg; }
104 public:
105   static const char* check_can_parse(ciMethod* callee);
106 
107   static InlineTree* build_inline_tree_root();
108   static InlineTree* find_subtree_from_root(InlineTree* root, JVMState* jvms, ciMethod* callee);
109 
110   // For temporary (stack-allocated, stateless) ilts:
111   InlineTree(Compile* c, ciMethod* callee_method, JVMState* caller_jvms, float site_invoke_ratio, int max_inline_level);
112 
113   // See if it is OK to inline.
114   // The receiver is the inline tree for the caller.
</pre>
<hr />
<pre>
463   // Merge the current mapping into an exception handler.
464   void merge_exception(int target_bci);
465   // Helper: Merge the current mapping into the given basic block
466   void merge_common(Block* target, int pnum);
467   // Helper functions for merging individual cells.
468   PhiNode *ensure_phi(       int idx, bool nocreate = false);
469   PhiNode *ensure_memory_phi(int idx, bool nocreate = false);
470   // Helper to merge the current memory state into the given basic block
471   void merge_memory_edges(MergeMemNode* n, int pnum, bool nophi);
472 
473   // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
474   void do_one_bytecode();
475 
476   // helper function to generate array store check
477   void array_store_check();
478   // Helper function to generate array load
479   void array_load(BasicType etype);
480   // Helper function to generate array store
481   void array_store(BasicType etype);
482   // Helper function to compute array addressing
<span class="line-modified">483   Node* array_addressing(BasicType type, int vals, const Type*&amp; elemtype);</span>
<span class="line-added">484 </span>
<span class="line-added">485   void clinit_deopt();</span>
486 
487   void rtm_deopt();
488 
489   // Pass current map to exits
490   void return_current(Node* value);
491 
492   // Register finalizers on return from Object.&lt;init&gt;
493   void call_register_finalizer();
494 
495   // Insert a compiler safepoint into the graph
496   void add_safepoint();
497 
498   // Insert a compiler safepoint into the graph, if there is a back-branch.
499   void maybe_add_safepoint(int target_bci) {
500     if (UseLoopSafepoints &amp;&amp; target_bci &lt;= bci()) {
501       add_safepoint();
502     }
503   }
504 
505   // Note:  Intrinsic generation routines may be found in library_call.cpp.
</pre>
<hr />
<pre>
515 
516   // Helper functions for type checking bytecodes:
517   void  do_checkcast();
518   void  do_instanceof();
519 
520   // Helper functions for shifting &amp; arithmetic
521   void modf();
522   void modd();
523   void l2f();
524 
525   void do_irem();
526 
527   // implementation of _get* and _put* bytecodes
528   void do_getstatic() { do_field_access(true,  false); }
529   void do_getfield () { do_field_access(true,  true); }
530   void do_putstatic() { do_field_access(false, false); }
531   void do_putfield () { do_field_access(false, true); }
532 
533   // common code for making initial checks and forming addresses
534   void do_field_access(bool is_get, bool is_field);

535 
536   // common code for actually performing the load or store
537   void do_get_xxx(Node* obj, ciField* field, bool is_field);
538   void do_put_xxx(Node* obj, ciField* field, bool is_field);
539 
540   // implementation of object creation bytecodes

541   void do_new();
542   void do_newarray(BasicType elemtype);
543   void do_anewarray();
544   void do_multianewarray();
545   Node* expand_multianewarray(ciArrayKlass* array_klass, Node* *lengths, int ndimensions, int nargs);
546 
547   // implementation of jsr/ret
548   void do_jsr();
549   void do_ret();
550 
551   float   dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test);
552   float   branch_prediction(float &amp;cnt, BoolTest::mask btest, int target_bci, Node* test);
553   bool    seems_never_taken(float prob) const;
554   bool    path_is_suitable_for_uncommon_trap(float prob) const;
555   bool    seems_stable_comparison() const;
556 
557   void    do_ifnull(BoolTest::mask btest, Node* c);
558   void    do_if(BoolTest::mask btest, Node* c);
559   int     repush_if_args();
560   void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,
</pre>
</td>
</tr>
</table>
<center><a href="output.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
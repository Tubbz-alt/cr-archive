<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="superword.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;oops/typeArrayKlass.hpp&quot;
  #include &quot;opto/matcher.hpp&quot;
  #include &quot;opto/node.hpp&quot;
  #include &quot;opto/opcodes.hpp&quot;
  #include &quot;opto/type.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // Portions of code courtesy of Clifford Click
  
  // Optimization - Graph Style
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,11 ***</span>
    const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
                                              stable_dimension, is_narrow_oop,
                                              field-&gt;is_autobox_cache());
    if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
      ciCallSite* call_site = holder-&gt;as_call_site();
<span class="line-modified">!     if (!call_site-&gt;is_constant_call_site()) {</span>
        ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
        Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
      }
    }
    return con_type;
<span class="line-new-header">--- 374,11 ---</span>
    const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
                                              stable_dimension, is_narrow_oop,
                                              field-&gt;is_autobox_cache());
    if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
      ciCallSite* call_site = holder-&gt;as_call_site();
<span class="line-modified">!     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {</span>
        ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
        Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
      }
    }
    return con_type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,22 ***</span>
  int Type::uhash( const Type *const t ) {
    return t-&gt;hash();
  }
  
  #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
<span class="line-modified">! </span>
<span class="line-modified">! static double pos_dinf() {</span>
<span class="line-removed">-   union { int64_t i; double d; } v;</span>
<span class="line-removed">-   v.i = CONST64(0x7ff0000000000000);</span>
<span class="line-removed">-   return v.d;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static float pos_finf() {</span>
<span class="line-removed">-   union { int32_t i; float f; } v;</span>
<span class="line-removed">-   v.i = 0x7f800000;</span>
<span class="line-removed">-   return v.f;</span>
<span class="line-removed">- }</span>
  
  //--------------------------Initialize_shared----------------------------------
  void Type::Initialize_shared(Compile* current) {
    // This method does not need to be locked because the first system
    // compilations (stub compilations) occur serially.  If they are
<span class="line-new-header">--- 410,12 ---</span>
  int Type::uhash( const Type *const t ) {
    return t-&gt;hash();
  }
  
  #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
<span class="line-modified">! #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite</span>
<span class="line-modified">! #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite</span>
  
  //--------------------------Initialize_shared----------------------------------
  void Type::Initialize_shared(Compile* current) {
    // This method does not need to be locked because the first system
    // compilations (stub compilations) occur serially.  If they are
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,17 ***</span>
    BOTTOM  = make(Bottom);       // Everything
    HALF    = make(Half);         // Placeholder half of doublewide type
  
    TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
    TypeF::ONE  = TypeF::make(1.0); // Float 1
<span class="line-modified">!   TypeF::POS_INF = TypeF::make(pos_finf());</span>
<span class="line-modified">!   TypeF::NEG_INF = TypeF::make(-pos_finf());</span>
  
    TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
    TypeD::ONE  = TypeD::make(1.0); // Double 1
<span class="line-modified">!   TypeD::POS_INF = TypeD::make(pos_dinf());</span>
<span class="line-modified">!   TypeD::NEG_INF = TypeD::make(-pos_dinf());</span>
  
    TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
    TypeInt::ZERO    = TypeInt::make( 0);  //  0
    TypeInt::ONE     = TypeInt::make( 1);  //  1
    TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
<span class="line-new-header">--- 442,17 ---</span>
    BOTTOM  = make(Bottom);       // Everything
    HALF    = make(Half);         // Placeholder half of doublewide type
  
    TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
    TypeF::ONE  = TypeF::make(1.0); // Float 1
<span class="line-modified">!   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));</span>
<span class="line-modified">!   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));</span>
  
    TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
    TypeD::ONE  = TypeD::make(1.0); // Double 1
<span class="line-modified">!   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));</span>
<span class="line-modified">!   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));</span>
  
    TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
    TypeInt::ZERO    = TypeInt::make( 0);  //  0
    TypeInt::ONE     = TypeInt::make( 1);  //  1
    TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,12 ***</span>
  
    // Every type has a dual (to make my lattice symmetric).
    // Since we just discovered a new Type, compute its dual right now.
    assert( !_dual, &quot;&quot; );         // No dual yet
    _dual = xdual();              // Compute the dual
<span class="line-modified">!   if( cmp(this,_dual)==0 ) {    // Handle self-symmetric</span>
<span class="line-modified">!     _dual = this;</span>
      return this;
    }
    assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
    assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
    // New Type, insert into Type table
<span class="line-new-header">--- 719,15 ---</span>
  
    // Every type has a dual (to make my lattice symmetric).
    // Since we just discovered a new Type, compute its dual right now.
    assert( !_dual, &quot;&quot; );         // No dual yet
    _dual = xdual();              // Compute the dual
<span class="line-modified">!   if (cmp(this, _dual) == 0) {  // Handle self-symmetric</span>
<span class="line-modified">!     if (_dual != this) {</span>
<span class="line-added">+       delete _dual;</span>
<span class="line-added">+       _dual = this;</span>
<span class="line-added">+     }</span>
      return this;
    }
    assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
    assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
    // New Type, insert into Type table
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2107,11 ***</span>
  
    case Array: {                 // Meeting 2 arrays?
      const TypeAry *a = t-&gt;is_ary();
      return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
                           _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">!                          _stable &amp; a-&gt;_stable);</span>
    }
    case Top:
      break;
    }
    return this;                  // Return the double constant
<span class="line-new-header">--- 2101,11 ---</span>
  
    case Array: {                 // Meeting 2 arrays?
      const TypeAry *a = t-&gt;is_ary();
      return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
                           _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
<span class="line-modified">!                          _stable &amp;&amp; a-&gt;_stable);</span>
    }
    case Top:
      break;
    }
    return this;                  // Return the double constant
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3009,19 ***</span>
            assert(o != NULL, &quot;must be constant&quot;);
            ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
            ciField* field = k-&gt;get_field_by_offset(_offset, true);
            assert(field != NULL, &quot;missing field&quot;);
            BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">!           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||</span>
<span class="line-removed">-                                                        basic_elem_type == T_ARRAY);</span>
          } else {
            // Instance fields which contains a compressed oop references.
            field = ik-&gt;get_field_by_offset(_offset, false);
            if (field != NULL) {
              BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">!             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||</span>
<span class="line-removed">-                                                          basic_elem_type == T_ARRAY);</span>
            } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
              // Compile::find_alias_type() cast exactness on all types to verify
              // that it does not affect alias type.
              _is_ptr_to_narrowoop = UseCompressedOops;
            } else {
<span class="line-new-header">--- 3003,17 ---</span>
            assert(o != NULL, &quot;must be constant&quot;);
            ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
            ciField* field = k-&gt;get_field_by_offset(_offset, true);
            assert(field != NULL, &quot;missing field&quot;);
            BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">!           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);</span>
          } else {
            // Instance fields which contains a compressed oop references.
            field = ik-&gt;get_field_by_offset(_offset, false);
            if (field != NULL) {
              BasicType basic_elem_type = field-&gt;layout_type();
<span class="line-modified">!             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);</span>
            } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
              // Compile::find_alias_type() cast exactness on all types to verify
              // that it does not affect alias type.
              _is_ptr_to_narrowoop = UseCompressedOops;
            } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3058,14 ***</span>
    // There are no instances of a general oop.
    // Return self unchanged.
    return this;
  }
  
<span class="line-removed">- const TypeOopPtr *TypeOopPtr::cast_to_nonconst() const {</span>
<span class="line-removed">-   return this;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //-----------------------------cast_to_exactness-------------------------------
  const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
    // There is no such thing as an exact general oop.
    // Return self unchanged.
    return this;
<span class="line-new-header">--- 3050,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3568,15 ***</span>
  const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
    return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
  }
  
<span class="line-removed">- const TypeOopPtr *TypeInstPtr::cast_to_nonconst() const {</span>
<span class="line-removed">-   if (const_oop() == NULL) return this;</span>
<span class="line-removed">-   return make(NotNull, klass(), _klass_is_exact, NULL, _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //------------------------------xmeet_unloaded---------------------------------
  // Compute the MEET of two InstPtrs when at least one is unloaded.
  // Assume classes are different since called after check for same name/class-loader
  const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
      int off = meet_offset(tinst-&gt;offset());
<span class="line-new-header">--- 3556,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3877,11 ***</span>
      // Check for subtyping:
      ciKlass *subtype = NULL;
      bool subtype_exact = false;
      if( tinst_klass-&gt;equals(this_klass) ) {
        subtype = this_klass;
<span class="line-modified">!       subtype_exact = below_centerline(ptr) ? (this_xk &amp; tinst_xk) : (this_xk | tinst_xk);</span>
      } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
        subtype = this_klass;     // Pick subtyping class
        subtype_exact = this_xk;
      } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
        subtype = tinst_klass;    // Pick subtyping class
<span class="line-new-header">--- 3860,11 ---</span>
      // Check for subtyping:
      ciKlass *subtype = NULL;
      bool subtype_exact = false;
      if( tinst_klass-&gt;equals(this_klass) ) {
        subtype = this_klass;
<span class="line-modified">!       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);</span>
      } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
        subtype = this_klass;     // Pick subtyping class
        subtype_exact = this_xk;
      } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
        subtype = tinst_klass;    // Pick subtyping class
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4105,42 ***</span>
  const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
    return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
  }
  
<span class="line-removed">- const TypeOopPtr *TypeAryPtr::cast_to_nonconst() const {</span>
<span class="line-removed">-   if (const_oop() == NULL) return this;</span>
<span class="line-removed">-   return make(NotNull, NULL, _ary, klass(), _klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! </span>
<span class="line-modified">! //-----------------------------narrow_size_type-------------------------------</span>
<span class="line-modified">! // Local cache for arrayOopDesc::max_array_length(etype),</span>
<span class="line-modified">! // which is kind of slow (and cached elsewhere by other users).</span>
<span class="line-modified">! static jint max_array_length_cache[T_CONFLICT+1];</span>
<span class="line-removed">- static jint max_array_length(BasicType etype) {</span>
<span class="line-removed">-   jint&amp; cache = max_array_length_cache[etype];</span>
<span class="line-removed">-   jint res = cache;</span>
<span class="line-removed">-   if (res == 0) {</span>
<span class="line-removed">-     switch (etype) {</span>
<span class="line-removed">-     case T_NARROWOOP:</span>
        etype = T_OBJECT;
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case T_NARROWKLASS:</span>
<span class="line-modified">!     case T_CONFLICT:</span>
<span class="line-modified">!     case T_ILLEGAL:</span>
<span class="line-removed">-     case T_VOID:</span>
<span class="line-removed">-       etype = T_BYTE;           // will produce conservatively high value</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       break;</span>
      }
<span class="line-removed">-     cache = res = arrayOopDesc::max_array_length(etype);</span>
    }
<span class="line-modified">!   return res;</span>
  }
  
  // Narrow the given size type to the index range for the given array base type.
  // Return NULL if the resulting int type becomes empty.
  const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
    jint hi = size-&gt;_hi;
    jint lo = size-&gt;_lo;
<span class="line-new-header">--- 4088,27 ---</span>
  const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
    if( instance_id == _instance_id ) return this;
    return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
  }
  
  
<span class="line-modified">! //-----------------------------max_array_length-------------------------------</span>
<span class="line-modified">! // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.</span>
<span class="line-modified">! jint TypeAryPtr::max_array_length(BasicType etype) {</span>
<span class="line-modified">!   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {</span>
<span class="line-modified">!     if (etype == T_NARROWOOP) {</span>
        etype = T_OBJECT;
<span class="line-modified">!     } else if (etype == T_ILLEGAL) { // bottom[]</span>
<span class="line-modified">!       etype = T_BYTE; // will produce conservatively high value</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       fatal(&quot;not an element type: %s&quot;, type2name(etype));</span>
      }
    }
<span class="line-modified">!   return arrayOopDesc::max_array_length(etype);</span>
  }
  
<span class="line-added">+ //-----------------------------narrow_size_type-------------------------------</span>
  // Narrow the given size type to the index range for the given array base type.
  // Return NULL if the resulting int type becomes empty.
  const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
    jint hi = size-&gt;_hi;
    jint lo = size-&gt;_lo;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4359,11 ***</span>
      case TopPTR:
        // Compute new klass on demand, do not use tap-&gt;_klass
        if (below_centerline(this-&gt;_ptr)) {
          xk = this-&gt;_klass_is_exact;
        } else {
<span class="line-modified">!         xk = (tap-&gt;_klass_is_exact | this-&gt;_klass_is_exact);</span>
        }
        return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
      case Constant: {
        ciObject* o = const_oop();
        if( _ptr == Constant ) {
<span class="line-new-header">--- 4327,11 ---</span>
      case TopPTR:
        // Compute new klass on demand, do not use tap-&gt;_klass
        if (below_centerline(this-&gt;_ptr)) {
          xk = this-&gt;_klass_is_exact;
        } else {
<span class="line-modified">!         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);</span>
        }
        return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
      case Constant: {
        ciObject* o = const_oop();
        if( _ptr == Constant ) {
</pre>
<center><a href="superword.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
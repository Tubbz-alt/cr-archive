<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 
  43 // Portions of code courtesy of Clifford Click
  44 
  45 // Optimization - Graph Style
  46 
  47 // Dictionary of types shared among compilations.
  48 Dict* Type::_shared_type_dict = NULL;
  49 
  50 // Array which maps compiler types to Basic Types
  51 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  52   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  53   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  54   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  55   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  56   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  57   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  58   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  59   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  60   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  61   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  62 
  63 #ifdef SPARC
  64   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  65   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
  66   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  67   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  68   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  69 #elif defined(PPC64)
  70   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  71   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  72   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  73   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  74   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  75 #elif defined(S390)
  76   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  77   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  78   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  79   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  80   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  81 #else // all other
  82   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  83   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  84   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  85   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  86   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  87 #endif
  88   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  89   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  90   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  91   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  92   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  93   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  94   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  95   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  96   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  97   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  98   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
  99   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 100   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 101   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 102   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 103   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 104   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 105   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 106 };
 107 
 108 // Map ideal registers (machine types) to ideal types
 109 const Type *Type::mreg2type[_last_machine_leaf];
 110 
 111 // Map basic types to canonical Type* pointers.
 112 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 113 
 114 // Map basic types to constant-zero Types.
 115 const Type* Type::            _zero_type[T_CONFLICT+1];
 116 
 117 // Map basic types to array-body alias types.
 118 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 119 
 120 //=============================================================================
 121 // Convenience common pre-built types.
 122 const Type *Type::ABIO;         // State-of-machine only
 123 const Type *Type::BOTTOM;       // All values
 124 const Type *Type::CONTROL;      // Control only
 125 const Type *Type::DOUBLE;       // All doubles
 126 const Type *Type::FLOAT;        // All floats
 127 const Type *Type::HALF;         // Placeholder half of doublewide type
 128 const Type *Type::MEMORY;       // Abstract store only
 129 const Type *Type::RETURN_ADDRESS;
 130 const Type *Type::TOP;          // No values in set
 131 
 132 //------------------------------get_const_type---------------------------
 133 const Type* Type::get_const_type(ciType* type) {
 134   if (type == NULL) {
 135     return NULL;
 136   } else if (type-&gt;is_primitive_type()) {
 137     return get_const_basic_type(type-&gt;basic_type());
 138   } else {
 139     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 140   }
 141 }
 142 
 143 //---------------------------array_element_basic_type---------------------------------
 144 // Mapping to the array element&#39;s basic type.
 145 BasicType Type::array_element_basic_type() const {
 146   BasicType bt = basic_type();
 147   if (bt == T_INT) {
 148     if (this == TypeInt::INT)   return T_INT;
 149     if (this == TypeInt::CHAR)  return T_CHAR;
 150     if (this == TypeInt::BYTE)  return T_BYTE;
 151     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 152     if (this == TypeInt::SHORT) return T_SHORT;
 153     return T_VOID;
 154   }
 155   return bt;
 156 }
 157 
 158 // For two instance arrays of same dimension, return the base element types.
 159 // Otherwise or if the arrays have different dimensions, return NULL.
 160 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 161                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 162 
 163   if (e1) *e1 = NULL;
 164   if (e2) *e2 = NULL;
 165   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 166   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 167 
 168   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 169     // Handle multidimensional arrays
 170     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 171     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 172     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 173       a1tap = a1tp-&gt;is_aryptr();
 174       a2tap = a2tp-&gt;is_aryptr();
 175       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 176       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 177     }
 178     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 179       if (e1) *e1 = a1tp-&gt;is_instptr();
 180       if (e2) *e2 = a2tp-&gt;is_instptr();
 181     }
 182   }
 183 }
 184 
 185 //---------------------------get_typeflow_type---------------------------------
 186 // Import a type produced by ciTypeFlow.
 187 const Type* Type::get_typeflow_type(ciType* type) {
 188   switch (type-&gt;basic_type()) {
 189 
 190   case ciTypeFlow::StateVector::T_BOTTOM:
 191     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 192     return Type::BOTTOM;
 193 
 194   case ciTypeFlow::StateVector::T_TOP:
 195     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 196     return Type::TOP;
 197 
 198   case ciTypeFlow::StateVector::T_NULL:
 199     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 200     return TypePtr::NULL_PTR;
 201 
 202   case ciTypeFlow::StateVector::T_LONG2:
 203     // The ciTypeFlow pass pushes a long, then the half.
 204     // We do the same.
 205     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 206     return TypeInt::TOP;
 207 
 208   case ciTypeFlow::StateVector::T_DOUBLE2:
 209     // The ciTypeFlow pass pushes double, then the half.
 210     // Our convention is the same.
 211     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 212     return Type::TOP;
 213 
 214   case T_ADDRESS:
 215     assert(type-&gt;is_return_address(), &quot;&quot;);
 216     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 217 
 218   default:
 219     // make sure we did not mix up the cases:
 220     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 221     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 222     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 223     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 224     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 225     assert(!type-&gt;is_return_address(), &quot;&quot;);
 226 
 227     return Type::get_const_type(type);
 228   }
 229 }
 230 
 231 
 232 //-----------------------make_from_constant------------------------------------
 233 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 234                                      int stable_dimension, bool is_narrow_oop,
 235                                      bool is_autobox_cache) {
 236   switch (constant.basic_type()) {
 237     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 238     case T_CHAR:     return TypeInt::make(constant.as_char());
 239     case T_BYTE:     return TypeInt::make(constant.as_byte());
 240     case T_SHORT:    return TypeInt::make(constant.as_short());
 241     case T_INT:      return TypeInt::make(constant.as_int());
 242     case T_LONG:     return TypeLong::make(constant.as_long());
 243     case T_FLOAT:    return TypeF::make(constant.as_float());
 244     case T_DOUBLE:   return TypeD::make(constant.as_double());
 245     case T_ARRAY:
 246     case T_OBJECT: {
 247         const Type* con_type = NULL;
 248         ciObject* oop_constant = constant.as_object();
 249         if (oop_constant-&gt;is_null_object()) {
 250           con_type = Type::get_zero_type(T_OBJECT);
 251         } else {
 252           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 253           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 254           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 255             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 256           }
 257           if (stable_dimension &gt; 0) {
 258             assert(FoldStableValues, &quot;sanity&quot;);
 259             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 260             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 261           }
 262         }
 263         if (is_narrow_oop) {
 264           con_type = con_type-&gt;make_narrowoop();
 265         }
 266         return con_type;
 267       }
 268     case T_ILLEGAL:
 269       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 270       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 271       return NULL;
 272     default:
 273       // Fall through to failure
 274       return NULL;
 275   }
 276 }
 277 
 278 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 279   BasicType conbt = con.basic_type();
 280   switch (conbt) {
 281     case T_BOOLEAN: conbt = T_BYTE;   break;
 282     case T_ARRAY:   conbt = T_OBJECT; break;
 283     default:                          break;
 284   }
 285   switch (loadbt) {
 286     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 287     case T_NARROWOOP: loadbt = T_OBJECT; break;
 288     case T_ARRAY:     loadbt = T_OBJECT; break;
 289     case T_ADDRESS:   loadbt = T_OBJECT; break;
 290     default:                             break;
 291   }
 292   if (conbt == loadbt) {
 293     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 294       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 295       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 296     } else {
 297       return con;
 298     }
 299   }
 300   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 301     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 302     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 303   }
 304   return ciConstant(); // T_ILLEGAL
 305 }
 306 
 307 // Try to constant-fold a stable array element.
 308 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 309                                                    BasicType loadbt, bool is_unsigned_load) {
 310   // Decode the results of GraphKit::array_element_address.
 311   ciConstant element_value = array-&gt;element_value_by_offset(off);
 312   if (element_value.basic_type() == T_ILLEGAL) {
 313     return NULL; // wrong offset
 314   }
 315   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 316 
 317   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 318          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 319 
 320   if (con.is_valid() &amp;&amp;          // not a mismatched access
 321       !con.is_null_or_zero()) {  // not a default value
 322     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 323     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 324   }
 325   return NULL;
 326 }
 327 
 328 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 329   ciField* field;
 330   ciType* type = holder-&gt;java_mirror_type();
 331   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 332     // Static field
 333     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 334   } else {
 335     // Instance field
 336     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 337   }
 338   if (field == NULL) {
 339     return NULL; // Wrong offset
 340   }
 341   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 342 }
 343 
 344 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 345                                            BasicType loadbt, bool is_unsigned_load) {
 346   if (!field-&gt;is_constant()) {
 347     return NULL; // Non-constant field
 348   }
 349   ciConstant field_value;
 350   if (field-&gt;is_static()) {
 351     // final static field
 352     field_value = field-&gt;constant_value();
 353   } else if (holder != NULL) {
 354     // final or stable non-static field
 355     // Treat final non-static fields of trusted classes (classes in
 356     // java.lang.invoke and sun.invoke packages and subpackages) as
 357     // compile time constants.
 358     field_value = field-&gt;constant_value_of(holder);
 359   }
 360   if (!field_value.is_valid()) {
 361     return NULL; // Not a constant
 362   }
 363 
 364   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 365 
 366   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 367          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 368 
 369   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 370   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 371   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 372 
 373   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 374                                             stable_dimension, is_narrow_oop,
 375                                             field-&gt;is_autobox_cache());
 376   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 377     ciCallSite* call_site = holder-&gt;as_call_site();
 378     if (!call_site-&gt;is_constant_call_site()) {
 379       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 380       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 381     }
 382   }
 383   return con_type;
 384 }
 385 
 386 //------------------------------make-------------------------------------------
 387 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 388 // and look for an existing copy in the type dictionary.
 389 const Type *Type::make( enum TYPES t ) {
 390   return (new Type(t))-&gt;hashcons();
 391 }
 392 
 393 //------------------------------cmp--------------------------------------------
 394 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 395   if( t1-&gt;_base != t2-&gt;_base )
 396     return 1;                   // Missed badly
 397   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 398   return !t1-&gt;eq(t2);           // Return ZERO if equal
 399 }
 400 
 401 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 402   if (!include_speculative) {
 403     return remove_speculative();
 404   }
 405   return this;
 406 }
 407 
 408 //------------------------------hash-------------------------------------------
 409 int Type::uhash( const Type *const t ) {
 410   return t-&gt;hash();
 411 }
 412 
 413 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 414 
 415 static double pos_dinf() {
 416   union { int64_t i; double d; } v;
 417   v.i = CONST64(0x7ff0000000000000);
 418   return v.d;
 419 }
 420 
 421 static float pos_finf() {
 422   union { int32_t i; float f; } v;
 423   v.i = 0x7f800000;
 424   return v.f;
 425 }
 426 
 427 //--------------------------Initialize_shared----------------------------------
 428 void Type::Initialize_shared(Compile* current) {
 429   // This method does not need to be locked because the first system
 430   // compilations (stub compilations) occur serially.  If they are
 431   // changed to proceed in parallel, then this section will need
 432   // locking.
 433 
 434   Arena* save = current-&gt;type_arena();
 435   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 436 
 437   current-&gt;set_type_arena(shared_type_arena);
 438   _shared_type_dict =
 439     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 440                                   shared_type_arena, 128 );
 441   current-&gt;set_type_dict(_shared_type_dict);
 442 
 443   // Make shared pre-built types.
 444   CONTROL = make(Control);      // Control only
 445   TOP     = make(Top);          // No values in set
 446   MEMORY  = make(Memory);       // Abstract store only
 447   ABIO    = make(Abio);         // State-of-machine only
 448   RETURN_ADDRESS=make(Return_Address);
 449   FLOAT   = make(FloatBot);     // All floats
 450   DOUBLE  = make(DoubleBot);    // All doubles
 451   BOTTOM  = make(Bottom);       // Everything
 452   HALF    = make(Half);         // Placeholder half of doublewide type
 453 
 454   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 455   TypeF::ONE  = TypeF::make(1.0); // Float 1
 456   TypeF::POS_INF = TypeF::make(pos_finf());
 457   TypeF::NEG_INF = TypeF::make(-pos_finf());
 458 
 459   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 460   TypeD::ONE  = TypeD::make(1.0); // Double 1
 461   TypeD::POS_INF = TypeD::make(pos_dinf());
 462   TypeD::NEG_INF = TypeD::make(-pos_dinf());
 463 
 464   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 465   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 466   TypeInt::ONE     = TypeInt::make( 1);  //  1
 467   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 468   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 469   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 470   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 471   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 472   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 473   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 474   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 475   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 476   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 477   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 478   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 479   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 480   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 481   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 482   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 483   // CmpL is overloaded both as the bytecode computation returning
 484   // a trinary (-1,0,+1) integer result AND as an efficient long
 485   // compare returning optimizer ideal-type flags.
 486   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 487   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 488   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 489   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 490   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 491 
 492   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 493   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 494   TypeLong::ONE     = TypeLong::make( 1);        //  1
 495   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 496   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 497   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 498   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 499   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 500 
 501   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 502   fboth[0] = Type::CONTROL;
 503   fboth[1] = Type::CONTROL;
 504   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 505 
 506   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 507   ffalse[0] = Type::CONTROL;
 508   ffalse[1] = Type::TOP;
 509   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 510 
 511   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 512   fneither[0] = Type::TOP;
 513   fneither[1] = Type::TOP;
 514   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 515 
 516   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 517   ftrue[0] = Type::TOP;
 518   ftrue[1] = Type::CONTROL;
 519   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 520 
 521   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 522   floop[0] = Type::CONTROL;
 523   floop[1] = TypeInt::INT;
 524   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 525 
 526   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);
 527   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);
 528   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);
 529 
 530   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 531   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 532 
 533   const Type **fmembar = TypeTuple::fields(0);
 534   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 535 
 536   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 537   fsc[0] = TypeInt::CC;
 538   fsc[1] = Type::MEMORY;
 539   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 540 
 541   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 542   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 543   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 544   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 545                                            false, 0, oopDesc::mark_offset_in_bytes());
 546   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 547                                            false, 0, oopDesc::klass_offset_in_bytes());
 548   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);
 549 
 550   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);
 551 
 552   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 553   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 554 
 555   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 556 
 557   mreg2type[Op_Node] = Type::BOTTOM;
 558   mreg2type[Op_Set ] = 0;
 559   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 560   mreg2type[Op_RegI] = TypeInt::INT;
 561   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 562   mreg2type[Op_RegF] = Type::FLOAT;
 563   mreg2type[Op_RegD] = Type::DOUBLE;
 564   mreg2type[Op_RegL] = TypeLong::LONG;
 565   mreg2type[Op_RegFlags] = TypeInt::CC;
 566 
 567   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());
 568 
 569   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 570 
 571 #ifdef _LP64
 572   if (UseCompressedOops) {
 573     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 574     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 575   } else
 576 #endif
 577   {
 578     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 579     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 580   }
 581   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);
 582   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);
 583   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);
 584   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);
 585   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);
 586   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);
 587   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);
 588 
 589   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 590   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 591   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 592   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 593   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 594   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 595   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 596   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 597   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 598   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 599   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 600   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 601 
 602   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );
 603   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );
 604 
 605   const Type **fi2c = TypeTuple::fields(2);
 606   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 607   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 608   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 609 
 610   const Type **intpair = TypeTuple::fields(2);
 611   intpair[0] = TypeInt::INT;
 612   intpair[1] = TypeInt::INT;
 613   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 614 
 615   const Type **longpair = TypeTuple::fields(2);
 616   longpair[0] = TypeLong::LONG;
 617   longpair[1] = TypeLong::LONG;
 618   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 619 
 620   const Type **intccpair = TypeTuple::fields(2);
 621   intccpair[0] = TypeInt::INT;
 622   intccpair[1] = TypeInt::CC;
 623   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 624 
 625   const Type **longccpair = TypeTuple::fields(2);
 626   longccpair[0] = TypeLong::LONG;
 627   longccpair[1] = TypeInt::CC;
 628   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 629 
 630   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 631   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 632   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 633   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 634   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 635   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 636   _const_basic_type[T_INT]         = TypeInt::INT;
 637   _const_basic_type[T_LONG]        = TypeLong::LONG;
 638   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 639   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 640   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 641   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 642   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 643   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 644   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 645 
 646   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 647   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 648   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 649   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 650   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 651   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 652   _zero_type[T_INT]         = TypeInt::ZERO;
 653   _zero_type[T_LONG]        = TypeLong::ZERO;
 654   _zero_type[T_FLOAT]       = TypeF::ZERO;
 655   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 656   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 657   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 658   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 659   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 660 
 661   // get_zero_type() should not happen for T_CONFLICT
 662   _zero_type[T_CONFLICT]= NULL;
 663 
 664   // Vector predefined types, it needs initialized _const_basic_type[].
 665   if (Matcher::vector_size_supported(T_BYTE,4)) {
 666     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 667   }
 668   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 669     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 670   }
 671   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 672     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 673   }
 674   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 675     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 676   }
 677   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 678     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 679   }
 680   mreg2type[Op_VecS] = TypeVect::VECTS;
 681   mreg2type[Op_VecD] = TypeVect::VECTD;
 682   mreg2type[Op_VecX] = TypeVect::VECTX;
 683   mreg2type[Op_VecY] = TypeVect::VECTY;
 684   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 685 
 686   // Restore working type arena.
 687   current-&gt;set_type_arena(save);
 688   current-&gt;set_type_dict(NULL);
 689 }
 690 
 691 //------------------------------Initialize-------------------------------------
 692 void Type::Initialize(Compile* current) {
 693   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 694 
 695   if (_shared_type_dict == NULL) {
 696     Initialize_shared(current);
 697   }
 698 
 699   Arena* type_arena = current-&gt;type_arena();
 700 
 701   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 702   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 703   current-&gt;set_type_dict(tdic);
 704 
 705   // Transfer the shared types.
 706   DictI i(_shared_type_dict);
 707   for( ; i.test(); ++i ) {
 708     Type* t = (Type*)i._value;
 709     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 710   }
 711 }
 712 
 713 //------------------------------hashcons---------------------------------------
 714 // Do the hash-cons trick.  If the Type already exists in the type table,
 715 // delete the current Type and return the existing Type.  Otherwise stick the
 716 // current Type in the Type table.
 717 const Type *Type::hashcons(void) {
 718   debug_only(base());           // Check the assertion in Type::base().
 719   // Look up the Type in the Type dictionary
 720   Dict *tdic = type_dict();
 721   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 722   if( old ) {                   // Pre-existing Type?
 723     if( old != this )           // Yes, this guy is not the pre-existing?
 724       delete this;              // Yes, Nuke this guy
 725     assert( old-&gt;_dual, &quot;&quot; );
 726     return old;                 // Return pre-existing
 727   }
 728 
 729   // Every type has a dual (to make my lattice symmetric).
 730   // Since we just discovered a new Type, compute its dual right now.
 731   assert( !_dual, &quot;&quot; );         // No dual yet
 732   _dual = xdual();              // Compute the dual
 733   if( cmp(this,_dual)==0 ) {    // Handle self-symmetric
 734     _dual = this;
 735     return this;
 736   }
 737   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 738   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 739   // New Type, insert into Type table
 740   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 741   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 742 #ifdef ASSERT
 743   Type *dual_dual = (Type*)_dual-&gt;xdual();
 744   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 745   delete dual_dual;
 746 #endif
 747   return this;                  // Return new Type
 748 }
 749 
 750 //------------------------------eq---------------------------------------------
 751 // Structural equality check for Type representations
 752 bool Type::eq( const Type * ) const {
 753   return true;                  // Nothing else can go wrong
 754 }
 755 
 756 //------------------------------hash-------------------------------------------
 757 // Type-specific hashing function.
 758 int Type::hash(void) const {
 759   return _base;
 760 }
 761 
 762 //------------------------------is_finite--------------------------------------
 763 // Has a finite value
 764 bool Type::is_finite() const {
 765   return false;
 766 }
 767 
 768 //------------------------------is_nan-----------------------------------------
 769 // Is not a number (NaN)
 770 bool Type::is_nan()    const {
 771   return false;
 772 }
 773 
 774 //----------------------interface_vs_oop---------------------------------------
 775 #ifdef ASSERT
 776 bool Type::interface_vs_oop_helper(const Type *t) const {
 777   bool result = false;
 778 
 779   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 780   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 781   if( this_ptr == NULL || t_ptr == NULL )
 782     return result;
 783 
 784   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 785   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 786   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 787     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 788     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 789     result = this_interface ^ t_interface;
 790   }
 791 
 792   return result;
 793 }
 794 
 795 bool Type::interface_vs_oop(const Type *t) const {
 796   if (interface_vs_oop_helper(t)) {
 797     return true;
 798   }
 799   // Now check the speculative parts as well
 800   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 801   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 802   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 803     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 804       return true;
 805     }
 806     return false;
 807   }
 808   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 809     return true;
 810   }
 811   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 812     return true;
 813   }
 814   return false;
 815 }
 816 
 817 #endif
 818 
 819 //------------------------------meet-------------------------------------------
 820 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 821 // commutative and the lattice is symmetric.
 822 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 823   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 824     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 825     return result-&gt;make_narrowoop();
 826   }
 827   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 828     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 829     return result-&gt;make_narrowklass();
 830   }
 831 
 832   const Type *this_t = maybe_remove_speculative(include_speculative);
 833   t = t-&gt;maybe_remove_speculative(include_speculative);
 834 
 835   const Type *mt = this_t-&gt;xmeet(t);
 836   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 837   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 838 #ifdef ASSERT
 839   assert(mt == t-&gt;xmeet(this_t), &quot;meet not commutative&quot;);
 840   const Type* dual_join = mt-&gt;_dual;
 841   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 842   const Type *t2this = dual_join-&gt;xmeet(this_t-&gt;_dual);
 843 
 844   // Interface meet Oop is Not Symmetric:
 845   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 846   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 847 
 848   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this_t-&gt;_dual) ) {
 849     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 850     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 851     tty-&gt;print(&quot;this=                   &quot;);         this_t-&gt;dump(); tty-&gt;cr();
 852     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 853 
 854     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 855     tty-&gt;print(&quot;this_dual=              &quot;);  this_t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 856     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 857 
 858     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 859     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 860 
 861     fatal(&quot;meet not symmetric&quot; );
 862   }
 863 #endif
 864   return mt;
 865 }
 866 
 867 //------------------------------xmeet------------------------------------------
 868 // Compute the MEET of two types.  It returns a new Type object.
 869 const Type *Type::xmeet( const Type *t ) const {
 870   // Perform a fast test for common case; meeting the same types together.
 871   if( this == t ) return this;  // Meeting same type-rep?
 872 
 873   // Meeting TOP with anything?
 874   if( _base == Top ) return t;
 875 
 876   // Meeting BOTTOM with anything?
 877   if( _base == Bottom ) return BOTTOM;
 878 
 879   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 880   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 881   switch (t-&gt;base()) {  // Switch on original type
 882 
 883   // Cut in half the number of cases I must handle.  Only need cases for when
 884   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 885   case FloatCon:
 886   case DoubleCon:
 887   case Int:
 888   case Long:
 889     return t-&gt;xmeet(this);
 890 
 891   case OopPtr:
 892     return t-&gt;xmeet(this);
 893 
 894   case InstPtr:
 895     return t-&gt;xmeet(this);
 896 
 897   case MetadataPtr:
 898   case KlassPtr:
 899     return t-&gt;xmeet(this);
 900 
 901   case AryPtr:
 902     return t-&gt;xmeet(this);
 903 
 904   case NarrowOop:
 905     return t-&gt;xmeet(this);
 906 
 907   case NarrowKlass:
 908     return t-&gt;xmeet(this);
 909 
 910   case Bad:                     // Type check
 911   default:                      // Bogus type not in lattice
 912     typerr(t);
 913     return Type::BOTTOM;
 914 
 915   case Bottom:                  // Ye Olde Default
 916     return t;
 917 
 918   case FloatTop:
 919     if( _base == FloatTop ) return this;
 920   case FloatBot:                // Float
 921     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 922     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 923     typerr(t);
 924     return Type::BOTTOM;
 925 
 926   case DoubleTop:
 927     if( _base == DoubleTop ) return this;
 928   case DoubleBot:               // Double
 929     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 930     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 931     typerr(t);
 932     return Type::BOTTOM;
 933 
 934   // These next few cases must match exactly or it is a compile-time error.
 935   case Control:                 // Control of code
 936   case Abio:                    // State of world outside of program
 937   case Memory:
 938     if( _base == t-&gt;_base )  return this;
 939     typerr(t);
 940     return Type::BOTTOM;
 941 
 942   case Top:                     // Top of the lattice
 943     return this;
 944   }
 945 
 946   // The type is unchanged
 947   return this;
 948 }
 949 
 950 //-----------------------------filter------------------------------------------
 951 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
 952   const Type* ft = join_helper(kills, include_speculative);
 953   if (ft-&gt;empty())
 954     return Type::TOP;           // Canonical empty value
 955   return ft;
 956 }
 957 
 958 //------------------------------xdual------------------------------------------
 959 // Compute dual right now.
 960 const Type::TYPES Type::dual_type[Type::lastype] = {
 961   Bad,          // Bad
 962   Control,      // Control
 963   Bottom,       // Top
 964   Bad,          // Int - handled in v-call
 965   Bad,          // Long - handled in v-call
 966   Half,         // Half
 967   Bad,          // NarrowOop - handled in v-call
 968   Bad,          // NarrowKlass - handled in v-call
 969 
 970   Bad,          // Tuple - handled in v-call
 971   Bad,          // Array - handled in v-call
 972   Bad,          // VectorS - handled in v-call
 973   Bad,          // VectorD - handled in v-call
 974   Bad,          // VectorX - handled in v-call
 975   Bad,          // VectorY - handled in v-call
 976   Bad,          // VectorZ - handled in v-call
 977 
 978   Bad,          // AnyPtr - handled in v-call
 979   Bad,          // RawPtr - handled in v-call
 980   Bad,          // OopPtr - handled in v-call
 981   Bad,          // InstPtr - handled in v-call
 982   Bad,          // AryPtr - handled in v-call
 983 
 984   Bad,          //  MetadataPtr - handled in v-call
 985   Bad,          // KlassPtr - handled in v-call
 986 
 987   Bad,          // Function - handled in v-call
 988   Abio,         // Abio
 989   Return_Address,// Return_Address
 990   Memory,       // Memory
 991   FloatBot,     // FloatTop
 992   FloatCon,     // FloatCon
 993   FloatTop,     // FloatBot
 994   DoubleBot,    // DoubleTop
 995   DoubleCon,    // DoubleCon
 996   DoubleTop,    // DoubleBot
 997   Top           // Bottom
 998 };
 999 
1000 const Type *Type::xdual() const {
1001   // Note: the base() accessor asserts the sanity of _base.
1002   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1003   return new Type(_type_info[_base].dual_type);
1004 }
1005 
1006 //------------------------------has_memory-------------------------------------
1007 bool Type::has_memory() const {
1008   Type::TYPES tx = base();
1009   if (tx == Memory) return true;
1010   if (tx == Tuple) {
1011     const TypeTuple *t = is_tuple();
1012     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1013       tx = t-&gt;field_at(i)-&gt;base();
1014       if (tx == Memory)  return true;
1015     }
1016   }
1017   return false;
1018 }
1019 
1020 #ifndef PRODUCT
1021 //------------------------------dump2------------------------------------------
1022 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1023   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1024 }
1025 
1026 //------------------------------dump-------------------------------------------
1027 void Type::dump_on(outputStream *st) const {
1028   ResourceMark rm;
1029   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1030   dump2(d,1, st);
1031   if (is_ptr_to_narrowoop()) {
1032     st-&gt;print(&quot; [narrow]&quot;);
1033   } else if (is_ptr_to_narrowklass()) {
1034     st-&gt;print(&quot; [narrowklass]&quot;);
1035   }
1036 }
1037 
1038 //-----------------------------------------------------------------------------
1039 const char* Type::str(const Type* t) {
1040   stringStream ss;
1041   t-&gt;dump_on(&amp;ss);
1042   return ss.as_string();
1043 }
1044 #endif
1045 
1046 //------------------------------singleton--------------------------------------
1047 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1048 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1049 bool Type::singleton(void) const {
1050   return _base == Top || _base == Half;
1051 }
1052 
1053 //------------------------------empty------------------------------------------
1054 // TRUE if Type is a type with no values, FALSE otherwise.
1055 bool Type::empty(void) const {
1056   switch (_base) {
1057   case DoubleTop:
1058   case FloatTop:
1059   case Top:
1060     return true;
1061 
1062   case Half:
1063   case Abio:
1064   case Return_Address:
1065   case Memory:
1066   case Bottom:
1067   case FloatBot:
1068   case DoubleBot:
1069     return false;  // never a singleton, therefore never empty
1070 
1071   default:
1072     ShouldNotReachHere();
1073     return false;
1074   }
1075 }
1076 
1077 //------------------------------dump_stats-------------------------------------
1078 // Dump collected statistics to stderr
1079 #ifndef PRODUCT
1080 void Type::dump_stats() {
1081   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1082 }
1083 #endif
1084 
1085 //------------------------------typerr-----------------------------------------
1086 void Type::typerr( const Type *t ) const {
1087 #ifndef PRODUCT
1088   tty-&gt;print(&quot;\nError mixing types: &quot;);
1089   dump();
1090   tty-&gt;print(&quot; and &quot;);
1091   t-&gt;dump();
1092   tty-&gt;print(&quot;\n&quot;);
1093 #endif
1094   ShouldNotReachHere();
1095 }
1096 
1097 
1098 //=============================================================================
1099 // Convenience common pre-built types.
1100 const TypeF *TypeF::ZERO;       // Floating point zero
1101 const TypeF *TypeF::ONE;        // Floating point one
1102 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1103 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1104 
1105 //------------------------------make-------------------------------------------
1106 // Create a float constant
1107 const TypeF *TypeF::make(float f) {
1108   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1109 }
1110 
1111 //------------------------------meet-------------------------------------------
1112 // Compute the MEET of two types.  It returns a new Type object.
1113 const Type *TypeF::xmeet( const Type *t ) const {
1114   // Perform a fast test for common case; meeting the same types together.
1115   if( this == t ) return this;  // Meeting same type-rep?
1116 
1117   // Current &quot;this-&gt;_base&quot; is FloatCon
1118   switch (t-&gt;base()) {          // Switch on original type
1119   case AnyPtr:                  // Mixing with oops happens when javac
1120   case RawPtr:                  // reuses local variables
1121   case OopPtr:
1122   case InstPtr:
1123   case AryPtr:
1124   case MetadataPtr:
1125   case KlassPtr:
1126   case NarrowOop:
1127   case NarrowKlass:
1128   case Int:
1129   case Long:
1130   case DoubleTop:
1131   case DoubleCon:
1132   case DoubleBot:
1133   case Bottom:                  // Ye Olde Default
1134     return Type::BOTTOM;
1135 
1136   case FloatBot:
1137     return t;
1138 
1139   default:                      // All else is a mistake
1140     typerr(t);
1141 
1142   case FloatCon:                // Float-constant vs Float-constant?
1143     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1144                                 // must compare bitwise as positive zero, negative zero and NaN have
1145                                 // all the same representation in C++
1146       return FLOAT;             // Return generic float
1147                                 // Equal constants
1148   case Top:
1149   case FloatTop:
1150     break;                      // Return the float constant
1151   }
1152   return this;                  // Return the float constant
1153 }
1154 
1155 //------------------------------xdual------------------------------------------
1156 // Dual: symmetric
1157 const Type *TypeF::xdual() const {
1158   return this;
1159 }
1160 
1161 //------------------------------eq---------------------------------------------
1162 // Structural equality check for Type representations
1163 bool TypeF::eq(const Type *t) const {
1164   // Bitwise comparison to distinguish between +/-0. These values must be treated
1165   // as different to be consistent with C1 and the interpreter.
1166   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1167 }
1168 
1169 //------------------------------hash-------------------------------------------
1170 // Type-specific hashing function.
1171 int TypeF::hash(void) const {
1172   return *(int*)(&amp;_f);
1173 }
1174 
1175 //------------------------------is_finite--------------------------------------
1176 // Has a finite value
1177 bool TypeF::is_finite() const {
1178   return g_isfinite(getf()) != 0;
1179 }
1180 
1181 //------------------------------is_nan-----------------------------------------
1182 // Is not a number (NaN)
1183 bool TypeF::is_nan()    const {
1184   return g_isnan(getf()) != 0;
1185 }
1186 
1187 //------------------------------dump2------------------------------------------
1188 // Dump float constant Type
1189 #ifndef PRODUCT
1190 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1191   Type::dump2(d,depth, st);
1192   st-&gt;print(&quot;%f&quot;, _f);
1193 }
1194 #endif
1195 
1196 //------------------------------singleton--------------------------------------
1197 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1198 // constants (Ldi nodes).  Singletons are integer, float or double constants
1199 // or a single symbol.
1200 bool TypeF::singleton(void) const {
1201   return true;                  // Always a singleton
1202 }
1203 
1204 bool TypeF::empty(void) const {
1205   return false;                 // always exactly a singleton
1206 }
1207 
1208 //=============================================================================
1209 // Convenience common pre-built types.
1210 const TypeD *TypeD::ZERO;       // Floating point zero
1211 const TypeD *TypeD::ONE;        // Floating point one
1212 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1213 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1214 
1215 //------------------------------make-------------------------------------------
1216 const TypeD *TypeD::make(double d) {
1217   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1218 }
1219 
1220 //------------------------------meet-------------------------------------------
1221 // Compute the MEET of two types.  It returns a new Type object.
1222 const Type *TypeD::xmeet( const Type *t ) const {
1223   // Perform a fast test for common case; meeting the same types together.
1224   if( this == t ) return this;  // Meeting same type-rep?
1225 
1226   // Current &quot;this-&gt;_base&quot; is DoubleCon
1227   switch (t-&gt;base()) {          // Switch on original type
1228   case AnyPtr:                  // Mixing with oops happens when javac
1229   case RawPtr:                  // reuses local variables
1230   case OopPtr:
1231   case InstPtr:
1232   case AryPtr:
1233   case MetadataPtr:
1234   case KlassPtr:
1235   case NarrowOop:
1236   case NarrowKlass:
1237   case Int:
1238   case Long:
1239   case FloatTop:
1240   case FloatCon:
1241   case FloatBot:
1242   case Bottom:                  // Ye Olde Default
1243     return Type::BOTTOM;
1244 
1245   case DoubleBot:
1246     return t;
1247 
1248   default:                      // All else is a mistake
1249     typerr(t);
1250 
1251   case DoubleCon:               // Double-constant vs Double-constant?
1252     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1253       return DOUBLE;            // Return generic double
1254   case Top:
1255   case DoubleTop:
1256     break;
1257   }
1258   return this;                  // Return the double constant
1259 }
1260 
1261 //------------------------------xdual------------------------------------------
1262 // Dual: symmetric
1263 const Type *TypeD::xdual() const {
1264   return this;
1265 }
1266 
1267 //------------------------------eq---------------------------------------------
1268 // Structural equality check for Type representations
1269 bool TypeD::eq(const Type *t) const {
1270   // Bitwise comparison to distinguish between +/-0. These values must be treated
1271   // as different to be consistent with C1 and the interpreter.
1272   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1273 }
1274 
1275 //------------------------------hash-------------------------------------------
1276 // Type-specific hashing function.
1277 int TypeD::hash(void) const {
1278   return *(int*)(&amp;_d);
1279 }
1280 
1281 //------------------------------is_finite--------------------------------------
1282 // Has a finite value
1283 bool TypeD::is_finite() const {
1284   return g_isfinite(getd()) != 0;
1285 }
1286 
1287 //------------------------------is_nan-----------------------------------------
1288 // Is not a number (NaN)
1289 bool TypeD::is_nan()    const {
1290   return g_isnan(getd()) != 0;
1291 }
1292 
1293 //------------------------------dump2------------------------------------------
1294 // Dump double constant Type
1295 #ifndef PRODUCT
1296 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1297   Type::dump2(d,depth,st);
1298   st-&gt;print(&quot;%f&quot;, _d);
1299 }
1300 #endif
1301 
1302 //------------------------------singleton--------------------------------------
1303 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1304 // constants (Ldi nodes).  Singletons are integer, float or double constants
1305 // or a single symbol.
1306 bool TypeD::singleton(void) const {
1307   return true;                  // Always a singleton
1308 }
1309 
1310 bool TypeD::empty(void) const {
1311   return false;                 // always exactly a singleton
1312 }
1313 
1314 //=============================================================================
1315 // Convience common pre-built types.
1316 const TypeInt *TypeInt::MINUS_1;// -1
1317 const TypeInt *TypeInt::ZERO;   // 0
1318 const TypeInt *TypeInt::ONE;    // 1
1319 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1320 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1321 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1322 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1323 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1324 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1325 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1326 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1327 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1328 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1329 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1330 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1331 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1332 const TypeInt *TypeInt::INT;    // 32-bit integers
1333 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1334 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1335 
1336 //------------------------------TypeInt----------------------------------------
1337 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1338 }
1339 
1340 //------------------------------make-------------------------------------------
1341 const TypeInt *TypeInt::make( jint lo ) {
1342   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1343 }
1344 
1345 static int normalize_int_widen( jint lo, jint hi, int w ) {
1346   // Certain normalizations keep us sane when comparing types.
1347   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1348   if (lo &lt;= hi) {
1349     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1350     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1351   } else {
1352     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1353     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1354   }
1355   return w;
1356 }
1357 
1358 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1359   w = normalize_int_widen(lo, hi, w);
1360   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1361 }
1362 
1363 //------------------------------meet-------------------------------------------
1364 // Compute the MEET of two types.  It returns a new Type representation object
1365 // with reference count equal to the number of Types pointing at it.
1366 // Caller should wrap a Types around it.
1367 const Type *TypeInt::xmeet( const Type *t ) const {
1368   // Perform a fast test for common case; meeting the same types together.
1369   if( this == t ) return this;  // Meeting same type?
1370 
1371   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1372   switch (t-&gt;base()) {          // Switch on original type
1373   case AnyPtr:                  // Mixing with oops happens when javac
1374   case RawPtr:                  // reuses local variables
1375   case OopPtr:
1376   case InstPtr:
1377   case AryPtr:
1378   case MetadataPtr:
1379   case KlassPtr:
1380   case NarrowOop:
1381   case NarrowKlass:
1382   case Long:
1383   case FloatTop:
1384   case FloatCon:
1385   case FloatBot:
1386   case DoubleTop:
1387   case DoubleCon:
1388   case DoubleBot:
1389   case Bottom:                  // Ye Olde Default
1390     return Type::BOTTOM;
1391   default:                      // All else is a mistake
1392     typerr(t);
1393   case Top:                     // No change
1394     return this;
1395   case Int:                     // Int vs Int?
1396     break;
1397   }
1398 
1399   // Expand covered set
1400   const TypeInt *r = t-&gt;is_int();
1401   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1402 }
1403 
1404 //------------------------------xdual------------------------------------------
1405 // Dual: reverse hi &amp; lo; flip widen
1406 const Type *TypeInt::xdual() const {
1407   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1408   return new TypeInt(_hi,_lo,w);
1409 }
1410 
1411 //------------------------------widen------------------------------------------
1412 // Only happens for optimistic top-down optimizations.
1413 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1414   // Coming from TOP or such; no widening
1415   if( old-&gt;base() != Int ) return this;
1416   const TypeInt *ot = old-&gt;is_int();
1417 
1418   // If new guy is equal to old guy, no widening
1419   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1420     return old;
1421 
1422   // If new guy contains old, then we widened
1423   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1424     // New contains old
1425     // If new guy is already wider than old, no widening
1426     if( _widen &gt; ot-&gt;_widen ) return this;
1427     // If old guy was a constant, do not bother
1428     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1429     // Now widen new guy.
1430     // Check for widening too far
1431     if (_widen == WidenMax) {
1432       int max = max_jint;
1433       int min = min_jint;
1434       if (limit-&gt;isa_int()) {
1435         max = limit-&gt;is_int()-&gt;_hi;
1436         min = limit-&gt;is_int()-&gt;_lo;
1437       }
1438       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1439         // If neither endpoint is extremal yet, push out the endpoint
1440         // which is closer to its respective limit.
1441         if (_lo &gt;= 0 ||                 // easy common case
1442             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1443           // Try to widen to an unsigned range type of 31 bits:
1444           return make(_lo, max, WidenMax);
1445         } else {
1446           return make(min, _hi, WidenMax);
1447         }
1448       }
1449       return TypeInt::INT;
1450     }
1451     // Returned widened new guy
1452     return make(_lo,_hi,_widen+1);
1453   }
1454 
1455   // If old guy contains new, then we probably widened too far &amp; dropped to
1456   // bottom.  Return the wider fellow.
1457   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1458     return old;
1459 
1460   //fatal(&quot;Integer value range is not subset&quot;);
1461   //return this;
1462   return TypeInt::INT;
1463 }
1464 
1465 //------------------------------narrow---------------------------------------
1466 // Only happens for pessimistic optimizations.
1467 const Type *TypeInt::narrow( const Type *old ) const {
1468   if (_lo &gt;= _hi)  return this;   // already narrow enough
1469   if (old == NULL)  return this;
1470   const TypeInt* ot = old-&gt;isa_int();
1471   if (ot == NULL)  return this;
1472   jint olo = ot-&gt;_lo;
1473   jint ohi = ot-&gt;_hi;
1474 
1475   // If new guy is equal to old guy, no narrowing
1476   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1477 
1478   // If old guy was maximum range, allow the narrowing
1479   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1480 
1481   if (_lo &lt; olo || _hi &gt; ohi)
1482     return this;                // doesn&#39;t narrow; pretty wierd
1483 
1484   // The new type narrows the old type, so look for a &quot;death march&quot;.
1485   // See comments on PhaseTransform::saturate.
1486   juint nrange = (juint)_hi - _lo;
1487   juint orange = (juint)ohi - olo;
1488   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1489     // Use the new type only if the range shrinks a lot.
1490     // We do not want the optimizer computing 2^31 point by point.
1491     return old;
1492   }
1493 
1494   return this;
1495 }
1496 
1497 //-----------------------------filter------------------------------------------
1498 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1499   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1500   if (ft == NULL || ft-&gt;empty())
1501     return Type::TOP;           // Canonical empty value
1502   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1503     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1504     // The widen bits must be allowed to run freely through the graph.
1505     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1506   }
1507   return ft;
1508 }
1509 
1510 //------------------------------eq---------------------------------------------
1511 // Structural equality check for Type representations
1512 bool TypeInt::eq( const Type *t ) const {
1513   const TypeInt *r = t-&gt;is_int(); // Handy access
1514   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1515 }
1516 
1517 //------------------------------hash-------------------------------------------
1518 // Type-specific hashing function.
1519 int TypeInt::hash(void) const {
1520   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1521 }
1522 
1523 //------------------------------is_finite--------------------------------------
1524 // Has a finite value
1525 bool TypeInt::is_finite() const {
1526   return true;
1527 }
1528 
1529 //------------------------------dump2------------------------------------------
1530 // Dump TypeInt
1531 #ifndef PRODUCT
1532 static const char* intname(char* buf, jint n) {
1533   if (n == min_jint)
1534     return &quot;min&quot;;
1535   else if (n &lt; min_jint + 10000)
1536     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1537   else if (n == max_jint)
1538     return &quot;max&quot;;
1539   else if (n &gt; max_jint - 10000)
1540     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1541   else
1542     sprintf(buf, INT32_FORMAT, n);
1543   return buf;
1544 }
1545 
1546 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1547   char buf[40], buf2[40];
1548   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1549     st-&gt;print(&quot;int&quot;);
1550   else if (is_con())
1551     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1552   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1553     st-&gt;print(&quot;bool&quot;);
1554   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1555     st-&gt;print(&quot;byte&quot;);
1556   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1557     st-&gt;print(&quot;char&quot;);
1558   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1559     st-&gt;print(&quot;short&quot;);
1560   else if (_hi == max_jint)
1561     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1562   else if (_lo == min_jint)
1563     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1564   else
1565     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1566 
1567   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1568     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1569 }
1570 #endif
1571 
1572 //------------------------------singleton--------------------------------------
1573 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1574 // constants.
1575 bool TypeInt::singleton(void) const {
1576   return _lo &gt;= _hi;
1577 }
1578 
1579 bool TypeInt::empty(void) const {
1580   return _lo &gt; _hi;
1581 }
1582 
1583 //=============================================================================
1584 // Convenience common pre-built types.
1585 const TypeLong *TypeLong::MINUS_1;// -1
1586 const TypeLong *TypeLong::ZERO; // 0
1587 const TypeLong *TypeLong::ONE;  // 1
1588 const TypeLong *TypeLong::POS;  // &gt;=0
1589 const TypeLong *TypeLong::LONG; // 64-bit integers
1590 const TypeLong *TypeLong::INT;  // 32-bit subrange
1591 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1592 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1593 
1594 //------------------------------TypeLong---------------------------------------
1595 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1596 }
1597 
1598 //------------------------------make-------------------------------------------
1599 const TypeLong *TypeLong::make( jlong lo ) {
1600   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1601 }
1602 
1603 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1604   // Certain normalizations keep us sane when comparing types.
1605   // The &#39;SMALLINT&#39; covers constants.
1606   if (lo &lt;= hi) {
1607     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1608     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1609   } else {
1610     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1611     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1612   }
1613   return w;
1614 }
1615 
1616 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1617   w = normalize_long_widen(lo, hi, w);
1618   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1619 }
1620 
1621 
1622 //------------------------------meet-------------------------------------------
1623 // Compute the MEET of two types.  It returns a new Type representation object
1624 // with reference count equal to the number of Types pointing at it.
1625 // Caller should wrap a Types around it.
1626 const Type *TypeLong::xmeet( const Type *t ) const {
1627   // Perform a fast test for common case; meeting the same types together.
1628   if( this == t ) return this;  // Meeting same type?
1629 
1630   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1631   switch (t-&gt;base()) {          // Switch on original type
1632   case AnyPtr:                  // Mixing with oops happens when javac
1633   case RawPtr:                  // reuses local variables
1634   case OopPtr:
1635   case InstPtr:
1636   case AryPtr:
1637   case MetadataPtr:
1638   case KlassPtr:
1639   case NarrowOop:
1640   case NarrowKlass:
1641   case Int:
1642   case FloatTop:
1643   case FloatCon:
1644   case FloatBot:
1645   case DoubleTop:
1646   case DoubleCon:
1647   case DoubleBot:
1648   case Bottom:                  // Ye Olde Default
1649     return Type::BOTTOM;
1650   default:                      // All else is a mistake
1651     typerr(t);
1652   case Top:                     // No change
1653     return this;
1654   case Long:                    // Long vs Long?
1655     break;
1656   }
1657 
1658   // Expand covered set
1659   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1660   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1661 }
1662 
1663 //------------------------------xdual------------------------------------------
1664 // Dual: reverse hi &amp; lo; flip widen
1665 const Type *TypeLong::xdual() const {
1666   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1667   return new TypeLong(_hi,_lo,w);
1668 }
1669 
1670 //------------------------------widen------------------------------------------
1671 // Only happens for optimistic top-down optimizations.
1672 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1673   // Coming from TOP or such; no widening
1674   if( old-&gt;base() != Long ) return this;
1675   const TypeLong *ot = old-&gt;is_long();
1676 
1677   // If new guy is equal to old guy, no widening
1678   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1679     return old;
1680 
1681   // If new guy contains old, then we widened
1682   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1683     // New contains old
1684     // If new guy is already wider than old, no widening
1685     if( _widen &gt; ot-&gt;_widen ) return this;
1686     // If old guy was a constant, do not bother
1687     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1688     // Now widen new guy.
1689     // Check for widening too far
1690     if (_widen == WidenMax) {
1691       jlong max = max_jlong;
1692       jlong min = min_jlong;
1693       if (limit-&gt;isa_long()) {
1694         max = limit-&gt;is_long()-&gt;_hi;
1695         min = limit-&gt;is_long()-&gt;_lo;
1696       }
1697       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1698         // If neither endpoint is extremal yet, push out the endpoint
1699         // which is closer to its respective limit.
1700         if (_lo &gt;= 0 ||                 // easy common case
1701             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1702           // Try to widen to an unsigned range type of 32/63 bits:
1703           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1704             return make(_lo, max_juint, WidenMax);
1705           else
1706             return make(_lo, max, WidenMax);
1707         } else {
1708           return make(min, _hi, WidenMax);
1709         }
1710       }
1711       return TypeLong::LONG;
1712     }
1713     // Returned widened new guy
1714     return make(_lo,_hi,_widen+1);
1715   }
1716 
1717   // If old guy contains new, then we probably widened too far &amp; dropped to
1718   // bottom.  Return the wider fellow.
1719   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1720     return old;
1721 
1722   //  fatal(&quot;Long value range is not subset&quot;);
1723   // return this;
1724   return TypeLong::LONG;
1725 }
1726 
1727 //------------------------------narrow----------------------------------------
1728 // Only happens for pessimistic optimizations.
1729 const Type *TypeLong::narrow( const Type *old ) const {
1730   if (_lo &gt;= _hi)  return this;   // already narrow enough
1731   if (old == NULL)  return this;
1732   const TypeLong* ot = old-&gt;isa_long();
1733   if (ot == NULL)  return this;
1734   jlong olo = ot-&gt;_lo;
1735   jlong ohi = ot-&gt;_hi;
1736 
1737   // If new guy is equal to old guy, no narrowing
1738   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1739 
1740   // If old guy was maximum range, allow the narrowing
1741   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1742 
1743   if (_lo &lt; olo || _hi &gt; ohi)
1744     return this;                // doesn&#39;t narrow; pretty wierd
1745 
1746   // The new type narrows the old type, so look for a &quot;death march&quot;.
1747   // See comments on PhaseTransform::saturate.
1748   julong nrange = _hi - _lo;
1749   julong orange = ohi - olo;
1750   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1751     // Use the new type only if the range shrinks a lot.
1752     // We do not want the optimizer computing 2^31 point by point.
1753     return old;
1754   }
1755 
1756   return this;
1757 }
1758 
1759 //-----------------------------filter------------------------------------------
1760 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1761   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1762   if (ft == NULL || ft-&gt;empty())
1763     return Type::TOP;           // Canonical empty value
1764   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1765     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1766     // The widen bits must be allowed to run freely through the graph.
1767     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1768   }
1769   return ft;
1770 }
1771 
1772 //------------------------------eq---------------------------------------------
1773 // Structural equality check for Type representations
1774 bool TypeLong::eq( const Type *t ) const {
1775   const TypeLong *r = t-&gt;is_long(); // Handy access
1776   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1777 }
1778 
1779 //------------------------------hash-------------------------------------------
1780 // Type-specific hashing function.
1781 int TypeLong::hash(void) const {
1782   return (int)(_lo+_hi+_widen+(int)Type::Long);
1783 }
1784 
1785 //------------------------------is_finite--------------------------------------
1786 // Has a finite value
1787 bool TypeLong::is_finite() const {
1788   return true;
1789 }
1790 
1791 //------------------------------dump2------------------------------------------
1792 // Dump TypeLong
1793 #ifndef PRODUCT
1794 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1795   if (n &gt; x) {
1796     if (n &gt;= x + 10000)  return NULL;
1797     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1798   } else if (n &lt; x) {
1799     if (n &lt;= x - 10000)  return NULL;
1800     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1801   } else {
1802     return xname;
1803   }
1804   return buf;
1805 }
1806 
1807 static const char* longname(char* buf, jlong n) {
1808   const char* str;
1809   if (n == min_jlong)
1810     return &quot;min&quot;;
1811   else if (n &lt; min_jlong + 10000)
1812     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1813   else if (n == max_jlong)
1814     return &quot;max&quot;;
1815   else if (n &gt; max_jlong - 10000)
1816     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1817   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1818     return str;
1819   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1820     return str;
1821   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1822     return str;
1823   else
1824     sprintf(buf, JLONG_FORMAT, n);
1825   return buf;
1826 }
1827 
1828 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1829   char buf[80], buf2[80];
1830   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1831     st-&gt;print(&quot;long&quot;);
1832   else if (is_con())
1833     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1834   else if (_hi == max_jlong)
1835     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1836   else if (_lo == min_jlong)
1837     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1838   else
1839     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1840 
1841   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1842     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1843 }
1844 #endif
1845 
1846 //------------------------------singleton--------------------------------------
1847 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1848 // constants
1849 bool TypeLong::singleton(void) const {
1850   return _lo &gt;= _hi;
1851 }
1852 
1853 bool TypeLong::empty(void) const {
1854   return _lo &gt; _hi;
1855 }
1856 
1857 //=============================================================================
1858 // Convenience common pre-built types.
1859 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1860 const TypeTuple *TypeTuple::IFFALSE;
1861 const TypeTuple *TypeTuple::IFTRUE;
1862 const TypeTuple *TypeTuple::IFNEITHER;
1863 const TypeTuple *TypeTuple::LOOPBODY;
1864 const TypeTuple *TypeTuple::MEMBAR;
1865 const TypeTuple *TypeTuple::STORECONDITIONAL;
1866 const TypeTuple *TypeTuple::START_I2C;
1867 const TypeTuple *TypeTuple::INT_PAIR;
1868 const TypeTuple *TypeTuple::LONG_PAIR;
1869 const TypeTuple *TypeTuple::INT_CC_PAIR;
1870 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1871 
1872 
1873 //------------------------------make-------------------------------------------
1874 // Make a TypeTuple from the range of a method signature
1875 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {
1876   ciType* return_type = sig-&gt;return_type();
1877   uint arg_cnt = return_type-&gt;size();
1878   const Type **field_array = fields(arg_cnt);
1879   switch (return_type-&gt;basic_type()) {
1880   case T_LONG:
1881     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1882     field_array[TypeFunc::Parms+1] = Type::HALF;
1883     break;
1884   case T_DOUBLE:
1885     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1886     field_array[TypeFunc::Parms+1] = Type::HALF;
1887     break;
1888   case T_OBJECT:
1889   case T_ARRAY:
1890   case T_BOOLEAN:
1891   case T_CHAR:
1892   case T_FLOAT:
1893   case T_BYTE:
1894   case T_SHORT:
1895   case T_INT:
1896     field_array[TypeFunc::Parms] = get_const_type(return_type);
1897     break;
1898   case T_VOID:
1899     break;
1900   default:
1901     ShouldNotReachHere();
1902   }
1903   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1904 }
1905 
1906 // Make a TypeTuple from the domain of a method signature
1907 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {
1908   uint arg_cnt = sig-&gt;size();
1909 
1910   uint pos = TypeFunc::Parms;
1911   const Type **field_array;
1912   if (recv != NULL) {
1913     arg_cnt++;
1914     field_array = fields(arg_cnt);
1915     // Use get_const_type here because it respects UseUniqueSubclasses:
1916     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
1917   } else {
1918     field_array = fields(arg_cnt);
1919   }
1920 
1921   int i = 0;
1922   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1923     ciType* type = sig-&gt;type_at(i);
1924 
1925     switch (type-&gt;basic_type()) {
1926     case T_LONG:
1927       field_array[pos++] = TypeLong::LONG;
1928       field_array[pos++] = Type::HALF;
1929       break;
1930     case T_DOUBLE:
1931       field_array[pos++] = Type::DOUBLE;
1932       field_array[pos++] = Type::HALF;
1933       break;
1934     case T_OBJECT:
1935     case T_ARRAY:
1936     case T_FLOAT:
1937     case T_INT:
1938       field_array[pos++] = get_const_type(type);
1939       break;
1940     case T_BOOLEAN:
1941     case T_CHAR:
1942     case T_BYTE:
1943     case T_SHORT:
1944       field_array[pos++] = TypeInt::INT;
1945       break;
1946     default:
1947       ShouldNotReachHere();
1948     }
1949     i++;
1950   }
1951 
1952   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1953 }
1954 
1955 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1956   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1957 }
1958 
1959 //------------------------------fields-----------------------------------------
1960 // Subroutine call type with space allocated for argument types
1961 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1962 const Type **TypeTuple::fields( uint arg_cnt ) {
1963   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1964   flds[TypeFunc::Control  ] = Type::CONTROL;
1965   flds[TypeFunc::I_O      ] = Type::ABIO;
1966   flds[TypeFunc::Memory   ] = Type::MEMORY;
1967   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1968   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1969 
1970   return flds;
1971 }
1972 
1973 //------------------------------meet-------------------------------------------
1974 // Compute the MEET of two types.  It returns a new Type object.
1975 const Type *TypeTuple::xmeet( const Type *t ) const {
1976   // Perform a fast test for common case; meeting the same types together.
1977   if( this == t ) return this;  // Meeting same type-rep?
1978 
1979   // Current &quot;this-&gt;_base&quot; is Tuple
1980   switch (t-&gt;base()) {          // switch on original type
1981 
1982   case Bottom:                  // Ye Olde Default
1983     return t;
1984 
1985   default:                      // All else is a mistake
1986     typerr(t);
1987 
1988   case Tuple: {                 // Meeting 2 signatures?
1989     const TypeTuple *x = t-&gt;is_tuple();
1990     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
1991     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
1992     for( uint i=0; i&lt;_cnt; i++ )
1993       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
1994     return TypeTuple::make(_cnt,fields);
1995   }
1996   case Top:
1997     break;
1998   }
1999   return this;                  // Return the double constant
2000 }
2001 
2002 //------------------------------xdual------------------------------------------
2003 // Dual: compute field-by-field dual
2004 const Type *TypeTuple::xdual() const {
2005   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2006   for( uint i=0; i&lt;_cnt; i++ )
2007     fields[i] = _fields[i]-&gt;dual();
2008   return new TypeTuple(_cnt,fields);
2009 }
2010 
2011 //------------------------------eq---------------------------------------------
2012 // Structural equality check for Type representations
2013 bool TypeTuple::eq( const Type *t ) const {
2014   const TypeTuple *s = (const TypeTuple *)t;
2015   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2016   for (uint i = 0; i &lt; _cnt; i++)
2017     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2018       return false;             // Missed
2019   return true;
2020 }
2021 
2022 //------------------------------hash-------------------------------------------
2023 // Type-specific hashing function.
2024 int TypeTuple::hash(void) const {
2025   intptr_t sum = _cnt;
2026   for( uint i=0; i&lt;_cnt; i++ )
2027     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2028   return sum;
2029 }
2030 
2031 //------------------------------dump2------------------------------------------
2032 // Dump signature Type
2033 #ifndef PRODUCT
2034 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2035   st-&gt;print(&quot;{&quot;);
2036   if( !depth || d[this] ) {     // Check for recursive print
2037     st-&gt;print(&quot;...}&quot;);
2038     return;
2039   }
2040   d.Insert((void*)this, (void*)this);   // Stop recursion
2041   if( _cnt ) {
2042     uint i;
2043     for( i=0; i&lt;_cnt-1; i++ ) {
2044       st-&gt;print(&quot;%d:&quot;, i);
2045       _fields[i]-&gt;dump2(d, depth-1, st);
2046       st-&gt;print(&quot;, &quot;);
2047     }
2048     st-&gt;print(&quot;%d:&quot;, i);
2049     _fields[i]-&gt;dump2(d, depth-1, st);
2050   }
2051   st-&gt;print(&quot;}&quot;);
2052 }
2053 #endif
2054 
2055 //------------------------------singleton--------------------------------------
2056 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2057 // constants (Ldi nodes).  Singletons are integer, float or double constants
2058 // or a single symbol.
2059 bool TypeTuple::singleton(void) const {
2060   return false;                 // Never a singleton
2061 }
2062 
2063 bool TypeTuple::empty(void) const {
2064   for( uint i=0; i&lt;_cnt; i++ ) {
2065     if (_fields[i]-&gt;empty())  return true;
2066   }
2067   return false;
2068 }
2069 
2070 //=============================================================================
2071 // Convenience common pre-built types.
2072 
2073 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2074   // Certain normalizations keep us sane when comparing types.
2075   // We do not want arrayOop variables to differ only by the wideness
2076   // of their index types.  Pick minimum wideness, since that is the
2077   // forced wideness of small ranges anyway.
2078   if (size-&gt;_widen != Type::WidenMin)
2079     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2080   else
2081     return size;
2082 }
2083 
2084 //------------------------------make-------------------------------------------
2085 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {
2086   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2087     elem = elem-&gt;make_narrowoop();
2088   }
2089   size = normalize_array_size(size);
2090   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();
2091 }
2092 
2093 //------------------------------meet-------------------------------------------
2094 // Compute the MEET of two types.  It returns a new Type object.
2095 const Type *TypeAry::xmeet( const Type *t ) const {
2096   // Perform a fast test for common case; meeting the same types together.
2097   if( this == t ) return this;  // Meeting same type-rep?
2098 
2099   // Current &quot;this-&gt;_base&quot; is Ary
2100   switch (t-&gt;base()) {          // switch on original type
2101 
2102   case Bottom:                  // Ye Olde Default
2103     return t;
2104 
2105   default:                      // All else is a mistake
2106     typerr(t);
2107 
2108   case Array: {                 // Meeting 2 arrays?
2109     const TypeAry *a = t-&gt;is_ary();
2110     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2111                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2112                          _stable &amp; a-&gt;_stable);
2113   }
2114   case Top:
2115     break;
2116   }
2117   return this;                  // Return the double constant
2118 }
2119 
2120 //------------------------------xdual------------------------------------------
2121 // Dual: compute field-by-field dual
2122 const Type *TypeAry::xdual() const {
2123   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2124   size_dual = normalize_array_size(size_dual);
2125   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2126 }
2127 
2128 //------------------------------eq---------------------------------------------
2129 // Structural equality check for Type representations
2130 bool TypeAry::eq( const Type *t ) const {
2131   const TypeAry *a = (const TypeAry*)t;
2132   return _elem == a-&gt;_elem &amp;&amp;
2133     _stable == a-&gt;_stable &amp;&amp;
2134     _size == a-&gt;_size;
2135 }
2136 
2137 //------------------------------hash-------------------------------------------
2138 // Type-specific hashing function.
2139 int TypeAry::hash(void) const {
2140   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2141 }
2142 
2143 /**
2144  * Return same type without a speculative part in the element
2145  */
2146 const Type* TypeAry::remove_speculative() const {
2147   return make(_elem-&gt;remove_speculative(), _size, _stable);
2148 }
2149 
2150 /**
2151  * Return same type with cleaned up speculative part of element
2152  */
2153 const Type* TypeAry::cleanup_speculative() const {
2154   return make(_elem-&gt;cleanup_speculative(), _size, _stable);
2155 }
2156 
2157 /**
2158  * Return same type but with a different inline depth (used for speculation)
2159  *
2160  * @param depth  depth to meet with
2161  */
2162 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2163   if (!UseInlineDepthForSpeculativeTypes) {
2164     return this;
2165   }
2166   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2167 }
2168 
2169 //----------------------interface_vs_oop---------------------------------------
2170 #ifdef ASSERT
2171 bool TypeAry::interface_vs_oop(const Type *t) const {
2172   const TypeAry* t_ary = t-&gt;is_ary();
2173   if (t_ary) {
2174     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2175     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2176     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2177       return this_ptr-&gt;interface_vs_oop(t_ptr);
2178     }
2179   }
2180   return false;
2181 }
2182 #endif
2183 
2184 //------------------------------dump2------------------------------------------
2185 #ifndef PRODUCT
2186 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2187   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2188   _elem-&gt;dump2(d, depth, st);
2189   st-&gt;print(&quot;[&quot;);
2190   _size-&gt;dump2(d, depth, st);
2191   st-&gt;print(&quot;]&quot;);
2192 }
2193 #endif
2194 
2195 //------------------------------singleton--------------------------------------
2196 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2197 // constants (Ldi nodes).  Singletons are integer, float or double constants
2198 // or a single symbol.
2199 bool TypeAry::singleton(void) const {
2200   return false;                 // Never a singleton
2201 }
2202 
2203 bool TypeAry::empty(void) const {
2204   return _elem-&gt;empty() || _size-&gt;empty();
2205 }
2206 
2207 //--------------------------ary_must_be_exact----------------------------------
2208 bool TypeAry::ary_must_be_exact() const {
2209   if (!UseExactTypes)       return false;
2210   // This logic looks at the element type of an array, and returns true
2211   // if the element type is either a primitive or a final instance class.
2212   // In such cases, an array built on this ary must have no subclasses.
2213   if (_elem == BOTTOM)      return false;  // general array not exact
2214   if (_elem == TOP   )      return false;  // inverted general array not exact
2215   const TypeOopPtr*  toop = NULL;
2216   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2217     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2218   } else {
2219     toop = _elem-&gt;isa_oopptr();
2220   }
2221   if (!toop)                return true;   // a primitive type, like int
2222   ciKlass* tklass = toop-&gt;klass();
2223   if (tklass == NULL)       return false;  // unloaded class
2224   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2225   const TypeInstPtr* tinst;
2226   if (_elem-&gt;isa_narrowoop())
2227     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2228   else
2229     tinst = _elem-&gt;isa_instptr();
2230   if (tinst)
2231     return tklass-&gt;as_instance_klass()-&gt;is_final();
2232   const TypeAryPtr*  tap;
2233   if (_elem-&gt;isa_narrowoop())
2234     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2235   else
2236     tap = _elem-&gt;isa_aryptr();
2237   if (tap)
2238     return tap-&gt;ary()-&gt;ary_must_be_exact();
2239   return false;
2240 }
2241 
2242 //==============================TypeVect=======================================
2243 // Convenience common pre-built types.
2244 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2245 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2246 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2247 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2248 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2249 
2250 //------------------------------make-------------------------------------------
2251 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2252   BasicType elem_bt = elem-&gt;array_element_basic_type();
2253   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2254   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2255   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2256   int size = length * type2aelembytes(elem_bt);
2257   switch (Matcher::vector_ideal_reg(size)) {
2258   case Op_VecS:
2259     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2260   case Op_RegL:
2261   case Op_VecD:
2262   case Op_RegD:
2263     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2264   case Op_VecX:
2265     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2266   case Op_VecY:
2267     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2268   case Op_VecZ:
2269     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2270   }
2271  ShouldNotReachHere();
2272   return NULL;
2273 }
2274 
2275 //------------------------------meet-------------------------------------------
2276 // Compute the MEET of two types.  It returns a new Type object.
2277 const Type *TypeVect::xmeet( const Type *t ) const {
2278   // Perform a fast test for common case; meeting the same types together.
2279   if( this == t ) return this;  // Meeting same type-rep?
2280 
2281   // Current &quot;this-&gt;_base&quot; is Vector
2282   switch (t-&gt;base()) {          // switch on original type
2283 
2284   case Bottom:                  // Ye Olde Default
2285     return t;
2286 
2287   default:                      // All else is a mistake
2288     typerr(t);
2289 
2290   case VectorS:
2291   case VectorD:
2292   case VectorX:
2293   case VectorY:
2294   case VectorZ: {                // Meeting 2 vectors?
2295     const TypeVect* v = t-&gt;is_vect();
2296     assert(  base() == v-&gt;base(), &quot;&quot;);
2297     assert(length() == v-&gt;length(), &quot;&quot;);
2298     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2299     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2300   }
2301   case Top:
2302     break;
2303   }
2304   return this;
2305 }
2306 
2307 //------------------------------xdual------------------------------------------
2308 // Dual: compute field-by-field dual
2309 const Type *TypeVect::xdual() const {
2310   return new TypeVect(base(), _elem-&gt;dual(), _length);
2311 }
2312 
2313 //------------------------------eq---------------------------------------------
2314 // Structural equality check for Type representations
2315 bool TypeVect::eq(const Type *t) const {
2316   const TypeVect *v = t-&gt;is_vect();
2317   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2318 }
2319 
2320 //------------------------------hash-------------------------------------------
2321 // Type-specific hashing function.
2322 int TypeVect::hash(void) const {
2323   return (intptr_t)_elem + (intptr_t)_length;
2324 }
2325 
2326 //------------------------------singleton--------------------------------------
2327 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2328 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2329 // constant value (when vector is created with Replicate code).
2330 bool TypeVect::singleton(void) const {
2331 // There is no Con node for vectors yet.
2332 //  return _elem-&gt;singleton();
2333   return false;
2334 }
2335 
2336 bool TypeVect::empty(void) const {
2337   return _elem-&gt;empty();
2338 }
2339 
2340 //------------------------------dump2------------------------------------------
2341 #ifndef PRODUCT
2342 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2343   switch (base()) {
2344   case VectorS:
2345     st-&gt;print(&quot;vectors[&quot;); break;
2346   case VectorD:
2347     st-&gt;print(&quot;vectord[&quot;); break;
2348   case VectorX:
2349     st-&gt;print(&quot;vectorx[&quot;); break;
2350   case VectorY:
2351     st-&gt;print(&quot;vectory[&quot;); break;
2352   case VectorZ:
2353     st-&gt;print(&quot;vectorz[&quot;); break;
2354   default:
2355     ShouldNotReachHere();
2356   }
2357   st-&gt;print(&quot;%d]:{&quot;, _length);
2358   _elem-&gt;dump2(d, depth, st);
2359   st-&gt;print(&quot;}&quot;);
2360 }
2361 #endif
2362 
2363 
2364 //=============================================================================
2365 // Convenience common pre-built types.
2366 const TypePtr *TypePtr::NULL_PTR;
2367 const TypePtr *TypePtr::NOTNULL;
2368 const TypePtr *TypePtr::BOTTOM;
2369 
2370 //------------------------------meet-------------------------------------------
2371 // Meet over the PTR enum
2372 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2373   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2374   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2375   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2376   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2377   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2378   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2379   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2380 };
2381 
2382 //------------------------------make-------------------------------------------
2383 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {
2384   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2385 }
2386 
2387 //------------------------------cast_to_ptr_type-------------------------------
2388 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2389   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2390   if( ptr == _ptr ) return this;
2391   return make(_base, ptr, _offset, _speculative, _inline_depth);
2392 }
2393 
2394 //------------------------------get_con----------------------------------------
2395 intptr_t TypePtr::get_con() const {
2396   assert( _ptr == Null, &quot;&quot; );
2397   return _offset;
2398 }
2399 
2400 //------------------------------meet-------------------------------------------
2401 // Compute the MEET of two types.  It returns a new Type object.
2402 const Type *TypePtr::xmeet(const Type *t) const {
2403   const Type* res = xmeet_helper(t);
2404   if (res-&gt;isa_ptr() == NULL) {
2405     return res;
2406   }
2407 
2408   const TypePtr* res_ptr = res-&gt;is_ptr();
2409   if (res_ptr-&gt;speculative() != NULL) {
2410     // type-&gt;speculative() == NULL means that speculation is no better
2411     // than type, i.e. type-&gt;speculative() == type. So there are 2
2412     // ways to represent the fact that we have no useful speculative
2413     // data and we should use a single one to be able to test for
2414     // equality between types. Check whether type-&gt;speculative() ==
2415     // type and set speculative to NULL if it is the case.
2416     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2417       return res_ptr-&gt;remove_speculative();
2418     }
2419   }
2420 
2421   return res;
2422 }
2423 
2424 const Type *TypePtr::xmeet_helper(const Type *t) const {
2425   // Perform a fast test for common case; meeting the same types together.
2426   if( this == t ) return this;  // Meeting same type-rep?
2427 
2428   // Current &quot;this-&gt;_base&quot; is AnyPtr
2429   switch (t-&gt;base()) {          // switch on original type
2430   case Int:                     // Mixing ints &amp; oops happens when javac
2431   case Long:                    // reuses local variables
2432   case FloatTop:
2433   case FloatCon:
2434   case FloatBot:
2435   case DoubleTop:
2436   case DoubleCon:
2437   case DoubleBot:
2438   case NarrowOop:
2439   case NarrowKlass:
2440   case Bottom:                  // Ye Olde Default
2441     return Type::BOTTOM;
2442   case Top:
2443     return this;
2444 
2445   case AnyPtr: {                // Meeting to AnyPtrs
2446     const TypePtr *tp = t-&gt;is_ptr();
2447     const TypePtr* speculative = xmeet_speculative(tp);
2448     int depth = meet_inline_depth(tp-&gt;inline_depth());
2449     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2450   }
2451   case RawPtr:                  // For these, flip the call around to cut down
2452   case OopPtr:
2453   case InstPtr:                 // on the cases I have to handle.
2454   case AryPtr:
2455   case MetadataPtr:
2456   case KlassPtr:
2457     return t-&gt;xmeet(this);      // Call in reverse direction
2458   default:                      // All else is a mistake
2459     typerr(t);
2460 
2461   }
2462   return this;
2463 }
2464 
2465 //------------------------------meet_offset------------------------------------
2466 int TypePtr::meet_offset( int offset ) const {
2467   // Either is &#39;TOP&#39; offset?  Return the other offset!
2468   if( _offset == OffsetTop ) return offset;
2469   if( offset == OffsetTop ) return _offset;
2470   // If either is different, return &#39;BOTTOM&#39; offset
2471   if( _offset != offset ) return OffsetBot;
2472   return _offset;
2473 }
2474 
2475 //------------------------------dual_offset------------------------------------
2476 int TypePtr::dual_offset( ) const {
2477   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
2478   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
2479   return _offset;               // Map everything else into self
2480 }
2481 
2482 //------------------------------xdual------------------------------------------
2483 // Dual: compute field-by-field dual
2484 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2485   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2486 };
2487 const Type *TypePtr::xdual() const {
2488   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2489 }
2490 
2491 //------------------------------xadd_offset------------------------------------
2492 int TypePtr::xadd_offset( intptr_t offset ) const {
2493   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
2494   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;
2495   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
2496   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;
2497   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
2498   offset += (intptr_t)_offset;
2499   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;
2500 
2501   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
2502   // It is possible to construct a negative offset during PhaseCCP
2503 
2504   return (int)offset;        // Sum valid offsets
2505 }
2506 
2507 //------------------------------add_offset-------------------------------------
2508 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2509   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2510 }
2511 
2512 //------------------------------eq---------------------------------------------
2513 // Structural equality check for Type representations
2514 bool TypePtr::eq( const Type *t ) const {
2515   const TypePtr *a = (const TypePtr*)t;
2516   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2517 }
2518 
2519 //------------------------------hash-------------------------------------------
2520 // Type-specific hashing function.
2521 int TypePtr::hash(void) const {
2522   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));
2523 ;
2524 }
2525 
2526 /**
2527  * Return same type without a speculative part
2528  */
2529 const Type* TypePtr::remove_speculative() const {
2530   if (_speculative == NULL) {
2531     return this;
2532   }
2533   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2534   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2535 }
2536 
2537 /**
2538  * Return same type but drop speculative part if we know we won&#39;t use
2539  * it
2540  */
2541 const Type* TypePtr::cleanup_speculative() const {
2542   if (speculative() == NULL) {
2543     return this;
2544   }
2545   const Type* no_spec = remove_speculative();
2546   // If this is NULL_PTR then we don&#39;t need the speculative type
2547   // (with_inline_depth in case the current type inline depth is
2548   // InlineDepthTop)
2549   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2550     return no_spec;
2551   }
2552   if (above_centerline(speculative()-&gt;ptr())) {
2553     return no_spec;
2554   }
2555   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2556   // If the speculative may be null and is an inexact klass then it
2557   // doesn&#39;t help
2558   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2559       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2560     return no_spec;
2561   }
2562   return this;
2563 }
2564 
2565 /**
2566  * dual of the speculative part of the type
2567  */
2568 const TypePtr* TypePtr::dual_speculative() const {
2569   if (_speculative == NULL) {
2570     return NULL;
2571   }
2572   return _speculative-&gt;dual()-&gt;is_ptr();
2573 }
2574 
2575 /**
2576  * meet of the speculative parts of 2 types
2577  *
2578  * @param other  type to meet with
2579  */
2580 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2581   bool this_has_spec = (_speculative != NULL);
2582   bool other_has_spec = (other-&gt;speculative() != NULL);
2583 
2584   if (!this_has_spec &amp;&amp; !other_has_spec) {
2585     return NULL;
2586   }
2587 
2588   // If we are at a point where control flow meets and one branch has
2589   // a speculative type and the other has not, we meet the speculative
2590   // type of one branch with the actual type of the other. If the
2591   // actual type is exact and the speculative is as well, then the
2592   // result is a speculative type which is exact and we can continue
2593   // speculation further.
2594   const TypePtr* this_spec = _speculative;
2595   const TypePtr* other_spec = other-&gt;speculative();
2596 
2597   if (!this_has_spec) {
2598     this_spec = this;
2599   }
2600 
2601   if (!other_has_spec) {
2602     other_spec = other;
2603   }
2604 
2605   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2606 }
2607 
2608 /**
2609  * dual of the inline depth for this type (used for speculation)
2610  */
2611 int TypePtr::dual_inline_depth() const {
2612   return -inline_depth();
2613 }
2614 
2615 /**
2616  * meet of 2 inline depths (used for speculation)
2617  *
2618  * @param depth  depth to meet with
2619  */
2620 int TypePtr::meet_inline_depth(int depth) const {
2621   return MAX2(inline_depth(), depth);
2622 }
2623 
2624 /**
2625  * Are the speculative parts of 2 types equal?
2626  *
2627  * @param other  type to compare this one to
2628  */
2629 bool TypePtr::eq_speculative(const TypePtr* other) const {
2630   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2631     return _speculative == other-&gt;speculative();
2632   }
2633 
2634   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2635     return false;
2636   }
2637 
2638   return _speculative-&gt;eq(other-&gt;speculative());
2639 }
2640 
2641 /**
2642  * Hash of the speculative part of the type
2643  */
2644 int TypePtr::hash_speculative() const {
2645   if (_speculative == NULL) {
2646     return 0;
2647   }
2648 
2649   return _speculative-&gt;hash();
2650 }
2651 
2652 /**
2653  * add offset to the speculative part of the type
2654  *
2655  * @param offset  offset to add
2656  */
2657 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2658   if (_speculative == NULL) {
2659     return NULL;
2660   }
2661   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2662 }
2663 
2664 /**
2665  * return exact klass from the speculative type if there&#39;s one
2666  */
2667 ciKlass* TypePtr::speculative_type() const {
2668   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2669     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2670     if (speculative-&gt;klass_is_exact()) {
2671       return speculative-&gt;klass();
2672     }
2673   }
2674   return NULL;
2675 }
2676 
2677 /**
2678  * return true if speculative type may be null
2679  */
2680 bool TypePtr::speculative_maybe_null() const {
2681   if (_speculative != NULL) {
2682     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2683     return speculative-&gt;maybe_null();
2684   }
2685   return true;
2686 }
2687 
2688 bool TypePtr::speculative_always_null() const {
2689   if (_speculative != NULL) {
2690     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2691     return speculative == TypePtr::NULL_PTR;
2692   }
2693   return false;
2694 }
2695 
2696 /**
2697  * Same as TypePtr::speculative_type() but return the klass only if
2698  * the speculative tells us is not null
2699  */
2700 ciKlass* TypePtr::speculative_type_not_null() const {
2701   if (speculative_maybe_null()) {
2702     return NULL;
2703   }
2704   return speculative_type();
2705 }
2706 
2707 /**
2708  * Check whether new profiling would improve speculative type
2709  *
2710  * @param   exact_kls    class from profiling
2711  * @param   inline_depth inlining depth of profile point
2712  *
2713  * @return  true if type profile is valuable
2714  */
2715 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2716   // no profiling?
2717   if (exact_kls == NULL) {
2718     return false;
2719   }
2720   if (speculative() == TypePtr::NULL_PTR) {
2721     return false;
2722   }
2723   // no speculative type or non exact speculative type?
2724   if (speculative_type() == NULL) {
2725     return true;
2726   }
2727   // If the node already has an exact speculative type keep it,
2728   // unless it was provided by profiling that is at a deeper
2729   // inlining level. Profiling at a higher inlining depth is
2730   // expected to be less accurate.
2731   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2732     return false;
2733   }
2734   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2735   return inline_depth &lt; _speculative-&gt;inline_depth();
2736 }
2737 
2738 /**
2739  * Check whether new profiling would improve ptr (= tells us it is non
2740  * null)
2741  *
2742  * @param   ptr_kind always null or not null?
2743  *
2744  * @return  true if ptr profile is valuable
2745  */
2746 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
2747   // profiling doesn&#39;t tell us anything useful
2748   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
2749     return false;
2750   }
2751   // We already know this is not null
2752   if (!this-&gt;maybe_null()) {
2753     return false;
2754   }
2755   // We already know the speculative type cannot be null
2756   if (!speculative_maybe_null()) {
2757     return false;
2758   }
2759   // We already know this is always null
2760   if (this == TypePtr::NULL_PTR) {
2761     return false;
2762   }
2763   // We already know the speculative type is always null
2764   if (speculative_always_null()) {
2765     return false;
2766   }
2767   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2768     return false;
2769   }
2770   return true;
2771 }
2772 
2773 //------------------------------dump2------------------------------------------
2774 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2775   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2776 };
2777 
2778 #ifndef PRODUCT
2779 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2780   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2781   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
2782   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);
2783   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);
2784   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);
2785   dump_inline_depth(st);
2786   dump_speculative(st);
2787 }
2788 
2789 /**
2790  *dump the speculative part of the type
2791  */
2792 void TypePtr::dump_speculative(outputStream *st) const {
2793   if (_speculative != NULL) {
2794     st-&gt;print(&quot; (speculative=&quot;);
2795     _speculative-&gt;dump_on(st);
2796     st-&gt;print(&quot;)&quot;);
2797   }
2798 }
2799 
2800 /**
2801  *dump the inline depth of the type
2802  */
2803 void TypePtr::dump_inline_depth(outputStream *st) const {
2804   if (_inline_depth != InlineDepthBottom) {
2805     if (_inline_depth == InlineDepthTop) {
2806       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2807     } else {
2808       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2809     }
2810   }
2811 }
2812 #endif
2813 
2814 //------------------------------singleton--------------------------------------
2815 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2816 // constants
2817 bool TypePtr::singleton(void) const {
2818   // TopPTR, Null, AnyNull, Constant are all singletons
2819   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);
2820 }
2821 
2822 bool TypePtr::empty(void) const {
2823   return (_offset == OffsetTop) || above_centerline(_ptr);
2824 }
2825 
2826 //=============================================================================
2827 // Convenience common pre-built types.
2828 const TypeRawPtr *TypeRawPtr::BOTTOM;
2829 const TypeRawPtr *TypeRawPtr::NOTNULL;
2830 
2831 //------------------------------make-------------------------------------------
2832 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2833   assert( ptr != Constant, &quot;what is the constant?&quot; );
2834   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2835   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2836 }
2837 
2838 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2839   assert( bits, &quot;Use TypePtr for NULL&quot; );
2840   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2841 }
2842 
2843 //------------------------------cast_to_ptr_type-------------------------------
2844 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
2845   assert( ptr != Constant, &quot;what is the constant?&quot; );
2846   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2847   assert( _bits==0, &quot;Why cast a constant address?&quot;);
2848   if( ptr == _ptr ) return this;
2849   return make(ptr);
2850 }
2851 
2852 //------------------------------get_con----------------------------------------
2853 intptr_t TypeRawPtr::get_con() const {
2854   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
2855   return (intptr_t)_bits;
2856 }
2857 
2858 //------------------------------meet-------------------------------------------
2859 // Compute the MEET of two types.  It returns a new Type object.
2860 const Type *TypeRawPtr::xmeet( const Type *t ) const {
2861   // Perform a fast test for common case; meeting the same types together.
2862   if( this == t ) return this;  // Meeting same type-rep?
2863 
2864   // Current &quot;this-&gt;_base&quot; is RawPtr
2865   switch( t-&gt;base() ) {         // switch on original type
2866   case Bottom:                  // Ye Olde Default
2867     return t;
2868   case Top:
2869     return this;
2870   case AnyPtr:                  // Meeting to AnyPtrs
2871     break;
2872   case RawPtr: {                // might be top, bot, any/not or constant
2873     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
2874     enum PTR ptr = meet_ptr( tptr );
2875     if( ptr == Constant ) {     // Cannot be equal constants, so...
2876       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
2877       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
2878       ptr = NotNull;            // Fall down in lattice
2879     }
2880     return make( ptr );
2881   }
2882 
2883   case OopPtr:
2884   case InstPtr:
2885   case AryPtr:
2886   case MetadataPtr:
2887   case KlassPtr:
2888     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
2889   default:                      // All else is a mistake
2890     typerr(t);
2891   }
2892 
2893   // Found an AnyPtr type vs self-RawPtr type
2894   const TypePtr *tp = t-&gt;is_ptr();
2895   switch (tp-&gt;ptr()) {
2896   case TypePtr::TopPTR:  return this;
2897   case TypePtr::BotPTR:  return t;
2898   case TypePtr::Null:
2899     if( _ptr == TypePtr::TopPTR ) return t;
2900     return TypeRawPtr::BOTTOM;
2901   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
2902   case TypePtr::AnyNull:
2903     if( _ptr == TypePtr::Constant) return this;
2904     return make( meet_ptr(TypePtr::AnyNull) );
2905   default: ShouldNotReachHere();
2906   }
2907   return this;
2908 }
2909 
2910 //------------------------------xdual------------------------------------------
2911 // Dual: compute field-by-field dual
2912 const Type *TypeRawPtr::xdual() const {
2913   return new TypeRawPtr( dual_ptr(), _bits );
2914 }
2915 
2916 //------------------------------add_offset-------------------------------------
2917 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
2918   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
2919   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
2920   if( offset == 0 ) return this; // No change
2921   switch (_ptr) {
2922   case TypePtr::TopPTR:
2923   case TypePtr::BotPTR:
2924   case TypePtr::NotNull:
2925     return this;
2926   case TypePtr::Null:
2927   case TypePtr::Constant: {
2928     address bits = _bits+offset;
2929     if ( bits == 0 ) return TypePtr::NULL_PTR;
2930     return make( bits );
2931   }
2932   default:  ShouldNotReachHere();
2933   }
2934   return NULL;                  // Lint noise
2935 }
2936 
2937 //------------------------------eq---------------------------------------------
2938 // Structural equality check for Type representations
2939 bool TypeRawPtr::eq( const Type *t ) const {
2940   const TypeRawPtr *a = (const TypeRawPtr*)t;
2941   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
2942 }
2943 
2944 //------------------------------hash-------------------------------------------
2945 // Type-specific hashing function.
2946 int TypeRawPtr::hash(void) const {
2947   return (intptr_t)_bits + TypePtr::hash();
2948 }
2949 
2950 //------------------------------dump2------------------------------------------
2951 #ifndef PRODUCT
2952 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2953   if( _ptr == Constant )
2954     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2955   else
2956     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2957 }
2958 #endif
2959 
2960 //=============================================================================
2961 // Convenience common pre-built type.
2962 const TypeOopPtr *TypeOopPtr::BOTTOM;
2963 
2964 //------------------------------TypeOopPtr-------------------------------------
2965 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
2966                        int instance_id, const TypePtr* speculative, int inline_depth)
2967   : TypePtr(t, ptr, offset, speculative, inline_depth),
2968     _const_oop(o), _klass(k),
2969     _klass_is_exact(xk),
2970     _is_ptr_to_narrowoop(false),
2971     _is_ptr_to_narrowklass(false),
2972     _is_ptr_to_boxed_value(false),
2973     _instance_id(instance_id) {
2974   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
2975       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
2976     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);
2977   }
2978 #ifdef _LP64
2979   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {
2980     if (_offset == oopDesc::klass_offset_in_bytes()) {
2981       _is_ptr_to_narrowklass = UseCompressedClassPointers;
2982     } else if (klass() == NULL) {
2983       // Array with unknown body type
2984       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
2985       _is_ptr_to_narrowoop = UseCompressedOops;
2986     } else if (this-&gt;isa_aryptr()) {
2987       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;
2988                              _offset != arrayOopDesc::length_offset_in_bytes());
2989     } else if (klass()-&gt;is_instance_klass()) {
2990       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
2991       ciField* field = NULL;
2992       if (this-&gt;isa_klassptr()) {
2993         // Perm objects don&#39;t use compressed references
2994       } else if (_offset == OffsetBot || _offset == OffsetTop) {
2995         // unsafe access
2996         _is_ptr_to_narrowoop = UseCompressedOops;
2997       } else { // exclude unsafe ops
2998         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2999 
3000         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3001             (_offset == java_lang_Class::klass_offset_in_bytes() ||
3002              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
3003           // Special hidden fields from the Class.
3004           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3005           _is_ptr_to_narrowoop = false;
3006         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3007                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3008           // Static fields
3009           assert(o != NULL, &quot;must be constant&quot;);
3010           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3011           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3012           assert(field != NULL, &quot;missing field&quot;);
3013           BasicType basic_elem_type = field-&gt;layout_type();
3014           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||
3015                                                        basic_elem_type == T_ARRAY);
3016         } else {
3017           // Instance fields which contains a compressed oop references.
3018           field = ik-&gt;get_field_by_offset(_offset, false);
3019           if (field != NULL) {
3020             BasicType basic_elem_type = field-&gt;layout_type();
3021             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; (basic_elem_type == T_OBJECT ||
3022                                                          basic_elem_type == T_ARRAY);
3023           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3024             // Compile::find_alias_type() cast exactness on all types to verify
3025             // that it does not affect alias type.
3026             _is_ptr_to_narrowoop = UseCompressedOops;
3027           } else {
3028             // Type for the copy start in LibraryCallKit::inline_native_clone().
3029             _is_ptr_to_narrowoop = UseCompressedOops;
3030           }
3031         }
3032       }
3033     }
3034   }
3035 #endif
3036 }
3037 
3038 //------------------------------make-------------------------------------------
3039 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3040                                      const TypePtr* speculative, int inline_depth) {
3041   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3042   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3043   bool      xk = false;
3044   ciObject* o = NULL;
3045   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3046 }
3047 
3048 
3049 //------------------------------cast_to_ptr_type-------------------------------
3050 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3051   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3052   if( ptr == _ptr ) return this;
3053   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3054 }
3055 
3056 //-----------------------------cast_to_instance_id----------------------------
3057 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3058   // There are no instances of a general oop.
3059   // Return self unchanged.
3060   return this;
3061 }
3062 
3063 const TypeOopPtr *TypeOopPtr::cast_to_nonconst() const {
3064   return this;
3065 }
3066 
3067 //-----------------------------cast_to_exactness-------------------------------
3068 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3069   // There is no such thing as an exact general oop.
3070   // Return self unchanged.
3071   return this;
3072 }
3073 
3074 
3075 //------------------------------as_klass_type----------------------------------
3076 // Return the klass type corresponding to this instance or array type.
3077 // It is the type that is loaded from an object of this type.
3078 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3079   ciKlass* k = klass();
3080   bool    xk = klass_is_exact();
3081   if (k == NULL)
3082     return TypeKlassPtr::OBJECT;
3083   else
3084     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3085 }
3086 
3087 //------------------------------meet-------------------------------------------
3088 // Compute the MEET of two types.  It returns a new Type object.
3089 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3090   // Perform a fast test for common case; meeting the same types together.
3091   if( this == t ) return this;  // Meeting same type-rep?
3092 
3093   // Current &quot;this-&gt;_base&quot; is OopPtr
3094   switch (t-&gt;base()) {          // switch on original type
3095 
3096   case Int:                     // Mixing ints &amp; oops happens when javac
3097   case Long:                    // reuses local variables
3098   case FloatTop:
3099   case FloatCon:
3100   case FloatBot:
3101   case DoubleTop:
3102   case DoubleCon:
3103   case DoubleBot:
3104   case NarrowOop:
3105   case NarrowKlass:
3106   case Bottom:                  // Ye Olde Default
3107     return Type::BOTTOM;
3108   case Top:
3109     return this;
3110 
3111   default:                      // All else is a mistake
3112     typerr(t);
3113 
3114   case RawPtr:
3115   case MetadataPtr:
3116   case KlassPtr:
3117     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3118 
3119   case AnyPtr: {
3120     // Found an AnyPtr type vs self-OopPtr type
3121     const TypePtr *tp = t-&gt;is_ptr();
3122     int offset = meet_offset(tp-&gt;offset());
3123     PTR ptr = meet_ptr(tp-&gt;ptr());
3124     const TypePtr* speculative = xmeet_speculative(tp);
3125     int depth = meet_inline_depth(tp-&gt;inline_depth());
3126     switch (tp-&gt;ptr()) {
3127     case Null:
3128       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3129       // else fall through:
3130     case TopPTR:
3131     case AnyNull: {
3132       int instance_id = meet_instance_id(InstanceTop);
3133       return make(ptr, offset, instance_id, speculative, depth);
3134     }
3135     case BotPTR:
3136     case NotNull:
3137       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3138     default: typerr(t);
3139     }
3140   }
3141 
3142   case OopPtr: {                 // Meeting to other OopPtrs
3143     const TypeOopPtr *tp = t-&gt;is_oopptr();
3144     int instance_id = meet_instance_id(tp-&gt;instance_id());
3145     const TypePtr* speculative = xmeet_speculative(tp);
3146     int depth = meet_inline_depth(tp-&gt;inline_depth());
3147     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3148   }
3149 
3150   case InstPtr:                  // For these, flip the call around to cut down
3151   case AryPtr:
3152     return t-&gt;xmeet(this);      // Call in reverse direction
3153 
3154   } // End of switch
3155   return this;                  // Return the double constant
3156 }
3157 
3158 
3159 //------------------------------xdual------------------------------------------
3160 // Dual of a pure heap pointer.  No relevant klass or oop information.
3161 const Type *TypeOopPtr::xdual() const {
3162   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3163   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3164   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3165 }
3166 
3167 //--------------------------make_from_klass_common-----------------------------
3168 // Computes the element-type given a klass.
3169 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3170   if (klass-&gt;is_instance_klass()) {
3171     Compile* C = Compile::current();
3172     Dependencies* deps = C-&gt;dependencies();
3173     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3174     // Element is an instance
3175     bool klass_is_exact = false;
3176     if (klass-&gt;is_loaded()) {
3177       // Try to set klass_is_exact.
3178       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3179       klass_is_exact = ik-&gt;is_final();
3180       if (!klass_is_exact &amp;&amp; klass_change
3181           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3182         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3183         if (sub != NULL) {
3184           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3185           klass = ik = sub;
3186           klass_is_exact = sub-&gt;is_final();
3187         }
3188       }
3189       if (!klass_is_exact &amp;&amp; try_for_exact
3190           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3191         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3192           // Add a dependence; if concrete subclass added we need to recompile
3193           deps-&gt;assert_leaf_type(ik);
3194           klass_is_exact = true;
3195         }
3196       }
3197     }
3198     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);
3199   } else if (klass-&gt;is_obj_array_klass()) {
3200     // Element is an object array. Recursively call ourself.
3201     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);
3202     bool xk = etype-&gt;klass_is_exact();
3203     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3204     // We used to pass NotNull in here, asserting that the sub-arrays
3205     // are all not-null.  This is not true in generally, as code can
3206     // slam NULLs down in the subarrays.
3207     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);
3208     return arr;
3209   } else if (klass-&gt;is_type_array_klass()) {
3210     // Element is an typeArray
3211     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3212     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3213     // We used to pass NotNull in here, asserting that the array pointer
3214     // is not-null. That was not true in general.
3215     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);
3216     return arr;
3217   } else {
3218     ShouldNotReachHere();
3219     return NULL;
3220   }
3221 }
3222 
3223 //------------------------------make_from_constant-----------------------------
3224 // Make a java pointer from an oop constant
3225 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3226   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3227 
3228   const bool make_constant = require_constant || o-&gt;should_be_constant();
3229 
3230   ciKlass* klass = o-&gt;klass();
3231   if (klass-&gt;is_instance_klass()) {
3232     // Element is an instance
3233     if (make_constant) {
3234       return TypeInstPtr::make(o);
3235     } else {
3236       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);
3237     }
3238   } else if (klass-&gt;is_obj_array_klass()) {
3239     // Element is an object array. Recursively call ourself.
3240     const TypeOopPtr *etype =
3241       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());
3242     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3243     // We used to pass NotNull in here, asserting that the sub-arrays
3244     // are all not-null.  This is not true in generally, as code can
3245     // slam NULLs down in the subarrays.
3246     if (make_constant) {
3247       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3248     } else {
3249       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3250     }
3251   } else if (klass-&gt;is_type_array_klass()) {
3252     // Element is an typeArray
3253     const Type* etype =
3254       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3255     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3256     // We used to pass NotNull in here, asserting that the array pointer
3257     // is not-null. That was not true in general.
3258     if (make_constant) {
3259       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3260     } else {
3261       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3262     }
3263   }
3264 
3265   fatal(&quot;unhandled object type&quot;);
3266   return NULL;
3267 }
3268 
3269 //------------------------------get_con----------------------------------------
3270 intptr_t TypeOopPtr::get_con() const {
3271   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3272   assert( _offset &gt;= 0, &quot;&quot; );
3273 
3274   if (_offset != 0) {
3275     // After being ported to the compiler interface, the compiler no longer
3276     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3277     // to a handle at compile time.  This handle is embedded in the generated
3278     // code and dereferenced at the time the nmethod is made.  Until that time,
3279     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3280     // have access to the addresses!).  This does not seem to currently happen,
3281     // but this assertion here is to help prevent its occurence.
3282     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3283     ShouldNotReachHere();
3284   }
3285 
3286   return (intptr_t)const_oop()-&gt;constant_encoding();
3287 }
3288 
3289 
3290 //-----------------------------filter------------------------------------------
3291 // Do not allow interface-vs.-noninterface joins to collapse to top.
3292 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3293 
3294   const Type* ft = join_helper(kills, include_speculative);
3295   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3296   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3297 
3298   if (ft-&gt;empty()) {
3299     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3300     // interface.  This can happen because the bytecodes do not contain
3301     // enough type info to distinguish a Java-level interface variable
3302     // from a Java-level object variable.  If we meet 2 classes which
3303     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3304     // doesn&#39;t implement I, we have no way to tell if the result should
3305     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3306     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3307     // uplift the type.
3308     if (!empty()) {
3309       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3310         return kills;           // Uplift to interface
3311       }
3312       // Also check for evil cases of &#39;this&#39; being a class array
3313       // and &#39;kills&#39; expecting an array of interfaces.
3314       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3315       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3316         return kills;           // Uplift to array of interface
3317       }
3318     }
3319 
3320     return Type::TOP;           // Canonical empty value
3321   }
3322 
3323   // If we have an interface-typed Phi or cast and we narrow to a class type,
3324   // the join should report back the class.  However, if we have a J/L/Object
3325   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3326   // join report an interface back out.  This isn&#39;t possible but happens
3327   // because the type system doesn&#39;t interact well with interfaces.
3328   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3329       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3330       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3331     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3332     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3333   }
3334 
3335   return ft;
3336 }
3337 
3338 //------------------------------eq---------------------------------------------
3339 // Structural equality check for Type representations
3340 bool TypeOopPtr::eq( const Type *t ) const {
3341   const TypeOopPtr *a = (const TypeOopPtr*)t;
3342   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3343       _instance_id != a-&gt;_instance_id)  return false;
3344   ciObject* one = const_oop();
3345   ciObject* two = a-&gt;const_oop();
3346   if (one == NULL || two == NULL) {
3347     return (one == two) &amp;&amp; TypePtr::eq(t);
3348   } else {
3349     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3350   }
3351 }
3352 
3353 //------------------------------hash-------------------------------------------
3354 // Type-specific hashing function.
3355 int TypeOopPtr::hash(void) const {
3356   return
3357     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3358              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3359 }
3360 
3361 //------------------------------dump2------------------------------------------
3362 #ifndef PRODUCT
3363 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3364   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3365   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3366   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3367   switch( _offset ) {
3368   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
3369   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
3370   case         0: break;
3371   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
3372   }
3373   if (_instance_id == InstanceTop)
3374     st-&gt;print(&quot;,iid=top&quot;);
3375   else if (_instance_id != InstanceBot)
3376     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3377 
3378   dump_inline_depth(st);
3379   dump_speculative(st);
3380 }
3381 #endif
3382 
3383 //------------------------------singleton--------------------------------------
3384 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3385 // constants
3386 bool TypeOopPtr::singleton(void) const {
3387   // detune optimizer to not generate constant oop + constant offset as a constant!
3388   // TopPTR, Null, AnyNull, Constant are all singletons
3389   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
3390 }
3391 
3392 //------------------------------add_offset-------------------------------------
3393 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3394   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3395 }
3396 
3397 /**
3398  * Return same type without a speculative part
3399  */
3400 const Type* TypeOopPtr::remove_speculative() const {
3401   if (_speculative == NULL) {
3402     return this;
3403   }
3404   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3405   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3406 }
3407 
3408 /**
3409  * Return same type but drop speculative part if we know we won&#39;t use
3410  * it
3411  */
3412 const Type* TypeOopPtr::cleanup_speculative() const {
3413   // If the klass is exact and the ptr is not null then there&#39;s
3414   // nothing that the speculative type can help us with
3415   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3416     return remove_speculative();
3417   }
3418   return TypePtr::cleanup_speculative();
3419 }
3420 
3421 /**
3422  * Return same type but with a different inline depth (used for speculation)
3423  *
3424  * @param depth  depth to meet with
3425  */
3426 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3427   if (!UseInlineDepthForSpeculativeTypes) {
3428     return this;
3429   }
3430   return make(_ptr, _offset, _instance_id, _speculative, depth);
3431 }
3432 
3433 //------------------------------with_instance_id--------------------------------
3434 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3435   assert(_instance_id != -1, &quot;should be known&quot;);
3436   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3437 }
3438 
3439 //------------------------------meet_instance_id--------------------------------
3440 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3441   // Either is &#39;TOP&#39; instance?  Return the other instance!
3442   if( _instance_id == InstanceTop ) return  instance_id;
3443   if(  instance_id == InstanceTop ) return _instance_id;
3444   // If either is different, return &#39;BOTTOM&#39; instance
3445   if( _instance_id != instance_id ) return InstanceBot;
3446   return _instance_id;
3447 }
3448 
3449 //------------------------------dual_instance_id--------------------------------
3450 int TypeOopPtr::dual_instance_id( ) const {
3451   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3452   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3453   return _instance_id;              // Map everything else into self
3454 }
3455 
3456 /**
3457  * Check whether new profiling would improve speculative type
3458  *
3459  * @param   exact_kls    class from profiling
3460  * @param   inline_depth inlining depth of profile point
3461  *
3462  * @return  true if type profile is valuable
3463  */
3464 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3465   // no way to improve an already exact type
3466   if (klass_is_exact()) {
3467     return false;
3468   }
3469   return TypePtr::would_improve_type(exact_kls, inline_depth);
3470 }
3471 
3472 //=============================================================================
3473 // Convenience common pre-built types.
3474 const TypeInstPtr *TypeInstPtr::NOTNULL;
3475 const TypeInstPtr *TypeInstPtr::BOTTOM;
3476 const TypeInstPtr *TypeInstPtr::MIRROR;
3477 const TypeInstPtr *TypeInstPtr::MARK;
3478 const TypeInstPtr *TypeInstPtr::KLASS;
3479 
3480 //------------------------------TypeInstPtr-------------------------------------
3481 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,
3482                          int instance_id, const TypePtr* speculative, int inline_depth)
3483   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),
3484     _name(k-&gt;name()) {
3485    assert(k != NULL &amp;&amp;
3486           (k-&gt;is_loaded() || o == NULL),
3487           &quot;cannot have constants with non-loaded klass&quot;);
3488 };
3489 
3490 //------------------------------make-------------------------------------------
3491 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3492                                      ciKlass* k,
3493                                      bool xk,
3494                                      ciObject* o,
3495                                      int offset,
3496                                      int instance_id,
3497                                      const TypePtr* speculative,
3498                                      int inline_depth) {
3499   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3500   // Either const_oop() is NULL or else ptr is Constant
3501   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3502           &quot;constant pointers must have a value supplied&quot; );
3503   // Ptr is never Null
3504   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3505 
3506   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3507   if (!UseExactTypes)  xk = false;
3508   if (ptr == Constant) {
3509     // Note:  This case includes meta-object constants, such as methods.
3510     xk = true;
3511   } else if (k-&gt;is_loaded()) {
3512     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3513     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3514     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3515   }
3516 
3517   // Now hash this baby
3518   TypeInstPtr *result =
3519     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3520 
3521   return result;
3522 }
3523 
3524 /**
3525  *  Create constant type for a constant boxed value
3526  */
3527 const Type* TypeInstPtr::get_const_boxed_value() const {
3528   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3529   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3530   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3531   BasicType bt = constant.basic_type();
3532   switch (bt) {
3533     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3534     case T_INT:      return TypeInt::make(constant.as_int());
3535     case T_CHAR:     return TypeInt::make(constant.as_char());
3536     case T_BYTE:     return TypeInt::make(constant.as_byte());
3537     case T_SHORT:    return TypeInt::make(constant.as_short());
3538     case T_FLOAT:    return TypeF::make(constant.as_float());
3539     case T_DOUBLE:   return TypeD::make(constant.as_double());
3540     case T_LONG:     return TypeLong::make(constant.as_long());
3541     default:         break;
3542   }
3543   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3544   return NULL;
3545 }
3546 
3547 //------------------------------cast_to_ptr_type-------------------------------
3548 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3549   if( ptr == _ptr ) return this;
3550   // Reconstruct _sig info here since not a problem with later lazy
3551   // construction, _sig will show up on demand.
3552   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3553 }
3554 
3555 
3556 //-----------------------------cast_to_exactness-------------------------------
3557 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3558   if( klass_is_exact == _klass_is_exact ) return this;
3559   if (!UseExactTypes)  return this;
3560   if (!_klass-&gt;is_loaded())  return this;
3561   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3562   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3563   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3564   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3565 }
3566 
3567 //-----------------------------cast_to_instance_id----------------------------
3568 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3569   if( instance_id == _instance_id ) return this;
3570   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3571 }
3572 
3573 const TypeOopPtr *TypeInstPtr::cast_to_nonconst() const {
3574   if (const_oop() == NULL) return this;
3575   return make(NotNull, klass(), _klass_is_exact, NULL, _offset, _instance_id, _speculative, _inline_depth);
3576 }
3577 
3578 //------------------------------xmeet_unloaded---------------------------------
3579 // Compute the MEET of two InstPtrs when at least one is unloaded.
3580 // Assume classes are different since called after check for same name/class-loader
3581 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3582     int off = meet_offset(tinst-&gt;offset());
3583     PTR ptr = meet_ptr(tinst-&gt;ptr());
3584     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3585     const TypePtr* speculative = xmeet_speculative(tinst);
3586     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3587 
3588     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3589     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3590     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3591       //
3592       // Meet unloaded class with java/lang/Object
3593       //
3594       // Meet
3595       //          |                     Unloaded Class
3596       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3597       //  ===================================================================
3598       //   TOP    | ..........................Unloaded......................|
3599       //  AnyNull |  U-AN    |................Unloaded......................|
3600       // Constant | ... O-NN .................................. |   O-BOT   |
3601       //  NotNull | ... O-NN .................................. |   O-BOT   |
3602       //  BOTTOM  | ........................Object-BOTTOM ..................|
3603       //
3604       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3605       //
3606       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3607       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }
3608       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3609       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3610         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3611         else                                      { return TypeInstPtr::NOTNULL; }
3612       }
3613       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3614 
3615       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3616     }
3617 
3618     // Both are unloaded, not the same class, not Object
3619     // Or meet unloaded with a different loaded class, not java/lang/Object
3620     if( ptr != TypePtr::BotPTR ) {
3621       return TypeInstPtr::NOTNULL;
3622     }
3623     return TypeInstPtr::BOTTOM;
3624 }
3625 
3626 
3627 //------------------------------meet-------------------------------------------
3628 // Compute the MEET of two types.  It returns a new Type object.
3629 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3630   // Perform a fast test for common case; meeting the same types together.
3631   if( this == t ) return this;  // Meeting same type-rep?
3632 
3633   // Current &quot;this-&gt;_base&quot; is Pointer
3634   switch (t-&gt;base()) {          // switch on original type
3635 
3636   case Int:                     // Mixing ints &amp; oops happens when javac
3637   case Long:                    // reuses local variables
3638   case FloatTop:
3639   case FloatCon:
3640   case FloatBot:
3641   case DoubleTop:
3642   case DoubleCon:
3643   case DoubleBot:
3644   case NarrowOop:
3645   case NarrowKlass:
3646   case Bottom:                  // Ye Olde Default
3647     return Type::BOTTOM;
3648   case Top:
3649     return this;
3650 
3651   default:                      // All else is a mistake
3652     typerr(t);
3653 
3654   case MetadataPtr:
3655   case KlassPtr:
3656   case RawPtr: return TypePtr::BOTTOM;
3657 
3658   case AryPtr: {                // All arrays inherit from Object class
3659     const TypeAryPtr *tp = t-&gt;is_aryptr();
3660     int offset = meet_offset(tp-&gt;offset());
3661     PTR ptr = meet_ptr(tp-&gt;ptr());
3662     int instance_id = meet_instance_id(tp-&gt;instance_id());
3663     const TypePtr* speculative = xmeet_speculative(tp);
3664     int depth = meet_inline_depth(tp-&gt;inline_depth());
3665     switch (ptr) {
3666     case TopPTR:
3667     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3668       // For instances when a subclass meets a superclass we fall
3669       // below the centerline when the superclass is exact. We need to
3670       // do the same here.
3671       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3672         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3673       } else {
3674         // cannot subclass, so the meet has to fall badly below the centerline
3675         ptr = NotNull;
3676         instance_id = InstanceBot;
3677         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3678       }
3679     case Constant:
3680     case NotNull:
3681     case BotPTR:                // Fall down to object klass
3682       // LCA is object_klass, but if we subclass from the top we can do better
3683       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3684         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3685         // then we can subclass in the Java class hierarchy.
3686         // For instances when a subclass meets a superclass we fall
3687         // below the centerline when the superclass is exact. We need
3688         // to do the same here.
3689         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3690           // that is, tp&#39;s array type is a subtype of my klass
3691           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3692                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3693         }
3694       }
3695       // The other case cannot happen, since I cannot be a subtype of an array.
3696       // The meet falls down to Object class below centerline.
3697       if( ptr == Constant )
3698          ptr = NotNull;
3699       instance_id = InstanceBot;
3700       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3701     default: typerr(t);
3702     }
3703   }
3704 
3705   case OopPtr: {                // Meeting to OopPtrs
3706     // Found a OopPtr type vs self-InstPtr type
3707     const TypeOopPtr *tp = t-&gt;is_oopptr();
3708     int offset = meet_offset(tp-&gt;offset());
3709     PTR ptr = meet_ptr(tp-&gt;ptr());
3710     switch (tp-&gt;ptr()) {
3711     case TopPTR:
3712     case AnyNull: {
3713       int instance_id = meet_instance_id(InstanceTop);
3714       const TypePtr* speculative = xmeet_speculative(tp);
3715       int depth = meet_inline_depth(tp-&gt;inline_depth());
3716       return make(ptr, klass(), klass_is_exact(),
3717                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3718     }
3719     case NotNull:
3720     case BotPTR: {
3721       int instance_id = meet_instance_id(tp-&gt;instance_id());
3722       const TypePtr* speculative = xmeet_speculative(tp);
3723       int depth = meet_inline_depth(tp-&gt;inline_depth());
3724       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3725     }
3726     default: typerr(t);
3727     }
3728   }
3729 
3730   case AnyPtr: {                // Meeting to AnyPtrs
3731     // Found an AnyPtr type vs self-InstPtr type
3732     const TypePtr *tp = t-&gt;is_ptr();
3733     int offset = meet_offset(tp-&gt;offset());
3734     PTR ptr = meet_ptr(tp-&gt;ptr());
3735     int instance_id = meet_instance_id(InstanceTop);
3736     const TypePtr* speculative = xmeet_speculative(tp);
3737     int depth = meet_inline_depth(tp-&gt;inline_depth());
3738     switch (tp-&gt;ptr()) {
3739     case Null:
3740       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3741       // else fall through to AnyNull
3742     case TopPTR:
3743     case AnyNull: {
3744       return make(ptr, klass(), klass_is_exact(),
3745                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3746     }
3747     case NotNull:
3748     case BotPTR:
3749       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3750     default: typerr(t);
3751     }
3752   }
3753 
3754   /*
3755                  A-top         }
3756                /   |   \       }  Tops
3757            B-top A-any C-top   }
3758               | /  |  \ |      }  Any-nulls
3759            B-any   |   C-any   }
3760               |    |    |
3761            B-con A-con C-con   } constants; not comparable across classes
3762               |    |    |
3763            B-not   |   C-not   }
3764               | \  |  / |      }  not-nulls
3765            B-bot A-not C-bot   }
3766                \   |   /       }  Bottoms
3767                  A-bot         }
3768   */
3769 
3770   case InstPtr: {                // Meeting 2 Oops?
3771     // Found an InstPtr sub-type vs self-InstPtr type
3772     const TypeInstPtr *tinst = t-&gt;is_instptr();
3773     int off = meet_offset( tinst-&gt;offset() );
3774     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3775     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3776     const TypePtr* speculative = xmeet_speculative(tinst);
3777     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3778 
3779     // Check for easy case; klasses are equal (and perhaps not loaded!)
3780     // If we have constants, then we created oops so classes are loaded
3781     // and we can handle the constants further down.  This case handles
3782     // both-not-loaded or both-loaded classes
3783     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {
3784       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);
3785     }
3786 
3787     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3788     ciKlass* tinst_klass = tinst-&gt;klass();
3789     ciKlass* this_klass  = this-&gt;klass();
3790     bool tinst_xk = tinst-&gt;klass_is_exact();
3791     bool this_xk  = this-&gt;klass_is_exact();
3792     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3793       // One of these classes has not been loaded
3794       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3795 #ifndef PRODUCT
3796       if( PrintOpto &amp;&amp; Verbose ) {
3797         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3798         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3799         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3800       }
3801 #endif
3802       return unloaded_meet;
3803     }
3804 
3805     // Handle mixing oops and interfaces first.
3806     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3807                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3808       ciKlass *tmp = tinst_klass; // Swap interface around
3809       tinst_klass = this_klass;
3810       this_klass = tmp;
3811       bool tmp2 = tinst_xk;
3812       tinst_xk = this_xk;
3813       this_xk = tmp2;
3814     }
3815     if (tinst_klass-&gt;is_interface() &amp;&amp;
3816         !(this_klass-&gt;is_interface() ||
3817           // Treat java/lang/Object as an honorary interface,
3818           // because we need a bottom for the interface hierarchy.
3819           this_klass == ciEnv::current()-&gt;Object_klass())) {
3820       // Oop meets interface!
3821 
3822       // See if the oop subtypes (implements) interface.
3823       ciKlass *k;
3824       bool xk;
3825       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3826         // Oop indeed subtypes.  Now keep oop or interface depending
3827         // on whether we are both above the centerline or either is
3828         // below the centerline.  If we are on the centerline
3829         // (e.g., Constant vs. AnyNull interface), use the constant.
3830         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3831         // If we are keeping this_klass, keep its exactness too.
3832         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
3833       } else {                  // Does not implement, fall to Object
3834         // Oop does not implement interface, so mixing falls to Object
3835         // just like the verifier does (if both are above the
3836         // centerline fall to interface)
3837         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3838         xk = above_centerline(ptr) ? tinst_xk : false;
3839         // Watch out for Constant vs. AnyNull interface.
3840         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3841         instance_id = InstanceBot;
3842       }
3843       ciObject* o = NULL;  // the Constant value, if any
3844       if (ptr == Constant) {
3845         // Find out which constant.
3846         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3847       }
3848       return make(ptr, k, xk, o, off, instance_id, speculative, depth);
3849     }
3850 
3851     // Either oop vs oop or interface vs interface or interface vs Object
3852 
3853     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3854     // If we split one up &amp; one down AND they subtype, take the down man.
3855     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3856     // If both are up and they subtype, take the subtype class.
3857     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3858     // If both are down and they subtype, take the supertype class.
3859     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3860     // Constants treated as down.
3861 
3862     // Now, reorder the above list; observe that both-down+subtype is also
3863     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3864     // If we split one up &amp; one down AND they subtype, take the down man.
3865     // If both are up and they subtype, take the subtype class.
3866 
3867     // If both are down and they subtype, &quot;fall hard&quot;.
3868     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3869     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3870     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3871 
3872     // If a proper subtype is exact, and we return it, we return it exactly.
3873     // If a proper supertype is exact, there can be no subtyping relationship!
3874     // If both types are equal to the subtype, exactness is and-ed below the
3875     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3876 
3877     // Check for subtyping:
3878     ciKlass *subtype = NULL;
3879     bool subtype_exact = false;
3880     if( tinst_klass-&gt;equals(this_klass) ) {
3881       subtype = this_klass;
3882       subtype_exact = below_centerline(ptr) ? (this_xk &amp; tinst_xk) : (this_xk | tinst_xk);
3883     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3884       subtype = this_klass;     // Pick subtyping class
3885       subtype_exact = this_xk;
3886     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3887       subtype = tinst_klass;    // Pick subtyping class
3888       subtype_exact = tinst_xk;
3889     }
3890 
3891     if( subtype ) {
3892       if( above_centerline(ptr) ) { // both are up?
3893         this_klass = tinst_klass = subtype;
3894         this_xk = tinst_xk = subtype_exact;
3895       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3896         this_klass = tinst_klass; // tinst is down; keep down man
3897         this_xk = tinst_xk;
3898       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3899         tinst_klass = this_klass; // this is down; keep down man
3900         tinst_xk = this_xk;
3901       } else {
3902         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
3903       }
3904     }
3905 
3906     // Check for classes now being equal
3907     if (tinst_klass-&gt;equals(this_klass)) {
3908       // If the klasses are equal, the constants may still differ.  Fall to
3909       // NotNull if they do (neither constant is NULL; that is a special case
3910       // handled elsewhere).
3911       ciObject* o = NULL;             // Assume not constant when done
3912       ciObject* this_oop  = const_oop();
3913       ciObject* tinst_oop = tinst-&gt;const_oop();
3914       if( ptr == Constant ) {
3915         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3916             this_oop-&gt;equals(tinst_oop) )
3917           o = this_oop;
3918         else if (above_centerline(this -&gt;_ptr))
3919           o = tinst_oop;
3920         else if (above_centerline(tinst -&gt;_ptr))
3921           o = this_oop;
3922         else
3923           ptr = NotNull;
3924       }
3925       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);
3926     } // Else classes are not equal
3927 
3928     // Since klasses are different, we require a LCA in the Java
3929     // class hierarchy - which means we have to fall to at least NotNull.
3930     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3931       ptr = NotNull;
3932 
3933     instance_id = InstanceBot;
3934 
3935     // Now we find the LCA of Java classes
3936     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
3937     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);
3938   } // End of case InstPtr
3939 
3940   } // End of switch
3941   return this;                  // Return the double constant
3942 }
3943 
3944 
3945 //------------------------java_mirror_type--------------------------------------
3946 ciType* TypeInstPtr::java_mirror_type() const {
3947   // must be a singleton type
3948   if( const_oop() == NULL )  return NULL;
3949 
3950   // must be of type java.lang.Class
3951   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
3952 
3953   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3954 }
3955 
3956 
3957 //------------------------------xdual------------------------------------------
3958 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3959 // inheritance mechanism.
3960 const Type *TypeInstPtr::xdual() const {
3961   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3962 }
3963 
3964 //------------------------------eq---------------------------------------------
3965 // Structural equality check for Type representations
3966 bool TypeInstPtr::eq( const Type *t ) const {
3967   const TypeInstPtr *p = t-&gt;is_instptr();
3968   return
3969     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
3970     TypeOopPtr::eq(p);          // Check sub-type stuff
3971 }
3972 
3973 //------------------------------hash-------------------------------------------
3974 // Type-specific hashing function.
3975 int TypeInstPtr::hash(void) const {
3976   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());
3977   return hash;
3978 }
3979 
3980 //------------------------------dump2------------------------------------------
3981 // Dump oop Type
3982 #ifndef PRODUCT
3983 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3984   // Print the name of the klass.
3985   klass()-&gt;print_name_on(st);
3986 
3987   switch( _ptr ) {
3988   case Constant:
3989     // TO DO: Make CI print the hex address of the underlying oop.
3990     if (WizardMode || Verbose) {
3991       const_oop()-&gt;print_oop(st);
3992     }
3993   case BotPTR:
3994     if (!WizardMode &amp;&amp; !Verbose) {
3995       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3996       break;
3997     }
3998   case TopPTR:
3999   case AnyNull:
4000   case NotNull:
4001     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4002     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4003     break;
4004   default:
4005     break;
4006   }
4007 
4008   if( _offset ) {               // Dump offset, if any
4009     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);
4010     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);
4011     else st-&gt;print(&quot;+%d&quot;, _offset);
4012   }
4013 
4014   st-&gt;print(&quot; *&quot;);
4015   if (_instance_id == InstanceTop)
4016     st-&gt;print(&quot;,iid=top&quot;);
4017   else if (_instance_id != InstanceBot)
4018     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4019 
4020   dump_inline_depth(st);
4021   dump_speculative(st);
4022 }
4023 #endif
4024 
4025 //------------------------------add_offset-------------------------------------
4026 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4027   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),
4028               _instance_id, add_offset_speculative(offset), _inline_depth);
4029 }
4030 
4031 const Type *TypeInstPtr::remove_speculative() const {
4032   if (_speculative == NULL) {
4033     return this;
4034   }
4035   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4036   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,
4037               _instance_id, NULL, _inline_depth);
4038 }
4039 
4040 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4041   if (!UseInlineDepthForSpeculativeTypes) {
4042     return this;
4043   }
4044   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);
4045 }
4046 
4047 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4048   assert(is_known_instance(), &quot;should be known&quot;);
4049   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);
4050 }
4051 
4052 //=============================================================================
4053 // Convenience common pre-built types.
4054 const TypeAryPtr *TypeAryPtr::RANGE;
4055 const TypeAryPtr *TypeAryPtr::OOPS;
4056 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4057 const TypeAryPtr *TypeAryPtr::BYTES;
4058 const TypeAryPtr *TypeAryPtr::SHORTS;
4059 const TypeAryPtr *TypeAryPtr::CHARS;
4060 const TypeAryPtr *TypeAryPtr::INTS;
4061 const TypeAryPtr *TypeAryPtr::LONGS;
4062 const TypeAryPtr *TypeAryPtr::FLOATS;
4063 const TypeAryPtr *TypeAryPtr::DOUBLES;
4064 
4065 //------------------------------make-------------------------------------------
4066 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4067                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4068   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4069          &quot;integral arrays must be pre-equipped with a class&quot;);
4070   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4071   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4072   if (!UseExactTypes)  xk = (ptr == Constant);
4073   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4074 }
4075 
4076 //------------------------------make-------------------------------------------
4077 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4078                                    int instance_id, const TypePtr* speculative, int inline_depth,
4079                                    bool is_autobox_cache) {
4080   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4081          &quot;integral arrays must be pre-equipped with a class&quot;);
4082   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4083   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4084   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4085   if (!UseExactTypes)  xk = (ptr == Constant);
4086   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4087 }
4088 
4089 //------------------------------cast_to_ptr_type-------------------------------
4090 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4091   if( ptr == _ptr ) return this;
4092   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4093 }
4094 
4095 
4096 //-----------------------------cast_to_exactness-------------------------------
4097 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4098   if( klass_is_exact == _klass_is_exact ) return this;
4099   if (!UseExactTypes)  return this;
4100   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4101   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4102 }
4103 
4104 //-----------------------------cast_to_instance_id----------------------------
4105 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4106   if( instance_id == _instance_id ) return this;
4107   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4108 }
4109 
4110 const TypeOopPtr *TypeAryPtr::cast_to_nonconst() const {
4111   if (const_oop() == NULL) return this;
4112   return make(NotNull, NULL, _ary, klass(), _klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4113 }
4114 
4115 
4116 //-----------------------------narrow_size_type-------------------------------
4117 // Local cache for arrayOopDesc::max_array_length(etype),
4118 // which is kind of slow (and cached elsewhere by other users).
4119 static jint max_array_length_cache[T_CONFLICT+1];
4120 static jint max_array_length(BasicType etype) {
4121   jint&amp; cache = max_array_length_cache[etype];
4122   jint res = cache;
4123   if (res == 0) {
4124     switch (etype) {
4125     case T_NARROWOOP:
4126       etype = T_OBJECT;
4127       break;
4128     case T_NARROWKLASS:
4129     case T_CONFLICT:
4130     case T_ILLEGAL:
4131     case T_VOID:
4132       etype = T_BYTE;           // will produce conservatively high value
4133       break;
4134     default:
4135       break;
4136     }
4137     cache = res = arrayOopDesc::max_array_length(etype);
4138   }
4139   return res;
4140 }
4141 
4142 // Narrow the given size type to the index range for the given array base type.
4143 // Return NULL if the resulting int type becomes empty.
4144 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4145   jint hi = size-&gt;_hi;
4146   jint lo = size-&gt;_lo;
4147   jint min_lo = 0;
4148   jint max_hi = max_array_length(elem()-&gt;basic_type());
4149   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4150   bool chg = false;
4151   if (lo &lt; min_lo) {
4152     lo = min_lo;
4153     if (size-&gt;is_con()) {
4154       hi = lo;
4155     }
4156     chg = true;
4157   }
4158   if (hi &gt; max_hi) {
4159     hi = max_hi;
4160     if (size-&gt;is_con()) {
4161       lo = hi;
4162     }
4163     chg = true;
4164   }
4165   // Negative length arrays will produce weird intermediate dead fast-path code
4166   if (lo &gt; hi)
4167     return TypeInt::ZERO;
4168   if (!chg)
4169     return size;
4170   return TypeInt::make(lo, hi, Type::WidenMin);
4171 }
4172 
4173 //-------------------------------cast_to_size----------------------------------
4174 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4175   assert(new_size != NULL, &quot;&quot;);
4176   new_size = narrow_size_type(new_size);
4177   if (new_size == size())  return this;
4178   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());
4179   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4180 }
4181 
4182 //------------------------------cast_to_stable---------------------------------
4183 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4184   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4185     return this;
4186 
4187   const Type* elem = this-&gt;elem();
4188   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4189 
4190   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4191     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4192     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4193   }
4194 
4195   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);
4196 
4197   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4198 }
4199 
4200 //-----------------------------stable_dimension--------------------------------
4201 int TypeAryPtr::stable_dimension() const {
4202   if (!is_stable())  return 0;
4203   int dim = 1;
4204   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4205   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4206     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4207   return dim;
4208 }
4209 
4210 //----------------------cast_to_autobox_cache-----------------------------------
4211 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4212   if (is_autobox_cache() == cache)  return this;
4213   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4214   if (etype == NULL)  return this;
4215   // The pointers in the autobox arrays are always non-null.
4216   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4217   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4218   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());
4219   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);
4220 }
4221 
4222 //------------------------------eq---------------------------------------------
4223 // Structural equality check for Type representations
4224 bool TypeAryPtr::eq( const Type *t ) const {
4225   const TypeAryPtr *p = t-&gt;is_aryptr();
4226   return
4227     _ary == p-&gt;_ary &amp;&amp;  // Check array
4228     TypeOopPtr::eq(p);  // Check sub-parts
4229 }
4230 
4231 //------------------------------hash-------------------------------------------
4232 // Type-specific hashing function.
4233 int TypeAryPtr::hash(void) const {
4234   return (intptr_t)_ary + TypeOopPtr::hash();
4235 }
4236 
4237 //------------------------------meet-------------------------------------------
4238 // Compute the MEET of two types.  It returns a new Type object.
4239 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4240   // Perform a fast test for common case; meeting the same types together.
4241   if( this == t ) return this;  // Meeting same type-rep?
4242   // Current &quot;this-&gt;_base&quot; is Pointer
4243   switch (t-&gt;base()) {          // switch on original type
4244 
4245   // Mixing ints &amp; oops happens when javac reuses local variables
4246   case Int:
4247   case Long:
4248   case FloatTop:
4249   case FloatCon:
4250   case FloatBot:
4251   case DoubleTop:
4252   case DoubleCon:
4253   case DoubleBot:
4254   case NarrowOop:
4255   case NarrowKlass:
4256   case Bottom:                  // Ye Olde Default
4257     return Type::BOTTOM;
4258   case Top:
4259     return this;
4260 
4261   default:                      // All else is a mistake
4262     typerr(t);
4263 
4264   case OopPtr: {                // Meeting to OopPtrs
4265     // Found a OopPtr type vs self-AryPtr type
4266     const TypeOopPtr *tp = t-&gt;is_oopptr();
4267     int offset = meet_offset(tp-&gt;offset());
4268     PTR ptr = meet_ptr(tp-&gt;ptr());
4269     int depth = meet_inline_depth(tp-&gt;inline_depth());
4270     const TypePtr* speculative = xmeet_speculative(tp);
4271     switch (tp-&gt;ptr()) {
4272     case TopPTR:
4273     case AnyNull: {
4274       int instance_id = meet_instance_id(InstanceTop);
4275       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4276                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4277     }
4278     case BotPTR:
4279     case NotNull: {
4280       int instance_id = meet_instance_id(tp-&gt;instance_id());
4281       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4282     }
4283     default: ShouldNotReachHere();
4284     }
4285   }
4286 
4287   case AnyPtr: {                // Meeting two AnyPtrs
4288     // Found an AnyPtr type vs self-AryPtr type
4289     const TypePtr *tp = t-&gt;is_ptr();
4290     int offset = meet_offset(tp-&gt;offset());
4291     PTR ptr = meet_ptr(tp-&gt;ptr());
4292     const TypePtr* speculative = xmeet_speculative(tp);
4293     int depth = meet_inline_depth(tp-&gt;inline_depth());
4294     switch (tp-&gt;ptr()) {
4295     case TopPTR:
4296       return this;
4297     case BotPTR:
4298     case NotNull:
4299       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4300     case Null:
4301       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4302       // else fall through to AnyNull
4303     case AnyNull: {
4304       int instance_id = meet_instance_id(InstanceTop);
4305       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4306                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4307     }
4308     default: ShouldNotReachHere();
4309     }
4310   }
4311 
4312   case MetadataPtr:
4313   case KlassPtr:
4314   case RawPtr: return TypePtr::BOTTOM;
4315 
4316   case AryPtr: {                // Meeting 2 references?
4317     const TypeAryPtr *tap = t-&gt;is_aryptr();
4318     int off = meet_offset(tap-&gt;offset());
4319     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4320     PTR ptr = meet_ptr(tap-&gt;ptr());
4321     int instance_id = meet_instance_id(tap-&gt;instance_id());
4322     const TypePtr* speculative = xmeet_speculative(tap);
4323     int depth = meet_inline_depth(tap-&gt;inline_depth());
4324     ciKlass* lazy_klass = NULL;
4325     if (tary-&gt;_elem-&gt;isa_int()) {
4326       // Integral array element types have irrelevant lattice relations.
4327       // It is the klass that determines array layout, not the element type.
4328       if (_klass == NULL)
4329         lazy_klass = tap-&gt;_klass;
4330       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4331         lazy_klass = _klass;
4332       } else {
4333         // Something like byte[int+] meets char[int+].
4334         // This must fall to bottom, not (int[-128..65535])[int+].
4335         instance_id = InstanceBot;
4336         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4337       }
4338     } else // Non integral arrays.
4339       // Must fall to bottom if exact klasses in upper lattice
4340       // are not equal or super klass is exact.
4341       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4342           // meet with top[] and bottom[] are processed further down:
4343           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;
4344           // both are exact and not equal:
4345           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4346            // &#39;tap&#39;  is exact and super or unrelated:
4347            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4348            // &#39;this&#39; is exact and super or unrelated:
4349            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4350       if (above_centerline(ptr)) {
4351         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4352       }
4353       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4354     }
4355 
4356     bool xk = false;
4357     switch (tap-&gt;ptr()) {
4358     case AnyNull:
4359     case TopPTR:
4360       // Compute new klass on demand, do not use tap-&gt;_klass
4361       if (below_centerline(this-&gt;_ptr)) {
4362         xk = this-&gt;_klass_is_exact;
4363       } else {
4364         xk = (tap-&gt;_klass_is_exact | this-&gt;_klass_is_exact);
4365       }
4366       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4367     case Constant: {
4368       ciObject* o = const_oop();
4369       if( _ptr == Constant ) {
4370         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4371           xk = (klass() == tap-&gt;klass());
4372           ptr = NotNull;
4373           o = NULL;
4374           instance_id = InstanceBot;
4375         } else {
4376           xk = true;
4377         }
4378       } else if(above_centerline(_ptr)) {
4379         o = tap-&gt;const_oop();
4380         xk = true;
4381       } else {
4382         // Only precise for identical arrays
4383         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4384       }
4385       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4386     }
4387     case NotNull:
4388     case BotPTR:
4389       // Compute new klass on demand, do not use tap-&gt;_klass
4390       if (above_centerline(this-&gt;_ptr))
4391             xk = tap-&gt;_klass_is_exact;
4392       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4393               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4394       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4395     default: ShouldNotReachHere();
4396     }
4397   }
4398 
4399   // All arrays inherit from Object class
4400   case InstPtr: {
4401     const TypeInstPtr *tp = t-&gt;is_instptr();
4402     int offset = meet_offset(tp-&gt;offset());
4403     PTR ptr = meet_ptr(tp-&gt;ptr());
4404     int instance_id = meet_instance_id(tp-&gt;instance_id());
4405     const TypePtr* speculative = xmeet_speculative(tp);
4406     int depth = meet_inline_depth(tp-&gt;inline_depth());
4407     switch (ptr) {
4408     case TopPTR:
4409     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4410       // For instances when a subclass meets a superclass we fall
4411       // below the centerline when the superclass is exact. We need to
4412       // do the same here.
4413       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4414         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4415       } else {
4416         // cannot subclass, so the meet has to fall badly below the centerline
4417         ptr = NotNull;
4418         instance_id = InstanceBot;
4419         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4420       }
4421     case Constant:
4422     case NotNull:
4423     case BotPTR:                // Fall down to object klass
4424       // LCA is object_klass, but if we subclass from the top we can do better
4425       if (above_centerline(tp-&gt;ptr())) {
4426         // If &#39;tp&#39;  is above the centerline and it is Object class
4427         // then we can subclass in the Java class hierarchy.
4428         // For instances when a subclass meets a superclass we fall
4429         // below the centerline when the superclass is exact. We need
4430         // to do the same here.
4431         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4432           // that is, my array type is a subtype of &#39;tp&#39; klass
4433           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4434                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4435         }
4436       }
4437       // The other case cannot happen, since t cannot be a subtype of an array.
4438       // The meet falls down to Object class below centerline.
4439       if( ptr == Constant )
4440          ptr = NotNull;
4441       instance_id = InstanceBot;
4442       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4443     default: typerr(t);
4444     }
4445   }
4446   }
4447   return this;                  // Lint noise
4448 }
4449 
4450 //------------------------------xdual------------------------------------------
4451 // Dual: compute field-by-field dual
4452 const Type *TypeAryPtr::xdual() const {
4453   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4454 }
4455 
4456 //----------------------interface_vs_oop---------------------------------------
4457 #ifdef ASSERT
4458 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4459   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4460   if (t_aryptr) {
4461     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4462   }
4463   return false;
4464 }
4465 #endif
4466 
4467 //------------------------------dump2------------------------------------------
4468 #ifndef PRODUCT
4469 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4470   _ary-&gt;dump2(d,depth,st);
4471   switch( _ptr ) {
4472   case Constant:
4473     const_oop()-&gt;print(st);
4474     break;
4475   case BotPTR:
4476     if (!WizardMode &amp;&amp; !Verbose) {
4477       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4478       break;
4479     }
4480   case TopPTR:
4481   case AnyNull:
4482   case NotNull:
4483     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4484     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4485     break;
4486   default:
4487     break;
4488   }
4489 
4490   if( _offset != 0 ) {
4491     int header_size = objArrayOopDesc::header_size() * wordSize;
4492     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);
4493     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);
4494     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);
4495     else {
4496       BasicType basic_elem_type = elem()-&gt;basic_type();
4497       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4498       int elem_size = type2aelembytes(basic_elem_type);
4499       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);
4500     }
4501   }
4502   st-&gt;print(&quot; *&quot;);
4503   if (_instance_id == InstanceTop)
4504     st-&gt;print(&quot;,iid=top&quot;);
4505   else if (_instance_id != InstanceBot)
4506     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4507 
4508   dump_inline_depth(st);
4509   dump_speculative(st);
4510 }
4511 #endif
4512 
4513 bool TypeAryPtr::empty(void) const {
4514   if (_ary-&gt;empty())       return true;
4515   return TypeOopPtr::empty();
4516 }
4517 
4518 //------------------------------add_offset-------------------------------------
4519 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4520   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
4521 }
4522 
4523 const Type *TypeAryPtr::remove_speculative() const {
4524   if (_speculative == NULL) {
4525     return this;
4526   }
4527   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4528   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);
4529 }
4530 
4531 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4532   if (!UseInlineDepthForSpeculativeTypes) {
4533     return this;
4534   }
4535   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);
4536 }
4537 
4538 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4539   assert(is_known_instance(), &quot;should be known&quot;);
4540   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4541 }
4542 
4543 //=============================================================================
4544 
4545 //------------------------------hash-------------------------------------------
4546 // Type-specific hashing function.
4547 int TypeNarrowPtr::hash(void) const {
4548   return _ptrtype-&gt;hash() + 7;
4549 }
4550 
4551 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4552   return _ptrtype-&gt;singleton();
4553 }
4554 
4555 bool TypeNarrowPtr::empty(void) const {
4556   return _ptrtype-&gt;empty();
4557 }
4558 
4559 intptr_t TypeNarrowPtr::get_con() const {
4560   return _ptrtype-&gt;get_con();
4561 }
4562 
4563 bool TypeNarrowPtr::eq( const Type *t ) const {
4564   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
4565   if (tc != NULL) {
4566     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
4567       return false;
4568     }
4569     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
4570   }
4571   return false;
4572 }
4573 
4574 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
4575   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
4576   return make_same_narrowptr(odual);
4577 }
4578 
4579 
4580 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
4581   if (isa_same_narrowptr(kills)) {
4582     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
4583     if (ft-&gt;empty())
4584       return Type::TOP;           // Canonical empty value
4585     if (ft-&gt;isa_ptr()) {
4586       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
4587     }
4588     return ft;
4589   } else if (kills-&gt;isa_ptr()) {
4590     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
4591     if (ft-&gt;empty())
4592       return Type::TOP;           // Canonical empty value
4593     return ft;
4594   } else {
4595     return Type::TOP;
4596   }
4597 }
4598 
4599 //------------------------------xmeet------------------------------------------
4600 // Compute the MEET of two types.  It returns a new Type object.
4601 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
4602   // Perform a fast test for common case; meeting the same types together.
4603   if( this == t ) return this;  // Meeting same type-rep?
4604 
4605   if (t-&gt;base() == base()) {
4606     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
4607     if (result-&gt;isa_ptr()) {
4608       return make_hash_same_narrowptr(result-&gt;is_ptr());
4609     }
4610     return result;
4611   }
4612 
4613   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4614   switch (t-&gt;base()) {          // switch on original type
4615 
4616   case Int:                     // Mixing ints &amp; oops happens when javac
4617   case Long:                    // reuses local variables
4618   case FloatTop:
4619   case FloatCon:
4620   case FloatBot:
4621   case DoubleTop:
4622   case DoubleCon:
4623   case DoubleBot:
4624   case AnyPtr:
4625   case RawPtr:
4626   case OopPtr:
4627   case InstPtr:
4628   case AryPtr:
4629   case MetadataPtr:
4630   case KlassPtr:
4631   case NarrowOop:
4632   case NarrowKlass:
4633 
4634   case Bottom:                  // Ye Olde Default
4635     return Type::BOTTOM;
4636   case Top:
4637     return this;
4638 
4639   default:                      // All else is a mistake
4640     typerr(t);
4641 
4642   } // End of switch
4643 
4644   return this;
4645 }
4646 
4647 #ifndef PRODUCT
4648 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4649   _ptrtype-&gt;dump2(d, depth, st);
4650 }
4651 #endif
4652 
4653 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4654 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4655 
4656 
4657 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4658   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
4659 }
4660 
4661 const Type* TypeNarrowOop::remove_speculative() const {
4662   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
4663 }
4664 
4665 const Type* TypeNarrowOop::cleanup_speculative() const {
4666   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
4667 }
4668 
4669 #ifndef PRODUCT
4670 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4671   st-&gt;print(&quot;narrowoop: &quot;);
4672   TypeNarrowPtr::dump2(d, depth, st);
4673 }
4674 #endif
4675 
4676 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
4677 
4678 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
4679   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
4680 }
4681 
4682 #ifndef PRODUCT
4683 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4684   st-&gt;print(&quot;narrowklass: &quot;);
4685   TypeNarrowPtr::dump2(d, depth, st);
4686 }
4687 #endif
4688 
4689 
4690 //------------------------------eq---------------------------------------------
4691 // Structural equality check for Type representations
4692 bool TypeMetadataPtr::eq( const Type *t ) const {
4693   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
4694   ciMetadata* one = metadata();
4695   ciMetadata* two = a-&gt;metadata();
4696   if (one == NULL || two == NULL) {
4697     return (one == two) &amp;&amp; TypePtr::eq(t);
4698   } else {
4699     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4700   }
4701 }
4702 
4703 //------------------------------hash-------------------------------------------
4704 // Type-specific hashing function.
4705 int TypeMetadataPtr::hash(void) const {
4706   return
4707     (metadata() ? metadata()-&gt;hash() : 0) +
4708     TypePtr::hash();
4709 }
4710 
4711 //------------------------------singleton--------------------------------------
4712 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4713 // constants
4714 bool TypeMetadataPtr::singleton(void) const {
4715   // detune optimizer to not generate constant metadata + constant offset as a constant!
4716   // TopPTR, Null, AnyNull, Constant are all singletons
4717   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4718 }
4719 
4720 //------------------------------add_offset-------------------------------------
4721 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4722   return make( _ptr, _metadata, xadd_offset(offset));
4723 }
4724 
4725 //-----------------------------filter------------------------------------------
4726 // Do not allow interface-vs.-noninterface joins to collapse to top.
4727 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4728   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4729   if (ft == NULL || ft-&gt;empty())
4730     return Type::TOP;           // Canonical empty value
4731   return ft;
4732 }
4733 
4734  //------------------------------get_con----------------------------------------
4735 intptr_t TypeMetadataPtr::get_con() const {
4736   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
4737   assert( _offset &gt;= 0, &quot;&quot; );
4738 
4739   if (_offset != 0) {
4740     // After being ported to the compiler interface, the compiler no longer
4741     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4742     // to a handle at compile time.  This handle is embedded in the generated
4743     // code and dereferenced at the time the nmethod is made.  Until that time,
4744     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4745     // have access to the addresses!).  This does not seem to currently happen,
4746     // but this assertion here is to help prevent its occurence.
4747     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4748     ShouldNotReachHere();
4749   }
4750 
4751   return (intptr_t)metadata()-&gt;constant_encoding();
4752 }
4753 
4754 //------------------------------cast_to_ptr_type-------------------------------
4755 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4756   if( ptr == _ptr ) return this;
4757   return make(ptr, metadata(), _offset);
4758 }
4759 
4760 //------------------------------meet-------------------------------------------
4761 // Compute the MEET of two types.  It returns a new Type object.
4762 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
4763   // Perform a fast test for common case; meeting the same types together.
4764   if( this == t ) return this;  // Meeting same type-rep?
4765 
4766   // Current &quot;this-&gt;_base&quot; is OopPtr
4767   switch (t-&gt;base()) {          // switch on original type
4768 
4769   case Int:                     // Mixing ints &amp; oops happens when javac
4770   case Long:                    // reuses local variables
4771   case FloatTop:
4772   case FloatCon:
4773   case FloatBot:
4774   case DoubleTop:
4775   case DoubleCon:
4776   case DoubleBot:
4777   case NarrowOop:
4778   case NarrowKlass:
4779   case Bottom:                  // Ye Olde Default
4780     return Type::BOTTOM;
4781   case Top:
4782     return this;
4783 
4784   default:                      // All else is a mistake
4785     typerr(t);
4786 
4787   case AnyPtr: {
4788     // Found an AnyPtr type vs self-OopPtr type
4789     const TypePtr *tp = t-&gt;is_ptr();
4790     int offset = meet_offset(tp-&gt;offset());
4791     PTR ptr = meet_ptr(tp-&gt;ptr());
4792     switch (tp-&gt;ptr()) {
4793     case Null:
4794       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4795       // else fall through:
4796     case TopPTR:
4797     case AnyNull: {
4798       return make(ptr, _metadata, offset);
4799     }
4800     case BotPTR:
4801     case NotNull:
4802       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4803     default: typerr(t);
4804     }
4805   }
4806 
4807   case RawPtr:
4808   case KlassPtr:
4809   case OopPtr:
4810   case InstPtr:
4811   case AryPtr:
4812     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4813 
4814   case MetadataPtr: {
4815     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
4816     int offset = meet_offset(tp-&gt;offset());
4817     PTR tptr = tp-&gt;ptr();
4818     PTR ptr = meet_ptr(tptr);
4819     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4820     if (tptr == TopPTR || _ptr == TopPTR ||
4821         metadata()-&gt;equals(tp-&gt;metadata())) {
4822       return make(ptr, md, offset);
4823     }
4824     // metadata is different
4825     if( ptr == Constant ) {  // Cannot be equal constants, so...
4826       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4827       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4828       ptr = NotNull;            // Fall down in lattice
4829     }
4830     return make(ptr, NULL, offset);
4831     break;
4832   }
4833   } // End of switch
4834   return this;                  // Return the double constant
4835 }
4836 
4837 
4838 //------------------------------xdual------------------------------------------
4839 // Dual of a pure metadata pointer.
4840 const Type *TypeMetadataPtr::xdual() const {
4841   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4842 }
4843 
4844 //------------------------------dump2------------------------------------------
4845 #ifndef PRODUCT
4846 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4847   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4848   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
4849   switch( _offset ) {
4850   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4851   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4852   case         0: break;
4853   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
4854   }
4855 }
4856 #endif
4857 
4858 
4859 //=============================================================================
4860 // Convenience common pre-built type.
4861 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4862 
4863 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):
4864   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4865 }
4866 
4867 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
4868   return make(Constant, m, 0);
4869 }
4870 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
4871   return make(Constant, m, 0);
4872 }
4873 
4874 //------------------------------make-------------------------------------------
4875 // Create a meta data constant
4876 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {
4877   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4878   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4879 }
4880 
4881 
4882 //=============================================================================
4883 // Convenience common pre-built types.
4884 
4885 // Not-null object klass or below
4886 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4887 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4888 
4889 //------------------------------TypeKlassPtr-----------------------------------
4890 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )
4891   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {
4892 }
4893 
4894 //------------------------------make-------------------------------------------
4895 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
4896 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {
4897   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);
4898   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
4899   TypeKlassPtr *r =
4900     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();
4901 
4902   return r;
4903 }
4904 
4905 //------------------------------eq---------------------------------------------
4906 // Structural equality check for Type representations
4907 bool TypeKlassPtr::eq( const Type *t ) const {
4908   const TypeKlassPtr *p = t-&gt;is_klassptr();
4909   return
4910     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4911     TypePtr::eq(p);
4912 }
4913 
4914 //------------------------------hash-------------------------------------------
4915 // Type-specific hashing function.
4916 int TypeKlassPtr::hash(void) const {
4917   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());
4918 }
4919 
4920 //------------------------------singleton--------------------------------------
4921 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4922 // constants
4923 bool TypeKlassPtr::singleton(void) const {
4924   // detune optimizer to not generate constant klass + constant offset as a constant!
4925   // TopPTR, Null, AnyNull, Constant are all singletons
4926   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4927 }
4928 
4929 // Do not allow interface-vs.-noninterface joins to collapse to top.
4930 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4931   // logic here mirrors the one from TypeOopPtr::filter. See comments
4932   // there.
4933   const Type* ft = join_helper(kills, include_speculative);
4934   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4935   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4936 
4937   if (ft-&gt;empty()) {
4938     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
4939       return kills;             // Uplift to interface
4940 
4941     return Type::TOP;           // Canonical empty value
4942   }
4943 
4944   // Interface klass type could be exact in opposite to interface type,
4945   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4946   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4947       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4948       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4949       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4950     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4951   }
4952 
4953   return ft;
4954 }
4955 
4956 //----------------------compute_klass------------------------------------------
4957 // Compute the defining klass for this class
4958 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4959   // Compute _klass based on element type.
4960   ciKlass* k_ary = NULL;
4961   const TypeInstPtr *tinst;
4962   const TypeAryPtr *tary;
4963   const Type* el = elem();
4964   if (el-&gt;isa_narrowoop()) {
4965     el = el-&gt;make_ptr();
4966   }
4967 
4968   // Get element klass
4969   if ((tinst = el-&gt;isa_instptr()) != NULL) {
4970     // Compute array klass from element klass
4971     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());
4972   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4973     // Compute array klass from element klass
4974     ciKlass* k_elem = tary-&gt;klass();
4975     // If element type is something like bottom[], k_elem will be null.
4976     if (k_elem != NULL)
4977       k_ary = ciObjArrayKlass::make(k_elem);
4978   } else if ((el-&gt;base() == Type::Top) ||
4979              (el-&gt;base() == Type::Bottom)) {
4980     // element type of Bottom occurs from meet of basic type
4981     // and object; Top occurs when doing join on Bottom.
4982     // Leave k_ary at NULL.
4983   } else {
4984     // Cannot compute array klass directly from basic type,
4985     // since subtypes of TypeInt all have basic type T_INT.
4986 #ifdef ASSERT
4987     if (verify &amp;&amp; el-&gt;isa_int()) {
4988       // Check simple cases when verifying klass.
4989       BasicType bt = T_ILLEGAL;
4990       if (el == TypeInt::BYTE) {
4991         bt = T_BYTE;
4992       } else if (el == TypeInt::SHORT) {
4993         bt = T_SHORT;
4994       } else if (el == TypeInt::CHAR) {
4995         bt = T_CHAR;
4996       } else if (el == TypeInt::INT) {
4997         bt = T_INT;
4998       } else {
4999         return _klass; // just return specified klass
5000       }
5001       return ciTypeArrayKlass::make(bt);
5002     }
5003 #endif
5004     assert(!el-&gt;isa_int(),
5005            &quot;integral arrays must be pre-equipped with a class&quot;);
5006     // Compute array klass directly from basic type
5007     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5008   }
5009   return k_ary;
5010 }
5011 
5012 //------------------------------klass------------------------------------------
5013 // Return the defining klass for this class
5014 ciKlass* TypeAryPtr::klass() const {
5015   if( _klass ) return _klass;   // Return cached value, if possible
5016 
5017   // Oops, need to compute _klass and cache it
5018   ciKlass* k_ary = compute_klass();
5019 
5020   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5021     // The _klass field acts as a cache of the underlying
5022     // ciKlass for this array type.  In order to set the field,
5023     // we need to cast away const-ness.
5024     //
5025     // IMPORTANT NOTE: we *never* set the _klass field for the
5026     // type TypeAryPtr::OOPS.  This Type is shared between all
5027     // active compilations.  However, the ciKlass which represents
5028     // this Type is *not* shared between compilations, so caching
5029     // this value would result in fetching a dangling pointer.
5030     //
5031     // Recomputing the underlying ciKlass for each request is
5032     // a bit less efficient than caching, but calls to
5033     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5034     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5035     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5036         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {
5037       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5038     }
5039   }
5040   return k_ary;
5041 }
5042 
5043 
5044 //------------------------------add_offset-------------------------------------
5045 // Access internals of klass object
5046 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5047   return make( _ptr, klass(), xadd_offset(offset) );
5048 }
5049 
5050 //------------------------------cast_to_ptr_type-------------------------------
5051 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5052   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5053   if( ptr == _ptr ) return this;
5054   return make(ptr, _klass, _offset);
5055 }
5056 
5057 
5058 //-----------------------------cast_to_exactness-------------------------------
5059 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5060   if( klass_is_exact == _klass_is_exact ) return this;
5061   if (!UseExactTypes)  return this;
5062   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);
5063 }
5064 
5065 
5066 //-----------------------------as_instance_type--------------------------------
5067 // Corresponding type for an instance of the given class.
5068 // It will be NotNull, and exact if and only if the klass type is exact.
5069 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5070   ciKlass* k = klass();
5071   bool    xk = klass_is_exact();
5072   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5073   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5074   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5075   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5076   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5077 }
5078 
5079 
5080 //------------------------------xmeet------------------------------------------
5081 // Compute the MEET of two types, return a new Type object.
5082 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5083   // Perform a fast test for common case; meeting the same types together.
5084   if( this == t ) return this;  // Meeting same type-rep?
5085 
5086   // Current &quot;this-&gt;_base&quot; is Pointer
5087   switch (t-&gt;base()) {          // switch on original type
5088 
5089   case Int:                     // Mixing ints &amp; oops happens when javac
5090   case Long:                    // reuses local variables
5091   case FloatTop:
5092   case FloatCon:
5093   case FloatBot:
5094   case DoubleTop:
5095   case DoubleCon:
5096   case DoubleBot:
5097   case NarrowOop:
5098   case NarrowKlass:
5099   case Bottom:                  // Ye Olde Default
5100     return Type::BOTTOM;
5101   case Top:
5102     return this;
5103 
5104   default:                      // All else is a mistake
5105     typerr(t);
5106 
5107   case AnyPtr: {                // Meeting to AnyPtrs
5108     // Found an AnyPtr type vs self-KlassPtr type
5109     const TypePtr *tp = t-&gt;is_ptr();
5110     int offset = meet_offset(tp-&gt;offset());
5111     PTR ptr = meet_ptr(tp-&gt;ptr());
5112     switch (tp-&gt;ptr()) {
5113     case TopPTR:
5114       return this;
5115     case Null:
5116       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5117     case AnyNull:
5118       return make( ptr, klass(), offset );
5119     case BotPTR:
5120     case NotNull:
5121       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5122     default: typerr(t);
5123     }
5124   }
5125 
5126   case RawPtr:
5127   case MetadataPtr:
5128   case OopPtr:
5129   case AryPtr:                  // Meet with AryPtr
5130   case InstPtr:                 // Meet with InstPtr
5131     return TypePtr::BOTTOM;
5132 
5133   //
5134   //             A-top         }
5135   //           /   |   \       }  Tops
5136   //       B-top A-any C-top   }
5137   //          | /  |  \ |      }  Any-nulls
5138   //       B-any   |   C-any   }
5139   //          |    |    |
5140   //       B-con A-con C-con   } constants; not comparable across classes
5141   //          |    |    |
5142   //       B-not   |   C-not   }
5143   //          | \  |  / |      }  not-nulls
5144   //       B-bot A-not C-bot   }
5145   //           \   |   /       }  Bottoms
5146   //             A-bot         }
5147   //
5148 
5149   case KlassPtr: {  // Meet two KlassPtr types
5150     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5151     int  off     = meet_offset(tkls-&gt;offset());
5152     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5153 
5154     // Check for easy case; klasses are equal (and perhaps not loaded!)
5155     // If we have constants, then we created oops so classes are loaded
5156     // and we can handle the constants further down.  This case handles
5157     // not-loaded classes
5158     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {
5159       return make( ptr, klass(), off );
5160     }
5161 
5162     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5163     ciKlass* tkls_klass = tkls-&gt;klass();
5164     ciKlass* this_klass = this-&gt;klass();
5165     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5166     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5167 
5168     // If &#39;this&#39; type is above the centerline and is a superclass of the
5169     // other, we can treat &#39;this&#39; as having the same type as the other.
5170     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5171         tkls_klass-&gt;is_subtype_of(this_klass)) {
5172       this_klass = tkls_klass;
5173     }
5174     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5175     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5176     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5177         this_klass-&gt;is_subtype_of(tkls_klass)) {
5178       tkls_klass = this_klass;
5179     }
5180 
5181     // Check for classes now being equal
5182     if (tkls_klass-&gt;equals(this_klass)) {
5183       // If the klasses are equal, the constants may still differ.  Fall to
5184       // NotNull if they do (neither constant is NULL; that is a special case
5185       // handled elsewhere).
5186       if( ptr == Constant ) {
5187         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5188             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5189         else if (above_centerline(this-&gt;ptr()));
5190         else if (above_centerline(tkls-&gt;ptr()));
5191         else
5192           ptr = NotNull;
5193       }
5194       return make( ptr, this_klass, off );
5195     } // Else classes are not equal
5196 
5197     // Since klasses are different, we require the LCA in the Java
5198     // class hierarchy - which means we have to fall to at least NotNull.
5199     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5200       ptr = NotNull;
5201     // Now we find the LCA of Java classes
5202     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5203     return   make( ptr, k, off );
5204   } // End of case KlassPtr
5205 
5206   } // End of switch
5207   return this;                  // Return the double constant
5208 }
5209 
5210 //------------------------------xdual------------------------------------------
5211 // Dual: compute field-by-field dual
5212 const Type    *TypeKlassPtr::xdual() const {
5213   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );
5214 }
5215 
5216 //------------------------------get_con----------------------------------------
5217 intptr_t TypeKlassPtr::get_con() const {
5218   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5219   assert( _offset &gt;= 0, &quot;&quot; );
5220 
5221   if (_offset != 0) {
5222     // After being ported to the compiler interface, the compiler no longer
5223     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5224     // to a handle at compile time.  This handle is embedded in the generated
5225     // code and dereferenced at the time the nmethod is made.  Until that time,
5226     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5227     // have access to the addresses!).  This does not seem to currently happen,
5228     // but this assertion here is to help prevent its occurence.
5229     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5230     ShouldNotReachHere();
5231   }
5232 
5233   return (intptr_t)klass()-&gt;constant_encoding();
5234 }
5235 //------------------------------dump2------------------------------------------
5236 // Dump Klass Type
5237 #ifndef PRODUCT
5238 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5239   switch( _ptr ) {
5240   case Constant:
5241     st-&gt;print(&quot;precise &quot;);
5242   case NotNull:
5243     {
5244       const char *name = klass()-&gt;name()-&gt;as_utf8();
5245       if( name ) {
5246         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5247       } else {
5248         ShouldNotReachHere();
5249       }
5250     }
5251   case BotPTR:
5252     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5253   case TopPTR:
5254   case AnyNull:
5255     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5256     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5257     break;
5258   default:
5259     break;
5260   }
5261 
5262   if( _offset ) {               // Dump offset, if any
5263     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }
5264     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }
5265     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }
5266   }
5267 
5268   st-&gt;print(&quot; *&quot;);
5269 }
5270 #endif
5271 
5272 
5273 
5274 //=============================================================================
5275 // Convenience common pre-built types.
5276 
5277 //------------------------------make-------------------------------------------
5278 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {
5279   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();
5280 }
5281 
5282 //------------------------------make-------------------------------------------
5283 const TypeFunc *TypeFunc::make(ciMethod* method) {
5284   Compile* C = Compile::current();
5285   const TypeFunc* tf = C-&gt;last_tf(method); // check cache
5286   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5287   const TypeTuple *domain;
5288   if (method-&gt;is_static()) {
5289     domain = TypeTuple::make_domain(NULL, method-&gt;signature());
5290   } else {
5291     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());
5292   }
5293   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());
5294   tf = TypeFunc::make(domain, range);
5295   C-&gt;set_last_tf(method, tf);  // fill cache
5296   return tf;
5297 }
5298 
5299 //------------------------------meet-------------------------------------------
5300 // Compute the MEET of two types.  It returns a new Type object.
5301 const Type *TypeFunc::xmeet( const Type *t ) const {
5302   // Perform a fast test for common case; meeting the same types together.
5303   if( this == t ) return this;  // Meeting same type-rep?
5304 
5305   // Current &quot;this-&gt;_base&quot; is Func
5306   switch (t-&gt;base()) {          // switch on original type
5307 
5308   case Bottom:                  // Ye Olde Default
5309     return t;
5310 
5311   default:                      // All else is a mistake
5312     typerr(t);
5313 
5314   case Top:
5315     break;
5316   }
5317   return this;                  // Return the double constant
5318 }
5319 
5320 //------------------------------xdual------------------------------------------
5321 // Dual: compute field-by-field dual
5322 const Type *TypeFunc::xdual() const {
5323   return this;
5324 }
5325 
5326 //------------------------------eq---------------------------------------------
5327 // Structural equality check for Type representations
5328 bool TypeFunc::eq( const Type *t ) const {
5329   const TypeFunc *a = (const TypeFunc*)t;
5330   return _domain == a-&gt;_domain &amp;&amp;
5331     _range == a-&gt;_range;
5332 }
5333 
5334 //------------------------------hash-------------------------------------------
5335 // Type-specific hashing function.
5336 int TypeFunc::hash(void) const {
5337   return (intptr_t)_domain + (intptr_t)_range;
5338 }
5339 
5340 //------------------------------dump2------------------------------------------
5341 // Dump Function Type
5342 #ifndef PRODUCT
5343 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5344   if( _range-&gt;cnt() &lt;= Parms )
5345     st-&gt;print(&quot;void&quot;);
5346   else {
5347     uint i;
5348     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {
5349       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5350       st-&gt;print(&quot;/&quot;);
5351     }
5352     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5353   }
5354   st-&gt;print(&quot; &quot;);
5355   st-&gt;print(&quot;( &quot;);
5356   if( !depth || d[this] ) {     // Check for recursive dump
5357     st-&gt;print(&quot;...)&quot;);
5358     return;
5359   }
5360   d.Insert((void*)this,(void*)this);    // Stop recursion
5361   if (Parms &lt; _domain-&gt;cnt())
5362     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5363   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {
5364     st-&gt;print(&quot;, &quot;);
5365     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5366   }
5367   st-&gt;print(&quot; )&quot;);
5368 }
5369 #endif
5370 
5371 //------------------------------singleton--------------------------------------
5372 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5373 // constants (Ldi nodes).  Singletons are integer, float or double constants
5374 // or a single symbol.
5375 bool TypeFunc::singleton(void) const {
5376   return false;                 // Never a singleton
5377 }
5378 
5379 bool TypeFunc::empty(void) const {
5380   return false;                 // Never empty
5381 }
5382 
5383 
5384 BasicType TypeFunc::return_type() const{
5385   if (range()-&gt;cnt() == TypeFunc::Parms) {
5386     return T_VOID;
5387   }
5388   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5389 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/memnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mulnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/memnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.


  46 protected:
  47 #ifdef ASSERT
  48   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  49 #endif
  50   virtual uint size_of() const;
  51 public:
  52   enum { Control,               // When is it safe to do this load?
  53          Memory,                // Chunk of memory is being loaded from
  54          Address,               // Actually address, derived from base
  55          ValueIn,               // Value to store
  56          OopStore               // Preceeding oop store, only in StoreCM
  57   };
  58   typedef enum { unordered = 0,
  59                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  60                  release,       // Store has to release or be preceded by MemBarRelease.
  61                  seqcst,        // LoadStore has to have both acquire and release semantics.
  62                  unset          // The memory ordering is not set (used for testing)
  63   } MemOrd;
  64 protected:
<span class="line-modified">  65   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at )</span>
<span class="line-modified">  66     : Node(c0,c1,c2   ), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  67     init_class_id(Class_Mem);
  68     debug_only(_adr_type=at; adr_type();)
  69   }
<span class="line-modified">  70   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 )</span>
<span class="line-modified">  71     : Node(c0,c1,c2,c3), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  72     init_class_id(Class_Mem);
  73     debug_only(_adr_type=at; adr_type();)
  74   }
<span class="line-modified">  75   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4)</span>
<span class="line-modified">  76     : Node(c0,c1,c2,c3,c4), _unaligned_access(false), _mismatched_access(false), _unsafe_access(false) {</span>




  77     init_class_id(Class_Mem);
  78     debug_only(_adr_type=at; adr_type();)
  79   }
  80 
  81   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  82   static bool check_if_adr_maybe_raw(Node* adr);
  83 
  84 public:
  85   // Helpers for the optimizer.  Documented in memnode.cpp.
  86   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
  87                                       Node* p2, AllocateNode* a2,
  88                                       PhaseTransform* phase);
  89   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
  90 
  91   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
  92   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
  93   // This one should probably be a phase-specific function:
  94   static bool all_controls_dominate(Node* dom, Node* sub);
  95 
  96   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
</pre>
<hr />
<pre>
 108     return _adr_type;
 109 #else
 110     return 0;
 111 #endif
 112   }
 113 
 114   // Map a load or store opcode to its corresponding store opcode.
 115   // (Return -1 if unknown.)
 116   virtual int store_Opcode() const { return -1; }
 117 
 118   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 119   virtual BasicType memory_type() const = 0;
 120   virtual int memory_size() const {
 121 #ifdef ASSERT
 122     return type2aelembytes(memory_type(), true);
 123 #else
 124     return type2aelembytes(memory_type());
 125 #endif
 126   }
 127 



 128   // Search through memory states which precede this node (load or store).
 129   // Look for an exact match for the address, with no intervening
 130   // aliased stores.
 131   Node* find_previous_store(PhaseTransform* phase);
 132 
 133   // Can this node (load or store) accurately see a stored value in
 134   // the given memory state?  (The state may or may not be in(Memory).)
 135   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 136 
 137   void set_unaligned_access() { _unaligned_access = true; }
 138   bool is_unaligned_access() const { return _unaligned_access; }
 139   void set_mismatched_access() { _mismatched_access = true; }
 140   bool is_mismatched_access() const { return _mismatched_access; }
 141   void set_unsafe_access() { _unsafe_access = true; }
 142   bool is_unsafe_access() const { return _unsafe_access; }
 143 
 144 #ifndef PRODUCT
 145   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 146   virtual void dump_spec(outputStream *st) const;
 147 #endif
 148 };
 149 
 150 //------------------------------LoadNode---------------------------------------
 151 // Load value; requires Memory and Address
 152 class LoadNode : public MemNode {
 153 public:
 154   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 155   // on the dominating test.  The field _control_dependency below records
 156   // whether that node depends only on the dominating test.
<span class="line-modified"> 157   // Methods used to build LoadNodes pass an argument of type enum</span>
<span class="line-modified"> 158   // ControlDependency instead of a boolean because those methods</span>
<span class="line-modified"> 159   // typically have multiple boolean parameters with default values:</span>
<span class="line-removed"> 160   // passing the wrong boolean to one of these parameters by mistake</span>
<span class="line-removed"> 161   // goes easily unnoticed. Using an enum, the compiler can check that</span>
<span class="line-removed"> 162   // the type of a value and the type of the parameter match.</span>
 163   enum ControlDependency {
 164     Pinned,

 165     DependsOnlyOnTest
 166   };

 167 private:
 168   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 169   // into account: If the graph already has a non-pinned LoadNode and
 170   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 171   // to replace the pinned LoadNode with the non-pinned LoadNode,
 172   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 173   // those inputs in the first place. If the graph already has a
 174   // pinned LoadNode and we add a non pinned LoadNode with the same
 175   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 176   // non-pinned LoadNode by the pinned LoadNode.
 177   ControlDependency _control_dependency;
 178 
 179   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 180   // loads that can be reordered, and such requiring acquire semantics to
 181   // adhere to the Java specification.  The required behaviour is stored in
 182   // this field.
 183   const MemOrd _mo;
 184 


 185 protected:
<span class="line-modified"> 186   virtual uint cmp(const Node &amp;n) const;</span>
 187   virtual uint size_of() const; // Size is bigger
 188   // Should LoadNode::Ideal() attempt to remove control edges?
 189   virtual bool can_remove_control() const;
 190   const Type* const _type;      // What kind of value is loaded?
 191 
 192   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 193 public:
 194 
 195   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 196     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 197     init_class_id(Class_Load);
 198   }
 199   inline bool is_unordered() const { return !is_acquire(); }
 200   inline bool is_acquire() const {
 201     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 202     return _mo == acquire;
 203   }
 204   inline bool is_unsigned() const {
 205     int lop = Opcode();
 206     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 207   }
 208 
 209   // Polymorphic factory method:
 210   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 211                     const TypePtr* at, const Type *rt, BasicType bt,
 212                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 213                     bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>

 214 
 215   virtual uint hash()   const;  // Check the type
 216 
 217   // Handle algebraic identities here.  If we have an identity, return the Node
 218   // we are equivalent to.  We look for Load of a Store.
 219   virtual Node* Identity(PhaseGVN* phase);
 220 
 221   // If the load is from Field memory and the pointer is non-null, it might be possible to
 222   // zero out the control input.
 223   // If the offset is constant and the base is an object allocation,
 224   // try to hook me up to the exact initializing store.
 225   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 226 
 227   // Split instance field load through Phi.
 228   Node* split_through_phi(PhaseGVN *phase);
 229 
 230   // Recover original value from boxed values
 231   Node *eliminate_autobox(PhaseGVN *phase);
 232 
 233   // Compute a new Type for this node.  Basically we just do the pre-check,
</pre>
<hr />
<pre>
 245     assert(t != NULL, &quot;sanity&quot;);
 246     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 247     *(const Type**)&amp;_type = t;   // cast away const-ness
 248     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 249     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 250   }
 251   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 252 
 253   // Do not match memory edge
 254   virtual uint match_edge(uint idx) const;
 255 
 256   // Map a load opcode to its corresponding store opcode.
 257   virtual int store_Opcode() const = 0;
 258 
 259   // Check if the load&#39;s memory input is a Phi node with the same control.
 260   bool is_instance_field_load_with_local_phi(Node* ctrl);
 261 
 262   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 263   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 264 



 265 #ifndef PRODUCT
 266   virtual void dump_spec(outputStream *st) const;
 267 #endif
 268 #ifdef ASSERT
 269   // Helper function to allow a raw load without control edge for some cases
 270   static bool is_immutable_value(Node* adr);
 271 #endif
 272 protected:
 273   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 274                                      ciKlass* klass) const;
 275 
 276   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 277 
 278   // depends_only_on_test is almost always true, and needs to be almost always
 279   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 280   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 281   // GC barriers, the control edge carries the dependence preventing hoisting past
 282   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 283   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 284   // which produce results (new raw memory state) inside of loops preventing all
</pre>
<hr />
<pre>
 356   virtual int store_Opcode() const { return Op_StoreI; }
 357   virtual BasicType memory_type() const { return T_INT; }
 358 };
 359 
 360 //------------------------------LoadRangeNode----------------------------------
 361 // Load an array length from the array
 362 class LoadRangeNode : public LoadINode {
 363 public:
 364   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 365     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 366   virtual int Opcode() const;
 367   virtual const Type* Value(PhaseGVN* phase) const;
 368   virtual Node* Identity(PhaseGVN* phase);
 369   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 370 };
 371 
 372 //------------------------------LoadLNode--------------------------------------
 373 // Load a long from memory
 374 class LoadLNode : public LoadNode {
 375   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<span class="line-modified"> 376   virtual uint cmp( const Node &amp;n ) const {</span>
 377     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 378       &amp;&amp; LoadNode::cmp(n);
 379   }
 380   virtual uint size_of() const { return sizeof(*this); }
 381   const bool _require_atomic_access;  // is piecewise load forbidden?
 382 
 383 public:
 384   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 385             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 386     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 387   virtual int Opcode() const;
 388   virtual uint ideal_reg() const { return Op_RegL; }
 389   virtual int store_Opcode() const { return Op_StoreL; }
 390   virtual BasicType memory_type() const { return T_LONG; }
 391   bool require_atomic_access() const { return _require_atomic_access; }
 392   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 393                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 394                                 bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>
 395 #ifndef PRODUCT
 396   virtual void dump_spec(outputStream *st) const {
 397     LoadNode::dump_spec(st);
 398     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 399   }
 400 #endif
 401 };
 402 
 403 //------------------------------LoadL_unalignedNode----------------------------
 404 // Load a long from unaligned memory
 405 class LoadL_unalignedNode : public LoadLNode {
 406 public:
 407   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 408     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 409   virtual int Opcode() const;
 410 };
 411 
 412 //------------------------------LoadFNode--------------------------------------
 413 // Load a float (64 bits) from memory
 414 class LoadFNode : public LoadNode {
 415 public:
 416   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 417     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 418   virtual int Opcode() const;
 419   virtual uint ideal_reg() const { return Op_RegF; }
 420   virtual int store_Opcode() const { return Op_StoreF; }
 421   virtual BasicType memory_type() const { return T_FLOAT; }
 422 };
 423 
 424 //------------------------------LoadDNode--------------------------------------
 425 // Load a double (64 bits) from memory
 426 class LoadDNode : public LoadNode {
 427   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<span class="line-modified"> 428   virtual uint cmp( const Node &amp;n ) const {</span>
 429     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 430       &amp;&amp; LoadNode::cmp(n);
 431   }
 432   virtual uint size_of() const { return sizeof(*this); }
 433   const bool _require_atomic_access;  // is piecewise load forbidden?
 434 
 435 public:
 436   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 437             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 438     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 439   virtual int Opcode() const;
 440   virtual uint ideal_reg() const { return Op_RegD; }
 441   virtual int store_Opcode() const { return Op_StoreD; }
 442   virtual BasicType memory_type() const { return T_DOUBLE; }
 443   bool require_atomic_access() const { return _require_atomic_access; }
 444   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 445                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 446                                 bool unaligned = false, bool mismatched = false, bool unsafe = false);</span>
 447 #ifndef PRODUCT
 448   virtual void dump_spec(outputStream *st) const {
 449     LoadNode::dump_spec(st);
 450     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 451   }
 452 #endif
 453 };
 454 
 455 //------------------------------LoadD_unalignedNode----------------------------
 456 // Load a double from unaligned memory
 457 class LoadD_unalignedNode : public LoadDNode {
 458 public:
 459   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 460     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 461   virtual int Opcode() const;
 462 };
 463 
 464 //------------------------------LoadPNode--------------------------------------
 465 // Load a pointer from memory (either object or array)
 466 class LoadPNode : public LoadNode {
</pre>
<hr />
<pre>
 518   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 519 
 520   virtual const Type* Value(PhaseGVN* phase) const;
 521   virtual Node* Identity(PhaseGVN* phase);
 522   virtual bool depends_only_on_test() const { return true; }
 523 };
 524 
 525 
 526 //------------------------------StoreNode--------------------------------------
 527 // Store value; requires Store, Address and Value
 528 class StoreNode : public MemNode {
 529 private:
 530   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 531   // stores that can be reordered, and such requiring release semantics to
 532   // adhere to the Java specification.  The required behaviour is stored in
 533   // this field.
 534   const MemOrd _mo;
 535   // Needed for proper cloning.
 536   virtual uint size_of() const { return sizeof(*this); }
 537 protected:
<span class="line-modified"> 538   virtual uint cmp( const Node &amp;n ) const;</span>
 539   virtual bool depends_only_on_test() const { return false; }
 540 
 541   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 542   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 543 
 544 public:
 545   // We must ensure that stores of object references will be visible
 546   // only after the object&#39;s initialization. So the callers of this
 547   // procedure must indicate that the store requires `release&#39;
 548   // semantics, if the stored value is an object reference that might
 549   // point to a new object and may become externally visible.
 550   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 551     : MemNode(c, mem, adr, at, val), _mo(mo) {
 552     init_class_id(Class_Store);
 553   }
 554   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 555     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 556     init_class_id(Class_Store);
 557   }
 558 
</pre>
<hr />
<pre>
 633     : StoreNode(c, mem, adr, at, val, mo) {}
 634   virtual int Opcode() const;
 635   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 636   virtual BasicType memory_type() const { return T_CHAR; }
 637 };
 638 
 639 //------------------------------StoreINode-------------------------------------
 640 // Store int to memory
 641 class StoreINode : public StoreNode {
 642 public:
 643   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 644     : StoreNode(c, mem, adr, at, val, mo) {}
 645   virtual int Opcode() const;
 646   virtual BasicType memory_type() const { return T_INT; }
 647 };
 648 
 649 //------------------------------StoreLNode-------------------------------------
 650 // Store long to memory
 651 class StoreLNode : public StoreNode {
 652   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<span class="line-modified"> 653   virtual uint cmp( const Node &amp;n ) const {</span>
 654     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 655       &amp;&amp; StoreNode::cmp(n);
 656   }
 657   virtual uint size_of() const { return sizeof(*this); }
 658   const bool _require_atomic_access;  // is piecewise store forbidden?
 659 
 660 public:
 661   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 662     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 663   virtual int Opcode() const;
 664   virtual BasicType memory_type() const { return T_LONG; }
 665   bool require_atomic_access() const { return _require_atomic_access; }
 666   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 667 #ifndef PRODUCT
 668   virtual void dump_spec(outputStream *st) const {
 669     StoreNode::dump_spec(st);
 670     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 671   }
 672 #endif
 673 };
 674 
 675 //------------------------------StoreFNode-------------------------------------
 676 // Store float to memory
 677 class StoreFNode : public StoreNode {
 678 public:
 679   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 680     : StoreNode(c, mem, adr, at, val, mo) {}
 681   virtual int Opcode() const;
 682   virtual BasicType memory_type() const { return T_FLOAT; }
 683 };
 684 
 685 //------------------------------StoreDNode-------------------------------------
 686 // Store double to memory
 687 class StoreDNode : public StoreNode {
 688   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<span class="line-modified"> 689   virtual uint cmp( const Node &amp;n ) const {</span>
 690     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 691       &amp;&amp; StoreNode::cmp(n);
 692   }
 693   virtual uint size_of() const { return sizeof(*this); }
 694   const bool _require_atomic_access;  // is piecewise store forbidden?
 695 public:
 696   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 697              MemOrd mo, bool require_atomic_access = false)
 698     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 699   virtual int Opcode() const;
 700   virtual BasicType memory_type() const { return T_DOUBLE; }
 701   bool require_atomic_access() const { return _require_atomic_access; }
 702   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 703 #ifndef PRODUCT
 704   virtual void dump_spec(outputStream *st) const {
 705     StoreNode::dump_spec(st);
 706     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 707   }
 708 #endif
 709 
</pre>
<hr />
<pre>
 729   virtual BasicType memory_type() const { return T_NARROWOOP; }
 730 };
 731 
 732 //------------------------------StoreNKlassNode--------------------------------------
 733 // Store narrow klass to memory
 734 class StoreNKlassNode : public StoreNNode {
 735 public:
 736   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 737     : StoreNNode(c, mem, adr, at, val, mo) {}
 738   virtual int Opcode() const;
 739   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 740 };
 741 
 742 //------------------------------StoreCMNode-----------------------------------
 743 // Store card-mark byte to memory for CM
 744 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 745 // Preceeding equivalent StoreCMs may be eliminated.
 746 class StoreCMNode : public StoreNode {
 747  private:
 748   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
<span class="line-modified"> 749   virtual uint cmp( const Node &amp;n ) const {</span>
 750     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 751       &amp;&amp; StoreNode::cmp(n);
 752   }
 753   virtual uint size_of() const { return sizeof(*this); }
 754   int _oop_alias_idx;   // The alias_idx of OopStore
 755 
 756 public:
 757   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 758     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 759     _oop_alias_idx(oop_alias_idx) {
 760     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 761            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 762            &quot;bad oop alias idx&quot;);
 763   }
 764   virtual int Opcode() const;
 765   virtual Node* Identity(PhaseGVN* phase);
 766   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 767   virtual const Type* Value(PhaseGVN* phase) const;
 768   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 769   int oop_alias_idx() const { return _oop_alias_idx; }
</pre>
<hr />
<pre>
 793   virtual bool      is_CFG() const  { return false; }
 794   virtual const Type *bottom_type() const {return Type::MEMORY;}
 795   virtual const TypePtr *adr_type() const {
 796     Node* ctrl = in(0);
 797     if (ctrl == NULL)  return NULL; // node is dead
 798     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 799   }
 800   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 801   virtual const Type* Value(PhaseGVN* phase) const;
 802 #ifndef PRODUCT
 803   virtual void dump_spec(outputStream *st) const {};
 804 #endif
 805 };
 806 
 807 //------------------------------LoadStoreNode---------------------------
 808 // Note: is_Mem() method returns &#39;true&#39; for this class.
 809 class LoadStoreNode : public Node {
 810 private:
 811   const Type* const _type;      // What kind of value is loaded?
 812   const TypePtr* _adr_type;     // What kind of memory is being addressed?

 813   virtual uint size_of() const; // Size is bigger
 814 public:
 815   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 816   virtual bool depends_only_on_test() const { return false; }
 817   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 818 
 819   virtual const Type *bottom_type() const { return _type; }
 820   virtual uint ideal_reg() const;
 821   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 822 
 823   bool result_not_used() const;
 824   MemBarNode* trailing_membar() const;



 825 };
 826 
 827 class LoadStoreConditionalNode : public LoadStoreNode {
 828 public:
 829   enum {
 830     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 831   };
 832   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 833 };
 834 
 835 //------------------------------StorePConditionalNode---------------------------
 836 // Conditionally store pointer to memory, if no change since prior
 837 // load-locked.  Sets flags for success or failure of the store.
 838 class StorePConditionalNode : public LoadStoreConditionalNode {
 839 public:
 840   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 841   virtual int Opcode() const;
 842   // Produces flags
 843   virtual uint ideal_reg() const { return Op_RegFlags; }
 844 };
</pre>
<hr />
<pre>
 856 
 857 //------------------------------StoreLConditionalNode---------------------------
 858 // Conditionally store long to memory, if no change since prior
 859 // load-locked.  Sets flags for success or failure of the store.
 860 class StoreLConditionalNode : public LoadStoreConditionalNode {
 861 public:
 862   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 863   virtual int Opcode() const;
 864   // Produces flags
 865   virtual uint ideal_reg() const { return Op_RegFlags; }
 866 };
 867 
 868 class CompareAndSwapNode : public LoadStoreConditionalNode {
 869 private:
 870   const MemNode::MemOrd _mem_ord;
 871 public:
 872   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 873   MemNode::MemOrd order() const {
 874     return _mem_ord;
 875   }

 876 };
 877 
 878 class CompareAndExchangeNode : public LoadStoreNode {
 879 private:
 880   const MemNode::MemOrd _mem_ord;
 881 public:
 882   enum {
 883     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 884   };
 885   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 886     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 887      init_req(ExpectedIn, ex );
 888   }
 889 
 890   MemNode::MemOrd order() const {
 891     return _mem_ord;
 892   }

 893 };
 894 
 895 //------------------------------CompareAndSwapBNode---------------------------
 896 class CompareAndSwapBNode : public CompareAndSwapNode {
 897 public:
 898   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 899   virtual int Opcode() const;
 900 };
 901 
 902 //------------------------------CompareAndSwapSNode---------------------------
 903 class CompareAndSwapSNode : public CompareAndSwapNode {
 904 public:
 905   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 906   virtual int Opcode() const;
 907 };
 908 
 909 //------------------------------CompareAndSwapINode---------------------------
 910 class CompareAndSwapINode : public CompareAndSwapNode {
 911 public:
 912   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
</pre>
<hr />
<pre>
1125   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1126                             Node* start_offset,
1127                             Node* end_offset,
1128                             PhaseGVN* phase);
1129   // Return allocation input memory edge if it is different instance
1130   // or itself if it is the one we are looking for.
1131   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1132 };
1133 
1134 //------------------------------MemBar-----------------------------------------
1135 // There are different flavors of Memory Barriers to match the Java Memory
1136 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1137 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1138 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1139 // preceding ref can be moved to after them.  We insert a MemBar-Release
1140 // before a FastUnlock or volatile-store.  All volatiles need to be
1141 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1142 // separate it from any following volatile-load.
1143 class MemBarNode: public MultiNode {
1144   virtual uint hash() const ;                  // { return NO_HASH; }
<span class="line-modified">1145   virtual uint cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1146 
1147   virtual uint size_of() const { return sizeof(*this); }
1148   // Memory type this node is serializing.  Usually either rawptr or bottom.
1149   const TypePtr* _adr_type;
1150 
1151   // How is this membar related to a nearby memory access?
1152   enum {
1153     Standalone,
1154     TrailingLoad,
1155     TrailingStore,
1156     LeadingStore,
1157     TrailingLoadStore,
1158     LeadingLoadStore
1159   } _kind;
1160 
1161 #ifdef ASSERT
1162   uint _pair_idx;
1163 #endif
1164 
1165 public:
</pre>
<hr />
<pre>
1343   // An InitializeNode must completed before macro expansion is done.
1344   // Completion requires that the AllocateNode must be followed by
1345   // initialization of the new memory to zero, then to any initializers.
1346   bool is_complete() { return _is_complete != Incomplete; }
1347   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1348 
1349   // Mark complete.  (Must not yet be complete.)
1350   void set_complete(PhaseGVN* phase);
1351   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1352 
1353   bool does_not_escape() { return _does_not_escape; }
1354   void set_does_not_escape() { _does_not_escape = true; }
1355 
1356 #ifdef ASSERT
1357   // ensure all non-degenerate stores are ordered and non-overlapping
1358   bool stores_are_sane(PhaseTransform* phase);
1359 #endif //ASSERT
1360 
1361   // See if this store can be captured; return offset where it initializes.
1362   // Return 0 if the store cannot be moved (any sort of problem).
<span class="line-modified">1363   intptr_t can_capture_store(StoreNode* st, PhaseTransform* phase, bool can_reshape);</span>
1364 
1365   // Capture another store; reformat it to write my internal raw memory.
1366   // Return the captured copy, else NULL if there is some sort of problem.
<span class="line-modified">1367   Node* capture_store(StoreNode* st, intptr_t start, PhaseTransform* phase, bool can_reshape);</span>
1368 
1369   // Find captured store which corresponds to the range [start..start+size).
1370   // Return my own memory projection (meaning the initial zero bits)
1371   // if there is no such store.  Return NULL if there is a problem.
1372   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1373 
1374   // Called when the associated AllocateNode is expanded into CFG.
1375   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1376                         intptr_t header_size, Node* size_in_bytes,
<span class="line-modified">1377                         PhaseGVN* phase);</span>
1378 
1379  private:
1380   void remove_extra_zeroes();
1381 
1382   // Find out where a captured store should be placed (or already is placed).
1383   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1384                                      PhaseTransform* phase);
1385 
1386   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1387 
1388   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1389 
<span class="line-modified">1390   bool detect_init_independence(Node* n, int&amp; count);</span>
1391 
1392   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1393                                PhaseGVN* phase);
1394 
1395   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1396 };
1397 
1398 //------------------------------MergeMem---------------------------------------
1399 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1400 class MergeMemNode: public Node {
1401   virtual uint hash() const ;                  // { return NO_HASH; }
<span class="line-modified">1402   virtual uint cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1403   friend class MergeMemStream;
1404   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1405 
1406 public:
1407   // If the input is a whole memory state, clone it with all its slices intact.
1408   // Otherwise, make a new memory state with just that base memory input.
1409   // In either case, the result is a newly created MergeMem.
1410   static MergeMemNode* make(Node* base_memory);
1411 
1412   virtual int Opcode() const;
1413   virtual Node* Identity(PhaseGVN* phase);
1414   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1415   virtual uint ideal_reg() const { return NotAMachineReg; }
1416   virtual uint match_edge(uint idx) const { return 0; }
1417   virtual const RegMask &amp;out_RegMask() const;
1418   virtual const Type *bottom_type() const { return Type::MEMORY; }
1419   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1420   // sparse accessors
1421   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1422   // (Caller should clone it if it is a phi-nest.)
</pre>
<hr />
<pre>
1614       return true;
1615     }
1616     return false;
1617   }
1618 
1619   // find the next non-empty item
1620   bool next_non_empty(bool have_mm2) {
1621     while (next(have_mm2)) {
1622       if (!is_empty()) {
1623         // make sure _mem2 is filled in sensibly
1624         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1625         return true;
1626       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1627         return true;   // is_empty() == true
1628       }
1629     }
1630     return false;
1631   }
1632 };
1633 




































1634 //------------------------------Prefetch---------------------------------------
1635 
1636 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1637 class PrefetchAllocationNode : public Node {
1638 public:
1639   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1640   virtual int Opcode() const;
1641   virtual uint ideal_reg() const { return NotAMachineReg; }
1642   virtual uint match_edge(uint idx) const { return idx==2; }
1643   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1644 };
1645 
1646 #endif // SHARE_OPTO_MEMNODE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  26 #define SHARE_OPTO_MEMNODE_HPP
  27 
  28 #include &quot;opto/multnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 #include &quot;opto/type.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 class MultiNode;
  36 class PhaseCCP;
  37 class PhaseTransform;
  38 
  39 //------------------------------MemNode----------------------------------------
  40 // Load or Store, possibly throwing a NULL pointer exception
  41 class MemNode : public Node {
  42 private:
  43   bool _unaligned_access; // Unaligned access from unsafe
  44   bool _mismatched_access; // Mismatched access from unsafe: byte read in integer array for instance
  45   bool _unsafe_access;     // Access of unsafe origin.
<span class="line-added">  46   uint8_t _barrier; // Bit field with barrier information</span>
<span class="line-added">  47 </span>
  48 protected:
  49 #ifdef ASSERT
  50   const TypePtr* _adr_type;     // What kind of memory is being addressed?
  51 #endif
  52   virtual uint size_of() const;
  53 public:
  54   enum { Control,               // When is it safe to do this load?
  55          Memory,                // Chunk of memory is being loaded from
  56          Address,               // Actually address, derived from base
  57          ValueIn,               // Value to store
  58          OopStore               // Preceeding oop store, only in StoreCM
  59   };
  60   typedef enum { unordered = 0,
  61                  acquire,       // Load has to acquire or be succeeded by MemBarAcquire.
  62                  release,       // Store has to release or be preceded by MemBarRelease.
  63                  seqcst,        // LoadStore has to have both acquire and release semantics.
  64                  unset          // The memory ordering is not set (used for testing)
  65   } MemOrd;
  66 protected:
<span class="line-modified">  67   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at ) :</span>
<span class="line-modified">  68       Node(c0,c1,c2),</span>
<span class="line-added">  69       _unaligned_access(false),</span>
<span class="line-added">  70       _mismatched_access(false),</span>
<span class="line-added">  71       _unsafe_access(false),</span>
<span class="line-added">  72       _barrier(0) {</span>
  73     init_class_id(Class_Mem);
  74     debug_only(_adr_type=at; adr_type();)
  75   }
<span class="line-modified">  76   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3 ) :</span>
<span class="line-modified">  77       Node(c0,c1,c2,c3),</span>
<span class="line-added">  78       _unaligned_access(false),</span>
<span class="line-added">  79       _mismatched_access(false),</span>
<span class="line-added">  80       _unsafe_access(false),</span>
<span class="line-added">  81       _barrier(0) {</span>
  82     init_class_id(Class_Mem);
  83     debug_only(_adr_type=at; adr_type();)
  84   }
<span class="line-modified">  85   MemNode( Node *c0, Node *c1, Node *c2, const TypePtr* at, Node *c3, Node *c4) :</span>
<span class="line-modified">  86       Node(c0,c1,c2,c3,c4),</span>
<span class="line-added">  87       _unaligned_access(false),</span>
<span class="line-added">  88       _mismatched_access(false),</span>
<span class="line-added">  89       _unsafe_access(false),</span>
<span class="line-added">  90       _barrier(0) {</span>
  91     init_class_id(Class_Mem);
  92     debug_only(_adr_type=at; adr_type();)
  93   }
  94 
  95   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const { return NULL; }
  96   static bool check_if_adr_maybe_raw(Node* adr);
  97 
  98 public:
  99   // Helpers for the optimizer.  Documented in memnode.cpp.
 100   static bool detect_ptr_independence(Node* p1, AllocateNode* a1,
 101                                       Node* p2, AllocateNode* a2,
 102                                       PhaseTransform* phase);
 103   static bool adr_phi_is_loop_invariant(Node* adr_phi, Node* cast);
 104 
 105   static Node *optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase);
 106   static Node *optimize_memory_chain(Node *mchain, const TypePtr *t_adr, Node *load, PhaseGVN *phase);
 107   // This one should probably be a phase-specific function:
 108   static bool all_controls_dominate(Node* dom, Node* sub);
 109 
 110   virtual const class TypePtr *adr_type() const;  // returns bottom_type of address
</pre>
<hr />
<pre>
 122     return _adr_type;
 123 #else
 124     return 0;
 125 #endif
 126   }
 127 
 128   // Map a load or store opcode to its corresponding store opcode.
 129   // (Return -1 if unknown.)
 130   virtual int store_Opcode() const { return -1; }
 131 
 132   // What is the type of the value in memory?  (T_VOID mean &quot;unspecified&quot;.)
 133   virtual BasicType memory_type() const = 0;
 134   virtual int memory_size() const {
 135 #ifdef ASSERT
 136     return type2aelembytes(memory_type(), true);
 137 #else
 138     return type2aelembytes(memory_type());
 139 #endif
 140   }
 141 
<span class="line-added"> 142   uint8_t barrier_data() { return _barrier; }</span>
<span class="line-added"> 143   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }</span>
<span class="line-added"> 144 </span>
 145   // Search through memory states which precede this node (load or store).
 146   // Look for an exact match for the address, with no intervening
 147   // aliased stores.
 148   Node* find_previous_store(PhaseTransform* phase);
 149 
 150   // Can this node (load or store) accurately see a stored value in
 151   // the given memory state?  (The state may or may not be in(Memory).)
 152   Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;
 153 
 154   void set_unaligned_access() { _unaligned_access = true; }
 155   bool is_unaligned_access() const { return _unaligned_access; }
 156   void set_mismatched_access() { _mismatched_access = true; }
 157   bool is_mismatched_access() const { return _mismatched_access; }
 158   void set_unsafe_access() { _unsafe_access = true; }
 159   bool is_unsafe_access() const { return _unsafe_access; }
 160 
 161 #ifndef PRODUCT
 162   static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);
 163   virtual void dump_spec(outputStream *st) const;
 164 #endif
 165 };
 166 
 167 //------------------------------LoadNode---------------------------------------
 168 // Load value; requires Memory and Address
 169 class LoadNode : public MemNode {
 170 public:
 171   // Some loads (from unsafe) should be pinned: they don&#39;t depend only
 172   // on the dominating test.  The field _control_dependency below records
 173   // whether that node depends only on the dominating test.
<span class="line-modified"> 174   // Pinned and UnknownControl are similar, but differ in that Pinned</span>
<span class="line-modified"> 175   // loads are not allowed to float across safepoints, whereas UnknownControl</span>
<span class="line-modified"> 176   // loads are allowed to do that. Therefore, Pinned is stricter.</span>



 177   enum ControlDependency {
 178     Pinned,
<span class="line-added"> 179     UnknownControl,</span>
 180     DependsOnlyOnTest
 181   };
<span class="line-added"> 182 </span>
 183 private:
 184   // LoadNode::hash() doesn&#39;t take the _control_dependency field
 185   // into account: If the graph already has a non-pinned LoadNode and
 186   // we add a pinned LoadNode with the same inputs, it&#39;s safe for GVN
 187   // to replace the pinned LoadNode with the non-pinned LoadNode,
 188   // otherwise it wouldn&#39;t be safe to have a non pinned LoadNode with
 189   // those inputs in the first place. If the graph already has a
 190   // pinned LoadNode and we add a non pinned LoadNode with the same
 191   // inputs, it&#39;s safe (but suboptimal) for GVN to replace the
 192   // non-pinned LoadNode by the pinned LoadNode.
 193   ControlDependency _control_dependency;
 194 
 195   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 196   // loads that can be reordered, and such requiring acquire semantics to
 197   // adhere to the Java specification.  The required behaviour is stored in
 198   // this field.
 199   const MemOrd _mo;
 200 
<span class="line-added"> 201   AllocateNode* is_new_object_mark_load(PhaseGVN *phase) const;</span>
<span class="line-added"> 202 </span>
 203 protected:
<span class="line-modified"> 204   virtual bool cmp(const Node &amp;n) const;</span>
 205   virtual uint size_of() const; // Size is bigger
 206   // Should LoadNode::Ideal() attempt to remove control edges?
 207   virtual bool can_remove_control() const;
 208   const Type* const _type;      // What kind of value is loaded?
 209 
 210   virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*&amp; mem, bool can_see_stored_value) const;
 211 public:
 212 
 213   LoadNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *rt, MemOrd mo, ControlDependency control_dependency)
 214     : MemNode(c,mem,adr,at), _control_dependency(control_dependency), _mo(mo), _type(rt) {
 215     init_class_id(Class_Load);
 216   }
 217   inline bool is_unordered() const { return !is_acquire(); }
 218   inline bool is_acquire() const {
 219     assert(_mo == unordered || _mo == acquire, &quot;unexpected&quot;);
 220     return _mo == acquire;
 221   }
 222   inline bool is_unsigned() const {
 223     int lop = Opcode();
 224     return (lop == Op_LoadUB) || (lop == Op_LoadUS);
 225   }
 226 
 227   // Polymorphic factory method:
 228   static Node* make(PhaseGVN&amp; gvn, Node *c, Node *mem, Node *adr,
 229                     const TypePtr* at, const Type *rt, BasicType bt,
 230                     MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 231                     bool unaligned = false, bool mismatched = false, bool unsafe = false,</span>
<span class="line-added"> 232                     uint8_t barrier_data = 0);</span>
 233 
 234   virtual uint hash()   const;  // Check the type
 235 
 236   // Handle algebraic identities here.  If we have an identity, return the Node
 237   // we are equivalent to.  We look for Load of a Store.
 238   virtual Node* Identity(PhaseGVN* phase);
 239 
 240   // If the load is from Field memory and the pointer is non-null, it might be possible to
 241   // zero out the control input.
 242   // If the offset is constant and the base is an object allocation,
 243   // try to hook me up to the exact initializing store.
 244   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 245 
 246   // Split instance field load through Phi.
 247   Node* split_through_phi(PhaseGVN *phase);
 248 
 249   // Recover original value from boxed values
 250   Node *eliminate_autobox(PhaseGVN *phase);
 251 
 252   // Compute a new Type for this node.  Basically we just do the pre-check,
</pre>
<hr />
<pre>
 264     assert(t != NULL, &quot;sanity&quot;);
 265     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 266     *(const Type**)&amp;_type = t;   // cast away const-ness
 267     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 268     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
 269   }
 270   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
 271 
 272   // Do not match memory edge
 273   virtual uint match_edge(uint idx) const;
 274 
 275   // Map a load opcode to its corresponding store opcode.
 276   virtual int store_Opcode() const = 0;
 277 
 278   // Check if the load&#39;s memory input is a Phi node with the same control.
 279   bool is_instance_field_load_with_local_phi(Node* ctrl);
 280 
 281   Node* convert_to_unsigned_load(PhaseGVN&amp; gvn);
 282   Node* convert_to_signed_load(PhaseGVN&amp; gvn);
 283 
<span class="line-added"> 284   void pin() { _control_dependency = Pinned; }</span>
<span class="line-added"> 285   bool has_unknown_control_dependency() const { return _control_dependency == UnknownControl; }</span>
<span class="line-added"> 286 </span>
 287 #ifndef PRODUCT
 288   virtual void dump_spec(outputStream *st) const;
 289 #endif
 290 #ifdef ASSERT
 291   // Helper function to allow a raw load without control edge for some cases
 292   static bool is_immutable_value(Node* adr);
 293 #endif
 294 protected:
 295   const Type* load_array_final_field(const TypeKlassPtr *tkls,
 296                                      ciKlass* klass) const;
 297 
 298   Node* can_see_arraycopy_value(Node* st, PhaseGVN* phase) const;
 299 
 300   // depends_only_on_test is almost always true, and needs to be almost always
 301   // true to enable key hoisting &amp; commoning optimizations.  However, for the
 302   // special case of RawPtr loads from TLS top &amp; end, and other loads performed by
 303   // GC barriers, the control edge carries the dependence preventing hoisting past
 304   // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
 305   // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
 306   // which produce results (new raw memory state) inside of loops preventing all
</pre>
<hr />
<pre>
 378   virtual int store_Opcode() const { return Op_StoreI; }
 379   virtual BasicType memory_type() const { return T_INT; }
 380 };
 381 
 382 //------------------------------LoadRangeNode----------------------------------
 383 // Load an array length from the array
 384 class LoadRangeNode : public LoadINode {
 385 public:
 386   LoadRangeNode(Node *c, Node *mem, Node *adr, const TypeInt *ti = TypeInt::POS)
 387     : LoadINode(c, mem, adr, TypeAryPtr::RANGE, ti, MemNode::unordered) {}
 388   virtual int Opcode() const;
 389   virtual const Type* Value(PhaseGVN* phase) const;
 390   virtual Node* Identity(PhaseGVN* phase);
 391   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 392 };
 393 
 394 //------------------------------LoadLNode--------------------------------------
 395 // Load a long from memory
 396 class LoadLNode : public LoadNode {
 397   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<span class="line-modified"> 398   virtual bool cmp( const Node &amp;n ) const {</span>
 399     return _require_atomic_access == ((LoadLNode&amp;)n)._require_atomic_access
 400       &amp;&amp; LoadNode::cmp(n);
 401   }
 402   virtual uint size_of() const { return sizeof(*this); }
 403   const bool _require_atomic_access;  // is piecewise load forbidden?
 404 
 405 public:
 406   LoadLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const TypeLong *tl,
 407             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 408     : LoadNode(c, mem, adr, at, tl, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 409   virtual int Opcode() const;
 410   virtual uint ideal_reg() const { return Op_RegL; }
 411   virtual int store_Opcode() const { return Op_StoreL; }
 412   virtual BasicType memory_type() const { return T_LONG; }
 413   bool require_atomic_access() const { return _require_atomic_access; }
 414   static LoadLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 415                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 416                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);</span>
 417 #ifndef PRODUCT
 418   virtual void dump_spec(outputStream *st) const {
 419     LoadNode::dump_spec(st);
 420     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 421   }
 422 #endif
 423 };
 424 
 425 //------------------------------LoadL_unalignedNode----------------------------
 426 // Load a long from unaligned memory
 427 class LoadL_unalignedNode : public LoadLNode {
 428 public:
 429   LoadL_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 430     : LoadLNode(c, mem, adr, at, TypeLong::LONG, mo, control_dependency) {}
 431   virtual int Opcode() const;
 432 };
 433 
 434 //------------------------------LoadFNode--------------------------------------
 435 // Load a float (64 bits) from memory
 436 class LoadFNode : public LoadNode {
 437 public:
 438   LoadFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 439     : LoadNode(c, mem, adr, at, t, mo, control_dependency) {}
 440   virtual int Opcode() const;
 441   virtual uint ideal_reg() const { return Op_RegF; }
 442   virtual int store_Opcode() const { return Op_StoreF; }
 443   virtual BasicType memory_type() const { return T_FLOAT; }
 444 };
 445 
 446 //------------------------------LoadDNode--------------------------------------
 447 // Load a double (64 bits) from memory
 448 class LoadDNode : public LoadNode {
 449   virtual uint hash() const { return LoadNode::hash() + _require_atomic_access; }
<span class="line-modified"> 450   virtual bool cmp( const Node &amp;n ) const {</span>
 451     return _require_atomic_access == ((LoadDNode&amp;)n)._require_atomic_access
 452       &amp;&amp; LoadNode::cmp(n);
 453   }
 454   virtual uint size_of() const { return sizeof(*this); }
 455   const bool _require_atomic_access;  // is piecewise load forbidden?
 456 
 457 public:
 458   LoadDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, const Type *t,
 459             MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest, bool require_atomic_access = false)
 460     : LoadNode(c, mem, adr, at, t, mo, control_dependency), _require_atomic_access(require_atomic_access) {}
 461   virtual int Opcode() const;
 462   virtual uint ideal_reg() const { return Op_RegD; }
 463   virtual int store_Opcode() const { return Op_StoreD; }
 464   virtual BasicType memory_type() const { return T_DOUBLE; }
 465   bool require_atomic_access() const { return _require_atomic_access; }
 466   static LoadDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type,
 467                                 const Type* rt, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest,
<span class="line-modified"> 468                                 bool unaligned = false, bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0);</span>
 469 #ifndef PRODUCT
 470   virtual void dump_spec(outputStream *st) const {
 471     LoadNode::dump_spec(st);
 472     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 473   }
 474 #endif
 475 };
 476 
 477 //------------------------------LoadD_unalignedNode----------------------------
 478 // Load a double from unaligned memory
 479 class LoadD_unalignedNode : public LoadDNode {
 480 public:
 481   LoadD_unalignedNode(Node *c, Node *mem, Node *adr, const TypePtr* at, MemOrd mo, ControlDependency control_dependency = DependsOnlyOnTest)
 482     : LoadDNode(c, mem, adr, at, Type::DOUBLE, mo, control_dependency) {}
 483   virtual int Opcode() const;
 484 };
 485 
 486 //------------------------------LoadPNode--------------------------------------
 487 // Load a pointer from memory (either object or array)
 488 class LoadPNode : public LoadNode {
</pre>
<hr />
<pre>
 540   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 541 
 542   virtual const Type* Value(PhaseGVN* phase) const;
 543   virtual Node* Identity(PhaseGVN* phase);
 544   virtual bool depends_only_on_test() const { return true; }
 545 };
 546 
 547 
 548 //------------------------------StoreNode--------------------------------------
 549 // Store value; requires Store, Address and Value
 550 class StoreNode : public MemNode {
 551 private:
 552   // On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish
 553   // stores that can be reordered, and such requiring release semantics to
 554   // adhere to the Java specification.  The required behaviour is stored in
 555   // this field.
 556   const MemOrd _mo;
 557   // Needed for proper cloning.
 558   virtual uint size_of() const { return sizeof(*this); }
 559 protected:
<span class="line-modified"> 560   virtual bool cmp( const Node &amp;n ) const;</span>
 561   virtual bool depends_only_on_test() const { return false; }
 562 
 563   Node *Ideal_masked_input       (PhaseGVN *phase, uint mask);
 564   Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);
 565 
 566 public:
 567   // We must ensure that stores of object references will be visible
 568   // only after the object&#39;s initialization. So the callers of this
 569   // procedure must indicate that the store requires `release&#39;
 570   // semantics, if the stored value is an object reference that might
 571   // point to a new object and may become externally visible.
 572   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 573     : MemNode(c, mem, adr, at, val), _mo(mo) {
 574     init_class_id(Class_Store);
 575   }
 576   StoreNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, MemOrd mo)
 577     : MemNode(c, mem, adr, at, val, oop_store), _mo(mo) {
 578     init_class_id(Class_Store);
 579   }
 580 
</pre>
<hr />
<pre>
 655     : StoreNode(c, mem, adr, at, val, mo) {}
 656   virtual int Opcode() const;
 657   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 658   virtual BasicType memory_type() const { return T_CHAR; }
 659 };
 660 
 661 //------------------------------StoreINode-------------------------------------
 662 // Store int to memory
 663 class StoreINode : public StoreNode {
 664 public:
 665   StoreINode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 666     : StoreNode(c, mem, adr, at, val, mo) {}
 667   virtual int Opcode() const;
 668   virtual BasicType memory_type() const { return T_INT; }
 669 };
 670 
 671 //------------------------------StoreLNode-------------------------------------
 672 // Store long to memory
 673 class StoreLNode : public StoreNode {
 674   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<span class="line-modified"> 675   virtual bool cmp( const Node &amp;n ) const {</span>
 676     return _require_atomic_access == ((StoreLNode&amp;)n)._require_atomic_access
 677       &amp;&amp; StoreNode::cmp(n);
 678   }
 679   virtual uint size_of() const { return sizeof(*this); }
 680   const bool _require_atomic_access;  // is piecewise store forbidden?
 681 
 682 public:
 683   StoreLNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo, bool require_atomic_access = false)
 684     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 685   virtual int Opcode() const;
 686   virtual BasicType memory_type() const { return T_LONG; }
 687   bool require_atomic_access() const { return _require_atomic_access; }
 688   static StoreLNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 689 #ifndef PRODUCT
 690   virtual void dump_spec(outputStream *st) const {
 691     StoreNode::dump_spec(st);
 692     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 693   }
 694 #endif
 695 };
 696 
 697 //------------------------------StoreFNode-------------------------------------
 698 // Store float to memory
 699 class StoreFNode : public StoreNode {
 700 public:
 701   StoreFNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 702     : StoreNode(c, mem, adr, at, val, mo) {}
 703   virtual int Opcode() const;
 704   virtual BasicType memory_type() const { return T_FLOAT; }
 705 };
 706 
 707 //------------------------------StoreDNode-------------------------------------
 708 // Store double to memory
 709 class StoreDNode : public StoreNode {
 710   virtual uint hash() const { return StoreNode::hash() + _require_atomic_access; }
<span class="line-modified"> 711   virtual bool cmp( const Node &amp;n ) const {</span>
 712     return _require_atomic_access == ((StoreDNode&amp;)n)._require_atomic_access
 713       &amp;&amp; StoreNode::cmp(n);
 714   }
 715   virtual uint size_of() const { return sizeof(*this); }
 716   const bool _require_atomic_access;  // is piecewise store forbidden?
 717 public:
 718   StoreDNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val,
 719              MemOrd mo, bool require_atomic_access = false)
 720     : StoreNode(c, mem, adr, at, val, mo), _require_atomic_access(require_atomic_access) {}
 721   virtual int Opcode() const;
 722   virtual BasicType memory_type() const { return T_DOUBLE; }
 723   bool require_atomic_access() const { return _require_atomic_access; }
 724   static StoreDNode* make_atomic(Node* ctl, Node* mem, Node* adr, const TypePtr* adr_type, Node* val, MemOrd mo);
 725 #ifndef PRODUCT
 726   virtual void dump_spec(outputStream *st) const {
 727     StoreNode::dump_spec(st);
 728     if (_require_atomic_access)  st-&gt;print(&quot; Atomic!&quot;);
 729   }
 730 #endif
 731 
</pre>
<hr />
<pre>
 751   virtual BasicType memory_type() const { return T_NARROWOOP; }
 752 };
 753 
 754 //------------------------------StoreNKlassNode--------------------------------------
 755 // Store narrow klass to memory
 756 class StoreNKlassNode : public StoreNNode {
 757 public:
 758   StoreNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, MemOrd mo)
 759     : StoreNNode(c, mem, adr, at, val, mo) {}
 760   virtual int Opcode() const;
 761   virtual BasicType memory_type() const { return T_NARROWKLASS; }
 762 };
 763 
 764 //------------------------------StoreCMNode-----------------------------------
 765 // Store card-mark byte to memory for CM
 766 // The last StoreCM before a SafePoint must be preserved and occur after its &quot;oop&quot; store
 767 // Preceeding equivalent StoreCMs may be eliminated.
 768 class StoreCMNode : public StoreNode {
 769  private:
 770   virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }
<span class="line-modified"> 771   virtual bool cmp( const Node &amp;n ) const {</span>
 772     return _oop_alias_idx == ((StoreCMNode&amp;)n)._oop_alias_idx
 773       &amp;&amp; StoreNode::cmp(n);
 774   }
 775   virtual uint size_of() const { return sizeof(*this); }
 776   int _oop_alias_idx;   // The alias_idx of OopStore
 777 
 778 public:
 779   StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :
 780     StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),
 781     _oop_alias_idx(oop_alias_idx) {
 782     assert(_oop_alias_idx &gt;= Compile::AliasIdxRaw ||
 783            _oop_alias_idx == Compile::AliasIdxBot &amp;&amp; Compile::current()-&gt;AliasLevel() == 0,
 784            &quot;bad oop alias idx&quot;);
 785   }
 786   virtual int Opcode() const;
 787   virtual Node* Identity(PhaseGVN* phase);
 788   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 789   virtual const Type* Value(PhaseGVN* phase) const;
 790   virtual BasicType memory_type() const { return T_VOID; } // unspecific
 791   int oop_alias_idx() const { return _oop_alias_idx; }
</pre>
<hr />
<pre>
 815   virtual bool      is_CFG() const  { return false; }
 816   virtual const Type *bottom_type() const {return Type::MEMORY;}
 817   virtual const TypePtr *adr_type() const {
 818     Node* ctrl = in(0);
 819     if (ctrl == NULL)  return NULL; // node is dead
 820     return ctrl-&gt;in(MemNode::Memory)-&gt;adr_type();
 821   }
 822   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register
 823   virtual const Type* Value(PhaseGVN* phase) const;
 824 #ifndef PRODUCT
 825   virtual void dump_spec(outputStream *st) const {};
 826 #endif
 827 };
 828 
 829 //------------------------------LoadStoreNode---------------------------
 830 // Note: is_Mem() method returns &#39;true&#39; for this class.
 831 class LoadStoreNode : public Node {
 832 private:
 833   const Type* const _type;      // What kind of value is loaded?
 834   const TypePtr* _adr_type;     // What kind of memory is being addressed?
<span class="line-added"> 835   uint8_t _barrier; // Bit field with barrier information</span>
 836   virtual uint size_of() const; // Size is bigger
 837 public:
 838   LoadStoreNode( Node *c, Node *mem, Node *adr, Node *val, const TypePtr* at, const Type* rt, uint required );
 839   virtual bool depends_only_on_test() const { return false; }
 840   virtual uint match_edge(uint idx) const { return idx == MemNode::Address || idx == MemNode::ValueIn; }
 841 
 842   virtual const Type *bottom_type() const { return _type; }
 843   virtual uint ideal_reg() const;
 844   virtual const class TypePtr *adr_type() const { return _adr_type; }  // returns bottom_type of address
 845 
 846   bool result_not_used() const;
 847   MemBarNode* trailing_membar() const;
<span class="line-added"> 848 </span>
<span class="line-added"> 849   uint8_t barrier_data() { return _barrier; }</span>
<span class="line-added"> 850   void set_barrier_data(uint8_t barrier_data) { _barrier = barrier_data; }</span>
 851 };
 852 
 853 class LoadStoreConditionalNode : public LoadStoreNode {
 854 public:
 855   enum {
 856     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 857   };
 858   LoadStoreConditionalNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex);
 859 };
 860 
 861 //------------------------------StorePConditionalNode---------------------------
 862 // Conditionally store pointer to memory, if no change since prior
 863 // load-locked.  Sets flags for success or failure of the store.
 864 class StorePConditionalNode : public LoadStoreConditionalNode {
 865 public:
 866   StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 867   virtual int Opcode() const;
 868   // Produces flags
 869   virtual uint ideal_reg() const { return Op_RegFlags; }
 870 };
</pre>
<hr />
<pre>
 882 
 883 //------------------------------StoreLConditionalNode---------------------------
 884 // Conditionally store long to memory, if no change since prior
 885 // load-locked.  Sets flags for success or failure of the store.
 886 class StoreLConditionalNode : public LoadStoreConditionalNode {
 887 public:
 888   StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }
 889   virtual int Opcode() const;
 890   // Produces flags
 891   virtual uint ideal_reg() const { return Op_RegFlags; }
 892 };
 893 
 894 class CompareAndSwapNode : public LoadStoreConditionalNode {
 895 private:
 896   const MemNode::MemOrd _mem_ord;
 897 public:
 898   CompareAndSwapNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : LoadStoreConditionalNode(c, mem, adr, val, ex), _mem_ord(mem_ord) {}
 899   MemNode::MemOrd order() const {
 900     return _mem_ord;
 901   }
<span class="line-added"> 902   virtual uint size_of() const { return sizeof(*this); }</span>
 903 };
 904 
 905 class CompareAndExchangeNode : public LoadStoreNode {
 906 private:
 907   const MemNode::MemOrd _mem_ord;
 908 public:
 909   enum {
 910     ExpectedIn = MemNode::ValueIn+1 // One more input than MemNode
 911   };
 912   CompareAndExchangeNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord, const TypePtr* at, const Type* t) :
 913     LoadStoreNode(c, mem, adr, val, at, t, 5), _mem_ord(mem_ord) {
 914      init_req(ExpectedIn, ex );
 915   }
 916 
 917   MemNode::MemOrd order() const {
 918     return _mem_ord;
 919   }
<span class="line-added"> 920   virtual uint size_of() const { return sizeof(*this); }</span>
 921 };
 922 
 923 //------------------------------CompareAndSwapBNode---------------------------
 924 class CompareAndSwapBNode : public CompareAndSwapNode {
 925 public:
 926   CompareAndSwapBNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 927   virtual int Opcode() const;
 928 };
 929 
 930 //------------------------------CompareAndSwapSNode---------------------------
 931 class CompareAndSwapSNode : public CompareAndSwapNode {
 932 public:
 933   CompareAndSwapSNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
 934   virtual int Opcode() const;
 935 };
 936 
 937 //------------------------------CompareAndSwapINode---------------------------
 938 class CompareAndSwapINode : public CompareAndSwapNode {
 939 public:
 940   CompareAndSwapINode( Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord) : CompareAndSwapNode(c, mem, adr, val, ex, mem_ord) { }
</pre>
<hr />
<pre>
1153   static Node* clear_memory(Node* control, Node* mem, Node* dest,
1154                             Node* start_offset,
1155                             Node* end_offset,
1156                             PhaseGVN* phase);
1157   // Return allocation input memory edge if it is different instance
1158   // or itself if it is the one we are looking for.
1159   static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);
1160 };
1161 
1162 //------------------------------MemBar-----------------------------------------
1163 // There are different flavors of Memory Barriers to match the Java Memory
1164 // Model.  Monitor-enter and volatile-load act as Aquires: no following ref
1165 // can be moved to before them.  We insert a MemBar-Acquire after a FastLock or
1166 // volatile-load.  Monitor-exit and volatile-store act as Release: no
1167 // preceding ref can be moved to after them.  We insert a MemBar-Release
1168 // before a FastUnlock or volatile-store.  All volatiles need to be
1169 // serialized, so we follow all volatile-stores with a MemBar-Volatile to
1170 // separate it from any following volatile-load.
1171 class MemBarNode: public MultiNode {
1172   virtual uint hash() const ;                  // { return NO_HASH; }
<span class="line-modified">1173   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1174 
1175   virtual uint size_of() const { return sizeof(*this); }
1176   // Memory type this node is serializing.  Usually either rawptr or bottom.
1177   const TypePtr* _adr_type;
1178 
1179   // How is this membar related to a nearby memory access?
1180   enum {
1181     Standalone,
1182     TrailingLoad,
1183     TrailingStore,
1184     LeadingStore,
1185     TrailingLoadStore,
1186     LeadingLoadStore
1187   } _kind;
1188 
1189 #ifdef ASSERT
1190   uint _pair_idx;
1191 #endif
1192 
1193 public:
</pre>
<hr />
<pre>
1371   // An InitializeNode must completed before macro expansion is done.
1372   // Completion requires that the AllocateNode must be followed by
1373   // initialization of the new memory to zero, then to any initializers.
1374   bool is_complete() { return _is_complete != Incomplete; }
1375   bool is_complete_with_arraycopy() { return (_is_complete &amp; WithArraycopy) != 0; }
1376 
1377   // Mark complete.  (Must not yet be complete.)
1378   void set_complete(PhaseGVN* phase);
1379   void set_complete_with_arraycopy() { _is_complete = Complete | WithArraycopy; }
1380 
1381   bool does_not_escape() { return _does_not_escape; }
1382   void set_does_not_escape() { _does_not_escape = true; }
1383 
1384 #ifdef ASSERT
1385   // ensure all non-degenerate stores are ordered and non-overlapping
1386   bool stores_are_sane(PhaseTransform* phase);
1387 #endif //ASSERT
1388 
1389   // See if this store can be captured; return offset where it initializes.
1390   // Return 0 if the store cannot be moved (any sort of problem).
<span class="line-modified">1391   intptr_t can_capture_store(StoreNode* st, PhaseGVN* phase, bool can_reshape);</span>
1392 
1393   // Capture another store; reformat it to write my internal raw memory.
1394   // Return the captured copy, else NULL if there is some sort of problem.
<span class="line-modified">1395   Node* capture_store(StoreNode* st, intptr_t start, PhaseGVN* phase, bool can_reshape);</span>
1396 
1397   // Find captured store which corresponds to the range [start..start+size).
1398   // Return my own memory projection (meaning the initial zero bits)
1399   // if there is no such store.  Return NULL if there is a problem.
1400   Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);
1401 
1402   // Called when the associated AllocateNode is expanded into CFG.
1403   Node* complete_stores(Node* rawctl, Node* rawmem, Node* rawptr,
1404                         intptr_t header_size, Node* size_in_bytes,
<span class="line-modified">1405                         PhaseIterGVN* phase);</span>
1406 
1407  private:
1408   void remove_extra_zeroes();
1409 
1410   // Find out where a captured store should be placed (or already is placed).
1411   int captured_store_insertion_point(intptr_t start, int size_in_bytes,
1412                                      PhaseTransform* phase);
1413 
1414   static intptr_t get_store_offset(Node* st, PhaseTransform* phase);
1415 
1416   Node* make_raw_address(intptr_t offset, PhaseTransform* phase);
1417 
<span class="line-modified">1418   bool detect_init_independence(Node* value, PhaseGVN* phase);</span>
1419 
1420   void coalesce_subword_stores(intptr_t header_size, Node* size_in_bytes,
1421                                PhaseGVN* phase);
1422 
1423   intptr_t find_next_fullword_store(uint i, PhaseGVN* phase);
1424 };
1425 
1426 //------------------------------MergeMem---------------------------------------
1427 // (See comment in memnode.cpp near MergeMemNode::MergeMemNode for semantics.)
1428 class MergeMemNode: public Node {
1429   virtual uint hash() const ;                  // { return NO_HASH; }
<span class="line-modified">1430   virtual bool cmp( const Node &amp;n ) const ;    // Always fail, except on self</span>
1431   friend class MergeMemStream;
1432   MergeMemNode(Node* def);  // clients use MergeMemNode::make
1433 
1434 public:
1435   // If the input is a whole memory state, clone it with all its slices intact.
1436   // Otherwise, make a new memory state with just that base memory input.
1437   // In either case, the result is a newly created MergeMem.
1438   static MergeMemNode* make(Node* base_memory);
1439 
1440   virtual int Opcode() const;
1441   virtual Node* Identity(PhaseGVN* phase);
1442   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1443   virtual uint ideal_reg() const { return NotAMachineReg; }
1444   virtual uint match_edge(uint idx) const { return 0; }
1445   virtual const RegMask &amp;out_RegMask() const;
1446   virtual const Type *bottom_type() const { return Type::MEMORY; }
1447   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
1448   // sparse accessors
1449   // Fetch the previously stored &quot;set_memory_at&quot;, or else the base memory.
1450   // (Caller should clone it if it is a phi-nest.)
</pre>
<hr />
<pre>
1642       return true;
1643     }
1644     return false;
1645   }
1646 
1647   // find the next non-empty item
1648   bool next_non_empty(bool have_mm2) {
1649     while (next(have_mm2)) {
1650       if (!is_empty()) {
1651         // make sure _mem2 is filled in sensibly
1652         if (have_mm2 &amp;&amp; _mem2-&gt;is_top())  _mem2 = _mm2-&gt;base_memory();
1653         return true;
1654       } else if (have_mm2 &amp;&amp; !is_empty2()) {
1655         return true;   // is_empty() == true
1656       }
1657     }
1658     return false;
1659   }
1660 };
1661 
<span class="line-added">1662 // cachewb node for guaranteeing writeback of the cache line at a</span>
<span class="line-added">1663 // given address to (non-volatile) RAM</span>
<span class="line-added">1664 class CacheWBNode : public Node {</span>
<span class="line-added">1665 public:</span>
<span class="line-added">1666   CacheWBNode(Node *ctrl, Node *mem, Node *addr) : Node(ctrl, mem, addr) {}</span>
<span class="line-added">1667   virtual int Opcode() const;</span>
<span class="line-added">1668   virtual uint ideal_reg() const { return NotAMachineReg; }</span>
<span class="line-added">1669   virtual uint match_edge(uint idx) const { return (idx == 2); }</span>
<span class="line-added">1670   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }</span>
<span class="line-added">1671   virtual const Type *bottom_type() const { return Type::MEMORY; }</span>
<span class="line-added">1672 };</span>
<span class="line-added">1673 </span>
<span class="line-added">1674 // cachewb pre sync node for ensuring that writebacks are serialised</span>
<span class="line-added">1675 // relative to preceding or following stores</span>
<span class="line-added">1676 class CacheWBPreSyncNode : public Node {</span>
<span class="line-added">1677 public:</span>
<span class="line-added">1678   CacheWBPreSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}</span>
<span class="line-added">1679   virtual int Opcode() const;</span>
<span class="line-added">1680   virtual uint ideal_reg() const { return NotAMachineReg; }</span>
<span class="line-added">1681   virtual uint match_edge(uint idx) const { return false; }</span>
<span class="line-added">1682   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }</span>
<span class="line-added">1683   virtual const Type *bottom_type() const { return Type::MEMORY; }</span>
<span class="line-added">1684 };</span>
<span class="line-added">1685 </span>
<span class="line-added">1686 // cachewb pre sync node for ensuring that writebacks are serialised</span>
<span class="line-added">1687 // relative to preceding or following stores</span>
<span class="line-added">1688 class CacheWBPostSyncNode : public Node {</span>
<span class="line-added">1689 public:</span>
<span class="line-added">1690   CacheWBPostSyncNode(Node *ctrl, Node *mem) : Node(ctrl, mem) {}</span>
<span class="line-added">1691   virtual int Opcode() const;</span>
<span class="line-added">1692   virtual uint ideal_reg() const { return NotAMachineReg; }</span>
<span class="line-added">1693   virtual uint match_edge(uint idx) const { return false; }</span>
<span class="line-added">1694   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }</span>
<span class="line-added">1695   virtual const Type *bottom_type() const { return Type::MEMORY; }</span>
<span class="line-added">1696 };</span>
<span class="line-added">1697 </span>
1698 //------------------------------Prefetch---------------------------------------
1699 
1700 // Allocation prefetch which may fault, TLAB size have to be adjusted.
1701 class PrefetchAllocationNode : public Node {
1702 public:
1703   PrefetchAllocationNode(Node *mem, Node *adr) : Node(0,mem,adr) {}
1704   virtual int Opcode() const;
1705   virtual uint ideal_reg() const { return NotAMachineReg; }
1706   virtual uint match_edge(uint idx) const { return idx==2; }
1707   virtual const Type *bottom_type() const { return ( AllocatePrefetchStyle == 3 ) ? Type::MEMORY : Type::ABIO; }
1708 };
1709 
1710 #endif // SHARE_OPTO_MEMNODE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mulnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
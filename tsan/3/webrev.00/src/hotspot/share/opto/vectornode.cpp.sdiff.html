<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/vectornode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/vectornode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.inline.hpp&quot;
 26 #include &quot;opto/connode.hpp&quot;
 27 #include &quot;opto/vectornode.hpp&quot;

 28 
 29 //------------------------------VectorNode--------------------------------------
 30 
 31 // Return the vector operator for the specified scalar operation
 32 // and vector length.
 33 int VectorNode::opcode(int sopc, BasicType bt) {
 34   switch (sopc) {
 35   case Op_AddI:
 36     switch (bt) {
 37     case T_BOOLEAN:
 38     case T_BYTE:      return Op_AddVB;
 39     case T_CHAR:
 40     case T_SHORT:     return Op_AddVS;
 41     case T_INT:       return Op_AddVI;
 42     default:          ShouldNotReachHere(); return 0;
 43     }
 44   case Op_AddL:
 45     assert(bt == T_LONG, &quot;must be&quot;);
 46     return Op_AddVL;
 47   case Op_AddF:
</pre>
<hr />
<pre>
 53   case Op_SubI:
 54     switch (bt) {
 55     case T_BOOLEAN:
 56     case T_BYTE:   return Op_SubVB;
 57     case T_CHAR:
 58     case T_SHORT:  return Op_SubVS;
 59     case T_INT:    return Op_SubVI;
 60     default:       ShouldNotReachHere(); return 0;
 61     }
 62   case Op_SubL:
 63     assert(bt == T_LONG, &quot;must be&quot;);
 64     return Op_SubVL;
 65   case Op_SubF:
 66     assert(bt == T_FLOAT, &quot;must be&quot;);
 67     return Op_SubVF;
 68   case Op_SubD:
 69     assert(bt == T_DOUBLE, &quot;must be&quot;);
 70     return Op_SubVD;
 71   case Op_MulI:
 72     switch (bt) {
<span class="line-modified"> 73     case T_BOOLEAN:</span>
<span class="line-modified"> 74     case T_BYTE:   return 0;   // Unimplemented</span>
 75     case T_CHAR:
 76     case T_SHORT:  return Op_MulVS;
 77     case T_INT:    return Op_MulVI;
 78     default:       ShouldNotReachHere(); return 0;
 79     }
 80   case Op_MulL:
 81     assert(bt == T_LONG, &quot;must be&quot;);
 82     return Op_MulVL;
 83   case Op_MulF:
 84     assert(bt == T_FLOAT, &quot;must be&quot;);
 85     return Op_MulVF;
 86   case Op_MulD:
 87     assert(bt == T_DOUBLE, &quot;must be&quot;);
 88     return Op_MulVD;
 89   case Op_FmaD:
 90     assert(bt == T_DOUBLE, &quot;must be&quot;);
 91     return Op_FmaVD;
 92   case Op_FmaF:
 93     assert(bt == T_FLOAT, &quot;must be&quot;);
 94     return Op_FmaVF;
 95   case Op_CMoveF:
 96     assert(bt == T_FLOAT, &quot;must be&quot;);
 97     return Op_CMoveVF;
 98   case Op_CMoveD:
 99     assert(bt == T_DOUBLE, &quot;must be&quot;);
100     return Op_CMoveVD;
101   case Op_DivF:
102     assert(bt == T_FLOAT, &quot;must be&quot;);
103     return Op_DivVF;
104   case Op_DivD:
105     assert(bt == T_DOUBLE, &quot;must be&quot;);
106     return Op_DivVD;












107   case Op_AbsF:
108     assert(bt == T_FLOAT, &quot;must be&quot;);
109     return Op_AbsVF;
110   case Op_AbsD:
111     assert(bt == T_DOUBLE, &quot;must be&quot;);
112     return Op_AbsVD;
113   case Op_NegF:
114     assert(bt == T_FLOAT, &quot;must be&quot;);
115     return Op_NegVF;
116   case Op_NegD:
117     assert(bt == T_DOUBLE, &quot;must be&quot;);
118     return Op_NegVD;



119   case Op_SqrtF:
120     assert(bt == T_FLOAT, &quot;must be&quot;);
121     return Op_SqrtVF;
122   case Op_SqrtD:
123     assert(bt == T_DOUBLE, &quot;must be&quot;);
124     return Op_SqrtVD;
125   case Op_PopCountI:
126     if (bt == T_INT) {
127       return Op_PopCountVI;
128     }
129     // Unimplemented for subword types since bit count changes
130     // depending on size of lane (and sign bit).
131     return 0;
132   case Op_LShiftI:
133     switch (bt) {
134     case T_BOOLEAN:
135     case T_BYTE:   return Op_LShiftVB;
136     case T_CHAR:
137     case T_SHORT:  return Op_LShiftVS;
138     case T_INT:    return Op_LShiftVI;
</pre>
<hr />
<pre>
206   case Op_StoreI:
207   case Op_StoreL:
208   case Op_StoreF:
209   case Op_StoreD:
210     return Op_StoreVector;
211   case Op_MulAddS2I:
212     return Op_MulAddVS2VI;
213 
214   default:
215     return 0; // Unimplemented
216   }
217 }
218 
219 // Also used to check if the code generator
220 // supports the vector operation.
221 bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {
222   if (is_java_primitive(bt) &amp;&amp;
223       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
224       Matcher::vector_size_supported(bt, vlen)) {
225     int vopc = VectorNode::opcode(opc, bt);
<span class="line-modified">226     return vopc &gt; 0 &amp;&amp; Matcher::match_rule_supported_vector(vopc, vlen);</span>
227   }
228   return false;
229 }
230 
231 bool VectorNode::is_type_transition_short_to_int(Node* n) {
232   switch (n-&gt;Opcode()) {
233   case Op_MulAddS2I:
234     return true;
235   }
236   return false;
237 }
238 
239 bool VectorNode::is_type_transition_to_int(Node* n) {
240   return is_type_transition_short_to_int(n);
241 }
242 
243 bool VectorNode::is_muladds2i(Node* n) {
244   if (n-&gt;Opcode() == Op_MulAddS2I) {
245     return true;
246   }
247   return false;
248 }
249 







250 bool VectorNode::is_shift(Node* n) {
251   switch (n-&gt;Opcode()) {
252   case Op_LShiftI:
253   case Op_LShiftL:
254   case Op_RShiftI:
255   case Op_RShiftL:
256   case Op_URShiftI:
257   case Op_URShiftL:
258     return true;
259   default:
260     return false;
261   }
262 }
263 
264 // Check if input is loop invariant vector.
265 bool VectorNode::is_invariant_vector(Node* n) {
266   // Only Replicate vector nodes are loop invariant for now.
267   switch (n-&gt;Opcode()) {
268   case Op_ReplicateB:
269   case Op_ReplicateS:
270   case Op_ReplicateI:
271   case Op_ReplicateL:
272   case Op_ReplicateF:
273   case Op_ReplicateD:
274     return true;
275   default:
276     return false;
277   }
278 }
279 
280 // [Start, end) half-open range defining which operands are vectors
281 void VectorNode::vector_operands(Node* n, uint* start, uint* end) {
282   switch (n-&gt;Opcode()) {
283   case Op_LoadB:   case Op_LoadUB:
284   case Op_LoadS:   case Op_LoadUS:
285   case Op_LoadI:   case Op_LoadL:
286   case Op_LoadF:   case Op_LoadD:
287   case Op_LoadP:   case Op_LoadN:
<span class="line-removed">288   case Op_LoadBarrierSlowReg:</span>
<span class="line-removed">289   case Op_LoadBarrierWeakSlowReg:</span>
290     *start = 0;
291     *end   = 0; // no vector operands
292     break;
293   case Op_StoreB:  case Op_StoreC:
294   case Op_StoreI:  case Op_StoreL:
295   case Op_StoreF:  case Op_StoreD:
296   case Op_StoreP:  case Op_StoreN:
297     *start = MemNode::ValueIn;
298     *end   = MemNode::ValueIn + 1; // 1 vector operand
299     break;
300   case Op_LShiftI:  case Op_LShiftL:
301   case Op_RShiftI:  case Op_RShiftL:
302   case Op_URShiftI: case Op_URShiftL:
303     *start = 1;
304     *end   = 2; // 1 vector operand
305     break;
306   case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:
307   case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:
308   case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:
309   case Op_DivF: case Op_DivD:
</pre>
<hr />
<pre>
333 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {
334   const TypeVect* vt = TypeVect::make(bt, vlen);
335   int vopc = VectorNode::opcode(opc, bt);
336   // This method should not be called for unimplemented vectors.
337   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
338   switch (vopc) {
339   case Op_AddVB: return new AddVBNode(n1, n2, vt);
340   case Op_AddVS: return new AddVSNode(n1, n2, vt);
341   case Op_AddVI: return new AddVINode(n1, n2, vt);
342   case Op_AddVL: return new AddVLNode(n1, n2, vt);
343   case Op_AddVF: return new AddVFNode(n1, n2, vt);
344   case Op_AddVD: return new AddVDNode(n1, n2, vt);
345 
346   case Op_SubVB: return new SubVBNode(n1, n2, vt);
347   case Op_SubVS: return new SubVSNode(n1, n2, vt);
348   case Op_SubVI: return new SubVINode(n1, n2, vt);
349   case Op_SubVL: return new SubVLNode(n1, n2, vt);
350   case Op_SubVF: return new SubVFNode(n1, n2, vt);
351   case Op_SubVD: return new SubVDNode(n1, n2, vt);
352 

353   case Op_MulVS: return new MulVSNode(n1, n2, vt);
354   case Op_MulVI: return new MulVINode(n1, n2, vt);
355   case Op_MulVL: return new MulVLNode(n1, n2, vt);
356   case Op_MulVF: return new MulVFNode(n1, n2, vt);
357   case Op_MulVD: return new MulVDNode(n1, n2, vt);
358 
359   case Op_DivVF: return new DivVFNode(n1, n2, vt);
360   case Op_DivVD: return new DivVDNode(n1, n2, vt);
361 




362   case Op_AbsVF: return new AbsVFNode(n1, vt);
363   case Op_AbsVD: return new AbsVDNode(n1, vt);
364 
365   case Op_NegVF: return new NegVFNode(n1, vt);
366   case Op_NegVD: return new NegVDNode(n1, vt);
367 
368   case Op_SqrtVF: return new SqrtVFNode(n1, vt);
369   case Op_SqrtVD: return new SqrtVDNode(n1, vt);
370 
371   case Op_PopCountVI: return new PopCountVINode(n1, vt);
372 
373   case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);
374   case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);
375   case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);
376   case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);
377 
378   case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);
379   case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);
380   case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);
381   case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);
382 
383   case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);
384   case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);
385   case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);
386   case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);
387 
388   case Op_AndV: return new AndVNode(n1, n2, vt);
389   case Op_OrV:  return new OrVNode (n1, n2, vt);
390   case Op_XorV: return new XorVNode(n1, n2, vt);
391 
392   case Op_MinV: return new MinVNode(n1, n2, vt);
393   case Op_MaxV: return new MaxVNode(n1, n2, vt);
394 


395   case Op_MulAddVS2VI: return new MulAddVS2VINode(n1, n2, vt);
396   default:
397     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
398     return NULL;
399   }
400 }
401 
402 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt) {
403   const TypeVect* vt = TypeVect::make(bt, vlen);
404   int vopc = VectorNode::opcode(opc, bt);
405   // This method should not be called for unimplemented vectors.
406   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
407   switch (vopc) {
408   case Op_FmaVD: return new FmaVDNode(n1, n2, n3, vt);
409   case Op_FmaVF: return new FmaVFNode(n1, n2, n3, vt);
410   default:
411     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
412     return NULL;
413   }
414 }
</pre>
<hr />
<pre>
423   case T_BYTE:
424     return new ReplicateBNode(s, vt);
425   case T_CHAR:
426   case T_SHORT:
427     return new ReplicateSNode(s, vt);
428   case T_INT:
429     return new ReplicateINode(s, vt);
430   case T_LONG:
431     return new ReplicateLNode(s, vt);
432   case T_FLOAT:
433     return new ReplicateFNode(s, vt);
434   case T_DOUBLE:
435     return new ReplicateDNode(s, vt);
436   default:
437     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
438     return NULL;
439   }
440 }
441 
442 VectorNode* VectorNode::shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt) {
<span class="line-modified">443   assert(VectorNode::is_shift(shift) &amp;&amp; !cnt-&gt;is_Con(), &quot;only variable shift count&quot;);</span>
444   // Match shift count type with shift vector type.
445   const TypeVect* vt = TypeVect::make(bt, vlen);
446   switch (shift-&gt;Opcode()) {
447   case Op_LShiftI:
448   case Op_LShiftL:
449     return new LShiftCntVNode(cnt, vt);
450   case Op_RShiftI:
451   case Op_RShiftL:
452   case Op_URShiftI:
453   case Op_URShiftL:
454     return new RShiftCntVNode(cnt, vt);
455   default:
456     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[shift-&gt;Opcode()]);
457     return NULL;
458   }
459 }
460 
































461 // Return initial Pack node. Additional operands added with add_opd() calls.
462 PackNode* PackNode::make(Node* s, uint vlen, BasicType bt) {
463   const TypeVect* vt = TypeVect::make(bt, vlen);
464   switch (bt) {
465   case T_BOOLEAN:
466   case T_BYTE:
467     return new PackBNode(s, vt);
468   case T_CHAR:
469   case T_SHORT:
470     return new PackSNode(s, vt);
471   case T_INT:
472     return new PackINode(s, vt);
473   case T_LONG:
474     return new PackLNode(s, vt);
475   case T_FLOAT:
476     return new PackFNode(s, vt);
477   case T_DOUBLE:
478     return new PackDNode(s, vt);
479   default:
480     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.inline.hpp&quot;
 26 #include &quot;opto/connode.hpp&quot;
 27 #include &quot;opto/vectornode.hpp&quot;
<span class="line-added"> 28 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 29 
 30 //------------------------------VectorNode--------------------------------------
 31 
 32 // Return the vector operator for the specified scalar operation
 33 // and vector length.
 34 int VectorNode::opcode(int sopc, BasicType bt) {
 35   switch (sopc) {
 36   case Op_AddI:
 37     switch (bt) {
 38     case T_BOOLEAN:
 39     case T_BYTE:      return Op_AddVB;
 40     case T_CHAR:
 41     case T_SHORT:     return Op_AddVS;
 42     case T_INT:       return Op_AddVI;
 43     default:          ShouldNotReachHere(); return 0;
 44     }
 45   case Op_AddL:
 46     assert(bt == T_LONG, &quot;must be&quot;);
 47     return Op_AddVL;
 48   case Op_AddF:
</pre>
<hr />
<pre>
 54   case Op_SubI:
 55     switch (bt) {
 56     case T_BOOLEAN:
 57     case T_BYTE:   return Op_SubVB;
 58     case T_CHAR:
 59     case T_SHORT:  return Op_SubVS;
 60     case T_INT:    return Op_SubVI;
 61     default:       ShouldNotReachHere(); return 0;
 62     }
 63   case Op_SubL:
 64     assert(bt == T_LONG, &quot;must be&quot;);
 65     return Op_SubVL;
 66   case Op_SubF:
 67     assert(bt == T_FLOAT, &quot;must be&quot;);
 68     return Op_SubVF;
 69   case Op_SubD:
 70     assert(bt == T_DOUBLE, &quot;must be&quot;);
 71     return Op_SubVD;
 72   case Op_MulI:
 73     switch (bt) {
<span class="line-modified"> 74     case T_BOOLEAN:return 0;</span>
<span class="line-modified"> 75     case T_BYTE:   return Op_MulVB;</span>
 76     case T_CHAR:
 77     case T_SHORT:  return Op_MulVS;
 78     case T_INT:    return Op_MulVI;
 79     default:       ShouldNotReachHere(); return 0;
 80     }
 81   case Op_MulL:
 82     assert(bt == T_LONG, &quot;must be&quot;);
 83     return Op_MulVL;
 84   case Op_MulF:
 85     assert(bt == T_FLOAT, &quot;must be&quot;);
 86     return Op_MulVF;
 87   case Op_MulD:
 88     assert(bt == T_DOUBLE, &quot;must be&quot;);
 89     return Op_MulVD;
 90   case Op_FmaD:
 91     assert(bt == T_DOUBLE, &quot;must be&quot;);
 92     return Op_FmaVD;
 93   case Op_FmaF:
 94     assert(bt == T_FLOAT, &quot;must be&quot;);
 95     return Op_FmaVF;
 96   case Op_CMoveF:
 97     assert(bt == T_FLOAT, &quot;must be&quot;);
 98     return Op_CMoveVF;
 99   case Op_CMoveD:
100     assert(bt == T_DOUBLE, &quot;must be&quot;);
101     return Op_CMoveVD;
102   case Op_DivF:
103     assert(bt == T_FLOAT, &quot;must be&quot;);
104     return Op_DivVF;
105   case Op_DivD:
106     assert(bt == T_DOUBLE, &quot;must be&quot;);
107     return Op_DivVD;
<span class="line-added">108   case Op_AbsI:</span>
<span class="line-added">109     switch (bt) {</span>
<span class="line-added">110     case T_BOOLEAN:</span>
<span class="line-added">111     case T_CHAR:  return 0; // abs does not make sense for unsigned</span>
<span class="line-added">112     case T_BYTE:  return Op_AbsVB;</span>
<span class="line-added">113     case T_SHORT: return Op_AbsVS;</span>
<span class="line-added">114     case T_INT:   return Op_AbsVI;</span>
<span class="line-added">115     default: ShouldNotReachHere(); return 0;</span>
<span class="line-added">116     }</span>
<span class="line-added">117   case Op_AbsL:</span>
<span class="line-added">118     assert(bt == T_LONG, &quot;must be&quot;);</span>
<span class="line-added">119     return Op_AbsVL;</span>
120   case Op_AbsF:
121     assert(bt == T_FLOAT, &quot;must be&quot;);
122     return Op_AbsVF;
123   case Op_AbsD:
124     assert(bt == T_DOUBLE, &quot;must be&quot;);
125     return Op_AbsVD;
126   case Op_NegF:
127     assert(bt == T_FLOAT, &quot;must be&quot;);
128     return Op_NegVF;
129   case Op_NegD:
130     assert(bt == T_DOUBLE, &quot;must be&quot;);
131     return Op_NegVD;
<span class="line-added">132   case Op_RoundDoubleMode:</span>
<span class="line-added">133     assert(bt == T_DOUBLE, &quot;must be&quot;);</span>
<span class="line-added">134     return Op_RoundDoubleModeV;</span>
135   case Op_SqrtF:
136     assert(bt == T_FLOAT, &quot;must be&quot;);
137     return Op_SqrtVF;
138   case Op_SqrtD:
139     assert(bt == T_DOUBLE, &quot;must be&quot;);
140     return Op_SqrtVD;
141   case Op_PopCountI:
142     if (bt == T_INT) {
143       return Op_PopCountVI;
144     }
145     // Unimplemented for subword types since bit count changes
146     // depending on size of lane (and sign bit).
147     return 0;
148   case Op_LShiftI:
149     switch (bt) {
150     case T_BOOLEAN:
151     case T_BYTE:   return Op_LShiftVB;
152     case T_CHAR:
153     case T_SHORT:  return Op_LShiftVS;
154     case T_INT:    return Op_LShiftVI;
</pre>
<hr />
<pre>
222   case Op_StoreI:
223   case Op_StoreL:
224   case Op_StoreF:
225   case Op_StoreD:
226     return Op_StoreVector;
227   case Op_MulAddS2I:
228     return Op_MulAddVS2VI;
229 
230   default:
231     return 0; // Unimplemented
232   }
233 }
234 
235 // Also used to check if the code generator
236 // supports the vector operation.
237 bool VectorNode::implemented(int opc, uint vlen, BasicType bt) {
238   if (is_java_primitive(bt) &amp;&amp;
239       (vlen &gt; 1) &amp;&amp; is_power_of_2(vlen) &amp;&amp;
240       Matcher::vector_size_supported(bt, vlen)) {
241     int vopc = VectorNode::opcode(opc, bt);
<span class="line-modified">242     return vopc &gt; 0 &amp;&amp; Matcher::match_rule_supported_vector(vopc, vlen, bt);</span>
243   }
244   return false;
245 }
246 
247 bool VectorNode::is_type_transition_short_to_int(Node* n) {
248   switch (n-&gt;Opcode()) {
249   case Op_MulAddS2I:
250     return true;
251   }
252   return false;
253 }
254 
255 bool VectorNode::is_type_transition_to_int(Node* n) {
256   return is_type_transition_short_to_int(n);
257 }
258 
259 bool VectorNode::is_muladds2i(Node* n) {
260   if (n-&gt;Opcode() == Op_MulAddS2I) {
261     return true;
262   }
263   return false;
264 }
265 
<span class="line-added">266 bool VectorNode::is_roundopD(Node *n) {</span>
<span class="line-added">267   if (n-&gt;Opcode() == Op_RoundDoubleMode) {</span>
<span class="line-added">268     return true;</span>
<span class="line-added">269   }</span>
<span class="line-added">270   return false;</span>
<span class="line-added">271 }</span>
<span class="line-added">272 </span>
273 bool VectorNode::is_shift(Node* n) {
274   switch (n-&gt;Opcode()) {
275   case Op_LShiftI:
276   case Op_LShiftL:
277   case Op_RShiftI:
278   case Op_RShiftL:
279   case Op_URShiftI:
280   case Op_URShiftL:
281     return true;
282   default:
283     return false;
284   }
285 }
286 
287 // Check if input is loop invariant vector.
288 bool VectorNode::is_invariant_vector(Node* n) {
289   // Only Replicate vector nodes are loop invariant for now.
290   switch (n-&gt;Opcode()) {
291   case Op_ReplicateB:
292   case Op_ReplicateS:
293   case Op_ReplicateI:
294   case Op_ReplicateL:
295   case Op_ReplicateF:
296   case Op_ReplicateD:
297     return true;
298   default:
299     return false;
300   }
301 }
302 
303 // [Start, end) half-open range defining which operands are vectors
304 void VectorNode::vector_operands(Node* n, uint* start, uint* end) {
305   switch (n-&gt;Opcode()) {
306   case Op_LoadB:   case Op_LoadUB:
307   case Op_LoadS:   case Op_LoadUS:
308   case Op_LoadI:   case Op_LoadL:
309   case Op_LoadF:   case Op_LoadD:
310   case Op_LoadP:   case Op_LoadN:


311     *start = 0;
312     *end   = 0; // no vector operands
313     break;
314   case Op_StoreB:  case Op_StoreC:
315   case Op_StoreI:  case Op_StoreL:
316   case Op_StoreF:  case Op_StoreD:
317   case Op_StoreP:  case Op_StoreN:
318     *start = MemNode::ValueIn;
319     *end   = MemNode::ValueIn + 1; // 1 vector operand
320     break;
321   case Op_LShiftI:  case Op_LShiftL:
322   case Op_RShiftI:  case Op_RShiftL:
323   case Op_URShiftI: case Op_URShiftL:
324     *start = 1;
325     *end   = 2; // 1 vector operand
326     break;
327   case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:
328   case Op_SubI: case Op_SubL: case Op_SubF: case Op_SubD:
329   case Op_MulI: case Op_MulL: case Op_MulF: case Op_MulD:
330   case Op_DivF: case Op_DivD:
</pre>
<hr />
<pre>
354 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {
355   const TypeVect* vt = TypeVect::make(bt, vlen);
356   int vopc = VectorNode::opcode(opc, bt);
357   // This method should not be called for unimplemented vectors.
358   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
359   switch (vopc) {
360   case Op_AddVB: return new AddVBNode(n1, n2, vt);
361   case Op_AddVS: return new AddVSNode(n1, n2, vt);
362   case Op_AddVI: return new AddVINode(n1, n2, vt);
363   case Op_AddVL: return new AddVLNode(n1, n2, vt);
364   case Op_AddVF: return new AddVFNode(n1, n2, vt);
365   case Op_AddVD: return new AddVDNode(n1, n2, vt);
366 
367   case Op_SubVB: return new SubVBNode(n1, n2, vt);
368   case Op_SubVS: return new SubVSNode(n1, n2, vt);
369   case Op_SubVI: return new SubVINode(n1, n2, vt);
370   case Op_SubVL: return new SubVLNode(n1, n2, vt);
371   case Op_SubVF: return new SubVFNode(n1, n2, vt);
372   case Op_SubVD: return new SubVDNode(n1, n2, vt);
373 
<span class="line-added">374   case Op_MulVB: return new MulVBNode(n1, n2, vt);</span>
375   case Op_MulVS: return new MulVSNode(n1, n2, vt);
376   case Op_MulVI: return new MulVINode(n1, n2, vt);
377   case Op_MulVL: return new MulVLNode(n1, n2, vt);
378   case Op_MulVF: return new MulVFNode(n1, n2, vt);
379   case Op_MulVD: return new MulVDNode(n1, n2, vt);
380 
381   case Op_DivVF: return new DivVFNode(n1, n2, vt);
382   case Op_DivVD: return new DivVDNode(n1, n2, vt);
383 
<span class="line-added">384   case Op_AbsVB: return new AbsVBNode(n1, vt);</span>
<span class="line-added">385   case Op_AbsVS: return new AbsVSNode(n1, vt);</span>
<span class="line-added">386   case Op_AbsVI: return new AbsVINode(n1, vt);</span>
<span class="line-added">387   case Op_AbsVL: return new AbsVLNode(n1, vt);</span>
388   case Op_AbsVF: return new AbsVFNode(n1, vt);
389   case Op_AbsVD: return new AbsVDNode(n1, vt);
390 
391   case Op_NegVF: return new NegVFNode(n1, vt);
392   case Op_NegVD: return new NegVDNode(n1, vt);
393 
394   case Op_SqrtVF: return new SqrtVFNode(n1, vt);
395   case Op_SqrtVD: return new SqrtVDNode(n1, vt);
396 
397   case Op_PopCountVI: return new PopCountVINode(n1, vt);
398 
399   case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);
400   case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);
401   case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);
402   case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);
403 
404   case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);
405   case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);
406   case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);
407   case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);
408 
409   case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);
410   case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);
411   case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);
412   case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);
413 
414   case Op_AndV: return new AndVNode(n1, n2, vt);
415   case Op_OrV:  return new OrVNode (n1, n2, vt);
416   case Op_XorV: return new XorVNode(n1, n2, vt);
417 
418   case Op_MinV: return new MinVNode(n1, n2, vt);
419   case Op_MaxV: return new MaxVNode(n1, n2, vt);
420 
<span class="line-added">421   case Op_RoundDoubleModeV: return new RoundDoubleModeVNode(n1, n2, vt);</span>
<span class="line-added">422 </span>
423   case Op_MulAddVS2VI: return new MulAddVS2VINode(n1, n2, vt);
424   default:
425     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
426     return NULL;
427   }
428 }
429 
430 VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt) {
431   const TypeVect* vt = TypeVect::make(bt, vlen);
432   int vopc = VectorNode::opcode(opc, bt);
433   // This method should not be called for unimplemented vectors.
434   guarantee(vopc &gt; 0, &quot;Vector for &#39;%s&#39; is not implemented&quot;, NodeClassNames[opc]);
435   switch (vopc) {
436   case Op_FmaVD: return new FmaVDNode(n1, n2, n3, vt);
437   case Op_FmaVF: return new FmaVFNode(n1, n2, n3, vt);
438   default:
439     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[vopc]);
440     return NULL;
441   }
442 }
</pre>
<hr />
<pre>
451   case T_BYTE:
452     return new ReplicateBNode(s, vt);
453   case T_CHAR:
454   case T_SHORT:
455     return new ReplicateSNode(s, vt);
456   case T_INT:
457     return new ReplicateINode(s, vt);
458   case T_LONG:
459     return new ReplicateLNode(s, vt);
460   case T_FLOAT:
461     return new ReplicateFNode(s, vt);
462   case T_DOUBLE:
463     return new ReplicateDNode(s, vt);
464   default:
465     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
466     return NULL;
467   }
468 }
469 
470 VectorNode* VectorNode::shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt) {
<span class="line-modified">471   assert(VectorNode::is_shift(shift), &quot;sanity&quot;);</span>
472   // Match shift count type with shift vector type.
473   const TypeVect* vt = TypeVect::make(bt, vlen);
474   switch (shift-&gt;Opcode()) {
475   case Op_LShiftI:
476   case Op_LShiftL:
477     return new LShiftCntVNode(cnt, vt);
478   case Op_RShiftI:
479   case Op_RShiftL:
480   case Op_URShiftI:
481   case Op_URShiftL:
482     return new RShiftCntVNode(cnt, vt);
483   default:
484     fatal(&quot;Missed vector creation for &#39;%s&#39;&quot;, NodeClassNames[shift-&gt;Opcode()]);
485     return NULL;
486   }
487 }
488 
<span class="line-added">489 bool VectorNode::is_vector_shift(int opc) {</span>
<span class="line-added">490   assert(opc &gt; _last_machine_leaf &amp;&amp; opc &lt; _last_opcode, &quot;invalid opcode&quot;);</span>
<span class="line-added">491   switch (opc) {</span>
<span class="line-added">492   case Op_LShiftVB:</span>
<span class="line-added">493   case Op_LShiftVS:</span>
<span class="line-added">494   case Op_LShiftVI:</span>
<span class="line-added">495   case Op_LShiftVL:</span>
<span class="line-added">496   case Op_RShiftVB:</span>
<span class="line-added">497   case Op_RShiftVS:</span>
<span class="line-added">498   case Op_RShiftVI:</span>
<span class="line-added">499   case Op_RShiftVL:</span>
<span class="line-added">500   case Op_URShiftVB:</span>
<span class="line-added">501   case Op_URShiftVS:</span>
<span class="line-added">502   case Op_URShiftVI:</span>
<span class="line-added">503   case Op_URShiftVL:</span>
<span class="line-added">504     return true;</span>
<span class="line-added">505   default:</span>
<span class="line-added">506     return false;</span>
<span class="line-added">507   }</span>
<span class="line-added">508 }</span>
<span class="line-added">509 </span>
<span class="line-added">510 bool VectorNode::is_vector_shift_count(int opc) {</span>
<span class="line-added">511   assert(opc &gt; _last_machine_leaf &amp;&amp; opc &lt; _last_opcode, &quot;invalid opcode&quot;);</span>
<span class="line-added">512   switch (opc) {</span>
<span class="line-added">513   case Op_RShiftCntV:</span>
<span class="line-added">514   case Op_LShiftCntV:</span>
<span class="line-added">515     return true;</span>
<span class="line-added">516   default:</span>
<span class="line-added">517     return false;</span>
<span class="line-added">518   }</span>
<span class="line-added">519 }</span>
<span class="line-added">520 </span>
521 // Return initial Pack node. Additional operands added with add_opd() calls.
522 PackNode* PackNode::make(Node* s, uint vlen, BasicType bt) {
523   const TypeVect* vt = TypeVect::make(bt, vlen);
524   switch (bt) {
525   case T_BOOLEAN:
526   case T_BYTE:
527     return new PackBNode(s, vt);
528   case T_CHAR:
529   case T_SHORT:
530     return new PackSNode(s, vt);
531   case T_INT:
532     return new PackINode(s, vt);
533   case T_LONG:
534     return new PackLNode(s, vt);
535   case T_FLOAT:
536     return new PackFNode(s, vt);
537   case T_DOUBLE:
538     return new PackDNode(s, vt);
539   default:
540     fatal(&quot;Type &#39;%s&#39; is not supported for vectors&quot;, type2name(bt));
</pre>
</td>
</tr>
</table>
<center><a href="type.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
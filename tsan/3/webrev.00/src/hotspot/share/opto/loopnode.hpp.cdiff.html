<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,12 ***</span>
  class CountedLoopNode;
  class IdealLoopTree;
  class LoopNode;
  class Node;
  class OuterStripMinedLoopEndNode;
<span class="line-removed">- class ShenandoahBarrierNode;</span>
<span class="line-removed">- class ShenandoahWriteBarrierNode;</span>
  class PathFrequency;
  class PhaseIdealLoop;
  class CountedLoopReserveKit;
  class VectorSet;
  class Invariance;
<span class="line-new-header">--- 36,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,11 ***</span>
    bool is_valid_counted_loop() const;
  #ifndef PRODUCT
    virtual void dump_spec(outputStream *st) const;
  #endif
  
<span class="line-modified">!   void verify_strip_mined(int expect_skeleton) const;</span>
    virtual LoopNode* skip_strip_mined(int expect_skeleton = 1) { return this; }
    virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }
    virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }
    virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }
    virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }
<span class="line-new-header">--- 150,11 ---</span>
    bool is_valid_counted_loop() const;
  #ifndef PRODUCT
    virtual void dump_spec(outputStream *st) const;
  #endif
  
<span class="line-modified">!   void verify_strip_mined(int expect_skeleton) const NOT_DEBUG_RETURN;</span>
    virtual LoopNode* skip_strip_mined(int expect_skeleton = 1) { return this; }
    virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }
    virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }
    virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }
    virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,11 ***</span>
    bool is_main_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Main;   }
    bool is_post_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Post;   }
    bool is_reduction_loop() const { return (_loop_flags&amp;HasReductions) == HasReductions; }
    bool was_slp_analyzed () const { return (_loop_flags&amp;WasSlpAnalyzed) == WasSlpAnalyzed; }
    bool has_passed_slp   () const { return (_loop_flags&amp;PassedSlpAnalysis) == PassedSlpAnalysis; }
<span class="line-modified">!   bool do_unroll_only      () const { return (_loop_flags&amp;DoUnrollOnly) == DoUnrollOnly; }</span>
    bool is_main_no_pre_loop() const { return _loop_flags &amp; MainHasNoPreLoop; }
    bool has_atomic_post_loop  () const { return (_loop_flags &amp; HasAtomicPostLoop) == HasAtomicPostLoop; }
    void set_main_no_pre_loop() { _loop_flags |= MainHasNoPreLoop; }
  
    int main_idx() const { return _main_idx; }
<span class="line-new-header">--- 262,11 ---</span>
    bool is_main_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Main;   }
    bool is_post_loop     () const { return (_loop_flags&amp;PreMainPostFlagsMask) == Post;   }
    bool is_reduction_loop() const { return (_loop_flags&amp;HasReductions) == HasReductions; }
    bool was_slp_analyzed () const { return (_loop_flags&amp;WasSlpAnalyzed) == WasSlpAnalyzed; }
    bool has_passed_slp   () const { return (_loop_flags&amp;PassedSlpAnalysis) == PassedSlpAnalysis; }
<span class="line-modified">!   bool is_unroll_only   () const { return (_loop_flags&amp;DoUnrollOnly) == DoUnrollOnly; }</span>
    bool is_main_no_pre_loop() const { return _loop_flags &amp; MainHasNoPreLoop; }
    bool has_atomic_post_loop  () const { return (_loop_flags &amp; HasAtomicPostLoop) == HasAtomicPostLoop; }
    void set_main_no_pre_loop() { _loop_flags |= MainHasNoPreLoop; }
  
    int main_idx() const { return _main_idx; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,30 ***</span>
    virtual void dump_spec(outputStream *st) const;
  #endif
  };
  
  
<span class="line-modified">! inline CountedLoopEndNode *CountedLoopNode::loopexit_or_null() const {</span>
<span class="line-modified">!   Node *bc = back_control();</span>
<span class="line-modified">!   if( bc == NULL ) return NULL;</span>
<span class="line-modified">!   Node *le = bc-&gt;in(0);</span>
<span class="line-modified">!   if( le-&gt;Opcode() != Op_CountedLoopEnd )</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   return (CountedLoopEndNode*)le;</span>
  }
<span class="line-modified">! inline CountedLoopEndNode *CountedLoopNode::loopexit() const {</span>
    CountedLoopEndNode* cle = loopexit_or_null();
    assert(cle != NULL, &quot;loopexit is NULL&quot;);
    return cle;
  }
<span class="line-modified">! inline Node *CountedLoopNode::init_trip() const { return loopexit_or_null() ? loopexit()-&gt;init_trip() : NULL; }</span>
<span class="line-modified">! inline Node *CountedLoopNode::stride() const { return loopexit_or_null() ? loopexit()-&gt;stride() : NULL; }</span>
<span class="line-modified">! inline int CountedLoopNode::stride_con() const { return loopexit_or_null() ? loopexit()-&gt;stride_con() : 0; }</span>
<span class="line-modified">! inline bool CountedLoopNode::stride_is_con() const { return loopexit_or_null() &amp;&amp; loopexit()-&gt;stride_is_con(); }</span>
<span class="line-modified">! inline Node *CountedLoopNode::limit() const { return loopexit_or_null() ? loopexit()-&gt;limit() : NULL; }</span>
<span class="line-modified">! inline Node *CountedLoopNode::incr() const { return loopexit_or_null() ? loopexit()-&gt;incr() : NULL; }</span>
<span class="line-modified">! inline Node *CountedLoopNode::phi() const { return loopexit_or_null() ? loopexit()-&gt;phi() : NULL; }</span>
  
  //------------------------------LoopLimitNode-----------------------------
  // Counted Loop limit node which represents exact final iterator value:
  // trip_count = (limit - init_trip + stride - 1)/stride
  // final_value= trip_count * stride + init_trip.
<span class="line-new-header">--- 368,53 ---</span>
    virtual void dump_spec(outputStream *st) const;
  #endif
  };
  
  
<span class="line-modified">! inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {</span>
<span class="line-modified">!   Node* bctrl = back_control();</span>
<span class="line-modified">!   if (bctrl == NULL) return NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* lexit = bctrl-&gt;in(0);</span>
<span class="line-modified">!   return (CountedLoopEndNode*)</span>
<span class="line-modified">!       (lexit-&gt;Opcode() == Op_CountedLoopEnd ? lexit : NULL);</span>
  }
<span class="line-modified">! </span>
<span class="line-added">+ inline CountedLoopEndNode* CountedLoopNode::loopexit() const {</span>
    CountedLoopEndNode* cle = loopexit_or_null();
    assert(cle != NULL, &quot;loopexit is NULL&quot;);
    return cle;
  }
<span class="line-modified">! </span>
<span class="line-modified">! inline Node* CountedLoopNode::init_trip() const {</span>
<span class="line-modified">!   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-modified">!   return cle != NULL ? cle-&gt;init_trip() : NULL;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! inline Node* CountedLoopNode::stride() const {</span>
<span class="line-modified">!   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL ? cle-&gt;stride() : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ inline int CountedLoopNode::stride_con() const {</span>
<span class="line-added">+   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL ? cle-&gt;stride_con() : 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ inline bool CountedLoopNode::stride_is_con() const {</span>
<span class="line-added">+   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL &amp;&amp; cle-&gt;stride_is_con();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ inline Node* CountedLoopNode::limit() const {</span>
<span class="line-added">+   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL ? cle-&gt;limit() : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ inline Node* CountedLoopNode::incr() const {</span>
<span class="line-added">+   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL ? cle-&gt;incr() : NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ inline Node* CountedLoopNode::phi() const {</span>
<span class="line-added">+   CountedLoopEndNode* cle = loopexit_or_null();</span>
<span class="line-added">+   return cle != NULL ? cle-&gt;phi() : NULL;</span>
<span class="line-added">+ }</span>
  
  //------------------------------LoopLimitNode-----------------------------
  // Counted Loop limit node which represents exact final iterator value:
  // trip_count = (limit - init_trip + stride - 1)/stride
  // final_value= trip_count * stride + init_trip.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,13 ***</span>
    IdealLoopTree *_parent;       // Parent in loop tree
    IdealLoopTree *_next;         // Next sibling in loop tree
    IdealLoopTree *_child;        // First child in loop tree
  
    // The head-tail backedge defines the loop.
<span class="line-modified">!   // If tail is NULL then this loop has multiple backedges as part of the</span>
<span class="line-modified">!   // same loop.  During cleanup I&#39;ll peel off the multiple backedges; merge</span>
<span class="line-modified">!   // them at the loop bottom and flow 1 real backedge into the loop.</span>
    Node *_head;                  // Head of loop
    Node *_tail;                  // Tail of loop
    inline Node *tail();          // Handle lazy update of _tail field
    PhaseIdealLoop* _phase;
    int _local_loop_unroll_limit;
<span class="line-new-header">--- 477,13 ---</span>
    IdealLoopTree *_parent;       // Parent in loop tree
    IdealLoopTree *_next;         // Next sibling in loop tree
    IdealLoopTree *_child;        // First child in loop tree
  
    // The head-tail backedge defines the loop.
<span class="line-modified">!   // If a loop has multiple backedges, this is addressed during cleanup where</span>
<span class="line-modified">!   // we peel off the multiple backedges,  merging all edges at the bottom and</span>
<span class="line-modified">!   // ensuring that one proper backedge flow into the loop.</span>
    Node *_head;                  // Head of loop
    Node *_tail;                  // Tail of loop
    inline Node *tail();          // Handle lazy update of _tail field
    PhaseIdealLoop* _phase;
    int _local_loop_unroll_limit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,11 ***</span>
        _local_loop_unroll_limit(0), _local_loop_unroll_factor(0),
        _nest(0), _irreducible(0), _has_call(0), _has_sfpt(0), _rce_candidate(0),
        _safepts(NULL),
        _required_safept(NULL),
        _allow_optimizations(true)
<span class="line-modified">!   { }</span>
  
    // Is &#39;l&#39; a member of &#39;this&#39;?
    bool is_member(const IdealLoopTree *l) const; // Test for nested membership
  
    // Set loop nesting depth.  Accumulate has_call bits.
<span class="line-new-header">--- 508,14 ---</span>
        _local_loop_unroll_limit(0), _local_loop_unroll_factor(0),
        _nest(0), _irreducible(0), _has_call(0), _has_sfpt(0), _rce_candidate(0),
        _safepts(NULL),
        _required_safept(NULL),
        _allow_optimizations(true)
<span class="line-modified">!   {</span>
<span class="line-added">+     precond(_head != NULL);</span>
<span class="line-added">+     precond(_tail != NULL);</span>
<span class="line-added">+   }</span>
  
    // Is &#39;l&#39; a member of &#39;this&#39;?
    bool is_member(const IdealLoopTree *l) const; // Test for nested membership
  
    // Set loop nesting depth.  Accumulate has_call bits.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,26 ***</span>
    // Return TRUE or FALSE if the loop should be unswitched -- clone
    // loop with an invariant test
    bool policy_unswitching( PhaseIdealLoop *phase ) const;
  
    // Micro-benchmark spamming.  Remove empty loops.
<span class="line-modified">!   bool policy_do_remove_empty_loop( PhaseIdealLoop *phase );</span>
  
    // Convert one iteration loop into normal code.
<span class="line-modified">!   bool policy_do_one_iteration_loop( PhaseIdealLoop *phase );</span>
  
<span class="line-modified">!   // Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can</span>
<span class="line-removed">-   // make some loop-invariant test (usually a null-check) happen before the</span>
<span class="line-removed">-   // loop.</span>
<span class="line-removed">-   bool policy_peeling( PhaseIdealLoop *phase ) const;</span>
  
    // Return TRUE or FALSE if the loop should be maximally unrolled. Stash any
    // known trip count in the counted loop node.
<span class="line-modified">!   bool policy_maximally_unroll( PhaseIdealLoop *phase ) const;</span>
  
<span class="line-modified">!   // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if</span>
<span class="line-modified">!   // the loop is a CountedLoop and the body is small enough.</span>
    bool policy_unroll(PhaseIdealLoop *phase);
  
    // Loop analyses to map to a maximal superword unrolling for vectorization.
    void policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct);
  
<span class="line-new-header">--- 582,27 ---</span>
    // Return TRUE or FALSE if the loop should be unswitched -- clone
    // loop with an invariant test
    bool policy_unswitching( PhaseIdealLoop *phase ) const;
  
    // Micro-benchmark spamming.  Remove empty loops.
<span class="line-modified">!   bool do_remove_empty_loop( PhaseIdealLoop *phase );</span>
  
    // Convert one iteration loop into normal code.
<span class="line-modified">!   bool do_one_iteration_loop( PhaseIdealLoop *phase );</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Return TRUE or FALSE if the loop should be peeled or not. Peel if we can</span>
<span class="line-added">+   // move some loop-invariant test (usually a null-check) before the loop.</span>
<span class="line-added">+   bool policy_peeling(PhaseIdealLoop *phase);</span>
  
<span class="line-modified">!   uint estimate_peeling(PhaseIdealLoop *phase);</span>
  
    // Return TRUE or FALSE if the loop should be maximally unrolled. Stash any
    // known trip count in the counted loop node.
<span class="line-modified">!   bool policy_maximally_unroll(PhaseIdealLoop *phase) const;</span>
  
<span class="line-modified">!   // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll</span>
<span class="line-modified">!   // if the loop is a counted loop and the loop body is small enough.</span>
    bool policy_unroll(PhaseIdealLoop *phase);
  
    // Loop analyses to map to a maximal superword unrolling for vectorization.
    void policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,10 ***</span>
<span class="line-new-header">--- 619,15 ---</span>
    bool policy_align( PhaseIdealLoop *phase ) const;
  
    // Return TRUE if &quot;iff&quot; is a range check.
    bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const;
  
<span class="line-added">+   // Estimate the number of nodes required when cloning a loop (body).</span>
<span class="line-added">+   uint est_loop_clone_sz(uint factor) const;</span>
<span class="line-added">+   // Estimate the number of nodes required when unrolling a loop (body).</span>
<span class="line-added">+   uint est_loop_unroll_sz(uint factor) const;</span>
<span class="line-added">+ </span>
    // Compute loop trip count if possible
    void compute_trip_count(PhaseIdealLoop* phase);
  
    // Compute loop trip count from profile data
    float compute_profile_trip_cnt_helper(Node* n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 615,39 ***</span>
    bool is_invariant(Node* n) const;
  
    // Put loop body on igvn work list
    void record_for_igvn();
  
<span class="line-modified">!   bool is_loop()    { return !_irreducible &amp;&amp; _tail &amp;&amp; !_tail-&gt;is_top(); }</span>
<span class="line-modified">!   bool is_inner()   { return is_loop() &amp;&amp; _child == NULL; }</span>
<span class="line-modified">!   bool is_counted() { return is_loop() &amp;&amp; _head != NULL &amp;&amp; _head-&gt;is_CountedLoop(); }</span>
  
    void remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase);
  
  #ifndef PRODUCT
<span class="line-modified">!   void dump_head( ) const;      // Dump loop head only</span>
    void dump() const;            // Dump this loop recursively
    void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;
  #endif
  
  };
  
  // -----------------------------PhaseIdealLoop---------------------------------
<span class="line-modified">! // Computes the mapping from Nodes to IdealLoopTrees.  Organizes IdealLoopTrees into a</span>
<span class="line-modified">! // loop tree.  Drives the loop-based transformations on the ideal graph.</span>
  class PhaseIdealLoop : public PhaseTransform {
    friend class IdealLoopTree;
    friend class SuperWord;
    friend class CountedLoopReserveKit;
<span class="line-modified">!   friend class ShenandoahBarrierNode;</span>
<span class="line-modified">!   friend class ShenandoahWriteBarrierNode;</span>
  
    // Pre-computed def-use info
    PhaseIterGVN &amp;_igvn;
  
    // Head of loop tree
<span class="line-modified">!   IdealLoopTree *_ltree_root;</span>
  
    // Array of pre-order numbers, plus post-visited bit.
    // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
    // ODD for post-visited.  Other bits are the pre-order number.
    uint *_preorders;
<span class="line-new-header">--- 645,46 ---</span>
    bool is_invariant(Node* n) const;
  
    // Put loop body on igvn work list
    void record_for_igvn();
  
<span class="line-modified">!   bool is_root() { return _parent == NULL; }</span>
<span class="line-modified">!   // A proper/reducible loop w/o any (occasional) dead back-edge.</span>
<span class="line-modified">!   bool is_loop() { return !_irreducible &amp;&amp; !tail()-&gt;is_top(); }</span>
<span class="line-added">+   bool is_counted()   { return is_loop() &amp;&amp; _head-&gt;is_CountedLoop(); }</span>
<span class="line-added">+   bool is_innermost() { return is_loop() &amp;&amp; _child == NULL; }</span>
  
    void remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase);
  
  #ifndef PRODUCT
<span class="line-modified">!   void dump_head() const;       // Dump loop head only</span>
    void dump() const;            // Dump this loop recursively
    void verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const;
  #endif
  
<span class="line-added">+  private:</span>
<span class="line-added">+   enum { EMPTY_LOOP_SIZE = 7 }; // Number of nodes in an empty loop.</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Estimate the number of nodes resulting from control and data flow merge.</span>
<span class="line-added">+   uint est_loop_flow_merge_sz() const;</span>
  };
  
  // -----------------------------PhaseIdealLoop---------------------------------
<span class="line-modified">! // Computes the mapping from Nodes to IdealLoopTrees. Organizes IdealLoopTrees</span>
<span class="line-modified">! // into a loop tree. Drives the loop-based transformations on the ideal graph.</span>
  class PhaseIdealLoop : public PhaseTransform {
    friend class IdealLoopTree;
    friend class SuperWord;
    friend class CountedLoopReserveKit;
<span class="line-modified">!   friend class ShenandoahBarrierC2Support;</span>
<span class="line-modified">!   friend class AutoNodeBudget;</span>
  
    // Pre-computed def-use info
    PhaseIterGVN &amp;_igvn;
  
    // Head of loop tree
<span class="line-modified">!   IdealLoopTree* _ltree_root;</span>
  
    // Array of pre-order numbers, plus post-visited bit.
    // ZERO for not pre-visited.  EVEN for pre-visited but not post-visited.
    // ODD for post-visited.  Other bits are the pre-order number.
    uint *_preorders;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 732,12 ***</span>
      }
      return find_non_split_ctrl(n);
    }
    Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
  
<span class="line-modified">!   // Helper function for directing control inputs away from CFG split</span>
<span class="line-removed">-   // points.</span>
    Node *find_non_split_ctrl( Node *ctrl ) const {
      if (ctrl != NULL) {
        if (ctrl-&gt;is_MultiBranch()) {
          ctrl = ctrl-&gt;in(0);
        }
<span class="line-new-header">--- 769,11 ---</span>
      }
      return find_non_split_ctrl(n);
    }
    Node *dom_lca_for_get_late_ctrl_internal( Node *lca, Node *n, Node *tag );
  
<span class="line-modified">!   // Helper function for directing control inputs away from CFG split points.</span>
    Node *find_non_split_ctrl( Node *ctrl ) const {
      if (ctrl != NULL) {
        if (ctrl-&gt;is_MultiBranch()) {
          ctrl = ctrl-&gt;in(0);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 793,10 ***</span>
<span class="line-new-header">--- 829,11 ---</span>
    // get their replacement Node in slot 1.  Instead of updating the block
    // location of all Nodes in the subsumed block, we lazily do it.  As we
    // pull such a subsumed block out of the array, we write back the final
    // correct block.
    Node *get_ctrl( Node *i ) {
<span class="line-added">+ </span>
      assert(has_node(i), &quot;&quot;);
      Node *n = get_ctrl_no_update(i);
      _nodes.map( i-&gt;_idx, (Node*)((intptr_t)n + 1) );
      assert(has_node(i) &amp;&amp; has_ctrl(i), &quot;&quot;);
      assert(n == find_non_split_ctrl(n), &quot;must return legal ctrl&quot; );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,11 ***</span>
    PhaseIdealLoop( PhaseIterGVN &amp;igvn) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(NULL),
      _verify_only(true),
<span class="line-modified">!     _dom_lca_tags(arena()) { // Thread::resource_area</span>
      build_and_optimize(LoopOptsVerify);
    }
  
    // build the loop tree and perform any requested optimizations
    void build_and_optimize(LoopOptsMode mode);
<span class="line-new-header">--- 921,12 ---</span>
    PhaseIdealLoop( PhaseIterGVN &amp;igvn) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(NULL),
      _verify_only(true),
<span class="line-modified">!     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added">+     _nodes_required(UINT_MAX) {</span>
      build_and_optimize(LoopOptsVerify);
    }
  
    // build the loop tree and perform any requested optimizations
    void build_and_optimize(LoopOptsMode mode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 900,21 ***</span>
    PhaseIdealLoop(PhaseIterGVN &amp;igvn, LoopOptsMode mode) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(NULL),
      _verify_only(false),
<span class="line-modified">!     _dom_lca_tags(arena()) { // Thread::resource_area</span>
      build_and_optimize(mode);
    }
  
    // Verify that verify_me made the same decisions as a fresh run.
    PhaseIdealLoop(PhaseIterGVN &amp;igvn, const PhaseIdealLoop *verify_me) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(verify_me),
      _verify_only(false),
<span class="line-modified">!     _dom_lca_tags(arena()) { // Thread::resource_area</span>
      build_and_optimize(LoopOptsVerify);
    }
  
  public:
    Node* idom_no_update(Node* d) const {
<span class="line-new-header">--- 938,23 ---</span>
    PhaseIdealLoop(PhaseIterGVN &amp;igvn, LoopOptsMode mode) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(NULL),
      _verify_only(false),
<span class="line-modified">!     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added">+     _nodes_required(UINT_MAX) {</span>
      build_and_optimize(mode);
    }
  
    // Verify that verify_me made the same decisions as a fresh run.
    PhaseIdealLoop(PhaseIterGVN &amp;igvn, const PhaseIdealLoop *verify_me) :
      PhaseTransform(Ideal_Loop),
      _igvn(igvn),
      _verify_me(verify_me),
      _verify_only(false),
<span class="line-modified">!     _dom_lca_tags(arena()),  // Thread::resource_area</span>
<span class="line-added">+     _nodes_required(UINT_MAX) {</span>
      build_and_optimize(LoopOptsVerify);
    }
  
  public:
    Node* idom_no_update(Node* d) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,13 ***</span>
  
    // True if the method has at least 1 irreducible loop
    bool _has_irreducible_loops;
  
    // Per-Node transform
<span class="line-modified">!   virtual Node *transform( Node *a_node ) { return 0; }</span>
  
<span class="line-modified">!   bool is_counted_loop(Node* x, IdealLoopTree*&amp; loop);</span>
    IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
                                                 IdealLoopTree* loop, float cl_prob, float le_fcnt,
                                                 Node*&amp; entry_control, Node*&amp; iffalse);
  
    Node* exact_limit( IdealLoopTree *loop );
<span class="line-new-header">--- 1022,13 ---</span>
  
    // True if the method has at least 1 irreducible loop
    bool _has_irreducible_loops;
  
    // Per-Node transform
<span class="line-modified">!   virtual Node* transform(Node* n) { return 0; }</span>
  
<span class="line-modified">!   bool is_counted_loop(Node* n, IdealLoopTree* &amp;loop);</span>
    IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
                                                 IdealLoopTree* loop, float cl_prob, float le_fcnt,
                                                 Node*&amp; entry_control, Node*&amp; iffalse);
  
    Node* exact_limit( IdealLoopTree *loop );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 999,11 ***</span>
      if (!has_node(n))  return _ltree_root;
      assert(!has_ctrl(n), &quot;&quot;);
      return (IdealLoopTree*)_nodes[n-&gt;_idx];
    }
  
<span class="line-modified">!   IdealLoopTree *ltree_root() const { return _ltree_root; }</span>
  
    // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
    int is_member( const IdealLoopTree *loop, Node *n ) const {
      return loop-&gt;is_member(get_loop(n)); }
  
<span class="line-new-header">--- 1039,11 ---</span>
      if (!has_node(n))  return _ltree_root;
      assert(!has_ctrl(n), &quot;&quot;);
      return (IdealLoopTree*)_nodes[n-&gt;_idx];
    }
  
<span class="line-modified">!   IdealLoopTree* ltree_root() const { return _ltree_root; }</span>
  
    // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
    int is_member( const IdealLoopTree *loop, Node *n ) const {
      return loop-&gt;is_member(get_loop(n)); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,14 ***</span>
    static ProjNode* clone_predicate(ProjNode* predicate_proj, Node* new_entry,
                                     Deoptimization::DeoptReason reason,
                                     PhaseIdealLoop* loop_phase,
                                     PhaseIterGVN* igvn);
  
<span class="line-removed">-   static void clone_loop_predicates_fix_mem(ProjNode* dom_proj , ProjNode* proj,</span>
<span class="line-removed">-                                             PhaseIdealLoop* loop_phase,</span>
<span class="line-removed">-                                             PhaseIterGVN* igvn);</span>
<span class="line-removed">- </span>
    static Node* clone_loop_predicates(Node* old_entry, Node* new_entry,
                                           bool clone_limit_check,
                                           PhaseIdealLoop* loop_phase,
                                           PhaseIterGVN* igvn);
    Node* clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check);
<span class="line-new-header">--- 1136,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1272,13 ***</span>
    // forcing an extra register move)
    void reorg_offsets( IdealLoopTree *loop );
  
    // Check for aggressive application of &#39;split-if&#39; optimization,
    // using basic block level info.
<span class="line-modified">!   void  split_if_with_blocks     ( VectorSet &amp;visited, Node_Stack &amp;nstack, bool last_round );</span>
    Node *split_if_with_blocks_pre ( Node *n );
<span class="line-modified">!   void  split_if_with_blocks_post( Node *n, bool last_round );</span>
    Node *has_local_phi_input( Node *n );
    // Mark an IfNode as being dominated by a prior test,
    // without actually altering the CFG (and hence IDOM info).
    void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );
  
<span class="line-new-header">--- 1308,13 ---</span>
    // forcing an extra register move)
    void reorg_offsets( IdealLoopTree *loop );
  
    // Check for aggressive application of &#39;split-if&#39; optimization,
    // using basic block level info.
<span class="line-modified">!   void  split_if_with_blocks     ( VectorSet &amp;visited, Node_Stack &amp;nstack);</span>
    Node *split_if_with_blocks_pre ( Node *n );
<span class="line-modified">!   void  split_if_with_blocks_post( Node *n );</span>
    Node *has_local_phi_input( Node *n );
    // Mark an IfNode as being dominated by a prior test,
    // without actually altering the CFG (and hence IDOM info).
    void dominated_by( Node *prevdom, Node *iff, bool flip = false, bool exclude_loop_predicate = false );
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1288,11 ***</span>
    Node *split_thru_phi( Node *n, Node *region, int policy );
    // Found an If getting its condition-code input from a Phi in the
    // same block.  Split thru the Region.
    void do_split_if( Node *iff );
  
<span class="line-modified">!   // Conversion of fill/copy patterns into intrisic versions</span>
    bool do_intrinsify_fill();
    bool intrinsify_fill(IdealLoopTree* lpt);
    bool match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
                         Node*&amp; shift, Node*&amp; offset);
  
<span class="line-new-header">--- 1324,11 ---</span>
    Node *split_thru_phi( Node *n, Node *region, int policy );
    // Found an If getting its condition-code input from a Phi in the
    // same block.  Split thru the Region.
    void do_split_if( Node *iff );
  
<span class="line-modified">!   // Conversion of fill/copy patterns into intrinsic versions</span>
    bool do_intrinsify_fill();
    bool intrinsify_fill(IdealLoopTree* lpt);
    bool match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
                         Node*&amp; shift, Node*&amp; offset);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1321,37 ***</span>
    bool must_throttle_split_if() {
      uint threshold = C-&gt;max_node_limit() * 2 / 5;
      return C-&gt;live_nodes() &gt; threshold;
    }
  
    bool _created_loop_node;
  public:
    void set_created_loop_node() { _created_loop_node = true; }
    bool created_loop_node()     { return _created_loop_node; }
<span class="line-modified">!   void register_new_node( Node *n, Node *blk );</span>
  
  #ifdef ASSERT
    void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
  #endif
  
  #ifndef PRODUCT
<span class="line-modified">!   void dump( ) const;</span>
<span class="line-modified">!   void dump( IdealLoopTree *loop, uint rpo_idx, Node_List &amp;rpo_list ) const;</span>
    void verify() const;          // Major slow  :-)
<span class="line-modified">!   void verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const;</span>
<span class="line-modified">!   IdealLoopTree *get_loop_idx(Node* n) const {</span>
      // Dead nodes have no loop, so return the top level loop instead
      return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
    }
    // Print some stats
    static void print_statistics();
    static int _loop_invokes;     // Count of PhaseIdealLoop invokes
    static int _loop_work;        // Sum of PhaseIdealLoop x _unique
  #endif
<span class="line-modified">!   void rpo( Node *start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list ) const;</span>
  };
  
  // This kit may be used for making of a reserved copy of a loop before this loop
  //  goes under non-reversible changes.
  //
  // Function create_reserve() creates a reserved copy (clone) of the loop.
  // The reserved copy is created by calling
<span class="line-new-header">--- 1357,147 ---</span>
    bool must_throttle_split_if() {
      uint threshold = C-&gt;max_node_limit() * 2 / 5;
      return C-&gt;live_nodes() &gt; threshold;
    }
  
<span class="line-added">+   // A simplistic node request tracking mechanism, where</span>
<span class="line-added">+   //   = UINT_MAX   Request not valid or made final.</span>
<span class="line-added">+   //   &lt; UINT_MAX   Nodes currently requested (estimate).</span>
<span class="line-added">+   uint _nodes_required;</span>
<span class="line-added">+ </span>
<span class="line-added">+   enum { REQUIRE_MIN = 70 };</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint nodes_required() const { return _nodes_required; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Given the _currently_  available number of nodes, check  whether there is</span>
<span class="line-added">+   // &quot;room&quot; for an additional request or not, considering the already required</span>
<span class="line-added">+   // number of  nodes.  Return TRUE if  the new request is  exceeding the node</span>
<span class="line-added">+   // budget limit, otherwise return FALSE.  Note that this interpretation will</span>
<span class="line-added">+   // act pessimistic on  additional requests when new nodes  have already been</span>
<span class="line-added">+   // generated since the &#39;begin&#39;.  This behaviour fits with the intention that</span>
<span class="line-added">+   // node estimates/requests should be made upfront.</span>
<span class="line-added">+   bool exceeding_node_budget(uint required = 0) {</span>
<span class="line-added">+     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(), &quot;sanity&quot;);</span>
<span class="line-added">+     uint available = C-&gt;max_node_limit() - C-&gt;live_nodes();</span>
<span class="line-added">+     return available &lt; required + _nodes_required + REQUIRE_MIN;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint require_nodes(uint require, uint minreq = REQUIRE_MIN) {</span>
<span class="line-added">+     precond(require &gt; 0);</span>
<span class="line-added">+     _nodes_required += MAX2(require, minreq);</span>
<span class="line-added">+     return _nodes_required;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool may_require_nodes(uint require, uint minreq = REQUIRE_MIN) {</span>
<span class="line-added">+     return !exceeding_node_budget(require) &amp;&amp; require_nodes(require, minreq) &gt; 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint require_nodes_begin() {</span>
<span class="line-added">+     assert(_nodes_required == UINT_MAX, &quot;Bad state (begin).&quot;);</span>
<span class="line-added">+     _nodes_required = 0;</span>
<span class="line-added">+     return C-&gt;live_nodes();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // When a node request is final,  optionally check that the requested number</span>
<span class="line-added">+   // of nodes was  reasonably correct with respect to the  number of new nodes</span>
<span class="line-added">+   // introduced since the last &#39;begin&#39;. Always check that we have not exceeded</span>
<span class="line-added">+   // the maximum node limit.</span>
<span class="line-added">+   void require_nodes_final(uint live_at_begin, bool check_estimate) {</span>
<span class="line-added">+     assert(_nodes_required &lt; UINT_MAX, &quot;Bad state (final).&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (check_estimate) {</span>
<span class="line-added">+       // Assert that the node budget request was not off by too much (x2).</span>
<span class="line-added">+       // Should this be the case we _surely_ need to improve the estimates</span>
<span class="line-added">+       // used in our budget calculations.</span>
<span class="line-added">+       assert(C-&gt;live_nodes() - live_at_begin &lt;= 2 * _nodes_required,</span>
<span class="line-added">+              &quot;Bad node estimate: actual = %d &gt;&gt; request = %d&quot;,</span>
<span class="line-added">+              C-&gt;live_nodes() - live_at_begin, _nodes_required);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Assert that we have stayed within the node budget limit.</span>
<span class="line-added">+     assert(C-&gt;live_nodes() &lt; C-&gt;max_node_limit(),</span>
<span class="line-added">+            &quot;Exceeding node budget limit: %d + %d &gt; %d (request = %d)&quot;,</span>
<span class="line-added">+            C-&gt;live_nodes() - live_at_begin, live_at_begin,</span>
<span class="line-added">+            C-&gt;max_node_limit(), _nodes_required);</span>
<span class="line-added">+ </span>
<span class="line-added">+     _nodes_required = UINT_MAX;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    bool _created_loop_node;
<span class="line-added">+ </span>
  public:
    void set_created_loop_node() { _created_loop_node = true; }
    bool created_loop_node()     { return _created_loop_node; }
<span class="line-modified">!   void register_new_node(Node* n, Node* blk);</span>
  
  #ifdef ASSERT
    void dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA);
  #endif
  
  #ifndef PRODUCT
<span class="line-modified">!   void dump() const;</span>
<span class="line-modified">!   void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &amp;rpo_list) const;</span>
    void verify() const;          // Major slow  :-)
<span class="line-modified">!   void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &amp;visited) const;</span>
<span class="line-modified">!   IdealLoopTree* get_loop_idx(Node* n) const {</span>
      // Dead nodes have no loop, so return the top level loop instead
      return _nodes[n-&gt;_idx] ? (IdealLoopTree*)_nodes[n-&gt;_idx] : _ltree_root;
    }
    // Print some stats
    static void print_statistics();
    static int _loop_invokes;     // Count of PhaseIdealLoop invokes
    static int _loop_work;        // Sum of PhaseIdealLoop x _unique
  #endif
<span class="line-modified">! </span>
<span class="line-added">+   void rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const;</span>
  };
  
<span class="line-added">+ </span>
<span class="line-added">+ class AutoNodeBudget : public StackObj</span>
<span class="line-added">+ {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   enum budget_check_t { BUDGET_CHECK, NO_BUDGET_CHECK };</span>
<span class="line-added">+ </span>
<span class="line-added">+   AutoNodeBudget(PhaseIdealLoop* phase, budget_check_t chk = BUDGET_CHECK)</span>
<span class="line-added">+     : _phase(phase),</span>
<span class="line-added">+       _check_at_final(chk == BUDGET_CHECK),</span>
<span class="line-added">+       _nodes_at_begin(0)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     precond(_phase != NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+     _nodes_at_begin = _phase-&gt;require_nodes_begin();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~AutoNodeBudget() {</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+     if (TraceLoopOpts) {</span>
<span class="line-added">+       uint request = _phase-&gt;nodes_required();</span>
<span class="line-added">+       uint delta   = _phase-&gt;C-&gt;live_nodes() - _nodes_at_begin;</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (request &lt; delta) {</span>
<span class="line-added">+         tty-&gt;print_cr(&quot;Exceeding node budget: %d &lt; %d&quot;, request, delta);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         uint const REQUIRE_MIN = PhaseIdealLoop::REQUIRE_MIN;</span>
<span class="line-added">+         // Identify the worst estimates as &quot;poor&quot; ones.</span>
<span class="line-added">+         if (request &gt; REQUIRE_MIN &amp;&amp; delta &gt; 0) {</span>
<span class="line-added">+           if ((delta &gt;  REQUIRE_MIN &amp;&amp; request &gt;  3 * delta) ||</span>
<span class="line-added">+               (delta &lt;= REQUIRE_MIN &amp;&amp; request &gt; 10 * delta)) {</span>
<span class="line-added">+             tty-&gt;print_cr(&quot;Poor node estimate: %d &gt;&gt; %d&quot;, request, delta);</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif // PRODUCT</span>
<span class="line-added">+     _phase-&gt;require_nodes_final(_nodes_at_begin, _check_at_final);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+   PhaseIdealLoop* _phase;</span>
<span class="line-added">+   bool _check_at_final;</span>
<span class="line-added">+   uint _nodes_at_begin;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // This kit may be used for making of a reserved copy of a loop before this loop
  //  goes under non-reversible changes.
  //
  // Function create_reserve() creates a reserved copy (clone) of the loop.
  // The reserved copy is created by calling
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1411,18 ***</span>
    private:
      bool create_reserve();
  };// class CountedLoopReserveKit
  
  inline Node* IdealLoopTree::tail() {
<span class="line-modified">! // Handle lazy update of _tail field</span>
<span class="line-modified">!   Node *n = _tail;</span>
<span class="line-modified">!   //while( !n-&gt;in(0) )  // Skip dead CFG nodes</span>
<span class="line-modified">!     //n = n-&gt;in(1);</span>
<span class="line-modified">!   if (n-&gt;in(0) == NULL)</span>
<span class="line-removed">-     n = _phase-&gt;get_ctrl(n);</span>
<span class="line-removed">-   _tail = n;</span>
<span class="line-removed">-   return n;</span>
  }
  
  
  // Iterate over the loop tree using a preorder, left-to-right traversal.
  //
<span class="line-new-header">--- 1557,15 ---</span>
    private:
      bool create_reserve();
  };// class CountedLoopReserveKit
  
  inline Node* IdealLoopTree::tail() {
<span class="line-modified">!   // Handle lazy update of _tail field.</span>
<span class="line-modified">!   if (_tail-&gt;in(0) == NULL) {</span>
<span class="line-modified">!     _tail = _phase-&gt;get_ctrl(_tail);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return _tail;</span>
  }
  
  
  // Iterate over the loop tree using a preorder, left-to-right traversal.
  //
</pre>
<center><a href="loopnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
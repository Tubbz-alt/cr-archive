diff a/src/hotspot/share/opto/block.cpp b/src/hotspot/share/opto/block.cpp
--- a/src/hotspot/share/opto/block.cpp
+++ b/src/hotspot/share/opto/block.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -34,10 +34,11 @@
 #include "opto/machnode.hpp"
 #include "opto/matcher.hpp"
 #include "opto/opcodes.hpp"
 #include "opto/rootnode.hpp"
 #include "utilities/copy.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 void Block_Array::grow( uint i ) {
   assert(i >= Max(), "must be an overflow");
   debug_only(_limit = i+1);
   if( i < _size )  return;
@@ -45,11 +46,11 @@
     _size = 1;
     _blocks = (Block**)_arena->Amalloc( _size * sizeof(Block*) );
     _blocks[0] = NULL;
   }
   uint old = _size;
-  while( i >= _size ) _size <<= 1;      // Double to fit
+  _size = next_power_of_2(i);
   _blocks = (Block**)_arena->Arealloc( _blocks, old*sizeof(Block*),_size*sizeof(Block*));
   Copy::zero_to_bytes( &_blocks[old], (_size-old)*sizeof(Block*) );
 }
 
 void Block_List::remove(uint i) {
@@ -265,11 +266,11 @@
   return false;
 }
 
 #ifndef PRODUCT
 void Block::dump_bidx(const Block* orig, outputStream* st) const {
-  if (_pre_order) st->print("B%d",_pre_order);
+  if (_pre_order) st->print("B%d", _pre_order);
   else st->print("N%d", head()->_idx);
 
   if (Verbose && orig != this) {
     // Dump the original block's idx
     st->print(" (");
@@ -289,34 +290,40 @@
     st->print(" ");
   }
 }
 
 void Block::dump_head(const PhaseCFG* cfg, outputStream* st) const {
-  // Print the basic block
+  // Print the basic block.
   dump_bidx(this, st);
-  st->print(": #\t");
+  st->print(": ");
 
-  // Print the incoming CFG edges and the outgoing CFG edges
+  // Print the outgoing CFG edges.
+  st->print("#\tout( ");
   for( uint i=0; i<_num_succs; i++ ) {
     non_connector_successor(i)->dump_bidx(_succs[i], st);
     st->print(" ");
   }
-  st->print("<- ");
+
+  // Print the incoming CFG edges.
+  st->print(") <- ");
   if( head()->is_block_start() ) {
+    st->print("in( ");
     for (uint i=1; i<num_preds(); i++) {
       Node *s = pred(i);
       if (cfg != NULL) {
         Block *p = cfg->get_block_for_node(s);
         p->dump_pred(cfg, p, st);
       } else {
-        while (!s->is_block_start())
+        while (!s->is_block_start()) {
           s = s->in(0);
+        }
         st->print("N%d ", s->_idx );
       }
     }
+    st->print(") ");
   } else {
-    st->print("BLOCK HEAD IS JUNK  ");
+    st->print("BLOCK HEAD IS JUNK ");
   }
 
   // Print loop, if any
   const Block *bhead = this;    // Head of self-loop
   Node *bh = bhead->head();
@@ -325,16 +332,19 @@
     LoopNode *loop = bh->as_Loop();
     const Block *bx = cfg->get_block_for_node(loop->in(LoopNode::LoopBackControl));
     while (bx->is_connector()) {
       bx = cfg->get_block_for_node(bx->pred(1));
     }
-    st->print("\tLoop: B%d-B%d ", bhead->_pre_order, bx->_pre_order);
+    st->print("Loop( B%d-B%d ", bhead->_pre_order, bx->_pre_order);
     // Dump any loop-specific bits, especially for CountedLoops.
     loop->dump_spec(st);
+    st->print(")");
   } else if (has_loop_alignment()) {
-    st->print(" top-of-loop");
+    st->print("top-of-loop");
   }
+
+  // Print frequency and other optimization-relevant information
   st->print(" Freq: %g",_freq);
   if( Verbose || WizardMode ) {
     st->print(" IDom: %d/#%d", _idom ? _idom->_pre_order : 0, _dom_depth);
     st->print(" RegPressure: %d",_reg_pressure);
     st->print(" IHRP Index: %d",_ihrp_index);

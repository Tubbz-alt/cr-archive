<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/subnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/subnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 112,35 ***</span>
    return sub(t1,t2);            // Local flavor of type subtraction
  
  }
  
  //=============================================================================
<span class="line-removed">- </span>
  //------------------------------Helper function--------------------------------
<span class="line-modified">! static bool ok_to_convert(Node* inc, Node* iv) {</span>
<span class="line-modified">!     // Do not collapse (x+c0)-y if &quot;+&quot; is a loop increment, because the</span>
<span class="line-modified">!     // &quot;-&quot; is loop invariant and collapsing extends the live-range of &quot;x&quot;</span>
<span class="line-modified">!     // to overlap with the &quot;+&quot;, forcing another register to be used in</span>
<span class="line-modified">!     // the loop.</span>
<span class="line-modified">!     // This test will be clearer with &#39;&amp;&amp;&#39; (apply DeMorgan&#39;s rule)</span>
<span class="line-modified">!     // but I like the early cutouts that happen here.</span>
<span class="line-modified">!     const PhiNode *phi;</span>
<span class="line-modified">!     if( ( !inc-&gt;in(1)-&gt;is_Phi() ||</span>
<span class="line-modified">!           !(phi=inc-&gt;in(1)-&gt;as_Phi()) ||</span>
<span class="line-modified">!           phi-&gt;is_copy() ||</span>
<span class="line-modified">!           !phi-&gt;region()-&gt;is_CountedLoop() ||</span>
<span class="line-modified">!           inc != phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr() )</span>
<span class="line-modified">!        &amp;&amp;</span>
<span class="line-removed">-         // Do not collapse (x+c0)-iv if &quot;iv&quot; is a loop induction variable,</span>
<span class="line-removed">-         // because &quot;x&quot; maybe invariant.</span>
<span class="line-removed">-         ( !iv-&gt;is_loop_iv() )</span>
<span class="line-removed">-       ) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
  }
  //------------------------------Ideal------------------------------------------
  Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
    Node *in1 = in(1);
    Node *in2 = in(2);
    uint op1 = in1-&gt;Opcode();
<span class="line-new-header">--- 112,41 ---</span>
    return sub(t1,t2);            // Local flavor of type subtraction
  
  }
  
  //=============================================================================
  //------------------------------Helper function--------------------------------
<span class="line-modified">! </span>
<span class="line-modified">! static bool is_cloop_increment(Node* inc) {</span>
<span class="line-modified">!   precond(inc-&gt;Opcode() == Op_AddI || inc-&gt;Opcode() == Op_AddL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!inc-&gt;in(1)-&gt;is_Phi()) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   const PhiNode* phi = inc-&gt;in(1)-&gt;as_Phi();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (phi-&gt;is_copy() || !phi-&gt;region()-&gt;is_CountedLoop()) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return inc == phi-&gt;region()-&gt;as_CountedLoop()-&gt;incr();</span>
  }
<span class="line-added">+ </span>
<span class="line-added">+ // Given the expression &#39;(x + C) - v&#39;, or</span>
<span class="line-added">+ //                      &#39;v - (x + C)&#39;, we examine nodes &#39;+&#39; and &#39;v&#39;:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ //  1. Do not convert if &#39;+&#39; is a counted-loop increment, because the &#39;-&#39; is</span>
<span class="line-added">+ //     loop invariant and converting extends the live-range of &#39;x&#39; to overlap</span>
<span class="line-added">+ //     with the &#39;+&#39;, forcing another register to be used in the loop.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ //  2. Do not convert if &#39;v&#39; is a counted-loop induction variable, because</span>
<span class="line-added">+ //     &#39;x&#39; might be invariant.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ static bool ok_to_convert(Node* inc, Node* var) {</span>
<span class="line-added">+   return !(is_cloop_increment(inc) || var-&gt;is_cloop_ind_var());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //------------------------------Ideal------------------------------------------
  Node *SubINode::Ideal(PhaseGVN *phase, bool can_reshape){
    Node *in1 = in(1);
    Node *in2 = in(2);
    uint op1 = in1-&gt;Opcode();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,27 ***</span>
      // Equal pointer constants (klasses, nulls, etc.)
      return TypeInt::CC_EQ;
    }
  
    // See if it is 2 unrelated classes.
<span class="line-modified">!   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-modified">!   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-modified">!   if (p0 &amp;&amp; p1) {</span>
      Node* in1 = in(1)-&gt;uncast();
      Node* in2 = in(2)-&gt;uncast();
      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
      if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
        return TypeInt::CC_GT;  // different pointers
      }
<span class="line-modified">!     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-modified">!     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-modified">!     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-modified">!     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-modified">!     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
      if (klass0 &amp;&amp; klass1 &amp;&amp;
<span class="line-removed">-         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
          klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
          klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
          (!klass0-&gt;is_obj_array_klass() ||
           !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
          (!klass1-&gt;is_obj_array_klass() ||
<span class="line-new-header">--- 817,52 ---</span>
      // Equal pointer constants (klasses, nulls, etc.)
      return TypeInt::CC_EQ;
    }
  
    // See if it is 2 unrelated classes.
<span class="line-modified">!   const TypeOopPtr* oop_p0 = r0-&gt;isa_oopptr();</span>
<span class="line-modified">!   const TypeOopPtr* oop_p1 = r1-&gt;isa_oopptr();</span>
<span class="line-modified">!   bool both_oop_ptr = oop_p0 &amp;&amp; oop_p1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (both_oop_ptr) {</span>
      Node* in1 = in(1)-&gt;uncast();
      Node* in2 = in(2)-&gt;uncast();
      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);
      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);
      if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {
        return TypeInt::CC_GT;  // different pointers
      }
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const TypeKlassPtr* klass_p0 = r0-&gt;isa_klassptr();</span>
<span class="line-modified">!   const TypeKlassPtr* klass_p1 = r1-&gt;isa_klassptr();</span>
<span class="line-modified">! </span>
<span class="line-added">+   if (both_oop_ptr || (klass_p0 &amp;&amp; klass_p1)) { // both or neither are klass pointers</span>
<span class="line-added">+     ciKlass* klass0 = NULL;</span>
<span class="line-added">+     bool    xklass0 = false;</span>
<span class="line-added">+     ciKlass* klass1 = NULL;</span>
<span class="line-added">+     bool    xklass1 = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (oop_p0) {</span>
<span class="line-added">+       klass0 = oop_p0-&gt;klass();</span>
<span class="line-added">+       xklass0 = oop_p0-&gt;klass_is_exact();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(klass_p0, &quot;must be non-null if oop_p0 is null&quot;);</span>
<span class="line-added">+       klass0 = klass_p0-&gt;klass();</span>
<span class="line-added">+       xklass0 = klass_p0-&gt;klass_is_exact();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (oop_p1) {</span>
<span class="line-added">+       klass1 = oop_p1-&gt;klass();</span>
<span class="line-added">+       xklass1 = oop_p1-&gt;klass_is_exact();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(klass_p1, &quot;must be non-null if oop_p1 is null&quot;);</span>
<span class="line-added">+       klass1 = klass_p1-&gt;klass();</span>
<span class="line-added">+       xklass1 = klass_p1-&gt;klass_is_exact();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (klass0 &amp;&amp; klass1 &amp;&amp;
          klass0-&gt;is_loaded() &amp;&amp; !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces
          klass1-&gt;is_loaded() &amp;&amp; !klass1-&gt;is_interface() &amp;&amp;
          (!klass0-&gt;is_obj_array_klass() ||
           !klass0-&gt;as_obj_array_klass()-&gt;base_element_klass()-&gt;is_interface()) &amp;&amp;
          (!klass1-&gt;is_obj_array_klass() ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1046,77 ***</span>
  //=============================================================================
  //------------------------------sub--------------------------------------------
  // Simplify an CmpN (compare 2 pointers) node, based on local information.
  // If both inputs are constants, compare them.
  const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
<span class="line-modified">!   const TypePtr *r0 = t1-&gt;make_ptr(); // Handy access</span>
<span class="line-modified">!   const TypePtr *r1 = t2-&gt;make_ptr();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Undefined inputs makes for an undefined result</span>
<span class="line-removed">-   if ((r0 == NULL) || (r1 == NULL) ||</span>
<span class="line-removed">-       TypePtr::above_centerline(r0-&gt;_ptr) ||</span>
<span class="line-removed">-       TypePtr::above_centerline(r1-&gt;_ptr)) {</span>
<span class="line-removed">-     return Type::TOP;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (r0 == r1 &amp;&amp; r0-&gt;singleton()) {</span>
<span class="line-removed">-     // Equal pointer constants (klasses, nulls, etc.)</span>
<span class="line-removed">-     return TypeInt::CC_EQ;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // See if it is 2 unrelated classes.</span>
<span class="line-removed">-   const TypeOopPtr* p0 = r0-&gt;isa_oopptr();</span>
<span class="line-removed">-   const TypeOopPtr* p1 = r1-&gt;isa_oopptr();</span>
<span class="line-removed">-   if (p0 &amp;&amp; p1) {</span>
<span class="line-removed">-     ciKlass* klass0 = p0-&gt;klass();</span>
<span class="line-removed">-     bool    xklass0 = p0-&gt;klass_is_exact();</span>
<span class="line-removed">-     ciKlass* klass1 = p1-&gt;klass();</span>
<span class="line-removed">-     bool    xklass1 = p1-&gt;klass_is_exact();</span>
<span class="line-removed">-     int kps = (p0-&gt;isa_klassptr()?1:0) + (p1-&gt;isa_klassptr()?1:0);</span>
<span class="line-removed">-     if (klass0 &amp;&amp; klass1 &amp;&amp;</span>
<span class="line-removed">-         kps != 1 &amp;&amp;             // both or neither are klass pointers</span>
<span class="line-removed">-         !klass0-&gt;is_interface() &amp;&amp; // do not trust interfaces</span>
<span class="line-removed">-         !klass1-&gt;is_interface()) {</span>
<span class="line-removed">-       bool unrelated_classes = false;</span>
<span class="line-removed">-       // See if neither subclasses the other, or if the class on top</span>
<span class="line-removed">-       // is precise.  In either of these cases, the compare is known</span>
<span class="line-removed">-       // to fail if at least one of the pointers is provably not null.</span>
<span class="line-removed">-       if (klass0-&gt;equals(klass1)) { // if types are unequal but klasses are equal</span>
<span class="line-removed">-         // Do nothing; we know nothing for imprecise types</span>
<span class="line-removed">-       } else if (klass0-&gt;is_subtype_of(klass1)) {</span>
<span class="line-removed">-         // If klass1&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">-         unrelated_classes = xklass1;</span>
<span class="line-removed">-       } else if (klass1-&gt;is_subtype_of(klass0)) {</span>
<span class="line-removed">-         // If klass0&#39;s type is PRECISE, then classes are unrelated.</span>
<span class="line-removed">-         unrelated_classes = xklass0;</span>
<span class="line-removed">-       } else {                  // Neither subtypes the other</span>
<span class="line-removed">-         unrelated_classes = true;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (unrelated_classes) {</span>
<span class="line-removed">-         // The oops classes are known to be unrelated. If the joined PTRs of</span>
<span class="line-removed">-         // two oops is not Null and not Bottom, then we are sure that one</span>
<span class="line-removed">-         // of the two oops is non-null, and the comparison will always fail.</span>
<span class="line-removed">-         TypePtr::PTR jp = r0-&gt;join_ptr(r1-&gt;_ptr);</span>
<span class="line-removed">-         if (jp != TypePtr::Null &amp;&amp; jp != TypePtr::BotPTR) {</span>
<span class="line-removed">-           return TypeInt::CC_GT;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Known constants can be compared exactly</span>
<span class="line-removed">-   // Null can be distinguished from any NotNull pointers</span>
<span class="line-removed">-   // Unknown inputs makes an unknown result</span>
<span class="line-removed">-   if( r0-&gt;singleton() ) {</span>
<span class="line-removed">-     intptr_t bits0 = r0-&gt;get_con();</span>
<span class="line-removed">-     if( r1-&gt;singleton() )</span>
<span class="line-removed">-       return bits0 == r1-&gt;get_con() ? TypeInt::CC_EQ : TypeInt::CC_GT;</span>
<span class="line-removed">-     return ( r1-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits0==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">-   } else if( r1-&gt;singleton() ) {</span>
<span class="line-removed">-     intptr_t bits1 = r1-&gt;get_con();</span>
<span class="line-removed">-     return ( r0-&gt;_ptr == TypePtr::NotNull &amp;&amp; bits1==0 ) ? TypeInt::CC_GT : TypeInt::CC;</span>
<span class="line-removed">-   } else</span>
<span class="line-removed">-     return TypeInt::CC;</span>
  }
  
  //------------------------------Ideal------------------------------------------
  Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
    return NULL;
<span class="line-new-header">--- 1077,12 ---</span>
  //=============================================================================
  //------------------------------sub--------------------------------------------
  // Simplify an CmpN (compare 2 pointers) node, based on local information.
  // If both inputs are constants, compare them.
  const Type *CmpNNode::sub( const Type *t1, const Type *t2 ) const {
<span class="line-modified">!   ShouldNotReachHere();</span>
<span class="line-modified">!   return bottom_type();</span>
  }
  
  //------------------------------Ideal------------------------------------------
  Node *CmpNNode::Ideal( PhaseGVN *phase, bool can_reshape ) {
    return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,11 ***</span>
  //=============================================================================
  uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
  uint BoolNode::size_of() const { return sizeof(BoolNode); }
  
  //------------------------------operator==-------------------------------------
<span class="line-modified">! uint BoolNode::cmp( const Node &amp;n ) const {</span>
    const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
    return (_test._test == b-&gt;_test._test);
  }
  
  //-------------------------------make_predicate--------------------------------
<span class="line-new-header">--- 1243,11 ---</span>
  //=============================================================================
  uint BoolNode::hash() const { return (Node::hash() &lt;&lt; 3)|(_test._test+1); }
  uint BoolNode::size_of() const { return sizeof(BoolNode); }
  
  //------------------------------operator==-------------------------------------
<span class="line-modified">! bool BoolNode::cmp( const Node &amp;n ) const {</span>
    const BoolNode *b = (const BoolNode *)&amp;n; // Cast up
    return (_test._test == b-&gt;_test._test);
  }
  
  //-------------------------------make_predicate--------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1384,11 ***</span>
    // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
    // This moves the constant to the right.  Helps value-numbering.
    Node *cmp = in(1);
    if( !cmp-&gt;is_Sub() ) return NULL;
    int cop = cmp-&gt;Opcode();
<span class="line-modified">!   if( cop == Op_FastLock || cop == Op_FastUnlock) return NULL;</span>
    Node *cmp1 = cmp-&gt;in(1);
    Node *cmp2 = cmp-&gt;in(2);
    if( !cmp1 ) return NULL;
  
    if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
<span class="line-new-header">--- 1350,11 ---</span>
    // Change &quot;bool tst (cmp con x)&quot; into &quot;bool ~tst (cmp x con)&quot;.
    // This moves the constant to the right.  Helps value-numbering.
    Node *cmp = in(1);
    if( !cmp-&gt;is_Sub() ) return NULL;
    int cop = cmp-&gt;Opcode();
<span class="line-modified">!   if( cop == Op_FastLock || cop == Op_FastUnlock || cmp-&gt;is_SubTypeCheck()) return NULL;</span>
    Node *cmp1 = cmp-&gt;in(1);
    Node *cmp2 = cmp-&gt;in(2);
    if( !cmp1 ) return NULL;
  
    if (_test._test == BoolTest::overflow || _test._test == BoolTest::no_overflow) {
</pre>
<center><a href="stringopts.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="subnode.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/runtime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rootnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="runtime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/runtime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 286   // is that we return an oop, but we can block on exit from this routine and
 287   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 288   // fetch the oop from TLS after any possible GC.
 289   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 290   thread-&gt;set_vm_result(result);
 291   JRT_BLOCK_END;
 292 
 293 
 294   // inform GC that we won&#39;t do card marks for initializing writes.
 295   SharedRuntime::on_slowpath_allocation_exit(thread);
 296 
 297   oop result = thread-&gt;vm_result();
 298   if ((len &gt; 0) &amp;&amp; (result != NULL) &amp;&amp;
 299       is_deoptimized_caller_frame(thread)) {
 300     // Zero array here if the caller is deoptimized.
 301     int size = ((typeArrayOop)result)-&gt;object_size();
 302     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 303     const size_t hs = arrayOopDesc::header_size(elem_type);
 304     // Align to next 8 bytes to avoid trashing arrays&#39;s length.
 305     const size_t aligned_hs = align_object_offset(hs);
<span class="line-modified"> 306     HeapWord* obj = (HeapWord*)result;</span>
 307     if (aligned_hs &gt; hs) {
 308       Copy::zero_to_words(obj+hs, aligned_hs-hs);
 309     }
 310     // Optimized zeroing.
 311     Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
 312   }
 313 
 314 JRT_END
 315 
 316 // Note: multianewarray for one dimension is handled inline by GraphKit::new_array.
 317 
 318 // multianewarray for 2 dimensions
 319 JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))
 320 #ifndef PRODUCT
 321   SharedRuntime::_multi2_ctr++;                // multianewarray for 1 dimension
 322 #endif
 323   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 324   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 325   jint dims[2];
 326   dims[0] = len1;
</pre>
<hr />
<pre>
 883   const Type** fields = TypeTuple::fields(argcnt);
 884   int argp = TypeFunc::Parms;
 885   fields[argp++] = TypePtr::NOTNULL;    // src
 886   fields[argp++] = TypePtr::NOTNULL;    // dest
 887   fields[argp++] = TypePtr::NOTNULL;    // k array
 888   fields[argp++] = TypePtr::NOTNULL;    // r array
 889   fields[argp++] = TypeInt::INT;        // src len
 890   if (Matcher::pass_original_key_for_aes()) {
 891     fields[argp++] = TypePtr::NOTNULL;    // original k array
 892   }
 893   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 894   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 895 
 896   // returning cipher len (int)
 897   fields = TypeTuple::fields(1);
 898   fields[TypeFunc::Parms+0] = TypeInt::INT;
 899   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 900   return TypeFunc::make(domain, range);
 901 }
 902 



























 903 //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 904 const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
 905   // create input type (domain)
 906   int num_args = 7;
 907   if (Matcher::pass_original_key_for_aes()) {
 908     num_args = 8;
 909   }
 910   int argcnt = num_args;
 911   const Type** fields = TypeTuple::fields(argcnt);
 912   int argp = TypeFunc::Parms;
 913   fields[argp++] = TypePtr::NOTNULL; // src
 914   fields[argp++] = TypePtr::NOTNULL; // dest
 915   fields[argp++] = TypePtr::NOTNULL; // k array
 916   fields[argp++] = TypePtr::NOTNULL; // counter array
 917   fields[argp++] = TypeInt::INT; // src len
 918   fields[argp++] = TypePtr::NOTNULL; // saved_encCounter
 919   fields[argp++] = TypePtr::NOTNULL; // saved used addr
 920   if (Matcher::pass_original_key_for_aes()) {
 921     fields[argp++] = TypePtr::NOTNULL; // original k array
 922   }
</pre>
<hr />
<pre>
1067   int argcnt = num_args;
1068   const Type** fields = TypeTuple::fields(argcnt);
1069   int argp = TypeFunc::Parms;
1070   fields[argp++] = TypePtr::NOTNULL;    // a
1071   fields[argp++] = TypePtr::NOTNULL;    // n
1072   fields[argp++] = TypeInt::INT;        // len
1073   fields[argp++] = TypeLong::LONG;      // inv
1074   fields[argp++] = Type::HALF;
1075   fields[argp++] = TypePtr::NOTNULL;    // result
1076   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1077   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1078 
1079   // result type needed
1080   fields = TypeTuple::fields(1);
1081   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1082 
1083   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1084   return TypeFunc::make(domain, range);
1085 }
1086 



















1087 const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
1088   // create input type (domain)
1089   int num_args = 4;
1090   int argcnt = num_args;
1091   const Type** fields = TypeTuple::fields(argcnt);
1092   int argp = TypeFunc::Parms;
1093   fields[argp++] = TypePtr::NOTNULL;    // obja
1094   fields[argp++] = TypePtr::NOTNULL;    // objb
1095   fields[argp++] = TypeInt::INT;        // length, number of elements
1096   fields[argp++] = TypeInt::INT;        // log2scale, element size
1097   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1098   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1099 
1100   //return mismatch index (int)
1101   fields = TypeTuple::fields(1);
1102   fields[TypeFunc::Parms + 0] = TypeInt::INT;
1103   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
1104   return TypeFunc::make(domain, range);
1105 }
1106 
</pre>
<hr />
<pre>
1395 }
1396 
1397 //------------------------------rethrow----------------------------------------
1398 // We get here after compiled code has executed a &#39;RethrowNode&#39;.  The callee
1399 // is either throwing or rethrowing an exception.  The callee-save registers
1400 // have been restored, synchronized objects have been unlocked and the callee
1401 // stack frame has been removed.  The return address was passed in.
1402 // Exception oop is passed as the 1st argument.  This routine is then called
1403 // from the stub.  On exit, we know where to jump in the caller&#39;s code.
1404 // After this C code exits, the stub will pop his frame and end in a jump
1405 // (instead of a return).  We enter the caller&#39;s default handler.
1406 //
1407 // This must be JRT_LEAF:
1408 //     - caller will not change its state as we cannot block on exit,
1409 //       therefore raw_exception_handler_for_return_address is all it takes
1410 //       to handle deoptimized blobs
1411 //
1412 // However, there needs to be a safepoint check in the middle!  So compiled
1413 // safepoints are completely watertight.
1414 //
<span class="line-modified">1415 // Thus, it cannot be a leaf since it contains the NoGCVerifier.</span>
1416 //
1417 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
1418 //
1419 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
1420 #ifndef PRODUCT
1421   SharedRuntime::_rethrow_ctr++;               // count rethrows
1422 #endif
1423   assert (exception != NULL, &quot;should have thrown a NULLPointerException&quot;);
1424 #ifdef ASSERT
1425   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1426     // should throw an exception here
1427     ShouldNotReachHere();
1428   }
1429 #endif
1430 
1431   thread-&gt;set_vm_result(exception);
1432   // Frame not compiled (handles deoptimization blob)
1433   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
1434 }
1435 
</pre>
<hr />
<pre>
1615     }
1616     st.print(&quot;@%d&quot;, bci);
1617     // To print linenumbers instead of bci use: m-&gt;line_number_from_bci(bci)
1618   }
1619   NamedCounter* c;
1620   if (tag == NamedCounter::BiasedLockingCounter) {
1621     c = new BiasedLockingNamedCounter(st.as_string());
1622   } else if (tag == NamedCounter::RTMLockingCounter) {
1623     c = new RTMLockingNamedCounter(st.as_string());
1624   } else {
1625     c = new NamedCounter(st.as_string(), tag);
1626   }
1627 
1628   // atomically add the new counter to the head of the list.  We only
1629   // add counters so this is safe.
1630   NamedCounter* head;
1631   do {
1632     c-&gt;set_next(NULL);
1633     head = _named_counters;
1634     c-&gt;set_next(head);
<span class="line-modified">1635   } while (Atomic::cmpxchg(c, &amp;_named_counters, head) != head);</span>
1636   return c;
1637 }
1638 
1639 int trace_exception_counter = 0;
1640 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
1641   trace_exception_counter++;
1642   stringStream tempst;
1643 
1644   tempst.print(&quot;%d [Exception (%s): &quot;, trace_exception_counter, msg);
1645   exception_oop-&gt;print_value_on(&amp;tempst);
1646   tempst.print(&quot; in &quot;);
1647   CodeBlob* blob = CodeCache::find_blob(exception_pc);
1648   if (blob-&gt;is_compiled()) {
1649     CompiledMethod* cm = blob-&gt;as_compiled_method_or_null();
1650     cm-&gt;method()-&gt;print_value_on(&amp;tempst);
1651   } else if (blob-&gt;is_runtime_stub()) {
1652     tempst.print(&quot;&lt;runtime-stub&gt;&quot;);
1653   } else {
1654     tempst.print(&quot;&lt;unknown&gt;&quot;);
1655   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 286   // is that we return an oop, but we can block on exit from this routine and
 287   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 288   // fetch the oop from TLS after any possible GC.
 289   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 290   thread-&gt;set_vm_result(result);
 291   JRT_BLOCK_END;
 292 
 293 
 294   // inform GC that we won&#39;t do card marks for initializing writes.
 295   SharedRuntime::on_slowpath_allocation_exit(thread);
 296 
 297   oop result = thread-&gt;vm_result();
 298   if ((len &gt; 0) &amp;&amp; (result != NULL) &amp;&amp;
 299       is_deoptimized_caller_frame(thread)) {
 300     // Zero array here if the caller is deoptimized.
 301     int size = ((typeArrayOop)result)-&gt;object_size();
 302     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 303     const size_t hs = arrayOopDesc::header_size(elem_type);
 304     // Align to next 8 bytes to avoid trashing arrays&#39;s length.
 305     const size_t aligned_hs = align_object_offset(hs);
<span class="line-modified"> 306     HeapWord* obj = cast_from_oop&lt;HeapWord*&gt;(result);</span>
 307     if (aligned_hs &gt; hs) {
 308       Copy::zero_to_words(obj+hs, aligned_hs-hs);
 309     }
 310     // Optimized zeroing.
 311     Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
 312   }
 313 
 314 JRT_END
 315 
 316 // Note: multianewarray for one dimension is handled inline by GraphKit::new_array.
 317 
 318 // multianewarray for 2 dimensions
 319 JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))
 320 #ifndef PRODUCT
 321   SharedRuntime::_multi2_ctr++;                // multianewarray for 1 dimension
 322 #endif
 323   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 324   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 325   jint dims[2];
 326   dims[0] = len1;
</pre>
<hr />
<pre>
 883   const Type** fields = TypeTuple::fields(argcnt);
 884   int argp = TypeFunc::Parms;
 885   fields[argp++] = TypePtr::NOTNULL;    // src
 886   fields[argp++] = TypePtr::NOTNULL;    // dest
 887   fields[argp++] = TypePtr::NOTNULL;    // k array
 888   fields[argp++] = TypePtr::NOTNULL;    // r array
 889   fields[argp++] = TypeInt::INT;        // src len
 890   if (Matcher::pass_original_key_for_aes()) {
 891     fields[argp++] = TypePtr::NOTNULL;    // original k array
 892   }
 893   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 894   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 895 
 896   // returning cipher len (int)
 897   fields = TypeTuple::fields(1);
 898   fields[TypeFunc::Parms+0] = TypeInt::INT;
 899   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 900   return TypeFunc::make(domain, range);
 901 }
 902 
<span class="line-added"> 903 // for electronicCodeBook calls of aescrypt encrypt/decrypt, three pointers and a length, returning int</span>
<span class="line-added"> 904 const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {</span>
<span class="line-added"> 905   // create input type (domain)</span>
<span class="line-added"> 906   int num_args = 4;</span>
<span class="line-added"> 907   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="line-added"> 908      num_args = 5;</span>
<span class="line-added"> 909   }</span>
<span class="line-added"> 910   int argcnt = num_args;</span>
<span class="line-added"> 911   const Type** fields = TypeTuple::fields(argcnt);</span>
<span class="line-added"> 912   int argp = TypeFunc::Parms;</span>
<span class="line-added"> 913   fields[argp++] = TypePtr::NOTNULL;    // src</span>
<span class="line-added"> 914   fields[argp++] = TypePtr::NOTNULL;    // dest</span>
<span class="line-added"> 915   fields[argp++] = TypePtr::NOTNULL;    // k array</span>
<span class="line-added"> 916   fields[argp++] = TypeInt::INT;        // src len</span>
<span class="line-added"> 917   if (Matcher::pass_original_key_for_aes()) {</span>
<span class="line-added"> 918      fields[argp++] = TypePtr::NOTNULL;    // original k array</span>
<span class="line-added"> 919   }</span>
<span class="line-added"> 920   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);</span>
<span class="line-added"> 921   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923   // returning cipher len (int)</span>
<span class="line-added"> 924   fields = TypeTuple::fields(1);</span>
<span class="line-added"> 925   fields[TypeFunc::Parms + 0] = TypeInt::INT;</span>
<span class="line-added"> 926   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);</span>
<span class="line-added"> 927   return TypeFunc::make(domain, range);</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
 930 //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 931 const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
 932   // create input type (domain)
 933   int num_args = 7;
 934   if (Matcher::pass_original_key_for_aes()) {
 935     num_args = 8;
 936   }
 937   int argcnt = num_args;
 938   const Type** fields = TypeTuple::fields(argcnt);
 939   int argp = TypeFunc::Parms;
 940   fields[argp++] = TypePtr::NOTNULL; // src
 941   fields[argp++] = TypePtr::NOTNULL; // dest
 942   fields[argp++] = TypePtr::NOTNULL; // k array
 943   fields[argp++] = TypePtr::NOTNULL; // counter array
 944   fields[argp++] = TypeInt::INT; // src len
 945   fields[argp++] = TypePtr::NOTNULL; // saved_encCounter
 946   fields[argp++] = TypePtr::NOTNULL; // saved used addr
 947   if (Matcher::pass_original_key_for_aes()) {
 948     fields[argp++] = TypePtr::NOTNULL; // original k array
 949   }
</pre>
<hr />
<pre>
1094   int argcnt = num_args;
1095   const Type** fields = TypeTuple::fields(argcnt);
1096   int argp = TypeFunc::Parms;
1097   fields[argp++] = TypePtr::NOTNULL;    // a
1098   fields[argp++] = TypePtr::NOTNULL;    // n
1099   fields[argp++] = TypeInt::INT;        // len
1100   fields[argp++] = TypeLong::LONG;      // inv
1101   fields[argp++] = Type::HALF;
1102   fields[argp++] = TypePtr::NOTNULL;    // result
1103   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1104   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1105 
1106   // result type needed
1107   fields = TypeTuple::fields(1);
1108   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1109 
1110   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1111   return TypeFunc::make(domain, range);
1112 }
1113 
<span class="line-added">1114 const TypeFunc * OptoRuntime::bigIntegerShift_Type() {</span>
<span class="line-added">1115   int argcnt = 5;</span>
<span class="line-added">1116   const Type** fields = TypeTuple::fields(argcnt);</span>
<span class="line-added">1117   int argp = TypeFunc::Parms;</span>
<span class="line-added">1118   fields[argp++] = TypePtr::NOTNULL;    // newArr</span>
<span class="line-added">1119   fields[argp++] = TypePtr::NOTNULL;    // oldArr</span>
<span class="line-added">1120   fields[argp++] = TypeInt::INT;        // newIdx</span>
<span class="line-added">1121   fields[argp++] = TypeInt::INT;        // shiftCount</span>
<span class="line-added">1122   fields[argp++] = TypeInt::INT;        // numIter</span>
<span class="line-added">1123   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);</span>
<span class="line-added">1124   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);</span>
<span class="line-added">1125 </span>
<span class="line-added">1126   // no result type needed</span>
<span class="line-added">1127   fields = TypeTuple::fields(1);</span>
<span class="line-added">1128   fields[TypeFunc::Parms + 0] = NULL;</span>
<span class="line-added">1129   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);</span>
<span class="line-added">1130   return TypeFunc::make(domain, range);</span>
<span class="line-added">1131 }</span>
<span class="line-added">1132 </span>
1133 const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
1134   // create input type (domain)
1135   int num_args = 4;
1136   int argcnt = num_args;
1137   const Type** fields = TypeTuple::fields(argcnt);
1138   int argp = TypeFunc::Parms;
1139   fields[argp++] = TypePtr::NOTNULL;    // obja
1140   fields[argp++] = TypePtr::NOTNULL;    // objb
1141   fields[argp++] = TypeInt::INT;        // length, number of elements
1142   fields[argp++] = TypeInt::INT;        // log2scale, element size
1143   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1144   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1145 
1146   //return mismatch index (int)
1147   fields = TypeTuple::fields(1);
1148   fields[TypeFunc::Parms + 0] = TypeInt::INT;
1149   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
1150   return TypeFunc::make(domain, range);
1151 }
1152 
</pre>
<hr />
<pre>
1441 }
1442 
1443 //------------------------------rethrow----------------------------------------
1444 // We get here after compiled code has executed a &#39;RethrowNode&#39;.  The callee
1445 // is either throwing or rethrowing an exception.  The callee-save registers
1446 // have been restored, synchronized objects have been unlocked and the callee
1447 // stack frame has been removed.  The return address was passed in.
1448 // Exception oop is passed as the 1st argument.  This routine is then called
1449 // from the stub.  On exit, we know where to jump in the caller&#39;s code.
1450 // After this C code exits, the stub will pop his frame and end in a jump
1451 // (instead of a return).  We enter the caller&#39;s default handler.
1452 //
1453 // This must be JRT_LEAF:
1454 //     - caller will not change its state as we cannot block on exit,
1455 //       therefore raw_exception_handler_for_return_address is all it takes
1456 //       to handle deoptimized blobs
1457 //
1458 // However, there needs to be a safepoint check in the middle!  So compiled
1459 // safepoints are completely watertight.
1460 //
<span class="line-modified">1461 // Thus, it cannot be a leaf since it contains the NoSafepointVerifier.</span>
1462 //
1463 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
1464 //
1465 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
1466 #ifndef PRODUCT
1467   SharedRuntime::_rethrow_ctr++;               // count rethrows
1468 #endif
1469   assert (exception != NULL, &quot;should have thrown a NULLPointerException&quot;);
1470 #ifdef ASSERT
1471   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1472     // should throw an exception here
1473     ShouldNotReachHere();
1474   }
1475 #endif
1476 
1477   thread-&gt;set_vm_result(exception);
1478   // Frame not compiled (handles deoptimization blob)
1479   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
1480 }
1481 
</pre>
<hr />
<pre>
1661     }
1662     st.print(&quot;@%d&quot;, bci);
1663     // To print linenumbers instead of bci use: m-&gt;line_number_from_bci(bci)
1664   }
1665   NamedCounter* c;
1666   if (tag == NamedCounter::BiasedLockingCounter) {
1667     c = new BiasedLockingNamedCounter(st.as_string());
1668   } else if (tag == NamedCounter::RTMLockingCounter) {
1669     c = new RTMLockingNamedCounter(st.as_string());
1670   } else {
1671     c = new NamedCounter(st.as_string(), tag);
1672   }
1673 
1674   // atomically add the new counter to the head of the list.  We only
1675   // add counters so this is safe.
1676   NamedCounter* head;
1677   do {
1678     c-&gt;set_next(NULL);
1679     head = _named_counters;
1680     c-&gt;set_next(head);
<span class="line-modified">1681   } while (Atomic::cmpxchg(&amp;_named_counters, head, c) != head);</span>
1682   return c;
1683 }
1684 
1685 int trace_exception_counter = 0;
1686 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
1687   trace_exception_counter++;
1688   stringStream tempst;
1689 
1690   tempst.print(&quot;%d [Exception (%s): &quot;, trace_exception_counter, msg);
1691   exception_oop-&gt;print_value_on(&amp;tempst);
1692   tempst.print(&quot; in &quot;);
1693   CodeBlob* blob = CodeCache::find_blob(exception_pc);
1694   if (blob-&gt;is_compiled()) {
1695     CompiledMethod* cm = blob-&gt;as_compiled_method_or_null();
1696     cm-&gt;method()-&gt;print_value_on(&amp;tempst);
1697   } else if (blob-&gt;is_runtime_stub()) {
1698     tempst.print(&quot;&lt;runtime-stub&gt;&quot;);
1699   } else {
1700     tempst.print(&quot;&lt;unknown&gt;&quot;);
1701   }
</pre>
</td>
</tr>
</table>
<center><a href="rootnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="runtime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
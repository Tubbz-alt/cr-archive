<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;compiler/oopMap.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/block.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/chaitin.hpp&quot;
  35 #include &quot;opto/coalesce.hpp&quot;
  36 #include &quot;opto/connode.hpp&quot;
  37 #include &quot;opto/idealGraphPrinter.hpp&quot;
  38 #include &quot;opto/indexSet.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 
  46 #ifndef PRODUCT
  47 void LRG::dump() const {
  48   ttyLocker ttyl;
  49   tty-&gt;print(&quot;%d &quot;,num_regs());
  50   _mask.dump();
  51   if( _msize_valid ) {
  52     if( mask_size() == compute_mask_size() ) tty-&gt;print(&quot;, #%d &quot;,_mask_size);
  53     else tty-&gt;print(&quot;, #!!!_%d_vs_%d &quot;,_mask_size,_mask.Size());
  54   } else {
  55     tty-&gt;print(&quot;, #?(%d) &quot;,_mask.Size());
  56   }
  57 
  58   tty-&gt;print(&quot;EffDeg: &quot;);
  59   if( _degree_valid ) tty-&gt;print( &quot;%d &quot;, _eff_degree );
  60   else tty-&gt;print(&quot;? &quot;);
  61 
  62   if( is_multidef() ) {
  63     tty-&gt;print(&quot;MultiDef &quot;);
  64     if (_defs != NULL) {
  65       tty-&gt;print(&quot;(&quot;);
  66       for (int i = 0; i &lt; _defs-&gt;length(); i++) {
  67         tty-&gt;print(&quot;N%d &quot;, _defs-&gt;at(i)-&gt;_idx);
  68       }
  69       tty-&gt;print(&quot;) &quot;);
  70     }
  71   }
  72   else if( _def == 0 ) tty-&gt;print(&quot;Dead &quot;);
  73   else tty-&gt;print(&quot;Def: N%d &quot;,_def-&gt;_idx);
  74 
  75   tty-&gt;print(&quot;Cost:%4.2g Area:%4.2g Score:%4.2g &quot;,_cost,_area, score());
  76   // Flags
  77   if( _is_oop ) tty-&gt;print(&quot;Oop &quot;);
  78   if( _is_float ) tty-&gt;print(&quot;Float &quot;);
  79   if( _is_vector ) tty-&gt;print(&quot;Vector &quot;);
  80   if( _was_spilled1 ) tty-&gt;print(&quot;Spilled &quot;);
  81   if( _was_spilled2 ) tty-&gt;print(&quot;Spilled2 &quot;);
  82   if( _direct_conflict ) tty-&gt;print(&quot;Direct_conflict &quot;);
  83   if( _fat_proj ) tty-&gt;print(&quot;Fat &quot;);
  84   if( _was_lo ) tty-&gt;print(&quot;Lo &quot;);
  85   if( _has_copy ) tty-&gt;print(&quot;Copy &quot;);
  86   if( _at_risk ) tty-&gt;print(&quot;Risk &quot;);
  87 
  88   if( _must_spill ) tty-&gt;print(&quot;Must_spill &quot;);
  89   if( _is_bound ) tty-&gt;print(&quot;Bound &quot;);
  90   if( _msize_valid ) {
  91     if( _degree_valid &amp;&amp; lo_degree() ) tty-&gt;print(&quot;Trivial &quot;);
  92   }
  93 
  94   tty-&gt;cr();
  95 }
  96 #endif
  97 
  98 // Compute score from cost and area.  Low score is best to spill.
  99 static double raw_score( double cost, double area ) {
 100   return cost - (area*RegisterCostAreaRatio) * 1.52588e-5;
 101 }
 102 
 103 double LRG::score() const {
 104   // Scale _area by RegisterCostAreaRatio/64K then subtract from cost.
 105   // Bigger area lowers score, encourages spilling this live range.
 106   // Bigger cost raise score, prevents spilling this live range.
 107   // (Note: 1/65536 is the magic constant below; I dont trust the C optimizer
 108   // to turn a divide by a constant into a multiply by the reciprical).
 109   double score = raw_score( _cost, _area);
 110 
 111   // Account for area.  Basically, LRGs covering large areas are better
 112   // to spill because more other LRGs get freed up.
 113   if( _area == 0.0 )            // No area?  Then no progress to spill
 114     return 1e35;
 115 
 116   if( _was_spilled2 )           // If spilled once before, we are unlikely
 117     return score + 1e30;        // to make progress again.
 118 
 119   if( _cost &gt;= _area*3.0 )      // Tiny area relative to cost
 120     return score + 1e17;        // Probably no progress to spill
 121 
 122   if( (_cost+_cost) &gt;= _area*3.0 ) // Small area relative to cost
 123     return score + 1e10;        // Likely no progress to spill
 124 
 125   return score;
 126 }
 127 
 128 #define NUMBUCKS 3
 129 
 130 // Straight out of Tarjan&#39;s union-find algorithm
 131 uint LiveRangeMap::find_compress(uint lrg) {
 132   uint cur = lrg;
 133   uint next = _uf_map.at(cur);
 134   while (next != cur) { // Scan chain of equivalences
 135     assert( next &lt; cur, &quot;always union smaller&quot;);
 136     cur = next; // until find a fixed-point
 137     next = _uf_map.at(cur);
 138   }
 139 
 140   // Core of union-find algorithm: update chain of
 141   // equivalences to be equal to the root.
 142   while (lrg != next) {
 143     uint tmp = _uf_map.at(lrg);
 144     _uf_map.at_put(lrg, next);
 145     lrg = tmp;
 146   }
 147   return lrg;
 148 }
 149 
 150 // Reset the Union-Find map to identity
 151 void LiveRangeMap::reset_uf_map(uint max_lrg_id) {
 152   _max_lrg_id= max_lrg_id;
 153   // Force the Union-Find mapping to be at least this large
 154   _uf_map.at_put_grow(_max_lrg_id, 0);
 155   // Initialize it to be the ID mapping.
 156   for (uint i = 0; i &lt; _max_lrg_id; ++i) {
 157     _uf_map.at_put(i, i);
 158   }
 159 }
 160 
 161 // Make all Nodes map directly to their final live range; no need for
 162 // the Union-Find mapping after this call.
 163 void LiveRangeMap::compress_uf_map_for_nodes() {
 164   // For all Nodes, compress mapping
 165   uint unique = _names.length();
 166   for (uint i = 0; i &lt; unique; ++i) {
 167     uint lrg = _names.at(i);
 168     uint compressed_lrg = find(lrg);
 169     if (lrg != compressed_lrg) {
 170       _names.at_put(i, compressed_lrg);
 171     }
 172   }
 173 }
 174 
 175 // Like Find above, but no path compress, so bad asymptotic behavior
 176 uint LiveRangeMap::find_const(uint lrg) const {
 177   if (!lrg) {
 178     return lrg; // Ignore the zero LRG
 179   }
 180 
 181   // Off the end?  This happens during debugging dumps when you got
 182   // brand new live ranges but have not told the allocator yet.
 183   if (lrg &gt;= _max_lrg_id) {
 184     return lrg;
 185   }
 186 
 187   uint next = _uf_map.at(lrg);
 188   while (next != lrg) { // Scan chain of equivalences
 189     assert(next &lt; lrg, &quot;always union smaller&quot;);
 190     lrg = next; // until find a fixed-point
 191     next = _uf_map.at(lrg);
 192   }
 193   return next;
 194 }
 195 
 196 PhaseChaitin::PhaseChaitin(uint unique, PhaseCFG &amp;cfg, Matcher &amp;matcher, bool scheduling_info_generated)
 197   : PhaseRegAlloc(unique, cfg, matcher,
 198 #ifndef PRODUCT
 199        print_chaitin_statistics
 200 #else
 201        NULL
 202 #endif
 203        )
 204   , _live(0)
 205   , _spilled_once(Thread::current()-&gt;resource_area())
 206   , _spilled_twice(Thread::current()-&gt;resource_area())
 207   , _lo_degree(0), _lo_stk_degree(0), _hi_degree(0), _simplified(0)
 208   , _oldphi(unique)
 209 #ifndef PRODUCT
 210   , _trace_spilling(C-&gt;directive()-&gt;TraceSpillingOption)
 211 #endif
 212   , _lrg_map(Thread::current()-&gt;resource_area(), unique)
 213   , _scheduling_info_generated(scheduling_info_generated)
 214   , _sched_int_pressure(0, INTPRESSURE)
 215   , _sched_float_pressure(0, FLOATPRESSURE)
 216   , _scratch_int_pressure(0, INTPRESSURE)
 217   , _scratch_float_pressure(0, FLOATPRESSURE)
 218 {
 219   Compile::TracePhase tp(&quot;ctorChaitin&quot;, &amp;timers[_t_ctorChaitin]);
 220 
 221   _high_frequency_lrg = MIN2(double(OPTO_LRG_HIGH_FREQ), _cfg.get_outer_loop_frequency());
 222 
 223   // Build a list of basic blocks, sorted by frequency
 224   _blks = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 225   // Experiment with sorting strategies to speed compilation
 226   double  cutoff = BLOCK_FREQUENCY(1.0); // Cutoff for high frequency bucket
 227   Block **buckets[NUMBUCKS];             // Array of buckets
 228   uint    buckcnt[NUMBUCKS];             // Array of bucket counters
 229   double  buckval[NUMBUCKS];             // Array of bucket value cutoffs
 230   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 231     buckets[i] = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 232     buckcnt[i] = 0;
 233     // Bump by three orders of magnitude each time
 234     cutoff *= 0.001;
 235     buckval[i] = cutoff;
 236     for (uint j = 0; j &lt; _cfg.number_of_blocks(); j++) {
 237       buckets[i][j] = NULL;
 238     }
 239   }
 240   // Sort blocks into buckets
 241   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 242     for (uint j = 0; j &lt; NUMBUCKS; j++) {
 243       if ((j == NUMBUCKS - 1) || (_cfg.get_block(i)-&gt;_freq &gt; buckval[j])) {
 244         // Assign block to end of list for appropriate bucket
 245         buckets[j][buckcnt[j]++] = _cfg.get_block(i);
 246         break; // kick out of inner loop
 247       }
 248     }
 249   }
 250   // Dump buckets into final block array
 251   uint blkcnt = 0;
 252   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 253     for (uint j = 0; j &lt; buckcnt[i]; j++) {
 254       _blks[blkcnt++] = buckets[i][j];
 255     }
 256   }
 257 
 258   assert(blkcnt == _cfg.number_of_blocks(), &quot;Block array not totally filled&quot;);
 259 }
 260 
 261 // union 2 sets together.
 262 void PhaseChaitin::Union( const Node *src_n, const Node *dst_n ) {
 263   uint src = _lrg_map.find(src_n);
 264   uint dst = _lrg_map.find(dst_n);
 265   assert(src, &quot;&quot;);
 266   assert(dst, &quot;&quot;);
 267   assert(src &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 268   assert(dst &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 269   assert(src &lt; dst, &quot;always union smaller&quot;);
 270   _lrg_map.uf_map(dst, src);
 271 }
 272 
 273 void PhaseChaitin::new_lrg(const Node *x, uint lrg) {
 274   // Make the Node-&gt;LRG mapping
 275   _lrg_map.extend(x-&gt;_idx,lrg);
 276   // Make the Union-Find mapping an identity function
 277   _lrg_map.uf_extend(lrg, lrg);
 278 }
 279 
 280 
 281 int PhaseChaitin::clone_projs(Block* b, uint idx, Node* orig, Node* copy, uint&amp; max_lrg_id) {
 282   assert(b-&gt;find_node(copy) == (idx - 1), &quot;incorrect insert index for copy kill projections&quot;);
 283   DEBUG_ONLY( Block* borig = _cfg.get_block_for_node(orig); )
 284   int found_projs = 0;
 285   uint cnt = orig-&gt;outcnt();
 286   for (uint i = 0; i &lt; cnt; i++) {
 287     Node* proj = orig-&gt;raw_out(i);
 288     if (proj-&gt;is_MachProj()) {
 289       assert(proj-&gt;outcnt() == 0, &quot;only kill projections are expected here&quot;);
 290       assert(_cfg.get_block_for_node(proj) == borig, &quot;incorrect block for kill projections&quot;);
 291       found_projs++;
 292       // Copy kill projections after the cloned node
 293       Node* kills = proj-&gt;clone();
 294       kills-&gt;set_req(0, copy);
 295       b-&gt;insert_node(kills, idx++);
 296       _cfg.map_node_to_block(kills, b);
 297       new_lrg(kills, max_lrg_id++);
 298     }
 299   }
 300   return found_projs;
 301 }
 302 
 303 // Renumber the live ranges to compact them.  Makes the IFG smaller.
 304 void PhaseChaitin::compact() {
 305   Compile::TracePhase tp(&quot;chaitinCompact&quot;, &amp;timers[_t_chaitinCompact]);
 306 
 307   // Current the _uf_map contains a series of short chains which are headed
 308   // by a self-cycle.  All the chains run from big numbers to little numbers.
 309   // The Find() call chases the chains &amp; shortens them for the next Find call.
 310   // We are going to change this structure slightly.  Numbers above a moving
 311   // wave &#39;i&#39; are unchanged.  Numbers below &#39;j&#39; point directly to their
 312   // compacted live range with no further chaining.  There are no chains or
 313   // cycles below &#39;i&#39;, so the Find call no longer works.
 314   uint j=1;
 315   uint i;
 316   for (i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
 317     uint lr = _lrg_map.uf_live_range_id(i);
 318     // Ignore unallocated live ranges
 319     if (!lr) {
 320       continue;
 321     }
 322     assert(lr &lt;= i, &quot;&quot;);
 323     _lrg_map.uf_map(i, ( lr == i ) ? j++ : _lrg_map.uf_live_range_id(lr));
 324   }
 325   // Now change the Node-&gt;LR mapping to reflect the compacted names
 326   uint unique = _lrg_map.size();
 327   for (i = 0; i &lt; unique; i++) {
 328     uint lrg_id = _lrg_map.live_range_id(i);
 329     _lrg_map.map(i, _lrg_map.uf_live_range_id(lrg_id));
 330   }
 331 
 332   // Reset the Union-Find mapping
 333   _lrg_map.reset_uf_map(j);
 334 }
 335 
 336 void PhaseChaitin::Register_Allocate() {
 337 
 338   // Above the OLD FP (and in registers) are the incoming arguments.  Stack
 339   // slots in this area are called &quot;arg_slots&quot;.  Above the NEW FP (and in
 340   // registers) is the outgoing argument area; above that is the spill/temp
 341   // area.  These are all &quot;frame_slots&quot;.  Arg_slots start at the zero
 342   // stack_slots and count up to the known arg_size.  Frame_slots start at
 343   // the stack_slot #arg_size and go up.  After allocation I map stack
 344   // slots to actual offsets.  Stack-slots in the arg_slot area are biased
 345   // by the frame_size; stack-slots in the frame_slot area are biased by 0.
 346 
 347   _trip_cnt = 0;
 348   _alternate = 0;
 349   _matcher._allocation_started = true;
 350 
 351   ResourceArea split_arena(mtCompiler);     // Arena for Split local resources
 352   ResourceArea live_arena(mtCompiler);      // Arena for liveness &amp; IFG info
 353   ResourceMark rm(&amp;live_arena);
 354 
 355   // Need live-ness for the IFG; need the IFG for coalescing.  If the
 356   // liveness is JUST for coalescing, then I can get some mileage by renaming
 357   // all copy-related live ranges low and then using the max copy-related
 358   // live range as a cut-off for LIVE and the IFG.  In other words, I can
 359   // build a subset of LIVE and IFG just for copies.
 360   PhaseLive live(_cfg, _lrg_map.names(), &amp;live_arena, false);
 361 
 362   // Need IFG for coalescing and coloring
 363   PhaseIFG ifg(&amp;live_arena);
 364   _ifg = &amp;ifg;
 365 
 366   // Come out of SSA world to the Named world.  Assign (virtual) registers to
 367   // Nodes.  Use the same register for all inputs and the output of PhiNodes
 368   // - effectively ending SSA form.  This requires either coalescing live
 369   // ranges or inserting copies.  For the moment, we insert &quot;virtual copies&quot;
 370   // - we pretend there is a copy prior to each Phi in predecessor blocks.
 371   // We will attempt to coalesce such &quot;virtual copies&quot; before we manifest
 372   // them for real.
 373   de_ssa();
 374 
 375 #ifdef ASSERT
 376   // Veify the graph before RA.
 377   verify(&amp;live_arena);
 378 #endif
 379 
 380   {
 381     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 382     _live = NULL;                 // Mark live as being not available
 383     rm.reset_to_mark();           // Reclaim working storage
 384     IndexSet::reset_memory(C, &amp;live_arena);
 385     ifg.init(_lrg_map.max_lrg_id()); // Empty IFG
 386     gather_lrg_masks( false );    // Collect LRG masks
 387     live.compute(_lrg_map.max_lrg_id()); // Compute liveness
 388     _live = &amp;live;                // Mark LIVE as being available
 389   }
 390 
 391   // Base pointers are currently &quot;used&quot; by instructions which define new
 392   // derived pointers.  This makes base pointers live up to the where the
 393   // derived pointer is made, but not beyond.  Really, they need to be live
 394   // across any GC point where the derived value is live.  So this code looks
 395   // at all the GC points, and &quot;stretches&quot; the live range of any base pointer
 396   // to the GC point.
 397   if (stretch_base_pointer_live_ranges(&amp;live_arena)) {
 398     Compile::TracePhase tp(&quot;computeLive (sbplr)&quot;, &amp;timers[_t_computeLive]);
 399     // Since some live range stretched, I need to recompute live
 400     _live = NULL;
 401     rm.reset_to_mark();         // Reclaim working storage
 402     IndexSet::reset_memory(C, &amp;live_arena);
 403     ifg.init(_lrg_map.max_lrg_id());
 404     gather_lrg_masks(false);
 405     live.compute(_lrg_map.max_lrg_id());
 406     _live = &amp;live;
 407   }
 408   // Create the interference graph using virtual copies
 409   build_ifg_virtual();  // Include stack slots this time
 410 
 411   // The IFG is/was triangular.  I am &#39;squaring it up&#39; so Union can run
 412   // faster.  Union requires a &#39;for all&#39; operation which is slow on the
 413   // triangular adjacency matrix (quick reminder: the IFG is &#39;sparse&#39; -
 414   // meaning I can visit all the Nodes neighbors less than a Node in time
 415   // O(# of neighbors), but I have to visit all the Nodes greater than a
 416   // given Node and search them for an instance, i.e., time O(#MaxLRG)).
 417   _ifg-&gt;SquareUp();
 418 
 419   // Aggressive (but pessimistic) copy coalescing.
 420   // This pass works on virtual copies.  Any virtual copies which are not
 421   // coalesced get manifested as actual copies
 422   {
 423     Compile::TracePhase tp(&quot;chaitinCoalesce1&quot;, &amp;timers[_t_chaitinCoalesce1]);
 424 
 425     PhaseAggressiveCoalesce coalesce(*this);
 426     coalesce.coalesce_driver();
 427     // Insert un-coalesced copies.  Visit all Phis.  Where inputs to a Phi do
 428     // not match the Phi itself, insert a copy.
 429     coalesce.insert_copies(_matcher);
 430     if (C-&gt;failing()) {
 431       return;
 432     }
 433   }
 434 
 435   // After aggressive coalesce, attempt a first cut at coloring.
 436   // To color, we need the IFG and for that we need LIVE.
 437   {
 438     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 439     _live = NULL;
 440     rm.reset_to_mark();           // Reclaim working storage
 441     IndexSet::reset_memory(C, &amp;live_arena);
 442     ifg.init(_lrg_map.max_lrg_id());
 443     gather_lrg_masks( true );
 444     live.compute(_lrg_map.max_lrg_id());
 445     _live = &amp;live;
 446   }
 447 
 448   // Build physical interference graph
 449   uint must_spill = 0;
 450   must_spill = build_ifg_physical(&amp;live_arena);
 451   // If we have a guaranteed spill, might as well spill now
 452   if (must_spill) {
 453     if(!_lrg_map.max_lrg_id()) {
 454       return;
 455     }
 456     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit)
 457     C-&gt;check_node_count(10*must_spill, &quot;out of nodes before split&quot;);
 458     if (C-&gt;failing()) {
 459       return;
 460     }
 461 
 462     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 463     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 464     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 465     // or we failed to split
 466     C-&gt;check_node_count(2*NodeLimitFudgeFactor, &quot;out of nodes after physical split&quot;);
 467     if (C-&gt;failing()) {
 468       return;
 469     }
 470 
 471     NOT_PRODUCT(C-&gt;verify_graph_edges();)
 472 
 473     compact();                  // Compact LRGs; return new lower max lrg
 474 
 475     {
 476       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 477       _live = NULL;
 478       rm.reset_to_mark();         // Reclaim working storage
 479       IndexSet::reset_memory(C, &amp;live_arena);
 480       ifg.init(_lrg_map.max_lrg_id()); // Build a new interference graph
 481       gather_lrg_masks( true );   // Collect intersect mask
 482       live.compute(_lrg_map.max_lrg_id()); // Compute LIVE
 483       _live = &amp;live;
 484     }
 485     build_ifg_physical(&amp;live_arena);
 486     _ifg-&gt;SquareUp();
 487     _ifg-&gt;Compute_Effective_Degree();
 488     // Only do conservative coalescing if requested
 489     if (OptoCoalesce) {
 490       Compile::TracePhase tp(&quot;chaitinCoalesce2&quot;, &amp;timers[_t_chaitinCoalesce2]);
 491       // Conservative (and pessimistic) copy coalescing of those spills
 492       PhaseConservativeCoalesce coalesce(*this);
 493       // If max live ranges greater than cutoff, don&#39;t color the stack.
 494       // This cutoff can be larger than below since it is only done once.
 495       coalesce.coalesce_driver();
 496     }
 497     _lrg_map.compress_uf_map_for_nodes();
 498 
 499 #ifdef ASSERT
 500     verify(&amp;live_arena, true);
 501 #endif
 502   } else {
 503     ifg.SquareUp();
 504     ifg.Compute_Effective_Degree();
 505 #ifdef ASSERT
 506     set_was_low();
 507 #endif
 508   }
 509 
 510   // Prepare for Simplify &amp; Select
 511   cache_lrg_info();           // Count degree of LRGs
 512 
 513   // Simplify the InterFerence Graph by removing LRGs of low degree.
 514   // LRGs of low degree are trivially colorable.
 515   Simplify();
 516 
 517   // Select colors by re-inserting LRGs back into the IFG in reverse order.
 518   // Return whether or not something spills.
 519   uint spills = Select( );
 520 
 521   // If we spill, split and recycle the entire thing
 522   while( spills ) {
 523     if( _trip_cnt++ &gt; 24 ) {
 524       DEBUG_ONLY( dump_for_spill_split_recycle(); )
 525       if( _trip_cnt &gt; 27 ) {
 526         C-&gt;record_method_not_compilable(&quot;failed spill-split-recycle sanity check&quot;);
 527         return;
 528       }
 529     }
 530 
 531     if (!_lrg_map.max_lrg_id()) {
 532       return;
 533     }
 534     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 535     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 536     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 537     C-&gt;check_node_count(2 * NodeLimitFudgeFactor, &quot;out of nodes after split&quot;);
 538     if (C-&gt;failing()) {
 539       return;
 540     }
 541 
 542     compact(); // Compact LRGs; return new lower max lrg
 543 
 544     // Nuke the live-ness and interference graph and LiveRanGe info
 545     {
 546       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 547       _live = NULL;
 548       rm.reset_to_mark();         // Reclaim working storage
 549       IndexSet::reset_memory(C, &amp;live_arena);
 550       ifg.init(_lrg_map.max_lrg_id());
 551 
 552       // Create LiveRanGe array.
 553       // Intersect register masks for all USEs and DEFs
 554       gather_lrg_masks(true);
 555       live.compute(_lrg_map.max_lrg_id());
 556       _live = &amp;live;
 557     }
 558     must_spill = build_ifg_physical(&amp;live_arena);
 559     _ifg-&gt;SquareUp();
 560     _ifg-&gt;Compute_Effective_Degree();
 561 
 562     // Only do conservative coalescing if requested
 563     if (OptoCoalesce) {
 564       Compile::TracePhase tp(&quot;chaitinCoalesce3&quot;, &amp;timers[_t_chaitinCoalesce3]);
 565       // Conservative (and pessimistic) copy coalescing
 566       PhaseConservativeCoalesce coalesce(*this);
 567       // Check for few live ranges determines how aggressive coalesce is.
 568       coalesce.coalesce_driver();
 569     }
 570     _lrg_map.compress_uf_map_for_nodes();
 571 #ifdef ASSERT
 572     verify(&amp;live_arena, true);
 573 #endif
 574     cache_lrg_info();           // Count degree of LRGs
 575 
 576     // Simplify the InterFerence Graph by removing LRGs of low degree.
 577     // LRGs of low degree are trivially colorable.
 578     Simplify();
 579 
 580     // Select colors by re-inserting LRGs back into the IFG in reverse order.
 581     // Return whether or not something spills.
 582     spills = Select();
 583   }
 584 
 585   // Count number of Simplify-Select trips per coloring success.
 586   _allocator_attempts += _trip_cnt + 1;
 587   _allocator_successes += 1;
 588 
 589   // Peephole remove copies
 590   post_allocate_copy_removal();
 591 
 592   // Merge multidefs if multiple defs representing the same value are used in a single block.
 593   merge_multidefs();
 594 
 595 #ifdef ASSERT
 596   // Veify the graph after RA.
 597   verify(&amp;live_arena);
 598 #endif
 599 
 600   // max_reg is past the largest *register* used.
 601   // Convert that to a frame_slot number.
 602   if (_max_reg &lt;= _matcher._new_SP) {
 603     _framesize = C-&gt;out_preserve_stack_slots();
 604   }
 605   else {
 606     _framesize = _max_reg -_matcher._new_SP;
 607   }
 608   assert((int)(_matcher._new_SP+_framesize) &gt;= (int)_matcher._out_arg_limit, &quot;framesize must be large enough&quot;);
 609 
 610   // This frame must preserve the required fp alignment
 611   _framesize = align_up(_framesize, Matcher::stack_alignment_in_slots());
 612   assert(_framesize &lt;= 1000000, &quot;sanity check&quot;);
 613 #ifndef PRODUCT
 614   _total_framesize += _framesize;
 615   if ((int)_framesize &gt; _max_framesize) {
 616     _max_framesize = _framesize;
 617   }
 618 #endif
 619 
 620   // Convert CISC spills
 621   fixup_spills();
 622 
 623   // Log regalloc results
 624   CompileLog* log = Compile::current()-&gt;log();
 625   if (log != NULL) {
 626     log-&gt;elem(&quot;regalloc attempts=&#39;%d&#39; success=&#39;%d&#39;&quot;, _trip_cnt, !C-&gt;failing());
 627   }
 628 
 629   if (C-&gt;failing()) {
 630     return;
 631   }
 632 
 633   NOT_PRODUCT(C-&gt;verify_graph_edges();)
 634 
 635   // Move important info out of the live_arena to longer lasting storage.
 636   alloc_node_regs(_lrg_map.size());
 637   for (uint i=0; i &lt; _lrg_map.size(); i++) {
 638     if (_lrg_map.live_range_id(i)) { // Live range associated with Node?
 639       LRG &amp;lrg = lrgs(_lrg_map.live_range_id(i));
 640       if (!lrg.alive()) {
 641         set_bad(i);
 642       } else if (lrg.num_regs() == 1) {
 643         set1(i, lrg.reg());
 644       } else {                  // Must be a register-set
 645         if (!lrg._fat_proj) {   // Must be aligned adjacent register set
 646           // Live ranges record the highest register in their mask.
 647           // We want the low register for the AD file writer&#39;s convenience.
 648           OptoReg::Name hi = lrg.reg(); // Get hi register
 649           OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); // Find lo
 650           // We have to use pair [lo,lo+1] even for wide vectors because
 651           // the rest of code generation works only with pairs. It is safe
 652           // since for registers encoding only &#39;lo&#39; is used.
 653           // Second reg from pair is used in ScheduleAndBundle on SPARC where
 654           // vector max size is 8 which corresponds to registers pair.
 655           // It is also used in BuildOopMaps but oop operations are not
 656           // vectorized.
 657           set2(i, lo);
 658         } else {                // Misaligned; extract 2 bits
 659           OptoReg::Name hi = lrg.reg(); // Get hi register
 660           lrg.Remove(hi);       // Yank from mask
 661           int lo = lrg.mask().find_first_elem(); // Find lo
 662           set_pair(i, hi, lo);
 663         }
 664       }
 665       if( lrg._is_oop ) _node_oops.set(i);
 666     } else {
 667       set_bad(i);
 668     }
 669   }
 670 
 671   // Done!
 672   _live = NULL;
 673   _ifg = NULL;
 674   C-&gt;set_indexSet_arena(NULL);  // ResourceArea is at end of scope
 675 }
 676 
 677 void PhaseChaitin::de_ssa() {
 678   // Set initial Names for all Nodes.  Most Nodes get the virtual register
 679   // number.  A few get the ZERO live range number.  These do not
 680   // get allocated, but instead rely on correct scheduling to ensure that
 681   // only one instance is simultaneously live at a time.
 682   uint lr_counter = 1;
 683   for( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 684     Block* block = _cfg.get_block(i);
 685     uint cnt = block-&gt;number_of_nodes();
 686 
 687     // Handle all the normal Nodes in the block
 688     for( uint j = 0; j &lt; cnt; j++ ) {
 689       Node *n = block-&gt;get_node(j);
 690       // Pre-color to the zero live range, or pick virtual register
 691       const RegMask &amp;rm = n-&gt;out_RegMask();
 692       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? lr_counter++ : 0);
 693     }
 694   }
 695 
 696   // Reset the Union-Find mapping to be identity
 697   _lrg_map.reset_uf_map(lr_counter);
 698 }
 699 
 700 void PhaseChaitin::mark_ssa() {
 701   // Use ssa names to populate the live range maps or if no mask
 702   // is available, use the 0 entry.
 703   uint max_idx = 0;
 704   for ( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 705     Block* block = _cfg.get_block(i);
 706     uint cnt = block-&gt;number_of_nodes();
 707 
 708     // Handle all the normal Nodes in the block
 709     for ( uint j = 0; j &lt; cnt; j++ ) {
 710       Node *n = block-&gt;get_node(j);
 711       // Pre-color to the zero live range, or pick virtual register
 712       const RegMask &amp;rm = n-&gt;out_RegMask();
 713       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? n-&gt;_idx : 0);
 714       max_idx = (n-&gt;_idx &gt; max_idx) ? n-&gt;_idx : max_idx;
 715     }
 716   }
 717   _lrg_map.set_max_lrg_id(max_idx+1);
 718 
 719   // Reset the Union-Find mapping to be identity
 720   _lrg_map.reset_uf_map(max_idx+1);
 721 }
 722 
 723 
 724 // Gather LiveRanGe information, including register masks.  Modification of
 725 // cisc spillable in_RegMasks should not be done before AggressiveCoalesce.
 726 void PhaseChaitin::gather_lrg_masks( bool after_aggressive ) {
 727 
 728   // Nail down the frame pointer live range
 729   uint fp_lrg = _lrg_map.live_range_id(_cfg.get_root_node()-&gt;in(1)-&gt;in(TypeFunc::FramePtr));
 730   lrgs(fp_lrg)._cost += 1e12;   // Cost is infinite
 731 
 732   // For all blocks
 733   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 734     Block* block = _cfg.get_block(i);
 735 
 736     // For all instructions
 737     for (uint j = 1; j &lt; block-&gt;number_of_nodes(); j++) {
 738       Node* n = block-&gt;get_node(j);
 739       uint input_edge_start =1; // Skip control most nodes
 740       bool is_machine_node = false;
 741       if (n-&gt;is_Mach()) {
 742         is_machine_node = true;
 743         input_edge_start = n-&gt;as_Mach()-&gt;oper_input_base();
 744       }
 745       uint idx = n-&gt;is_Copy();
 746 
 747       // Get virtual register number, same as LiveRanGe index
 748       uint vreg = _lrg_map.live_range_id(n);
 749       LRG&amp; lrg = lrgs(vreg);
 750       if (vreg) {              // No vreg means un-allocable (e.g. memory)
 751 
 752         // Check for float-vs-int live range (used in register-pressure
 753         // calculations)
 754         const Type *n_type = n-&gt;bottom_type();
 755         if (n_type-&gt;is_floatingpoint()) {
 756           lrg._is_float = 1;
 757         }
 758 
 759         // Check for twice prior spilling.  Once prior spilling might have
 760         // spilled &#39;soft&#39;, 2nd prior spill should have spilled &#39;hard&#39; and
 761         // further spilling is unlikely to make progress.
 762         if (_spilled_once.test(n-&gt;_idx)) {
 763           lrg._was_spilled1 = 1;
 764           if (_spilled_twice.test(n-&gt;_idx)) {
 765             lrg._was_spilled2 = 1;
 766           }
 767         }
 768 
 769 #ifndef PRODUCT
 770         // Collect bits not used by product code, but which may be useful for
 771         // debugging.
 772 
 773         // Collect has-copy bit
 774         if (idx) {
 775           lrg._has_copy = 1;
 776           uint clidx = _lrg_map.live_range_id(n-&gt;in(idx));
 777           LRG&amp; copy_src = lrgs(clidx);
 778           copy_src._has_copy = 1;
 779         }
 780 
 781         if (trace_spilling() &amp;&amp; lrg._def != NULL) {
 782           // collect defs for MultiDef printing
 783           if (lrg._defs == NULL) {
 784             lrg._defs = new (_ifg-&gt;_arena) GrowableArray&lt;Node*&gt;(_ifg-&gt;_arena, 2, 0, NULL);
 785             lrg._defs-&gt;append(lrg._def);
 786           }
 787           lrg._defs-&gt;append(n);
 788         }
 789 #endif
 790 
 791         // Check for a single def LRG; these can spill nicely
 792         // via rematerialization.  Flag as NULL for no def found
 793         // yet, or &#39;n&#39; for single def or -1 for many defs.
 794         lrg._def = lrg._def ? NodeSentinel : n;
 795 
 796         // Limit result register mask to acceptable registers
 797         const RegMask &amp;rm = n-&gt;out_RegMask();
 798         lrg.AND( rm );
 799 
 800         uint ireg = n-&gt;ideal_reg();
 801         assert( !n-&gt;bottom_type()-&gt;isa_oop_ptr() || ireg == Op_RegP,
 802                 &quot;oops must be in Op_RegP&#39;s&quot; );
 803 
 804         // Check for vector live range (only if vector register is used).
 805         // On SPARC vector uses RegD which could be misaligned so it is not
 806         // processes as vector in RA.
 807         if (RegMask::is_vector(ireg))
 808           lrg._is_vector = 1;
 809         assert(n_type-&gt;isa_vect() == NULL || lrg._is_vector || ireg == Op_RegD || ireg == Op_RegL,
 810                &quot;vector must be in vector registers&quot;);
 811 
 812         // Check for bound register masks
 813         const RegMask &amp;lrgmask = lrg.mask();
 814         if (lrgmask.is_bound(ireg)) {
 815           lrg._is_bound = 1;
 816         }
 817 
 818         // Check for maximum frequency value
 819         if (lrg._maxfreq &lt; block-&gt;_freq) {
 820           lrg._maxfreq = block-&gt;_freq;
 821         }
 822 
 823         // Check for oop-iness, or long/double
 824         // Check for multi-kill projection
 825         switch (ireg) {
 826         case MachProjNode::fat_proj:
 827           // Fat projections have size equal to number of registers killed
 828           lrg.set_num_regs(rm.Size());
 829           lrg.set_reg_pressure(lrg.num_regs());
 830           lrg._fat_proj = 1;
 831           lrg._is_bound = 1;
 832           break;
 833         case Op_RegP:
 834 #ifdef _LP64
 835           lrg.set_num_regs(2);  // Size is 2 stack words
 836 #else
 837           lrg.set_num_regs(1);  // Size is 1 stack word
 838 #endif
 839           // Register pressure is tracked relative to the maximum values
 840           // suggested for that platform, INTPRESSURE and FLOATPRESSURE,
 841           // and relative to other types which compete for the same regs.
 842           //
 843           // The following table contains suggested values based on the
 844           // architectures as defined in each .ad file.
 845           // INTPRESSURE and FLOATPRESSURE may be tuned differently for
 846           // compile-speed or performance.
 847           // Note1:
 848           // SPARC and SPARCV9 reg_pressures are at 2 instead of 1
 849           // since .ad registers are defined as high and low halves.
 850           // These reg_pressure values remain compatible with the code
 851           // in is_high_pressure() which relates get_invalid_mask_size(),
 852           // Block::_reg_pressure and INTPRESSURE, FLOATPRESSURE.
 853           // Note2:
 854           // SPARC -d32 has 24 registers available for integral values,
 855           // but only 10 of these are safe for 64-bit longs.
 856           // Using set_reg_pressure(2) for both int and long means
 857           // the allocator will believe it can fit 26 longs into
 858           // registers.  Using 2 for longs and 1 for ints means the
 859           // allocator will attempt to put 52 integers into registers.
 860           // The settings below limit this problem to methods with
 861           // many long values which are being run on 32-bit SPARC.
 862           //
 863           // ------------------- reg_pressure --------------------
 864           // Each entry is reg_pressure_per_value,number_of_regs
 865           //         RegL  RegI  RegFlags   RegF RegD    INTPRESSURE  FLOATPRESSURE
 866           // IA32     2     1     1          1    1          6           6
 867           // IA64     1     1     1          1    1         50          41
 868           // SPARC    2     2     2          2    2         48 (24)     52 (26)
 869           // SPARCV9  2     2     2          2    2         48 (24)     52 (26)
 870           // AMD64    1     1     1          1    1         14          15
 871           // -----------------------------------------------------
 872 #if defined(SPARC)
 873           lrg.set_reg_pressure(2);  // use for v9 as well
 874 #else
 875           lrg.set_reg_pressure(1);  // normally one value per register
 876 #endif
 877           if( n_type-&gt;isa_oop_ptr() ) {
 878             lrg._is_oop = 1;
 879           }
 880           break;
 881         case Op_RegL:           // Check for long or double
 882         case Op_RegD:
 883           lrg.set_num_regs(2);
 884           // Define platform specific register pressure
 885 #if defined(SPARC) || defined(ARM32)
 886           lrg.set_reg_pressure(2);
 887 #elif defined(IA32)
 888           if( ireg == Op_RegL ) {
 889             lrg.set_reg_pressure(2);
 890           } else {
 891             lrg.set_reg_pressure(1);
 892           }
 893 #else
 894           lrg.set_reg_pressure(1);  // normally one value per register
 895 #endif
 896           // If this def of a double forces a mis-aligned double,
 897           // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
 898           // AND changes how we count interferences.  A mis-aligned
 899           // double can interfere with TWO aligned pairs, or effectively
 900           // FOUR registers!
 901           if (rm.is_misaligned_pair()) {
 902             lrg._fat_proj = 1;
 903             lrg._is_bound = 1;
 904           }
 905           break;
 906         case Op_RegF:
 907         case Op_RegI:
 908         case Op_RegN:
 909         case Op_RegFlags:
 910         case 0:                 // not an ideal register
 911           lrg.set_num_regs(1);
 912 #ifdef SPARC
 913           lrg.set_reg_pressure(2);
 914 #else
 915           lrg.set_reg_pressure(1);
 916 #endif
 917           break;
 918         case Op_VecS:
 919           assert(Matcher::vector_size_supported(T_BYTE,4), &quot;sanity&quot;);
 920           assert(RegMask::num_registers(Op_VecS) == RegMask::SlotsPerVecS, &quot;sanity&quot;);
 921           lrg.set_num_regs(RegMask::SlotsPerVecS);
 922           lrg.set_reg_pressure(1);
 923           break;
 924         case Op_VecD:
 925           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecD), &quot;sanity&quot;);
 926           assert(RegMask::num_registers(Op_VecD) == RegMask::SlotsPerVecD, &quot;sanity&quot;);
 927           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecD), &quot;vector should be aligned&quot;);
 928           lrg.set_num_regs(RegMask::SlotsPerVecD);
 929           lrg.set_reg_pressure(1);
 930           break;
 931         case Op_VecX:
 932           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecX), &quot;sanity&quot;);
 933           assert(RegMask::num_registers(Op_VecX) == RegMask::SlotsPerVecX, &quot;sanity&quot;);
 934           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecX), &quot;vector should be aligned&quot;);
 935           lrg.set_num_regs(RegMask::SlotsPerVecX);
 936           lrg.set_reg_pressure(1);
 937           break;
 938         case Op_VecY:
 939           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecY), &quot;sanity&quot;);
 940           assert(RegMask::num_registers(Op_VecY) == RegMask::SlotsPerVecY, &quot;sanity&quot;);
 941           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecY), &quot;vector should be aligned&quot;);
 942           lrg.set_num_regs(RegMask::SlotsPerVecY);
 943           lrg.set_reg_pressure(1);
 944           break;
 945         case Op_VecZ:
 946           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecZ), &quot;sanity&quot;);
 947           assert(RegMask::num_registers(Op_VecZ) == RegMask::SlotsPerVecZ, &quot;sanity&quot;);
 948           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecZ), &quot;vector should be aligned&quot;);
 949           lrg.set_num_regs(RegMask::SlotsPerVecZ);
 950           lrg.set_reg_pressure(1);
 951           break;
 952         default:
 953           ShouldNotReachHere();
 954         }
 955       }
 956 
 957       // Now do the same for inputs
 958       uint cnt = n-&gt;req();
 959       // Setup for CISC SPILLING
 960       uint inp = (uint)AdlcVMDeps::Not_cisc_spillable;
 961       if( UseCISCSpill &amp;&amp; after_aggressive ) {
 962         inp = n-&gt;cisc_operand();
 963         if( inp != (uint)AdlcVMDeps::Not_cisc_spillable )
 964           // Convert operand number to edge index number
 965           inp = n-&gt;as_Mach()-&gt;operand_index(inp);
 966       }
 967 
 968       // Prepare register mask for each input
 969       for( uint k = input_edge_start; k &lt; cnt; k++ ) {
 970         uint vreg = _lrg_map.live_range_id(n-&gt;in(k));
 971         if (!vreg) {
 972           continue;
 973         }
 974 
 975         // If this instruction is CISC Spillable, add the flags
 976         // bit to its appropriate input
 977         if( UseCISCSpill &amp;&amp; after_aggressive &amp;&amp; inp == k ) {
 978 #ifndef PRODUCT
 979           if( TraceCISCSpill ) {
 980             tty-&gt;print(&quot;  use_cisc_RegMask: &quot;);
 981             n-&gt;dump();
 982           }
 983 #endif
 984           n-&gt;as_Mach()-&gt;use_cisc_RegMask();
 985         }
 986 
 987         if (is_machine_node &amp;&amp; _scheduling_info_generated) {
 988           MachNode* cur_node = n-&gt;as_Mach();
 989           // this is cleaned up by register allocation
 990           if (k &gt;= cur_node-&gt;num_opnds()) continue;
 991         }
 992 
 993         LRG &amp;lrg = lrgs(vreg);
 994         // // Testing for floating point code shape
 995         // Node *test = n-&gt;in(k);
 996         // if( test-&gt;is_Mach() ) {
 997         //   MachNode *m = test-&gt;as_Mach();
 998         //   int  op = m-&gt;ideal_Opcode();
 999         //   if (n-&gt;is_Call() &amp;&amp; (op == Op_AddF || op == Op_MulF) ) {
1000         //     int zzz = 1;
1001         //   }
1002         // }
1003 
1004         // Limit result register mask to acceptable registers.
1005         // Do not limit registers from uncommon uses before
1006         // AggressiveCoalesce.  This effectively pre-virtual-splits
1007         // around uncommon uses of common defs.
1008         const RegMask &amp;rm = n-&gt;in_RegMask(k);
1009         if (!after_aggressive &amp;&amp; _cfg.get_block_for_node(n-&gt;in(k))-&gt;_freq &gt; 1000 * block-&gt;_freq) {
1010           // Since we are BEFORE aggressive coalesce, leave the register
1011           // mask untrimmed by the call.  This encourages more coalescing.
1012           // Later, AFTER aggressive, this live range will have to spill
1013           // but the spiller handles slow-path calls very nicely.
1014         } else {
1015           lrg.AND( rm );
1016         }
1017 
1018         // Check for bound register masks
1019         const RegMask &amp;lrgmask = lrg.mask();
1020         uint kreg = n-&gt;in(k)-&gt;ideal_reg();
1021         bool is_vect = RegMask::is_vector(kreg);
1022         assert(n-&gt;in(k)-&gt;bottom_type()-&gt;isa_vect() == NULL ||
1023                is_vect || kreg == Op_RegD || kreg == Op_RegL,
1024                &quot;vector must be in vector registers&quot;);
1025         if (lrgmask.is_bound(kreg))
1026           lrg._is_bound = 1;
1027 
1028         // If this use of a double forces a mis-aligned double,
1029         // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
1030         // AND changes how we count interferences.  A mis-aligned
1031         // double can interfere with TWO aligned pairs, or effectively
1032         // FOUR registers!
1033 #ifdef ASSERT
1034         if (is_vect &amp;&amp; !_scheduling_info_generated) {
1035           if (lrg.num_regs() != 0) {
1036             assert(lrgmask.is_aligned_sets(lrg.num_regs()), &quot;vector should be aligned&quot;);
1037             assert(!lrg._fat_proj, &quot;sanity&quot;);
1038             assert(RegMask::num_registers(kreg) == lrg.num_regs(), &quot;sanity&quot;);
1039           } else {
1040             assert(n-&gt;is_Phi(), &quot;not all inputs processed only if Phi&quot;);
1041           }
1042         }
1043 #endif
1044         if (!is_vect &amp;&amp; lrg.num_regs() == 2 &amp;&amp; !lrg._fat_proj &amp;&amp; rm.is_misaligned_pair()) {
1045           lrg._fat_proj = 1;
1046           lrg._is_bound = 1;
1047         }
1048         // if the LRG is an unaligned pair, we will have to spill
1049         // so clear the LRG&#39;s register mask if it is not already spilled
1050         if (!is_vect &amp;&amp; !n-&gt;is_SpillCopy() &amp;&amp;
1051             (lrg._def == NULL || lrg.is_multidef() || !lrg._def-&gt;is_SpillCopy()) &amp;&amp;
1052             lrgmask.is_misaligned_pair()) {
1053           lrg.Clear();
1054         }
1055 
1056         // Check for maximum frequency value
1057         if (lrg._maxfreq &lt; block-&gt;_freq) {
1058           lrg._maxfreq = block-&gt;_freq;
1059         }
1060 
1061       } // End for all allocated inputs
1062     } // end for all instructions
1063   } // end for all blocks
1064 
1065   // Final per-liverange setup
1066   for (uint i2 = 0; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
1067     LRG &amp;lrg = lrgs(i2);
1068     assert(!lrg._is_vector || !lrg._fat_proj, &quot;sanity&quot;);
1069     if (lrg.num_regs() &gt; 1 &amp;&amp; !lrg._fat_proj) {
1070       lrg.clear_to_sets();
1071     }
1072     lrg.compute_set_mask_size();
1073     if (lrg.not_free()) {      // Handle case where we lose from the start
1074       lrg.set_reg(OptoReg::Name(LRG::SPILL_REG));
1075       lrg._direct_conflict = 1;
1076     }
1077     lrg.set_degree(0);          // no neighbors in IFG yet
1078   }
1079 }
1080 
1081 // Set the was-lo-degree bit.  Conservative coalescing should not change the
1082 // colorability of the graph.  If any live range was of low-degree before
1083 // coalescing, it should Simplify.  This call sets the was-lo-degree bit.
1084 // The bit is checked in Simplify.
1085 void PhaseChaitin::set_was_low() {
1086 #ifdef ASSERT
1087   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1088     int size = lrgs(i).num_regs();
1089     uint old_was_lo = lrgs(i)._was_lo;
1090     lrgs(i)._was_lo = 0;
1091     if( lrgs(i).lo_degree() ) {
1092       lrgs(i)._was_lo = 1;      // Trivially of low degree
1093     } else {                    // Else check the Brigg&#39;s assertion
1094       // Brigg&#39;s observation is that the lo-degree neighbors of a
1095       // hi-degree live range will not interfere with the color choices
1096       // of said hi-degree live range.  The Simplify reverse-stack-coloring
1097       // order takes care of the details.  Hence you do not have to count
1098       // low-degree neighbors when determining if this guy colors.
1099       int briggs_degree = 0;
1100       IndexSet *s = _ifg-&gt;neighbors(i);
1101       IndexSetIterator elements(s);
1102       uint lidx;
1103       while((lidx = elements.next()) != 0) {
1104         if( !lrgs(lidx).lo_degree() )
1105           briggs_degree += MAX2(size,lrgs(lidx).num_regs());
1106       }
1107       if( briggs_degree &lt; lrgs(i).degrees_of_freedom() )
1108         lrgs(i)._was_lo = 1;    // Low degree via the briggs assertion
1109     }
1110     assert(old_was_lo &lt;= lrgs(i)._was_lo, &quot;_was_lo may not decrease&quot;);
1111   }
1112 #endif
1113 }
1114 
1115 // Compute cost/area ratio, in case we spill.  Build the lo-degree list.
1116 void PhaseChaitin::cache_lrg_info( ) {
1117   Compile::TracePhase tp(&quot;chaitinCacheLRG&quot;, &amp;timers[_t_chaitinCacheLRG]);
1118 
1119   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1120     LRG &amp;lrg = lrgs(i);
1121 
1122     // Check for being of low degree: means we can be trivially colored.
1123     // Low degree, dead or must-spill guys just get to simplify right away
1124     if( lrg.lo_degree() ||
1125        !lrg.alive() ||
1126         lrg._must_spill ) {
1127       // Split low degree list into those guys that must get a
1128       // register and those that can go to register or stack.
1129       // The idea is LRGs that can go register or stack color first when
1130       // they have a good chance of getting a register.  The register-only
1131       // lo-degree live ranges always get a register.
1132       OptoReg::Name hi_reg = lrg.mask().find_last_elem();
1133       if( OptoReg::is_stack(hi_reg)) { // Can go to stack?
1134         lrg._next = _lo_stk_degree;
1135         _lo_stk_degree = i;
1136       } else {
1137         lrg._next = _lo_degree;
1138         _lo_degree = i;
1139       }
1140     } else {                    // Else high degree
1141       lrgs(_hi_degree)._prev = i;
1142       lrg._next = _hi_degree;
1143       lrg._prev = 0;
1144       _hi_degree = i;
1145     }
1146   }
1147 }
1148 
1149 // Simplify the IFG by removing LRGs of low degree.
1150 void PhaseChaitin::Simplify( ) {
1151   Compile::TracePhase tp(&quot;chaitinSimplify&quot;, &amp;timers[_t_chaitinSimplify]);
1152 
1153   while( 1 ) {                  // Repeat till simplified it all
1154     // May want to explore simplifying lo_degree before _lo_stk_degree.
1155     // This might result in more spills coloring into registers during
1156     // Select().
1157     while( _lo_degree || _lo_stk_degree ) {
1158       // If possible, pull from lo_stk first
1159       uint lo;
1160       if( _lo_degree ) {
1161         lo = _lo_degree;
1162         _lo_degree = lrgs(lo)._next;
1163       } else {
1164         lo = _lo_stk_degree;
1165         _lo_stk_degree = lrgs(lo)._next;
1166       }
1167 
1168       // Put the simplified guy on the simplified list.
1169       lrgs(lo)._next = _simplified;
1170       _simplified = lo;
1171       // If this guy is &quot;at risk&quot; then mark his current neighbors
<a name="2" id="anc2"></a><span class="line-modified">1172       if (lrgs(lo)._at_risk &amp;&amp; !_ifg-&gt;neighbors(lo)-&gt;is_empty()) {</span>
1173         IndexSetIterator elements(_ifg-&gt;neighbors(lo));
1174         uint datum;
1175         while ((datum = elements.next()) != 0) {
1176           lrgs(datum)._risk_bias = lo;
1177         }
1178       }
1179 
1180       // Yank this guy from the IFG.
<a name="3" id="anc3"></a><span class="line-modified">1181       IndexSet *adj = _ifg-&gt;remove_node(lo);</span>
<span class="line-added">1182       if (adj-&gt;is_empty()) {</span>
<span class="line-added">1183         continue;</span>
<span class="line-added">1184       }</span>
1185 
1186       // If any neighbors&#39; degrees fall below their number of
1187       // allowed registers, then put that neighbor on the low degree
1188       // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
1189       // unchanged by this action.  Thus the two are equal at most once,
1190       // so LRGs hit the lo-degree worklist at most once.
1191       IndexSetIterator elements(adj);
1192       uint neighbor;
1193       while ((neighbor = elements.next()) != 0) {
1194         LRG *n = &amp;lrgs(neighbor);
1195 #ifdef ASSERT
<a name="4" id="anc4"></a><span class="line-modified">1196         if (VerifyRegisterAllocator) {</span>
1197           assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
1198         }
1199 #endif
1200 
1201         // Check for just becoming of-low-degree just counting registers.
1202         // _must_spill live ranges are already on the low degree list.
<a name="5" id="anc5"></a><span class="line-modified">1203         if (n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill) {</span>
<span class="line-modified">1204           assert(!_ifg-&gt;_yanked-&gt;test(neighbor), &quot;Cannot move to lo degree twice&quot;);</span>
1205           // Pull from hi-degree list
1206           uint prev = n-&gt;_prev;
1207           uint next = n-&gt;_next;
<a name="6" id="anc6"></a><span class="line-modified">1208           if (prev) {</span>
<span class="line-modified">1209             lrgs(prev)._next = next;</span>
<span class="line-added">1210           } else {</span>
<span class="line-added">1211             _hi_degree = next;</span>
<span class="line-added">1212           }</span>
1213           lrgs(next)._prev = prev;
1214           n-&gt;_next = _lo_degree;
1215           _lo_degree = neighbor;
1216         }
1217       }
1218     } // End of while lo-degree/lo_stk_degree worklist not empty
1219 
1220     // Check for got everything: is hi-degree list empty?
<a name="7" id="anc7"></a><span class="line-modified">1221     if (!_hi_degree) break;</span>
1222 
1223     // Time to pick a potential spill guy
1224     uint lo_score = _hi_degree;
1225     double score = lrgs(lo_score).score();
1226     double area = lrgs(lo_score)._area;
1227     double cost = lrgs(lo_score)._cost;
1228     bool bound = lrgs(lo_score)._is_bound;
1229 
1230     // Find cheapest guy
1231     debug_only( int lo_no_simplify=0; );
<a name="8" id="anc8"></a><span class="line-modified">1232     for (uint i = _hi_degree; i; i = lrgs(i)._next) {</span>
<span class="line-modified">1233       assert(!_ifg-&gt;_yanked-&gt;test(i), &quot;&quot;);</span>
1234       // It&#39;s just vaguely possible to move hi-degree to lo-degree without
1235       // going through a just-lo-degree stage: If you remove a double from
1236       // a float live range it&#39;s degree will drop by 2 and you can skip the
1237       // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
1238       // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
1239       if( lrgs(i).lo_degree() ) {
1240         lo_score = i;
1241         break;
1242       }
1243       debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );
1244       double iscore = lrgs(i).score();
1245       double iarea = lrgs(i)._area;
1246       double icost = lrgs(i)._cost;
1247       bool ibound = lrgs(i)._is_bound;
1248 
1249       // Compare cost/area of i vs cost/area of lo_score.  Smaller cost/area
1250       // wins.  Ties happen because all live ranges in question have spilled
1251       // a few times before and the spill-score adds a huge number which
1252       // washes out the low order bits.  We are choosing the lesser of 2
1253       // evils; in this case pick largest area to spill.
1254       // Ties also happen when live ranges are defined and used only inside
1255       // one block. In which case their area is 0 and score set to max.
1256       // In such case choose bound live range over unbound to free registers
1257       // or with smaller cost to spill.
<a name="9" id="anc9"></a><span class="line-modified">1258       if ( iscore &lt; score ||</span>
1259           (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
1260           (iscore == score &amp;&amp; iarea == area &amp;&amp;
1261            ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
1262         lo_score = i;
1263         score = iscore;
1264         area = iarea;
1265         cost = icost;
1266         bound = ibound;
1267       }
1268     }
1269     LRG *lo_lrg = &amp;lrgs(lo_score);
1270     // The live range we choose for spilling is either hi-degree, or very
1271     // rarely it can be low-degree.  If we choose a hi-degree live range
1272     // there better not be any lo-degree choices.
1273     assert( lo_lrg-&gt;lo_degree() || !lo_no_simplify, &quot;Live range was lo-degree before coalesce; should simplify&quot; );
1274 
1275     // Pull from hi-degree list
1276     uint prev = lo_lrg-&gt;_prev;
1277     uint next = lo_lrg-&gt;_next;
1278     if( prev ) lrgs(prev)._next = next;
1279     else _hi_degree = next;
1280     lrgs(next)._prev = prev;
1281     // Jam him on the lo-degree list, despite his high degree.
1282     // Maybe he&#39;ll get a color, and maybe he&#39;ll spill.
1283     // Only Select() will know.
1284     lrgs(lo_score)._at_risk = true;
1285     _lo_degree = lo_score;
1286     lo_lrg-&gt;_next = 0;
1287 
1288   } // End of while not simplified everything
1289 
1290 }
1291 
1292 // Is &#39;reg&#39; register legal for &#39;lrg&#39;?
1293 static bool is_legal_reg(LRG &amp;lrg, OptoReg::Name reg, int chunk) {
1294   if (reg &gt;= chunk &amp;&amp; reg &lt; (chunk + RegMask::CHUNK_SIZE) &amp;&amp;
1295       lrg.mask().Member(OptoReg::add(reg,-chunk))) {
1296     // RA uses OptoReg which represent the highest element of a registers set.
1297     // For example, vectorX (128bit) on x86 uses [XMM,XMMb,XMMc,XMMd] set
1298     // in which XMMd is used by RA to represent such vectors. A double value
1299     // uses [XMM,XMMb] pairs and XMMb is used by RA for it.
1300     // The register mask uses largest bits set of overlapping register sets.
1301     // On x86 with AVX it uses 8 bits for each XMM registers set.
1302     //
1303     // The &#39;lrg&#39; already has cleared-to-set register mask (done in Select()
1304     // before calling choose_color()). Passing mask.Member(reg) check above
1305     // indicates that the size (num_regs) of &#39;reg&#39; set is less or equal to
1306     // &#39;lrg&#39; set size.
1307     // For set size 1 any register which is member of &#39;lrg&#39; mask is legal.
1308     if (lrg.num_regs()==1)
1309       return true;
1310     // For larger sets only an aligned register with the same set size is legal.
1311     int mask = lrg.num_regs()-1;
1312     if ((reg&amp;mask) == mask)
1313       return true;
1314   }
1315   return false;
1316 }
1317 
1318 // Choose a color using the biasing heuristic
1319 OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
1320 
1321   // Check for &quot;at_risk&quot; LRG&#39;s
1322   uint risk_lrg = _lrg_map.find(lrg._risk_bias);
<a name="10" id="anc10"></a><span class="line-modified">1323   if (risk_lrg != 0 &amp;&amp; !_ifg-&gt;neighbors(risk_lrg)-&gt;is_empty()) {</span>
1324     // Walk the colored neighbors of the &quot;at_risk&quot; candidate
1325     // Choose a color which is both legal and already taken by a neighbor
1326     // of the &quot;at_risk&quot; candidate in order to improve the chances of the
1327     // &quot;at_risk&quot; candidate of coloring
1328     IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
1329     uint datum;
1330     while ((datum = elements.next()) != 0) {
1331       OptoReg::Name reg = lrgs(datum).reg();
1332       // If this LRG&#39;s register is legal for us, choose it
1333       if (is_legal_reg(lrg, reg, chunk))
1334         return reg;
1335     }
1336   }
1337 
1338   uint copy_lrg = _lrg_map.find(lrg._copy_bias);
<a name="11" id="anc11"></a><span class="line-modified">1339   if (copy_lrg != 0) {</span>
1340     // If he has a color,
<a name="12" id="anc12"></a><span class="line-modified">1341     if(!_ifg-&gt;_yanked-&gt;test(copy_lrg)) {</span>
1342       OptoReg::Name reg = lrgs(copy_lrg).reg();
1343       //  And it is legal for you,
1344       if (is_legal_reg(lrg, reg, chunk))
1345         return reg;
1346     } else if( chunk == 0 ) {
1347       // Choose a color which is legal for him
1348       RegMask tempmask = lrg.mask();
1349       tempmask.AND(lrgs(copy_lrg).mask());
1350       tempmask.clear_to_sets(lrg.num_regs());
1351       OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());
1352       if (OptoReg::is_valid(reg))
1353         return reg;
1354     }
1355   }
1356 
1357   // If no bias info exists, just go with the register selection ordering
1358   if (lrg._is_vector || lrg.num_regs() == 2) {
1359     // Find an aligned set
1360     return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);
1361   }
1362 
1363   // CNC - Fun hack.  Alternate 1st and 2nd selection.  Enables post-allocate
1364   // copy removal to remove many more copies, by preventing a just-assigned
1365   // register from being repeatedly assigned.
1366   OptoReg::Name reg = lrg.mask().find_first_elem();
1367   if( (++_alternate &amp; 1) &amp;&amp; OptoReg::is_valid(reg) ) {
1368     // This &#39;Remove; find; Insert&#39; idiom is an expensive way to find the
1369     // SECOND element in the mask.
1370     lrg.Remove(reg);
1371     OptoReg::Name reg2 = lrg.mask().find_first_elem();
1372     lrg.Insert(reg);
1373     if( OptoReg::is_reg(reg2))
1374       reg = reg2;
1375   }
1376   return OptoReg::add( reg, chunk );
1377 }
1378 
1379 // Choose a color in the current chunk
1380 OptoReg::Name PhaseChaitin::choose_color( LRG &amp;lrg, int chunk ) {
1381   assert( C-&gt;in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1382   assert(C-&gt;out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1383 
1384   if( lrg.num_regs() == 1 ||    // Common Case
1385       !lrg._fat_proj )          // Aligned+adjacent pairs ok
1386     // Use a heuristic to &quot;bias&quot; the color choice
1387     return bias_color(lrg, chunk);
1388 
1389   assert(!lrg._is_vector, &quot;should be not vector here&quot; );
1390   assert( lrg.num_regs() &gt;= 2, &quot;dead live ranges do not color&quot; );
1391 
1392   // Fat-proj case or misaligned double argument.
1393   assert(lrg.compute_mask_size() == lrg.num_regs() ||
1394          lrg.num_regs() == 2,&quot;fat projs exactly color&quot; );
1395   assert( !chunk, &quot;always color in 1st chunk&quot; );
1396   // Return the highest element in the set.
1397   return lrg.mask().find_last_elem();
1398 }
1399 
1400 // Select colors by re-inserting LRGs back into the IFG.  LRGs are re-inserted
1401 // in reverse order of removal.  As long as nothing of hi-degree was yanked,
1402 // everything going back is guaranteed a color.  Select that color.  If some
1403 // hi-degree LRG cannot get a color then we record that we must spill.
1404 uint PhaseChaitin::Select( ) {
1405   Compile::TracePhase tp(&quot;chaitinSelect&quot;, &amp;timers[_t_chaitinSelect]);
1406 
1407   uint spill_reg = LRG::SPILL_REG;
1408   _max_reg = OptoReg::Name(0);  // Past max register used
1409   while( _simplified ) {
1410     // Pull next LRG from the simplified list - in reverse order of removal
1411     uint lidx = _simplified;
1412     LRG *lrg = &amp;lrgs(lidx);
1413     _simplified = lrg-&gt;_next;
1414 
1415 
1416 #ifndef PRODUCT
1417     if (trace_spilling()) {
1418       ttyLocker ttyl;
1419       tty-&gt;print_cr(&quot;L%d selecting degree %d degrees_of_freedom %d&quot;, lidx, lrg-&gt;degree(),
1420                     lrg-&gt;degrees_of_freedom());
1421       lrg-&gt;dump();
1422     }
1423 #endif
1424 
1425     // Re-insert into the IFG
1426     _ifg-&gt;re_insert(lidx);
1427     if( !lrg-&gt;alive() ) continue;
1428     // capture allstackedness flag before mask is hacked
1429     const int is_allstack = lrg-&gt;mask().is_AllStack();
1430 
1431     // Yeah, yeah, yeah, I know, I know.  I can refactor this
1432     // to avoid the GOTO, although the refactored code will not
1433     // be much clearer.  We arrive here IFF we have a stack-based
1434     // live range that cannot color in the current chunk, and it
1435     // has to move into the next free stack chunk.
1436     int chunk = 0;              // Current chunk is first chunk
1437     retry_next_chunk:
1438 
1439     // Remove neighbor colors
1440     IndexSet *s = _ifg-&gt;neighbors(lidx);
<a name="13" id="anc13"></a>
1441     debug_only(RegMask orig_mask = lrg-&gt;mask();)
<a name="14" id="anc14"></a><span class="line-modified">1442 </span>
<span class="line-modified">1443     if (!s-&gt;is_empty()) {</span>
<span class="line-modified">1444       IndexSetIterator elements(s);</span>
<span class="line-modified">1445       uint neighbor;</span>
<span class="line-modified">1446       while ((neighbor = elements.next()) != 0) {</span>
<span class="line-modified">1447         // Note that neighbor might be a spill_reg.  In this case, exclusion</span>
<span class="line-modified">1448         // of its color will be a no-op, since the spill_reg chunk is in outer</span>
<span class="line-modified">1449         // space.  Also, if neighbor is in a different chunk, this exclusion</span>
<span class="line-modified">1450         // will be a no-op.  (Later on, if lrg runs out of possible colors in</span>
<span class="line-modified">1451         // its chunk, a new chunk of color may be tried, in which case</span>
<span class="line-modified">1452         // examination of neighbors is started again, at retry_next_chunk.)</span>
<span class="line-modified">1453         LRG &amp;nlrg = lrgs(neighbor);</span>
<span class="line-modified">1454         OptoReg::Name nreg = nlrg.reg();</span>
<span class="line-added">1455         // Only subtract masks in the same chunk</span>
<span class="line-added">1456         if (nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE) {</span>
1457 #ifndef PRODUCT
<a name="15" id="anc15"></a><span class="line-modified">1458           uint size = lrg-&gt;mask().Size();</span>
<span class="line-modified">1459           RegMask rm = lrg-&gt;mask();</span>
1460 #endif
<a name="16" id="anc16"></a><span class="line-modified">1461           lrg-&gt;SUBTRACT(nlrg.mask());</span>
1462 #ifndef PRODUCT
<a name="17" id="anc17"></a><span class="line-modified">1463           if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {</span>
<span class="line-modified">1464             ttyLocker ttyl;</span>
<span class="line-modified">1465             tty-&gt;print(&quot;L%d &quot;, lidx);</span>
<span class="line-modified">1466             rm.dump();</span>
<span class="line-modified">1467             tty-&gt;print(&quot; intersected L%d &quot;, neighbor);</span>
<span class="line-modified">1468             nlrg.mask().dump();</span>
<span class="line-modified">1469             tty-&gt;print(&quot; removed &quot;);</span>
<span class="line-modified">1470             rm.SUBTRACT(lrg-&gt;mask());</span>
<span class="line-modified">1471             rm.dump();</span>
<span class="line-modified">1472             tty-&gt;print(&quot; leaving &quot;);</span>
<span class="line-modified">1473             lrg-&gt;mask().dump();</span>
<span class="line-modified">1474             tty-&gt;cr();</span>
<span class="line-modified">1475           }</span>
1476 #endif
<a name="18" id="anc18"></a><span class="line-added">1477         }</span>
1478       }
1479     }
1480     //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
1481     // Aligned pairs need aligned masks
1482     assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1483     if (lrg-&gt;num_regs() &gt; 1 &amp;&amp; !lrg-&gt;_fat_proj) {
1484       lrg-&gt;clear_to_sets();
1485     }
1486 
1487     // Check if a color is available and if so pick the color
1488     OptoReg::Name reg = choose_color( *lrg, chunk );
1489 #ifdef SPARC
1490     debug_only(lrg-&gt;compute_set_mask_size());
1491     assert(lrg-&gt;num_regs() &lt; 2 || lrg-&gt;is_bound() || is_even(reg-1), &quot;allocate all doubles aligned&quot;);
1492 #endif
1493 
1494     //---------------
1495     // If we fail to color and the AllStack flag is set, trigger
1496     // a chunk-rollover event
1497     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) &amp;&amp; is_allstack) {
1498       // Bump register mask up to next stack chunk
1499       chunk += RegMask::CHUNK_SIZE;
1500       lrg-&gt;Set_All();
1501 
1502       goto retry_next_chunk;
1503     }
1504 
1505     //---------------
1506     // Did we get a color?
1507     else if( OptoReg::is_valid(reg)) {
1508 #ifndef PRODUCT
1509       RegMask avail_rm = lrg-&gt;mask();
1510 #endif
1511 
1512       // Record selected register
1513       lrg-&gt;set_reg(reg);
1514 
1515       if( reg &gt;= _max_reg )     // Compute max register limit
1516         _max_reg = OptoReg::add(reg,1);
1517       // Fold reg back into normal space
1518       reg = OptoReg::add(reg,-chunk);
1519 
1520       // If the live range is not bound, then we actually had some choices
1521       // to make.  In this case, the mask has more bits in it than the colors
1522       // chosen.  Restrict the mask to just what was picked.
1523       int n_regs = lrg-&gt;num_regs();
1524       assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1525       if (n_regs == 1 || !lrg-&gt;_fat_proj) {
1526         assert(!lrg-&gt;_is_vector || n_regs &lt;= RegMask::SlotsPerVecZ, &quot;sanity&quot;);
1527         lrg-&gt;Clear();           // Clear the mask
1528         lrg-&gt;Insert(reg);       // Set regmask to match selected reg
1529         // For vectors and pairs, also insert the low bit of the pair
1530         for (int i = 1; i &lt; n_regs; i++)
1531           lrg-&gt;Insert(OptoReg::add(reg,-i));
1532         lrg-&gt;set_mask_size(n_regs);
1533       } else {                  // Else fatproj
1534         // mask must be equal to fatproj bits, by definition
1535       }
1536 #ifndef PRODUCT
1537       if (trace_spilling()) {
1538         ttyLocker ttyl;
1539         tty-&gt;print(&quot;L%d selected &quot;, lidx);
1540         lrg-&gt;mask().dump();
1541         tty-&gt;print(&quot; from &quot;);
1542         avail_rm.dump();
1543         tty-&gt;cr();
1544       }
1545 #endif
1546       // Note that reg is the highest-numbered register in the newly-bound mask.
1547     } // end color available case
1548 
1549     //---------------
1550     // Live range is live and no colors available
1551     else {
1552       assert( lrg-&gt;alive(), &quot;&quot; );
1553       assert( !lrg-&gt;_fat_proj || lrg-&gt;is_multidef() ||
1554               lrg-&gt;_def-&gt;outcnt() &gt; 0, &quot;fat_proj cannot spill&quot;);
1555       assert( !orig_mask.is_AllStack(), &quot;All Stack does not spill&quot; );
1556 
1557       // Assign the special spillreg register
1558       lrg-&gt;set_reg(OptoReg::Name(spill_reg++));
1559       // Do not empty the regmask; leave mask_size lying around
1560       // for use during Spilling
1561 #ifndef PRODUCT
1562       if( trace_spilling() ) {
1563         ttyLocker ttyl;
1564         tty-&gt;print(&quot;L%d spilling with neighbors: &quot;, lidx);
1565         s-&gt;dump();
1566         debug_only(tty-&gt;print(&quot; original mask: &quot;));
1567         debug_only(orig_mask.dump());
1568         dump_lrg(lidx);
1569       }
1570 #endif
1571     } // end spill case
1572 
1573   }
1574 
1575   return spill_reg-LRG::SPILL_REG;      // Return number of spills
1576 }
1577 
1578 // Set the &#39;spilled_once&#39; or &#39;spilled_twice&#39; flag on a node.
1579 void PhaseChaitin::set_was_spilled( Node *n ) {
1580   if( _spilled_once.test_set(n-&gt;_idx) )
1581     _spilled_twice.set(n-&gt;_idx);
1582 }
1583 
1584 // Convert Ideal spill instructions into proper FramePtr + offset Loads and
1585 // Stores.  Use-def chains are NOT preserved, but Node-&gt;LRG-&gt;reg maps are.
1586 void PhaseChaitin::fixup_spills() {
1587   // This function does only cisc spill work.
1588   if( !UseCISCSpill ) return;
1589 
1590   Compile::TracePhase tp(&quot;fixupSpills&quot;, &amp;timers[_t_fixupSpills]);
1591 
1592   // Grab the Frame Pointer
1593   Node *fp = _cfg.get_root_block()-&gt;head()-&gt;in(1)-&gt;in(TypeFunc::FramePtr);
1594 
1595   // For all blocks
1596   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1597     Block* block = _cfg.get_block(i);
1598 
1599     // For all instructions in block
1600     uint last_inst = block-&gt;end_idx();
1601     for (uint j = 1; j &lt;= last_inst; j++) {
1602       Node* n = block-&gt;get_node(j);
1603 
1604       // Dead instruction???
1605       assert( n-&gt;outcnt() != 0 ||// Nothing dead after post alloc
1606               C-&gt;top() == n ||  // Or the random TOP node
1607               n-&gt;is_Proj(),     // Or a fat-proj kill node
1608               &quot;No dead instructions after post-alloc&quot; );
1609 
1610       int inp = n-&gt;cisc_operand();
1611       if( inp != AdlcVMDeps::Not_cisc_spillable ) {
1612         // Convert operand number to edge index number
1613         MachNode *mach = n-&gt;as_Mach();
1614         inp = mach-&gt;operand_index(inp);
1615         Node *src = n-&gt;in(inp);   // Value to load or store
1616         LRG &amp;lrg_cisc = lrgs(_lrg_map.find_const(src));
1617         OptoReg::Name src_reg = lrg_cisc.reg();
1618         // Doubles record the HIGH register of an adjacent pair.
1619         src_reg = OptoReg::add(src_reg,1-lrg_cisc.num_regs());
1620         if( OptoReg::is_stack(src_reg) ) { // If input is on stack
1621           // This is a CISC Spill, get stack offset and construct new node
1622 #ifndef PRODUCT
1623           if( TraceCISCSpill ) {
1624             tty-&gt;print(&quot;    reg-instr:  &quot;);
1625             n-&gt;dump();
1626           }
1627 #endif
1628           int stk_offset = reg2offset(src_reg);
1629           // Bailout if we might exceed node limit when spilling this instruction
1630           C-&gt;check_node_count(0, &quot;out of nodes fixing spills&quot;);
1631           if (C-&gt;failing())  return;
1632           // Transform node
1633           MachNode *cisc = mach-&gt;cisc_version(stk_offset)-&gt;as_Mach();
1634           cisc-&gt;set_req(inp,fp);          // Base register is frame pointer
1635           if( cisc-&gt;oper_input_base() &gt; 1 &amp;&amp; mach-&gt;oper_input_base() &lt;= 1 ) {
1636             assert( cisc-&gt;oper_input_base() == 2, &quot;Only adding one edge&quot;);
1637             cisc-&gt;ins_req(1,src);         // Requires a memory edge
1638           }
1639           block-&gt;map_node(cisc, j);          // Insert into basic block
1640           n-&gt;subsume_by(cisc, C); // Correct graph
1641           //
1642           ++_used_cisc_instructions;
1643 #ifndef PRODUCT
1644           if( TraceCISCSpill ) {
1645             tty-&gt;print(&quot;    cisc-instr: &quot;);
1646             cisc-&gt;dump();
1647           }
1648 #endif
1649         } else {
1650 #ifndef PRODUCT
1651           if( TraceCISCSpill ) {
1652             tty-&gt;print(&quot;    using reg-instr: &quot;);
1653             n-&gt;dump();
1654           }
1655 #endif
1656           ++_unused_cisc_instructions;    // input can be on stack
1657         }
1658       }
1659 
1660     } // End of for all instructions
1661 
1662   } // End of for all blocks
1663 }
1664 
1665 // Helper to stretch above; recursively discover the base Node for a
1666 // given derived Node.  Easy for AddP-related machine nodes, but needs
1667 // to be recursive for derived Phis.
1668 Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &amp;maxlrg ) {
1669   // See if already computed; if so return it
1670   if( derived_base_map[derived-&gt;_idx] )
1671     return derived_base_map[derived-&gt;_idx];
1672 
1673   // See if this happens to be a base.
1674   // NOTE: we use TypePtr instead of TypeOopPtr because we can have
1675   // pointers derived from NULL!  These are always along paths that
1676   // can&#39;t happen at run-time but the optimizer cannot deduce it so
1677   // we have to handle it gracefully.
1678   assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1679           derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1680   const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1681   // If its an OOP with a non-zero offset, then it is derived.
1682   if( tj == NULL || tj-&gt;_offset == 0 ) {
1683     derived_base_map[derived-&gt;_idx] = derived;
1684     return derived;
1685   }
1686   // Derived is NULL+offset?  Base is NULL!
1687   if( derived-&gt;is_Con() ) {
1688     Node *base = _matcher.mach_null();
1689     assert(base != NULL, &quot;sanity&quot;);
1690     if (base-&gt;in(0) == NULL) {
1691       // Initialize it once and make it shared:
1692       // set control to _root and place it into Start block
1693       // (where top() node is placed).
1694       base-&gt;init_req(0, _cfg.get_root_node());
1695       Block *startb = _cfg.get_block_for_node(C-&gt;top());
1696       uint node_pos = startb-&gt;find_node(C-&gt;top());
1697       startb-&gt;insert_node(base, node_pos);
1698       _cfg.map_node_to_block(base, startb);
1699       assert(_lrg_map.live_range_id(base) == 0, &quot;should not have LRG yet&quot;);
1700 
1701       // The loadConP0 might have projection nodes depending on architecture
1702       // Add the projection nodes to the CFG
1703       for (DUIterator_Fast imax, i = base-&gt;fast_outs(imax); i &lt; imax; i++) {
1704         Node* use = base-&gt;fast_out(i);
1705         if (use-&gt;is_MachProj()) {
1706           startb-&gt;insert_node(use, ++node_pos);
1707           _cfg.map_node_to_block(use, startb);
1708           new_lrg(use, maxlrg++);
1709         }
1710       }
1711     }
1712     if (_lrg_map.live_range_id(base) == 0) {
1713       new_lrg(base, maxlrg++);
1714     }
1715     assert(base-&gt;in(0) == _cfg.get_root_node() &amp;&amp; _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C-&gt;top()), &quot;base NULL should be shared&quot;);
1716     derived_base_map[derived-&gt;_idx] = base;
1717     return base;
1718   }
1719 
1720   // Check for AddP-related opcodes
1721   if (!derived-&gt;is_Phi()) {
1722     assert(derived-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP, &quot;but is: %s&quot;, derived-&gt;Name());
1723     Node *base = derived-&gt;in(AddPNode::Base);
1724     derived_base_map[derived-&gt;_idx] = base;
1725     return base;
1726   }
1727 
1728   // Recursively find bases for Phis.
1729   // First check to see if we can avoid a base Phi here.
1730   Node *base = find_base_for_derived( derived_base_map, derived-&gt;in(1),maxlrg);
1731   uint i;
1732   for( i = 2; i &lt; derived-&gt;req(); i++ )
1733     if( base != find_base_for_derived( derived_base_map,derived-&gt;in(i),maxlrg))
1734       break;
1735   // Went to the end without finding any different bases?
1736   if( i == derived-&gt;req() ) {   // No need for a base Phi here
1737     derived_base_map[derived-&gt;_idx] = base;
1738     return base;
1739   }
1740 
1741   // Now we see we need a base-Phi here to merge the bases
1742   const Type *t = base-&gt;bottom_type();
1743   base = new PhiNode( derived-&gt;in(0), t );
1744   for( i = 1; i &lt; derived-&gt;req(); i++ ) {
1745     base-&gt;init_req(i, find_base_for_derived(derived_base_map, derived-&gt;in(i), maxlrg));
1746     t = t-&gt;meet(base-&gt;in(i)-&gt;bottom_type());
1747   }
1748   base-&gt;as_Phi()-&gt;set_type(t);
1749 
1750   // Search the current block for an existing base-Phi
1751   Block *b = _cfg.get_block_for_node(derived);
1752   for( i = 1; i &lt;= b-&gt;end_idx(); i++ ) {// Search for matching Phi
1753     Node *phi = b-&gt;get_node(i);
1754     if( !phi-&gt;is_Phi() ) {      // Found end of Phis with no match?
1755       b-&gt;insert_node(base,  i); // Must insert created Phi here as base
1756       _cfg.map_node_to_block(base, b);
1757       new_lrg(base,maxlrg++);
1758       break;
1759     }
1760     // See if Phi matches.
1761     uint j;
1762     for( j = 1; j &lt; base-&gt;req(); j++ )
1763       if( phi-&gt;in(j) != base-&gt;in(j) &amp;&amp;
1764           !(phi-&gt;in(j)-&gt;is_Con() &amp;&amp; base-&gt;in(j)-&gt;is_Con()) ) // allow different NULLs
1765         break;
1766     if( j == base-&gt;req() ) {    // All inputs match?
1767       base = phi;               // Then use existing &#39;phi&#39; and drop &#39;base&#39;
1768       break;
1769     }
1770   }
1771 
1772 
1773   // Cache info for later passes
1774   derived_base_map[derived-&gt;_idx] = base;
1775   return base;
1776 }
1777 
1778 // At each Safepoint, insert extra debug edges for each pair of derived value/
1779 // base pointer that is live across the Safepoint for oopmap building.  The
1780 // edge pairs get added in after sfpt-&gt;jvmtail()-&gt;oopoff(), but are in the
1781 // required edge set.
1782 bool PhaseChaitin::stretch_base_pointer_live_ranges(ResourceArea *a) {
1783   int must_recompute_live = false;
1784   uint maxlrg = _lrg_map.max_lrg_id();
1785   Node **derived_base_map = (Node**)a-&gt;Amalloc(sizeof(Node*)*C-&gt;unique());
1786   memset( derived_base_map, 0, sizeof(Node*)*C-&gt;unique() );
1787 
1788   // For all blocks in RPO do...
1789   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1790     Block* block = _cfg.get_block(i);
1791     // Note use of deep-copy constructor.  I cannot hammer the original
1792     // liveout bits, because they are needed by the following coalesce pass.
1793     IndexSet liveout(_live-&gt;live(block));
1794 
1795     for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
1796       Node* n = block-&gt;get_node(j - 1);
1797 
1798       // Pre-split compares of loop-phis.  Loop-phis form a cycle we would
1799       // like to see in the same register.  Compare uses the loop-phi and so
1800       // extends its live range BUT cannot be part of the cycle.  If this
1801       // extended live range overlaps with the update of the loop-phi value
1802       // we need both alive at the same time -- which requires at least 1
1803       // copy.  But because Intel has only 2-address registers we end up with
1804       // at least 2 copies, one before the loop-phi update instruction and
1805       // one after.  Instead we split the input to the compare just after the
1806       // phi.
1807       if( n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CmpI ) {
1808         Node *phi = n-&gt;in(1);
1809         if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;as_Phi()-&gt;region()-&gt;is_Loop() ) {
1810           Block *phi_block = _cfg.get_block_for_node(phi);
1811           if (_cfg.get_block_for_node(phi_block-&gt;pred(2)) == block) {
1812             const RegMask *mask = C-&gt;matcher()-&gt;idealreg2spillmask[Op_RegI];
1813             Node *spill = new MachSpillCopyNode(MachSpillCopyNode::LoopPhiInput, phi, *mask, *mask);
1814             insert_proj( phi_block, 1, spill, maxlrg++ );
1815             n-&gt;set_req(1,spill);
1816             must_recompute_live = true;
1817           }
1818         }
1819       }
1820 
1821       // Get value being defined
1822       uint lidx = _lrg_map.live_range_id(n);
1823       // Ignore the occasional brand-new live range
1824       if (lidx &amp;&amp; lidx &lt; _lrg_map.max_lrg_id()) {
1825         // Remove from live-out set
1826         liveout.remove(lidx);
1827 
1828         // Copies do not define a new value and so do not interfere.
1829         // Remove the copies source from the liveout set before interfering.
1830         uint idx = n-&gt;is_Copy();
1831         if (idx) {
1832           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1833         }
1834       }
1835 
1836       // Found a safepoint?
1837       JVMState *jvms = n-&gt;jvms();
<a name="19" id="anc19"></a><span class="line-modified">1838       if (jvms &amp;&amp; !liveout.is_empty()) {</span>
1839         // Now scan for a live derived pointer
1840         IndexSetIterator elements(&amp;liveout);
1841         uint neighbor;
1842         while ((neighbor = elements.next()) != 0) {
1843           // Find reaching DEF for base and derived values
1844           // This works because we are still in SSA during this call.
1845           Node *derived = lrgs(neighbor)._def;
1846           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1847           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1848                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1849           // If its an OOP with a non-zero offset, then it is derived.
1850           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {
1851             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1852             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1853             // Add reaching DEFs of derived pointer and base pointer as a
1854             // pair of inputs
1855             n-&gt;add_req(derived);
1856             n-&gt;add_req(base);
1857 
1858             // See if the base pointer is already live to this point.
1859             // Since I&#39;m working on the SSA form, live-ness amounts to
1860             // reaching def&#39;s.  So if I find the base&#39;s live range then
1861             // I know the base&#39;s def reaches here.
1862             if ((_lrg_map.live_range_id(base) &gt;= _lrg_map.max_lrg_id() || // (Brand new base (hence not live) or
1863                  !liveout.member(_lrg_map.live_range_id(base))) &amp;&amp; // not live) AND
1864                  (_lrg_map.live_range_id(base) &gt; 0) &amp;&amp; // not a constant
1865                  _cfg.get_block_for_node(base) != block) { // base not def&#39;d in blk)
1866               // Base pointer is not currently live.  Since I stretched
1867               // the base pointer to here and it crosses basic-block
1868               // boundaries, the global live info is now incorrect.
1869               // Recompute live.
1870               must_recompute_live = true;
1871             } // End of if base pointer is not live to debug info
1872           }
1873         } // End of scan all live data for derived ptrs crossing GC point
1874       } // End of if found a GC point
1875 
1876       // Make all inputs live
1877       if (!n-&gt;is_Phi()) {      // Phi function uses come from prior block
1878         for (uint k = 1; k &lt; n-&gt;req(); k++) {
1879           uint lidx = _lrg_map.live_range_id(n-&gt;in(k));
1880           if (lidx &lt; _lrg_map.max_lrg_id()) {
1881             liveout.insert(lidx);
1882           }
1883         }
1884       }
1885 
1886     } // End of forall instructions in block
1887     liveout.clear();  // Free the memory used by liveout.
1888 
1889   } // End of forall blocks
1890   _lrg_map.set_max_lrg_id(maxlrg);
1891 
1892   // If I created a new live range I need to recompute live
1893   if (maxlrg != _ifg-&gt;_maxlrg) {
1894     must_recompute_live = true;
1895   }
1896 
1897   return must_recompute_live != 0;
1898 }
1899 
1900 // Extend the node to LRG mapping
1901 
1902 void PhaseChaitin::add_reference(const Node *node, const Node *old_node) {
1903   _lrg_map.extend(node-&gt;_idx, _lrg_map.live_range_id(old_node));
1904 }
1905 
1906 #ifndef PRODUCT
1907 void PhaseChaitin::dump(const Node *n) const {
1908   uint r = (n-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(n) : 0;
1909   tty-&gt;print(&quot;L%d&quot;,r);
1910   if (r &amp;&amp; n-&gt;Opcode() != Op_Phi) {
1911     if( _node_regs ) {          // Got a post-allocation copy of allocation?
1912       tty-&gt;print(&quot;[&quot;);
1913       OptoReg::Name second = get_reg_second(n);
1914       if( OptoReg::is_valid(second) ) {
1915         if( OptoReg::is_reg(second) )
1916           tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1917         else
1918           tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(second));
1919       }
1920       OptoReg::Name first = get_reg_first(n);
1921       if( OptoReg::is_reg(first) )
1922         tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1923       else
1924          tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(first));
1925     } else
1926     n-&gt;out_RegMask().dump();
1927   }
1928   tty-&gt;print(&quot;/N%d\t&quot;,n-&gt;_idx);
1929   tty-&gt;print(&quot;%s === &quot;, n-&gt;Name());
1930   uint k;
1931   for (k = 0; k &lt; n-&gt;req(); k++) {
1932     Node *m = n-&gt;in(k);
1933     if (!m) {
1934       tty-&gt;print(&quot;_ &quot;);
1935     }
1936     else {
1937       uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1938       tty-&gt;print(&quot;L%d&quot;,r);
1939       // Data MultiNode&#39;s can have projections with no real registers.
1940       // Don&#39;t die while dumping them.
1941       int op = n-&gt;Opcode();
1942       if( r &amp;&amp; op != Op_Phi &amp;&amp; op != Op_Proj &amp;&amp; op != Op_SCMemProj) {
1943         if( _node_regs ) {
1944           tty-&gt;print(&quot;[&quot;);
1945           OptoReg::Name second = get_reg_second(n-&gt;in(k));
1946           if( OptoReg::is_valid(second) ) {
1947             if( OptoReg::is_reg(second) )
1948               tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1949             else
1950               tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1951                          reg2offset_unchecked(second));
1952           }
1953           OptoReg::Name first = get_reg_first(n-&gt;in(k));
1954           if( OptoReg::is_reg(first) )
1955             tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1956           else
1957             tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1958                        reg2offset_unchecked(first));
1959         } else
1960           n-&gt;in_RegMask(k).dump();
1961       }
1962       tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1963     }
1964   }
1965   if( k &lt; n-&gt;len() &amp;&amp; n-&gt;in(k) ) tty-&gt;print(&quot;| &quot;);
1966   for( ; k &lt; n-&gt;len(); k++ ) {
1967     Node *m = n-&gt;in(k);
1968     if(!m) {
1969       break;
1970     }
1971     uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1972     tty-&gt;print(&quot;L%d&quot;,r);
1973     tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1974   }
1975   if( n-&gt;is_Mach() ) n-&gt;as_Mach()-&gt;dump_spec(tty);
1976   else n-&gt;dump_spec(tty);
1977   if( _spilled_once.test(n-&gt;_idx ) ) {
1978     tty-&gt;print(&quot; Spill_1&quot;);
1979     if( _spilled_twice.test(n-&gt;_idx ) )
1980       tty-&gt;print(&quot; Spill_2&quot;);
1981   }
1982   tty-&gt;print(&quot;\n&quot;);
1983 }
1984 
1985 void PhaseChaitin::dump(const Block *b) const {
1986   b-&gt;dump_head(&amp;_cfg);
1987 
1988   // For all instructions
1989   for( uint j = 0; j &lt; b-&gt;number_of_nodes(); j++ )
1990     dump(b-&gt;get_node(j));
1991   // Print live-out info at end of block
1992   if( _live ) {
1993     tty-&gt;print(&quot;Liveout: &quot;);
1994     IndexSet *live = _live-&gt;live(b);
1995     IndexSetIterator elements(live);
1996     tty-&gt;print(&quot;{&quot;);
1997     uint i;
1998     while ((i = elements.next()) != 0) {
1999       tty-&gt;print(&quot;L%d &quot;, _lrg_map.find_const(i));
2000     }
2001     tty-&gt;print_cr(&quot;}&quot;);
2002   }
2003   tty-&gt;print(&quot;\n&quot;);
2004 }
2005 
2006 void PhaseChaitin::dump() const {
2007   tty-&gt;print( &quot;--- Chaitin -- argsize: %d  framesize: %d ---\n&quot;,
2008               _matcher._new_SP, _framesize );
2009 
2010   // For all blocks
2011   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2012     dump(_cfg.get_block(i));
2013   }
2014   // End of per-block dump
2015   tty-&gt;print(&quot;\n&quot;);
2016 
2017   if (!_ifg) {
2018     tty-&gt;print(&quot;(No IFG.)\n&quot;);
2019     return;
2020   }
2021 
2022   // Dump LRG array
2023   tty-&gt;print(&quot;--- Live RanGe Array ---\n&quot;);
2024   for (uint i2 = 1; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
2025     tty-&gt;print(&quot;L%d: &quot;,i2);
2026     if (i2 &lt; _ifg-&gt;_maxlrg) {
2027       lrgs(i2).dump();
2028     }
2029     else {
2030       tty-&gt;print_cr(&quot;new LRG&quot;);
2031     }
2032   }
2033   tty-&gt;cr();
2034 
2035   // Dump lo-degree list
2036   tty-&gt;print(&quot;Lo degree: &quot;);
2037   for(uint i3 = _lo_degree; i3; i3 = lrgs(i3)._next )
2038     tty-&gt;print(&quot;L%d &quot;,i3);
2039   tty-&gt;cr();
2040 
2041   // Dump lo-stk-degree list
2042   tty-&gt;print(&quot;Lo stk degree: &quot;);
2043   for(uint i4 = _lo_stk_degree; i4; i4 = lrgs(i4)._next )
2044     tty-&gt;print(&quot;L%d &quot;,i4);
2045   tty-&gt;cr();
2046 
2047   // Dump lo-degree list
2048   tty-&gt;print(&quot;Hi degree: &quot;);
2049   for(uint i5 = _hi_degree; i5; i5 = lrgs(i5)._next )
2050     tty-&gt;print(&quot;L%d &quot;,i5);
2051   tty-&gt;cr();
2052 }
2053 
2054 void PhaseChaitin::dump_degree_lists() const {
2055   // Dump lo-degree list
2056   tty-&gt;print(&quot;Lo degree: &quot;);
2057   for( uint i = _lo_degree; i; i = lrgs(i)._next )
2058     tty-&gt;print(&quot;L%d &quot;,i);
2059   tty-&gt;cr();
2060 
2061   // Dump lo-stk-degree list
2062   tty-&gt;print(&quot;Lo stk degree: &quot;);
2063   for(uint i2 = _lo_stk_degree; i2; i2 = lrgs(i2)._next )
2064     tty-&gt;print(&quot;L%d &quot;,i2);
2065   tty-&gt;cr();
2066 
2067   // Dump lo-degree list
2068   tty-&gt;print(&quot;Hi degree: &quot;);
2069   for(uint i3 = _hi_degree; i3; i3 = lrgs(i3)._next )
2070     tty-&gt;print(&quot;L%d &quot;,i3);
2071   tty-&gt;cr();
2072 }
2073 
2074 void PhaseChaitin::dump_simplified() const {
2075   tty-&gt;print(&quot;Simplified: &quot;);
2076   for( uint i = _simplified; i; i = lrgs(i)._next )
2077     tty-&gt;print(&quot;L%d &quot;,i);
2078   tty-&gt;cr();
2079 }
2080 
2081 static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {
2082   if ((int)reg &lt; 0)
2083     sprintf(buf, &quot;&lt;OptoReg::%d&gt;&quot;, (int)reg);
2084   else if (OptoReg::is_reg(reg))
2085     strcpy(buf, Matcher::regName[reg]);
2086   else
2087     sprintf(buf,&quot;%s + #%d&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
2088             pc-&gt;reg2offset(reg));
2089   return buf+strlen(buf);
2090 }
2091 
2092 // Dump a register name into a buffer.  Be intelligent if we get called
2093 // before allocation is complete.
2094 char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
<a name="20" id="anc20"></a><span class="line-modified">2095   if( _node_regs ) {</span>


2096     // Post allocation, use direct mappings, no LRG info available
2097     print_reg( get_reg_first(n), this, buf );
2098   } else {
2099     uint lidx = _lrg_map.find_const(n); // Grab LRG number
2100     if( !_ifg ) {
2101       sprintf(buf,&quot;L%d&quot;,lidx);  // No register binding yet
2102     } else if( !lidx ) {        // Special, not allocated value
2103       strcpy(buf,&quot;Special&quot;);
2104     } else {
2105       if (lrgs(lidx)._is_vector) {
2106         if (lrgs(lidx).mask().is_bound_set(lrgs(lidx).num_regs()))
2107           print_reg( lrgs(lidx).reg(), this, buf ); // a bound machine register
2108         else
2109           sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2110       } else if( (lrgs(lidx).num_regs() == 1)
2111                  ? lrgs(lidx).mask().is_bound1()
2112                  : lrgs(lidx).mask().is_bound_pair() ) {
2113         // Hah!  We have a bound machine register
2114         print_reg( lrgs(lidx).reg(), this, buf );
2115       } else {
2116         sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2117       }
2118     }
2119   }
2120   return buf+strlen(buf);
2121 }
2122 
2123 void PhaseChaitin::dump_for_spill_split_recycle() const {
2124   if( WizardMode &amp;&amp; (PrintCompilation || PrintOpto) ) {
2125     // Display which live ranges need to be split and the allocator&#39;s state
2126     tty-&gt;print_cr(&quot;Graph-Coloring Iteration %d will split the following live ranges&quot;, _trip_cnt);
2127     for (uint bidx = 1; bidx &lt; _lrg_map.max_lrg_id(); bidx++) {
2128       if( lrgs(bidx).alive() &amp;&amp; lrgs(bidx).reg() &gt;= LRG::SPILL_REG ) {
2129         tty-&gt;print(&quot;L%d: &quot;, bidx);
2130         lrgs(bidx).dump();
2131       }
2132     }
2133     tty-&gt;cr();
2134     dump();
2135   }
2136 }
2137 
2138 void PhaseChaitin::dump_frame() const {
2139   const char *fp = OptoReg::regname(OptoReg::c_frame_pointer);
2140   const TypeTuple *domain = C-&gt;tf()-&gt;domain();
2141   const int        argcnt = domain-&gt;cnt() - TypeFunc::Parms;
2142 
2143   // Incoming arguments in registers dump
2144   for( int k = 0; k &lt; argcnt; k++ ) {
2145     OptoReg::Name parmreg = _matcher._parm_regs[k].first();
2146     if( OptoReg::is_reg(parmreg))  {
2147       const char *reg_name = OptoReg::regname(parmreg);
2148       tty-&gt;print(&quot;#r%3.3d %s&quot;, parmreg, reg_name);
2149       parmreg = _matcher._parm_regs[k].second();
2150       if( OptoReg::is_reg(parmreg))  {
2151         tty-&gt;print(&quot;:%s&quot;, OptoReg::regname(parmreg));
2152       }
2153       tty-&gt;print(&quot;   : parm %d: &quot;, k);
2154       domain-&gt;field_at(k + TypeFunc::Parms)-&gt;dump();
2155       tty-&gt;cr();
2156     }
2157   }
2158 
2159   // Check for un-owned padding above incoming args
2160   OptoReg::Name reg = _matcher._new_SP;
2161   if( reg &gt; _matcher._in_arg_limit ) {
2162     reg = OptoReg::add(reg, -1);
2163     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: pad0, owned by CALLER&quot;, reg, fp, reg2offset_unchecked(reg));
2164   }
2165 
2166   // Incoming argument area dump
2167   OptoReg::Name begin_in_arg = OptoReg::add(_matcher._old_SP,C-&gt;out_preserve_stack_slots());
2168   while( reg &gt; begin_in_arg ) {
2169     reg = OptoReg::add(reg, -1);
2170     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2171     int j;
2172     for( j = 0; j &lt; argcnt; j++) {
2173       if( _matcher._parm_regs[j].first() == reg ||
2174           _matcher._parm_regs[j].second() == reg ) {
2175         tty-&gt;print(&quot;parm %d: &quot;,j);
2176         domain-&gt;field_at(j + TypeFunc::Parms)-&gt;dump();
2177         tty-&gt;cr();
2178         break;
2179       }
2180     }
2181     if( j &gt;= argcnt )
2182       tty-&gt;print_cr(&quot;HOLE, owned by SELF&quot;);
2183   }
2184 
2185   // Old outgoing preserve area
2186   while( reg &gt; _matcher._old_SP ) {
2187     reg = OptoReg::add(reg, -1);
2188     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: old out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2189   }
2190 
2191   // Old SP
2192   tty-&gt;print_cr(&quot;# -- Old %s -- Framesize: %d --&quot;,fp,
2193     reg2offset_unchecked(OptoReg::add(_matcher._old_SP,-1)) - reg2offset_unchecked(_matcher._new_SP)+jintSize);
2194 
2195   // Preserve area dump
2196   int fixed_slots = C-&gt;fixed_slots();
2197   OptoReg::Name begin_in_preserve = OptoReg::add(_matcher._old_SP, -(int)C-&gt;in_preserve_stack_slots());
2198   OptoReg::Name return_addr = _matcher.return_addr();
2199 
2200   reg = OptoReg::add(reg, -1);
2201   while (OptoReg::is_stack(reg)) {
2202     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2203     if (return_addr == reg) {
2204       tty-&gt;print_cr(&quot;return address&quot;);
2205     } else if (reg &gt;= begin_in_preserve) {
2206       // Preserved slots are present on x86
2207       if (return_addr == OptoReg::add(reg, VMRegImpl::slots_per_word))
2208         tty-&gt;print_cr(&quot;saved fp register&quot;);
2209       else if (return_addr == OptoReg::add(reg, 2*VMRegImpl::slots_per_word) &amp;&amp;
2210                VerifyStackAtCalls)
2211         tty-&gt;print_cr(&quot;0xBADB100D   +VerifyStackAtCalls&quot;);
2212       else
2213         tty-&gt;print_cr(&quot;in_preserve&quot;);
2214     } else if ((int)OptoReg::reg2stack(reg) &lt; fixed_slots) {
2215       tty-&gt;print_cr(&quot;Fixed slot %d&quot;, OptoReg::reg2stack(reg));
2216     } else {
2217       tty-&gt;print_cr(&quot;pad2, stack alignment&quot;);
2218     }
2219     reg = OptoReg::add(reg, -1);
2220   }
2221 
2222   // Spill area dump
2223   reg = OptoReg::add(_matcher._new_SP, _framesize );
2224   while( reg &gt; _matcher._out_arg_limit ) {
2225     reg = OptoReg::add(reg, -1);
2226     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: spill&quot;,reg,fp,reg2offset_unchecked(reg));
2227   }
2228 
2229   // Outgoing argument area dump
2230   while( reg &gt; OptoReg::add(_matcher._new_SP, C-&gt;out_preserve_stack_slots()) ) {
2231     reg = OptoReg::add(reg, -1);
2232     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: outgoing argument&quot;,reg,fp,reg2offset_unchecked(reg));
2233   }
2234 
2235   // Outgoing new preserve area
2236   while( reg &gt; _matcher._new_SP ) {
2237     reg = OptoReg::add(reg, -1);
2238     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: new out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2239   }
2240   tty-&gt;print_cr(&quot;#&quot;);
2241 }
2242 
2243 void PhaseChaitin::dump_bb( uint pre_order ) const {
2244   tty-&gt;print_cr(&quot;---dump of B%d---&quot;,pre_order);
2245   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2246     Block* block = _cfg.get_block(i);
2247     if (block-&gt;_pre_order == pre_order) {
2248       dump(block);
2249     }
2250   }
2251 }
2252 
2253 void PhaseChaitin::dump_lrg( uint lidx, bool defs_only ) const {
2254   tty-&gt;print_cr(&quot;---dump of L%d---&quot;,lidx);
2255 
2256   if (_ifg) {
2257     if (lidx &gt;= _lrg_map.max_lrg_id()) {
2258       tty-&gt;print(&quot;Attempt to print live range index beyond max live range.\n&quot;);
2259       return;
2260     }
2261     tty-&gt;print(&quot;L%d: &quot;,lidx);
2262     if (lidx &lt; _ifg-&gt;_maxlrg) {
2263       lrgs(lidx).dump();
2264     } else {
2265       tty-&gt;print_cr(&quot;new LRG&quot;);
2266     }
2267   }
2268   if( _ifg &amp;&amp; lidx &lt; _ifg-&gt;_maxlrg) {
2269     tty-&gt;print(&quot;Neighbors: %d - &quot;, _ifg-&gt;neighbor_cnt(lidx));
2270     _ifg-&gt;neighbors(lidx)-&gt;dump();
2271     tty-&gt;cr();
2272   }
2273   // For all blocks
2274   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2275     Block* block = _cfg.get_block(i);
2276     int dump_once = 0;
2277 
2278     // For all instructions
2279     for( uint j = 0; j &lt; block-&gt;number_of_nodes(); j++ ) {
2280       Node *n = block-&gt;get_node(j);
2281       if (_lrg_map.find_const(n) == lidx) {
2282         if (!dump_once++) {
2283           tty-&gt;cr();
2284           block-&gt;dump_head(&amp;_cfg);
2285         }
2286         dump(n);
2287         continue;
2288       }
2289       if (!defs_only) {
2290         uint cnt = n-&gt;req();
2291         for( uint k = 1; k &lt; cnt; k++ ) {
2292           Node *m = n-&gt;in(k);
2293           if (!m)  {
2294             continue;  // be robust in the dumper
2295           }
2296           if (_lrg_map.find_const(m) == lidx) {
2297             if (!dump_once++) {
2298               tty-&gt;cr();
2299               block-&gt;dump_head(&amp;_cfg);
2300             }
2301             dump(n);
2302           }
2303         }
2304       }
2305     }
2306   } // End of per-block dump
2307   tty-&gt;cr();
2308 }
2309 #endif // not PRODUCT
2310 
2311 int PhaseChaitin::_final_loads  = 0;
2312 int PhaseChaitin::_final_stores = 0;
2313 int PhaseChaitin::_final_memoves= 0;
2314 int PhaseChaitin::_final_copies = 0;
2315 double PhaseChaitin::_final_load_cost  = 0;
2316 double PhaseChaitin::_final_store_cost = 0;
2317 double PhaseChaitin::_final_memove_cost= 0;
2318 double PhaseChaitin::_final_copy_cost  = 0;
2319 int PhaseChaitin::_conserv_coalesce = 0;
2320 int PhaseChaitin::_conserv_coalesce_pair = 0;
2321 int PhaseChaitin::_conserv_coalesce_trie = 0;
2322 int PhaseChaitin::_conserv_coalesce_quad = 0;
2323 int PhaseChaitin::_post_alloc = 0;
2324 int PhaseChaitin::_lost_opp_pp_coalesce = 0;
2325 int PhaseChaitin::_lost_opp_cflow_coalesce = 0;
2326 int PhaseChaitin::_used_cisc_instructions   = 0;
2327 int PhaseChaitin::_unused_cisc_instructions = 0;
2328 int PhaseChaitin::_allocator_attempts       = 0;
2329 int PhaseChaitin::_allocator_successes      = 0;
2330 
2331 #ifndef PRODUCT
2332 uint PhaseChaitin::_high_pressure           = 0;
2333 uint PhaseChaitin::_low_pressure            = 0;
2334 
2335 void PhaseChaitin::print_chaitin_statistics() {
2336   tty-&gt;print_cr(&quot;Inserted %d spill loads, %d spill stores, %d mem-mem moves and %d copies.&quot;, _final_loads, _final_stores, _final_memoves, _final_copies);
2337   tty-&gt;print_cr(&quot;Total load cost= %6.0f, store cost = %6.0f, mem-mem cost = %5.2f, copy cost = %5.0f.&quot;, _final_load_cost, _final_store_cost, _final_memove_cost, _final_copy_cost);
2338   tty-&gt;print_cr(&quot;Adjusted spill cost = %7.0f.&quot;,
2339                 _final_load_cost*4.0 + _final_store_cost  * 2.0 +
2340                 _final_copy_cost*1.0 + _final_memove_cost*12.0);
2341   tty-&gt;print(&quot;Conservatively coalesced %d copies, %d pairs&quot;,
2342                 _conserv_coalesce, _conserv_coalesce_pair);
2343   if( _conserv_coalesce_trie || _conserv_coalesce_quad )
2344     tty-&gt;print(&quot;, %d tries, %d quads&quot;, _conserv_coalesce_trie, _conserv_coalesce_quad);
2345   tty-&gt;print_cr(&quot;, %d post alloc.&quot;, _post_alloc);
2346   if( _lost_opp_pp_coalesce || _lost_opp_cflow_coalesce )
2347     tty-&gt;print_cr(&quot;Lost coalesce opportunity, %d private-private, and %d cflow interfered.&quot;,
2348                   _lost_opp_pp_coalesce, _lost_opp_cflow_coalesce );
2349   if( _used_cisc_instructions || _unused_cisc_instructions )
2350     tty-&gt;print_cr(&quot;Used cisc instruction  %d,  remained in register %d&quot;,
2351                    _used_cisc_instructions, _unused_cisc_instructions);
2352   if( _allocator_successes != 0 )
2353     tty-&gt;print_cr(&quot;Average allocation trips %f&quot;, (float)_allocator_attempts/(float)_allocator_successes);
2354   tty-&gt;print_cr(&quot;High Pressure Blocks = %d, Low Pressure Blocks = %d&quot;, _high_pressure, _low_pressure);
2355 }
2356 #endif // not PRODUCT
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
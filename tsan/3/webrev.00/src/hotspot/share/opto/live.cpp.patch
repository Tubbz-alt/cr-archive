diff a/src/hotspot/share/opto/live.cpp b/src/hotspot/share/opto/live.cpp
--- a/src/hotspot/share/opto/live.cpp
+++ b/src/hotspot/share/opto/live.cpp
@@ -82,11 +82,11 @@
     _defs[i].initialize(_maxlrg);
   }
 
   // Array of delta-set pointers, indexed by block pre_order-1.
   _deltas = NEW_RESOURCE_ARRAY(IndexSet*,_cfg.number_of_blocks());
-  memset( _deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());
+  memset(_deltas, 0, sizeof(IndexSet*)* _cfg.number_of_blocks());
 
   _free_IndexSet = NULL;
 
   // Blocks having done pass-1
   VectorSet first_pass(Thread::current()->resource_area());
@@ -106,12 +106,12 @@
         break;
       }
 
       uint r = _names.at(n->_idx);
       assert(!def_outside->member(r), "Use of external LRG overlaps the same LRG defined in this block");
-      def->insert( r );
-      use->remove( r );
+      def->insert(r);
+      use->remove(r);
       uint cnt = n->req();
       for (uint k = 1; k < cnt; k++) {
         Node *nk = n->in(k);
         uint nkidx = nk->_idx;
         if (_cfg.get_block_for_node(nk) != block) {
@@ -150,11 +150,11 @@
 
     // Inner loop: blocks that picked up new live-out values to be propagated
     while (_worklist->size()) {
       Block* block = _worklist->pop();
       IndexSet *delta = getset(block);
-      assert( delta->count(), "missing delta set" );
+      assert(delta->count(), "missing delta set");
 
       // Add new-live-in to predecessors live-out sets
       for (uint l = 1; l < block->num_preds(); l++) {
         Block* predecessor = _cfg.get_block_for_node(block->pred(l));
         add_liveout(predecessor, delta, first_pass);
@@ -189,117 +189,122 @@
 }
 #endif
 
 // Get an IndexSet for a block.  Return existing one, if any.  Make a new
 // empty one if a prior one does not exist.
-IndexSet *PhaseLive::getset( Block *p ) {
+IndexSet *PhaseLive::getset(Block *p) {
   IndexSet *delta = _deltas[p->_pre_order-1];
-  if( !delta )                  // Not on worklist?
+  if (!delta) {                 // Not on worklist?
     // Get a free set; flag as being on worklist
     delta = _deltas[p->_pre_order-1] = getfreeset();
+  }
   return delta;                 // Return set of new live-out items
 }
 
 // Pull from free list, or allocate.  Internal allocation on the returned set
 // is always from thread local storage.
-IndexSet *PhaseLive::getfreeset( ) {
+IndexSet *PhaseLive::getfreeset() {
   IndexSet *f = _free_IndexSet;
-  if( !f ) {
+  if (!f) {
     f = new IndexSet;
-//    f->set_arena(Thread::current()->resource_area());
     f->initialize(_maxlrg, Thread::current()->resource_area());
   } else {
     // Pull from free list
     _free_IndexSet = f->next();
-  //f->_cnt = 0;                        // Reset to empty
-//    f->set_arena(Thread::current()->resource_area());
     f->initialize(_maxlrg, Thread::current()->resource_area());
   }
   return f;
 }
 
 // Free an IndexSet from a block.
-void PhaseLive::freeset( Block *p ) {
+void PhaseLive::freeset(Block *p) {
   IndexSet *f = _deltas[p->_pre_order-1];
-  if ( _keep_deltas ) {
+  if (_keep_deltas) {
     add_livein(p, f);
   }
   f->set_next(_free_IndexSet);
   _free_IndexSet = f;           // Drop onto free list
   _deltas[p->_pre_order-1] = NULL;
 }
 
 // Add a live-out value to a given blocks live-out set.  If it is new, then
 // also add it to the delta set and stick the block on the worklist.
-void PhaseLive::add_liveout( Block *p, uint r, VectorSet &first_pass ) {
+void PhaseLive::add_liveout(Block *p, uint r, VectorSet &first_pass) {
   IndexSet *live = &_live[p->_pre_order-1];
-  if( live->insert(r) ) {       // If actually inserted...
+  if (live->insert(r)) {        // If actually inserted...
     // We extended the live-out set.  See if the value is generated locally.
     // If it is not, then we must extend the live-in set.
-    if( !_defs[p->_pre_order-1].member( r ) ) {
-      if( !_deltas[p->_pre_order-1] && // Not on worklist?
-          first_pass.test(p->_pre_order) )
+    if (!_defs[p->_pre_order-1].member(r)) {
+      if (!_deltas[p->_pre_order-1] && // Not on worklist?
+          first_pass.test(p->_pre_order)) {
         _worklist->push(p);     // Actually go on worklist if already 1st pass
+      }
       getset(p)->insert(r);
     }
   }
 }
 
 // Add a vector of live-out values to a given blocks live-out set.
-void PhaseLive::add_liveout( Block *p, IndexSet *lo, VectorSet &first_pass ) {
+void PhaseLive::add_liveout(Block *p, IndexSet *lo, VectorSet &first_pass) {
   IndexSet *live = &_live[p->_pre_order-1];
   IndexSet *defs = &_defs[p->_pre_order-1];
   IndexSet *on_worklist = _deltas[p->_pre_order-1];
   IndexSet *delta = on_worklist ? on_worklist : getfreeset();
 
-  IndexSetIterator elements(lo);
-  uint r;
-  while ((r = elements.next()) != 0) {
-    if( live->insert(r) &&      // If actually inserted...
-        !defs->member( r ) )    // and not defined locally
-      delta->insert(r);         // Then add to live-in set
+  if (!lo->is_empty()) {
+    IndexSetIterator elements(lo);
+    uint r;
+    while ((r = elements.next()) != 0) {
+      if (live->insert(r) &&      // If actually inserted...
+          !defs->member(r)) {     // and not defined locally
+        delta->insert(r);         // Then add to live-in set
+      }
+    }
   }
 
-  if( delta->count() ) {                // If actually added things
+  if (delta->count()) {                // If actually added things
     _deltas[p->_pre_order-1] = delta; // Flag as on worklist now
-    if( !on_worklist &&         // Not on worklist?
-        first_pass.test(p->_pre_order) )
+    if (!on_worklist &&         // Not on worklist?
+        first_pass.test(p->_pre_order)) {
       _worklist->push(p);       // Actually go on worklist if already 1st pass
+    }
   } else {                      // Nothing there; just free it
     delta->set_next(_free_IndexSet);
     _free_IndexSet = delta;     // Drop onto free list
   }
 }
 
 // Add a vector of live-in values to a given blocks live-in set.
 void PhaseLive::add_livein(Block *p, IndexSet *lo) {
   IndexSet *livein = &_livein[p->_pre_order-1];
-  IndexSetIterator elements(lo);
-  uint r;
-  while ((r = elements.next()) != 0) {
-    livein->insert(r);         // Then add to live-in set
+  if (!livein->is_empty()) {
+    IndexSetIterator elements(lo);
+    uint r;
+    while ((r = elements.next()) != 0) {
+      livein->insert(r);         // Then add to live-in set
+    }
   }
 }
 
 #ifndef PRODUCT
 // Dump the live-out set for a block
-void PhaseLive::dump( const Block *b ) const {
+void PhaseLive::dump(const Block *b) const {
   tty->print("Block %d: ",b->_pre_order);
-  if ( _keep_deltas ) {
+  if (_keep_deltas) {
     tty->print("LiveIn: ");  _livein[b->_pre_order-1].dump();
   }
   tty->print("LiveOut: ");  _live[b->_pre_order-1].dump();
   uint cnt = b->number_of_nodes();
-  for( uint i=0; i<cnt; i++ ) {
+  for (uint i = 0; i < cnt; i++) {
     tty->print("L%d/", _names.at(b->get_node(i)->_idx));
     b->get_node(i)->dump();
   }
   tty->print("\n");
 }
 
 // Verify that base pointers and derived pointers are still sane.
-void PhaseChaitin::verify_base_ptrs( ResourceArea *a ) const {
+void PhaseChaitin::verify_base_ptrs(ResourceArea *a) const {
 #ifdef ASSERT
   Unique_Node_List worklist(a);
   for (uint i = 0; i < _cfg.number_of_blocks(); i++) {
     Block* block = _cfg.get_block(i);
     for (uint j = block->end_idx() + 1; j > 1; j--) {
@@ -320,21 +325,21 @@
               bool is_derived = ((idx - jvms->oopoff()) & 1) == 0;
               // search upwards through spills and spill phis for AddP
               worklist.clear();
               worklist.push(check);
               uint k = 0;
-              while( k < worklist.size() ) {
+              while (k < worklist.size()) {
                 check = worklist.at(k);
                 assert(check,"Bad base or derived pointer");
                 // See PhaseChaitin::find_base_for_derived() for all cases.
                 int isc = check->is_Copy();
-                if( isc ) {
+                if (isc) {
                   worklist.push(check->in(isc));
-                } else if( check->is_Phi() ) {
+                } else if (check->is_Phi()) {
                   for (uint m = 1; m < check->req(); m++)
                     worklist.push(check->in(m));
-                } else if( check->is_Con() ) {
+                } else if (check->is_Con()) {
                   if (is_derived) {
                     // Derived is NULL+offset
                     assert(!is_derived || check->bottom_type()->is_ptr()->ptr() == TypePtr::Null,"Bad derived pointer");
                   } else {
                     assert(check->bottom_type()->is_ptr()->_offset == 0,"Bad base pointer");
@@ -344,12 +349,12 @@
                     } else {
                       assert(check->Opcode() == Op_ConP &&
                              check->bottom_type()->is_ptr()->ptr() == TypePtr::Null,"Bad base pointer");
                     }
                   }
-                } else if( check->bottom_type()->is_ptr()->_offset == 0 ) {
-                  if(check->is_Proj() || (check->is_Mach() &&
+                } else if (check->bottom_type()->is_ptr()->_offset == 0) {
+                  if (check->is_Proj() || (check->is_Mach() &&
                      (check->as_Mach()->ideal_Opcode() == Op_CreateEx ||
                       check->as_Mach()->ideal_Opcode() == Op_ThreadLocal ||
                       check->as_Mach()->ideal_Opcode() == Op_CMoveP ||
                       check->as_Mach()->ideal_Opcode() == Op_CheckCastPP ||
 #ifdef _LP64
@@ -379,13 +384,13 @@
   } // End of forall blocks
 #endif
 }
 
 // Verify that graphs and base pointers are still sane.
-void PhaseChaitin::verify( ResourceArea *a, bool verify_ifg ) const {
+void PhaseChaitin::verify(ResourceArea *a, bool verify_ifg) const {
 #ifdef ASSERT
-  if( VerifyOpto || VerifyRegisterAllocator ) {
+  if (VerifyRegisterAllocator) {
     _cfg.verify();
     verify_base_ptrs(a);
     if(verify_ifg)
       _ifg->verify(this);
   }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/escape.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="doCall.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="escape.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/escape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,10 ***</span>
<span class="line-new-header">--- 348,16 ---</span>
    uint n_idx = n-&gt;_idx;
    PointsToNode* n_ptn = ptnode_adr(n_idx);
    if (n_ptn != NULL)
      return; // No need to redefine PointsTo node during first iteration.
  
<span class="line-added">+   int opcode = n-&gt;Opcode();</span>
<span class="line-added">+   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_to_con_graph(this, igvn, delayed_worklist, n, opcode);</span>
<span class="line-added">+   if (gc_handled) {</span>
<span class="line-added">+     return; // Ignore node if already handled by GC.</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (n-&gt;is_Call()) {
      // Arguments to allocation and locking don&#39;t escape.
      if (n-&gt;is_AbstractLock()) {
        // Put Lock and Unlock nodes on IGVN worklist to process them during
        // first IGVN optimization when escape information is still available.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,15 ***</span>
    // Put this check here to process call arguments since some call nodes
    // point to phantom_obj.
    if (n_ptn == phantom_obj || n_ptn == null_obj)
      return; // Skip predefined nodes.
  
<span class="line-removed">-   int opcode = n-&gt;Opcode();</span>
<span class="line-removed">-   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_to_con_graph(this, igvn, delayed_worklist, n, opcode);</span>
<span class="line-removed">-   if (gc_handled) {</span>
<span class="line-removed">-     return; // Ignore node if already handled by GC.</span>
<span class="line-removed">-   }</span>
    switch (opcode) {
      case Op_AddP: {
        Node* base = get_addp_base(n);
        PointsToNode* ptn_base = ptnode_adr(base-&gt;_idx);
        // Field nodes are created for all field types. They are used in
<span class="line-new-header">--- 386,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 987,10 ***</span>
<span class="line-new-header">--- 988,12 ---</span>
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesAdler32&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_encryptBlock&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_decryptBlock&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_encryptAESCrypt&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_decryptAESCrypt&quot;) == 0 ||
<span class="line-added">+                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_encryptAESCrypt&quot;) == 0 ||</span>
<span class="line-added">+                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_decryptAESCrypt&quot;) == 0 ||</span>
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;counterMode_AESCrypt&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;ghash_processBlocks&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;encodeBlock&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompress&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompressMB&quot;) == 0 ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1001,10 ***</span>
<span class="line-new-header">--- 1004,12 ---</span>
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;multiplyToLen&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;squareToLen&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;mulAdd&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_multiply&quot;) == 0 ||
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_square&quot;) == 0 ||
<span class="line-added">+                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerRightShiftWorker&quot;) == 0 ||</span>
<span class="line-added">+                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerLeftShiftWorker&quot;) == 0 ||</span>
                    strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;vectorizedMismatch&quot;) == 0)
                   ))) {
              call-&gt;dump();
              fatal(&quot;EA unexpected CallLeaf %s&quot;, call-&gt;as_CallLeaf()-&gt;_name);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,11 ***</span>
        // related field nodes (same base and offset).
        add_field_uses_to_worklist(use-&gt;as_Field());
      }
    }
    _worklist.clear();
<span class="line-modified">!   _in_worklist.Reset();</span>
    return new_edges;
  }
  
  // Put on worklist all related field nodes.
  void ConnectionGraph::add_field_uses_to_worklist(FieldNode* field) {
<span class="line-new-header">--- 1414,11 ---</span>
        // related field nodes (same base and offset).
        add_field_uses_to_worklist(use-&gt;as_Field());
      }
    }
    _worklist.clear();
<span class="line-modified">!   _in_worklist.reset();</span>
    return new_edges;
  }
  
  // Put on worklist all related field nodes.
  void ConnectionGraph::add_field_uses_to_worklist(FieldNode* field) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2108,11 ***</span>
            BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
          bt = T_OBJECT;
        }
      }
    }
<span class="line-modified">!   return (bt == T_OBJECT || bt == T_NARROWOOP || bt == T_ARRAY);</span>
  }
  
  // Returns unique pointed java object or NULL.
  JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {
    assert(!_collecting, &quot;should not call when contructed graph&quot;);
<span class="line-new-header">--- 2113,12 ---</span>
            BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
          bt = T_OBJECT;
        }
      }
    }
<span class="line-modified">!   // Note: T_NARROWOOP is not classed as a real reference type</span>
<span class="line-added">+   return (is_reference_type(bt) || bt == T_NARROWOOP);</span>
  }
  
  // Returns unique pointed java object or NULL.
  JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {
    assert(!_collecting, &quot;should not call when contructed graph&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2120,10 ***</span>
<span class="line-new-header">--- 2126,13 ---</span>
    uint idx = n-&gt;_idx;
    if (idx &gt;= nodes_size()) {
      return NULL;
    }
    PointsToNode* ptn = ptnode_adr(idx);
<span class="line-added">+   if (ptn == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
    if (ptn-&gt;is_JavaObject()) {
      return ptn-&gt;as_JavaObject();
    }
    assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
    // Check all java objects it points to.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2173,10 ***</span>
<span class="line-new-header">--- 2182,13 ---</span>
    uint idx = n-&gt;_idx;
    if (idx &gt;= nodes_size()) {
      return false;
    }
    PointsToNode* ptn = ptnode_adr(idx);
<span class="line-added">+   if (ptn == NULL) {</span>
<span class="line-added">+     return false; // not in congraph (e.g. ConI)</span>
<span class="line-added">+   }</span>
    PointsToNode::EscapeState es = ptn-&gt;escape_state();
    // If we have already computed a value, return it.
    if (es &gt;= PointsToNode::GlobalEscape)
      return false;
    if (ptn-&gt;is_JavaObject()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2344,12 ***</span>
        Node* uncast_base = base-&gt;uncast();
        int opcode = uncast_base-&gt;Opcode();
        assert(opcode == Op_ConP || opcode == Op_ThreadLocal ||
               opcode == Op_CastX2P || uncast_base-&gt;is_DecodeNarrowPtr() ||
               (uncast_base-&gt;is_Mem() &amp;&amp; (uncast_base-&gt;bottom_type()-&gt;isa_rawptr() != NULL)) ||
<span class="line-modified">!              (uncast_base-&gt;is_Proj() &amp;&amp; uncast_base-&gt;in(0)-&gt;is_Allocate()) ||</span>
<span class="line-removed">-              BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_is_barrier_node(uncast_base), &quot;sanity&quot;);</span>
      }
    }
    return base;
  }
  
<span class="line-new-header">--- 2356,11 ---</span>
        Node* uncast_base = base-&gt;uncast();
        int opcode = uncast_base-&gt;Opcode();
        assert(opcode == Op_ConP || opcode == Op_ThreadLocal ||
               opcode == Op_CastX2P || uncast_base-&gt;is_DecodeNarrowPtr() ||
               (uncast_base-&gt;is_Mem() &amp;&amp; (uncast_base-&gt;bottom_type()-&gt;isa_rawptr() != NULL)) ||
<span class="line-modified">!              (uncast_base-&gt;is_Proj() &amp;&amp; uncast_base-&gt;in(0)-&gt;is_Allocate()), &quot;sanity&quot;);</span>
      }
    }
    return base;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2733,15 ***</span>
          // which contains this memory slice, otherwise skip over it.
          if (alloc == NULL || alloc-&gt;_idx != (uint)toop-&gt;instance_id()) {
            result = proj_in-&gt;in(TypeFunc::Memory);
          }
        } else if (proj_in-&gt;is_MemBar()) {
<span class="line-modified">!         if (proj_in-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem() &amp;&amp;</span>
<span class="line-modified">!             proj_in-&gt;in(TypeFunc::Memory)-&gt;as_MergeMem()-&gt;in(Compile::AliasIdxRaw)-&gt;is_Proj() &amp;&amp;</span>
<span class="line-modified">!             proj_in-&gt;in(TypeFunc::Memory)-&gt;as_MergeMem()-&gt;in(Compile::AliasIdxRaw)-&gt;in(0)-&gt;is_ArrayCopy()) {</span>
<span class="line-modified">!           // clone</span>
<span class="line-modified">!           ArrayCopyNode* ac = proj_in-&gt;in(TypeFunc::Memory)-&gt;as_MergeMem()-&gt;in(Compile::AliasIdxRaw)-&gt;in(0)-&gt;as_ArrayCopy();</span>
            if (ac-&gt;may_modify(toop, igvn)) {
              break;
            }
          }
          result = proj_in-&gt;in(TypeFunc::Memory);
<span class="line-new-header">--- 2744,18 ---</span>
          // which contains this memory slice, otherwise skip over it.
          if (alloc == NULL || alloc-&gt;_idx != (uint)toop-&gt;instance_id()) {
            result = proj_in-&gt;in(TypeFunc::Memory);
          }
        } else if (proj_in-&gt;is_MemBar()) {
<span class="line-modified">!         // Check if there is an array copy for a clone</span>
<span class="line-modified">!         // Step over GC barrier when ReduceInitialCardMarks is disabled</span>
<span class="line-modified">!         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified">!         Node* control_proj_ac = bs-&gt;step_over_gc_barrier(proj_in-&gt;in(0));</span>
<span class="line-modified">! </span>
<span class="line-added">+         if (control_proj_ac-&gt;is_Proj() &amp;&amp; control_proj_ac-&gt;in(0)-&gt;is_ArrayCopy()) {</span>
<span class="line-added">+           // Stop if it is a clone</span>
<span class="line-added">+           ArrayCopyNode* ac = control_proj_ac-&gt;in(0)-&gt;as_ArrayCopy();</span>
            if (ac-&gt;may_modify(toop, igvn)) {
              break;
            }
          }
          result = proj_in-&gt;in(TypeFunc::Memory);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3083,11 ***</span>
        if (!split_AddP(n, base)) continue; // wrong type from dead path
      } else if (n-&gt;is_Phi() ||
                 n-&gt;is_CheckCastPP() ||
                 n-&gt;is_EncodeP() ||
                 n-&gt;is_DecodeN() ||
<span class="line-removed">-                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_is_barrier_node(n) ||</span>
                 (n-&gt;is_ConstraintCast() &amp;&amp; n-&gt;Opcode() == Op_CastPP)) {
        if (visited.test_set(n-&gt;_idx)) {
          assert(n-&gt;is_Phi(), &quot;loops only through Phi&#39;s&quot;);
          continue;  // already processed
        }
<span class="line-new-header">--- 3097,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3154,11 ***</span>
          alloc_worklist.append_if_missing(use);
        } else if (use-&gt;is_Phi() ||
                   use-&gt;is_CheckCastPP() ||
                   use-&gt;is_EncodeNarrowPtr() ||
                   use-&gt;is_DecodeNarrowPtr() ||
<span class="line-removed">-                  BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_is_barrier_node(use) ||</span>
                   (use-&gt;is_ConstraintCast() &amp;&amp; use-&gt;Opcode() == Op_CastPP)) {
          alloc_worklist.append_if_missing(use);
  #ifdef ASSERT
        } else if (use-&gt;is_Mem()) {
          assert(use-&gt;in(MemNode::Address) != n, &quot;EA: missing allocation reference path&quot;);
<span class="line-new-header">--- 3167,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3185,10 ***</span>
<span class="line-new-header">--- 3197,11 ---</span>
          } else if (!(op == Op_CmpP || op == Op_Conv2B ||
                op == Op_CastP2X || op == Op_StoreCM ||
                op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||
                op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||
                op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||
<span class="line-added">+               op == Op_SubTypeCheck ||</span>
                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(use))) {
            n-&gt;dump();
            use-&gt;dump();
            assert(false, &quot;EA: missing allocation reference path&quot;);
          }
</pre>
<center><a href="doCall.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="escape.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/doCall.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="divnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="escape.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/doCall.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,12 ***</span>
      CallGenerator* cg = CallGenerator::for_method_handle_call(jvms, caller, callee, delayed_forbidden);
      assert(cg == NULL || !delayed_forbidden || !cg-&gt;is_late_inline() || cg-&gt;is_mh_late_inline(), &quot;unexpected CallGenerator&quot;);
      return cg;
    }
  
<span class="line-modified">!   // Do not inline strict fp into non-strict code, or the reverse</span>
<span class="line-modified">!   if (caller-&gt;is_strict() ^ callee-&gt;is_strict()) {</span>
      allow_inline = false;
    }
  
    // Attempt to inline...
    if (allow_inline) {
<span class="line-new-header">--- 148,13 ---</span>
      CallGenerator* cg = CallGenerator::for_method_handle_call(jvms, caller, callee, delayed_forbidden);
      assert(cg == NULL || !delayed_forbidden || !cg-&gt;is_late_inline() || cg-&gt;is_mh_late_inline(), &quot;unexpected CallGenerator&quot;);
      return cg;
    }
  
<span class="line-modified">!   // If explicit rounding is required, do not inline strict into non-strict code (or the reverse).</span>
<span class="line-modified">!   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp;</span>
<span class="line-added">+       caller-&gt;is_strict() != callee-&gt;is_strict()) {</span>
      allow_inline = false;
    }
  
    // Attempt to inline...
    if (allow_inline) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,14 ***</span>
      // it&#39;s 0 then no class implements decl_interface and there&#39;s
      // no point in inlining.
      if (call_does_dispatch &amp;&amp; bytecode == Bytecodes::_invokeinterface) {
        ciInstanceKlass* declared_interface =
            caller-&gt;get_declared_method_holder_at_bci(bci)-&gt;as_instance_klass();
  
<span class="line-modified">!       if (declared_interface-&gt;nof_implementors() == 1 &amp;&amp;</span>
            (!callee-&gt;is_default_method() || callee-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet */) {
<span class="line-modified">!         ciInstanceKlass* singleton = declared_interface-&gt;implementor();</span>
          ciMethod* cha_monomorphic_target =
              callee-&gt;find_monomorphic_target(caller-&gt;holder(), declared_interface, singleton);
  
          if (cha_monomorphic_target != NULL &amp;&amp;
              cha_monomorphic_target-&gt;holder() != env()-&gt;Object_klass()) { // subtype check against Object is useless
<span class="line-new-header">--- 309,16 ---</span>
      // it&#39;s 0 then no class implements decl_interface and there&#39;s
      // no point in inlining.
      if (call_does_dispatch &amp;&amp; bytecode == Bytecodes::_invokeinterface) {
        ciInstanceKlass* declared_interface =
            caller-&gt;get_declared_method_holder_at_bci(bci)-&gt;as_instance_klass();
<span class="line-added">+       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();</span>
  
<span class="line-modified">!       if (singleton != NULL &amp;&amp;</span>
            (!callee-&gt;is_default_method() || callee-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet */) {
<span class="line-modified">!         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);</span>
<span class="line-added">+ </span>
          ciMethod* cha_monomorphic_target =
              callee-&gt;find_monomorphic_target(caller-&gt;holder(), declared_interface, singleton);
  
          if (cha_monomorphic_target != NULL &amp;&amp;
              cha_monomorphic_target-&gt;holder() != env()-&gt;Object_klass()) { // subtype check against Object is useless
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,12 ***</span>
            // The Java code knows this, at VerifyType.isNullConversion.
            pop_node(rt);  // whatever it was, pop it
          } else if (rt == T_INT || is_subword_type(rt)) {
            // Nothing.  These cases are handled in lambda form bytecode.
            assert(ct == T_INT || is_subword_type(ct), &quot;must match: rt=%s, ct=%s&quot;, type2name(rt), type2name(ct));
<span class="line-modified">!         } else if (rt == T_OBJECT || rt == T_ARRAY) {</span>
<span class="line-modified">!           assert(ct == T_OBJECT || ct == T_ARRAY, &quot;rt=%s, ct=%s&quot;, type2name(rt), type2name(ct));</span>
            if (ctype-&gt;is_loaded()) {
              const TypeOopPtr* arg_type = TypeOopPtr::make_from_klass(rtype-&gt;as_klass());
              const Type*       sig_type = TypeOopPtr::make_from_klass(ctype-&gt;as_klass());
              if (arg_type != NULL &amp;&amp; !arg_type-&gt;higher_equal(sig_type)) {
                Node* retnode = pop();
<span class="line-new-header">--- 701,12 ---</span>
            // The Java code knows this, at VerifyType.isNullConversion.
            pop_node(rt);  // whatever it was, pop it
          } else if (rt == T_INT || is_subword_type(rt)) {
            // Nothing.  These cases are handled in lambda form bytecode.
            assert(ct == T_INT || is_subword_type(ct), &quot;must match: rt=%s, ct=%s&quot;, type2name(rt), type2name(ct));
<span class="line-modified">!         } else if (is_reference_type(rt)) {</span>
<span class="line-modified">!           assert(is_reference_type(ct), &quot;rt=%s, ct=%s&quot;, type2name(rt), type2name(ct));</span>
            if (ctype-&gt;is_loaded()) {
              const TypeOopPtr* arg_type = TypeOopPtr::make_from_klass(rtype-&gt;as_klass());
              const Type*       sig_type = TypeOopPtr::make_from_klass(ctype-&gt;as_klass());
              if (arg_type != NULL &amp;&amp; !arg_type-&gt;higher_equal(sig_type)) {
                Node* retnode = pop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,11 ***</span>
        set_bci(iter().next_bci());
        null_assert(peek());
        set_bci(iter().cur_bci()); // put it back
      }
      BasicType ct = ctype-&gt;basic_type();
<span class="line-modified">!     if (ct == T_OBJECT || ct == T_ARRAY) {</span>
        record_profiled_return_for_speculation();
      }
    }
  
    // Restart record of parsing work after possible inlining of call
<span class="line-new-header">--- 749,11 ---</span>
        set_bci(iter().next_bci());
        null_assert(peek());
        set_bci(iter().cur_bci()); // put it back
      }
      BasicType ct = ctype-&gt;basic_type();
<span class="line-modified">!     if (is_reference_type(ct)) {</span>
        record_profiled_return_for_speculation();
      }
    }
  
    // Restart record of parsing work after possible inlining of call
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1150,18 ***</span>
                         log()-&gt;identify(cha_monomorphic_target));
        }
        cha_monomorphic_target = NULL;
      }
    }
    if (cha_monomorphic_target != NULL) {
      // Hardwiring a virtual.
<span class="line-modified">!     // If we inlined because CHA revealed only a single target method,</span>
<span class="line-modified">!     // then we are dependent on that target method not getting overridden</span>
<span class="line-modified">!     // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver</span>
<span class="line-modified">!     // dest_method here, as opposed to the actual receiver, which may</span>
<span class="line-modified">!     // falsely lead us to believe that the receiver is final or private.</span>
<span class="line-modified">!     dependencies()-&gt;assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);</span>
      return cha_monomorphic_target;
    }
  
    // If the type is exact, we can still bind the method w/o a vcall.
    // (This case comes after CHA so we can see how much extra work it does.)
<span class="line-new-header">--- 1153,23 ---</span>
                         log()-&gt;identify(cha_monomorphic_target));
        }
        cha_monomorphic_target = NULL;
      }
    }
<span class="line-added">+ </span>
    if (cha_monomorphic_target != NULL) {
      // Hardwiring a virtual.
<span class="line-modified">!     assert(!callee-&gt;can_be_statically_bound(), &quot;should have been handled earlier&quot;);</span>
<span class="line-modified">!     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);</span>
<span class="line-modified">!     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_receiver)) {</span>
<span class="line-modified">!       // If we inlined because CHA revealed only a single target method,</span>
<span class="line-modified">!       // then we are dependent on that target method not getting overridden</span>
<span class="line-modified">!       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver</span>
<span class="line-added">+       // dest_method here, as opposed to the actual receiver, which may</span>
<span class="line-added">+       // falsely lead us to believe that the receiver is final or private.</span>
<span class="line-added">+       dependencies()-&gt;assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);</span>
<span class="line-added">+     }</span>
      return cha_monomorphic_target;
    }
  
    // If the type is exact, we can still bind the method w/o a vcall.
    // (This case comes after CHA so we can see how much extra work it does.)
</pre>
<center><a href="divnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="escape.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopPredicate.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopTransform.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,17 ***</span>
  
  //------------------------------is_loop_exit-----------------------------------
  // Given an IfNode, return the loop-exiting projection or NULL if both
  // arms remain in the loop.
  Node *IdealLoopTree::is_loop_exit(Node *iff) const {
<span class="line-modified">!   if( iff-&gt;outcnt() != 2 ) return NULL; // Ignore partially dead tests</span>
    PhaseIdealLoop *phase = _phase;
    // Test is an IfNode, has 2 projections.  If BOTH are in the loop
    // we need loop unswitching instead of peeling.
<span class="line-modified">!   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(0) )) )</span>
      return iff-&gt;raw_out(0);
<span class="line-modified">!   if( !is_member(phase-&gt;get_loop( iff-&gt;raw_out(1) )) )</span>
      return iff-&gt;raw_out(1);
    return NULL;
  }
  
  
<span class="line-new-header">--- 43,17 ---</span>
  
  //------------------------------is_loop_exit-----------------------------------
  // Given an IfNode, return the loop-exiting projection or NULL if both
  // arms remain in the loop.
  Node *IdealLoopTree::is_loop_exit(Node *iff) const {
<span class="line-modified">!   if (iff-&gt;outcnt() != 2) return NULL;  // Ignore partially dead tests</span>
    PhaseIdealLoop *phase = _phase;
    // Test is an IfNode, has 2 projections.  If BOTH are in the loop
    // we need loop unswitching instead of peeling.
<span class="line-modified">!   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(0))))</span>
      return iff-&gt;raw_out(0);
<span class="line-modified">!   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(1))))</span>
      return iff-&gt;raw_out(1);
    return NULL;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,11 ***</span>
  
  
  //------------------------------record_for_igvn----------------------------
  // Put loop body on igvn work list
  void IdealLoopTree::record_for_igvn() {
<span class="line-modified">!   for( uint i = 0; i &lt; _body.size(); i++ ) {</span>
      Node *n = _body.at(i);
      _phase-&gt;_igvn._worklist.push(n);
    }
    // put body of outer strip mined loop on igvn work list as well
    if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
<span class="line-new-header">--- 61,11 ---</span>
  
  
  //------------------------------record_for_igvn----------------------------
  // Put loop body on igvn work list
  void IdealLoopTree::record_for_igvn() {
<span class="line-modified">!   for (uint i = 0; i &lt; _body.size(); i++) {</span>
      Node *n = _body.at(i);
      _phase-&gt;_igvn._worklist.push(n);
    }
    // put body of outer strip mined loop on igvn work list as well
    if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
      IfNode *iff = n-&gt;as_If();
      if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
        Node *exit = is_loop_exit(iff);
        if (exit) {
          float exit_prob = iff-&gt;_prob;
<span class="line-modified">!         if (exit-&gt;Opcode() == Op_IfFalse) exit_prob = 1.0 - exit_prob;</span>
          if (exit_prob &gt; PROB_MIN) {
            float exit_cnt = iff-&gt;_fcnt * exit_prob;
            return exit_cnt;
          }
        }
<span class="line-new-header">--- 143,13 ---</span>
      IfNode *iff = n-&gt;as_If();
      if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
        Node *exit = is_loop_exit(iff);
        if (exit) {
          float exit_prob = iff-&gt;_prob;
<span class="line-modified">!         if (exit-&gt;Opcode() == Op_IfFalse) {</span>
<span class="line-added">+           exit_prob = 1.0 - exit_prob;</span>
<span class="line-added">+         }</span>
          if (exit_prob &gt; PROB_MIN) {
            float exit_cnt = iff-&gt;_fcnt * exit_prob;
            return exit_cnt;
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,11 ***</span>
      float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
  
      // Now compute a loop exit count
      float loop_exit_cnt = 0.0f;
      if (_child == NULL) {
<span class="line-modified">!       for( uint i = 0; i &lt; _body.size(); i++ ) {</span>
          Node *n = _body[i];
          loop_exit_cnt += compute_profile_trip_cnt_helper(n);
        }
      } else {
        ResourceMark rm;
<span class="line-new-header">--- 202,11 ---</span>
      float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
  
      // Now compute a loop exit count
      float loop_exit_cnt = 0.0f;
      if (_child == NULL) {
<span class="line-modified">!       for (uint i = 0; i &lt; _body.size(); i++) {</span>
          Node *n = _body[i];
          loop_exit_cnt += compute_profile_trip_cnt_helper(n);
        }
      } else {
        ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,10 ***</span>
<span class="line-new-header">--- 284,13 ---</span>
    if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
    Node* inv1 = n1-&gt;in(inv1_idx);
    Node* n2 = n1-&gt;in(3 - inv1_idx);
    int inv2_idx = is_invariant_addition(n2, phase);
    if (!inv2_idx) return NULL;
<span class="line-added">+ </span>
<span class="line-added">+   if (!phase-&gt;may_require_nodes(10, 10)) return NULL;</span>
<span class="line-added">+ </span>
    Node* x    = n2-&gt;in(3 - inv2_idx);
    Node* inv2 = n2-&gt;in(inv2_idx);
  
    bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
    bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,85 ***</span>
      Node *n = _body.at(i);
      for (int j = 0; j &lt; 5; j++) {
        Node* nn = reassociate_add_sub(n, phase);
        if (nn == NULL) break;
        n = nn; // again
<span class="line-modified">!     };</span>
    }
  }
  
  //------------------------------policy_peeling---------------------------------
<span class="line-modified">! // Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can</span>
<span class="line-modified">! // make some loop-invariant test (usually a null-check) happen before the loop.</span>
<span class="line-modified">! bool IdealLoopTree::policy_peeling( PhaseIdealLoop *phase ) const {</span>
<span class="line-modified">!   Node *test = ((IdealLoopTree*)this)-&gt;tail();</span>
<span class="line-modified">!   int  body_size = ((IdealLoopTree*)this)-&gt;_body.size();</span>
<span class="line-modified">!   // Peeling does loop cloning which can result in O(N^2) node construction</span>
<span class="line-modified">!   if( body_size &gt; 255 /* Prevent overflow for large body_size */</span>
<span class="line-modified">!       || (body_size * body_size + phase-&gt;C-&gt;live_nodes()) &gt; phase-&gt;C-&gt;max_node_limit() ) {</span>
<span class="line-modified">!     return false;           // too large to safely clone</span>
    }
  
<span class="line-modified">!   // check for vectorized loops, any peeling done was already applied</span>
<span class="line-modified">!   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;</span>
  
<span class="line-modified">!   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;trip_count() == 1) {</span>
<span class="line-modified">!     return false;</span>
    }
  
<span class="line-modified">!   while( test != _head ) {      // Scan till run off top of loop</span>
<span class="line-modified">!     if( test-&gt;is_If() ) {       // Test?</span>
        Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
<span class="line-modified">!       if (ctrl-&gt;is_top())</span>
<span class="line-modified">!         return false;           // Found dead test on live IF?  No peeling!</span>
<span class="line-modified">!       // Standard IF only has one input value to check for loop invariance</span>
<span class="line-modified">!       assert(test-&gt;Opcode() == Op_If || test-&gt;Opcode() == Op_CountedLoopEnd || test-&gt;Opcode() == Op_RangeCheck, &quot;Check this code when new subtype is added&quot;);</span>
        // Condition is not a member of this loop?
<span class="line-modified">!       if( !is_member(phase-&gt;get_loop(ctrl)) &amp;&amp;</span>
<span class="line-modified">!           is_loop_exit(test) )</span>
<span class="line-modified">!         return true;            // Found reason to peel!</span>
      }
<span class="line-modified">!     // Walk up dominators to loop _head looking for test which is</span>
<span class="line-modified">!     // executed on every path thru loop.</span>
      test = phase-&gt;idom(test);
    }
<span class="line-modified">!   return false;</span>
  }
  
  //------------------------------peeled_dom_test_elim---------------------------
  // If we got the effect of peeling, either by actually peeling or by making
  // a pre-loop which must execute at least once, we can remove all
  // loop-invariant dominated tests in the main body.
<span class="line-modified">! void PhaseIdealLoop::peeled_dom_test_elim( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
    bool progress = true;
<span class="line-modified">!   while( progress ) {</span>
      progress = false;           // Reset for next iteration
      Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
      Node *test = prev-&gt;in(0);
<span class="line-modified">!     while( test != loop-&gt;_head ) { // Scan till run off top of loop</span>
  
        int p_op = prev-&gt;Opcode();
<span class="line-modified">!       if( (p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;</span>
            test-&gt;is_If() &amp;&amp;      // Test?
            !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
            // Condition is not a member of this loop?
            !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
          // Walk loop body looking for instances of this test
<span class="line-modified">!         for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
            Node *n = loop-&gt;_body.at(i);
<span class="line-modified">!           if( n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/ ) {</span>
              // IfNode was dominated by version in peeled loop body
              progress = true;
<span class="line-modified">!             dominated_by( old_new[prev-&gt;_idx], n );</span>
            }
          }
        }
        prev = test;
        test = idom(test);
      } // End of scan tests in loop
  
<span class="line-modified">!   } // End of while( progress )</span>
  }
  
  //------------------------------do_peeling-------------------------------------
  // Peel the first iteration of the given loop.
  // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
<span class="line-new-header">--- 338,111 ---</span>
      Node *n = _body.at(i);
      for (int j = 0; j &lt; 5; j++) {
        Node* nn = reassociate_add_sub(n, phase);
        if (nn == NULL) break;
        n = nn; // again
<span class="line-modified">!     }</span>
    }
  }
  
  //------------------------------policy_peeling---------------------------------
<span class="line-modified">! // Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling</span>
<span class="line-modified">! // is applicable if we can make a loop-invariant test (usually a null-check)</span>
<span class="line-modified">! // execute before we enter the loop. When TRUE, the estimated node budget is</span>
<span class="line-modified">! // also requested.</span>
<span class="line-modified">! bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-modified">!   uint estimate = estimate_peeling(phase);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return estimate == 0 ? false : phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Perform actual policy and size estimate for the loop peeling transform, and</span>
<span class="line-added">+ // return the estimated loop size if peeling is applicable, otherwise return</span>
<span class="line-added">+ // zero. No node budget is allocated.</span>
<span class="line-added">+ uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">+   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Peeling does loop cloning which can result in O(N^2) node construction.</span>
<span class="line-added">+   if (_body.size() &gt; 255) {</span>
<span class="line-added">+     return 0;   // Suppress too large body size.</span>
    }
<span class="line-added">+   // Optimistic estimate that approximates loop body complexity via data and</span>
<span class="line-added">+   // control flow fan-out (instead of using the more pessimistic: BodySize^2).</span>
<span class="line-added">+   uint estimate = est_loop_clone_sz(2);</span>
  
<span class="line-modified">!   if (phase-&gt;exceeding_node_budget(estimate)) {</span>
<span class="line-modified">!     return 0;   // Too large to safely clone.</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // Check for vectorized loops, any peeling done was already applied.</span>
<span class="line-modified">!   if (_head-&gt;is_CountedLoop()) {</span>
<span class="line-added">+     CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
<span class="line-added">+     if (cl-&gt;is_unroll_only() || cl-&gt;trip_count() == 1) {</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   Node* test = tail();</span>
<span class="line-modified">! </span>
<span class="line-added">+   while (test != _head) {   // Scan till run off top of loop</span>
<span class="line-added">+     if (test-&gt;is_If()) {    // Test?</span>
        Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
<span class="line-modified">!       if (ctrl-&gt;is_top()) {</span>
<span class="line-modified">!         return 0;           // Found dead test on live IF?  No peeling!</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       // Standard IF only has one input value to check for loop invariance.</span>
<span class="line-added">+       assert(test-&gt;Opcode() == Op_If ||</span>
<span class="line-added">+              test-&gt;Opcode() == Op_CountedLoopEnd ||</span>
<span class="line-added">+              test-&gt;Opcode() == Op_RangeCheck,</span>
<span class="line-added">+              &quot;Check this code when new subtype is added&quot;);</span>
        // Condition is not a member of this loop?
<span class="line-modified">!       if (!is_member(phase-&gt;get_loop(ctrl)) &amp;&amp; is_loop_exit(test)) {</span>
<span class="line-modified">!         return estimate;    // Found reason to peel!</span>
<span class="line-modified">!       }</span>
      }
<span class="line-modified">!     // Walk up dominators to loop _head looking for test which is executed on</span>
<span class="line-modified">!     // every path through the loop.</span>
      test = phase-&gt;idom(test);
    }
<span class="line-modified">!   return 0;</span>
  }
  
  //------------------------------peeled_dom_test_elim---------------------------
  // If we got the effect of peeling, either by actually peeling or by making
  // a pre-loop which must execute at least once, we can remove all
  // loop-invariant dominated tests in the main body.
<span class="line-modified">! void PhaseIdealLoop::peeled_dom_test_elim(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
    bool progress = true;
<span class="line-modified">!   while (progress) {</span>
      progress = false;           // Reset for next iteration
      Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
      Node *test = prev-&gt;in(0);
<span class="line-modified">!     while (test != loop-&gt;_head) { // Scan till run off top of loop</span>
  
        int p_op = prev-&gt;Opcode();
<span class="line-modified">!       if ((p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;</span>
            test-&gt;is_If() &amp;&amp;      // Test?
            !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
            // Condition is not a member of this loop?
            !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
          // Walk loop body looking for instances of this test
<span class="line-modified">!         for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
            Node *n = loop-&gt;_body.at(i);
<span class="line-modified">!           if (n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/) {</span>
              // IfNode was dominated by version in peeled loop body
              progress = true;
<span class="line-modified">!             dominated_by(old_new[prev-&gt;_idx], n);</span>
            }
          }
        }
        prev = test;
        test = idom(test);
      } // End of scan tests in loop
  
<span class="line-modified">!   } // End of while (progress)</span>
  }
  
  //------------------------------do_peeling-------------------------------------
  // Peel the first iteration of the given loop.
  // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,11 ***</span>
  //            region
  //              |
  //              v
  //             exit
  //
<span class="line-modified">! void PhaseIdealLoop::do_peeling( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
  
    C-&gt;set_major_progress();
    // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
    // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
    // iterations adjusted.  Therefore, we need to declare this loop as
<span class="line-new-header">--- 579,11 ---</span>
  //            region
  //              |
  //              v
  //             exit
  //
<span class="line-modified">! void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
  
    C-&gt;set_major_progress();
    // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
    // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
    // iterations adjusted.  Therefore, we need to declare this loop as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,11 ***</span>
    head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
    for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
      Node* old = head-&gt;fast_out(j);
      if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
        Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
<span class="line-modified">!       if (!new_exit_value )     // Backedge value is ALSO loop invariant?</span>
          // Then loop body backedge value remains the same.
          new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
        _igvn.hash_delete(old);
        old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
      }
<span class="line-new-header">--- 628,11 ---</span>
    head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
    for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
      Node* old = head-&gt;fast_out(j);
      if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
        Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
<span class="line-modified">!       if (!new_exit_value)     // Backedge value is ALSO loop invariant?</span>
          // Then loop body backedge value remains the same.
          new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
        _igvn.hash_delete(old);
        old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,74 ***</span>
        _igvn.hash_delete(use);
        use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
      }
    }
  
<span class="line-removed">- </span>
    // Step 4: Correct dom-depth info.  Set to loop-head depth.
<span class="line-modified">!   int dd = dom_depth(head);</span>
<span class="line-modified">!   set_idom(head, head-&gt;in(1), dd);</span>
    for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
      Node *old = loop-&gt;_body.at(j3);
      Node *nnn = old_new[old-&gt;_idx];
<span class="line-modified">!     if (!has_ctrl(nnn))</span>
        set_idom(nnn, idom(nnn), dd-1);
    }
  
    // Now force out all loop-invariant dominating tests.  The optimizer
    // finds some, but we _know_ they are all useless.
    peeled_dom_test_elim(loop,old_new);
  
    loop-&gt;record_for_igvn();
  }
  
<span class="line-removed">- #define EMPTY_LOOP_SIZE 7 // number of nodes in an empty loop</span>
<span class="line-removed">- </span>
  //------------------------------policy_maximally_unroll------------------------
<span class="line-modified">! // Calculate exact loop trip count and return true if loop can be maximally</span>
<span class="line-modified">! // unrolled.</span>
<span class="line-modified">! bool IdealLoopTree::policy_maximally_unroll( PhaseIdealLoop *phase ) const {</span>
<span class="line-modified">!   CountedLoopNode *cl = _head-&gt;as_CountedLoop();</span>
    assert(cl-&gt;is_normal_loop(), &quot;&quot;);
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop())</span>
<span class="line-modified">!     return false; // Malformed counted loop</span>
<span class="line-modified">! </span>
    if (!cl-&gt;has_exact_trip_count()) {
<span class="line-modified">!     // Trip count is not exact.</span>
<span class="line-removed">-     return false;</span>
    }
  
    uint trip_count = cl-&gt;trip_count();
    // Note, max_juint is used to indicate unknown trip count.
    assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
<span class="line-modified">!   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_uint.&quot;);</span>
  
<span class="line-modified">!   // Real policy: if we maximally unroll, does it get too big?</span>
<span class="line-modified">!   // Allow the unrolled mess to get larger than standard loop</span>
<span class="line-modified">!   // size.  After all, it will no longer be a loop.</span>
<span class="line-modified">!   uint body_size    = _body.size();</span>
    uint unroll_limit = (uint)LoopUnrollLimit * 4;
<span class="line-modified">!   assert( (intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);</span>
<span class="line-modified">!   if (trip_count &gt; unroll_limit || body_size &gt; unroll_limit) {</span>
      return false;
    }
  
<span class="line-modified">!   // Fully unroll a loop with few iterations regardless next</span>
<span class="line-removed">-   // conditions since following loop optimizations will split</span>
<span class="line-removed">-   // such loop anyway (pre-main-post).</span>
<span class="line-removed">-   if (trip_count &lt;= 3)</span>
<span class="line-removed">-     return true;</span>
  
<span class="line-modified">!   // Take into account that after unroll conjoined heads and tails will fold,</span>
<span class="line-removed">-   // otherwise policy_unroll() may allow more unrolling than max unrolling.</span>
<span class="line-removed">-   uint new_body_size = EMPTY_LOOP_SIZE + (body_size - EMPTY_LOOP_SIZE) * trip_count;</span>
<span class="line-removed">-   uint tst_body_size = (new_body_size - EMPTY_LOOP_SIZE) / trip_count + EMPTY_LOOP_SIZE;</span>
<span class="line-removed">-   if (body_size != tst_body_size) // Check for int overflow</span>
      return false;
<span class="line-modified">!   if (new_body_size &gt; unroll_limit ||</span>
<span class="line-modified">!       // Unrolling can result in a large amount of node construction</span>
<span class="line-modified">!       new_body_size &gt;= phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes()) {</span>
      return false;
    }
  
    // Do not unroll a loop with String intrinsics code.
    // String intrinsics are large and have loops.
<span class="line-new-header">--- 650,73 ---</span>
        _igvn.hash_delete(use);
        use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
      }
    }
  
    // Step 4: Correct dom-depth info.  Set to loop-head depth.
<span class="line-modified">! </span>
<span class="line-modified">!   int dd = dom_depth(head-&gt;skip_strip_mined());</span>
<span class="line-added">+   set_idom(head-&gt;skip_strip_mined(), head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl), dd);</span>
    for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
      Node *old = loop-&gt;_body.at(j3);
      Node *nnn = old_new[old-&gt;_idx];
<span class="line-modified">!     if (!has_ctrl(nnn)) {</span>
        set_idom(nnn, idom(nnn), dd-1);
<span class="line-added">+     }</span>
    }
  
    // Now force out all loop-invariant dominating tests.  The optimizer
    // finds some, but we _know_ they are all useless.
    peeled_dom_test_elim(loop,old_new);
  
    loop-&gt;record_for_igvn();
  }
  
  //------------------------------policy_maximally_unroll------------------------
<span class="line-modified">! // Calculate the exact  loop trip-count and return TRUE if loop can be fully,</span>
<span class="line-modified">! // i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated</span>
<span class="line-modified">! // node budget is also requested.</span>
<span class="line-modified">! bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {</span>
<span class="line-added">+   CountedLoopNode* cl = _head-&gt;as_CountedLoop();</span>
    assert(cl-&gt;is_normal_loop(), &quot;&quot;);
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified">!     return false;   // Malformed counted loop.</span>
<span class="line-modified">!   }</span>
    if (!cl-&gt;has_exact_trip_count()) {
<span class="line-modified">!     return false;   // Trip count is not exact.</span>
    }
  
    uint trip_count = cl-&gt;trip_count();
    // Note, max_juint is used to indicate unknown trip count.
    assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
<span class="line-modified">!   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_juint.&quot;);</span>
  
<span class="line-modified">!   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-modified">!   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Allow the unrolled body to get larger than the standard loop size limit.</span>
    uint unroll_limit = (uint)LoopUnrollLimit * 4;
<span class="line-modified">!   assert((intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);</span>
<span class="line-modified">!   if (trip_count &gt; unroll_limit || _body.size() &gt; unroll_limit) {</span>
      return false;
    }
  
<span class="line-modified">!   uint new_body_size = est_loop_unroll_sz(trip_count);</span>
  
<span class="line-modified">!   if (new_body_size == UINT_MAX) { // Check for bad estimate (overflow).</span>
      return false;
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Fully unroll a loop with few iterations, regardless of other conditions,</span>
<span class="line-added">+   // since the following (general) loop optimizations will split such loop in</span>
<span class="line-added">+   // any case (into pre-main-post).</span>
<span class="line-added">+   if (trip_count &lt;= 3) {</span>
<span class="line-added">+     return phase-&gt;may_require_nodes(new_body_size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Reject if unrolling will result in too much node construction.</span>
<span class="line-added">+   if (new_body_size &gt; unroll_limit || phase-&gt;exceeding_node_budget(new_body_size)) {</span>
      return false;
    }
  
    // Do not unroll a loop with String intrinsics code.
    // String intrinsics are large and have loops.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,61 ***</span>
        }
  #endif
      } // switch
    }
  
<span class="line-modified">!   return true; // Do maximally unroll</span>
  }
  
  
  //------------------------------policy_unroll----------------------------------
<span class="line-modified">! // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if</span>
<span class="line-modified">! // the loop is a CountedLoop and the body is small enough.</span>
  bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
  
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
    assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
  
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop())</span>
      return false; // Malformed counted loop
  
    // Protect against over-unrolling.
    // After split at least one iteration will be executed in pre-loop.
<span class="line-modified">!   if (cl-&gt;trip_count() &lt;= (uint)(cl-&gt;is_normal_loop() ? 2 : 1)) return false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   _local_loop_unroll_limit = LoopUnrollLimit;</span>
    _local_loop_unroll_factor = 4;
<span class="line-modified">!   int future_unroll_ct = cl-&gt;unrolled_count() * 2;</span>
    if (!cl-&gt;is_vectorized_loop()) {
<span class="line-modified">!     if (future_unroll_ct &gt; LoopMaxUnroll) return false;</span>
    } else {
      // obey user constraints on vector mapped loops with additional unrolling applied
      int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
<span class="line-modified">!     if ((future_unroll_ct / unroll_constraint) &gt; LoopMaxUnroll) return false;</span>
    }
  
    // Check for initial stride being a small enough constant
<span class="line-modified">!   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_ct) return false;</span>
  
    // Don&#39;t unroll if the next round of unrolling would push us
    // over the expected trip count of the loop.  One is subtracted
    // from the expected trip count because the pre-loop normally
    // executes 1 iteration.
    if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
        cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
<span class="line-modified">!       future_unroll_ct        &gt; UnrollLimitForProfileCheck &amp;&amp;</span>
<span class="line-modified">!       (float)future_unroll_ct &gt; cl-&gt;profile_trip_cnt() - 1.0) {</span>
      return false;
    }
  
    // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
    //   the residual iterations are more than 10% of the trip count
    //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
    //   Progress defined as current size less than 20% larger than previous size.
    if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
<span class="line-modified">!       future_unroll_ct &gt; LoopUnrollMin &amp;&amp;</span>
<span class="line-modified">!       (future_unroll_ct - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;</span>
        1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
      return false;
    }
  
    Node *init_n = cl-&gt;init_trip();
<span class="line-new-header">--- 742,67 ---</span>
        }
  #endif
      } // switch
    }
  
<span class="line-modified">!   return phase-&gt;may_require_nodes(new_body_size);</span>
  }
  
  
  //------------------------------policy_unroll----------------------------------
<span class="line-modified">! // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if</span>
<span class="line-modified">! // the loop is  a counted loop and  the loop body is small  enough. When TRUE,</span>
<span class="line-added">+ // the estimated node budget is also requested.</span>
  bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
  
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
    assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
  
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop()) {</span>
      return false; // Malformed counted loop
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">+   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
  
    // Protect against over-unrolling.
    // After split at least one iteration will be executed in pre-loop.
<span class="line-modified">!   if (cl-&gt;trip_count() &lt;= (cl-&gt;is_normal_loop() ? 2u : 1u)) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   _local_loop_unroll_limit  = LoopUnrollLimit;</span>
    _local_loop_unroll_factor = 4;
<span class="line-modified">!   int future_unroll_cnt = cl-&gt;unrolled_count() * 2;</span>
    if (!cl-&gt;is_vectorized_loop()) {
<span class="line-modified">!     if (future_unroll_cnt &gt; LoopMaxUnroll) return false;</span>
    } else {
      // obey user constraints on vector mapped loops with additional unrolling applied
      int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
<span class="line-modified">!     if ((future_unroll_cnt / unroll_constraint) &gt; LoopMaxUnroll) return false;</span>
    }
  
    // Check for initial stride being a small enough constant
<span class="line-modified">!   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_cnt) return false;</span>
  
    // Don&#39;t unroll if the next round of unrolling would push us
    // over the expected trip count of the loop.  One is subtracted
    // from the expected trip count because the pre-loop normally
    // executes 1 iteration.
    if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
        cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
<span class="line-modified">!       future_unroll_cnt        &gt; UnrollLimitForProfileCheck &amp;&amp;</span>
<span class="line-modified">!       (float)future_unroll_cnt &gt; cl-&gt;profile_trip_cnt() - 1.0) {</span>
      return false;
    }
  
    // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
    //   the residual iterations are more than 10% of the trip count
    //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
    //   Progress defined as current size less than 20% larger than previous size.
    if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
<span class="line-modified">!       future_unroll_cnt &gt; LoopUnrollMin &amp;&amp;</span>
<span class="line-modified">!       (future_unroll_cnt - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;</span>
        1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
      return false;
    }
  
    Node *init_n = cl-&gt;init_trip();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 846,46 ***</span>
  
      // Only attempt slp analysis when user controls do not prohibit it
      if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
        // Once policy_slp_analysis succeeds, mark the loop with the
        // maximal unroll factor so that we minimize analysis passes
<span class="line-modified">!       if (future_unroll_ct &gt;= _local_loop_unroll_factor) {</span>
<span class="line-modified">!         policy_unroll_slp_analysis(cl, phase, future_unroll_ct);</span>
        }
      }
    }
  
    int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
    if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
      LoopMaxUnroll = slp_max_unroll_factor;
    }
    if (cl-&gt;has_passed_slp()) {
<span class="line-modified">!     if (slp_max_unroll_factor &gt;= future_unroll_ct) return true;</span>
<span class="line-modified">!     // Normal case: loop too big</span>
<span class="line-modified">!     return false;</span>
    }
  
    // Check for being too big
    if (body_size &gt; (uint)_local_loop_unroll_limit) {
<span class="line-modified">!     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; (uint)LoopUnrollLimit * 4) {</span>
<span class="line-modified">!       return true;</span>
      }
<span class="line-modified">!     // Normal case: loop too big</span>
<span class="line-removed">-     return false;</span>
    }
  
<span class="line-modified">!   if (cl-&gt;do_unroll_only()) {</span>
      if (TraceSuperWordLoopUnrollAnalysis) {
<span class="line-modified">!       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d,factor = %d)\n&quot;, slp_max_unroll_factor, future_unroll_ct);</span>
      }
    }
  
    // Unroll once!  (Each trip will soon do double iterations)
<span class="line-modified">!   return true;</span>
  }
  
<span class="line-modified">! void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_ct) {</span>
    // Enable this functionality target by target as needed
    if (SuperWordLoopUnrollAnalysis) {
      if (!cl-&gt;was_slp_analyzed()) {
        SuperWord sw(phase);
        sw.transform_loop(this, false);
<span class="line-new-header">--- 882,54 ---</span>
  
      // Only attempt slp analysis when user controls do not prohibit it
      if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
        // Once policy_slp_analysis succeeds, mark the loop with the
        // maximal unroll factor so that we minimize analysis passes
<span class="line-modified">!       if (future_unroll_cnt &gt;= _local_loop_unroll_factor) {</span>
<span class="line-modified">!         policy_unroll_slp_analysis(cl, phase, future_unroll_cnt);</span>
        }
      }
    }
  
    int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
    if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
      LoopMaxUnroll = slp_max_unroll_factor;
    }
<span class="line-added">+ </span>
<span class="line-added">+   uint estimate = est_loop_clone_sz(2);</span>
<span class="line-added">+ </span>
    if (cl-&gt;has_passed_slp()) {
<span class="line-modified">!     if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
<span class="line-modified">!       return phase-&gt;may_require_nodes(estimate);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     return false; // Loop too big.</span>
    }
  
    // Check for being too big
    if (body_size &gt; (uint)_local_loop_unroll_limit) {
<span class="line-modified">!     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; 4u * LoopUnrollLimit) {</span>
<span class="line-modified">!       return phase-&gt;may_require_nodes(estimate);</span>
      }
<span class="line-modified">!     return false; // Loop too big.</span>
    }
  
<span class="line-modified">!   if (cl-&gt;is_unroll_only()) {</span>
      if (TraceSuperWordLoopUnrollAnalysis) {
<span class="line-modified">!       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d, factor=%d)\n&quot;,</span>
<span class="line-added">+                     slp_max_unroll_factor, future_unroll_cnt);</span>
      }
    }
  
    // Unroll once!  (Each trip will soon do double iterations)
<span class="line-modified">!   return phase-&gt;may_require_nodes(estimate);</span>
  }
  
<span class="line-modified">! void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_cnt) {</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">+   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">+ </span>
    // Enable this functionality target by target as needed
    if (SuperWordLoopUnrollAnalysis) {
      if (!cl-&gt;was_slp_analyzed()) {
        SuperWord sw(phase);
        sw.transform_loop(this, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,11 ***</span>
        }
      }
  
      if (cl-&gt;has_passed_slp()) {
        int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
<span class="line-modified">!       if (slp_max_unroll_factor &gt;= future_unroll_ct) {</span>
          int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
          if (new_limit &gt; LoopUnrollLimit) {
            if (TraceSuperWordLoopUnrollAnalysis) {
              tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
            }
<span class="line-new-header">--- 940,11 ---</span>
        }
      }
  
      if (cl-&gt;has_passed_slp()) {
        int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
<span class="line-modified">!       if (slp_max_unroll_factor &gt;= future_unroll_cnt) {</span>
          int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
          if (new_limit &gt; LoopUnrollLimit) {
            if (TraceSuperWordLoopUnrollAnalysis) {
              tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,134 ***</span>
  // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
  // expression that does the alignment.  Note that only one array base can be
  // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
  // if we vectorize short memory ops into longer memory ops, we may want to
  // increase alignment.
<span class="line-modified">! bool IdealLoopTree::policy_align( PhaseIdealLoop *phase ) const {</span>
    return false;
  }
  
  //------------------------------policy_range_check-----------------------------
<span class="line-modified">! // Return TRUE or FALSE if the loop should be range-check-eliminated.</span>
<span class="line-modified">! // Actually we do iteration-splitting, a more powerful form of RCE.</span>
<span class="line-modified">! bool IdealLoopTree::policy_range_check( PhaseIdealLoop *phase ) const {</span>
    if (!RangeCheckElimination) return false;
  
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">!   // If we unrolled with no intention of doing RCE and we later</span>
<span class="line-modified">!   // changed our minds, we got no pre-loop.  Either we need to</span>
<span class="line-modified">!   // make a new pre-loop, or we gotta disallow RCE.</span>
    if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
    Node *trip_counter = cl-&gt;phi();
  
    // check for vectorized loops, some opts are no longer needed
<span class="line-modified">!   if (cl-&gt;do_unroll_only()) return false;</span>
  
    // Check loop body for tests of trip-counter plus loop-invariant vs
    // loop-invariant.
    for (uint i = 0; i &lt; _body.size(); i++) {
      Node *iff = _body[i];
      if (iff-&gt;Opcode() == Op_If ||
          iff-&gt;Opcode() == Op_RangeCheck) { // Test?
  
        // Comparing trip+off vs limit
        Node *bol = iff-&gt;in(1);
<span class="line-modified">!       if (bol-&gt;req() != 2) continue; // dead constant test</span>
        if (!bol-&gt;is_Bool()) {
          assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
          continue;
        }
<span class="line-modified">!       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne)</span>
          continue; // not RC
<span class="line-modified">! </span>
        Node *cmp = bol-&gt;in(1);
        Node *rc_exp = cmp-&gt;in(1);
        Node *limit = cmp-&gt;in(2);
  
        Node *limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">!       if( limit_c == phase-&gt;C-&gt;top() )</span>
          return false;           // Found dead test on live IF?  No RCE!
<span class="line-modified">!       if( is_member(phase-&gt;get_loop(limit_c) ) ) {</span>
          // Compare might have operands swapped; commute them
          rc_exp = cmp-&gt;in(2);
          limit  = cmp-&gt;in(1);
          limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">!         if( is_member(phase-&gt;get_loop(limit_c) ) )</span>
            continue;             // Both inputs are loop varying; cannot RCE
        }
  
        if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
          continue;
        }
<span class="line-modified">!       // Yeah!  Found a test like &#39;trip+off vs limit&#39;</span>
<span class="line-modified">!       // Test is an IfNode, has 2 projections.  If BOTH are in the loop</span>
<span class="line-modified">!       // we need loop unswitching instead of iteration splitting.</span>
<span class="line-modified">!       if( is_loop_exit(iff) )</span>
<span class="line-modified">!         return true;            // Found reason to split iterations</span>
      } // End of is IF
    }
  
    return false;
  }
  
  //------------------------------policy_peel_only-------------------------------
  // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
  // for unrolling loops with NO array accesses.
<span class="line-modified">! bool IdealLoopTree::policy_peel_only( PhaseIdealLoop *phase ) const {</span>
    // check for vectorized loops, any peeling done was already applied
<span class="line-modified">!   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;do_unroll_only()) return false;</span>
  
<span class="line-modified">!   for( uint i = 0; i &lt; _body.size(); i++ )</span>
<span class="line-modified">!     if( _body[i]-&gt;is_Mem() )</span>
        return false;
<span class="line-modified">! </span>
    // No memory accesses at all!
    return true;
  }
  
  //------------------------------clone_up_backedge_goo--------------------------
  // If Node n lives in the back_ctrl block and cannot float, we clone a private
  // version of n in preheader_ctrl block and return that, otherwise return n.
<span class="line-modified">! Node *PhaseIdealLoop::clone_up_backedge_goo( Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones ) {</span>
<span class="line-modified">!   if( get_ctrl(n) != back_ctrl ) return n;</span>
  
    // Only visit once
    if (visited.test_set(n-&gt;_idx)) {
      Node *x = clones.find(n-&gt;_idx);
<span class="line-modified">!     if (x != NULL)</span>
<span class="line-removed">-       return x;</span>
<span class="line-removed">-     return n;</span>
    }
  
    Node *x = NULL;               // If required, a clone of &#39;n&#39;
    // Check for &#39;n&#39; being pinned in the backedge.
<span class="line-modified">!   if( n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl ) {</span>
      assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
      x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
      clones.push(x, n-&gt;_idx);
<span class="line-modified">!     x-&gt;set_req( 0, preheader_ctrl ); // Fix x&#39;s control input to preheader</span>
    }
  
    // Recursive fixup any other input edges into x.
    // If there are no changes we can just return &#39;n&#39;, otherwise
    // we need to clone a private copy and change it.
<span class="line-modified">!   for( uint i = 1; i &lt; n-&gt;req(); i++ ) {</span>
<span class="line-modified">!     Node *g = clone_up_backedge_goo( back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones );</span>
<span class="line-modified">!     if( g != n-&gt;in(i) ) {</span>
<span class="line-modified">!       if( !x ) {</span>
          assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
          x = n-&gt;clone();
          clones.push(x, n-&gt;_idx);
        }
        x-&gt;set_req(i, g);
      }
    }
<span class="line-modified">!   if( x ) {                     // x can legally float to pre-header location</span>
<span class="line-modified">!     register_new_node( x, preheader_ctrl );</span>
      return x;
    } else {                      // raise n to cover LCA of uses
<span class="line-modified">!     set_ctrl( n, find_non_split_ctrl(back_ctrl-&gt;in(0)) );</span>
    }
    return n;
  }
  
  Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
<span class="line-new-header">--- 959,151 ---</span>
  // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
  // expression that does the alignment.  Note that only one array base can be
  // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
  // if we vectorize short memory ops into longer memory ops, we may want to
  // increase alignment.
<span class="line-modified">! bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {</span>
    return false;
  }
  
  //------------------------------policy_range_check-----------------------------
<span class="line-modified">! // Return TRUE or FALSE if the loop should be range-check-eliminated or not.</span>
<span class="line-modified">! // When TRUE, the estimated node budget is also requested.</span>
<span class="line-modified">! //</span>
<span class="line-added">+ // We will actually perform iteration-splitting, a more powerful form of RCE.</span>
<span class="line-added">+ bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {</span>
    if (!RangeCheckElimination) return false;
  
<span class="line-added">+   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">+   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">+ </span>
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">!   // If we unrolled  with no intention of doing RCE and we  later changed our</span>
<span class="line-modified">!   // minds, we got no pre-loop.  Either we need to make a new pre-loop, or we</span>
<span class="line-modified">!   // have to disallow RCE.</span>
    if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
    Node *trip_counter = cl-&gt;phi();
  
    // check for vectorized loops, some opts are no longer needed
<span class="line-modified">!   if (cl-&gt;is_unroll_only()) return false;</span>
  
    // Check loop body for tests of trip-counter plus loop-invariant vs
    // loop-invariant.
    for (uint i = 0; i &lt; _body.size(); i++) {
      Node *iff = _body[i];
      if (iff-&gt;Opcode() == Op_If ||
          iff-&gt;Opcode() == Op_RangeCheck) { // Test?
  
        // Comparing trip+off vs limit
        Node *bol = iff-&gt;in(1);
<span class="line-modified">!       if (bol-&gt;req() != 2) {</span>
<span class="line-added">+         continue; // dead constant test</span>
<span class="line-added">+       }</span>
        if (!bol-&gt;is_Bool()) {
          assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
          continue;
        }
<span class="line-modified">!       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {</span>
          continue; // not RC
<span class="line-modified">!       }</span>
        Node *cmp = bol-&gt;in(1);
        Node *rc_exp = cmp-&gt;in(1);
        Node *limit = cmp-&gt;in(2);
  
        Node *limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">!       if (limit_c == phase-&gt;C-&gt;top()) {</span>
          return false;           // Found dead test on live IF?  No RCE!
<span class="line-modified">!       }</span>
<span class="line-added">+       if (is_member(phase-&gt;get_loop(limit_c))) {</span>
          // Compare might have operands swapped; commute them
          rc_exp = cmp-&gt;in(2);
          limit  = cmp-&gt;in(1);
          limit_c = phase-&gt;get_ctrl(limit);
<span class="line-modified">!         if (is_member(phase-&gt;get_loop(limit_c))) {</span>
            continue;             // Both inputs are loop varying; cannot RCE
<span class="line-added">+         }</span>
        }
  
        if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
          continue;
        }
<span class="line-modified">!       // Found a test like &#39;trip+off vs limit&#39;. Test is an IfNode, has two (2)</span>
<span class="line-modified">!       // projections. If BOTH are in the loop we need loop unswitching instead</span>
<span class="line-modified">!       // of iteration splitting.</span>
<span class="line-modified">!       if (is_loop_exit(iff)) {</span>
<span class="line-modified">!         // Found valid reason to split iterations (if there is room).</span>
<span class="line-added">+         // NOTE: Usually a gross overestimate.</span>
<span class="line-added">+         return phase-&gt;may_require_nodes(est_loop_clone_sz(2));</span>
<span class="line-added">+       }</span>
      } // End of is IF
    }
  
    return false;
  }
  
  //------------------------------policy_peel_only-------------------------------
  // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
  // for unrolling loops with NO array accesses.
<span class="line-modified">! bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If nodes are depleted, some transform has miscalculated its needs.</span>
<span class="line-added">+   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);</span>
<span class="line-added">+ </span>
    // check for vectorized loops, any peeling done was already applied
<span class="line-modified">!   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">!     if (_body[i]-&gt;is_Mem()) {</span>
        return false;
<span class="line-modified">!     }</span>
<span class="line-added">+   }</span>
    // No memory accesses at all!
    return true;
  }
  
  //------------------------------clone_up_backedge_goo--------------------------
  // If Node n lives in the back_ctrl block and cannot float, we clone a private
  // version of n in preheader_ctrl block and return that, otherwise return n.
<span class="line-modified">! Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones) {</span>
<span class="line-modified">!   if (get_ctrl(n) != back_ctrl) return n;</span>
  
    // Only visit once
    if (visited.test_set(n-&gt;_idx)) {
      Node *x = clones.find(n-&gt;_idx);
<span class="line-modified">!     return (x != NULL) ? x : n;</span>
    }
  
    Node *x = NULL;               // If required, a clone of &#39;n&#39;
    // Check for &#39;n&#39; being pinned in the backedge.
<span class="line-modified">!   if (n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl) {</span>
      assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
      x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
      clones.push(x, n-&gt;_idx);
<span class="line-modified">!     x-&gt;set_req(0, preheader_ctrl); // Fix x&#39;s control input to preheader</span>
    }
  
    // Recursive fixup any other input edges into x.
    // If there are no changes we can just return &#39;n&#39;, otherwise
    // we need to clone a private copy and change it.
<span class="line-modified">!   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-modified">!     Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones);</span>
<span class="line-modified">!     if (g != n-&gt;in(i)) {</span>
<span class="line-modified">!       if (!x) {</span>
          assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
          x = n-&gt;clone();
          clones.push(x, n-&gt;_idx);
        }
        x-&gt;set_req(i, g);
      }
    }
<span class="line-modified">!   if (x) {                     // x can legally float to pre-header location</span>
<span class="line-modified">!     register_new_node(x, preheader_ctrl);</span>
      return x;
    } else {                      // raise n to cover LCA of uses
<span class="line-modified">!     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));</span>
    }
    return n;
  }
  
  Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1204,11 ***</span>
    proj-&gt;set_req(0, new_iff);
    other_proj-&gt;set_req(0, new_iff);
    Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
    register_new_node(frame, C-&gt;start());
    // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
<span class="line-modified">!   Node* halt = new HaltNode(other_proj, frame);</span>
    C-&gt;root()-&gt;add_req(halt);
    new_iff-&gt;set_req(0, prev_proj);
  
    register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
    register_control(proj, outer_loop-&gt;_parent, new_iff);
<span class="line-new-header">--- 1265,11 ---</span>
    proj-&gt;set_req(0, new_iff);
    other_proj-&gt;set_req(0, new_iff);
    Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
    register_new_node(frame, C-&gt;start());
    // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
<span class="line-modified">!   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);</span>
    C-&gt;root()-&gt;add_req(halt);
    new_iff-&gt;set_req(0, prev_proj);
  
    register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
    register_control(proj, outer_loop-&gt;_parent, new_iff);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1242,11 ***</span>
  
  //------------------------------insert_pre_post_loops--------------------------
  // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
  // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
  // alignment.  Useful to unroll loops that do no array accesses.
<span class="line-modified">! void PhaseIdealLoop::insert_pre_post_loops( IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only ) {</span>
  
  #ifndef PRODUCT
    if (TraceLoopOpts) {
      if (peel_only)
        tty-&gt;print(&quot;PeelMainPost &quot;);
<span class="line-new-header">--- 1303,11 ---</span>
  
  //------------------------------insert_pre_post_loops--------------------------
  // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
  // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
  // alignment.  Useful to unroll loops that do no array accesses.
<span class="line-modified">! void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {</span>
  
  #ifndef PRODUCT
    if (TraceLoopOpts) {
      if (peel_only)
        tty-&gt;print(&quot;PeelMainPost &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1257,13 ***</span>
  #endif
    C-&gt;set_major_progress();
  
    // Find common pieces of the loop being guarded with pre &amp; post loops
    CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
<span class="line-modified">!   assert( main_head-&gt;is_normal_loop(), &quot;&quot; );</span>
    CountedLoopEndNode *main_end = main_head-&gt;loopexit();
<span class="line-modified">!   assert( main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot; );</span>
  
    Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
    Node *init      = main_head-&gt;init_trip();
    Node *incr      = main_end -&gt;incr();
    Node *limit     = main_end -&gt;limit();
<span class="line-new-header">--- 1318,13 ---</span>
  #endif
    C-&gt;set_major_progress();
  
    // Find common pieces of the loop being guarded with pre &amp; post loops
    CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
<span class="line-modified">!   assert(main_head-&gt;is_normal_loop(), &quot;&quot;);</span>
    CountedLoopEndNode *main_end = main_head-&gt;loopexit();
<span class="line-modified">!   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);</span>
  
    Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
    Node *init      = main_head-&gt;init_trip();
    Node *incr      = main_end -&gt;incr();
    Node *limit     = main_end -&gt;limit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1271,17 ***</span>
    Node *cmp       = main_end -&gt;cmp_node();
    BoolTest::mask b_test = main_end-&gt;test_trip();
  
    // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
    Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
<span class="line-modified">!   if( bol-&gt;outcnt() != 1 ) {</span>
      bol = bol-&gt;clone();
      register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
      _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
    }
    // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
<span class="line-modified">!   if( cmp-&gt;outcnt() != 1 ) {</span>
      cmp = cmp-&gt;clone();
      register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
      _igvn.replace_input_of(bol, 1, cmp);
    }
  
<span class="line-new-header">--- 1332,17 ---</span>
    Node *cmp       = main_end -&gt;cmp_node();
    BoolTest::mask b_test = main_end-&gt;test_trip();
  
    // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
    Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
<span class="line-modified">!   if (bol-&gt;outcnt() != 1) {</span>
      bol = bol-&gt;clone();
      register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
      _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
    }
    // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
<span class="line-modified">!   if (cmp-&gt;outcnt() != 1) {</span>
      cmp = cmp-&gt;clone();
      register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
      _igvn.replace_input_of(bol, 1, cmp);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,41 ***</span>
    // Reduce the pre-loop trip count.
    pre_end-&gt;_prob = PROB_FAIR;
  
    // Find the pre-loop normal exit.
    Node* pre_exit = pre_end-&gt;proj_out(false);
<span class="line-modified">!   assert( pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot; );</span>
    IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
<span class="line-modified">!   _igvn.register_new_node_with_optimizer( new_pre_exit );</span>
    set_idom(new_pre_exit, pre_end, dd_main_head);
    set_loop(new_pre_exit, outer_loop-&gt;_parent);
  
    // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
    // pre-loop, the main-loop may not execute at all.  Later in life this
    // zero-trip guard will become the minimum-trip guard when we unroll
    // the main-loop.
    Node *min_opaq = new Opaque1Node(C, limit);
<span class="line-modified">!   Node *min_cmp  = new CmpINode( pre_incr, min_opaq );</span>
<span class="line-modified">!   Node *min_bol  = new BoolNode( min_cmp, b_test );</span>
<span class="line-modified">!   register_new_node( min_opaq, new_pre_exit );</span>
<span class="line-modified">!   register_new_node( min_cmp , new_pre_exit );</span>
<span class="line-modified">!   register_new_node( min_bol , new_pre_exit );</span>
  
    // Build the IfNode (assume the main-loop is executed always).
<span class="line-modified">!   IfNode *min_iff = new IfNode( new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN );</span>
<span class="line-modified">!   _igvn.register_new_node_with_optimizer( min_iff );</span>
    set_idom(min_iff, new_pre_exit, dd_main_head);
    set_loop(min_iff, outer_loop-&gt;_parent);
  
    // Plug in the false-path, taken if we need to skip main-loop
<span class="line-modified">!   _igvn.hash_delete( pre_exit );</span>
    pre_exit-&gt;set_req(0, min_iff);
    set_idom(pre_exit, min_iff, dd_main_head);
    set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
    // Make the true-path, must enter the main loop
<span class="line-modified">!   Node *min_taken = new IfTrueNode( min_iff );</span>
<span class="line-modified">!   _igvn.register_new_node_with_optimizer( min_taken );</span>
    set_idom(min_taken, min_iff, dd_main_head);
    set_loop(min_taken, outer_loop-&gt;_parent);
    // Plug in the true path
    _igvn.hash_delete(outer_main_head);
    outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
<span class="line-new-header">--- 1373,41 ---</span>
    // Reduce the pre-loop trip count.
    pre_end-&gt;_prob = PROB_FAIR;
  
    // Find the pre-loop normal exit.
    Node* pre_exit = pre_end-&gt;proj_out(false);
<span class="line-modified">!   assert(pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);</span>
    IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
<span class="line-modified">!   _igvn.register_new_node_with_optimizer(new_pre_exit);</span>
    set_idom(new_pre_exit, pre_end, dd_main_head);
    set_loop(new_pre_exit, outer_loop-&gt;_parent);
  
    // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
    // pre-loop, the main-loop may not execute at all.  Later in life this
    // zero-trip guard will become the minimum-trip guard when we unroll
    // the main-loop.
    Node *min_opaq = new Opaque1Node(C, limit);
<span class="line-modified">!   Node *min_cmp  = new CmpINode(pre_incr, min_opaq);</span>
<span class="line-modified">!   Node *min_bol  = new BoolNode(min_cmp, b_test);</span>
<span class="line-modified">!   register_new_node(min_opaq, new_pre_exit);</span>
<span class="line-modified">!   register_new_node(min_cmp , new_pre_exit);</span>
<span class="line-modified">!   register_new_node(min_bol , new_pre_exit);</span>
  
    // Build the IfNode (assume the main-loop is executed always).
<span class="line-modified">!   IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);</span>
<span class="line-modified">!   _igvn.register_new_node_with_optimizer(min_iff);</span>
    set_idom(min_iff, new_pre_exit, dd_main_head);
    set_loop(min_iff, outer_loop-&gt;_parent);
  
    // Plug in the false-path, taken if we need to skip main-loop
<span class="line-modified">!   _igvn.hash_delete(pre_exit);</span>
    pre_exit-&gt;set_req(0, min_iff);
    set_idom(pre_exit, min_iff, dd_main_head);
    set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
    // Make the true-path, must enter the main loop
<span class="line-modified">!   Node *min_taken = new IfTrueNode(min_iff);</span>
<span class="line-modified">!   _igvn.register_new_node_with_optimizer(min_taken);</span>
    set_idom(min_taken, min_iff, dd_main_head);
    set_loop(min_taken, outer_loop-&gt;_parent);
    // Plug in the true path
    _igvn.hash_delete(outer_main_head);
    outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1357,18 ***</span>
    Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
    // Step B3: Make the fall-in values to the main-loop come from the
    // fall-out values of the pre-loop.
    for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
      Node* main_phi = main_head-&gt;fast_out(i2);
<span class="line-modified">!     if( main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0 ) {</span>
        Node *pre_phi = old_new[main_phi-&gt;_idx];
        Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
                                               main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
                                               pre_phi-&gt;in(LoopNode::LoopBackControl),
                                               visited, clones);
        _igvn.hash_delete(main_phi);
<span class="line-modified">!       main_phi-&gt;set_req( LoopNode::EntryControl, fallpre );</span>
      }
    }
  
    // Nodes inside the loop may be control dependent on a predicate
    // that was moved before the preloop. If the back branch of the main
<span class="line-new-header">--- 1418,18 ---</span>
    Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
    // Step B3: Make the fall-in values to the main-loop come from the
    // fall-out values of the pre-loop.
    for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
      Node* main_phi = main_head-&gt;fast_out(i2);
<span class="line-modified">!     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
        Node *pre_phi = old_new[main_phi-&gt;_idx];
        Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
                                               main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
                                               pre_phi-&gt;in(LoopNode::LoopBackControl),
                                               visited, clones);
        _igvn.hash_delete(main_phi);
<span class="line-modified">!       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);</span>
      }
    }
  
    // Nodes inside the loop may be control dependent on a predicate
    // that was moved before the preloop. If the back branch of the main
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,31 ***</span>
    // the if branch that enters the loop, between the input induction
    // variable value and the induction variable Phi to preserve correct
    // dependencies.
  
    // CastII for the main loop:
<span class="line-modified">!   Node* castii = cast_incr_before_loop( pre_incr, min_taken, main_head );</span>
    assert(castii != NULL, &quot;no castII inserted&quot;);
    Node* opaque_castii = new Opaque1Node(C, castii);
    register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
    duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
  
    // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
    // RCE and alignment may change this later.
    Node *cmp_end = pre_end-&gt;cmp_node();
<span class="line-modified">!   assert( cmp_end-&gt;in(2) == limit, &quot;&quot; );</span>
<span class="line-modified">!   Node *pre_limit = new AddINode( init, stride );</span>
  
    // Save the original loop limit in this Opaque1 node for
    // use by range check elimination.
    Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
  
<span class="line-modified">!   register_new_node( pre_limit, pre_head-&gt;in(0) );</span>
<span class="line-modified">!   register_new_node( pre_opaq , pre_head-&gt;in(0) );</span>
  
    // Since no other users of pre-loop compare, I can hack limit directly
<span class="line-modified">!   assert( cmp_end-&gt;outcnt() == 1, &quot;no other users&quot; );</span>
    _igvn.hash_delete(cmp_end);
    cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
  
    // Special case for not-equal loop bounds:
    // Change pre loop test, main loop test, and the
<span class="line-new-header">--- 1440,31 ---</span>
    // the if branch that enters the loop, between the input induction
    // variable value and the induction variable Phi to preserve correct
    // dependencies.
  
    // CastII for the main loop:
<span class="line-modified">!   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);</span>
    assert(castii != NULL, &quot;no castII inserted&quot;);
    Node* opaque_castii = new Opaque1Node(C, castii);
    register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
    duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);
  
    // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
    // RCE and alignment may change this later.
    Node *cmp_end = pre_end-&gt;cmp_node();
<span class="line-modified">!   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);</span>
<span class="line-modified">!   Node *pre_limit = new AddINode(init, stride);</span>
  
    // Save the original loop limit in this Opaque1 node for
    // use by range check elimination.
    Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
  
<span class="line-modified">!   register_new_node(pre_limit, pre_head-&gt;in(0));</span>
<span class="line-modified">!   register_new_node(pre_opaq , pre_head-&gt;in(0));</span>
  
    // Since no other users of pre-loop compare, I can hack limit directly
<span class="line-modified">!   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);</span>
    _igvn.hash_delete(cmp_end);
    cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
  
    // Special case for not-equal loop bounds:
    // Change pre loop test, main loop test, and the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1419,28 ***</span>
  
      BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
      // Modify pre loop end condition
      Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
      BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node( new_bol0, pre_head-&gt;in(0) );</span>
      _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
      // Modify main loop guard condition
      assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
      BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node( new_bol1, new_pre_exit );</span>
      _igvn.hash_delete(min_iff);
      min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
      // Modify main loop end condition
      BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
      BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node( new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl) );</span>
      _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
    }
  
    // Flag main loop
    main_head-&gt;set_main_loop();
<span class="line-modified">!   if( peel_only ) main_head-&gt;set_main_no_pre_loop();</span>
  
    // Subtract a trip count for the pre-loop.
    main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
  
    // It&#39;s difficult to be precise about the trip-counts
<span class="line-new-header">--- 1480,30 ---</span>
  
      BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
      // Modify pre loop end condition
      Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
      BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node(new_bol0, pre_head-&gt;in(0));</span>
      _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
      // Modify main loop guard condition
      assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
      BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node(new_bol1, new_pre_exit);</span>
      _igvn.hash_delete(min_iff);
      min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
      // Modify main loop end condition
      BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
      BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
<span class="line-modified">!     register_new_node(new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl));</span>
      _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
    }
  
    // Flag main loop
    main_head-&gt;set_main_loop();
<span class="line-modified">!   if (peel_only) {</span>
<span class="line-added">+     main_head-&gt;set_main_no_pre_loop();</span>
<span class="line-added">+   }</span>
  
    // Subtract a trip count for the pre-loop.
    main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
  
    // It&#39;s difficult to be precise about the trip-counts
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1455,12 ***</span>
    loop-&gt;record_for_igvn();
  }
  
  //------------------------------insert_vector_post_loop------------------------
  // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
<span class="line-modified">! // unroll_policy has already informed us that more unrolling is about to happen to</span>
<span class="line-modified">! // the main loop.  The resultant post loop will serve as a vectorized drain loop.</span>
  void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
    if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
  
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
  
<span class="line-new-header">--- 1518,13 ---</span>
    loop-&gt;record_for_igvn();
  }
  
  //------------------------------insert_vector_post_loop------------------------
  // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
<span class="line-modified">! // unroll_policy has  already informed  us that more  unrolling is  about to</span>
<span class="line-modified">! // happen  to the  main  loop.  The  resultant  post loop  will  serve as  a</span>
<span class="line-added">+ // vectorized drain loop.</span>
  void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
    if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
  
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1476,10 ***</span>
<span class="line-new-header">--- 1540,14 ---</span>
    if (cur_unroll != slp_max_unroll_factor) return;
  
    // we only ever process this one time
    if (cl-&gt;has_atomic_post_loop()) return;
  
<span class="line-added">+   if (!may_require_nodes(loop-&gt;est_loop_clone_sz(2))) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
    if (TraceLoopOpts) {
      tty-&gt;print(&quot;PostVector  &quot;);
      loop-&gt;dump_head();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1636,11 ***</span>
    Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
    // Step A3: Make the fall-in values to the post-loop come from the
    // fall-out values of the main-loop.
    for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* main_phi = main_head-&gt;fast_out(i);
<span class="line-modified">!     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt;0) {</span>
        Node *cur_phi = old_new[main_phi-&gt;_idx];
        Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
                                              post_head-&gt;init_control(),
                                              main_phi-&gt;in(LoopNode::LoopBackControl),
                                              visited, clones);
<span class="line-new-header">--- 1704,11 ---</span>
    Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
    // Step A3: Make the fall-in values to the post-loop come from the
    // fall-out values of the main-loop.
    for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* main_phi = main_head-&gt;fast_out(i);
<span class="line-modified">!     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {</span>
        Node *cur_phi = old_new[main_phi-&gt;_idx];
        Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
                                              post_head-&gt;init_control(),
                                              main_phi-&gt;in(LoopNode::LoopBackControl),
                                              visited, clones);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1708,11 ***</span>
    }
  }
  
  //------------------------------do_unroll--------------------------------------
  // Unroll the loop body one step - make each trip do 2 iterations.
<span class="line-modified">! void PhaseIdealLoop::do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip ) {</span>
    assert(LoopUnrollLimit, &quot;&quot;);
    CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
    CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
  #ifndef PRODUCT
    if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
<span class="line-new-header">--- 1776,11 ---</span>
    }
  }
  
  //------------------------------do_unroll--------------------------------------
  // Unroll the loop body one step - make each trip do 2 iterations.
<span class="line-modified">! void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip) {</span>
    assert(LoopUnrollLimit, &quot;&quot;);
    CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
    CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
  #ifndef PRODUCT
    if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1731,12 ***</span>
      Arena* arena = Thread::current()-&gt;resource_area();
      Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
      Node_List rpo_list;
      VectorSet visited(arena);
      visited.set(loop_head-&gt;_idx);
<span class="line-modified">!     rpo( loop_head, stack, visited, rpo_list );</span>
<span class="line-modified">!     dump(loop, rpo_list.size(), rpo_list );</span>
    }
  #endif
  
    // Remember loop node count before unrolling to detect
    // if rounds of unroll,optimize are making progress
<span class="line-new-header">--- 1799,12 ---</span>
      Arena* arena = Thread::current()-&gt;resource_area();
      Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
      Node_List rpo_list;
      VectorSet visited(arena);
      visited.set(loop_head-&gt;_idx);
<span class="line-modified">!     rpo(loop_head, stack, visited, rpo_list);</span>
<span class="line-modified">!     dump(loop, rpo_list.size(), rpo_list);</span>
    }
  #endif
  
    // Remember loop node count before unrolling to detect
    // if rounds of unroll,optimize are making progress
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1809,11 ***</span>
      assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
  
      // Verify that policy_unroll result is still valid.
      const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
      assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
<span class="line-modified">!         stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo), &quot;sanity&quot;);</span>
  
      if (limit-&gt;is_Con()) {
        // The check in policy_unroll and the assert above guarantee
        // no underflow if limit is constant.
        new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
<span class="line-new-header">--- 1877,12 ---</span>
      assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
  
      // Verify that policy_unroll result is still valid.
      const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
      assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
<span class="line-modified">!            stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo),</span>
<span class="line-added">+            &quot;sanity&quot;);</span>
  
      if (limit-&gt;is_Con()) {
        // The check in policy_unroll and the assert above guarantee
        // no underflow if limit is constant.
        new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1827,12 ***</span>
          // Otherwise reorg_offsets() optimization will create a separate
          // Opaque node for each use of trip-counter and as result
          // zero trip guard limit will be different from loop limit.
          assert(has_ctrl(opaq), &quot;should have it&quot;);
          Node* opaq_ctrl = get_ctrl(opaq);
<span class="line-modified">!         limit = new Opaque2Node( C, limit );</span>
<span class="line-modified">!         register_new_node( limit, opaq_ctrl );</span>
        }
        if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
            (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
          // No underflow.
          new_limit = new SubINode(limit, stride);
<span class="line-new-header">--- 1896,12 ---</span>
          // Otherwise reorg_offsets() optimization will create a separate
          // Opaque node for each use of trip-counter and as result
          // zero trip guard limit will be different from loop limit.
          assert(has_ctrl(opaq), &quot;should have it&quot;);
          Node* opaq_ctrl = get_ctrl(opaq);
<span class="line-modified">!         limit = new Opaque2Node(C, limit);</span>
<span class="line-modified">!         register_new_node(limit, opaq_ctrl);</span>
        }
        if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
            (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
          // No underflow.
          new_limit = new SubINode(limit, stride);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1869,19 ***</span>
          } else {
            old_limit = limit;
            adj_limit = new SubINode(limit, stride);
          }
          assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
<span class="line-modified">!         register_new_node( adj_limit, ctrl ); // adjust amount</span>
          Node* adj_cmp = new CmpINode(old_limit, adj_limit);
<span class="line-modified">!         register_new_node( adj_cmp, ctrl );</span>
          Node* adj_bool = new BoolNode(adj_cmp, bt);
<span class="line-modified">!         register_new_node( adj_bool, ctrl );</span>
          new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
        }
        register_new_node(new_limit, ctrl);
      }
      assert(new_limit != NULL, &quot;&quot;);
      // Replace in loop test.
      assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
      if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
        // Don&#39;t need to create new test since only one user.
<span class="line-new-header">--- 1938,20 ---</span>
          } else {
            old_limit = limit;
            adj_limit = new SubINode(limit, stride);
          }
          assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
<span class="line-modified">!         register_new_node(adj_limit, ctrl); // adjust amount</span>
          Node* adj_cmp = new CmpINode(old_limit, adj_limit);
<span class="line-modified">!         register_new_node(adj_cmp, ctrl);</span>
          Node* adj_bool = new BoolNode(adj_cmp, bt);
<span class="line-modified">!         register_new_node(adj_bool, ctrl);</span>
          new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
        }
        register_new_node(new_limit, ctrl);
      }
<span class="line-added">+ </span>
      assert(new_limit != NULL, &quot;&quot;);
      // Replace in loop test.
      assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
      if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
        // Don&#39;t need to create new test since only one user.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1927,44 ***</span>
  
    // Make backedges of the clone equal to backedges of the original.
    // Make the fall-in from the original come from the fall-out of the clone.
    for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
      Node* phi = loop_head-&gt;fast_out(j);
<span class="line-modified">!     if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0 ) {</span>
        Node *newphi = old_new[phi-&gt;_idx];
<span class="line-modified">!       _igvn.hash_delete( phi );</span>
<span class="line-modified">!       _igvn.hash_delete( newphi );</span>
  
        phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
        newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
        phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
      }
    }
    Node *clone_head = old_new[loop_head-&gt;_idx];
<span class="line-modified">!   _igvn.hash_delete( clone_head );</span>
    loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
    clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
    loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
    loop-&gt;_head = clone_head;     // New loop header
  
    set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
    set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
  
    // Kill the clone&#39;s backedge
    Node *newcle = old_new[loop_end-&gt;_idx];
<span class="line-modified">!   _igvn.hash_delete( newcle );</span>
    Node *one = _igvn.intcon(1);
    set_ctrl(one, C-&gt;root());
    newcle-&gt;set_req(1, one);
    // Force clone into same loop body
    uint max = loop-&gt;_body.size();
<span class="line-modified">!   for( uint k = 0; k &lt; max; k++ ) {</span>
      Node *old = loop-&gt;_body.at(k);
      Node *nnn = old_new[old-&gt;_idx];
      loop-&gt;_body.push(nnn);
<span class="line-modified">!     if (!has_ctrl(old))</span>
        set_loop(nnn, loop);
    }
  
    loop-&gt;record_for_igvn();
    loop_head-&gt;clear_strip_mined();
  
<span class="line-new-header">--- 1997,45 ---</span>
  
    // Make backedges of the clone equal to backedges of the original.
    // Make the fall-in from the original come from the fall-out of the clone.
    for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
      Node* phi = loop_head-&gt;fast_out(j);
<span class="line-modified">!     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0) {</span>
        Node *newphi = old_new[phi-&gt;_idx];
<span class="line-modified">!       _igvn.hash_delete(phi);</span>
<span class="line-modified">!       _igvn.hash_delete(newphi);</span>
  
        phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
        newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
        phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
      }
    }
    Node *clone_head = old_new[loop_head-&gt;_idx];
<span class="line-modified">!   _igvn.hash_delete(clone_head);</span>
    loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
    clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
    loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
    loop-&gt;_head = clone_head;     // New loop header
  
    set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
    set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
  
    // Kill the clone&#39;s backedge
    Node *newcle = old_new[loop_end-&gt;_idx];
<span class="line-modified">!   _igvn.hash_delete(newcle);</span>
    Node *one = _igvn.intcon(1);
    set_ctrl(one, C-&gt;root());
    newcle-&gt;set_req(1, one);
    // Force clone into same loop body
    uint max = loop-&gt;_body.size();
<span class="line-modified">!   for (uint k = 0; k &lt; max; k++) {</span>
      Node *old = loop-&gt;_body.at(k);
      Node *nnn = old_new[old-&gt;_idx];
      loop-&gt;_body.push(nnn);
<span class="line-modified">!     if (!has_ctrl(old)) {</span>
        set_loop(nnn, loop);
<span class="line-added">+     }</span>
    }
  
    loop-&gt;record_for_igvn();
    loop_head-&gt;clear_strip_mined();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1972,11 ***</span>
    if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
      tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
      for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
        loop-&gt;_body.at(i)-&gt;dump();
      }
<span class="line-modified">!     if(C-&gt;clone_map().is_debug()) {</span>
        tty-&gt;print(&quot;\nCloneMap\n&quot;);
        Dict* dict = C-&gt;clone_map().dict();
        DictI i(dict);
        tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
        for (int ii = 0; i.test(); ++i, ++ii) {
<span class="line-new-header">--- 2043,11 ---</span>
    if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
      tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
      for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
        loop-&gt;_body.at(i)-&gt;dump();
      }
<span class="line-modified">!     if (C-&gt;clone_map().is_debug()) {</span>
        tty-&gt;print(&quot;\nCloneMap\n&quot;);
        Dict* dict = C-&gt;clone_map().dict();
        DictI i(dict);
        tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
        for (int ii = 0; i.test(); ++i, ++ii) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1988,16 ***</span>
        }
        tty-&gt;print_cr(&quot; &quot;);
      }
    }
  #endif
<span class="line-removed">- </span>
  }
  
  //------------------------------do_maximally_unroll----------------------------
  
<span class="line-modified">! void PhaseIdealLoop::do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
    assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
    assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
  #ifndef PRODUCT
    if (TraceLoopOpts) {
<span class="line-new-header">--- 2059,15 ---</span>
        }
        tty-&gt;print_cr(&quot; &quot;);
      }
    }
  #endif
  }
  
  //------------------------------do_maximally_unroll----------------------------
  
<span class="line-modified">! void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
    assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
    assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
  #ifndef PRODUCT
    if (TraceLoopOpts) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2111,11 ***</span>
  //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
  // always holds true.  That is, either increase the number of iterations in
  // the pre-loop or the post-loop until the condition holds true in the main
  // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
  // stride and scale are constants (offset and limit often are).
<span class="line-modified">! void PhaseIdealLoop::add_constraint( int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit ) {</span>
    // For positive stride, the pre-loop limit always uses a MAX function
    // and the main loop a MIN function.  For negative stride these are
    // reversed.
  
    // Also for positive stride*scale the affine function is increasing, so the
<span class="line-new-header">--- 2181,11 ---</span>
  //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
  // always holds true.  That is, either increase the number of iterations in
  // the pre-loop or the post-loop until the condition holds true in the main
  // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
  // stride and scale are constants (offset and limit often are).
<span class="line-modified">! void PhaseIdealLoop::add_constraint(int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit) {</span>
    // For positive stride, the pre-loop limit always uses a MAX function
    // and the main loop a MIN function.  For negative stride these are
    // reversed.
  
    // Also for positive stride*scale the affine function is increasing, so the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2196,11 ***</span>
      // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
      Node *one  = _igvn.intcon(1);
      set_ctrl(one, C-&gt;root());
  
      Node *plus_one = new AddINode(offset, one);
<span class="line-modified">!     register_new_node( plus_one, pre_ctrl );</span>
      // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
      *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
                                scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
  
      if (low_limit-&gt;get_int() == -max_jint) {
<span class="line-new-header">--- 2266,11 ---</span>
      // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
      Node *one  = _igvn.intcon(1);
      set_ctrl(one, C-&gt;root());
  
      Node *plus_one = new AddINode(offset, one);
<span class="line-modified">!     register_new_node(plus_one, pre_ctrl);</span>
      // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
      *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
                                scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
  
      if (low_limit-&gt;get_int() == -max_jint) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2357,37 ***</span>
    register_control(iffalse, _ltree_root, new_iff);
    ProjNode* iftrue = new IfTrueNode(new_iff);
    register_control(iftrue, loop-&gt;_parent, new_iff);
    Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
    register_new_node(frame, C-&gt;start());
<span class="line-modified">!   Node* halt = new HaltNode(iffalse, frame);</span>
    register_control(halt, _ltree_root, iffalse);
    C-&gt;root()-&gt;add_req(halt);
    return iftrue;
  }
  
  //------------------------------do_range_check---------------------------------
  // Eliminate range-checks and other trip-counter vs loop-invariant tests.
<span class="line-modified">! int PhaseIdealLoop::do_range_check( IdealLoopTree *loop, Node_List &amp;old_new ) {</span>
  #ifndef PRODUCT
    if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
      tty-&gt;print(&quot;Range Check Elimination &quot;);
      loop-&gt;dump_head();
    } else if (TraceLoopOpts) {
      tty-&gt;print(&quot;RangeCheck   &quot;);
      loop-&gt;dump_head();
    }
  #endif
    assert(RangeCheckElimination, &quot;&quot;);
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
    // If we fail before trying to eliminate range checks, set multiversion state
    int closed_range_checks = 1;
  
    // protect against stride not being a constant
<span class="line-modified">!   if (!cl-&gt;stride_is_con())</span>
      return closed_range_checks;
<span class="line-modified">! </span>
    // Find the trip counter; we are iteration splitting based on it
    Node *trip_counter = cl-&gt;phi();
    // Find the main loop limit; we will trim it&#39;s iterations
    // to not ever trip end tests
    Node *main_limit = cl-&gt;limit();
<span class="line-new-header">--- 2427,38 ---</span>
    register_control(iffalse, _ltree_root, new_iff);
    ProjNode* iftrue = new IfTrueNode(new_iff);
    register_control(iftrue, loop-&gt;_parent, new_iff);
    Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
    register_new_node(frame, C-&gt;start());
<span class="line-modified">!   Node* halt = new HaltNode(iffalse, frame, &quot;range check predicate failed which is impossible&quot;);</span>
    register_control(halt, _ltree_root, iffalse);
    C-&gt;root()-&gt;add_req(halt);
    return iftrue;
  }
  
  //------------------------------do_range_check---------------------------------
  // Eliminate range-checks and other trip-counter vs loop-invariant tests.
<span class="line-modified">! int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &amp;old_new) {</span>
  #ifndef PRODUCT
    if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
      tty-&gt;print(&quot;Range Check Elimination &quot;);
      loop-&gt;dump_head();
    } else if (TraceLoopOpts) {
      tty-&gt;print(&quot;RangeCheck   &quot;);
      loop-&gt;dump_head();
    }
  #endif
<span class="line-added">+ </span>
    assert(RangeCheckElimination, &quot;&quot;);
    CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
    // If we fail before trying to eliminate range checks, set multiversion state
    int closed_range_checks = 1;
  
    // protect against stride not being a constant
<span class="line-modified">!   if (!cl-&gt;stride_is_con()) {</span>
      return closed_range_checks;
<span class="line-modified">!   }</span>
    // Find the trip counter; we are iteration splitting based on it
    Node *trip_counter = cl-&gt;phi();
    // Find the main loop limit; we will trim it&#39;s iterations
    // to not ever trip end tests
    Node *main_limit = cl-&gt;limit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2398,11 ***</span>
    if (!is_canonical_loop_entry(cl)) {
      return closed_range_checks;
    }
  
    // Need to find the main-loop zero-trip guard
<span class="line-modified">!   Node *ctrl  = cl-&gt;skip_predicates();</span>
    Node *iffm = ctrl-&gt;in(0);
    Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
    assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
  
    // Find the pre-loop limit; we will expand its iterations to
<span class="line-new-header">--- 2469,11 ---</span>
    if (!is_canonical_loop_entry(cl)) {
      return closed_range_checks;
    }
  
    // Need to find the main-loop zero-trip guard
<span class="line-modified">!   Node *ctrl = cl-&gt;skip_predicates();</span>
    Node *iffm = ctrl-&gt;in(0);
    Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
    assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
  
    // Find the pre-loop limit; we will expand its iterations to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2416,24 ***</span>
    assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
    Node *pre_opaq1 = pre_end-&gt;limit();
    // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
    // optimized away and then another round of loop opts attempted.
    // We can not optimize this particular loop in that case.
<span class="line-modified">!   if (pre_opaq1-&gt;Opcode() != Op_Opaque1)</span>
      return closed_range_checks;
    Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
    Node *pre_limit = pre_opaq-&gt;in(1);
  
    // Where do we put new limit calculations
    Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
  
    // Ensure the original loop limit is available from the
    // pre-loop Opaque1 node.
    Node *orig_limit = pre_opaq-&gt;original_loop_limit();
<span class="line-modified">!   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP)</span>
      return closed_range_checks;
<span class="line-modified">! </span>
    // Must know if its a count-up or count-down loop
  
    int stride_con = cl-&gt;stride_con();
    Node *zero = _igvn.intcon(0);
    Node *one  = _igvn.intcon(1);
<span class="line-new-header">--- 2487,25 ---</span>
    assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
    Node *pre_opaq1 = pre_end-&gt;limit();
    // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
    // optimized away and then another round of loop opts attempted.
    // We can not optimize this particular loop in that case.
<span class="line-modified">!   if (pre_opaq1-&gt;Opcode() != Op_Opaque1) {</span>
      return closed_range_checks;
<span class="line-added">+   }</span>
    Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
    Node *pre_limit = pre_opaq-&gt;in(1);
  
    // Where do we put new limit calculations
    Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
  
    // Ensure the original loop limit is available from the
    // pre-loop Opaque1 node.
    Node *orig_limit = pre_opaq-&gt;original_loop_limit();
<span class="line-modified">!   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {</span>
      return closed_range_checks;
<span class="line-modified">!   }</span>
    // Must know if its a count-up or count-down loop
  
    int stride_con = cl-&gt;stride_con();
    Node *zero = _igvn.intcon(0);
    Node *one  = _igvn.intcon(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2455,48 ***</span>
    // the loop is in canonical form to multiversion.
    closed_range_checks = 0;
  
    Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
    assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
    // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
<span class="line-modified">!   for( uint i = 0; i &lt; loop-&gt;_body.size(); i++ ) {</span>
      Node *iff = loop-&gt;_body[i];
      if (iff-&gt;Opcode() == Op_If ||
          iff-&gt;Opcode() == Op_RangeCheck) { // Test?
        // Test is an IfNode, has 2 projections.  If BOTH are in the loop
        // we need loop unswitching instead of iteration splitting.
        closed_range_checks++;
        Node *exit = loop-&gt;is_loop_exit(iff);
<span class="line-modified">!       if( !exit ) continue;</span>
        int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
  
        // Get boolean condition to test
        Node *i1 = iff-&gt;in(1);
<span class="line-modified">!       if( !i1-&gt;is_Bool() ) continue;</span>
        BoolNode *bol = i1-&gt;as_Bool();
        BoolTest b_test = bol-&gt;_test;
        // Flip sense of test if exit condition is flipped
<span class="line-modified">!       if( flip )</span>
          b_test = b_test.negate();
<span class="line-modified">! </span>
        // Get compare
        Node *cmp = bol-&gt;in(1);
  
        // Look for trip_counter + offset vs limit
        Node *rc_exp = cmp-&gt;in(1);
        Node *limit  = cmp-&gt;in(2);
        int scale_con= 1;        // Assume trip counter not scaled
  
        Node *limit_c = get_ctrl(limit);
<span class="line-modified">!       if( loop-&gt;is_member(get_loop(limit_c) ) ) {</span>
          // Compare might have operands swapped; commute them
          b_test = b_test.commute();
          rc_exp = cmp-&gt;in(2);
          limit  = cmp-&gt;in(1);
          limit_c = get_ctrl(limit);
<span class="line-modified">!         if( loop-&gt;is_member(get_loop(limit_c) ) )</span>
            continue;             // Both inputs are loop varying; cannot RCE
        }
        // Here we know &#39;limit&#39; is loop invariant
  
        // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
        // previous round of rce), in which case, it can&#39;t be used in the
<span class="line-new-header">--- 2527,50 ---</span>
    // the loop is in canonical form to multiversion.
    closed_range_checks = 0;
  
    Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
    assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
<span class="line-added">+ </span>
    // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
<span class="line-modified">!   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {</span>
      Node *iff = loop-&gt;_body[i];
      if (iff-&gt;Opcode() == Op_If ||
          iff-&gt;Opcode() == Op_RangeCheck) { // Test?
        // Test is an IfNode, has 2 projections.  If BOTH are in the loop
        // we need loop unswitching instead of iteration splitting.
        closed_range_checks++;
        Node *exit = loop-&gt;is_loop_exit(iff);
<span class="line-modified">!       if (!exit) continue;</span>
        int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
  
        // Get boolean condition to test
        Node *i1 = iff-&gt;in(1);
<span class="line-modified">!       if (!i1-&gt;is_Bool()) continue;</span>
        BoolNode *bol = i1-&gt;as_Bool();
        BoolTest b_test = bol-&gt;_test;
        // Flip sense of test if exit condition is flipped
<span class="line-modified">!       if (flip) {</span>
          b_test = b_test.negate();
<span class="line-modified">!       }</span>
        // Get compare
        Node *cmp = bol-&gt;in(1);
  
        // Look for trip_counter + offset vs limit
        Node *rc_exp = cmp-&gt;in(1);
        Node *limit  = cmp-&gt;in(2);
        int scale_con= 1;        // Assume trip counter not scaled
  
        Node *limit_c = get_ctrl(limit);
<span class="line-modified">!       if (loop-&gt;is_member(get_loop(limit_c))) {</span>
          // Compare might have operands swapped; commute them
          b_test = b_test.commute();
          rc_exp = cmp-&gt;in(2);
          limit  = cmp-&gt;in(1);
          limit_c = get_ctrl(limit);
<span class="line-modified">!         if (loop-&gt;is_member(get_loop(limit_c))) {</span>
            continue;             // Both inputs are loop varying; cannot RCE
<span class="line-added">+         }</span>
        }
        // Here we know &#39;limit&#39; is loop invariant
  
        // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
        // previous round of rce), in which case, it can&#39;t be used in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2511,12 ***</span>
        if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
          continue;
        }
  
        Node *offset_c = get_ctrl(offset);
<span class="line-modified">!       if( loop-&gt;is_member( get_loop(offset_c) ) )</span>
          continue;               // Offset is not really loop invariant
        // Here we know &#39;offset&#39; is loop invariant.
  
        // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
        // zero trip test.
        if (is_dominator(ctrl, offset_c)) {
<span class="line-new-header">--- 2585,13 ---</span>
        if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
          continue;
        }
  
        Node *offset_c = get_ctrl(offset);
<span class="line-modified">!       if (loop-&gt;is_member(get_loop(offset_c))) {</span>
          continue;               // Offset is not really loop invariant
<span class="line-added">+       }</span>
        // Here we know &#39;offset&#39; is loop invariant.
  
        // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
        // zero trip test.
        if (is_dominator(ctrl, offset_c)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2534,14 ***</span>
        // monotonically increases by stride_con, a constant.  Both (or either)
        // stride_con and scale_con can be negative which will flip about the
        // sense of the test.
  
        // Adjust pre and main loop limits to guard the correct iteration set
<span class="line-modified">!       if( cmp-&gt;Opcode() == Op_CmpU ) {// Unsigned compare is really 2 tests</span>
<span class="line-modified">!         if( b_test._test == BoolTest::lt ) { // Range checks always use lt</span>
            // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
<span class="line-modified">!           add_constraint( stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );</span>
            // (0-offset)/scale could be outside of loop iterations range.
            conditional_rc = true;
            Node* init = cl-&gt;init_trip();
            Node* opaque_init = new Opaque1Node(C, init);
            register_new_node(opaque_init, predicate_proj);
<span class="line-new-header">--- 2609,14 ---</span>
        // monotonically increases by stride_con, a constant.  Both (or either)
        // stride_con and scale_con can be negative which will flip about the
        // sense of the test.
  
        // Adjust pre and main loop limits to guard the correct iteration set
<span class="line-modified">!       if (cmp-&gt;Opcode() == Op_CmpU) { // Unsigned compare is really 2 tests</span>
<span class="line-modified">!         if (b_test._test == BoolTest::lt) { // Range checks always use lt</span>
            // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
<span class="line-modified">!           add_constraint(stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
            // (0-offset)/scale could be outside of loop iterations range.
            conditional_rc = true;
            Node* init = cl-&gt;init_trip();
            Node* opaque_init = new Opaque1Node(C, init);
            register_new_node(opaque_init, predicate_proj);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2564,33 ***</span>
              tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
            }
            continue;             // In release mode, ignore it
          }
        } else {                  // Otherwise work on normal compares
<span class="line-modified">!         switch( b_test._test ) {</span>
          case BoolTest::gt:
            // Fall into GE case
          case BoolTest::ge:
            // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
            scale_con = -scale_con;
<span class="line-modified">!           offset = new SubINode( zero, offset );</span>
<span class="line-modified">!           register_new_node( offset, pre_ctrl );</span>
<span class="line-modified">!           limit  = new SubINode( zero, limit );</span>
<span class="line-modified">!           register_new_node( limit, pre_ctrl );</span>
            // Fall into LE case
          case BoolTest::le:
            if (b_test._test != BoolTest::gt) {
              // Convert X &lt;= Y to X &lt; Y+1
<span class="line-modified">!             limit = new AddINode( limit, one );</span>
<span class="line-modified">!             register_new_node( limit, pre_ctrl );</span>
            }
            // Fall into LT case
          case BoolTest::lt:
            // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
            // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
            // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
<span class="line-modified">!           add_constraint( stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit );</span>
            // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
            // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
            // still be outside of loop range.
            conditional_rc = true;
            break;
<span class="line-new-header">--- 2639,33 ---</span>
              tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
            }
            continue;             // In release mode, ignore it
          }
        } else {                  // Otherwise work on normal compares
<span class="line-modified">!         switch(b_test._test) {</span>
          case BoolTest::gt:
            // Fall into GE case
          case BoolTest::ge:
            // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
            scale_con = -scale_con;
<span class="line-modified">!           offset = new SubINode(zero, offset);</span>
<span class="line-modified">!           register_new_node(offset, pre_ctrl);</span>
<span class="line-modified">!           limit  = new SubINode(zero, limit);</span>
<span class="line-modified">!           register_new_node(limit, pre_ctrl);</span>
            // Fall into LE case
          case BoolTest::le:
            if (b_test._test != BoolTest::gt) {
              // Convert X &lt;= Y to X &lt; Y+1
<span class="line-modified">!             limit = new AddINode(limit, one);</span>
<span class="line-modified">!             register_new_node(limit, pre_ctrl);</span>
            }
            // Fall into LT case
          case BoolTest::lt:
            // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
            // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
            // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
<span class="line-modified">!           add_constraint(stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);</span>
            // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
            // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
            // still be outside of loop range.
            conditional_rc = true;
            break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2602,11 ***</span>
          }
        }
  
        // Kill the eliminated test
        C-&gt;set_major_progress();
<span class="line-modified">!       Node *kill_con = _igvn.intcon( 1-flip );</span>
        set_ctrl(kill_con, C-&gt;root());
        _igvn.replace_input_of(iff, 1, kill_con);
        // Find surviving projection
        assert(iff-&gt;is_If(), &quot;&quot;);
        ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
<span class="line-new-header">--- 2677,11 ---</span>
          }
        }
  
        // Kill the eliminated test
        C-&gt;set_major_progress();
<span class="line-modified">!       Node *kill_con = _igvn.intcon(1-flip);</span>
        set_ctrl(kill_con, C-&gt;root());
        _igvn.replace_input_of(iff, 1, kill_con);
        // Find surviving projection
        assert(iff-&gt;is_If(), &quot;&quot;);
        ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2622,13 ***</span>
          }
        }
        if (limit-&gt;Opcode() == Op_LoadRange) {
          closed_range_checks--;
        }
<span class="line-removed">- </span>
      } // End of is IF
<span class="line-removed">- </span>
    }
    if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
      _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
      set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
    }
<span class="line-new-header">--- 2697,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2645,25 ***</span>
    // need to round up based on stride.
    cl-&gt;set_nonexact_trip_count();
    Node *main_cle = cl-&gt;loopexit();
    Node *main_bol = main_cle-&gt;in(1);
    // Hacking loop bounds; need private copies of exit test
<span class="line-modified">!   if( main_bol-&gt;outcnt() &gt; 1 ) {// BoolNode shared?</span>
<span class="line-modified">!     main_bol = main_bol-&gt;clone();// Clone a private BoolNode</span>
<span class="line-modified">!     register_new_node( main_bol, main_cle-&gt;in(0) );</span>
      _igvn.replace_input_of(main_cle, 1, main_bol);
    }
    Node *main_cmp = main_bol-&gt;in(1);
<span class="line-modified">!   if( main_cmp-&gt;outcnt() &gt; 1 ) { // CmpNode shared?</span>
<span class="line-modified">!     main_cmp = main_cmp-&gt;clone();// Clone a private CmpNode</span>
<span class="line-modified">!     register_new_node( main_cmp, main_cle-&gt;in(0) );</span>
      _igvn.replace_input_of(main_bol, 1, main_cmp);
    }
    // Hack the now-private loop bounds
    _igvn.replace_input_of(main_cmp, 2, main_limit);
    // The OpaqueNode is unshared by design
<span class="line-modified">!   assert( opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot; );</span>
    _igvn.replace_input_of(opqzm, 1, main_limit);
  
    return closed_range_checks;
  }
  
<span class="line-new-header">--- 2718,25 ---</span>
    // need to round up based on stride.
    cl-&gt;set_nonexact_trip_count();
    Node *main_cle = cl-&gt;loopexit();
    Node *main_bol = main_cle-&gt;in(1);
    // Hacking loop bounds; need private copies of exit test
<span class="line-modified">!   if (main_bol-&gt;outcnt() &gt; 1) {     // BoolNode shared?</span>
<span class="line-modified">!     main_bol = main_bol-&gt;clone();   // Clone a private BoolNode</span>
<span class="line-modified">!     register_new_node(main_bol, main_cle-&gt;in(0));</span>
      _igvn.replace_input_of(main_cle, 1, main_bol);
    }
    Node *main_cmp = main_bol-&gt;in(1);
<span class="line-modified">!   if (main_cmp-&gt;outcnt() &gt; 1) {     // CmpNode shared?</span>
<span class="line-modified">!     main_cmp = main_cmp-&gt;clone();   // Clone a private CmpNode</span>
<span class="line-modified">!     register_new_node(main_cmp, main_cle-&gt;in(0));</span>
      _igvn.replace_input_of(main_bol, 1, main_cmp);
    }
    // Hack the now-private loop bounds
    _igvn.replace_input_of(main_cmp, 2, main_limit);
    // The OpaqueNode is unshared by design
<span class="line-modified">!   assert(opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot;);</span>
    _igvn.replace_input_of(opqzm, 1, main_limit);
  
    return closed_range_checks;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,68 ***</span>
  }
  
  //------------------------------DCE_loop_body----------------------------------
  // Remove simplistic dead code from loop body
  void IdealLoopTree::DCE_loop_body() {
<span class="line-modified">!   for( uint i = 0; i &lt; _body.size(); i++ )</span>
<span class="line-modified">!     if( _body.at(i)-&gt;outcnt() == 0 )</span>
<span class="line-modified">!       _body.map( i--, _body.pop() );</span>
  }
  
  
  //------------------------------adjust_loop_exit_prob--------------------------
  // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
  // Replace with a 1-in-10 exit guess.
<span class="line-modified">! void IdealLoopTree::adjust_loop_exit_prob( PhaseIdealLoop *phase ) {</span>
    Node *test = tail();
<span class="line-modified">!   while( test != _head ) {</span>
      uint top = test-&gt;Opcode();
<span class="line-modified">!     if( top == Op_IfTrue || top == Op_IfFalse ) {</span>
        int test_con = ((ProjNode*)test)-&gt;_con;
        assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
        IfNode *iff = test-&gt;in(0)-&gt;as_If();
<span class="line-modified">!       if( iff-&gt;outcnt() == 2 ) {        // Ignore dead tests</span>
          Node *bol = iff-&gt;in(1);
<span class="line-modified">!         if( bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;</span>
<span class="line-modified">!             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP ) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN )))</span>
            return;               // Allocation loops RARELY take backedge
          // Find the OTHER exit path from the IF
          Node* ex = iff-&gt;proj_out(1-test_con);
          float p = iff-&gt;_prob;
<span class="line-modified">!         if( !phase-&gt;is_member( this, ex ) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN ) {</span>
<span class="line-modified">!           if( top == Op_IfTrue ) {</span>
<span class="line-modified">!             if( p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {</span>
                iff-&gt;_prob = PROB_STATIC_FREQUENT;
              }
            } else {
<span class="line-modified">!             if( p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {</span>
                iff-&gt;_prob = PROB_STATIC_INFREQUENT;
              }
            }
          }
        }
<span class="line-new-header">--- 2901,71 ---</span>
  }
  
  //------------------------------DCE_loop_body----------------------------------
  // Remove simplistic dead code from loop body
  void IdealLoopTree::DCE_loop_body() {
<span class="line-modified">!   for (uint i = 0; i &lt; _body.size(); i++) {</span>
<span class="line-modified">!     if (_body.at(i)-&gt;outcnt() == 0) {</span>
<span class="line-modified">!       _body.map(i, _body.pop());</span>
<span class="line-added">+       i--; // Ensure we revisit the updated index.</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  }
  
  
  //------------------------------adjust_loop_exit_prob--------------------------
  // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
  // Replace with a 1-in-10 exit guess.
<span class="line-modified">! void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {</span>
    Node *test = tail();
<span class="line-modified">!   while (test != _head) {</span>
      uint top = test-&gt;Opcode();
<span class="line-modified">!     if (top == Op_IfTrue || top == Op_IfFalse) {</span>
        int test_con = ((ProjNode*)test)-&gt;_con;
        assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
        IfNode *iff = test-&gt;in(0)-&gt;as_If();
<span class="line-modified">!       if (iff-&gt;outcnt() == 2) {         // Ignore dead tests</span>
          Node *bol = iff-&gt;in(1);
<span class="line-modified">!         if (bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;</span>
<span class="line-modified">!             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP) ||</span>
<span class="line-modified">!              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN)))</span>
            return;               // Allocation loops RARELY take backedge
          // Find the OTHER exit path from the IF
          Node* ex = iff-&gt;proj_out(1-test_con);
          float p = iff-&gt;_prob;
<span class="line-modified">!         if (!phase-&gt;is_member(this, ex) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN) {</span>
<span class="line-modified">!           if (top == Op_IfTrue) {</span>
<span class="line-modified">!             if (p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {</span>
                iff-&gt;_prob = PROB_STATIC_FREQUENT;
              }
            } else {
<span class="line-modified">!             if (p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {</span>
                iff-&gt;_prob = PROB_STATIC_INFREQUENT;
              }
            }
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2897,20 ***</span>
      test = phase-&gt;idom(test);
    }
  }
  
  #ifdef ASSERT
<span class="line-modified">! static CountedLoopNode* locate_pre_from_main(CountedLoopNode *cl) {</span>
<span class="line-modified">!   Node *ctrl  = cl-&gt;skip_predicates();</span>
    assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">!   Node *iffm = ctrl-&gt;in(0);</span>
    assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
<span class="line-modified">!   Node *p_f = iffm-&gt;in(0);</span>
    assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">!   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();</span>
<span class="line-modified">!   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);</span>
<span class="line-modified">!   return pre_end-&gt;loopnode();</span>
  }
  #endif
  
  // Remove the main and post loops and make the pre loop execute all
  // iterations. Useful when the pre loop is found empty.
<span class="line-new-header">--- 2973,21 ---</span>
      test = phase-&gt;idom(test);
    }
  }
  
  #ifdef ASSERT
<span class="line-modified">! static CountedLoopNode* locate_pre_from_main(CountedLoopNode* main_loop) {</span>
<span class="line-modified">!   assert(!main_loop-&gt;is_main_no_pre_loop(), &quot;Does not have a pre loop&quot;);</span>
<span class="line-added">+   Node* ctrl = main_loop-&gt;skip_predicates();</span>
    assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">!   Node* iffm = ctrl-&gt;in(0);</span>
    assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
<span class="line-modified">!   Node* p_f = iffm-&gt;in(0);</span>
    assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
<span class="line-modified">!   CountedLoopNode* pre_loop = p_f-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">!   assert(pre_loop-&gt;is_pre_loop(), &quot;No pre loop found&quot;);</span>
<span class="line-modified">!   return pre_loop;</span>
  }
  #endif
  
  // Remove the main and post loops and make the pre loop execute all
  // iterations. Useful when the pre loop is found empty.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2932,11 ***</span>
    if (!next_head-&gt;is_CountedLoop()) {
      return;
    }
  
    CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
<span class="line-modified">!   if (!main_head-&gt;is_main_loop()) {</span>
      return;
    }
  
    assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
    Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
<span class="line-new-header">--- 3009,11 ---</span>
    if (!next_head-&gt;is_CountedLoop()) {
      return;
    }
  
    CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
<span class="line-modified">!   if (!main_head-&gt;is_main_loop() || main_head-&gt;is_main_no_pre_loop()) {</span>
      return;
    }
  
    assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
    Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2947,44 ***</span>
    Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
    assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
    phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
  }
  
<span class="line-modified">! //------------------------------policy_do_remove_empty_loop--------------------</span>
<span class="line-modified">! // Micro-benchmark spamming.  Policy is to always remove empty loops.</span>
<span class="line-modified">! // The &#39;DO&#39; part is to replace the trip counter with the value it will</span>
<span class="line-modified">! // have on the last iteration.  This will break the loop.</span>
<span class="line-modified">! bool IdealLoopTree::policy_do_remove_empty_loop( PhaseIdealLoop *phase ) {</span>
    // Minimum size must be empty loop
<span class="line-modified">!   if (_body.size() &gt; EMPTY_LOOP_SIZE)</span>
      return false;
<span class="line-modified">! </span>
<span class="line-modified">!   if (!_head-&gt;is_CountedLoop())</span>
<span class="line-modified">!     return false;     // Dead loop</span>
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop())</span>
<span class="line-modified">!     return false; // Malformed loop</span>
<span class="line-modified">!   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))</span>
<span class="line-modified">!     return false;             // Infinite loop</span>
<span class="line-modified">! </span>
    if (cl-&gt;is_pre_loop()) {
<span class="line-modified">!     // If the loop we are removing is a pre-loop then the main and</span>
<span class="line-modified">!     // post loop can be removed as well</span>
      remove_main_post_loops(cl, phase);
    }
  
  #ifdef ASSERT
    // Ensure only one phi which is the iv.
    Node* iv = NULL;
    for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* n = cl-&gt;fast_out(i);
      if (n-&gt;Opcode() == Op_Phi) {
<span class="line-modified">!       assert(iv == NULL, &quot;Too many phis&quot; );</span>
        iv = n;
      }
    }
<span class="line-modified">!   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot; );</span>
  #endif
  
    // main and post loops have explicitly created zero trip guard
    bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
    if (needs_guard) {
<span class="line-new-header">--- 3024,46 ---</span>
    Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
    assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
    phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
  }
  
<span class="line-modified">! //------------------------------do_remove_empty_loop---------------------------</span>
<span class="line-modified">! // We always attempt remove empty loops.   The approach is to replace the trip</span>
<span class="line-modified">! // counter with the value it will have on the last iteration.  This will break</span>
<span class="line-modified">! // the loop.</span>
<span class="line-modified">! bool IdealLoopTree::do_remove_empty_loop(PhaseIdealLoop *phase) {</span>
    // Minimum size must be empty loop
<span class="line-modified">!   if (_body.size() &gt; EMPTY_LOOP_SIZE) {</span>
      return false;
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (!_head-&gt;is_CountedLoop()) {</span>
<span class="line-modified">!     return false;   // Dead loop</span>
<span class="line-added">+   }</span>
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-modified">!   if (!cl-&gt;is_valid_counted_loop()) {</span>
<span class="line-modified">!     return false;   // Malformed loop</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)))) {</span>
<span class="line-modified">!     return false;   // Infinite loop</span>
<span class="line-added">+   }</span>
    if (cl-&gt;is_pre_loop()) {
<span class="line-modified">!     // If the loop we are removing is a pre-loop then the main and post loop</span>
<span class="line-modified">!     // can be removed as well.</span>
      remove_main_post_loops(cl, phase);
    }
  
  #ifdef ASSERT
    // Ensure only one phi which is the iv.
    Node* iv = NULL;
    for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* n = cl-&gt;fast_out(i);
      if (n-&gt;Opcode() == Op_Phi) {
<span class="line-modified">!       assert(iv == NULL, &quot;Too many phis&quot;);</span>
        iv = n;
      }
    }
<span class="line-modified">!   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot;);</span>
  #endif
  
    // main and post loops have explicitly created zero trip guard
    bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
    if (needs_guard) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3049,35 ***</span>
    Node *exact_limit = phase-&gt;exact_limit(this);
    if (exact_limit != cl-&gt;limit()) {
      // We also need to replace the original limit to collapse loop exit.
      Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
      assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
      phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
      phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
    }
    // Note: the final value after increment should not overflow since
    // counted loop has limit check predicate.
<span class="line-modified">!   Node *final = new SubINode( exact_limit, cl-&gt;stride() );</span>
    phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
    phase-&gt;_igvn.replace_node(phi,final);
    phase-&gt;C-&gt;set_major_progress();
    return true;
  }
  
<span class="line-modified">! //------------------------------policy_do_one_iteration_loop-------------------</span>
  // Convert one iteration loop into normal code.
<span class="line-modified">! bool IdealLoopTree::policy_do_one_iteration_loop( PhaseIdealLoop *phase ) {</span>
<span class="line-modified">!   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop())</span>
      return false; // Only for counted loop
<span class="line-modified">! </span>
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
    if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
      return false;
    }
  
  #ifndef PRODUCT
<span class="line-modified">!   if(TraceLoopOpts) {</span>
      tty-&gt;print(&quot;OneIteration &quot;);
      this-&gt;dump_head();
    }
  #endif
  
<span class="line-new-header">--- 3128,42 ---</span>
    Node *exact_limit = phase-&gt;exact_limit(this);
    if (exact_limit != cl-&gt;limit()) {
      // We also need to replace the original limit to collapse loop exit.
      Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
      assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
<span class="line-added">+     // Duplicate cmp node if it has other users</span>
<span class="line-added">+     if (cmp-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">+       cmp = cmp-&gt;clone();</span>
<span class="line-added">+       cmp = phase-&gt;_igvn.register_new_node_with_optimizer(cmp);</span>
<span class="line-added">+       BoolNode *bol = cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();</span>
<span class="line-added">+       phase-&gt;_igvn.replace_input_of(bol, 1, cmp); // put bol on worklist</span>
<span class="line-added">+     }</span>
      phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
      phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
    }
    // Note: the final value after increment should not overflow since
    // counted loop has limit check predicate.
<span class="line-modified">!   Node *final = new SubINode(exact_limit, cl-&gt;stride());</span>
    phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
    phase-&gt;_igvn.replace_node(phi,final);
    phase-&gt;C-&gt;set_major_progress();
    return true;
  }
  
<span class="line-modified">! //------------------------------do_one_iteration_loop--------------------------</span>
  // Convert one iteration loop into normal code.
<span class="line-modified">! bool IdealLoopTree::do_one_iteration_loop(PhaseIdealLoop *phase) {</span>
<span class="line-modified">!   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {</span>
      return false; // Only for counted loop
<span class="line-modified">!   }</span>
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
    if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
      return false;
    }
  
  #ifndef PRODUCT
<span class="line-modified">!   if (TraceLoopOpts) {</span>
      tty-&gt;print(&quot;OneIteration &quot;);
      this-&gt;dump_head();
    }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3094,37 ***</span>
    return true;
  }
  
  //=============================================================================
  //------------------------------iteration_split_impl---------------------------
<span class="line-modified">! bool IdealLoopTree::iteration_split_impl( PhaseIdealLoop *phase, Node_List &amp;old_new ) {</span>
    // Compute loop trip count if possible.
    compute_trip_count(phase);
  
    // Convert one iteration loop into normal code.
<span class="line-modified">!   if (policy_do_one_iteration_loop(phase))</span>
      return true;
<span class="line-modified">! </span>
    // Check and remove empty loops (spam micro-benchmarks)
<span class="line-modified">!   if (policy_do_remove_empty_loop(phase))</span>
      return true;  // Here we removed an empty loop
  
<span class="line-modified">!   bool should_peel = policy_peeling(phase); // Should we peel?</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool should_unswitch = policy_unswitching(phase);</span>
  
    // Non-counted loops may be peeled; exactly 1 iteration is peeled.
    // This removes loop-invariant tests (usually null checks).
    if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
      if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
        // Partial peel succeeded so terminate this round of loop opts
        return false;
      }
<span class="line-modified">!     if (should_peel) {            // Should we peel?</span>
        if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
<span class="line-modified">!       phase-&gt;do_peeling(this,old_new);</span>
<span class="line-modified">!     } else if (should_unswitch) {</span>
        phase-&gt;do_unswitching(this, old_new);
      }
      return true;
    }
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
<span class="line-new-header">--- 3180,36 ---</span>
    return true;
  }
  
  //=============================================================================
  //------------------------------iteration_split_impl---------------------------
<span class="line-modified">! bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &amp;old_new) {</span>
    // Compute loop trip count if possible.
    compute_trip_count(phase);
  
    // Convert one iteration loop into normal code.
<span class="line-modified">!   if (do_one_iteration_loop(phase)) {</span>
      return true;
<span class="line-modified">!   }</span>
    // Check and remove empty loops (spam micro-benchmarks)
<span class="line-modified">!   if (do_remove_empty_loop(phase)) {</span>
      return true;  // Here we removed an empty loop
<span class="line-added">+   }</span>
  
<span class="line-modified">!   AutoNodeBudget node_budget(phase);</span>
  
    // Non-counted loops may be peeled; exactly 1 iteration is peeled.
    // This removes loop-invariant tests (usually null checks).
    if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
      if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
        // Partial peel succeeded so terminate this round of loop opts
        return false;
      }
<span class="line-modified">!     if (policy_peeling(phase)) {    // Should we peel?</span>
        if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
<span class="line-modified">!       phase-&gt;do_peeling(this, old_new);</span>
<span class="line-modified">!     } else if (policy_unswitching(phase)) {</span>
        phase-&gt;do_unswitching(this, old_new);
      }
      return true;
    }
    CountedLoopNode *cl = _head-&gt;as_CountedLoop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3138,29 ***</span>
    compute_profile_trip_cnt(phase);
  
    // Before attempting fancy unrolling, RCE or alignment, see if we want
    // to completely unroll this loop or do loop unswitching.
    if (cl-&gt;is_normal_loop()) {
<span class="line-modified">!     if (should_unswitch) {</span>
        phase-&gt;do_unswitching(this, old_new);
        return true;
      }
<span class="line-modified">!     bool should_maximally_unroll =  policy_maximally_unroll(phase);</span>
<span class="line-removed">-     if (should_maximally_unroll) {</span>
        // Here we did some unrolling and peeling.  Eventually we will
        // completely unroll this loop and it will no longer be a loop.
<span class="line-modified">!       phase-&gt;do_maximally_unroll(this,old_new);</span>
        return true;
      }
    }
  
<span class="line-modified">!   // Skip next optimizations if running low on nodes. Note that</span>
<span class="line-modified">!   // policy_unswitching and policy_maximally_unroll have this check.</span>
<span class="line-removed">-   int nodes_left = phase-&gt;C-&gt;max_node_limit() - phase-&gt;C-&gt;live_nodes();</span>
<span class="line-removed">-   if ((int)(2 * _body.size()) &gt; nodes_left) {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
  
    // Counted loops may be peeled, may need some iterations run up
    // front for RCE, and may want to align loop refs to a cache
    // line.  Thus we clone a full loop up front whose trip count is
    // at least 1 (if peeling), but may be several more.
<span class="line-new-header">--- 3223,24 ---</span>
    compute_profile_trip_cnt(phase);
  
    // Before attempting fancy unrolling, RCE or alignment, see if we want
    // to completely unroll this loop or do loop unswitching.
    if (cl-&gt;is_normal_loop()) {
<span class="line-modified">!     if (policy_unswitching(phase)) {</span>
        phase-&gt;do_unswitching(this, old_new);
        return true;
      }
<span class="line-modified">!     if (policy_maximally_unroll(phase)) {</span>
        // Here we did some unrolling and peeling.  Eventually we will
        // completely unroll this loop and it will no longer be a loop.
<span class="line-modified">!       phase-&gt;do_maximally_unroll(this, old_new);</span>
        return true;
      }
    }
  
<span class="line-modified">!   uint est_peeling = estimate_peeling(phase);</span>
<span class="line-modified">!   bool should_peel = 0 &lt; est_peeling;</span>
  
    // Counted loops may be peeled, may need some iterations run up
    // front for RCE, and may want to align loop refs to a cache
    // line.  Thus we clone a full loop up front whose trip count is
    // at least 1 (if peeling), but may be several more.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3171,33 ***</span>
  
    // A post-loop will finish any odd iterations (leftover after
    // unrolling), plus any needed for RCE purposes.
  
    bool should_unroll = policy_unroll(phase);
  
<span class="line-modified">!   bool should_rce = policy_range_check(phase);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool should_align = policy_align(phase);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // If not RCE&#39;ing (iteration splitting) or Aligning, then we do not</span>
<span class="line-removed">-   // need a pre-loop.  We may still need to peel an initial iteration but</span>
<span class="line-removed">-   // we will not be needing an unknown number of pre-iterations.</span>
    //
<span class="line-modified">!   // Basically, if may_rce_align reports FALSE first time through,</span>
<span class="line-modified">!   // we will not be able to later do RCE or Aligning on this loop.</span>
    bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
  
    // If we have any of these conditions (RCE, alignment, unrolling) met, then
    // we switch to the pre-/main-/post-loop model.  This model also covers
    // peeling.
    if (should_rce || should_align || should_unroll) {
<span class="line-modified">!     if (cl-&gt;is_normal_loop())  // Convert to &#39;pre/main/post&#39; loops</span>
<span class="line-modified">!       phase-&gt;insert_pre_post_loops(this,old_new, !may_rce_align);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Adjust the pre- and main-loop limits to let the pre and post loops run</span>
<span class="line-modified">!     // with full checks, but the main-loop with no checks.  Remove said</span>
<span class="line-modified">!     // checks from the main body.</span>
      if (should_rce) {
        if (phase-&gt;do_range_check(this, old_new) != 0) {
          cl-&gt;mark_has_range_checks();
        }
      } else if (PostLoopMultiversioning) {
<span class="line-new-header">--- 3251,36 ---</span>
  
    // A post-loop will finish any odd iterations (leftover after
    // unrolling), plus any needed for RCE purposes.
  
    bool should_unroll = policy_unroll(phase);
<span class="line-added">+   bool should_rce    = policy_range_check(phase);</span>
<span class="line-added">+   // TODO: Remove align -- not used.</span>
<span class="line-added">+   bool should_align  = policy_align(phase);</span>
  
<span class="line-modified">!   // If not RCE&#39;ing  (iteration splitting) or Aligning, then we  do not need a</span>
<span class="line-modified">!   // pre-loop.  We may still need to peel an initial iteration but we will not</span>
<span class="line-modified">!   // be needing an unknown number of pre-iterations.</span>
    //
<span class="line-modified">!   // Basically, if may_rce_align reports FALSE first time through, we will not</span>
<span class="line-modified">!   // be able to later do RCE or Aligning on this loop.</span>
    bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
  
    // If we have any of these conditions (RCE, alignment, unrolling) met, then
    // we switch to the pre-/main-/post-loop model.  This model also covers
    // peeling.
    if (should_rce || should_align || should_unroll) {
<span class="line-modified">!     if (cl-&gt;is_normal_loop()) { // Convert to &#39;pre/main/post&#39; loops</span>
<span class="line-modified">!       uint estimate = est_loop_clone_sz(3);</span>
<span class="line-modified">!       if (!phase-&gt;may_require_nodes(estimate)) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       phase-&gt;insert_pre_post_loops(this, old_new, !may_rce_align);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Adjust the pre- and main-loop limits to let the pre and  post loops run</span>
<span class="line-added">+     // with full checks, but the main-loop with no checks.  Remove said checks</span>
<span class="line-added">+     // from the main body.</span>
      if (should_rce) {
        if (phase-&gt;do_range_check(this, old_new) != 0) {
          cl-&gt;mark_has_range_checks();
        }
      } else if (PostLoopMultiversioning) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3221,63 ***</span>
          phase-&gt;insert_vector_post_loop(this, old_new);
        }
        phase-&gt;do_unroll(this, old_new, true);
      }
  
<span class="line-modified">!     // Adjust the pre-loop limits to align the main body</span>
<span class="line-modified">!     // iterations.</span>
<span class="line-removed">-     if (should_align)</span>
        Unimplemented();
<span class="line-modified">! </span>
    } else {                      // Else we have an unchanged counted loop
<span class="line-modified">!     if (should_peel)           // Might want to peel but do nothing else</span>
<span class="line-modified">!       phase-&gt;do_peeling(this,old_new);</span>
    }
    return true;
  }
  
  
  //=============================================================================
  //------------------------------iteration_split--------------------------------
<span class="line-modified">! bool IdealLoopTree::iteration_split( PhaseIdealLoop *phase, Node_List &amp;old_new ) {</span>
    // Recursively iteration split nested loops
<span class="line-modified">!   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new))</span>
      return false;
  
    // Clean out prior deadwood
    DCE_loop_body();
  
<span class="line-removed">- </span>
    // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
    // Replace with a 1-in-10 exit guess.
<span class="line-modified">!   if (_parent /*not the root loop*/ &amp;&amp;</span>
<span class="line-removed">-       !_irreducible &amp;&amp;</span>
<span class="line-removed">-       // Also ignore the occasional dead backedge</span>
<span class="line-removed">-       !tail()-&gt;is_top()) {</span>
      adjust_loop_exit_prob(phase);
    }
  
<span class="line-modified">!   // Gate unrolling, RCE and peeling efforts.</span>
<span class="line-modified">!   if (!_child &amp;&amp;                // If not an inner loop, do not split</span>
<span class="line-removed">-       !_irreducible &amp;&amp;</span>
<span class="line-removed">-       _allow_optimizations &amp;&amp;</span>
<span class="line-removed">-       !tail()-&gt;is_top()) {     // Also ignore the occasional dead backedge</span>
      if (!_has_call) {
<span class="line-modified">!         if (!iteration_split_impl(phase, old_new)) {</span>
<span class="line-modified">!           return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     } else if (policy_unswitching(phase)) {</span>
<span class="line-modified">!       phase-&gt;do_unswitching(this, old_new);</span>
      }
    }
  
    // Minor offset re-organization to remove loop-fallout uses of
    // trip counter when there was no major reshaping.
    phase-&gt;reorg_offsets(this);
  
<span class="line-modified">!   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new))</span>
      return false;
    return true;
  }
  
  
  //=============================================================================
<span class="line-new-header">--- 3304,63 ---</span>
          phase-&gt;insert_vector_post_loop(this, old_new);
        }
        phase-&gt;do_unroll(this, old_new, true);
      }
  
<span class="line-modified">!     // Adjust the pre-loop limits to align the main body iterations.</span>
<span class="line-modified">!     if (should_align) {</span>
        Unimplemented();
<span class="line-modified">!     }</span>
    } else {                      // Else we have an unchanged counted loop
<span class="line-modified">!     if (should_peel) {          // Might want to peel but do nothing else</span>
<span class="line-modified">!       if (phase-&gt;may_require_nodes(est_peeling)) {</span>
<span class="line-added">+         phase-&gt;do_peeling(this, old_new);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
    }
    return true;
  }
  
  
  //=============================================================================
  //------------------------------iteration_split--------------------------------
<span class="line-modified">! bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &amp;old_new) {</span>
    // Recursively iteration split nested loops
<span class="line-modified">!   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new)) {</span>
      return false;
<span class="line-added">+   }</span>
  
    // Clean out prior deadwood
    DCE_loop_body();
  
    // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
    // Replace with a 1-in-10 exit guess.
<span class="line-modified">!   if (!is_root() &amp;&amp; is_loop()) {</span>
      adjust_loop_exit_prob(phase);
    }
  
<span class="line-modified">!   // Unrolling, RCE and peeling efforts, iff innermost loop.</span>
<span class="line-modified">!   if (_allow_optimizations &amp;&amp; is_innermost()) {</span>
      if (!_has_call) {
<span class="line-modified">!       if (!iteration_split_impl(phase, old_new)) {</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       AutoNodeBudget node_budget(phase);</span>
<span class="line-added">+       if (policy_unswitching(phase)) {</span>
<span class="line-added">+         phase-&gt;do_unswitching(this, old_new);</span>
<span class="line-added">+       }</span>
      }
    }
  
    // Minor offset re-organization to remove loop-fallout uses of
    // trip counter when there was no major reshaping.
    phase-&gt;reorg_offsets(this);
  
<span class="line-modified">!   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new)) {</span>
      return false;
<span class="line-added">+   }</span>
    return true;
  }
  
  
  //=============================================================================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3535,11 ***</span>
  
  
  
  bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
    // Only for counted inner loops
<span class="line-modified">!   if (!lpt-&gt;is_counted() || !lpt-&gt;is_inner()) {</span>
      return false;
    }
  
    // Must have constant stride
    CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
<span class="line-new-header">--- 3618,11 ---</span>
  
  
  
  bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
    // Only for counted inner loops
<span class="line-modified">!   if (!lpt-&gt;is_counted() || !lpt-&gt;is_innermost()) {</span>
      return false;
    }
  
    // Must have constant stride
    CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
</pre>
<center><a href="loopPredicate.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>